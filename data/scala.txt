TITLE: Using a Higher-Order Function with Multiple Parameters in Scala
DESCRIPTION: This example demonstrates how to use the 'executeNTimes' function by passing in a simple 'helloWorld' function and specifying the number of executions.

LANGUAGE: scala
CODE:
def helloWorld(): Unit = println("Hello, world")
executeNTimes(helloWorld, 3)

----------------------------------------

TITLE: Class Construction with Default Parameters
DESCRIPTION: Shows how to define a Point class with default parameter values and demonstrates named parameter usage when creating instances.

LANGUAGE: scala
CODE:
class Point(val x: Double = 0, val y: Double = 0)

val point1 = new Point(y = 1)

----------------------------------------

TITLE: Basic Hello World - Scala 3
DESCRIPTION: Simplified Hello World program implementation in Scala 3 using the @main annotation. Demonstrates the more concise syntax available in Scala 3.

LANGUAGE: scala
CODE:
@main def hello() = println("Hello, World!")

----------------------------------------

TITLE: Scala Class Definition
DESCRIPTION: Example of a Scala class with constructor parameters and methods.

LANGUAGE: scala
CODE:
class Person(var firstName: String, var lastName: String) {
    def printFullName() = println(s"$firstName $lastName")
}

----------------------------------------

TITLE: Reassignment Behavior of Val and Var in Scala
DESCRIPTION: These snippets illustrate the difference in reassignment behavior between val (immutable) and var (mutable) variables in Scala. Attempting to reassign a val results in a compiler error.

LANGUAGE: scala
CODE:
val msg = "Hello, world"
msg = "Aloha"   // "reassignment to val" error; this won't compile

LANGUAGE: scala
CODE:
var msg = "Hello, world"
msg = "Aloha"   // this compiles because a var can be reassigned

----------------------------------------

TITLE: Implementing Enumerations with Case Objects
DESCRIPTION: Example of creating type-safe enumerations using sealed traits and case objects for pizza toppings, crust sizes, and types.

LANGUAGE: scala
CODE:
sealed trait Topping
case object Cheese extends Topping
case object Pepperoni extends Topping
case object Sausage extends Topping
case object Mushrooms extends Topping
case object Onions extends Topping

sealed trait CrustSize
case object SmallCrustSize extends CrustSize
case object MediumCrustSize extends CrustSize
case object LargeCrustSize extends CrustSize

sealed trait CrustType
case object RegularCrustType extends CrustType
case object ThinCrustType extends CrustType
case object ThickCrustType extends CrustType

----------------------------------------

TITLE: Defining a Higher-Order Function with Complex Parameter Types in Scala
DESCRIPTION: This snippet shows how to create a higher-order function 'executeAndPrint' that takes a function of type (Int, Int) => Int along with two integer parameters.

LANGUAGE: scala
CODE:
def executeAndPrint(f: (Int, Int) => Int, i: Int, j: Int): Unit =
  println(f(i, j))

----------------------------------------

TITLE: Creating Pizza Instances Using Multiple Constructors in Scala
DESCRIPTION: This snippet shows how to create Pizza instances using the various constructors defined in the Pizza class. It demonstrates the flexibility provided by auxiliary constructors.

LANGUAGE: scala
CODE:
val p1 = new Pizza(DefaultCrustSize, DefaultCrustType)
val p2 = new Pizza(DefaultCrustSize)
val p3 = new Pizza(DefaultCrustType)
val p4 = new Pizza

----------------------------------------

TITLE: Using Case Classes in Pattern Matching with Scala
DESCRIPTION: This snippet shows how to use case classes in pattern matching. It defines a trait 'Person' and two case classes 'Student' and 'Teacher' that extend it. Then it demonstrates how to use these in a match expression.

LANGUAGE: scala
CODE:
trait Person {
    def name: String
}

case class Student(name: String, year: Int) extends Person
case class Teacher(name: String, specialty: String) extends Person

def getPrintableString(p: Person): String = p match {
    case Student(name, year) =>
        s"$name is a student in Year $year."
    case Teacher(name, whatTheyTeach) =>
        s"$name teaches $whatTheyTeach."
}

val s = Student("Al", 1)
val t = Teacher("Bob Donnan", "Mathematics")

println(getPrintableString(s))
println(getPrintableString(t))

----------------------------------------

TITLE: Defining Case Classes for Domain Objects
DESCRIPTION: Shows how to model compound data using case classes for pizza orders and customer information.

LANGUAGE: scala
CODE:
case class Pizza(
  crustSize: CrustSize,
  crustType: CrustType,
  toppings: Seq[Topping]
)

case class Address(
  street1: String,
  street2: Option[String],
  city: String,
  state: String,
  zipCode: String
)

case class Customer(
  name: String,
  phone: String,
  address: Address
)

case class Order(
  pizzas: Seq[Pizza],
  customer: Customer
)

----------------------------------------

TITLE: Methods with Inferred Return Types in Scala
DESCRIPTION: This snippet demonstrates the same 'sum' and 'concatenate' methods without explicitly declaring their return types. Scala can infer the return types based on the method body.

LANGUAGE: scala
CODE:
def sum(a: Int, b: Int) = a + b
def concatenate(s1: String, s2: String) = s1 + s2

----------------------------------------

TITLE: Defining a Generic Trait with Abstract Methods in Scala
DESCRIPTION: Shows how to define a trait with a generic type parameter and abstract methods, which becomes useful for implementing iterators.

LANGUAGE: scala
CODE:
trait Iterator[A] {
  def hasNext: Boolean
  def next(): A
}

LANGUAGE: scala
CODE:
trait Iterator[A]:
  def hasNext: Boolean
  def next(): A

----------------------------------------

TITLE: Function-Accepting Higher-Order Function in Scala
DESCRIPTION: Shows how to create a higher-order function that accepts a function parameter to reduce code duplication.

LANGUAGE: scala
CODE:
object SalaryRaiser {
  private def promotion(salaries: List[Double], promotionFunction: Double => Double): List[Double] =
    salaries.map(promotionFunction)

  def smallPromotion(salaries: List[Double]): List[Double] =
    promotion(salaries, salary => salary * 1.1)

  def greatPromotion(salaries: List[Double]): List[Double] =
    promotion(salaries, salary => salary * math.log(salary))

  def hugePromotion(salaries: List[Double]): List[Double] =
    promotion(salaries, salary => salary * salary)
}

----------------------------------------

TITLE: Interactive Hello World - Scala 2
DESCRIPTION: Enhanced Hello World program in Scala 2 that reads user input. Demonstrates importing from standard library and string concatenation.

LANGUAGE: scala
CODE:
import scala.io.StdIn.readLine

object helloInteractive {

  def main(args: Array[String]) = {
    println("Please enter your name:")
    val name = readLine()

    println("Hello, " + name + "!")
  }

}

----------------------------------------

TITLE: Basic Class Definition
DESCRIPTION: Demonstrates the basic syntax for defining classes in Scala with constructor parameters.

LANGUAGE: scala
CODE:
class Person(var name: String, var vocation: String)
class Book(var title: String, var author: String, var year: Int)
class Movie(var name: String, var director: String, var year: Int)

----------------------------------------

TITLE: Basic Hello World - Scala 2
DESCRIPTION: Traditional Hello World program implementation in Scala 2. Creates an object with a main method that prints 'Hello, World!' to standard output.

LANGUAGE: scala
CODE:
object hello {
  def main(args: Array[String]) = {
    println("Hello, World!")
  }
}

----------------------------------------

TITLE: Declaring Values and Variables in Scala
DESCRIPTION: Shows how to declare immutable values using 'val' and mutable variables using 'var' in Scala, with optional type annotations.

LANGUAGE: scala
CODE:
val x = 1 + 1
println(x) // 2

val x: Int = 1 + 1

var x = 1 + 1
x = 3 // This compiles because "x" is declared with the "var" keyword.
println(x * x) // 9

var x: Int = 1 + 1

----------------------------------------

TITLE: Defining a Higher-Order Function in Scala
DESCRIPTION: This snippet demonstrates how to define a simple higher-order function 'sayHello' that takes a function parameter and executes it.

LANGUAGE: scala
CODE:
def sayHello(f: () => Unit): Unit = f()

----------------------------------------

TITLE: Basic Class Definition
DESCRIPTION: Demonstrates the basic syntax for defining classes in Scala with constructor parameters.

LANGUAGE: scala
CODE:
class Person(var name: String, var vocation: String)
class Book(var title: String, var author: String, var year: Int)
class Movie(var name: String, var director: String, var year: Int)

----------------------------------------

TITLE: Using Map with Lambda Functions in Scala
DESCRIPTION: Demonstrates two equivalent ways to multiply each number in a List by 2 using lambda functions with the map method. Shows both the explicit parameter version and the placeholder syntax (_).

LANGUAGE: scala
CODE:
val a = List(1, 2, 3).map(i => i * 2)   // List(2,4,6)
val b = List(1, 2, 3).map(_ * 2)        // List(2,4,6)

----------------------------------------

TITLE: Defining a Scala Method with Explicit Return Type
DESCRIPTION: This example demonstrates how to explicitly declare the return type of a Scala method. It shows the same 'double' method with the return type Int specified.

LANGUAGE: scala
CODE:
def double(a: Int): Int = a * 2

----------------------------------------

TITLE: Using map with Function Parameters in Scala
DESCRIPTION: Demonstrates using the map higher-order function with a separate function definition to transform a sequence of salaries.

LANGUAGE: scala
CODE:
val salaries = Seq(20_000, 70_000, 40_000)
val doubleSalary = (x: Int) => x * 2
val newSalaries = salaries.map(doubleSalary) // List(40000, 140000, 80000)

----------------------------------------

TITLE: Simple Method Examples in Scala
DESCRIPTION: These examples show two simple methods: 'sum' for adding two integers and 'concatenate' for joining two strings. Both methods explicitly declare their return types.

LANGUAGE: scala
CODE:
def sum(a: Int, b: Int): Int = a + b
def concatenate(s1: String, s2: String): String = s1 + s2

----------------------------------------

TITLE: Working with Case Classes in Scala
DESCRIPTION: Demonstrates how to define and use case classes in Scala, including instantiation and value comparison.

LANGUAGE: scala
CODE:
case class Point(x: Int, y: Int)

val point = Point(1, 2)
val anotherPoint = Point(1, 2)
val yetAnotherPoint = Point(2, 2)

if (point == anotherPoint) {
  println(s"$point and $anotherPoint are the same.")
} else {
  println(s"$point and $anotherPoint are different.")
} // Point(1,2) and Point(1,2) are the same.

if (point == yetAnotherPoint) {
  println(s"$point and $yetAnotherPoint are the same.")
} else {
  println(s"$point and $yetAnotherPoint are different.")
} // Point(1,2) and Point(2,2) are different.

----------------------------------------

TITLE: Interactive Hello World - Scala 3
DESCRIPTION: Enhanced Hello World program in Scala 3 that reads user input. Shows the more concise syntax while maintaining the same functionality as Scala 2 version.

LANGUAGE: scala
CODE:
import scala.io.StdIn.readLine

@main def helloInteractive() =
  println("Please enter your name:")
  val name = readLine()

  println("Hello, " + name + "!")

----------------------------------------

TITLE: Type-Based Pattern Matching in Scala
DESCRIPTION: Shows how to match on types in Scala. It defines a sealed trait Device with two case class implementations, then matches on these types to call type-specific methods.

LANGUAGE: scala
CODE:
sealed trait Device
case class Phone(model: String) extends Device:
  def screenOff = "Turning screen off"

case class Computer(model: String) extends Device:
  def screenSaverOn = "Turning screen saver on..."


def goIdle(device: Device): String = device match
  case p: Phone => p.screenOff
  case c: Computer => c.screenSaverOn

----------------------------------------

TITLE: Matching on Case Classes in Scala
DESCRIPTION: Demonstrates pattern matching on case classes. It defines a sealed trait Notification with three case class implementations, then matches on these types.

LANGUAGE: scala
CODE:
sealed trait Notification

case class Email(sender: String, title: String, body: String) extends Notification

case class SMS(caller: String, message: String) extends Notification

case class VoiceRecording(contactName: String, link: String) extends Notification

def showNotification(notification: Notification): String =
  notification match
    case Email(sender, title, _) =>
      s"You got an email from $sender with title: $title"
    case SMS(number, message) =>
      s"You got an SMS from $number! Message: $message"
    case VoiceRecording(name, link) =>
      s"You received a Voice Recording from $name! Click the link to hear it: $link"

val someSms = SMS("12345", "Are you there?")
val someVoiceRecording = VoiceRecording("Tom", "voicerecording.org/id/123")

println(showNotification(someSms))
println(showNotification(someVoiceRecording))

----------------------------------------

TITLE: Defining a Minimal Scala Class
DESCRIPTION: Demonstrates how to define a basic class in Scala and create an instance of it. Shows the difference between Scala 2 and Scala 3 syntax for object instantiation.

LANGUAGE: scala
CODE:
class User

val user1 = new User

LANGUAGE: scala
CODE:
class User

val user1 = User()

----------------------------------------

TITLE: Using BigInt and BigDecimal in Scala
DESCRIPTION: This snippet demonstrates how to create and use BigInt and BigDecimal types in Scala for handling large numbers. It shows variable declaration and basic arithmetic operations.

LANGUAGE: scala
CODE:
var b = BigInt(1234567890)
var b = BigDecimal(123456.789)

LANGUAGE: scala
CODE:
scala> var b = BigInt(1234567890)
b: scala.math.BigInt = 1234567890

scala> b + b
res0: scala.math.BigInt = 2469135780

scala> b * b
res1: scala.math.BigInt = 1524157875019052100

scala> b += 1

scala> println(b)
1234567891

----------------------------------------

TITLE: Defining a Scala Class with Constructor and Methods
DESCRIPTION: Shows how to create a more complex class with constructor parameters, variables, and methods. Includes examples for both Scala 2 and Scala 3 syntax.

LANGUAGE: scala
CODE:
class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}

val point1 = new Point(2, 3)
println(point1.x)  // prints 2
println(point1)    // prints (2, 3)

LANGUAGE: scala
CODE:
class Point(var x: Int, var y: Int):

  def move(dx: Int, dy: Int): Unit =
    x = x + dx
    y = y + dy

  override def toString: String =
    s"($x, $y)"
end Point

val point1 = Point(2, 3)
println(point1.x)  // prints 2
println(point1)    // prints (2, 3)

----------------------------------------

TITLE: Using Named Arguments in Scala Class Instantiation
DESCRIPTION: Shows how to use named arguments when creating an instance of a class with default constructor values. Includes examples for Scala 2 and Scala 3.

LANGUAGE: scala
CODE:
class Point(var x: Int = 0, var y: Int = 0)
val point2 = new Point(y = 2)
println(point2)               // prints (0, 2)

LANGUAGE: scala
CODE:
class Point(var x: Int = 0, var y: Int = 0)
val point2 = Point(y = 2)
println(point2)           // prints (0, 2)

----------------------------------------

TITLE: Creating Hello World Program in Scala
DESCRIPTION: A basic Scala program that prints 'Hello, world' to the console. The code demonstrates the use of an object declaration with a main method, which is the entry point of the program.

LANGUAGE: scala
CODE:
object Hello {
    def main(args: Array[String]) = {
        println("Hello, world")
    }
}

----------------------------------------

TITLE: Defining a Scala Class with Constructor and Methods
DESCRIPTION: Shows how to create a more complex class with constructor parameters, variables, and methods. Includes examples for both Scala 2 and Scala 3 syntax.

LANGUAGE: scala
CODE:
class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}

val point1 = new Point(2, 3)
println(point1.x)  // prints 2
println(point1)    // prints (2, 3)

LANGUAGE: scala
CODE:
class Point(var x: Int, var y: Int):

  def move(dx: Int, dy: Int): Unit =
    x = x + dx
    y = y + dy

  override def toString: String =
    s"($x, $y)"
end Point

val point1 = Point(2, 3)
println(point1.x)  // prints 2
println(point1)    // prints (2, 3)

----------------------------------------

TITLE: Pattern Guards in Scala Pattern Matching
DESCRIPTION: Demonstrates the use of pattern guards, which are boolean expressions used to make cases more specific in pattern matching.

LANGUAGE: scala
CODE:
def showImportantNotification(notification: Notification, importantPeopleInfo: Seq[String]): String =
  notification match
    case Email(sender, _, _) if importantPeopleInfo.contains(sender) =>
      "You got an email from special someone!"
    case SMS(number, _) if importantPeopleInfo.contains(number) =>
      "You got an SMS from special someone!"
    case other =>
      showNotification(other) // nothing special, delegate to our original showNotification function

----------------------------------------

TITLE: Basic Pattern Matching in Scala
DESCRIPTION: Demonstrates basic pattern matching syntax using a random integer value. The match expression returns a string based on the matched case.

LANGUAGE: scala
CODE:
import scala.util.Random

val x: Int = Random.nextInt(10)

x match
  case 0 => "zero"
  case 1 => "one"
  case 2 => "two"
  case _ => "other"

----------------------------------------

TITLE: Defining and Using a Case Class in Scala
DESCRIPTION: This snippet demonstrates how to define a case class 'Person' and create an instance of it without using the 'new' keyword. It also shows that accessor methods are generated for case class parameters, but mutator methods are not.

LANGUAGE: scala
CODE:
case class Person(name: String, relation: String)

// "new" not needed before Person
val christina = Person("Christina", "niece")

// Accessor method generated
christina.name

// Mutator methods not generated
// This will cause an error:
// christina.name = "Fred"

----------------------------------------

TITLE: Creating Lists Using Cons Operator in Scala
DESCRIPTION: Shows an alternative way to create Lists in Scala using the cons (::) operator, which is similar to Lisp syntax.

LANGUAGE: scala
CODE:
val list = 1 :: 2 :: 3 :: Nil

----------------------------------------

TITLE: Defining Basic Singleton Object in Scala
DESCRIPTION: Demonstrates the basic syntax for defining a singleton object in Scala using the object keyword.

LANGUAGE: scala
CODE:
object Box

----------------------------------------

TITLE: Basic Class Definition Comparison
DESCRIPTION: Shows how to define a basic class with fields and methods in both Java and Scala

LANGUAGE: java
CODE:
class Person {
  public String firstName;
  public String lastName;
  public int age;
  public Person(String firstName, String lastName, int age) {
    this.firstName = firstName;
    this.lastName = lastName;
    this.age = age;
  }
  public String toString() {
    return String.format("%s %s is %d years old.", firstName, lastName, age);
  }
}

LANGUAGE: scala
CODE:
class Person(
  var firstName: String,
  var lastName: String,
  var age: Int
):
  override def toString = s"$firstName $lastName is $age years old."

----------------------------------------

TITLE: Creating Lists in Scala
DESCRIPTION: Demonstrates various ways to create and populate List objects in Scala, including direct initialization and using range methods.

LANGUAGE: scala
CODE:
val a = List(1, 2, 3)           // a: List[Int] = List(1, 2, 3)

// Range methods
val b = (1 to 5).toList         // b: List[Int] = List(1, 2, 3, 4, 5)
val c = (1 to 10 by 2).toList   // c: List[Int] = List(1, 3, 5, 7, 9)
val e = (1 until 5).toList      // e: List[Int] = List(1, 2, 3, 4)
val f = List.range(1, 5)        // f: List[Int] = List(1, 2, 3, 4)
val g = List.range(1, 10, 3)    // g: List[Int] = List(1, 4, 7)

----------------------------------------

TITLE: Defining a Simple Method in Scala
DESCRIPTION: This snippet demonstrates the basic syntax for defining a method in Scala. It shows the structure including method name, parameters with their types, return type, and method body.

LANGUAGE: scala
CODE:
def methodName(param1: Type1, param2: Type2): ReturnType =
  // the method body
  // goes here

----------------------------------------

TITLE: Using Named Functions with Map and Filter in Scala
DESCRIPTION: Shows how to use named functions instead of anonymous functions with map and filter methods, demonstrating the equivalence.

LANGUAGE: scala
CODE:
def double(i: Int): Int = i * 2
val doubledInts = ints.map(double)

LANGUAGE: scala
CODE:
def lessThanFive(i: Int): Boolean = (i < 5)
val y = ints.filter(lessThanFive)

----------------------------------------

TITLE: Creating and Using Immutable Scala Map
DESCRIPTION: This snippet demonstrates the creation of an immutable Map in Scala and various operations that can be performed on it, such as iteration, key/value access, containment checking, transformation, filtering, and taking elements.

LANGUAGE: scala
CODE:
val m = Map(
    1 -> "a", 
    2 -> "b", 
    3 -> "c",
    4 -> "d"
)

// how to iterate over Map elements
for ((k,v) <- m) printf("key: %s, value: %s\n", k, v)

// how to get the keys from a Map
val keys = m.keys

// how to get the values from a Map
val values = m.values

// how to test if a Map contains a key
val contains3 = m.contains(3)

// how to transform Map values
val ucMap = m.transform((k,v) => v.toUpperCase)

// how to filter a Map by its keys
val twoAndThree = m.view.filterKeys(Set(2,3)).toMap

// how to take the first two elements from a Map
val firstTwoElements = m.take(2)

----------------------------------------

TITLE: Defining a Simple Method in Scala
DESCRIPTION: This snippet demonstrates the basic syntax for defining a method in Scala. It shows the structure including method name, parameters with their types, return type, and method body.

LANGUAGE: scala
CODE:
def methodName(param1: Type1, param2: Type2): ReturnType =
  // the method body
  // goes here

----------------------------------------

TITLE: Specific Collection Implementation Examples in Scala
DESCRIPTION: Shows how to create specific collection implementations using the same uniform syntax

LANGUAGE: scala
CODE:
List(1, 2, 3)
HashMap("x" -> 24, "y" -> 25, "z" -> 26)

----------------------------------------

TITLE: Creating Basic Scala Class Constructor
DESCRIPTION: Demonstrates the basic syntax for creating a Scala class with two constructor parameters. The parameters automatically become class fields.

LANGUAGE: scala
CODE:
class Person(var firstName: String, var lastName: String)

----------------------------------------

TITLE: Case Class Parameters as Public Vals in Scala
DESCRIPTION: Shows how case class parameters are public vals by default, making them immutable. Attempts to reassign a parameter value will not compile.

LANGUAGE: scala
CODE:
case class Message(sender: String, recipient: String, body: String)
val message1 = Message("guillaume@quebec.ca", "jorge@catalonia.es", "Ça va ?")

println(message1.sender)  // prints guillaume@quebec.ca
message1.sender = "travis@washington.us"  // this line does not compile

----------------------------------------

TITLE: Method Coercion to Function in Scala
DESCRIPTION: Demonstrates how Scala coerces methods into functions when passed to higher-order functions.

LANGUAGE: scala
CODE:
case class WeeklyWeatherForecast(temperatures: Seq[Double]) {
  private def convertCtoF(temp: Double) = temp * 1.8 + 32
  def forecastInFahrenheit: Seq[Double] = temperatures.map(convertCtoF)
}

----------------------------------------

TITLE: Declaring Basic Numeric Types in Scala
DESCRIPTION: This snippet demonstrates how to declare variables of basic numeric types in Scala. It shows explicit type declarations for Byte, Int, Long, Short, Double, and Float.

LANGUAGE: scala
CODE:
val b: Byte = 1
val x: Int = 1
val l: Long = 1
val s: Short = 1
val d: Double = 2.0
val f: Float = 3.0

----------------------------------------

TITLE: Basic Function Parameters with Map and Filter in Scala
DESCRIPTION: Demonstrates using map and filter functions with anonymous functions to transform lists.

LANGUAGE: scala
CODE:
val nums = (1 to 10).toList

val doubles = nums.map(_ * 2)
val lessThanFive = nums.filter(_ < 5)

----------------------------------------

TITLE: String Operations and Conversions in Scala
DESCRIPTION: Demonstrates various string operations including reverse, map, drop, and slice, as well as implicit conversion of String to Seq[Char]. Shows how strings can be manipulated using sequence operations through implicit conversions to WrappedString and StringOps.

LANGUAGE: scala
CODE:
val str = "hello"
str: java.lang.String = hello
str.reverse
res6: String = olleh
str.map(_.toUpper)
res7: String = HELLO
str drop 3
res8: String = lo
str slice (1, 4)
res9: String = ell
val s: Seq[Char] = str
s: Seq[Char] = WrappedString(h, e, l, l, o)

----------------------------------------

TITLE: Traditional Helper Method Approach
DESCRIPTION: Shows the traditional way of adding functionality through helper objects in both Scala 2 and 3.

LANGUAGE: scala
CODE:
object CircleHelpers {
  def circumference(c: Circle): Double = c.radius * math.Pi * 2
}

LANGUAGE: scala
CODE:
object CircleHelpers:
  def circumference(c: Circle): Double = c.radius * math.Pi * 2

----------------------------------------

TITLE: Creating a Higher-Order Function with Multiple Parameters in Scala
DESCRIPTION: This snippet defines a higher-order function 'executeNTimes' that takes a function and an integer as parameters, executing the function the specified number of times.

LANGUAGE: scala
CODE:
def executeNTimes(f: () => Unit, n: Int): Unit =
  for (i <- 1 to n) f()

----------------------------------------

TITLE: Implementing toInt with Option Pattern in Scala
DESCRIPTION: Demonstrates error handling using Option/Some/None pattern to convert a string to an integer. Returns Some(int) for valid integers and None for invalid inputs.

LANGUAGE: scala
CODE:
def toInt(s: String): Option[Int] = {
    try {
        Some(Integer.parseInt(s.trim))
    } catch {
        case e: Exception => None
    }
}

----------------------------------------

TITLE: Parsing and Modifying JSON with uPickle in Scala
DESCRIPTION: This snippet demonstrates how to parse a JSON string, modify its contents, and write it back to a string using uPickle. It shows adding, modifying, and removing fields and elements from the JSON structure.

LANGUAGE: scala
CODE:
// Parse the JSON string
val json: ujson.Value = ujson.read("{\"name\":\"John\",\"pets\":[\"Toolkitty\",\"Scaniel\"]}")

// Update it
json("name") = "Peter"
json("nickname") = "Pete"
json("pets").arr.remove(1)

// Write it back to a String
val result: String = ujson.write(json)
println(result)
// prints: {"name":"Peter","pets":["Toolkitty"],"nickname":"Pete"}

----------------------------------------

TITLE: Common List Operations in Scala
DESCRIPTION: Illustrates various functional methods available on Scala List objects, such as drop, filter, slice, and map. These methods return new collections without mutating the original.

LANGUAGE: scala
CODE:
// a sample list
val a = List(10, 20, 30, 40, 10)      // List(10, 20, 30, 40, 10)

a.drop(2)                             // List(30, 40, 10)
a.dropWhile(_ < 25)                   // List(30, 40, 10)
a.filter(_ < 25)                      // List(10, 20, 10)
a.slice(2,4)                          // List(30, 40)
a.tail                                // List(20, 30, 40, 10)
a.take(3)                             // List(10, 20, 30)
a.takeWhile(_ < 30)                   // List(10, 20)

// flatten
val a = List(List(1,2), List(3,4))
a.flatten                             // List(1, 2, 3, 4)

// map, flatMap
val nums = List("one", "two")
nums.map(_.toUpperCase)               // List("ONE", "TWO")
nums.flatMap(_.toUpperCase)           // List('O', 'N', 'E', 'T', 'W', 'O')

----------------------------------------

TITLE: Evaluating Simple Expressions in Scala
DESCRIPTION: Demonstrates how to evaluate and print simple expressions in Scala using the println function.

LANGUAGE: scala
CODE:
println(1) // 1
println(1 + 1) // 2
println("Hello!") // Hello!
println("Hello," + " world!") // Hello, world!

----------------------------------------

TITLE: Defining a Case Class in Scala
DESCRIPTION: Demonstrates the minimal syntax for defining a case class in Scala and creating an instance. Case classes automatically have an apply method for object construction.

LANGUAGE: scala
CODE:
case class Book(isbn: String)

val frankenstein = Book("978-0486282114")

----------------------------------------

TITLE: Basic Future Creation and Usage in Scala
DESCRIPTION: Demonstrates basic future creation using Future.apply with an ExecutionContext to perform asynchronous matrix inversion.

LANGUAGE: scala
CODE:
val inverseFuture: Future[Matrix] = Future {
  fatMatrix.inverse() // non-blocking long lasting computation
}(executionContext)

----------------------------------------

TITLE: Traditional Helper Method Approach
DESCRIPTION: Shows the traditional way of adding functionality through helper objects in both Scala 2 and 3.

LANGUAGE: scala
CODE:
object CircleHelpers {
  def circumference(c: Circle): Double = c.radius * math.Pi * 2
}

LANGUAGE: scala
CODE:
object CircleHelpers:
  def circumference(c: Circle): Double = c.radius * math.Pi * 2

----------------------------------------

TITLE: Copying Case Class Instances in Scala
DESCRIPTION: Demonstrates the use of the copy method to create a shallow copy of a case class instance, with the option to change specific constructor arguments.

LANGUAGE: scala
CODE:
case class Message(sender: String, recipient: String, body: String)
val message4 = Message("julien@bretagne.fr", "travis@washington.us", "Me zo o komz gant ma amezeg")
val message5 = message4.copy(sender = message4.recipient, recipient = "claire@bourgogne.fr")
message5.sender  // travis@washington.us
message5.recipient // claire@bourgogne.fr
message5.body  // "Me zo o komz gant ma amezeg"

----------------------------------------

TITLE: Filtering Collections in Scala
DESCRIPTION: Demonstrates using filter method to create new lists based on conditions.

LANGUAGE: scala
CODE:
val lessThanFive = nums.filter(_ < 5)
val evens = nums.filter(_ % 2 == 0)
val shortNames = names.filter(_.length <= 4)

----------------------------------------

TITLE: Common List Operations with Functions in Scala
DESCRIPTION: Various examples of using map, filter, and other higher-order functions with lists.

LANGUAGE: scala
CODE:
List("foo", "bar").map(_.toUpperCase)
List("foo", "bar").map(_.capitalize)
List("adam", "scott").map(_.length)
List(1,2,3,4,5).map(_ * 10)
List(1,2,3,4,5).filter(_ > 2)
List(5,1,3,11,7).takeWhile(_ < 6)

----------------------------------------

TITLE: Collection Creation Examples in Scala
DESCRIPTION: Demonstrates uniform syntax for creating different types of collections in Scala, showing how various collection types can be instantiated with similar syntax

LANGUAGE: scala
CODE:
Traversable(1, 2, 3)
Iterable("x", "y", "z")
Map("x" -> 24, "y" -> 25, "z" -> 26)
Set(Color.red, Color.green, Color.blue)
SortedSet("hello", "world")
Buffer(x, y, z)
IndexedSeq(1.0, 2.0)
LinearSeq(a, b, c)

----------------------------------------

TITLE: Future with Blocking Helper
DESCRIPTION: Shows the recommended way to handle blocking operations within futures using the blocking construct.

LANGUAGE: scala
CODE:
Future {
  blocking {
    myLock.lock()
    // ...
  }
}

----------------------------------------

TITLE: Defining a Basic Method That Returns a Function in Scala
DESCRIPTION: This snippet shows how to create a simple 'greet' method that returns a function. The returned function takes a String parameter and prints a greeting.

LANGUAGE: scala
CODE:
def greet(): String => Unit = 
  (name: String) => println(s"Hello, $name")

----------------------------------------

TITLE: Multiline Method in Scala 3
DESCRIPTION: This snippet demonstrates a multiline method in Scala 3 that converts a Throwable's stack trace to a string. It uses StringWriter and PrintWriter to capture the stack trace.

LANGUAGE: scala
CODE:
def getStackTraceAsString(t: Throwable): String =
  val sw = new StringWriter
  t.printStackTrace(new PrintWriter(sw))
  sw.toString

----------------------------------------

TITLE: Filtering Collections in Scala
DESCRIPTION: Demonstrates using filter method to create new lists based on conditions.

LANGUAGE: scala
CODE:
val lessThanFive = nums.filter(_ < 5)
val evens = nums.filter(_ % 2 == 0)
val shortNames = names.filter(_.length <= 4)

----------------------------------------

TITLE: Future with Blocking Helper
DESCRIPTION: Shows the recommended way to handle blocking operations within futures using the blocking construct.

LANGUAGE: scala
CODE:
Future {
  blocking {
    myLock.lock()
    // ...
  }
}

----------------------------------------

TITLE: Explicit and Implicit Type Declarations in Scala
DESCRIPTION: This snippet shows how to declare variables with explicit type annotations and how to use type inference in Scala. It demonstrates that the compiler can often infer types automatically.

LANGUAGE: scala
CODE:
val x: Int = 1   // explicit
val x = 1        // implicit; the compiler infers the type

----------------------------------------

TITLE: Demonstrating Type Inference in Scala
DESCRIPTION: This snippet shows how Scala's type inference allows developers to write code without explicitly specifying variable types, making it feel more dynamic.

LANGUAGE: scala
CODE:
val a = 1
val b = 2.0
val c = "Hi!"

----------------------------------------

TITLE: Creating Lists in Scala
DESCRIPTION: Demonstrates how to create initial Lists in Scala, with and without explicit type declarations.

LANGUAGE: scala
CODE:
val ints = List(1, 2, 3)
val names = List("Joel", "Chris", "Ed")

LANGUAGE: scala
CODE:
val ints: List[Int] = List(1, 2, 3)
val names: List[String] = List("Joel", "Chris", "Ed")

----------------------------------------

TITLE: Defining a Main Method in Scala 3
DESCRIPTION: Defines a top-level method annotated with @main that prints 'Hello, World!' to the console. This is the entry point for a Scala 3 application.

LANGUAGE: scala
CODE:
@main def hello(): Unit =
  println("Hello, World!")

----------------------------------------

TITLE: Anonymous Function with Map in Scala
DESCRIPTION: Shows how to use an anonymous function directly with map for more concise code.

LANGUAGE: scala
CODE:
val salaries = Seq(20_000, 70_000, 40_000)
val newSalaries = salaries.map(x => x * 2) // List(40000, 140000, 80000)

----------------------------------------

TITLE: Implementing a Trait in a Class in Scala
DESCRIPTION: Demonstrates how to extend a trait in a class and implement its abstract methods using the 'override' keyword. It includes an example of an IntIterator class.

LANGUAGE: scala
CODE:
trait Iterator[A] {
  def hasNext: Boolean
  def next(): A
}

class IntIterator(to: Int) extends Iterator[Int] {
  private var current = 0
  override def hasNext: Boolean = current < to
  override def next(): Int = {
    if (hasNext) {
      val t = current
      current += 1
      t
    } else 0
  }
}

val iterator = new IntIterator(10)
iterator.next()  // returns 0
iterator.next()  // returns 1

LANGUAGE: scala
CODE:
trait Iterator[A]:
  def hasNext: Boolean
  def next(): A

class IntIterator(to: Int) extends Iterator[Int]:
  private var current = 0
  override def hasNext: Boolean = current < to
  override def next(): Int =
    if hasNext then
      val t = current
      current += 1
      t
    else
      0
end IntIterator

val iterator = IntIterator(10)
iterator.next()  // returns 0
iterator.next()  // returns 1

----------------------------------------

TITLE: Defining and Using Functions in Scala
DESCRIPTION: Shows how to define anonymous functions, named functions, and functions with multiple or no parameters in Scala.

LANGUAGE: scala
CODE:
(x: Int) => x + 1

val addOne = (x: Int) => x + 1
println(addOne(1)) // 2

val add = (x: Int, y: Int) => x + y
println(add(1, 2)) // 3

val getTheAnswer = () => 42
println(getTheAnswer()) // 42

----------------------------------------

TITLE: Using foldLeft and reduceLeft in Scala
DESCRIPTION: Demonstrates the use of foldLeft and reduceLeft methods to sum the values in a sequence of integers. These methods are commonly used for aggregation operations on collections.

LANGUAGE: scala
CODE:
val firstTen = (1 to 10).toList            // List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)

firstTen.reduceLeft(_ + _)                 // 55
firstTen.foldLeft(100)(_ + _)              // 155 (100 is a "seed" value)

----------------------------------------

TITLE: Automatic Result Variables in REPL
DESCRIPTION: Shows how REPL automatically creates result variables (res0, res1) for expressions without explicit assignment.

LANGUAGE: scala
CODE:
scala> 2 + 2
res0: Int = 4

scala> 3 / 3
res1: Int = 1

----------------------------------------

TITLE: Defining Variables in Scala and Python
DESCRIPTION: Examples of how to define variables in Scala compared to Python, including integers, strings, and multi-line strings.

LANGUAGE: python
CODE:
x = 1
x = "Hi"
y = """foo
     bar
     baz"""

LANGUAGE: scala
CODE:
val x = 1
val x = "Hi"
val y = """foo
         bar
         baz"""

----------------------------------------

TITLE: Combining Functionality with Mixins in Scala
DESCRIPTION: Creates a new class RichStringIter that combines the functionality of StringIterator and RichIterator using mixin composition.

LANGUAGE: scala
CODE:
class RichStringIter extends StringIterator("Scala") with RichIterator
val richStringIter = new RichStringIter
richStringIter.foreach(println)

----------------------------------------

TITLE: For Loop with Multiple Generators
DESCRIPTION: Shows how to write for loops with multiple generators and guards in Scala. Demonstrates iteration over sequences with filtering conditions.

LANGUAGE: scala
CODE:
for {
  i <- 1 to 2
  j <- 'a' to 'b'
  k <- 1 to 10 by 5
} {
  println(s"i = $i, j = $j, k = $k")
}

----------------------------------------

TITLE: Defining a Scala Trait with Concrete and Abstract Methods
DESCRIPTION: This snippet demonstrates how to create a Scala trait with both a concrete method (speak) and an abstract method (comeToMaster).

LANGUAGE: scala
CODE:
trait Pet {
    def speak = println("Yo")     // concrete implementation of a speak method
    def comeToMaster(): Unit      // abstract
}

----------------------------------------

TITLE: Implementing a Recursive Pure Function to Sum a List of Integers in Scala
DESCRIPTION: This example shows a more complex pure function that calculates the sum of a list of integers using recursion. It takes a List[Int] as input and returns an Int as output, demonstrating pattern matching and recursive calls.

LANGUAGE: scala
CODE:
def sum(list: List[Int]): Int = list match {
    case Nil => 0
    case head :: tail => head + sum(tail)
}

----------------------------------------

TITLE: Basic Match Expression in Scala
DESCRIPTION: Demonstrates a simple match expression used like a switch statement to convert numeric months to their names. Shows how to handle default cases with the underscore (_) wildcard.

LANGUAGE: scala
CODE:
i match {
    case 1  => println("January")
    case 2  => println("February")
    case 3  => println("March")
    case 4  => println("April")
    case 5  => println("May")
    case 6  => println("June")
    case 7  => println("July")
    case 8  => println("August")
    case 9  => println("September")
    case 10 => println("October")
    case 11 => println("November")
    case 12 => println("December")
    case _  => println("Invalid month")
}

----------------------------------------

TITLE: Comparing Case Class Instances in Scala
DESCRIPTION: This snippet shows how to compare instances of case classes using the automatically-generated equals method. It demonstrates that two instances with different values are not equal.

LANGUAGE: scala
CODE:
case class Person(name: String, relation: String)

val christina = Person("Christina", "niece")
val hannah = Person("Hannah", "niece")

christina == hannah  // returns false

----------------------------------------

TITLE: Implementing Multiversal Equality for an Online Bookstore
DESCRIPTION: This comprehensive example shows how to implement multiversal equality for an online bookstore, allowing or disallowing comparisons between different types of books.

LANGUAGE: scala
CODE:
// [1] add this import, or this command line flag: -language:strictEquality
import scala.language.strictEquality

// [2] create your class hierarchy
trait Book:
    def author: String
    def title: String
    def year: Int

case class PrintedBook(
    author: String,
    title: String,
    year: Int,
    pages: Int
) extends Book

case class AudioBook(
    author: String,
    title: String,
    year: Int,
    lengthInMinutes: Int
) extends Book

// [3] create type class instances to define the allowed comparisons.
//     allow `PrintedBook == PrintedBook`
//     allow `AudioBook == AudioBook`
given CanEqual[PrintedBook, PrintedBook] = CanEqual.derived
given CanEqual[AudioBook, AudioBook] = CanEqual.derived

// [4a] comparing two printed books works as desired
val p1 = PrintedBook("1984", "George Orwell", 1961, 328)
val p2 = PrintedBook("1984", "George Orwell", 1961, 328)
println(p1 == p2)         // true

// [4b] you can't compare a printed book and an audiobook
val pBook = PrintedBook("1984", "George Orwell", 1961, 328)
val aBook = AudioBook("1984", "George Orwell", 2006, 682)
println(pBook == aBook)   // compiler error

----------------------------------------

TITLE: Creating a Hello World Program in Scala
DESCRIPTION: Defines a main method that prints 'Hello, World!' to the console. Uses the @main annotation to designate the entry point.

LANGUAGE: scala
CODE:
//> using scala {{site.scala-3-version}}

@main
def hello(): Unit =
  println("Hello, World!")

----------------------------------------

TITLE: Complex Scala Class Implementation
DESCRIPTION: Demonstrates a more complex Scala class with constructor body, field declarations, method definitions, and initialization code.

LANGUAGE: scala
CODE:
class Person(var firstName: String, var lastName: String) {
    println("the constructor begins")
    var age = 0
    private val HOME = System.getProperty("user.home")
    override def toString(): String = s"$firstName $lastName is $age years old"
    def printHome(): Unit = println(s"HOME = $HOME")    
    def printFullName(): Unit = println(this) 
    printHome()
    printFullName()
    println("you've reached the end of the constructor")
}

----------------------------------------

TITLE: Filtering Users with For Comprehension in Scala
DESCRIPTION: Demonstrates using a for comprehension to filter a list of User objects and extract names of users in their twenties. The example shows both Scala 2 and Scala 3 syntax.

LANGUAGE: scala
CODE:
case class User(name: String, age: Int)

val userBase = List(
  User("Travis", 28),
  User("Kelly", 33),
  User("Jennifer", 44),
  User("Dennis", 23))

val twentySomethings =
  for (user <- userBase if user.age >=20 && user.age < 30)
  yield user.name  // i.e. add this to a list

twentySomethings.foreach(println)  // prints Travis Dennis

LANGUAGE: scala
CODE:
case class User(name: String, age: Int)

val userBase = List(
  User("Travis", 28),
  User("Kelly", 33),
  User("Jennifer", 44),
  User("Dennis", 23))

val twentySomethings =
  for user <- userBase if user.age >=20 && user.age < 30
  yield user.name  // i.e. add this to a list

twentySomethings.foreach(println)  // prints Travis Dennis

----------------------------------------

TITLE: Using Singleton Object Methods (Scala)
DESCRIPTION: This snippet shows how to call methods directly on a singleton object. It demonstrates using the StringUtils object's isNullOrEmpty method with different inputs.

LANGUAGE: scala
CODE:
val x = StringUtils.isNullOrEmpty("")    // true
val x = StringUtils.isNullOrEmpty("a")   // false

----------------------------------------

TITLE: Subtyping with Traits in Scala
DESCRIPTION: Illustrates how traits can be used for subtyping, allowing objects of classes that extend a trait to be used where the trait type is expected. It includes an example with Pet, Cat, and Dog classes.

LANGUAGE: scala
CODE:
import scala.collection.mutable.ArrayBuffer

trait Pet {
  val name: String
}

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

val dog = new Dog("Harry")
val cat = new Cat("Sally")

val animals = ArrayBuffer.empty[Pet]
animals.append(dog)
animals.append(cat)
animals.foreach(pet => println(pet.name))  // Prints Harry Sally

LANGUAGE: scala
CODE:
import scala.collection.mutable.ArrayBuffer

trait Pet:
  val name: String

class Cat(val name: String) extends Pet
class Dog(val name: String) extends Pet

val dog = Dog("Harry")
val cat = Cat("Sally")

val animals = ArrayBuffer.empty[Pet]
animals.append(dog)
animals.append(cat)
animals.foreach(pet => println(pet.name))  // Prints Harry Sally

----------------------------------------

TITLE: Using External Libraries in Scala
DESCRIPTION: Demonstrates adding a dependency on os-lib and using it to count files in the current directory. Uses the //> using directive to specify dependencies.

LANGUAGE: scala
CODE:
//> using scala {{site.scala-3-version}}
//> using dep "com.lihaoyi::os-lib:0.11.4"

@main
def countFiles(): Unit =
  val paths = os.list(os.pwd)
  println(paths.length)

----------------------------------------

TITLE: Implementing Buffer Operations in Scala
DESCRIPTION: This code snippet illustrates the usage of Buffer operations in Scala, including element addition, removal, and insertion. It uses ArrayBuffer as an example implementation.

LANGUAGE: scala
CODE:
import scala.collection.mutable.ArrayBuffer

val buf = ArrayBuffer(1, 2, 3)

// Additions
buf += 4              // buf is now ArrayBuffer(1, 2, 3, 4)
buf ++= List(5, 6)    // buf is now ArrayBuffer(1, 2, 3, 4, 5, 6)
0 +=: buf             // buf is now ArrayBuffer(0, 1, 2, 3, 4, 5, 6)

// Insertions
buf.insert(2, 10)     // buf is now ArrayBuffer(0, 1, 10, 2, 3, 4, 5, 6)

// Removals
buf -= 3              // buf is now ArrayBuffer(0, 1, 10, 2, 4, 5, 6)
buf.remove(1, 2)      // buf is now ArrayBuffer(0, 2, 4, 5, 6)

// Clearing
buf.clear()           // buf is now empty ArrayBuffer()

----------------------------------------

TITLE: Implementing toInt with Try Pattern in Scala
DESCRIPTION: Demonstrates error handling using Try/Success/Failure pattern to convert a string to an integer. Automatically catches exceptions and wraps them in Failure.

LANGUAGE: scala
CODE:
def toInt(s: String): Try[Int] = Try {
    Integer.parseInt(s.trim)
}

----------------------------------------

TITLE: Defining a Circle Class in Scala
DESCRIPTION: This snippet defines a simple case class representing a Circle with x and y coordinates and a radius.

LANGUAGE: scala
CODE:
case class Circle(x: Double, y: Double, radius: Double)

----------------------------------------

TITLE: Defining a Basic Trait in Scala
DESCRIPTION: Demonstrates the simplest form of trait definition in Scala, using the 'trait' keyword followed by an identifier.

LANGUAGE: scala
CODE:
trait HairColor

----------------------------------------

TITLE: Importing Try Classes in Scala
DESCRIPTION: Shows how to import Try, Success, and Failure classes for error handling.

LANGUAGE: scala
CODE:
import scala.util.{Try,Success,Failure}

----------------------------------------

TITLE: Demonstrating Basic Collection Methods in Scala
DESCRIPTION: This snippet shows examples of common collection methods like distinct, drop, head, intersect, and take on a List.

LANGUAGE: scala
CODE:
val a = List(10, 20, 30, 40, 10)      // List(10, 20, 30, 40, 10)

a.distinct                            // List(10, 20, 30, 40)
a.drop(2)                             // List(30, 40, 10)
a.dropRight(2)                        // List(10, 20, 30)
a.head                                // 10
a.headOption                          // Some(10)
a.init                                // List(10, 20, 30, 40)
a.intersect(List(19,20,21))           // List(20)
a.last                                // 10
a.lastOption                          // Some(10)
a.slice(2,4)                          // List(30, 40)
a.tail                                // List(20, 30, 40, 10)
a.take(3)                             // List(10, 20, 30)
a.takeRight(2)                        // List(40, 10)

----------------------------------------

TITLE: Creating Collections in Scala and Python
DESCRIPTION: Comparison of how to create lists, dictionaries/maps, sets, and tuples in Scala and Python.

LANGUAGE: python
CODE:
x = [1,2,3]

x = {
  "Toy Story": 8.3,
  "Forrest Gump": 8.8,
  "Cloud Atlas": 7.4
}

x = {1,2,3}

x = (11, "Eleven")

LANGUAGE: scala
CODE:
val x = List(1,2,3)

val x = Map(
  "Toy Story" -> 8.3,
  "Forrest Gump" -> 8.8,
  "Cloud Atlas" -> 7.4
)

val x = Set(1,2,3)

val x = (11, "Eleven")

----------------------------------------

TITLE: Function-Returning Function in Scala
DESCRIPTION: Illustrates how to create a function that returns another function as its result.

LANGUAGE: scala
CODE:
def urlBuilder(ssl: Boolean, domainName: String): (String, String) => String = {
  val schema = if (ssl) "https://" else "http://"
  (endpoint: String, query: String) => s"$schema$domainName/$endpoint?$query"
}

----------------------------------------

TITLE: Defining a Partial Function in Scala
DESCRIPTION: This snippet demonstrates how to define a partial function in Scala using a case statement. The function doubles odd integers.

LANGUAGE: scala
CODE:
val doubledOdds: PartialFunction[Int, Int] = {
  case i if i % 2 == 1 => i * 2
}

----------------------------------------

TITLE: Implementing Generic Classes in Scala
DESCRIPTION: Demonstrates how to define and use generic classes in Scala, using a Reference class as an example.

LANGUAGE: scala
CODE:
import compiletime.uninitialized

class Reference[T]:
  private var contents: T = uninitialized
  def set(value: T): Unit = contents = value
  def get: T = contents

----------------------------------------

TITLE: Working with List Collection in Scala
DESCRIPTION: Shows how to create and iterate over a List of strings using a for loop.

LANGUAGE: scala
CODE:
val people = List(
    "Bill", 
    "Candy", 
    "Karen", 
    "Leo", 
    "Regina"
)

LANGUAGE: scala
CODE:
for (p <- people) println(p)

----------------------------------------

TITLE: Pattern Matching with Match Expressions
DESCRIPTION: Demonstrates Scala's pattern matching capabilities using match expressions. Shows matching on constants, case classes, and type patterns.

LANGUAGE: scala
CODE:
i match {
  case 0 => println("1")
  case 1 => println("2")
  case what => println(s"You gave me: $what")
}

----------------------------------------

TITLE: Using the Copy Method of Case Classes in Scala
DESCRIPTION: This snippet demonstrates how to use the automatically-generated copy method of case classes. It shows how to create a new instance of a case class by copying an existing instance and modifying one field.

LANGUAGE: scala
CODE:
case class BaseballTeam(name: String, lastWorldSeriesWin: Int)

val cubs1908 = BaseballTeam("Chicago Cubs", 1908)
val cubs2016 = cubs1908.copy(lastWorldSeriesWin = 2016)

----------------------------------------

TITLE: Demonstrating Array Operations in Scala
DESCRIPTION: This snippet shows basic array creation and manipulation in Scala, including mapping, filtering, and reversing operations.

LANGUAGE: scala
CODE:
val a1 = Array(1, 2, 3)
val a2 = a1 map (_ * 3)
val a3 = a2 filter (_ % 2 != 0)
a3.reverse

----------------------------------------

TITLE: Defining a Scala Class with Default Constructor Values
DESCRIPTION: Demonstrates how to provide default values for constructor parameters in a Scala class. Shows examples for both Scala 2 and Scala 3.

LANGUAGE: scala
CODE:
class Point(var x: Int = 0, var y: Int = 0)

val origin = new Point    // x and y are both set to 0
val point1 = new Point(1) // x is set to 1 and y is set to 0
println(point1)           // prints (1, 0)

LANGUAGE: scala
CODE:
class Point(var x: Int = 0, var y: Int = 0)

val origin = Point()  // x and y are both set to 0
val point1 = Point(1) // x is set to 1 and y is set to 0
println(point1)       // prints (1, 0)

----------------------------------------

TITLE: Defining and Using a Caching Function in Scala
DESCRIPTION: This snippet demonstrates how to create a caching function using a mutable Map. It shows the implementation of a function 'f' and a cached version 'cachedF' that stores results in a map for faster subsequent access.

LANGUAGE: scala
CODE:
def f(x: String) = {
  println("taking my time."); sleep(100)
  x.reverse
}

val cache = collection.mutable.Map[String, String]()

def cachedF(s: String) = cache.getOrElseUpdate(s, f(s))

cachedF("abc")
cachedF("abc")

----------------------------------------

TITLE: Pattern Matching with Option in Scala
DESCRIPTION: Example showing how to handle Option return values using pattern matching to process both successful and failed conversions.

LANGUAGE: scala
CODE:
toInt(x) match {
    case Some(i) => println(i)
    case None => println("That didn't work.")
}

----------------------------------------

TITLE: Creating and Modifying Mutable Set in Scala
DESCRIPTION: Shows how to create a mutable Set and modify it using += and -= operations.

LANGUAGE: scala
CODE:
val s = collection.mutable.Set(1, 2, 3)
s: scala.collection.mutable.Set[Int] = Set(1, 2, 3)
s += 4
res3: s.type = Set(1, 4, 2, 3)
s -= 2
res4: s.type = Set(1, 4, 3)

----------------------------------------

TITLE: Defining a Pure Function to Double an Integer in Scala
DESCRIPTION: This snippet demonstrates a simple pure function that doubles the input integer value. It takes an Int as input and returns an Int as output, with no side effects or external dependencies.

LANGUAGE: scala
CODE:
def double(i: Int): Int = i * 2

----------------------------------------

TITLE: Import Statements in Scala 2
DESCRIPTION: Shows various ways to use import statements in Scala 2, including importing everything, specific members, and renaming imports.

LANGUAGE: scala
CODE:
import users._  // import everything from the users package
import users.User  // import the class User
import users.{User, UserPreferences}  // Only imports selected members
import users.{UserPreferences => UPrefs}  // import and rename for convenience

----------------------------------------

TITLE: Covariant ImmutableBox Implementation
DESCRIPTION: Demonstrates a covariant implementation of an immutable box class that preserves subtyping relationships.

LANGUAGE: scala
CODE:
class ImmutableBox[+A](val content: A)

----------------------------------------

TITLE: Deconstructing Tuples in Scala
DESCRIPTION: Shows how to deconstruct a tuple into individual variables using pattern matching.

LANGUAGE: scala
CODE:
val (name, quantity) = ingredient

println(name) // Sugar

println(quantity) // 25

----------------------------------------

TITLE: Binding Function Results in Scala
DESCRIPTION: Demonstrates the difference between binding results of synchronous and asynchronous (Future) function calls in Scala.

LANGUAGE: scala
CODE:
def aShortRunningTask(): Int = 42
val x = aShortRunningTask

LANGUAGE: scala
CODE:
def aLongRunningTask(): Future[Int] = ???
val x = aLongRunningTask

----------------------------------------

TITLE: Using Map Method in Scala Collections
DESCRIPTION: Examples of using map to transform elements in lists, including doubling numbers and capitalizing strings.

LANGUAGE: scala
CODE:
val doubles = nums.map(_ * 2)
val capNames = names.map(_.capitalize)
val lessThanFive = nums.map(_ < 5)

----------------------------------------

TITLE: Combining Multiple Futures with for-expression in Scala
DESCRIPTION: Demonstrates how to use a for-expression to combine the results of multiple Futures into a single result.

LANGUAGE: scala
CODE:
val result: Future[(Double, Double, Double)] = for {
    aapl <- aaplFuture
    amzn <- amznFuture
    goog <- googFuture
} yield (aapl, amzn, goog)

----------------------------------------

TITLE: Demonstrating Any Type Usage in Scala
DESCRIPTION: This snippet creates a List of Any type and populates it with various data types including string, integer, character, boolean, and function. It then iterates over the list to print each element.

LANGUAGE: scala
CODE:
val list: List[Any] = List(
  "a string",
  732,  // an integer
  'c',  // a character
  true, // a boolean value
  () => "an anonymous function returning a string"
)

list.foreach(element => println(element))

----------------------------------------

TITLE: Deconstructing Trees with Splicing in Scala
DESCRIPTION: Shows how to use splicing (..$, ...$) to deconstruct syntax trees in pattern matching with Scala quasiquotes. This allows for extracting multiple elements or nested lists of elements.

LANGUAGE: scala
CODE:
val q"f(..$args)" = q"f(a, b)"
val q"f(...$argss)" = q"f(a, b)(c)"

----------------------------------------

TITLE: Key-Value Pattern Extraction in Scala
DESCRIPTION: Shows how to use regular expressions with groups to extract key-value pairs from a multi-line string. Uses capture groups and iterates through all matches to parse CSS-like properties.

LANGUAGE: scala
CODE:
import scala.util.matching.Regex

val keyValPattern: Regex = "([0-9a-zA-Z- ]+): ([0-9a-zA-Z-#()/. ]+)".r

val input: String =
  """background-color: #A03300;
    |background-image: url(img/header100.png);
    |background-position: top center;
    |background-repeat: repeat-x;
    |background-size: 2160px 108px;
    |margin: 0;
    |height: 108px;
    |width: 100%;""".stripMargin

for (patternMatch <- keyValPattern.findAllMatchIn(input))
  println(s"key: ${patternMatch.group(1)} value: ${patternMatch.group(2)}")

----------------------------------------

TITLE: Initializing and Querying Immutable Set in Scala
DESCRIPTION: Demonstrates creating an immutable Set of fruits and querying for element existence using the apply method.

LANGUAGE: scala
CODE:
val fruit = Set("apple", "orange", "peach", "banana")
fruit: scala.collection.immutable.Set[java.lang.String] = Set(apple, orange, peach, banana)
fruit("peach")
res0: Boolean = true
fruit("potato")
res1: Boolean = false

----------------------------------------

TITLE: Creating and Modifying Mutable Scala Map
DESCRIPTION: This snippet shows how to create a mutable Map in Scala and perform various modification operations, including adding elements, removing elements, updating values, and filtering in-place.

LANGUAGE: scala
CODE:
val states = scala.collection.mutable.Map(
    "AL" -> "Alabama", 
    "AK" -> "Alaska"
)

// add elements with +=
states += ("AZ" -> "Arizona")
states ++= Map("CO" -> "Colorado", "KY" -> "Kentucky")

// remove elements with -=
states -= "KY"
states --= List("AZ", "CO")

// update elements by reassigning them
states("AK") = "Alaska, The Big State"

// filter elements by supplying a function that operates on
// the keys and/or values
states.filterInPlace((k,v) => k == "AK")

----------------------------------------

TITLE: Comparing WrappedArray and ArrayOps Conversions
DESCRIPTION: This snippet illustrates the difference between the two implicit conversions applied to arrays: WrappedArray and ArrayOps.

LANGUAGE: scala
CODE:
val seq: Seq[Int] = a1
seq.reverse
val ops: collection.mutable.ArrayOps[Int] = a1
ops.reverse

----------------------------------------

TITLE: Implementing JSON Serialization for Custom Class - Scala 2
DESCRIPTION: Shows how to implement JSON serialization for a custom case class in Scala 2 using uPickle's macroRW to generate a ReadWriter instance.

LANGUAGE: scala
CODE:
import upickle.default._

case class PetOwner(name: String, pets: List[String])
implicit val ownerRw: ReadWriter[PetOwner] = macroRW

val petOwner = PetOwner("Peter", List("Toolkitty", "Scaniel"))
val json: String = write(petOwner)
println(json)
// prints: {"name":"Peter","pets":["Toolkitty","Scaniel"]}"

----------------------------------------

TITLE: Using Map Method in Scala Collections
DESCRIPTION: Examples of using map to transform elements in lists, including doubling numbers and capitalizing strings.

LANGUAGE: scala
CODE:
val doubles = nums.map(_ * 2)
val capNames = names.map(_.capitalize)
val lessThanFive = nums.map(_ < 5)

----------------------------------------

TITLE: Using Named Parameters in Scala Method Calls
DESCRIPTION: This example demonstrates how to use named parameters when calling a method in Scala. It improves readability, especially when multiple parameters have the same type.

LANGUAGE: scala
CODE:
makeConnection(
  url = "https://localhost",
  timeout = 2500
)

----------------------------------------

TITLE: Initializing Sample Lists in Scala
DESCRIPTION: Creating sample lists of integers and strings to demonstrate collection methods.

LANGUAGE: scala
CODE:
val nums = (1 to 10).toList
val names = List("joel", "ed", "chris", "maurice")

----------------------------------------

TITLE: Implementing Companion Object Pattern
DESCRIPTION: Shows how to create a companion object with private utility methods that can be accessed by the companion class.

LANGUAGE: scala
CODE:
import scala.math.{Pi, pow}

case class Circle(radius: Double) {
  import Circle._
  def area: Double = calculateArea(radius)
}

object Circle {
  private def calculateArea(radius: Double): Double = Pi * pow(radius, 2.0)
}

val circle1 = Circle(5.0)

circle1.area

----------------------------------------

TITLE: Basic Mixin Example in Scala
DESCRIPTION: Demonstrates the basic usage of mixins in Scala, showing how a class can extend another class and incorporate a trait as a mixin.

LANGUAGE: scala
CODE:
abstract class A {
  val message: String
}
class B extends A {
  val message = "I'm an instance of class B"
}
trait C extends A {
  def loudMessage = message.toUpperCase()
}
class D extends B with C

val d = new D
println(d.message)  // I'm an instance of class B
println(d.loudMessage)  // I'M AN INSTANCE OF CLASS B

----------------------------------------

TITLE: Initializing Sample Lists in Scala
DESCRIPTION: Creates two sample lists: oneToTen containing integers 1 to 10, and names containing a list of strings.

LANGUAGE: scala
CODE:
val oneToTen = (1 to 10).toList
val names = List("adam", "brandy", "chris", "david")

----------------------------------------

TITLE: Multiple Constructors with Option Values
DESCRIPTION: Demonstrates implementing multiple apply methods in a companion object to provide different constructor options with Option values.

LANGUAGE: scala
CODE:
class Person {
    var name: Option[String] = None
    var age: Option[Int] = None
    override def toString = s"$name, $age"
}

object Person {
    def apply(name: Option[String]): Person = {
        var p = new Person
        p.name = name
        p
    }

    def apply(name: Option[String], age: Option[Int]): Person = {
        var p = new Person
        p.name = name
        p.age = age
        p
    }
}

----------------------------------------

TITLE: Implementing Factorial Using Nested Methods - Scala 3
DESCRIPTION: Implementation of a factorial calculation using nested methods in Scala 3, showcasing the new syntax with 'then' keywords and simplified indentation.

LANGUAGE: scala
CODE:
def factorial(x: Int): Int =
  def fact(x: Int, accumulator: Int): Int =
    if x <= 1 then accumulator
    else fact(x - 1, x * accumulator)
  fact(x, 1)

println("Factorial of 2: " + factorial(2))
println("Factorial of 3: " + factorial(3))

----------------------------------------

TITLE: Future with Implicit ExecutionContext
DESCRIPTION: Shows the idiomatic way of creating futures using an implicit ExecutionContext.

LANGUAGE: scala
CODE:
implicit val ec: ExecutionContext = ...
val inverseFuture : Future[Matrix] = Future {
  fatMatrix.inverse()
} // ec is implicitly passed

----------------------------------------

TITLE: Future Composition with For-Comprehension
DESCRIPTION: Demonstrates functional composition of multiple Futures using for-comprehensions and map/flatMap

LANGUAGE: scala
CODE:
val usdQuote = Future { connection.getCurrentValue(USD) }
val chfQuote = Future { connection.getCurrentValue(CHF) }

val purchase = for {
  usd <- usdQuote
  chf <- chfQuote
  if isProfitable(usd, chf)
} yield connection.buy(amount, chf)

----------------------------------------

TITLE: Defining a Generic Stack Class in Scala
DESCRIPTION: This snippet demonstrates how to define a generic Stack class in Scala. The class takes a type parameter A and implements basic stack operations like push, peek, and pop.

LANGUAGE: scala
CODE:
class Stack[A]:
  private var elements: List[A] = Nil
  def push(x: A): Unit =
    elements = x :: elements
  def peek: A = elements.head
  def pop(): A =
    val currentTop = peek
    elements = elements.tail
    currentTop

----------------------------------------

TITLE: JSON Serialization with Scala 3 Objects
DESCRIPTION: Shows how to read and write Scala objects to JSON files using uPickle and OS-Lib in Scala 3, featuring case class definition with derives keyword.

LANGUAGE: scala
CODE:
import upickle.default.*

case class PetOwner(name: String, pets: List[String]) derives ReadWriter

// read a PetOwner from a JSON file
val petOwner: PetOwner = read[PetOwner](os.read(os.pwd / "pet-owner.json"))

// create a new PetOwner
val petOwnerUpdated = petOwner.copy(pets = "Toolkitty" :: petOwner.pets)

// write to a new file
os.write(os.pwd / "pet-owner-updated.json", write(petOwnerUpdated))

----------------------------------------

TITLE: Traditional Class-based Data Storage in Scala
DESCRIPTION: Example of a traditional class approach for storing multiple values of different types.

LANGUAGE: scala
CODE:
class SomeThings(i: Int, s: String, p: Person)

----------------------------------------

TITLE: Match Expression with Multiple Cases
DESCRIPTION: Shows how to handle multiple cases in a single case statement using the | (or) operator. Demonstrates pattern matching with different data types.

LANGUAGE: scala
CODE:
def isTrue(a: Any) = a match {
    case 0 | "" => false
    case _ => true
}

----------------------------------------

TITLE: Using Union Types in Scala 3 Method Signatures
DESCRIPTION: This example demonstrates how Scala 3's union types allow for concise expression of multiple expected argument types and return types in method signatures.

LANGUAGE: scala
CODE:
def isTruthy(a: Boolean | Int | String): Boolean = ???
def dogCatOrWhatever(): Dog | Plant | Car | Sun = ???

----------------------------------------

TITLE: Basic if/then/else Statement in Scala
DESCRIPTION: Demonstrates simple if/then/else conditional logic in both Scala 2 and 3 syntax. Shows single-line and multi-line variations.

LANGUAGE: scala
CODE:
if (x == 1) println(x)

if (x == 1) {
  println("x is 1, as you can see:")
  println(x)
}

----------------------------------------

TITLE: Running Scala Program
DESCRIPTION: Command line instructions for compiling and running a Scala program using the scala command.

LANGUAGE: bash
CODE:
$ scala run hello.scala

----------------------------------------

TITLE: Importing Extension Method
DESCRIPTION: Demonstrates how to import and use an extension method from another package.

LANGUAGE: scala
CODE:
import lib.circumference

aCircle.circumference

----------------------------------------

TITLE: Reassigning Var in Scala REPL
DESCRIPTION: This snippet demonstrates the successful reassignment of a var (mutable) variable in the Scala REPL.

LANGUAGE: scala
CODE:
scala> var a = 'a'
a: Char = a

scala> a = 'b'
a: Char = b

----------------------------------------

TITLE: Implementing Multiple Traits in Scala Class
DESCRIPTION: Demonstrates how to create a Dog class that implements multiple traits using extends and with keywords.

LANGUAGE: scala
CODE:
class Dog extends Speaker with TailWagger with Runner {

    // Speaker
    def speak(): String = "Woof!"

    // TailWagger
    def startTail(): Unit = println("tail is wagging")
    def stopTail(): Unit = println("tail is stopped")

    // Runner
    def startRunning(): Unit = println("I'm running")
    def stopRunning(): Unit = println("Stopped running")

}

----------------------------------------

TITLE: Importing Extension Method
DESCRIPTION: Demonstrates how to import and use an extension method from another package.

LANGUAGE: scala
CODE:
import lib.circumference

aCircle.circumference

----------------------------------------

TITLE: Calling Methods with Default Parameters in Scala
DESCRIPTION: This snippet shows two ways to call the 'makeConnection' method: one using the default timeout value, and another specifying a custom timeout.

LANGUAGE: scala
CODE:
makeConnection("https://localhost")         // url=http://localhost, timeout=5000
makeConnection("https://localhost", 2500)   // url=http://localhost, timeout=2500

----------------------------------------

TITLE: Valid Abstract Class Declaration in Scala
DESCRIPTION: Shows the correct way to declare an abstract class with constructor parameters.

LANGUAGE: scala
CODE:
abstract class Animal(name: String)

----------------------------------------

TITLE: Handling Combined Future Results with onComplete in Scala
DESCRIPTION: Shows how to use onComplete to process the results of combined Futures, including timing information and error handling.

LANGUAGE: scala
CODE:
result.onComplete {
    case Success(x) => {
        val totalTime = deltaTime(startTime)
        println(s"In Success case, time delta: ${totalTime}")
        println(s"The stock prices are: $x")
    }
    case Failure(e) => e.printStackTrace
}

----------------------------------------

TITLE: Defining a Type Class with Multiple Methods in Scala 2 and 3
DESCRIPTION: This snippet demonstrates how to define a type class with multiple methods, using the 'HasLegs' trait as an example in both Scala 2 and Scala 3.

LANGUAGE: scala
CODE:
// Scala 2
trait HasLegs[A] {
  def walk(a: A): Unit
  def run(a: A): Unit
}

LANGUAGE: scala
CODE:
// Scala 3
trait HasLegs[A]:
  extension (a: A)
    def walk(): Unit
    def run(): Unit

----------------------------------------

TITLE: Using For-Comprehension with Futures in Scala
DESCRIPTION: Demonstrates using for-comprehension syntax with Futures for easier handling of asynchronous operations.

LANGUAGE: scala
CODE:
val f: Future[List[String]] = Future {
  session.getRecentPosts()
}

for {
  posts <- f
  post <- posts
} println(post)

LANGUAGE: scala
CODE:
val f: Future[List[String]] = Future {
  session.getRecentPosts()
}

for
  posts <- f
  post <- posts
do println(post)

----------------------------------------

TITLE: Additional Scala Class Examples
DESCRIPTION: Shows various examples of Scala classes with different parameter configurations and formatting styles.

LANGUAGE: scala
CODE:
class Pizza (var crustSize: Int, var crustType: String)

class Stock(var symbol: String, var price: BigDecimal)

class Socket(val timeout: Int, val linger: Int) {
    override def toString = s"timeout: $timeout, linger: $linger"
}

class Address (
    var street1: String,
    var street2: String,
    var city: String, 
    var state: String
)

----------------------------------------

TITLE: Concrete String Iterator Implementation in Scala
DESCRIPTION: Implements a concrete StringIterator class that extends the abstract AbsIterator, providing implementations for all abstract members.

LANGUAGE: scala
CODE:
class StringIterator(s: String) extends AbsIterator {
  type T = Char
  private var i = 0
  def hasNext = i < s.length
  def next() = {
    val ch = s charAt i
    i += 1
    ch
  }
}

----------------------------------------

TITLE: Creating Generic Arrays with ClassTag
DESCRIPTION: This snippet shows how to create generic arrays in Scala using ClassTag to provide runtime type information.

LANGUAGE: scala
CODE:
import scala.reflect.ClassTag
def evenElems[T: ClassTag](xs: Vector[T]): Array[T] = {
  val arr = new Array[T]((xs.length + 1) / 2)
  for (i <- 0 until xs.length by 2)
    arr(i / 2) = xs(i)
  arr
}

----------------------------------------

TITLE: Using foreach Method with Collections
DESCRIPTION: Demonstrates the foreach method as an alternative to for loops for collection iteration.

LANGUAGE: scala
CODE:
people.foreach(println)

----------------------------------------

TITLE: Defining Extension Methods in Scala 3
DESCRIPTION: This snippet shows how to define an extension method 'makeInt' for the String class in Scala 3. It demonstrates adding new functionality to existing types without modifying their source code.

LANGUAGE: scala
CODE:
extension (s: String)
  def makeInt(radix: Int): Int = Integer.parseInt(s, radix)

"1".makeInt(2)      // Int = 1
"10".makeInt(2)     // Int = 2
"100".makeInt(2)    // Int = 4

----------------------------------------

TITLE: Scala Variable Declarations
DESCRIPTION: Examples showing immutable (val) and mutable (var) variable declarations in Scala with type inference.

LANGUAGE: scala
CODE:
val x = 1   //immutable
var y = 0   //mutable

----------------------------------------

TITLE: Match Expression with Value Assignment
DESCRIPTION: Shows how to use a match expression to return and assign values rather than printing directly. Demonstrates the expression-oriented nature of Scala's match statements.

LANGUAGE: scala
CODE:
val monthName = i match {
    case 1  => "January"
    case 2  => "February"
    case 3  => "March"
    case 4  => "April"
    case 5  => "May"
    case 6  => "June"
    case 7  => "July"
    case 8  => "August"
    case 9  => "September"
    case 10 => "October"
    case 11 => "November"
    case 12 => "December"
    case _  => "Invalid month"
}

----------------------------------------

TITLE: Hello World in Scala
DESCRIPTION: Basic Hello World program demonstrating Scala's object-oriented syntax and entry point.

LANGUAGE: scala
CODE:
object Hello extends App {
    println("Hello, world")
}

----------------------------------------

TITLE: Method with Default Parameter in Scala
DESCRIPTION: This example shows a method 'makeConnection' with a default value for the 'timeout' parameter. It demonstrates how default parameters can be used in Scala methods.

LANGUAGE: scala
CODE:
def makeConnection(url: String, timeout: Int = 5000): Unit =
  println(s"url=$url, timeout=$timeout")

----------------------------------------

TITLE: Option-based String to Integer Conversion in Scala
DESCRIPTION: An improved implementation using Option/Some/None to handle string to integer conversion, providing clear distinction between successful and failed conversions.

LANGUAGE: scala
CODE:
def toInt(s: String): Option[Int] = {
    try {
        Some(Integer.parseInt(s.trim))
    } catch {
        case e: Exception => None
    }
}

----------------------------------------

TITLE: Defining Basic Abstract Type Member in Scala
DESCRIPTION: Demonstrates creating a trait with an abstract type member T and a value element of that type. Shows basic abstract type definition syntax in both Scala 2 and 3.

LANGUAGE: scala
CODE:
trait Buffer {
  type T
  val element: T
}

----------------------------------------

TITLE: Using Expressions with 's' Interpolator in Scala
DESCRIPTION: Shows how to embed arbitrary expressions within string interpolation using the 's' interpolator in Scala.

LANGUAGE: scala
CODE:
println(s"1 + 1 = ${1 + 1}")

----------------------------------------

TITLE: Using Map with Anonymous Functions in Scala
DESCRIPTION: Shows how to use the map method with anonymous functions to transform a list of integers. Includes multiple syntax options for writing anonymous functions.

LANGUAGE: scala
CODE:
val doubledInts = ints.map(_ * 2)

LANGUAGE: scala
CODE:
val doubledInts = ints.map((i: Int) => i * 2)

LANGUAGE: scala
CODE:
val doubledInts = ints.map(i => i * 2)

----------------------------------------

TITLE: Basic Companion Object Definition in Scala
DESCRIPTION: Demonstrates the basic structure of a companion object and class with the same name defined in the same file.

LANGUAGE: scala
CODE:
class Pizza {
}

object Pizza {
}

----------------------------------------

TITLE: Implementing a Recursive Pure Function in Scala 2
DESCRIPTION: This example shows a pure function that calculates the sum of a list of integers using recursion in Scala 2 syntax.

LANGUAGE: scala
CODE:
def sum(xs: List[Int]): Int = xs match {
  case Nil => 0
  case head :: tail => head + sum(tail)
}

----------------------------------------

TITLE: Explicit Type Declaration in Scala
DESCRIPTION: Demonstrates how to explicitly declare variable types in Scala using the type annotation syntax. Shows examples with Int and String types.

LANGUAGE: scala
CODE:
val count: Int = 1
val name: String = "Alvin"

----------------------------------------

TITLE: Promise Creation and Usage
DESCRIPTION: Demonstrates creating and completing promises with producer-consumer pattern.

LANGUAGE: scala
CODE:
import scala.concurrent.{ Future, Promise }
import scala.concurrent.ExecutionContext.Implicits.global

val p = Promise[T]()
val f = p.future

val producer = Future {
  val r = produceSomething()
  p.success(r)
  continueDoingSomethingUnrelated()
}

val consumer = Future {
  startDoingSomething()
  f.foreach { r =>
    doSomethingWithResult()
  }
}

----------------------------------------

TITLE: Enum Definition with Parameters
DESCRIPTION: Shows how to create enums with parameters and methods in Scala 3.

LANGUAGE: scala
CODE:
enum Planet(mass: Double, radius: Double):
  private final val G = 6.67300E-11
  def surfaceGravity = G * mass / (radius * radius)
  def surfaceWeight(otherMass: Double) =
    otherMass * surfaceGravity

  case Mercury extends Planet(3.303e+23, 2.4397e6)
  case Earth   extends Planet(5.976e+24, 6.37814e6)

----------------------------------------

TITLE: Match Expression with If Guards
DESCRIPTION: Demonstrates using if expressions within case statements for more complex pattern matching scenarios, including range checking and multiple conditions.

LANGUAGE: scala
CODE:
count match {
    case 1 => println("one, a lonely number")
    case x if x == 2 || x == 3 => println("two's company, three's a crowd")
    case x if x > 3 => println("4+, that's a party")
    case _ => println("i'm guessing your number is zero or less")
}

----------------------------------------

TITLE: Using a Higher-Order Function with Complex Parameter Types in Scala
DESCRIPTION: This example demonstrates how to use the 'executeAndPrint' function by passing in different functions (sum and multiply) along with integer arguments.

LANGUAGE: scala
CODE:
def sum(x: Int, y: Int) = x + y
def multiply(x: Int, y: Int) = x * y

executeAndPrint(sum, 3, 11)       // prints 14
executeAndPrint(multiply, 3, 9)   // prints 27

----------------------------------------

TITLE: Demonstrating Type Inference for Variables in Scala
DESCRIPTION: This snippet shows how Scala can infer the type of a variable without an explicit type declaration. The compiler automatically detects that 'businessName' is a String.

LANGUAGE: scala
CODE:
val businessName = "Montreux Jazz Café"

----------------------------------------

TITLE: File Reading with Try-Catch in Scala
DESCRIPTION: Demonstrates basic try/catch usage for handling file operations in Scala. Shows how to catch specific exceptions (FileNotFoundException and IOException) when attempting to read a file.

LANGUAGE: scala
CODE:
var text = ""
try {
    text = openAndReadAFile(filename)
} catch {
    case e: FileNotFoundException => println("Couldn't find that file.")
    case e: IOException => println("Had an IOException trying to read that file")
}

----------------------------------------

TITLE: Interactive Name Input Program in Scala
DESCRIPTION: A complete program that demonstrates reading user input using StdIn.readLine. The program prompts for first and last names and prints them back to the user.

LANGUAGE: scala
CODE:
import scala.io.StdIn.readLine

object HelloInteractive extends App {

    print("Enter your first name: ")
    val firstName = readLine()

    print("Enter your last name: ")
    val lastName = readLine()

    println(s"Your name is $firstName $lastName")

}

----------------------------------------

TITLE: Creating Doubled Numbers List with Scala for Expression
DESCRIPTION: This snippet demonstrates how to use a Scala for expression to create a new list of integers where all values are doubled from an existing list.

LANGUAGE: scala
CODE:
val nums = Seq(1,2,3)
val doubledNums = for (n <- nums) yield n * 2

----------------------------------------

TITLE: Defining and Using Methods in Scala
DESCRIPTION: Demonstrates how to define methods in Scala using the 'def' keyword, including methods with multiple parameter lists and multi-line expressions.

LANGUAGE: scala
CODE:
def add(x: Int, y: Int): Int = x + y
println(add(1, 2)) // 3

def addThenMultiply(x: Int, y: Int)(multiplier: Int): Int = (x + y) * multiplier
println(addThenMultiply(1, 2)(3)) // 9

def name: String = System.getProperty("user.name")
println("Hello, " + name + "!")

def getSquareString(input: Double): String = {
  val square = input * input
  square.toString
}
println(getSquareString(2.5)) // 6.25

----------------------------------------

TITLE: Creating Modules from Traits Using Objects (Scala)
DESCRIPTION: This snippet demonstrates how to use objects to implement traits and create modules in Scala. It combines two traits (AddService and MultiplyService) into a concrete object (MathService) that provides mathematical operations.

LANGUAGE: scala
CODE:
trait AddService:
  def add(a: Int, b: Int) = a + b

trait MultiplyService:
  def multiply(a: Int, b: Int) = a * b

// implement those traits as a concrete object
object MathService extends AddService, MultiplyService

// use the object
import MathService.*
println(add(1,1))        // 2
println(multiply(2,2))   // 4

----------------------------------------

TITLE: Storing Functions in Collections
DESCRIPTION: Shows how to store multiple function variables in collections like List and Map.

LANGUAGE: scala
CODE:
val triple = (i: Int) => i * 3
val functionList = List(double, triple)

val functionMap = Map(
  "2x" -> double,
  "3x" -> triple
)

----------------------------------------

TITLE: Accessing and Modifying Class Fields in Scala
DESCRIPTION: Examples of accessing and modifying fields of class instances in Scala.

LANGUAGE: scala
CODE:
p.name       // "Robert Allen Zimmerman"
p.vocation   // "Harmonica Player"

p.name = "Bob Dylan"
p.vocation = "Musician"

----------------------------------------

TITLE: Assigning Result of if Expression to Variable
DESCRIPTION: Shows how to assign the result of an if expression to a variable, demonstrating that if expressions always return a value in Scala.

LANGUAGE: scala
CODE:
val minValue = if (a < b) a else b

----------------------------------------

TITLE: Defining Program Entry Point in Scala
DESCRIPTION: Shows how to define the main method as the entry point of a Scala program using an object.

LANGUAGE: scala
CODE:
object Main {
  def main(args: Array[String]): Unit =
    println("Hello, Scala developer!")
}

----------------------------------------

TITLE: Defining Inline Constants in Scala 3
DESCRIPTION: Demonstrates how to define inline constants in Scala 3, which are guaranteed to be inlined at compile-time.

LANGUAGE: scala
CODE:
inline val pi = 3.141592653589793
inline val pie = "🥧"

----------------------------------------

TITLE: Creating a Tuple in Scala
DESCRIPTION: Demonstrates how to create a tuple containing multiple values of different types.

LANGUAGE: scala
CODE:
val t = (3, "Three", new Person("Al"))

----------------------------------------

TITLE: Using take and drop Methods on Scala Lists
DESCRIPTION: Demonstrates the use of take, takeRight, takeWhile, drop, dropRight, and dropWhile methods to create new lists by selecting or removing elements.

LANGUAGE: scala
CODE:
oneToTen.take(2)        // List(1, 2)
oneToTen.takeRight(2)   // List(9, 10)
oneToTen.takeWhile(_ < 5)       // List(1, 2, 3, 4)

oneToTen.drop(5)        // List(6, 7, 8, 9, 10)
oneToTen.dropRight(7)   // List(1, 2, 3)
oneToTen.dropWhile(_ < 5)       // List(5, 6, 7, 8, 9, 10)

----------------------------------------

TITLE: Demonstrating Seq Operations in Scala
DESCRIPTION: This code snippet demonstrates various operations available on Seq trait in Scala, including indexing, length, search, addition, and sorting operations.

LANGUAGE: scala
CODE:
val xs: Seq[Int] = Seq(1, 2, 3, 4, 5)

// Indexing and Length
xs(2)                // Returns 3
xs.length             // Returns 5
xs.indices            // Returns Range(0, 1, 2, 3, 4)

// Index Search
xs.indexOf(3)         // Returns 2
xs.lastIndexOf(5)     // Returns 4

// Additions
6 +: xs               // Returns Seq(6, 1, 2, 3, 4, 5)
xs :+ 6               // Returns Seq(1, 2, 3, 4, 5, 6)

// Sorting
xs.sorted             // Returns Seq(1, 2, 3, 4, 5)
xs.sortWith(_ > _)    // Returns Seq(5, 4, 3, 2, 1)

// Reversals
xs.reverse            // Returns Seq(5, 4, 3, 2, 1)

----------------------------------------

TITLE: Defining foldLeft Method with Multiple Parameter Lists in Scala
DESCRIPTION: Example of the foldLeft method definition from Scala's Iterable trait, showcasing multiple parameter lists.

LANGUAGE: scala
CODE:
trait Iterable[A]:
  ...
  def foldLeft[B](z: B)(op: (B, A) => B): B
  ...

----------------------------------------

TITLE: Creating a Thread-Safe Mutable Map in Scala
DESCRIPTION: This snippet shows how to create a thread-safe mutable map by mixing in the SynchronizedMap trait with a HashMap. It includes an example of overriding the default method to provide a custom response for non-existent keys.

LANGUAGE: scala
CODE:
import scala.collection.mutable.{Map, SynchronizedMap, HashMap}
object MapMaker {
  def makeMap: Map[String, String] = {
    new HashMap[String, String] with SynchronizedMap[String, String] {
      override def default(key: String) =
        "Why do you want to know?"
    }
  }
}

----------------------------------------

TITLE: Defining and Using foldLeft with Multiple Parameter Lists for Type Inference in Scala
DESCRIPTION: Showing how multiple parameter lists enable better type inference in Scala.

LANGUAGE: scala
CODE:
def foldLeft2[A, B](as: List[A], b0: B)(op: (B, A) => B) = ???
def possible = foldLeft2(numbers, 0)(_ + _)

----------------------------------------

TITLE: Defining a Trait with Abstract and Concrete Methods in Scala
DESCRIPTION: This snippet demonstrates how to define a trait named 'Similarity' in Scala. It includes an abstract method 'isSimilar' and a concrete method 'isNotSimilar' with a default implementation.

LANGUAGE: scala
CODE:
trait Similarity {
  def isSimilar(x: Any): Boolean
  def isNotSimilar(x: Any): Boolean = !isSimilar(x)
}

----------------------------------------

TITLE: Abstract Class Pet Implementation in Scala
DESCRIPTION: Demonstrates creating an abstract class with both concrete and abstract methods.

LANGUAGE: scala
CODE:
abstract class Pet (name: String) {
    def speak(): Unit = println("Yo")   // concrete implementation
    def comeToMaster(): Unit            // abstract method
}

----------------------------------------

TITLE: Adding Scala 2 Nightly Resolver in SBT
DESCRIPTION: Adds the resolver for Scala 2 nightly versions to the SBT build configuration. This is required to access the nightly builds.

LANGUAGE: scala
CODE:
Global / resolvers += "scala-integration" at
  "https://scala-ci.typesafe.com/artifactory/scala-integration/"
scalaVersion := "2.13.15-bin-abcd123"

----------------------------------------

TITLE: Demonstrating Seq Operations in Scala
DESCRIPTION: This code snippet demonstrates various operations available on Seq trait in Scala, including indexing, length, search, addition, and sorting operations.

LANGUAGE: scala
CODE:
val xs: Seq[Int] = Seq(1, 2, 3, 4, 5)

// Indexing and Length
xs(2)                // Returns 3
xs.length             // Returns 5
xs.indices            // Returns Range(0, 1, 2, 3, 4)

// Index Search
xs.indexOf(3)         // Returns 2
xs.lastIndexOf(5)     // Returns 4

// Additions
6 +: xs               // Returns Seq(6, 1, 2, 3, 4, 5)
xs :+ 6               // Returns Seq(1, 2, 3, 4, 5, 6)

// Sorting
xs.sorted             // Returns Seq(1, 2, 3, 4, 5)
xs.sortWith(_ > _)    // Returns Seq(5, 4, 3, 2, 1)

// Reversals
xs.reverse            // Returns Seq(5, 4, 3, 2, 1)

----------------------------------------

TITLE: Iterating Over Sequence with Scala for Loop
DESCRIPTION: Demonstrates basic for loop iteration over a Sequence of integers.

LANGUAGE: scala
CODE:
val nums = Seq(1,2,3)

LANGUAGE: scala
CODE:
for (n <- nums) println(n)

----------------------------------------

TITLE: Writing Output in Scala
DESCRIPTION: Demonstrates different methods for writing output in Scala, including println for output with newline, print for output without newline, and writing to standard error.

LANGUAGE: scala
CODE:
println("Hello, world")

LANGUAGE: scala
CODE:
print("Hello without newline")

LANGUAGE: scala
CODE:
System.err.println("yikes, an error happened")

----------------------------------------

TITLE: Higher-Order Function Invocation in Scala
DESCRIPTION: Shows the recommended syntax for invoking higher-order functions in Scala using dot notation. It also provides examples of incorrect invocations to avoid.

LANGUAGE: scala
CODE:
names.map(_.toUpperCase)

// wrong! missing dot
names map (_.toUpperCase)
// wrong! extra space
names.map (_.toUpperCase)

----------------------------------------

TITLE: Pattern Matching with Tuples
DESCRIPTION: Demonstrates tuple destructuring using pattern matching to extract individual elements.

LANGUAGE: scala
CODE:
val (name, quantity) = ingredient
println(name)     // Sugar
println(quantity) // 25

----------------------------------------

TITLE: Defining foldLeft Method with Multiple Parameter Lists in Scala
DESCRIPTION: Example of the foldLeft method definition from Scala's Iterable trait, showcasing multiple parameter lists.

LANGUAGE: scala
CODE:
trait Iterable[A]:
  ...
  def foldLeft[B](z: B)(op: (B, A) => B): B
  ...

----------------------------------------

TITLE: Multiple Trait Definition
DESCRIPTION: Defines multiple traits (Speaker, TailWagger, Runner) to demonstrate modular code organization.

LANGUAGE: scala
CODE:
trait Speaker {
    def speak(): String
}

trait TailWagger {
    def startTail(): Unit
    def stopTail(): Unit
}

trait Runner {
    def startRunning(): Unit
    def stopRunning(): Unit
}

----------------------------------------

TITLE: Defining and Implementing Traits in Scala
DESCRIPTION: Demonstrates how to define traits with abstract and concrete methods, and how to extend and override them in classes.

LANGUAGE: scala
CODE:
trait Greeter {
  def greet(name: String): Unit =
    println("Hello, " + name + "!")
}

class DefaultGreeter extends Greeter

class CustomizableGreeter(prefix: String, postfix: String) extends Greeter {
  override def greet(name: String): Unit = {
    println(prefix + name + postfix)
  }
}

val greeter = new DefaultGreeter()
greeter.greet("Scala developer") // Hello, Scala developer!

val customGreeter = new CustomizableGreeter("How are you, ", "?")
customGreeter.greet("Scala developer") // How are you, Scala developer?

----------------------------------------

TITLE: Abstract Iterator Class Definition in Scala
DESCRIPTION: Defines an abstract class AbsIterator with an abstract type T and standard iterator methods.

LANGUAGE: scala
CODE:
abstract class AbsIterator {
  type T
  def hasNext: Boolean
  def next(): T
}

----------------------------------------

TITLE: Defining Utility Methods in a Singleton Object (Scala)
DESCRIPTION: This snippet demonstrates how to create a singleton object with utility methods for string manipulation. It includes methods for checking if a string is null or empty, and trimming whitespace from the left or right side of a string.

LANGUAGE: scala
CODE:
object StringUtils:
  def isNullOrEmpty(s: String): Boolean = s == null || s.trim.isEmpty
  def leftTrim(s: String): String = s.replaceAll("^\\s+", "")
  def rightTrim(s: String): String = s.replaceAll("\\s+$", "")

----------------------------------------

TITLE: Creating Singleton Logger Object
DESCRIPTION: Shows how to create a utility singleton object with a logging method that can be imported and used throughout the application.

LANGUAGE: scala
CODE:
package logging

object Logger {
  def info(message: String): Unit = println(s"INFO: $message")
}

----------------------------------------

TITLE: Defining Showable Type Class in Scala
DESCRIPTION: Demonstrates the creation of a Showable type class with a show method that takes an implicit parameter. This allows for type-specific pretty-printing implementations.

LANGUAGE: scala
CODE:
trait Showable[T] { def show(x: T): String }
def show[T](x: T)(implicit s: Showable[T]) = s.show(x)

----------------------------------------

TITLE: Adding Elements to Mutable Map in Scala
DESCRIPTION: Demonstrates various ways to add single and multiple elements to a mutable Map using += and ++= operators.

LANGUAGE: scala
CODE:
states += ("AL" -> "Alabama")
states += ("AR" -> "Arkansas", "AZ" -> "Arizona")
states ++= Map("CA" -> "California", "CO" -> "Colorado")

----------------------------------------

TITLE: Defining Extension Methods in Scala 3
DESCRIPTION: Demonstrates how to define extension methods for a Circle class in Scala 3 using the extension keyword.

LANGUAGE: scala
CODE:
extension (c: Circle)
  def circumference: Double = c.radius * math.Pi * 2
  def diameter: Double = c.radius * 2
  def area: Double = math.Pi * c.radius * c.radius

----------------------------------------

TITLE: Defining Multiple Constructors for a Scala Pizza Class
DESCRIPTION: This snippet demonstrates how to define a Pizza class with a primary constructor and multiple auxiliary constructors. It includes default values for crust size and type, and overrides the toString method.

LANGUAGE: scala
CODE:
val DefaultCrustSize = 12
val DefaultCrustType = "THIN"

// the primary constructor
class Pizza (var crustSize: Int, var crustType: String) {

    // one-arg auxiliary constructor
    def this(crustSize: Int) = {
        this(crustSize, DefaultCrustType)
    }

    // one-arg auxiliary constructor
    def this(crustType: String) = {
        this(DefaultCrustSize, crustType)
    }

    // zero-arg auxiliary constructor
    def this() = {
        this(DefaultCrustSize, DefaultCrustType)
    }

    override def toString = s"A $crustSize inch pizza with a $crustType crust"

}

----------------------------------------

TITLE: Using a Synchronized Map in Scala
DESCRIPTION: This snippet demonstrates how to use the synchronized map created by the MapMaker object. It shows adding key-value pairs, accessing existing and non-existing keys, and updating the map.

LANGUAGE: scala
CODE:
val capital = MapMaker.makeMap  
capital ++ List("US" -> "Washington", "France" -> "Paris", "Japan" -> "Tokyo")
capital("Japan")
capital("New Zealand")
capital += ("New Zealand" -> "Wellington")
capital("New Zealand")

----------------------------------------

TITLE: Importing and Creating Mutable Map in Scala
DESCRIPTION: Shows how to import the mutable Map class and create a new mutable Map instance.

LANGUAGE: scala
CODE:
import scala.collection.mutable.Map

val states = collection.mutable.Map("AK" -> "Alaska")

----------------------------------------

TITLE: Scala if/else Construct
DESCRIPTION: Illustrates the if/else construct in Scala, providing alternative actions for true and false conditions.

LANGUAGE: scala
CODE:
if (a == b) {
    doSomething()
} else {
    doSomethingElse()
}

----------------------------------------

TITLE: Starting Scala 2 REPL Session
DESCRIPTION: This snippet shows how to start a Scala 2 REPL session using the 'scala' command. It displays the welcome message and version information.

LANGUAGE: bash
CODE:
$ scala
Welcome to Scala {{site.scala-version}} (OpenJDK 64-Bit Server VM, Java 1.8.0_342).
Type in expressions for evaluation. Or try :help.

scala> _

----------------------------------------

TITLE: Handling Query Parameters with Cask in Scala
DESCRIPTION: Demonstrates creating a web endpoint that accepts an optional 'city' query parameter to display time in different timezones. Uses ZoneId to validate and process timezone information, with pattern matching to handle both presence and absence of the city parameter.

LANGUAGE: scala
CODE:
import java.time.{ZoneId, ZonedDateTime}

object Example extends cask.MainRoutes {

  private def getZoneIdForCity(city: String): Option[ZoneId] = {
    import scala.jdk.CollectionConverters._
    ZoneId.getAvailableZoneIds.asScala.find(_.endsWith("/" + city)).map(ZoneId.of)
  }

  @cask.get("/time")
  def dynamicWithParam(city: Option[String] = None): String = {
    city match {
      case Some(value) => getZoneIdForCity(value) match {
        case Some(zoneId) => s"Current date is: ${ZonedDateTime.now().withZoneSameInstant(zoneId)}"
        case None => s"Couldn't find time zone for city $value"
      }
      case None => s"Current date is: ${ZonedDateTime.now()}"
    }
  }

  initialize()
}

LANGUAGE: scala
CODE:
import java.time.{ZoneId, ZonedDateTime}

object Example extends cask.MainRoutes:

  private def getZoneIdForCity(city: String): Option[ZoneId] =
    import scala.jdk.CollectionConverters.*
    ZoneId.getAvailableZoneIds.asScala.find(_.endsWith("/" + city)).map(ZoneId.of)

  @cask.get("/time")
  def dynamicWithParam(city: Option[String] = None): String =
    city match
      case Some(value) => getZoneIdForCity(value) match
        case Some(zoneId) => s"Current date is: ${ZonedDateTime.now().withZoneSameInstant(zoneId)}"
        case None => s"Couldn't find time zone for city $value"
      case None => s"Current date is: ${ZonedDateTime.now()}"

  initialize()

----------------------------------------

TITLE: Defining Basic Macro with Inspection
DESCRIPTION: Shows how to create a basic macro that prints the expression of the provided argument at compile-time using Expr[T].

LANGUAGE: scala
CODE:
import scala.quoted.* // imports Quotes, Expr

def inspectCode(x: Expr[Any])(using Quotes): Expr[Any] =
  println(x.show)
  x

----------------------------------------

TITLE: Importing from Root Package in Scala 2
DESCRIPTION: Shows how to import from the root of the project in Scala 2 using the _root_ prefix to resolve naming conflicts.

LANGUAGE: scala
CODE:
package accounts

import _root_.users._

----------------------------------------

TITLE: Creating Standard sbt Directory Structure
DESCRIPTION: The standard directory structure that sbt expects for Scala projects, showing the hierarchy of main and test directories for Java, Scala, and resources.

LANGUAGE: bash
CODE:
build.sbt
project/
src/
-- main/
   |-- java/
   |-- resources/
   |-- scala/
|-- test/
   |-- java/
   |-- resources/
   |-- scala/
target/

----------------------------------------

TITLE: Implementing Companion Objects and Classes (Scala)
DESCRIPTION: This example illustrates the use of companion objects and classes in Scala. It shows how a companion class (Circle) can access private members of its companion object, demonstrating encapsulation and separation of concerns.

LANGUAGE: scala
CODE:
import scala.math.*

class Circle(radius: Double):
  import Circle.*
  def area: Double = calculateArea(radius)

object Circle:
  private def calculateArea(radius: Double): Double =
    Pi * pow(radius, 2.0)

val circle1 = Circle(5.0)
circle1.area   // Double = 78.53981633974483

----------------------------------------

TITLE: Listing Control Structures in Scala
DESCRIPTION: Overview of the main control structures available in Scala, including both traditional control flows and Scala-specific constructs.

LANGUAGE: scala
CODE:
- if/then/else
- `for` loops
- try/catch/finally
- `match` expressions
- `for` expressions

----------------------------------------

TITLE: Invalid Type Casting Example in Scala
DESCRIPTION: This snippet shows an example of invalid type casting in Scala, attempting to cast a Float to a Long directly, which is not allowed.

LANGUAGE: scala
CODE:
val x: Long = 987654321
val y: Float = x.toFloat  // 9.8765434E8
val z: Long = y  // Does not conform

----------------------------------------

TITLE: Address Class with Optional Field in Scala
DESCRIPTION: Example of using Option to handle optional fields in a class definition, avoiding null values.

LANGUAGE: scala
CODE:
class Address (
    var street1: String,
    var street2: Option[String],
    var city: String, 
    var state: String, 
    var zip: String
)

----------------------------------------

TITLE: Defining and Calling Methods in Scala REPL
DESCRIPTION: This snippet shows how to define a method (sum) and then call it within the Scala REPL environment. It demonstrates method definition syntax and execution.

LANGUAGE: scala
CODE:
scala> def sum(a: Int, b: Int): Int = a + b
def sum(a: Int, b: Int): Int

scala> sum(2, 2)
val res2: Int = 4

----------------------------------------

TITLE: Handling Future Completion with onComplete in Scala
DESCRIPTION: Shows how to use the onComplete callback method to handle both successful and failed Future results.

LANGUAGE: scala
CODE:
a.onComplete {
    case Success(value) => println(s"Got the callback, value = $value")
    case Failure(e) => e.printStackTrace
}

----------------------------------------

TITLE: Defining a Method with Implicit Parameter List in Scala
DESCRIPTION: Example of using a separate parameter list for implicit parameters in Scala.

LANGUAGE: scala
CODE:
def execute(arg: Int)(using ec: scala.concurrent.ExecutionContext) = ???

----------------------------------------

TITLE: Custom ExecutionContext with ManagedBlocker
DESCRIPTION: Example showing how to use ForkJoinPool.managedBlock with futures for blocking operations.

LANGUAGE: scala
CODE:
Future {
  ForkJoinPool.managedBlock(
    new ManagedBlocker {
       var done = false

       def block(): Boolean = {
         try {
           myLock.lock()
           // ...
         } finally {
          done = true
         }
         true
       }

       def isReleasable: Boolean = done
    }
  )
}

----------------------------------------

TITLE: String Pattern Matching in Scala
DESCRIPTION: Shows how to use the s-interpolator for pattern matching on strings. It extracts parts of a string based on a pattern.

LANGUAGE: scala
CODE:
val input: String = "Alice is 25 years old"

input match
  case s"$name is $age years old" => s"$name's age is $age"
  case _ => "No match"
// Result: "Alice's age is 25"

----------------------------------------

TITLE: Concrete Dog Class Implementation in Scala
DESCRIPTION: Shows how to extend an abstract class and implement its abstract methods.

LANGUAGE: scala
CODE:
class Dog(name: String) extends Pet(name) {
    override def speak() = println("Woof")
    def comeToMaster() = println("Here I come!")
}

----------------------------------------

TITLE: Pattern Matching Function in Scala
DESCRIPTION: Shows how to use pattern matching in a function definition. The function returns a string based on the input integer value.

LANGUAGE: scala
CODE:
def matchTest(x: Int): String = x match
  case 1 => "one"
  case 2 => "two"
  case _ => "other"

matchTest(3)  // returns other
matchTest(1)  // returns one

----------------------------------------

TITLE: String Interpolation in Scala
DESCRIPTION: This snippet shows how to use string interpolation in Scala to embed variables and expressions directly into strings, improving readability and conciseness.

LANGUAGE: scala
CODE:
val firstName = "John"
val mi = 'C'
val lastName = "Doe"
println(s"Name: $firstName $mi $lastName")   // "Name: John C Doe"

LANGUAGE: scala
CODE:
println(s"2 + 2 = ${2 + 2}")   // prints "2 + 2 = 4"

val x = -1
println(s"x.abs = ${x.abs}")   // prints "x.abs = 1"

----------------------------------------

TITLE: Defining a Basic Scala Class
DESCRIPTION: Demonstrates the minimal syntax for defining a class in Scala and creating an instance of it. The class 'User' is defined without any constructor parameters or body.

LANGUAGE: scala
CODE:
class User

val user1 = new User

----------------------------------------

TITLE: Handling Undefined Cases in Partial Functions in Scala
DESCRIPTION: This snippet demonstrates what happens when a partial function is applied to an argument not in its domain, resulting in a MatchError.

LANGUAGE: scala
CODE:
doubledOdds(4)  // Exception in thread "main" scala.MatchError: 4

----------------------------------------

TITLE: Finding Palindromes with Views in Scala
DESCRIPTION: Demonstrates using views to efficiently search for palindromes in a large sequence of words.

LANGUAGE: scala
CODE:
def isPalindrome(x: String) = x == x.reverse
def findPalindrome(s: Seq[String]) = s find isPalindrome
findPalindrome(words.view take 1000000)

----------------------------------------

TITLE: Equivalent Java Hello World Program
DESCRIPTION: The Java equivalent of the Scala Hello World program, showing the similarities and differences between the two languages.

LANGUAGE: java
CODE:
public class Hello {
    public static void main(String[] args) {
        System.out.println("Hello, world");
    }
}

----------------------------------------

TITLE: Iterating with For-Expression in Scala
DESCRIPTION: Illustrates how to use a for-expression to iterate through all elements of an iterator, which is syntactic sugar for foreach.

LANGUAGE: scala
CODE:
for (elem <- it) println(elem)

----------------------------------------

TITLE: Implementing Graph with Path-Dependent Node Type in Scala
DESCRIPTION: Initial implementation of a Graph class containing an inner Node class. The Node class is path-dependent, meaning nodes can only connect to other nodes from the same Graph instance. Includes methods for creating new nodes and connecting them.

LANGUAGE: scala
CODE:
class Graph {
  class Node {
    var connectedNodes: List[Node] = Nil
    def connectTo(node: Node): Unit = {
      if (!connectedNodes.exists(node.equals)) {
        connectedNodes = node :: connectedNodes
      }
    }
  }
  var nodes: List[Node] = Nil
  def newNode: Node = {
    val res = new Node
    nodes = res :: nodes
    res
  }
}

----------------------------------------

TITLE: Implicit Type Inference in Scala
DESCRIPTION: Shows how Scala can automatically infer variable types without explicit declarations, which is the preferred approach for cleaner code.

LANGUAGE: scala
CODE:
val count = 1
val name = "Alvin"

----------------------------------------

TITLE: Multiple Extension Methods
DESCRIPTION: Shows how to define multiple extension methods for a single type.

LANGUAGE: scala
CODE:
extension (c: Circle)
  def circumference: Double = c.radius * math.Pi * 2
  def diameter: Double = c.radius * 2
  def area: Double = math.Pi * c.radius * c.radius

----------------------------------------

TITLE: Creating Project Directory Structure with Shell Commands
DESCRIPTION: Shell commands to create the necessary directory structure for a Scala/sbt project named HelloScalaTest

LANGUAGE: sh
CODE:
mkdir HelloScalaTest
cd HelloScalaTest
mkdir -p src/{main,test}/{java,resources,scala}
mkdir lib project target

----------------------------------------

TITLE: Iterating Through Elements with While Loop in Scala
DESCRIPTION: Demonstrates how to iterate through all elements of an iterator using a while loop and the hasNext/next methods.

LANGUAGE: scala
CODE:
while (it.hasNext)
  println(it.next())

----------------------------------------

TITLE: Mixing in Scala Traits on the Fly
DESCRIPTION: This example shows how to mix in traits with concrete methods when instantiating a class, without modifying the original class definition.

LANGUAGE: scala
CODE:
class Dog(name: String)

val d = new Dog("Fido") with TailWagger with Runner

----------------------------------------

TITLE: Sending POST Request with String Body in Scala 2 using sttp
DESCRIPTION: This snippet demonstrates how to send a POST request with a string body using sttp's quickRequest in Scala 2. It includes importing the necessary package, creating the request with a body, sending it, and printing the response code.

LANGUAGE: scala
CODE:
import sttp.client4.quick._

val response = quickRequest
  .post(uri"https://example.com/")
  .body("Lorem ipsum")
  .send()

println(response.code)
// prints: 200

----------------------------------------

TITLE: Implementing Actor Message Handling
DESCRIPTION: Example of handling messages in an Akka actor using pattern matching on case objects and classes.

LANGUAGE: scala
CODE:
class Speak extends Actor {
  def receive = {
    case StartSpeakingMessage(textToSpeak) =>
        // code to speak the text
    case StopSpeakingMessage =>
        // code to stop speaking
    case PauseSpeakingMessage =>
        // code to pause speaking
    case ResumeSpeakingMessage =>
        // code to resume speaking
  }
}

----------------------------------------

TITLE: Using Java Libraries in Scala
DESCRIPTION: Shows how to import and use Java classes in Scala, demonstrating seamless interoperability with Java libraries.

LANGUAGE: scala
CODE:
import java.time.format.{DateTimeFormatter, FormatStyle}
import java.time.LocalDate
import java.util.Locale.*

@main def FrenchDate: Unit =
  val now = LocalDate.now
  val df = DateTimeFormatter.ofLocalizedDate(FormatStyle.LONG).withLocale(FRANCE)
  println(df.format(now))

----------------------------------------

TITLE: Defining a Simple Scala Method with One Input Parameter
DESCRIPTION: This snippet shows how to define a method named 'double' that takes one integer input parameter and returns its doubled value. It demonstrates the basic syntax for method definition in Scala.

LANGUAGE: scala
CODE:
def double(a: Int) = a * 2

----------------------------------------

TITLE: Parallel Array Reduction Using fold
DESCRIPTION: Demonstrates using fold operation on a parallel array to compute the sum of numbers, showing parallel reduction operation.

LANGUAGE: scala
CODE:
val parArray = (1 to 10000).toArray.par
parArray.fold(0)(_ + _)

----------------------------------------

TITLE: Converting Collections between Scala 2 and Java
DESCRIPTION: This code snippet shows how to convert Scala collections to Java collections and vice versa in Scala 2, using the asJava and asScala extension methods.

LANGUAGE: scala
CODE:
scala> import collection.mutable._
import collection.mutable._

scala> val jul: java.util.List[Int] = ArrayBuffer(1, 2, 3).asJava
val jul: java.util.List[Int] = [1, 2, 3]

scala> val buf: Seq[Int] = jul.asScala
val buf: scala.collection.mutable.Seq[Int] = ArrayBuffer(1, 2, 3)

scala> val m: java.util.Map[String, Int] = HashMap("abc" -> 1, "hello" -> 2).asJava
val m: java.util.Map[String,Int] = {abc=1, hello=2}

----------------------------------------

TITLE: Parallel String Transformation Using map
DESCRIPTION: Example of using parallel map to transform a collection of strings to uppercase, showing parallel collection type inference and transformation.

LANGUAGE: scala
CODE:
val lastNames = List("Smith","Jones","Frankenstein","Bach","Jackson","Rodin").par
lastNames.map(_.toUpperCase)

----------------------------------------

TITLE: Declaring Variables in Scala
DESCRIPTION: This snippet shows how variables are declared in Scala using val for immutable variables and var for mutable variables. It demonstrates Scala's type inference capability.

LANGUAGE: scala
CODE:
val s = "hello"   // immutable
var i = 42        // mutable

val p = new Person("Joel Fleischman")

----------------------------------------

TITLE: Generating Collections with Factory
DESCRIPTION: Implements a generator for arbitrary collection types using the Factory trait, allowing users to choose the precise collection type to produce.

LANGUAGE: scala
CODE:
import scala.collection.Factory

implicit def collection[CC[_], A](implicit
  genA: Gen[A],
  factory: Factory[A, CC[A]]
): Gen[CC[A]] =
  new Gen[CC[A]] {
    def get: CC[A] = {
      val lazyElements =
        LazyList.unfold(()) { _ =>
          if (Random.nextInt(100) < 10) None
          else Some((genA.get, ()))
        }
      factory.fromSpecific(lazyElements)
    }
  }

----------------------------------------

TITLE: Implementing a While Loop Using By-name Parameters in Scala 2
DESCRIPTION: This example shows how to implement a while loop using by-name parameters in Scala 2. The 'whileLoop' function takes two by-name parameters: a condition and a body. It recursively calls itself until the condition is false.

LANGUAGE: scala
CODE:
def whileLoop(condition: => Boolean)(body: => Unit): Unit =
  if (condition) {
    body
    whileLoop(condition)(body)
  }

var i = 2

whileLoop (i > 0) {
  println(i)
  i -= 1
}  // prints 2 1

----------------------------------------

TITLE: Type Inference Example in Scala
DESCRIPTION: Demonstrates proper usage of type inference for private fields and local variables where the type is evident from the value.

LANGUAGE: scala
CODE:
private val name = "Daniel"

----------------------------------------

TITLE: Testing Asynchronous Methods with MUnit
DESCRIPTION: Demonstrates how to write MUnit tests for asynchronous operations using for-comprehension to handle multiple Future operations. The test verifies the square function with both positive and negative inputs.

LANGUAGE: scala
CODE:
// Import the global execution context, required to call async methods
import scala.concurrent.ExecutionContext.Implicits.global

class AsyncMathLibTests extends munit.FunSuite {
  test("square") {
    for {
      squareOf3 <- AsyncMathLib.square(3)
      squareOfMinus4 <- AsyncMathLib.square(-4)
    } yield {
      assertEquals(squareOf3, 9)
      assertEquals(squareOfMinus4, 16)
    }
  }
}

LANGUAGE: scala
CODE:
// Import the global execution context, required to call async methods
import scala.concurrent.ExecutionContext.Implicits.global

class AsyncMathLibTests extends munit.FunSuite:
  test("square") {
    for
      squareOf3 <- AsyncMathLib.square(3)
      squareOfMinus4 <- AsyncMathLib.square(-4)
    yield
      assertEquals(squareOf3, 9)
      assertEquals(squareOfMinus4, 16)
  }

----------------------------------------

TITLE: Creating Basic Day of Week Enumeration in Scala
DESCRIPTION: Demonstrates how to create an enumeration for days of the week using a sealed trait and case objects.

LANGUAGE: scala
CODE:
sealed trait DayOfWeek
case object Sunday extends DayOfWeek
case object Monday extends DayOfWeek
case object Tuesday extends DayOfWeek
case object Wednesday extends DayOfWeek
case object Thursday extends DayOfWeek
case object Friday extends DayOfWeek
case object Saturday extends DayOfWeek

----------------------------------------

TITLE: Implementing Lazy Map in Scala
DESCRIPTION: Demonstrates how to implement a lazy map operation on an Iterable collection. The function f is applied to elements only as they are demanded.

LANGUAGE: scala
CODE:
def lazyMap[T, U](iter: Iterable[T], f: T => U) = new Iterable[U] {
  def iterator = iter.iterator.map(f)
}

LANGUAGE: scala
CODE:
def lazyMap[T, U](iter: Iterable[T], f: T => U) = new Iterable[U]:
  def iterator = iter.iterator.map(f)

----------------------------------------

TITLE: Defining Variance Classes in Scala
DESCRIPTION: Demonstrates the basic syntax for declaring covariant, contravariant, and invariant classes using type parameters.

LANGUAGE: scala
CODE:
class Foo[+A] // A covariant class
class Bar[-A] // A contravariant class
class Baz[A]  // An invariant class

----------------------------------------

TITLE: Accessing JSON Array Elements in Scala
DESCRIPTION: Shows how to access elements in a JSON array using index notation. The example demonstrates accessing multiple elements from a pets array.

LANGUAGE: scala
CODE:
val pets: ujson.Value = json("pets")

val firstPet: String = pets(0).str
val secondPet: String = pets(1).str

println(s"The pets are $firstPet and $secondPet")
// prints: The pets are Toolkitty and Scaniel

----------------------------------------

TITLE: Using Filter with Anonymous Functions in Scala
DESCRIPTION: Demonstrates using the filter method with anonymous functions to create new lists based on conditions.

LANGUAGE: scala
CODE:
val x = ints.filter(_ > 5)

LANGUAGE: scala
CODE:
val x = ints.filter(_ < 5)

LANGUAGE: scala
CODE:
val x = ints.filter(_ % 2 == 0)

----------------------------------------

TITLE: Defining Enumerations in Scala 3
DESCRIPTION: Demonstrates how to model data alternatives using enums in Scala 3 for pizza attributes like crust size, type and toppings.

LANGUAGE: scala
CODE:
enum CrustSize:
  case Small, Medium, Large

enum CrustType:
  case Thin, Thick, Regular

enum Topping:
  case Cheese, Pepperoni, BlackOlives, GreenOlives, Onions

----------------------------------------

TITLE: Using Named Arguments with Default Values in Scala
DESCRIPTION: This snippet demonstrates how named arguments can be used with methods that have default parameter values. It shows correct usage and an error case where positional arguments are used after named arguments.

LANGUAGE: scala
CODE:
def printFullName(first: String, middle: String = "Q.", last: String): Unit =
  println(s"$first $middle $last")

printFullName(first = "John", last = "Public")  // Prints "John Q. Public"
printFullName("John", last = "Public")  // Prints "John Q. Public"
printFullName("John", middle = "Quincy", "Public")  // Prints "John Quincy Public"
printFullName(last = "Public", first = "John")  // Prints "John Q. Public"
printFullName(last = "Public", "John")  // error: positional after named argument

----------------------------------------

TITLE: Complex Pattern Matching with Planet Data
DESCRIPTION: Shows pattern matching on a list of tuples containing planet data with specific case handling.

LANGUAGE: scala
CODE:
val planets =
  List(("Mercury", 57.9), ("Venus", 108.2), ("Earth", 149.6),
       ("Mars", 227.9), ("Jupiter", 778.3))
planets.foreach {
  case ("Earth", distance) =>
    println(s"Our planet is $distance million kilometers from the sun")
  case _ =>
}

----------------------------------------

TITLE: Contact Information Validation using Regex Patterns in Scala
DESCRIPTION: Demonstrates using regular expressions in pattern matching to validate and process different types of contact information (email and phone numbers). Uses complex regex patterns with multiple capture groups.

LANGUAGE: scala
CODE:
def saveContactInformation(contact: String): Unit = {
  import scala.util.matching.Regex

  val emailPattern: Regex = """^(\w+)@(\w+(.\w+)+)$""".r
  val phonePattern: Regex = """^(\d{3}-\d{3}-\d{4})$""".r

  contact match {
    case emailPattern(localPart, domainName, _) => 
      println(s"Hi $localPart, we have saved your email address.")
    case phonePattern(phoneNumber) => 
      println(s"Hi, we have saved your phone number $phoneNumber.")
    case _ => 
      println("Invalid contact information, neither an email address nor phone number.")
  }
}

----------------------------------------

TITLE: Supporting Collection-like Types with IsIterable
DESCRIPTION: Extends the sumBy operation to work with collection-like types such as String and Array using IsIterable.

LANGUAGE: scala
CODE:
import scala.collection.generic.IsIterable

class SumByOperation[A](coll: IterableOnce[A]) {
  def sumBy[B](f: A => B)(implicit num: Numeric[B]): B = ... // same as before
}

implicit def SumByOperation[Repr](coll: Repr)(implicit it: IsIterable[Repr]): SumByOperation[it.A] =
  new SumByOperation[it.A](it(coll))

----------------------------------------

TITLE: Using Generic Array Creation Method
DESCRIPTION: This snippet demonstrates the usage of the evenElems method to create arrays of different types using implicit ClassTag.

LANGUAGE: scala
CODE:
evenElems(Vector(1, 2, 3, 4, 5))
evenElems(Vector("this", "is", "a", "test", "run"))

----------------------------------------

TITLE: Explicit Type Declaration in Scala
DESCRIPTION: This snippet demonstrates how to explicitly declare variable types in Scala, even though it's usually not necessary due to type inference.

LANGUAGE: scala
CODE:
val s: String = "hello"
var i: Int = 42

----------------------------------------

TITLE: Implementing WebSocket Communication with sttp
DESCRIPTION: Shows how to establish and use WebSocket connections using sttp's WebSocket support. The example demonstrates sending and receiving text messages through a WebSocket connection with async handling.

LANGUAGE: scala
CODE:
import scala.concurrent.duration.Duration
import scala.concurrent.{Await, Future}
import scala.concurrent.ExecutionContext.Implicits.global

import sttp.client4._
import sttp.ws.WebSocket

val asyncBackend = DefaultFutureBackend()

def useWebSocket(ws: WebSocket[Future]): Future[Unit] =
  for {
    _ <- ws.sendText("Hello")
    text <- ws.receiveText()
  } yield {
    println(text)
  }

val response = quickRequest
  .get(uri"wss://ws.postman-echo.com/raw")
  .response(asWebSocketAlways(useWebSocket))
  .send(asyncBackend)

Await.result(response, Duration.Inf)
// prints: Hello

----------------------------------------

TITLE: Using foldLeft with Multiple Parameter Lists in Scala
DESCRIPTION: Demonstration of using the foldLeft method to sum a list of numbers.

LANGUAGE: scala
CODE:
val numbers = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
val res = numbers.foldLeft(0)((m, n) => m + n)
println(res) // 55

----------------------------------------

TITLE: Implementing Message Types with Case Objects
DESCRIPTION: Example of defining message types using case objects and case classes for an Alexa-like speaking system.

LANGUAGE: scala
CODE:
case class StartSpeakingMessage(textToSpeak: String)
case object StopSpeakingMessage
case object PauseSpeakingMessage
case object ResumeSpeakingMessage

----------------------------------------

TITLE: Defining Enumerations in Scala 3
DESCRIPTION: Examples of defining simple enumerations in Scala 3.

LANGUAGE: scala
CODE:
enum CrustSize:
  case Small, Medium, Large

enum CrustType:
  case Thin, Thick, Regular

enum Topping:
  case Cheese, Pepperoni, BlackOlives, GreenOlives, Onions

----------------------------------------

TITLE: Demonstrating Type Inference for Anonymous Function Parameters in Scala
DESCRIPTION: This snippet illustrates how Scala can infer types for anonymous function parameters in certain contexts, such as when passed as arguments to higher-order functions like 'map'.

LANGUAGE: scala
CODE:
Seq(1, 3, 4).map(x => x * 2)  // List(2, 6, 8)

----------------------------------------

TITLE: Type Parameter Information Using Implicit TypeTag
DESCRIPTION: Implements a method that prints type argument information using an implicit TypeTag parameter.

LANGUAGE: scala
CODE:
import scala.reflect.runtime.universe._

def paramInfo[T](x: T)(implicit tag: TypeTag[T]): Unit = {
  val targs = tag.tpe match { case TypeRef(_, _, args) => args }
  println(s"type of $x has type arguments $targs")
}

----------------------------------------

TITLE: Testing File Exception in Scala 3
DESCRIPTION: Shows how to test for NoSuchFileException when attempting to read a non-existent file using MUnit in Scala 3 syntax. Demonstrates the usage of intercept assertion with Scala 3's new syntax.

LANGUAGE: scala
CODE:
import java.nio.file.NoSuchFileException

class FileTests extends munit.FunSuite:
  test("read missing file") {
    val missingFile = os.pwd / "missing.txt"
    intercept[NoSuchFileException] {
      // the code that should throw an exception
      os.read(missingFile)
    }
  }

----------------------------------------

TITLE: Reassigning Val in Scala REPL
DESCRIPTION: This snippet shows the error that occurs when attempting to reassign a val (immutable) variable in the Scala REPL.

LANGUAGE: scala
CODE:
scala> val a = 'a'
a: Char = a

scala> a = 'b'
<console>:12: error: reassignment to val
       a = 'b'
         ^

----------------------------------------

TITLE: Implementing Order Class with Customer Information in Scala
DESCRIPTION: This snippet defines an Order class that contains a list of pizzas and customer information. It includes methods for adding and removing pizzas, and placeholders for price calculations.

LANGUAGE: scala
CODE:
class Order (
    val pizzas: ArrayBuffer[Pizza],
    var customer: Customer
) {

    def addPizza(p: Pizza): Unit = pizzas += p
    def removePizza(p: Pizza): Unit = pizzas -= p

    // need to implement these
    def getBasePrice(): Int = ???
    def getTaxes(): Int = ???
    def getTotalPrice(): Int = ???

}

----------------------------------------

TITLE: Implementing Reduce Function in Scala
DESCRIPTION: Example of using reduce to combine list elements, including a helper method for demonstration.

LANGUAGE: scala
CODE:
def add(x: Int, y: Int): Int = {
    val theSum = x + y
    println(s"received $x and $y, their sum is $theSum")
    theSum
}

val a = List(1,2,3,4)
a.reduce(add)

----------------------------------------

TITLE: Capitalizing String List with Scala for Expression
DESCRIPTION: This example shows how to use a Scala for expression to create a new list of capitalized strings from a list of lowercase strings.

LANGUAGE: scala
CODE:
val names = List("adam", "david", "frank")
val ucNames = for (name <- names) yield name.capitalize

----------------------------------------

TITLE: Implementing a Printf Macro in Scala
DESCRIPTION: Provides a complete implementation of a 'printf' macro that validates and applies format strings at compile-time.

LANGUAGE: scala
CODE:
import scala.reflect.macros.Context
import scala.collection.mutable.{ListBuffer, Stack}

object Macros {
  def printf(format: String, params: Any*): Unit = macro printf_impl

  def printf_impl(c: Context)(format: c.Expr[String], params: c.Expr[Any]*): c.Expr[Unit] = {
    import c.universe._
    val Literal(Constant(s_format: String)) = format.tree

    val evals = ListBuffer[ValDef]()
    def precompute(value: Tree, tpe: Type): Ident = {
      val freshName = TermName(c.fresh("eval$"))
      evals += ValDef(Modifiers(), freshName, TypeTree(tpe), value)
      Ident(freshName)
    }

    val paramsStack = Stack[Tree]((params map (_.tree)): _*)
    val refs = s_format.split("(?<=%[\\w%])|(?=%[\\w%])") map {
      case "%d" => precompute(paramsStack.pop, typeOf[Int])
      case "%s" => precompute(paramsStack.pop, typeOf[String])
      case "%%" => Literal(Constant("%"))
      case part => Literal(Constant(part))
    }

    val stats = evals ++ refs.map(ref => reify(print(c.Expr[Any](ref).splice)).tree)
    c.Expr[Unit](Block(stats.toList, Literal(Constant(()))))
  }
}

----------------------------------------

TITLE: Sample ScalaCheck Test Implementation
DESCRIPTION: Example of writing a ScalaCheck-based test for the Scala test suite, demonstrating property-based testing of list concatenation.

LANGUAGE: scala
CODE:
import org.scalacheck._
import Prop._

object Test {
	val prop_ConcatLists = property{ (l1: ListInt, l2: ListInt) =>
		l1.size + l2.size == (l1 ::: l2).size
	}

	val tests = List(("prop_ConcatLists", prop_ConcatLists))
}

----------------------------------------

TITLE: Using dropWhile on Iterator in Scala
DESCRIPTION: Shows how to use the dropWhile method to find the first element of an iterator that satisfies a certain condition.

LANGUAGE: scala
CODE:
val it = Iterator("a", "number", "of", "words")
it dropWhile (_.length < 2)

----------------------------------------

TITLE: Illustrating Type Inference for Method Return Types in Scala
DESCRIPTION: This example demonstrates how Scala can infer the return type of a method. The compiler deduces that the 'squareOf' method returns an Int based on its implementation.

LANGUAGE: scala
CODE:
def squareOf(x: Int) = x * x

----------------------------------------

TITLE: Executing Basic Expressions in Scala REPL
DESCRIPTION: This snippet shows how to execute basic arithmetic expressions in the Scala REPL. It demonstrates automatic variable assignment (res0, res1) for expression results.

LANGUAGE: scala
CODE:
scala> 1 + 1
val res0: Int = 2

scala> 2 + 2
val res1: Int = 4

----------------------------------------

TITLE: Complete Try-Catch-Finally Pattern in Scala
DESCRIPTION: Shows the full try/catch/finally structure including handling multiple exception types and using a finally block for resource cleanup. Demonstrates handling specific exceptions and catching general Throwable cases.

LANGUAGE: scala
CODE:
try {
    // your scala code here
} 
catch {
    case foo: FooException => handleFooException(foo)
    case bar: BarException => handleBarException(bar)
    case _: Throwable => println("Got some other kind of Throwable exception")
} finally {
    // your scala code here, such as closing a database connection
    // or file handle
}

----------------------------------------

TITLE: Macro Entry Point Definition
DESCRIPTION: Demonstrates how to define the entry point for a macro using inline def and splice syntax.

LANGUAGE: scala
CODE:
inline def inspect(inline x: Any): Any = ${ inspectCode('x) }

----------------------------------------

TITLE: Implementing Times Method with Implicit Class in Scala
DESCRIPTION: Demonstrates creating an implicit class IntWithTimes that adds a 'times' method to Int values. The implementation allows executing a given function a specified number of times.

LANGUAGE: scala
CODE:
object Helpers {
  implicit class IntWithTimes(x: Int) {
    def times[A](f: => A): Unit = {
      def loop(current: Int): Unit =
        if(current > 0) {
          f
          loop(current - 1)
        }
      loop(x)
    }
  }
}

----------------------------------------

TITLE: Demonstrating Lazy Evaluation with Views in Scala
DESCRIPTION: Illustrates the step-by-step process of creating a view, applying transformations, and forcing the result, showing how lazy evaluation works.

LANGUAGE: scala
CODE:
val vv = v.view
vv.map(_ + 1)
res13.map(_ * 2)
res14.to(Vector)

----------------------------------------

TITLE: Using If as a Method Body in Java and Scala
DESCRIPTION: Demonstrates how to use if statements as method bodies in Java and Scala.

LANGUAGE: java
CODE:
public int min(int a, int b) {
  return (a < b) ? a : b;
}

LANGUAGE: scala
CODE:
def min(a: Int, b: Int): Int =
  if a < b then a else b

----------------------------------------

TITLE: Using Named Parameters in Scala Constructor
DESCRIPTION: Demonstrates how to use named parameters when creating an instance of a class with default constructor values. This allows for specifying only certain parameters by name.

LANGUAGE: scala
CODE:
class Point(var x: Int = 0, var y: Int = 0)
val point2 = new Point(y = 2)
println(point2.y)  // wyświetla 2

----------------------------------------

TITLE: Creating Basic MUnit Test Suite in Scala 3
DESCRIPTION: Shows the Scala 3 syntax for creating a test suite with MUnit, using significant indentation.

LANGUAGE: scala
CODE:
package example

class MyTests extends munit.FunSuite:
  test("sum of two integers") {
    val obtained = 2 + 2
    val expected = 4
    assertEquals(obtained, expected)
  }

----------------------------------------

TITLE: Implementing Variance Types in Scala 3
DESCRIPTION: Shows implementation of invariant, covariant, and contravariant type examples using Pipeline, Producer, and Consumer traits.

LANGUAGE: scala
CODE:
// an example of an invariant type
trait Pipeline[T]:
  def process(t: T): T

// an example of a covariant type
trait Producer[+T]:
  def make: T

// an example of a contravariant type
trait Consumer[-T]:
  def take(t: T): Unit

----------------------------------------

TITLE: Traversing Map Elements in Scala
DESCRIPTION: Shows different ways to iterate over Map elements using for comprehension and foreach with pattern matching.

LANGUAGE: scala
CODE:
val ratings = Map(
    "Lady in the Water"-> 3.0, 
    "Snakes on a Plane"-> 4.0,
    "You, Me and Dupree"-> 3.5
)

for ((k,v) <- ratings) println(s"key: $k, value: $v")

ratings.foreach {
    case(movie, rating) => println(s"key: $movie, value: $rating")
}

----------------------------------------

TITLE: Creating a Multi-Language Greeting Function Factory in Scala
DESCRIPTION: This snippet demonstrates a more complex example where a method returns different greeting functions based on the specified language.

LANGUAGE: scala
CODE:
def createGreetingFunction(desiredLanguage: String): String => Unit =
  val englishGreeting = (name: String) => println(s"Hello, $name")
  val frenchGreeting = (name: String) => println(s"Bonjour, $name")
  desiredLanguage match
    case "english" => englishGreeting
    case "french" => frenchGreeting

----------------------------------------

TITLE: Using ClassMirror for Constructor Invocation in Scala
DESCRIPTION: Shows how to create a ClassMirror and use it to reflectively invoke a class constructor.

LANGUAGE: scala
CODE:
scala> case class C(x: Int)
defined class C

scala> val m = ru.runtimeMirror(getClass.getClassLoader)
m: scala.reflect.runtime.universe.Mirror = JavaMirror ...

scala> val classC = ru.typeOf[C].typeSymbol.asClass
classC: scala.reflect.runtime.universe.Symbol = class C

scala> val cm = m.reflectClass(classC)
cm: scala.reflect.runtime.universe.ClassMirror = class mirror for C (bound to null)

scala> val ctorC = ru.typeOf[C].decl(ru.termNames.CONSTRUCTOR).asMethod
ctorC: scala.reflect.runtime.universe.MethodSymbol = constructor C

scala> val ctorm = cm.reflectConstructor(ctorC)
ctorm: scala.reflect.runtime.universe.MethodMirror = constructor mirror for C.<init>(x: scala.Int): C (bound to null)

scala> ctorm(2)
res0: Any = C(2)

----------------------------------------

TITLE: Implementing Macro Bundles in Scala
DESCRIPTION: This snippet demonstrates how to create a macro bundle class and define macro implementations within it. It shows both monomorphic and polymorphic macro implementations, as well as how to reference these implementations in a separate object.

LANGUAGE: scala
CODE:
import scala.reflect.macros.blackbox.Context

class Impl(val c: Context) {
  def mono = c.literalUnit
  def poly[T: c.WeakTypeTag] = c.literal(c.weakTypeOf[T].toString)
}

object Macros {
  def mono = macro Impl.mono
  def poly[T] = macro Impl.poly[T]
}

----------------------------------------

TITLE: Inspecting Runtime Types using TypeTags in Scala
DESCRIPTION: Demonstrates how to use TypeTags to inspect runtime types, including generic types. It shows how to obtain a TypeTag for a List[Int] and access its type information.

LANGUAGE: scala
CODE:
import scala.reflect.runtime.{universe => ru}
val l = List(1,2,3)
def getTypeTag[T: ru.TypeTag](obj: T) = ru.typeTag[T]
val theType = getTypeTag(l).tpe
val decls = theType.decls.take(10)

----------------------------------------

TITLE: Implementing Lazy Map in Scala
DESCRIPTION: Demonstrates a non-strict implementation of the map operation using a custom Iterable.

LANGUAGE: scala
CODE:
def lazyMap[T, U](coll: Iterable[T], f: T => U) = new Iterable[U] {
  def iterator = coll.iterator map f
}

----------------------------------------

TITLE: Macro with Type Parameters
DESCRIPTION: Example showing how to create a macro that handles type parameters using Type[T] and Expr[T].

LANGUAGE: scala
CODE:
inline def logged[T](inline x: T): T = ${ loggedCode('x)  }

def loggedCode[T](x: Expr[T])(using Type[T], Quotes): Expr[T] = ...

----------------------------------------

TITLE: Defining Extension Method in Scala 3
DESCRIPTION: Shows how to define an extension method for the Circle class in Scala 3.

LANGUAGE: scala
CODE:
extension (c: Circle)
  def circumference: Double = c.radius * math.Pi * 2

----------------------------------------

TITLE: Control Structures in Scala and Python
DESCRIPTION: Comparison of if statements, for loops, and while loops in Scala and Python.

LANGUAGE: python
CODE:
if x < 0:
    print("negative")
elif x == 0:
    print("zero")
else:
    print("positive")

for i in range(0,3):
    print(i)

while i < 3:
    print(i)
    i += 1

LANGUAGE: scala
CODE:
if x < 0 then
  println("negative")
else if x == 0 then
  println("zero")
else
  println("positive")

for i <- 0 until 3 do println(i)

var i = 1
while i < 3 do
  println(i)
  i += 1

----------------------------------------

TITLE: Mutable Queue Operations in Scala
DESCRIPTION: Shows common operations on mutable Queues including enqueuing and dequeuing elements.

LANGUAGE: scala
CODE:
val queue = new scala.collection.mutable.Queue[String]
queue += "a"
queue ++= List("b", "c")
queue.dequeue

----------------------------------------

TITLE: Working with ListBuffer in Scala
DESCRIPTION: Shows how to use a mutable ListBuffer for building lists with efficient append operations.

LANGUAGE: scala
CODE:
val buf = scala.collection.mutable.ListBuffer.empty[Int]
buf += 1
buf += 10
buf.toList

----------------------------------------

TITLE: Implementing Palindrome Search in Scala
DESCRIPTION: Defines functions to check for palindromes and find palindromes in a sequence, demonstrating the use of views for efficient searching.

LANGUAGE: scala
CODE:
def isPalindrome(x: String) = x == x.reverse
def findPalindrome(s: Seq[String]) = s.find(isPalindrome)
val palindromes = findPalindrome(words.view.take(1000000))

----------------------------------------

TITLE: Creating a Method that Returns a Future in Scala
DESCRIPTION: Shows how to create a method that returns a Future, simulating a slow-running operation.

LANGUAGE: scala
CODE:
def slowlyDouble(x: Int, delay: Long): Future[Int] = Future {
  sleep(delay)
  x * 2
}

----------------------------------------

TITLE: Defining Single-Line For Loops in Java and Scala
DESCRIPTION: Shows how to define single-line for loops in Java and Scala.

LANGUAGE: java
CODE:
for (int i: ints) {
  System.out.println(i);
}

LANGUAGE: scala
CODE:
//preferred
for i <- ints do println(i)

// also available
for (i <- ints) println(i)

----------------------------------------

TITLE: Extending a Scala Trait in a Class
DESCRIPTION: This example shows how to extend a trait in a Scala class, implementing the required abstract method.

LANGUAGE: scala
CODE:
class Dog(name: String) extends Pet {
    def comeToMaster(): Unit = println("Woo-hoo, I'm coming!")
}

----------------------------------------

TITLE: Defining Extension Method in Scala 3
DESCRIPTION: Shows how to define an extension method for the Circle class in Scala 3.

LANGUAGE: scala
CODE:
extension (c: Circle)
  def circumference: Double = c.radius * math.Pi * 2

----------------------------------------

TITLE: Defining Basic Type Hierarchy in Scala
DESCRIPTION: Demonstrates the basic type hierarchy used to explain variance concepts with Item, Buyable, and Book traits.

LANGUAGE: scala
CODE:
trait Item { def productNumber: String }
trait Buyable extends Item { def price: Int }
trait Book extends Buyable { def isbn: String }

----------------------------------------

TITLE: Testing Exception Message in Scala
DESCRIPTION: Shows how to capture and verify the exception message using intercept assertion. This example demonstrates how to perform additional assertions on the caught exception.

LANGUAGE: scala
CODE:
val exception = intercept[NoSuchFileException](os.read(missingFile))
assert(clue(exception.getMessage).contains("missing.txt"))

----------------------------------------

TITLE: Using Singleton Logger in Project
DESCRIPTION: Demonstrates how to import and use the singleton logger object's methods in another class.

LANGUAGE: scala
CODE:
import logging.Logger.info

class Project(name: String, daysToComplete: Int)

class Test {
  val project1 = new Project("TPS Reports", 1)
  val project2 = new Project("Website redesign", 5)
  info("Created projects")  // Prints "INFO: Created projects"
}

----------------------------------------

TITLE: Using Compile-Time Mirrors in Scala Macros
DESCRIPTION: Illustrates the use of compile-time mirrors in a Scala macro to load symbols by name and create an AST.

LANGUAGE: scala
CODE:
import scala.reflect.macros.Context

case class Location(filename: String, line: Int, column: Int)

object Macros {
  def currentLocation: Location = macro impl

  def impl(c: Context): c.Expr[Location] = {
    import c.universe._
    val pos = c.macroApplication.pos
    val clsLocation = c.mirror.staticModule("Location") // get symbol of "Location" object
    c.Expr(Apply(Ident(clsLocation), List(Literal(Constant(pos.source.path)), Literal(Constant(pos.line)), Literal(Constant(pos.column)))))
  }
}

----------------------------------------

TITLE: Removing Elements from ArrayBuffer in Scala
DESCRIPTION: This snippet demonstrates how to remove elements from an ArrayBuffer using various methods.

LANGUAGE: scala
CODE:
nums -= 9
nums -= 7 -= 8
nums --= Array(5, 6)

----------------------------------------

TITLE: Using Views for Efficient Transformations in Scala
DESCRIPTION: Shows how to use views to avoid intermediate collection creation when applying multiple transformations.

LANGUAGE: scala
CODE:
val v = Vector(1 to 10: _*)
(v.view map (_ + 1) map (_ * 2)).force

----------------------------------------

TITLE: Iterating Over Scala Lists with foreach
DESCRIPTION: Demonstrates the use of foreach method to iterate over all elements in a list for side effects like printing.

LANGUAGE: scala
CODE:
names.foreach(println)

----------------------------------------

TITLE: Creating a Basic Package in Scala
DESCRIPTION: Demonstrates how to create a simple package and class in Scala. This is the most basic way to declare a package.

LANGUAGE: scala
CODE:
package users

class User

----------------------------------------

TITLE: Implementing a Recursive Pure Function in Scala 3
DESCRIPTION: This example demonstrates the same sum function as above, but using Scala 3 syntax with significant indentation.

LANGUAGE: scala
CODE:
def sum(xs: List[Int]): Int = xs match
  case Nil => 0
  case head :: tail => head + sum(tail)

----------------------------------------

TITLE: Testing File Exception in Scala 2
DESCRIPTION: Demonstrates how to test for NoSuchFileException when attempting to read a non-existent file using MUnit in Scala 2. Uses the intercept assertion to verify the exception is thrown.

LANGUAGE: scala
CODE:
import java.nio.file.NoSuchFileException

class FileTests extends munit.FunSuite {
  test("read missing file") {
    val missingFile = os.pwd / "missing.txt"
    
    intercept[NoSuchFileException] { 
      os.read(missingFile)
    }
  }
}

----------------------------------------

TITLE: Defining Class Inheritance in Java and Scala
DESCRIPTION: Demonstrates how to define class inheritance in Java and Scala.

LANGUAGE: java
CODE:
class Dog extends Animal implements HasLegs, HasTail

LANGUAGE: scala
CODE:
class Dog extends Animal, HasLegs, HasTail

----------------------------------------

TITLE: Defining Classes in Python and Scala
DESCRIPTION: Shows how to define classes with constructors and methods in Python and Scala.

LANGUAGE: python
CODE:
class Person(object):
  def __init__(self, name):
    self.name = name

  def speak(self):
    print(f'Hello, my name is {self.name}')

LANGUAGE: scala
CODE:
class Person (var name: String):
  def speak() = println(s"Hello, my name is $name")

----------------------------------------

TITLE: Implementing CustomerID Extractor in Scala 3
DESCRIPTION: Shows the Scala 3 syntax version of the CustomerID extractor object, using the new significant indentation syntax and simplified control structures.

LANGUAGE: scala
CODE:
import scala.util.Random

object CustomerID:

  def apply(name: String) = s"$name--${Random.nextLong()}"

  def unapply(customerID: String): Option[String] =
    val stringArray: Array[String] = customerID.split("--")
    if stringArray.tail.nonEmpty then Some(stringArray.head) else None

val customer1ID = CustomerID("Sukyoung")  // Sukyoung--23098234908
customer1ID match
  case CustomerID(name) => println(name)  // prints Sukyoung
  case _ => println("Could not extract a CustomerID")

----------------------------------------

TITLE: Nesting Packages in Scala 2
DESCRIPTION: Shows how to nest packages within each other in Scala 2. This method provides greater control over scope and encapsulation.

LANGUAGE: scala
CODE:
package users {
  package administrators {
    class NormalUser
  }
  package normalusers {
    class NormalUser
  }
}

----------------------------------------

TITLE: Using Extension Method
DESCRIPTION: Shows how to use the extension method once defined.

LANGUAGE: scala
CODE:
aCircle.circumference

----------------------------------------

TITLE: Creating a Scala Compiler Plugin Descriptor
DESCRIPTION: This XML snippet shows how to create a plugin descriptor file (scalac-plugin.xml) that specifies the name and entry point of a Scala compiler plugin.

LANGUAGE: xml
CODE:
<plugin>
  <name>divbyzero</name>
  <classname>localhost.DivByZero</classname>
</plugin>

----------------------------------------

TITLE: List Lifting with Splice Operators in Scala
DESCRIPTION: Demonstrates lifting and splicing of List elements in quasiquotes.

LANGUAGE: scala
CODE:
val ints = List(1, 2, 3)
val f123 = q"f(..$ints)"

val intss = List(List(1, 2, 3), List(4, 5), List(6))
val f123456 = q"f(...$intss)"

----------------------------------------

TITLE: First Version of Capped Collection Implementation
DESCRIPTION: Initial implementation of a capped sequence that holds a maximum number of elements, extending immutable.Iterable[A].

LANGUAGE: scala
CODE:
class Capped1[A] private (val capacity: Int, val length: Int, offset: Int, elems: Array[Any])
  extends immutable.Iterable[A] { self =>

  def this(capacity: Int) =
    this(capacity, length = 0, offset = 0, elems = Array.ofDim(capacity))

  def appended[B >: A](elem: B): Capped1[B] = {
    val newElems = Array.ofDim[Any](capacity)
    Array.copy(elems, 0, newElems, 0, capacity)
    val (newOffset, newLength) =
      if (length == capacity) {
        newElems(offset) = elem
        ((offset + 1) % capacity, length)
      } else {
        newElems(length) = elem
        (offset, length + 1)
      }
    new Capped1[B](capacity, newLength, newOffset, newElems)
  }

  @inline def :+ [B >: A](elem: B): Capped1[B] = appended(elem)

  def apply(i: Int): A = elems((i + offset) % capacity).asInstanceOf[A]

  def iterator: Iterator[A] = new AbstractIterator[A] {
    private var current = 0
    def hasNext = current < self.length
    def next(): A = {
      val elem = self(current)
      current += 1
      elem
    }
  }

  override def className = "Capped1"
}

----------------------------------------

TITLE: Importing Mutable Collections in Scala
DESCRIPTION: Example showing how to import mutable collections while maintaining access to immutable ones by default

LANGUAGE: scala
CODE:
import scala.collection.mutable

----------------------------------------

TITLE: Using Partial Functions with collect Method in Scala
DESCRIPTION: This snippet shows how to use a partial function as an argument to the collect method on a List, transforming odd numbers.

LANGUAGE: scala
CODE:
val res = List(1, 2, 3).collect({ case i if i % 2 == 1 => i * 2 }) // List(2, 6)

----------------------------------------

TITLE: String Manipulation and Conversion Operations in Scala
DESCRIPTION: Demonstrates various string operations including reverse, map, drop, and slice methods, as well as conversion of String to Seq[Char]. Shows how implicit conversions enable sequence operations on strings through WrappedString and StringOps.

LANGUAGE: scala
CODE:
val str = "hello"
val str: java.lang.String = hello

str.reverse
val res6: String = olleh

str.map(_.toUpper)
val res7: String = HELLO

str.drop(3)
val res8: String = lo

str.slice(1, 4)
val res9: String = ell

val s: Seq[Char] = str
val s: Seq[Char] = hello

----------------------------------------

TITLE: Invalid Trait Constructor Example in Scala
DESCRIPTION: Demonstrates that traits cannot have constructor parameters in Scala.

LANGUAGE: scala
CODE:
// this won't compile
trait Animal(name: String)

----------------------------------------

TITLE: Class and Object Naming in Scala
DESCRIPTION: Demonstrates proper naming conventions for classes and objects using upper camel case.

LANGUAGE: scala
CODE:
class MyFairLady

object ast {
  sealed trait Expr
  case class Plus(e1: Expr, e2: Expr) extends Expr
}

----------------------------------------

TITLE: Defining Circle Class in Scala
DESCRIPTION: Basic case class definition for a Circle with x, y coordinates and radius.

LANGUAGE: scala
CODE:
case class Circle(x: Double, y: Double, radius: Double)

----------------------------------------

TITLE: Creating File Utilities with Scala Object
DESCRIPTION: Example of a File utilities singleton object with methods for file operations using Try for error handling.

LANGUAGE: scala
CODE:
object FileUtils {
    def readTextFileAsString(filename: String): Try[String] = ...
    def copyFile(srcFile: File, destFile: File): Try[Boolean] = ...
    def readFileToByteArray(file: File): Try[Array[Byte]] = ...
    def readFileToString(file: File): Try[String] = ...
    def readFileToString(file: File, encoding: String): Try[String] = ...
    def readLines(file: File, encoding: String): Try[List[String]] = ...
}

----------------------------------------

TITLE: Defining Simple Interfaces in Java and Scala
DESCRIPTION: Demonstrates how to define simple interfaces in Java and Scala.

LANGUAGE: java
CODE:
public interface Adder {
  public int add(int a, int b);
}

LANGUAGE: scala
CODE:
trait Adder:
  def add(a: Int, b: Int): Int

----------------------------------------

TITLE: Defining Final Classes in Java and Scala
DESCRIPTION: Shows how classes are defined as final by default in Scala, while in Java they need to be explicitly marked as final.

LANGUAGE: java
CODE:
final class Person

LANGUAGE: scala
CODE:
class Person

----------------------------------------

TITLE: Using a Type Class in Scala 2 and 3
DESCRIPTION: This snippet demonstrates how to use the 'Showable' type class with a 'Person' instance in both Scala 2 and Scala 3.

LANGUAGE: scala
CODE:
// Scala 2
val person = Person("John", "Doe")
println(showablePerson.show(person))

LANGUAGE: scala
CODE:
// Scala 3
val person = Person("John", "Doe")
println(person.show)

----------------------------------------

TITLE: Implementing unapply Method for Object Deconstruction
DESCRIPTION: Shows how to implement an unapply method in a companion object to enable object deconstruction and pattern matching.

LANGUAGE: scala
CODE:
class Person(var name: String, var age: Int)

object Person {
    def unapply(p: Person): String = s"${p.name}, ${p.age}"
}

----------------------------------------

TITLE: Arity-1 Method Invocation (Infix Notation) in Scala
DESCRIPTION: Illustrates the infix notation for invoking arity-1 (single argument) methods in Scala. It shows both recommended and controversial uses, as well as an incorrect example with side-effects.

LANGUAGE: scala
CODE:
// recommended
names.mkString(",")

// also sometimes seen; controversial
names mkString ","

// wrong - has side-effects
javaList add item

----------------------------------------

TITLE: Java Interoperability Example
DESCRIPTION: Illustrates that Scala default parameters are not optional when called from Java code, showing both the Scala class definition and attempted Java usage.

LANGUAGE: scala
CODE:
class Point(val x: Double = 0, val y: Double = 0)

LANGUAGE: java
CODE:
public class Main {
    public static void main(String[] args) {
        Point point = new Point(1);  // does not compile
    }
}

----------------------------------------

TITLE: Quasiquote Type Examples in Scala
DESCRIPTION: Examples of quasiquote syntax for various Scala type constructs, including type identifiers, singleton types, type projections, and compound types.

LANGUAGE: scala
CODE:
tq""
tq"$tpname" or tq"Name"
tq"$ref.type"
tq"$tpt#$tpname"
tq"$ref.$tpname"
tq"$tpname.super[$tpname].$tpname"
tq"this.$tpname"
tq"$tpt[..$tpts]"
tq"$tpt @$annots"
tq"..$parents { ..$defns }"
tq"$tpt forSome { ..$defns }"
tq"(..$tpts)"
tq"(..$tpts) => $tpt"

----------------------------------------

TITLE: Type Ascription for Blackbox Macro Expansion in Scala
DESCRIPTION: Illustrates how the Scala typechecker wraps the expansion of a blackbox macro into a type ascription, where T is the declared return type of the macro.

LANGUAGE: scala
CODE:
(x: T)

----------------------------------------

TITLE: Updating Map Elements in Scala
DESCRIPTION: Demonstrates how to update existing key-value pairs in a mutable Map.

LANGUAGE: scala
CODE:
states("AK") = "Alaska, A Really Big State"

----------------------------------------

TITLE: Consuming Collections with sumBy Operation
DESCRIPTION: Implements a sumBy operation as an extension method that can be applied to any IterableOnce collection. It sums the elements after applying a transformation function.

LANGUAGE: scala
CODE:
import scala.collection.IterableOnce

implicit class SumByOperation[A](coll: IterableOnce[A]) {
  def sumBy[B](f: A => B)(implicit num: Numeric[B]): B = {
    val it = coll.iterator
    var result = f(it.next())
    while (it.hasNext) {
      result = num.plus(result, f(it.next()))
    }
    result
  }
}

----------------------------------------

TITLE: Obtaining TypeTag Using typeTag Method
DESCRIPTION: Demonstrates how to obtain a TypeTag for Int type using the typeTag method from Universe.

LANGUAGE: scala
CODE:
import scala.reflect.runtime.universe._
val tt = typeTag[Int]

----------------------------------------

TITLE: Complex String Manipulation with Scala for Expression
DESCRIPTION: This snippet demonstrates a more complex use of Scala for expressions, removing an underscore prefix and capitalizing names from a list of strings.

LANGUAGE: scala
CODE:
val names = List("_adam", "_david", "_frank")
val capNames = for (name <- names) yield {
    val nameWithoutUnderscore = name.drop(1)
    val capName = nameWithoutUnderscore.capitalize
    capName
}

----------------------------------------

TITLE: Defining Mixins in Scala
DESCRIPTION: Demonstrates how to use mixins in Scala, a feature not available in Java.

LANGUAGE: scala
CODE:
class DavidBanner

trait Angry:
  def beAngry() =
    println("You won't like me ...")

trait Big:
  println("I'm big")

trait Green:
  println("I'm green")

// mix in the traits as DavidBanner
// is created
val hulk = new DavidBanner with Big with Angry with Green

----------------------------------------

TITLE: Defining an Extension Method for Circle in Scala 3
DESCRIPTION: This snippet shows how to define an extension method 'circumference' for the Circle class in Scala 3.

LANGUAGE: scala
CODE:
extension (c: Circle)
  def circumference: Double = c.radius * math.Pi * 2

----------------------------------------

TITLE: Additional ArrayBuffer Operations in Scala
DESCRIPTION: This snippet showcases various other methods available for ArrayBuffer, including append, prepend, insert, clear, and range operations.

LANGUAGE: scala
CODE:
val a = ArrayBuffer(1, 2, 3)
a.append(4)
a.appendAll(Seq(5, 6))
a.clear

val a = ArrayBuffer(9, 10)
a.insert(0, 8)
a.insertAll(0, Vector(4, 5, 6, 7))
a.prepend(3)
a.prependAll(Array(0, 1, 2))

val a = ArrayBuffer.range('a', 'h')
a.remove(0)
a.remove(2, 3)

val a = ArrayBuffer.range('a', 'h')
a.dropInPlace(2)
a.dropRightInPlace(2)

----------------------------------------

TITLE: Scala.js DOM manipulation example
DESCRIPTION: This snippet demonstrates how to use Scala.js to manipulate the DOM, including showing an alert dialog, defining a button with click behavior, and creating and appending HTML elements.

LANGUAGE: scala
CODE:
// show an alert dialog on a button click
jQuery("#hello-button").click{() =>
  dom.window.alert("Hello, world")
}

// define a button and what should happen when it's clicked
val btn = button(
  "Click me",
  onclick := { () =>
    dom.window.alert("Hello, world")
  })

// create two divs with css classes, an h2 element, and the button
val content =
  div(cls := "foo",
    div(cls := "bar",
      h2("Hello"),
      btn
    )
  )

// add the content to the DOM
val root = dom.document.getElementById("root")
root.innerHTML = ""
root.appendChild(content.render)

----------------------------------------

TITLE: Defining For Comprehensions in Scala
DESCRIPTION: Shows how to define for comprehensions in Scala, a feature not available in Java.

LANGUAGE: scala
CODE:
val list = 
  for
    i <- 1 to 3
  yield
    i * 10
// list: Vector(10, 20, 30)

----------------------------------------

TITLE: Complete Pizza Class with Test Application
DESCRIPTION: Provides a complete implementation including enumerations, Pizza class with toString override, and a test application to demonstrate usage.

LANGUAGE: scala
CODE:
import scala.collection.mutable.ArrayBuffer

sealed trait Topping
case object Cheese extends Topping
case object Pepperoni extends Topping
case object Sausage extends Topping
case object Mushrooms extends Topping
case object Onions extends Topping

sealed trait CrustSize
case object SmallCrustSize extends CrustSize
case object MediumCrustSize extends CrustSize
case object LargeCrustSize extends CrustSize

sealed trait CrustType
case object RegularCrustType extends CrustType
case object ThinCrustType extends CrustType
case object ThickCrustType extends CrustType

class Pizza (
    var crustSize: CrustSize = MediumCrustSize, 
    var crustType: CrustType = RegularCrustType
) {

    // ArrayBuffer is a mutable sequence (list)
    val toppings = ArrayBuffer[Topping]()

    def addTopping(t: Topping): Unit = toppings += t
    def removeTopping(t: Topping): Unit = toppings -= t
    def removeAllToppings(): Unit = toppings.clear()

    override def toString(): String = {
        s"""
        |Crust Size: $crustSize
        |Crust Type: $crustType
        |Toppings:   $toppings
        """.stripMargin
    }
}

// a little "driver" app
object PizzaTest extends App {
   val p = new Pizza
   p.addTopping(Cheese)
   p.addTopping(Pepperoni)
   println(p)
}

----------------------------------------

TITLE: Accessing Private Members Between Class and Companion Object
DESCRIPTION: Shows how a class and its companion object can access each other's private members through a practical example.

LANGUAGE: scala
CODE:
class SomeClass {
    def printFilename() = {
        println(SomeClass.HiddenFilename)
    }
}

object SomeClass {
    private val HiddenFilename = "/tmp/foo.bar"
}

----------------------------------------

TITLE: Creating Instances of a Scala Class with Default Parameters
DESCRIPTION: This snippet shows various ways to create instances of a Scala class that has default constructor parameter values.

LANGUAGE: scala
CODE:
new Socket()
new Socket(1000)
new Socket(4000, 6000)

----------------------------------------

TITLE: Implementing Comparator and Max Function with Contextual Parameters in Scala 3
DESCRIPTION: This snippet demonstrates the Scala 3 syntax for defining and using contextual parameters (formerly known as implicit parameters). It defines a Comparator trait, provides given instances for Int and String, and shows a max function using contextual parameters.

LANGUAGE: scala
CODE:
trait Comparator[A]:
  def compare(x: A, y: A): Int

object Comparator:
  given Comparator[Int] with
    def compare(x: Int, y: Int): Int = Integer.compare(x, y)

  given Comparator[String] with
    def compare(x: String, y: String): Int = x.compareTo(y)
end Comparator

def max[A](x: A, y: A)(using comparator: Comparator[A]): A =
  if comparator.compare(x, y) >= 0 then x
  else y

println(max(10, 6))             // 10
println(max("hello", "world"))  // world

----------------------------------------

TITLE: Using Implicit Class Times Method in Scala
DESCRIPTION: Shows how to import and use the IntWithTimes implicit class to execute a println statement multiple times.

LANGUAGE: scala
CODE:
scala> import Helpers._
import Helpers._

scala> 5 times println("HI")
HI
HI
HI
HI
HI

----------------------------------------

TITLE: Quasiquote Auxiliary Examples in Scala
DESCRIPTION: Examples of quasiquote syntax for auxiliary Scala constructs, including imports, case clauses, and for-comprehension enumerators.

LANGUAGE: scala
CODE:
q"import $ref.{..$sels}"
cq"$pat if $expr => $expr"
fq"$pat <- $expr"
fq"$pat = $expr"
fq"if $expr"

----------------------------------------

TITLE: Initializing and Adding Elements to a Mutable Set in Scala
DESCRIPTION: This snippet shows how to import and initialize a mutable Set, and then add elements to it using various methods like +=, ++=, and add.

LANGUAGE: scala
CODE:
val set = scala.collection.mutable.Set[Int]()

set += 1
set += 2 += 3
set ++= Vector(4, 5)

LANGUAGE: scala
CODE:
scala> val set = scala.collection.mutable.Set[Int]()
val set: scala.collection.mutable.Set[Int] = Set()

scala> set += 1
val res0: scala.collection.mutable.Set[Int] = Set(1)

scala> set += 2 += 3
val res1: scala.collection.mutable.Set[Int] = Set(1, 2, 3)

scala> set ++= Vector(4, 5)
val res2: scala.collection.mutable.Set[Int] = Set(1, 5, 2, 3, 4)

scala> set += 2
val res3: scala.collection.mutable.Set[Int] = Set(1, 5, 2, 3, 4)

scala> set.add(6)
res4: Boolean = true

scala> set.add(5)
res5: Boolean = false

----------------------------------------

TITLE: Defining Base Traits in Scala
DESCRIPTION: Defines two traits Cloneable and Resetable that will be used to demonstrate intersection types. Cloneable extends java.lang.Cloneable and provides a public clone method, while Resetable defines a reset method.

LANGUAGE: scala
CODE:
trait Cloneable extends java.lang.Cloneable {
  override def clone(): Cloneable = { // makes clone public
    super.clone().asInstanceOf[Cloneable]
  }
}
trait Resetable {
  def reset: Unit
}

----------------------------------------

TITLE: HashMap Usage in Scala
DESCRIPTION: Shows basic operations with mutable HashMap including adding and accessing elements.

LANGUAGE: scala
CODE:
val map = scala.collection.mutable.HashMap.empty[Int,String]
map += (1 -> "make a web site")
map += (3 -> "profit!")
map(1)
map contains 2

----------------------------------------

TITLE: Implementing a Macro Annotation Transformation in Scala
DESCRIPTION: Shows the full implementation of the 'identity' macro annotation, including the macro implementation object. This code handles different cases of annotation application and demonstrates how to process and expand the annottees.

LANGUAGE: scala
CODE:
import scala.annotation.{StaticAnnotation, compileTimeOnly}
import scala.language.experimental.macros
import scala.reflect.macros.whitebox

@compileTimeOnly("enable macro paradise to expand macro annotations")
class identity extends StaticAnnotation {
  def macroTransform(annottees: Any*): Any = macro identityMacro.impl
}

object identityMacro {
  def impl(c: whitebox.Context)(annottees: c.Expr[Any]*): c.Expr[Any] = {
    import c.universe._
    val inputs = annottees.map(_.tree).toList
    val (annottee, expandees) = inputs match {
      case (param: ValDef) :: (rest @ (_ :: _)) => (param, rest)
      case (param: TypeDef) :: (rest @ (_ :: _)) => (param, rest)
      case _ => (EmptyTree, inputs)
    }
    println((annottee, expandees))
    val outputs = expandees
    c.Expr[Any](Block(outputs, Literal(Constant(()))))
  }
}

----------------------------------------

TITLE: Redefining Val in Scala REPL
DESCRIPTION: This snippet demonstrates a special case in the Scala REPL where val fields can be redefined, which is not possible in regular Scala code.

LANGUAGE: scala
CODE:
scala> val age = 18
age: Int = 18

scala> val age = 19
age: Int = 19

----------------------------------------

TITLE: Demonstrating Mutable Collection Equality Issues in Scala
DESCRIPTION: Shows how modifying a mutable collection used as a HashMap key can lead to lookup failures due to changing hash codes. This example illustrates why using mutable collections as map keys can be problematic.

LANGUAGE: scala
CODE:
import collection.mutable.{HashMap, ArrayBuffer}
val buf = ArrayBuffer(1, 2, 3)
val map = HashMap(buf -> 3)
map(buf)
buf(0) += 1
map(buf)

----------------------------------------

TITLE: Type-Safe Distance Calculation Example
DESCRIPTION: Illustrates using value classes for type safety without runtime allocation overhead in a distance calculation scenario.

LANGUAGE: scala
CODE:
class Meter(val value: Double) extends AnyVal {
  def +(m: Meter): Meter = new Meter(value + m.value)
}

----------------------------------------

TITLE: Extending Abstract Type with Upper Bounds in Scala
DESCRIPTION: Shows how to extend the Buffer trait with a SeqBuffer class that adds type constraints. Introduces upper-type-bound and demonstrates using multiple abstract types.

LANGUAGE: scala
CODE:
abstract class SeqBuffer extends Buffer {
  type U
  type T <: Seq[U]
  def length = element.length
}

----------------------------------------

TITLE: Defining and Using foldLeft with Single Parameter List in Scala
DESCRIPTION: Example showing how type inference fails with a single parameter list version of foldLeft.

LANGUAGE: scala
CODE:
def foldLeft1[A, B](as: List[A], b0: B, op: (B, A) => B) = ???
def notPossible = foldLeft1(numbers, 0, _ + _)

----------------------------------------

TITLE: Value Class with Method Definition
DESCRIPTION: Shows how to define methods within a value class while maintaining the value class constraints.

LANGUAGE: scala
CODE:
class Wrapper(val underlying: Int) extends AnyVal {
  def foo: Wrapper = new Wrapper(underlying * 19)
}

----------------------------------------

TITLE: Implementing apply Method in Companion Object
DESCRIPTION: Shows how to implement an apply method in a companion object to enable instance creation without the new keyword.

LANGUAGE: scala
CODE:
class Person {
    var name = ""
}

object Person {
    def apply(name: String): Person = {
        var p = new Person
        p.name = name
        p
    }
}

----------------------------------------

TITLE: Using Named Parameters in Scala Class Instantiation
DESCRIPTION: This snippet shows how to use named parameters when creating an instance of a Scala class, which can improve code readability.

LANGUAGE: scala
CODE:
val s = new Socket(timeout=2000, linger=3000)

----------------------------------------

TITLE: Trait Definition with Abstract and Concrete Members
DESCRIPTION: Demonstrates trait usage with both abstract and implemented methods.

LANGUAGE: scala
CODE:
trait HasLegs:
  def numLegs: Int
  def walk(): Unit
  def stop() = println("Stopped walking")

----------------------------------------

TITLE: Querying Members of a Type in Scala Reflection
DESCRIPTION: Shows how to query members of a type using reflection, specifically finding the 'map' method in the List class.

LANGUAGE: scala
CODE:
val listTpe = typeOf[List[Int]]
listTpe.member(mapName)

----------------------------------------

TITLE: Calling Methods in Scala
DESCRIPTION: This example shows how to call the previously defined 'sum' and 'concatenate' methods, assigning their results to variables.

LANGUAGE: scala
CODE:
val x = sum(1, 2)
val y = concatenate("foo", "bar")

----------------------------------------

TITLE: Implicit Conversion between Array and WrappedArray
DESCRIPTION: This snippet demonstrates the implicit conversion between Scala arrays and WrappedArray instances, which allows arrays to be used as sequences.

LANGUAGE: scala
CODE:
val seq: Seq[Int] = a1
val a4: Array[Int] = seq.toArray
a1 eq a4

----------------------------------------

TITLE: Creating a Synchronized Set in Scala
DESCRIPTION: This snippet shows how to create a thread-safe mutable set by mixing in the SynchronizedSet trait with a HashSet.

LANGUAGE: scala
CODE:
import scala.collection.mutable
val synchroSet =
  new mutable.HashSet[Int] with mutable.SynchronizedSet[Int]

----------------------------------------

TITLE: Nested Object Solution for State Initialization
DESCRIPTION: Example showing how to use nested objects to safely initialize state that would otherwise be accessed before initialization in inheritance scenarios.

LANGUAGE: scala
CODE:
class Adder {
  var sum = 0
  def add(x: Int): Unit = sum += x
  add(1)
}
class LogAdder extends Adder {
  private object state {
    var added: Set[Int] = Set.empty
  }
  import state._
  override def add(x: Int): Unit = { added += x; super.add(x) }
}

----------------------------------------

TITLE: REPL Examples of Creating Scala Class Instances
DESCRIPTION: This snippet demonstrates the output of creating Socket instances with different parameter combinations in the Scala REPL.

LANGUAGE: scala
CODE:
scala> new Socket()
res0: Socket = timeout: 2000, linger: 3000

scala> new Socket(1000)
res1: Socket = timeout: 1000, linger: 3000

scala> new Socket(4000, 6000)
res2: Socket = timeout: 4000, linger: 6000

----------------------------------------

TITLE: Demonstrating Correct 2-Space Indentation in Scala
DESCRIPTION: This snippet illustrates the correct indentation style using 2 spaces, which is the recommended approach in Scala.

LANGUAGE: scala
CODE:
// right!
class Foo {
  def twospaces = {
    val x = 2
    ..
  }
}

----------------------------------------

TITLE: Accessing Tuple Elements in Scala 3
DESCRIPTION: Shows how to access tuple elements using array-like indexing in Scala 3.

LANGUAGE: scala
CODE:
println(ingredient(0)) // Sugar
println(ingredient(1)) // 25

----------------------------------------

TITLE: Demonstrating Compilation Error with Invalid Type in PetContainer in Scala
DESCRIPTION: This snippet shows an attempt to create a PetContainer with a Lion, which is not a subtype of Pet. This results in a compilation error, illustrating the enforcement of the upper type bound.

LANGUAGE: scala
CODE:
// this would not compile
val lionContainer = new PetContainer[Lion](new Lion)

----------------------------------------

TITLE: Workarounds for Single Parameter List foldLeft in Scala
DESCRIPTION: Demonstrating ways to use the single parameter list version of foldLeft by explicitly specifying types.

LANGUAGE: scala
CODE:
def firstWay = foldLeft1[Int, Int](numbers, 0, _ + _)
def secondWay = foldLeft1(numbers, 0, (a: Int, b: Int) => a + b)

----------------------------------------

TITLE: Reading Entire File Content in Scala
DESCRIPTION: Shows how to read an entire file into a string using OS-Lib's os.read function.

LANGUAGE: scala
CODE:
val content: String = os.read(path)

----------------------------------------

TITLE: Tuple-returning unapply Method
DESCRIPTION: Demonstrates an unapply method that returns multiple fields as a tuple for more flexible object deconstruction.

LANGUAGE: scala
CODE:
class Person(var name: String, var age: Int)

object Person {
    def unapply(p: Person): Tuple2[String, Int] = (p.name, p.age)
}

----------------------------------------

TITLE: Defining Basic Person Class in Scala
DESCRIPTION: Simple class definition showing a basic Person class with a mutable name field.

LANGUAGE: scala
CODE:
class Person(var name: String)

----------------------------------------

TITLE: Function Type Declaration in Scala
DESCRIPTION: Demonstrates proper syntax for declaring function types with correct spacing between parameter types, arrows, and return types.

LANGUAGE: scala
CODE:
def foo(f: Int => String) = ...

def bar(f: (Boolean, Double) => List[String]) = ...

----------------------------------------

TITLE: Current vs Proposed Desugaring Example
DESCRIPTION: Example showing current complex desugaring vs proposed simpler desugaring for pure aliases.

LANGUAGE: scala
CODE:
for
  a <- doSth(arg)
  b = a
yield a + b

LANGUAGE: scala
CODE:
// Current desugaring
doSth(arg).map { a =>
  val b = a
  (a, b)
}.map { case (a, b) =>
  a + b
}

LANGUAGE: scala
CODE:
// Proposed desugaring
doSth(arg).map { a =>
  val b = a
  a + b
}

----------------------------------------

TITLE: Sending GET Request with sttp in Scala
DESCRIPTION: Demonstrates how to send a simple GET request using sttp's quickRequest and handle the response. The example uses httpbin.org as the target URL and prints the response code and body.

LANGUAGE: scala
CODE:
import sttp.client4.quick._
import sttp.client4.Response

val response: Response[String] = quickRequest
  .get(uri"https://httpbin.org/get")
  .send()

println(response.code)
// prints: 200

println(response.body)
// prints some JSON string

----------------------------------------

TITLE: Parsing JSON String with uJson in Scala
DESCRIPTION: Demonstrates how to parse a JSON string and access string fields using ujson.read() method. The example shows accessing a simple name field from a JSON object.

LANGUAGE: scala
CODE:
val jsonString = "{\"name\": \"Peter\", \"age\": 13, \"pets\": [\"Toolkitty\", \"Scaniel\"]}"
val json: ujson.Value  = ujson.read(jsonString)
println(json("name").str)
// prints: Peter

----------------------------------------

TITLE: Importing JavaConverters for Collection Conversion
DESCRIPTION: Shows how to import the JavaConverters object to enable conversion methods between Java and Scala collections.

LANGUAGE: scala
CODE:
import collection.JavaConverters._

----------------------------------------

TITLE: Implementing a Simple Scala Compiler Plugin
DESCRIPTION: This code snippet demonstrates how to create a basic compiler plugin that detects division by zero. It shows the structure of a Plugin class, including component definition and phase implementation.

LANGUAGE: scala
CODE:
package localhost

import scala.tools.nsc
import nsc.Global
import nsc.Phase
import nsc.plugins.Plugin
import nsc.plugins.PluginComponent

class DivByZero(val global: Global) extends Plugin {
  import global._

  val name = "divbyzero"
  val description = "checks for division by zero"
  val components = List[PluginComponent](Component)

  private object Component extends PluginComponent {
    val global: DivByZero.this.global.type = DivByZero.this.global
    val runsAfter = List[String]("refchecks")
    val phaseName = DivByZero.this.name
    def newPhase(_prev: Phase) = new DivByZeroPhase(_prev)
    class DivByZeroPhase(prev: Phase) extends StdPhase(prev) {
      override def name = DivByZero.this.name
      def apply(unit: CompilationUnit): Unit = {
        for ( tree @ Apply(Select(rcvr, nme.DIV), List(Literal(Constant(0)))) <- unit.body
             if rcvr.tpe <:< definitions.IntClass.tpe)
          {
            global.reporter.error(tree.pos, "definitely division by zero")
          }
      }
    }
  }
}

----------------------------------------

TITLE: Quasiquote Expression Examples in Scala
DESCRIPTION: Examples of quasiquote syntax for various Scala expression types, including literals, identifiers, selections, applications, and control structures.

LANGUAGE: scala
CODE:
q""
q"$value"
q"$tname" or q"name"
q"$expr.$tname"
q"$tpname.super[$tpname].$tname"
q"$tpname.this"
q"$expr(...$exprss)"
q"$expr[..$tpts]"
q"$expr = $expr"
q"$expr(..$exprs) = $expr"
q"return $expr"
q"throw $expr"
q"$expr: $tpt"
q"$expr: @$annot"
q"(..$exprs)"
q"{ ..$stats }"
q"if ($expr) $expr else $expr"
q"$expr match { case ..$cases }"
q"try $expr catch { case ..$cases } finally $expr"
q"(..$params) => $expr"
q"{ case ..$cases }"
q"while ($expr) $expr"
q"do $expr while ($expr)"
q"for (..$enums) $expr"
q"for (..$enums) yield $expr"
q"new { ..$earlydefns } with ..$parents { $self => ..$stats }"

----------------------------------------

TITLE: Defining Switch/Match with Multiple Conditions in Java and Scala
DESCRIPTION: Shows how to define switch statements with multiple conditions in Java and match expressions in Scala.

LANGUAGE: java
CODE:
String numAsString = "";
switch (i) {
  case 1: case 3:
  case 5: case 7: case 9: 
    numAsString = "odd";
    break;
  case 2: case 4:
  case 6: case 8: case 10: 
    numAsString = "even";
    break;
  default:
    numAsString = "too big";
    break;
}

LANGUAGE: scala
CODE:
val numAsString = i match
  case 1 | 3 | 5 | 7 | 9 => "odd"
  case 2 | 4 | 6 | 8 | 10 => "even"
  case _ => "too big"

----------------------------------------

TITLE: Generating Pairs with For Comprehension in Scala
DESCRIPTION: Shows how to use a for comprehension with multiple generators to compute pairs of numbers with a specific sum. The example includes both Scala 2 and Scala 3 syntax.

LANGUAGE: scala
CODE:
def foo(n: Int, v: Int) =
   for (i <- 0 until n;
        j <- 0 until n if i + j == v)
   yield (i, j)

foo(10, 10).foreach {
  case (i, j) =>
    println(s"($i, $j) ")  // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
}

LANGUAGE: scala
CODE:
def foo(n: Int, v: Int) =
   for i <- 0 until n
       j <- 0 until n if i + j == v
   yield (i, j)

foo(10, 10).foreach {
  (i, j) => println(s"($i, $j) ")  // prints (1, 9) (2, 8) (3, 7) (4, 6) (5, 5) (6, 4) (7, 3) (8, 2) (9, 1)
}

----------------------------------------

TITLE: Implementing Debug Macro with Quasiquotes in Scala
DESCRIPTION: This snippet shows how to implement a debug macro that prints the expression code before executing it. It uses quasiquotes for AST manipulation, deconstructing arguments and constructing a rewritten result.

LANGUAGE: scala
CODE:
object debug {
  def apply[T](x: => T): T = macro impl
  def impl(c: Context)(x: c.Tree) = { import c.universe._
    val q"...$stats" = x
    val loggedStats = stats.flatMap { stat =>
      val msg = "executing " + showCode(stat)
      List(q"println($msg)", stat)
    }
    q"...$loggedStats"
  }
}

// usage
object Test extends App {
  def faulty: Int = throw new Exception
  debug {
    val x = 1
    val y = x + faulty
    x + y
  }
}

----------------------------------------

TITLE: Defining a Function with By-name Parameter in Scala
DESCRIPTION: This snippet demonstrates how to define a function with a by-name parameter in Scala. The parameter 'input' is of type Int and is prepended with '=>' to make it a by-name parameter.

LANGUAGE: scala
CODE:
def calculate(input: => Int) = input * 37

----------------------------------------

TITLE: Top-Level Definitions in Scala 3
DESCRIPTION: Shows how to define package-level variables and methods directly in Scala 3 without using package objects.

LANGUAGE: scala
CODE:
// in file gardening/fruits/package.scala
package gardening.fruits

val planted = List(Apple, Plum, Banana)
def showFruit(fruit: Fruit): Unit =
  println(s"${fruit.name}s are ${fruit.color}")

----------------------------------------

TITLE: Deserializing JSON to Map in Scala
DESCRIPTION: Demonstrates how to deserialize JSON into a Map[String, List[Int]] using uPickle. Includes error handling for incorrect types.

LANGUAGE: scala
CODE:
val json = "{\"primes\": [2, 3, 5], \"evens\": [2, 4, 6]} "
val map: Map[String, List[Int]] =
  upickle.default.read[Map[String, List[Int]]](json)

println(map("primes"))
// prints: List(2, 3, 5)

----------------------------------------

TITLE: Varargs Handling in Macros
DESCRIPTION: Shows how to work with varargs in macros using Varargs extractor and Seq[Expr[T]].

LANGUAGE: scala
CODE:
import scala.quoted.*

inline def sumNow(inline nums: Int*): Int =
  ${ sumCode('nums)  }

def sumCode(nums: Expr[Seq[Int]])(using Quotes): Expr[Int] =
  import quotes.reflect.report
  nums match
    case Varargs(numberExprs) => // numberExprs: Seq[Expr[Int]]
      val numbers: Seq[Int] = numberExprs.map(_.valueOrAbort)
      Expr(numbers.sum)
    case _ => report.errorAndAbort(
      "Expected explicit varargs sequence. " +
      "Notation `args*` is not supported.", nums)

----------------------------------------

TITLE: Converting Immutable Scala List to Java List
DESCRIPTION: This snippet shows how converting an immutable Scala List to a Java List results in an unmodifiable list that throws an UnsupportedOperationException when attempting to modify it.

LANGUAGE: scala
CODE:
scala> val jul = List(1, 2, 3).asJava
val jul: java.util.List[Int] = [1, 2, 3]

scala> jul.add(7)
java.lang.UnsupportedOperationException
    at java.util.AbstractList.add(AbstractList.java:148)

----------------------------------------

TITLE: Workaround for Referential Transparency using Symbol Unquoting
DESCRIPTION: This code shows an alternative approach to maintain referential transparency in macros by resolving and unquoting symbols instead of using plain identifiers.

LANGUAGE: scala
CODE:
def impl(c: Context)(x: c.Tree) = {
  import c.universe._
  val myMacro = symbolOf[MyMacro.type].asClass.module
  val wrapper = myMacro.info.member(TermName("wrapper"))
  q"$wrapper($x)"
}

----------------------------------------

TITLE: Inline Conditionals in Scala 3
DESCRIPTION: Shows how inline conditionals in Scala 3 can be used for compile-time branching and optimization.

LANGUAGE: scala
CODE:
inline def power(x: Double, inline n: Int): Double =
  if (n == 0) 1.0
  else if (n % 2 == 1) x * power(x, n - 1)
  else power(x * x, n / 2)

----------------------------------------

TITLE: Adding Cask Dependency with Scala CLI
DESCRIPTION: Demonstrates how to add Cask dependency using Scala CLI's using directive. Specifies version 0.10.2 of the com.lihaoyi::cask library.

LANGUAGE: scala
CODE:
//> using dep com.lihaoyi::cask::0.10.2

----------------------------------------

TITLE: Function Trait with Variance in Scala 3
DESCRIPTION: Shows the implementation of the Function trait with contravariant input and covariant output types.

LANGUAGE: scala
CODE:
trait Function[-A, +B]:
  def apply(a: A): B

----------------------------------------

TITLE: Adding Custom Headers to sttp Request in Scala
DESCRIPTION: Shows how to add custom headers to an sttp request using the header method. The example adds an 'Origin' header to a GET request and prints the resulting headers.

LANGUAGE: scala
CODE:
import sttp.client4.quick._

val request = quickRequest
  .get(uri"https://example.com")
  .header("Origin", "https://scala-lang.org")

println(request.headers)
// prints: Vector(Accept-Encoding: gzip, deflate, Origin: https://scala-lang.org)

----------------------------------------

TITLE: Transforming Collections with BuildFrom
DESCRIPTION: Implements an intersperse operation that can be applied to any sequence and returns a sequence with a new element inserted between each element of the source sequence, using BuildFrom to ensure the result type matches the input type.

LANGUAGE: scala
CODE:
import scala.collection.{ AbstractView, BuildFrom }
import scala.collection.generic.IsSeq

class IntersperseOperation[Repr, S <: IsSeq[Repr]](coll: Repr, seq: S) {
  def intersperse[B >: seq.A, That](sep: B)(implicit bf: BuildFrom[Repr, B, That]): That = {
    val seqOps = seq(coll)
    bf.fromSpecific(coll)(new AbstractView[B] {
      // same as before
    })
  }
}

implicit def IntersperseOperation[Repr](coll: Repr)(implicit seq: IsSeq[Repr]): IntersperseOperation[Repr, seq.type] =
  new IntersperseOperation(coll, seq)

----------------------------------------

TITLE: Operator Precedence Example in Scala
DESCRIPTION: Illustrates how operator precedence works in Scala with a complex expression using multiple operators.

LANGUAGE: scala
CODE:
a + b ^? c ?^ d less a ==> b | c

LANGUAGE: scala
CODE:
((a + b) ^? (c ?^ d)) less ((a ==> b) | c)

----------------------------------------

TITLE: Function Types in Collections
DESCRIPTION: Demonstrates the type signatures when storing functions in collections.

LANGUAGE: scala
CODE:
// a List that contains functions of the type `Int => Int`
functionList: List[Int => Int]

// a Map whose keys have the type `String`, and whose
// values have the type `Int => Int`
functionMap: Map[String, Int => Int]

----------------------------------------

TITLE: Defining Switch/Match Statements in Java and Scala
DESCRIPTION: Demonstrates how to define switch statements in Java and match expressions in Scala.

LANGUAGE: java
CODE:
String monthAsString = "";
switch(day) {
  case 1: monthAsString = "January";
        break;
  case 2: monthAsString = "February";
        break;
  default: monthAsString = "Other";
        break;
}

LANGUAGE: scala
CODE:
val monthAsString = day match
  case 1 => "January"
  case 2 => "February"
  _ => "Other"

----------------------------------------

TITLE: Multi-line Conditional Expression with Operators in Scala
DESCRIPTION: Illustrates how parentheses can be used to disable semicolon inference when starting lines with operators in conditional expressions.

LANGUAGE: scala
CODE:
(  someCondition
|| someOtherCondition
|| thirdCondition
)

----------------------------------------

TITLE: Demonstrating Named Arguments in Scala Method Calls
DESCRIPTION: This snippet shows various ways to call a method using named arguments. It demonstrates how named arguments can be used in any order and how they can be mixed with positional arguments.

LANGUAGE: scala
CODE:
def printName(first: String, last: String): Unit =
  println(s"$first $last")

printName("John", "Public")  // Prints "John Public"
printName(first = "John", last = "Public")  // Prints "John Public"
printName(last = "Public", first = "John")  // Prints "John Public"
printName("Elton", last = "John")  // Prints "Elton John"

----------------------------------------

TITLE: Scala if Statement with Block
DESCRIPTION: Shows an if statement with its action enclosed in a block, allowing for multiple lines of code to be executed if the condition is true.

LANGUAGE: scala
CODE:
if (a == b) {
    doSomething()
}

----------------------------------------

TITLE: Arity-0 Method Invocation in Scala
DESCRIPTION: Shows the two ways of invoking arity-0 (no argument) methods in Scala. It emphasizes that parentheses should only be omitted for purely functional methods with no side-effects.

LANGUAGE: scala
CODE:
reply()

// is the same as

reply

----------------------------------------

TITLE: Type to TypeRepr Conversion
DESCRIPTION: Demonstrates converting between Type[T] and TypeRepr representations using TypeRepr.of and asType methods.

LANGUAGE: scala
CODE:
def g[T: Type](using Quotes) =
  import quotes.reflect.*
  val tpe: TypeRepr = TypeRepr.of[T]
  tpe.asType match
    case '[t] => '{ val x: t = ${...} }
  ...

----------------------------------------

TITLE: Implementing a Type Class Instance in Scala 2 and 3
DESCRIPTION: This snippet shows how to implement a concrete instance of the 'Showable' type class for a 'Person' class in both Scala 2 and Scala 3.

LANGUAGE: scala
CODE:
case class Person(firstName: String, lastName: String)

LANGUAGE: scala
CODE:
// Scala 2
implicit val showablePerson: Showable[Person] = new Showable[Person] {
  def show(p: Person): String =
    s"${p.firstName} ${p.lastName}"
}

LANGUAGE: scala
CODE:
// Scala 3
given Showable[Person] with
  extension (p: Person) def show: String =
    s"${p.firstName} ${p.lastName}"

----------------------------------------

TITLE: Using Type Pattern in Scala Quasiquotes
DESCRIPTION: Demonstrates how to use type patterns to check the type of a scrutinee in Scala quasiquotes.

LANGUAGE: scala
CODE:
scala> val isT = pq"_: T"
isT: universe.Typed = (_: T)

scala> val pq"_: $tpt" = isT
tpt: universe.Tree = T

----------------------------------------

TITLE: Defining View trait in Scala
DESCRIPTION: Shows the definition of the View trait for non-strict collections.

LANGUAGE: scala
CODE:
trait View[+A] extends Iterable[A], IterableOps[A, View, View[A]]:
  def iterator: Iterator[A]

----------------------------------------

TITLE: Procedure Syntax Migration in Scala
DESCRIPTION: Shows the required change from deprecated procedure syntax to explicit return type syntax in Scala 3, adding ': Unit =' to method declarations.

LANGUAGE: scala
CODE:
object Bar {
  def print() { 
    println("bar")
  }
}

----------------------------------------

TITLE: Using Alternative Pattern in Scala Quasiquotes
DESCRIPTION: Demonstrates how to use alternative patterns to represent a pattern that matches when at least one of the branches matches in Scala quasiquotes.

LANGUAGE: scala
CODE:
scala> val alt = pq"Foo() | Bar() | Baz()"
alt: universe.Alternative = (Foo()| Bar()| Baz())

scala> val pq"$first | ..$rest" = alt
head: universe.Tree = Foo()
tail: List[universe.Tree] = List(Bar(), Baz())

scala> val pq"..$init | $last" = alt
init: List[universe.Tree] = List(Foo(), Bar())
last: universe.Tree = Baz()

----------------------------------------

TITLE: Sending POST Request with String Body in Scala 3 using sttp
DESCRIPTION: This snippet shows how to send a POST request with a string body using sttp's quickRequest in Scala 3. It includes importing the necessary package, creating the request with a body, sending it, and printing the response code.

LANGUAGE: scala
CODE:
import sttp.client4.quick.*

val response = quickRequest
  .post(uri"https://example.com/")
  .body("Lorem ipsum")
  .send()

println(response.code)
// prints: 200

----------------------------------------

TITLE: Creating and Querying SortedSet in Scala
DESCRIPTION: Demonstrates creating a TreeSet with custom ordering and performing range queries.

LANGUAGE: scala
CODE:
val myOrdering = Ordering.fromLessThan[String](_ > _)
myOrdering: scala.math.Ordering[String] = ...
TreeSet.empty(myOrdering)
res1: scala.collection.immutable.TreeSet[String] = TreeSet()
TreeSet.empty[String]
res2: scala.collection.immutable.TreeSet[String] = TreeSet()
res2 + ("one", "two", "three", "four")
res3: scala.collection.immutable.TreeSet[String] = TreeSet(four, one, three, two)
res3 range ("one", "two")
res4: scala.collection.immutable.TreeSet[String] = TreeSet(one, three)
res3 from "three"
res5: scala.collection.immutable.TreeSet[String] = TreeSet(three, two)

----------------------------------------

TITLE: GitHub Actions Workflow for Continuous Integration
DESCRIPTION: YAML configuration for setting up a GitHub Actions workflow for continuous integration.

LANGUAGE: yaml
CODE:
name: Continuous integration
on: push

jobs:
  ci:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-java@v3
        with:
          distribution: temurin
          java-version: 8
          cache: sbt
      - name: unit tests
        run: sbt +test

----------------------------------------

TITLE: Using Function Variables
DESCRIPTION: Demonstrates how to invoke a function variable and use it with higher-order functions like map.

LANGUAGE: scala
CODE:
val x = double(2)   // 4
List(1, 2, 3).map(double)   // List(2, 4, 6)

----------------------------------------

TITLE: Three-Element Tuple with Custom Class in Scala
DESCRIPTION: Demonstrates creating a tuple containing primitive types and a custom class instance.

LANGUAGE: scala
CODE:
case class Person(name: String)
val t = (3, "Three", new Person("David"))

----------------------------------------

TITLE: Type Pattern Matching with Expr in Scala
DESCRIPTION: Demonstrates how to extract the precise type of an Expr using pattern matching. The pattern match allows accessing both the expression and its type information.

LANGUAGE: scala
CODE:
val x: Expr[X] = ...
x match
  case '{ $x: t } =>
    // `x: Expr[X & t]` where `t` is the precise type of `x`

----------------------------------------

TITLE: HTML Template Response with Scalatags
DESCRIPTION: Implementation using Scalatags library to generate HTML responses. Shows how to create structured HTML output with proper content type headers.

LANGUAGE: scala
CODE:
import java.time.{ZoneId, ZonedDateTime}
import scalatags.Text.all._

object Example extends cask.MainRoutes {

  private def getZoneIdForCity(city: String): Option[ZoneId] = {
    import scala.jdk.CollectionConverters._
    ZoneId.getAvailableZoneIds.asScala.find(_.endsWith("/" + city)).map(ZoneId.of)
  }
  
  @cask.get("/time/:city")
  def dynamicWithCity(city: String): doctype = {
    val text = getZoneIdForCity(city) match {
      case Some(zoneId) => s"Current date is: ${ZonedDateTime.now().withZoneSameInstant(zoneId)}"
      case None => s"Couldn't find time zone for city $city"
    }

    doctype("html")(
      html(
        body(
          p(text)
        )
      )
    )
  }

  initialize()
}

----------------------------------------

TITLE: Java-Scala Annotation Usage Comparison
DESCRIPTION: Demonstrates the syntax differences between Java and Scala when applying annotations with named parameters.

LANGUAGE: java
CODE:
@Source(url = "https://coders.com/",
        mail = "support@coders.com")
public class MyJavaClass extends TheirClass ...

LANGUAGE: scala
CODE:
@Source(url = "https://coders.com/",
        mail = "support@coders.com")
class MyScalaClass ...

----------------------------------------

TITLE: Partitioning Collections in Scala
DESCRIPTION: Demonstrates the partition operation on a collection to separate people into minors and adults based on age. Shows the conciseness and universality of Scala collections operations.

LANGUAGE: scala
CODE:
val (minors, adults) = people partition (_.age < 18)

----------------------------------------

TITLE: Using a Macro in Scala
DESCRIPTION: Demonstrates how to use the 'printf' macro in a Scala application.

LANGUAGE: scala
CODE:
object Test extends App {
  import Macros._
  printf("hello %s!", "world")
}

----------------------------------------

TITLE: Implementing JSON Serialization for Custom Class - Scala 3
DESCRIPTION: Demonstrates JSON serialization for a custom case class in Scala 3 using the derives keyword to automatically generate ReadWriter instance.

LANGUAGE: scala
CODE:
import upickle.default._

case class PetOwner(name: String, pets: List[String]) derives ReadWriter

val petOwner = PetOwner("Peter", List("Toolkitty", "Scaniel"))
val json: String = write(petOwner)
println(json)
// prints: {"name":"Peter","pets":["Toolkitty","Scaniel"]}"

----------------------------------------

TITLE: Using Context Bounds Syntax
DESCRIPTION: Simplified version of maxElement using context bounds syntax, which is a shorthand for expressing a context parameter applied to a type parameter.

LANGUAGE: scala
CODE:
def maxElement[A: Ord](as: List[A]): A =
  as.reduceLeft(max(_, _))

----------------------------------------

TITLE: Implementing Private Members and Getter/Setter in Scala
DESCRIPTION: Demonstrates how to create private members in a Scala class and implement custom getter and setter methods. Shows examples for both Scala 2 and Scala 3 syntax.

LANGUAGE: scala
CODE:
class Point {
  private var _x = 0
  private var _y = 0
  private val bound = 100

  def x: Int = _x
  def x_=(newValue: Int): Unit = {
    if (newValue < bound)
      _x = newValue
    else
      printWarning()
  }

  def y: Int = _y
  def y_=(newValue: Int): Unit = {
    if (newValue < bound)
      _y = newValue
    else
      printWarning()
  }

  private def printWarning(): Unit =
    println("WARNING: Out of bounds")
}

val point1 = new Point
point1.x = 99
point1.y = 101 // prints the warning

LANGUAGE: scala
CODE:
class Point:
  private var _x = 0
  private var _y = 0
  private val bound = 100

  def x: Int = _x
  def x_=(newValue: Int): Unit =
    if newValue < bound then
      _x = newValue
    else
      printWarning()

  def y: Int = _y
  def y_=(newValue: Int): Unit =
    if newValue < bound then
      _y = newValue
    else
      printWarning()

  private def printWarning(): Unit =
    println("WARNING: Out of bounds")
end Point

val point1 = Point()
point1.x = 99
point1.y = 101 // prints the warning

----------------------------------------

TITLE: Liquid Template Include
DESCRIPTION: Template include statement for rendering documentation sections with provided links

LANGUAGE: liquid
CODE:
{% include inner-documentation-sections.html links=page.explore_resources %}

----------------------------------------

TITLE: Partial Application with Multiple Parameter Lists in Scala
DESCRIPTION: Demonstrating partial application using foldLeft with multiple parameter lists to create reusable functions.

LANGUAGE: scala
CODE:
val numbers = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
val numberFunc = numbers.foldLeft(List[Int]())

val squares = numberFunc((xs, x) => xs :+ x*x)
println(squares) // List(1, 4, 9, 16, 25, 36, 49, 64, 81, 100)

val cubes = numberFunc((xs, x) => xs :+ x*x*x)
println(cubes)  // List(1, 8, 27, 64, 125, 216, 343, 512, 729, 1000)

----------------------------------------

TITLE: Form Handling with Cask in Scala
DESCRIPTION: Demonstrates handling HTML form submissions using Cask's @cask.postForm annotation. Creates an HTML form endpoint and processes POST requests with form data.

LANGUAGE: scala
CODE:
object Example extends cask.MainRoutes {

  @cask.get("/form")
  def getForm(): cask.Response[String] = {
    val html =
      """<!doctype html>
        |<html>
        |<body>
        |<form action=\"/form\" method=\"post\">
        |  <label for=\"name\">First name:</label><br>
        |  <input type=\"text\" name=\"name\" value=\"\"><br>
        |  <label for=\"surname\">Last name:</label><br>
        |  <input type=\"text\" name=\"surname\" value=\"\"><br><br>
        |  <input type=\"submit\" value=\"Submit\">
        |</form>
        |</body>
        |</html>""".stripMargin

    cask.Response(data = html, headers = Seq("Content-Type" -> "text/html"))
  }

  @cask.postForm("/form")
  def formEndpoint(name: String, surname: String): String =
    "Hello " + name + " " + surname

  initialize()
}

----------------------------------------

TITLE: Implementing Pure Functions for Pizza Operations
DESCRIPTION: Shows implementation of pure functions for calculating pizza prices based on toppings and crust options.

LANGUAGE: scala
CODE:
def pizzaPrice(p: Pizza): Double = p match
  case Pizza(crustSize, crustType, toppings) =>
    val base  = 6.00
    val crust = crustPrice(crustSize, crustType)
    val tops  = toppings.map(toppingPrice).sum
    base + crust + tops

def toppingPrice(t: Topping): Double = t match
  case Cheese | Onions => 0.5
  case Pepperoni | BlackOlives | GreenOlives => 0.75

----------------------------------------

TITLE: Implementing Generic List Generation in Scala 2
DESCRIPTION: A recursive method that creates a list of duplicate elements using type parameterization. The method takes a generic type parameter A, a value of that type, and a length parameter to determine how many duplicates to create. It demonstrates both explicit and implicit type parameter usage.

LANGUAGE: scala
CODE:
def listOfDuplicates[A](x: A, length: Int): List[A] = {
  if (length < 1)
    Nil
  else
    x :: listOfDuplicates(x, length - 1)
}
println(listOfDuplicates[Int](3, 4))  // List(3, 3, 3, 3)
println(listOfDuplicates("La", 8))  // List(La, La, La, La, La, La, La, La)

----------------------------------------

TITLE: Parsing JSON Response with STTP in Scala 3
DESCRIPTION: Demonstrates JSON response parsing using STTP client and uJson in Scala 3. The example retrieves and parses user data from GitHub's API using a GET request.

LANGUAGE: scala
CODE:
import sttp.client4.quick.*

val response = quickRequest
  .get(uri"https://api.github.com/user")
  .auth.bearer(sys.env("GITHUB_TOKEN"))
  .send()

val json = ujson.read(response.body)

println(json("login").str)
// prints your login

----------------------------------------

TITLE: Implementing Pure Functions for Pizza Operations
DESCRIPTION: Shows implementation of pure functions for calculating pizza prices based on toppings and crust options.

LANGUAGE: scala
CODE:
def pizzaPrice(p: Pizza): Double = p match
  case Pizza(crustSize, crustType, toppings) =>
    val base  = 6.00
    val crust = crustPrice(crustSize, crustType)
    val tops  = toppings.map(toppingPrice).sum
    base + crust + tops

def toppingPrice(t: Topping): Double = t match
  case Cheese | Onions => 0.5
  case Pepperoni | BlackOlives | GreenOlives => 0.75

----------------------------------------

TITLE: Starting the Scala REPL
DESCRIPTION: Shows the initial REPL prompt after launching the Scala interpreter from the command line.

LANGUAGE: scala
CODE:
$ scala
Welcome to Scala 2.13.0 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_131).
Type in expressions for evaluation. Or try :help.

scala> _

----------------------------------------

TITLE: Tuple Type Summoning with Optional Result
DESCRIPTION: Alternative implementation for summoning tuple types that returns an Option of an Expr[Tuple]. Provides a more functional approach with option handling.

LANGUAGE: scala
CODE:
def summonAll[T](using Type[T])(using Quotes): Option[Expr[Tuple]]] = {
    Type.of[T] match
      case '[ head *: tail ] =>
        for headExpr <- Expr.summon[head]
            tailExpr <- summonAll[tail]
        yield '{ headExpr *: tailExpr }
      case '[ EmptyTuple ] => Some('{ EmptyTuple })
      case _ => None
  }

----------------------------------------

TITLE: Compiling and Running Scala Program
DESCRIPTION: Shell commands demonstrating how to compile and run the HelloInteractive Scala program, including example program output.

LANGUAGE: sh
CODE:
$ scalac HelloInteractive.scala

LANGUAGE: sh
CODE:
$ scala HelloInteractive

LANGUAGE: sh
CODE:
$ scala HelloInteractive
Enter your first name: Alvin
Enter your last name: Alexander
Your name is Alvin Alexander

----------------------------------------

TITLE: Demonstrating Implicit Resolution Failure in Scala 2
DESCRIPTION: This snippet shows a case where implicit resolution fails due to the absence of an implicit Comparator for Boolean type. It demonstrates how Scala's implicit resolution mechanism works and its compile-time safety.

LANGUAGE: scala
CODE:
// does not compile:
println(max(false, true))
//         ^
//     error: could not find implicit value for parameter comparator: Comparator[Boolean]

----------------------------------------

TITLE: Using a Generic Stack with Integer Type in Scala
DESCRIPTION: This example shows how to create and use a Stack instance with Integer type. It demonstrates pushing elements onto the stack and popping them off.

LANGUAGE: scala
CODE:
val stack = Stack[Int]
stack.push(1)
stack.push(2)
println(stack.pop())  // prints 2
println(stack.pop())  // prints 1

----------------------------------------

TITLE: Accessing and Modifying Fields at Runtime in Scala
DESCRIPTION: Demonstrates how to access and modify fields of an object at runtime using reflection. It shows how to obtain a FieldMirror and use it to get and set a field's value.

LANGUAGE: scala
CODE:
case class Purchase(name: String, orderNumber: Int, var shipped: Boolean)
val p = Purchase("Jeff Lebowski", 23819, false)
val m = ru.runtimeMirror(p.getClass.getClassLoader)
val shippingTermSymb = ru.typeOf[Purchase].decl(ru.TermName("shipped")).asTerm
val im = m.reflect(p)
val shippingFieldMirror = im.reflectField(shippingTermSymb)
shippingFieldMirror.get
shippingFieldMirror.set(true)
shippingFieldMirror.get

----------------------------------------

TITLE: Appending to an Existing File with OS-Lib in Scala
DESCRIPTION: This snippet demonstrates how to append content to an existing file using os.write.append. It adds two more lines to the file and then prints the total number of lines.

LANGUAGE: scala
CODE:
os.write.append(path, "two more\nlines\n")
println(os.read.lines(path).size)
// prints: 4

----------------------------------------

TITLE: Complete JSON Deserialization Example with Custom Type
DESCRIPTION: Full example showing JSON deserialization to a custom case class including ReadWriter derivation and usage.

LANGUAGE: scala
CODE:
import upickle.default._

case class PetOwner(name: String, pets: List[String])
implicit val ownerRw: ReadWriter[PetOwner] = macroRW

val json = "{\"name\": \"Peter\", \"pets\": [\"Toolkitty\", \"Scaniel\"]}"
val petOwner: PetOwner = read[PetOwner](json)

val firstPet = petOwner.pets.head
println(s"${petOwner.name} has a pet called $firstPet")
// prints: Peter has a pet called Toolkitty

----------------------------------------

TITLE: Pizza-Related Enumerations in Scala
DESCRIPTION: Defines enumerations for pizza toppings, crust sizes, and crust types using sealed traits and case objects.

LANGUAGE: scala
CODE:
sealed trait Topping
case object Cheese extends Topping
case object Pepperoni extends Topping
case object Sausage extends Topping
case object Mushrooms extends Topping
case object Onions extends Topping

sealed trait CrustSize
case object SmallCrustSize extends CrustSize
case object MediumCrustSize extends CrustSize
case object LargeCrustSize extends CrustSize

sealed trait CrustType
case object RegularCrustType extends CrustType
case object ThinCrustType extends CrustType
case object ThickCrustType extends CrustType

----------------------------------------

TITLE: Demonstrating Ambiguous Method References in Scaladoc
DESCRIPTION: Illustrates a scenario where method references in Scaladoc comments can be ambiguous and need to be disambiguated.

LANGUAGE: scala
CODE:
import scala.collection.mutable.ListBuffer
class bar {
    def foo(x: Int): Boolean = ???
    def foo(x: ListBuffer[Int], y: String): Int = ???
}

----------------------------------------

TITLE: Using Infix Notation for Operators in Scala
DESCRIPTION: Shows the more common infix notation for using operators in Scala.

LANGUAGE: scala
CODE:
10 + 1

----------------------------------------

TITLE: Duplicating Iterator in Scala
DESCRIPTION: Demonstrates how to duplicate an iterator to create two independent iterators that can be used separately without affecting each other.

LANGUAGE: scala
CODE:
val (words, ns) = Iterator("a", "number", "of", "words").duplicate
val shorts = words.filter(_.length < 3).toList
val count = ns.map(_.length).sum

----------------------------------------

TITLE: Enabling Strict Equality in Scala 3
DESCRIPTION: This snippet shows how to enable strict equality checks in Scala 3 using the scala.language.strictEquality import, which prevents comparisons between different types.

LANGUAGE: scala
CODE:
import scala.language.strictEquality

val rover = Dog("Rover")
val fido = Dog("Fido")
println(rover == fido)   // compiler error

// compiler error message:
// Values of types Dog and Dog cannot be compared with == or !=

----------------------------------------

TITLE: Defining a Sealed Trait and Case Classes in Scala
DESCRIPTION: Shows the definition of an Option ADT (Algebraic Data Type) using a sealed trait and case classes. This example demonstrates how related elements are grouped in a single file named 'Option.scala'.

LANGUAGE: scala
CODE:
sealed trait Option[+A]

case class Some[A](a: A) extends Option[A]

case object None extends Option[Nothing]

----------------------------------------

TITLE: Two-Element Tuple Creation in Scala
DESCRIPTION: Shows creation of a simple two-element tuple with String and Int types.

LANGUAGE: scala
CODE:
val d = ("Maggie", 30)

----------------------------------------

TITLE: Serializing Map to JSON using uPickle in Scala
DESCRIPTION: Demonstrates how to serialize a Map containing String keys and Integer values to JSON format using uPickle's default writer.

LANGUAGE: scala
CODE:
val map: Map[String, Int] =
  Map("Toolkitty" -> 3, "Scaniel" -> 5)
val jsonString: String = upickle.default.write(map)
println(jsonString)
// prints: {"Toolkitty":3,"Scaniel":5}

----------------------------------------

TITLE: Pattern Matching on Algebraic Data Types in Scala
DESCRIPTION: Demonstrates how to use pattern matching to evaluate and manipulate algebraic data types in Scala.

LANGUAGE: scala
CODE:
def eval(t: Tree, ev: Environment): Int = t match
  case Sum(left, right) => eval(left, ev) + eval(right, ev)
  case Var(n)    => ev(n)
  case Const(v)  => v

----------------------------------------

TITLE: Formatting Multiline Strings with stripMargin in Scala
DESCRIPTION: This snippet demonstrates how to use the stripMargin method to properly format multiline strings in Scala.

LANGUAGE: scala
CODE:
val speech = """Four score and
               |seven years ago
               |our fathers ...""".stripMargin

----------------------------------------

TITLE: Basic Pizza Class Implementation in Scala
DESCRIPTION: Implements a Pizza class with mutable toppings collection and methods for managing toppings.

LANGUAGE: scala
CODE:
class Pizza (
    var crustSize: CrustSize = MediumCrustSize, 
    var crustType: CrustType = RegularCrustType
) {

    // ArrayBuffer is a mutable sequence (list)
    val toppings = scala.collection.mutable.ArrayBuffer[Topping]()

    def addTopping(t: Topping): Unit = toppings += t
    def removeTopping(t: Topping): Unit = toppings -= t
    def removeAllToppings(): Unit = toppings.clear()

}

----------------------------------------

TITLE: Incorrect Level Consistency Examples
DESCRIPTION: Shows invalid code examples that violate level consistency rules between compile-time and runtime

LANGUAGE: scala
CODE:
def myBadCounter1(using Quotes): Expr[Int] = {
  var x = 0
  '{ x += 1; x }
}

def myBadCounter2(using Quotes): Expr[Int] = '{
  var x = 0
  ${ x += 1; 'x }
}

----------------------------------------

TITLE: Basic Dynamic Time Endpoint in Scala
DESCRIPTION: Creates a basic endpoint that returns current date and time using Cask framework. The endpoint is accessible at /time and returns plain text response.

LANGUAGE: scala
CODE:
import java.time.ZonedDateTime

object Example extends cask.MainRoutes {
  @cask.get("/time")
  def dynamic(): String = s"Current date is: ${ZonedDateTime.now()}"

  initialize()
}

----------------------------------------

TITLE: Defining and Using Inline Methods in Scala 3
DESCRIPTION: Illustrates how to define an inline method in Scala 3 and how it is expanded at the call-site during compile-time.

LANGUAGE: scala
CODE:
inline def logged[T](level: Int, message: => String)(inline op: T): T =
  println(s"[$level]Computing $message")
  val res = op
  println(s"[$level]Result of $message: $res")
  res

----------------------------------------

TITLE: Compound and Structural Types in Scala Quasiquotes
DESCRIPTION: Demonstrates compound type creation with 'with' keyword and structural type refinements.

LANGUAGE: scala
CODE:
val compound = tq"A with B with C"
val tq"..$parents { ..$defns }" = compound

val structural = tq"{ val x: Int; val y: Int }"

----------------------------------------

TITLE: Setting Versions Dictionary URL in SBT
DESCRIPTION: SBT configuration that specifies the URL of the versions dictionary JSON file during documentation generation.

LANGUAGE: scala
CODE:
doc / scalacOptions ++= Seq("-versions-dictionary-url", "https://dotty.epfl.ch/versions.json")

----------------------------------------

TITLE: For Comprehension with Tuples in Scala 2
DESCRIPTION: Demonstrates using for comprehension to iterate over and process tuple pairs.

LANGUAGE: scala
CODE:
val numPairs = List((2, 5), (3, -7), (20, 56))
for ((a, b) <- numPairs) {
  println(a * b)
}

----------------------------------------

TITLE: Creating and Using Blocks in Scala
DESCRIPTION: Demonstrates how to create a block of expressions in Scala using curly braces, where the result of the last expression is the result of the block.

LANGUAGE: scala
CODE:
println({
  val x = 1 + 1
  x + 1
}) // 3

----------------------------------------

TITLE: Reading and Writing Raw JSON Files in Scala
DESCRIPTION: Demonstrates how to read JSON from a file, modify its content, and write it back to a new file using ujson and OS-Lib libraries.

LANGUAGE: scala
CODE:
// read a JSON file
val json = ujson.read(os.read(os.pwd / "raw.json"))

// modify the JSON content
json("updated") = "now"

//write to a new file
os.write(os.pwd / "raw-updated.json", ujson.write(json))

----------------------------------------

TITLE: Comparing Instances of Different Classes with Universal Equality
DESCRIPTION: This example demonstrates how universal equality allows comparison between instances of different classes, which may not be desirable.

LANGUAGE: scala
CODE:
case class Cat(name: String)
case class Dog(name: String)
val d = Dog("Fido")
val c = Cat("Morris")

d == c  // false, but it compiles

----------------------------------------

TITLE: Defining Custom Case Class for JSON Serialization
DESCRIPTION: Creates a PetOwner case class that will be used for JSON serialization, containing an owner's name and a list of pet names.

LANGUAGE: scala
CODE:
case class PetOwner(name: String, pets: List[String])

----------------------------------------

TITLE: Implementing foreach method in Scala's Iterable trait
DESCRIPTION: This snippet shows the implementation of the foreach method in the Iterable trait, which uses the abstract iterator method to traverse elements.

LANGUAGE: scala
CODE:
def foreach[U](f: Elem => U): Unit = {
  val it = iterator
  while (it.hasNext) f(it.next())
}

----------------------------------------

TITLE: Using String Interpolation in Scala
DESCRIPTION: This snippet demonstrates string interpolation in Scala, which provides a more convenient way to insert variables into strings.

LANGUAGE: scala
CODE:
val name = s"$firstName $mi $lastName"

----------------------------------------

TITLE: Stack Trace Example of Thread Safety Issue in Scala Reflection
DESCRIPTION: Example stack trace showing a typical manifestation of thread safety issues in Scala reflection, specifically related to symbol initialization and type reference computation.

LANGUAGE: java
CODE:
java.lang.NullPointerException:
at s.r.i.Types$TypeRef.computeHashCode(Types.scala:2332)
at s.r.i.Types$UniqueType.<init>(Types.scala:1274)
at s.r.i.Types$TypeRef.<init>(Types.scala:2315)
at s.r.i.Types$NoArgsTypeRef.<init>(Types.scala:2107)
at s.r.i.Types$ModuleTypeRef.<init>(Types.scala:2078)
at s.r.i.Types$PackageTypeRef.<init>(Types.scala:2095)
at s.r.i.Types$TypeRef$.apply(Types.scala:2516)
at s.r.i.Types$class.typeRef(Types.scala:3577)
at s.r.i.SymbolTable.typeRef(SymbolTable.scala:13)
at s.r.i.Symbols$TypeSymbol.newTypeRef(Symbols.scala:2754)

----------------------------------------

TITLE: Basic HTML Static File Example
DESCRIPTION: A minimal HTML file showing the structure of a static webpage to be served

LANGUAGE: html
CODE:
<!doctype html>
<html>
    <head>
        <title>Hello World</title>
    </head>
    <body>
        <h1>Hello world</h1>
    </body>
</html>

----------------------------------------

TITLE: Dynamic Time Endpoint with City Parameter
DESCRIPTION: Enhanced version of time endpoint that accepts city as a path parameter and returns time in that city's timezone. Uses path segments feature of Cask.

LANGUAGE: scala
CODE:
import java.time.{ZoneId, ZonedDateTime}

object Example extends cask.MainRoutes {

  private def getZoneIdForCity(city: String): Option[ZoneId] = {
    import scala.jdk.CollectionConverters._
    ZoneId.getAvailableZoneIds.asScala.find(_.endsWith("/" + city)).map(ZoneId.of)
  }

  @cask.get("/time/:city")
  def dynamicWithCity(city: String): String = {
    getZoneIdForCity(city) match {
      case Some(zoneId) => s"Current date is: ${ZonedDateTime.now().withZoneSameInstant(zoneId)}"
      case None => s"Couldn't find time zone for city $city"
    }
  }

  initialize()
}

----------------------------------------

TITLE: Proposed RuntimeCheck Annotation Definition
DESCRIPTION: Definition of the new RuntimeCheck annotation class in the scala.annotation.internal package.

LANGUAGE: scala
CODE:
package scala.annotation.internal

final class RuntimeCheck extends Annotation

----------------------------------------

TITLE: Disabling Compilation for Specific Scala Snippets
DESCRIPTION: This example demonstrates how to disable compilation for specific snippets using the 'nocompile' flag.

LANGUAGE: scala
CODE:
// under the hood `map` is transformed into
List(1).map( _  + 1)(<implicits>)

----------------------------------------

TITLE: Illustrating Limitations of Type Inference with Null in Scala
DESCRIPTION: This example demonstrates a case where relying on type inference can lead to overly specific types, causing compilation errors in subsequent assignments.

LANGUAGE: scala
CODE:
var obj = null

LANGUAGE: scala
CODE:
obj = new AnyRef

----------------------------------------

TITLE: Adding List Parameter to Map Function
DESCRIPTION: Adding List[Int] parameter to the map function definition.

LANGUAGE: scala
CODE:
def map[A](f: (Int) => A, xs: List[Int])

----------------------------------------

TITLE: Nesting Packages in Scala 3
DESCRIPTION: Demonstrates the Scala 3 syntax for nesting packages. Note the use of colons instead of curly braces.

LANGUAGE: scala
CODE:
package users:
  package administrators:
    class NormalUser

  package normalusers:
    class NormalUser

----------------------------------------

TITLE: Configuring MiMa for Binary Compatibility Checks
DESCRIPTION: sbt configuration for setting up MiMa to check binary compatibility between versions.

LANGUAGE: scala
CODE:
mimaPreviousArtifacts := previousStableVersion.value.map(organization.value %% name.value % _).toSet

----------------------------------------

TITLE: Using Buffers in Scala
DESCRIPTION: This code snippet demonstrates the usage of buffers in Scala, which are mutable sequences that allow efficient element manipulation, including addition, insertion, and removal.

LANGUAGE: scala
CODE:
import scala.collection.mutable.ArrayBuffer

val buf = ArrayBuffer(1, 2, 3)

// Addition
buf += 4  // ArrayBuffer(1, 2, 3, 4)
buf ++= Seq(5, 6)  // ArrayBuffer(1, 2, 3, 4, 5, 6)

// Insertion
buf.insert(0, 0)  // ArrayBuffer(0, 1, 2, 3, 4, 5, 6)

// Removal
buf -= 3  // ArrayBuffer(0, 1, 2, 4, 5, 6)
buf.remove(1, 2)  // ArrayBuffer(0, 4, 5, 6)

// Clearing
buf.clear()  // ArrayBuffer()

----------------------------------------

TITLE: Creating and Using a Simple Future in Scala
DESCRIPTION: Demonstrates how to create a Future from a long-running task and check its completion status.

LANGUAGE: scala
CODE:
import scala.concurrent.Future
import scala.concurrent.ExecutionContext.Implicits.global
import scala.util.{Failure, Success}

def longRunningAlgorithm() =
  Thread.sleep(10_000)
  42

val eventualInt = Future(longRunningAlgorithm())

----------------------------------------

TITLE: Using Compiler Options with scalac (Bash)
DESCRIPTION: Demonstrates how to use various types of compiler options with the scalac command, including boolean flags, options with arguments, and single-argument options.

LANGUAGE: bash
CODE:
scalac [ <options> ] <source files>

scalac -Werror -Xlint Hello.scala

scalac -Vprint:parser,typer

scalac -d /tmp

----------------------------------------

TITLE: Scala Traits Implementation
DESCRIPTION: Example showing trait definitions and class inheritance in Scala.

LANGUAGE: scala
CODE:
trait Speaker {
    def speak(): String  // has no body, so it's abstract
}

trait TailWagger {
    def startTail(): Unit = println("tail is wagging")
    def stopTail(): Unit = println("tail is stopped")
}

trait Runner {
    def startRunning(): Unit = println("I'm running")
    def stopRunning(): Unit = println("Stopped running")
}

----------------------------------------

TITLE: Tuple Pattern Matching Assignment in Scala
DESCRIPTION: Shows how to use pattern matching to assign tuple elements to individual variables.

LANGUAGE: scala
CODE:
val (symbol, currentPrice, bidPrice) = getStockInfo

----------------------------------------

TITLE: For Comprehension with Multiple Options in Scala
DESCRIPTION: Example of using for comprehension to handle multiple Option values, showing how to combine multiple conversions and handle their results together.

LANGUAGE: scala
CODE:
val y = for
  a <- makeInt(stringA)
  b <- makeInt(stringB)
  c <- makeInt(stringC)
yield
  a + b + c

----------------------------------------

TITLE: Configuring Scalafmt for Scala 3 Formatting
DESCRIPTION: Demonstrates how to configure the Scalafmt formatter to support Scala 3 syntax, including selective enabling for specific file patterns.

LANGUAGE: conf
CODE:
//.scalafmt.conf
fileOverride {
  "glob:**/scala-3*/**" {
    runner.dialect = scala3
  }
}

----------------------------------------

TITLE: Defining List and Vector map operations in Scala
DESCRIPTION: Shows how the map operation is defined differently for List and Vector collection types.

LANGUAGE: scala
CODE:
trait List[A]:
  def map[B](f: A => B): List[B]

trait Vector[A]:
  def map[B](f: A => B): Vector[B]

----------------------------------------

TITLE: First Version of RNA Strands Class in Scala
DESCRIPTION: Implements a basic RNA sequence class with packed representation of bases.

LANGUAGE: scala
CODE:
import collection.IndexedSeqLike
import collection.mutable.{Builder, ArrayBuffer}
import collection.generic.CanBuildFrom

final class RNA1 private (val groups: Array[Int],
    val length: Int) extends IndexedSeq[Base] {

  import RNA1._

  def apply(idx: Int): Base = {
    if (idx < 0 || length <= idx)
      throw new IndexOutOfBoundsException
    Base.fromInt(groups(idx / N) >> (idx % N * S) & M)
  }
}

object RNA1 {

  // Number of bits necessary to represent group
  private val S = 2            

  // Number of groups that fit in an Int
  private val N = 32 / S       

  // Bitmask to isolate a group
  private val M = (1 << S) - 1

  def fromSeq(buf: Seq[Base]): RNA1 = {
    val groups = new Array[Int]((buf.length + N - 1) / N)
    for (i <- 0 until buf.length)
      groups(i / N) |= Base.toInt(buf(i)) << (i % N * S)
    new RNA1(groups, buf.length)
  }

  def apply(bases: Base*) = fromSeq(bases)
}

----------------------------------------

TITLE: Writing a File All at Once with OS-Lib in Scala
DESCRIPTION: This snippet demonstrates how to write a string to a new file using os.write. It creates a temporary file and writes two lines of text to it.

LANGUAGE: scala
CODE:
val path: os.Path = os.temp.dir() / "output.txt"
os.write(path, "hello\nthere\n")
println(os.read.lines(path).size)
// prints: 2

----------------------------------------

TITLE: Cross-Compiling Quasiquotes with SBT for Scala 2.10 and 2.11
DESCRIPTION: An sbt configuration snippet that allows cross-compilation of quasiquotes for both Scala 2.10 and 2.11, handling the different dependency requirements for each version.

LANGUAGE: scala
CODE:
libraryDependencies := {
  CrossVersion.partialVersion(scalaVersion.value) match {
    // if scala 2.11+ is used, quasiquotes are merged into scala-reflect
    case Some((2, scalaMajor)) if scalaMajor >= 11 =>
      libraryDependencies.value
    // in Scala 2.10, quasiquotes are provided by macro paradise
    case Some((2, 10)) =>
      libraryDependencies.value ++ Seq(
        compilerPlugin("org.scalamacros" % "paradise" % "2.0.0" cross CrossVersion.full),
        "org.scalamacros" %% "quasiquotes" % "2.0.0" cross CrossVersion.binary)
  }
}

----------------------------------------

TITLE: Animal Class Hierarchy Definition
DESCRIPTION: Defines a basic class hierarchy with Animal as the parent class and Cat/Dog as subclasses.

LANGUAGE: scala
CODE:
abstract class Animal {
  def name: String
}
case class Cat(name: String) extends Animal
case class Dog(name: String) extends Animal

----------------------------------------

TITLE: For Expression Implementation
DESCRIPTION: Implementation of the map function body using a for expression.

LANGUAGE: scala
CODE:
for (x <- xs) yield f(x)

LANGUAGE: scala
CODE:
for x <- xs yield f(x)

----------------------------------------

TITLE: Basic Quote and Splice Example in Scala
DESCRIPTION: Demonstrates basic usage of quoted code blocks with string interpolation using quotes ('{ ... }) and splices (${ ... })

LANGUAGE: scala
CODE:
val msg = Expr("Hello")
val printHello = '{ print($msg) }
println(printHello.show) // print("Hello")

----------------------------------------

TITLE: Defining Fruit Class and Objects in Scala
DESCRIPTION: Creates a case class Fruit and three objects (Apple, Plum, Banana) extending it within the gardening.fruits package.

LANGUAGE: scala
CODE:
// in file gardening/fruits/Fruit.scala
package gardening.fruits

case class Fruit(name: String, color: String)
object Apple extends Fruit("Apple", "green")
object Plum extends Fruit("Plum", "blue")
object Banana extends Fruit("Banana", "yellow")

----------------------------------------

TITLE: Converting Iterator to BufferedIterator in Scala
DESCRIPTION: Shows how to convert a regular iterator to a buffered iterator using the buffered method, and demonstrates the usage of head and next methods.

LANGUAGE: scala
CODE:
val it = Iterator(1, 2, 3, 4)
val bit = it.buffered
bit.head
bit.next()
bit.next()
bit.headOption

----------------------------------------

TITLE: Adding Cask Dependency in Mill Build Definition
DESCRIPTION: Demonstrates how to add Cask dependency in a Mill build file. Configures a root module with Scala version 3.4.2 and includes the Cask library dependency.

LANGUAGE: scala
CODE:
object example extends RootModule with ScalaModule {
  def scalaVersion = "3.4.2"
  def ivyDeps = Agg(
    ivy"com.lihaoyi::cask::0.10.2"
  )
}

----------------------------------------

TITLE: Demonstrating Inliner Warnings in Scala
DESCRIPTION: This code snippet demonstrates how the Scala inliner issues warnings for methods annotated with @inline that cannot be inlined. It shows the difference in behavior between a non-final method and a final method in terms of inlining.

LANGUAGE: scala
CODE:
class C {
  @inline def f = 1
  def t = f           // cannot inline: C.f is not final
}
object T extends C {
  override def t = f  // can inline: T.f is final
}

----------------------------------------

TITLE: Creating and Using Lazy Streams in Scala
DESCRIPTION: Demonstrates creation and usage of lazy Streams, including a Fibonacci sequence implementation using #:: operator for lazy evaluation.

LANGUAGE: scala
CODE:
val str = 1 #:: 2 #:: 3 #:: Stream.empty

def fibFrom(a: Int, b: Int): Stream[Int] = a #:: fibFrom(b, a + b)

val fibs = fibFrom(1, 1).take(7)
fibs.toList

----------------------------------------

TITLE: Method Returning Tuple in Scala
DESCRIPTION: Example of a method that returns a three-element tuple representing stock information.

LANGUAGE: scala
CODE:
def getStockInfo = {
    // other code here ...
    ("NFLX", 100.00, 101.00)  // this is a Tuple3
}

----------------------------------------

TITLE: Configuring build.sbt for ScalaTest
DESCRIPTION: SBT build configuration file that defines the project name, version, Scala version, and adds ScalaTest dependency

LANGUAGE: scala
CODE:
name := "HelloScalaTest"
version := "1.0"
scalaVersion := "{{site.scala-version}}"

libraryDependencies +=
    "org.scalatest" %% "scalatest" % "3.2.19" % Test

----------------------------------------

TITLE: Scala 2 Macro Error Example
DESCRIPTION: Example showing the compiler error when attempting to use a Scala 2.13 macro in Scala 3 code. The error occurs during compilation and suggests using -Xignore-scala2-macros flag.

LANGUAGE: text
CODE:
 -- Error: /src/main/scala/example/Example.scala:10:45 
 10 |  val documentFormat = Json.format[Document]
    |                            ^
    |Scala 2 macro cannot be used in Scala 3. See https://dotty.epfl.ch/docs/reference/dropped-features/macros.html
    |To turn this error into a warning, pass -Xignore-scala2-macros to the compiler

----------------------------------------

TITLE: PrefixMap Implementation with Patricia Trie
DESCRIPTION: Implementation of a mutable map using a Patricia trie data structure to store string keys efficiently.

LANGUAGE: scala
CODE:
class PrefixMap[A]
  extends mutable.Map[String, A]
    with mutable.MapOps[String, A, mutable.Map, PrefixMap[A]]
    with StrictOptimizedIterableOps[(String, A), mutable.Iterable, PrefixMap[A]] {

  private var suffixes: immutable.Map[Char, PrefixMap[A]] = immutable.Map.empty
  private var value: Option[A] = None

  def get(s: String): Option[A] =
    if (s.isEmpty) value
    else suffixes.get(s(0)).flatMap(_.get(s.substring(1)))

  def withPrefix(s: String): PrefixMap[A] =
    if (s.isEmpty) this
    else {
      val leading = s(0)
      suffixes.get(leading) match {
        case None =>
          suffixes = suffixes + (leading -> empty)
        case _ =>
      }
      suffixes(leading).withPrefix(s.substring(1))
    }

  def iterator: Iterator[(String, A)] =
    (for (v <- value.iterator) yield ("", v)) ++
      (for ((chr, m) <- suffixes.iterator;
            (s, v) <- m.iterator) yield (chr +: s, v))

  def addOne(kv: (String, A)): this.type = {
    withPrefix(kv._1).value = Some(kv._2)
    this
  }

  def subtractOne(s: String): this.type = {
    if (s.isEmpty) { val prev = value; value = None; prev }
    else suffixes.get(s(0)).flatMap(_.remove(s.substring(1)))
    this
  }
}

----------------------------------------

TITLE: Final Version of RNA Strands Class in Scala
DESCRIPTION: Complete implementation of RNA class with optimized foreach method.

LANGUAGE: scala
CODE:
final class RNA private (val groups: Array[Int], val length: Int)
  extends IndexedSeq[Base] with IndexedSeqLike[Base, RNA] {

  import RNA._

  // Mandatory re-implementation of `newBuilder` in `IndexedSeq`
  override protected[this] def newBuilder: Builder[Base, RNA] =
    RNA.newBuilder

  // Mandatory implementation of `apply` in `IndexedSeq`
  def apply(idx: Int): Base = {
    if (idx < 0 || length <= idx)
      throw new IndexOutOfBoundsException
    Base.fromInt(groups(idx / N) >> (idx % N * S) & M)
  }

  // Optional re-implementation of foreach,
  // to make it more efficient.
  override def foreach[U](f: Base => U): Unit = {
    var i = 0
    var b = 0
    while (i < length) {
      b = if (i % N == 0) groups(i / N) else b >>> S
      f(Base.fromInt(b & M))
      i += 1
    }
  }
}

----------------------------------------

TITLE: YAML Configuration for SIP Meeting Results
DESCRIPTION: YAML front matter configuration defining the layout, title, and accepted proposals from the October 21st, 2022 SIP meeting. Lists three accepted proposals with their respective URLs and names.

LANGUAGE: yaml
CODE:
---
layout: sip-meeting-results
title: SIP Meeting Results - 21st October 2022
partof: results
proposals:
  - url: https://docs.scala-lang.org/sips/fewer-braces.html
    name: SIP-44 - Fewer braces
    result: accepted
  - url: https://docs.scala-lang.org/sips/scala-cli.html
    name: SIP-46 - Use Scala CLI to implement the 'scala' command
    result: accepted
  - url: https://docs.scala-lang.org/sips/clause-interleaving.html
    name: SIP-47 - Clause Interleaving
    result: accepted
---

----------------------------------------

TITLE: Advanced Splicing in Quasiquotes with Scala
DESCRIPTION: Demonstrates more advanced splicing techniques in Scala quasiquotes, including using ...$ for nested lists and combining multiple splices in a single quasiquote.

LANGUAGE: scala
CODE:
val argss = List(ab, List(c))
val fargss = q"f(...$argss)"

----------------------------------------

TITLE: Generic Map Function Implementation
DESCRIPTION: Fully generic implementation of the map function that works with any List type.

LANGUAGE: scala
CODE:
def map[A, B](f: (B) => A, xs: List[B]): List[A] =
  for (x <- xs) yield f(x)

LANGUAGE: scala
CODE:
def map[A, B](f: (B) => A, xs: List[B]): List[A] =
  for x <- xs yield f(x)

----------------------------------------

TITLE: Basic Int Lifting Example in Scala
DESCRIPTION: Demonstrates basic lifting of Int values in quasiquotes to create a tree representation.

LANGUAGE: scala
CODE:
val two = 1 + 1
val four = q"$two + $two"

----------------------------------------

TITLE: Defining For Loops with Guards in Java and Scala
DESCRIPTION: Demonstrates how to define for loops with guards (if expressions) in Java and Scala.

LANGUAGE: java
CODE:
List ints = 
  ArrayList(1,2,3,4,5,6,7,8,9,10);

for (int i: ints) {
  if (i % 2 == 0 && i < 5) {
    System.out.println(x);
  }
}

LANGUAGE: scala
CODE:
for
  i <- 1 to 10
  if i % 2 == 0
  if i < 5
do
  println(i)

----------------------------------------

TITLE: Using a Generic Stack with Subtype Hierarchy in Scala
DESCRIPTION: This snippet illustrates how a generic Stack can be used with a subtype hierarchy. It defines Fruit, Apple, and Banana classes, and shows how a Stack of Fruit can accept instances of its subclasses.

LANGUAGE: scala
CODE:
class Fruit
class Apple extends Fruit
class Banana extends Fruit

val stack = Stack[Fruit]
val apple = Apple()
val banana = Banana()

stack.push(apple)
stack.push(banana)

----------------------------------------

TITLE: Adding Cask Dependency in SBT Build Definition
DESCRIPTION: Shows how to configure a Scala project in sbt with Cask dependency. Includes scala version specification (3.4.2), library dependency, and fork setting.

LANGUAGE: scala
CODE:
lazy val example = project.in(file("example"))
  .settings(
    scalaVersion := "3.4.2",
    libraryDependencies += "com.lihaoyi" %% "cask" % "0.10.2",
    fork := true
  )

----------------------------------------

TITLE: Implementing Extractor Macro in Scala
DESCRIPTION: Demonstrates how to implement an extractor macro that passes the scrutinee back to the pattern match. It includes the unapply method and its macro implementation.

LANGUAGE: scala
CODE:
def unapply(x: SomeType) = ???

LANGUAGE: scala
CODE:
def unapply(x: SomeType) = macro impl
def impl(c: Context)(x: c.Tree) = {
  q"""
    new {
      class Match(x: SomeType) {
        def isEmpty = false
        def get = x
      }
      def unapply(x: SomeType) = new Match(x)
    }.unapply($x)
  """
}

----------------------------------------

TITLE: Upcasting Macro Expansion for Blackbox Compatibility
DESCRIPTION: Example of explicitly upcasting a macro expansion to make it work as a blackbox macro in both Scala 2.10.x and 2.11.0.

LANGUAGE: scala
CODE:
object Macros {
  def impl(c: Context) = {
    import c.universe._
    q"(new { val x = 2 }): Any" // note the explicit type ascription
  }

  def foo: Any = macro impl
}

object Test extends App {
  // consistently doesn't work in Scala 2.10.x and Scala 2.11.0
  // regardless of whether foo is whitebox or blackbox
  println(Macros.foo.x)
}

----------------------------------------

TITLE: Examples of Statements in Scala
DESCRIPTION: Illustrates examples of statements in Scala, which are used for their side effects and do not return values.

LANGUAGE: scala
CODE:
if (a == b) doSomething()
println("Hello")

----------------------------------------

TITLE: Expression Summoning from Type
DESCRIPTION: Demonstrates summoning an expression from a Type using pattern matching and type parameters.

LANGUAGE: scala
CODE:
val tpe: Type[_] = ...
tpe match
  // (1) Use `a` as the name of the unknown type and (2) bring a given `Type[a]` into scope
  case '[a] => Expr.summon[a]

----------------------------------------

TITLE: Configuring Scala 3 Cross-Version Dependencies in sbt
DESCRIPTION: Shows how to configure library dependencies for cross-compilation between Scala 2.13 and Scala 3 using sbt 1.5's new cross-version syntax.

LANGUAGE: scala
CODE:
// Use a Scala 2.13 library in Scala 3
libraryDependency += ("org.foo" %% "foo" % "1.0.0").cross(CrossVersion.for3Use2_13)

// Use a Scala 3 library in Scala 2.13 
libraryDependency += ("org.bar" %% "bar" % "1.0.0").cross(CrossVersion.for2_13Use3)

----------------------------------------

TITLE: Promise Creation and Completion
DESCRIPTION: Shows how to create and complete a Promise which can be used to create and complete a Future

LANGUAGE: scala
CODE:
import scala.concurrent.{ Future, Promise }

val p = Promise[T]()
val f = p.future

val producer = Future {
  val r = produceSomething()
  p success r
  continueDoingSomethingUnrelated()
}

----------------------------------------

TITLE: Basic Integer Conversion with Exception Handling in Scala
DESCRIPTION: A basic method that converts strings to integers using try-catch, returning 0 for failed conversions. This demonstrates traditional error handling but has limitations in distinguishing between actual zeros and conversion failures.

LANGUAGE: scala
CODE:
def makeInt(s: String): Int =
  try
    Integer.parseInt(s.trim)
  catch
    case e: Exception => 0

----------------------------------------

TITLE: Using Inline Constants in Scala 3
DESCRIPTION: Shows how inline constants are used and evaluated at compile-time in Scala 3.

LANGUAGE: scala
CODE:
val pi2 = pi + pi // val pi2 = 6.283185307179586
val pie2 = pie + pie // val pie2 = "🥧🥧"

----------------------------------------

TITLE: Implementing Fibonacci Iterator in Current Scala
DESCRIPTION: Current implementation of a Fibonacci sequence iterator showing the verbose approach needed without multiple assignments.

LANGUAGE: scala
CODE:
class FibonacciIterator() extends Iterator[Int]:

  private var a: Int = 0
  private var b: Int = 1

  def hasNext = true
  def next() =
    val r = a
    val n = a + b
    a = b
    b = n
    r

----------------------------------------

TITLE: Liftable Trait Definition in Scala
DESCRIPTION: Shows the core Liftable trait definition that enables custom type lifting.

LANGUAGE: scala
CODE:
trait Liftable[T] {
  def apply(value: T): Tree
}

----------------------------------------

TITLE: Implicit Class Scope Examples in Scala
DESCRIPTION: Demonstrates valid and invalid scope declarations for implicit classes, showing they must be defined inside another trait/class/object.

LANGUAGE: scala
CODE:
object Helpers {
   implicit class RichInt(x: Int) // OK!
}
implicit class RichDouble(x: Double) // BAD!

----------------------------------------

TITLE: Enabling Comparisons with CanEqual in Scala 3
DESCRIPTION: This example demonstrates two ways to enable comparisons between instances of the same class using the CanEqual type class in Scala 3.

LANGUAGE: scala
CODE:
// Option 1
case class Dog(name: String) derives CanEqual

// Option 2
case class Dog(name: String)
given CanEqual[Dog, Dog] = CanEqual.derived

----------------------------------------

TITLE: Configuring Macro Paradise Plugin in Maven for Scala
DESCRIPTION: This XML snippet demonstrates how to configure the Macro Paradise compiler plugin in a Maven project's pom.xml file. It includes the plugin configuration with a placeholder for the Scala version.

LANGUAGE: xml
CODE:
<compilerPlugins>
  <compilerPlugin>
    <groupId>org.scalamacros</groupId>
    <artifactId>paradise_<YOUR.SCALA.VERSION></artifactId>
    <version>2.1.0</version>
  </compilerPlugin>
</compilerPlugins>

----------------------------------------

TITLE: Defining Single-Line Methods in Java and Scala
DESCRIPTION: Shows how to define single-line methods in Java and Scala. Scala's syntax is more concise.

LANGUAGE: java
CODE:
public int add(int a, int b) {
  return a + b;
}

LANGUAGE: scala
CODE:
def add(a: Int, b: Int): Int = a + b

----------------------------------------

TITLE: Dynamic JSON Handling with ujson.Value
DESCRIPTION: Demonstrates handling dynamic JSON structures using ujson.Value type from uPickle library. Allows processing of JSON with unknown field structure.

LANGUAGE: scala
CODE:
object Example extends cask.MainRoutes {

  @cask.postJson("/json")
  def jsonEndpoint(value: ujson.Value): String =
    value.toString

  initialize()
}

----------------------------------------

TITLE: Using FieldMirror to Access and Modify Fields in Scala
DESCRIPTION: Demonstrates creating and using FieldMirrors to get and set instance fields reflectively.

LANGUAGE: scala
CODE:
scala> class C { val x = 2; var y = 3 }
defined class C

scala> val m = ru.runtimeMirror(getClass.getClassLoader)
m: scala.reflect.runtime.universe.Mirror = JavaMirror ...

scala> val im = m.reflect(new C)
im: scala.reflect.runtime.universe.InstanceMirror = instance mirror for C@5f0c8ac1

scala> val fieldX = ru.typeOf[C].decl(ru.TermName("x")).asTerm.accessed.asTerm
fieldX: scala.reflect.runtime.universe.TermSymbol = value x

scala> val fmX = im.reflectField(fieldX)
fmX: scala.reflect.runtime.universe.FieldMirror = field mirror for C.x (bound to C@5f0c8ac1)

scala> fmX.get
res0: Any = 2

scala> fmX.set(3)

scala> val fieldY = ru.typeOf[C].decl(ru.TermName("y")).asTerm.accessed.asTerm
fieldY: scala.reflect.runtime.universe.TermSymbol = variable y

scala> val fmY = im.reflectField(fieldY)
fmY: scala.reflect.runtime.universe.FieldMirror = field mirror for C.y (bound to C@5f0c8ac1)

scala> fmY.get
res1: Any = 3

scala> fmY.set(4)

scala> fmY.get
res2: Any = 4

----------------------------------------

TITLE: Mapping Iterator Elements in Scala
DESCRIPTION: Demonstrates how to use the map method on an iterator to transform its elements. Note that this operation advances the iterator to its end.

LANGUAGE: scala
CODE:
val it = Iterator("a", "number", "of", "words")
it.map(_.length)

----------------------------------------

TITLE: Creating Lists in Scala
DESCRIPTION: Demonstrates different ways to create lists in Scala, including direct initialization and using the range method.

LANGUAGE: scala
CODE:
val ints = List(1,2,3)

LANGUAGE: scala
CODE:
val ints = List.range(1, 10)

----------------------------------------

TITLE: Configuring SBT Documentation Settings for Scala
DESCRIPTION: Example showing how to configure Scaladoc output directory and project name in SBT build definition.

LANGUAGE: scala
CODE:
Compile / doc / target := file("output"),
Compile / doc / scalacOptions ++= Seq("-project", "my-project"),

----------------------------------------

TITLE: Inheritance Shadowing Example in Scala
DESCRIPTION: Demonstrates how inherited members can shadow identifiers in outer scopes, which requires explicit disambiguation in Scala 3.

LANGUAGE: scala
CODE:
object B {
  val x = 1
  class C extends A {
    println(x)
  }
}

----------------------------------------

TITLE: Basic Opaque Type Definition
DESCRIPTION: Example showing how to define and use an opaque type Logarithm to wrap Double values

LANGUAGE: scala
CODE:
package object opaquetypes {
  opaque type Logarithm = Double

  object Logarithm {
    def apply(d: Double): Logarithm = math.log(d)
    def safe(d: Double): Option[Logarithm] =
      if (d > 0.0) Some(math.log(d)) else None
    def exponent(l: Logarithm): Double = l

    implicit class LogarithmOps(val `this`: Logarithm) extends AnyVal {
      def toDouble: Double = math.exp(`this`)
      def +(that: Logarithm): Logarithm = Logarithm(math.exp(`this`) + math.exp(that))
      def *(that: Logarithm): Logarithm = Logarithm(`this` + that)
    }
  }
}

----------------------------------------

TITLE: Option-based Integer Conversion in Scala
DESCRIPTION: An improved version using Option type that converts strings to integers, returning Some(int) for successful conversions and None for failures. This provides better error handling by making the failure case explicit.

LANGUAGE: scala
CODE:
def makeInt(s: String): Option[Int] =
  try
    Some(Integer.parseInt(s.trim))
  catch
    case e: Exception => None

----------------------------------------

TITLE: Running Single Test Suite Commands
DESCRIPTION: Command examples for running a single test suite named 'example.MyTests' using different build tools (Scala CLI, sbt, and Mill).

LANGUAGE: bash
CODE:
scala-cli test example --test-only example.MyTests

LANGUAGE: bash
CODE:
sbt:example> testOnly example.MyTests

LANGUAGE: bash
CODE:
./mill example.test.testOnly example.MyTests

----------------------------------------

TITLE: Applied Types in Scala Quasiquotes
DESCRIPTION: Shows how to work with parameterized types and type arguments in quasiquotes.

LANGUAGE: scala
CODE:
val applied = tq"Foo[A, B]"
val tq"Foo[..$targs]" = applied

----------------------------------------

TITLE: Implicit Class Constructor Examples in Scala
DESCRIPTION: Shows valid and invalid constructor patterns for implicit classes, illustrating the single non-implicit argument restriction.

LANGUAGE: scala
CODE:
implicit class RichDate(date: java.time.LocalDate) // OK!
implicit class Indexer[T](collection: Seq[T], index: Int) // BAD!
implicit class Indexer[T](collection: Seq[T])(implicit index: Index) // OK!

----------------------------------------

TITLE: Single Test Selection with .only Modifier - Scala 2
DESCRIPTION: Example of using .only modifier to run a specific test within a test suite in Scala 2. Only the multiplication test will run while the addition test is ignored.

LANGUAGE: scala
CODE:
class MathSuite extends munit.FunSuite {
  test("addition") {
    assert(1 + 1 == 2)
  }
  test("multiplication".only) {
    assert(3 * 7 == 21)
  }
}

----------------------------------------

TITLE: Universal Trait Implementation with Value Class
DESCRIPTION: Demonstrates how to combine universal traits with value classes for basic method inheritance.

LANGUAGE: scala
CODE:
trait Printable extends Any {
  def print(): Unit = println(this)
}
class Wrapper(val underlying: Int) extends AnyVal with Printable

----------------------------------------

TITLE: Example of Regular Scala Compiler Output for Implicit Error
DESCRIPTION: Demonstrates the standard compiler output for an implicit resolution error, showing the limited information provided without the enhanced formatting.

LANGUAGE: scala
CODE:
[error] /path/Example.scala:20:5: could not find implicit value for parameter a: io.circe.Decoder[A]
[error]   A.fun
[error]     ^

----------------------------------------

TITLE: Defining User-Defined Enum Members in Java and Scala
DESCRIPTION: Demonstrates how to define enums with user-defined members in Java and Scala.

LANGUAGE: java
CODE:
enum Planet {
  MERCURY (3.303e+23, 2.4397e6),
  VENUS   (4.869e+24, 6.0518e6),
  EARTH   (5.976e+24, 6.37814e6);
  // more planets ...

  private final double mass;
  private final double radius;

  Planet(double mass, double radius) {
    this.mass = mass;
    this.radius = radius;
  }

  public static final double G = 
    6.67300E-11;

  private double mass() {
    return mass;
  }

  private double radius() {
    return radius;
  }

  double surfaceGravity() {
    return G * mass / 
      (radius * radius);
  }

  double surfaceWeight(
    double otherMass
  ) {
    return otherMass *
      surfaceGravity();
  }

}

LANGUAGE: scala
CODE:
enum Planet(
  mass: Double, 
  radius: Double
):
  case Mercury extends 
    Planet(3.303e+23, 2.4397e6)
  case Venus extends 
    Planet(4.869e+24, 6.0518e6)
  case Earth extends 
    Planet(5.976e+24, 6.37814e6)
    // more planets ...

  private final val G = 6.67300E-11

  def surfaceGravity = 
    G * mass / (radius * radius)

  def surfaceWeight(otherMass: Double)
    = otherMass * surfaceGravity

----------------------------------------

TITLE: Sending JSON Request with STTP in Scala 3
DESCRIPTION: Shows how to send a JSON payload using Scala 3 syntax with STTP client. The example updates a user's profile on GitHub's API using a PATCH request with bearer token authentication.

LANGUAGE: scala
CODE:
import sttp.client4.quick.*

val json = ujson.Obj(
  "location" -> "hometown",
  "bio" -> "Scala programmer"
)

val response = quickRequest
  .patch(uri"https://api.github.com/user")
  .auth.bearer(sys.env("GITHUB_TOKEN"))
  .header("Content-Type", "application/json")
  .body(ujson.write(json))
  .send()

println(response.code)
// prints: 200

println(response.body)
// prints the full updated profile in JSON

----------------------------------------

TITLE: Implementing ParStringCombiner
DESCRIPTION: Custom combiner implementation for ParString that efficiently combines and builds parallel strings.

LANGUAGE: scala
CODE:
private class ParStringCombiner extends Combiner[Char, ParString] {
  var sz = 0
  val chunks = new ArrayBuffer[StringBuilder] += new StringBuilder
  var lastc = chunks.last

  def size: Int = sz
  def +=(elem: Char): this.type = {
    lastc += elem
    sz += 1
    this
  }
  def clear = {
    chunks.clear
    chunks += new StringBuilder
    lastc = chunks.last
    sz = 0
  }
  def result: ParString = {
    val rsb = new StringBuilder
    for (sb <- chunks) rsb.append(sb)
    new ParString(rsb.toString)
  }
}

----------------------------------------

TITLE: Identifiers and Selections in Scala Quasiquotes
DESCRIPTION: Demonstrates working with identifiers and member selections including handling backquoted identifiers and name extraction.

LANGUAGE: scala
CODE:
val name = TermName("Foo")
val foo = q"$name"
val backquoted = q"`$name`"

----------------------------------------

TITLE: Defining a Basic Macro Annotation in Scala
DESCRIPTION: Demonstrates how to define a simple macro annotation called 'identity' that logs its annottees. It includes the necessary imports and class definition with the macroTransform method.

LANGUAGE: scala
CODE:
import scala.annotation.{StaticAnnotation, compileTimeOnly}
import scala.language.experimental.macros
import scala.reflect.macros.whitebox

@compileTimeOnly("enable macro paradise to expand macro annotations")
class identity extends StaticAnnotation {
  def macroTransform(annottees: Any*): Any = macro ???
}

----------------------------------------

TITLE: Demonstrating Type Inference for Variables in Scala
DESCRIPTION: This snippet shows how Scala can infer the type of a variable without an explicit type declaration. The compiler determines that 'businessName' is of type String based on the assigned value.

LANGUAGE: scala
CODE:
val businessName = "Montreux Jazz Café"

----------------------------------------

TITLE: Scala REPL with Dependencies Example
DESCRIPTION: Example showing how to start a Scala REPL with third-party dependencies using Scala CLI

LANGUAGE: shell
CODE:
scala-cli repl --dep com.lihaoyi::os-lib:0.7.8

----------------------------------------

TITLE: SIP-16 Metadata Definition in Markdown
DESCRIPTION: YAML frontmatter metadata defining the title, status and pull request number for SIP-16 proposal document

LANGUAGE: markdown
CODE:
---
title: SIP-16 - Self-cleaning Macros
status: rejected
pull-request-number: 15

---

----------------------------------------

TITLE: Using Try Pattern Results in Scala
DESCRIPTION: Shows how to handle Try results using match expressions and for comprehensions.

LANGUAGE: scala
CODE:
toInt(x) match {
    case Success(i) => println(i)
    case Failure(s) => println(s"Failed. Reason: $s")
}

val y = for {
    a <- toInt(stringA)
    b <- toInt(stringB)
    c <- toInt(stringC)
} yield a + b + c

----------------------------------------

TITLE: Universal Trait Implementation with Value Class
DESCRIPTION: Demonstrates how to combine universal traits with value classes for basic method inheritance.

LANGUAGE: scala
CODE:
trait Printable extends Any {
  def print(): Unit = println(this)
}
class Wrapper(val underlying: Int) extends AnyVal with Printable

----------------------------------------

TITLE: YAML Frontend Matter for SIP Meeting Results
DESCRIPTION: YAML configuration block defining the layout, title, and status of Scala Improvement Proposals discussed during the meeting. Contains metadata about two proposals under review.

LANGUAGE: yaml
CODE:
---
layout: sip-meeting-results
title: SIP Meeting Results - 16th September 2022
partof: results
proposals:
  - url: https://github.com/scala/improvement-proposals/pull/47
    name: SIP-47 - Clause Interleaving
    result: under-review
  - url: https://github.com/scala/improvement-proposals/pull/46
    name: SIP-46 - Use Scala CLI to implement the 'scala' command
    result: under-review
---

----------------------------------------

TITLE: Implementing Concrete Integer Sequence Buffer in Scala
DESCRIPTION: Demonstrates concrete implementation of abstract types using anonymous class instantiation. Creates a buffer specifically for integer sequences.

LANGUAGE: scala
CODE:
abstract class IntSeqBuffer extends SeqBuffer {
  type U = Int
}

def newIntSeqBuf(elem1: Int, elem2: Int): IntSeqBuffer =
  new IntSeqBuffer {
    type T = List[U]
    val element = List(elem1, elem2)
  }
val buf = newIntSeqBuf(7, 8)
println("length = " + buf.length)
println("content = " + buf.element)

----------------------------------------

TITLE: Implementing Self-Types with User and Tweeter Example in Scala 3
DESCRIPTION: Shows self-type implementation in Scala 3 syntax, demonstrating the same Twitter-like system where Tweeter requires User trait. Illustrates the syntax differences in Scala 3 including the removal of curly braces and different trait mixing syntax.

LANGUAGE: scala
CODE:
trait User:
  def username: String

trait Tweeter:
  this: User =>  // reassign this
  def tweet(tweetText: String) = println(s"$username: $tweetText")

class VerifiedTweeter(val username_ : String) extends Tweeter, User:  // We mixin User because Tweeter required it
  def username = s"real $username_"

val realBeyoncé = VerifiedTweeter("Beyoncé")
realBeyoncé.tweet("Just spilled my glass of lemonade")  // prints "real Beyoncé: Just spilled my glass of lemonade"

----------------------------------------

TITLE: Failing Test Example in Scala
DESCRIPTION: Example of a failing test case in Scala that demonstrates assertion failure output. The test compares two values that don't match to show how failures are reported.

LANGUAGE: scala
CODE:
test("failing test") {
  val obtained = 2 + 3
  val expected = 4
  assertEquals(obtained, expected)
}

----------------------------------------

TITLE: Equivalent Java Static Members
DESCRIPTION: Shows how the Scala @static members are represented in equivalent Java code.

LANGUAGE: java
CODE:
class Foo {
  public static int x = 5;
  public static int bar(int y) {
    return x + y;
  }
}

----------------------------------------

TITLE: Proposed Desugaring of Binary Operators in Scala
DESCRIPTION: This code block outlines the proposed change to the desugaring of binary operators, which preserves laziness for by-name parameters.

LANGUAGE: text
CODE:
A left-associative binary
operation `e1 op e2` is interpreted as `e1.op(e2)`. If `op` is
right-associative and its parameter is passed by name, the same operation is interpreted as
`e2.op(e1)`. If `op` is right-associative and its parameter is passed by value,
it is interpreted as `{ val x=e1; e2.op(x) }`, where `x` is a fresh name.

----------------------------------------

TITLE: Collections Operations in Python and Scala
DESCRIPTION: Shows how to perform common operations on collections like mapping and filtering in Python and Scala.

LANGUAGE: python
CODE:
x = [i * 10 for i in numbers]

evens = [i for i in numbers if i % 2 == 0]

x = [i * 10 for i in numbers if i % 2 == 0]

x = map(lambda x: x * 10, numbers)

f = lambda x: x > 1
x = filter(f, numbers)

LANGUAGE: scala
CODE:
val x = for i <- numbers yield i * 10

val evens = numbers.filter(_ % 2 == 0)
// or
val evens = for i <- numbers if i % 2 == 0 yield i

val x = numbers.filter(_ % 2 == 0).map(_ * 10)
// or
val x = for i <- numbers if i % 2 == 0 yield i * 10

val x = numbers.map(_ * 10)

val x = numbers.filter(_ > 1)

----------------------------------------

TITLE: MiMa Binary Issue Filter in sbt
DESCRIPTION: Shows how to add a MiMa binary issue filter in sbt to exclude specific compatibility problems.

LANGUAGE: scala
CODE:
import com.typesafe.tools.mima.core._
mimaBinaryIssueFilters += ProblemFilters.exclude[DirectMissingMethodProblem]("Person.this")

----------------------------------------

TITLE: Defining a Generic Macro in Scala
DESCRIPTION: Shows how to define a generic macro 'map' for a Queryable class, including type parameters.

LANGUAGE: scala
CODE:
class Queryable[T] {
 def map[U](p: T => U): Queryable[U] = macro QImpl.map[T, U]
}

object QImpl {
 def map[T: c.WeakTypeTag, U: c.WeakTypeTag]
        (c: Context)
        (p: c.Expr[T => U]): c.Expr[Queryable[U]] = ...
}

----------------------------------------

TITLE: Simple Method Examples in Scala
DESCRIPTION: These examples demonstrate two simple methods: 'sum' for adding integers and 'concatenate' for joining strings. Both methods explicitly declare their return types.

LANGUAGE: scala
CODE:
def sum(a: Int, b: Int): Int = a + b
def concatenate(s1: String, s2: String): String = s1 + s2

----------------------------------------

TITLE: Defining URI Extension Methods in Scala
DESCRIPTION: Example of defining an extension method for the URI class to add a / operation.

LANGUAGE: scala
CODE:
import java.net.URI

object URIExtensions:
  extension (uri: URI)
    def /(child: String): URI = uri.resolve(child)

def app2(): Unit =
  import URIExtensions.*
  val rootURI = new URI("https://www.example.com/")
  val projectURI = rootURI / "project/"

----------------------------------------

TITLE: Configuring Jekyll Layout for SIP-17 Documentation
DESCRIPTION: YAML front matter for configuring a Jekyll-based webpage layout for the SIP-17 documentation. It specifies metadata such as title, stage, status, and permalink for the Type Dynamic proposal.

LANGUAGE: yaml
CODE:
---
layout: sip
title: SIP-17 - Type Dynamic
stage: completed
status: shipped
permalink: /sips/:title.html
redirect_from: /sips/pending/type-dynamic.html
---

----------------------------------------

TITLE: Computing Square Roots with Concurrent Tries in Scala
DESCRIPTION: This snippet demonstrates using a ParTrieMap to iteratively compute square roots of numbers. It removes converged values from the map during traversal, showcasing the concurrent trie's ability to handle modifications.

LANGUAGE: scala
CODE:
case class Entry(num: Double) {
  var sqrt = num
}

val length = 50000

// prepare the list
val entries = (1 until length) map { num => Entry(num.toDouble) }
val results = ParTrieMap()
for (e <- entries) results += ((e.num, e))

// compute square roots
while (results.nonEmpty) {
  for ((num, e) <- results) {
    val nsqrt = 0.5 * (e.sqrt + e.num / e.sqrt)
    if (math.abs(nsqrt - e.sqrt) < 0.01) {
      results.remove(num)
    } else e.sqrt = nsqrt
  }
}

----------------------------------------

TITLE: Declaring Immutable and Mutable Variables in Scala
DESCRIPTION: This snippet demonstrates how to create immutable (val) and mutable (var) variables in Scala. It shows the basic syntax for declaring variables without explicit type annotations.

LANGUAGE: scala
CODE:
// immutable
val a = 0

// mutable
var b = 1

----------------------------------------

TITLE: YAML Frontmatter Configuration for SIP Meeting Results
DESCRIPTION: YAML configuration block defining the layout, title, and proposal results from the SIP meeting. Contains metadata about accepted proposals including their GitHub URLs and names.

LANGUAGE: yaml
CODE:
---
layout: sip-meeting-results
title: SIP Meeting Results - 19th April 2024
partof: results
proposals:
  - url: https://github.com/scala/improvement-proposals/pull/72
    name: SIP-58 - Named Tuples
    result: accepted
  - url: https://github.com/scala/improvement-proposals/pull/79
    name: SIP-62 - For comprehension improvements
    result: accepted
  - url: https://github.com/scala/improvement-proposals/pull/81
    name: SIP-64 - Improve the syntax of context bounds and givens
    result: accepted
---

----------------------------------------

TITLE: Adding Specific MUnit Version in SBT
DESCRIPTION: Shows how to add a specific version of MUnit as a test dependency in an SBT build.

LANGUAGE: scala
CODE:
libraryDependencies += "org.scalameta" %% "munit" % "1.1.0" % Test

----------------------------------------

TITLE: Converting Abstract Types to Type Parameters in Scala
DESCRIPTION: Shows how to convert abstract type members into type parameters, using variance annotations and generic type bounds.

LANGUAGE: scala
CODE:
abstract class Buffer[+T] {
  val element: T
}
abstract class SeqBuffer[U, +T <: Seq[U]] extends Buffer[T] {
  def length = element.length
}

def newIntSeqBuf(e1: Int, e2: Int): SeqBuffer[Int, Seq[Int]] =
  new SeqBuffer[Int, List[Int]] {
    val element = List(e1, e2)
  }

val buf = newIntSeqBuf(7, 8)
println("length = " + buf.length)
println("content = " + buf.element)

----------------------------------------

TITLE: Declaring Built-in Numeric Types in Scala
DESCRIPTION: This code demonstrates how to declare variables of various built-in numeric types in Scala, including Byte, Int, Long, Short, Double, and Float.

LANGUAGE: scala
CODE:
val b: Byte = 1
val i: Int = 1
val l: Long = 1
val s: Short = 1
val d: Double = 2.0
val f: Float = 3.0

----------------------------------------

TITLE: Named Tuple Field Access Example
DESCRIPTION: Example demonstrating how to access fields of named tuples using the dot notation.

LANGUAGE: scala
CODE:
val persons: List[Person] = ...
val minors = persons.filter: p =>
  p.age < 18

----------------------------------------

TITLE: Scala.js Static Members Example
DESCRIPTION: Demonstrates usage of @static annotation in Scala.js-defined JavaScript classes.

LANGUAGE: scala
CODE:
@ScalaJSDefined
class Foo extends js.Object

@ScalaJSDefined
object Foo extends js.Object {
  @static val x = 5
  @static def bar(y: Int): Int = x + y
}

----------------------------------------

TITLE: Defining Match Types in Scala 3
DESCRIPTION: Example of defining recursive match types in Scala 3 to compute leaf element types. The match type LeafElem recursively processes container types like Array and Iterable to find the ultimate element type.

LANGUAGE: scala
CODE:
type LeafElem[X] = X match {
  case String => Char
  case Array[t] => LeafElem[t]
  case Iterable[t] => LeafElem[t]
  case AnyVal => X
}

----------------------------------------

TITLE: Complete Map Function Implementation
DESCRIPTION: Complete implementation of the map function for List[Int].

LANGUAGE: scala
CODE:
def map[A](f: (Int) => A, xs: List[Int]): List[A] =
  for (x <- xs) yield f(x)

LANGUAGE: scala
CODE:
def map[A](f: (Int) => A, xs: List[Int]): List[A] =
  for x <- xs yield f(x)

----------------------------------------

TITLE: Comparing Multiple Parameter Lists and Currying in Scala
DESCRIPTION: Example comparing the syntax and usage of methods with multiple parameter lists to curried functions. It demonstrates that while they differ in definition, they can be called in the same way.

LANGUAGE: scala
CODE:
// версия с множественными списками параметров
def addMultiple(n1: Int)(n2: Int) = n1 + n2
// два различных способа получить каррированную версию
def add(n1: Int, n2: Int) = n1 + n2
val addCurried1 = (add _).curried
val addCurried2 = (n1: Int) => (n2: Int) => n1 + n2
// независимо от определения, вызов всех трех идентичен
addMultiple(3)(4)  // 7
addCurried1(3)(4)  // 7
addCurried2(3)(4)  // 7

----------------------------------------

TITLE: Cross-Compatible Internal API Usage in Macros
DESCRIPTION: Technique for using internal APIs in macros that are compatible with both Scala 2.10.x and 2.11.0.

LANGUAGE: scala
CODE:
import scala.reflect.macros.Context
import scala.language.experimental.macros

private object HasCompat { val compat = ??? }; import HasCompat._

object Macros {
  def impl(c: Context): c.Expr[Int] = {
    import c.universe._
    import compat._
    c.Expr[Int](Literal(Constant(42)) setType definitions.IntTpe)
  }

  def ultimateAnswer: Int = macro impl
}

----------------------------------------

TITLE: Defining IterableOps trait in Scala
DESCRIPTION: Shows the definition of the IterableOps trait which implements operations for Iterable collections.

LANGUAGE: scala
CODE:
trait IterableOps[+A, +CC[_], +C] { … }

----------------------------------------

TITLE: Demonstrating Infix Expression vs Type Precedence in Scala
DESCRIPTION: Illustrates the difference between infix expression precedence and infix type precedence using numeric operations. Shows how expression operations follow standard mathematical precedence while type operations are left-associative.

LANGUAGE: scala
CODE:
object InfixExpressionPrecedence {
  case class Nummy(expand : String) {
    def + (that : Nummy) : Nummy = Nummy(s"Plus[$this,$that]")
    def / (that : Nummy) : Nummy = Nummy(s"Div[$this,$that]")
  }
  object N1 extends Nummy("N1")
  object N2 extends Nummy("N2")
  object N3 extends Nummy("N3")
  object N4 extends Nummy("N4")
  //Both expand to Plus[Plus[N1,Div[N2,N3]],N4]
  assert((N1 + N2 / N3 + N4).expand == (N1 + (N2 / N3) + N4).expand)
}
object InfixTypePrecedence {
  trait Plus[N1, N2]
  trait Div[N1, N2]
  type +[N1, N2] = Plus[N1, N2]
  type /[N1, N2] = Div[N1, N2]
  trait N1
  trait N2
  trait N3
  trait N4
  //Error!
  //Left  expands to Plus[Div[Plus[N1,N2],N3],N4] (Surprising)
  //Right expands to Plus[Plus[N1,Div[N2,N3]],N4]
  implicitly[(N1 + N2 / N3 + N4) =:= (N1 + (N2 / N3) + N4)]
}

----------------------------------------

TITLE: Function Value Declarations in Scala
DESCRIPTION: Shows preferred syntax for declaring function values, including multi-line function declarations and type inference usage.

LANGUAGE: scala
CODE:
val f1 = { (a: Int, b: Int) =>
  val sum = a + b
  sum
}

----------------------------------------

TITLE: Using Logarithm Class
DESCRIPTION: Example usage of the Logarithm class showing basic arithmetic operations.

LANGUAGE: scala
CODE:
val l2 = Logarithm(2.0)
val l3 = Logarithm(3.0)
println((l2 * l3).toDouble) // prints 6.0
println((l2 + l3).toDouble) // prints 4.999...

----------------------------------------

TITLE: Implementing WebSocket Server Handler in Scala
DESCRIPTION: Scala implementation of WebSocket endpoint using Cask framework. Handles static resource serving and processes WebSocket messages to return timezone-specific dates for given cities.

LANGUAGE: scala
CODE:
@cask.staticResources("/static")
def static() = "."

private def getZoneIdForCity(city: String): Option[ZoneId] =
  import scala.jdk.CollectionConverters.*
  ZoneId.getAvailableZoneIds.asScala.find(_.endsWith("/" + city)).map(ZoneId.of)

@cask.websocket("/websocket")
def websocket(): cask.WsHandler =
  cask.WsHandler { channel =>
    cask.WsActor {
      case cask.Ws.Text("") => channel.send(cask.Ws.Close())
      case cask.Ws.Text(city) =>
        val text = getZoneIdForCity(city) match
          case Some(zoneId) => s"Current date is: ${ZonedDateTime.now().withZoneSameInstant(zoneId)}"
          case None => s"Couldn't find time zone for city $city"
        channel.send(cask.Ws.Text(text))
    }
  }

initialize()

----------------------------------------

TITLE: Value Class with Method Definition in Scala
DESCRIPTION: An example of a value class with a method definition, demonstrating that value classes can have def members but not additional val or var members.

LANGUAGE: scala
CODE:
class Wrapper(val underlying: Int) extends AnyVal {
  def foo: Wrapper = new Wrapper(underlying * 19)
}

----------------------------------------

TITLE: Adding UPickle dependency with Scala CLI
DESCRIPTION: Using Scala CLI to add the entire Scala toolkit or specifically the UPickle library as a dependency. The toolkit includes UPickle along with other utilities.

LANGUAGE: scala
CODE:
//> using toolkit latest

LANGUAGE: scala
CODE:
//> using dep com.lihaoyi::upickle:4.1.0

----------------------------------------

TITLE: Creating a Future in Scala
DESCRIPTION: Demonstrates how to create a Future to perform an asynchronous computation.

LANGUAGE: scala
CODE:
val inverseFuture: Future[Matrix] = Future {
    fatMatrix.inverse() // non-blocking long lasting computation
}(executionContext)

----------------------------------------

TITLE: Creating File Path in Scala using OS-Lib
DESCRIPTION: Demonstrates how to create a file path using OS-Lib's path construction syntax. Creates a path to the system dictionary file.

LANGUAGE: scala
CODE:
val path: os.Path = os.root / "usr" / "share" / "dict" / "words"

----------------------------------------

TITLE: Handling Edge Cases in Scala's Fewer Braces Syntax
DESCRIPTION: Examples of edge cases that are not allowed in the proposed syntax, along with alternative ways to express the same logic without using braces.

LANGUAGE: scala
CODE:
a < b || locally:
  val x = f(c)
  x > 0

LANGUAGE: scala
CODE:
source --> ( x =>
  val y = x * x
  println(y)
)

LANGUAGE: scala
CODE:
xo.fold:
  defaultValue
.apply:
  x => f(x)

xs.groupMapReduce: item =>
  key(item)
.apply: item =>
  value(item)
.apply: (value1, value2) =>
  reduce(value1, value2)

----------------------------------------

TITLE: Using showRaw Pretty Printer in Scala
DESCRIPTION: Shows the use of the showRaw pretty printer to display the internal structure of a quasiquote-generated class definition.

LANGUAGE: scala
CODE:
println(showRaw(q"class C"))

----------------------------------------

TITLE: Pattern Matching North Command in Scala
DESCRIPTION: Example showing basic pattern matching for north movement command

LANGUAGE: scala
CODE:
import Command.*

def loop(cmd: Command): Unit =
  cmd match
    case Command(North :: Nil) => // Code for going north

----------------------------------------

TITLE: Extension Methods using Value Classes
DESCRIPTION: Shows how to create allocation-free extension methods using value classes and implicit classes.

LANGUAGE: scala
CODE:
implicit class RichInt(val self: Int) extends AnyVal {
  def toHexString: String = java.lang.Integer.toHexString(self)
}

----------------------------------------

TITLE: Custom Point Class Lifting Implementation
DESCRIPTION: Shows how to implement custom lifting for a Point case class with proper qualification.

LANGUAGE: scala
CODE:
package points

import scala.reflect.runtime.universe._

case class Point(x: Int, y: Int)
object Point {
  implicit val lift = Liftable[Point] { p =>
    q"_root_.points.Point(${p.x}, ${p.y})"
  }
}

----------------------------------------

TITLE: Demonstrating Deterministic Results with Non-Commutative Operations in Scala Parallel Collections
DESCRIPTION: Illustrates that non-commutative operations like string concatenation can still produce deterministic results when used with parallel collections. Shows a parallel reduce operation for string concatenation.

LANGUAGE: scala
CODE:
val strings = List("abc","def","ghi","jk","lmnop","qrs","tuv","wx","yz").par
val alfabeto = strings.reduce(_++_)

----------------------------------------

TITLE: Extension Methods using Value Classes
DESCRIPTION: Shows how to create allocation-free extension methods using value classes and implicit classes.

LANGUAGE: scala
CODE:
implicit class RichInt(val self: Int) extends AnyVal {
  def toHexString: String = java.lang.Integer.toHexString(self)
}

----------------------------------------

TITLE: Numeric Type Conversion Example
DESCRIPTION: Shows how implicit conversion automatically converts an Int to Long when required by method parameters. The conversion Int.int2long is automatically applied.

LANGUAGE: scala
CODE:
Int.int2long(x)

----------------------------------------

TITLE: Compatibility Example with Custom Extension Method
DESCRIPTION: Example showing potential backward compatibility concerns with custom extension methods.

LANGUAGE: scala
CODE:
// source A.scala
package example

extension (predef: scala.Predef.type)
  transparent inline def runtimeCheck[T](x: T): x.type =
    println("fake runtimeCheck")
    x

----------------------------------------

TITLE: Inline Structural Type Usage in Scala
DESCRIPTION: Demonstrates compact inline declaration of simple structural types under 50 characters.

LANGUAGE: scala
CODE:
def foo(a: { val bar: String }) = ...

----------------------------------------

TITLE: Example Type Lambda in Scala 3
DESCRIPTION: Demonstrates the new type lambda syntax for type-level functions, which previously required a compiler plugin in Scala 2.

LANGUAGE: scala
CODE:
[A] => List[A] => List[A]

----------------------------------------

TITLE: Demonstrating Type Inference in Generic Classes and Polymorphic Methods
DESCRIPTION: These examples show how Scala can infer types for generic classes and polymorphic methods. The compiler determines the types based on the context and actual parameters provided.

LANGUAGE: scala
CODE:
case class MyPair[A, B](x: A, y: B)
val p = MyPair(1, "scala") // type: MyPair[Int, String]

def id[T](x: T) = x
val q = id(1)              // type: Int

----------------------------------------

TITLE: Implementação Modificada de Grafo em Scala para Permitir Conexões Entre Grafos
DESCRIPTION: Versão modificada da implementação do grafo que permite conectar nós de diferentes grafos. Utiliza o tipo Graph#Node para referenciar nós de qualquer grafo.

LANGUAGE: scala
CODE:
class Graph {
  class Node {
    var connectedNodes: List[Graph#Node] = Nil
    def connectTo(node: Graph#Node): Unit = {
      if (!connectedNodes.exists(node.equals)) {
        connectedNodes = node :: connectedNodes
      }
    }
  }
  var nodes: List[Node] = Nil
  def newNode: Node = {
    val res = new Node
    nodes = res :: nodes
    res
  }
}

----------------------------------------

TITLE: Adding OS-Lib Dependency in Scala CLI
DESCRIPTION: This snippet demonstrates how to add a specific version of OS-Lib as a dependency in a Scala CLI project. It uses a single line directive to include OS-Lib version 0.11.3.

LANGUAGE: scala
CODE:
//> using dep com.lihaoyi::os-lib:0.11.3

----------------------------------------

TITLE: Using Implicit ExecutionContext in Scala
DESCRIPTION: Shows how to use an implicit ExecutionContext when creating a Future.

LANGUAGE: scala
CODE:
implicit val ec: ExecutionContext = ...
val inverseFuture : Future[Matrix] = Future {
  fatMatrix.inverse()
} // ec is implicitly passed

LANGUAGE: scala
CODE:
given ExecutionContext = ...
val inverseFuture : Future[Matrix] = Future {
  fatMatrix.inverse()
} // execution context is implicitly passed

----------------------------------------

TITLE: Using foreach Method with Iterator in Scala
DESCRIPTION: Shows how to use the foreach method to iterate through all elements of an iterator, which is a more concise alternative to the while loop.

LANGUAGE: scala
CODE:
it foreach println

----------------------------------------

TITLE: Grammar Updates for Type Variable Syntax
DESCRIPTION: Defines the new grammar rules for supporting explicit type variable definitions in quoted type patterns.

LANGUAGE: scala
CODE:
Quoted            ::=  ''' '{' Block '}'
                    |  ''' '[' TypeBlock ']'
TypeBlock         ::=  {TypeBlockStat semi} Type
TypeBlockStat     ::=  'type' {nl} TypeDcl

----------------------------------------

TITLE: Using Tuple Pattern in Scala Quasiquotes
DESCRIPTION: Illustrates how tuple patterns are syntactic sugar that expands as a TupleN extractor in Scala quasiquotes.

LANGUAGE: scala
CODE:
scala> val tup2pat = pq"(a, b)"
tup2pat: universe.Tree = scala.Tuple2((a @ _), (b @ _))

scala> val pq"(..$pats)" = tup2pat
pats: List[universe.Tree] = List((a @ _), (b @ _))

----------------------------------------

TITLE: Show Type Class Example with Generic Derivation
DESCRIPTION: Example demonstrating type class derivation for recursive data types using byname implicits

LANGUAGE: scala
CODE:
trait Show[T] {
  def show(x: T): String
}

object Show {
  def apply[T](implicit st: => Show[T]): Show[T] = st

  implicit def showGeneric[T, R]
    (implicit
      gen:    Generic.Aux[T, R],
      sr:  => Show[R]):
              Show[T] = new Show[T] {
    def show(x: T): String = sr.show(gen.to(x))
  }
}

----------------------------------------

TITLE: Working with Literals in Scala Quasiquotes
DESCRIPTION: Examples of using quasiquotes with different literal types including integers, floats, booleans, characters, strings and symbols.

LANGUAGE: scala
CODE:
q"1", q"1L"              // integer literals
q"1.0f", q"1.0", q"1.0d" // floating point literals
q"true", q"false"        // boolean literals
q"'c'"                   // character literal
q"\"string\""        // string literal
q"'symbol"               // symbol literal
q"null"                  // null literal
q"()"                    // unit literal

----------------------------------------

TITLE: Array Tabulation Method with ClassManifest (2.8)
DESCRIPTION: Updated implementation of array tabulation requiring ClassManifest for runtime type information.

LANGUAGE: scala
CODE:
def tabulate[T](len: Int, f: Int => T)(implicit m: ClassManifest[T]) = {
    val xs = new Array[T](len)
    for (i <- 0 until len) xs(i) = f(i)
    xs
}

----------------------------------------

TITLE: Implementing operations in IterableOps
DESCRIPTION: Shows how filter and map operations are implemented in IterableOps using Views.

LANGUAGE: scala
CODE:
trait IterableOps[+A, +CC[_], +C]:

  def filter(pred: A => Boolean): C =
    fromSpecific(View.Filter(this, pred))

  def map[B](f: A => B): CC[B] = 
    from(View.Map(this, f))

  protected def fromSpecific(coll: IterableOnce[A]): C
  protected def from[E](it: IterableOnce[E]): CC[E]

----------------------------------------

TITLE: Skipping Empty Words with BufferedIterator in Scala
DESCRIPTION: Illustrates how to use a BufferedIterator to skip leading empty strings from an iterator without advancing past the first non-empty string.

LANGUAGE: scala
CODE:
def skipEmptyWords(it: BufferedIterator[String]) =
  while (it.head.isEmpty) { it.next() }

----------------------------------------

TITLE: Polymorphic Function Alternative
DESCRIPTION: Shows an alternative implementation using polymorphic functions, highlighting the drawbacks compared to the proposed solution.

LANGUAGE: scala
CODE:
def getOrElse(k:Key): [V >: k.Value] => (default: V) => V =
    [V] => (default: V) => ???

----------------------------------------

TITLE: Pattern Matching with Tuples in Scala
DESCRIPTION: Illustrates using tuples in pattern matching with a list of planet distances from the sun.

LANGUAGE: scala
CODE:
val planetDistanceFromSun = List(("Mercury", 57.9), ("Venus", 108.2), ("Earth", 149.6 ), ("Mars", 227.9), ("Jupiter", 778.3))

planetDistanceFromSun.foreach{ tuple => {
  
  tuple match {
    
      case ("Mercury", distance) => println(s"Mercury is $distance millions km far from Sun")
      
      case p if(p._1 == "Venus") => println(s"Venus is ${p._2} millions km far from Sun")
      
      case p if(p._1 == "Earth") => println(s"Blue planet is ${p._2} millions km far from Sun")
      
      case _ => println("Too far....")
      
    }
    
  }
  
}

----------------------------------------

TITLE: Configuring Compiler Options in sbt (Scala)
DESCRIPTION: Illustrates how to configure compiler options in an sbt build file using the scalacOptions setting. It demonstrates the convention of appending options and providing one option per line for easy editing.

LANGUAGE: scala
CODE:
scalacOptions ++= Seq(          // use ++= to add to existing options
  "-encoding", "utf8",          // if an option takes an arg, supply it on the same line
  "-feature",                   // then put the next option on a new line for easy editing
  "-language:implicitConversions",
  "-language:existentials",
  "-unchecked",
  "-Werror",
  "-Xlint",                     // exploit "trailing comma" syntax so you can add an option without editing this line
)                               // for "trailing comma", the closing paren must be on the next line

----------------------------------------

TITLE: Type Parameter Conventions in Scala
DESCRIPTION: Shows naming conventions for type parameters and higher-kinded types.

LANGUAGE: scala
CODE:
class List[A] {
  def map[B](f: A => B): List[B] = ...
}

class Map[Key, Value] {
  def get(key: Key): Value
  def put(key: Key, value: Value): Unit
}

class HigherOrderMap[Key[_], Value[_]] { ... }

----------------------------------------

TITLE: Navigation Bar Template with Previous/Next Links Using HTML/Liquid
DESCRIPTION: Creates a navigation bar that conditionally displays previous and next page links using Liquid template logic. The template checks for the existence of previous-page and next-page variables to determine which navigation arrows to show.

LANGUAGE: html
CODE:
<nav>
  <div class="pager">
  {% if page.previous-page %}
      <div class="previous"><a href="{{ page.previous-page }}.html""><span aria-hidden="true">&larr;</span> Previous</a></div>
   {% endif %}
   {% if page.next-page %}
      <div class="next"><a href="{{ page.next-page }}.html">Next <span aria-hidden="true">&rarr;</span></a></div>
   {% endif %}
  </div>
</nav>

----------------------------------------

TITLE: Using ManagedBlocker with ForkJoinPool in Scala
DESCRIPTION: Demonstrates how to use ManagedBlocker with ForkJoinPool for blocking operations.

LANGUAGE: scala
CODE:
import scala.concurrent.{ Future, ExecutionContext }
import scala.concurrent.forkjoin._

// the following is equivalent to `implicit val ec = ExecutionContext.global`
import ExecutionContext.Implicits.global

Future {
  ForkJoinPool.managedBlock(
    new ManagedBlocker {
      var done = false

      def block(): Boolean = {
        try {
          myLock.lock()
          // ...
        } finally {
          done = true
        }
        true
      }

      def isReleasable: Boolean = done
    }
  )
}

LANGUAGE: scala
CODE:
import scala.concurrent.{ Future, ExecutionContext }
import scala.concurrent.forkjoin.*

// the following is equivalent to `given ExecutionContext = ExecutionContext.global`
import ExecutionContext.Implicits.global

Future {
  ForkJoinPool.managedBlock(
    new ManagedBlocker {
      var done = false

      def block(): Boolean =
        try
          myLock.lock()
          // ...
        finally
          done = true
        true

      def isReleasable: Boolean = done
    }
  )
}

----------------------------------------

TITLE: Configuring Scala 3 Compiler Options
DESCRIPTION: Comprehensive sbt configuration for managing compiler options across Scala 2.13 and Scala 3, including migration-specific settings and version-specific compiler flags.

LANGUAGE: scala
CODE:
scalacOptions ++= {
  Seq(
    "-encoding",
    "UTF-8",
    "-feature",
    "-language:implicitConversions",
    // disabled during the migration
    // "-Xfatal-warnings"
  ) ++ 
    (CrossVersion.partialVersion(scalaVersion.value) match {
      case Some((3, _)) => Seq(
        "-unchecked",
        "-source:3.0-migration"
      )
      case _ => Seq(
        "-deprecation",
        "-Xfatal-warnings",
        "-Wunused:imports,privates,locals",
        "-Wvalue-discard"
      )
    })
}

----------------------------------------

TITLE: Setting up ToolBox API in Scala 2.11 REPL
DESCRIPTION: Imports necessary classes and creates a ToolBox instance for advanced quasiquote operations in the Scala 2.11 REPL.

LANGUAGE: scala
CODE:
import scala.reflect.runtime.currentMirror
import scala.tools.reflect.ToolBox
val toolbox = currentMirror.mkToolBox()

----------------------------------------

TITLE: Demonstrating Extractor Pattern in Scala Quasiquotes
DESCRIPTION: Shows how extractors can be used to delegate pattern matching to another object's unapply method in Scala quasiquotes.

LANGUAGE: scala
CODE:
scala> val extractor = pq"Foo(1, 2, 3)"
extractor: universe.Tree = Foo(1, 2, 3)

scala> val pq"$id(..$pats)" = extractor
id: universe.Tree = Foo
pats: List[universe.Tree] = List(1, 2, 3)

----------------------------------------

TITLE: Mirror Classes Example
DESCRIPTION: Shows how static forwarders work with nested objects in Scala.

LANGUAGE: scala
CODE:
object O {
  val d = 1
  object I {
    val f = 1
  }
}

----------------------------------------

TITLE: Demonstrating Whitebox Inline Definitions in Scala
DESCRIPTION: Shows the current and proposed syntax for whitebox inline definitions in Dotty/Scala 3. The proposed syntax uses a 'flextype' modifier instead of the '<:' syntax.

LANGUAGE: scala
CODE:
inline def f() <: T = …
inline given C as _ <: T = …

LANGUAGE: scala
CODE:
inline flextype def f(): T = …
inline flextype given C as T = …

----------------------------------------

TITLE: Demonstrando o Uso de Lista Encadeada Covariante em Scala
DESCRIPTION: Este snippet ilustra o uso da classe ListNode covariante, demonstrando como elementos de diferentes tipos podem ser adicionados à lista, resultando em uma lista de um supertipo comum.

LANGUAGE: scala
CODE:
object LowerBoundTest extends App {
  val empty: ListNode[Null] = ListNode(null, null)
  val strList: ListNode[String] = empty.prepend("hello")
                                       .prepend("world")
  val anyList: ListNode[Any] = strList.prepend(12345)
}

----------------------------------------

TITLE: Defining List as an Iterable in Scala
DESCRIPTION: Shows how List is defined as an Iterable, extending IterableOps.

LANGUAGE: scala
CODE:
trait List[+A] extends Iterable[A]
  with IterableOps[A, List, List[A]]

----------------------------------------

TITLE: Handling Long Expressions with Line Wrapping in Scala
DESCRIPTION: This example demonstrates how to properly wrap long expressions across multiple lines, maintaining readability and correct syntax.

LANGUAGE: scala
CODE:
val result = 1 + 2 + 3 + 4 + 5 + 6 +
  7 + 8 + 9 + 10 + 11 + 12 + 13 + 14 +
  15 + 16 + 17 + 18 + 19 + 20

----------------------------------------

TITLE: Deferred Given Definition in Scala (Proposed Syntax)
DESCRIPTION: Proposed syntax for defining a deferred given using the 'deferred' keyword.

LANGUAGE: scala
CODE:
given T = deferred

----------------------------------------

TITLE: Using Tuples in For-Expressions in Scala
DESCRIPTION: Demonstrates how to use tuple deconstruction in a for-expression to multiply pairs of numbers.

LANGUAGE: scala
CODE:
val numPairs = List((2, 5), (3, -7), (20, 56))

for ((a, b) <- numPairs) {

  println(a * b)
  
}

----------------------------------------

TITLE: Using showCode Pretty Printer in Scala 2.11
DESCRIPTION: Demonstrates the use of the showCode pretty printer to display a quasiquote-generated class definition in a more readable format.

LANGUAGE: scala
CODE:
val C = q"class C"
println(showCode(C))

----------------------------------------

TITLE: Compiler Transformation of Implicit Class
DESCRIPTION: Shows how the compiler transforms an implicit class definition into a regular class and an implicit conversion method.

LANGUAGE: scala
CODE:
class RichInt(n: Int) extends Ordered[Int] {
  def min(m: Int): Int = if (n <= m) n else m
  ...
}
implicit final def RichInt(n: Int): RichInt = new RichInt(n)

----------------------------------------

TITLE: Defining a Hello World Program in Scala
DESCRIPTION: A basic Scala program that prints 'Hello, world!' to the console. It demonstrates the structure of a Scala object with a main method.

LANGUAGE: scala
CODE:
object HolaMundo {
  def main(args: Array[String]): Unit = {
    println("¡Hola, mundo!")
  }
}

----------------------------------------

TITLE: Page Styling CSS
DESCRIPTION: CSS styles defining the layout and appearance of the page including background, typography, and layout elements.

LANGUAGE: css
CODE:
html, body {
  padding-top: 36px;
  height: 100%;
  background:url({{ site.baseurl }}/resources/images/bg-short.jpg) no-repeat top center #310808;
  -webkit-box-shadow: inset 0 10px 50px rgba(0,0,0,.6);
  -moz-box-shadow: inset 0 10px 50px rgba(0,0,0,.6);
}

/* Additional CSS styles omitted for brevity */

----------------------------------------

TITLE: Creating Many Blocking Futures in Scala
DESCRIPTION: Demonstrates creating multiple blocking Futures, which can lead to thread exhaustion.

LANGUAGE: scala
CODE:
implicit val ec = ExecutionContext.global

for (i <- 1 to 32000) {
  Future {
    blocking {
      Thread.sleep(999999)
    }
  }
}

LANGUAGE: scala
CODE:
given ExecutionContext = ExecutionContext.global

for i <- 1 to 32000 do
  Future {
    blocking {
      Thread.sleep(999999)
    }
  }

----------------------------------------

TITLE: Using Sequences for Multiple Query Parameter Values in Scala
DESCRIPTION: Shows how to use Seq[String] to represent multiple values for a single query parameter in URI construction. Empty sequences result in the parameter being omitted.

LANGUAGE: scala
CODE:
def getUri(versions: Seq[String]): Uri =
  uri"https://example.com/scala?version=$versions"

println(getUri(Seq("3.2.2")))
// prints: https://example.com/scala?version=3.2.2

println(getUri(Seq("2.13.8", "2.13.9", "2.13.10")))
// prints: https://example.com/scala?version=2.13.8&version=2.13.9&version=2.13.10

println(getUri(Seq.empty))
// prints: https://example.com/scala

----------------------------------------

TITLE: Using Binding Pattern in Scala Quasiquotes
DESCRIPTION: Illustrates how to use binding patterns to name a pattern or its parts to a local variable in Scala quasiquotes.

LANGUAGE: scala
CODE:
scala> val bindtup = pq"foo @ (1, 2)"
bindtup: universe.Bind = (foo @ scala.Tuple2(1, 2))

scala> val pq"$name @ $pat" = bindtup
name: universe.Name = foo
pat: universe.Tree = scala.Tuple2(1, 2)

----------------------------------------

TITLE: Grammar Changes for Fewer Braces in Scala
DESCRIPTION: The proposed grammar changes to support optional braces for function arguments. This includes modifications to SimpleExpr, InfixExpr, and the introduction of ColonArgument and LambdaStart.

LANGUAGE: scala
CODE:
SimpleExpr       ::=  ...
                   |  SimpleExpr ColonArgument
InfixExpr        ::=  ...
                   |  InfixExpr id ColonArgument
ColonArgument    ::=  colon [LambdaStart]
                      indent (CaseClauses | Block) outdent
LambdaStart      ::=  FunParams ('=>' | '?=>')
                   |  HkTypeParamClause '=>'

----------------------------------------

TITLE: Defining publicInBinary Annotation in Scala Standard Library
DESCRIPTION: Specifies the addition of publicInBinary annotation to the Scala standard library as a StaticAnnotation.

LANGUAGE: scala
CODE:
package scala.annotation

final class publicInBinary extends scala.annotation.StaticAnnotation

----------------------------------------

TITLE: Constructing Type Identifiers in Scala Quasiquotes
DESCRIPTION: Demonstrates how to create and deconstruct type identifiers using TypeName and pattern matching.

LANGUAGE: scala
CODE:
val name = TypeName("Foo")
val foo = tq"$name"

val tq"${name: TypeName}" = tq"Foo"

----------------------------------------

TITLE: Defining filter operations for List and Map in Scala
DESCRIPTION: Demonstrates how the filter operation is defined for List and Map collection types.

LANGUAGE: scala
CODE:
trait List[A]:
  def filter(p: A => Boolean): List[A]

trait Map[K, V]:
  def filter(p: ((K, V)) => Boolean): Map[K, V]

----------------------------------------

TITLE: Installing sbt-scala3-migrate Plugin
DESCRIPTION: Adding the sbt-scala3-migrate plugin to project/plugins.sbt to enable migration tooling

LANGUAGE: scala
CODE:
// project/plugins.sbt
addSbtPlugin("ch.epfl.scala" % "sbt-scala3-migrate" % "0.6.1")

----------------------------------------

TITLE: Defining YAML Frontmatter for SIP Meeting Results Page in Markdown
DESCRIPTION: This code snippet defines the YAML frontmatter for a Jekyll-based page containing SIP meeting results. It specifies the layout, title, and related information for the page.

LANGUAGE: markdown
CODE:
---
layout: sip-meeting-results
title: SIP Meeting Results - 11th September 2023
partof: results
proposals: []
---

----------------------------------------

TITLE: Defining If-Else If-Else Statements in Java and Scala
DESCRIPTION: Shows how to define if-else if-else statements in Java and Scala.

LANGUAGE: java
CODE:
if (x < 0) {
  System.out.println("negative")
} else if (x == 0) {
  System.out.println("zero")
} else {
  System.out.println("positive")
}

LANGUAGE: scala
CODE:
if x < 0 then
  println("negative")
else if x == 0
  println("zero")
else
  println("positive")

----------------------------------------

TITLE: Defining Blackbox Macro Context in Scala
DESCRIPTION: Shows how to define a blackbox macro context, which is used to create macros that behave like normal methods and have restrictions applied by the Scala typechecker.

LANGUAGE: scala
CODE:
scala.reflect.macros.blackbox.Context

----------------------------------------

TITLE: Looping Over Lists in Scala
DESCRIPTION: Demonstrates how to iterate over a List using a for loop in Scala.

LANGUAGE: scala
CODE:
val names = List("Joel", "Chris", "Ed")
for (name <- names) println(name)

----------------------------------------

TITLE: Demonstrating Binary Compatibility Issues with Inlining in Scala
DESCRIPTION: This code snippet shows how inlining can potentially break binary compatibility in Scala. It illustrates the use of private methods and how they are accessed in companion objects, which can lead to unexpected behavior when inlined.

LANGUAGE: scala
CODE:
class C {
  private def x = 0
  @inline final def m: Int = x
}
object C {
  def t(c: C) = c.x
}

----------------------------------------

TITLE: Future を使用した非同期計算の例
DESCRIPTION: ソーシャルネットワークAPIから友達のリストを非同期に取得する例

LANGUAGE: scala
CODE:
import scala.concurrent._
import ExecutionContext.Implicits.global

val session = socialNetwork.createSessionFor("user", credentials)
val f: Future[List[Friend]] = Future {
  session.getFriends()
}

----------------------------------------

TITLE: Invalid Value Class with Multiple Parameters in Scala
DESCRIPTION: An example demonstrating that value classes cannot have multiple constructor parameters.

LANGUAGE: scala
CODE:
class Complex(val real: Double, val imag: Double) extends AnyVal

----------------------------------------

TITLE: Hello World with Command-line Arguments in Scala
DESCRIPTION: An enhanced version of the Hello World program that accepts command-line arguments. It demonstrates how to access and use the args array that's automatically available when extending the App trait.

LANGUAGE: scala
CODE:
object HelloYou extends App {
    if (args.size == 0)
        println("Hello, you")
    else
        println("Hello, " + args(0))
}

----------------------------------------

TITLE: Constructing URIs with Automatic Escaping in Scala
DESCRIPTION: Demonstrates the use of the `uri` interpolator to create URIs with automatic escaping of special characters. This snippet shows how to interpolate variables into URIs safely.

LANGUAGE: scala
CODE:
import sttp.client4.quick._
import sttp.model.Uri

val book = "programming in scala"
val bookUri: Uri = uri"https://example.com/books/$book"

println(bookUri)
// prints: https://example.com/books/programming%20in%20scala

----------------------------------------

TITLE: Demonstrating Referential Transparency Issue in Scala Quasiquotes
DESCRIPTION: This snippet illustrates how quasiquotes fail to maintain referential transparency by not respecting custom imports, resolving 'Map' to the default immutable Map instead of the imported mutable Map.

LANGUAGE: scala
CODE:
scala> import collection.mutable.Map

scala> def typecheckType(tree: Tree): Type =
         toolbox.typecheck(tree, toolbox.TYPEmode).tpe

scala> typecheckType(tq"Map[_, _]") =:= typeOf[Map[_, _]]
false

scala> typecheckType(tq"Map[_, _]") =:= typeOf[collection.immutable.Map[_, _]]
true

----------------------------------------

TITLE: Default Arguments with Type Parameters in Scala
DESCRIPTION: Demonstrates how default arguments can be used with polymorphic methods and classes, allowing the default value to adapt to the inferred type.

LANGUAGE: scala
CODE:
def f[T](a: T = 1) = a
f()    // returns 1: Int
f("s") // returns "s": String

def g[T](a: T = 1, b: T = "2") = b
g(a = "1")  // OK, returns "2": String
g(b = 2)    // OK, returns 2: Int
g()         // OK, returns "2": Any
// g[Int]() // "error: type mismatch; found: String, required: Int"

class A[T](a: T = "defaultString")
new A()  // creates an instance of A[String]
new A(1) // creates an instance of A[Int]

----------------------------------------

TITLE: Named Tuple Type and Value Definition
DESCRIPTION: Example showing how to define and use named tuple types and values, including type declaration, value construction, and pattern matching.

LANGUAGE: scala
CODE:
type Person = (name: String, age: Int)
val Bob: Person = (name = "Bob", age = 33)

Bob match
  case (name = n, age = 22) => ...

----------------------------------------

TITLE: Mixing Named and Positional Arguments in Scala
DESCRIPTION: Shows how named and positional arguments can be mixed in a method call, as long as the positional arguments form a prefix of the argument list.

LANGUAGE: scala
CODE:
f(0, b = "1")     // valid
f(b = "1", a = 0) // valid
// f(b = "1", 0)  // invalid, a positional after named argument
// f(0, a = 1)    // invalid, parameter 'a' specified twice

----------------------------------------

TITLE: Vector Operations in Scala
DESCRIPTION: Shows common operations with immutable Vectors including creation, appending elements, and updating values while maintaining immutability.

LANGUAGE: scala
CODE:
val vec = scala.collection.immutable.Vector.empty
val vec2 = vec :+ 1 :+ 2
val vec3 = 100 +: vec2
vec3(0)

val vec = Vector(1, 2, 3)
vec updated (2, 4)

----------------------------------------

TITLE: Proposed Quote Escaping Solution in Scala
DESCRIPTION: The new proposed syntax using $" to escape quotes in string interpolations.

LANGUAGE: scala
CODE:
s"A common question for Scala programmers is $"How can I represent a literal $" character in Scala interpolations?$""

----------------------------------------

TITLE: YAML Front Matter Configuration for SIP Meeting Results
DESCRIPTION: YAML configuration block defining the layout, title, and proposal details for the SIP meeting results page. Includes metadata about SIP-54 proposal and its acceptance status.

LANGUAGE: yaml
CODE:
---
layout: sip-meeting-results
title: SIP Meeting Results - 16th June 2023
partof: results
proposals:
  - url: https://docs.scala-lang.org/sips/multi-source-extension-overloads.html
    name: SIP-54 - Multi-Source Extension Overloads
    result: accepted
---

----------------------------------------

TITLE: Defining Interfaces with Default Methods in Java and Scala
DESCRIPTION: Shows how to define interfaces with default methods in Java and Scala.

LANGUAGE: java
CODE:
public interface Adder {
  int add(int a, int b);
  default int multiply(
    int a, int b
  ) {
    return a * b;
  }
}

LANGUAGE: scala
CODE:
trait Adder:
  def add(a: Int, b: Int): Int
  def multiply(a: Int, b: Int): Int =
    a * b

----------------------------------------

TITLE: Defining Whitebox Macro Context in Scala
DESCRIPTION: Demonstrates how to define a whitebox macro context, which is used to create macros that can transcend normal method behavior and have no restrictions applied by the Scala typechecker.

LANGUAGE: scala
CODE:
scala.reflect.macros.whitebox.Context

----------------------------------------

TITLE: Tuple Type Summoning in List Format
DESCRIPTION: Implementation of a method that summons all types in a tuple and returns them as a List of expressions. Handles error reporting for unsummonable types.

LANGUAGE: scala
CODE:
def summonAllInList[T](using Type[T])(using Quotes): List[Expr[Any]] = {
    Type.of[T] match
      case '[ head *: tail ] =>
        Expr.summon[head] match
          case Some(headExpr) => headExpr :: summonAllInList[tail]
          case _ => quotes.reflect.report.throwError(s"Could not summon ${Type.show[head]}")
      case '[ EmptyTuple ] => Nil
      case _ => quotes.reflect.report.throwError(s"Could not `summonAllInList` of tuple with unknown size: ${Type.show[T]}")
  }

----------------------------------------

TITLE: Sending POST Request with Binary Data in Scala using sttp
DESCRIPTION: This snippet demonstrates how to send a POST request with binary data using sttp's quickRequest in both Scala 2 and 3. It shows how to convert a string to bytes and use it as the request body.

LANGUAGE: scala
CODE:
val bytes: Array[Byte] = "john".getBytes
val request = quickRequest.post(uri"https://example.com/").body(bytes)

----------------------------------------

TITLE: Meeting Minutes Table Format in Markdown
DESCRIPTION: Markdown table showing the meeting agenda topics and their respective reviewers

LANGUAGE: markdown
CODE:
| Topic | Reviewer |
| --- | --- |
| Discussion of the voting system | N/A |
| [SIP-20: Improved Lazy Val Initialization](https://github.com/scala/improvement-proposals/pull/19) | Sébastien Doeraene |
| [SIP-27: Trailing commas](https://github.com/scala/docs.scala-lang/pull/533#issuecomment-232959066) | Eugene Burmako |

----------------------------------------

TITLE: Invalid Value Class Inheritance in Scala
DESCRIPTION: An example demonstrating that value classes cannot inherit from non-universal traits and cannot be inherited from.

LANGUAGE: scala
CODE:
trait NotUniversal
class Value(val x: Int) extends AnyVal with NotUniversal
class Extend(x: Int) extends Value(x)

----------------------------------------

TITLE: Simple Hello World Using App Trait in Scala
DESCRIPTION: A simplified version of Hello World program that extends the App trait to avoid writing an explicit main method. The App trait provides its own main method implementation.

LANGUAGE: scala
CODE:
object Hello2 extends App {
    println("Hello, world")
}

----------------------------------------

TITLE: Simplified Macro Implementation with Quasiquotes in Scala
DESCRIPTION: This snippet demonstrates how quasiquotes simplify macro implementations in Scala 2.11 compared to 2.10. It shows how to use trees directly in macro implementations instead of the reify-centric Expr API.

LANGUAGE: scala
CODE:
// 2.10
object Macro {
  def apply(x: Int): Int = macro impl
  def impl(c: Context)(x: c.Expr[Int]): c.Expr[Int] = { import c.universe._
    c.Expr(q"$x + 1")
  }
}

// in 2.11 you can also do it like that
object Macro {
  def apply(x: Int): Int = macro impl
  def impl(c: Context)(x: c.Tree) = { import c.universe._
    q"$x + 1"
  }
}

----------------------------------------

TITLE: Demonstrating Empty Expression in Scala Quasiquotes
DESCRIPTION: Shows how to use q"" to indicate missing tree parts in various contexts like Val, Var, Def, Try and Case clauses.

LANGUAGE: scala
CODE:
q""

----------------------------------------

TITLE: Pattern matching and isInstanceOf with literal types
DESCRIPTION: Demonstrates how pattern matching and isInstanceOf tests work with literal types.

LANGUAGE: Scala
CODE:
(1: Any) match {
  case one: 1 => true
  case _ => false
}                                  // result is true: Boolean
(1: Any).isInstanceOf[1]           // result is true: Boolean

----------------------------------------

TITLE: YAML Frontmatter Configuration for SID-4 Documentation
DESCRIPTION: YAML configuration block defining metadata for the SID-4 documentation page, including layout, title, stage, status and permalink settings.

LANGUAGE: yaml
CODE:
---
layout: sip
title: SID-4 - Early Member Definitions
stage: completed
status: shipped
permalink: /sips/:title.html
redirect_from: /sips/pending/early-member-definitions.html
---

----------------------------------------

TITLE: Defining Immutable Fields in Java and Scala
DESCRIPTION: Shows how to define immutable fields in Java and Scala.

LANGUAGE: java
CODE:
final int i = 1;

LANGUAGE: scala
CODE:
val i = 1

----------------------------------------

TITLE: Curly Brace Placement in Scala Function Definitions
DESCRIPTION: Demonstrates the correct placement of opening curly braces on the same line as function declarations. This is the preferred style to avoid semi-colon inference issues.

LANGUAGE: scala
CODE:
def foo = {
  ...
}

----------------------------------------

TITLE: Mutable Stack Implementation in Scala
DESCRIPTION: Demonstrates using mutable Stack with push, pop, and top operations.

LANGUAGE: scala
CODE:
val stack = new scala.collection.mutable.Stack[Int]
stack.push(1)
stack.push(2)
stack.top
stack.pop

----------------------------------------

TITLE: Defining YAML Front Matter for SIP Meeting Results Page
DESCRIPTION: This YAML front matter defines metadata for a Jekyll page documenting Scala Improvement Proposal (SIP) meeting results. It includes layout information, title, and details about the accepted proposal (SIP-49 on Polymorphic Eta-Expansion).

LANGUAGE: yaml
CODE:
---
layout: sip-meeting-results
title: SIP Meeting Results - 18th November 2022
partof: results
proposals:
  - url: https://docs.scala-lang.org/sips/polymorphic-eta-expansion.html
    name: SIP-49 - Polymorphic Eta-Expansion
    result: accepted
---

----------------------------------------

TITLE: Converting Sequential to Parallel Collections in Scala
DESCRIPTION: Method for converting sequential collections to their parallel variants using the par method. The conversion is constant time for collections sharing the same data structure, with mutable hash maps and sets being an exception on first conversion.

LANGUAGE: scala
CODE:
sequentialCollection.par

----------------------------------------

TITLE: Demonstrating Proposed Indentation Syntax for Scala 3
DESCRIPTION: Shows an example of the proposed indentation-based syntax for class and object definitions in Scala 3, using colons and optional 'end' markers.

LANGUAGE: scala
CODE:
class Foo:

  def foo = ???

object Foo:

  def bar = ???

end Foo

----------------------------------------

TITLE: Concatenating Strings Using + Operator in Scala
DESCRIPTION: This snippet shows how to concatenate strings using the + operator in Scala.

LANGUAGE: scala
CODE:
val name = firstName + " " + mi + " " + lastName

----------------------------------------

TITLE: Defining Extension Method with Type Parameters
DESCRIPTION: Example of an extension method definition showing type-based searchable signature

LANGUAGE: scala
CODE:
extension [T](arr: IArray[T]) def span(p: T => Boolean): (IArray[T], IArray[T]) = ...

----------------------------------------

TITLE: Meeting Agenda Table in Markdown
DESCRIPTION: Markdown table showing the SIP meeting agenda with topics, reviewers and status

LANGUAGE: markdown
CODE:
|Topic|Reviewers| Accepted/Rejected |
| --- | --- | --- |
| [SIP-NN: Right-Associative By-Name Operators](https://docs.scala-lang.org/sips/right-associative-by-name-operators.html) | Adriaan Moors | Pending |
| [SIP-ZZ: Opaque types](https://docs.scala-lang.org/sips/opaque-types.html) | Sébastien Doeraene | Pending |
| [SIP-33: Match infix and prefix types to meet expression rules](https://docs.scala-lang.org/sips/priority-based-infix-type-precedence.html)| Josh Suereth | Pending |
|[SIP-28 and SIP-29: Inline meta](https://github.com/scala/improvement-proposals/pull/28)|Josh Suereth and Iulian Dragos| Pending |

----------------------------------------

TITLE: Parallel Collection Creation Methods
DESCRIPTION: Shows different ways to create parallel collections, either through direct instantiation or conversion from sequential collections.

LANGUAGE: scala
CODE:
import scala.collection.parallel.immutable.ParVector
val pv = new ParVector[Int]

val pv = Vector(1,2,3,4,5,6,7,8,9).par

----------------------------------------

TITLE: Initial Scala Location Macro Definition
DESCRIPTION: Basic code skeleton showing dual macro definitions for both Scala 2.13 and Scala 3, demonstrating how to define the same macro for both versions.

LANGUAGE: scala
CODE:
// example/src/main/scala/location/Location.scala
package location

case class Location(path: String, line: Int)

object Macros:
  def location: Location = macro ???
  inline def location: Location = ${ ??? }

----------------------------------------

TITLE: Obtaining ClassTag Using classTag Method
DESCRIPTION: Shows how to obtain a ClassTag for String type using the classTag method.

LANGUAGE: scala
CODE:
import scala.reflect._
val ct = classTag[String]

----------------------------------------

TITLE: Custom Point Unliftable Implementation
DESCRIPTION: Example of implementing a custom Unliftable instance for a Point case class. Shows how to define pattern matching for extracting coordinates and constructing a Point instance from a syntax tree.

LANGUAGE: scala
CODE:
package Points

import scala.universe._

case class Point(x: Int, y: Int)
object Point {
  implicit val unliftPoint = Unliftable[points.Point] {
    case q"_root_.points.Point(${x: Int}, ${y: Int})" => Point(x, y)
  }
}

----------------------------------------

TITLE: Macro Implementation with Potential Referential Transparency Issue
DESCRIPTION: This code snippet shows a macro implementation that may encounter referential transparency problems due to unqualified references in the generated code.

LANGUAGE: scala
CODE:
// ---- MyMacro.scala ----
package example

import scala.reflect.macros.blackbox.Context
import scala.language.experimental.macros

object MyMacro {
  def wrapper(x: Int) = { println(s"wrapped x = $x"); x }
  def apply(x: Int): Int = macro impl
  def impl(c: Context)(x: c.Tree) = {
    import c.universe._
    q"wrapper($x)"
  }
}

// ---- Test.scala ----
package example

object Test extends App {
  def wrapper(x: Int) = x
  MyMacro(2)
}

----------------------------------------

TITLE: SIP-20 Metadata Configuration
DESCRIPTION: YAML frontmatter defining the metadata for SIP-20, including title, status, pull request number, and implementation stage.

LANGUAGE: yaml
CODE:
---
title: SIP-20 - Improved Lazy Vals Initialization
status: shipped
pull-request-number: 19
stage: completed
---

----------------------------------------

TITLE: Reverting to Scala 2 style syntax
DESCRIPTION: This snippet shows the final result of applying the -old-syntax -rewrite options to fully revert the code back to Scala 2 style syntax.

LANGUAGE: scala
CODE:
case class State(n: Int, minValue: Int, maxValue: Int) {
  
  def inc: State =
    if (n == maxValue)
      this
    else
      this.copy(n = n + 1)
  
  def printAll: Unit = {
    println("Printing all")
    for {
      i <- minValue to maxValue
      j <- 0 to n
    }
    println(i + j)
  }
}

----------------------------------------

TITLE: For-Comprehensions in Scala
DESCRIPTION: Shows the preferred syntax for for-comprehensions with multiple generators and those without yield clauses.

LANGUAGE: scala
CODE:
// right!
for {
  x <- board.rows
  y <- board.files
} yield (x, y)

// right!
for (x <- board.rows; y <- board.files) {
  printf("(%d, %d)", x, y)
}

----------------------------------------

TITLE: Defining YAML Front Matter for SIP Meeting Results Page
DESCRIPTION: This YAML front matter block defines metadata for a Jekyll-based page documenting SIP meeting results. It specifies the layout, title, and that the page is part of the 'results' section. An empty 'proposals' array is also included.

LANGUAGE: yaml
CODE:
---
layout: sip-meeting-results
title: SIP Meeting Results - 12th December 2023
partof: results
proposals: []
---

----------------------------------------

TITLE: YAML Configuration for SIP Meeting Results
DESCRIPTION: YAML frontmatter configuration defining the layout, title, and results of multiple Scala Improvement Proposals (SIPs) from a meeting held on August 26th, 2022. Each proposal includes a URL, name, and result status.

LANGUAGE: yaml
CODE:
---
layout: sip-meeting-results
title: SIP Meeting Results - 26th August 2022
partof: results
proposals:
  - url: https://github.com/scala/improvement-proposals/pull/29
    name: SIP-32 - Allow referring to other arguments in default parameters
    result: rejected
  - url: https://github.com/scala/improvement-proposals/pull/37
    name: SIP-39 - Uncluttering Abuse of Match
    result: rejected
  - url: https://docs.scala-lang.org/sips/binary-integer-literals.html
    name: SIP-42 - Binary Integer Literals
    result: accepted
  - url: https://github.com/scala/improvement-proposals/pull/42
    name: SIP-40 - Name Based XML Literals
    result: rejected
  - url: https://github.com/scala/improvement-proposals/pull/41
    name: SIP-45 - Curried varargs
    result: rejected
  - url: https://docs.scala-lang.org/sips/fewer-braces.html
    name: SIP-44 - Fewer braces
    result: accepted
---

----------------------------------------

TITLE: Demonstrating Parsing Challenge with New Control Syntax
DESCRIPTION: Shows a potential parsing challenge with the new control syntax when used with boolean expressions spanning multiple lines.

LANGUAGE: scala
CODE:
if (x || y)
  && (a || b) then foo()

----------------------------------------

TITLE: Environment-Specific Testing with MUnit Assume
DESCRIPTION: Shows how to implement environment-specific tests using MUnit's assume function. This example demonstrates checking for Linux OS before running a test that verifies home directory path.

LANGUAGE: scala
CODE:
import scala.util.Properties

test("home directory") {
  assume(Properties.isLinux, "this test runs only on Linux")
  assert(os.home.toString.startsWith("/home/"))
}

----------------------------------------

TITLE: Pizza Service Interface
DESCRIPTION: Trait defining the interface for pizza operations

LANGUAGE: scala
CODE:
trait PizzaServiceInterface:
  def price(p: Pizza): Double
  def addTopping(p: Pizza, t: Topping): Pizza
  def removeAllToppings(p: Pizza): Pizza
  def updateCrustSize(p: Pizza, cs: CrustSize): Pizza
  def updateCrustType(p: Pizza, ct: CrustType): Pizza

----------------------------------------

TITLE: Singleton-ops Library Usage Example
DESCRIPTION: Demonstrates type-level arithmetic operations using the singleton-ops library with Typelevel Scala, showing both successful compilations and intentional compilation failures.

LANGUAGE: scala
CODE:
import singleton.ops._

val four1 : 4 = implicitly[2 + 2]
val four2 : 2 + 2 = 4
val four3 : 1 + 3 = implicitly[2 + 2]

class MyVec[L] {
  def doubleSize = new MyVec[2 * L]
  def nSize[N] = new MyVec[N * L]
}
object MyVec {
  implicit def apply[L](implicit check : Require[L > 0]) : MyVec[L] = new MyVec[L]()
}
val myVec : MyVec[10] = MyVec[4 + 1].doubleSize
val myBadVec = MyVec[-1] //fails compilation, as required

----------------------------------------

TITLE: Non-deterministic Parallel Side Effects
DESCRIPTION: Illustrates potential issues with side-effects in parallel collections leading to non-deterministic results.

LANGUAGE: scala
CODE:
var sum = 0
val list = (1 to 1000).toList.par
list.foreach(sum += _)

----------------------------------------

TITLE: Demonstrating Trait Parameter Usage in Scala
DESCRIPTION: This code snippet shows examples of how to use trait parameters in Scala, including trait declarations and class implementations with different inheritance patterns.

LANGUAGE: scala
CODE:
trait T(x: A)
trait U extends T

// Illegal:
// class C extends U

// Legal:
class C extends T(e) with U
class C extends U with T(e)

trait V(x2: B)
class D extends T(e1) with V(e2)

----------------------------------------

TITLE: Basic @unroll Method Example
DESCRIPTION: Demonstrates basic usage of @unroll annotation on a method with default parameters, showing generated forwarders

LANGUAGE: scala
CODE:
object Unrolled{
   def foo(s: String, n: Int = 1, @unroll b: Boolean = true, @unroll l: Long = 0) = s + n + b + l

   def foo(s: String, n: Int, b: Boolean) = foo(s, n, b, 0)
   def foo(s: String, n: Int) = foo(s, n, true, 0)
}

----------------------------------------

TITLE: Offline Code Generation with Quasiquotes in Scala
DESCRIPTION: This snippet shows how to implement an offline code generator using quasiquotes for AST manipulation and the showCode method for serializing the AST into actual source code before writing it to disk.

LANGUAGE: scala
CODE:
object OfflineCodeGen extends App {
  def generateCode() =
    q"package mypackage { class MyClass }"
  def saveToFile(path: String, code: Tree) = {
    val writer = new java.io.PrintWriter(path)
    try writer.write(showCode(code))
    finally writer.close()
  }
  saveToFile("myfile.scala", generateCode())
}

----------------------------------------

TITLE: Restricted Keywords Example in Scala
DESCRIPTION: Demonstrates how code using the new restricted keywords 'given' and 'enum' must be modified for Scala 3 compatibility by wrapping them in backticks.

LANGUAGE: scala
CODE:
object given { 
  val enum = ??? 
  println(enum) 
}

----------------------------------------

TITLE: Basic Polymorphic Eta-Expansion Example
DESCRIPTION: Demonstrates basic polymorphic eta-expansion converting a polymorphic method into a polymorphic function.

LANGUAGE: scala
CODE:
def f1[A](x: A): A = ???
val v1_1: [B] => B => B = f1 // f1 becomes [B'] => (y: B') => f1[B'](y)

----------------------------------------

TITLE: Using Clues in MUnit Assertions
DESCRIPTION: Demonstrates how to use clues in MUnit assertions to get more detailed error reports when assertions fail. The clue function provides additional context about the values being compared.

LANGUAGE: scala
CODE:
assert(clue(List(a).head) > clue(b))

----------------------------------------

TITLE: Formatting Control Structures in Scala
DESCRIPTION: Demonstrates correct spacing for control structures in Scala. A space should follow the defining keyword for all control structures.

LANGUAGE: scala
CODE:
// right!
if (foo) bar else baz
for (i <- 0 to 10) { ... }
while (true) { println("Hello, World!") }

// wrong!
if(foo) bar else baz
for(i <- 0 to 10) { ... }
while(true) { println("Hello, World!") }

----------------------------------------

TITLE: Configuring SBT for Cross-Compilation
DESCRIPTION: SBT configuration to set up correct compiler flags for cross-compiling between Scala 2 and 3 with kind-projector syntax.

LANGUAGE: scala
CODE:
ThisBuild / scalacOptions ++= {
  CrossVersion.partialVersion(scalaVersion.value) match {
    case Some((3, _)) => Seq("-Ykind-projector:underscores")
    case Some((2, 12 | 13)) => Seq("-Xsource:3", "-P:kind-projector:underscore-placeholders")
  }
}

----------------------------------------

TITLE: SIP Process Table Structure in Markdown
DESCRIPTION: HTML table structure defining the stages, purposes, entry criteria and expected changes for each phase of the SIP process.

LANGUAGE: markdown
CODE:
<table>
    <thead>
        <tr>
            <td>Stage</td>
            <td>Purpose</td>
            <td>Entry criteria</td>
            <td>Post-entry changes expected</td>
        </tr>
    </thead>
    <tbody>
        <tr>
            <td>Pre-SIP</td>
            <td>Gather initial community feedback and support.</td>
            <td>N/A. Opening a "Pre-SIP" post on the Scala Contributors forum can be done by anyone at any time</td>
            <td>N/A</td>
        </tr>
        <!-- Additional table rows omitted for brevity -->
    </tbody>
</table>

----------------------------------------

TITLE: Pattern Matching with Quasiquotes in Scala
DESCRIPTION: Shows how to use quasiquotes for pattern matching against syntax trees in Scala. The match case uses the same q"..." syntax to define a pattern that checks for structural equality.

LANGUAGE: scala
CODE:
println(tree match { case q"i am { a quasiquote }" => "it worked!" })

----------------------------------------

TITLE: Configuring Scala Compiler for Enhanced Error Formatting
DESCRIPTION: Basic configuration options for enabling improved error formatting in Scala 2.13.6. These flags enable printing of implicit chains and colored diffs for found/required errors.

LANGUAGE: scala
CODE:
-Vimplicits
-Vtype-diffs

----------------------------------------

TITLE: Immutable Value Declaration
DESCRIPTION: Shows how immutable values are declared in both languages

LANGUAGE: javascript
CODE:
const

LANGUAGE: scala
CODE:
val

----------------------------------------

TITLE: Basic Comments Comparison
DESCRIPTION: Shows how comments are written in both JavaScript and Scala

LANGUAGE: javascript
CODE:
//
/* ... */
/** ... */

LANGUAGE: scala
CODE:
//
/* ... */
/** ... */

----------------------------------------

TITLE: Defining a Class and Companion Object in Scala
DESCRIPTION: Demonstrates how to define a class named 'Inbox' and its companion object in a file named 'Inbox.scala'. The class and object are placed in the 'org.coolness' package.

LANGUAGE: scala
CODE:
package org.coolness

class Inbox { ... }

// companion object
object Inbox { ... }

----------------------------------------

TITLE: Enabling Comparisons Between Different Book Types
DESCRIPTION: This snippet shows how to allow comparisons between PrintedBook and AudioBook instances using CanEqual type class instances.

LANGUAGE: scala
CODE:
// allow `PrintedBook == AudioBook`, and `AudioBook == PrintedBook`
given CanEqual[PrintedBook, AudioBook] = CanEqual.derived
given CanEqual[AudioBook, PrintedBook] = CanEqual.derived

println(pBook == aBook)   // false
println(aBook == pBook)   // false

----------------------------------------

TITLE: Invariant Box Class Implementation
DESCRIPTION: Shows how to implement a basic invariant generic Box class with mutable content.

LANGUAGE: scala
CODE:
class Box[A](var content: A)

----------------------------------------

TITLE: JSON Type Conversion in Scala
DESCRIPTION: Demonstrates how to convert JSON values to specific Scala types using uJson's type conversion methods. Shows handling of objects, numbers, and arrays with proper type annotations.

LANGUAGE: scala
CODE:
import scala.collection.mutable

val jsonString = "{\"name\": \"Peter\", \"age\": 13, \"pets\": [\"Toolkitty\", \"Scaniel\"]}"
val json = ujson.read(jsonString)

val person: mutable.Map[String, ujson.Value] = json.obj
val age: Double = person("age").num
val pets: mutable.Buffer[ujson.Value] = person("pets").arr

----------------------------------------

TITLE: Defining MapOps trait in Scala
DESCRIPTION: Shows the definition of the MapOps trait for Map collections.

LANGUAGE: scala
CODE:
trait MapOps[K, +V, +CC[_, _], +C] extends IterableOps[(K, V), Iterable, C]:
  def map[K2, V2](f: ((K, V)) => (K2, V2)): CC[K2, V2] = …

----------------------------------------

TITLE: Auto-application Example
DESCRIPTION: Demonstrates the deprecated auto-application syntax for empty-paren methods and its explicit form.

LANGUAGE: scala
CODE:
object Hello {
  def message(): String = "Hello"
}

println(Hello.message)

----------------------------------------

TITLE: Run Method with Named Context Bound (Proposed Syntax)
DESCRIPTION: Proposed syntax for a run method using a named context bound for Parser.

LANGUAGE: scala
CODE:
def run[P : Parser as p](in: p.Input): p.Result

----------------------------------------

TITLE: Implementing Reduce Method with Summon in Scala
DESCRIPTION: Implementation of the reduce method using summon to access the Monoid instance.

LANGUAGE: scala
CODE:
def reduce[A : Monoid](xs: List[A]): A =
  xs.foldLeft(summon[Monoid[A]].unit)(_ `combine` _)

----------------------------------------

TITLE: Defining Comparer Type with Context Bound in Scala (Proposed)
DESCRIPTION: Proposed syntax for defining a Comparer type with a context bound in a function type.

LANGUAGE: scala
CODE:
type Comparer = [X: Ord] => (x: X, y: X) => Boolean
val less: Comparer = [X: Ord as ord] => (x: X, y: X) =>
  ord.compare(x, y) < 0

----------------------------------------

TITLE: Defining Custom Operators with Case Classes in Scala
DESCRIPTION: Demonstrates how to define a custom + operator for a Vec case class in Scala, allowing vector addition.

LANGUAGE: scala
CODE:
case class Vec(x: Double, y: Double):
  def +(that: Vec) = Vec(this.x + that.x, this.y + that.y)

val vector1 = Vec(1.0, 1.0)
val vector2 = Vec(2.0, 2.0)

val vector3 = vector1 + vector2
vector3.x  // 3.0
vector3.y  // 3.0

----------------------------------------

TITLE: Scala Package Level Definitions
DESCRIPTION: Example showing package level value and function definitions

LANGUAGE: scala
CODE:
package p

val a = (1, 2)

def b = a._2

----------------------------------------

TITLE: Defining Iso Trait for Type Isomorphisms in Scala
DESCRIPTION: Introduces the Iso trait representing isomorphisms between types, used for converting between case classes and tuples.

LANGUAGE: scala
CODE:
trait Iso[T, U] {
  def to(t: T) : U
  def from(u: U) : T
}

case class Foo(i: Int, s: String, b: Boolean)
def conv[C, L](c: C)(implicit iso: Iso[C, L]): L = iso.to(c)

val tp  = conv(Foo(23, "foo", true))
tp: (Int, String, Boolean)
tp == (23, "foo", true)

----------------------------------------

TITLE: Error Reporting in Scala Inline Methods
DESCRIPTION: Demonstrates how to emit compile-time error messages within inline methods using the error function. The error is emitted only when the code is not eliminated as part of a dead branch during inlining.

LANGUAGE: scala
CODE:
inline def doSomething(inline mode: Boolean): Unit =
  if mode then ...
  else if !mode then ...
  else error("Mode must be a known value")

doSomething(true)
doSomething(false)
val bool: Boolean = ...
doSomething(bool) // error: Mode must be a known value

----------------------------------------

TITLE: Importing Given Instances in Scala 3
DESCRIPTION: This snippet demonstrates how to import given instances separately from other members in Scala 3. It shows the basic form of importing all non-given members and then importing only the given instance.

LANGUAGE: scala
CODE:
object A:
  class TC
  given tc: TC = ???
  def f(using TC) = ???

object B:
  import A.*       // import all non-given members
  import A.given   // import the given instance

----------------------------------------

TITLE: Defining Mutable Fields in Java and Scala
DESCRIPTION: Demonstrates how to define mutable fields in Java and Scala.

LANGUAGE: java
CODE:
int i = 1;
var i = 1;

LANGUAGE: scala
CODE:
var i = 1

----------------------------------------

TITLE: Function Definition in Scala
DESCRIPTION: Demonstrates various ways to define functions in Scala, including standard functions, anonymous functions, and functions with explicit return types.

LANGUAGE: scala
CODE:
def f(x: Int) = { x * x }

def f(x: Any) = println(x)

type R = Double
def f(x: R)

(x: R) => x * x

----------------------------------------

TITLE: Using Helper Method
DESCRIPTION: Demonstrates how to use the traditional helper method approach.

LANGUAGE: scala
CODE:
val aCircle = Circle(2, 3, 5)

// without extension methods
CircleHelpers.circumference(aCircle)

----------------------------------------

TITLE: Function Value Type Inference in Scala
DESCRIPTION: Shows how Scala handles type inference for function values when the type is already known from context.

LANGUAGE: scala
CODE:
val ls: List[String] = ...
ls.map(str => str.toInt)

----------------------------------------

TITLE: Creating Collections with Scala REPL Examples
DESCRIPTION: Demonstrates creating collections using the apply method in the Scala REPL, showing how abstract base classes like Traversable are implemented.

LANGUAGE: scala
CODE:
scala> List(1, 2, 3)
res17: List[Int] = List(1, 2, 3)
scala> Traversable(1, 2, 3)
res18: Traversable[Int] = List(1, 2, 3)
scala> mutable.Traversable(1, 2, 3)
res19: scala.collection.mutable.Traversable[Int] = ArrayBuffer(1, 2, 3)

----------------------------------------

TITLE: Configuring GitHub Pages Publication
DESCRIPTION: sbt configuration for publishing documentation to GitHub Pages using sbt-ghpages.

LANGUAGE: scala
CODE:
enablePlugins(GhpagesPlugin)
git.remoteRepo := sonatypeProjectHosting.value.get.scmUrl

----------------------------------------

TITLE: Defining YAML Front Matter for Scala SIP Meeting Results
DESCRIPTION: This YAML front matter block defines metadata for a page documenting Scala Improvement Proposal (SIP) meeting results. It specifies the layout, title, and details of the proposals discussed, including their GitHub URLs, names, and outcomes.

LANGUAGE: yaml
CODE:
---
layout: sip-meeting-results
title: SIP Meeting Results - 27th September 2024
partof: results
proposals:
  - url: https://github.com/scala/improvement-proposals/pull/72
    name: SIP-58 - Named Tuples
    result: accepted
  - url: https://github.com/scala/improvement-proposals/pull/81
    name: SIP-64 - Improve the syntax of context bounds and givens
    result: accepted
---

----------------------------------------

TITLE: Method Declaration Patterns in Scala
DESCRIPTION: Illustrates proper method declaration syntax including parameter handling, return types, and modifiers ordering.

LANGUAGE: scala
CODE:
@Transaction
@throws(classOf[IOException])
override protected final def foo(): Unit = {
  ...
}

----------------------------------------

TITLE: Defining Syntax for Trait Parameters in Scala
DESCRIPTION: This code snippet defines the syntax for trait parameters in Scala, including class definitions, template options, and constructor applications.

LANGUAGE: scala
CODE:
TmplDef ::=  ([`case'] `class' | `trait') ClassDef
ClassDef ::=  id [ClsTypeParamClause] [ConstrMods] ClsParamClauses TemplateOpt
TemplateOpt ::=  [`extends' Template | [nl] TemplateBody]
Template ::=  ConstrApps [TemplateBody] | TemplateBody
ConstrApps ::=  ConstrApp {`with' ConstrApp}
ConstrApp  ::=  AnnotType {ArgumentExprs}

----------------------------------------

TITLE: Expr to Term Conversion
DESCRIPTION: Shows how to convert between Expr[T] and Term representations using asTerm and asExprOf methods from the reflection API.

LANGUAGE: scala
CODE:
def f(x: Expr[Int])(using Quotes): Expr[Int] =
  import quotes.reflect.*
  val tree: Term = x.asTerm
  val expr: Expr[Int] = tree.asExprOf[Int]
  expr

----------------------------------------

TITLE: Example Function with Wildcard Type
DESCRIPTION: Example showing function definition with wildcard type parameter usage

LANGUAGE: scala
CODE:
def f[X](x: C[X])

f(C[_])

----------------------------------------

TITLE: Implementing H2Db Type Macro in Scala
DESCRIPTION: This snippet shows the implementation of the H2Db type macro. It demonstrates how to generate a statically typed database wrapper by connecting to the database at compile-time, introducing a top-level definition, and returning an Apply node.

LANGUAGE: scala
CODE:
type H2Db(url: String) = macro impl

def impl(c: Context)(url: c.Expr[String]): c.Tree = {
  val name = c.freshName(c.enclosingImpl.name).toTypeName
  val clazz = ClassDef(..., Template(..., generateCode()))
  c.introduceTopLevel(c.enclosingPackage.pid.toString, clazz)
  val classRef = Select(c.enclosingPackage.pid, name)
  Apply(classRef, List(Literal(Constant(c.eval(url)))))
}

object Db extends H2Db("coffees")
// equivalent to: object Db extends Db$1("coffees")

----------------------------------------

TITLE: Inline Method with Different Parameter Types in Scala 3
DESCRIPTION: Demonstrates an inline method using by-value, by-name, and inline parameters, showing how they are handled differently during inlining.

LANGUAGE: scala
CODE:
inline def logged[T](level: Int, message: => String)(inline op: T): T =
  println(s"[$level]Computing $message")
  val res = op
  println(s"[$level]Result of $message: $res")
  res

----------------------------------------

TITLE: Companion Object for Prefix Maps in Scala
DESCRIPTION: Companion object for PrefixMap class with factory methods and CanBuildFrom implicit.

LANGUAGE: scala
CODE:
import scala.collection.mutable.{Builder, MapBuilder}
import scala.collection.generic.CanBuildFrom

object PrefixMap extends {
  def empty[T] = new PrefixMap[T]

  def apply[T](kvs: (String, T)*): PrefixMap[T] = {
    val m: PrefixMap[T] = empty
    for (kv <- kvs) m += kv
    m
  }

  def newBuilder[T]: Builder[(String, T), PrefixMap[T]] =
    new MapBuilder[String, T, PrefixMap[T]](empty)

  implicit def canBuildFrom[T]
    : CanBuildFrom[PrefixMap[_], (String, T), PrefixMap[T]] =
      new CanBuildFrom[PrefixMap[_], (String, T), PrefixMap[T]] {
        def apply(from: PrefixMap[_]) = newBuilder[T]
        def apply() = newBuilder[T]
      }
}

----------------------------------------

TITLE: YAML Configuration for Scala Documentation Homepage
DESCRIPTION: YAML layout configuration that defines the structure and content of the Scala documentation landing page. Includes sections for beginners, returning users, Scala 3 exploration, and language evolution information. Each section contains links with titles, descriptions, icons, and URLs.

LANGUAGE: yaml
CODE:
---
layout: landing-page
languages: [ja, zh-cn, ru, uk]

title: Learn Scala
namespace: root
discourse: true
partof: documentation
more-resources-label: More Resources
redirect_from:
  - /scala3/
  - /scala3/index.html

sections:
  - title: "First Steps..."
    links:
      - title: "Getting Started"
        description: "Install Scala on your computer and start writing some Scala code!"
        icon: "fa fa-rocket"
        link: /getting-started/install-scala.html
      # ... [truncated for brevity]
---

----------------------------------------

TITLE: Implementing Ord trait and max function
DESCRIPTION: Definition of the Ord trait for comparing values and a max function that uses it to compare two values.

LANGUAGE: scala
CODE:
/** Defines how to compare values of type `A` */
trait Ord[A]:
  def greaterThan(a1: A, a2: A): Boolean

/** Returns the maximum of two values */
def max[A](a1: A, a2: A)(using ord: Ord[A]): A =
  if ord.greaterThan(a1, a2) then a1 else a2

----------------------------------------

TITLE: Implicit Macro Materializer for Showable in Scala
DESCRIPTION: Demonstrates how to use an implicit macro to automatically generate Showable instances, reducing boilerplate code.

LANGUAGE: scala
CODE:
trait Showable[T] { def show(x: T): String }
object Showable {
  implicit def materializeShowable[T]: Showable[T] = macro ...
}

----------------------------------------

TITLE: Merging Given and Non-Given Imports in Scala 3
DESCRIPTION: This snippet shows how to merge the import of given instances and other members into a single import statement in Scala 3.

LANGUAGE: scala
CODE:
object B:
  import A.{given, *}

----------------------------------------

TITLE: Adding Macro Paradise Plugin to SBT Build in Scala
DESCRIPTION: This snippet shows how to add the Macro Paradise plugin to an SBT build file. It includes adding the Sonatype releases resolver and the compiler plugin dependency.

LANGUAGE: scala
CODE:
resolvers += Resolver.sonatypeRepo("releases")
addCompilerPlugin("org.scalamacros" % "paradise" % "2.1.0" cross CrossVersion.full)

----------------------------------------

TITLE: Configuring Sonatype Credentials
DESCRIPTION: Example of how to store Sonatype credentials in a local sbt file.

LANGUAGE: scala
CODE:
credentials += Credentials("Sonatype Nexus Repository Manager",
        "oss.sonatype.org",
        "(Sonatype user name)",
        "(Sonatype password)")

----------------------------------------

TITLE: Defining SIP Meeting Results in YAML Front Matter
DESCRIPTION: This YAML front matter defines metadata for a Scala Improvement Proposal (SIP) meeting results page. It specifies the layout, title, and lists the proposals discussed along with their outcomes.

LANGUAGE: yaml
CODE:
---
layout: sip-meeting-results
title: SIP Meeting Results - 21st June 2024
partof: results
proposals:
  - url: https://github.com/scala/improvement-proposals/pull/47
    name: SIP-47 - Clause interleaving
    result: accepted
---

----------------------------------------

TITLE: Tworzenie podstawowego pakietu w Scala
DESCRIPTION: Pokazuje, jak zadeklarować pakiet i zdefiniować w nim klasę. Jest to najprostszy sposób tworzenia pakietów w Scala.

LANGUAGE: scala
CODE:
package users

class User

----------------------------------------

TITLE: Defining SIP-21 Metadata in YAML
DESCRIPTION: YAML frontmatter metadata block defining the title, status and pull request number for SIP-21 proposal about Spores.

LANGUAGE: yaml
CODE:
---
title: SIP-21 - Spores
status: withdrawn
pull-request-number: 20

---

----------------------------------------

TITLE: Defining Extension Method in Scala 3
DESCRIPTION: Demonstrates the syntax for defining an extension method 'span' on IArray[T] in Scala 3. The method takes a predicate function and returns a tuple of two IArrays.

LANGUAGE: scala
CODE:
extension [T](arr: IArray[T]) def span(p: T => Boolean): (IArray[T], IArray[T]) = ...

----------------------------------------

TITLE: Generating Meeting Minutes List with Liquid Templates
DESCRIPTION: Liquid template code that generates an ordered list of historical SIP meeting minutes by sorting entries by date in reverse chronological order and filtering for 'minutes' content.

LANGUAGE: liquid
CODE:
{% assign sips = site.sips | sort: 'date' | reverse %}
{% for pg in sips %}
  {% if pg.partof == 'minutes' %}
    <li><a href="{{ site.baseurl }}{{ pg.url }}">{{ pg.title }}</a></li>
  {% endif %}
{% endfor %}

----------------------------------------

TITLE: Creating Class Definitions with Modifiers in Scala Reflection
DESCRIPTION: Shows how to create class definitions with different modifiers using reflection.

LANGUAGE: scala
CODE:
ClassDef(Modifiers(NoFlags), TypeName("C"), Nil, ...)
ClassDef(Modifiers(PRIVATE), TypeName("C"), Nil, ...)
ClassDef(Modifiers(PRIVATE | FINAL), TypeName("C"), Nil, ...)

----------------------------------------

TITLE: Formatting Scala Code Block in Markdown
DESCRIPTION: Demonstrates how to properly format a Scala code block in Markdown for bug reports. This ensures the code is displayed correctly in the issue tracker.

LANGUAGE: markdown
CODE:
```scala
List(1, 2, 3).map(x => x + 1)
```

----------------------------------------

TITLE: Running Partest with Ant
DESCRIPTION: Command for running the test suite using ant (note: removed in 2.12 branch).

LANGUAGE: bash
CODE:
$ ant test.suite

----------------------------------------

TITLE: Creating a TermName in Scala Reflection
DESCRIPTION: Demonstrates how to create a TermName object using the runtime reflection universe.

LANGUAGE: scala
CODE:
import scala.reflect.runtime.universe._
val mapName = TermName("map")

----------------------------------------

TITLE: Future の関数型合成の例
DESCRIPTION: map と flatMap を使用して Future を合成する例

LANGUAGE: scala
CODE:
val purchase = for {
  usd <- usdQuote
  chf <- chfQuote
  if isProfitable(usd, chf)
} yield connection.buy(amount, chf)

----------------------------------------

TITLE: Creating a Syntax Tree with Quasiquotes in Scala
DESCRIPTION: Demonstrates how to create a syntax tree using quasiquotes in Scala. The q"..." syntax is used to wrap a code snippet, which is then converted into a tree representation.

LANGUAGE: scala
CODE:
val tree = q"i am { a quasiquote }"

----------------------------------------

TITLE: List Showable Implementation with Implicit Macro Integration in Scala
DESCRIPTION: Shows how to implement a Showable instance for Lists that works seamlessly with the macro-based materializer for individual elements.

LANGUAGE: scala
CODE:
implicit def listShowable[T](implicit s: Showable[T]) =
  new Showable[List[T]] {
    def show(x: List[T]) = { x.map(s.show).mkString("List(", ", ", ")")
  }
}
show(List(42)) // prints: List(42)

----------------------------------------

TITLE: Implementing a Covariant List with Lower Type Bounds in Scala
DESCRIPTION: This code snippet demonstrates the implementation of a covariant singly-linked list in Scala using lower type bounds. It shows how to define a List trait, NonEmptyList case class, and Nil object, and how to use lower type bounds to fix variance-related compilation issues.

LANGUAGE: scala
CODE:
trait List[+A]:
  def prepend[B >: A](elem: B): NonEmptyList[B] = NonEmptyList(elem, this)

case class NonEmptyList[+A](head: A, tail: List[A]) extends List[A]

object Nil extends List[Nothing]

----------------------------------------

TITLE: Creating WebSocket Client Interface with HTML/JavaScript
DESCRIPTION: HTML template with JavaScript code that establishes WebSocket connection to the server, handles message sending and receiving, and manages connection status.

LANGUAGE: html
CODE:
<!DOCTYPE html>
<html>
<body>
<div>
    <input type="text" id="input" placeholder="Provide city name">
    <button onclick="sendMessage()">Send</button>
</div>
<div id="time"></div>
<script>
    const ws = new WebSocket('ws://localhost:8080/websocket');
    ws.onmessage = function(event) {
        receiveMessage(event.data);
    };

    ws.onclose = function(event) {
        receiveMessage('The connection has been closed');
    };

    function sendMessage() {
        const inputElement = document.getElementById('input');
        const message = inputElement.value;
        ws.send(message);
    }

    function receiveMessage(message) {
        const timeElement = document.getElementById('time');
        timeElement.textContent = message;
    }
</script>
</body>
</html>

----------------------------------------

TITLE: Comparación con notación orientada a objetos tradicional en Scala
DESCRIPTION: Este snippet muestra la misma funcionalidad que el anterior, pero utilizando una sintaxis de orientación a objetos más tradicional para comparación.

LANGUAGE: scala
CODE:
def not(x: MyBool) = x.negate; // punto y coma necesario aquí
def xor(x: MyBool, y: MyBool) = x.or(y).and(x.and(y).negate)

----------------------------------------

TITLE: YAML Frontmatter Configuration for SIP Meeting Results Page
DESCRIPTION: YAML frontmatter configuration block defining the page layout, title, and tracking of proposal statuses including SIP-61's acceptance and SIP-64's discussion status.

LANGUAGE: yaml
CODE:
---
layout: sip-meeting-results
title: SIP Meeting Results - 24th May 2024
partof: results
proposals:
  - url: https://github.com/scala/improvement-proposals/pull/78
    name: SIP-61 - Unroll default arguments for binary compatibility
    result: accepted
---

----------------------------------------

TITLE: Package Naming and Root Access in Scala
DESCRIPTION: Shows correct package naming conventions and usage of _root_ qualifier for fully-qualified imports.

LANGUAGE: scala
CODE:
package com.novell.coolness

package com.novell
package coolness

import _root_.net.liftweb._

----------------------------------------

TITLE: Type Pattern Matching in Scala Quotes
DESCRIPTION: Examples of quoted type pattern matching using nested type variable definitions.

LANGUAGE: scala
CODE:
case '[ t ] => f[t]
case '[ List[t] ] => g[t]

----------------------------------------

TITLE: Type Alias and Method Declarations
DESCRIPTION: Demonstration of class methods and type alias usage with different parameter arrangements that can be found via type-based search

LANGUAGE: scala
CODE:
class Num():
  def a(i: Int, j: Int): Int
  def b(i: Int)(j: Int): Int
  def c(i: Int): (Int => Int)
  val d: Int => Int => Int
  val e: Int => Int => Int
  val f: (Int, Int) => Int
end Num

def g(i: Num, j: Int, k: Int): Int
extension (i: Num) def h(j: Int, k: Int): Int
def i(i: Num, j: Int)(k: Int): Int
extension (i: Num) def j(j: Int)(k: Int): Int
...

----------------------------------------

TITLE: Lazy Val Solution for Initialization
DESCRIPTION: Solution using lazy vals to defer initialization until first access, preventing null values during construction.

LANGUAGE: scala
CODE:
abstract class A {
  lazy val x1: String
  lazy val x2: String = "mom"

  println("A: " + x1 + ", " + x2)
}
class B extends A {
  lazy val x1: String = "hello"

  println("B: " + x1 + ", " + x2)
}
class C extends B {
  override lazy val x2: String = "dad"

  println("C: " + x1 + ", " + x2)
}

----------------------------------------

TITLE: Table Row Hover Effect
DESCRIPTION: jQuery code that implements a hover effect for table rows, changing background color on mouse enter and leave.

LANGUAGE: javascript
CODE:
jQuery(document).ready(function($) {
  $(".bottom table tr").hover(
    function(){$(this).css("background-color", "#FFCC85");},
    function(){$(this).css("background-color", "#ffffff");}
  );
});

----------------------------------------

TITLE: Custom JSON Serialization in Scala 3
DESCRIPTION: Demonstrates custom JSON serialization using Scala 3 syntax with given instances. Shows the same Bar class serialization example adapted for Scala 3's syntax.

LANGUAGE: scala
CODE:
import upickle.default.*

case class Bar(i: Int, s: String)

object Bar:
  given ReadWriter[Bar] = readwriter[ujson.Value]
    .bimap[Bar](
      x => ujson.Arr(x.s, x.i),
      json => new Bar(json(1).num.toInt, json(0).str)
    )

val bar = Bar(5, "bar")
val json = upickle.default.write(bar)
println(json)
// prints: [5, "bar"]

----------------------------------------

TITLE: Match Type Pattern Examples
DESCRIPTION: Examples of legal and illegal match type patterns showcasing various use cases.

LANGUAGE: scala
CODE:
// Legal patterns
case Any =>
case Int =>
case List[Int] =>
case Array[String] =>
case scala.collection.immutable.List[t] =>
case Array[t] =>
case Either[s, t] =>

// Illegal patterns
case Inv[Cov[t]] =>
case Inv[Inv[t]] =>
case Contra[Cov[t]] =>

----------------------------------------

TITLE: Defining Metadata for Scala 3 Contribution Guide
DESCRIPTION: This YAML frontmatter block defines metadata for a webpage about contributing to Scala 3. It includes a title, description, and a redirect URL to the official documentation.

LANGUAGE: yaml
CODE:
---
title: Contributing to Scala 3
description: This page introduces the compiler procedures for the Scala 3 compiler.
redirect_to: https://dotty.epfl.ch/docs/contributing/procedures/index.html
---

----------------------------------------

TITLE: Building and running Scala Android app with Maven
DESCRIPTION: Maven commands for building, running, and packaging the Scala Android app using GraalVM Native Image and Gluon plugins.

LANGUAGE: bash
CODE:
mvn gluonfx:run
mvn gluonfx:build gluonfx:nativerun
mvn -Pandroid gluonfx:build gluonfx:package

----------------------------------------

TITLE: Quasiquote Pattern Examples in Scala
DESCRIPTION: Examples of quasiquote syntax for various Scala pattern matching constructs, including wildcard patterns, literal patterns, and extractor patterns.

LANGUAGE: scala
CODE:
pq"_"
pq"$value"
pq"$name @ $pat"
pq"$ref(..$pats)"
pq"_: $tpt"
pq"$first │ ..$rest"
pq"(..$pats)"

----------------------------------------

TITLE: Cross-Compatible Scala 2/3 Macro Implementation
DESCRIPTION: A macro implementation that works in both Scala 2 and 3, using basic reflection without quasiquotes.

LANGUAGE: scala
CODE:
import scala.reflect.macros.blackbox.Context

def locationImpl(c: Context): c.Tree =  {
  import c.universe._
  val line = Literal(Constant(c.enclosingPosition.line))
  val path = Literal(Constant(c.enclosingPosition.source.path))
  New(c.mirror.staticClass(classOf[Location].getName()), path, line)
}

----------------------------------------

TITLE: Local Imports in Scala 2
DESCRIPTION: Shows how to use imports locally within a function in Scala 2. This feature allows for more fine-grained control over imports.

LANGUAGE: scala
CODE:
def sqrtplus1(x: Int) = {
  import scala.math.sqrt
  sqrt(x) + 1.0
}

----------------------------------------

TITLE: Implementing Asynchronous HTTP Requests with sttp Future Backend
DESCRIPTION: Demonstrates how to send asynchronous HTTP requests using sttp's DefaultFutureBackend. The code shows how to make a GET request that returns a Future[Response[String]].

LANGUAGE: scala
CODE:
import scala.concurrent.Future
import sttp.client4._

val asyncBackend = DefaultFutureBackend()
val response: Future[Response[String]] = quickRequest
  .get(uri"https://example.com")
  .send(asyncBackend)

----------------------------------------

TITLE: Utilizando operadores de infijo y postfijo en Scala
DESCRIPTION: Este código demuestra cómo utilizar los métodos de MyBool como operadores de infijo y postfijo, incluyendo la definición de una función XOR.

LANGUAGE: scala
CODE:
def not(x: MyBool) = x negate; // punto y coma necesario aquí
def xor(x: MyBool, y: MyBool) = (x or y) and not(x and y)

----------------------------------------

TITLE: Markdown Front Matter for Scala Improvement Process Page
DESCRIPTION: YAML front matter defining the layout and title for the Scala Improvement Process page in a static site generator.

LANGUAGE: markdown
CODE:
---
layout: sips
title: Scala Improvement Process
---

----------------------------------------

TITLE: Compiler Options Migration Example
DESCRIPTION: Example showing how to configure scalacOptions for both Scala 2.13 and Scala 3 compatibility

LANGUAGE: scala
CODE:
lazy val main = project
  .in(file("."))
  .settings(
    scalaVersion := "2.13.11",
    scalacOptions ++= {
      if (scalaVersion.value.startsWith("3.")) scala3Options
      else scala2Options
    }
  )

lazy val sharedScalacOptions =
  Seq("-encoding", "UTF-8", "-Wunused:imports,privates,locals")

lazy val scala2Options = sharedScalacOptions ++
  Seq("-target:jvm-1.8", "-Xsource:3", "-explaintypes")

lazy val scala3Options = sharedScalacOptions ++
  Seq("-Xunchecked-java-output-version:8", "-explain")

----------------------------------------

TITLE: NamedTuple Implementation
DESCRIPTION: Core implementation of the NamedTuple type showing how named tuples are represented internally using opaque types.

LANGUAGE: scala
CODE:
opaque type NamedTuple[N <: Tuple, +V <: Tuple] >: V = V

----------------------------------------

TITLE: Singleton Type Construction in Scala Quasiquotes
DESCRIPTION: Shows how to create and match singleton types using the .type syntax.

LANGUAGE: scala
CODE:
val singleton = tq"foo.bar.type".sr
val tq"$ref.type" = tq"foo.bar.type"

----------------------------------------

TITLE: Class Member Ordering in Scala
DESCRIPTION: Shows proper organization of class members including fields and methods, with rules for newline spacing and field precedence.

LANGUAGE: scala
CODE:
class Foo {
  val bar = 42
  val baz = "Daniel"

  def doSomething(): Unit = { ... }

  def add(x: Int, y: Int): Int = x + y
}

----------------------------------------

TITLE: Configuring MUnit in Mill Build
DESCRIPTION: Demonstrates how to set up MUnit testing in a Mill build file using the toolkit-test package and TestModule.Munit trait.

LANGUAGE: scala
CODE:
object example extends ScalaModule {
  def scalaVersion = "3.4.2"
  object test extends Tests with TestModule.Munit {
    def ivyDeps =
      Agg(
        ivy"org.scala-lang::toolkit-test:0.7.0"
      )
  }
}

----------------------------------------

TITLE: Tail Recursion Annotation Example in Scala
DESCRIPTION: Shows the use of @tailrec annotation to ensure a method is tail-recursive, with a factorial calculation implementation.

LANGUAGE: scala
CODE:
import scala.annotation.tailrec

def factorial(x: Int): Int =

  @tailrec
  def factorialHelper(x: Int, accumulator: Int): Int =
    if x == 1 then accumulator else factorialHelper(x - 1, accumulator * x)
  factorialHelper(x, 1)

----------------------------------------

TITLE: Simplifying Technical Instructions Example
DESCRIPTION: Shows how to rewrite technical instructions by removing unnecessary qualifiers like 'simply' and 'just' while maintaining clarity.

LANGUAGE: markdown
CODE:
Original: You can then simply execute the program with the `run` command.
Improved: You can then execute the program with the `run` command.

----------------------------------------

TITLE: Quoted Code Expression Example - Scala
DESCRIPTION: Demonstrates how to improve readability when working with quoted code expressions by breaking down complex operations into separate variables.

LANGUAGE: scala
CODE:
val sc: StringContext = ...
val partExprs = sc.parts.map(Expr(_))
val partsExpr = Varargs(partExprs)
'{ StringContext($partsExpr: _*) }

----------------------------------------

TITLE: Defining Basic Classes in Scala
DESCRIPTION: Shows how to define simple classes with constructor parameters defined as var fields

LANGUAGE: scala
CODE:
class Person(var name: String, var vocation: String)
class Book(var title: String, var author: String, var year: Int)
class Movie(var name: String, var director: String, var year: Int)

----------------------------------------

TITLE: Type Projection and Selection in Scala Quasiquotes
DESCRIPTION: Illustrates type projection syntax with # operator and type member selection.

LANGUAGE: scala
CODE:
val proj = tq"Foo#Bar"
val tq"$foo#$bar" = proj

val int = tq"scala.Int"
val tq"scala.$name" = int

----------------------------------------

TITLE: Workaround for Referential Transparency using Fully Qualified Names
DESCRIPTION: This snippet demonstrates how to avoid referential transparency issues in macros by using fully qualified names with '_root_' prefix.

LANGUAGE: scala
CODE:
def impl(c: Context)(x: c.Tree) = {
  import c.universe._
  q"_root_.example.MyMacro.wrapper($x)"
}

----------------------------------------

TITLE: Running sbt test command
DESCRIPTION: Demonstrates the output of running 'sbt test' command to execute ScalaTest suite.

LANGUAGE: bash
CODE:
sbt test
[info] Loading global plugins from /Users/username/.sbt/0.13/plugins
[info] Loading project definition from /Users/username/workspace/sandbox/my-something-project/project
[info] Set current project to scalatest-example (in build file:/Users/username/workspace/sandbox/my-something-project/)
[info] CubeCalculatorTest:
[info] - CubeCalculator.cube
[info] Run completed in 267 milliseconds.
[info] Total number of tests run: 1
[info] Suites: completed 1, aborted 0
[info] Tests: succeeded 1, failed 0, canceled 0, ignored 0, pending 0
[info] All tests passed.
[success] Total time: 1 s, completed Feb 2, 2017 7:37:31 PM

----------------------------------------

TITLE: Reading Process Output with BC Calculator in Scala
DESCRIPTION: Shows how to execute the bc calculator command and read its output as text. Demonstrates basic arithmetic computation using an external process.

LANGUAGE: scala
CODE:
val res: os.CommandResult = os.proc("bc", "-e", "2 + 2").call()
val text: String = res.out.text()
println(text.trim.toInt)
// prints: 4

----------------------------------------

TITLE: Converting Java collections to Scala mutable collections
DESCRIPTION: 展示如何将Java集合转换回Scala的可变集合类型。使用asScala方法进行转换。

LANGUAGE: scala
CODE:
val buf: Seq[Int] = jul.asScala

----------------------------------------

TITLE: Hello World with Val in Scala
DESCRIPTION: This snippet shows a simple 'Hello, world' program in Scala using a val field to store the greeting message.

LANGUAGE: scala
CODE:
object Hello3 extends App {
    val hello = "Hello, world"
    println(hello)
}

----------------------------------------

TITLE: Basic Type Parameter List Interleaving in Scala
DESCRIPTION: Demonstrates a simple example of interleaving type and term parameter lists in a method definition.

LANGUAGE: scala
CODE:
def pair[A](a: A)[B](b: B): (A, B) = (a, b)

----------------------------------------

TITLE: JSON Response Generation with Case Classes
DESCRIPTION: Shows how to generate JSON responses using case classes and uPickle serialization. Includes type class derivation for JSON serialization.

LANGUAGE: scala
CODE:
import java.time.{ZoneId, ZonedDateTime}

object Example extends cask.MainRoutes {
  import upickle.default.{ReadWriter, macroRW, writeJs}
  case class TimeData(timezone: Option[String], time: String)
  object TimeData {
    implicit val rw: ReadWriter[TimeData] = macroRW
  }

  private def getZoneIdForCity(city: String): Option[ZoneId] = {
    import scala.jdk.CollectionConverters._
    ZoneId.getAvailableZoneIds.asScala.find(_.endsWith("/" + city)).map(ZoneId.of)
  }

  @cask.get("/time_json/:city")
  def timeJSON(city: String): ujson.Value = {
    val timezone = getZoneIdForCity(city)
    val time = timezone match {
      case Some(zoneId) => s"Current date is: ${ZonedDateTime.now().withZoneSameInstant(zoneId)}"
      case None => s"Couldn't find time zone for city $city"
    }
    writeJs(TimeData(timezone.map(_.toString), time))
  }

  initialize()
}

----------------------------------------

TITLE: Formatting Method Calls with Numerous Arguments in Scala
DESCRIPTION: This snippet shows the recommended way to format method calls with multiple arguments, placing each argument on a separate line for improved readability.

LANGUAGE: scala
CODE:
foo(
  someVeryLongFieldName,
  andAnotherVeryLongFieldName,
  "this is a string",
  3.1415)

----------------------------------------

TITLE: Configuring MUnit in SBT Build
DESCRIPTION: Shows how to configure MUnit dependency in an SBT build file using the toolkit-test package. The Test configuration ensures the dependency is only available in test sources.

LANGUAGE: scala
CODE:
lazy val example = project.in(file("."))
  .settings(
    scalaVersion := "3.4.2",
    libraryDependencies += "org.scala-lang" %% "toolkit-test" % "0.7.0" % Test
  )

----------------------------------------

TITLE: Configuring sbt-site and Paradox
DESCRIPTION: sbt configuration for setting up documentation generation using sbt-site and Paradox.

LANGUAGE: scala
CODE:
enablePlugins(ParadoxSitePlugin, SitePreviewPlugin)
Paradox / sourceDirectory := sourceDirectory.value / "documentation"

----------------------------------------

TITLE: Generating Scaladoc Using sbt
DESCRIPTION: Using the sbt shell to generate API documentation. The generated HTML documentation will be placed in the target/ directory.

LANGUAGE: bash
CODE:
> doc
[info] Main Scala API documentation to target/scala-2.12/api...
[info] model contains 1 documentable templates
[info] Main Scala API documentation successful.
[success] Total time: 20 s

----------------------------------------

TITLE: Instantiating Classes in Scala 3
DESCRIPTION: Shows Scala 3's creator application syntax without new keyword

LANGUAGE: scala
CODE:
val p = Person("Robert Allen Zimmerman", "Harmonica Player")

----------------------------------------

TITLE: GitHub Actions Workflow for Continuous Publication
DESCRIPTION: YAML configuration for setting up a GitHub Actions workflow for continuous publication when a new tag is pushed.

LANGUAGE: yaml
CODE:
name: Continuous publication
on:
  push:
    tags: [v*]

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0
      - uses: actions/setup-java@v3
        with:
          distribution: temurin
          java-version: 8
          cache: sbt
      - run: sbt ci-release
        env:
          PGP_PASSPHRASE: ${{ secrets.PGP_PASSPHRASE }}
          PGP_SECRET: ${{ secrets.PGP_SECRET }}
          SONATYPE_PASSWORD: ${{ secrets.SONATYPE_PASSWORD }}
          SONATYPE_USERNAME: ${{ secrets.SONATYPE_USERNAME }}

----------------------------------------

TITLE: Defining Basic Scala Trait
DESCRIPTION: Demonstrates how to define a basic Scala trait TailWagger with abstract methods for tail movement functionality.

LANGUAGE: scala
CODE:
trait TailWagger {
    def startTail(): Unit
    def stopTail(): Unit
}

----------------------------------------

TITLE: Configuring Cross-Building in sbt for Scala 2.13 and 3
DESCRIPTION: Basic sbt configuration to enable cross-building between Scala 2.13 and Scala 3 versions. Sets the default Scala version and defines additional cross-compilation versions.

LANGUAGE: scala
CODE:
scalaVersion := "3.3.1"
crossScalaVersions ++= Seq("2.13.11", "3.3.1")

----------------------------------------

TITLE: Single Test Selection with .only Modifier - Scala 3
DESCRIPTION: Example of using .only modifier to run a specific test within a test suite in Scala 3. Only the multiplication test will run while the addition test is ignored.

LANGUAGE: scala
CODE:
class MathSuite extends munit.FunSuite:
  test("addition") {
    assert(1 + 1 == 2)
  }
  test("multiplication".only) {
    assert(3 * 7 == 21)
  }

----------------------------------------

TITLE: Definiowanie abstrakcyjnej klasy Graph w Scali
DESCRIPTION: Abstrakcyjna klasa Graph definiuje podstawową strukturę grafu z abstrakcyjnymi typami Edge i Node oraz metodami do zarządzania węzłami i krawędziami.

LANGUAGE: scala
CODE:
abstract class Graph {
  type Edge
  type Node <: NodeIntf
  abstract class NodeIntf {
    def connectWith(node: Node): Edge
  }
  def nodes: List[Node]
  def edges: List[Edge]
  def addNode: Node
}

----------------------------------------

TITLE: Demonstrating Implicit Definition Warning in Scala
DESCRIPTION: This snippet shows how the Scala compiler issues a warning for an implicit definition without an explicit type when using the -Xsource:3 flag.

LANGUAGE: scala
CODE:
scala> object O { implicit val s = "" }
                               ^
       error: Implicit definition must have explicit type (inferred String) [quickfixable]

----------------------------------------

TITLE: Defining Binary APIs with @publicInBinary in Scala
DESCRIPTION: Demonstrates the use of @publicInBinary annotation on various class members to make them publicly accessible in bytecode while maintaining their original visibility in Scala.

LANGUAGE: scala
CODE:
class C {
  @publicInBinary private[C] def packagePrivateAPI: Int = ...
  @publicInBinary protected def protectedAPI: Int = ...
  @publicInBinary def publicAPI: Int = ... // warn: `@publicInBinary` has no effect on public definitions
}

LANGUAGE: java
CODE:
public class C {
  public C();
  public int packagePrivateAPI();
  public int protectedAPI();
  public int publicAPI();
}

----------------------------------------

TITLE: Defining and Using a Method with Single Parameter List in Scala
DESCRIPTION: Example of a method definition with a single parameter list, demonstrating type inference limitations. The method foldLeft1 is defined and then called in ways that either compile or fail to compile.

LANGUAGE: scala
CODE:
def foldLeft1[A, B](as: List[A], b0: B, op: (B, A) => B) = ???

def notPossible = foldLeft1(numbers, 0, _ + _)

def firstWay = foldLeft1[Int, Int](numbers, 0, _ + _)
def secondWay = foldLeft1(numbers, 0, (a: Int, b: Int) => a + b)

----------------------------------------

TITLE: Multi-line Parenthetical Expression Formatting in Scala
DESCRIPTION: Shows proper formatting for long expressions wrapped in parentheses across multiple lines. Parentheses should be unspaced and kept on the same lines as their content.

LANGUAGE: scala
CODE:
(this + is a very ++ long *
  expression)

----------------------------------------

TITLE: Defining a Generic Reference Class in Scala
DESCRIPTION: An example of a generic class in Scala, representing a reference that can hold any type of object.

LANGUAGE: scala
CODE:
class Referencia[T] {
  private var contenido: T = _
  def set(valor: T) { contenido = valor }
  def get: T = contenido
}

----------------------------------------

TITLE: Cross-Version Test for Location Macro
DESCRIPTION: This test case verifies that the location macro works correctly in both Scala 2.13 and Scala 3. It checks if the macro correctly reports the line number.

LANGUAGE: scala
CODE:
package location

class MacrosSpec extends munit.FunSuite {
  test("location") {
    assertEquals(Macros.location.line, 5)
  }
}

----------------------------------------

TITLE: Initializing Google Analytics Tracking
DESCRIPTION: JavaScript code that sets up Google Analytics tracking with account ID UA-574683-5 and adds the tracking script to the page.

LANGUAGE: javascript
CODE:
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-574683-5']);
_gaq.push(['_trackPageview']);

(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();

----------------------------------------

TITLE: Specifying Scala Version and Toolkit for a Project
DESCRIPTION: Creates a project.scala file to specify the Scala version and include the Scala Toolkit for use in an IDE project.

LANGUAGE: scala
CODE:
//> using scala {{site.scala-3-version}}
//> using toolkit 0.5.0

----------------------------------------

TITLE: Extension Method Eta-Expansion
DESCRIPTION: Demonstrates eta-expansion with extension methods and interleaved parameters.

LANGUAGE: scala
CODE:
extension (x: Int)
  def extf1[A](x: A): A = ???

val extv1_1: [B] => B => B = extf1(4) // extf1(4) becomes [B'] => (y: B')  => extf1(4)[B'](y)

val extv1_3: Int => [B] => B => B = extf1 // extf1 becomes (i: Int) => [B'] => (y: B')  => extf1(i)[B'](y)

----------------------------------------

TITLE: Method Definitions in Quasiquotes
DESCRIPTION: Shows how to work with method definitions including modifiers, type parameters, value parameters and return types.

LANGUAGE: scala
CODE:
val q"$mods def $name[..$tparams](...$paramss): $tpt = $body" = q"def f = 1"

----------------------------------------

TITLE: Reverting to braces while keeping new control structures
DESCRIPTION: This snippet demonstrates the result of applying the -no-indent -rewrite options to revert to using braces while retaining the new control structures.

LANGUAGE: scala
CODE:
case class State(n: Int, minValue: Int, maxValue: Int) {
  
  def inc: State =
    if n == maxValue then
      this
    else
      this.copy(n = n + 1)
  
  def printAll: Unit = {
    println("Printing all")
    for {
      i <- minValue to maxValue
      j <- 0 to n
    }
    do println(i + j)
  }
}

----------------------------------------

TITLE: Defining Combiner Trait in Scala
DESCRIPTION: Definition of the Combiner trait which extends Builder to enable combining multiple collection partitions. The combine method merges two Combiners into a new one containing the union of their elements.

LANGUAGE: scala
CODE:
trait Combiner[Elem, To] extends Builder[Elem, To] {
	def combine(other: Combiner[Elem, To]): Combiner[Elem, To]
}

----------------------------------------

TITLE: Defining a Hello World Program in Scala 3
DESCRIPTION: Demonstrates how to write a Hello World program in Scala 3 using the @main annotation and top-level definitions.

LANGUAGE: scala
CODE:
@main def HelloWorld(args: String*): Unit =
  println("Hello, World!")

----------------------------------------

TITLE: Workaround Using Helper Function in Scala
DESCRIPTION: Current workaround solution using helper function to handle command synonyms

LANGUAGE: scala
CODE:
def loop(cmd: Cmd): Unit =
  def pickUp(item: String): Unit = // Code for picking up item
    cmd match
      case Command(Pick :: Up :: Item(name)) => pickUp(name)
      case Command(Get :: Item(name)) => pickUp(name)

----------------------------------------

TITLE: Demonstrating Collection Migration Warnings in Scala REPL
DESCRIPTION: Example REPL session showing deprecation and migration warnings when using old collection methods. Demonstrates the transition from List.unzip to xs.unzip syntax and changes in Map.keys return type.

LANGUAGE: scala
CODE:
>scala -deprecation -Xmigration
Welcome to Scala version 2.8.0.final
Type in expressions to have them evaluated.
Type :help for more information.
scala> val xs = List((1, 2), (3, 4))
xs: List[(Int, Int)] = List((1,2), (3,4))
scala> List.unzip(xs)
<console>:7: warning: method unzip in object List is deprecated: use xs.unzip instead of List.unzip(xs)
       List.unzip(xs)
            ^
res0: (List[Int], List[Int]) = (List(1, 3),List(2, 4))
scala> xs.unzip
res1: (List[Int], List[Int]) = (List(1, 3),List(2, 4))
scala> val m = xs.toMap
m: scala.collection.immutable.Map[Int,Int] = Map((1,2), (3,4))
scala> m.keys
<console>:8: warning: method keys in trait MapLike has changed semantics:
As of 2.8, keys returns Iterable[A] rather than Iterator[A].
       m.keys
         ^
res2: Iterable[Int] = Set(1, 3)

----------------------------------------

TITLE: Pattern Matching in Scala
DESCRIPTION: Shows different pattern matching techniques including case expressions, variable binding, and type matching.

LANGUAGE: scala
CODE:
(xs zip ys) map {
  case (x, y) => x * y
}

val v42 = 42
3 match {
  case `v42` => println("42")
  case _     => println("Not 42")
}

----------------------------------------

TITLE: Zagnieżdżanie pakietów w Scala
DESCRIPTION: Demonstruje bardziej zaawansowany sposób deklarowania pakietów z użyciem nawiasów klamrowych, co pozwala na zagnieżdżanie i lepszą kontrolę nad zakresem.

LANGUAGE: scala
CODE:
package users {
  package administrators {
    class NormalUser
  }
  package normalusers {
    class NormalUser
  }
}

----------------------------------------

TITLE: Configuring Scala 3 Module Dependency on Scala 2.13 Artifact in sbt
DESCRIPTION: This sbt configuration demonstrates how to set up a Scala 3 project (foo) that depends on a Scala 2.13 project (bar). It shows the scalaVersion settings for both projects.

LANGUAGE: scala
CODE:
// build.sbt (sbt 1.5 or higher)
lazy val foo = project.in(file("foo"))
  .settings(scalaVersion := "3.3.1")
  .dependsOn(bar)

lazy val bar = project.in(file("bar"))
  .settings(scalaVersion := "2.13.11")

----------------------------------------

TITLE: Improving Method Documentation Example
DESCRIPTION: Demonstrates how to rewrite method documentation to avoid subjective terms like 'easiest' while maintaining informative content.

LANGUAGE: markdown
CODE:
Original: The foobar method is the easiest way to get started with our library.
Improved: We show here how to use the foobar method to get started with our library.

----------------------------------------

TITLE: Pattern Matching with Option Results in Scala
DESCRIPTION: Example of handling Option results using pattern matching, demonstrating how to handle both successful and failed conversions explicitly.

LANGUAGE: scala
CODE:
makeInt(x) match
  case Some(i) => println(i)
  case None => println("That didn't work.")

----------------------------------------

TITLE: Creating Multiline Strings in Scala
DESCRIPTION: This example demonstrates how to create multiline strings in Scala using triple quotes, which allows for easy formatting of long text blocks.

LANGUAGE: scala
CODE:
val quote = """The essence of Scala:
               Fusion of functional and object-oriented
               programming in a typed setting."""

----------------------------------------

TITLE: Comparing Compiler Options Between Scala 2.13 and 3.x
DESCRIPTION: This compilation shows how various compiler options map between Scala 2.13 and Scala 3.3. Some options are directly supported, others have been renamed, and some are not yet available in Scala 3. The comparison covers options like -Vprint, -Wconf, and compiler plugin configurations.



----------------------------------------

TITLE: Override Method Return Type Inference in Scala
DESCRIPTION: Demonstrates how return type inference differs for override methods between Scala 2.13 and 3. In Scala 3, the return type is inferred from the parent method, while in Scala 2.13 it's inferred from the implementation.

LANGUAGE: scala
CODE:
class Foo

class RichFoo(foo: Foo) extends Foo {
  def show: String = ""
}

class Parent {
  def foo: Foo = new Foo
}

class Child extends Parent {
  override def foo = new RichFoo(super.foo)
}

----------------------------------------

TITLE: Rewriting to new control structures in Scala 3
DESCRIPTION: This snippet demonstrates the result of applying the -new-syntax -rewrite options to convert the code to use new control structures in Scala 3.

LANGUAGE: scala
CODE:
case class State(n: Int, minValue: Int, maxValue: Int) {
  
  def inc: State =
    if n == maxValue then
      this
    else
      this.copy(n = n + 1)
  
  def printAll: Unit = {
    println("Printing all")
    for
      i <- minValue to maxValue
      j <- 0 to n
    do println(i + j)
  }
}

----------------------------------------

TITLE: Implementing ParStringSplitter
DESCRIPTION: Implementation of a custom splitter for parallel string collection with methods for traversing and splitting the collection.

LANGUAGE: scala
CODE:
class ParStringSplitter(private var s: String, private var i: Int, private val ntl: Int)
extends SeqSplitter[Char] {
  final def hasNext = i < ntl
  final def next = {
    val r = s.charAt(i)
    i += 1
    r
  }
  def remaining = ntl - i
  def dup = new ParStringSplitter(s, i, ntl)
  def split = {
    val rem = remaining
    if (rem >= 2) psplit(rem / 2, rem - rem / 2)
    else Seq(this)
  }
}

----------------------------------------

TITLE: Generating Scaladoc Using Command Line Tool
DESCRIPTION: Using the scaladoc command-line utility to generate documentation. Shows basic usage and how to specify output directory using the -d option.

LANGUAGE: bash
CODE:
$ scaladoc src/main/scala/App.scala
model contains 1 documentable templates

LANGUAGE: bash
CODE:
$ scaladoc -d build/ src/main/scala/App.scala

----------------------------------------

TITLE: SIP-36 Metadata in YAML Format
DESCRIPTION: YAML frontmatter defining the metadata for SIP-36 proposal, including title, status and pull request reference.

LANGUAGE: yaml
CODE:
title: SIP-36 - Adding prefix types
status: withdrawn
pull-request-number: 35

----------------------------------------

TITLE: Trivial Conditionals in Scala
DESCRIPTION: Demonstrates the compact syntax for short if/else expressions in Scala, which can be used in place of the ternary operator from other languages.

LANGUAGE: scala
CODE:
val res = if (foo) bar else baz

----------------------------------------

TITLE: Adding OS-Lib Dependency in sbt
DESCRIPTION: This snippet demonstrates how to add a specific version of OS-Lib as a dependency in an sbt project. It uses the libraryDependencies setting to include OS-Lib version 0.11.3.

LANGUAGE: scala
CODE:
libraryDependencies += "com.lihaoyi" %% "os-lib" % "0.11.3"

----------------------------------------

TITLE: Using foldLeft with Multiple Parameter Lists in Scala
DESCRIPTION: Demonstration of using the foldLeft method to sum a list of numbers. The method is called with an initial value of 0 and a function that adds each element to the accumulated sum.

LANGUAGE: scala
CODE:
val numbers = List(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
val res = numbers.foldLeft(0)((m, n) => m + n)
println(res) // 55

----------------------------------------

TITLE: Using ModuleMirror to Access Singleton Object Instances in Scala
DESCRIPTION: Demonstrates how to use a ModuleMirror to access the instance of a singleton object.

LANGUAGE: scala
CODE:
scala> object C { def x = 2 }
defined module C

scala> val m = ru.runtimeMirror(getClass.getClassLoader)
m: scala.reflect.runtime.universe.Mirror = JavaMirror ...

scala> val objectC = ru.typeOf[C.type].termSymbol.asModule
objectC: scala.reflect.runtime.universe.ModuleSymbol = object C

scala> val mm = m.reflectModule(objectC)
mm: scala.reflect.runtime.universe.ModuleMirror = module mirror for C (bound to null)

scala> val obj = mm.instance
obj: Any = C$@1005ec04

----------------------------------------

TITLE: Class Parameter Solution for Val Initialization
DESCRIPTION: Solution using class parameters to avoid null values during initialization by passing values through constructors.

LANGUAGE: scala
CODE:
abstract class A(val x1: String, val x2: String = "mom") {
  println("A: " + x1 + ", " + x2)
}
class B(x1: String = "hello", x2: String = "mom") extends A(x1, x2) {
  println("B: " + x1 + ", " + x2)
}
class C(x2: String = "dad") extends B(x2 = x2) {
  println("C: " + x1 + ", " + x2)
}

----------------------------------------

TITLE: Breadth-First Search Using Concurrent Tries in Scala
DESCRIPTION: This code implements a breadth-first search algorithm using ParTrieMap for open and closed node lists. It demonstrates concurrent tries' ability to handle parallel modifications during traversal in a complex algorithm.

LANGUAGE: scala
CODE:
val length = 1000

// define the Node type
type Node = (Int, Int);
type Parent = (Int, Int);

// operations on the Node type
def up(n: Node) = (n._1, n._2 - 1);
def down(n: Node) = (n._1, n._2 + 1);
def left(n: Node) = (n._1 - 1, n._2);
def right(n: Node) = (n._1 + 1, n._2);

// create a map and a target
val target = (length / 2, length / 2);
val map = Array.tabulate(length, length)((x, y) => (x % 3) != 0 || (y % 3) != 0 || (x, y) == target)
def onMap(n: Node) = n._1 >= 0 && n._1 < length && n._2 >= 0 && n._2 < length

// open list - the nodefront
// closed list - nodes already processed
val open = ParTrieMap[Node, Parent]()
val closed = ParTrieMap[Node, Parent]()

// add a couple of starting positions
open((0, 0)) = null
open((length - 1, length - 1)) = null
open((0, length - 1)) = null
open((length - 1, 0)) = null

// greedy bfs path search
while (open.nonEmpty && !open.contains(target)) {
  for ((node, parent) <- open) {
    def expand(next: Node) {
      if (onMap(next) && map(next._1)(next._2) && !closed.contains(next) && !open.contains(next)) {
        open(next) = node
      }
    }
    expand(up(node))
    expand(down(node))
    expand(left(node))
    expand(right(node))
    closed(node) = parent
    open.remove(node)
  }
}

// print path
var pathnode = open(target)
while (closed.contains(pathnode)) {
  print(pathnode + "->")
  pathnode = closed(pathnode)
}
println()

----------------------------------------

TITLE: Converting Sequential List to Parallel Map Operation
DESCRIPTION: Demonstrates how to convert a sequential list to parallel and perform a map operation. Shows the basic syntax difference between sequential and parallel collection operations.

LANGUAGE: scala
CODE:
val list = (1 to 10000).toList
list.map(_ + 42)

list.par.map(_ + 42)

----------------------------------------

TITLE: Basic Value Class Definition in Scala
DESCRIPTION: Demonstrates the minimal implementation of a value class with a single public val parameter that serves as the underlying runtime representation.

LANGUAGE: scala
CODE:
class Wrapper(val underlying: Int) extends AnyVal

----------------------------------------

TITLE: Declaring BigInt and BigDecimal Variables in Scala
DESCRIPTION: This code demonstrates how to create BigInt and BigDecimal variables in Scala for handling very large numbers or precise decimal arithmetic.

LANGUAGE: scala
CODE:
var a = BigInt(1_234_567_890_987_654_321L)
var b = BigDecimal(123_456.789)

----------------------------------------

TITLE: Using ArrayBuffer in Scala
DESCRIPTION: Demonstrates creating and manipulating a mutable ArrayBuffer collection which efficiently handles appending elements.

LANGUAGE: scala
CODE:
val buf = scala.collection.mutable.ArrayBuffer.empty[Int]
buf += 1
buf += 10
buf.toArray

----------------------------------------

TITLE: Configuring Library Dependencies for Scala 3
DESCRIPTION: Examples of configuring library dependencies in sbt for Scala 3, including cross-version support for libraries that don't have native Scala 3 versions.

LANGUAGE: scala
CODE:
("com.lihaoyi" %% "os-lib" % "0.7.7").cross(CrossVersion.for3Use2_13)

LANGUAGE: scala
CODE:
("com.lihaoyi" %%% "os-lib" % "0.7.7").cross(CrossVersion.for3Use2_13)

----------------------------------------

TITLE: Implementing filter and map in IterableOps
DESCRIPTION: Shows how filter and map operations are implemented in the IterableOps trait.

LANGUAGE: scala
CODE:
trait IterableOps[+A, +CC[_], +C]:
  def filter(p: A => Boolean): C = …
  def map[B](f: A => B): CC[B] = …

----------------------------------------

TITLE: Symbol Literals Removal Example
DESCRIPTION: Demonstrates the deprecated symbol literal syntax in Scala 2 and its replacement in Scala 3 using Symbol() constructor.

LANGUAGE: scala
CODE:
val values: Map[Symbol, Int] = Map('abc -> 1)

val abc = values('abc)

----------------------------------------

TITLE: Implementacja konkretnej klasy ConcreteDirectedGraph w Scali
DESCRIPTION: ConcreteDirectedGraph to pełna implementacja DirectedGraph, która definiuje konkretne typy dla Edge i Node oraz implementuje metody fabrykujące newNode i newEdge.

LANGUAGE: scala
CODE:
class ConcreteDirectedGraph extends DirectedGraph {
  type Edge = EdgeImpl
  type Node = NodeImpl
  protected def newNode: Node = new NodeImpl
  protected def newEdge(f: Node, t: Node): Edge =
    new EdgeImpl(f, t)
}

----------------------------------------

TITLE: Defining Multiple Scala Traits with Behaviors
DESCRIPTION: This example shows how to create multiple traits with a mix of abstract and concrete method implementations.

LANGUAGE: scala
CODE:
trait Speaker {
    def speak(): String   //abstract
}

trait TailWagger {
    def startTail(): Unit = println("tail is wagging")
    def stopTail(): Unit = println("tail is stopped")
}

trait Runner {
    def startRunning(): Unit = println("I'm running")
    def stopRunning(): Unit = println("Stopped running")
}

----------------------------------------

TITLE: Creating Basic Tuples in Scala
DESCRIPTION: Demonstrates how to create a simple two-element tuple containing a String and an Int value.

LANGUAGE: scala
CODE:
val ingredient = ("Sugar", 25)

----------------------------------------

TITLE: Converting Sequential List to Parallel Map Operation
DESCRIPTION: Demonstrates how to convert a sequential list to parallel and perform a map operation. Shows the basic syntax difference between sequential and parallel collection operations.

LANGUAGE: scala
CODE:
val list = (1 to 10000).toList
list.map(_ + 42)

list.par.map(_ + 42)

----------------------------------------

TITLE: Workaround Solutions for Quote Escaping in Scala
DESCRIPTION: Various existing workaround methods for handling quotes in string interpolations before the proposal, including triple quotes and string splicing.

LANGUAGE: scala
CODE:
s"""A common question for Scala programmers is "How can I represent a literal " character in Scala interpolations?"""

//with a normal escape in a string in a block
s"A common question for Scala programmers is ${"\""}How can I represent a literal ${"\""} character in Scala interpolations?${"\""}"
//with a quote character as a block
s"A common question for Scala programmers is ${'"'}How can I represent a literal ${'"'} character in Scala interpolations?${'"'}"
//with an identifier referencing a string that contains a single quote
val quote = "\""
s"A common question for Scala programmers is ${q}How can I represent a literal $q character in Scala interpolations?$q"

----------------------------------------

TITLE: Using MethodMirror to Invoke Instance Methods in Scala
DESCRIPTION: Shows how to create and use a MethodMirror to reflectively invoke an instance method.

LANGUAGE: scala
CODE:
scala> val methodX = ru.typeOf[C].decl(ru.TermName("x")).asMethod
methodX: scala.reflect.runtime.universe.MethodSymbol = method x

scala> val mm = im.reflectMethod(methodX)
mm: scala.reflect.runtime.universe.MethodMirror = method mirror for C.x: scala.Int (bound to C@3442299e)

scala> mm()
res0: Any = 2

----------------------------------------

TITLE: Implementing Showable Instances for Int and String in Scala
DESCRIPTION: Shows how to create implicit Showable instances for Int and demonstrates the compilation error when trying to use show with a String without a corresponding instance.

LANGUAGE: scala
CODE:
implicit object IntShowable extends Showable[Int] {
  def show(x: Int) = x.toString
}
show(42) // "42"
show("42") // compilation error

----------------------------------------

TITLE: Typed Macro Definition and Implementation
DESCRIPTION: Shows the typed version of macro definition and implementation that forces compiler typechecking.

LANGUAGE: scala
CODE:
type Enum(symbol: Symbol*) = macro Macros.enum
object Macros {
  def enum(c: Context)(symbol: c.Expr[Symbol]*): c.Tree = ...
}

----------------------------------------

TITLE: Demonstrating Scala 3 Version Properties
DESCRIPTION: Code example showing how to check Scala version numbers in Scala 3, illustrating that Scala 3 uses the Scala 2.13 library internally.

LANGUAGE: scala
CODE:
Welcome to Scala 3.3.4 (17.0.3, Java OpenJDK 64-Bit Server VM).
Type in expressions for evaluation. Or try :help.

scala> util.Properties.versionNumberString
val res0: String = 2.13.15

----------------------------------------

TITLE: Fixed Pattern Matching Solution
DESCRIPTION: Solution to fix pattern matching unsoundness by using bounded type parameters to establish a common ancestor type.

LANGUAGE: scala
CODE:
def combineFetch[A](x: Fetch[_ <: A], y: Fetch[_ <: A]): Fetch[A] = Fetch(x.ids ++ y.ids)

----------------------------------------

TITLE: Shared Location Class for Scala 2 and 3
DESCRIPTION: This code defines the Location case class that is shared between Scala 2 and Scala 3 implementations. It's placed in the common source directory.

LANGUAGE: scala
CODE:
package location

case class Location(path: String, line: Int)

----------------------------------------

TITLE: Lokalne importy w funkcji Scala
DESCRIPTION: Demonstruje możliwość umieszczenia importu wewnątrz funkcji, co jest cechą charakterystyczną dla Scala, odróżniającą ją od Javy.

LANGUAGE: scala
CODE:
def sqrtplus1(x: Int) = {
  import scala.math.sqrt
  sqrt(x) + 1.0
}

----------------------------------------

TITLE: Using Different Quasiquote Interpolators in Scala
DESCRIPTION: Demonstrates the use of different quasiquote interpolators (q, tq, pq) for expressions, types, and patterns in Scala. Each interpolator is specialized for a specific syntactic context.

LANGUAGE: scala
CODE:
val x = q"""
  val x: List[Int] = List(1, 2) match {
    case List(a, b) => List(a + b)
  }
"""

----------------------------------------

TITLE: Demonstrating Type Inference Limitation with Recursive Methods in Scala
DESCRIPTION: This snippet shows a case where Scala's type inference fails for recursive methods. The compiler cannot infer the return type of the 'fac' method due to its recursive nature.

LANGUAGE: scala
CODE:
def fac(n: Int) = if (n == 0) 1 else n * fac(n - 1)

LANGUAGE: scala
CODE:
def fac(n: Int) = if n == 0 then 1 else n * fac(n - 1)

----------------------------------------

TITLE: Configuring Scala 3 Module Dependency on Published Scala 2.13 Library in sbt
DESCRIPTION: This sbt configuration shows how to set up a Scala 3 project (foo) that depends on a published Scala 2.13 library (bar). It uses CrossVersion.for3Use2_13 to resolve the correct artifact.

LANGUAGE: scala
CODE:
lazy val foo = project.in(file("foo"))
  .settings(
    scalaVersion := "3.3.1",
    libraryDependencies += ("org.bar" %% "bar" % "1.0.0").cross(CrossVersion.for3Use2_13)
  )

----------------------------------------

TITLE: Using ValueOf type class
DESCRIPTION: Examples of using the ValueOf type class to obtain the unique value of types with a single inhabitant.

LANGUAGE: Scala
CODE:
def foo[T](implicit v: ValueOf[T]): T = v.value
foo[13]                            // result is 13: Int

def valueOf[T](implicit vt: ValueOf[T]): T = vt.value

object Foo
valueOf[Foo.type]       // result is Foo: Foo.type

valueOf[23]             // result is 23: Int

----------------------------------------

TITLE: Using apply Method for Collection Creation in Scala
DESCRIPTION: Shows how the parentheses syntax for collection creation is actually a call to the apply method of the collection's companion object.

LANGUAGE: scala
CODE:
List.apply(1.0, 2.0)

----------------------------------------

TITLE: Boilerplate Example for Showable Instances in Scala
DESCRIPTION: Illustrates the boilerplate problem with type classes by showing similar implementations for two different classes C and D.

LANGUAGE: scala
CODE:
class C(x: Int)
implicit def cShowable = new Showable[C] {
  def show(c: C) = "C(" + c.x + ")"
}

class D(x: Int)
implicit def dShowable = new Showable[D] {
  def show(d: D) = "D(" + d.x + ")"
}

----------------------------------------

TITLE: Cross-Universe Liftable Implementation
DESCRIPTION: Demonstrates how to share Liftable implementations between macro and runtime universes.

LANGUAGE: scala
CODE:
import scala.reflect.api.Universe
import scala.reflect.macros.blackbox.Context

trait LiftableImpls {
  val universe: Universe
  import universe._

  implicit val liftPoint = Liftable[points.Point] { p =>
    q"_root_.points.Point(${p.x}, ${p.y})"
  }
}

object RuntimeLiftableImpls extends LiftableImpls {
  val universe: universe.type = universe
}

trait MacroLiftableImpls extends LiftableImpls {
  val c: Context
  val universe: c.universe.type = c.universe
}

----------------------------------------

TITLE: Java Annotation Definition Example
DESCRIPTION: Shows how to define a custom annotation in Java with multiple elements.

LANGUAGE: java
CODE:
@interface Source {
  public String url();
  public String mail();
}

----------------------------------------

TITLE: Value Eta-expansion Example
DESCRIPTION: Shows the deprecated value eta-expansion syntax and its replacement using explicit function syntax.

LANGUAGE: scala
CODE:
val x = 1
val f: () => Int = x _

----------------------------------------

TITLE: MacroImplementations Fix
DESCRIPTION: Git diff showing the fix for string interpolator token handling

LANGUAGE: diff
CODE:
diff --git a/src/compiler/scala/tools/reflect/MacroImplementations.scala b/src/compiler/scala/tools/
index 002a3fce82..4e8f02084d 100644
--- a/src/compiler/scala/tools/reflect/MacroImplementations.scala
+++ b/src/compiler/scala/tools/reflect/MacroImplementations.scala
@@ -117,7 +117,8 @@ abstract class MacroImplementations {
       if (!strIsEmpty) {
         val len = str.length
         while (idx < len) {
-          if (str(idx) == '%') {
+          def notPercentN = str(idx) != '%' || (idx + 1 < len && str(idx + 1) != 'n')
+          if (str(idx) == '%' && notPercentN) {
             bldr append (str substring (start, idx)) append "%%"
             start = idx + 1
           }

----------------------------------------

TITLE: Parsing JSON Response with STTP in Scala 2
DESCRIPTION: Shows how to parse JSON responses from HTTP requests using STTP client and uJson in Scala 2. The example retrieves and parses user data from GitHub's API using a GET request.

LANGUAGE: scala
CODE:
import sttp.client4.quick._

val response = quickRequest
  .get(uri"https://api.github.com/user")
  .auth.bearer(sys.env("GITHUB_TOKEN"))
  .send()

val json = ujson.read(response.body)

println(json("login").str)
// prints your login

----------------------------------------

TITLE: Implementing Algebraic Data Types with Scala 3 Enums
DESCRIPTION: Shows how to use Scala 3 enums to define algebraic data types for representing expression trees.

LANGUAGE: scala
CODE:
enum Tree:
  case Sum(left: Tree, right: Tree)
  case Var(n: String)
  case Const(v: Int)

----------------------------------------

TITLE: Configuring Scala3 Scaladoc Blog Settings
DESCRIPTION: This YAML snippet shows how to configure blog settings in Scala3 Scaladoc using a 'blog.yml' file. It demonstrates changing the input and output directories and hiding the blog.

LANGUAGE: yaml
CODE:
input: my_posts
output: my_docs
hidden: true

----------------------------------------

TITLE: Defining an Ord Trait for Comparable Objects in Scala
DESCRIPTION: A trait definition in Scala that provides a basis for comparable objects, similar to Java's Comparable interface but with default implementations.

LANGUAGE: scala
CODE:
trait Ord {
  def < (that: Any): Boolean
  def <=(that: Any): Boolean =  (this < that) || (this == that)
  def > (that: Any): Boolean = !(this <= that)
  def >=(that: Any): Boolean = !(this < that)
}

----------------------------------------

TITLE: Scala CLI Shebang Script Example
DESCRIPTION: Example showing how to create a Unix shebang script using Scala CLI

LANGUAGE: shell
CODE:
#!/usr/bin/env -S scala-cli shebang --scala-version 2.13
println("Hello, world)

----------------------------------------

TITLE: Installing Jekyll Dependencies
DESCRIPTION: Basic commands to install dependencies and start the Jekyll server for local development.

LANGUAGE: bash
CODE:
bundle install
bundle exec jekyll serve -I

----------------------------------------

TITLE: Defining Basic Implicit Class in Scala
DESCRIPTION: Demonstrates the basic syntax for defining an implicit class RichInt that extends Int with additional functionality. The class must have exactly one argument in its primary constructor.

LANGUAGE: scala
CODE:
implicit class RichInt(n: Int) extends Ordered[Int] {
  def min(m: Int): Int = if (n <= m) n else m
  ...
}

----------------------------------------

TITLE: Accessor and Mutator Methods in Scala
DESCRIPTION: Illustrates proper naming conventions for accessor and mutator methods, including boolean properties.

LANGUAGE: scala
CODE:
class Company {
  private var _name: String = _

  def name = _name

  def name_=(name: String) {
    _name = name
  }
}

----------------------------------------

TITLE: Using Reduce Method in Scala Collections
DESCRIPTION: This snippet demonstrates how to use the reduce method to sum or multiply elements in a list.

LANGUAGE: scala
CODE:
def add(x: Int, y: Int): Int =
  val theSum = x + y
  println(s"received $x and $y, their sum is $theSum")
  theSum

val a = List(1,2,3,4)

scala> a.reduce(add)
received 1 and 2, their sum is 3
received 3 and 3, their sum is 6
received 6 and 4, their sum is 10
res0: Int = 10

scala> a.reduce(_ + _)
res0: Int = 10

scala> a.reduce(_ * _)
res1: Int = 24

----------------------------------------

TITLE: Configuring Maven Assembly Plugin for Executable JAR
DESCRIPTION: This XML snippet shows how to configure the Maven Assembly Plugin in the pom.xml file. It creates an executable JAR with dependencies and specifies the main class in the manifest.

LANGUAGE: xml
CODE:
<project ...>
    <modelVersion>X.X.X</modelVersion>
    ...
    <licenses>
        ...
    </licenses>

    <properties>
        ...
    </properties>

    <dependencies>
        ...
    </dependencies>

    <build>
        ...
        <plugins>
            ...
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-assembly-plugin</artifactId>
                <version>2.4</version>
                <configuration>
                    <descriptorRefs>
                        <descriptorRef>jar-with-dependencies</descriptorRef>
                    </descriptorRefs>
                    <archive>
                        <manifest>
                            <mainClass>com.your-package.MainClass</mainClass>
                        </manifest>
                    </archive>
                </configuration>
                <executions>
                    <execution>
                        <phase>package</phase>
                        <goals>
                            <goal>single</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
        </plugins>
    </build>
</project>

----------------------------------------

TITLE: Enabling Member Grouping Tags in SBT for Scaladoc
DESCRIPTION: Shows how to enable member grouping tags in Scaladoc using SBT build configuration.

LANGUAGE: scala
CODE:
scalacOptions in (Compile, doc) ++= Seq(
  "-groups"
)

----------------------------------------

TITLE: Static Resources Serving with Cask (Scala 3)
DESCRIPTION: Simplified example using @cask.staticResources annotation to serve files from resources directory in Scala 3

LANGUAGE: scala
CODE:
object Example extends cask.MainRoutes:
  @cask.staticResources("/static")
  def staticEndpoint(): String = "."

  initialize()

----------------------------------------

TITLE: Defining SeqLike Trait in Scala
DESCRIPTION: Definition of the SeqLike trait that abstracts over collection representation types, allowing for flexible implementation of sequence operations.

LANGUAGE: scala
CODE:
trait SeqLike[+Elem, +Repr] { ... }

----------------------------------------

TITLE: Using Anonymous Functions in Scala
DESCRIPTION: A variation of the timer program using an anonymous function instead of a named function for the callback.

LANGUAGE: scala
CODE:
object TemporizadorAnonimo {
  def unaVezPorSegundo(callback: () => Unit) {
    while (true) {
      callback();
      Thread sleep 1000
    }
  }
  def main(args: Array[String]): Unit = {
    unaVezPorSegundo(
        () => println("El tiempo vuela como una flecha...")
    )
  }
}

----------------------------------------

TITLE: Defining Word Enum and Command Class in Scala
DESCRIPTION: Basic enum definition for Word types and Command class used in text adventure game example

LANGUAGE: scala
CODE:
enum Word
  case Get, North, Go, Pick, Up
  case Item(name: String)

  case class Command(words: List[Word])

----------------------------------------

TITLE: Cheatsheet Template
DESCRIPTION: Template for creating documentation cheatsheets with special layout and markdown tables.

LANGUAGE: markdown
CODE:
---
layout: cheatsheet
title: YOUR TITLE
by: YOUR NAME
about: SOME TEXT ABOUT THE CHEAT SHEET.
---
| Title A | Title B |
|---------|----------|
| content | more    |

----------------------------------------

TITLE: Writing Comments in Scala
DESCRIPTION: Demonstrates the three common ways to write comments in Scala code, including single-line and multi-line comment syntax. These commenting styles are similar to Java and other C-style languages.

LANGUAGE: scala
CODE:
// a single line comment

/*
 * a multiline comment
 */

/**
 * also a multiline comment
 */

----------------------------------------

TITLE: Class Declaration Patterns in Scala
DESCRIPTION: Demonstrates proper formatting for class declarations with constructor arguments, including line length considerations and trailing commas usage.

LANGUAGE: scala
CODE:
class Person(name: String, age: Int) {
  …
}

class Person(
  name: String,
  age: Int,
  birthdate: Date,
  astrologicalSign: String,
  shoeSize: Int,
  favoriteColor: java.awt.Color,
) {
  def firstMethod: Foo = …
}

----------------------------------------

TITLE: Variable Declaration Comparison
DESCRIPTION: Demonstrates how variables are declared in JavaScript and Scala

LANGUAGE: javascript
CODE:
let  // now preferred for mutable
var  // old mutable style

LANGUAGE: scala
CODE:
var  // used for mutable variables

----------------------------------------

TITLE: Defining and Using Traits in Scala
DESCRIPTION: Shows how to define and implement traits in Scala, using the Ord trait as an example for comparable objects.

LANGUAGE: scala
CODE:
trait Ord:
  def < (that: Any): Boolean
  def <=(that: Any): Boolean =  (this < that) || (this == that)
  def > (that: Any): Boolean = !(this <= that)
  def >=(that: Any): Boolean = !(this < that)

----------------------------------------

TITLE: Scala 2 Specific Macro Implementation
DESCRIPTION: Scala 2.13 specific implementation using quasiquotes, designed to be placed in a separate compatibility module.

LANGUAGE: scala
CODE:
package location

import scala.reflect.macros.blackbox.Context
import scala.language.experimental.macros

case class Location(path: String, line: Int)

object Scala2MacrosCompat {
  private[location] def locationImpl(c: Context): c.Tree =  {
    import c.universe._
    val location = typeOf[Location]
    val line = Literal(Constant(c.enclosingPosition.line))
    val path = Literal(Constant(c.enclosingPosition.source.path))
    q"new $location($path, $line)"
  }
}

----------------------------------------

TITLE: Creating Custom Decorators for Authentication in Cask (Scala)
DESCRIPTION: This snippet shows how to create and use a custom decorator in Cask for authentication purposes. The 'loggedIn' decorator checks if a valid session cookie exists before allowing access to the decorated endpoint. It also demonstrates passing additional arguments to the decorated function.

LANGUAGE: scala
CODE:
class loggedIn extends cask.RawDecorator {
  override def wrapFunction(ctx: cask.Request, delegate: Delegate): Result[Raw] = {
    ctx.cookies.get("sessionId") match {
      case Some(cookie) if sessionIds.contains(cookie.value) => delegate(Map("sessionId" -> cookie.value))
      case _ => cask.router.Result.Success(cask.model.Response("You aren't logged in", 403))
    }
  }
}

@loggedIn()
@cask.get("/decorated")
def decorated()(sessionId: String): String = {
  s"You are logged in with id: $sessionId"
}

----------------------------------------

TITLE: Unsound Pattern Matching Example in Scala 2
DESCRIPTION: Example showing unsound pattern matching in Scala 2 where type parameters are not properly checked for equality.

LANGUAGE: scala
CODE:
trait Request
case class Fetch[A](ids: Set[A]) extends Request

object Request {
  def combineFetch[A](x: Fetch[A], y: Fetch[A]): Fetch[A] = Fetch(x.ids ++ y.ids)

  def combineReq(x: Request, y: Request): Request = {
    (x, y) match {
      case (x @ Fetch(_), y @ Fetch(_)) => combineFetch(x, y)
    }
  }
}

----------------------------------------

TITLE: For Comprehension Without Yield
DESCRIPTION: Demonstrates using for comprehension without yield statement, returning Unit and producing side effects through println.

LANGUAGE: scala
CODE:
def foo(n: Int, v: Int) =
   for (i <- 0 until n;
        j <- 0 until n if i + j == v)
   println(s"($i, $j)")

foo(10, 10)

----------------------------------------

TITLE: Embedding Google Document in HTML for SIP-17 Content
DESCRIPTION: HTML code for embedding a Google Document containing the full SIP-17 proposal. It includes an iframe with the document source and styling attributes for proper display within the webpage.

LANGUAGE: html
CODE:
<iframe
  src="https://docs.google.com/document/d/1XaNgZ06AR7bXJA9-jHrAiBVUwqReqG4-av6beoLaf3U/preview?"
  style="width:572px;height:800px;"> </iframe>

----------------------------------------

TITLE: Demonstrating Incorrect 4-Space Indentation in Scala
DESCRIPTION: This snippet shows an incorrect indentation style using 4 spaces, which is not recommended in Scala.

LANGUAGE: scala
CODE:
// wrong!
class Foo {
    def fourspaces = {
        val x = 4
        ..
    }
}

----------------------------------------

TITLE: Configuring Advanced Snippet Compilation Settings
DESCRIPTION: This snippet demonstrates how to configure advanced snippet compilation settings using path-based flags and multiple settings.

LANGUAGE: scala
CODE:
-snippet-compiler:docs=compile,library/src=compile,library/src/scala/quoted=nocompile,library/src/scala/compiletime=fail

----------------------------------------

TITLE: Abstract Method Unrolling Example
DESCRIPTION: Demonstrates how @unroll works with abstract methods in traits and their implementations

LANGUAGE: scala
CODE:
trait Unrolled{
  def foo(s: String, n: Int = 1, @unroll b: Boolean = true, @unroll l: Long = 0): String = foo(s, n, b)
  def foo(s: String, n: Int, b: Boolean): String = foo(s, n)
  def foo(s: String, n: Int): String
}

object UnrolledObj extends Unrolled{
  def foo(s: String, n: Int = 1, @unroll b: Boolean = true, @unroll l: Long = 0) = s + n + b + l
  def foo(s: String, n: Int, b: Boolean) = foo(s, n, b, 0)
  def foo(s: String, n: Int) = foo(s, n, true)
}

----------------------------------------

TITLE: Code Style Implementation
DESCRIPTION: JavaScript function to apply syntax highlighting styles to code blocks. Adds prettyprint classes for Scala code highlighting.

LANGUAGE: javascript
CODE:
function styleCode() {
  if (typeof disableStyleCode != "undefined") {
    return;
  }
  var a = false;
  $("pre code").parent().each(function() {
    if (!$(this).hasClass("prettyprint")) {
      $(this).addClass("prettyprint lang-scala linenums");
      a = true
    }
  });
  if (a) { prettyPrint() }
}

----------------------------------------

TITLE: Package Naming Convention for Organizations
DESCRIPTION: Illustrates the recommended package naming convention for projects developed within organizations with a website.

LANGUAGE: scala
CODE:
package com.google.selfdrivingcar.camera

class Lens

----------------------------------------

TITLE: Defining a Complex Number Class in Scala
DESCRIPTION: An example of a Scala class definition for complex numbers, demonstrating class parameters and methods without arguments.

LANGUAGE: scala
CODE:
class Complejo(real: Double, imaginaria: Double) {
  def re = real
  def im = imaginaria
  override def toString() =
    "" + re + (if (im < 0) "" else "+") + im + "i"
}

----------------------------------------

TITLE: Viewing app logs on Android device
DESCRIPTION: Command to filter and display log output from the Scala Android app running on a connected device using adb logcat.

LANGUAGE: bash
CODE:
adb logcat | grep GraalCompiled

----------------------------------------

TITLE: Running Tests with SBT
DESCRIPTION: Command to run all tests in the 'example' project using SBT with sample output showing test execution results.

LANGUAGE: bash
CODE:
sbt:example> test
# MyTests:
#   + sum of two integers 0.006s
# [info] Passed: Total 1, Failed 0, Errors 0, Passed 1
# [success] Total time: 0 s, completed Nov 11, 2022 12:54:08 PM

----------------------------------------

TITLE: Creating and Accessing Tuples in Scala
DESCRIPTION: Demonstrates how to create a tuple with two elements (String and Int) and access its elements using underscore notation.

LANGUAGE: scala
CODE:
val ingredient = ("Sugar" , 25):Tuple2[String, Int]

println(ingredient._1) // Sugar

println(ingredient._2) // 25

----------------------------------------

TITLE: Initialization Order Example
DESCRIPTION: Demonstrates initialization order differences between static and non-static fields.

LANGUAGE: scala
CODE:
class C {
  val x = {println("x"); 1 }
}

object O extends C {
  val y = { println("y"); 2 }
}

object Os extends C {
  @static val y = { println("y"); 2 }
}

----------------------------------------

TITLE: Markdown Front Matter Configuration
DESCRIPTION: YAML front matter configuration for the SID-9 documentation page, defining metadata like layout, title, stage, status and permalink settings.

LANGUAGE: markdown
CODE:
---
layout: sip
title: SID-9 - Scala Specialization
stage: completed
status: shipped
permalink: /sips/:title.html
redirect_from: /sips/pending/scala-specialization.html
---

----------------------------------------

TITLE: Implementing Factorial Using Nested Methods - Scala 2
DESCRIPTION: Implementation of a factorial calculation using nested methods in Scala 2. The outer method 'factorial' contains an inner method 'fact' that uses tail recursion with an accumulator parameter for efficient computation.

LANGUAGE: scala
CODE:
def factorial(x: Int): Int = {
  def fact(x: Int, accumulator: Int): Int = {
    if (x <= 1) accumulator
    else fact(x - 1, x * accumulator)
  }  
  fact(x, 1)
}

println("Factorial of 2: " + factorial(2))
println("Factorial of 3: " + factorial(3))

----------------------------------------

TITLE: Handling Ambiguity with Named Arguments in Scala
DESCRIPTION: Demonstrates how to handle cases where a named argument could be interpreted as both a parameter name and a variable assignment.

LANGUAGE: scala
CODE:
def twice(op: => Unit) = { op; op }
var op = 1
// twice(op = op + 1) // error: reference to 'op' is ambiguous
twice((op = op + 1))  // assignment, not a named argument
twice({op = op + 1})  // assignment
twice{ op = op + 1 }  // assignment

----------------------------------------

TITLE: Demonstrating Incorrect Formatting of Long Method Invocations in Scala
DESCRIPTION: This snippet shows an incorrect way of formatting long method invocations, which can lead to readability issues and should be avoided.

LANGUAGE: scala
CODE:
// wrong!
val myLongFieldNameWithNoRealPoint = foo(someVeryLongFieldName,
                                             andAnotherVeryLongFieldName,
                                             "this is a string",
                                             3.1415)

----------------------------------------

TITLE: Basic Symbol Usage Example
DESCRIPTION: Example showing how to get method symbol from a class type

LANGUAGE: scala
CODE:
import scala.reflect.runtime.universe._
class C[T] { def test[U](x: T)(y: U): Int = ??? }
val testMember = typeOf[C[Int]].member(TermName("test"))
testMember.asMethod

----------------------------------------

TITLE: Summing Elements with Parallel fold in Scala
DESCRIPTION: Illustrates using a parallelized fold operation to sum the elements of a ParArray. Shows creation of a parallel array and application of the fold operation.

LANGUAGE: scala
CODE:
val parArray = (1 to 10000).toArray.par
parArray.fold(0)(_ + _)

----------------------------------------

TITLE: Checking GraalVM Java version
DESCRIPTION: Displays the installed Java version to verify GraalVM setup. The output should show the GraalVM version and build information.

LANGUAGE: bash
CODE:
> java -version
openjdk version "11.0.10" 2021-01-19
OpenJDK Runtime Environment GraalVM CE 21.0.0 (build 11.0.10+8-jvmci-21.0-b06)
OpenJDK 64-Bit Server VM GraalVM CE 21.0.0 (build 11.0.10+8-jvmci-21.0-b06, mixed mode, sharing)

----------------------------------------

TITLE: Streaming File Lines in Scala
DESCRIPTION: Shows how to efficiently stream file contents line by line using OS-Lib's read.lines.stream method, reading only the first line.

LANGUAGE: scala
CODE:
val lineStream: geny.Generator[String] = os.read.lines.stream(path)
val firstLine: String = lineStream.head
println(firstLine)
// prints: A

----------------------------------------

TITLE: Demonstrating Trailing Comma Usage in Scala Sequence
DESCRIPTION: This snippet shows how trailing commas can be used in a multi-line sequence definition in Scala, making it easier to add, remove, or reorder elements without syntax errors.

LANGUAGE: scala
CODE:
Seq(
  foo,
  bar,
  baz,
)

----------------------------------------

TITLE: Defining Scaladoc Page Layout in YAML
DESCRIPTION: YAML front matter configuration for a Scaladoc documentation page, specifying layout, title, navigation, and URL settings.

LANGUAGE: yaml
CODE:
---
layout: multipage-overview
title: Using the Scaladoc Interface
partof: scaladoc
overview-name: Scaladoc

num: 2

permalink: /overviews/scaladoc/:title.html
redirect_from:
  - /overviews/scaladoc/usage.html
---

----------------------------------------

TITLE: Adding Dependencies in sbt Build File
DESCRIPTION: Demonstrates how to add external library dependencies to a Scala project by modifying the build.sbt file. Shows the syntax for adding the scala-parser-combinators library.

LANGUAGE: scala
CODE:
libraryDependencies += "org.scala-lang.modules" %% "scala-parser-combinators" % "2.1.1"

----------------------------------------

TITLE: Showing Reordering Difficulty Without Trailing Commas in Scala
DESCRIPTION: This snippet illustrates the challenge of reordering elements in a sequence without trailing comma support, leading to a syntax error.

LANGUAGE: scala
CODE:
val xs = Seq(
  foo,
  baz
  bar,
)       // error: illegal start of simple expression

----------------------------------------

TITLE: Using literal types in Scala
DESCRIPTION: Examples of using literal types in various contexts like value declarations, parameter types, type arguments, and type parameter bounds.

LANGUAGE: Scala
CODE:
val one: 1 = 1
def foo(x: 1): Option[1] = Some(x)
def bar[T <: 1](t: T): T = t
foo(1: 1)

----------------------------------------

TITLE: Nested Type Variables in Scala Quote Patterns
DESCRIPTION: Shows how nested type variables are introduced and used in quote patterns without explicit declarations.

LANGUAGE: scala
CODE:
case '{ $x: t } => f[t](x: Expr[t])

----------------------------------------

TITLE: Benchmarking Parallel Map Operation on ParHashMap in Scala
DESCRIPTION: This snippet demonstrates benchmarking a parallel map operation on a ParHashMap. It includes both parallel and sequential versions for comparison, with configurable collection size and parallelism level.

LANGUAGE: scala
CODE:
import collection.parallel.mutable.ParHashMap

object Map extends testing.Benchmark {
  val length = sys.props("length").toInt
  val par = sys.props("par").toInt
  val phm = ParHashMap((0 until length) zip (0 until length): _*)

  phm.tasksupport = new collection.parallel.ForkJoinTaskSupport(new scala.concurrent.forkjoin.ForkJoinPool(par))

  def run = {
    phm map {
      kv => kv
    }
  }
}

object MapSeq extends testing.Benchmark {
  val length = sys.props("length").toInt
  val hm = collection.mutable.HashMap((0 until length) zip (0 until length): _*)

  def run = {
    hm map {
      kv => kv
    }
  }
}

----------------------------------------

TITLE: Updated Build Configuration Post-Migration
DESCRIPTION: Final build.sbt configuration after applying all migration changes including cross-version settings

LANGUAGE: scala
CODE:
lazy val main = project
  .in(file("."))
  .settings(
    scalaVersion := "2.13.11",
    libraryDependencies ++= Seq(
      "org.typelevel" %% "cats-core" % "2.6.1",
      "io.github.java-diff-utils" % "java-diff-utils" % "4.12",
      ("org.scalameta" %% "parsers" % "4.8.9").cross(CrossVersion.for3Use2_13),
      "org.scalameta" %% "munit" % "0.7.25" % Test
    ),
    libraryDependencies ++= {
      if (scalaVersion.value.startsWith("3.")) Seq.empty
      else Seq(
        compilerPlugin(("org.typelevel" %% "kind-projector" % "0.13.2").cross(CrossVersion.full))
      )
    },
    scalacOptions ++= {
      if (scalaVersion.value.startsWith("3.")) Seq("-Ykind-projector")
      else Seq.empty
    }
  )

----------------------------------------

TITLE: Enums in Python and Scala
DESCRIPTION: Demonstrates how to define and use enums in Python and Scala.

LANGUAGE: python
CODE:
from enum import Enum, auto
class Color(Enum):
    RED = auto()
    GREEN = auto()
    BLUE = auto()

Color.RED == Color.BLUE  # False

LANGUAGE: scala
CODE:
enum Color:
  case Red, Green, Blue

Color.Red == Color.Blue  // false

enum Color(val rgb: Int):
  case Red   extends Color(0xFF0000)
  case Green extends Color(0x00FF00)
  case Blue  extends Color(0x0000FF)

----------------------------------------

TITLE: Making Multi-part Requests with sttp in Scala
DESCRIPTION: This snippet shows how to make a multi-part request to upload multiple files simultaneously using sttp. It demonstrates creating multipart file bodies and sending them in a POST request.

LANGUAGE: scala
CODE:
import sttp.client4.quick._

val file1 = (os.pwd / "avatar1.png").toNIO
val file2 = (os.pwd / "avatar2.png").toNIO
val response = quickRequest
  .post(uri"https://example.com/")
  .multipartBody(
    multipartFile("avatar1.png", file1),
    multipartFile("avatar2.png", file2)
  )
  .send()

----------------------------------------

TITLE: Enums in Python and Scala
DESCRIPTION: Demonstrates how to define and use enums in Python and Scala.

LANGUAGE: python
CODE:
from enum import Enum, auto
class Color(Enum):
    RED = auto()
    GREEN = auto()
    BLUE = auto()

Color.RED == Color.BLUE  # False

LANGUAGE: scala
CODE:
enum Color:
  case Red, Green, Blue

Color.Red == Color.Blue  // false

enum Color(val rgb: Int):
  case Red   extends Color(0xFF0000)
  case Green extends Color(0x00FF00)
  case Blue  extends Color(0x0000FF)

----------------------------------------

TITLE: Jekyll Front Matter Configuration
DESCRIPTION: YAML front matter configuration for a Jekyll page defining the layout, title, and proposal details for the SIP meeting results.

LANGUAGE: yaml
CODE:
---
layout: sip-meeting-results
title: SIP Meeting Results - 20th October 2023
partof: results
proposals:
  - url: https://docs.scala-lang.org/sips/binary-api.html
    name: SIP-52 - Binary APIs
    result: accepted
---

----------------------------------------

TITLE: Google Analytics Implementation Script
DESCRIPTION: JavaScript code for implementing Google Analytics tracking with account ID UA-574683-5. Creates an async script tag to load the analytics code.

LANGUAGE: javascript
CODE:
var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-574683-5']);
_gaq.push(['_trackPageview']);

(function() {
  var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
  ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
  var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();

----------------------------------------

TITLE: Basic Markdown Documentation Template
DESCRIPTION: Basic template for single-page documentation using Jekyll front matter and markdown syntax.

LANGUAGE: markdown
CODE:
---
layout: singlepage-overview
title: My Awesome Title
---

## An h2 Header in Markdown

And a paragraph, with a [link](https://www.scala-lang.org).

----------------------------------------

TITLE: Context Bound for Type Member in Scala (Proposed Syntax)
DESCRIPTION: Proposed syntax for applying a context bound to a type member.

LANGUAGE: scala
CODE:
class Collection:
  type Element : Ord

----------------------------------------

TITLE: Template Definition in Scala Quasiquotes
DESCRIPTION: Shows template structure used in new expressions, classes, traits and objects. Includes early definitions, parents list, self type and body statements.

LANGUAGE: scala
CODE:
q"new { ..$earlydefns } with ..$parents { $self => ..$stats }"

----------------------------------------

TITLE: Defining a Hello World Object in Scala 2
DESCRIPTION: Creates a Scala object that extends App and prints 'Hello, World!' to the console. This is the entry point for a Scala 2 application.

LANGUAGE: scala
CODE:
object Hello extends App {
  println("Hello, World!")
}

----------------------------------------

TITLE: Aggregating Definitions in Scala 2 Package Object
DESCRIPTION: Shows how to combine multiple trait definitions into a package object using inheritance in Scala 2.

LANGUAGE: scala
CODE:
package gardening

// `fruits` instead inherits its members from its parents.
package object fruits extends FruitAliases with FruitHelpers

----------------------------------------

TITLE: Initial Build Configuration Example
DESCRIPTION: Example sbt build configuration before migration showing dependencies and compiler plugins

LANGUAGE: scala
CODE:
lazy val main = project
  .in(file("."))
  .settings(
    scalaVersion := "2.13.11",
    libraryDependencies ++= Seq(
      "org.typelevel" %% "cats-core" % "2.4.0",
      "io.github.java-diff-utils" % "java-diff-utils" % "4.12",
      "org.scalameta" %% "parsers" % "4.8.9",
      "org.scalameta" %% "munit" % "0.7.23" % Test,
      "com.softwaremill.scalamacrodebug" %% "macros" % "0.4.1" % Test
    ),
    addCompilerPlugin(("org.typelevel" %% "kind-projector" % "0.13.2").cross(CrossVersion.full)),
    addCompilerPlugin("com.olegpy" %% "better-monadic-for" % "0.3.1")
  )

----------------------------------------

TITLE: Control Structures in Python and Scala
DESCRIPTION: Compares control structures like if statements, loops, and match expressions in Python and Scala.

LANGUAGE: python
CODE:
if x == 1: print(x)

if x == 1:
  print("x is 1, as you can see:")
  print(x)

if x < 0:
  print("negative")
elif x == 0:
  print("zero")
else:
  print("positive")

for i in range(0,3):
  print(i)

for i in ints: print(i)

for i in ints:
  x = i * 2
  print(f"i = {i}, x = {x}")

match month:
  case 1:
    monthAsString = "January"
  case 2:
    monthAsString = "February"
  case _:
    monthAsString = "Other"

LANGUAGE: scala
CODE:
if x == 1 then println(x)

if x == 1 then
  println("x is 1, as you can see:")
  println(x)

if x < 0 then
  println("negative")
else if x == 0 then
  println("zero")
else
  println("positive")

for i <- 0 until 3 do println(i)

for i <- ints do println(i)

for
  i <- ints
do
  val x = i * 2
  println(s"i = $i, x = $x")

val monthAsString = month match
  case 1 => "January"
  case 2 => "February"
  _ => "Other"

----------------------------------------

TITLE: Defining SIP-26 Metadata in YAML
DESCRIPTION: YAML frontmatter defining the metadata for SIP-26 (Scala Improvement Proposal) for unsigned integers, including title, status and pull request reference.

LANGUAGE: yaml
CODE:
title: SIP-26 - Unsigned Integers
status: rejected
pull-request-number: 27

----------------------------------------

TITLE: Just-in-Time Compilation with Quasiquotes in Scala
DESCRIPTION: This snippet illustrates how to use the ToolBox API with quasiquotes to generate, compile, and run Scala code at runtime. It demonstrates the power of quasiquotes in dynamic code execution.

LANGUAGE: scala
CODE:
scala> val code = q"""println("compiled and run at runtime!")"""
scala> val compiledCode = toolbox.compile(code)
scala> val result = compiledCode()
compiled and run at runtime!
result: Any = ()

----------------------------------------

TITLE: Key-Value Store API Example
DESCRIPTION: Demonstrates a practical use case for interleaved parameter lists in a heterogeneous key-value store API.

LANGUAGE: scala
CODE:
trait Key:
  type Value

class Store:
  def get(key: Key): key.Value = …
  def put(key: Key)(value: => key.Value): Unit = …

----------------------------------------

TITLE: Defining a Method with Implicit Parameter in Scala
DESCRIPTION: Example of using multiple parameter lists to specify an implicit parameter. The execute method is defined with two parameter lists, the second one containing an implicit ExecutionContext.

LANGUAGE: scala
CODE:
def execute(arg: Int)(using ec: scala.concurrent.ExecutionContext) = ???

----------------------------------------

TITLE: Map Function Usage Examples
DESCRIPTION: Examples demonstrating the usage of the map function with different types.

LANGUAGE: scala
CODE:
def double(i : Int): Int = i * 2
map(double, List(1, 2, 3))            // List(2, 4, 6)

def strlen(s: String): Int = s.length
map(strlen, List("a", "bb", "ccc"))   // List(1, 2, 3)

----------------------------------------

TITLE: Using Package Definitions in Scala 3
DESCRIPTION: Example program showing how to import and use package-level definitions in Scala 3.

LANGUAGE: scala
CODE:
// in file printPlanted.scala
import gardening.fruits.*

@main def printPlanted(): Unit =
  for fruit <- planted do
    showFruit(fruit)

----------------------------------------

TITLE: Running Tests with Scala CLI
DESCRIPTION: Command to run all tests in the 'example' folder using Scala CLI with sample output showing a passing test.

LANGUAGE: bash
CODE:
scala-cli test example
# Compiling project (test, Scala 3.2.1, JVM)
# Compiled project (test, Scala 3.2.1, JVM)
# MyTests:
#  + sum of two integers 0.009s

----------------------------------------

TITLE: Markdown Front Matter Configuration for Scaladoc Overview
DESCRIPTION: YAML front matter configuration for a Jekyll-based documentation page about Scaladoc. Defines the page layout, title, navigation structure, and permalink.

LANGUAGE: markdown
CODE:
---
layout: multipage-overview
title: Overview
partof: scaladoc
overview-name: Scaladoc

num: 1

permalink: /overviews/scaladoc/:title.html
---

----------------------------------------

TITLE: Creating Variables in Python and Scala
DESCRIPTION: Demonstrates how to create variables of different types in Python and Scala, including integers, strings, lists, dictionaries/maps, sets, and tuples.

LANGUAGE: python
CODE:
x = 1
x = "Hi"
y = """foo
     bar
     baz"""

x = [1,2,3]

x = {
  "Toy Story": 8.3,
  "Forrest Gump": 8.8,
  "Cloud Atlas": 7.4
}

x = {1,2,3}

x = (11, "Eleven")

LANGUAGE: scala
CODE:
val x = 1
val x = "Hi"
val y = """foo
          bar
          baz"""

val x = List(1,2,3)

val x = Map(
  "Toy Story" -> 8.3,
  "Forrest Gump" -> 8.8,
  "Cloud Atlas" -> 7.4
)

val x = Set(1,2,3)

val x = (11, "Eleven")

----------------------------------------

TITLE: Block Indentation for Arguments in Scala
DESCRIPTION: Shows how opening braces must be properly indented when passing block arguments in Scala 3, following style guide recommendations.

LANGUAGE: scala
CODE:
test("my test")
{
  assert(1 == 1)
}

----------------------------------------

TITLE: Configuring Version Dictionary JSON Structure
DESCRIPTION: JSON configuration file that maps documentation version labels to their corresponding URLs. This file is referenced by all documentation versions to enable cross-version navigation.

LANGUAGE: json
CODE:
{
  "versions": {
    "3.0.x": "https://dotty.epfl.ch/3.0.x/docs/index.html",
    "Nightly": "https://dotty.epfl.ch/docs/index.html"
  }
}

----------------------------------------

TITLE: Compiling Byname Implicit Example
DESCRIPTION: Shows how the compiler desugars byname implicit arguments into val declarations

LANGUAGE: scala
CODE:
val foo: Foo = scala.Predef.implicitly[Foo](
  {
    object LazyDefns$1 {
      val rec$1: Foo = Foo.foo(rec$1)
                       //      ^^^^^
                       // recursive knot tied here
    }
    LazyDefns$1.rec$1
  }
)

----------------------------------------

TITLE: Using Multiple Extension Methods in the Same Scope in Scala
DESCRIPTION: Example demonstrating the current limitation of using extension methods with the same name from different sources in the same scope.

LANGUAGE: scala
CODE:
def app(): Unit =
  import PathExtensions.*
  import URIExtensions.*

  val projectDir = Paths.get(".") / "project"
  val rootURI = new URI("https://www.example.com/")
  val projectURI = rootURI / "project/"
  println(s"$projectDir -> $projectURI")
end app

----------------------------------------

TITLE: Implementing Logarithms with Opaque Types
DESCRIPTION: Modern implementation using Scala 3's opaque types for zero-cost abstraction.

LANGUAGE: scala
CODE:
object Logarithms:
  opaque type Logarithm = Double

  object Logarithm:
    def apply(d: Double): Logarithm = math.log(d)

  extension (x: Logarithm)
    def toDouble: Double = math.exp(x)
    def + (y: Logarithm): Logarithm = Logarithm(math.exp(x) + math.exp(y))
    def * (y: Logarithm): Logarithm = x + y

----------------------------------------

TITLE: Demonstrating Contextual Parameter Resolution Failure in Scala 3
DESCRIPTION: This snippet illustrates a case where contextual parameter resolution fails in Scala 3 due to the absence of a given instance of Comparator for Boolean type. It shows how Scala 3's contextual abstraction mechanism provides compile-time safety.

LANGUAGE: scala
CODE:
// does not compile:
println(max(false, true))
-- Error: ----------------------------------------------------------------------
1 |println(max(false, true))
  |                        ^
  |no given instance of type Comparator[Boolean] was found for parameter comparator of method max

----------------------------------------

TITLE: Creating Basic FunFixture for File Testing in Scala 3
DESCRIPTION: Shows how to implement a FunFixture for temporary file management using Scala 3 syntax. Includes setup and teardown operations for resource management.

LANGUAGE: scala
CODE:
class FileTests extends munit.FunSuite:
  val usingTempFile: FunFixture[os.Path] = FunFixture(
    setup = _ => os.temp(prefix = "file-tests"),
    teardown = tempFile => os.remove(tempFile)
  )
  usingTempFile.test("overwrite on file") { tempFile =>
    os.write.over(tempFile, "Hello, World!")
    val obtained = os.read(tempFile)
    assertEquals(obtained, "Hello, World!")
  }

----------------------------------------

TITLE: Defining a State class in Scala 2 style
DESCRIPTION: This snippet shows a Scala 2 style class definition with methods using traditional control structures and braces.

LANGUAGE: scala
CODE:
case class State(n: Int, minValue: Int, maxValue: Int) {
  
  def inc: State =
    if (n == maxValue)
      this
    else
      this.copy(n = n + 1)
  
  def printAll: Unit = {
    println("Printing all")
    for {
      i <- minValue to maxValue
      j <- 0 to n
    } println(i + j)
  }
}

----------------------------------------

TITLE: Pizza Case Class Definition
DESCRIPTION: Shows how to model a Pizza using a case class that combines the enum components

LANGUAGE: scala
CODE:
case class Pizza(
  crustSize: CrustSize,
  crustType: CrustType,
  toppings: Seq[Topping]
)

----------------------------------------

TITLE: Type Parameter Naming in Scala
DESCRIPTION: Shows the deprecated use of underscore as a type parameter name and the required change to use proper identifiers in Scala 3.

LANGUAGE: scala
CODE:
def foo[_: Foo]: Unit = ???

----------------------------------------

TITLE: Konwencja nazewnictwa pakietów w Scala
DESCRIPTION: Pokazuje zalecaną konwencję nazewnictwa pakietów dla projektów organizacyjnych, wykorzystującą domenę internetową.

LANGUAGE: scala
CODE:
package com.google.selfdrivingcar.camera

class Lens

----------------------------------------

TITLE: Alternative Pattern Matching for Commands in Scala
DESCRIPTION: Examples showing alternative pattern matching syntax for command synonyms

LANGUAGE: scala
CODE:
case Command(North :: Nil | Go :: North :: Nil) => // Code for going north

LANGUAGE: scala
CODE:
case Command(Pick :: Up :: Item(name) :: Nil) => // Code for picking up items

LANGUAGE: scala
CODE:
case Command(Pick :: Up :: Item(name) :: Nil | Get :: Item(name) :: Nil) => // Code for picking up items

----------------------------------------

TITLE: Factorial Calculation Output
DESCRIPTION: Example output showing the results of calculating factorials for numbers 2 and 3 using the nested method implementation.

LANGUAGE: text
CODE:
Factorial of 2: 2
Factorial of 3: 6

----------------------------------------

TITLE: Defining While Loops in Java and Scala
DESCRIPTION: Demonstrates how to define while loops in Java and Scala.

LANGUAGE: java
CODE:
while (i < 3) {
  System.out.println(i);
  i++;
}

LANGUAGE: scala
CODE:
while i < 3 do
  println(i)
  i += 1

----------------------------------------

TITLE: Demonstrating Eager Evaluation in Scala Stream
DESCRIPTION: This snippet shows how the current implementation eagerly evaluates the first element of a Stream, even when using right-associative operators.

LANGUAGE: scala
CODE:
def f(i: Int) = { println("Generating "+i); i }

f(1) #:: f(2) #:: f(3) #:: Stream.empty
Generating 1
res0: scala.collection.immutable.Stream[Int] = Stream(1, ?)

----------------------------------------

TITLE: Static File Serving with Cask (Scala 3)
DESCRIPTION: Example showing how to serve static files from a directory using @cask.staticFiles annotation in Scala 3

LANGUAGE: scala
CODE:
object Example extends cask.MainRoutes:
  @cask.staticFiles("/static")
  def staticEndpoint(): String = "src/main/resources" // or "resources" if not using SBT

  initialize()

----------------------------------------

TITLE: Scala Compiler Usage Command
DESCRIPTION: Demonstrates the basic command line usage of the Scala compiler (scalac) with key migration-related options including -explain, -rewrite, and -source version settings.

LANGUAGE: text
CODE:
$ scalac
Usage: scalac <options> <source files>
where possible standard options include:

...
-explain           Explain errors in more detail.
...
-rewrite           When used in conjunction with a `...-migration` source version, rewrites sources to migrate to new version.
...
-source            source version
                   Default: 3.0.
                   Choices: 3.0, future, 3.0-migration, future-migration.
...

----------------------------------------

TITLE: Defining Multi-Line Methods in Scala 3
DESCRIPTION: Shows how to define a method with multiple lines of code in the body using Scala 3 syntax.

LANGUAGE: scala
CODE:
def addThenDouble(a: Int, b: Int): Int =
  // imagine that this body requires multiple lines
  val sum = a + b
  sum * 2

----------------------------------------

TITLE: Unsound Variance Checks Example in Scala 2
DESCRIPTION: Example demonstrating unsound variance checks in Scala 2 that are no longer allowed in Scala 3. Shows problematic code with contravariant type A in covariant position and covariant type A in contravariant position.

LANGUAGE: scala
CODE:
class Foo[-A](x: List[A]) {
  def f[B](y: List[B] = x): Unit = ???
}

class Outer[+A](x: A) {
  class Inner(y: A)
}

----------------------------------------

TITLE: Demonstrating Binary Integer Literal Usage in Scala
DESCRIPTION: Examples of binary integer literals in Scala, including the use of separators for improved readability.

LANGUAGE: scala
CODE:
0b00101010 // integer value 42
0b_1110_1101_1011_0111 // using separators for readability

----------------------------------------

TITLE: Array Tabulation Method (Pre-2.8)
DESCRIPTION: Original implementation of array tabulation without ClassManifest requirement.

LANGUAGE: scala
CODE:
def tabulate[T](len: Int, f: Int => T) = {
    val xs = new Array[T](len)
    for (i <- 0 until len) xs(i) = f(i)
    xs
}

----------------------------------------

TITLE: Importing CollectionConverters in Scala 3
DESCRIPTION: This snippet demonstrates how to import the CollectionConverters object in Scala 3, using the new wildcard import syntax.

LANGUAGE: scala
CODE:
scala> import scala.jdk.CollectionConverters.*
import scala.jdk.CollectionConverters.*

----------------------------------------

TITLE: Handling Exceptions in Java and Scala
DESCRIPTION: Shows how Java uses checked exceptions while Scala prefers returning Option types for error handling.

LANGUAGE: java
CODE:
public int makeInt(String s)
throws NumberFormatException {
  // code here to convert a String to an int
}

LANGUAGE: scala
CODE:
def makeInt(s: String): Option[Int] =
  try
    Some(s.toInt)
  catch
    case e: NumberFormatException => None

----------------------------------------

TITLE: Named Tuple Pattern Matching Examples
DESCRIPTION: Examples showing different ways to pattern match on named tuples, including full and partial matching with different orderings.

LANGUAGE: scala
CODE:
Bob match
  case (name, age) => ...

Bob match
  case (name = x, age = y) => ...

Bob match
  case (age = x) => ...

Bob match
  case (age = x, name = y) => ...

----------------------------------------

TITLE: Scala 3 Extension Method Syntax
DESCRIPTION: Example showing new extension method syntax in Scala 3

LANGUAGE: scala
CODE:
extends (x: A) {

  def foo(y: A) = ...

}

----------------------------------------

TITLE: Complex Type Lambda Migration
DESCRIPTION: Examples of migrating complex type lambda expressions to cross-compatible syntax or Scala 3 native type lambdas.

LANGUAGE: scala
CODE:
type MyLambda[F[_], A] = EitherT[F, Int, A]
MyLambda

LANGUAGE: scala
CODE:
[F[_], A] =>> EitherT[F, Int, A]

----------------------------------------

TITLE: Importing and Using an Extension Method in Scala 3
DESCRIPTION: This snippet shows how to import an extension method from a package and use it on a Circle instance in Scala 3.

LANGUAGE: scala
CODE:
import lib.circumference

aCircle.circumference

----------------------------------------

TITLE: Importing and Using an Extension Method in Scala 3
DESCRIPTION: This snippet shows how to import an extension method from a package and use it on a Circle instance in Scala 3.

LANGUAGE: scala
CODE:
import lib.circumference

aCircle.circumference

----------------------------------------

TITLE: Fixed Variance Checks Solutions
DESCRIPTION: Solutions to fix variance check issues by either adding method overloads or using bounded type parameters.

LANGUAGE: scala
CODE:
class Foo[-A](x: List[A]) {
  def f[B](y: List[B]): Unit = ???
  def f(): Unit = f(x)
}

class Outer[+A](x: A) {
  class Inner[B >: A](y: B)
}

----------------------------------------

TITLE: Comparing Literal Pattern with Literal Expression in Scala Quasiquotes
DESCRIPTION: Demonstrates the equivalence of literal patterns to literal expressions at the AST level in Scala quasiquotes.

LANGUAGE: scala
CODE:
scala> val equivalent = pq"1" equalsStructure q"1"
equivalent: Boolean = true

----------------------------------------

TITLE: Accessing Tuple Elements in Scala 2
DESCRIPTION: Shows how to access tuple elements using position-based notation with _1, _2 syntax in Scala 2.

LANGUAGE: scala
CODE:
println(ingredient._1) // Sugar
println(ingredient._2) // 25

----------------------------------------

TITLE: Collection Transformation Examples in Scala
DESCRIPTION: Demonstrates the uniform return type principle where collection operations maintain the original collection type

LANGUAGE: scala
CODE:
scala> List(1, 2, 3) map (_ + 1)
res0: List[Int] = List(2, 3, 4)
scala> Set(1, 2, 3) map (_ * 2)
res0: Set[Int] = Set(2, 4, 6)

----------------------------------------

TITLE: Defining Auxiliary Constructors in Java and Scala
DESCRIPTION: Demonstrates how to define auxiliary constructors in Java and Scala classes.

LANGUAGE: java
CODE:
public class Person {
  public String firstName;
  public String lastName;
  public int age;

  // primary constructor
  public Person(
    String firstName,
    String lastName,
    int age
  ) {
    this.firstName = firstName;
    this.lastName = lastName;
    this.age = age;
  }

  // zero-arg constructor
  public Person() {
    this("", "", 0);
  }

  // one-arg constructor
  public Person(String firstName) {
    this(firstName, "", 0);
  }

  // two-arg constructor
  public Person(
    String firstName, 
    String lastName
  ) {
    this(firstName, lastName, 0);
  }

}

LANGUAGE: scala
CODE:
class Person (
  var firstName: String,
  var lastName: String,
  var age: Int
):
   // zero-arg auxiliary constructor
   def this() = this("", "", 0)

   // one-arg auxiliary constructor
   def this(firstName: String) = 
      this(firstName, "", 0)

   // two-arg auxiliary constructor
   def this(
      firstName: String,
      lastName: String
   ) = 
     this(firstName, lastName, 0)

end Person

----------------------------------------

TITLE: Match Type Pattern Abstract Syntax
DESCRIPTION: Defines the abstract syntax grammar for match type patterns, including type captures and applied patterns.

LANGUAGE: scala
CODE:
MatchTypePattern ::= TypeWithoutCapture
                   | MatchTypeAppliedPattern

TypeWithoutCapture ::= Type

MatchTypeAppliedPattern ::= TyconWithoutCapture '[' MatchTypeSubPattern { ',' MatchTypeSubPattern } ']'

TyconWithoutCapture ::= Type

MatchTypeSubPattern ::= TypeCapture
                      | TypeWithoutCapture
                      | MatchTypeAppliedPattern

TypeCapture ::= NamedTypeCapture
              | WildcardTypeCapture

----------------------------------------

TITLE: Jekyll Front Matter Configuration for SIP Meeting Results
DESCRIPTION: YAML front matter block that configures the Jekyll page layout and metadata for Scala Improvement Proposal meeting results. Specifies the layout type, page title, and indicates it is part of results with no active proposals.

LANGUAGE: yaml
CODE:
---
layout: sip-meeting-results
title: SIP Meeting Results - 21st July 2023
partof: results
proposals: []
---

----------------------------------------

TITLE: Reflective Type Usage in Scala
DESCRIPTION: Shows how reflective types are handled differently in Scala 3, requiring explicit type annotations where Scala 2 would infer them automatically. Demonstrates the usage of structural types with reflective calls.

LANGUAGE: scala
CODE:
import scala.language.reflectiveCalls

val foo = new {
  def bar: Unit = ???
}

----------------------------------------

TITLE: Creating a Scala Class with Constructor and Methods
DESCRIPTION: Defines a 'Point' class with constructor parameters, variables, and methods. It demonstrates how to create instance variables, define methods, and override the toString method.

LANGUAGE: scala
CODE:
class Point(var x: Int, var y: Int) {

  def move(dx: Int, dy: Int): Unit = {
    x = x + dx
    y = y + dy
  }

  override def toString: String =
    s"($x, $y)"
}

val point1 = new Point(2, 3)
point1.x  // 2
println(point1)  // wyświetla (2, 3)

----------------------------------------

TITLE: Code Style Formatting Function
DESCRIPTION: JavaScript function that applies prettify styling to code blocks, specifically for Scala code snippets with line numbers.

LANGUAGE: javascript
CODE:
function styleCode() {
  if (typeof disableStyleCode != "undefined") {
    return;
  }
  var a = false;
  $("pre code").parent().each(function() {
    if (!$(this).hasClass("prettyprint")) {
      $(this).addClass("prettyprint lang-scala linenums");
      a = true
    }
  });
  if (a) { prettyPrint() }
}

----------------------------------------

TITLE: Updating Mutable Sequences with Views in Scala
DESCRIPTION: Shows how to use views to create a window into a mutable sequence for selective updates.

LANGUAGE: scala
CODE:
val arr = (0 to 9).toArray
val subarr = arr.view.slice(3, 6)
def negate(xs: collection.mutable.Seq[Int]) =
  for (i <- 0 until xs.length) xs(i) = -xs(i)
negate(subarr)

----------------------------------------

TITLE: Defining Animal Hierarchy and PetContainer with Upper Type Bound in Scala
DESCRIPTION: This snippet defines an animal hierarchy and a PetContainer class with an upper type bound. It demonstrates how to create containers for different pet types and shows that attempting to create a container for a non-pet animal results in a compilation error.

LANGUAGE: scala
CODE:
abstract class Animal {
 def name: String
}

abstract class Pet extends Animal {}

class Cat extends Pet {
  override def name: String = "Cat"
}

class Dog extends Pet {
  override def name: String = "Dog"
}

class Lion extends Animal {
  override def name: String = "Lion"
}

class PetContainer[P <: Pet](p: P) {
  def pet: P = p
}

val dogContainer = new PetContainer[Dog](new Dog)
val catContainer = new PetContainer[Cat](new Cat)

----------------------------------------

TITLE: Demonstrating Auto Application Code Examples in Scala
DESCRIPTION: Code examples showing different ways of method application and the potential ambiguity that can arise with auto application feature.

LANGUAGE: scala
CODE:
f()()
f.apply().apply()
f().apply()

----------------------------------------

TITLE: Annotation Handling with Implicit Classes
DESCRIPTION: Examples of how annotations are handled with implicit classes, showing both default behavior and targeted annotations.

LANGUAGE: scala
CODE:
@bar
implicit class Foo(n: Int)

LANGUAGE: scala
CODE:
@bar implicit def Foo(n: Int): Foo = new Foo(n)
@bar class Foo(n:Int)

LANGUAGE: scala
CODE:
@(bar @genClass) implicit class Foo(n: Int)

LANGUAGE: scala
CODE:
implicit def Foo(n: Int): Foo = new Foo(n)
@bar class Foo(n: Int)

----------------------------------------

TITLE: Enhanced GetOrElse Implementation
DESCRIPTION: Shows how interleaved parameter lists enable a more elegant getOrElse implementation for the key-value store.

LANGUAGE: scala
CODE:
def getOrElse(key: Key)[V >: key.Value](default: => V): V = …

----------------------------------------

TITLE: Ambiguous Conversion Example
DESCRIPTION: Example showing ambiguous implicit conversion between Boolean and lazy Boolean that compiles in Scala 2 but not in Scala 3.

LANGUAGE: scala
CODE:
implicit def boolFoo(bool: Boolean): Foo = ???
implicit def lazyBoolFoo(lazyBool:  => Boolean): Foo = ???

true.foo()

----------------------------------------

TITLE: Demonstrating Non-Determinism with Side Effects in Scala Parallel Collections
DESCRIPTION: Illustrates how operations with side effects can lead to non-deterministic results when used with parallel collections. Shows multiple executions of a parallel foreach with mutable state.

LANGUAGE: scala
CODE:
var sum = 0
val list = (1 to 1000).toList.par
list.foreach(sum += _); sum

var sum = 0
list.foreach(sum += _); sum

var sum = 0
list.foreach(sum += _); sum

----------------------------------------

TITLE: Smooth Scroll Implementation
DESCRIPTION: jQuery code for implementing smooth scrolling to anchor links with highlighting effect on the target element.

LANGUAGE: javascript
CODE:
jQuery(document).ready(function($) {
  $(".scroll").click(function(event){
    event.preventDefault();
    $('html,body').animate({scrollTop:$(this.hash).offset().top}, 500);
    $('html,body').animate({scrollTop:$(this.hash).offset().top-=50}, 500);
    $(this.hash).effect("highlight", {color: "#FFCC85"}, 3000);
  });
});

----------------------------------------

TITLE: Markdown Page Frontmatter Configuration
DESCRIPTION: Jekyll page configuration frontmatter specifying the layout, title, stage status and URL configuration for the Scala Improvement Document about annotation internals.

LANGUAGE: markdown
CODE:
---
layout: sip
title: SID-5 - Internals of Scala Annotations
stage: completed
status: shipped
permalink: /sips/:title.html
redirect_from: /sips/pending/internals-of-scala-annotations.html
---

----------------------------------------

TITLE: Basic Number Pattern Matching in Scala
DESCRIPTION: Demonstrates basic regular expression usage to validate if a string contains a number. Uses the Regex class and pattern matching to check password requirements.

LANGUAGE: scala
CODE:
import scala.util.matching.Regex

val numberPattern: Regex = "[0-9]".r

numberPattern.findFirstMatchIn("awesomepassword") match {
  case Some(_) => println("Password OK")
  case None => println("Password must contain a number")
}

----------------------------------------

TITLE: Early Initializer Replacement
DESCRIPTION: Demonstrates the deprecated early initializer syntax and its replacement using trait parameters or intermediate classes.

LANGUAGE: scala
CODE:
trait Bar(name: String) {
  val size: Int = name.size
}

object Foo extends Bar("Foo")

----------------------------------------

TITLE: Using Duration in Scala
DESCRIPTION: Demonstrates various ways to create and use Duration objects for handling time in concurrent applications.

LANGUAGE: scala
CODE:
import scala.concurrent.duration._
import java.util.concurrent.TimeUnit._

// instantiation
val d1 = Duration(100, MILLISECONDS) // from Long and TimeUnit
val d2 = Duration(100, "millis") // from Long and String
val d3 = 100 millis // implicitly from Long, Int or Double
val d4 = Duration("1.2 µs") // from String

// pattern matching
val Duration(length, unit) = 5 millis

LANGUAGE: scala
CODE:
import scala.concurrent.duration.*
import java.util.concurrent.TimeUnit.*

// instantiation
val d1 = Duration(100, MILLISECONDS) // from Long and TimeUnit
val d2 = Duration(100, "millis") // from Long and String
val d3 = 100.millis // implicitly from Long, Int or Double
val d4 = Duration("1.2 µs") // from String

// pattern matching
val Duration(length, unit) = 5.millis

----------------------------------------

TITLE: Singleton type inference with Singleton bound
DESCRIPTION: Demonstrates how adding an upper bound of Singleton to a type parameter affects type inference, allowing singleton types to be inferred.

LANGUAGE: Scala
CODE:
type Id[A] = A
def wide[T](t: T): Id[T] = t
wide(23)                           // result is 23: Id[Int]
def narrow[T <: Singleton](t: T): Id[T] = t
narrow(23)                         // result is 23: Id[23]

----------------------------------------

TITLE: Using Extension Methods from Multiple Sources in Scala
DESCRIPTION: Example of using extension methods imported from multiple sources, which would work with this SIP but cause ambiguity without it.

LANGUAGE: scala
CODE:
import A.*
import B.*

val foo: Foo = ???
foo.meth() // works with this SIP; "ambiguous import" without it

// unchanged:
meth(foo)() // always ambiguous, just like
normalMeth(foo) // always ambiguous

----------------------------------------

TITLE: Configuring Scala 2.13 Module Dependency on Scala 3 Artifact in sbt
DESCRIPTION: This sbt configuration demonstrates how to set up a Scala 2.13 project (foo) that depends on a Scala 3 project (bar). It enables the TASTy reader with -Ytasty-reader option.

LANGUAGE: scala
CODE:
// build.sbt (sbt 1.5 or higher)
lazy val foo = project.in.file("foo")
  .settings(
    scalaVersion := "2.13.11",
    scalacOptions += "-Ytasty-reader"
  )
  .dependsOn(bar)

lazy val bar = project.in(file("bar"))
  .settings(scalaVersion := "3.3.1")

----------------------------------------

TITLE: Implementing a Trait in a Scala Class and Usage Example
DESCRIPTION: This snippet shows how to implement the 'Similarity' trait in a 'Point' class, and provides a usage example in an object that extends App. It demonstrates trait integration and method overriding.

LANGUAGE: scala
CODE:
class Point(xc: Int, yc: Int) extends Similarity {
  var x: Int = xc
  var y: Int = yc
  def isSimilar(obj: Any) =
    obj.isInstanceOf[Point] &&
    obj.asInstanceOf[Point].x == x
}
object TraitsTest extends App {
  val p1 = new Point(2, 3)
  val p2 = new Point(2, 4)
  val p3 = new Point(3, 3)
  println(p1.isNotSimilar(p2))
  println(p1.isNotSimilar(p3))
  println(p1.isNotSimilar(2))
}

----------------------------------------

TITLE: Implementing a Trait in a Scala Class and Usage Example
DESCRIPTION: This snippet shows how to implement the 'Similarity' trait in a 'Point' class, and provides a usage example in an object that extends App. It demonstrates trait integration and method overriding.

LANGUAGE: scala
CODE:
class Point(xc: Int, yc: Int) extends Similarity {
  var x: Int = xc
  var y: Int = yc
  def isSimilar(obj: Any) =
    obj.isInstanceOf[Point] &&
    obj.asInstanceOf[Point].x == x
}
object TraitsTest extends App {
  val p1 = new Point(2, 3)
  val p2 = new Point(2, 4)
  val p3 = new Point(3, 3)
  println(p1.isNotSimilar(p2))
  println(p1.isNotSimilar(p3))
  println(p1.isNotSimilar(2))
}

----------------------------------------

TITLE: Adding MUnit via Scala CLI Toolkit
DESCRIPTION: Shows how to add MUnit dependency using Scala CLI's toolkit feature. This approach makes the testing framework available in test files (those in test directory or with .test.scala extension).

LANGUAGE: scala
CODE:
//> using toolkit latest

----------------------------------------

TITLE: Current Desugaring of Binary Operators in Scala
DESCRIPTION: This code block describes the current specification for desugaring binary operators in Scala, which leads to the eagerness issue.

LANGUAGE: text
CODE:
A left-associative binary
operation `e1 op e2` is interpreted as `e1.op(e2)`. If `op` is
right-associative, the same operation is interpreted as
`{ val x=e1; e2.op(x) }`, where `x` is a fresh name.

----------------------------------------

TITLE: Using Path-Dependent Types with Graph Nodes
DESCRIPTION: Example demonstrating the creation and connection of nodes within the same graph instance. Shows how path-dependent types ensure type safety by explicitly declaring node types.

LANGUAGE: scala
CODE:
val graph1: Graph = new Graph
val node1: graph1.Node = graph1.newNode
val node2: graph1.Node = graph1.newNode
val node3: graph1.Node = graph1.newNode
node1.connectTo(node2)
node3.connectTo(node1)

----------------------------------------

TITLE: Removing Elements from a Mutable Set in Scala
DESCRIPTION: This snippet demonstrates how to remove elements from a mutable Set using methods like -=, --=, clear, and remove. It shows the behavior of these methods through REPL examples.

LANGUAGE: scala
CODE:
scala> val set = scala.collection.mutable.Set(1, 2, 3, 4, 5)
set: scala.collection.mutable.Set[Int] = Set(2, 1, 4, 3, 5)

// one element
scala> set -= 1
res0: scala.collection.mutable.Set[Int] = Set(2, 4, 3, 5)

// two or more elements (-= has a varargs field)
scala> set -= (2, 3)
res1: scala.collection.mutable.Set[Int] = Set(4, 5)

// multiple elements defined in another sequence
scala> set --= Array(4,5)
res2: scala.collection.mutable.Set[Int] = Set()

scala> val set = scala.collection.mutable.Set(1, 2, 3, 4, 5)
set: scala.collection.mutable.Set[Int] = Set(2, 1, 4, 3, 5)

// clear
scala> set.clear()

scala> set
res0: scala.collection.mutable.Set[Int] = Set()

// remove
scala> val set = scala.collection.mutable.Set(1, 2, 3, 4, 5)
set: scala.collection.mutable.Set[Int] = Set(2, 1, 4, 3, 5)

scala> set.remove(2)
res1: Boolean = true

scala> set
res2: scala.collection.mutable.Set[Int] = Set(1, 4, 3, 5)

scala> set.remove(40)
res3: Boolean = false

----------------------------------------

TITLE: Defining Splitter Trait in Scala
DESCRIPTION: Definition of the Splitter trait which extends Iterator to enable partitioning parallel collections into disjoint subsets. The split method divides the collection into smaller parts for parallel processing.

LANGUAGE: scala
CODE:
trait Splitter[T] extends Iterator[T] {
	def split: Seq[Splitter[T]]
}

----------------------------------------

TITLE: Demonstrating Long Literal Inference Issue in Scala REPL
DESCRIPTION: Shows how long integer literals without an explicit type annotation can fail to infer as Long in certain expressions.

LANGUAGE: scala
CODE:
scala> val x: Long = 10_000_000_000
val x: Long = 10000000000
scala> val x: Long = 10_000_000_000 + 1
1 |val x: Long = 10_000_000_000 + 1
  |              ^^^^^^^^^^^^^^
  |              number too large

----------------------------------------

TITLE: Explicit Type Variables in Scala Quote Patterns
DESCRIPTION: Demonstrates the usage of explicit type variable declarations in quote patterns with type variable names and bounds. Shows how type variables can be referenced with backticks.

LANGUAGE: scala
CODE:
case '{ type t; $x: `t` } => f[t](x: Expr[t])
case '{ type u; ($ls: List[`u`]).map($f: `u` => Int) } => g[u](ls: Expr[List[u]], f: Expr[u => Int])
case '{ type tail <: Tuple; $x: *:[Int, `tail`] } => h[tail](x: Expr[*:[Int, tail])

----------------------------------------

TITLE: Power Calculation Macro Implementation
DESCRIPTION: Complete implementation of a power calculation macro that evaluates expressions at compile-time.

LANGUAGE: scala
CODE:
def pow(x: Double, n: Int): Double =
  if n == 0 then 1 else x * pow(x, n - 1)

def powerCode(
  x: Expr[Double],
  n: Expr[Int]
)(using Quotes): Expr[Double] =
  val value: Double = pow(x.valueOrAbort, n.valueOrAbort)
  Expr(value)

----------------------------------------

TITLE: Option to Iterable Conversion Example
DESCRIPTION: Shows how Option implicitly converts to Iterable when using collection methods.

LANGUAGE: scala
CODE:
Some(42).drop(1)
// : Iterable[Int] = List()

----------------------------------------

TITLE: Curly Braces Usage in Scala Control Structures
DESCRIPTION: Illustrates when to omit or include curly braces in various control structures like if, while, for, and case statements.

LANGUAGE: scala
CODE:
val news = if (foo)
  goodNews()
else
  badNews()

if (foo) {
  println("foo was true")
}

news match {
  case "good" => println("Good news!")
  case "bad" => println("Bad news!")
}

----------------------------------------

TITLE: Defining Class Methods and Additional Fields in Scala 3
DESCRIPTION: Example of a class with methods and additional fields in Scala 3 syntax.

LANGUAGE: scala
CODE:
class Person(var firstName: String, var lastName: String):

  println("initialization begins")
  val fullName = firstName + " " + lastName

  // метод класса
  def printFullName: Unit =
    // обращение к полю `fullName`, определенному выше
    println(fullName)

  printFullName
  println("initialization ends")

----------------------------------------

TITLE: Basic Extractor Usage Example
DESCRIPTION: Shows how to use an extractor object for direct value extraction without pattern matching in a match expression.

LANGUAGE: scala
CODE:
val customer2ID = CustomerID("Nico")
val CustomerID(name) = customer2ID
println(name)  // prints Nico

----------------------------------------

TITLE: Regular Method vs Anonymous Function in Scala
DESCRIPTION: Shows how a regular method definition can be used instead of an anonymous function when passing to map.

LANGUAGE: scala
CODE:
def double(i: Int): Int = i * 2   //a method that doubles an Int
val doubles = nums.map(double)

----------------------------------------

TITLE: Implementando uma Lista Encadeada Covariante com Limitante Inferior em Scala
DESCRIPTION: Este snippet redefine a classe ListNode como covariante, utilizando um limitante inferior de tipo no método prepend para permitir a inserção de elementos de supertipos. Demonstra o uso prático de limitantes inferiores de tipos.

LANGUAGE: scala
CODE:
case class ListNode[+T](h: T, t: ListNode[T]) {
  def head: T = h
  def tail: ListNode[T] = t
  def prepend[U >: T](elem: U): ListNode[U] =
    ListNode(elem, this)
}

----------------------------------------

TITLE: Unrolled Case Class Example
DESCRIPTION: Shows how @unroll works with case classes, generating compatible constructors, apply and copy methods

LANGUAGE: scala
CODE:
case class Unrolled(s: String, n: Int = 1, @unroll b: Boolean = true, @unroll l: Long = 0L){
   def this(s: String, n: Int) = this(s, n, true, 0L)
   def this(s: String, n: Int, b: Boolean) = this(s, n, b, 0L)

   def copy(s: String, n: Int) = copy(s, n, this.b, this.l)
   def copy(s: String, n: Int, b: Boolean) = copy(s, n, b, this.l)
}

object Unrolled{
   def apply(s: String, n: Int) = apply(s, n, true, 0L)
   def apply(s: String, n: Int, b: Boolean) = apply(s, n, b, 0L)
}

----------------------------------------

TITLE: Basic Static Members Usage in Scala
DESCRIPTION: Demonstrates basic usage of @static annotation for declaring static fields and methods in a Scala object companion.

LANGUAGE: scala
CODE:
class Foo

object Foo {
  @static val x = 5
  @static def bar(y: Int): Int = x + y
}

println(Foo.x)
println(Foo.bar(12))

----------------------------------------

TITLE: Importing Quasiquotes in Scala 2.11 REPL
DESCRIPTION: Sets up the universe object and imports necessary symbols for using quasiquotes in the Scala 2.11 REPL.

LANGUAGE: scala
CODE:
val universe: scala.reflect.runtime.universe.type = scala.reflect.runtime.universe
import universe._

----------------------------------------

TITLE: Defining a Timer Function with Callback in Scala
DESCRIPTION: A Scala program demonstrating how to pass functions as values. It defines a timer function that executes a callback every second.

LANGUAGE: scala
CODE:
object Temporizador {
  def unaVezPorSegundo(callback: () => Unit) {
    while (true) {
      callback();
      Thread sleep 1000
    }
  }
  def tiempoVuela() {
    println("El tiempo vuela como una flecha...")
  }
  def main(args: Array[String]): Unit = {
    unaVezPorSegundo(tiempoVuela)
  }
}

----------------------------------------

TITLE: YAML Project Configuration
DESCRIPTION: YAML configuration defining Scala-related projects and their contribution details, including links to repositories, documentation, and issue trackers.

LANGUAGE: yaml
CODE:
title: IDE and Build Tool Contributions
num: 11

projects:
  - title: sbt
    description: The interactive build tool.
    icon: https://www.scala-sbt.org/assets/sbt-logo.svg
    link: https://github.com/sbt/sbt
    homeLink: https://www.scala-sbt.org/
    issuesLink: https://github.com/sbt/sbt#issues-and-pull-requests
    readmeLink: https://github.com/sbt/sbt/blob/0.13/README.md
    contributingLink: https://github.com/sbt/sbt/blob/0.13/CONTRIBUTING.md

----------------------------------------

TITLE: Handling Non-Public References in Inline Methods with Binary APIs in Scala
DESCRIPTION: Shows how non-public references in inline methods are handled with @publicInBinary annotations, including automatic accessor generation for non-annotated private members.

LANGUAGE: scala
CODE:
import scala.annotation.publicInBinary
class C {
  @publicInBinary private[C] def a: Int = ...
  private[C] def b: Int = ...
  @publicInBinary protected def c: Int = ...
  protected def d: Int = ...
  inline def foo: Int = a + b + c + d
}

LANGUAGE: scala
CODE:
class C {
  @publicInBinary private[C] def a: Int = ...
  private[C] def b: Int = ...
  @publicInBinary protected def c: Int = ...
  protected def d: Int = ...
  final def C$$inline$b: Int = ...
  final def C$$inline$d: Int = ...
  inline def foo: Int = a + C$$inline$b + c + C$$inline$d
}

----------------------------------------

TITLE: Defining SemiGroup and Monoid Traits in Scala
DESCRIPTION: Example of defining SemiGroup and Monoid traits with extension methods and unit value.

LANGUAGE: scala
CODE:
trait SemiGroup[A]:
  extension (x: A) def combine(y: A): A

trait Monoid[A] extends SemiGroup[A]:
  def unit: A

----------------------------------------

TITLE: Deconstructing Trees with Unquoting in Scala
DESCRIPTION: Shows how to use unquoting in pattern matching to deconstruct a syntax tree in Scala. This allows for extracting parts of a tree into variables.

LANGUAGE: scala
CODE:
val q"i am $what" = q"i am { a quasiquote }"

----------------------------------------

TITLE: Partitioning Collections in Scala
DESCRIPTION: Demonstrates partitioning a collection of people into minors and adults based on age, showcasing the conciseness and universal applicability of Scala collection operations.

LANGUAGE: scala
CODE:
val (minors, adults) = people partition (_.age < 18)

----------------------------------------

TITLE: Implementando uma Lista Encadeada Invariante em Scala
DESCRIPTION: Este snippet define uma classe ListNode invariante com operações básicas de lista encadeada, incluindo um método de pré-inserção. Demonstra a implementação inicial sem uso de limitantes de tipos.

LANGUAGE: scala
CODE:
case class ListNode[T](h: T, t: ListNode[T]) {
  def head: T = h
  def tail: ListNode[T] = t
  def prepend(elem: T): ListNode[T] =
    ListNode(elem, this)
}

----------------------------------------

TITLE: Defining a Basic Macro in Scala
DESCRIPTION: Shows how to define a simple macro named 'assert' that takes a boolean condition and a message.

LANGUAGE: scala
CODE:
def assert(cond: Boolean, msg: Any) = macro Asserts.assertImpl

----------------------------------------

TITLE: Defining YAML Frontmatter for Scala 3 Compiler Documentation
DESCRIPTION: This YAML snippet defines the metadata for a documentation page about finding the cause of issues in the Scala 3 compiler. It specifies the title, description, and a redirect URL to the actual content.

LANGUAGE: yaml
CODE:
---
title: Finding the Cause of an Issue
description: This page describes navigating around the Scala 3 compiler.
redirect_to: https://dotty.epfl.ch/docs/contributing/workflow/cause.html
---

----------------------------------------

TITLE: Creating and Using InstanceMirror in Scala Reflection
DESCRIPTION: Demonstrates creating an InstanceMirror for a class instance, which can be used to reflect on instance methods and fields.

LANGUAGE: scala
CODE:
scala> class C { def x = 2 }
defined class C

scala> val im = m.reflect(new C)
im: scala.reflect.runtime.universe.InstanceMirror = instance mirror for C@3442299e

----------------------------------------

TITLE: Converting Scala mutable collections to Java collections
DESCRIPTION: 演示如何将Scala的可变集合(如ArrayBuffer和HashMap)转换为对应的Java集合类型。使用asJava方法进行转换。

LANGUAGE: scala
CODE:
import collection.mutable._

val jul: java.util.List[Int] = ArrayBuffer(1, 2, 3).asJava
val m: java.util.Map[String, Int] = HashMap("abc" -> 1, "hello" -> 2).asJava

----------------------------------------

TITLE: New Given Syntax for Ord Instances in Scala (Proposed)
DESCRIPTION: Proposed new syntax for defining given instances of Ord for String and List types.

LANGUAGE: scala
CODE:
given Ord[String]:
  def compare(x: String, y: String) = ...

given [A : Ord] => Ord[List[A]]:
  def compare(x: List[A], y: List[A]) = ...

----------------------------------------

TITLE: Basic Value Class Definition in Scala
DESCRIPTION: Example showing the basic structure of a value class definition with a single parameter and methods.

LANGUAGE: scala
CODE:
class C (val u: U) extends AnyVal {
  def m1(ps1) = ...
  ...
  def mN(psN) = ...
}

----------------------------------------

TITLE: Working with Modifiers in Scala Quasiquotes
DESCRIPTION: Demonstrates different ways to work with modifiers in quasiquotes including flags, private within names, and annotations. Shows how to combine and extract modifiers.

LANGUAGE: scala
CODE:
val f1 = q"${Modifiers(PRIVATE | IMPLICIT)} def f"
val f2 = q"$PRIVATE $IMPLICIT def f"
val f3 = q"private implicit def f"

----------------------------------------

TITLE: Example Usage of Traversable Methods in Scala
DESCRIPTION: This snippet demonstrates various methods available in the Traversable trait, including addition, map operations, and conversions.

LANGUAGE: scala
CODE:
xs ++ ys
xs map f
xs flatMap f
xs collect f
xs.toArray
xs.toList
xs.toIterable
xs.toSeq
xs.toIndexedSeq
xs.toStream
xs.toSet
xs.toMap

----------------------------------------

TITLE: Example Usage of Traversable Methods in Scala
DESCRIPTION: This snippet demonstrates various methods available in the Traversable trait, including addition, map operations, and conversions.

LANGUAGE: scala
CODE:
xs ++ ys
xs map f
xs flatMap f
xs collect f
xs.toArray
xs.toList
xs.toIterable
xs.toSeq
xs.toIndexedSeq
xs.toStream
xs.toSet
xs.toMap

----------------------------------------

TITLE: Utilizando o Grafo com Tipos Explícitos em Scala
DESCRIPTION: Versão aprimorada do exemplo anterior, declarando explicitamente os tipos das entidades. Demonstra como o tipo do nó é prefixado com sua instância externa.

LANGUAGE: scala
CODE:
def graphTest: Unit = {
  val g: Graph = new Graph
  val n1: g.Node = g.newNode
  val n2: g.Node = g.newNode
  val n3: g.Node = g.newNode
  n1.connectTo(n2)
  n3.connectTo(n1)
}

----------------------------------------

TITLE: Implementing Generic List Generation in Scala 3
DESCRIPTION: The Scala 3 version of the list duplication method showing updated syntax with 'then' keywords. Functionally identical to the Scala 2 version but uses more modern syntax conventions.

LANGUAGE: scala
CODE:
def listOfDuplicates[A](x: A, length: Int): List[A] =
  if length < 1 then
    Nil
  else
    x :: listOfDuplicates(x, length - 1)

println(listOfDuplicates[Int](3, 4))  // List(3, 3, 3, 3)
println(listOfDuplicates("La", 8))  // List(La, La, La, La, La, La, La, La)

----------------------------------------

TITLE: YAML Frontmatter Configuration
DESCRIPTION: YAML frontmatter block defining the page metadata and redirect configuration for the Scala 3 compiler phases documentation.

LANGUAGE: yaml
CODE:
---
title: Compiler Phases
description: This page describes the phases for the Scala 3 compiler.
redirect_to: https://dotty.epfl.ch/docs/contributing/architecture/phases.html
---

----------------------------------------

TITLE: Invalid Nested Value Classes in Scala
DESCRIPTION: An example showing that value classes cannot be nested within each other.

LANGUAGE: scala
CODE:
class Outer(val inner: Inner) extends AnyVal
class Inner(val value: Int) extends AnyVal

----------------------------------------

TITLE: SIP GitHub Label States Definition
DESCRIPTION: Markdown table showing the valid combinations of stage and status labels used to track SIP proposals in GitHub.

LANGUAGE: markdown
CODE:
|                        |                                     |                         |
|------------------------|-------------------------------------|-------------------------|
| `stage:pre-sip`        | `status:submitted`                  |                         |
| `stage:design`         | `status:under-review`               |                         |
| `stage:design`         | `status:vote-requested`             | `recommendation:accept` |

----------------------------------------

TITLE: Quasiquote Definition Examples in Scala
DESCRIPTION: Examples of quasiquote syntax for various Scala definition constructs, including val, var, method, class, trait, and object definitions.

LANGUAGE: scala
CODE:
q"$mods val $tname: $tpt = $expr" or q"$mods val $pat = $expr"
q"$mods var $tname: $tpt = $expr" or q"$mods var $pat = $expr"
q"$mods val $pat: $tpt = $expr"
q"$mods var $pat: $tpt = $expr"
q"$mods def $tname[..$tparams](...$paramss): $tpt = $expr"
q"$mods def this(...$paramss) = this(..$argss)"
q"$mods type $tpname[..$tparams] = $tpt"
q"$mods class $tpname[..$tparams] $ctorMods(...$paramss) extends { ..$earlydefns } with ..$parents { $self => ..$stats }"
q"$mods trait $tpname[..$tparams] extends { ..$earlydefns } with ..$parents { $self => ..$stats }"
q"$mods object $tname extends { ..$earlydefns } with ..$parents { $self => ..$body }"
q"package $ref { ..$topstats }"
q"package object $tname extends { ..$earlydefns } with ..$parents { $self => ..$stats }"

----------------------------------------

TITLE: Creating a Square Function in Scala Worksheet
DESCRIPTION: Defines a function to calculate the square of an integer and demonstrates its usage. This example is used to show how Scala Worksheets work in IntelliJ.

LANGUAGE: scala
CODE:
def square(x: Int): Int = x * x

square(2)

----------------------------------------

TITLE: Converting Parallel to Sequential Collections in Scala
DESCRIPTION: Method for converting parallel collections back to sequential variants using the seq method. The conversion is always constant time, and for mutable collections, both variants share the same underlying store.

LANGUAGE: scala
CODE:
parallelCollection.seq

----------------------------------------

TITLE: Importowanie z pełną ścieżką w Scala
DESCRIPTION: Pokazuje, jak uniknąć konfliktów nazw poprzez użycie pełnej ścieżki pakietu z przedrostkiem _root_.

LANGUAGE: scala
CODE:
package accounts

import _root_.users._

----------------------------------------

TITLE: Variable Declaration and Assignment in Scala
DESCRIPTION: Shows different ways to declare and assign variables in Scala, including mutable vars, immutable vals, and type annotations.

LANGUAGE: scala
CODE:
var x = 5
x = 6

val x = 5
// x = 6 // This would be invalid

var x: Double = 5

----------------------------------------

TITLE: Demonstrating Context in Scala Snippets
DESCRIPTION: This snippet illustrates how context is automatically provided for code snippets in docstrings, allowing methods to be called without explicit class instantiation.

LANGUAGE: scala
CODE:
slice(2, 5) == drop(2).take(3)

----------------------------------------

TITLE: Defining a Simple Case Class in Scala
DESCRIPTION: Shows the definition of a simple Person case class, which is used in subsequent examples to demonstrate tuple usage.

LANGUAGE: scala
CODE:
case class Person(name: String)

----------------------------------------

TITLE: Creating Simple Scala Class and Object
DESCRIPTION: Sample Scala code defining a Person class and Hello object for testing purposes

LANGUAGE: scala
CODE:
package simpletest

object Hello extends App {
    val p = new Person("Alvin Alexander")
    println(s"Hello ${p.name}")
}

class Person(var name: String)

----------------------------------------

TITLE: Creating Class Instances in Scala 3
DESCRIPTION: Demonstration of creating class instances without the 'new' keyword in Scala 3.

LANGUAGE: scala
CODE:
val p = Person("Robert Allen Zimmerman", "Harmonica Player")

----------------------------------------

TITLE: Quote Pattern Matching Examples
DESCRIPTION: Demonstrates pattern matching on quoted code using quote patterns and extractors

LANGUAGE: scala
CODE:
def valueOfBoolean(x: Expr[Boolean])(using Quotes): Option[Boolean] =
  x match
    case '{ true } => Some(true)
    case '{ false } => Some(false)
    case _ => None

----------------------------------------

TITLE: Example Test Implementation
DESCRIPTION: Example test case demonstrating string interpolation functionality

LANGUAGE: scala
CODE:
object Test extends App {
  val a = 1
  val s = f"$a%s%n$a%s"
  println(s)
}

----------------------------------------

TITLE: Sending JSON Request with STTP in Scala 2
DESCRIPTION: Demonstrates how to send a JSON payload to GitHub's API using STTP client. The example updates a user's profile with new location and bio information using a PATCH request with bearer token authentication.

LANGUAGE: scala
CODE:
import sttp.client4.quick._

val json = ujson.Obj(
  "location" -> "hometown",
  "bio" -> "Scala programmer"
)

val response = quickRequest
  .patch(uri"https://api.github.com/user")
  .auth.bearer(sys.env("GITHUB_TOKEN"))
  .header("Content-Type", "application/json")
  .body(ujson.write(json))
  .send()

println(response.code)
// prints: 200

println(response.body)
// prints the full updated profile in JSON

----------------------------------------

TITLE: Defining traits and a Dog class in Scala
DESCRIPTION: This example shows how to define two traits (HasLegs and HasTail), create a class (Dog) that extends and implements those traits, and then create and use an instance of the Dog class.

LANGUAGE: scala
CODE:
trait HasLegs:
  def numLegs: Int
  def walk(): Unit
  def stop() = println("Stopped walking")

trait HasTail:
  def wagTail(): Unit
  def stopTail(): Unit

class Dog(var name: String) extends HasLegs, HasTail:
  val numLegs = 4
  def walk() = println("I'm walking")
  def wagTail() = println("⎞⎜⎛  ⎞⎜⎛")
  def stopTail() = println("Tail is stopped")
  override def toString = s"$name is a Dog"

// create a Dog instance
val d = Dog("Rover")

// use the class's attributes and behaviors
println(d.numLegs)   // 4
d.wagTail()          // "⎞⎜⎛  ⎞⎜⎛"
d.walk()             // "I'm walking"

----------------------------------------

TITLE: Demonstrating Optional Braces for Function Arguments in Scala
DESCRIPTION: Examples showing how function arguments can be written without braces using the proposed syntax. This includes single and multi-line arguments, as well as lambda expressions.

LANGUAGE: scala
CODE:
times(10):
  println("ah")
  println("ha")

LANGUAGE: scala
CODE:
credentials `++`:
  val file = Path.userHome / ".credentials"
  if file.exists
  then Seq(Credentials(file))
  else Seq()

LANGUAGE: scala
CODE:
xs.map:
  x =>
    val y = x - 1
    y * y

LANGUAGE: scala
CODE:
xs.map: x =>
  val y = x - 1
  y * y

LANGUAGE: scala
CODE:
xs.foldLeft(0): (x, y) =>
  x + y

----------------------------------------

TITLE: Overriding Snippet Compilation Settings Inline
DESCRIPTION: This example shows how to override snippet compilation settings directly in the snippet using the 'sc:' prefix followed by a flag.

LANGUAGE: scala
CODE:
val itShouldFail: Int = List(1.1, 2, 3).head

----------------------------------------

TITLE: Running Scala 3 Nightly with scala-cli
DESCRIPTION: Demonstrates how to run Scala 3 nightly versions using scala-cli. This command starts a REPL with the latest nightly build of Scala 3.

LANGUAGE: shell
CODE:
scala-cli -S 3.nightly

----------------------------------------

TITLE: Importing Future-related Classes in Scala
DESCRIPTION: Shows the necessary import statements for working with Futures in Scala.

LANGUAGE: scala
CODE:
import scala.concurrent.Future
import scala.concurrent.ExecutionContext.Implicits.global
import scala.util.{Failure, Success}

----------------------------------------

TITLE: Filtering Overridden Symbols in Scala Reflection
DESCRIPTION: Demonstrates how to get a list of all overridden symbols in the List class, sorted by declaration order.

LANGUAGE: scala
CODE:
val overridden = listTpe.decls.sorted.filter(_.isOverride)

----------------------------------------

TITLE: Case Class Companion Object Usage in Scala
DESCRIPTION: Demonstrates how to handle case class companion object methods that no longer inherit from Function traits in Scala 3.

LANGUAGE: scala
CODE:
case class Foo(x: Int, b: Boolean)

val fooCtr: (Int, Boolean) => Foo = (x, b) => Foo(x, b)

fooCtr.curried(1)(true)
fooCtr.tupled((2, false))

----------------------------------------

TITLE: Scala Code Block with mdoc Validation
DESCRIPTION: Example of using mdoc to validate Scala code snippets in documentation.

LANGUAGE: scala
CODE:
```scala mdoc
val a = 1
```

----------------------------------------

TITLE: Using Map for Query Parameters in Scala URIs
DESCRIPTION: Shows how to use a Map[String, String] to generate query parameters in a URI. The `uri` interpolator automatically handles the conversion and escaping of the map values.

LANGUAGE: scala
CODE:
val queryParams = Map(
  "q" -> "scala",
  "limit" -> "10",
  "page" -> "1"
)
val uriWithQueryParams = uri"https://example.com/search?$queryParams"
println(uriWithQueryParams)
// prints: https://example.com/search?q=scala&limit=10&page=1

----------------------------------------

TITLE: Calling Methods on Scala Collections
DESCRIPTION: Demonstrates how to call built-in methods on Scala collections using a List example.

LANGUAGE: scala
CODE:
val x = List(1, 2, 3)

x.size          // 3
x.contains(1)   // true
x.map(_ * 10)   // List(10, 20, 30)

----------------------------------------

TITLE: Scala Version-Specific Code Tabs Template
DESCRIPTION: Template for showing version-specific code examples using Jekyll tabs directive.

LANGUAGE: liquid
CODE:
{% tabs hello-world-demo class=tabs-scala-version %}

{% tab 'Scala 2' %}
```scala
object hello extends App {
  println("Hello, World!")
}
```
{% endtab %}

{% tab 'Scala 3' %}
```scala
@main def hello() = println("Hello, World!")
```
{% endtab %}

{% endtabs %}

----------------------------------------

TITLE: Filtering Scala Lists with filter Method
DESCRIPTION: Shows how to use the filter method to create new lists containing only elements that satisfy a given predicate.

LANGUAGE: scala
CODE:
val lessThanFive = oneToTen.filter(_ < 5)
val evens = oneToTen.filter(_ % 2 == 0)
val shortNames = names.filter(_.length <= 4)

----------------------------------------

TITLE: Adding UPickle dependency with sbt
DESCRIPTION: Using sbt to add the Scala toolkit or specifically the UPickle library as a dependency. The example includes setting the Scala version and adding the dependency to the project settings.

LANGUAGE: scala
CODE:
lazy val example = project.in(file("."))
  .settings(
    scalaVersion := "3.4.2",
    libraryDependencies += "org.scala-lang" %% "toolkit" % "0.7.0"
  )

LANGUAGE: scala
CODE:
libraryDependencies += "com.lihaoyi" %% "upickle" % "4.1.0"

----------------------------------------

TITLE: Defining Enumerations for Pizza Attributes in Scala
DESCRIPTION: This snippet defines sealed traits and case objects for pizza toppings, crust sizes, and crust types. These enumerations provide type-safe options for pizza attributes.

LANGUAGE: scala
CODE:
sealed trait Topping
case object Cheese extends Topping
case object Pepperoni extends Topping
case object Sausage extends Topping
case object Mushrooms extends Topping
case object Onions extends Topping

sealed trait CrustSize
case object SmallCrustSize extends CrustSize
case object MediumCrustSize extends CrustSize
case object LargeCrustSize extends CrustSize

sealed trait CrustType
case object RegularCrustType extends CrustType
case object ThinCrustType extends CrustType
case object ThickCrustType extends CrustType

----------------------------------------

TITLE: Defining and Using H2Db Type Macro in Scala
DESCRIPTION: This snippet demonstrates the definition and usage of an H2Db type macro that generates a case class with CRUD functionality from a database table. It shows how to define the macro, implement it, and use it to create a database wrapper.

LANGUAGE: scala
CODE:
type H2Db(url: String) = macro impl

object Db extends H2Db("coffees")

val brazilian = Db.Coffees.insert("Brazilian", 99, 0)
Db.Coffees.update(brazilian.copy(price = 10))
println(Db.Coffees.all)

----------------------------------------

TITLE: YAML Frontmatter Configuration for PR Checklist Page
DESCRIPTION: YAML configuration block that defines metadata for a documentation page about Scala 3 pull request requirements, including a redirect to the official documentation.

LANGUAGE: yaml
CODE:
---
title: Pull Request Checklist
description: This page describes a checklist before opening a Pull Request to the Scala 3 compiler.
redirect_to: https://dotty.epfl.ch/docs/contributing/workflow/checklist.html
---

----------------------------------------

TITLE: Configuring Sonatype Publication Settings
DESCRIPTION: sbt configuration for publishing to Sonatype, including project information and license details.

LANGUAGE: scala
CODE:
name := "library-example"

organization := "ch.epfl.scala"

licenses := Seq("APL2" -> url("https://www.apache.org/licenses/LICENSE-2.0.txt"))

description := "A library that does nothing useful"

import xerial.sbt.Sonatype._
sonatypeProjectHosting := Some(GitHubHosting("scalacenter", "library-example", "julien.richard-foy@epfl.ch"))

publishTo := sonatypePublishToBundle.value

----------------------------------------

TITLE: Printing Calendar Output with Cal Command in Scala
DESCRIPTION: Demonstrates how to execute the cal command to display a calendar and process its output line by line. Shows handling multi-line output from external processes.

LANGUAGE: scala
CODE:
val res: os.CommandResult = os.proc("cal", "-h", "2", "2023").call()
res.out.lines().foreach(println)
// prints:
//   February 2023
// Su Mo Tu We Th Fr Sa
//          1  2  3  4
// ...

----------------------------------------

TITLE: Calling Methods in Scala
DESCRIPTION: This example demonstrates how to call the previously defined 'sum' and 'concatenate' methods, assigning their results to variables.

LANGUAGE: scala
CODE:
val x = sum(1, 2)
val y = concatenate("foo", "bar")

----------------------------------------

TITLE: Changing Task Support for Parallel Collection in Scala
DESCRIPTION: Demonstrates how to import parallel collections, create a parallel array, and change its task support to use a custom ForkJoinPool. This snippet shows the basic setup for customizing parallel collection behavior.

LANGUAGE: scala
CODE:
import scala.collection.parallel._
val pc = mutable.ParArray(1, 2, 3)
val forkJoinPool = new java.util.concurrent.ForkJoinPool(2)
pc.tasksupport = new ForkJoinTaskSupport(forkJoinPool)
pc map { _ + 1 }

----------------------------------------

TITLE: StringBuilder Usage in Scala
DESCRIPTION: Illustrates using StringBuilder for efficient string construction in Scala.

LANGUAGE: scala
CODE:
val buf = new StringBuilder
buf += 'a'
buf ++= "bcdef"
buf.toString

----------------------------------------

TITLE: Installing sttp via Mill
DESCRIPTION: Shows how to add sttp dependencies in a Mill build file, demonstrating both toolkit and standalone dependency configurations.

LANGUAGE: scala
CODE:
object example extends ScalaModule {
  def scalaVersion = "3.4.2"
  def ivyDeps =
    Agg(
      ivy"org.scala-lang::toolkit:0.7.0"
    )
}

LANGUAGE: scala
CODE:
ivy"com.softwaremill.sttp.client4::core:4.0.0-RC1"

----------------------------------------

TITLE: Deprecation Annotation Example in Scala
DESCRIPTION: Demonstrates how to use the @deprecated annotation to mark methods as deprecated, causing compiler warnings when used.

LANGUAGE: scala
CODE:
object DeprecationDemo extends App:
  @deprecated("deprecation message", "release # which deprecates method")
  def hello = "hola"

  hello

----------------------------------------

TITLE: Showcasing Limitation of Type Inference in Recursive Methods
DESCRIPTION: This snippet illustrates a case where Scala's type inference fails. For recursive methods, the compiler cannot infer the return type, causing a compilation error.

LANGUAGE: scala
CODE:
def fac(n: Int) = if (n == 0) 1 else n * fac(n - 1)

----------------------------------------

TITLE: Starting External Process with OS-Lib in Scala
DESCRIPTION: Demonstrates how to create and execute an external process using os.proc to create a file with the touch command. Shows how to check the process exit code and verify file creation.

LANGUAGE: scala
CODE:
val path: os.Path = os.pwd / "output.txt"
println(os.exists(path))
// prints: false
val result: os.CommandResult = os.proc("touch", path).call()
println(result.exitCode)
// prints: 0
println(os.exists(path))
// prints: true

----------------------------------------

TITLE: Multi-line Method Definition in Scala 3
DESCRIPTION: This snippet shows a multi-line method 'getStackTraceAsString' that takes a Throwable and returns its stack trace as a string. It demonstrates Scala 3's syntax for multi-line methods.

LANGUAGE: scala
CODE:
def getStackTraceAsString(t: Throwable): String =
  val sw = new StringWriter
  t.printStackTrace(new PrintWriter(sw))
  sw.toString

----------------------------------------

TITLE: Final Version of RNA Companion Object in Scala
DESCRIPTION: Companion object for RNA class with factory methods and CanBuildFrom implicit.

LANGUAGE: scala
CODE:
object RNA {

  private val S = 2            // number of bits in group
  private val M = (1 << S) - 1 // bitmask to isolate a group
  private val N = 32 / S       // number of groups in an Int

  def fromSeq(buf: Seq[Base]): RNA = {
    val groups = new Array[Int]((buf.length + N - 1) / N)
    for (i <- 0 until buf.length)
      groups(i / N) |= Base.toInt(buf(i)) << (i % N * S)
    new RNA(groups, buf.length)
  }

  def apply(bases: Base*) = fromSeq(bases)

  def newBuilder: Builder[Base, RNA] =
    new ArrayBuffer mapResult fromSeq

  implicit def canBuildFrom: CanBuildFrom[RNA, Base, RNA] =
    new CanBuildFrom[RNA, Base, RNA] {
      def apply(): Builder[Base, RNA] = newBuilder
      def apply(from: RNA): Builder[Base, RNA] = newBuilder
    }
}

----------------------------------------

TITLE: Demonstrating grouped and sliding methods in Scala collections
DESCRIPTION: This REPL interaction demonstrates the difference between the grouped and sliding methods in Scala collections, showing how they create subsequences of elements.

LANGUAGE: scala
CODE:
scala> val xs = List(1, 2, 3, 4, 5)
xs: List[Int] = List(1, 2, 3, 4, 5)
scala> val git = xs grouped 3
git: Iterator[List[Int]] = non-empty iterator
scala> git.next()
res3: List[Int] = List(1, 2, 3)
scala> git.next()
res4: List[Int] = List(4, 5)
scala> val sit = xs sliding 3
sit: Iterator[List[Int]] = non-empty iterator
scala> sit.next()
res5: List[Int] = List(1, 2, 3)
scala> sit.next()
res6: List[Int] = List(2, 3, 4)
scala> sit.next()
res7: List[Int] = List(3, 4, 5)

----------------------------------------

TITLE: Simplifying Class Construction with Default Parameter Values in Scala
DESCRIPTION: This snippet demonstrates how using default values for constructor parameters can often eliminate the need for auxiliary constructors, simplifying the class definition.

LANGUAGE: scala
CODE:
class Pizza(
    var crustSize: Int = DefaultCrustSize, 
    var crustType: String = DefaultCrustType
)

----------------------------------------

TITLE: Complete Value Class Implementation Example
DESCRIPTION: Detailed example of a Meter value class implementation with various methods and transformations.

LANGUAGE: scala
CODE:
class Meter(val underlying: Double) extends AnyVal with Printable {
   def plus (other: Meter): Meter =
      new Meter(this.underlying + other.underlying)
   def divide (factor: Double): Meter = new Meter(this.underlying / factor)
   def less (other: Meter): Boolean = this.underlying < other.underlying
   override def toString: String = underlying.toString + "m"
}

----------------------------------------

TITLE: Installing sttp via Scala CLI
DESCRIPTION: Shows how to add sttp dependencies using Scala CLI, either through the complete toolkit or as a standalone dependency.

LANGUAGE: scala
CODE:
//> using toolkit latest

LANGUAGE: scala
CODE:
//> using dep com.softwaremill.sttp.client4::core:4.0.0-RC1

----------------------------------------

TITLE: Using Covariant List with Different Bird Types in Scala
DESCRIPTION: This code snippet demonstrates how to use the covariant List implementation with different bird types. It shows type widening and the effects of lower type bounds when adding elements to the list.

LANGUAGE: scala
CODE:
trait Bird
case class AfricanSwallow() extends Bird
case class EuropeanSwallow() extends Bird

val africanSwallows: List[AfricanSwallow] = Nil.prepend(AfricanSwallow())
val swallowsFromAntarctica: List[Bird] = Nil
val someBird: Bird = EuropeanSwallow()

// assign swallows to birds
val birds: List[Bird] = africanSwallows

// add some bird to swallows, `B` is `Bird`
val someBirds = africanSwallows.prepend(someBird)

// add a swallow to birds
val moreBirds = birds.prepend(EuropeanSwallow())

// add disparate swallows together, `B` is `Bird` because that is the supertype common to both swallows
val allBirds = africanSwallows.prepend(EuropeanSwallow())

// but this is a mistake! adding a list of birds widens the type arg too much. -Xlint will warn!
val error = moreBirds.prepend(swallowsFromAntarctica)    // List[Object]

----------------------------------------

TITLE: Including Books Template
DESCRIPTION: Liquid template include statement that pulls in the books listing template component.

LANGUAGE: liquid
CODE:
{% include books.html %}

----------------------------------------

TITLE: Custom Case Class Definition for JSON Deserialization
DESCRIPTION: Defines a PetOwner case class for JSON deserialization example.

LANGUAGE: scala
CODE:
case class PetOwner(name: String, pets: List[String])

----------------------------------------

TITLE: Accessing List Elements with head and tail in Scala
DESCRIPTION: Shows how to use head to access the first element and tail to access all elements except the first in a list.

LANGUAGE: scala
CODE:
oneToTen.head   // 1
oneToTen.tail   // List(2, 3, 4, 5, 6, 7, 8, 9, 10)

names.head      // adam
names.tail      // List(brandy, chris, david)

----------------------------------------

TITLE: Configuring Scala Toolkit Dependency in Mill
DESCRIPTION: This snippet shows how to add the Scala Toolkit as a dependency in a Mill project. It defines a ScalaModule with Scala version 3.4.2 and includes the toolkit version 0.7.0 as an Ivy dependency.

LANGUAGE: scala
CODE:
object example extends ScalaModule {
  def scalaVersion = "3.4.2"
  def ivyDeps =
    Agg(
      ivy"org.scala-lang::toolkit:0.7.0"
    )
}

----------------------------------------

TITLE: Collapsing Zeros in Iterator using Span in Scala
DESCRIPTION: Demonstrates how to use span and ++ methods to efficiently collapse leading zeros in an iterator while preserving the first zero.

LANGUAGE: scala
CODE:
def collapse(it: Iterator[Int]) = {
  val (zeros, rest) = it.span(_ == 0)
  zeros.take(1) ++ rest
}
collapse(Iterator(0, 0, 0, 1, 2, 3, 4)).toList

----------------------------------------

TITLE: Improving the Greeting Method with a Customizable Message in Scala
DESCRIPTION: This snippet enhances the 'greet' method by allowing a custom greeting to be passed as a parameter, making the function more flexible.

LANGUAGE: scala
CODE:
def greet(theGreeting: String): String => Unit = 
  (name: String) => println(s"$theGreeting, $name")

----------------------------------------

TITLE: Różne sposoby importowania w Scala
DESCRIPTION: Przedstawia różne metody importowania elementów z pakietów, w tym importowanie wszystkiego, selektywne importy oraz importowanie z zmianą nazwy.

LANGUAGE: scala
CODE:
import users._  // zaimportuj wszystko z pakietu użytkowników
import users.User  // zaimportuj klasę User
import users.{User, UserPreferences}  // zaimportuj tylko wybrane elementy
import users.{UserPreferences => UPrefs}  // zaimportuj i zmień nazwę dla wygody

----------------------------------------

TITLE: Defining Try/Catch/Finally Blocks in Java and Scala
DESCRIPTION: Demonstrates how to define try/catch/finally blocks in Java and Scala.

LANGUAGE: java
CODE:
try {
  writeTextToFile(text);
} catch (IOException ioe) {
  println(ioe.getMessage())
} catch (NumberFormatException nfe) {
  println(nfe.getMessage())
} finally {
  println("Clean up resources here.")
}

LANGUAGE: scala
CODE:
try
  writeTextToFile(text)
catch
  case ioe: IOException =>
    println(ioe.getMessage)
  case nfe: NumberFormatException =>
    println(nfe.getMessage)
finally
  println("Clean up resources here.")

----------------------------------------

TITLE: Defining enums and a Pizza class in Scala
DESCRIPTION: This snippet demonstrates how to create enumerations for crust sizes, types and toppings, then define an OOP-style Pizza class that uses those enums. It also shows how to create and use a Pizza instance.

LANGUAGE: scala
CODE:
// create some enumerations that the Pizza class will use
enum CrustSize:
  case Small, Medium, Large

enum CrustType:
  case Thin, Thick, Regular

enum Topping:
  case Cheese, Pepperoni, BlackOlives, GreenOlives, Onions

// import those enumerations and the ArrayBuffer,
// so the Pizza class can use them
import CrustSize.*
import CrustType.*
import Topping.*
import scala.collection.mutable.ArrayBuffer

// define an OOP style Pizza class
class Pizza(
  var crustSize: CrustSize,
  var crustType: CrustType
):

  private val toppings = ArrayBuffer[Topping]()

  def addTopping(t: Topping): Unit =
    toppings += t

  def removeTopping(t: Topping): Unit =
    toppings -= t

  def removeAllToppings(): Unit =
    toppings.clear()

  override def toString(): String =
    s"""
      |Pizza:
      |  Crust Size: ${crustSize}
      |  Crust Type: ${crustType}
      |  Toppings:   ${toppings}
    """.stripMargin

end Pizza

// create a Pizza instance
val p = Pizza(Small, Thin)

// change the crust
p.crustSize = Large
p.crustType = Thick

// add and remove toppings
p.addTopping(Cheese)
p.addTopping(Pepperoni)
p.addTopping(BlackOlives)
p.removeTopping(Pepperoni)

// print the pizza, which uses its `toString` method
println(p)

----------------------------------------

TITLE: Generating SIP List with Liquid Templates in HTML
DESCRIPTION: This code snippet uses Liquid templating to generate an HTML list of Scala Improvement Proposals (SIPs). It iterates through SIP data, categorizing and displaying them based on their stage and status, with color-coded tags for visual distinction.

LANGUAGE: liquid
CODE:
{% assign sips = site.sips | sort: title %}
{% assign sipData = site.data.sip-data %}

<div class="sip-list">
  <ul>
  {% for sip in sips %}
   {% if sip.stage == "design" or sip.stage == "implementation" %}
     <li class="no-fragmentation">
      <strong>
        <a href="{% if sip.pull-request-number %}https://github.com/scala/improvement-proposals/pull/{{ sip.pull-request-number }}{% else %}{{ sip.url }}{% endif %}">
          {{ sip.title }}
        </a>
      </strong>
      <div class="tag" style="background-color: {{ sipData[sip.stage].color }}">Stage: {{ sipData[sip.stage].text }}</div>
      <div class="tag" style="background-color: {{ sipData[sip.status].color }}">Status: {{ sipData[sip.status].text }}</div>
      {% if sip.recommendation %}
        <div class="tag" style="background-color: {{ sipData[sip.recommendation].color }}">Recommendation: {{ sipData[sip.recommendation].text }}</div>
      {% endif %}
     </li>
   {% endif %}
  {% endfor %}
  </ul>
</div>

----------------------------------------

TITLE: Improving the Greeting Method with a Customizable Message in Scala
DESCRIPTION: This snippet enhances the 'greet' method by allowing a custom greeting to be passed as a parameter, making the function more flexible.

LANGUAGE: scala
CODE:
def greet(theGreeting: String): String => Unit = 
  (name: String) => println(s"$theGreeting, $name")

----------------------------------------

TITLE: Creating ScalaTest Unit Tests
DESCRIPTION: Example of writing unit tests using ScalaTest's AnyFunSuite style, including normal and pending tests.

LANGUAGE: scala
CODE:
package math
  
import org.scalatest.funsuite.AnyFunSuite

class MathUtilsTests extends AnyFunSuite:

  // test 1
  test("'double' should handle 0") {
    val result = MathUtils.double(0)
    assert(result == 0)
  }

  // test 2
  test("'double' should handle 1") {
    val result = MathUtils.double(1)
    assert(result == 2)
  }
 
  test("test with Int.MaxValue") (pending)

end MathUtilsTests

----------------------------------------

TITLE: Running Compiled Scala Program
DESCRIPTION: Command to execute the compiled Scala program using the scala runtime.

LANGUAGE: sh
CODE:
$ scala Hello

----------------------------------------

TITLE: Tuple Map Example with Some.apply
DESCRIPTION: Shows how polymorphic eta-expansion affects tuple map operations.

LANGUAGE: scala
CODE:
List(1, 2, 3).map(Some.apply) // works

("Hello", 2, 'u').map(Some.apply) // error:
// Found: Any => Some[Any], Required: [t] => (t) => Nothing

----------------------------------------

TITLE: Using Callbacks with Futures in Scala
DESCRIPTION: Demonstrates how to use the onComplete callback method with a Future to handle success and failure cases.

LANGUAGE: scala
CODE:
eventualInt.onComplete {
  case Success(value) => println(s"Got the callback, value = $value")
  case Failure(e) => e.printStackTrace
}

----------------------------------------

TITLE: Defining Parameterized Enums in Java and Scala
DESCRIPTION: Shows how to define parameterized enums in Java and Scala.

LANGUAGE: java
CODE:
enum Color {
  Red(0xFF0000),
  Green(0x00FF00),
  Blue(0x0000FF);

  private int rgb;

  Color(int rgb) {
    this.rgb = rgb;
  }
}

LANGUAGE: scala
CODE:
enum Color(val rgb: Int):
  case Red  extends Color(0xFF0000)
  case Green extends Color(0x00FF00)
  case Blue  extends Color(0x0000FF)

----------------------------------------

TITLE: Starting Scala 3 REPL Session
DESCRIPTION: This snippet demonstrates how to start a Scala 3 REPL session using the 'scala' command. It shows the welcome message and version information for Scala 3.

LANGUAGE: bash
CODE:
$ scala
Welcome to Scala {{site.scala-3-version}} (1.8.0_322, Java OpenJDK 64-Bit Server VM).
Type in expressions for evaluation. Or try :help.

scala> _

----------------------------------------

TITLE: Chaining Operations on Immutable Collections in Scala
DESCRIPTION: Demonstrates method chaining on immutable collections using filter and map operations. Shows how to create a fluent sequence of transformations on a List.

LANGUAGE: scala
CODE:
// a sample list
val nums = (1 to 10).toList   // List(1,2,3,4,5,6,7,8,9,10)

// methods can be chained together as needed
val x = nums.filter(_ > 3)
            .filter(_ < 7)
            .map(_ * 10)

// result: x == List(40, 50, 60)

----------------------------------------

TITLE: Returning Values from If Statements in Java and Scala
DESCRIPTION: Shows how to return values from if statements in Java (using ternary operator) and Scala.

LANGUAGE: java
CODE:
int minVal = (a < b) ? a : b;

LANGUAGE: scala
CODE:
val minValue = if a < b then a else b

----------------------------------------

TITLE: Lambda Parameter Parentheses in Scala
DESCRIPTION: Illustrates the requirement in Scala 3 to enclose lambda parameters in parentheses when specifying their type.

LANGUAGE: scala
CODE:
val f = { x: Int => x * x }

----------------------------------------

TITLE: Using Directives Bug Report Example
DESCRIPTION: Example showing how to use directives to configure Scala compilation settings in a single file

LANGUAGE: scala
CODE:
//> using platform "native"
//> using "com.lihaoyi::os-lib:0.7.8"
//> using options "-Xfatal-warnings"

def foo = println("<here comes the buggy warning with Scala Native and os-lib>")

----------------------------------------

TITLE: Adding Basic Authentication to sttp Request in Scala
DESCRIPTION: Demonstrates how to add basic authentication to an sttp request using the auth.basic method. The example shows the syntax for adding a username and password to a GET request.

LANGUAGE: scala
CODE:
import sttp.client4.quick._

// a request with a authentication
val request = quickRequest
  .get(uri"https://example.com")
  .auth.basic(user = "user", password = "***")

----------------------------------------

TITLE: Defining OOP-style Classes with Primary Constructors in Java and Scala
DESCRIPTION: Shows how to define a class with a primary constructor in Java and Scala. The Scala version is more concise.

LANGUAGE: java
CODE:
class Person {
  public String firstName;
  public String lastName;
  public int age;
  public Person(
    String firstName, 
    String lastName,
    int age
  ) {
    this.firstName = firstName;
    this.lastName = lastName;
    this.age = age;
  }
  public String toString() {
    return String.format("%s %s is %d years old.", firstName, lastName, age);
  }
}

LANGUAGE: scala
CODE:
class Person (
  var firstName: String,
  var lastName: String,
  var age: Int
):  
  override def toString = s"$firstName $lastName is $age years old."

----------------------------------------

TITLE: Defining Multi-Line For Loops in Java and Scala
DESCRIPTION: Demonstrates how to define multi-line for loops in Java and Scala.

LANGUAGE: java
CODE:
for (int i: ints) {
  int x = i * 2;
  System.out.println(x);
}

LANGUAGE: scala
CODE:
for
  i <- ints
do
  val x = i * 2
  println(s"i = $i, x = $x")

----------------------------------------

TITLE: Writing Methods Using Type Classes in Scala 2 and 3
DESCRIPTION: This snippet shows how to write methods that use type classes as parameters in both Scala 2 and Scala 3, demonstrating the 'showAll' method that works with a list of any type A that has a 'Showable' instance.

LANGUAGE: scala
CODE:
// Scala 2
def showAll[A](as: List[A])(implicit showable: Showable[A]): Unit =
  as.foreach(a => println(showable.show(a)))

showAll(List(Person("Jane"), Person("Mary")))

LANGUAGE: scala
CODE:
// Scala 3
def showAll[A: Showable](as: List[A]): Unit =
  as.foreach(a => println(a.show))

showAll(List(Person("Jane"), Person("Mary")))

----------------------------------------

TITLE: Creating and Using Futures in Scala
DESCRIPTION: Demonstrates creating and using Futures for asynchronous operations in a social network context.

LANGUAGE: scala
CODE:
import scala.concurrent._
import ExecutionContext.Implicits.global

val session = socialNetwork.createSessionFor("user", credentials)
val f: Future[List[Friend]] = Future {
  session.getFriends()
}

LANGUAGE: scala
CODE:
import scala.concurrent.*
import ExecutionContext.Implicits.global

val session = socialNetwork.createSessionFor("user", credentials)
val f: Future[List[Friend]] = Future {
  session.getFriends()
}

----------------------------------------

TITLE: Patricia Trie Implementation in Scala
DESCRIPTION: Implements a mutable prefix map using a Patricia trie data structure.

LANGUAGE: scala
CODE:
import collection._

class PrefixMap[T]
extends mutable.Map[String, T]
   with mutable.MapLike[String, T, PrefixMap[T]] {

  var suffixes: immutable.Map[Char, PrefixMap[T]] = Map.empty
  var value: Option[T] = None

  def get(s: String): Option[T] =
    if (s.isEmpty) value
    else suffixes get (s(0)) flatMap (_.get(s substring 1))

  def withPrefix(s: String): PrefixMap[T] =
    if (s.isEmpty) this
    else {
      val leading = s(0)
      suffixes get leading match {
        case None =>
          suffixes = suffixes + (leading -> empty)
        case _ =>
      }
      suffixes(leading) withPrefix (s substring 1)
    }

  override def update(s: String, elem: T) =
    withPrefix(s).value = Some(elem)

  override def remove(s: String): Option[T] =
    if (s.isEmpty) { val prev = value; value = None; prev }
    else suffixes get (s(0)) flatMap (_.remove(s substring 1))

  def iterator: Iterator[(String, T)] =
    (for (v <- value.iterator) yield ("", v)) ++
    (for ((chr, m) <- suffixes.iterator;
          (s, v) <- m.iterator) yield (chr +: s, v))

  def += (kv: (String, T)): this.type = { update(kv._1, kv._2); this }

  def -= (s: String): this.type  = { remove(s); this }

  override def empty = new PrefixMap[T]
}

----------------------------------------

TITLE: Defining Trampoline Method for Monoid in Scala
DESCRIPTION: Example of defining a trampoline method in the Monoid companion object to simplify usage.

LANGUAGE: scala
CODE:
trait Monoid[A] extends SemiGroup[A]:
  def unit: A
object Monoid:
  def unit[A](using m: Monoid[A]): A = m.unit
...
def reduce[A : Monoid](xs: List[A]): A =
  xs.foldLeft(Monoid.unit)(_ `combine` _)

----------------------------------------

TITLE: Demonstrating Wildcard Pattern in Scala Quasiquotes
DESCRIPTION: Shows the simplest pattern that matches any input using the wildcard pattern in Scala quasiquotes.

LANGUAGE: scala
CODE:
pq"_"

----------------------------------------

TITLE: For-Yield with Multiple Options in Scala
DESCRIPTION: Demonstration of using for-yield expressions to work with multiple Option values, combining them into a single result.

LANGUAGE: scala
CODE:
val y = for {
    a <- toInt(stringA)
    b <- toInt(stringB)
    c <- toInt(stringC)
} yield a + b + c

----------------------------------------

TITLE: Defining Open Classes in Java and Scala
DESCRIPTION: Demonstrates how to define classes that are open for extension in Java and Scala.

LANGUAGE: java
CODE:
class Person

LANGUAGE: scala
CODE:
open class Person

----------------------------------------

TITLE: Demonstrating Leading Infix Operator Behavior
DESCRIPTION: This snippet shows how the -Xsource:3 flag affects the behavior of leading infix operators in Scala.

LANGUAGE: scala
CODE:
  def f =
    1
    + 2

----------------------------------------

TITLE: Running Scala Benchmark with JVM Parameters
DESCRIPTION: This Java command demonstrates how to run a Scala benchmark with specific JVM parameters, including server mode, classpath settings, and system properties for configuring the benchmark.

LANGUAGE: bash
CODE:
java -server -cp .:../../build/pack/lib/scala-library.jar -Dpar=1 -Dlength=300000 Map 10

----------------------------------------

TITLE: Evolving Case Class Definition in Scala 2
DESCRIPTION: Demonstrates how to change a case class definition while maintaining backwards compatibility in Scala 2. This includes making the primary constructor private, defining private unapply, and creating withXXX methods for field modifications.

LANGUAGE: scala
CODE:
// Mark the primary constructor as private
case class Person private (name: String, age: Int) {
  // Create withXxx methods for every field, implemented by using the (private) copy method
  def withName(name: String): Person = copy(name = name)
  def withAge(age: Int): Person = copy(age = age)
}

object Person {
  // Create a public constructor (which uses the private primary constructor)
  def apply(name: String, age: Int) = new Person(name, age)
  // Make the extractor private
  private def unapply(p: Person): Some[Person] = Some(p)
}

----------------------------------------

TITLE: Naming Context Bounds in Scala (Proposed Syntax)
DESCRIPTION: Proposed syntax for naming context bounds using 'as' keyword.

LANGUAGE: scala
CODE:
def reduce[A : Monoid as m](xs: List[A]): A =
  xs.foldLeft(m.unit)(_ `combine` _)

----------------------------------------

TITLE: Example of Infix Type and Type Argument Line Breaking in Scala
DESCRIPTION: Illustrates how long types (over 79 characters) are split into multiple lines for better readability in error messages.

LANGUAGE: scala
CODE:
implicit error;
!I e: String
f invalid because
!I impPar4: List[
  (
    VeryLongTypeName ::::
    VeryLongTypeName ::::
    VeryLongTypeName ::::
    VeryLongTypeName
  )
  ::::
  (Short :::: Short) ::::
  (
    VeryLongTypeName ::::
    VeryLongTypeName ::::
    VeryLongTypeName ::::
    VeryLongTypeName
  )
  ::::
  VeryLongTypeName ::::
  VeryLongTypeName ::::
  VeryLongTypeName ::::
  VeryLongTypeName
]

----------------------------------------

TITLE: Using Scala Nightly in Script Directives
DESCRIPTION: Shows how to specify a Scala nightly version using a directive in a Scala script file. This allows running the script with a nightly build.

LANGUAGE: scala
CODE:
//> using scala 3.nightly

----------------------------------------

TITLE: Configuring Scala Toolkit Dependency in sbt
DESCRIPTION: This snippet shows how to add the Scala Toolkit as a dependency in an sbt project. It configures the project settings with Scala version 3.4.2 and includes the toolkit version 0.7.0 as a library dependency.

LANGUAGE: scala
CODE:
lazy val example = project.in(file("."))
  .settings(
    scalaVersion := "3.4.2",
    libraryDependencies += "org.scala-lang" %% "toolkit" % "0.7.0"
  )

----------------------------------------

TITLE: Running Scala 2 Nightly with scala-cli
DESCRIPTION: Demonstrates how to run Scala 2 nightly versions using scala-cli. This command starts a REPL with the latest nightly build of Scala 2.13.

LANGUAGE: shell
CODE:
scala-cli -S 2.13.nightly

----------------------------------------

TITLE: Configuring Jekyll Front Matter for Scala Books Page
DESCRIPTION: YAML front matter configuration for a Jekyll page that displays Scala programming books. Sets the page title, layout template, and includes a redirect from a legacy documentation URL path.

LANGUAGE: yaml
CODE:
---
title: Books
layout: basic-index
redirect_from:
  - /documentation/books.html
---

----------------------------------------

TITLE: Importing Reflection API Components
DESCRIPTION: Shows how to properly import and use the reflection API components in a macro implementation, including accessing the Quotes context and reflect module.

LANGUAGE: scala
CODE:
import scala.quoted.* // Import `quotes`, `Quotes`, and `Expr`

def f(x: Expr[Int])(using Quotes): Expr[Int] =
  import quotes.reflect.* // Import `Tree`, `TypeRepr`, `Symbol`, `Position`, .....
  val tree: Tree = ...
  ...

----------------------------------------

TITLE: Illustrating Difficulty of Commenting Out Elements Without Trailing Commas
DESCRIPTION: This example demonstrates the inconvenience of commenting out elements in a sequence without trailing comma support, resulting in a syntax error.

LANGUAGE: scala
CODE:
Seq(
  foo,
  bar,
//  baz
)       // error: illegal start of simple expression

----------------------------------------

TITLE: Adding Scala Toolkit Dependency in Scala CLI
DESCRIPTION: This snippet shows how to require the latest version of the Scala Toolkit in a Scala CLI project. It uses a single line directive to include the entire toolkit.

LANGUAGE: scala
CODE:
//> using toolkit latest

----------------------------------------

TITLE: SBT Cross-Build Configuration
DESCRIPTION: SBT configuration for managing source directories when cross-building between Scala 2.12 and 2.13

LANGUAGE: scala
CODE:
unmanagedSourceDirectories in Compile += {
  val sourceDir = (sourceDirectory in Compile).value
  CrossVersion.partialVersion(scalaVersion.value) match {
    case Some((2, n)) if n >= 13 => sourceDir / "scala-2.13+"
    case _                       => sourceDir / "scala-2.13-"
  }
}

----------------------------------------

TITLE: Running Tests with Mill
DESCRIPTION: Command to run all tests in the 'example' module using Mill build tool with sample output.

LANGUAGE: bash
CODE:
./mill example.test.test
# [71/71] example.test.test
# MyTests:
#   + sum of two integers 0.008s

----------------------------------------

TITLE: Compiling and Running Scala Pizza Application
DESCRIPTION: Shell commands for compiling the Pizza.scala file and running the PizzaTest application.

LANGUAGE: sh
CODE:
$ scalac Pizza.scala
$ scala PizzaTest

----------------------------------------

TITLE: Defining a Hello World Program in Scala 2
DESCRIPTION: Shows how to write a simple Hello World program in Scala 2, introducing the object keyword and main method syntax.

LANGUAGE: scala
CODE:
object HelloWorld {
  def main(args: Array[String]): Unit = {
    println("Hello, World!")
  }
}

----------------------------------------

TITLE: Bug-fix Contribution Checklist in Markdown
DESCRIPTION: A structured checklist detailing the step-by-step process for submitting bug fixes to the Scala project, including issue selection, forking, testing, and pull request submission.

LANGUAGE: markdown
CODE:
1. Select a bug to fix from GitHub, or create a GitHub issue
2. Optional (but recommended), announce intention on Scala Contributors
3. Fork the Scala repository and clone your fork
4. Create a feature branch: use branch name `issue/NNNN`
5. Fix the bug or implement the new small feature
6. Test until all tests pass
7. Commit changes to feature branch
8. Re-write git history if necessary
9. Submit a pull request
10. Work with reviewer to get pull request merged
11. Celebrate!

----------------------------------------

TITLE: Running Standalone Partest
DESCRIPTION: Example of running partest standalone with options for showing diffs and logs of failed tests (removed in 2.12.2).

LANGUAGE: bash
CODE:
./test/partest --show-diff --show-log --failed

----------------------------------------

TITLE: Basic Enum Type Macro Implementation
DESCRIPTION: Example showing how to implement an enumeration using typed macro parameters, which requires symbol quotation.

LANGUAGE: scala
CODE:
object Days extends Enum('Monday, 'Tuesday, 'Wednesday...)

----------------------------------------

TITLE: Adding Overloaded Constructor in Scala 2
DESCRIPTION: Shows how to add an overloaded constructor to initialize additional fields in Scala 2.

LANGUAGE: scala
CODE:
object Person {
  // Original public constructor
  def apply(name: String, age: Int): Person = new Person(name, age, None)
  // Additional constructor that also sets the address
  def apply(name: String, age: Int, address: String): Person =
    new Person(name, age, Some(address))
}

----------------------------------------

TITLE: YAML Front Matter Configuration for SID-8 Documentation
DESCRIPTION: Jekyll front matter configuration block defining metadata for the Scala Improvement Document (SID) 8 page about Scala Swing Overview. Includes layout settings, title, implementation stage, status and URL configurations.

LANGUAGE: yaml
CODE:
---
layout: sip
title: SID-8 - Scala Swing Overview
stage: completed
status: shipped
permalink: /sips/:title.html
redirect_from: /sips/pending/scala-swing-overview.html
---

----------------------------------------

TITLE: Implementing a Simple Custom Interpolator in Scala
DESCRIPTION: Provides a basic implementation of a custom 'json' interpolator in Scala. This example demonstrates how to access the raw string parts and expression values within the interpolator method.

LANGUAGE: scala
CODE:
implicit class JsonHelper(val sc: StringContext) extends AnyVal {
  def json(args: Any*): JSONObject = {
    val strings = sc.parts.iterator
    val expressions = args.iterator
    var buf = new StringBuilder(strings.next())
    while(strings.hasNext) {
      buf.append(expressions.next())
      buf.append(strings.next())
    }
    parseJson(buf)
  }
}

----------------------------------------

TITLE: Using a Generic Reference Class in Scala
DESCRIPTION: Demonstrates how to use the generic Reference class with a specific type (Int).

LANGUAGE: scala
CODE:
object ReferenciaEntero {
  def main(args: Array[String]): Unit = {
    val ref = new Referencia[Int]
    ref.set(13)
    println("La referencia tiene la mitad de " + (ref.get * 2))
  }
}

----------------------------------------

TITLE: Setting up GraalVM environment variables in Bash
DESCRIPTION: Configures the necessary environment variables for GraalVM in the ~/.bash_profile file. This includes setting GRAALVM_HOME, JAVA_HOME, and updating the PATH.

LANGUAGE: bash
CODE:
export GRAALVM_HOME=<path to GraalVM home directory>
export JAVA_HOME=$GRAALVM_HOME
export PATH=$GRAALVM_HOME/bin:$PATH

----------------------------------------

TITLE: Creating Multiline Strings in Scala
DESCRIPTION: This snippet shows how to create multiline strings in Scala using triple quotes.

LANGUAGE: scala
CODE:
val speech = """Four score and
               seven years ago
               our fathers ..."""

----------------------------------------

TITLE: Installing GraalVM Native Image
DESCRIPTION: Command to install the Native Image component for GraalVM using the GraalVM Updater (gu) tool.

LANGUAGE: bash
CODE:
gu install native-image

----------------------------------------

TITLE: Defining Map as an Iterable in Scala
DESCRIPTION: Shows how Map is defined as an Iterable, extending MapOps.

LANGUAGE: scala
CODE:
trait Map[K, V] extends Iterable[(K, V)]
  with MapOps[K, V, Map, Map[K, V]]

----------------------------------------

TITLE: Test Exclusion with .ignore Modifier - Scala 2
DESCRIPTION: Example of using .ignore modifier to exclude specific tests from running in Scala 2. The addition test is ignored while multiplication and remainder tests run.

LANGUAGE: scala
CODE:
class MathSuite extends munit.FunSuite {
  test("addition".ignore) {
    assert(1 + 1 == 2)
  }
  test("multiplication") {
    assert(3 * 7 == 21)
  }
  test("remainder") {
    assert(13 % 5 == 3)
  }
}

----------------------------------------

TITLE: Markdown Frontmatter Configuration
DESCRIPTION: YAML frontmatter block defining metadata for the tutorial page including title, type, description and navigation links.

LANGUAGE: yaml
CODE:
---
title: Migration Tutorial
type: chapter
description: This chapter contains the tutorials for porting a Scala 2.13 project to Scala 3
num: 9
previous-page: tooling-migration-mode
next-page: tutorial-prerequisites
---

----------------------------------------

TITLE: YAML Frontmatter Configuration for SID-10 Documentation
DESCRIPTION: YAML configuration block defining metadata for the SID-10 documentation page, including layout, title, status tracking, and URL configuration.

LANGUAGE: yaml
CODE:
---
layout: sip
title: SID-10 - Storage of pickled Scala signatures in class files
stage: completed
status: shipped
permalink: /sips/:title.html
redirect_from: /sips/pending/picked-signatures.html
---

----------------------------------------

TITLE: Initializing Variables for String Concatenation in Scala
DESCRIPTION: This snippet demonstrates the initialization of variables that will be used in string concatenation examples.

LANGUAGE: scala
CODE:
val firstName = "John"
val mi = 'C'
val lastName = "Doe"

----------------------------------------

TITLE: Constructing Type Variable Pattern in Scala Quasiquotes
DESCRIPTION: Shows the steps to construct and deconstruct a type variable pattern in Scala quasiquotes.

LANGUAGE: scala
CODE:
scala> val name = TypeName("t")
scala> val empty = q""
scala> val t = pq"$name @ $empty"
scala> val tpt = tq"F[$t]"
scala> val typevar = pq"_: $tpt"
typevar: universe.Typed = (_: F[(t @ _)])

----------------------------------------

TITLE: SBT Local Settings Configuration
DESCRIPTION: Example sbt configuration for local development settings

LANGUAGE: scala
CODE:
// skip docs for local publishing
publishArtifact in (Compile, packageDoc) in ThisBuild := false
// set version based on current sha, so that you can easily consume this build from another sbt project
baseVersionSuffix := s"local-${Process("tools/get-scala-commit-sha").lines.head.substring(0, 7)}"
// show more logging during a partest run
testOptions in IntegrationTest in LocalProject("test") ++= Seq(Tests.Argument("--show-log"), Tests.Argument("--show-diff"))
// if incremental compilation is compiling too much (should be fine under sbt 0.13.13)
// antStyle := true

----------------------------------------

TITLE: Test Exclusion with .ignore Modifier - Scala 3
DESCRIPTION: Example of using .ignore modifier to exclude specific tests from running in Scala 3. The addition test is ignored while multiplication and remainder tests run.

LANGUAGE: scala
CODE:
class MathSuite extends munit.FunSuite:
  test("addition".ignore) {
    assert(1 + 1 == 2)
  }
  test("multiplication") {
    assert(3 * 7 == 21)
  }
  test("remainder") {
    assert(13 % 5 == 3)
  }

----------------------------------------

TITLE: Defining Page Metadata for Scala3 Scaladoc Blog Posts
DESCRIPTION: This YAML snippet demonstrates the front matter structure for defining metadata in Scala3 Scaladoc blog posts. It includes fields for layout, author, title, subtitle, date, and author image.

LANGUAGE: yaml
CODE:
---
layout: <A reference to the layout page for the blog page>
author: <Name of the author of the page>
title: <Title of the page>
subTitle: <Subtitle of the page>
date: <Date of the creation of the page>, e.g. 2016-12-05
authorImg: <Link to the author's image>
---
<Content of your page>

----------------------------------------

TITLE: Implementing a Multiline Scala Method
DESCRIPTION: This example shows how to create a method with multiple lines of code. It demonstrates the use of curly braces for multiline method bodies and introduces local variables within the method.

LANGUAGE: scala
CODE:
def addThenDouble(a: Int, b: Int): Int = {
    val sum = a + b
    val doubled = sum * 2
    doubled
}

----------------------------------------

TITLE: Docker Compose Setup
DESCRIPTION: Commands for building and serving the documentation site using Docker Compose, including environment variable configuration for proper file permissions.

LANGUAGE: bash
CODE:
env UID="$(id -u)" GID="$(id -g)" docker-compose up

----------------------------------------

TITLE: Scala Build Tools Compatibility Table
DESCRIPTION: Markdown table showing minimum working versions of various Scala build tools for different JDK versions.

LANGUAGE: markdown
CODE:
| JDK         | scala-cli  | sbt       | mill       |
|:-----------:|:----------:|:---------:|:-----------|
| 23          | 1.4.1      | 1.9.0     | 0.11.8     |
| 21 (LTS)    | 1.0.0      | 1.9.0     | 0.11.5     |
| 17 (LTS)    | 1.0.0      | 1.6.0     | 0.7.0      |
| 11 (LTS)    | 1.0.0      | 1.1.0     | 0.1.5      |
| 8 (LTS)     | 1.0.0      | 1.0.0     | 0.1.0      |

----------------------------------------

TITLE: Demonstrating NullPointerException in Scala Reflection
DESCRIPTION: This code snippet showcases a typical stack trace of a NullPointerException that can occur due to thread safety issues in Scala reflection. It illustrates the internal calls within the reflection library that can lead to this error.

LANGUAGE: text
CODE:
java.lang.NullPointerException:
at s.r.i.Types$TypeRef.computeHashCode(Types.scala:2332)
at s.r.i.Types$UniqueType.<init>(Types.scala:1274)
at s.r.i.Types$TypeRef.<init>(Types.scala:2315)
at s.r.i.Types$NoArgsTypeRef.<init>(Types.scala:2107)
at s.r.i.Types$ModuleTypeRef.<init>(Types.scala:2078)
at s.r.i.Types$PackageTypeRef.<init>(Types.scala:2095)
at s.r.i.Types$TypeRef$.apply(Types.scala:2516)
at s.r.i.Types$class.typeRef(Types.scala:3577)
at s.r.i.SymbolTable.typeRef(SymbolTable.scala:13)
at s.r.i.Symbols$TypeSymbol.newTypeRef(Symbols.scala:2754)

----------------------------------------

TITLE: Demonstrating Blog Directory Structure in Scala3 Scaladoc
DESCRIPTION: This snippet shows the required directory structure for including a blog in Scala3 Scaladoc. The '_blog' directory must contain a '_posts' subdirectory for blog posts and an 'index.html' file.

LANGUAGE: plaintext
CODE:
├── _blog
│   ├── _posts
│   │   └── 2016-12-05-implicit-function-types.md
│   └── index.html

----------------------------------------

TITLE: Defining Seq Trait with SeqLike Implementation
DESCRIPTION: Implementation of the Seq trait that extends SeqLike with concrete type parameters.

LANGUAGE: scala
CODE:
trait Seq[+Elem] extends ... with SeqLike[Elem, Seq[Elem]] { ... }

----------------------------------------

TITLE: YAML Front Matter Configuration for SIP Meeting Results
DESCRIPTION: YAML configuration block defining the layout, title, and proposal details for a SIP meeting results page. Documents the acceptance of SIP-56 for Match Types specification.

LANGUAGE: yaml
CODE:
---
layout: sip-meeting-results
title: SIP Meeting Results - 19th January 2024
partof: results
proposals:
  - url: https://docs.scala-lang.org/sips/match-types-spec.html
    name: SIP-56 - Proper Specification for Match Types
    result: accepted as completed
---

----------------------------------------

TITLE: Creating Basic Scala Collections
DESCRIPTION: Demonstrates the creation of various Scala collections using parentheses syntax, which internally calls the apply method of the collection's companion object.

LANGUAGE: scala
CODE:
Traversable()             // An empty traversable object
List()                    // The empty list
List(1.0, 2.0)            // A list with elements 1.0, 2.0
Vector(1.0, 2.0)          // A vector with elements 1.0, 2.0
Iterator(1, 2, 3)         // An iterator returning three integers.
Set(dog, cat, bird)       // A set of three animals
HashSet(dog, cat, bird)   // A hash set of the same animals
Map('a' -> 7, 'b' -> 0)   // A map from characters to integers

----------------------------------------

TITLE: Defining a Simple Scala Object for Testing
DESCRIPTION: This code defines a Scala object named CubeCalculator with a method 'cube' that calculates the cube of an integer. This object will be used as the subject for testing.

LANGUAGE: scala
CODE:
object CubeCalculator:
  def cube(x: Int) =
    x * x * x

----------------------------------------

TITLE: Error Handling in JSON Deserialization
DESCRIPTION: Shows how uPickle handles type mismatches during deserialization by throwing AbortException.

LANGUAGE: scala
CODE:
val json = "{\"name\": \"Peter\"} "
upickle.default.read[Map[String, List[Int]]](json)
// throws: upickle.core.AbortException: expected sequence got string at index 9

----------------------------------------

TITLE: Implementing Utility Methods with Scala Object
DESCRIPTION: Example of a Pizza utilities singleton object containing methods for pizza topping manipulation.

LANGUAGE: scala
CODE:
object PizzaUtils {
    def addTopping(p: Pizza, t: Topping): Pizza = ...
    def removeTopping(p: Pizza, t: Topping): Pizza = ...
    def removeAllToppings(p: Pizza): Pizza = ...
}

----------------------------------------

TITLE: Adding sbt-sonatype and sbt-pgp Plugins
DESCRIPTION: Configuration for adding the sbt-sonatype and sbt-pgp plugins to the project/plugins.sbt file.

LANGUAGE: scala
CODE:
addSbtPlugin("org.xerial.sbt" % "sbt-sonatype" % "3.9.21")
addSbtPlugin("com.github.sbt" % "sbt-pgp" % "2.2.1")

----------------------------------------

TITLE: Implementando um Grafo com Classes Internas em Scala
DESCRIPTION: Define uma classe Graph com uma classe interna Node. Demonstra como criar nós e conectá-los dentro do grafo. Inclui métodos para criar novos nós e conectar nós existentes.

LANGUAGE: scala
CODE:
class Graph {
  class Node {
    var connectedNodes: List[Node] = Nil
    def connectTo(node: Node): Unit = {
      if (!connectedNodes.exists(node.equals)) {
        connectedNodes = node :: connectedNodes
      }
    }
  }
  var nodes: List[Node] = Nil
  def newNode: Node = {
    val res = new Node
    nodes = res :: nodes
    res
  }
}

----------------------------------------

TITLE: Handling Command-line Arguments in Scala
DESCRIPTION: Defines a main method that takes a name argument and prints a greeting. Uses string interpolation to include the argument in the output.

LANGUAGE: scala
CODE:
//> using scala {{site.scala-3-version}}

@main
def hello(name: String): Unit =
  println(s"Hello, $name!")

----------------------------------------

TITLE: Using Package Definitions in Scala 2
DESCRIPTION: Example program showing how to import and use package-level definitions in Scala 2.

LANGUAGE: scala
CODE:
// in file PrintPlanted.scala
import gardening.fruits._

object PrintPlanted {
  def main(args: Array[String]): Unit = {
    for (fruit <- planted) {
      showFruit(fruit)
    }
  }
}

----------------------------------------

TITLE: Writing ScalaTest FunSuite Tests
DESCRIPTION: ScalaTest unit tests using FunSuite style to test the Person class functionality

LANGUAGE: scala
CODE:
package simpletest

import org.scalatest.funsuite.AnyFunSuite

class HelloTests extends AnyFunSuite {

    // test 1
    test("the name is set correctly in constructor") {
        val p = new Person("Barney Rubble")
        assert(p.name == "Barney Rubble")
    }

    // test 2
    test("a Person's name can be changed") {
        val p = new Person("Chad Johnson")
        p.name = "Ochocinco"
        assert(p.name == "Ochocinco")
    }

}

----------------------------------------

TITLE: Compiling Scala Program
DESCRIPTION: Command to compile the Scala source code into JVM bytecode files using the scalac compiler.

LANGUAGE: sh
CODE:
$ scalac Hello.scala

----------------------------------------

TITLE: Using Assert with Lists in Scala 2/3
DESCRIPTION: Example of using the assert method to verify a condition on a list transformation, checking if all numbers are even after multiplication.

LANGUAGE: scala
CODE:
test("all even numbers") {
  val input: List[Int] = List(1, 2, 3, 4)
  val obtainedResults: List[Int] = input.map(_ * 2)
  // check that obtained values are all even numbers
  assert(obtainedResults.forall(x => x % 2 == 0))
}