TITLE: Configuring Root Route with Document-Level Components in Remix
DESCRIPTION: This snippet demonstrates how to set up the root route in a Remix application, including the use of document-level components like Links, Meta, and Scripts. It also shows how to include global stylesheets and set up the basic HTML structure.

LANGUAGE: tsx
CODE:
import type { LinksFunction } from "@remix-run/node"; // or cloudflare/deno
import {
  Links,
  LiveReload,
  Meta,
  Outlet,
  Scripts,
  ScrollRestoration,
} from "@remix-run/react";

import globalStylesheetUrl from "./global-styles.css";

export const links: LinksFunction = () => {
  return [{ rel: "stylesheet", href: globalStylesheetUrl }];
};

export default function App() {
  return (
    <html lang="en">
      <head>
        <meta charSet="utf-8" />
        <meta
          name="viewport"
          content="width=device-width, initial-scale=1"
        />

        {/* All `meta` exports on all routes will render here */}
        <Meta />

        {/* All `link` exports on all routes will render here */}
        <Links />
      </head>
      <body>
        {/* Child routes render here */}
        <Outlet />

        {/* Manages scroll position for client-side transitions */}
        {/* If you use a nonce-based content security policy for scripts, you must provide the `nonce` prop. Otherwise, omit the nonce prop as shown here. */}
        <ScrollRestoration />

        {/* Script tags go here */}
        {/* If you use a nonce-based content security policy for scripts, you must provide the `nonce` prop. Otherwise, omit the nonce prop as shown here. */}
        <Scripts />

        {/* Sets up automatic reload when you change code */}
        {/* and only does anything during development */}
        {/* If you use a nonce-based content security policy for scripts, you must provide the `nonce` prop. Otherwise, omit the nonce prop as shown here. */}
        <LiveReload />
      </body>
    </html>
  );
}

----------------------------------------

TITLE: Implementing User Session Validation in Remix
DESCRIPTION: This snippet demonstrates how to create a function that validates user sessions for protecting routes in Remix. It uses cookie-based session storage and redirects to login if no valid session is found.

LANGUAGE: typescript
CODE:
import {
  createCookieSessionStorage,
  redirect,
} from "@remix-run/node"; // or cloudflare/deno

// somewhere you've got a session storage
const { getSession } = createCookieSessionStorage();

export async function requireUserSession(request) {
  // get the session
  const cookie = request.headers.get("cookie");
  const session = await getSession(cookie);

  // validate the session, `userId` is just an example, use whatever value you
  // put in the session when the user authenticated
  if (!session.has("userId")) {
    // if there is no user session, redirect to login
    throw redirect("/login");
  }

  return session;
}

----------------------------------------

TITLE: Defining Route Module Exports in Remix
DESCRIPTION: This snippet shows the basic structure of a Remix route module with loader, component, and action exports. It demonstrates the three main parts of a route file that handle data loading, UI rendering, and data updates.

LANGUAGE: tsx
CODE:
export async function loader() {
  // provides data to the component
}

export default function Component() {
  // renders the UI
}

export async function action() {
  // updates persistent data
}

----------------------------------------

TITLE: Basic Remix Configuration Structure
DESCRIPTION: Basic configuration example showing the main options available in remix.config.js including app directory settings, assets configuration, and custom route definitions.

LANGUAGE: javascript
CODE:
/** @type {import('@remix-run/dev').AppConfig} */
module.exports = {
  appDirectory: "app",
  assetsBuildDirectory: "public/build",
  future: {
    /* any enabled future flags */
  },
  ignoredRouteFiles: ["**/*.css"],
  publicPath: "/build/",
  routes(defineRoutes) {
    return defineRoutes((route) => {
      route("/somewhere/cool/*", "catchall.tsx");
    });
  },
  serverBuildPath: "build/index.js",
};

----------------------------------------

TITLE: Implementing Form Validation Action in Remix TSX
DESCRIPTION: Shows how to implement a server-side action function that handles form validation for email and password fields, with error handling and redirection logic.

LANGUAGE: tsx
CODE:
import type { ActionFunctionArgs } from "@remix-run/node";
import { json, redirect } from "@remix-run/node";
import { Form } from "@remix-run/react";

export default function Signup() {
  // omitted for brevity
}

export async function action({
  request,
}: ActionFunctionArgs) {
  const formData = await request.formData();
  const email = String(formData.get("email"));
  const password = String(formData.get("password"));

  const errors = {};

  if (!email.includes("@")) {
    errors.email = "Invalid email address";
  }

  if (password.length < 12) {
    errors.password =
      "Password should be at least 12 characters";
  }

  if (Object.keys(errors).length > 0) {
    return json({ errors });
  }

  // Redirect to dashboard if validation is successful
  return redirect("/dashboard");
}

----------------------------------------

TITLE: Implementing BFF Pattern Loader Function in Remix TypeScript
DESCRIPTION: Demonstrates how to create a loader function that fetches data from an external API, authenticates using environment variables, and transforms the response data before sending to the client. Shows benefits of server-side processing including security, data pruning, and code optimization.

LANGUAGE: typescript
CODE:
import type { LoaderFunctionArgs } from "@remix-run/node"; // or cloudflare/deno
import { json } from "@remix-run/node"; // or cloudflare/deno
import escapeHtml from "escape-html";

export async function loader({
  request,
}: LoaderFunctionArgs) {
  const apiUrl = "http://api.example.com/some-data.json";
  const res = await fetch(apiUrl, {
    headers: {
      Authorization: `Bearer ${process.env.API_TOKEN}`,
    },
  });

  const data = await res.json();

  const prunedData = data.map((record) => {
    return {
      id: record.id,
      title: record.title,
      formattedBody: escapeHtml(record.content),
    };
  });
  return json(prunedData);
}

----------------------------------------

TITLE: Implementing Route Module with Server and Client Code in Remix
DESCRIPTION: Example of a complete route module showing server-side functions (loader, action, headers) and client-side component rendering. Demonstrates typical patterns for handling user data and form submissions in Remix.

LANGUAGE: tsx
CODE:
import type {
  ActionFunctionArgs,
  HeadersFunction,
  LoaderFunctionArgs,
} from "@remix-run/node"; // or cloudflare/deno
import { json } from "@remix-run/node"; // or cloudflare/deno
import { useLoaderData } from "@remix-run/react";

import { getUser, updateUser } from "../user";

export const headers: HeadersFunction = () => ({
  "Cache-Control": "max-age=300, s-maxage=3600",
});

export async function loader({
  request,
}: LoaderFunctionArgs) {
  const user = await getUser(request);
  return json({
    displayName: user.displayName,
    email: user.email,
  });
}

export default function Component() {
  const user = useLoaderData<typeof loader>();
  return (
    <Form action="/account">
      <h1>Settings for {user.displayName}</h1>

      <input
        name="displayName"
        defaultValue={user.displayName}
      />
      <input name="email" defaultValue={user.email} />

      <button type="submit">Save</button>
    </Form>
  );
}

export async function action({
  request,
}: ActionFunctionArgs) {
  const formData = await request.formData();
  const user = await getUser(request);

  await updateUser(user.id, {
    email: formData.get("email"),
    displayValue: formData.get("displayName"),
  });

  return json({ ok: true });
}

----------------------------------------

TITLE: Implementing Navigation Blocking with useBlocker in React Router
DESCRIPTION: This code snippet demonstrates how to use the useBlocker hook to prevent navigation when a form has unsaved changes. It shows how to conditionally render a confirmation dialog and handle proceed/cancel actions.

LANGUAGE: tsx
CODE:
function ImportantForm() {
  const [value, setValue] = React.useState("");

  // Block navigating elsewhere when data has been entered into the input
  const blocker = useBlocker(
    ({ currentLocation, nextLocation }) =>
      value !== "" &&
      currentLocation.pathname !== nextLocation.pathname
  );

  return (
    <Form method="post">
      <label>
        Enter some important data:
        <input
          name="data"
          value={value}
          onChange={(e) => setValue(e.target.value)}
        />
      </label>
      <button type="submit">Save</button>

      {blocker.state === "blocked" ? (
        <div>
          <p>Are you sure you want to leave?</p>
          <button onClick={() => blocker.proceed()}>
            Proceed
          </button>
          <button onClick={() => blocker.reset()}>
            Cancel
          </button>
        </div>
      ) : null}
    </Form>
  );
}

----------------------------------------

TITLE: Using Server and Client Loaders in Remix
DESCRIPTION: This example shows how to use both server and client loaders in a Remix route. The server loader fetches data from a database during SSR, while the client loader fetches data from an API during client-side navigation.

LANGUAGE: tsx
CODE:
export async function loader() {
  // During SSR, we talk to the DB directly
  const data = getServerDataFromDb();
  return json(data);
}

export async function clientLoader() {
  // During client-side navigations, we hit our exposed API endpoints directly
  const data = await fetchDataFromApi();
  return data;
}

export default function Component() {
  const data = useLoaderData<typeof loader>();
  return <>...</>;
}

----------------------------------------

TITLE: Implementing a Route Loader in Remix
DESCRIPTION: This code demonstrates how to create a loader function in a Remix route. It fetches user data and returns it as JSON, which will be available to the route component.

LANGUAGE: tsx
CODE:
import type { LoaderFunctionArgs } from "@remix-run/node"; // or cloudflare/deno
import { json } from "@remix-run/node"; // or cloudflare/deno

export async function loader({
  request,
}: LoaderFunctionArgs) {
  const user = await getUser(request);
  return json({
    displayName: user.displayName,
    email: user.email,
  });
}

export default function Component() {
  // ...
}

export async function action() {
  // ...
}

----------------------------------------

TITLE: Remix Route Module with Loader, Action, and Component
DESCRIPTION: This snippet showcases a complete Remix route module. It includes a loader for data fetching, an action for form handling, and a default export for the React component. It demonstrates how Remix combines server-side and client-side functionality in a single file.

LANGUAGE: tsx
CODE:
// Loaders only run on the server and provide data
// to your component on GET requests
export async function loader() {
  return json(await db.projects.findAll());
}

// The default export is the component that will be
// rendered when a route matches the URL. This runs
// both on the server and the client
export default function Projects() {
  const projects = useLoaderData<typeof loader>();
  const actionData = useActionData<typeof action>();

  return (
    <div>
      {projects.map((project) => (
        <Link key={project.slug} to={project.slug}>
          {project.title}
        </Link>
      ))}

      <Form method="post">
        <input name="title" />
        <button type="submit">Create New Project</button>
      </Form>
      {actionData?.errors ? (
        <ErrorMessages errors={actionData.errors} />
      ) : null}

      {/* outlets render the nested child routes
          that match the URL deeper than this route,
          allowing each layout to co-locate the UI and
          controller code in the same file */}
      <Outlet />
    </div>
  );
}

// Actions only run on the server and handle POST
// PUT, PATCH, and DELETE. They can also provide data
// to the component
export async function action({
  request,
}: ActionFunctionArgs) {
  const form = await request.formData();
  const errors = validate(form);
  if (errors) {
    return json({ errors });
  }
  await createProject({ title: form.get("title") });
  return json({ ok: true });
}

----------------------------------------

TITLE: Creating Custom Database Session Storage in Remix
DESCRIPTION: This example shows how to create a custom session storage using a database in Remix. It implements the required CRUD operations for managing session data.

LANGUAGE: typescript
CODE:
import { createSessionStorage } from "@remix-run/node"; // or cloudflare/deno

function createDatabaseSessionStorage({
  cookie,
  host,
  port,
}) {
  // Configure your database client...
  const db = createDatabaseClient(host, port);

  return createSessionStorage({
    cookie,
    async createData(data, expires) {
      // `expires` is a Date after which the data should be considered
      // invalid. You could use it to invalidate the data somehow or
      // automatically purge this record from your database.
      const id = await db.insert(data);
      return id;
    },
    async readData(id) {
      return (await db.select(id)) || null;
    },
    async updateData(id, data, expires) {
      await db.update(id, data);
    },
    async deleteData(id) {
      await db.delete(id);
    },
  });
}

const { getSession, commitSession, destroySession } =
  createDatabaseSessionStorage({
    host: "localhost",
    port: 1234,
    cookie: {
      name: "__session",
      sameSite: "lax",
    },
  });

----------------------------------------

TITLE: Creating a Progressive Search Box in Remix (TSX)
DESCRIPTION: This snippet shows how to create a search box component in Remix that works without JavaScript and can be progressively enhanced. It demonstrates using the URL as the source of truth and adding pending UI without changing the fundamental design.

LANGUAGE: tsx
CODE:
export function SearchBox() {
  return (
    <Form method="get" action="/search">
      <input type="search" name="query" />
      <SearchIcon />
    </Form>
  );
}

LANGUAGE: tsx
CODE:
import { useNavigation } from "@remix-run/react";

export function SearchBox() {
  const navigation = useNavigation();
  const isSearching =
    navigation.location.pathname === "/search";

  return (
    <Form method="get" action="/search">
      <input type="search" name="query" />
      {isSearching ? <Spinner /> : <SearchIcon />}
    </Form>
  );
}

----------------------------------------

TITLE: Implementing Add to Cart Functionality in Remix (TSX)
DESCRIPTION: This snippet demonstrates a simple Add to Cart button implementation using Remix's Form component. It shows how the feature works without JavaScript and then how it can be enhanced with client-side behavior using useFetcher.

LANGUAGE: tsx
CODE:
export function AddToCart({ id }) {
  return (
    <Form method="post" action="/add-to-cart">
      <input type="hidden" name="id" value={id} />
      <button type="submit">Add To Cart</button>
    </Form>
  );
}

LANGUAGE: tsx
CODE:
import { useFetcher } from "@remix-run/react";

export function AddToCart({ id }) {
  const fetcher = useFetcher();

  return (
    <fetcher.Form method="post" action="/add-to-cart">
      <input name="id" value={id} />
      <button type="submit">
        {fetcher.state === "submitting"
          ? "Adding..."
          : "Add To Cart"}
      </button>
    </fetcher.Form>
  );
}

----------------------------------------

TITLE: Loader Function with Database Query in Remix (TypeScript)
DESCRIPTION: Illustrates a loader function that queries a database using Prisma ORM. It fetches user data and returns it as JSON, demonstrating how server-only code is excluded from the browser bundle.

LANGUAGE: tsx
CODE:
import { useLoaderData } from "@remix-run/react";

import { prisma } from "../db";

export async function loader() {
  return json(await prisma.user.findMany());
}

export default function Users() {
  const data = useLoaderData<typeof loader>();
  return (
    <ul>
      {data.map((user) => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}

----------------------------------------

TITLE: Configuring Server Bundles with Vite Plugin in Remix
DESCRIPTION: Demonstrates how to configure the Remix Vite plugin to create separate server bundles for authenticated and unauthenticated routes. The serverBundles function analyzes the route branch to determine bundle assignment based on route path patterns.

LANGUAGE: typescript
CODE:
import { vitePlugin as remix } from "@remix-run/dev";
import { defineConfig } from "vite";

export default defineConfig({
  plugins: [
    remix({
      serverBundles: ({ branch }) => {
        const isAuthenticatedRoute = branch.some((route) =>
          route.id.split("/").includes("_authenticated")
        );

        return isAuthenticatedRoute
          ? "authenticated"
          : "unauthenticated";
      },
    }),
  ],
});

----------------------------------------

TITLE: Implementing Logout Functionality with Sessions in Remix
DESCRIPTION: This snippet demonstrates how to implement a logout route in Remix using sessions. It includes the action function to destroy the session and a simple logout form component.

LANGUAGE: tsx
CODE:
import { getSession, destroySession } from "../sessions";

export const action = async ({
  request,
}: ActionFunctionArgs) => {
  const session = await getSession(
    request.headers.get("Cookie")
  );
  return redirect("/login", {
    headers: {
      "Set-Cookie": await destroySession(session),
    },
  });
};

export default function LogoutRoute() {
  return (
    <>
      <p>Are you sure you want to log out?</p>
      <Form method="post">
        <button>Logout</button>
      </Form>
      <Link to="/">Never mind</Link>
    </>
  );
}

----------------------------------------

TITLE: Implementing Root Error Boundary in Remix
DESCRIPTION: Example showing how to create a root error boundary component in Remix. This component handles uncaught errors at the application root level and ensures proper rendering of Meta, Links, and Scripts components.

LANGUAGE: tsx
CODE:
export function ErrorBoundary() {
  const error = useRouteError();
  console.error(error);
  return (
    <html>
      <head>
        <title>Oh no!</title>
        <Meta />
        <Links />
      </head>
      <body>
        {/* add the UI you want your users to see */}
        <Scripts />
      </body>
    </html>
  );
}

----------------------------------------

TITLE: Canonical Link Meta Implementation
DESCRIPTION: Example demonstrating how to add canonical URL links using the meta function.

LANGUAGE: tsx
CODE:
export const meta: MetaFunction = () => {
  return [
    {
      tagName: "link",
      rel: "canonical",
      href: "https://remix.run",
    },
  ];
};

----------------------------------------

TITLE: Handling Multiple Forms in Remix Route
DESCRIPTION: This snippet demonstrates how to handle multiple forms in a single Remix route using the 'intent' field. It includes both the action function that processes different form submissions and the component rendering multiple forms.

LANGUAGE: typescript
CODE:
export async function action({
  request,
}: ActionFunctionArgs) {
  const formData = await request.formData();
  const intent = formData.get("intent");
  switch (intent) {
    case "update": {
      // do your update
      return updateProjectName(formData.get("name"));
    }
    case "delete": {
      // do your delete
      return deleteStuff(formData);
    }
    default: {
      throw new Error("Unexpected action");
    }
  }
}

export default function Projects() {
  const project = useLoaderData<typeof loader>();
  return (
    <>
      <h2>Update Project</h2>
      <Form method="post">
        <label>
          Project name:{" "}
          <input
            type="text"
            name="name"
            defaultValue={project.name}
          />
        </label>
        <button type="submit" name="intent" value="update">
          Update
        </button>
      </Form>

      <Form method="post">
        <button type="submit" name="intent" value="delete">
          Delete
        </button>
      </Form>
    </>
  );
}

----------------------------------------

TITLE: Defining Root Layout in Remix
DESCRIPTION: This code snippet demonstrates how to create a root layout component in Remix. It includes essential Remix components for handling links, meta tags, scripts, and rendering child routes.

LANGUAGE: tsx
CODE:
import {
  Links,
  Meta,
  Outlet,
  Scripts,
  ScrollRestoration,
} from "@remix-run/react";

export default function Root() {
  return (
    <html lang="en">
      <head>
        <Links />
        <Meta />
      </head>
      <body>
        <Outlet />
        <ScrollRestoration />
        <Scripts />
      </body>
    </html>
  );
}

----------------------------------------

TITLE: Accessing Request Object in Remix Loader (TypeScript)
DESCRIPTION: Shows how to use the request object in a loader to read headers and URL search parameters. This is useful for accessing cookies and query string data.

LANGUAGE: tsx
CODE:
export async function loader({
  request,
}: LoaderFunctionArgs) {
  // read a cookie
  const cookie = request.headers.get("Cookie");

  // parse the search params for `?q=`
  const url = new URL(request.url);
  const query = url.searchParams.get("q");
}

----------------------------------------

TITLE: Extended Remix Vite Plugin Configuration
DESCRIPTION: Comprehensive example showing various configuration options for the Remix Vite plugin, including basename, build directory, future flags, route ignoring, and custom routing.

LANGUAGE: javascript
CODE:
import { vitePlugin as remix } from "@remix-run/dev";
import { defineConfig } from "vite";

export default defineConfig({
  plugins: [
    remix({
      basename: "/",
      buildDirectory: "build",
      future: {
        /* any enabled future flags */
      },
      ignoredRouteFiles: ["**/*.css"],
      routes(defineRoutes) {
        return defineRoutes((route) => {
          route("/somewhere/cool/*", "catchall.tsx");
        });
      },
      serverBuildFile: "index.js",
    }),
  ],
});

----------------------------------------

TITLE: Implementing City Search Combobox with Remix
DESCRIPTION: Example implementation of a city search combobox component using Remix's useFetcher hook for handling network requests. Demonstrates automatic network management for rapid, consecutive search queries.

LANGUAGE: tsx
CODE:
import type { LoaderFunctionArgs } from "@remix-run/node"; // or cloudflare/deno
import { json } from "@remix-run/node"; // or cloudflare/deno

export async function loader({
  request,
}: LoaderFunctionArgs) {
  const { searchParams } = new URL(request.url);
  const cities = await searchCities(searchParams.get("q"));
  return json(cities);
}

export function CitySearchCombobox() {
  const fetcher = useFetcher<typeof loader>();

  return (
    <fetcher.Form action="/city-search">
      <Combobox aria-label="Cities">
        <ComboboxInput
          name="q"
          onChange={(event) =>
            // submit the form onChange to get the list of cities
            fetcher.submit(event.target.form)
          }
        />

        {/* render with the loader's data */}
        {fetcher.data ? (
          <ComboboxPopover className="shadow-popup">
            {fetcher.data.length > 0 ? (
              <ComboboxList>
                {fetcher.data.map((city) => (
                  <ComboboxOption
                    key={city.id}
                    value={city.name}
                  />
                ))}
              </ComboboxList>
            ) : (
              <span>No results found</span>
            )}
          </ComboboxPopover>
        ) : null}
      </Combobox>
    </fetcher.Form>
  );
}

----------------------------------------

TITLE: Implementing Layout Export in Remix Root Route
DESCRIPTION: This snippet shows how to use the optional Layout export in the root route of a Remix application. It demonstrates how to avoid duplicating the document structure across different components and handle error boundaries.

LANGUAGE: tsx
CODE:
import {
  Links,
  LiveReload,
  Meta,
  Outlet,
  Scripts,
  ScrollRestoration,
} from "@remix-run/react";

export function Layout({ children }) {
  return (
    <html lang="en">
      <head>
        <meta charSet="utf-8" />
        <meta
          name="viewport"
          content="width=device-width, initial-scale=1"
        />
        <Meta />
        <Links />
      </head>
      <body>
        {/* children will be the root Component, ErrorBoundary, or HydrateFallback */}
        {children}
        <Scripts />
        <ScrollRestoration />
        <LiveReload />
      </body>
    </html>
  );
}

export default function App() {
  return <Outlet />;
}

export function ErrorBoundary() {
  const error = useRouteError();

  if (isRouteErrorResponse(error)) {
    return (
      <>
        <h1>
          {error.status} {error.statusText}
        </h1>
        <p>{error.data}</p>
      </>
    );
  }

  return (
    <>
      <h1>Error!</h1>
      <p>{error?.message ?? "Unknown error"}</p>
    </>
  );
}

----------------------------------------

TITLE: Basic Data Loading with Remix Loader
DESCRIPTION: Example showing basic data loading in a Remix route using loader and useLoaderData hook to fetch and display a list of products.

LANGUAGE: tsx
CODE:
import { json } from "@remix-run/node";
import { useLoaderData } from "@remix-run/react";

export const loader = async () => {
  return json([
    { id: "1", name: "Pants" },
    { id: "2", name: "Jacket" },
  ]);
};

export default function Products() {
  const products = useLoaderData<typeof loader>();
  return (
    <div>
      <h1>Products</h1>
      {products.map((product) => (
        <div key={product.id}>{product.name}</div>
      ))}
    </div>
  );
}

----------------------------------------

TITLE: Using useLoaderData Hook in Remix (TSX)
DESCRIPTION: This snippet demonstrates how to use the useLoaderData hook to retrieve data from a loader function in a Remix application. It shows the loader function returning JSON data and the component accessing that data using useLoaderData.

LANGUAGE: tsx
CODE:
import { json } from "@remix-run/node"; // or cloudflare/deno
import { useLoaderData } from "@remix-run/react";

export async function loader() {
  return json(await fakeDb.invoices.findAll());
}

export default function Invoices() {
  const invoices = useLoaderData<typeof loader>();
  // ...
}

----------------------------------------

TITLE: Setting Cache-Control Headers in Remix Route Module
DESCRIPTION: Demonstrates how to export a headers function from a Remix route to set Cache-Control headers. This example sets a public cache with a max-age of 300 seconds for browsers and 3600 seconds for CDNs.

LANGUAGE: tsx
CODE:
export function headers() {
  return {
    "Cache-Control": "public, max-age=300, s-maxage=3600",
  };
}

export function meta() {
  /* ... */
}

export default function Gists() {
  /* ... */
}

----------------------------------------

TITLE: Implementing Deferred Data Loading
DESCRIPTION: Example of using Remix's defer utility to implement streamed data loading in a loader function.

LANGUAGE: tsx
CODE:
import type { LoaderFunctionArgs } from "@remix-run/node"; // or cloudflare/deno
import { defer } from "@remix-run/node"; // or cloudflare/deno
import { Await, useLoaderData } from "@remix-run/react";
import { Suspense } from "react";

import { ReviewsSkeleton } from "./reviews-skeleton";

export async function loader({
  params,
}: LoaderFunctionArgs) {
  const reviewsPromise = db.getReviews(params.productId);
  const product = await db.getProduct(params.productId);

  return defer({
    product,
    reviews: reviewsPromise,
  });
}

export default function Product() {
  const { product, reviews } =
    useLoaderData<typeof loader>();
  // existing code
}

----------------------------------------

TITLE: Creating and Using RemixStub for Unit Testing in Remix
DESCRIPTION: This snippet demonstrates how to create a RemixStub using createRemixStub for unit testing components that rely on Remix hooks and components. It shows setting up mocked routes with various properties like meta, links, Component, ErrorBoundary, action, and loader.

LANGUAGE: tsx
CODE:
import { createRemixStub } from "@remix-run/testing";

test("renders loader data", async () => {
  const RemixStub = createRemixStub([
    {
      path: "/",
      meta() {
        /* ... */
      },
      links() {
        /* ... */
      },
      Component: MyComponent,
      ErrorBoundary: MyErrorBoundary,
      action() {
        /* ... */
      },
      loader() {
        /* ... */
      },
    },
  ]);

  render(<RemixStub />);

  // Assert initial render
  await waitFor(() => screen.findByText("..."));

  // Click a button and assert a UI change
  user.click(screen.getByText("button text"));
  await waitFor(() => screen.findByText("..."));
});

----------------------------------------

TITLE: Implementing Client-Side Caching in Remix
DESCRIPTION: This snippet demonstrates how to implement client-side caching in Remix. It uses a server loader for initial data load, a clientLoader to manage the cache, and a clientAction to invalidate the cache when data changes.

LANGUAGE: tsx
CODE:
import type {
  ActionFunctionArgs,
  LoaderFunctionArgs,
} from "@remix-run/node";
import { json } from "@remix-run/node";
import type {
  ClientActionFunctionArgs,
  ClientLoaderFunctionArgs,
} from "@remix-run/react";

export async function loader({
  request,
}: LoaderFunctionArgs) {
  const data = await getDataFromDb({ request }); // (1)
  return json(data);
}

export async function action({
  request,
}: ActionFunctionArgs) {
  await saveDataToDb({ request });
  return json({ ok: true });
}

let isInitialRequest = true;

export async function clientLoader({
  request,
  serverLoader,
}: ClientLoaderFunctionArgs) {
  const cacheKey = generateKey(request);

  if (isInitialRequest) {
    isInitialRequest = false;
    const serverData = await serverLoader();
    cache.set(cacheKey, serverData); // (2)
    return serverData;
  }

  const cachedData = await cache.get(cacheKey);
  if (cachedData) {
    return cachedData; // (3)
  }

  const serverData = await serverLoader();
  cache.set(cacheKey, serverData);
  return serverData;
}
clientLoader.hydrate = true; // (2)

export async function clientAction({
  request,
  serverAction,
}: ClientActionFunctionArgs) {
  const cacheKey = generateKey(request);
  cache.delete(cacheKey); // (4)
  const serverData = await serverAction();
  return serverData;
}

----------------------------------------

TITLE: Implementing a Route Action in Remix
DESCRIPTION: This code shows how to create an action function in a Remix route. It handles form submissions, processes the form data, updates the user information, and returns a JSON response.

LANGUAGE: tsx
CODE:
import type {
  ActionFunctionArgs,
  LoaderFunctionArgs,
} from "@remix-run/node"; // or cloudflare/deno
import { json } from "@remix-run/node"; // or cloudflare/deno
import { useLoaderData, Form } from "@remix-run/react";

export async function loader({
  request,
}: LoaderFunctionArgs) {
  const user = await getUser(request);
  return json({
    displayName: user.displayName,
    email: user.email,
  });
}

export default function Component() {
  const user = useLoaderData<typeof loader>();
  return (
    <Form method="post" action="/account">
      <h1>Settings for {user.displayName}</h1>

      <input
        name="displayName"
        defaultValue={user.displayName}
      />
      <input name="email" defaultValue={user.email} />

      <button type="submit">Save</button>
    </Form>
  );
}

export async function action({
  request,
}: ActionFunctionArgs) {
  const formData = await request.formData();
  const user = await getUser(request);

  await updateUser(user.id, {
    email: formData.get("email"),
    displayName: formData.get("displayName"),
  });

  return json({ ok: true });
}

----------------------------------------

TITLE: Implementing Cloudinary File Upload Handler in Remix
DESCRIPTION: Demonstrates how to create a custom upload handler that processes image uploads and stores them in Cloudinary. Includes handling of multipart form data and composition with memory upload handler for fallback.

LANGUAGE: tsx
CODE:
import type {
  ActionFunctionArgs,
  UploadHandler,
} from "@remix-run/node"; // or cloudflare/deno
import {
  unstable_composeUploadHandlers,
  unstable_createMemoryUploadHandler,
  unstable_parseMultipartFormData,
} from "@remix-run/node"; // or cloudflare/deno
import { writeAsyncIterableToWritable } from "@remix-run/node"; // `writeAsyncIterableToWritable` is a Node-only utility
import type {
  UploadApiOptions,
  UploadApiResponse,
  UploadStream,
} from "cloudinary";
import cloudinary from "cloudinary";

async function uploadImageToCloudinary(
  data: AsyncIterable<Uint8Array>
) {
  const uploadPromise = new Promise<UploadApiResponse>(
    async (resolve, reject) => {
      const uploadStream =
        cloudinary.v2.uploader.upload_stream(
          {
            folder: "remix",
          },
          (error, result) => {
            if (error) {
              reject(error);
              return;
            }
            resolve(result);
          }
        );
      await writeAsyncIterableToWritable(
        data,
        uploadStream
      );
    }
  );

  return uploadPromise;
}

export const action = async ({
  request,
}: ActionFunctionArgs) => {
  const userId = getUserId(request);

  const uploadHandler = unstable_composeUploadHandlers(
    // our custom upload handler
    async ({ name, contentType, data, filename }) => {
      if (name !== "img") {
        return undefined;
      }
      const uploadedImage = await uploadImageToCloudinary(
        data
      );
      return uploadedImage.secure_url;
    },
    // fallback to memory for everything else
    unstable_createMemoryUploadHandler()
  );

  const formData = await unstable_parseMultipartFormData(
    request,
    uploadHandler
  );

  const imageUrl = formData.get("avatar");

  // because our uploadHandler returns a string, that's what the imageUrl will be.
  // ... etc
};

----------------------------------------

TITLE: Implementing Skip the Hop Pattern in Remix
DESCRIPTION: This snippet demonstrates how to skip the Remix server hop and hit the backend API directly using clientLoader. It loads data from the server loader on initial load and uses clientLoader for subsequent loads.

LANGUAGE: tsx
CODE:
import type { LoaderFunctionArgs } from "@remix-run/node";
import { json } from "@remix-run/node";
import type { ClientLoaderFunctionArgs } from "@remix-run/react";

export async function loader({
  request,
}: LoaderFunctionArgs) {
  const data = await fetchApiFromServer({ request }); // (1)
  return json(data);
}

export async function clientLoader({
  request,
}: ClientLoaderFunctionArgs) {
  const data = await fetchApiFromClient({ request }); // (2)
  return data;
}

----------------------------------------

TITLE: Using useActionData Hook with Form Submission in Remix
DESCRIPTION: This snippet demonstrates how to use the useActionData hook in a Remix application. It shows an action function that processes form data and returns a response, and a component that renders a form and displays the action data.

LANGUAGE: tsx
CODE:
import type { ActionFunctionArgs } from "@remix-run/node"; // or cloudflare/deno
import { json } from "@remix-run/node"; // or cloudflare/deno
import { Form, useActionData } from "@remix-run/react";

export async function action({
  request,
}: ActionFunctionArgs) {
  const body = await request.formData();
  const name = body.get("visitorsName");
  return json({ message: `Hello, ${name}` });
}

export default function Invoices() {
  const data = useActionData<typeof action>();
  return (
    <Form method="post">
      <input type="text" name="visitorsName" />
      {data ? data.message : "Waiting..."}
    </Form>
  );
}

----------------------------------------

TITLE: Creating and Checking Cookies in Remix
DESCRIPTION: Shows how to create a cookie with various options and how to check if an object is a Remix cookie container using the isCookie function.

LANGUAGE: typescript
CODE:
import { createCookie } from "@remix-run/node"; // or cloudflare/deno

const cookie = createCookie("cookie-name", {
  // all of these are optional defaults that can be overridden at runtime
  expires: new Date(Date.now() + 60_000),
  httpOnly: true,
  maxAge: 60,
  path: "/",
  sameSite: "lax",
  secrets: ["s3cret1"],
  secure: true,
});

LANGUAGE: typescript
CODE:
import { isCookie } from "@remix-run/node"; // or cloudflare/deno
const cookie = createCookie("user-prefs");
console.log(isCookie(cookie));
// true

----------------------------------------

TITLE: Cookie-based Persistent State Management
DESCRIPTION: Illustrates how to implement persistent state management using cookies in Remix, including both server-side and client-side handling.

LANGUAGE: tsx
CODE:
function Sidebar({ children }) {
  const fetcher = useFetcher();
  let { sidebarIsOpen } = useLoaderData<typeof loader>();

  if (fetcher.formData?.has("sidebar")) {
    sidebarIsOpen =
      fetcher.formData.get("sidebar") === "open";
  }

  return (
    <div>
      <fetcher.Form method="post">
        <button
          name="sidebar"
          value={sidebarIsOpen ? "closed" : "open"}
        >
          {sidebarIsOpen ? "Close" : "Open"}
        </button>
      </fetcher.Form>
      <aside hidden={!sidebarIsOpen}>{children}</aside>
    </div>
  );
}

----------------------------------------

TITLE: Error Handling in Remix Server Entry
DESCRIPTION: Implementation of handleError function for custom error logging and reporting. This function receives server-side errors and provides control over error handling, including the ability to send errors to external services. It includes logic to avoid logging aborted requests.

LANGUAGE: typescript
CODE:
export function handleError(
  error: unknown,
  {
    request,
    params,
    context,
  }: LoaderFunctionArgs | ActionFunctionArgs
) {
  if (!request.signal.aborted) {
    sendErrorToErrorReportingService(error);
    console.error(formatErrorForJsonLogging(error));
  }
}

----------------------------------------

TITLE: Implementing Defensive Layout Component in Remix Root Route
DESCRIPTION: This snippet demonstrates how to create a defensive Layout component in the root route of a Remix application. It shows how to handle both successful and error scenarios, and how to use useRouteLoaderData and useRouteError for conditional rendering.

LANGUAGE: tsx
CODE:
export function Layout({
  children,
}: {
  children: React.ReactNode;
}) {
  const data = useRouteLoaderData("root");
  const error = useRouteError();

  return (
    <html lang="en">
      <head>
        <meta charSet="utf-8" />
        <meta
          name="viewport"
          content="width=device-width, initial-scale=1"
        />
        <Meta />
        <Links />
        <style
          dangerouslySetInnerHTML={{
            __html: `
              :root {
                --themeVar: ${
                  data?.themeVar || defaultThemeVar
                }
              }
            `,
          }}
        />
      </head>
      <body>
        {data ? (
          <Analytics token={data.analyticsToken} />
        ) : null}
        {children}
        <ScrollRestoration />
        <Scripts />
      </body>
    </html>
  );
}

----------------------------------------

TITLE: Implementing clientAction in Remix TSX
DESCRIPTION: Demonstrates how to define a clientAction function that runs on the client-side to handle mutations. It receives params, request, and serverAction as arguments and can be used for cache invalidation and data handling.

LANGUAGE: tsx
CODE:
export const clientAction = async ({
  request,
  params,
  serverAction,
}: ClientActionFunctionArgs) => {
  invalidateClientSideCache();
  const data = await serverAction();
  return data;
};

----------------------------------------

TITLE: Remix Action Function for Project Creation
DESCRIPTION: Implements a Remix action function to handle the project creation form submission.

LANGUAGE: TypeScript
CODE:
export async function action({
  request,
}: ActionFunctionArgs) {
  const body = await request.formData();
  const project = await createProject(body);
  return redirect(`/projects/${project.id}`);
}

----------------------------------------

TITLE: Setting Up Root Route Component
DESCRIPTION: Configuring the main layout and routing structure in the root component with navigation and outlet setup

LANGUAGE: tsx
CODE:
import {
  Form,
  Links,
  Meta,
  Scripts,
  ScrollRestoration,
} from "@remix-run/react";

export default function App() {
  return (
    <html lang="en">
      <head>
        <meta charSet="utf-8" />
        <meta
          name="viewport"
          content="width=device-width, initial-scale=1"
        />
        <Meta />
        <Links />
      </head>
      <body>
        <div id="sidebar">
          <h1>Remix Contacts</h1>
          <div>
            <Form id="search-form" role="search">
              <input
                aria-label="Search contacts"
                id="q"
                name="q"
                placeholder="Search"
                type="search"
              />
              <div
                aria-hidden
                hidden={true}
                id="search-spinner"
              />
            </Form>
            <Form method="post">
              <button type="submit">New</button>
            </Form>
          </div>
          <nav>
            <ul>
              <li>
                <a href={`/contacts/1`}>Your Name</a>
              </li>
              <li>
                <a href={`/contacts/2`}>Your Friend</a>
              </li>
            </ul>
          </nav>
        </div>

        <ScrollRestoration />
        <Scripts />
      </body>
    </html>
  );

----------------------------------------

TITLE: Implementing Optimistic UI for Record Updates in Remix
DESCRIPTION: This snippet demonstrates how to use useFetcher to implement optimistic UI for record updates, allowing immediate UI feedback before server confirmation in a Remix application.

LANGUAGE: tsx
CODE:
import { useFetcher } from "@remix-run/react";

function ProjectListItem({ project }) {
  const fetcher = useFetcher();

  const starred = fetcher.formData
    ? // use optimistic value if submitting
      fetcher.formData.get("starred") === "1"
    : // fall back to the database state
      project.starred;

  return (
    <>
      <div>{project.name}</div>
      <fetcher.Form method="post">
        <button
          type="submit"
          name="starred"
          // use optimistic value to allow interruptions
          value={starred ? "0" : "1"}
        >
          {/* 👇 display optimistic value */}
          {starred ? "★" : "☆"}
        </button>
      </fetcher.Form>
    </>
  );
}

----------------------------------------

TITLE: Implementing File Upload Handler in Remix Action Function
DESCRIPTION: This snippet demonstrates how to use unstable_createFileUploadHandler in combination with unstable_composeUploadHandlers and unstable_createMemoryUploadHandler to handle file uploads in a Remix action function. It sets up a handler for files with a 5MB size limit and processes the uploaded avatar file.

LANGUAGE: tsx
CODE:
export const action = async ({
  request,
}: ActionFunctionArgs) => {
  const uploadHandler = unstable_composeUploadHandlers(
    unstable_createFileUploadHandler({
      maxPartSize: 5_000_000,
      file: ({ filename }) => filename,
    }),
    // parse everything else into memory
    unstable_createMemoryUploadHandler()
  );
  const formData = await unstable_parseMultipartFormData(
    request,
    uploadHandler
  );

  const file = formData.get("avatar");

  // file is a "NodeOnDiskFile" which implements the "File" API
  // ... etc
};

----------------------------------------

TITLE: Providing Context with Outlet Component
DESCRIPTION: Shows how to pass context data to child routes using the context prop of the Outlet component. This allows parent routes to share data with their child routes.

LANGUAGE: tsx
CODE:
<Outlet context={myContextValue} />

----------------------------------------

TITLE: Fetcher Form Component Usage
DESCRIPTION: Example showing how to use the fetcher.Form component for form submissions without navigation.

LANGUAGE: tsx
CODE:
function SomeComponent() {
  const fetcher = useFetcher();
  return (
    <fetcher.Form method="post" action="/some/route">
      <input type="text" />
    </fetcher.Form>
  );
}

----------------------------------------

TITLE: Using useFormAction Hook in Remix (TSX)
DESCRIPTION: Demonstrates how to import and use the useFormAction hook in a React component. It shows examples of using the hook with and without an argument to resolve the closest route URL.

LANGUAGE: tsx
CODE:
import { useFormAction } from "@remix-run/react";

function SomeComponent() {
  // closest route URL
  const action = useFormAction();

  // closest route URL + "destroy"
  const destroyAction = useFormAction("destroy");
}

----------------------------------------

TITLE: Error Response Handling in Remix Loader
DESCRIPTION: Example demonstrating how to throw and handle custom error responses in Remix loaders, including error sanitization and custom error messages

LANGUAGE: tsx
CODE:
export async function loader() {
  if (badConditionIsTrue()) {
    throw new Response("Oh no! Something went wrong!", {
      status: 500,
    });
  }
}

export function ErrorBoundary() {
  const error = useRouteError();
  if (isRouteErrorResponse(error)) {
    // error.status = 500
    // error.data = "Oh no! Something went wrong!"
  }
}

----------------------------------------

TITLE: NavLink with Dynamic Style Prop in Remix
DESCRIPTION: Illustrates how to use the style prop callback to dynamically style a NavLink based on its active and pending states.

LANGUAGE: tsx
CODE:
<NavLink
  to="/messages"
  style={({ isActive, isPending }) => {
    return {
      fontWeight: isActive ? "bold" : "",
      color: isPending ? "red" : "black",
    };
  }}
>
  Messages
</NavLink>

----------------------------------------

TITLE: Visualizing Request Flow with ASCII Diagrams
DESCRIPTION: ASCII diagrams demonstrating how Remix handles multiple concurrent submissions and request cancellation patterns. Shows timing of submissions, actions, and UI updates.

LANGUAGE: text
CODE:
submission 1: |----✓-----✅
submission 2:    |-----✓-----✅
submission 3:             |-----✓-----✅

LANGUAGE: text
CODE:
submission 1: |----✓---------❌
submission 2:    |-----✓-----✅
submission 3:             |-----✓-----✅

LANGUAGE: text
CODE:
     👇 interruption with new submission
|----❌----------------------✓
       |-------✓-----✅
                             👆
                  initial request reaches the server
                  after the interrupting submission
                  has completed revalidation

----------------------------------------

TITLE: Aggregating Breadcrumbs in Root Route using useMatches in Remix
DESCRIPTION: This code snippet shows how to aggregate breadcrumbs in the root route of a Remix application using the useMatches hook. It filters matches with breadcrumb handles and renders them in the header.

LANGUAGE: tsx
CODE:
import {
  Links,
  Scripts,
  useLoaderData,
  useMatches,
} from "@remix-run/react";

export default function Root() {
  const matches = useMatches();

  return (
    <html lang="en">
      <head>
        <Links />
      </head>
      <body>
        <header>
          <ol>
            {matches
              .filter(
                (match) =>
                  match.handle && match.handle.breadcrumb
              )
              .map((match, index) => (
                <li key={index}>
                  {match.handle.breadcrumb(match)}
                </li>
              ))}
          </ol>
        </header>
        <Outlet />
      </body>
    </html>
  );
}

----------------------------------------

TITLE: Throwing Responses in Remix Loader (TypeScript)
DESCRIPTION: Illustrates how to throw Response objects from loaders for redirects or showing alternative UI. The example includes utility functions for handling not found and authentication scenarios.

LANGUAGE: ts
CODE:
import { json } from "@remix-run/node"; // or cloudflare/deno

export function getInvoice(id) {
  const invoice = db.invoice.find({ where: { id } });
  if (invoice === null) {
    throw json("Not Found", { status: 404 });
  }
  return invoice;
}

LANGUAGE: ts
CODE:
import { redirect } from "@remix-run/node"; // or cloudflare/deno

import { getSession } from "./session";

export async function requireUserSession(request) {
  const session = await getSession(
    request.headers.get("cookie")
  );
  if (!session) {
    throw redirect("/login", 302);
  }
  return session.get("user");
}

LANGUAGE: tsx
CODE:
import type { LoaderFunctionArgs } from "@remix-run/node"; // or cloudflare/deno
import { json } from "@remix-run/node"; // or cloudflare/deno
import {
  isRouteErrorResponse,
  useLoaderData,
  useRouteError,
} from "@remix-run/react";

import { getInvoice } from "~/db";
import { requireUserSession } from "~/http";

export const loader = async ({
  params,
  request,
}: LoaderFunctionArgs) => {
  const user = await requireUserSession(request);
  const invoice = getInvoice(params.invoiceId);

  if (!invoice.userIds.includes(user.id)) {
    throw json(
      { invoiceOwnerEmail: invoice.owner.email },
      { status: 401 }
    );
  }

  return json(invoice);
};

export default function InvoiceRoute() {
  const invoice = useLoaderData<typeof loader>();
  return <InvoiceView invoice={invoice} />;
}

export function ErrorBoundary() {
  const error = useRouteError();

  if (isRouteErrorResponse(error)) {
    switch (error.status) {
      case 401:
        return (
          <div>
            <p>You don't have access to this invoice.</p>
            <p>
              Contact {error.data.invoiceOwnerEmail} to get
              access
            </p>
          </div>
        );
      case 404:
        return <div>Invoice not found!</div>;
    }

    return (
      <div>
        Something went wrong: {error.status}{" "}
        {error.statusText}
      </div>
    );
  }

  return (
    <div>
      Something went wrong:{" "}
      {error?.message || "Unknown Error"}
    </div>
  );
}

----------------------------------------

TITLE: Implementing Action and Loader Functions in Remix
DESCRIPTION: This snippet demonstrates how to implement action and loader functions in a Remix route. It includes handling form submissions, creating todos, and fetching todos.

LANGUAGE: tsx
CODE:
import type { ActionFunctionArgs } from "@remix-run/node"; // or cloudflare/deno
import { json, redirect } from "@remix-run/node"; // or cloudflare/deno
import { Form } from "@remix-run/react";

import { TodoList } from "~/components/TodoList";
import { fakeCreateTodo, fakeGetTodos } from "~/utils/db";

export async function action({
  request,
}: ActionFunctionArgs) {
  const body = await request.formData();
  const todo = await fakeCreateTodo({
    title: body.get("title"),
  });
  return redirect(`/todos/${todo.id}`);
}

export async function loader() {
  return json(await fakeGetTodos());
}

export default function Todos() {
  const data = useLoaderData<typeof loader>();
  return (
    <div>
      <TodoList todos={data} />
      <Form method="post">
        <input type="text" name="title" />
        <button type="submit">Create Todo</button>
      </Form>
    </div>
  );
}

----------------------------------------

TITLE: Using useRouteError Hook in Remix ErrorBoundary
DESCRIPTION: Demonstrates how to implement an ErrorBoundary component using the useRouteError hook to access and display error messages from actions, loaders, or rendering processes.

LANGUAGE: jsx
CODE:
export function ErrorBoundary() {
  const error = useRouteError();
  return <div>{error.message}</div>;
}

----------------------------------------

TITLE: Fetcher Load Method Usage
DESCRIPTION: Examples of using the fetcher.load method to load data from route loaders.

LANGUAGE: ts
CODE:
fetcher.load("/some/route");
fetcher.load("/some/route?foo=bar");

----------------------------------------

TITLE: Defining Link Elements with LinksFunction in Remix (TSX)
DESCRIPTION: This snippet demonstrates how to use the LinksFunction to define various types of <link> elements for a Remix route, including icons, stylesheets, and preloaded resources.

LANGUAGE: tsx
CODE:
import type { LinksFunction } from "@remix-run/node"; // or cloudflare/deno

export const links: LinksFunction = () => {
  return [
    {
      rel: "icon",
      href: "/favicon.png",
      type: "image/png",
    },
    {
      rel: "stylesheet",
      href: "https://example.com/some/styles.css",
    },
    { page: "/users/123" },
    {
      rel: "preload",
      href: "/images/banner.jpg",
      as: "image",
    },
  ];
};

----------------------------------------

TITLE: Basic Redirect Usage in Remix Action
DESCRIPTION: Demonstrates basic usage of redirect function within a Remix action handler, showing how to redirect to a login page when user session is not found.

LANGUAGE: tsx
CODE:
import { redirect } from "@remix-run/node"; // or cloudflare/deno

export const action = async () => {
  const userSession = await getUserSessionOrWhatever();

  if (!userSession) {
    return redirect("/login");
  }

  return json({ ok: true });
};

----------------------------------------

TITLE: Creating a Remix Stub for Testing in TSX
DESCRIPTION: This snippet demonstrates how to create a Remix stub using createRemixStub for testing purposes. It defines a route with a component and a loader function.

LANGUAGE: tsx
CODE:
import { createRemixStub } from "@remix-run/testing";

const RemixStub = createRemixStub([
  {
    path: "/",
    Component: MyComponent,
    loader() {
      return json({ message: "hello" });
    },
  },
]);

----------------------------------------

TITLE: Basic Loader Function in Remix (TypeScript)
DESCRIPTION: Demonstrates a simple loader function that returns JSON data. This function runs only on the server and provides data to the route when rendering.

LANGUAGE: tsx
CODE:
import { json } from "@remix-run/node"; // or cloudflare/deno

export const loader = async () => {
  return json({ ok: true });
};

----------------------------------------

TITLE: Basic Defer Usage in Remix TSX
DESCRIPTION: Demonstrates the basic usage of defer function for handling streaming responses with promises. The function allows returning both immediate data and pending promises without awaiting them.

LANGUAGE: tsx
CODE:
import { defer } from "@remix-run/node"; // or cloudflare/deno

export const loader = async () => {
  const aStillRunningPromise = loadSlowDataAsync();

  // So you can write this without awaiting the promise:
  return defer({
    critical: "data",
    slowPromise: aStillRunningPromise,
  });
};

----------------------------------------

TITLE: Complete Options Configuration Example
DESCRIPTION: Example showing all available options for the submit function including action, method, encType, and other configuration parameters.

LANGUAGE: tsx
CODE:
submit(data, {
  action: "",
  method: "post",
  encType: "application/x-www-form-urlencoded",
  preventScrollReset: false,
  replace: false,
  relative: "route",
});

----------------------------------------

TITLE: Configuring Remix Vite plugin
DESCRIPTION: Example of how to configure the Remix Vite plugin in a vite.config.ts file

LANGUAGE: typescript
CODE:
import { vitePlugin as remix } from "@remix-run/dev";
import { defineConfig } from "vite";

export default defineConfig({
  plugins: [remix()],
});

----------------------------------------

TITLE: Using useRouteLoaderData Hook in Remix TSX
DESCRIPTION: Demonstrates how to import and use the useRouteLoaderData hook to access loader data from a specific route. The example shows accessing user data from the root route.

LANGUAGE: tsx
CODE:
import { useRouteLoaderData } from "@remix-run/react";

function SomeComponent() {
  const { user } = useRouteLoaderData("root");
}

----------------------------------------

TITLE: Optimizing Revalidation with URL Parameters
DESCRIPTION: This snippet shows how to use currentParams and nextParams in shouldRevalidate to optimize revalidation based on changes in URL parameters.

LANGUAGE: tsx
CODE:
export async function loader({
  params,
}: LoaderFunctionArgs) {
  const id = params.slug.split("--")[1];
  return loadEvent(id);
}

export function shouldRevalidate({
  currentParams,
  nextParams,
  defaultShouldRevalidate,
}) {
  const currentId = currentParams.slug.split("--")[1];
  const nextId = nextParams.slug.split("--")[1];
  if (currentId === nextId) {
    return false;
  }

  return defaultShouldRevalidate;
}

----------------------------------------

TITLE: Updating a Record with Fetcher in Remix
DESCRIPTION: This example shows how to use useFetcher to delete a recipe from a list without navigating away from the page. It includes the route setup for fetching recipes and the component for rendering list items with delete functionality.

LANGUAGE: tsx
CODE:
import type { LoaderFunctionArgs } from "@remix-run/node"; // or cloudflare/deno
import { json } from "@remix-run/node"; // or cloudflare/deno
import { useLoaderData } from "@remix-run/react";

export async function loader({
  request,
}: LoaderFunctionArgs) {
  return json({
    recipes: await db.recipes.findAll({ limit: 30 }),
  });
}

export default function Recipes() {
  const { recipes } = useLoaderData<typeof loader>();
  return (
    <ul>
      {recipes.map((recipe) => (
        <RecipeListItem key={recipe.id} recipe={recipe} />
      ))}
    </ul>
  );
}

export async function action({
  request,
}: ActionFunctionArgs) {
  const formData = await request.formData();
  const id = formData.get("id");
  await db.recipes.delete(id);
  return json({ ok: true });
}

const RecipeListItem: FunctionComponent<{
  recipe: Recipe;
}> = ({ recipe }) => {
  const fetcher = useFetcher();
  const isDeleting = fetcher.state !== "idle";

  return (
    <li>
      <h2>{recipe.title}</h2>
      <fetcher.Form method="post">
        <button disabled={isDeleting} type="submit">
          {isDeleting ? "Deleting..." : "Delete"}
        </button>
      </fetcher.Form>
    </li>
  );
};

----------------------------------------

TITLE: Server Code Isolation in Remix Routes
DESCRIPTION: Demonstrates how to properly handle server-only code imports in Remix routes by using .server.ts files to prevent server code from being bundled into client-side JavaScript.

LANGUAGE: typescript
CODE:
import { json } from "@remix-run/node";
import fs from "~/utils/fs-extra.server";

export async function loader() {
  return json(await fs.pathExists("../some/path"));
}

export default function SomeRoute() {
  // ...
}

----------------------------------------

TITLE: Accessing URL Parameters in Remix Loader
DESCRIPTION: This code snippet shows how to access URL parameters in a Remix loader function. It demonstrates using the params object to retrieve dynamic segments from the URL.

LANGUAGE: tsx
CODE:
export async function loader({
  params,
}: LoaderFunctionArgs) {
  return fakeDb.getAllConcertsForCity(params.city);
}

----------------------------------------

TITLE: Implementing ErrorBoundary Component in Remix with TypeScript
DESCRIPTION: Example implementation of an ErrorBoundary component that handles both route error responses and runtime errors. It uses useRouteError hook to access the error object and isRouteErrorResponse utility to differentiate between different types of errors.

LANGUAGE: tsx
CODE:
import {
  isRouteErrorResponse,
  useRouteError,
} from "@remix-run/react";

export function ErrorBoundary() {
  const error = useRouteError();

  if (isRouteErrorResponse(error)) {
    return (
      <div>
        <h1>
          {error.status} {error.statusText}
        </h1>
        <p>{error.data}</p>
      </div>
    );
  } else if (error instanceof Error) {
    return (
      <div>
        <h1>Error</h1>
        <p>{error.message}</p>
        <p>The stack trace is:</p>
        <pre>{error.stack}</pre>
      </div>
    );
  } else {
    return <h1>Unknown Error</h1>;
  }
}

----------------------------------------

TITLE: Basic Route Module Without Streaming
DESCRIPTION: Example of a typical Remix route module implementation without streaming, showing synchronous data loading and rendering.

LANGUAGE: tsx
CODE:
import type { LoaderFunctionArgs } from "@remix-run/node"; // or cloudflare/deno
import { json } from "@remix-run/node"; // or cloudflare/deno
import { useLoaderData } from "@remix-run/react";

export async function loader({
  params,
}: LoaderFunctionArgs) {
  const [product, reviews] = await Promise.all([
    db.getProduct(params.productId),
    db.getReviews(params.productId),
  ]);

  return json({ product, reviews });
}

export default function Product() {
  const { product, reviews } =
    useLoaderData<typeof loader>();
  return (
    <>
      <ProductPage data={product} />
      <ProductReviews data={reviews} />
    </>
  );
}

----------------------------------------

TITLE: Using Outlet Component in Remix Parent Route
DESCRIPTION: Demonstrates how to use the Outlet component to render child routes within a parent route component. The Outlet acts as a placeholder where child route content will be rendered.

LANGUAGE: tsx
CODE:
import { Outlet } from "@remix-run/react";

export default function SomeParent() {
  return (
    <div>
      <h1>Parent Content</h1>

      <Outlet />
    </div>
  );
}

----------------------------------------

TITLE: Implementing Periodic Data Revalidation with useRevalidator in React
DESCRIPTION: This code snippet shows how to use useRevalidator to periodically revalidate page data. It uses a custom interval hook and triggers revalidation every 5 seconds when the revalidator is idle.

LANGUAGE: tsx
CODE:
function useLivePageData() {
  const revalidator = useRevalidator();
  const interval = useInterval(5000);

  useEffect(() => {
    if (revalidator.state === "idle") {
      revalidator.revalidate();
    }
  }, [interval, revalidator]);
}

----------------------------------------

TITLE: Pseudocode for Remix Request Handler Adaptation
DESCRIPTION: Illustrates the conceptual flow of how Remix adapters convert between server-specific requests/responses and Web Fetch API requests/responses.

LANGUAGE: typescript
CODE:
// import the app build created by `remix build`
import build from "./build/index.js";

// an express http server
const app = express();

// and here your Remix app is "just a request handler"
app.all("*", createRequestHandler({ build }));

// This is pseudo code, but illustrates what adapters do:
export function createRequestHandler({ build }) {
  // creates a Fetch API request handler from the server build
  const handleRequest = createRemixRequestHandler(build);

  // returns an express.js specific handler for the express server
  return async (req, res) => {
    // adapts the express.req to a Fetch API request
    const request = createRemixRequest(req);

    // calls the app handler and receives a Fetch API response
    const response = await handleRequest(request);

    // adapts the Fetch API response to the express.res
    sendRemixResponse(res, response);
  };
}

----------------------------------------

TITLE: Importing Assets in Remix TSX Components
DESCRIPTION: Demonstrates how to import and use asset files (images and CSS) in a Remix component. The example shows importing a banner image and CSS file, setting up stylesheet links using LinksFunction, and rendering the imported assets in a React component.

LANGUAGE: tsx
CODE:
import type { LinksFunction } from "@remix-run/node"; // or cloudflare/deno

import banner from "./images/banner.jpg";
import styles from "./styles/app.css";

export const links: LinksFunction = () => [
  { rel: "stylesheet", href: styles },
];

export default function Page() {
  return (
    <div>
      <h1>Some Page</h1>
      <img src={banner} />
    </div>
  );
}

----------------------------------------

TITLE: Creating a PDF Report Resource Route in Remix
DESCRIPTION: Implements a resource route that generates and returns a PDF report based on the request parameters.

LANGUAGE: tsx
CODE:
export async function loader({
  params,
}: LoaderFunctionArgs) {
  const report = await getReport(params.id);
  const pdf = await generateReportPDF(report);
  return new Response(pdf, {
    status: 200,
    headers: {
      "Content-Type": "application/pdf",
    },
  });
}

----------------------------------------

TITLE: Search Query Meta Implementation
DESCRIPTION: Example showing how to use location parameters to generate dynamic meta tags.

LANGUAGE: tsx
CODE:
export const meta: MetaFunction = ({ location }) => {
  const searchQuery = new URLSearchParams(
    location.search
  ).get("q");
  return [{ title: `Search results for "${searchQuery}"` }];
};

----------------------------------------

TITLE: Enhanced Remix Route Module with Client-Side Optimizations
DESCRIPTION: This snippet demonstrates an enhanced version of the Remix route module with client-side optimizations. It includes features like disabling the submit button during form submission, focusing on the input field after validation errors, and animating error messages.

LANGUAGE: tsx
CODE:
export default function Projects() {
  const projects = useLoaderData<typeof loader>();
  const actionData = useActionData<typeof action>();
  const { state } = useNavigation();
  const busy = state === "submitting";
  const inputRef = React.useRef();

  React.useEffect(() => {
    if (actionData.errors) {
      inputRef.current.focus();
    }
  }, [actionData]);

  return (
    <div>
      {projects.map((project) => (
        <Link key={project.slug} to={project.slug}>
          {project.title}
        </Link>
      ))}

      <Form method="post">
        <input ref={inputRef} name="title" />
        <button type="submit" disabled={busy}>
          {busy ? "Creating..." : "Create New Project"}
        </button>
      </Form>

      {actionData?.errors ? (
        <FadeIn>
          <ErrorMessages errors={actionData.errors} />
        </FadeIn>
      ) : null}

      <Outlet />
    </div>
  );
}

----------------------------------------

TITLE: Await Component with Resolve Prop
DESCRIPTION: Shows how to use the resolve prop to handle promises from useLoaderData.

LANGUAGE: tsx
CODE:
<Await resolve={somePromise} />

----------------------------------------

TITLE: Database Integration with Prisma
DESCRIPTION: Demonstrates how to integrate a database (Prisma) in a Remix loader to fetch data from a database.

LANGUAGE: tsx
CODE:
import type { LoaderFunctionArgs } from "@remix-run/node";
import { json } from "@remix-run/node";
import { useLoaderData } from "@remix-run/react";

import { db } from "~/db.server";

export const loader = async ({
  params,
}: LoaderFunctionArgs) => {
  return json(
    await db.product.findMany({
      where: {
        categoryId: params.categoryId,
      },
    })
  );
};

export default function ProductCategory() {
  const products = useLoaderData<typeof loader>();
  return (
    <div>
      <p>{products.length} Products</p>
    </div>
  );
}

----------------------------------------

TITLE: Client-Side Bundle After Build Process in Remix
DESCRIPTION: Shows how the route module is transformed for client-side execution after the build process removes server-only code (action, headers, and loader functions).

LANGUAGE: tsx
CODE:
import { useLoaderData } from "@remix-run/react";

export default function Component() {
  const user = useLoaderData();
  return (
    <Form action="/account">
      <h1>Settings for {user.displayName}</h1>

      <input
        name="displayName"
        defaultValue={user.displayName}
      />
      <input name="email" defaultValue={user.email} />

      <button type="submit">Save</button>
    </Form>
  );
}

----------------------------------------

TITLE: Configuring Client-Side Hydration in Remix
DESCRIPTION: Demonstrates the basic setup for hydrating a Remix application on the client side using ReactDOM.hydrateRoot. The code initializes the client-side rendering and wraps the RemixBrowser component in StrictMode for enhanced development checks.

LANGUAGE: tsx
CODE:
import { RemixBrowser } from "@remix-run/react";
import { startTransition, StrictMode } from "react";
import { hydrateRoot } from "react-dom/client";

startTransition(() => {
  hydrateRoot(
    document,
    <StrictMode>
      <RemixBrowser />
    </StrictMode>
  );
});

----------------------------------------

TITLE: Using useLocation Hook in Remix (TSX)
DESCRIPTION: Demonstrates how to import and use the useLocation hook from @remix-run/react to access the current location object in a React component.

LANGUAGE: tsx
CODE:
import { useLocation } from "@remix-run/react";

function SomeComponent() {
  const location = useLocation();
  // ...
}

----------------------------------------

TITLE: Pseudocode for Remix Adapter Implementation
DESCRIPTION: This snippet illustrates the concept of a Remix adapter using pseudocode. It shows how an adapter converts server-specific requests and responses to and from the Fetch API used by Remix.

LANGUAGE: typescript
CODE:
export function createRequestHandler({ build }) {
  // creates a Fetch API request handler from the server build
  const handleRequest = createRemixRequestHandler(build);

  // returns an express.js specific handler for the express server
  return async (req, res) => {
    // adapts the express.req to a Fetch API request
    const request = createRemixRequest(req);

    // calls the app handler and receives a Fetch API response
    const response = await handleRequest(request);

    // adapts the Fetch API response to the express.res
    sendRemixResponse(res, response);
  };
}

----------------------------------------

TITLE: Setting Cookie Attributes in Remix
DESCRIPTION: Illustrates how to set various cookie attributes when creating a cookie or during serialization. This example shows default attributes and how to override them.

LANGUAGE: typescript
CODE:
const cookie = createCookie("user-prefs", {
  // These are defaults for this cookie.
  path: "/",
  sameSite: "lax",
  httpOnly: true,
  secure: true,
  expires: new Date(Date.now() + 60_000),
  maxAge: 60,
});

// You can either use the defaults:
cookie.serialize(userPrefs);

// Or override individual ones as needed:
cookie.serialize(userPrefs, { sameSite: "strict" });

----------------------------------------

TITLE: Creating a Cookie in Remix
DESCRIPTION: Demonstrates how to create a cookie using the createCookie function from Remix. This example creates a cookie named 'user-prefs' with a one-week expiration.

LANGUAGE: typescript
CODE:
import { createCookie } from "@remix-run/node"; // or cloudflare/deno

export const userPrefs = createCookie("user-prefs", {
  maxAge: 604_800, // one week
});

----------------------------------------

TITLE: Defining a Route Component in Remix using React and TypeScript
DESCRIPTION: This code snippet demonstrates how to create a basic route component in Remix. The component is defined as the default export of a route module and returns a simple JSX structure with a heading and a paragraph.

LANGUAGE: tsx
CODE:
export default function MyRouteComponent() {
  return (
    <div>
      <h1>Look ma!</h1>
      <p>I'm still using React after like 8 years.</p>
    </div>
  );
}

----------------------------------------

TITLE: Integrating Remix with Express.js Server
DESCRIPTION: This snippet demonstrates how to integrate Remix with an Express.js server. It shows the basic setup for creating a request handler that uses Remix to handle all routes.

LANGUAGE: typescript
CODE:
const remix = require("@remix-run/express");
const express = require("express");

const app = express();

app.all(
  "*",
  remix.createRequestHandler({
    build: require("./build/server"),
  })
);

----------------------------------------

TITLE: Implementing UI Route with PDF Link in Remix
DESCRIPTION: Example of a UI Route component that displays a report and includes a link to a PDF version. Shows proper usage of the reloadDocument prop for resource route linking.

LANGUAGE: tsx
CODE:
export async function loader({
  params,
}: LoaderFunctionArgs) {
  return json(await getReport(params.id));
}

export default function Report() {
  const report = useLoaderData<typeof loader>();
  return (
    <div>
      <h1>{report.name}</h1>
      <Link to="pdf" reloadDocument>
        View as PDF
      </Link>
      {/* ... */}
    </div>
  );
}

----------------------------------------

TITLE: History Stack Navigation in Remix
DESCRIPTION: Shows how to navigate through the browser's history stack using numeric arguments with useNavigate.

LANGUAGE: tsx
CODE:
navigate(-1); // go back
navigate(1); // go forward
navigate(-2); // go back two

----------------------------------------

TITLE: Showing Browser History Stack with Redirect After POST
DESCRIPTION: This snippet shows how implementing a redirect after a POST request changes the browser history stack, preventing accidental form resubmissions.

LANGUAGE: plaintext
CODE:
GET /buy > POST /checkout, Redirect > GET /order/123

----------------------------------------

TITLE: Defer with Status and Headers in Remix TSX
DESCRIPTION: Shows how to use the defer function with additional configuration options including custom status codes and headers. This example sets a 418 status code and includes Cache-Control header.

LANGUAGE: tsx
CODE:
export const loader = async () => {
  const aStillRunningPromise = loadSlowDataAsync();

  return defer(
    {
      critical: "data",
      slowPromise: aStillRunningPromise,
    },
    {
      status: 418,
      headers: {
        "Cache-Control": "no-store",
      },
    }
  );
};

----------------------------------------

TITLE: Basic Meta Function Implementation in Remix TSX
DESCRIPTION: Example showing basic meta function usage to generate title and meta tags for SEO and social media.

LANGUAGE: tsx
CODE:
export const meta: MetaFunction = () => {
  return [
    { title: "Very cool app | Remix" },
    {
      property: "og:title",
      content: "Very cool app",
    },
    {
      name: "description",
      content: "This app is the best",
    },
  ];
};

----------------------------------------

TITLE: Type-Safe Loader Function in Remix (TypeScript)
DESCRIPTION: Shows how to achieve type safety for loader data in components using TypeScript. The example demonstrates automatic type inference for loader return values.

LANGUAGE: tsx
CODE:
import { json } from "@remix-run/node";
import { useLoaderData } from "@remix-run/react";

export async function loader() {
  return json({ name: "Ryan", date: new Date() });
}

export default function SomeRoute() {
  const data = useLoaderData<typeof loader>();
}

----------------------------------------

TITLE: Implementing Client-Only Data Loading in Remix
DESCRIPTION: This snippet shows a route that only depends on client-side data loading in Remix. It exports a clientLoader function, a HydrateFallback component for SSR, and uses useLoaderData hook to access the client data in the component.

LANGUAGE: tsx
CODE:
import type { ClientLoaderFunctionArgs } from "@remix-run/react";

export async function clientLoader({
  request,
}: ClientLoaderFunctionArgs) {
  const clientData = await getClientData(request);
  return clientData;
}
// Note: you do not have to set this explicitly - it is implied if there is no `loader`
clientLoader.hydrate = true;

// (2)
export function HydrateFallback() {
  return <p>Skeleton rendered during SSR</p>;
}

export default function Component() {
  const data = useLoaderData(); // (2) - client data
  return <>...</>;
}

----------------------------------------

TITLE: Plain Object Form Submission
DESCRIPTION: Example showing how to submit a plain JavaScript object that will be serialized as FormData.

LANGUAGE: tsx
CODE:
submit({ myKey: "myValue" }, { method: "post" });

----------------------------------------

TITLE: Full Example of Testing a Remix Component with Jest and React Testing Library in TSX
DESCRIPTION: This comprehensive example demonstrates how to test a Remix component using createRemixStub, Jest, and React Testing Library. It includes importing necessary functions, creating a test component, setting up the RemixStub, and performing assertions.

LANGUAGE: tsx
CODE:
import { json } from "@remix-run/node";
import { useLoaderData } from "@remix-run/react";
import { createRemixStub } from "@remix-run/testing";
import {
  render,
  screen,
  waitFor,
} from "@testing-library/react";

test("renders loader data", async () => {
  // ⚠️ This would usually be a component you import from your app code
  function MyComponent() {
    const data = useLoaderData() as { message: string };
    return <p>Message: {data.message}</p>;
  }

  const RemixStub = createRemixStub([
    {
      path: "/",
      Component: MyComponent,
      loader() {
        return json({ message: "hello" });
      },
    },
  ]);

  render(<RemixStub />);

  await waitFor(() => screen.findByText("Message: hello"));
});

----------------------------------------

TITLE: Setting Search Parameters Using Previous State
DESCRIPTION: Shows how to use the setter function with a callback that receives the previous search parameters, allowing for updates based on the current state.

LANGUAGE: tsx
CODE:
<button
  onClick={() => {
    setSearchParams((prev) => {
      prev.set("someKey", "someValue");
      return prev;
    });
  }}
/>

----------------------------------------

TITLE: Importing and Using CSS Modules in React Component
DESCRIPTION: This snippet shows how to import and use CSS Modules in a React component within a Remix application. It demonstrates importing the styles and applying them to a button component using the className prop.

LANGUAGE: tsx
CODE:
import styles from "./styles.module.css";

export const Button = React.forwardRef(
  ({ children, ...props }, ref) => {
    return (
      <button
        {...props}
        ref={ref}
        className={styles.root}
      />
    );
  }
);
Button.displayName = "Button";

----------------------------------------

TITLE: Using NavLink Component in Remix
DESCRIPTION: Demonstrates how to import and use the NavLink component with dynamic className based on active and pending states.

LANGUAGE: tsx
CODE:
import { NavLink } from "@remix-run/react";

<NavLink
  to="/messages"
  className={({ isActive, isPending }) =>
    isPending ? "pending" : isActive ? "active" : ""
  }
>
  Messages
</NavLink>;

----------------------------------------

TITLE: Implementing Scripts Component in Remix Root Layout
DESCRIPTION: Demonstrates how to properly implement the Scripts component within the root layout file of a Remix application. The Scripts component should be rendered inside the body element to enable client-side JavaScript functionality.

LANGUAGE: tsx
CODE:
import { Scripts } from "@remix-run/react";

export default function Root() {
  return (
    <html>
      <head />
      <body>
        <Scripts />
      </body>
    </html>
  );
}

----------------------------------------

TITLE: Custom Status Code Redirects in Remix
DESCRIPTION: Shows how to specify custom HTTP status codes (301, 303) when using the redirect function.

LANGUAGE: ts
CODE:
redirect(path, 301);
redirect(path, 303);

----------------------------------------

TITLE: Creating Request Handler with Express in Remix
DESCRIPTION: Demonstrates how to create a request handler using the Express adapter in Remix. It shows the setup for handling all HTTP verbs and passing the build and context to the handler.

LANGUAGE: typescript
CODE:
const {
  createRequestHandler,
} = require("@remix-run/express");
const express = require("express");

const app = express();

// needs to handle all verbs (GET, POST, etc.)
app.all(
  "*",
  createRequestHandler({
    // `remix build` and `remix dev` output files to a build directory, you need
    // to pass that build to the request handler
    build: require("./build"),

    // return anything you want here to be available as `context` in your
    // loaders and actions. This is where you can bridge the gap between Remix
    // and your server
    getLoadContext(req, res) {
      return {};
    },
  })
);

----------------------------------------

TITLE: Using Cookies in Remix Loader and Action Functions
DESCRIPTION: Shows how to use cookies in Remix loader and action functions. This example demonstrates reading and writing cookie values, and using them to control UI elements.

LANGUAGE: tsx
CODE:
import type {
  ActionFunctionArgs,
  LoaderFunctionArgs,
} from "@remix-run/node"; // or cloudflare/deno
import { json, redirect } from "@remix-run/node"; // or cloudflare/deno
import {
  useLoaderData,
  Link,
  Form,
} from "@remix-run/react";

import { userPrefs } from "~/cookies.server";

export async function loader({
  request,
}: LoaderFunctionArgs) {
  const cookieHeader = request.headers.get("Cookie");
  const cookie =
    (await userPrefs.parse(cookieHeader)) || {};
  return json({ showBanner: cookie.showBanner });
}

export async function action({
  request,
}: ActionFunctionArgs) {
  const cookieHeader = request.headers.get("Cookie");
  const cookie =
    (await userPrefs.parse(cookieHeader)) || {};
  const bodyParams = await request.formData();

  if (bodyParams.get("bannerVisibility") === "hidden") {
    cookie.showBanner = false;
  }

  return redirect("/", {
    headers: {
      "Set-Cookie": await userPrefs.serialize(cookie),
    },
  });
}

export default function Home() {
  const { showBanner } = useLoaderData<typeof loader>();

  return (
    <div>
      {showBanner ? (
        <div>
          <Link to="/sale">Don't miss our sale!</Link>
          <Form method="post">
            <input
              type="hidden"
              name="bannerVisibility"
              value="hidden"
            />
            <button type="submit">Hide</button>
          </Form>
        </div>
      ) : null}
      <h1>Welcome!</h1>
    </div>
  );
}

----------------------------------------

TITLE: Implementing GitHub Webhook Handler in Remix
DESCRIPTION: Example of a Resource Route that handles GitHub webhooks, including signature validation and payload processing.

LANGUAGE: tsx
CODE:
import crypto from "node:crypto";

import type { ActionFunctionArgs } from "@remix-run/node"; // or cloudflare/deno
import { json } from "@remix-run/node"; // or cloudflare/deno

export const action = async ({
  request,
}: ActionFunctionArgs) => {
  if (request.method !== "POST") {
    return json({ message: "Method not allowed" }, 405);
  }
  const payload = await request.json();

  /* Validate the webhook */
  const signature = request.headers.get(
    "X-Hub-Signature-256"
  );
  const generatedSignature = `sha256=${crypto
    .createHmac("sha256", process.env.GITHUB_WEBHOOK_SECRET)
    .update(JSON.stringify(payload))
    .digest("hex")}`;
  if (signature !== generatedSignature) {
    return json({ message: "Signature mismatch" }, 401);
  }

  /* process the webhook (e.g. enqueue a background job) */

  return json({ success: true }, 200);
};

----------------------------------------

TITLE: Implementing Browser Feature Detection in Remix Client Module
DESCRIPTION: Example of checking browser API support using a .client.ts module. This code demonstrates how to detect the Vibration API support, which must be isolated to client-side execution.

LANGUAGE: typescript
CODE:
// this would break the server
export const supportsVibrationAPI =
  "vibrate" in window.navigator;

----------------------------------------

TITLE: Using useAsyncError Hook with Await Component in Remix
DESCRIPTION: This snippet demonstrates how to use the useAsyncError hook to handle errors in an Await component. It retrieves the rejection value from the closest Await component and displays an error message.

LANGUAGE: tsx
CODE:
import { Await, useAsyncError } from "@remix-run/react";

function ErrorElement() {
  const error = useAsyncError();
  return (
    <p>Uh Oh, something went wrong! {error.message}</p>
  );
}

<Await
  resolve={promiseThatRejects}
  errorElement={<ErrorElement />}
/>;

----------------------------------------

TITLE: TypeScript Configuration for Remix Projects
DESCRIPTION: TSConfig file for Remix projects that includes necessary compiler options, module settings, and path configurations. Specifies TypeScript compilation rules and type definitions for Remix and Vite.

LANGUAGE: json
CODE:
{
  "include": [
    "**/*.ts",
    "**/*.tsx",
    "**/.server/**/*.ts",
    "**/.server/**/*.tsx",
    "**/.client/**/*.ts",
    "**/.client/**/*.tsx"
  ],
  "compilerOptions": {
    "lib": ["DOM", "DOM.Iterable", "ES2022"],
    "types": ["@remix-run/node", "vite/client"],
    "isolatedModules": true,
    "esModuleInterop": true,
    "jsx": "react-jsx",
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "resolveJsonModule": true,
    "target": "ES2022",
    "strict": true,
    "allowJs": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "baseUrl": ".",
    "paths": {
      "~/*": ["./app/*"]
    },
    "noEmit": true
  }
}

----------------------------------------

TITLE: Handling HTTP Methods in Resource Routes
DESCRIPTION: Examples of handling different HTTP methods (GET, POST, PUT, PATCH, DELETE) in Remix Resource Routes using loader and action functions.

LANGUAGE: tsx
CODE:
export const loader = async ({
  request,
}: LoaderFunctionArgs) => {
  // handle "GET" request

  return json({ success: true }, 200);
};

LANGUAGE: tsx
CODE:
export const action = async ({
  request,
}: ActionFunctionArgs) => {
  switch (request.method) {
    case "POST": {
      /* handle "POST" */
    }
    case "PUT": {
      /* handle "PUT" */
    }
    case "PATCH": {
      /* handle "PATCH" */
    }
    case "DELETE": {
      /* handle "DELETE" */
    }
  }
};

----------------------------------------

TITLE: Setting Form Action in Remix
DESCRIPTION: This snippet shows two ways to set the form action in Remix: using the Form component and using the submit function.

LANGUAGE: tsx
CODE:
// set from either one of these
<Form action="/some/where" />;
submit(formData, { action: "/some/where" });

----------------------------------------

TITLE: Implementing Login Functionality with Sessions in Remix
DESCRIPTION: This code snippet shows how to implement a login form and handle user authentication using sessions in Remix. It includes both the loader and action functions for the login route.

LANGUAGE: tsx
CODE:
import type {
  ActionFunctionArgs,
  LoaderFunctionArgs,
} from "@remix-run/node"; // or cloudflare/deno
import { json, redirect } from "@remix-run/node"; // or cloudflare/deno
import { useLoaderData } from "@remix-run/react";

import { getSession, commitSession } from "../sessions";

export async function loader({
  request,
}: LoaderFunctionArgs) {
  const session = await getSession(
    request.headers.get("Cookie")
  );

  if (session.has("userId")) {
    // Redirect to the home page if they are already signed in.
    return redirect("/");
  }

  const data = { error: session.get("error") };

  return json(data, {
    headers: {
      "Set-Cookie": await commitSession(session),
    },
  });
}

export async function action({
  request,
}: ActionFunctionArgs) {
  const session = await getSession(
    request.headers.get("Cookie")
  );
  const form = await request.formData();
  const username = form.get("username");
  const password = form.get("password");

  const userId = await validateCredentials(
    username,
    password
  );

  if (userId == null) {
    session.flash("error", "Invalid username/password");

    // Redirect back to the login page with errors.
    return redirect("/login", {
      headers: {
        "Set-Cookie": await commitSession(session),
      },
    });
  }

  session.set("userId", userId);

  // Login succeeded, send them to the home page.
  return redirect("/", {
    headers: {
      "Set-Cookie": await commitSession(session),
    },
  });
}

export default function Login() {
  const { error } = useLoaderData<typeof loader>();

  return (
    <div>
      {error ? <div className="error">{error}</div> : null}
      <form method="POST">
        <div>
          <p>Please sign in</p>
        </div>
        <label>
          Username: <input type="text" name="username" />
        </label>
        <label>
          Password:{" "}
          <input type="password" name="password" />
        </label>
      </form>
    </div>
  );
}

----------------------------------------

TITLE: Complete File Upload Implementation - Remix Action and Component
DESCRIPTION: Full example showing both the server-side action function for handling file uploads and the client-side form component. Demonstrates handling file uploads with custom upload handler and form submission.

LANGUAGE: tsx
CODE:
export const action = async ({
  request,
}: ActionFunctionArgs) => {
  const formData = await unstable_parseMultipartFormData(
    request,
    uploadHandler // <-- we'll look at this deeper next
  );

  // the returned value for the file field is whatever our uploadHandler returns.
  // Let's imagine we're uploading the avatar to s3,
  // so our uploadHandler returns the URL.
  const avatarUrl = formData.get("avatar");

  // update the currently logged in user's avatar in our database
  await updateUserAvatar(request, avatarUrl);

  // success! Redirect to account page
  return redirect("/account");
};

export default function AvatarUploadRoute() {
  return (
    <Form method="post" encType="multipart/form-data">
      <label htmlFor="avatar-input">Avatar</label>
      <input id="avatar-input" type="file" name="avatar" />
      <button>Upload</button>
    </Form>
  );
}

----------------------------------------

TITLE: Using a Component with CSS URL Imports in a Remix Route
DESCRIPTION: This snippet shows how to import and use a component with CSS URL imports in a Remix route file, including the necessary links export.

LANGUAGE: jsx
CODE:
import {
  Button,
  links as buttonLinks,
} from "../components/Button";

export const links = () => [...buttonLinks];

export default function HelloRoute() {
  return <Button>Hello!</Button>;
}

----------------------------------------

TITLE: Conventional Routes Directory Structure
DESCRIPTION: Example directory structure showing typical route file organization in Remix using the app/routes folder convention.

LANGUAGE: text
CODE:
app/
├── routes/
│   ├── _index.tsx
│   ├── about.tsx
│   ├── concerts._index.tsx
│   ├── concerts.$city.tsx
│   ├── concerts.trending.tsx
│   └── concerts.tsx
└── root.tsx

----------------------------------------

TITLE: Navigation with String Path in Remix
DESCRIPTION: Shows how to use useNavigate with a string path argument for basic navigation.

LANGUAGE: tsx
CODE:
navigate("/some/path");

----------------------------------------

TITLE: Setting Relative Path Behavior for Link in Remix
DESCRIPTION: Shows how to use the relative prop to define relative path behavior for the Link component.

LANGUAGE: tsx
CODE:
<Link to=".." />; // default: "route"
<Link relative="route" />;
<Link relative="path" />;

----------------------------------------

TITLE: Importing CSS in Remix Route Component
DESCRIPTION: This snippet demonstrates how to import a CSS file directly in a Remix route component. This approach allows for route-specific styling.

LANGUAGE: jsx
CODE:
import styles from "~/styles/jokes.css";

export function links() {
  return [{ rel: "stylesheet", href: styles }];
}

----------------------------------------

TITLE: Adding Spinners to NavLinks Using useParams in Remix
DESCRIPTION: This snippet demonstrates how to add spinners to NavLinks by inspecting URL parameters using the useParams hook in a Remix application.

LANGUAGE: tsx
CODE:
import { useParams } from "@remix-run/react";

export function ProjectList({ projects }) {
  const params = useParams();
  return (
    <nav>
      {projects.map((project) => (
        <NavLink key={project.id} to={project.id}>
          {project.name}
          {params.projectId === project.id ? (
            <Spinner />
          ) : null}
        </NavLink>
      ))}
    </nav>
  );
}

----------------------------------------

TITLE: Redirect with Headers in Remix
DESCRIPTION: Examples of using redirect with ResponseInit to set custom headers, particularly for session management using Set-Cookie header.

LANGUAGE: ts
CODE:
redirect(path, {
  headers: {
    "Set-Cookie": await commitSession(session),
  },
});

redirect(path, {
  status: 302,
  headers: {
    "Set-Cookie": await commitSession(session),
  },
});

----------------------------------------

TITLE: File Upload Handler Implementation
DESCRIPTION: Shows the correct way to implement file upload handlers within Remix action functions rather than at the module level to avoid server code execution in the browser.

LANGUAGE: typescript
CODE:
import { unstable_createFileUploadHandler } from "@remix-run/node";

export async function action() {
  const uploadHandler = unstable_createFileUploadHandler({
    maxPartSize: 5_000_000,
    file: ({ filename }) => filename,
  });

  // use `uploadHandler` here ...
}

----------------------------------------

TITLE: Creating Basic Signup Form Component in Remix TSX
DESCRIPTION: Demonstrates how to create a basic signup form using Remix's Form component with email and password inputs.

LANGUAGE: tsx
CODE:
import { Form } from "@remix-run/react";

export default function Signup() {
  return (
    <Form method="post">
      <p>
        <input type="email" name="email" />
      </p>

      <p>
        <input type="password" name="password" />
      </p>

      <button type="submit">Sign Up</button>
    </Form>
  );
}

----------------------------------------

TITLE: Basic useSubmit Hook Usage in React Component
DESCRIPTION: Basic example showing how to import and use the useSubmit hook within a React component to handle form submissions programmatically.

LANGUAGE: tsx
CODE:
import { useSubmit } from "@remix-run/react";

function SomeComponent() {
  const submit = useSubmit();
  return (
    <Form
      onChange={(event) => {
        submit(event.currentTarget);
      }}
    />
  );
}

----------------------------------------

TITLE: NavLink with View Transition in Remix
DESCRIPTION: Shows how to use the viewTransition prop and customize the transition using CSS classes and inline styles.

LANGUAGE: tsx
CODE:
<NavLink to={to} viewTransition>
  {({ isTransitioning }) => (
    <>
      <p
        style={{
          viewTransitionName: isTransitioning
            ? "image-title"
            : "",
        }}
      >
        Image Number {idx}
      </p>
      <img
        src={src}
        alt={`Img ${idx}`}
        style={{
          viewTransitionName: isTransitioning
            ? "image-expand"
            : "",
        }}
      />
    </>
  )}
</NavLink>

----------------------------------------

TITLE: Using CSS Modules in Remix
DESCRIPTION: This snippet illustrates how to use CSS Modules in a Remix application. It imports a CSS module and applies the styles to elements in the component.

LANGUAGE: jsx
CODE:
import styles from "~/styles/jokes.module.css";

export default function Jokes() {
  return (
    <div className={styles.container}>
      <h1 className={styles.title}>Jokes</h1>
      {/* ... */}
    </div>
  );
}

----------------------------------------

TITLE: Importing and Using useNavigation Hook in React
DESCRIPTION: This snippet demonstrates how to import the useNavigation hook from @remix-run/react and use it within a React component.

LANGUAGE: javascript
CODE:
import { useNavigation } from "@remix-run/react";

function SomeComponent() {
  const navigation = useNavigation();
  // ...
}

----------------------------------------

TITLE: Implementing Server-Only Data Loading in Remix
DESCRIPTION: This snippet demonstrates a route that only depends on server-side data loading in Remix. It exports a loader function to fetch data from the server and uses useLoaderData hook to access the data in the component.

LANGUAGE: tsx
CODE:
import type { LoaderFunctionArgs } from "@remix-run/node";
import { json } from "@remix-run/node";

export async function loader({
  request,
}: LoaderFunctionArgs) {
  const data = await getServerData(request);
  return json(data);
}

export default function Component() {
  const data = useLoaderData(); // (1) - server data
  return <>...</>;
}

----------------------------------------

TITLE: FormData Submission Example
DESCRIPTION: Example demonstrating how to submit data using a FormData instance.

LANGUAGE: tsx
CODE:
const formData = new FormData();
formData.append("myKey", "myValue");
submit(formData, { method: "post" });

----------------------------------------

TITLE: Defining a clientLoader Function in Remix
DESCRIPTION: This snippet demonstrates how to define a clientLoader function in a Remix route. It shows how to access server loader data, fetch client-side data, and return combined data for the route.

LANGUAGE: tsx
CODE:
export const clientLoader = async ({
  request,
  params,
  serverLoader,
}: ClientLoaderFunctionArgs) => {
  // call the server loader
  const serverData = await serverLoader();
  // And/or fetch data on the client
  const data = getDataFromClient();
  // Return the data to expose through useLoaderData()
  return data;
};

----------------------------------------

TITLE: Basic Form Component Usage in Remix (TSX)
DESCRIPTION: Demonstrates how to import and use the Form component from Remix to create a simple form for submitting event data.

LANGUAGE: tsx
CODE:
import { Form } from "@remix-run/react";

function NewEvent() {
  return (
    <Form action="/events" method="post">
      <input name="title" type="text" />
      <input name="description" type="text" />
    </Form>
  );
}

----------------------------------------

TITLE: Defining Breadcrumb for Child Route in Remix
DESCRIPTION: This snippet demonstrates how to define a breadcrumb for a child route using the handle property in Remix.

LANGUAGE: tsx
CODE:
export const handle = {
  breadcrumb: () => (
    <Link to="/parent/child">Child Route</Link>
  ),
};

----------------------------------------

TITLE: Using useOutletContext Hook in Remix (TSX)
DESCRIPTION: Demonstrates how to import and use the useOutletContext hook in a child component to access context values from a parent Outlet component. The hook returns the context value set by the closest parent Outlet component.

LANGUAGE: tsx
CODE:
import { useOutletContext } from "@remix-run/react";

function Child() {
  const myValue = useOutletContext();
  // ...
}

----------------------------------------

TITLE: Serving Remix SPA with Express
DESCRIPTION: Express server configuration to serve a Remix SPA with static assets and SPA fallback.

LANGUAGE: javascript
CODE:
app.use("/assets", express.static("build/client/assets"));
app.get("*", (req, res, next) =>
  res.sendFile(
    path.join(process.cwd(), "build/client/index.html"),
    next
  )
);

----------------------------------------

TITLE: Creating Shared Component Styles
DESCRIPTION: Shows how to create and include shared styles for components across the application.

LANGUAGE: css
CODE:
/* scope with class names */
.PrimaryButton {
  /* ... */
}

.TileGrid {
  /* ... */
}

/* or scope with data attributes to avoid concatenating
   className props, but it's really up to you */
[data-primary-button] {
  /* ... */
}

[data-tile-grid] {
  /* ... */
}

----------------------------------------

TITLE: Basic Usage of useNavigate Hook in Remix
DESCRIPTION: Demonstrates the basic usage of the useNavigate hook to navigate programmatically in response to a button click.

LANGUAGE: tsx
CODE:
import { useNavigate } from "@remix-run/react";

function SomeComponent() {
  const navigate = useNavigate();
  return (
    <button
      onClick={() => {
        navigate(-1);
      }}
    />
  );
}

----------------------------------------

TITLE: Using useNavigationType Hook in Remix (TSX)
DESCRIPTION: This snippet demonstrates how to import and use the useNavigationType hook in a React component within a Remix application. The hook returns the type of navigation used to arrive at the current location.

LANGUAGE: tsx
CODE:
import { useNavigationType } from "@remix-run/react";

function SomeComponent() {
  const navigationType = useNavigationType();
  // ...
}

----------------------------------------

TITLE: Signature of useSearchParams Hook
DESCRIPTION: Shows the signature of the useSearchParams hook, which returns a tuple containing the search parameters and a setter function.

LANGUAGE: tsx
CODE:
const [searchParams, setSearchParams] = useSearchParams();

----------------------------------------

TITLE: Implementing Busy Indicator for Record Creation in Remix
DESCRIPTION: This example shows how to use useNavigation to display a busy indicator during record creation, including form disabling and redirect handling in a Remix action.

LANGUAGE: tsx
CODE:
import type { ActionFunctionArgs } from "@remix-run/node"; // or cloudflare/deno
import { redirect } from "@remix-run/node"; // or cloudflare/deno
import { useNavigation } from "@remix-run/react";

export async function action({
  request,
}: ActionFunctionArgs) {
  const formData = await request.formData();
  const project = await createRecord({
    name: formData.get("name"),
    owner: formData.get("owner"),
  });
  return redirect(`/projects/${project.id}`);
}

export default function CreateProject() {
  const navigation = useNavigation();

  // important to check you're submitting to the action
  // for the pending UI, not just any action
  const isSubmitting =
    navigation.formAction === "/create-project";

  return (
    <Form method="post" action="/create-project">
      <fieldset disabled={isSubmitting}>
        <label>
          Name: <input type="text" name="projectName" />
        </label>
        <label>
          Owner: <UserSelect />
        </label>
        <button type="submit">Create</button>
      </fieldset>
      {isSubmitting ? <BusyIndicator /> : null}
    </Form>
  );
}

----------------------------------------

TITLE: Defining shouldRevalidate Function in Remix
DESCRIPTION: This snippet shows the basic structure of the shouldRevalidate function in Remix. It demonstrates the function signature and the parameters available for making revalidation decisions.

LANGUAGE: tsx
CODE:
import type { ShouldRevalidateFunction } from "@remix-run/react";

export const shouldRevalidate: ShouldRevalidateFunction = ({
  actionResult,
  currentParams,
  currentUrl,
  defaultShouldRevalidate,
  formAction,
  formData,
  formEncType,
  formMethod,
  nextParams,
  nextUrl,
}) => {
  return true;
};

----------------------------------------

TITLE: Defining CSS Module Styles in Remix
DESCRIPTION: This snippet demonstrates how to create a CSS Module file in Remix. The .module.css extension is used to opt into CSS Modules functionality. The example defines a 'root' class with basic button styling.

LANGUAGE: css
CODE:
.root {
  border: solid 1px;
  background: white;
  color: #454545;
}

----------------------------------------

TITLE: Error Message Example for Failed Package Resolution
DESCRIPTION: Example of an error message that occurs when Vite fails to resolve package dependencies during pre-bundling.

LANGUAGE: txt
CODE:
✘ [ERROR] Failed to resolve entry for package "<package>". The package may have incorrect main/module/exports specified in its package.json. [plugin vite:dep-pre-bundle]

----------------------------------------

TITLE: Using useFetchers Hook in React Component with Remix
DESCRIPTION: This snippet demonstrates how to use the useFetchers hook in a React component. It imports the hook from @remix-run/react and shows how to access fetcher states like formData and state.

LANGUAGE: tsx
CODE:
import { useFetchers } from "@remix-run/react";

function SomeComponent() {
  const fetchers = useFetchers();
  fetchers[0].formData; // FormData
  fetchers[0].state; // etc.
  // ...
}

----------------------------------------

TITLE: Initializing Remix Project with Template
DESCRIPTION: Generate a basic Remix project using the tutorial template and install dependencies

LANGUAGE: shellscript
CODE:
npx create-remix@latest --template remix-run/remix/templates/remix-tutorial

# cd into the app directory
cd {wherever you put the app}

# install dependencies if you haven't already
npm install

# start the server
npm run dev

----------------------------------------

TITLE: Manual Response Construction vs Redirect Helper
DESCRIPTION: Compares using the redirect helper with manually constructing a Response object for redirects.

LANGUAGE: ts
CODE:
// this is a shortcut...
return redirect("/else/where", 303);

// ...for this
return new Response(null, {
  status: 303,
  headers: {
    Location: "/else/where",
  },
});

----------------------------------------

TITLE: Basic Headers Configuration in Remix Route
DESCRIPTION: Demonstrates how to define basic HTTP headers in a Remix route, including Cache-Control and custom headers using the HeadersFunction type.

LANGUAGE: tsx
CODE:
import type { HeadersFunction } from "@remix-run/node"; // or cloudflare/deno

export const headers: HeadersFunction = ({
  actionHeaders,
  errorHeaders,
  loaderHeaders,
  parentHeaders,
}) => ({
  "X-Stretchy-Pants": "its for fun",
  "Cache-Control": "max-age=300, s-maxage=3600",
});

----------------------------------------

TITLE: Enabling v3_lazyRouteDiscovery Future Flag
DESCRIPTION: Configuration to enable the v3_lazyRouteDiscovery future flag in the Remix Vite plugin.

LANGUAGE: typescript
CODE:
remix({
  future: {
    v3_lazyRouteDiscovery: true,
  },
});

----------------------------------------

TITLE: Implementing State Persistence with useBeforeUnload in React/Remix
DESCRIPTION: Demonstrates how to use the useBeforeUnload hook to persist component state to localStorage before page unload. The example shows both saving state before unload and retrieving it when the component mounts.

LANGUAGE: tsx
CODE:
import { useBeforeUnload } from "@remix-run/react";

function SomeForm() {
  const [state, setState] = React.useState(null);

  // save it off before the automatic page reload
  useBeforeUnload(
    React.useCallback(() => {
      localStorage.stuff = state;
    }, [state])
  );

  // read it in when they return
  React.useEffect(() => {
    if (state === null && localStorage.stuff != null) {
      setState(localStorage.stuff);
    }
  }, [state]);

  return <>{/*... */}</>;
}

----------------------------------------

TITLE: Configuring a custom server for Remix Vite
DESCRIPTION: Example of how to configure a custom Express server for use with Remix Vite

LANGUAGE: javascript
CODE:
import { createRequestHandler } from "@remix-run/express";
import { installGlobals } from "@remix-run/node";
import express from "express";

installGlobals();

const viteDevServer =
  process.env.NODE_ENV === "production"
    ? undefined
    : await import("vite").then((vite) =>
        vite.createServer({
          server: { middlewareMode: true },
        })
      );

const app = express();

// handle asset requests
if (viteDevServer) {
  app.use(viteDevServer.middlewares);
} else {
  app.use(
    "/assets",
    express.static("build/client/assets", {
      immutable: true,
      maxAge: "1y",
    })
  );
}
app.use(express.static("build/client", { maxAge: "1h" }));

// handle SSR requests
app.all(
  "*",
  createRequestHandler({
    build: viteDevServer
      ? () =>
          viteDevServer.ssrLoadModule(
            "virtual:remix/server-build"
          )
      : await import("./build/server/index.js"),
  })
);

const port = 3000;
app.listen(port, () =>
  console.log("http://localhost:" + port)
);

----------------------------------------

TITLE: Using useParams Hook in Remix (TSX)
DESCRIPTION: This snippet demonstrates how to import and use the useParams hook in a React component within a Remix application. The hook returns an object containing key/value pairs of dynamic parameters from the current URL.

LANGUAGE: tsx
CODE:
import { useParams } from "@remix-run/react";

function SomeComponent() {
  const params = useParams();
  // ...
}

----------------------------------------

TITLE: Configuring Remix Dev Server with TLS
DESCRIPTION: Configuration options for enabling TLS in Remix development server using remix.config.js or command line flags.

LANGUAGE: javascript
CODE:
/** @type {import('@remix-run/dev').AppConfig} */
module.exports = {
  dev: {
    tlsKey: "key.pem", // relative to cwd
    tlsCert: "cert.pem", // relative to cwd
  },
};

LANGUAGE: shellscript
CODE:
remix dev --tls-key=key.pem --tls-cert=cert.pem -c "node ./server.js"

----------------------------------------

TITLE: useFormAction Hook Signature in Remix (TypeScript)
DESCRIPTION: Defines the function signature for the useFormAction hook. It shows that the hook accepts an optional action parameter and an options object with a 'relative' property that can be set to either 'route' or 'path'.

LANGUAGE: typescript
CODE:
useFormAction(action, options)

----------------------------------------

TITLE: Demonstrating Server Module File Structure in Remix
DESCRIPTION: Example directory structure showing how to organize server-only modules using both .server directories and individual .server files. Illustrates the placement of server modules within the Remix app directory hierarchy.

LANGUAGE: txt
CODE:
app
├── .server 👈 marks all files in this directory as server-only
│   ├── auth.ts
│   └── db.ts
├── cms.server.ts 👈 marks this file as server-only
├── root.tsx
└── routes
    └── _index.tsx

----------------------------------------

TITLE: Using data utility with custom headers
DESCRIPTION: Demonstrates how to use the data utility function to return data with a custom status code and headers in a Remix loader function. Shows proper usage for cases requiring specific HTTP responses.

LANGUAGE: tsx
CODE:
import { data } from "@remix-run/node"; // or cloudflare/deno

export const loader = async () => {
  return data(
    { not: "coffee" },
    {
      status: 418,
      headers: {
        "Cache-Control": "no-store",
      },
    }
  );
};

----------------------------------------

TITLE: Using HtmlLinkDescriptor in Remix LinksFunction (TSX)
DESCRIPTION: This snippet shows various examples of using HtmlLinkDescriptor objects in the LinksFunction to define different types of <link> elements, including favicons, external and local stylesheets, and prefetched images.

LANGUAGE: tsx
CODE:
import type { LinksFunction } from "@remix-run/node"; // or cloudflare/deno

import stylesHref from "../styles/something.css";

export const links: LinksFunction = () => {
  return [
    // add a favicon
    {
      rel: "icon",
      href: "/favicon.png",
      type: "image/png",
    },

    // add an external stylesheet
    {
      rel: "stylesheet",
      href: "https://example.com/some/styles.css",
      crossOrigin: "anonymous",
    },

    // add a local stylesheet, remix will fingerprint the file name for
    // production caching
    { rel: "stylesheet", href: stylesHref },

    // prefetch an image into the browser cache that the user is likely to see
    // as they interact with this page, perhaps they click a button to reveal in
    // a summary/details element
    {
      rel: "prefetch",
      as: "image",
      href: "/img/bunny.jpg",
    },

    // only prefetch it if they're on a bigger screen
    {
      rel: "prefetch",
      as: "image",
      href: "/img/bunny.jpg",
      media: "(min-width: 1000px)",
    },
  ];
};

----------------------------------------

TITLE: Customizing ScrollRestoration Key in Remix
DESCRIPTION: This snippet shows how to customize the key used for scroll position restoration using the getKey prop of the ScrollRestoration component. It allows for fine-grained control over scroll behavior.

LANGUAGE: tsx
CODE:
<ScrollRestoration
  getKey={(location, matches) => {
    // default behavior
    return location.key;
  }}
/>

----------------------------------------

TITLE: Updating Loader Return for v3_singleFetch
DESCRIPTION: Example of updating a loader function to return raw data instead of using json() for v3_singleFetch compatibility.

LANGUAGE: typescript
CODE:
-import { json } from "@remix-run/node";

export async function loader({}: LoaderFunctionArgs) {
  let tasks = await fetchTasks();
- return json(tasks);
+ return tasks;
}

----------------------------------------

TITLE: Await Component with Children Render Prop
DESCRIPTION: Demonstrates using a render callback as children to handle resolved promise values.

LANGUAGE: tsx
CODE:
<Await resolve={somePromise}>
  {(resolvedValue) => <p>{resolvedValue}</p>}
</Await>

----------------------------------------

TITLE: Conservative Cache Control Headers Management
DESCRIPTION: Implements a strategy for managing Cache-Control headers across nested routes by selecting the most conservative caching duration.

LANGUAGE: tsx
CODE:
import type { HeadersFunction } from "@remix-run/node"; // or cloudflare/deno
import parseCacheControl from "parse-cache-control";

export const headers: HeadersFunction = ({
  loaderHeaders,
  parentHeaders,
}) => {
  const loaderCache = parseCacheControl(
    loaderHeaders.get("Cache-Control")
  );
  const parentCache = parseCacheControl(
    parentHeaders.get("Cache-Control")
  );

  // take the most conservative between the parent and loader, otherwise
  // we'll be too aggressive for one of them.
  const maxAge = Math.min(
    loaderCache["max-age"],
    parentCache["max-age"]
  );

  return {
    "Cache-Control": `max-age=${maxAge}`,
  };
};

----------------------------------------

TITLE: Configuring Tailwind CSS in Remix
DESCRIPTION: This snippet demonstrates how to configure Tailwind CSS in a Remix application. It includes the necessary setup in the tailwind.config.js file.

LANGUAGE: jsx
CODE:
// tailwind.config.js
module.exports = {
  content: ["./app/**/*.{js,jsx,ts,tsx}"],
  theme: {
    extend: {},
  },
  plugins: [],
};

----------------------------------------

TITLE: Custom Status and Headers JSON Response in Remix TSX
DESCRIPTION: Demonstrates how to send a JSON response with custom HTTP status code and headers using the json helper function.

LANGUAGE: tsx
CODE:
export const loader = async () => {
  return json(
    { not: "coffee" },
    {
      status: 418,
      headers: {
        "Cache-Control": "no-store",
      },
    }
  );
};

----------------------------------------

TITLE: Creating Event Handler with Cloudflare Workers in Remix
DESCRIPTION: Demonstrates the simplified approach to creating an event handler for Cloudflare Workers using the Cloudflare Workers adapter in Remix.

LANGUAGE: typescript
CODE:
import { createEventHandler } from "@remix-run/cloudflare-workers";

import * as build from "../build";

addEventListener("fetch", createEventHandler({ build }));

----------------------------------------

TITLE: Using useAsyncValue Hook in Remix TSX
DESCRIPTION: Demonstrates how to implement the useAsyncValue hook to access resolved data from an Await component ancestor. The hook returns the resolved value from the closest Await component in the component tree.

LANGUAGE: tsx
CODE:
function SomeDescendant() {
  const value = useAsyncValue();
  // ...
}

LANGUAGE: tsx
CODE:
<Await resolve={somePromise}>
  <SomeDescendant />
</Await>

----------------------------------------

TITLE: MDX Component Integration with Frontmatter Data
DESCRIPTION: Demonstrates how to use frontmatter data with imported components in MDX

LANGUAGE: mdx
CODE:
---
componentData:
  label: Hello, World!
---

import SomeComponent from "~/components/some-component";

# Hello MDX!

<SomeComponent {...attributes.componentData} />

----------------------------------------

TITLE: Importing CSS in a React Component (TSX)
DESCRIPTION: Demonstrates a side effect import of a CSS file in a React component. This pattern is common in some NPM packages and requires special handling in Remix.

LANGUAGE: tsx
CODE:
import "./menu-button.css";

export function MenuButton() {
  return <button data-menu-button>{/* ... */}</button>;
}

----------------------------------------

TITLE: Advanced Request Handling with Cloudflare Workers in Remix
DESCRIPTION: Illustrates a more complex setup for handling requests and assets using the Cloudflare Workers adapter in Remix, including error handling for development and production environments.

LANGUAGE: typescript
CODE:
import {
  createRequestHandler,
  handleAsset,
} from "@remix-run/cloudflare-workers";

import * as build from "../build";

const handleRequest = createRequestHandler({ build });

const handleEvent = async (event: FetchEvent) => {
  let response = await handleAsset(event, build);

  if (!response) {
    response = await handleRequest(event);
  }

  return response;
};

addEventListener("fetch", (event) => {
  try {
    event.respondWith(handleEvent(event));
  } catch (e: any) {
    if (process.env.NODE_ENV === "development") {
      event.respondWith(
        new Response(e.message || e.toString(), {
          status: 500,
        })
      );
    }

    event.respondWith(
      new Response("Internal Error", { status: 500 })
    );
  }
});

----------------------------------------

TITLE: Route Folders Directory Structure
DESCRIPTION: Enhanced directory structure showing route organization using folders with route.tsx files for better module co-location.

LANGUAGE: text
CODE:
app/
├── routes/
│   ├── _index/
│   │   ├── signup-form.tsx
│   │   └── route.tsx
│   ├── about/
│   │   ├── header.tsx
│   │   └── route.tsx
│   ├── concerts/
│   │   ├── favorites-cookie.ts
│   │   └── route.tsx
│   ├── concerts.$city/
│   │   └── route.tsx
│   ├── concerts._index/
│   │   ├── featured.tsx
│   │   └── route.tsx
│   └── concerts.trending/
│       ├── card.tsx
│       ├── route.tsx
│       └── sponsored.tsx
└── root.tsx

----------------------------------------

TITLE: Using redirectDocument for Non-Remix App Redirection in Remix
DESCRIPTION: This snippet demonstrates how to use redirectDocument to perform a document-level redirect from a Remix app to a non-Remix app within the same domain. It checks for a user session and redirects to a login page if not found.

LANGUAGE: tsx
CODE:
import { redirectDocument } from "@remix-run/node"; // or cloudflare/deno

export const action = async () => {
  const userSession = await getUserSessionOrWhatever();

  if (!userSession) {
    // Assuming `/login` is a separate non-Remix app
    return redirectDocument("/login");
  }

  return json({ ok: true });
};

----------------------------------------

TITLE: Configuring v2_dev in remix.config.js
DESCRIPTION: Configuration for enabling v2 dev server functionality in Remix

LANGUAGE: javascript
CODE:
/** @type {import('@remix-run/dev').AppConfig} */
module.exports = {
  future: {
    v2_dev: true,
  },
};

----------------------------------------

TITLE: Advanced MDX Route with Loader and Exports
DESCRIPTION: Complex MDX example showing integration with Remix features including loaders, actions, and style imports

LANGUAGE: mdx
CODE:
---
meta:
  - title: My First Post
  - name: description
    content: Isn't this awesome?

headers:
  Cache-Control: no-cache

handle:
  someData: abc
---

import styles from "./first-post.css";

export const links = () => [
  { rel: "stylesheet", href: styles },
];

import { json } from "@remix-run/node";
import { useLoaderData } from "@remix-run/react";

export const loader = async () => {
  return json({ mamboNumber: 5 });
};

export function ComponentUsingData() {
  const { mamboNumber } = useLoaderData<typeof loader>();
  return <div id="loader">Mambo Number: {mamboNumber}</div>;
}

# This is some markdown!

<ComponentUsingData />

----------------------------------------

TITLE: Implementing Vanilla Extract Styles in React Component
DESCRIPTION: Example of using Vanilla Extract styles in a React component by importing the styles and applying them via className prop

LANGUAGE: tsx
CODE:
import * as styles from "./styles.css"; // Note that `.ts` is omitted here

export const Button = React.forwardRef(
  ({ children, ...props }, ref) => {
    return (
      <button
        {...props}
        ref={ref}
        className={styles.root}
      />
    );
  }
);
Button.displayName = "Button";

----------------------------------------

TITLE: Express Server Setup for Remix
DESCRIPTION: Configuration of an Express server to handle Remix requests with development and production modes.

LANGUAGE: javascript
CODE:
import { createRequestHandler } from "@remix-run/express";
import express from "express";

const viteDevServer =
  process.env.NODE_ENV === "production"
    ? null
    : await import("vite").then((vite) =>
        vite.createServer({
          server: { middlewareMode: true },
        })
      );

const app = express();
app.use(
  viteDevServer
    ? viteDevServer.middlewares
    : express.static("build/client")
);

const build = viteDevServer
  ? () =>
      viteDevServer.ssrLoadModule(
        "virtual:remix/server-build"
      )
  : await import("./build/server/index.js");

app.all("*", createRequestHandler({ build }));

app.listen(3000, () => {
  console.log("App listening on http://localhost:3000");
});

----------------------------------------

TITLE: Setting Custom Status Codes with redirectDocument in Remix
DESCRIPTION: These examples show how to use redirectDocument with custom HTTP status codes. The function accepts a status code as the second parameter for specifying different redirect types.

LANGUAGE: ts
CODE:
redirectDocument(path, 301);
redirectDocument(path, 303);

----------------------------------------

TITLE: Adding State to Link Navigation in Remix
DESCRIPTION: Demonstrates how to use the state prop to add persistent client-side routing state to the next location.

LANGUAGE: tsx
CODE:
<Link to="/somewhere/else" state={{ some: "value" }} />

----------------------------------------

TITLE: Creating a City Search Loader in Remix
DESCRIPTION: Implements a loader function for a city search route that accepts a query parameter and returns search results.

LANGUAGE: tsx
CODE:
export async function loader({
  request,
}: LoaderFunctionArgs) {
  const url = new URL(request.url);
  return json(
    await searchCities(url.searchParams.get("q"))
  );
}

----------------------------------------

TITLE: Accessing Cloudflare Environment Variables in Remix
DESCRIPTION: Demonstrates how to access environment variables when using Cloudflare adapters in Remix, utilizing the context object.

LANGUAGE: tsx
CODE:
export const loader = async ({
  context,
}: LoaderFunctionArgs) => {
  console.log(context.cloudflare.env.SOME_SECRET);
};

----------------------------------------

TITLE: Using data API for Custom Headers with v3_singleFetch
DESCRIPTION: Example of using the new data API to set custom headers when returning loader data with v3_singleFetch enabled.

LANGUAGE: typescript
CODE:
-import { json } from "@remix-run/node";
+import { data } from "@remix-run/node";

// This example assumes you already have a headers function to handle header
// merging for your document requests
export function headers() {
  // ...
}

export async function loader({}: LoaderFunctionArgs) {
  let tasks = await fetchTasks();
-  return json(tasks, {
+  return data(tasks, {
    headers: {
      "Cache-Control": "public, max-age=604800"
    }
  });
}

----------------------------------------

TITLE: Preventing Scroll Reset in Remix Navigation
DESCRIPTION: These snippets demonstrate how to prevent the default scroll reset behavior when navigating using Link or Form components in Remix.

LANGUAGE: tsx
CODE:
<Link preventScrollReset={true} />;
<Form preventScrollReset={true} />;

----------------------------------------

TITLE: Defining Vanilla Extract Styles
DESCRIPTION: Example of creating CSS styles using Vanilla Extract in a .css.ts file. Demonstrates style creation using the style function to define button styles.

LANGUAGE: typescript
CODE:
import { style } from "@vanilla-extract/css";

export const root = style({
  border: "solid 1px",
  background: "white",
  color: "#454545",
});

----------------------------------------

TITLE: Configuring Express Server with HTTPS
DESCRIPTION: Example of setting up an Express server with HTTPS using local TLS certificates. Demonstrates how to create an HTTPS server instance with custom certificates.

LANGUAGE: typescript
CODE:
import fs from "node:fs";
import https from "node:https";
import path from "node:path";

import express from "express";

const BUILD_DIR = path.resolve(__dirname, "build");
const build = require(BUILD_DIR);

const app = express();

// ... code setting up your express app goes here ...

const server = https.createServer(
  {
    key: fs.readFileSync("path/to/key.pem"),
    cert: fs.readFileSync("path/to/cert.pem"),
  },
  app
);

const port = 3000;
server.listen(port, () => {
  // ... code to run after your server is running goes here ...
});

----------------------------------------

TITLE: Defining types for MDX files in Remix Vite
DESCRIPTION: Example of how to define types for MDX files when using Remix Vite

LANGUAGE: typescript
CODE:
/// <reference types="@remix-run/node" />
/// <reference types="vite/client" />

declare module "*.mdx" {
  let MDXComponent: (props: any) => JSX.Element;
  export const frontmatter: any;
  export default MDXComponent;
}

----------------------------------------

TITLE: Implementing LiveReload Component in Remix Root Component
DESCRIPTION: This snippet demonstrates how to include the LiveReload component in the root component of a Remix application. The LiveReload component is imported from @remix-run/react and rendered within the body tag.

LANGUAGE: tsx
CODE:
import { LiveReload } from "@remix-run/react";

export default function Root() {
  return (
    <html>
      <head />
      <body>
        <LiveReload />
      </body>
    </html>
  );
}

----------------------------------------

TITLE: Adding Custom Headers to redirectDocument in Remix
DESCRIPTION: This snippet illustrates how to use redirectDocument with a ResponseInit object to add custom headers, such as setting a cookie during the redirect process.

LANGUAGE: ts
CODE:
redirectDocument(path, {
  headers: {
    "Set-Cookie": await commitSession(session),
  },
});

----------------------------------------

TITLE: Configuring Host Address in Remix App Server
DESCRIPTION: Example of setting the HOST environment variable to configure the server's hostname when starting the Remix App Server.

LANGUAGE: shellscript
CODE:
HOST=127.0.0.1 npx remix-serve build/index.js

----------------------------------------

TITLE: Implementing Meta Component in Remix Root Component
DESCRIPTION: Demonstrates how to implement the Meta component from @remix-run/react within the root component of a Remix application. The Meta component should be placed inside the HTML head element to properly render meta tags defined in route modules.

LANGUAGE: tsx
CODE:
import { Meta } from "@remix-run/react";

export default function Root() {
  return (
    <html>
      <head>
        <Meta />
      </head>
      <body></body>
    </html>
  );
}

----------------------------------------

TITLE: Optimizing Revalidation for Nested Routes
DESCRIPTION: This snippet demonstrates how to optimize revalidation for nested routes by checking params and form method in shouldRevalidate.

LANGUAGE: tsx
CODE:
export function shouldRevalidate({
  currentParams,
  nextParams,
  formMethod,
  defaultShouldRevalidate,
}) {
  if (
    formMethod === "GET" &&
    currentParams.projectId === nextParams.projectId
  ) {
    return false;
  }

  return defaultShouldRevalidate;
}

----------------------------------------

TITLE: Generated HTML Output from Meta Function
DESCRIPTION: The resulting HTML tags generated from the meta function implementation.

LANGUAGE: html
CODE:
<title>Very cool app | Remix</title>
<meta property="og:title" content="Very cool app" />;
<meta name="description" content="This app is the best" />

----------------------------------------

TITLE: Configuring Vanilla Extract for Remix Vite
DESCRIPTION: Example of how to configure the Vanilla Extract plugin for use with Remix Vite

LANGUAGE: typescript
CODE:
import { vitePlugin as remix } from "@remix-run/dev";
import { vanillaExtractPlugin } from "@vanilla-extract/vite-plugin";
import { defineConfig } from "vite";

export default defineConfig({
  plugins: [remix(), vanillaExtractPlugin()],
});

----------------------------------------

TITLE: Using useMatches Hook in React Component
DESCRIPTION: Demonstrates basic usage of the useMatches hook within a React component to access current route matches.

LANGUAGE: tsx
CODE:
function SomeComponent() {
  const matches = useMatches();

  // ...
}

----------------------------------------

TITLE: Using useMatches Hook in React Component
DESCRIPTION: Demonstrates basic usage of the useMatches hook within a React component to access current route matches.

LANGUAGE: tsx
CODE:
function SomeComponent() {
  const matches = useMatches();

  // ...
}

----------------------------------------

TITLE: Basic Usage Diff - Remix Multipart Form Data Parser
DESCRIPTION: Shows the difference between using standard formData and unstable_parseMultipartFormData.

LANGUAGE: diff
CODE:
- const formData = await request.formData();
+ const formData = await unstable_parseMultipartFormData(request, uploadHandler);

----------------------------------------

TITLE: Using reloadDocument with Link in Remix
DESCRIPTION: Demonstrates how to use the reloadDocument prop to force a full page reload instead of client-side routing.

LANGUAGE: tsx
CODE:
<Link to="/logout" reloadDocument />

----------------------------------------

TITLE: Handling Structured Data in Remix Forms
DESCRIPTION: This snippet shows various methods for handling structured data in Remix forms, including using multiple inputs with the same name, non-standard form-field naming conventions, and JSON in hidden fields.

LANGUAGE: tsx
CODE:
<Form method="post">
  <p>Select the categories for this video:</p>
  <label>
    <input type="checkbox" name="category" value="comedy" />{" "}
    Comedy
  </label>
  <label>
    <input type="checkbox" name="category" value="music" />{" "}
    Music
  </label>
  <label>
    <input type="checkbox" name="category" value="howto" />{" "}
    How-To
  </label>
</Form>

LANGUAGE: typescript
CODE:
export async function action({
  request,
}: ActionFunctionArgs) {
  const formData = await request.formData();
  const categories = formData.getAll("category");
  // ["comedy", "music"]
}

LANGUAGE: tsx
CODE:
<>
  // arrays with []
  <input name="category[]" value="comedy" />
  <input name="category[]" value="comedy" />
  // nested structures parentKey[childKey]
  <input name="user[name]" value="Ryan" />
</>

LANGUAGE: typescript
CODE:
import queryString from "query-string";

// in your action:
export async function action({
  request,
}: ActionFunctionArgs) {
  // use `request.text()`, not `request.formData` to get the form data as a url
  // encoded form query string
  const formQueryString = await request.text();

  // parse it into an object
  const obj = queryString.parse(formQueryString);
}

LANGUAGE: tsx
CODE:
<input
  type="hidden"
  name="json"
  value={JSON.stringify(obj)}
/>

LANGUAGE: typescript
CODE:
export async function action({
  request,
}: ActionFunctionArgs) {
  const formData = await request.formData();
  const obj = JSON.parse(formData.get("json"));
}

----------------------------------------

TITLE: Augmenting Server Data with Client-Side Data using HydrateFallback in Remix
DESCRIPTION: This example illustrates how to combine server-side data with client-side user preferences using HydrateFallback and clientLoader in Remix. It demonstrates the usage of both server and client loaders, and conditional rendering based on user preferences.

LANGUAGE: tsx
CODE:
export async function loader() {
  const data = getServerData();
  return json(data);
}

export async function clientLoader({
  request,
  params,
  serverLoader,
}: ClientLoaderFunctionArgs) {
  const [serverData, preferences] = await Promise.all([
    serverLoader(),
    getUserPreferences(),
  ]);
  return {
    ...serverData,
    preferences,
  };
}
clientLoader.hydrate = true;

export function HydrateFallback() {
  return <p>Loading user preferences...</p>;
}

export default function Component() {
  const data = useLoaderData<typeof clientLoader>();
  if (data.preferences.display === "list") {
    return <ListView items={data.items} />;
  } else {
    return <GridView items={data.items} />;
  }
}

----------------------------------------

TITLE: Creating a new Remix project with Vite
DESCRIPTION: Commands to create new Remix projects using different Vite-based templates

LANGUAGE: shellscript
CODE:
# Minimal server:
npx create-remix@latest

# Express:
npx create-remix@latest --template remix-run/remix/templates/express

# Cloudflare:
npx create-remix@latest --template remix-run/remix/templates/cloudflare

# Cloudflare Workers:
npx create-remix@latest --template remix-run/remix/templates/cloudflare-workers

----------------------------------------

TITLE: useHref Function Signature
DESCRIPTION: Shows the function signature for useHref hook including the to parameter and options object. The options object allows specifying relative URL resolution behavior.

LANGUAGE: typescript
CODE:
useHref(to, options)

----------------------------------------

TITLE: Importing Tailwind CSS in Remix Root
DESCRIPTION: TypeScript/React code for importing and linking Tailwind CSS styles in the Remix root component.

LANGUAGE: tsx
CODE:
import type { LinksFunction } from "@remix-run/node"; // or cloudflare/deno

// ...

import styles from "./tailwind.css?url";

export const links: LinksFunction = () => [
  { rel: "stylesheet", href: styles },
];

----------------------------------------

TITLE: Importing and Using Link Component in Remix
DESCRIPTION: Demonstrates how to import the Link component from @remix-run/react and use it for client-side navigation.

LANGUAGE: tsx
CODE:
import { Link } from "@remix-run/react";

<Link to="/dashboard">Dashboard</Link>;

----------------------------------------

TITLE: Configuring Vite for TypeScript
DESCRIPTION: Example of how to configure tsconfig.json for use with Vite in Remix

LANGUAGE: json
CODE:
{
  "compilerOptions": {
    "types": ["@remix-run/node", "vite/client"],
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "Bundler"
  }
}

----------------------------------------

TITLE: Styling Pending NavLink in CSS
DESCRIPTION: Demonstrates how to style a pending NavLink using CSS by targeting the automatically added 'pending' class.

LANGUAGE: css
CODE:
a.pending {
  color: red;
}

----------------------------------------

TITLE: Throwing a 404 Response in Remix Loader
DESCRIPTION: This code snippet demonstrates how to throw a 404 response in a Remix loader function when a requested page is not found in the database. It uses the `Response` object to create a 404 status response.

LANGUAGE: tsx
CODE:
export async function loader({
  params,
}: LoaderFunctionArgs) {
  const page = await db.page.findOne({
    where: { slug: params.slug },
  });

  if (!page) {
    throw new Response(null, {
      status: 404,
      statusText: "Not Found",
    });
  }

  return json(page);
}

----------------------------------------

TITLE: Passing Loader Headers to Route Headers in Remix
DESCRIPTION: Shows how to access and use loader headers in a route's headers function. This example passes the Cache-Control header from the loader to the route, allowing the data source to control caching behavior.

LANGUAGE: tsx
CODE:
export function headers({
  loaderHeaders,
}: {
  loaderHeaders: Headers;
}) {
  return {
    "Cache-Control": loaderHeaders.get("Cache-Control"),
  };
}

----------------------------------------

TITLE: Creating Pending Links with NavLink in Remix
DESCRIPTION: This example shows how to use the NavLink component's className callback to indicate pending navigation states for links in a Remix application.

LANGUAGE: tsx
CODE:
import { NavLink } from "@remix-run/react";

export function ProjectList({ projects }) {
  return (
    <nav>
      {projects.map((project) => (
        <NavLink
          key={project.id}
          to={project.id}
          className={({ isPending }) =>
            isPending ? "pending" : null
          }
        >
          {project.name}
        </NavLink>
      ))}
    </nav>
  );
}

----------------------------------------

TITLE: Implementing Fullstack State in Remix
DESCRIPTION: This snippet shows how to combine server and client data sources in Remix. It loads partial data from the server loader, uses a HydrateFallback component for SSR, and combines server and client data in the clientLoader.

LANGUAGE: tsx
CODE:
import type { LoaderFunctionArgs } from "@remix-run/node";
import { json } from "@remix-run/node";
import type { ClientLoaderFunctionArgs } from "@remix-run/react";

export async function loader({
  request,
}: LoaderFunctionArgs) {
  const partialData = await getPartialDataFromDb({
    request,
  }); // (1)
  return json(partialData);
}

export async function clientLoader({
  request,
  serverLoader,
}: ClientLoaderFunctionArgs) {
  const [serverData, clientData] = await Promise.all([
    serverLoader(),
    getClientData(request),
  ]);
  return {
    ...serverData, // (4)
    ...clientData, // (4)
  };
}
clientLoader.hydrate = true; // (3)

export function HydrateFallback() {
  return <p>Skeleton rendered during SSR</p>; // (2)
}

export default function Component() {
  // This will always be the combined set of server + client data
  const data = useLoaderData();
  return <>...</>;
}

----------------------------------------

TITLE: Server Dependencies Bundle Configuration
DESCRIPTION: Configuration for handling ESM-only packages in CJS builds by specifying patterns for modules to be transpiled and bundled with the server build.

LANGUAGE: javascript
CODE:
/** @type {import('@remix-run/dev').AppConfig} */
module.exports = {
  appDirectory: "app",
  assetsBuildDirectory: "public/build",
  publicPath: "/build/",
  serverBuildPath: "build/index.js",
  ignoredRouteFiles: ["**/*.css"],
  serverDependenciesToBundle: [
    /^rehype.*/,
    /^remark.*/,
    /^unified.*/,
    "@sindresorhus/slugify",
  ],
};

----------------------------------------

TITLE: Custom Server Integration with v2_dev
DESCRIPTION: Example of integrating v2_dev with a custom server setup

LANGUAGE: javascript
CODE:
import { broadcastDevReady } from "@remix-run/node";

const BUILD_DIR = path.join(process.cwd(), "build");

const port = 3000;
app.listen(port, async () => {
  console.log(`👉 http://localhost:${port}`);
  broadcastDevReady(await import(BUILD_DIR));
});

----------------------------------------

TITLE: Applying View Transition Styles with Link in Remix
DESCRIPTION: Demonstrates how to use useViewTransitionState hook with Link to apply specific styles for view transitions.

LANGUAGE: jsx
CODE:
function ImageLink(to) {
  const isTransitioning = useViewTransitionState(to);
  return (
    <Link to={to} viewTransition>
      <p
        style={{
          viewTransitionName: isTransitioning
            ? "image-title"
            : "",
        }}
      >
        Image Number {idx}
      </p>
      <img
        src={src}
        alt={`Img ${idx}`}
        style={{
          viewTransitionName: isTransitioning
            ? "image-expand"
            : "",
        }}
      />
    </Link>
  );
}

----------------------------------------

TITLE: Await Component Error Handling
DESCRIPTION: Demonstrates error handling using errorElement prop and useAsyncError hook.

LANGUAGE: tsx
CODE:
<Await errorElement={<div>Oops!</div>} />

LANGUAGE: tsx
CODE:
import { useAsyncError } from "@remix-run/react";

function SomeChild() {
  const error = useAsyncError();
  return <p>{error.message}</p>;
}

----------------------------------------

TITLE: Accessing Build Manifest in Vite Plugin Configuration
DESCRIPTION: Shows how to implement the buildEnd hook in the Remix Vite plugin configuration to access the build manifest. This allows inspection of the final build output and routing configuration.

LANGUAGE: typescript
CODE:
import { vitePlugin as remix } from "@remix-run/dev";
import { defineConfig } from "vite";

export default defineConfig({
  plugins: [
    remix({
      // ...
      buildEnd: async ({ buildManifest }) => {
        // ...
      },
    }),
  ],
});

----------------------------------------

TITLE: Enhanced Remix Form with Pending UI
DESCRIPTION: Demonstrates an enhanced Remix Form component with pending UI and disabled state during submission.

LANGUAGE: TypeScript
CODE:
export default function NewProject() {
  const navigation = useNavigation();
  const actionData = useActionData<typeof action>();

  return (
    <Form method="post">
      <fieldset
        disabled={navigation.state === "submitting"}
      >
        <p>
          <label>
            Name:{" "}
            <input
              name="name"
              type="text"
              defaultValue={
                actionData
                  ? actionData.values.name
                  : undefined
              }
            />
          </label>
        </p>

        {actionData && actionData.errors.name ? (
          <p style={{ color: "red" }}>
            {actionData.errors.name}
          </p>
        ) : null}

        <p>
          <label>
            Description:
            <br />
            <textarea
              name="description"
              defaultValue={
                actionData
                  ? actionData.values.description
                  : undefined
              }
            />
          </label>
        </p>

        {actionData && actionData.errors.description ? (
          <p style={{ color: "red" }}>
            {actionData.errors.description}
          </p>
        ) : null}

        <p>
          <button type="submit">
            {navigation.state === "submitting"
              ? "Creating..."
              : "Create"}
          </button>
        </p>
      </fieldset>
    </Form>
  );
}

----------------------------------------

TITLE: Blog Post Route with Single Fetch - TypeScript/TSX
DESCRIPTION: Example of a blog post route implementation using Single Fetch features to handle async data loading and streaming comments.

LANGUAGE: tsx
CODE:
export async function loader({
  params,
}: LoaderFunctionArgs) {
  const { slug } = params;

  const comments = fetchComments(slug);
  const blogData = await fetchBlogData(slug);

  return {
    content: blogData.content, // <- string
    published: blogData.date, // <- Date
    comments, // <- Promise
  };
}

export default function BlogPost() {
  const blogData = useLoaderData<typeof loader>();
  //    ^? { content: string, published: Date, comments: Promise }

  return (
    <>
      <Header published={blogData.date} />
      <BlogContent content={blogData.content} />
      <Suspense fallback={<CommentsSkeleton />}>
        <Await resolve={blogData.comments}>
          {(comments) => (
            <BlogComments comments={comments} />
          )}
        </Await>
      </Suspense>
    </>
  );
}

----------------------------------------

TITLE: Removing installGlobals from Vite Config
DESCRIPTION: Diff showing how to remove the installGlobals call from the Vite configuration file.

LANGUAGE: typescript
CODE:
import { vitePlugin as remix } from "@remix-run/dev";
import { defineConfig } from "vite";

-installGlobals();

export default defineConfig({
  plugins: [remix()],
});

----------------------------------------

TITLE: Creating Basic Vite Config for Remix
DESCRIPTION: Basic Vite configuration file for a Remix app using the Remix Vite plugin.

LANGUAGE: typescript
CODE:
import { vitePlugin as remix } from "@remix-run/dev";
import { defineConfig } from "vite";

export default defineConfig({
  plugins: [remix()],
});

----------------------------------------

TITLE: Setting Up Tailwind Base CSS
DESCRIPTION: Basic CSS file with Tailwind directives for importing base styles, components, and utilities.

LANGUAGE: css
CODE:
@tailwind base;
@tailwind components;
@tailwind utilities;

----------------------------------------

TITLE: Direct data return vs data utility comparison
DESCRIPTION: Illustrates the correct and incorrect usage patterns of the data utility, showing when to use direct return versus the data utility function in Remix loaders.

LANGUAGE: tsx
CODE:
export const loader = async () => {
  // ❌ Bad
  return data({ not: "coffee" });

  // ✅ Good
  return { not: "coffee" };
};

----------------------------------------

TITLE: Configuring Remix Options in Vite Config
DESCRIPTION: Example of passing Remix-specific options to the Remix Vite plugin.

LANGUAGE: typescript
CODE:
export default defineConfig({
  plugins: [
    remix({
      ignoredRouteFiles: ["**/*.css"],
    }),
  ],
});

----------------------------------------

TITLE: Enabling unstable_optimizeDeps in Vite Config
DESCRIPTION: Configuration to enable the unstable_optimizeDeps future flag in the Remix Vite plugin.

LANGUAGE: typescript
CODE:
export default defineConfig({
  plugins: [
    remix({
      future: {
        unstable_optimizeDeps: true,
      },
    }),
  ],
});

----------------------------------------

TITLE: Implementing Data Loading in Remix Route
DESCRIPTION: Demonstrates how to create a route that loads and displays team data using Remix's loader function and useLoaderData hook.

LANGUAGE: tsx
CODE:
export async function loader() {
  return json(await getTeams());
}

export default function Teams() {
  return (
    <TeamsView teams={useLoaderData<typeof loader>()} />
  );
}

----------------------------------------

TITLE: Browser Node Builtins Polyfill Configuration
DESCRIPTION: Configuration for Node.js polyfills in browser builds using JSPM, allowing specification of module and global polyfills.

LANGUAGE: javascript
CODE:
/** @type {import('@remix-run/dev').AppConfig} */
module.exports = {
  browserNodeBuiltinsPolyfill: {
    modules: {
      buffer: true, // Provide a JSPM polyfill
      fs: "empty", // Provide an empty polyfill
    },
    globals: {
      Buffer: true,
    },
  },
};

----------------------------------------

TITLE: Basic Route Module with Server and Browser Code
DESCRIPTION: Example of a typical Remix route module showing server-side loader, meta function, and client-side component rendering.

LANGUAGE: tsx
CODE:
import { json } from "@remix-run/node";
import { useLoaderData } from "@remix-run/react";

import { prisma } from "../db";
import PostsView from "../PostsView";

export async function loader() {
  return json(await prisma.post.findMany());
}

export function meta() {
  return [{ title: "Posts" }];
}

export default function Posts() {
  const posts = useLoaderData<typeof loader>();
  return <PostsView posts={posts} />;
}

----------------------------------------

TITLE: Package.json Configuration
DESCRIPTION: Essential package.json configurations including module type and script commands for development and production.

LANGUAGE: json
CODE:
{
  "type": "module",
  "scripts": {
    "dev": "node ./server.js",
    "start": "cross-env NODE_ENV=production node ./server.js"
  }
}

----------------------------------------

TITLE: Updated Error Boundary Implementation
DESCRIPTION: Example showing how to update error boundary handling for v2

LANGUAGE: typescript
CODE:
import {
  useRouteError,
  isRouteErrorResponse,
} from "@remix-run/react";

export function ErrorBoundary() {
  const error = useRouteError();

  if (isRouteErrorResponse(error)) {
    return (
      <div>
        <h1>Oops</h1>
        <p>Status: {error.status}</p>
        <p>{error.data.message}</p>
      </div>
    );
  }

  let errorMessage = "Unknown error";
  if (isDefinitelyAnError(error)) {
    errorMessage = error.message;
  }

  return (
    <div>
      <h1>Uh oh ...</h1>
      <p>Something went wrong.</p>
      <pre>{errorMessage}</pre>
    </div>
  );
}

----------------------------------------

TITLE: Basic MDX Route Configuration with Frontmatter
DESCRIPTION: Example of MDX route configuration using frontmatter for metadata and headers definition

LANGUAGE: markdown
CODE:
---
meta:
  - title: My First Post
  - name: description
    content: Isn't this awesome?
headers:
  Cache-Control: no-cache
---

# Hello Content!

----------------------------------------

TITLE: Enabling v3_relativeSplatPath Future Flag
DESCRIPTION: Configuration to enable the v3_relativeSplatPath future flag in the Remix Vite plugin.

LANGUAGE: typescript
CODE:
remix({
  future: {
    v3_relativeSplatPath: true,
  },
});

----------------------------------------

TITLE: Implementing City Search Combobox with Remix Fetcher
DESCRIPTION: Creates a combobox component that uses Remix's useFetcher hook to dynamically fetch and display city search results.

LANGUAGE: tsx
CODE:
function CitySearchCombobox() {
  const cities = useFetcher();

  return (
    <cities.Form method="get" action="/city-search">
      <Combobox aria-label="Cities">
        <div>
          <ComboboxInput
            name="q"
            onChange={(event) =>
              cities.submit(event.target.form)
            }
          />
          {cities.state === "submitting" ? (
            <Spinner />
          ) : null}
        </div>

        {cities.data ? (
          <ComboboxPopover className="shadow-popup">
            {cities.data.error ? (
              <p>Failed to load cities :(</p>
            ) : cities.data.length ? (
              <ComboboxList>
                {cities.data.map((city) => (
                  <ComboboxOption
                    key={city.id}
                    value={city.name}
                  />
                ))}
              </ComboboxList>
            ) : (
              <span>No results found</span>
            )}
          </ComboboxPopover>
        ) : null}
      </Combobox>
    </cities.Form>
  );
}

----------------------------------------

TITLE: Updating root.tsx for Remix SPA Hydration
DESCRIPTION: Modifications to root.tsx to support hydrating a specific div in Remix SPA mode.

LANGUAGE: typescript
CODE:
export function HydrateFallback() {
  return (
    <>
      <p>Loading...</p>
      <Scripts />
    </>
  );
}

export default function Component() {
  return (
    <>
      <Outlet />
      <Scripts />
    </>
  );
}

----------------------------------------

TITLE: Implementing Busy Indicator for Page Navigation in Remix
DESCRIPTION: This snippet demonstrates how to use the useNavigation hook to display a spinner during page navigation in a Remix application.

LANGUAGE: tsx
CODE:
import { useNavigation } from "@remix-run/react";

function PendingNavigation() {
  const navigation = useNavigation();
  return navigation.state === "loading" ? (
    <div className="spinner" />
  ) : null;
}

----------------------------------------

TITLE: Updating entry.client.tsx for Remix SPA Hydration
DESCRIPTION: Modifications to entry.client.tsx to hydrate a specific div instead of the full document in Remix SPA mode.

LANGUAGE: typescript
CODE:
import { RemixBrowser } from "@remix-run/react";
import { startTransition, StrictMode } from "react";
import { hydrateRoot } from "react-dom/client";

startTransition(() => {
  hydrateRoot(
    document.querySelector("#app"),
    <StrictMode>
      <RemixBrowser />
    </StrictMode>
  );
});

----------------------------------------

TITLE: Example .env File Content for Remix
DESCRIPTION: Demonstrates the format for defining environment variables in a .env file for Remix projects.

LANGUAGE: sh
CODE:
SOME_SECRET=super-secret

----------------------------------------

TITLE: Enabling v3_throwAbortReason Future Flag
DESCRIPTION: Configuration to enable the v3_throwAbortReason future flag in the Remix Vite plugin.

LANGUAGE: typescript
CODE:
remix({
  future: {
    v3_throwAbortReason: true,
  },
});

----------------------------------------

TITLE: Basic PostCSS Configuration with Autoprefixer
DESCRIPTION: Basic PostCSS configuration file setup that enables Autoprefixer plugin for CSS processing.

LANGUAGE: javascript
CODE:
module.exports = {
  plugins: {
    autoprefixer: {},
  },
};

----------------------------------------

TITLE: Using Link Component from Remix (Correct)
DESCRIPTION: Demonstrates the correct usage of the Link component in a Remix application. This approach enables Remix-specific features like prefetching of data and assets.

LANGUAGE: tsx
CODE:
import { Link } from "@remix-run/react";

// this will prefetch data and assets
<Link prefetch="intent" />;

----------------------------------------

TITLE: Module Side Effects Example
DESCRIPTION: Example showing module side effects that persist even when module cache is cleared, which should be avoided in development mode.

LANGUAGE: typescript
CODE:
import { json } from "@remix-run/node"; // or cloudflare/deno

// this starts running the moment the module is imported
setInterval(() => {
  console.log(Date.now());
}, 1000);

export async function loader() {
  // ...
}

----------------------------------------

TITLE: Creating Initial Empty routes.ts File
DESCRIPTION: Initial setup for an empty routes.ts file when migrating to config-based routing.

LANGUAGE: typescript
CODE:
import type { RouteConfig } from "@remix-run/route-config";

export default [] satisfies RouteConfig;

----------------------------------------

TITLE: Using useRevalidator for Window Focus Revalidation in React
DESCRIPTION: This snippet demonstrates how to use the useRevalidator hook to revalidate data when the window regains focus. It creates a component that triggers revalidation and displays a loading message.

LANGUAGE: tsx
CODE:
import { useRevalidator } from "@remix-run/react";

function WindowFocusRevalidator() {
  const revalidator = useRevalidator();

  useFakeWindowFocus(() => {
    revalidator.revalidate();
  });

  return (
    <div hidden={revalidator.state === "idle"}>
      Revalidating...
    </div>
  );
}

----------------------------------------

TITLE: Prisma Schema Definition
DESCRIPTION: Database schema definition for the jokes application using Prisma

LANGUAGE: Prisma
CODE:
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model Joke {
  id         String   @id @default(uuid())
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  name       String
  content    String
}

----------------------------------------

TITLE: Handling Route Parameters in Remix Loader (TypeScript)
DESCRIPTION: Demonstrates how to access and use route parameters in a loader function. The example shows fetching an invoice by ID from the route parameters.

LANGUAGE: tsx
CODE:
export async function loader({
  params,
}: LoaderFunctionArgs) {
  const invoice = await fakeDb.getInvoice(params.invoiceId);
  if (!invoice) throw new Response("", { status: 404 });
  return json(invoice);
}

----------------------------------------

TITLE: Advanced Navigation Options in Remix
DESCRIPTION: Demonstrates the use of additional options with useNavigate for more control over navigation behavior.

LANGUAGE: tsx
CODE:
navigate(".", {
  replace: true,
  relative: "path",
  state: { some: "state" },
});

----------------------------------------

TITLE: Installing Remix Global Polyfills in TypeScript
DESCRIPTION: Demonstrates how to install browser API globals like fetch, Response, Request, and Headers for Node.js testing environments. This is necessary for unit tests but not required in actual Remix applications where these are automatically installed.

LANGUAGE: typescript
CODE:
import { installGlobals } from "@remix-run/node";

// This installs globals such as "fetch", "Response", "Request" and "Headers".
installGlobals();

----------------------------------------

TITLE: Custom Dev Script Configuration
DESCRIPTION: Package.json configuration for custom dev server integration with Remix.

LANGUAGE: json
CODE:
{
  "scripts": {
    "dev": "remix dev -c \"node ./server.js\""
  }
}

----------------------------------------

TITLE: Combining Multiple Route Config Approaches
DESCRIPTION: Example of combining different route configuration approaches in a single routes.ts file.

LANGUAGE: typescript
CODE:
import { flatRoutes } from "@remix-run/fs-routes";
import type { RouteConfig } from "@remix-run/route-config";
import { route } from "@remix-run/route-config";
import { remixRoutesOptionAdapter } from "@remix-run/routes-option-adapter";

export default [
  ...(await flatRoutes({ rootDirectory: "fs-routes" })),

  ...(await remixRoutesOptionAdapter(/* ... */)),

  route("/hello", "routes/hello.tsx"),
] satisfies RouteConfig;

----------------------------------------

TITLE: Setting Prefetch Behavior for Link in Remix
DESCRIPTION: Shows various options for the prefetch prop to control data and module prefetching behavior of the Link component.

LANGUAGE: tsx
CODE:
<>
  <Link /> {/* defaults to "none" */}
  <Link prefetch="none" />
  <Link prefetch="intent" />
  <Link prefetch="render" />
  <Link prefetch="viewport" />
</>

----------------------------------------

TITLE: Importing Runtime-Specific Session Storage in Remix
DESCRIPTION: Demonstrates how to import session storage functions for different runtimes in Remix. It shows examples for Cloudflare KV storage and Node.js file system storage.

LANGUAGE: typescript
CODE:
// store sessions in cloudflare KV storage
import { createWorkersKVSessionStorage } from "@remix-run/cloudflare";

// store sessions on the file system in node
import { createFileSessionStorage } from "@remix-run/node";

----------------------------------------

TITLE: Global Headers Configuration in entry.server.tsx
DESCRIPTION: Shows how to configure global HTTP headers that apply to all document requests in the entry.server.tsx file.

LANGUAGE: tsx
CODE:
import type {
  AppLoadContext,
  EntryContext,
} from "@remix-run/node"; // or cloudflare/deno
import { RemixServer } from "@remix-run/react";
import { renderToString } from "react-dom/server";

export default function handleRequest(
  request: Request,
  responseStatusCode: number,
  responseHeaders: Headers,
  remixContext: EntryContext,
  loadContext: AppLoadContext
) {
  const markup = renderToString(
    <RemixServer context={remixContext} url={request.url} />
  );

  responseHeaders.set("Content-Type", "text/html");
  responseHeaders.set("X-Powered-By", "Hugs");

  return new Response("<!DOCTYPE html>" + markup, {
    headers: responseHeaders,
    status: responseStatusCode,
  });
}

----------------------------------------

TITLE: HTML Form for Creating a Project
DESCRIPTION: Demonstrates an HTML form for creating a new project using POST method.

LANGUAGE: HTML
CODE:
<form method="post" action="/projects">
  <label><input name="name" type="text" /></label>
  <label><textarea name="description"></textarea></label>
  <button type="submit">Create</button>
</form>

----------------------------------------

TITLE: Basic Form Action Examples with Index Parameter
DESCRIPTION: Demonstrates the basic usage of Form components with and without the ?index parameter to target different routes.

LANGUAGE: tsx
CODE:
<Form method="post" action="/projects" />;
<Form method="post" action="/projects?index" />;

----------------------------------------

TITLE: HTML Form with Multiple Inputs
DESCRIPTION: Shows an HTML form with multiple checkbox inputs for filtering search results.

LANGUAGE: HTML
CODE:
<form method="get" action="/search">
  <fieldset>
    <legend>Brand</legend>
    <label>
      <input name="brand" value="nike" type="checkbox" />
      Nike
    </label>
    <label>
      <input name="brand" value="reebok" type="checkbox" />
      Reebok
    </label>
    <label>
      <input name="color" value="white" type="checkbox" />
      White
    </label>
    <label>
      <input name="color" value="black" type="checkbox" />
      Black
    </label>
    <button type="submit">Search</button>
  </fieldset>
</form>

----------------------------------------

TITLE: Augmenting load context for Cloudflare
DESCRIPTION: Example of how to augment the load context for Cloudflare in Remix

LANGUAGE: typescript
CODE:
import { type AppLoadContext } from "@remix-run/cloudflare";
import { type PlatformProxy } from "wrangler";

// When using `wrangler.toml` to configure bindings,
// `wrangler types` will generate types for those bindings
// into the global `Env` interface.
// Need this empty interface so that typechecking passes
// even if no `wrangler.toml` exists.
interface Env {}

type Cloudflare = Omit<PlatformProxy<Env>, "dispose">;

declare module "@remix-run/cloudflare" {
  interface AppLoadContext {
    cloudflare: Cloudflare;
    extra: string; // augmented
  }
}

type GetLoadContext = (args: {
  request: Request;
  context: { cloudflare: Cloudflare }; // load context _before_ augmentation
}) => AppLoadContext;

// Shared implementation compatible with Vite, Wrangler, and Cloudflare Pages
export const getLoadContext: GetLoadContext = ({
  context,
}) => {
  return {
    ...context,
    extra: "stuff",
  };
};

----------------------------------------

TITLE: Replace Function with Response Headers
DESCRIPTION: Shows how to use replace function with ResponseInit object to include custom headers, specifically demonstrating session management through Set-Cookie header.

LANGUAGE: typescript
CODE:
replace(path, {
  headers: {
    "Set-Cookie": await commitSession(session),
  },
});

----------------------------------------

TITLE: Submit Function with Index Parameter
DESCRIPTION: Illustrates using the useSubmit hook with and without the index parameter for programmatic form submissions.

LANGUAGE: tsx
CODE:
function Component() {
  const submit = useSubmit();
  submit({}, { action: "/projects" });
  submit({}, { action: "/projects?index" });
}

----------------------------------------

TITLE: Remix Form Component with Validation
DESCRIPTION: Shows a Remix Form component with input validation and error display.

LANGUAGE: TypeScript
CODE:
export default function NewProject() {
  const actionData = useActionData<typeof action>();

  return (
    <form method="post" action="/projects/new">
      <p>
        <label>
          Name:{" "}
          <input
            name="name"
            type="text"
            defaultValue={actionData?.values.name}
          />
        </label>
      </p>

      {actionData?.errors.name ? (
        <p style={{ color: "red" }}>
          {actionData.errors.name}
        </p>
      ) : null}

      <p>
        <label>
          Description:
          <br />
          <textarea
            name="description"
            defaultValue={actionData?.values.description}
          />
        </label>
      </p>

      {actionData?.errors.description ? (
        <p style={{ color: "red" }}>
          {actionData.errors.description}
        </p>
      ) : null}

      <p>
        <button type="submit">Create</button>
      </p>
    </form>
  );
}

----------------------------------------

TITLE: Styling Transitioning NavLink with View Transition
DESCRIPTION: Shows how to apply view transition styles to a NavLink using the 'transitioning' class.

LANGUAGE: css
CODE:
a.transitioning {
  view-transition-name: my-transition;
}

----------------------------------------

TITLE: Running Specific Tests in Remix
DESCRIPTION: Example of running tests for a specific project within Remix using pnpm and jest, demonstrating how to filter tests by project, file, and test name.

LANGUAGE: shellscript
CODE:
pnpm test:primary --selectProjects react --testPathPattern transition --testNamePattern "initial values"

----------------------------------------

TITLE: Creating Cookie Session Storage in Remix
DESCRIPTION: This snippet demonstrates how to create a cookie-based session storage in Remix. It sets up the session with custom options like name, domain, and security settings.

LANGUAGE: typescript
CODE:
// app/sessions.ts
import { createCookieSessionStorage } from "@remix-run/node"; // or cloudflare/deno

type SessionData = {
  userId: string;
};

type SessionFlashData = {
  error: string;
};

const { getSession, commitSession, destroySession } =
  createCookieSessionStorage<SessionData, SessionFlashData>(
    {
      // a Cookie from `createCookie` or the CookieOptions to create one
      cookie: {
        name: "__session",

        // all of these are optional
        domain: "remix.run",
        // Expires can also be set (although maxAge overrides it when used in combination).
        // Note that this method is NOT recommended as `new Date` creates only one date on each server deployment, not a dynamic date in the future!
        //
        // expires: new Date(Date.now() + 60_000),
        httpOnly: true,
        maxAge: 60,
        path: "/",
        sameSite: "lax",
        secrets: ["s3cret1"],
        secure: true,
      },
    }
  );

export { getSession, commitSession, destroySession };

----------------------------------------

TITLE: Await Component with useAsyncValue Hook
DESCRIPTION: Shows how to access resolved values in child components using the useAsyncValue hook.

LANGUAGE: tsx
CODE:
<Await resolve={somePromise}>
  <SomeChild />
</Await>

LANGUAGE: tsx
CODE:
import { useAsyncValue } from "@remix-run/react";

function SomeChild() {
  const value = useAsyncValue();
  return <p>{value}</p>;
}

----------------------------------------

TITLE: Creating Development Request Handler
DESCRIPTION: Function to create a development-mode request handler that watches for server updates and manages rebuilds

LANGUAGE: javascript
CODE:
/**
 * @param {ServerBuild} initialBuild
 */
function createDevRequestHandler(initialBuild) {
  let build = initialBuild;
  async function handleServerUpdate() {
    // 1. re-import the server build
    build = await reimportServer();
    // 2. tell Remix that this app server is now up-to-date and ready
    broadcastDevReady(build);
  }

  chokidar
    .watch(VERSION_PATH, { ignoreInitial: true })
    .on("add", handleServerUpdate)
    .on("change", handleServerUpdate);

  // wrap request handler to make sure its recreated with the latest build for every request
  return async (req, res, next) => {
    try {
      return createRequestHandler({
        build,
        mode: "development",
      })(req, res, next);
    } catch (error) {
      next(error);
    }
  };
}

----------------------------------------

TITLE: Fetcher Component with Index Parameter
DESCRIPTION: Demonstrates using the useFetcher hook and Fetcher.Form component with various action configurations including the index parameter.

LANGUAGE: tsx
CODE:
function Component() {
  const fetcher = useFetcher();
  fetcher.submit({}, { action: "/projects" });
  fetcher.submit({}, { action: "/projects?index" });
  <fetcher.Form action="/projects" />;
  <fetcher.Form action="/projects?index" />;
  <fetcher.Form />; // defaults to the route in context
}

----------------------------------------

TITLE: Basic HTML Form for Search
DESCRIPTION: Demonstrates a simple HTML form for a search feature using GET method.

LANGUAGE: HTML
CODE:
<form method="get" action="/search">
  <label>Search <input name="term" type="text" /></label>
  <button type="submit">Search</button>
</form>

----------------------------------------

TITLE: Creating a Route Component with Form in Remix
DESCRIPTION: This snippet shows how to create a route component in Remix that uses the useLoaderData hook to access data from the loader. It renders a form for editing user account information.

LANGUAGE: tsx
CODE:
import type { LoaderFunctionArgs } from "@remix-run/node"; // or cloudflare/deno
import { json } from "@remix-run/node"; // or cloudflare/deno
import { useLoaderData, Form } from "@remix-run/react";

export async function loader({
  request,
}: LoaderFunctionArgs) {
  const user = await getUser(request);
  return json({
    displayName: user.displayName,
    email: user.email,
  });
}

export default function Component() {
  const user = useLoaderData<typeof loader>();
  return (
    <Form method="post" action="/account">
      <h1>Settings for {user.displayName}</h1>

      <input
        name="displayName"
        defaultValue={user.displayName}
      />
      <input name="email" defaultValue={user.email} />

      <button type="submit">Save</button>
    </Form>
  );
}

export async function action() {
  // ...
}

----------------------------------------

TITLE: Configuring Breaking Changes with Future Flags in Remix
DESCRIPTION: This snippet shows how to enable a breaking change for a future version in the Remix Vite plugin configuration. It uses the 'future' option in the vite.config.ts file to specify a version-specific feature flag.

LANGUAGE: typescript
CODE:
import { vitePlugin as remix } from "@remix-run/dev";
import { defineConfig } from "vite";

export default defineConfig({
  plugins: [
    remix({
      future: {
        v3_someFeature: true,
      },
    }),
  ],
});

----------------------------------------

TITLE: Displaying Validation Errors in Remix Form Component
DESCRIPTION: Illustrates how to display validation errors in the signup form using useActionData hook to access and render error messages from the action response.

LANGUAGE: tsx
CODE:
import type { ActionFunctionArgs } from "@remix-run/node";
import { json, redirect } from "@remix-run/node";
import { Form, useActionData } from "@remix-run/react";

export default function Signup() {
  const actionData = useActionData<typeof action>();

  return (
    <Form method="post">
      <p>
        <input type="email" name="email" />
        {actionData?.errors?.email ? (
          <em>{actionData?.errors.email}</em>
        ) : null}
      </p>

      <p>
        <input type="password" name="password" />
        {actionData?.errors?.password ? (
          <em>{actionData?.errors.password}</em>
        ) : null}
      </p>

      <button type="submit">Sign Up</button>
    </Form>
  );
}

export async function action({
  request,
}: ActionFunctionArgs) {
  // omitted for brevity
}

----------------------------------------

TITLE: Defining CSS Styles for a Button Component
DESCRIPTION: This snippet shows how to define CSS styles for a basic Button component using a separate CSS file.

LANGUAGE: css
CODE:
.Button__root {
  background: blue;
  color: white;
}

----------------------------------------

TITLE: Setting Route Handle for JavaScript Hydration in Remix TSX
DESCRIPTION: Defines a route handle to indicate whether a specific route should include JavaScript hydration.

LANGUAGE: tsx
CODE:
export const handle = { hydrate: true };

----------------------------------------

TITLE: Configuring MDX for Remix Vite
DESCRIPTION: Example of how to configure the MDX Rollup plugin for use with Remix Vite

LANGUAGE: typescript
CODE:
import mdx from "@mdx-js/rollup";
import { vitePlugin as remix } from "@remix-run/dev";
import remarkFrontmatter from "remark-frontmatter";
import remarkMdxFrontmatter from "remark-mdx-frontmatter";
import { defineConfig } from "vite";

export default defineConfig({
  plugins: [
    mdx({
      remarkPlugins: [
        remarkFrontmatter,
        remarkMdxFrontmatter,
      ],
    }),
    remix(),
  ],
});

----------------------------------------

TITLE: Enabling v3_routeConfig Future Flag
DESCRIPTION: Configuration to enable the v3_routeConfig future flag in the Remix Vite plugin.

LANGUAGE: typescript
CODE:
remix({
  future: {
    v3_routeConfig: true,
  },
});

----------------------------------------

TITLE: Remix Config with TLS Settings
DESCRIPTION: Example of Remix configuration file with TLS and manual mode settings.

LANGUAGE: javascript
CODE:
/** @type {import('@remix-run/dev').AppConfig} */
module.exports = {
  dev: {
    // ...any other options you want to set go here...
    manual: true,
    tlsKey: "./key.pem",
    tlsCert: "./cert.pem",
  },
};

----------------------------------------

TITLE: Implementing ESM Import Cache Busting
DESCRIPTION: Function to handle server code reimporting in ESM using timestamp-based cache busting

LANGUAGE: javascript
CODE:
import * as fs from "node:fs";
import * as path from "node:path";
import * as url from "node:url";

/** @typedef {import('@remix-run/node').ServerBuild} ServerBuild */

const BUILD_PATH = path.resolve("./build/index.js");
const VERSION_PATH = path.resolve("./build/version.txt");
const initialBuild = await reimportServer();

/**
 * @returns {Promise<ServerBuild>}
 */
async function reimportServer() {
  const stat = fs.statSync(BUILD_PATH);

  // convert build path to URL for Windows compatibility with dynamic `import`
  const BUILD_URL = url.pathToFileURL(BUILD_PATH).href;

  // use a timestamp query parameter to bust the import cache
  return import(BUILD_URL + "?t=" + stat.mtimeMs);
}

----------------------------------------

TITLE: Configuring Tailwind CSS for Remix Vite
DESCRIPTION: Example of how to configure Tailwind CSS with PostCSS for use with Remix Vite

LANGUAGE: javascript
CODE:
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};

----------------------------------------

TITLE: Creating a Basic Remix Project with TypeScript
DESCRIPTION: Command to create a new Remix project using the default template with TypeScript support.

LANGUAGE: shellscript
CODE:
npx create-remix@latest

----------------------------------------

TITLE: Creating Remix Environment Type Declaration
DESCRIPTION: TypeScript code for creating the remix.env.d.ts file with necessary type references.

LANGUAGE: typescript
CODE:
/// <reference types="@remix-run/dev" />
/// <reference types="@remix-run/node" />

----------------------------------------

TITLE: Implementing Memory Upload Handler in Remix Action
DESCRIPTION: Demonstrates how to create and use a memory-based upload handler in a Remix action function. The handler supports maxPartSize and filter options, storing uploaded files in memory. This approach is suitable for simple use cases but not recommended for large-scale applications.

LANGUAGE: tsx
CODE:
export const action = async ({
  request,
}: ActionFunctionArgs) => {
  const uploadHandler = unstable_createMemoryUploadHandler({
    maxPartSize: 500_000,
  });
  const formData = await unstable_parseMultipartFormData(
    request,
    uploadHandler
  );

  const file = formData.get("avatar");

  // file is a "File" (https://mdn.io/File) polyfilled for node
  // ... etc
};

----------------------------------------

TITLE: Enabling View Transitions with Link in Remix
DESCRIPTION: Shows how to use the viewTransition prop to enable View Transitions API for smoother navigation experiences.

LANGUAGE: jsx
CODE:
<Link to={to} viewTransition>
  Click me
</Link>

----------------------------------------

TITLE: Creating a Button Component with Bundled CSS in React
DESCRIPTION: This example demonstrates how to create a Button component in React that imports and uses bundled CSS styles.

LANGUAGE: jsx
CODE:
import "./Button.css";

export function Button(props) {
  return <button {...props} className="Button__root" />;
}

----------------------------------------

TITLE: TypeScript Interface for Route Matches
DESCRIPTION: Shows the data structure returned by useMatches hook, including route id, pathname, data, params, and handle for each route level.

LANGUAGE: ts
CODE:
[
  { id, pathname, data, params, handle }, // root route
  { id, pathname, data, params, handle }, // layout route
  { id, pathname, data, params, handle }, // child route
  // etc.
]

----------------------------------------

TITLE: Configuring Cloudflare with Remix Vite
DESCRIPTION: Example of how to configure Cloudflare with the Remix Vite plugin

LANGUAGE: typescript
CODE:
import {
  vitePlugin as remix,
  cloudflareDevProxyVitePlugin as remixCloudflareDevProxy,
} from "@remix-run/dev";
import { defineConfig } from "vite";

export default defineConfig({
  plugins: [remixCloudflareDevProxy(), remix()],
});

----------------------------------------

TITLE: Creating a Remix Project with Official Stacks
DESCRIPTION: Command to create a new Remix project using an official stack template (Blues Stack in this example).

LANGUAGE: shellscript
CODE:
npx create-remix@latest --template remix-run/blues-stack

----------------------------------------

TITLE: Exporting Custom Values in TypeScript
DESCRIPTION: This snippet demonstrates how to export custom values in a separate non-route module to avoid causing full reloads in routes.

LANGUAGE: ts
CODE:
export const myValue = "some value";

----------------------------------------

TITLE: JSON-LD Script Meta Implementation
DESCRIPTION: Example showing how to generate structured data using JSON-LD in meta function.

LANGUAGE: tsx
CODE:
export const meta: MetaFunction = () => {
  return [
    {
      "script:ld+json": {
        "@context": "https://schema.org",
        "@type": "Organization",
        name: "Remix",
        url: "https://remix.run",
      },
    },
  ];
};

----------------------------------------

TITLE: Setting Search Parameters with Navigation Options
DESCRIPTION: Demonstrates how to set new search parameters using the setSearchParams function, including an optional second argument for navigation options.

LANGUAGE: tsx
CODE:
<button
  onClick={() => {
    const params = new URLSearchParams();
    params.set("someKey", "someValue");
    setSearchParams(params, {
      preventScrollReset: true,
    });
  }}
/>

----------------------------------------

TITLE: Configuring JSConfig for Remix
DESCRIPTION: JSON configuration for jsconfig.json in a Remix project.

LANGUAGE: json
CODE:
{
  "compilerOptions": {
    "jsx": "react-jsx",
    "resolveJsonModule": true,
    "baseUrl": ".",
    "paths": {
      "~/*": ["./app/*"]
    }
  }
}

----------------------------------------

TITLE: Accessing Cloudflare bindings in a loader function
DESCRIPTION: Example of how to access Cloudflare bindings in a Remix loader function

LANGUAGE: typescript
CODE:
export const loader = ({ context }: LoaderFunctionArgs) => {
  const { env, cf, ctx } = context.cloudflare;
  // ... more loader code here...
};

----------------------------------------

TITLE: Generating Types for Cloudflare Bindings
DESCRIPTION: Command to generate TypeScript types for Cloudflare bindings defined in wrangler.toml. This needs to be rerun after changes to wrangler.toml.

LANGUAGE: sh
CODE:
npm run typegen

----------------------------------------

TITLE: Package.json Script Configuration for SASS
DESCRIPTION: NPM script configuration in package.json to watch and compile SASS files to CSS.

LANGUAGE: json
CODE:
{
  "scripts": {
    "dev": "concurrently \"npm run sass\" \"remix dev\""
  }
}

----------------------------------------

TITLE: Creating Remix Root Route
DESCRIPTION: TypeScript code for the root route component in a Remix application, providing the HTML structure.

LANGUAGE: tsx
CODE:
import { Outlet } from "@remix-run/react";

export default function Root() {
  return (
    <html lang="en">
      <head>
        <meta charSet="utf-8" />
        <link rel="icon" href="/favicon.ico" />
        <meta
          name="viewport"
          content="width=device-width, initial-scale=1"
        />
        <meta name="theme-color" content="#000000" />
        <meta
          name="description"
          content="My beautiful React app"
        />
        <link rel="apple-touch-icon" href="/logo192.png" />
        <link rel="manifest" href="/manifest.json" />
        <title>My React App</title>
      </head>
      <body>
        <div id="root">
          <Outlet />
        </div>
      </body>
    </html>
  );
}

----------------------------------------

TITLE: Updating package.json scripts for Remix Vite
DESCRIPTION: Example of how to update package.json scripts for use with Remix Vite

LANGUAGE: json
CODE:
{
  "scripts": {
    "dev": "remix vite:dev",
    "build": "remix vite:build",
    "start": "remix-serve ./build/server/index.js"
  }
}

----------------------------------------

TITLE: Creating a Remix Project with Community Stacks
DESCRIPTION: Command to create a new Remix project using a community stack template from GitHub.

LANGUAGE: shellscript
CODE:
npx create-remix@latest --template :username/:repo

----------------------------------------

TITLE: Creating Request Handler with Architect (AWS) in Remix
DESCRIPTION: Shows how to set up a request handler using the Architect adapter for AWS environments in Remix.

LANGUAGE: typescript
CODE:
const {
  createRequestHandler,
} = require("@remix-run/architect");
exports.handler = createRequestHandler({
  build: require("./build"),
});

----------------------------------------

TITLE: Preventing Root Loader Revalidation
DESCRIPTION: This example shows how to prevent the root loader from being called again by always returning false in shouldRevalidate.

LANGUAGE: tsx
CODE:
export const loader = async () => {
  return json({
    ENV: {
      CLOUDINARY_ACCT: process.env.CLOUDINARY_ACCT,
      STRIPE_PUBLIC_KEY: process.env.STRIPE_PUBLIC_KEY,
    },
  });
};

export const shouldRevalidate = () => false;

----------------------------------------

TITLE: Using unstable_usePrompt Hook in React Router
DESCRIPTION: This snippet demonstrates how to use the unstable_usePrompt hook to prompt the user for confirmation before navigating away from a form with unsaved changes. It checks if the input has a value and if the navigation is to a different pathname.

LANGUAGE: tsx
CODE:
function ImportantForm() {
  const [value, setValue] = React.useState("");

  // Block navigating elsewhere when data has been entered into the input
  unstable_usePrompt({
    message: "Are you sure?",
    when: ({ currentLocation, nextLocation }) =>
      value !== "" &&
      currentLocation.pathname !== nextLocation.pathname,
  });

  return (
    <Form method="post">
      <label>
        Enter some important data:
        <input
          name="data"
          value={value}
          onChange={(e) => setValue(e.target.value)}
        />
      </label>
      <button type="submit">Save</button>
    </Form>
  );
}

----------------------------------------

TITLE: Implementing Media Queries for Stylesheets in Remix
DESCRIPTION: Demonstrates how to use media queries with link tags to conditionally load stylesheets based on screen size or color scheme preferences.

LANGUAGE: typescript
CODE:
export const links: LinksFunction = () => {
  return [
    {
      rel: "stylesheet",
      href: mainStyles,
    },
    {
      rel: "stylesheet",
      href: largeStyles,
      media: "(min-width: 1024px)",
    },
    {
      rel: "stylesheet",
      href: xlStyles,
      media: "(min-width: 1280px)",
    },
    {
      rel: "stylesheet",
      href: darkStyles,
      media: "(prefers-color-scheme: dark)",
    },
  ];
};

----------------------------------------

TITLE: Adding Asset Preloads in Remix
DESCRIPTION: Shows how to add asset preloads for optimized loading of resources like SVG icons.

LANGUAGE: typescript
CODE:
import type { LinksFunction } from "@remix-run/node"; // or cloudflare/deno

import styles from "./styles.css?url";

export const links: LinksFunction = () => [
  {
    rel: "preload",
    href: "/icons/clipboard.svg",
    as: "image",
    type: "image/svg+xml",
  },
  { rel: "stylesheet", href: styles },
];

----------------------------------------

TITLE: Configuring Cloudflare Pages for Remix Vite
DESCRIPTION: Example of how to configure a Cloudflare Pages function for use with Remix Vite

LANGUAGE: typescript
CODE:
import { createPagesFunctionHandler } from "@remix-run/cloudflare-pages";

// @ts-ignore - the server build file is generated by `remix vite:build`
import * as build from "../build/server";

export const onRequest = createPagesFunctionHandler({
  build,
});

----------------------------------------

TITLE: MDX Configuration with Custom Plugins
DESCRIPTION: Configuration example for setting up custom remark and rehype plugins for MDX processing

LANGUAGE: javascript
CODE:
const {
  remarkMdxFrontmatter,
} = require("remark-mdx-frontmatter");

exports.mdx = async (filename) => {
  const [rehypeHighlight, remarkToc] = await Promise.all([
    import("rehype-highlight").then((mod) => mod.default),
    import("remark-toc").then((mod) => mod.default),
  ]);

  return {
    remarkPlugins: [remarkToc],
    rehypePlugins: [rehypeHighlight],
  };
};

----------------------------------------

TITLE: Creating Remix Server Entry Point
DESCRIPTION: TypeScript code for the server entry point in a Remix application, handling both bot and browser requests.

LANGUAGE: tsx
CODE:
import { PassThrough } from "node:stream";

import type {
  AppLoadContext,
  EntryContext,
} from "@remix-run/node";
import { createReadableStreamFromReadable } from "@remix-run/node";
import { RemixServer } from "@remix-run/react";
import { isbot } from "isbot";
import { renderToPipeableStream } from "react-dom/server";

const ABORT_DELAY = 5_000;

export default function handleRequest(
  request: Request,
  responseStatusCode: number,
  responseHeaders: Headers,
  remixContext: EntryContext,
  loadContext: AppLoadContext
) {
  return isbot(request.headers.get("user-agent") || "")
    ? handleBotRequest(
        request,
        responseStatusCode,
        responseHeaders,
        remixContext
      )
    : handleBrowserRequest(
        request,
        responseStatusCode,
        responseHeaders,
        remixContext
      );
}

function handleBotRequest(
  request: Request,
  responseStatusCode: number,
  responseHeaders: Headers,
  remixContext: EntryContext
) {
  return new Promise((resolve, reject) => {
    const { pipe, abort } = renderToPipeableStream(
      <RemixServer
        context={remixContext}
        url={request.url}
        abortDelay={ABORT_DELAY}
      />,
      {
        onAllReady() {
          const body = new PassThrough();

          responseHeaders.set("Content-Type", "text/html");

          resolve(
            new Response(
              createReadableStreamFromReadable(body),
              {
                headers: responseHeaders,
                status: responseStatusCode,
              }
            )
          );

          pipe(body);
        },
        onShellError(error: unknown) {
          reject(error);
        },
        onError(error: unknown) {
          responseStatusCode = 500;
          console.error(error);
        },
      }
    );

    setTimeout(abort, ABORT_DELAY);
  });
}

function handleBrowserRequest(
  request: Request,
  responseStatusCode: number,
  responseHeaders: Headers,
  remixContext: EntryContext
) {
  return new Promise((resolve, reject) => {
    const { pipe, abort } = renderToPipeableStream(
      <RemixServer
        context={remixContext}
        url={request.url}
        abortDelay={ABORT_DELAY}
      />,
      {
        onShellReady() {
          const body = new PassThrough();

          responseHeaders.set("Content-Type", "text/html");

          resolve(
            new Response(
              createReadableStreamFromReadable(body),
              {
                headers: responseHeaders,
                status: responseStatusCode,
              }
            )
          );

          pipe(body);
        },
        onShellError(error: unknown) {
          reject(error);
        },
        onError(error: unknown) {
          console.error(error);
          responseStatusCode = 500;
        },
      }
    );

    setTimeout(abort, ABORT_DELAY);
  });
}

----------------------------------------

TITLE: Using Link Component from React Router (Incorrect)
DESCRIPTION: Illustrates the incorrect usage of the Link component from React Router in a Remix application. This approach doesn't leverage Remix-specific features like prefetching.

LANGUAGE: tsx
CODE:
import { Link } from "react-router-dom";

// this won't do anything
<Link prefetch="intent" />;

----------------------------------------

TITLE: JSON Object Submission
DESCRIPTION: Example demonstrating how to submit a plain object that will be serialized as JSON.

LANGUAGE: tsx
CODE:
submit(
  { myKey: "myValue" },
  { method: "post", encType: "application/json" }
);

----------------------------------------

TITLE: Surfacing Component Styles in Remix
DESCRIPTION: Illustrates how to surface component styles to routes that use them, including dependency management.

LANGUAGE: typescript
CODE:
import type { LinksFunction } from "@remix-run/node"; // or cloudflare/deno

import { Button, links as buttonLinks } from "../button";

import styles from "./styles.css?url";

export const links: LinksFunction = () => [
  ...buttonLinks(),
  { rel: "stylesheet", href: styles },
];

export const PrimaryButton = React.forwardRef(
  ({ children, ...props }, ref) => {
    return (
      <Button {...props} ref={ref} data-primary-button />
    );
  }
);
PrimaryButton.displayName = "PrimaryButton";

----------------------------------------

TITLE: Configuring path aliases for Remix Vite
DESCRIPTION: Example of how to configure path aliases using vite-tsconfig-paths with Remix Vite

LANGUAGE: typescript
CODE:
import { vitePlugin as remix } from "@remix-run/dev";
import { defineConfig } from "vite";
import tsconfigPaths from "vite-tsconfig-paths";

export default defineConfig({
  plugins: [remix(), tsconfigPaths()],
});

----------------------------------------

TITLE: Running Remix App in Development Mode
DESCRIPTION: This command starts the Remix app in development mode, which rebuilds assets automatically when files are changed.

LANGUAGE: sh
CODE:
npm run dev

----------------------------------------

TITLE: Template Usage Examples
DESCRIPTION: Comprehensive examples of using different template sources including GitHub repos, URLs, and local paths

LANGUAGE: sh
CODE:
npx create-remix@latest ./my-app --template remix-run/grunge-stack
npx create-remix@latest ./my-app --template remix-run/remix/templates/remix
npx create-remix@latest ./my-app --template remix-run/examples/basic
npx create-remix@latest ./my-app --template :username/:repo
npx create-remix@latest ./my-app --template :username/:repo/:directory
npx create-remix@latest ./my-app --template https://github.com/:username/:repo
npx create-remix@latest ./my-app --template https://github.com/:username/:repo/tree/:branch
npx create-remix@latest ./my-app --template https://github.com/:username/:repo/tree/:branch/:directory
npx create-remix@latest ./my-app --template https://github.com/:username/:repo/archive/refs/tags/:tag.tar.gz
npx create-remix@latest ./my-app --template https://github.com/:username/:repo/releases/latest/download/:tag.tar.gz
npx create-remix@latest ./my-app --template https://example.com/remix-template.tar.gz
npx create-remix@latest ./my-app --template ./path/to/remix-template
npx create-remix@latest ./my-app --template ./path/to/remix-template.tar.gz

----------------------------------------

TITLE: Advanced PostCSS Configuration with Vanilla Extract Support
DESCRIPTION: PostCSS configuration that conditionally applies different plugins based on whether the file is a Vanilla Extract style or regular CSS.

LANGUAGE: javascript
CODE:
module.exports = (ctx) => {
  return ctx.remix?.vanillaExtract
    ? {
        // PostCSS plugins for Vanilla Extract styles...
      }
    : {
        // PostCSS plugins for other styles...
      };
};

----------------------------------------

TITLE: URL Search Params Handling
DESCRIPTION: Shows how to handle URL search parameters in a Remix loader and component using useSearchParams hook.

LANGUAGE: tsx
CODE:
import { useSearchParams } from "@remix-run/react";

export default function ProductFilters() {
  const [searchParams] = useSearchParams();
  const brands = searchParams.getAll("brand");

  return (
    <Form method="get">
      <label htmlFor="nike">Nike</label>
      <input
        type="checkbox"
        id="nike"
        name="brand"
        value="nike"
        defaultChecked={brands.includes("nike")}
      />
      <button type="submit">Update</button>
    </Form>
  );
}

----------------------------------------

TITLE: Showing Supported Exports for Hot Module Replacement in TSX
DESCRIPTION: This snippet illustrates which exports are compatible with Hot Module Replacement in Remix. Special route exports are handled by the Remix Vite plugin, while user-defined exports cause full reloads.

LANGUAGE: tsx
CODE:
// These exports are handled by the Remix Vite plugin
// to be HMR-compatible
export const meta = { title: "Home" }; // ✅
export const links = [
  { rel: "stylesheet", href: "style.css" },
]; // ✅

// These exports are removed by the Remix Vite plugin
// so they never affect HMR
export const headers = { "Cache-Control": "max-age=3600" }; // ✅
export const loader = async () => {}; // ✅
export const action = async () => {}; // ✅

// This is not a Remix export, nor a component export,
// so it will cause a full reload for this route
export const myValue = "some value"; // ❌

export default function Route() {} // ✅

----------------------------------------

TITLE: Serving Remix SPA with sirv-cli
DESCRIPTION: Command to serve a Remix SPA production build using sirv-cli with SPA fallback.

LANGUAGE: shellscript
CODE:
npx sirv-cli build/client/ --single

----------------------------------------

TITLE: Configuring Vite Dev Server Port
DESCRIPTION: Optional configuration to set the port for the Vite development server in the Vite config file.

LANGUAGE: typescript
CODE:
export default defineConfig({
  server: {
    port: 3000,
  },
  plugins: [remix()],
});

----------------------------------------

TITLE: useSubmit Hook Signature
DESCRIPTION: The basic function signature for the useSubmit hook showing the parameter structure.

LANGUAGE: tsx
CODE:
submit(targetOrData, options);

----------------------------------------

TITLE: Configuring Unstable Features in Remix Vite Plugin
DESCRIPTION: This snippet demonstrates how to enable an unstable feature in the Remix Vite plugin configuration. It uses the 'future' option in the vite.config.ts file to specify an unstable feature flag.

LANGUAGE: typescript
CODE:
import { vitePlugin as remix } from "@remix-run/dev";
import { defineConfig } from "vite";

export default defineConfig({
  plugins: [
    remix({
      future: {
        unstable_someFeature: true,
      },
    }),
  ],
});

----------------------------------------

TITLE: Installing Autoprefixer Plugin for PostCSS
DESCRIPTION: Command to install the Autoprefixer plugin as a development dependency for PostCSS processing.

LANGUAGE: shellscript
CODE:
npm install -D autoprefixer

----------------------------------------

TITLE: Creating New Playground in Remix
DESCRIPTION: Command to generate a new playground environment for testing Remix features, with an optional custom name.

LANGUAGE: shellscript
CODE:
pnpm playground:new <?name>

----------------------------------------

TITLE: Proxy Module Generated by Remix Compiler
DESCRIPTION: Demonstrates how Remix creates a proxy module to handle code splitting between server and browser environments.

LANGUAGE: tsx
CODE:
export { meta, default } from "./routes/posts.tsx";

----------------------------------------

TITLE: Updating to Latest Remix v2
DESCRIPTION: Command to update Remix packages to the latest v2 version.

LANGUAGE: shellscript
CODE:
npm install @remix-run/{dev,react,node,etc.}@2

----------------------------------------

TITLE: Signing Cookies in Remix
DESCRIPTION: Demonstrates how to sign cookies for enhanced security. This example shows how to create a signed cookie and how to rotate secrets.

LANGUAGE: typescript
CODE:
const cookie = createCookie("user-prefs", {
  secrets: ["s3cret1"],
});

LANGUAGE: typescript
CODE:
export const cookie = createCookie("user-prefs", {
  secrets: ["n3wsecr3t", "olds3cret"],
});

LANGUAGE: typescript
CODE:
import { cookie } from "~/cookies.server";

export async function loader({
  request,
}: LoaderFunctionArgs) {
  const oldCookie = request.headers.get("Cookie");
  // oldCookie may have been signed with "olds3cret", but still parses ok
  const value = await cookie.parse(oldCookie);

  new Response("...", {
    headers: {
      // Set-Cookie is signed with "n3wsecr3t"
      "Set-Cookie": await cookie.serialize(value),
    },
  });
}

----------------------------------------

TITLE: Defining Breadcrumb for Parent Route in Remix
DESCRIPTION: This snippet shows how to define a breadcrumb for a parent route using the handle property in Remix.

LANGUAGE: tsx
CODE:
export const handle = {
  breadcrumb: () => <Link to="/parent">Some Route</Link>,
};

----------------------------------------

TITLE: Simplified Form Validation with Remix
DESCRIPTION: Shows how Remix simplifies form validation by leveraging server-side validation and built-in form handling features.

LANGUAGE: tsx
CODE:
export function Signup() {
  const navigation = useNavigation();
  const actionData = useActionData<typeof action>();

  const userNameError = actionData?.errors?.userName;
  const passwordError = actionData?.errors?.password;
  const isSubmitting = navigation.formAction === "/signup";

  return (
    <Form method="post">
      <p>
        <input type="text" name="username" />
        {userNameError ? <i>{userNameError}</i> : null}
      </p>

      <p>
        <input type="password" name="password" />
        {passwordError ? <i>{passwordError}</i> : null}
      </p>

      <button disabled={isSubmitting} type="submit">
        Sign Up
      </button>

      {isSubmitting ? <BusyIndicator /> : null}
    </Form>
  );
}

----------------------------------------

TITLE: Running Tests for Specific Remix Package
DESCRIPTION: Commands for running tests, either for all packages or for a specific package like @remix-run/express.

LANGUAGE: shellscript
CODE:
# Test all packages
pnpm test

# Test only @remix-run/express
pnpm test:primary --selectProjects express

----------------------------------------

TITLE: Building Remix Production Assets
DESCRIPTION: Builds the Remix application for production deployment, generating optimized assets.

LANGUAGE: sh
CODE:
npm run build

----------------------------------------

TITLE: Fixing a bug in @remix-run/serve
DESCRIPTION: This snippet shows how a bug fix is documented in the changelog. It includes a description of the bug and the fix applied.

LANGUAGE: markdown
CODE:
### Patch Changes

- Fix HMR for CJS projects using `remix-serve` and manual mode (`remix dev --manual`) ([#7487](https://github.com/remix-run/remix/pull/7487))
  - By explicitly busting the `require` cache, `remix-serve` now correctly re-imports new server changes in CJS
  - ESM projects were already working correctly and are not affected by this.

----------------------------------------

TITLE: Illustrating Safe Back Button Navigation with Redirect
DESCRIPTION: This code demonstrates how the browser history stack looks when navigating back after implementing a redirect, preventing unintended form resubmissions.

LANGUAGE: plaintext
CODE:
GET /buy - *GET /order/123

----------------------------------------

TITLE: NPM Package Dependency Resolution Example
DESCRIPTION: Example output of using npm why command to determine package dependency relationships for troubleshooting.

LANGUAGE: shell
CODE:
❯ npm why jimp
jimp@0.16.13
node_modules/jimp
  jimp@"^0.16.1" from svg2img@1.0.0-beta.2
  node_modules/svg2img
    svg2img@"^1.0.0-beta.2" from the root project

----------------------------------------

TITLE: Major Version Change Example
DESCRIPTION: Example of a major version change documentation showing breaking changes and requirement updates

LANGUAGE: markdown
CODE:
### Major Changes

- Drop React 17 support ([#7121](https://github.com/remix-run/remix/pull/7121))
- Require Node >=18.0.0 ([#6939](https://github.com/remix-run/remix/pull/6939))
- Remove `v2_normalizeFormMethod` future flag ([#6875](https://github.com/remix-run/remix/pull/6875))

----------------------------------------

TITLE: Form Element Submission Example
DESCRIPTION: Example showing how to submit an HTMLFormElement using the submit function.

LANGUAGE: tsx
CODE:
<Form
  onSubmit={(event) => {
    submit(event.currentTarget);
  }}
/>

----------------------------------------

TITLE: Replacing History Entry with Link in Remix
DESCRIPTION: Shows how to use the replace prop to replace the current history entry instead of adding a new one.

LANGUAGE: tsx
CODE:
<Link replace />

----------------------------------------

TITLE: Cloning Remix Repository in Shell
DESCRIPTION: Instructions for forking and cloning the Remix repository locally, including checking out the dev branch for code changes.

LANGUAGE: shellscript
CODE:
# in a terminal, cd to parent directory where you want your clone to be, then
git clone https://github.com/<your_github_username>/remix.git
cd remix

# if you are making *any* code changes, make sure to checkout the dev branch
git checkout dev

----------------------------------------

TITLE: Installing SASS Preprocessor
DESCRIPTION: Command to install the SASS preprocessor as a development dependency.

LANGUAGE: shellscript
CODE:
npm add -D sass

----------------------------------------

TITLE: Demonstrating Browser History Stack for Form Submissions
DESCRIPTION: This snippet illustrates how the browser history stack changes during form submissions and navigation events, showing the potential for form resubmission when using the back button.

LANGUAGE: plaintext
CODE:
GET /buy > POST /checkout > *GET /order/123

----------------------------------------

TITLE: Configuring Root Component for Conditional JavaScript Loading in Remix
DESCRIPTION: Implements conditional JavaScript loading in the root component by checking route handles and selectively including Scripts component.

LANGUAGE: tsx
CODE:
import {
  Meta,
  Links,
  Scripts,
  Outlet,
  useMatches,
} from "@remix-run/react";

export default function App() {
  const matches = useMatches();

  // If at least one route wants to hydrate, this will return true
  const includeScripts = matches.some(
    (match) => match.handle?.hydrate
  );

  // then use the flag to render scripts or not
  return (
    <html lang="en">
      <head>
        <Meta />
        <Links />
      </head>
      <body>
        <Outlet />
        {/* include the scripts, or not! */}
        {includeScripts ? <Scripts /> : null}
      </body>
    </html>
  );
}

----------------------------------------

TITLE: Express Adapter Signal Abort Logic Fix
DESCRIPTION: Fix for adapter logic to prevent incorrect request signal aborting on the close event for successful requests.

LANGUAGE: markdown
CODE:
Fix adapter logic for aborting `request.signal` so we don't incorrectly abort on the `close` event for successful requests ([#10046](https://github.com/remix-run/remix/pull/10046))

----------------------------------------

TITLE: Installing Tailwind CSS in Remix
DESCRIPTION: Command to install Tailwind CSS as a development dependency in a Remix project.

LANGUAGE: shellscript
CODE:
npm install -D tailwindcss

----------------------------------------

TITLE: Using a Component with Bundled CSS in a Remix Route
DESCRIPTION: This snippet shows how to import and use a component with bundled CSS in a Remix route file.

LANGUAGE: jsx
CODE:
import { Button } from "../components/Button";

export default function HelloRoute() {
  return <Button>Hello!</Button>;
}

----------------------------------------

TITLE: NavLink with Children Callback in Remix
DESCRIPTION: Demonstrates how to use the children prop callback to customize the content of a NavLink based on its active and pending states.

LANGUAGE: tsx
CODE:
<NavLink to="/tasks">
  {({ isActive, isPending }) => (
    <span className={isActive ? "active" : ""}>Tasks</span>
  )}
</NavLink>

----------------------------------------

TITLE: Implementing a Form for Creating New Posts
DESCRIPTION: Creates a form component with validation for adding new blog posts, including an action function to handle form submission.

LANGUAGE: tsx
CODE:
import type { ActionFunctionArgs } from "@remix-run/node";
import { json, redirect } from "@remix-run/node";
import {
  Form,
  useActionData,
  useNavigation,
} from "@remix-run/react";
import invariant from "tiny-invariant";

import { createPost } from "~/models/post.server";

export const action = async ({
  request,
}: ActionFunctionArgs) => {
  const formData = await request.formData();

  const title = formData.get("title");
  const slug = formData.get("slug");
  const markdown = formData.get("markdown");

  const errors = {
    title: title ? null : "Title is required",
    slug: slug ? null : "Slug is required",
    markdown: markdown ? null : "Markdown is required",
  };
  const hasErrors = Object.values(errors).some(
    (errorMessage) => errorMessage
  );
  if (hasErrors) {
    return json(errors);
  }

  invariant(
    typeof title === "string",
    "title must be a string"
  );
  invariant(
    typeof slug === "string",
    "slug must be a string"
  );
  invariant(
    typeof markdown === "string",
    "markdown must be a string"
  );

  await createPost({ title, slug, markdown });

  return redirect("/posts/admin");
};

export default function NewPost() {
  const errors = useActionData<typeof action>();
  const navigation = useNavigation();
  const isCreating = Boolean(
    navigation.state === "submitting"
  );

  return (
    <Form method="post">
      {/* Form fields */}
      <button
        type="submit"
        disabled={isCreating}
      >
        {isCreating ? "Creating..." : "Create Post"}
      </button>
    </Form>
  );
}

----------------------------------------

TITLE: Adding Client-Side Environment Variables to Window Object in Remix
DESCRIPTION: Demonstrates how to expose server-side environment variables to the client by adding them to the window object in the Root component.

LANGUAGE: tsx
CODE:
export async function loader() {
  return json({
    ENV: {
      STRIPE_PUBLIC_KEY: process.env.STRIPE_PUBLIC_KEY,
    },
  });
}

export function Root() {
  const data = useLoaderData<typeof loader>();
  return (
    <html lang="en">
      <head>
        <Meta />
        <Links />
      </head>
      <body>
        <Outlet />
        <script
          dangerouslySetInnerHTML={{
            __html: `window.ENV = ${JSON.stringify(
              data.ENV
            )}`,
          }}
        />
        <Scripts />
      </body>
    </html>
  );
}

----------------------------------------

TITLE: Running Remix Development Server
DESCRIPTION: Command to start the Remix development server for local development.

LANGUAGE: sh
CODE:
npm run dev

----------------------------------------

TITLE: Starting Development Server
DESCRIPTION: Command to start the development server for local development

LANGUAGE: shellscript
CODE:
npm run dev

----------------------------------------

TITLE: Running Remix Development Server
DESCRIPTION: Starts the Remix development asset server and the Express server. This command runs the app in development mode, which purges the server require cache when Remix rebuilds assets.

LANGUAGE: sh
CODE:
npm run dev

----------------------------------------

TITLE: Accessing Environment Variables in Remix Loader
DESCRIPTION: Shows how to access environment variables within a Remix loader function using process.env.

LANGUAGE: tsx
CODE:
export async function loader() {
  console.log(process.env.SOME_SECRET);
}

----------------------------------------

TITLE: Express Dependency Upgrade
DESCRIPTION: Upgrade of the express dependency to version ^4.19.2.

LANGUAGE: markdown
CODE:
Upgrade `express` dependency to `^4.19.2` ([#9184](https://github.com/remix-run/remix/pull/9184))

----------------------------------------

TITLE: Deploying Remix Application
DESCRIPTION: Command to deploy the Remix application to Fly.io platform.

LANGUAGE: sh
CODE:
npm run deploy

----------------------------------------

TITLE: Accessing Form Data in Navigation Object
DESCRIPTION: This snippet shows how to access form data from the navigation object during a pending navigation, particularly useful for building Optimistic UI.

LANGUAGE: tsx
CODE:
// This form has the `email` field
<Form method="post" action="/signup">
  <input name="email" />
</Form>;

// So a navigation will have the field's value in `navigation.formData`
// while the navigation is pending.
navigation.formData.get("email");

----------------------------------------

TITLE: Updating entry.server.tsx for Remix SPA Hydration
DESCRIPTION: Modifications to entry.server.tsx to insert Remix-rendered HTML into a static HTML file for SPA mode.

LANGUAGE: typescript
CODE:
import fs from "node:fs";
import path from "node:path";

import type { EntryContext } from "@remix-run/node";
import { RemixServer } from "@remix-run/react";
import { renderToString } from "react-dom/server";

export default function handleRequest(
  request: Request,
  responseStatusCode: number,
  responseHeaders: Headers,
  remixContext: EntryContext
) {
  const shellHtml = fs
    .readFileSync(
      path.join(process.cwd(), "app/index.html")
    )
    .toString();

  const appHtml = renderToString(
    <RemixServer context={remixContext} url={request.url} />
  );

  const html = shellHtml.replace(
    "<!-- Remix SPA -->",
    appHtml
  );

  return new Response(html, {
    headers: { "Content-Type": "text/html" },
    status: responseStatusCode,
  });
}

----------------------------------------

TITLE: Deploying to Cloudflare Workers
DESCRIPTION: Command to deploy the Remix application to Cloudflare Workers production environment.

LANGUAGE: shell
CODE:
npm run deploy

----------------------------------------

TITLE: Setting Deno Deploy Token
DESCRIPTION: Command to set the Deno Deploy API token as an environment variable

LANGUAGE: sh
CODE:
export DENO_DEPLOY_TOKEN=<your Deno Deploy API token>

----------------------------------------

TITLE: Configuring Vite for Remix
DESCRIPTION: Basic Vite configuration setup required for Remix using the Remix Vite plugin.

LANGUAGE: javascript
CODE:
import { vitePlugin as remix } from "@remix-run/dev";
import { defineConfig } from "vite";

export default defineConfig({
  plugins: [remix()],
});

----------------------------------------

TITLE: Creating Local TLS Certificates with mkcert
DESCRIPTION: Commands for installing mkcert, creating a local Certificate Authority, and generating TLS certificates for local development.

LANGUAGE: shellscript
CODE:
mkcert -install

LANGUAGE: shellscript
CODE:
export NODE_EXTRA_CA_CERTS="$(mkcert -CAROOT)/rootCA.pem"

LANGUAGE: shellscript
CODE:
mkcert -key-file key.pem -cert-file cert.pem localhost

----------------------------------------

TITLE: Initializing a New Remix Project using CLI
DESCRIPTION: This command initializes a new Remix project using the create-remix package. It launches an interactive setup process in the terminal.

LANGUAGE: sh
CODE:
npx create-remix@latest

----------------------------------------

TITLE: Preventing Scroll Reset with Link in Remix
DESCRIPTION: Demonstrates how to use the preventScrollReset prop to maintain scroll position when navigating.

LANGUAGE: tsx
CODE:
<Link to="?tab=one" preventScrollReset />

----------------------------------------

TITLE: Configuring Vite for Remix SPA Mode
DESCRIPTION: Vite configuration to enable SPA mode in a Remix project by setting ssr to false.

LANGUAGE: javascript
CODE:
// vite.config.ts
import { vitePlugin as remix } from "@remix-run/dev";
import { defineConfig } from "vite";

export default defineConfig({
  plugins: [
    remix({
      ssr: false,
    }),
  ],
});

----------------------------------------

TITLE: Development Server Command
DESCRIPTION: Command to start the development server with hot reload

LANGUAGE: sh
CODE:
npm run dev

----------------------------------------

TITLE: Installing Remix Dependencies
DESCRIPTION: Commands for creating a new directory and installing required Remix dependencies including runtime and development packages.

LANGUAGE: shell
CODE:
mkdir my-remix-app
cd my-remix-app
npm init -y

# install runtime dependencies
npm i @remix-run/node @remix-run/react @remix-run/serve isbot@4 react react-dom

# install dev dependencies
npm i -D @remix-run/dev vite

----------------------------------------

TITLE: Authenticating with Fly.io
DESCRIPTION: Command to signup and authenticate with Fly.io service.

LANGUAGE: sh
CODE:
flyctl auth signup

----------------------------------------

TITLE: Installing Remix SPA Template
DESCRIPTION: Command to create a new Remix SPA project using the official template

LANGUAGE: shellscript
CODE:
npx create-remix@latest --template remix-run/remix/templates/spa

----------------------------------------

TITLE: Importing React Components
DESCRIPTION: Example of importing useState hook from React in TypeScript

LANGUAGE: typescript
CODE:
import { useState } from "react";

----------------------------------------

TITLE: Configuring Package.json for TypeScript in Remix
DESCRIPTION: Package.json configuration for a Remix application with TypeScript support. Includes scripts for building, development, linting, and type checking along with necessary dependencies.

LANGUAGE: json
CODE:
{
  "name": "remix-app",
  "private": true,
  "sideEffects": false,
  "scripts": {
    "build": "remix vite:build",
    "dev": "remix vite:dev",
    "lint": "eslint --ignore-path .gitignore .",
    "start": "remix-serve ./build/index.js",
    "typecheck": "tsc"
  },
  "dependencies": {
    "@remix-run/node": "latest",
    "@remix-run/react": "latest",
    "@remix-run/serve": "latest",
    "isbot": "^4.1.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0"
  },
  "devDependencies": {
    "@remix-run/dev": "latest",
    "@types/react": "^18.2.20",
    "@types/react-dom": "^18.2.7",
    "eslint": "^8.23.1",
    "typescript": "^5.1.6",
    "vite": "^6.0.0"
  },
  "engines": {
    "node": ">=18.0.0"
  }
}

----------------------------------------

TITLE: Installing @remix-run/css-bundle Package for Remix
DESCRIPTION: This command installs the @remix-run/css-bundle package using npm. This package is used to access the href of the generated CSS file when using CSS bundling features in Remix projects.

LANGUAGE: sh
CODE:
npm install @remix-run/css-bundle

----------------------------------------

TITLE: Initializing a New Remix Project using NPX
DESCRIPTION: This command uses npx to create a new Remix project. It runs the latest version of the create-remix package, which will guide the user through the project setup process.

LANGUAGE: sh
CODE:
npx create-remix@latest

----------------------------------------

TITLE: Accessing Client-Side Environment Variables in Remix
DESCRIPTION: Shows how to access client-side environment variables that have been exposed through the window object in a Remix application.

LANGUAGE: tsx
CODE:
import { loadStripe } from "@stripe/stripe-js";

export async function redirectToStripeCheckout(
  sessionId
) {
  const stripe = await loadStripe(
    window.ENV.STRIPE_PUBLIC_KEY
  );
  return stripe.redirectToCheckout({ sessionId });
}

----------------------------------------

TITLE: Initializing New Remix Project with NPX
DESCRIPTION: Command to create a new Remix project using the create-remix package. This will launch an interactive CLI that guides you through project setup.

LANGUAGE: sh
CODE:
npx create-remix@latest

----------------------------------------

TITLE: Deploying Remix Project to AWS with Architect
DESCRIPTION: This command deploys the built Remix application to AWS using Architect. It should be run after building the project for production.

LANGUAGE: sh
CODE:
npx arc deploy production

----------------------------------------

TITLE: Initializing Tailwind Configuration
DESCRIPTION: Command to create a TypeScript-based Tailwind configuration file.

LANGUAGE: shellscript
CODE:
npx tailwindcss init --ts

----------------------------------------

TITLE: Installing @remix-run/deno package using npm
DESCRIPTION: This command installs the @remix-run/deno package using npm. Despite being a Deno module, the package is managed through npm for dependency management in Remix projects.

LANGUAGE: sh
CODE:
npm install @remix-run/deno

----------------------------------------

TITLE: Setting Form Method in Remix
DESCRIPTION: This snippet demonstrates two methods to set the form method in Remix: using the Form component and using the submit function.

LANGUAGE: tsx
CODE:
// set from either one of these
<Form method="get" />;
submit(formData, { method: "get" });

----------------------------------------

TITLE: Initializing Fly.io Project
DESCRIPTION: Command to initialize a new Fly.io project configuration for the application.

LANGUAGE: sh
CODE:
flyctl launch

----------------------------------------

TITLE: Setting Form Method in Remix
DESCRIPTION: This snippet demonstrates two methods to set the form method in Remix: using the Form component and using the submit function.

LANGUAGE: tsx
CODE:
// set from either one of these
<Form method="get" />;
submit(formData, { method: "get" });

----------------------------------------

TITLE: Throwing Redirects in Remix
DESCRIPTION: Demonstrates how to throw redirect responses to immediately break execution flow and trigger a redirect.

LANGUAGE: ts
CODE:
if (!session) {
  throw redirect("/login", 302);
}

----------------------------------------

TITLE: Starting Remix Production Server
DESCRIPTION: Command to start the Remix application in production mode after building.

LANGUAGE: sh
CODE:
npm start

----------------------------------------

TITLE: Configuring Tailwind Content Sources
DESCRIPTION: TypeScript configuration for Tailwind CSS specifying which files to scan for generating utility classes.

LANGUAGE: typescript
CODE:
import type { Config } from "tailwindcss";

export default {
  content: [
    "./app/**/{**,.client,.server}/**/*.{js,jsx,ts,tsx}",
  ],
  theme: {
    extend: {},
  },
  plugins: [],
} satisfies Config;

----------------------------------------

TITLE: Importing Deno Modules
DESCRIPTION: Example of importing a Deno module using URL imports

LANGUAGE: typescript
CODE:
import { copy } from "https://deno.land/std@0.138.0/streams/conversion.ts";

----------------------------------------

TITLE: Building Remix Project for Production
DESCRIPTION: Command to build the Remix application for production deployment, preparing optimized assets.

LANGUAGE: sh
CODE:
npm run build

----------------------------------------

TITLE: Defining Route Styles in Remix
DESCRIPTION: Demonstrates how to add stylesheets to specific routes using the links function in Remix.

LANGUAGE: typescript
CODE:
import type { LinksFunction } from "@remix-run/node"; // or cloudflare/deno

import styles from "~/styles/dashboard.css?url";

export const links: LinksFunction = () => [
  { rel: "stylesheet", href: styles },
];

----------------------------------------

TITLE: Using Session Validation in Remix Loader
DESCRIPTION: This snippet shows how to use the requireUserSession function in a Remix loader to protect routes. It demonstrates both cases where session information is used and where it's not needed but still protects the route.

LANGUAGE: typescript
CODE:
export async function loader({
  request,
}: LoaderFunctionArgs) {
  // if the user isn't authenticated, this will redirect to login
  const session = await requireUserSession(request);

  // otherwise the code continues to execute
  const projects = await fakeDb.projects.scan({
    userId: session.get("userId"),
  });
  return json(projects);
}

LANGUAGE: typescript
CODE:
export async function loader({
  request,
}: LoaderFunctionArgs) {
  await requireUserSession(request);
  // continue
}

----------------------------------------

TITLE: Initializing a new Remix project using npm
DESCRIPTION: This command uses npx to create a new Remix project. After running it, users should follow the prompts in their terminal to complete the setup.

LANGUAGE: sh
CODE:
npx create-remix@latest

----------------------------------------

TITLE: Importing and Using Client Module Exports in Remix
DESCRIPTION: Shows how to import and use values from a client module, demonstrating that these values will be undefined on the server and only properly initialized on the client side.

LANGUAGE: typescript
CODE:
import { supportsVibrationAPI } from "./feature-check.client.ts";

console.log(supportsVibrationAPI);
// server: undefined
// client: true | false

----------------------------------------

TITLE: Configuring CSS Bundle in Remix Root Component
DESCRIPTION: TypeScript code snippet demonstrating how to import and use cssBundleHref in the links function of the root component. This setup applies the CSS bundle to the entire application.

LANGUAGE: typescript
CODE:
import { cssBundleHref } from "@remix-run/css-bundle";
import type { LinksFunction } from "@remix-run/node"; // or cloudflare/deno

export const links: LinksFunction = () => [
  ...(cssBundleHref
    ? [{ rel: "stylesheet", href: cssBundleHref }]
    : []),
  // ...
];

----------------------------------------

TITLE: Building Remix App for Production
DESCRIPTION: This command builds the Remix app for production, optimizing assets and generating static files.

LANGUAGE: sh
CODE:
npm run build

----------------------------------------

TITLE: Installing New Remix Project
DESCRIPTION: Command to initialize a new Remix project using npx. This will launch an interactive installer that guides you through project setup.

LANGUAGE: sh
CODE:
npx create-remix@latest

----------------------------------------

TITLE: Basic JSON Response in Remix TSX
DESCRIPTION: Shows the basic usage of the json helper function to create a JSON response, comparing it with the equivalent raw Response object implementation.

LANGUAGE: tsx
CODE:
import { json } from "@remix-run/node"; // or cloudflare/deno

export const loader = async () => {
  // So you can write this:
  return json({ any: "thing" });

  // Instead of this:
  return new Response(JSON.stringify({ any: "thing" }), {
    headers: {
      "Content-Type": "application/json; charset=utf-8",
    },
  });
};

----------------------------------------

TITLE: Single Fetch Type Setup
DESCRIPTION: Configuration needed to enable type safety for Single Fetch in vite.config.ts

LANGUAGE: typescript
CODE:
// vite.config.ts
declare module "@remix-run/server-runtime" {
  interface Future {
    unstable_singleFetch: true; // 👈 enable _types_ for single-fetch
  }
}

export default defineConfig({
  plugins: [
    remix({
      future: {
        unstable_singleFetch: true, // 👈 enable single-fetch
      },
    }),
  ],
});

----------------------------------------

TITLE: Starting Remix Development Server
DESCRIPTION: Command to start the Remix application in development mode. This mode rebuilds assets automatically when file changes are detected.

LANGUAGE: sh
CODE:
npm run dev

----------------------------------------

TITLE: Defining Global Styles in Remix Root Component
DESCRIPTION: This example shows how to define global styles in the root component of a Remix application. It uses the links export to include a global CSS file.

LANGUAGE: jsx
CODE:
import type { LinksFunction } from "@remix-run/node";
import styles from "~/styles/global.css";

export const links: LinksFunction = () => [
  { rel: "stylesheet", href: styles },
];

----------------------------------------

TITLE: Module Cache Example in Development Mode
DESCRIPTION: Example demonstrating how module-level caching behaves in development mode, where cache is reset on each request due to module cache purging.

LANGUAGE: typescript
CODE:
const cache = new Map();

export async function loader({
  params,
}: LoaderFunctionArgs) {
  if (cache.has(params.foo)) {
    return json(cache.get(params.foo));
  }

  const record = await fakeDb.stuff.find(params.foo);
  cache.set(params.foo, record);
  return json(record);
}

----------------------------------------

TITLE: Starting Remix Production Server
DESCRIPTION: Runs the built Remix application in production mode using the built-in app server.

LANGUAGE: sh
CODE:
npm start

----------------------------------------

TITLE: Defining Frontmatter Metadata in Markdown
DESCRIPTION: YAML frontmatter block defining metadata for a documentation page about Remix hooks, including title and order properties.

LANGUAGE: markdown
CODE:
---
title: Hooks
order: 6
---

----------------------------------------

TITLE: Deploying Remix Project to Cloudflare Pages
DESCRIPTION: Command to deploy the built Remix project to Cloudflare Pages.

LANGUAGE: sh
CODE:
npm run deploy

----------------------------------------

TITLE: Building Remix for Production
DESCRIPTION: Creates a production build of the Remix application by bundling and optimizing all assets.

LANGUAGE: sh
CODE:
npm run build

----------------------------------------

TITLE: Configuring Port in Remix App Server
DESCRIPTION: Example of setting the PORT environment variable to change the server's listening port.

LANGUAGE: shellscript
CODE:
PORT=4000 npx remix-serve build/index.js

----------------------------------------

TITLE: React HMR Setup
DESCRIPTION: React Fast Refresh setup for Vite compiler

LANGUAGE: typescript
CODE:
export default defineConfig({
  plugins: [
    mdx(),
    remix()
  ],
});

----------------------------------------

TITLE: Running Remix Development Server
DESCRIPTION: Command to start the Remix development server for local development.

LANGUAGE: sh
CODE:
npm run dev

----------------------------------------

TITLE: Configuring PostCSS in Remix
DESCRIPTION: This example shows how to configure PostCSS in a Remix application. It sets up a custom PostCSS configuration file to enable advanced CSS processing.

LANGUAGE: jsx
CODE:
// postcss.config.js
module.exports = {
  plugins: {
    'postcss-preset-env': {}
  }
};

----------------------------------------

TITLE: Running Remix SPA in Development Mode
DESCRIPTION: Command to start the Remix development server for SPA mode.

LANGUAGE: shellscript
CODE:
npx remix vite:dev

----------------------------------------

TITLE: Running Remix in Production Mode
DESCRIPTION: Starts the Remix application server in production mode using the built assets.

LANGUAGE: sh
CODE:
npm start

----------------------------------------

TITLE: Basic Remix App Server Command
DESCRIPTION: Basic command syntax for starting the Remix App Server with a server build path parameter.

LANGUAGE: shellscript
CODE:
remix-serve <server-build-path>
# e.g.
remix-serve build/index.js

----------------------------------------

TITLE: View Transitions API Usage
DESCRIPTION: Example of using the View Transitions API with Remix Links

LANGUAGE: jsx
CODE:
function ImageLink(to, src, alt) {
  const isTransitioning = unstable_useViewTransitionState(to);
  return (
    <Link to={to} unstable_viewTransition>
      <img
        src={src}
        alt={alt}
        style={{
          viewTransitionName: isTransitioning ? "image-expand" : "",
        }}
      />
    </Link>
  );
}

----------------------------------------

TITLE: Installing Remix CLI using npx
DESCRIPTION: This command initializes a new Remix project using the create-remix CLI tool. It prompts the user for project setup options.

LANGUAGE: sh
CODE:
npx create-remix@latest

----------------------------------------

TITLE: Exposing Server Environment Variables to Client in Remix Root Loader
DESCRIPTION: Shows how to return environment variables from the root loader to make them available on the client side.

LANGUAGE: tsx
CODE:
export async function loader() {
  return json({
    ENV: {
      STRIPE_PUBLIC_KEY: process.env.STRIPE_PUBLIC_KEY,
      FAUNA_DB_URL: process.env.FAUNA_DB_URL,
    },
  });
}

export function Root() {
  return (
    <html lang="en">
      <head>
        <Meta />
        <Links />
      </head>
      <body>
        <Outlet />
        <Scripts />
      </body>
    </html>
  );
}

----------------------------------------

TITLE: Styling Active NavLink in CSS
DESCRIPTION: Shows how to style an active NavLink using CSS by targeting the automatically added 'active' class.

LANGUAGE: css
CODE:
a.active {
  color: red;
}

----------------------------------------

TITLE: Building Remix Application for Production
DESCRIPTION: Builds the Remix application for production deployment, creating optimized assets.

LANGUAGE: sh
CODE:
npm run build

----------------------------------------

TITLE: Starting Remix Development Server
DESCRIPTION: Command to start the Remix application in development mode with hot reloading enabled.

LANGUAGE: sh
CODE:
npm run dev

----------------------------------------

TITLE: Starting Remix Development Server
DESCRIPTION: Launches the Remix application in development mode with hot reload capabilities for asset rebuilding on file changes.

LANGUAGE: sh
CODE:
npm run dev

----------------------------------------

TITLE: Running Remix in Production Mode
DESCRIPTION: Command to start the Remix application in production mode after building.

LANGUAGE: sh
CODE:
npm start

----------------------------------------

TITLE: Automatic Index Parameter in Index Routes
DESCRIPTION: Shows how Forms automatically handle the index parameter when rendered within index routes.

LANGUAGE: tsx
CODE:
function ProjectsIndex() {
  return <Form method="post" />;
}

----------------------------------------

TITLE: Using flatRoutes in routes.ts
DESCRIPTION: Example of using the flatRoutes function from @remix-run/fs-routes to maintain file-based routing in routes.ts.

LANGUAGE: typescript
CODE:
import { flatRoutes } from "@remix-run/fs-routes";

export default flatRoutes();

----------------------------------------

TITLE: Configuring Link Discovery Behavior in Remix
DESCRIPTION: Demonstrates how to set the discover prop on Link components to control route discovery behavior.

LANGUAGE: tsx
CODE:
<>
  <Link /> {/* defaults to "render" */}
  <Link discover="none" />
</>

----------------------------------------

TITLE: NPM Package Installation Example
DESCRIPTION: Demonstration of installing and importing NPM packages in a Deno project

LANGUAGE: sh
CODE:
npm install react

LANGUAGE: ts
CODE:
import { useState } from "react";

----------------------------------------

TITLE: Serving Production Build with sirv-cli
DESCRIPTION: Command to serve the production build using sirv-cli with SPA fallback configuration

LANGUAGE: shellscript
CODE:
npx sirv-cli build/client/ --single

----------------------------------------

TITLE: Importing useOutlet Hook in Remix
DESCRIPTION: Demonstrates how to import the useOutlet hook from the @remix-run/react package. This hook returns the element for child routes at the current level of route hierarchy and is used internally by the Outlet component.

LANGUAGE: tsx
CODE:
import { useOutlet } from "@remix-run/react";

----------------------------------------

TITLE: Updating Server Abort Delay for v3_singleFetch
DESCRIPTION: Changes required in entry.server.tsx to use the new streamTimeout API for v3_singleFetch compatibility.

LANGUAGE: typescript
CODE:
-const ABORT_DELAY = 5000;
+// Reject/cancel all pending promises after 5 seconds
+export const streamTimeout = 5000;

// ...

function handleBrowserRequest(/* ... */) {
  return new Promise((resolve, reject) => {
    const { pipe, abort } = renderToPipeableStream(
      <RemixServer
        context={remixContext}
        url={request.url}
-        abortDelay={ABORT_DELAY}
      />,
      {
        onShellReady() {
          /* ... */
        },
        onShellError(error: unknown) {
          /* ... */
        },
        onError(error: unknown) {
          /* ... */
        },
      }
    );

-    setTimeout(abort, ABORT_DELAY);
+   // Automatically timeout the React renderer after 6 seconds, which ensures
+   // React has enough time to flush down the rejected boundary contents
+   setTimeout(abort, streamTimeout + 1000);
  });
}

----------------------------------------

TITLE: Blog Index Implementation with MDX Posts
DESCRIPTION: Example of implementing a blog index page that imports and displays multiple MDX posts

LANGUAGE: typescript
CODE:
import { json } from "@remix-run/node";
import { Link, useLoaderData } from "@remix-run/react";

import * as postA from "./posts/a.mdx";
import * as postB from "./posts/b.md";
import * as postC from "./posts/c.md";

function postFromModule(mod) {
  return {
    slug: mod.filename.replace(/\.mdx?$/, ""),
    ...mod.attributes.meta,
  };
}

export async function loader() {
  return json([
    postFromModule(postA),
    postFromModule(postB),
    postFromModule(postC),
  ]);
}

export default function Index() {
  const posts = useLoaderData<typeof loader>();

  return (
    <ul>
      {posts.map((post) => (
        <li key={post.slug}>
          <Link to={post.slug}>{post.title}</Link>
          {post.description ? (
            <p>{post.description}</p>
          ) : null}
        </li>
      ))}
    </ul>
  );
}

----------------------------------------

TITLE: Installing Remix with Deno Template
DESCRIPTION: Command to create a new Remix project using the Deno template

LANGUAGE: sh
CODE:
npx create-remix@latest --template remix-run/remix/templates/classic-remix-compiler/deno

----------------------------------------

TITLE: Installing NPM Dependencies
DESCRIPTION: Example of installing React package using npm

LANGUAGE: sh
CODE:
npm install react

----------------------------------------

TITLE: Configuring TLS in remix.config.js
DESCRIPTION: Example configuration for enabling TLS in the Remix dev server using key and certificate files.

LANGUAGE: JavaScript
CODE:
module.exports = {
  future: {
    unstable_dev: {
      tlsKey: "key.pem",
      tlsCert: "cert.pem"
    }
  }
}

----------------------------------------

TITLE: Deno Deploy Configuration
DESCRIPTION: Package.json configuration for Deno Deploy deployment script

LANGUAGE: json
CODE:
{
  "scripts": {
    "deploy": "deployctl deploy --project=<your deno deploy project> --include=.cache,build,public ./build/index.js"
  }
}

----------------------------------------

TITLE: Using useResolvedPath Hook in React Component
DESCRIPTION: Demonstrates basic usage of useResolvedPath hook to resolve relative paths. The hook returns a Path object containing pathname, search, and hash properties.

LANGUAGE: tsx
CODE:
import { useResolvedPath } from "@remix-run/react";

function SomeComponent() {
  const path = useResolvedPath("../some/where");
  path.pathname;
  path.search;
  path.hash;
  // ...
}

----------------------------------------

TITLE: Custom Routes Configuration in Remix Vite Plugin
DESCRIPTION: Example demonstrating how to define custom routes using the routes configuration option, including async route definition and nested routes.

LANGUAGE: typescript
CODE:
import { vitePlugin as remix } from "@remix-run/dev";
import { defineConfig } from "vite";

export default defineConfig({
  plugins: [
    remix({
      routes: async (defineRoutes) => {
        return defineRoutes((route) => {
          route("/some/path/*", "catchall.tsx");

          route("some/:path", "some/route/file.js", () => {
            route("relative/path", "some/other/file");
          });
        });
      },
    }),
  ],
});

----------------------------------------

TITLE: Using actionResult in shouldRevalidate
DESCRIPTION: This example demonstrates how to use the actionResult parameter in shouldRevalidate to decide whether to revalidate based on the action's outcome.

LANGUAGE: tsx
CODE:
export async function action() {
  await saveSomeStuff();
  return { ok: true };
}

export function shouldRevalidate({
  actionResult,
  defaultShouldRevalidate,
}) {
  if (actionResult?.ok) {
    return false;
  }
  return defaultShouldRevalidate;
}

----------------------------------------

TITLE: Better x-forwarded-host Header Validation
DESCRIPTION: Code changes for improving validation of x-forwarded-host header to prevent potential security issues.

LANGUAGE: markdown
CODE:
Better validation of `x-forwarded-host` header to preent potential security issues. ([#10553](https://github.com/remix-run/remix/pull/10553))

----------------------------------------

TITLE: Production Build Commands
DESCRIPTION: Commands for building and running the application in production mode

LANGUAGE: sh
CODE:
npm run build

LANGUAGE: sh
CODE:
npm start

----------------------------------------

TITLE: Implementing Remix Preset with Config Validation
DESCRIPTION: Enhanced preset implementation that includes config validation using the remixConfigResolved hook to ensure serverBundles isn't overridden.

LANGUAGE: typescript
CODE:
import type {
  Preset,
  ServerBundlesFunction,
} from "@remix-run/dev";

const serverBundles: ServerBundlesFunction = ({
  branch,
}) => {
  const isAuthenticatedRoute = branch.some((route) =>
    route.id.split("/").includes("_authenticated")
  );

  return isAuthenticatedRoute
    ? "authenticated"
    : "unauthenticated";
};

export function myCoolPreset(): Preset {
  return {
    name: "my-cool-preset",
    remixConfig: () => ({ serverBundles }),
    remixConfigResolved: ({ remixConfig }) => {
      if (remixConfig.serverBundles !== serverBundles) {
        throw new Error("`serverBundles` was overridden!");
      }
    },
  };
}

----------------------------------------

TITLE: Updating CSS Imports for Vite
DESCRIPTION: Example of updating CSS imports to use Vite's explicit ?url import syntax for use in links functions.

LANGUAGE: typescript
CODE:
-import styles from "~/styles/dashboard.css";
+import styles from "~/styles/dashboard.css?url";

export const links = () => {
  return [
    { rel: "stylesheet", href: styles }
  ];
}

----------------------------------------

TITLE: URL-based State Management with SearchParams
DESCRIPTION: Shows how to manage view state using URL search parameters in Remix, demonstrating a more robust approach that persists across page loads.

LANGUAGE: tsx
CODE:
import { Form, useSearchParams } from "@remix-run/react";

export function List() {
  const [searchParams] = useSearchParams();
  const view = searchParams.get("view") || "list";

  return (
    <div>
      <Form>
        <button name="view" value="list">
          View as List
        </button>
        <button name="view" value="details">
          View with Details
        </button>
      </Form>
      {view === "list" ? <ListView /> : <DetailView />}
    </div>
  );
}

----------------------------------------

TITLE: Typing Loader Function with LoaderArgs
DESCRIPTION: Example showing how to type a loader function using the LoaderArgs type from @remix-run/cloudflare for better type inference

LANGUAGE: typescript
CODE:
import type { LoaderArgs } from "@remix-run/cloudflare";

export async function loader(args: LoaderArgs) {
  return json(data);
}

----------------------------------------

TITLE: Development Server Commands
DESCRIPTION: Commands for running the application in development mode

LANGUAGE: sh
CODE:
npm run dev

----------------------------------------

TITLE: Demonstrating Hook Usage for Preserving State in React Fast Refresh
DESCRIPTION: This snippet shows a workaround to preserve component state during hot updates by using the hook's return value directly instead of destructuring.

LANGUAGE: tsx
CODE:
export const loader = async () => {
  return json({ stuff: "some things" });
};

export default function Component() {
  const data = useLoaderData<typeof loader>();
  return (
    <div>
      <input />
      <p>{data.stuff}</p>
    </div>
  );
}

----------------------------------------

TITLE: Starting Remix Dev Server and Wrangler
DESCRIPTION: This command starts the Remix development server and Wrangler for local development. It emulates the Cloudflare runtime environment.

LANGUAGE: sh
CODE:
# start the remix dev server and wrangler
npm run dev

----------------------------------------

TITLE: HTML Template for Remix SPA Hydration
DESCRIPTION: HTML template for hydrating a specific div instead of the full document in Remix SPA mode.

LANGUAGE: html
CODE:
<!DOCTYPE html>
<html lang="en">
  <head>
    <title>My Cool App!</title>
  </head>
  <body>
    <div id="app"><!-- Remix SPA --></div>
  </body>
</html>

----------------------------------------

TITLE: Configuring Vite with tsconfigPaths
DESCRIPTION: Vite configuration that includes the vite-tsconfig-paths plugin to resolve path aliases.

LANGUAGE: typescript
CODE:
import { vitePlugin as remix } from "@remix-run/dev";
import { defineConfig } from "vite";
import tsconfigPaths from "vite-tsconfig-paths";

export default defineConfig({
  plugins: [remix(), tsconfigPaths()],
});

----------------------------------------

TITLE: Creating a Remix Project from Private Templates
DESCRIPTION: Command to create a new Remix project using a private GitHub repository template with authentication token.

LANGUAGE: shellscript
CODE:
npx create-remix@latest --template your-private/repo --token yourtoken

----------------------------------------

TITLE: ADR Markdown Template Structure
DESCRIPTION: Standard template for Architecture Decision Records with sections for metadata, context, decision details and consequences. Includes status field that can reference superseding ADRs.

LANGUAGE: markdown
CODE:
# Title

Date: YYYY-MM-DD

Status: proposed | rejected | accepted | deprecated | … | superseded by [0005](0005-example.md)

## Context

## Decision

## Consequences

----------------------------------------

TITLE: Starting Remix Development Server with Wrangler
DESCRIPTION: Command to start the Remix development server along with Wrangler for local development, emulating the Cloudflare runtime environment.

LANGUAGE: shell
CODE:
# start the remix dev server and wrangler
npm run dev

----------------------------------------

TITLE: Configuring Vite for CJS/ESM Dependency Issues
DESCRIPTION: Vite configuration to handle CJS/ESM dependency issues in Remix SPA mode by including specific dependencies in the server bundle.

LANGUAGE: typescript
CODE:
import { vitePlugin as remix } from "@remix-run/dev";
import { defineConfig } from "vite";
import tsconfigPaths from "vite-tsconfig-paths";

export default defineConfig({
  plugins: [
    remix({
      ssr: false,
    }),
    tsconfigPaths(),
  ],
  ssr: {
    // Bundle `problematic-dependency` into the server build
    noExternal: ["problematic-dependency"],
  },
  // ...
});

----------------------------------------

TITLE: Rendering Module Script Tags in Remix
DESCRIPTION: This snippet shows how Remix renders module script tags using the <Scripts/> component. Modern browsers load these scripts for enhanced SPA behavior, while older browsers ignore them, falling back to basic HTML functionality.

LANGUAGE: html
CODE:
<script type="module" src="..." />

----------------------------------------

TITLE: Server Timeout Configuration
DESCRIPTION: Configuration for handling server timeouts with streaming data in entry.server.tsx.

LANGUAGE: tsx
CODE:
const ABORT_DELAY = 5_000;

const { pipe, abort } = renderToPipeableStream(
  <RemixServer
    context={remixContext}
    url={request.url}
    abortDelay={ABORT_DELAY}
  />
  // ...
);

// ...

setTimeout(abort, ABORT_DELAY);

----------------------------------------

TITLE: Module Import Resolution Challenge
DESCRIPTION: Example demonstrating the challenge of converting TypeScript imports to JavaScript, specifically the ambiguity in determining correct file extensions for imports.

LANGUAGE: javascript
CODE:
// ./script.mjs (converted from ./script.js)
import myHelper from "./my-helper";

// Should this be converted to `./my-helper.mjs`?
// Probably, but can we be sure?

myHelper();

----------------------------------------

TITLE: Initializing Basic Remix Route Component
DESCRIPTION: Basic route component setup showing a hello world message

LANGUAGE: TSX
CODE:
import { LiveReload } from "@remix-run/react";

export default function App() {
  return (
    <html lang="en">
      <head>
        <meta charSet="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <title>Remix: So great, it's funny!</title>
      </head>
      <body>
        Hello world
        <LiveReload />
      </body>
    </html>
  );
}

----------------------------------------

TITLE: Router Creation and Provider Setup in React
DESCRIPTION: Example showing the new approach to router creation and setup using createBrowserRouter and RouterProvider.

LANGUAGE: tsx
CODE:
const router = createBrowserRouter([
  {
    path: "/",
    element: <Layout />,
    children: [
      {
        index: true,
        element: <Home />,
      },
    ],
  },
]);

function NewApp() {
  return <RouterProvider router={router} />;
}

----------------------------------------

TITLE: Creating a Posts Route in Remix
DESCRIPTION: Defines a route component for displaying blog posts, including a loader function to fetch data from the server.

LANGUAGE: tsx
CODE:
import { json } from "@remix-run/node";
import { Link, useLoaderData } from "@remix-run/react";

import { getPosts } from "~/models/post.server";

export const loader = async () => {
  return json({ posts: await getPosts() });
};

export default function Posts() {
  const { posts } = useLoaderData<typeof loader>();
  return (
    <main>
      <h1>Posts</h1>
      <ul>
        {posts.map((post) => (
          <li key={post.slug}>
            <Link
              to={post.slug}
              className="text-blue-600 underline"
            >
              {post.title}
            </Link>
          </li>
        ))}
      </ul>
    </main>
  );
}

----------------------------------------

TITLE: Creating a Button Component with CSS URL Imports in React
DESCRIPTION: This example demonstrates how to create a Button component in React that uses CSS URL imports and exports a links array for Remix.

LANGUAGE: jsx
CODE:
import buttonCssUrl from "./Button.css?url";

export const links = [
  { rel: "stylesheet", href: buttonCssUrl },
];

export function Button(props) {
  return <button {...props} className="Button__root" />;
}

----------------------------------------

TITLE: Enabling v3_singleFetch Future Flag
DESCRIPTION: Configuration to enable the v3_singleFetch future flag in the Remix Vite plugin, including type declaration.

LANGUAGE: typescript
CODE:
import { vitePlugin as remix } from "@remix-run/dev";
import { defineConfig } from "vite";
import tsconfigPaths from "vite-tsconfig-paths";

declare module "@remix-run/node" {
  // or cloudflare, deno, etc.
  interface Future {
    v3_singleFetch: true;
  }
}

export default defineConfig({
  plugins: [
    remix({
      future: {
        v3_singleFetch: true,
      },
    }),
    tsconfigPaths(),
  ],
});

----------------------------------------

TITLE: Creating Remix Projects from Local Templates
DESCRIPTION: Commands to create new Remix projects using local directory or tarball templates.

LANGUAGE: shellscript
CODE:
npx create-remix@latest --template /my/remix-stack
npx create-remix@latest --template /my/remix-stack.tar.gz
npx create-remix@latest --template /my/remix-stack.tgz
npx create-remix@latest --template file:///Users/michael/my-remix-stack.tar.gz

----------------------------------------

TITLE: Handling Omitted Generics in useLoaderData (TypeScript)
DESCRIPTION: Shows the proposed behavior when generics are omitted in useLoaderData. The function will return 'unknown' instead of 'any', helping to catch potential type errors.

LANGUAGE: typescript
CODE:
type MyLoaderData = {
  /*...*/
};

export default function Route() {
  const data = useLoaderData();
  // ^? unknown
}

----------------------------------------

TITLE: Defining Post Model and Database Interactions
DESCRIPTION: Creates a module for handling post-related database operations using Prisma.

LANGUAGE: typescript
CODE:
import { prisma } from "~/db.server";
import type { Post } from "@prisma/client";

export async function getPosts() {
  return prisma.post.findMany();
}

export async function getPost(slug: string) {
  return prisma.post.findUnique({ where: { slug } });
}

export async function createPost(
  post: Pick<Post, "slug" | "title" | "markdown">
) {
  return prisma.post.create({ data: post });
}

----------------------------------------

TITLE: Project Creation with Directory Path
DESCRIPTION: Creates a new Remix project in a specified directory path

LANGUAGE: sh
CODE:
npx create-remix@latest <projectDir>

----------------------------------------

TITLE: Enabling v3_fetcherPersist Future Flag
DESCRIPTION: Configuration to enable the v3_fetcherPersist future flag in the Remix Vite plugin.

LANGUAGE: typescript
CODE:
remix({
  future: {
    v3_fetcherPersist: true,
  },
});

----------------------------------------

TITLE: Importing Cross-Runtime Cookie Session Storage in Remix
DESCRIPTION: Shows how to import a cookie session storage function that is supported across all runtimes in Remix.

LANGUAGE: typescript
CODE:
import { createCookieSessionStorage } from "@remix-run/node"; // or cloudflare/deno

----------------------------------------

TITLE: Updating dependencies in @remix-run/serve
DESCRIPTION: This snippet shows the typical pattern of updating dependencies in the @remix-run/serve package. It lists the updated packages and their new versions.

LANGUAGE: markdown
CODE:
### Patch Changes

- Updated dependencies:
  - `@remix-run/node@2.16.4`
  - `@remix-run/express@2.16.4`

----------------------------------------

TITLE: Adding new feature to @remix-run/serve
DESCRIPTION: This snippet demonstrates how a new feature is added to the @remix-run/serve package. It includes the feature description and any related code changes.

LANGUAGE: markdown
CODE:
### Minor Changes

- `remix-serve` now picks an open port if 3000 is taken ([#7278](https://github.com/remix-run/remix/pull/7278))

  - If `PORT` env var is set, `remix-serve` will use that port
  - Otherwise, `remix-serve` picks an open port (3000 unless that is already taken)

----------------------------------------

TITLE: Help Command
DESCRIPTION: Displays available commands and flags for create-remix CLI

LANGUAGE: sh
CODE:
npx create-remix@latest --help

----------------------------------------

TITLE: Using remixRoutesOptionAdapter in routes.ts
DESCRIPTION: Example of using the remixRoutesOptionAdapter to convert Remix's routes option into a React Router RouteConfig array.

LANGUAGE: typescript
CODE:
import { type RouteConfig } from "@remix-run/route-config";
import { remixRoutesOptionAdapter } from "@remix-run/routes-option-adapter";
import { flatRoutes } from "remix-flat-routes";

export default remixRoutesOptionAdapter((defineRoutes) =>
  flatRoutes("routes", defineRoutes)
) satisfies RouteConfig;

----------------------------------------

TITLE: Illustrating Hook Changes Impact on React Fast Refresh in TSX
DESCRIPTION: This code shows how changing or renaming destructured keys from hook return values can affect React Fast Refresh's ability to preserve component state.

LANGUAGE: tsx
CODE:
export const loader = async () => {
  return json({ stuff: "some things" });
};

export default function Component() {
  const { stuff } = useLoaderData<typeof loader>();
  return (
    <div>
      <input />
      <p>{stuff}</p>
    </div>
  );
}

----------------------------------------

TITLE: Minor Version Change Example
DESCRIPTION: Example of a minor version change documentation showing renamed features and updated dependencies

LANGUAGE: markdown
CODE:
### Minor Changes

- Rename `future.unstable_fogOfWar` to `future.unstable_lazyRouteDiscovery` for clarity ([#9763](https://github.com/remix-run/remix/pull/9763))

### Patch Changes

- Updated dependencies:
  - `@remix-run/node@2.11.0`
  - `@remix-run/react@2.11.0`

----------------------------------------

TITLE: Package Manager Variations
DESCRIPTION: Examples of creating Remix projects using different package managers including npm, yarn, pnpm, and bun

LANGUAGE: sh
CODE:
npm create remix@latest <projectDir>
# or
yarn create remix@latest <projectDir>
# or
pnpm create remix@latest <projectDir>
# or
bunx create-remix@latest <projectDir>

----------------------------------------

TITLE: Updating package.json Scripts for Vite
DESCRIPTION: Changes to the package.json scripts for development, building, and starting a Remix app with Vite.

LANGUAGE: json
CODE:
{
  "scripts": {
    "dev": "remix vite:dev",
    "build": "remix vite:build",
    "start": "remix-serve ./build/server/index.js"
  }
}

----------------------------------------

TITLE: Importing React Router Components in Remix (Correct)
DESCRIPTION: Shows the correct way to import React Router components in a Remix application. This method ensures access to Remix's extended functionality for these components.

LANGUAGE: tsx
CODE:
import { useLocation } from "@remix-run/react";

----------------------------------------

TITLE: Using Loader Type Inference with useLoaderData
DESCRIPTION: Example showing how to use type inference with useLoaderData hook by leveraging the loader function's type

LANGUAGE: typescript
CODE:
let data = useLoaderData<typeof loader>();

----------------------------------------

TITLE: Markdown Documentation for Remix Server Runtime
DESCRIPTION: Documentation explaining the server runtime interface and package requirements for Remix implementations across different platforms. Includes information about required implementations and optional features.

LANGUAGE: markdown
CODE:
# @remix-run/server-runtime

[Remix](https://remix.run) supports multiple server runtimes:

- [Node](https://nodejs.org/en/)
- [Cloudflare](https://developers.cloudflare.com/workers/learning/how-workers-works/)
- [Deno](https://deno.land/) (Experimental 🧪)

Support for each runtime is provided by a corresponding Remix package:

- [`@remix-run/node`](https://github.com/remix-run/remix/tree/main/packages/remix-node)
- [`@remix-run/cloudflare`](https://github.com/remix-run/remix/tree/main/packages/remix-cloudflare)
- [`@remix-run/deno`](https://github.com/remix-run/remix/tree/main/packages/remix-deno)

This package defines a "Remix server runtime interface" that each runtime package must conform to.

Each Remix server runtime package MUST:

- Implement and export values for each type in [`interface.ts`](./interface.ts)
- Re-export types in [`reexport.ts`](./reexport.ts)

Each Remix server runtime package MAY:

- Re-export the [default implementations](./index.ts) as its implementations
- Export custom implementations adhering to the [interface types](./interface.ts)
- Provide additional exports relevant for that runtime

----------------------------------------

TITLE: Express Server Integration with Remix Dev
DESCRIPTION: Example of integrating Express server with Remix dev mode including broadcastDevReady setup.

LANGUAGE: typescript
CODE:
import path from "node:path";

import { broadcastDevReady } from "@remix-run/node";
import express from "express";

const BUILD_DIR = path.resolve(__dirname, "build");
const build = require(BUILD_DIR);

const app = express();

// ... code for setting up your express app goes here ...

app.all("*", createRequestHandler({ build }));

const port = 3000;
app.listen(port, () => {
  console.log(`👉 http://localhost:${port}`);

  if (process.env.NODE_ENV === "development") {
    broadcastDevReady(build);
  }
});

----------------------------------------

TITLE: Updating tsconfig.json for Vite
DESCRIPTION: Changes required in tsconfig.json when migrating to the Vite plugin, including types and module settings.

LANGUAGE: json
CODE:
{
  "compilerOptions": {
    "types": ["@remix-run/node", "vite/client"],
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "Bundler"
  }
}

----------------------------------------

TITLE: Importing React Router Components in Remix (Incorrect)
DESCRIPTION: Demonstrates the incorrect way to import React Router components in a Remix application. This method should be avoided as it doesn't utilize Remix's extended functionality.

LANGUAGE: tsx
CODE:
import { useLocation } from "react-router-dom";

----------------------------------------

TITLE: Illustrating Type Casting in useLoaderData Implementation (TypeScript)
DESCRIPTION: Demonstrates how useLoaderData currently works internally, showing that it returns an 'any' type that is implicitly cast to the generic type parameter. This can lead to type safety issues.

LANGUAGE: typescript
CODE:
let data: any;

// somewhere else, `loader` gets called an sets `data` to some value

function useLoaderData<T>(): T {
  return data; // <-- Typescript casts this `any` to `T`
}

----------------------------------------

TITLE: Illustrating Browser History Stack After Back Button Click
DESCRIPTION: This code demonstrates how the browser history stack looks after a user clicks the back button, potentially leading to an unintended form resubmission.

LANGUAGE: plaintext
CODE:
GET /buy - *POST /checkout < GET /order/123

----------------------------------------

TITLE: Creating .env File for Local Development in Remix
DESCRIPTION: Shows how to create and use a .env file for local development in Remix projects. This file should not be committed to version control.

LANGUAGE: sh
CODE:
touch .env

----------------------------------------

TITLE: Updating Relative Links for v3_relativeSplatPath
DESCRIPTION: Example of updating relative links within a route to account for changes introduced by the v3_relativeSplatPath flag.

LANGUAGE: typescript
CODE:
// dashboard.$.tsx or dashboard/route.tsx
function Dashboard() {
  return (
    <div>
      <h2>Dashboard</h2>
      <nav>
-        <Link to="">Dashboard Home</Link>
-        <Link to="team">Team</Link>
-        <Link to="projects">Projects</Link>
+        <Link to="../">Dashboard Home</Link>
+        <Link to="../team">Team</Link>
+        <Link to="../projects">Projects</Link>
      </nav>
    </div>
  );
}

----------------------------------------

TITLE: Importing Server-Only Modules Example
DESCRIPTION: Example showing how Remix handles server-only code through .server directories and files, preventing server code from being included in client bundles.

LANGUAGE: javascript
CODE:
// Example structure:
// /api.server.js
// /models/.server/user.js

----------------------------------------

TITLE: Safe useLayoutEffect Implementation
DESCRIPTION: Shows how to create a safe version of useLayoutEffect that works in both server and browser environments.

LANGUAGE: typescript
CODE:
import * as React from "react";

const canUseDOM = !!(
  typeof window !== "undefined" &&
  window.document &&
  window.document.createElement
);

const useLayoutEffect = canUseDOM
  ? React.useLayoutEffect
  : () => {};

----------------------------------------

TITLE: Manual Route Configuration in Vite
DESCRIPTION: Example of manually configuring routes using the Vite plugin configuration in Remix, demonstrating how to define routes programmatically.

LANGUAGE: typescript
CODE:
import { vitePlugin as remix } from "@remix-run/dev";
import { defineConfig } from "vite";

export default defineConfig({
  plugins: [
    remix({
      routes(defineRoutes) {
        return defineRoutes((route) => {
          route("/", "home/route.tsx", { index: true });
          route("about", "about/route.tsx");
          route("concerts", "concerts/layout.tsx", () => {
            route("", "concerts/home.tsx", { index: true });
            route("trending", "concerts/trending.tsx");
            route(":city", "concerts/city.tsx");
          });
        });
      },
    }),
  ],
});

----------------------------------------

TITLE: Loader-based Headers in Remix Route
DESCRIPTION: Shows how to forward Cache-Control headers from a loader response to the route headers function.

LANGUAGE: tsx
CODE:
import type { HeadersFunction } from "@remix-run/node"; // or cloudflare/deno

export const headers: HeadersFunction = ({
  loaderHeaders,
}) => ({
  "Cache-Control": loaderHeaders.get("Cache-Control"),
});

----------------------------------------

TITLE: Defining Routes with New Route Config API
DESCRIPTION: Example of defining routes using the new route config API from @remix-run/route-config.

LANGUAGE: typescript
CODE:
import {
  type RouteConfig,
  route,
  layout,
  index,
} from "@remix-run/route-config";

export default [
  index("home/route.tsx"),
  route("about", "about/route.tsx"),
  layout("concerts/layout.tsx", [
    route("trending", "concerts/trending.tsx"),
    route(":city", "concerts/city.tsx"),
  ]),
] satisfies RouteConfig;

----------------------------------------

TITLE: Route Structure Example for Nested Error Boundaries
DESCRIPTION: Demonstration of a typical route structure showing how nested error boundaries can be organized in a Remix application

LANGUAGE: text
CODE:
app/
├── routes/
│   ├── sales.tsx
│   ├── sales.invoices.tsx
│   └── sales.invoices.$invoiceId.tsx
└── root.tsx

----------------------------------------

TITLE: Handling Data Requests in Remix Server Entry
DESCRIPTION: Implementation of handleDataRequest function that allows modification of data request responses before they are sent to the client. This function can customize headers and other response properties for non-HTML data requests.

LANGUAGE: typescript
CODE:
export function handleDataRequest(
  response: Response,
  {
    request,
    params,
    context,
  }: LoaderFunctionArgs | ActionFunctionArgs
) {
  response.headers.set("X-Custom-Header", "value");
  return response;
}

----------------------------------------

TITLE: Browser-Safe Local Storage Hook Implementation
DESCRIPTION: Example of implementing a custom hook that safely uses localStorage by avoiding server-side execution through useEffect.

LANGUAGE: tsx
CODE:
function useLocalStorage(key: string) {
  const [state, setState] = useState(null);

  useEffect(() => {
    setState(localStorage.getItem(key));
  }, [key]);

  const setWithLocalStorage = (nextState) => {
    setState(nextState);
  };

  return [state, setWithLocalStorage];
}

----------------------------------------

TITLE: Configuring TSConfig for Remix
DESCRIPTION: JSON configuration for tsconfig.json in a Remix TypeScript project.

LANGUAGE: json
CODE:
{
  "include": ["remix.env.d.ts", "**/*.ts", "**/*.tsx"],
  "compilerOptions": {
    "lib": ["DOM", "DOM.Iterable", "ES2022"],
    "isolatedModules": true,
    "esModuleInterop": true,
    "jsx": "react-jsx",
    "resolveJsonModule": true,
    "moduleResolution": "Bundler",
    "baseUrl": ".",
    "noEmit": true,
    "paths": {
      "~/*": ["./app/*"]
    }
  }
}

----------------------------------------

TITLE: Installing Remix Packages
DESCRIPTION: Commands for installing necessary Remix packages for building a Remix application.

LANGUAGE: shell
CODE:
npm install @remix-run/react @remix-run/node @remix-run/serve
npm install -D @remix-run/dev

----------------------------------------

TITLE: Illustrating Named Function Components for React Fast Refresh in TSX
DESCRIPTION: This code demonstrates the correct way to define named function components for React Fast Refresh compatibility. Anonymous functions are not supported, while named functions and constants are.

LANGUAGE: tsx
CODE:
export default () => {}; // ❌
export default function () {} // ❌

const ComponentA = () => {};
export default ComponentA; // ✅

export default function ComponentB() {} // ✅

----------------------------------------

TITLE: Custom Route Definition
DESCRIPTION: Example of defining custom routes programmatically, including nested routes and catchall routes, as an alternative to filesystem-based routing.

LANGUAGE: javascript
CODE:
exports.routes = async (defineRoutes) => {
  return defineRoutes((route) => {
    route("/some/path/*", "catchall.tsx");
    route("some/:path", "some/route/file.js", () => {
      route("relative/path", "some/other/file");
    });
  });
};

----------------------------------------

TITLE: Server-Only Code with vite-env-only in Remix
DESCRIPTION: Demonstrates using the vite-env-only plugin to explicitly mark server-only code while maintaining client-safe code in the same module.

LANGUAGE: tsx
CODE:
import { serverOnly$ } from "vite-env-only";

import { db } from "~/.server/db";

export const getPosts = serverOnly$(async () => {
  return db.posts.findMany();
});

export const PostPreview = ({ title, description }) => {
  return (
    <article>
      <h2>{title}</h2>
      <p>{description}</p>
    </article>
  );
};

----------------------------------------

TITLE: Creating Remix Client Entry Point
DESCRIPTION: TypeScript code for the client entry point in a Remix application, handling hydration.

LANGUAGE: tsx
CODE:
import { RemixBrowser } from "@remix-run/react";
import { startTransition, StrictMode } from "react";
import { hydrateRoot } from "react-dom/client";

startTransition(() => {
  hydrateRoot(
    document,
    <StrictMode>
      <RemixBrowser />
    </StrictMode>
  );
});

----------------------------------------

TITLE: Creating a New Record with Form in Remix
DESCRIPTION: This snippet demonstrates how to create a new record using Form, useActionData, and useNavigation in Remix. It includes form validation, database interaction, and UI feedback.

LANGUAGE: tsx
CODE:
import type { ActionFunctionArgs } from "@remix-run/node"; // or cloudflare/deno
import { redirect } from "@remix-run/node"; // or cloudflare/deno
import {
  Form,
  useActionData,
  useNavigation,
} from "@remix-run/react";

export async function action({
  request,
}: ActionFunctionArgs) {
  const formData = await request.formData();
  const errors = await validateRecipeFormData(formData);
  if (errors) {
    return json({ errors });
  }
  const recipe = await db.recipes.create(formData);
  return redirect(`/recipes/${recipe.id}`);
}

export function NewRecipe() {
  const { errors } = useActionData<typeof action>();
  const navigation = useNavigation();
  const isSubmitting =
    navigation.formAction === "/recipes/new";

  return (
    <Form method="post">
      <label>
        Title: <input name="title" />
        {errors?.title ? <span>{errors.title}</span> : null}
      </label>
      <label>
        Ingredients: <textarea name="ingredients" />
        {errors?.ingredients ? (
          <span>{errors.ingredients}</span>
        ) : null}
      </label>
      <label>
        Directions: <textarea name="directions" />
        {errors?.directions ? (
          <span>{errors.directions}</span>
        ) : null}
      </label>
      <button type="submit">
        {isSubmitting ? "Saving..." : "Create Recipe"}
      </button>
    </Form>
  );
}

----------------------------------------

TITLE: Configuring Remix Documentation Page Metadata
DESCRIPTION: Front matter metadata configuration for a documentation page about utilities in the Remix framework. Specifies the title and order of the page in navigation.

LANGUAGE: markdown
CODE:
---
title: Utilities
order: 6
---

----------------------------------------

TITLE: Implementing CJS Require Cache Busting
DESCRIPTION: Function to handle server code reimporting in CommonJS by manually clearing require cache and reimporting server build

LANGUAGE: javascript
CODE:
const path = require("node:path");

/** @typedef {import('@remix-run/node').ServerBuild} ServerBuild */

const BUILD_PATH = path.resolve("./build/index.js");
const VERSION_PATH = path.resolve("./build/version.txt");
const initialBuild = reimportServer();

/**
 * @returns {ServerBuild}
 */
function reimportServer() {
  // 1. manually remove the server build from the require cache
  Object.keys(require.cache).forEach((key) => {
    if (key.startsWith(BUILD_PATH)) {
      delete require.cache[key];
    }
  });

  // 2. re-import the server build
  return require(BUILD_PATH);
}

----------------------------------------

TITLE: Mark Article as Read with Fetcher in Remix
DESCRIPTION: This snippet demonstrates how to use useFetcher to mark an article as read after the user has spent some time on the page and scrolled to the bottom. It uses a custom hook for detecting user behavior.

LANGUAGE: typescript
CODE:
function useMarkAsRead({ articleId, userId }) {
  const marker = useFetcher();

  useSpentSomeTimeHereAndScrolledToTheBottom(() => {
    marker.submit(
      { userId },
      {
        action: `/article/${articleId}/mark-as-read`,
        method: "post",
      }
    );
  });
}

----------------------------------------

TITLE: User Avatar Details Popup with Fetcher in Remix
DESCRIPTION: This example shows how to implement a user avatar details popup using useFetcher. It fetches user details when hovering over an avatar and displays them in a popup.

LANGUAGE: tsx
CODE:
export async function loader({
  params,
}: LoaderFunctionArgs) {
  return json(
    await fakeDb.user.find({ where: { id: params.id } })
  );
}

function UserAvatar({ partialUser }) {
  const userDetails = useFetcher<typeof loader>();
  const [showDetails, setShowDetails] = useState(false);

  useEffect(() => {
    if (
      showDetails &&
      userDetails.state === "idle" &&
      !userDetails.data
    ) {
      userDetails.load(`/users/${user.id}/details`);
    }
  }, [showDetails, userDetails]);

  return (
    <div
      onMouseEnter={() => setShowDetails(true)}
      onMouseLeave={() => setShowDetails(false)}
    >
      <img src={partialUser.profileImageUrl} />
      {showDetails ? (
        userDetails.state === "idle" && userDetails.data ? (
          <UserPopup user={userDetails.data} />
        ) : (
          <UserPopupLoading />
        )
      ) : null}
    </div>
  );
}

----------------------------------------

TITLE: Implementing Client-Only Route with HydrateFallback in Remix
DESCRIPTION: This snippet demonstrates how to create a client-only route using HydrateFallback and clientLoader in Remix. It shows the setup for loading game data on the client side and rendering a fallback during server-side rendering.

LANGUAGE: tsx
CODE:
export async function clientLoader() {
  const data = await loadSavedGameOrPrepareNewGame();
  return data;
}
// Note clientLoader.hydrate is implied without a server loader

export function HydrateFallback() {
  return <p>Loading Game...</p>;
}

export default function Component() {
  const data = useLoaderData<typeof clientLoader>();
  return <Game data={data} />;
}

----------------------------------------

TITLE: Vite Configuration for Dependency Exclusion
DESCRIPTION: Example of how to configure Vite to exclude problematic dependencies from optimization using the optimizeDeps.exclude option.

LANGUAGE: typescript
CODE:
export default defineConfig({
  optimizeDeps: {
    exclude: ["svg2img"],
  },
});

----------------------------------------

TITLE: Initializing Manual Dev Server Command
DESCRIPTION: Command to start Remix dev server in manual mode with a custom server script

LANGUAGE: shellscript
CODE:
remix dev --manual -c "node ./server.js"

----------------------------------------

TITLE: Conditional ScrollRestoration Key in Remix
DESCRIPTION: This snippet shows how to conditionally use different keys for scroll restoration based on the current pathname, allowing for hybrid behavior across different routes.

LANGUAGE: tsx
CODE:
<ScrollRestoration
  getKey={(location, matches) => {
    const paths = ["/home", "/notifications"];
    return paths.includes(location.pathname)
      ? // home and notifications restore by pathname
        location.pathname
      : // everything else by location like the browser
        location.key;
  }}
/>

----------------------------------------

TITLE: Database Connection Utility
DESCRIPTION: Utility for managing database connection with singleton pattern

LANGUAGE: TypeScript
CODE:
import { PrismaClient } from "@prisma/client";
import { singleton } from "./singleton.server";

export const db = singleton("prisma", () => new PrismaClient());

----------------------------------------

TITLE: Implementing Inline JavaScript with dangerouslySetInnerHTML in Remix
DESCRIPTION: Shows how to add minimal client-side interactivity using inline JavaScript when full hydration is disabled.

LANGUAGE: tsx
CODE:
return (
  <>
    <select id="qty">
      <option>1</option>
      <option>2</option>
      <option value="contact">
        Contact Sales for more
      </option>
    </select>

    <script
      dangerouslySetInnerHTML={{
        __html: `
          document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('qty').onchange = (event) => {
              if (event.target.value === "contact") {
                window.location.assign("/contact")
              }
            }
          });
        `,
      }}
    />
  </>
);

----------------------------------------

TITLE: Browser Environment Detection in TypeScript
DESCRIPTION: Shows the proper way to detect server vs browser environments across different JavaScript runtimes like Node.js, Deno, and Workers.

LANGUAGE: typescript
CODE:
if (typeof document === "undefined") {
  // running in a server environment
} else {
  // running in a browser environment
}

----------------------------------------

TITLE: Using Pathname for ScrollRestoration Key in Remix
DESCRIPTION: This example demonstrates using the pathname as the key for scroll restoration, which can be useful for maintaining scroll position on specific routes regardless of navigation method.

LANGUAGE: tsx
CODE:
<ScrollRestoration
  getKey={(location, matches) => {
    return location.pathname;
  }}
/>

----------------------------------------

TITLE: Implementing ScrollRestoration in Remix Root Component
DESCRIPTION: This snippet demonstrates how to implement the ScrollRestoration component in the root component of a Remix application. It should be placed just before the Scripts component.

LANGUAGE: tsx
CODE:
import {
  Scripts,
  ScrollRestoration,
} from "@remix-run/react";

export default function Root() {
  return (
    <html>
      <body>
        {/* ... */}
        <ScrollRestoration />
        <Scripts />
      </body>
    </html>
  );
}

----------------------------------------

TITLE: Installing and Testing Remix with pnpm
DESCRIPTION: Basic commands for setting up a Remix development environment, including installation, building, and running various test suites using pnpm package manager.

LANGUAGE: bash
CODE:
# install everything
pnpm install

# run the build
pnpm build

# run the unit tests
pnpm test:primary

# run the unit tests for a specific package in watch mode
pnpm test:primary packages/remix-react --watch

# run the playwright integration tests in Chromium
pnpm test:integration --project chromium

# run specific playwright integration tests in Chromium
pnpm test:integration integration/client-data --project chromium

----------------------------------------

TITLE: Basic React State Management Example
DESCRIPTION: Demonstrates a simple list/detail view toggle using React useState. Shows the basic but limited approach of using local component state.

LANGUAGE: tsx
CODE:
export function List() {
  const [view, setView] = React.useState("list");
  return (
    <div>
      <div>
        <button onClick={() => setView("list")}>
          View as List
        </button>
        <button onClick={() => setView("details")}>
          View with Details
        </button>
      </div>
      {view === "list" ? <ListView /> : <DetailView />}
    </div>
  );
}

----------------------------------------

TITLE: Navigation with Partial Path Object in Remix
DESCRIPTION: Illustrates using a Partial<Path> object with useNavigate for more detailed navigation control.

LANGUAGE: tsx
CODE:
navigate({
  pathname: "/some/path",
  search: "?query=string",
  hash: "#hash",
});

----------------------------------------

TITLE: Using View Transitions with Images in React/Remix
DESCRIPTION: Demonstrates how to implement view transitions on images using the useViewTransitionState hook. The component creates a linked image that smoothly transitions when navigating to a detailed view. The transition state is used to conditionally apply the view-transition-name CSS property.

LANGUAGE: jsx
CODE:
function NavImage({ src, alt, id }) {
  const to = `/images/${idx}`;
  const vt = useViewTransitionState(to);
  return (
    <Link to={to} viewTransition>
      <img
        src={src}
        alt={alt}
        style={{
          viewTransitionName: vt ? "image-expand" : "",
        }}
      />
    </Link>
  );
}

----------------------------------------

TITLE: Implementing Links Component in Remix Root Component
DESCRIPTION: Demonstrates how to use the Links component from @remix-run/react within the root component to render link tags in the document head. The Links component should be placed inside the HTML head element to properly manage route-based link elements.

LANGUAGE: tsx
CODE:
import { Links } from "@remix-run/react";

export default function Root() {
  return (
    <html>
      <head>
        <Links />
      </head>
      <body></body>
    </html>
  );
}

----------------------------------------

TITLE: Deprecating Non-Inferred Types in useLoaderData (TypeScript)
DESCRIPTION: Demonstrates the proposed deprecation of non-inferred types via generics in useLoaderData. Users are encouraged to use explicit type casting instead of non-inferred generics.

LANGUAGE: typescript
CODE:
type MyLoaderData = {
  /*...*/
};

export default function Route() {
  const dataGeneric = useLoaderData<MyLoaderData>(); // <-- will be deprecated
  const dataCast = useLoaderData() as MyLoaderData; // <- use this instead
}

----------------------------------------

TITLE: Creating PDF Resource Route in Remix
DESCRIPTION: Implementation of a Resource Route that generates and serves a PDF file. Demonstrates proper response headers and PDF generation handling.

LANGUAGE: tsx
CODE:
export async function loader({
  params,
}: LoaderFunctionArgs) {
  const report = await getReport(params.id);
  const pdf = await generateReportPDF(report);
  return new Response(pdf, {
    status: 200,
    headers: {
      "Content-Type": "application/pdf",
    },
  });
}

----------------------------------------

TITLE: Implementing Singleton Pattern for Server State
DESCRIPTION: Utility functions to maintain server-side state across rebuilds using singleton pattern

LANGUAGE: typescript
CODE:
export const singleton = <Value>(
  name: string,
  valueFactory: () => Value
): Value => {
  const g = global as any;
  g.__singletons ??= {};
  g.__singletons[name] ??= valueFactory();
  return g.__singletons[name];
};

LANGUAGE: typescript
CODE:
import { PrismaClient } from "@prisma/client";

import { singleton } from "~/utils/singleton.server";

// hard-code a unique key so we can look up the client when this module gets re-imported
export const db = singleton(
  "prisma",
  () => new PrismaClient()
);

----------------------------------------

TITLE: Proposed Type Inference for useLoaderData in Remix (TypeScript/TSX)
DESCRIPTION: Illustrates the proposed change for type inference in useLoaderData. This approach infers the return type from the loader function, improving type safety and reducing redundant type declarations.

LANGUAGE: tsx
CODE:
export const loader = async (args: LoaderArgs) => {
  // ...
  return json(/*.../);
};

export default function Route() {
  const data = useLoaderData<typeof loader>();
  // ...
}

----------------------------------------

TITLE: Basic Remix Project Creation
DESCRIPTION: Creates a new Remix project using the default interactive CLI configuration

LANGUAGE: sh
CODE:
npx create-remix@latest

----------------------------------------

TITLE: Setting Up CSS Bundling in Remix
DESCRIPTION: TypeScript code for setting up CSS bundling in a Remix application's root route.

LANGUAGE: tsx
CODE:
import { cssBundleHref } from "@remix-run/css-bundle";
import type { LinksFunction } from "@remix-run/node"; // or cloudflare/deno

export const links: LinksFunction = () => {
  return [
    ...(cssBundleHref
      ? [{ rel: "stylesheet", href: cssBundleHref }]
      : []),
    // ...
  ];
};

----------------------------------------

TITLE: Demonstrating Current useLoaderData and useActionData Usage in Remix (TypeScript/TSX)
DESCRIPTION: Shows how useLoaderData and useActionData are currently used with explicit type parameters in Remix v1.6.4. This approach requires users to manually specify types for both the hooks and the json responses.

LANGUAGE: tsx
CODE:
type MyLoaderData = {
  /* ... */
};
type MyActionData = {
  /* ... */
};

export default function Route() {
  const loaderData = useLoaderData<MyLoaderData>();
  const actionData = useActionData<MyActionData>();
  return <div>{/* ... */}</div>;
}

export const loader: LoaderFunction = () => {
  return json<MyLoaderData>({
    /* ... */
  });
};

export const action: ActionFunction = () => {
  return json<MyActionData>({
    /* ... */
  });
};

----------------------------------------

TITLE: Configuring Express Server with TLS
DESCRIPTION: Example of setting up an Express server with TLS certificate and key files.

LANGUAGE: TypeScript
CODE:
import fs from "node:fs";
import https from "node:https";
import express from "express";

const app = express();

const appServer = https.createServer(
  {
    key: fs.readFileSync("key.pem"),
    cert: fs.readFileSync("cert.pem")
  },
  app
);

appServer.listen(3000, () => {
  console.log("Ready on https://localhost:3000");
});

----------------------------------------

TITLE: Enabling Single Fetch Configuration - TypeScript
DESCRIPTION: Configuration setup to enable Single Fetch in a Remix application's Vite config file.

LANGUAGE: typescript
CODE:
export default defineConfig({
  plugins: [
    remix({
      future: {
        // ...
        v3_singleFetch: true,
      },
    }),
    // ...
  ],
});

----------------------------------------

TITLE: Accessing Streamed Data in React Component
DESCRIPTION: Shows how to access both critical and lazy-loaded data in a React component using useLoaderData hook, where lazy data is returned as a Promise.

LANGUAGE: tsx
CODE:
function Component() {
  const data = useLoaderData();
  // data.critical is a resolved value
  // data.lazy is a Promise
}

----------------------------------------

TITLE: TypeScript loader data usage example
DESCRIPTION: Example showing how to use inferred types with useLoaderData hook

LANGUAGE: typescript
CODE:
let data = useLoaderData<typeof loader>();

----------------------------------------

TITLE: Configuring Import Map for VS Code Deno Extension
DESCRIPTION: This JSON snippet defines an import map used solely for the Deno extension in VS Code. It maps React and ReactDOM imports to their ESM versions. This configuration is not used by Remix but helps with type hints in the editor.

LANGUAGE: json
CODE:
{
  "// This import map is used solely for the denoland.vscode-deno extension.": "",
  "// Remix does not support import maps.": "",
  "// Dependency management is done through `npm` and `node_modules/` instead.": "",
  "// Deno-only dependencies may be imported via URL imports (without using import maps).": "",

  "imports": {
    "react": "https://esm.sh/react@18.0.0",
    "react-dom": "https://esm.sh/react-dom@18.0.0",
    "react-dom/server": "https://esm.sh/react-dom@18.0.0/server"
  }
}

----------------------------------------

TITLE: TypeScript Loader Type Inference Example
DESCRIPTION: Demonstrates how to use LoaderArgs type and loader type inference with useLoaderData hook

LANGUAGE: typescript
CODE:
- import type { LoaderFunction } from "@remix-run/node";
+ import type { LoaderArgs } from "@remix-run/node";

- export const loader: LoaderFunction = async (args) => {
-   return json<LoaderData>(data);
- }
+ export async function loader(args: LoaderArgs) {
+   return json(data);
+ }

- let data = useLoaderData() as LoaderData;
+ let data = useLoaderData<typeof loader>();

----------------------------------------

TITLE: Initializing Remix Project with NPX
DESCRIPTION: This command uses npx to create a new Remix project. It runs the latest version of create-remix and prompts the user for project configuration.

LANGUAGE: sh
CODE:
npx create-remix@latest

----------------------------------------

TITLE: Configuring VS Code Settings for Deno
DESCRIPTION: This JSON snippet configures VS Code settings to enable Deno and use the custom import map for resolving NPM imports in the Deno extension. This helps provide correct type hints for NPM dependencies in a Deno environment.

LANGUAGE: json
CODE:
{
  "deno.enable": true,
  "deno.importMap": "./.vscode/resolve_npm_imports_in_deno.json"
}

----------------------------------------

TITLE: Node Server Setup with Globals
DESCRIPTION: Shows how to setup a Node server with required globals for fetch and source map support

LANGUAGE: javascript
CODE:
import { installGlobals } from "@remix-run/node";
import sourceMapSupport from "source-map-support";

sourceMapSupport.install();
installGlobals();

----------------------------------------

TITLE: Installing ESLint Configuration for Remix
DESCRIPTION: Command to install the ESLint configuration package and its dependencies using npm.

LANGUAGE: sh
CODE:
npm install -D eslint @remix-run/eslint-config

----------------------------------------

TITLE: Scroll Restoration Key Function in TypeScript
DESCRIPTION: Example implementation of the getKey function for ScrollRestoration component to control scroll position restoration behavior.

LANGUAGE: typescript
CODE:
function getKey(location: Location, matches: DataRouteMatch[]) {
  // Restore by pathname on /tweets
  if (location.pathname === "/tweets") {
    return location.pathname;
  }
  // Otherwise use the key
  return location.key;
}

----------------------------------------

TITLE: Implementing Basic Remix Preset with Server Bundles
DESCRIPTION: Example implementation of a basic Remix preset that configures server bundles based on route authentication status.

LANGUAGE: typescript
CODE:
import type { Preset } from "@remix-run/dev";

export function myCoolPreset(): Preset {
  return {
    name: "my-cool-preset",
    remixConfig: () => ({
      serverBundles: ({ branch }) => {
        const isAuthenticatedRoute = branch.some((route) =>
          route.id.split("/").includes("_authenticated")
        );

        return isAuthenticatedRoute
          ? "authenticated"
          : "unauthenticated";
      },
    }),
  };
}

----------------------------------------

TITLE: Declaring Single Fetch Future in Vite Config
DESCRIPTION: This code snippet shows how to declare and enable the single fetch future in a Vite configuration file for Remix.

LANGUAGE: typescript
CODE:
// vite.config.ts

declare module "@remix-run/server-runtime" {
  interface Future {
    unstable_singleFetch: true; // 👈 enable _types_ for single-fetch
  }
}

export default defineConfig({
  plugins: [
    remix({
      future: {
        unstable_singleFetch: true, // 👈 enable single-fetch
      },
    }),
  ],
});

----------------------------------------

TITLE: Visualizing Linear Workflow with Mermaid Diagram
DESCRIPTION: This Mermaid diagram illustrates the flow of issues through various statuses in the Linear workflow. It shows how issues move from intake to completion or cancellation, including feedback loops and potential blockers.

LANGUAGE: mermaid
CODE:
graph TD
    A(Github/Discord/???) -->|intake| Triage
    Triage -->|accepted| Backlog
    Triage -->|rejected| Canceled
    Backlog -->|planned| Todo
    Todo -->|picked up| InProgress(In Progress)
    InProgress -->|PR| InReview(In Review)
    InProgress -->|stopped| Todo
    InProgress -->|blocked| NeedsFeedback(Needs Feedback)
    NeedsFeedback -->|unblocked| InProgress
    InReview -->|larger changes| InProgress
    InReview -->|small comments| InReview
    InReview -->|merged| Done

----------------------------------------

TITLE: Defining Remix Preset Type Structure
DESCRIPTION: TypeScript type definition for Remix presets, showing the required structure with name property and optional remixConfig and remixConfigResolved hooks.

LANGUAGE: typescript
CODE:
type Preset = {
  name: string;

  remixConfig?: (args: {
    remixUserConfig: VitePluginConfig;
  }) => RemixConfigPreset | Promise<RemixConfigPreset>;

  remixConfigResolved?: (args: {
    remixConfig: ResolvedVitePluginConfig;
  }) => void | Promise<void>;
};

----------------------------------------

TITLE: Source Map Support Setup
DESCRIPTION: Code example showing how to install source-map-support when using a custom app server

LANGUAGE: javascript
CODE:
import sourceMapSupport from "source-map-support";
sourceMapSupport.install();

----------------------------------------

TITLE: Implementing Feature-Flagged Server-Side Request Handling in Remix
DESCRIPTION: This code snippet demonstrates how to implement a feature flag for testing the new React Router 6.4 static handler alongside the existing Remix request handling logic. It includes assertions to ensure the new approach produces equivalent results.

LANGUAGE: typescript
CODE:
const ENABLE_REMIX_ROUTER = false;

async function handleDocumentRequest({ request }) {
  const appState = {
    trackBoundaries: true,
    trackCatchBoundaries: true,
    catchBoundaryRouteId: null,
    renderBoundaryRouteId: null,
    loaderBoundaryRouteId: null,
    error: undefined,
    catch: undefined,
  };

  // ... do all the current stuff

  const serverHandoff = {
    actionData,
    appState: appState,
    matches: entryMatches,
    routeData,
  };

  const entryContext = {
    ...serverHandoff,
    manifest: build.assets,
    routeModules,
    serverHandoffString: createServerHandoffString(serverHandoff),
  };

  // If the flag is enabled, process the request again with the new static
  // handler and confirm we get the same data on the other side
  if (ENABLE_REMIX_ROUTER) {
    const staticHandler = unstable_createStaticHandler(routes);
    const context = await staticHandler.query(request);

    // Note: == only used for brevity ;)
    assert(entryContext.matches === context.matches);
    assert(entryContext.routeData === context.loaderData);
    assert(entryContext.actionData === context.actionData);

    if (catchBoundaryRouteId) {
      assert(appState.catch === context.errors[catchBoundaryRouteId]);
    }

    if (loaderBoundaryRouteId) {
      assert(appState.error === context.errors[loaderBoundaryRouteId]);
    }
  }
}

----------------------------------------

TITLE: Rendering and Testing a Remix Stub Component in TSX
DESCRIPTION: This snippet shows how to render a RemixStub component and perform assertions using React Testing Library.

LANGUAGE: tsx
CODE:
render(<RemixStub />);
await screen.findByText("Some rendered text");

----------------------------------------

TITLE: Installing Server Globals Setup
DESCRIPTION: Code example showing how to install required globals when using a custom app server instead of remix-serve

LANGUAGE: javascript
CODE:
import { installGlobals } from "@remix-run/node";

installGlobals();

----------------------------------------

TITLE: CLI Interaction for Remix Project Creation
DESCRIPTION: Example of the CLI prompt when creating a new Remix project, showing the option to choose between TypeScript and JavaScript.

LANGUAGE: sh
CODE:
❯ npx create-remix@latest
? Where would you like to create your app? ./my-remix-app
? What type of app do you want to create? Just the basics
? Where do you want to deploy? Choose Remix App Server if you're unsure; it's easy to change deployment targets. Remix App Server
? TypeScript or JavaScript? (Use arrow keys)
❯ TypeScript
  JavaScript

----------------------------------------

TITLE: Configuring RemixStub with Advanced Options in Remix
DESCRIPTION: This snippet demonstrates advanced usage of the RemixStub component, including controlling the initial URL, history stack, hydration data, and future flags. It shows how to test the app rendered at specific routes and with initial loader data.

LANGUAGE: tsx
CODE:
// Test the app rendered at "/2" with 2 prior history stack entries
render(
  <RemixStub
    initialEntries={["/", "/1", "/2"]}
    initialIndex={2}
  />
);

// Test the app rendered with initial loader data for the root route.  When using
// this, it's best to give your routes their own unique IDs in your route definitions
render(
  <RemixStub
    hydrationData={{
      loaderData: { root: { message: "hello" } },
    }}
  />
);

// Test the app rendered with given future flags enabled
render(<RemixStub future={{ v3_coolFeature: true }} />);

----------------------------------------

TITLE: Starting Remix Production Server
DESCRIPTION: Command to start the Remix application in production mode after building the project. This runs the app using the production-ready server.

LANGUAGE: sh
CODE:
npm start

----------------------------------------

TITLE: Migrating Remix CLI Commands to Vite
DESCRIPTION: Shows the mapping of traditional Remix CLI commands to their Vite equivalents. The build command now requires both client and SSR builds, while the dev command uses Vite's development server.

LANGUAGE: shell
CODE:
remix build 👉 vite build && vite build --ssr
remix dev 👉 vite dev

----------------------------------------

TITLE: Using createRemixStub with Stubbed Context in Remix
DESCRIPTION: This example shows how to use createRemixStub with a stubbed context for loaders that rely on the getLoadContext method. It demonstrates providing a stubbed context via the second parameter to createRemixStub.

LANGUAGE: tsx
CODE:
const RemixStub = createRemixStub(
  [
    {
      path: "/",
      Component: MyComponent,
      loader({ context }) {
        return json({ message: context.key });
      },
    },
  ],
  { key: "value" }
);

----------------------------------------

TITLE: Building Remix Project for Production
DESCRIPTION: Command to build the Remix project for production deployment. This step is necessary before running the app in production mode.

LANGUAGE: sh
CODE:
npm run build

----------------------------------------

TITLE: Installing Remix Framework using NPX
DESCRIPTION: Command to create a new Remix project using NPX. This will initiate an interactive setup process where you can configure your project options.

LANGUAGE: sh
CODE:
npx create-remix@latest

----------------------------------------

TITLE: Testing Library Dependencies Configuration
DESCRIPTION: Package.json configuration showing required dependencies for using Jest and Testing Library with the ESLint configuration.

LANGUAGE: json
CODE:
{
  "dependencies": {
    "@testing-library/jest-dom": ">=5.16.0",
    "@testing-library/react": ">=12.0.0",
    "jest": ">=28.0.0"
  }
}

----------------------------------------

TITLE: Building Remix for Production
DESCRIPTION: Command to build the Remix application for production deployment, generating optimized assets in the build directory.

LANGUAGE: sh
CODE:
npm run build

----------------------------------------

TITLE: Basic ESLint Configuration Setup
DESCRIPTION: Basic configuration setup for ESLint in a Remix project, extending the Remix ESLint configuration.

LANGUAGE: javascript
CODE:
module.exports = {
  extends: "@remix-run/eslint-config",
};

----------------------------------------

TITLE: ESLint Configuration with Jest and Testing Library
DESCRIPTION: Extended ESLint configuration that includes support for Jest and Testing Library in addition to basic Remix rules.

LANGUAGE: javascript
CODE:
module.exports = {
  extends: [
    "@remix-run/eslint-config",
    "@remix-run/eslint-config/jest-testing-library",
  ],
};

----------------------------------------

TITLE: Running Remix Project in Production Mode
DESCRIPTION: Starts the Remix app in production mode after building. This command runs the optimized version of the application.

LANGUAGE: sh
CODE:
npm start

----------------------------------------

TITLE: Installing Remix using NPX
DESCRIPTION: Command to create a new Remix project using the create-remix utility. This will launch an interactive setup process to configure your new Remix application.

LANGUAGE: sh
CODE:
npx create-remix@latest

----------------------------------------

TITLE: Calling broadcastDevReady in Custom Server
DESCRIPTION: Example of calling broadcastDevReady to notify the dev server when a build is ready.

LANGUAGE: JavaScript
CODE:
import { broadcastDevReady } from "@remix-run/node";
const BUILD_DIR = path.join(process.cwd(), "build");

app.listen(3000, () => {
  const build = require(BUILD_DIR);
  console.log("Ready: http://localhost:" + port);
  if (process.env.NODE_ENV === "development") {
    broadcastDevReady(build);
  }
});

----------------------------------------

TITLE: Building Remix Project for Production
DESCRIPTION: Builds the Remix app for production deployment. This command creates optimized assets and server-side code.

LANGUAGE: sh
CODE:
npm run build

----------------------------------------

TITLE: TypeScript typed server function example
DESCRIPTION: Example showing how to type loader functions to enable type inference

LANGUAGE: typescript
CODE:
import type { LoaderArgs } from "@remix-run/[runtime]";

export async function loader(args: LoaderArgs) {
  return json(data);
}

----------------------------------------

TITLE: Updating Root Route with Links Function
DESCRIPTION: TypeScript code for updating the root route with a links function to handle stylesheets and other assets.

LANGUAGE: tsx
CODE:
import type { LinksFunction } from "@remix-run/node"; // or cloudflare/deno
import { Links } from "@remix-run/react";

import App from "./app";
import stylesheetUrl from "./styles.css";

export const links: LinksFunction = () => {
  // `links` returns an array of objects whose
  // properties map to the `<link />` component props
  return [
    { rel: "icon", href: "/favicon.ico" },
    { rel: "apple-touch-icon", href: "/logo192.png" },
    { rel: "manifest", href: "/manifest.json" },
    { rel: "stylesheet", href: stylesheetUrl },
  ];
};

export default function Root() {
  return (
    <html lang="en">
      <head>
        <meta charSet="utf-8" />
        <meta
          name="viewport"
          content="width=device-width, initial-scale=1"
        />
        <meta name="theme-color" content="#000000" />
        <meta
          name="description"
          content="Web site created using create-react-app"
        />
        <Links />
        <title>React App</title>
      </head>
      <body>
        <App />
      </body>
    </html>
  );
}

----------------------------------------

TITLE: Production Build Commands
DESCRIPTION: Commands for building and running the application in production mode

LANGUAGE: sh
CODE:
npm run build

LANGUAGE: sh
CODE:
npm start

----------------------------------------

TITLE: Creating New Playground Project in Remix
DESCRIPTION: Command to create a new project within the playground directory, which is ignored by .gitignore. This allows for easy experimentation with local Remix packages.

LANGUAGE: markdown
CODE:
```
pnpm playground:new <?name>
```

----------------------------------------

TITLE: Updating Package Scripts for Remix
DESCRIPTION: JSON configuration for updating package.json scripts to use Remix commands.

LANGUAGE: json
CODE:
{
  "scripts": {
    "build": "remix build",
    "dev": "remix dev",
    "start": "remix-serve build/index.js",
    "typecheck": "tsc"
  }
}

----------------------------------------

TITLE: Installing Remix Deno Template
DESCRIPTION: Command to create a new Remix project using the Deno template

LANGUAGE: sh
CODE:
npx create-remix@latest --template remix-run/remix/templates/classic-remix-compiler/deno

----------------------------------------

TITLE: Running Remix Development Server with Architect
DESCRIPTION: This command starts both the Architect server sandbox and the Remix development server for local development. It watches for file changes and rebuilds assets automatically.

LANGUAGE: sh
CODE:
$ npm run dev

----------------------------------------

TITLE: Creating Remix Projects with Official Templates
DESCRIPTION: Commands to create Remix projects using various official templates for different deployment environments and configurations.

LANGUAGE: shellscript
CODE:
npx create-remix@latest --template remix-run/remix/templates/cloudflare
npx create-remix@latest --template remix-run/remix/templates/cloudflare-workers
npx create-remix@latest --template remix-run/remix/templates/express
npx create-remix@latest --template remix-run/remix/templates/remix
npx create-remix@latest --template remix-run/remix/templates/remix-javascript

## SPA Mode
npx create-remix@latest --template remix-run/remix/templates/spa

## Classic Remix Compiler
npx create-remix@latest --template remix-run/remix/templates/classic-remix-compiler/arc
npx create-remix@latest --template remix-run/remix/templates/classic-remix-compiler/cloudflare-pages
npx create-remix@latest --template remix-run/remix/templates/classic-remix-compiler/cloudflare-workers
npx create-remix@latest --template remix-run/remix/templates/classic-remix-compiler/deno
npx create-remix@latest --template remix-run/remix/templates/classic-remix-compiler/express
npx create-remix@latest --template remix-run/remix/templates/classic-remix-compiler/fly
npx create-remix@latest --template remix-run/remix/templates/classic-remix-compiler/remix
npx create-remix@latest --template remix-run/remix/templates/classic-remix-compiler/remix-javascript

----------------------------------------

TITLE: Building and Running Production Build
DESCRIPTION: Commands to build the Remix application for production and start the production server.

LANGUAGE: shell
CODE:
npm run build
npm start

----------------------------------------

TITLE: Building Remix Project for Production
DESCRIPTION: This command builds the Remix application for production deployment. It should be run before deploying the application to AWS.

LANGUAGE: sh
CODE:
npm run build

----------------------------------------

TITLE: Creating a Remix Project from Community Examples
DESCRIPTION: Command to create a new Remix project using a community-driven example template.

LANGUAGE: shellscript
CODE:
npx create-remix@latest --template remix-run/examples/basic

----------------------------------------

TITLE: Deploying Remix App to Cloudflare Workers
DESCRIPTION: Command to deploy the Remix application to Cloudflare Workers. Requires a Cloudflare account and Workers subdomain setup.

LANGUAGE: sh
CODE:
npm run deploy

----------------------------------------

TITLE: Deno Deploy Configuration
DESCRIPTION: Example package.json configuration for Deno Deploy deployment script

LANGUAGE: json
CODE:
{
  "scripts": {
    "deploy": "deployctl deploy --project=<your deno deploy project> --include=.cache,build,public ./build/index.js"
  }
}

----------------------------------------

TITLE: Initializing Remix Project with Express Template
DESCRIPTION: Command to create a new Remix project using the Express server template via npx. This initializes a project with the necessary configuration for Express deployment.

LANGUAGE: shell
CODE:
npx create-remix@latest --template remix-run/remix/templates/express

----------------------------------------

TITLE: Building and Running Wrangler for Cloudflare Workers
DESCRIPTION: Commands to build the Remix project and start Wrangler for Cloudflare Workers deployment.

LANGUAGE: sh
CODE:
npm run build
npm start

----------------------------------------

TITLE: Updating Deno Deploy CLI
DESCRIPTION: Command to update the Deno Deploy CLI to the latest version

LANGUAGE: sh
CODE:
deployctl upgrade

----------------------------------------

TITLE: Basic Remix CLI Help Command
DESCRIPTION: Command to display all available Remix CLI commands and flags.

LANGUAGE: shellscript
CODE:
npx @remix-run/dev -h

----------------------------------------

TITLE: Initializing New Remix Project using NPX
DESCRIPTION: Command to create a new Remix project using the create-remix package via npx. This will launch an interactive CLI tool that guides you through project setup.

LANGUAGE: sh
CODE:
npx create-remix@latest

----------------------------------------

TITLE: Running Remix App in Production Mode
DESCRIPTION: This command starts the Remix app in production mode, using the optimized build created by the build command.

LANGUAGE: sh
CODE:
npm start

----------------------------------------

TITLE: Installing CSS Bundle Package for Remix
DESCRIPTION: Command to install the @remix-run/css-bundle package using npm.

LANGUAGE: shellscript
CODE:
npm install @remix-run/css-bundle

----------------------------------------

TITLE: Installing Vanilla Extract Package
DESCRIPTION: Command to install the core Vanilla Extract styling package as a development dependency

LANGUAGE: shellscript
CODE:
npm install -D @vanilla-extract/css

----------------------------------------

TITLE: Generating Cloudflare Binding Types
DESCRIPTION: Command to generate TypeScript types for Cloudflare bindings defined in wrangler.toml. This needs to be rerun after changes to wrangler.toml.

LANGUAGE: sh
CODE:
npm run typegen

----------------------------------------

TITLE: Initializing New Remix Project using CLI
DESCRIPTION: Command to create a new Remix project using npx. This will launch an interactive CLI tool that guides you through project setup and configuration options.

LANGUAGE: sh
CODE:
npx create-remix@latest

----------------------------------------

TITLE: Previewing Remix SPA Production Build
DESCRIPTION: Command to preview the production build of a Remix SPA locally using Vite.

LANGUAGE: shellscript
CODE:
npx vite preview

----------------------------------------

TITLE: Building Remix Project for Production
DESCRIPTION: Command to build the Remix project for production deployment.

LANGUAGE: sh
CODE:
npm run build

----------------------------------------

TITLE: Installing Remix using npx
DESCRIPTION: This command uses npx to create a new Remix project. It runs the latest version of the create-remix package to set up a new Remix application.

LANGUAGE: shellscript
CODE:
npx create-remix@latest

----------------------------------------

TITLE: Creating a Remix SPA Project
DESCRIPTION: Command to create a new Remix project using the SPA template.

LANGUAGE: shellscript
CODE:
npx create-remix@latest --template remix-run/remix/templates/spa

----------------------------------------

TITLE: Running Remix Development Server
DESCRIPTION: Command to start the Remix development server for local development and testing.

LANGUAGE: shellscript
CODE:
npm run dev

----------------------------------------

TITLE: Initializing New Remix Project using CLI
DESCRIPTION: Command to create a new Remix project using the npm create-remix package. This will launch an interactive CLI that guides you through project setup.

LANGUAGE: sh
CODE:
npx create-remix@latest

----------------------------------------

TITLE: Composing Multiple Upload Handlers in Remix
DESCRIPTION: Shows how to compose multiple upload handlers for different file types, combining standard file uploads and Cloudinary uploads based on form field names.

LANGUAGE: typescript
CODE:
import type { UploadHandler } from "@remix-run/node"; // or cloudflare/deno
import { unstable_createFileUploadHandler } from "@remix-run/node"; // or cloudflare/deno
import { createCloudinaryUploadHandler } from "some-handy-remix-util";

export const standardFileUploadHandler =
  unstable_createFileUploadHandler({
    directory: "public/calendar-events",
  });

export const cloudinaryUploadHandler =
  createCloudinaryUploadHandler({
    folder: "/my-site/avatars",
  });

export const fileUploadHandler: UploadHandler = (args) => {
  if (args.name === "calendarEvent") {
    return standardFileUploadHandler(args);
  } else if (args.name === "eventBanner") {
    return cloudinaryUploadHandler(args);
  }
  return undefined;
};

----------------------------------------

TITLE: Running Remix Development Server
DESCRIPTION: Starts the Remix application in development mode with hot reloading enabled for asset rebuilding on file changes.

LANGUAGE: sh
CODE:
npm run dev

----------------------------------------

TITLE: Creating a New Remix Project using NPX
DESCRIPTION: This command initializes a new Remix project using the latest version of create-remix. After running this command, follow the prompts in the terminal to set up your project.

LANGUAGE: sh
CODE:
npx create-remix@latest

----------------------------------------

TITLE: Defining Markdown Frontmatter for Discussion Topics
DESCRIPTION: This snippet defines the frontmatter for a markdown document, specifying the title as 'Discussion Topics' and setting the order to 2.

LANGUAGE: markdown
CODE:
---
title: Discussion Topics
order: 2
---

----------------------------------------

TITLE: Creating a New Remix Project using CLI
DESCRIPTION: This command initializes a new Remix project using the latest version of the create-remix package. It launches an interactive prompt to guide the user through project setup.

LANGUAGE: sh
CODE:
npx create-remix@latest

----------------------------------------

TITLE: Defining Markdown Frontmatter
DESCRIPTION: Sets up the frontmatter metadata for a documentation page about Components, with a title and order number for navigation.

LANGUAGE: markdown
CODE:
---
title: Components
order: 5
---

----------------------------------------

TITLE: Installing Deno Deploy CLI
DESCRIPTION: Command to install the Deno Deploy CLI tool (deployctl)

LANGUAGE: sh
CODE:
deno install --allow-read --allow-write --allow-env --allow-net --allow-run --no-check -r -f https://deno.land/x/deploy/deployctl.ts

----------------------------------------

TITLE: Navigation Type Definition in TypeScript
DESCRIPTION: Type definition showing the flattened navigation state structure that replaces the previous transition.submission property.

LANGUAGE: typescript
CODE:
{
  state: "idle" | "loading" | "submitting";
  location: Location;
  formMethod?: FormMethod;
  formAction?: string;
  formEncType?: FormEncType;
  formData?: FormData;
}

----------------------------------------

TITLE: Deploying to Deno Deploy
DESCRIPTION: Command to deploy the application to Deno Deploy

LANGUAGE: sh
CODE:
npm run deploy

----------------------------------------

TITLE: Building Remix App for Production
DESCRIPTION: This command builds the Remix app for production deployment. It creates optimized assets and prepares the application for a production environment.

LANGUAGE: sh
CODE:
npm run build

----------------------------------------

TITLE: Previewing Production Build
DESCRIPTION: Command to preview the production build locally using Vite preview

LANGUAGE: shellscript
CODE:
npm run preview

----------------------------------------

TITLE: Running Remix Development Server
DESCRIPTION: Command to start the Remix development server for local development and testing.

LANGUAGE: shellscript
CODE:
npm run dev

----------------------------------------

TITLE: Starting Remix Development Server
DESCRIPTION: Command to run the Remix development server for local development.

LANGUAGE: shellscript
CODE:
npm run dev

----------------------------------------

TITLE: Running Remix Development Server
DESCRIPTION: Starts the Remix application in development mode with hot reloading enabled for asset rebuilding on file changes.

LANGUAGE: sh
CODE:
npm run dev

----------------------------------------

TITLE: Route Exports Server-Side Example
DESCRIPTION: Demonstration of server-only route exports in Remix that are automatically excluded from client bundles.

LANGUAGE: javascript
CODE:
export async function loader() { /* server-only code */ }
export async function action() { /* server-only code */ }
export function headers() { /* server-only code */ }