TITLE: Implementing Dynamic Pull Endpoint in TypeScript for Replicache
DESCRIPTION: This code snippet implements a dynamic pull endpoint for Replicache. It handles pull requests, queries the database for changes since the last pull, and constructs a response containing updated data and last mutation IDs. The implementation follows the Global Version strategy.

LANGUAGE: typescript
CODE:
import {serverID, tx, type Transaction} from './db';
import type {PatchOperation, PullResponse} from 'replicache';
import type {Request, Response, NextFunction} from 'express';

export async function handlePull(
  req: Request,
  res: Response,
  next: NextFunction,
): Promise<void> {
  try {
    const resp = await pull(req, res);
    res.json(resp);
  } catch (e) {
    next(e);
  }
}

async function pull(req: Request, res: Response) {
  const pull = req.body;
  console.log(`Processing pull`, JSON.stringify(pull));
  const {clientGroupID} = pull;
  const fromVersion = pull.cookie ?? 0;
  const t0 = Date.now();

  try {
    // Read all data in a single transaction so it's consistent.
    await tx(async t => {
      // Get current version.
      const {version: currentVersion} = await t.one<{version: number}>(
        'select version from replicache_server where id = $1',
        serverID,
      );

      if (fromVersion > currentVersion) {
        throw new Error(
          `fromVersion ${fromVersion} is from the future - aborting. This can happen in development if the server restarts. In that case, clear appliation data in browser and refresh.`,
        );
      }

      // Get lmids for requesting client groups.
      const lastMutationIDChanges = await getLastMutationIDChanges(
        t,
        clientGroupID,
        fromVersion,
      );

      // Get changed domain objects since requested version.
      const changed = await t.manyOrNone<{
        id: string;
        sender: string;
        content: string;
        ord: number;
        version: number;
        deleted: boolean;
      }>(
        'select id, sender, content, ord, version, deleted from message where version > $1',
        fromVersion,
      );

      // Build and return response.
      const patch: PatchOperation[] = [];
      for (const row of changed) {
        const {id, sender, content, ord, version: rowVersion, deleted} = row;
        if (deleted) {
          if (rowVersion > fromVersion) {
            patch.push({
              op: 'del',
              key: `message/${id}`,
            });
          }
        } else {
          patch.push({
            op: 'put',
            key: `message/${id}`,
            value: {
              from: sender,
              content,
              order: ord,
            },
          });
        }
      }

      const body: PullResponse = {
        lastMutationIDChanges: lastMutationIDChanges ?? {},
        cookie: currentVersion,
        patch,
      };
      res.json(body);
      res.end();
    });
  } catch (e) {
    console.error(e);
    res.status(500).send(e);
  } finally {
    console.log('Processed pull in', Date.now() - t0);
  }
}

async function getLastMutationIDChanges(
  t: Transaction,
  clientGroupID: string,
  fromVersion: number,
) {
  // eslint-disable-next-line @typescript-eslint/naming-convention
  const rows = await t.manyOrNone<{id: string; last_mutation_id: number}>(
    `select id, last_mutation_id
    from replicache_client
    where client_group_id = $1 and version > $2`,
    [clientGroupID, fromVersion],
  );
  return Object.fromEntries(rows.map(r => [r.id, r.last_mutation_id]));
}

----------------------------------------

TITLE: Implementing Push Handler in TypeScript for Replicache
DESCRIPTION: This code snippet implements the push handler for Replicache. It processes incoming mutations, updates the server state, and handles errors. The handler implements the Global Version strategy, including updating client records and domain data objects.

LANGUAGE: typescript
CODE:
import {serverID, tx, type Transaction} from './db';
import type {MessageWithID} from 'shared';
import type {MutationV1, PushRequestV1} from 'replicache';
import type {Request, Response, NextFunction} from 'express';

export async function handlePush(
  req: Request,
  res: Response,
  next: NextFunction,
): Promise<void> {
  try {
    await push(req, res);
  } catch (e) {
    next(e);
  }
}

async function push(req: Request, res: Response) {
  const push: PushRequestV1 = req.body;
  console.log('Processing push', JSON.stringify(push));

  const t0 = Date.now();
  try {
    // Iterate each mutation in the push.
    for (const mutation of push.mutations) {
      const t1 = Date.now();

      try {
        await tx(t => processMutation(t, push.clientGroupID, mutation));
      } catch (e) {
        console.error('Caught error from mutation', mutation, e);

        // Handle errors inside mutations by skipping and moving on. This is
        // convenient in development but you may want to reconsider as your app
        // gets close to production:
        // https://doc.replicache.dev/reference/server-push#error-handling
        await tx(t =>
          processMutation(t, push.clientGroupID, mutation, e as string),
        );
      }

      console.log('Processed mutation in', Date.now() - t1);
    }

    res.send('{}');

    await sendPoke();
  } catch (e) {
    console.error(e);
    res.status(500).send(e);
  } finally {
    console.log('Processed push in', Date.now() - t0);
  }
}

async function processMutation(
  t: Transaction,
  clientGroupID: string,
  mutation: MutationV1,
  error?: string | undefined,
) {
  const {clientID} = mutation;

  // Get the previous version and calculate the next one.
  const {version: prevVersion} = await t.one(
    'select version from replicache_server where id = $1 for update',
    serverID,
  );
  const nextVersion = prevVersion + 1;

  const lastMutationID = await getLastMutationID(t, clientID);
  const nextMutationID = lastMutationID + 1;

  console.log('nextVersion', nextVersion, 'nextMutationID', nextMutationID);

  // It's common due to connectivity issues for clients to send a
  // mutation which has already been processed. Skip these.
  if (mutation.id < nextMutationID) {
    console.log(
      `Mutation ${mutation.id} has already been processed - skipping`,
    );
    return;
  }

  // If the Replicache client is working correctly, this can never
  // happen. If it does there is nothing to do but return an error to
  // client and report a bug to Replicache.
  if (mutation.id > nextMutationID) {
    throw new Error(
      `Mutation ${mutation.id} is from the future - aborting. This can happen in development if the server restarts. In that case, clear appliation data in browser and refresh.`,
    );
  }

  if (error === undefined) {
    console.log('Processing mutation:', JSON.stringify(mutation));

    // For each possible mutation, run the server-side logic to apply the
    // mutation.
    switch (mutation.name) {
      case 'createMessage':
        await createMessage(t, mutation.args as MessageWithID, nextVersion);
        break;
      default:
        throw new Error(`Unknown mutation: ${mutation.name}`);
    }
  } else {
    // TODO: You can store state here in the database to return to clients to
    // provide additional info about errors.
    console.log(
      'Handling error from mutation',
      JSON.stringify(mutation),
      error,
    );
  }

  console.log('setting', clientID, 'last_mutation_id to', nextMutationID);
  // Update lastMutationID for requesting client.
  await setLastMutationID(
    t,
    clientID,
    clientGroupID,
    nextMutationID,
    nextVersion,
  );

  // Update global version.
  await t.none('update replicache_server set version = $1 where id = $2', [
    nextVersion,
    serverID,
  ]);
}

export async function getLastMutationID(t: Transaction, clientID: string) {
  const clientRow = await t.oneOrNone(
    'select last_mutation_id from replicache_client where id = $1',
    clientID,
  );
  if (!clientRow) {
    return 0;
  }
  return parseInt(clientRow.last_mutation_id);
}

async function setLastMutationID(
  t: Transaction,
  clientID: string,
  clientGroupID: string,
  mutationID: number,
  version: number,
) {
  const result = await t.result(
    `update replicache_client set
      client_group_id = $2,
      last_mutation_id = $3,
      version = $4
    where id = $1`,
    [clientID, clientGroupID, mutationID, version],
  );
  if (result.rowCount === 0) {
    await t.none(
      `insert into replicache_client (
        id,
        client_group_id,
        last_mutation_id,
        version
      ) values ($1, $2, $3, $4)`,
      [clientID, clientGroupID, mutationID, version],
    );
  }
}

async function createMessage(
  t: Transaction,
  {id, from, content, order}: MessageWithID,
  version: number,
) {
  await t.none(
    `insert into message (
    id, sender, content, ord, deleted, version) values
    ($1, $2, $3, $4, false, $5)`,
    [id, from, content, order, version],
  );
}

async function sendPoke() {
  // TODO
}

----------------------------------------

TITLE: Initializing PostgreSQL Database Schema for Replicache
DESCRIPTION: Creates the initial database schema for a Replicache backend using PostgreSQL. Implements tables for global version tracking (replicache_server), message storage with soft delete capability (message), and client mutation tracking (replicache_client). Each table includes Replicache-specific attributes for version control and synchronization.

LANGUAGE: typescript
CODE:
async function initDB() {
  console.log('initializing database...');
  const db = newDb().adapters.createPgPromise();
  await tx(async t => {
    // A single global version number for the entire database.
    await t.none(
      `create table replicache_server (id integer primary key not null, version integer)`,
    );
    await t.none(
      `insert into replicache_server (id, version) values ($1, 1)`,
      serverID,
    );

    // Stores chat messages.
    await t.none(`create table message (
        id text primary key not null,
        sender varchar(255) not null,
        content text not null,
        ord integer not null,
        deleted boolean not null,
        version integer not null)`);

    // Stores last mutationID processed for each Replicache client.
    await t.none(`create table replicache_client (
        id varchar(36) primary key not null,
        client_group_id varchar(36) not null,
        last_mutation_id integer not null,
        version integer not null)`);

    // TODO: indexes
  }, db);
  return db;
}

----------------------------------------

TITLE: Implementing React Chat UI with Replicache
DESCRIPTION: Complete React component implementation using Replicache for data management, including subscription setup, UI rendering, and form handling. Demonstrates integration with Replicache's useSubscribe hook and proper React lifecycle management.

LANGUAGE: tsx
CODE:
/* eslint-disable @typescript-eslint/no-unused-vars */
import React, {useEffect, useRef, useState} from 'react';
import ReactDOM from 'react-dom/client';
import {Replicache, TEST_LICENSE_KEY, WriteTransaction} from 'replicache';
import {Message, MessageWithID} from 'shared';
import {useSubscribe} from 'replicache-react';
import Pusher from 'pusher-js';
import {nanoid} from 'nanoid';

async function init() {
  const licenseKey =
    import.meta.env.VITE_REPLICACHE_LICENSE_KEY || TEST_LICENSE_KEY;
  if (!licenseKey) {
    throw new Error('Missing VITE_REPLICACHE_LICENSE_KEY');
  }

  function Root() {
    const [r, setR] = useState<Replicache<any> | null>(null);

    useEffect(() => {
      console.log('updating replicache');
      const r = new Replicache({
        name: 'chat-user-id',
        licenseKey,
        pushURL: `/api/replicache/push`,
        pullURL: `/api/replicache/pull`,
        logLevel: 'debug',
      });
      setR(r);
      listen(r);
      return () => {
        void r.close();
      };
    }, []);

    const messages = useSubscribe(
      r,
      async tx => {
        const list = await tx
          .scan<Message>({prefix: 'message/'})
          .entries()
          .toArray();
        list.sort(([, {order: a}], [, {order: b}]) => a - b);
        return list;
      },
      {default: []},
    );

    const usernameRef = useRef<HTMLInputElement>(null);
    const contentRef = useRef<HTMLInputElement>(null);

    const onSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
      e.preventDefault();
      // TODO: Create Message
    };

    return (
      <div>
        <form onSubmit={onSubmit}>
          <input ref={usernameRef} required /> says:
          <input ref={contentRef} required /> <input type="submit" />
        </form>
        {messages.map(([k, v]) => (
          <div key={k}>
            <b>{v.from}: </b>
            {v.content}
          </div>
        ))}
      </div>
    );
  }

  ReactDOM.createRoot(document.getElementById('root') as HTMLElement).render(
    <React.StrictMode>
      <Root />
    </React.StrictMode>,
  );
}

function listen(rep: Replicache) {
  // TODO: Listen for changes on server
}

await init();

----------------------------------------

TITLE: Initializing In-Memory Postgres Database with pg-mem for Replicache in TypeScript
DESCRIPTION: This code snippet sets up an in-memory Postgres database using pg-mem, initializes it, and provides functions for database access and transaction handling with snapshot isolation. It's designed for local development with Replicache and can be adapted for remote Postgres implementations.

LANGUAGE: typescript
CODE:
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-nocheck
import {newDb} from 'pg-mem';
import pgp, {IDatabase, ITask} from 'pg-promise';

const {isolationLevel} = pgp.txMode;

export const serverID = 1;

async function initDB() {
  console.log('initializing database...');
  const db = newDb().adapters.createPgPromise();
  return db;
}

function getDB() {
  // Cache the database in the Node global so that it survives HMR.
  if (!global.__db) {
    global.__db = initDB();
  }
  // eslint-disable-next-line @typescript-eslint/ban-types
  return global.__db as IDatabase<{}>;
}

// eslint-disable-next-line @typescript-eslint/ban-types
export type Transaction = ITask<{}>;
type TransactionCallback<R> = (t: Transaction) => Promise<R>;

// In Postgres, snapshot isolation is known as "repeatable read".
export async function tx<R>(f: TransactionCallback<R>, dbp = getDB()) {
  const db = await dbp;
  return await db.tx(
    {
      mode: new pgp.txMode.TransactionMode({
        tiLevel: isolationLevel.repeatableRead,
      }),
    },
    f,
  );
}

----------------------------------------

TITLE: Initializing Replicache Client in TypeScript
DESCRIPTION: Creates a new Replicache client instance with a unique name for each user. The client ID is logged to the console.

LANGUAGE: typescript
CODE:
import {Replicache} from "replicache";

const rep = new Replicache({
  name: userID,
  ...
});

console.log(rep.clientID);

----------------------------------------

TITLE: Implementing Subscriptions with React Hooks in TypeScript
DESCRIPTION: Demonstrates how to use the useSubscribe hook to create a subscription that renders a list of todos from Replicache.

LANGUAGE: tsx
CODE:
const todos = useSubscribe(rep, async tx => {
  return await tx.scan({prefix: 'todo/'}).toArray();
});
return (
  <ul>
    {todos.map(todo => (
      <li key={todo.id}>{todo.text}</li>
    ))}
  </ul>
);

----------------------------------------

TITLE: Defining Mutators for Replicache in TypeScript
DESCRIPTION: Shows how to define and register mutators for creating and updating todos in Replicache. Includes examples of createTodo and markTodoComplete mutators.

LANGUAGE: typescript
CODE:
const rep = new Replicache({
  ...
  mutators: {
    createTodo,
    markTodoComplete,
  },
});

async function createTodo(tx: WriteTransaction, todo: Todo) {
  await tx.set(`/todo/${todo.id}`, todo);
}

async function markTodoComplete(tx: WriteTransaction,
    {id, complete}: {id: string, complete: boolean}) {
  const key = `/todo/${id}`;
  const todo = await tx.get(key);
  if (!todo) {
    return;
  }
  todo.complete = complete;
  await tx.set(key, todo);
}

----------------------------------------

TITLE: Invoking Mutators in Replicache with TypeScript
DESCRIPTION: Demonstrates how to call mutators to change the Client View in Replicache, creating a new todo and marking it as complete.

LANGUAGE: typescript
CODE:
await rep.mutate.createTodo({id: nanoid(), text: "take out the trash"});
...
await rep.mutate.markTodoComplete({id: "t1", complete: true});

----------------------------------------

TITLE: Registering a Speculative Message Creation Mutator in JavaScript
DESCRIPTION: This snippet shows how to register a mutator for speculatively creating a message in Replicache. It defines the createMessage function that takes a transaction and message details as parameters, then sets the message in the local map.

LANGUAGE: javascript
CODE:
const r = new Replicache({
  name: 'chat-user-id',
  licenseKey,
  mutators: {
    async createMessage(
      tx: WriteTransaction,
      {id, from, content, order}: MessageWithID,
    ) {
      await tx.set(`message/${id}`, {
        from,
        content,
        order,
      });
    },
  },
  pushURL: `/api/replicache/push`,
  pullURL: `/api/replicache/pull`,
  logLevel: 'debug',
});

----------------------------------------

TITLE: Invoking the Message Creation Mutator on Form Submit in JavaScript
DESCRIPTION: This snippet demonstrates how to invoke the createMessage mutator when a user submits a message. It calculates the order of the new message, retrieves user input, and calls the mutator with a generated unique ID and message details.

LANGUAGE: javascript
CODE:
const onSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
  e.preventDefault();
  let last: Message | null = null;
  if (messages.length) {
    const lastMessageTuple = messages[messages.length - 1];
    last = lastMessageTuple[1];
  }
  const order = (last?.order ?? 0) + 1;
  const username = usernameRef.current?.value ?? '';
  const content = contentRef.current?.value ?? '';

  await r?.mutate.createMessage({
    id: nanoid(),
    from: username,
    content,
    order,
  });

  if (contentRef.current) {
    contentRef.current.value = '';
  }
};

----------------------------------------

TITLE: TypeScript Definition of PullRequest
DESCRIPTION: Defines the structure of the PullRequest object, which is sent as the JSON-encoded body of the HTTP POST request for a pull operation.

LANGUAGE: typescript
CODE:
type PullRequest = {
  pullVersion: 1;
  clientGroupID: string;
  cookie: JSONValue;
  profileID: string;
  schemaVersion: string;
};

----------------------------------------

TITLE: Defining Replicache Schema Types in TypeScript
DESCRIPTION: Defines TypeScript types for ReplicacheSpace, ReplicacheClientGroup, ReplicacheClient, and Todo entities used in the Global Version Strategy. These types include fields for version tracking and soft deletion.

LANGUAGE: typescript
CODE:
// Tracks the current global version of the database. There is only one of
// these system-wide.
type ReplicacheSpace = {
  version: number;
};

type ReplicacheClientGroup = {
  // Same as Reset Strategy.
  id: string;
  userID: any;
};

type ReplicacheClient = {
  // Same as Reset Strategy.
  id: string;
  clientGroupID: string;
  lastMutationID: number;

  // The global version this client was last modified at.
  lastModifiedVersion: number;
};

// Each of your domain entities will have two extra fields.
type Todo = {
  // ... fields needed for your application (id, title, complete, etc)

  // The global version this entity was last modified at.
  lastModifiedVersion: number;

  // "Soft delete" for marking whether this entity has been deleted.
  deleted: boolean;
};

----------------------------------------

TITLE: Defining Client View Record Type in TypeScript
DESCRIPTION: Defines the structure of a Client View Record (CVR) using TypeScript. A CVR represents a snapshot of a Client View at a particular moment in time, including client mutation IDs and entity versions.

LANGUAGE: typescript
CODE:
type CVR = {
  id: string;
  // Map of clientID->lastMutationID pairs, one for each client in the
  // client group.
  lastMutationIDs: Record<string, number>;
  // Map of key->version pairs, one for each entity in the client view.
  entities: Record<string, number>;
};

----------------------------------------

TITLE: Defining Replicache Schema for Per-Space Version Strategy in TypeScript
DESCRIPTION: TypeScript definitions for ReplicacheSpace, ReplicacheClientGroup, ReplicacheClient, and Todo entities used in the Per-Space Version Strategy. This schema extends the Global Version Strategy by adding spaceID fields.

LANGUAGE: typescript
CODE:
type ReplicacheSpace = {
  id: string;

  // Same as Global Version Strategy.
  version: number;
};

type ReplicacheClientGroup = {
  // Same as Global Version Strategy.
  id: string;
  userID: any;

  spaceID: string;
};

type ReplicacheClient = {
  // Same as Global Version Strategy.
  id: string;
  clientGroupID: string;
  lastMutationID: number;
  lastModifiedVersion: number;
};

// Each of your domain entities will have three additional fields.
type Todo = {
  // ... fields needed for your application (id, title, complete, etc)

  // Same as Global Version Strategy.
  lastModifiedVersion: number;
  deleted: boolean;

  spaceID: string;
};

----------------------------------------

TITLE: TypeScript Definition of PullResponse
DESCRIPTION: Defines the structure of the PullResponse, which is the JSON object returned in the HTTP response body for a successful pull operation.

LANGUAGE: typescript
CODE:
export type PullResponse =
  | PullResponseOK
  | ClientStateNotFoundResponse
  | VersionNotSupportedResponse;

export type PullResponseOK = {
  cookie: Cookie;
  lastMutationIDChanges: Record<ClientID, number>;
  patch: PatchOperation[];
};

export type Cookie =
  | null
  | string
  | number
  | (ReadonlyJSONValue & {readonly order: number | string});

export type ClientStateNotFoundResponse = {
  error: 'ClientStateNotFound';
};

export type VersionNotSupportedResponse = {
  error: 'VersionNotSupported';
  versionType?: 'pull' | 'push' | 'schema' | undefined;
};

----------------------------------------

TITLE: TypeScript Interface for Replicache Push Request
DESCRIPTION: Defines the structure of the PushRequest and Mutation types used in the HTTP request body. Includes fields like pushVersion, clientGroupID, mutations, profileID, and schemaVersion.

LANGUAGE: typescript
CODE:
type PushRequest = {
  pushVersion: 1;
  clientGroupID: string;
  mutations: Mutation[];
  profileID: string;
  schemaVersion: string;
};

type Mutation = {
  clientID: string;
  id: number;
  name: string;
  args: ReadonlyJSONValue;
  timestamp: number;
};

----------------------------------------

TITLE: Complete Undo Implementation in React and TypeScript with Replicache
DESCRIPTION: A full example of implementing undo functionality in a React component using Replicache, UndoManager, and react-hotkeys. It includes handling new items, undo/redo operations, and keyboard shortcuts.

LANGUAGE: tsx
CODE:
import { Replicache } from "replicache";
import { useSubscribe } from "replicache-react";
...
import { UndoManager } from "@rocicorp/undo";
import { HotKeys } from "react-hotkeys";

// Replicache and UndoManager are initialized outside of the initial component render.
// undoManager = new UndoManager()
const App = ({ rep }: { rep: Replicache<M>; undoManager: UndoManager }) => {
  const todos = useSubscribe(rep, listTodos, [], [rep]);

  // new item with undo
  const handleNewItem = (text: string) => {
      const id = nanoid();
      undoManager.add({
        execute: () => {
          rep.mutate.putTodo({
            id,
            text: text,
            sort: todos.length > 0 ? todos[todos.length - 1].sort + 1 : 0,
            completed: false,
          });
        };
        undo: () => rep.mutate.deleteTodos([id]),
      });
    };
  };

  const handlers = {
    undo: () => undoManager.undo(),
    redo: () => undoManager.redo(),
  };

  const keyMap = {
    undo: ["ctrl+z", "command+z"],
    redo: ["ctrl+y", "command+shift+z", "ctrl+shift+z"],
  };

  return (
    <Hotkeys
      {...{
        keyMap,
        handlers,
      }}
    >
        <Header onNewItem={handleNewItem} />
        <MainSection todos={todos} />
    </Hotkeys>
  );
};

----------------------------------------

TITLE: Defining Replicache Client Group and Client Types in TypeScript
DESCRIPTION: Defines the schema for ReplicacheClientGroup and ReplicacheClient types, which are necessary for implementing the Reset Strategy in Replicache.

LANGUAGE: typescript
CODE:
// A group of related ReplicacheClients. Typically there is one per browser
// profile.
type ReplicacheClientGroup = {
  // Globally unique ID, generated by Replicache.
  id: string;

  // Optional, but required if the application is authenticated. The userID
  // that created this ReplicacheClientGroup.
  userID: any;
};

// An instance of the Replicache JS class that has ever synced with the server.
type ReplicacheClient = {
  // Globally unique ID, generated by Replicache.
  id: string;

  // The ClientGroup this client is part of.
  clientGroupID: string;

  // Last mutation the server has processed from this client.
  lastMutationID: number;
};

----------------------------------------

TITLE: Implementing Client-side Poke Listener
DESCRIPTION: Client-side implementation of the listen function to handle poke events and trigger Replicache pulls

LANGUAGE: typescript
CODE:
function listen(rep: Replicache) {
  console.log('listening');
  // Listen for pokes, and pull whenever we get one.
  Pusher.logToConsole = true;
  if (
    !import.meta.env.VITE_PUBLIC_REPLICHAT_PUSHER_KEY ||
    !import.meta.env.VITE_PUBLIC_REPLICHAT_PUSHER_CLUSTER
  ) {
    throw new Error('Missing PUSHER_KEY or PUSHER_CLUSTER in env');
  }
  const pusher = new Pusher(import.meta.env.VITE_PUBLIC_REPLICHAT_PUSHER_KEY, {
    cluster: import.meta.env.VITE_PUBLIC_REPLICHAT_PUSHER_CLUSTER,
  });
  const channel = pusher.subscribe('default');
  channel.bind('poke', async () => {
    console.log('got poked');
    await rep.pull();
  });
}

----------------------------------------

TITLE: Implementing Server-side Poke with Pusher
DESCRIPTION: Server-side implementation of the sendPoke function using Pusher to trigger real-time updates

LANGUAGE: typescript
CODE:
import Pusher from 'pusher';
//...
async function sendPoke() {
  if (
    !process.env.REPLICHAT_PUSHER_APP_ID ||
    !process.env.REPLICHAT_PUSHER_KEY ||
    !process.env.REPLICHAT_PUSHER_SECRET ||
    !process.env.REPLICHAT_PUSHER_CLUSTER
  ) {
    throw new Error('Missing Pusher environment variables');
  }
  const pusher = new Pusher({
    appId: process.env.REPLICHAT_PUSHER_APP_ID,
    key: process.env.REPLICHAT_PUSHER_KEY,
    secret: process.env.REPLICHAT_PUSHER_SECRET,
    cluster: process.env.REPLICHAT_PUSHER_CLUSTER,
    useTLS: true,
  });
  const t0 = Date.now();
  await pusher.trigger('default', 'poke', {});
  console.log('Sent poke in', Date.now() - t0);
}

----------------------------------------

TITLE: Setting Pusher Environment Variables
DESCRIPTION: Environment variable configuration required for Pusher integration with Replicache

LANGUAGE: bash
CODE:
export REPLICHAT_PUSHER_APP_ID=<app id>
export REPLICHAT_PUSHER_KEY=<key>
export REPLICHAT_PUSHER_SECRET=<secret>
export REPLICHAT_PUSHER_CLUSTER=<cluster>
export VITE_PUBLIC_REPLICHAT_PUSHER_KEY=<key>
export VITE_PUBLIC_REPLICHAT_PUSHER_CLUSTER=<cluster>

----------------------------------------

TITLE: Implementing Replicache Pull Handler in TypeScript
DESCRIPTION: This TypeScript code defines an Express.js handler function for the Replicache pull endpoint. It serves a static Client View as a patch, demonstrating how to structure the response with clear and put operations.

LANGUAGE: typescript
CODE:
import type {Request, Response, NextFunction} from 'express';

export async function handlePull(
  _req: Request,
  res: Response,
  next: NextFunction,
): Promise<void> {
  try {
    res.json({
      // We will discuss these two fields in later steps.
      lastMutationIDChanges: {},
      cookie: 42,
      patch: [
        {op: 'clear'},
        {
          op: 'put',
          key: 'message/qpdgkvpb9ao',
          value: {
            from: 'Jane',
            content: "Hey, what's for lunch?",
            order: 1,
          },
        },
        {
          op: 'put',
          key: 'message/5ahljadc408',
          value: {
            from: 'Fred',
            content: 'tacos?',
            order: 2,
          },
        },
      ],
    });
  } catch (e) {
    next(e);
  }
}

----------------------------------------

TITLE: Defining Client View Schema in JavaScript
DESCRIPTION: This snippet demonstrates a simple Client View schema for a chat application, using a map of message objects with properties for sender, order, and content.

LANGUAGE: javascript
CODE:
{
  "messages/l2WXAsRlA2Rg47sfGMdAK": {
    "from": "Jane",
    "order": 1,
    "content": "Hey, what's up for lunch?"
  },
  "messages/g0Y8yLKobt0BpXwUrVJCK": {
    "from": "Fred",
    "order": 2,
    "content": "Taaaacos"
  }
}

----------------------------------------

TITLE: Creating Default ReplicacheClient JSON Object
DESCRIPTION: Demonstrates the creation of a default ReplicacheClient JSON object when it doesn't exist in the database during the push operation.

LANGUAGE: json
CODE:
{
  "id": mutation.clientID,
  "clientGroupID": body.clientGroupID,
  "lastMutationID": 0
}

----------------------------------------

TITLE: Updating ReplicacheClient in JSON
DESCRIPTION: Shows the JSON structure for updating the ReplicacheClient entity with new mutation ID and version information during the push operation in the Global Version Strategy.

LANGUAGE: json
CODE:
{
  "id": "mutation.clientID",
  "clientGroupID": "body.clientGroupID",
  "lastMutationID": "nextMutationID",
  "lastModifiedVersion": "nextVersion"
}

----------------------------------------

TITLE: Initializing Replicache with License Key
DESCRIPTION: This JavaScript code demonstrates how to initialize a new Replicache instance using the constructor, passing the license key as a parameter in the configuration object.

LANGUAGE: javascript
CODE:
new Replicache({
	licenseKey: "l123d3baa14984beca21bc42aee593064",
	...
});

----------------------------------------

TITLE: Base64 Encoding Implementation in Replicache
DESCRIPTION: Demonstrates basic binary data handling using base64 encoding with Replicache. Includes user data management with profile pictures stored as base64 strings.

LANGUAGE: typescript
CODE:
// npm install base64-arraybuffer
import * as base64 from 'base64-arraybuffer';

type User = {
  id: string;
  name: string;
  picture: Uint8Array;
};

type RepUser = {
  id: string;
  name: string;
  // Note how Replicache needs to use a string here!
  picture: string;
};

const rep = new Replicache({
  name: 'user-id',
  licenseKey: '...',
  mutators: {
    async setUserData(tx: WriteTransaction, user: RepUser) {
      await tx.set(`user/${user.id}`, user);
    },
  },
});

async function setUserData(rep: Replicache, user: User) {
  const {id, name, picture} = user;
  const repUser = {
    id,
    name,
    picture: base64.encode(picture.buffer),
  };
  await rep.mutate.setUserData(repUser);
}

async function getUserData(rep: Replicache, id: string): Promise<User> {
  const repUser = await rep.query(tx => tx.get(`user/${id}`));
  const {id, name, picture} = repUser;
  return {
    id,
    name,
    picture: new Uint8Array(base64.decode(picture)),
  };
}

----------------------------------------

TITLE: Optimized Base64 Storage with Separate Keys
DESCRIPTION: Shows how to optimize binary data storage by keeping large binary data in separate keys to prevent unnecessary data transfer when unrelated fields change.

LANGUAGE: typescript
CODE:
const rep = new Replicache({
  name: 'user-id',
  mutators: {
    async setUserData(tx: WriteTransaction, user: RepUser) {
      const {id, name, picture} = user;
      await tx.set(`user/${id}`, {id, name});
      await tx.set(`user/${id}/picture`, picture);
    },
  },
});

async function getUserData(rep: Replicache, id: string): Promise<User> {
  const {name, picture} = await rep.query(async tx => {
    const {name} = await tx.get(`user/${id}`);
    const picture = await tx.get(`user/${id}/picture`);
    return {name, picture};
  });
  return {
    id,
    name,
    picture: new Uint8Array(base64.decode(picture)),
  };
}

----------------------------------------

TITLE: Embedding Interactive Replicache Demo
DESCRIPTION: HTML iframe code to embed a CodeSandbox demo showing Replicache sync functionality. The demo allows testing sync between multiple browser tabs.

LANGUAGE: html
CODE:
<iframe src="https://codesandbox.io/embed/replicache-sync-13-vj6jpn?autoresize=1&fontsize=12&hidenavigation=0&theme=light&codemirror=1&view=split" style={{"width":"100%","height":"350px", "border":"1px solid rgb(222,221,221)", "overflow":"hidden"}} title="constructing-replicache" allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking" sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"></iframe>

----------------------------------------

TITLE: Content-Addressed Storage Implementation
DESCRIPTION: Implements content-addressed storage for immutable binary data using SHA-256 hashing. This approach is ideal for data that is frequently shared between different parts of the system.

LANGUAGE: typescript
CODE:
type RepUser = {
  id: string;
  name: string;
  picture: string;
  pictureHash: string;
};

async function computeHash(data: Uint8Array): Promise<string> {
  const buf = await crypto.subtle.digest('SHA-256', data);
  return Array.from(new Uint8Array(buf), b =>
    b.toString(16).padStart(2, '0'),
  ).join('');
}

const rep = new Replicache({
  name: 'user-id',
  licenseKey: '...',
  mutators: {
    async setUserData(tx: WriteTransaction, user: RepUser) {
      const {id, name, picture, pictureHash} = user;
      await tx.set(`user/${id}`, {id, name, pictureHash});
      await tx.set(`blob/${pictureHash}`, picture);
    },
  },
});

async function setUserData(rep: Replicache, user: User) {
  const {id, name, picture} = user;
  const pictureHash = await computeHash(picture);
  const repUser = {
    id,
    name,
    picture: base64.encode(picture.buffer),
    pictureHash,
  };
  await rep.mutate.setUserData(repUser);
}

----------------------------------------

TITLE: PostgreSQL Table Schema Reference
DESCRIPTION: Reference to PostgreSQL table schema with key-value structure using text key and JSON value columns, commonly used in Replicache sample applications.

LANGUAGE: sql
CODE:
CREATE TABLE entry (
  key text PRIMARY KEY,
  value json
);

----------------------------------------

TITLE: Initializing Default ReplicacheClient in JSON
DESCRIPTION: Defines a default JSON structure for a ReplicacheClient when it doesn't exist in the database. This is used during the push operation in the Global Version Strategy.

LANGUAGE: json
CODE:
{
  "id": "mutation.clientID",
  "clientGroupID": "body.clientGroupID",
  "lastMutationID": 0,
  "lastModifiedVersion": "lastModifiedVersion"
}

----------------------------------------

TITLE: Updating ReplicacheSpace in JSON
DESCRIPTION: Shows the JSON structure for updating the ReplicacheSpace entity with a new version during the push operation in the Global Version Strategy.

LANGUAGE: json
CODE:
{
  "version": "nextVersion"
}

----------------------------------------

TITLE: Updating ReplicacheClientGroup in JSON
DESCRIPTION: Demonstrates the JSON structure for updating the ReplicacheClientGroup entity during the push operation in the Global Version Strategy.

LANGUAGE: json
CODE:
{
  "id": "body.clientGroupID",
  "userID": "userID"
}

----------------------------------------

TITLE: Creating Default ReplicacheClientGroup JSON Object
DESCRIPTION: Shows how to create a default ReplicacheClientGroup JSON object when it doesn't exist in the database during the push operation.

LANGUAGE: json
CODE:
{
  "id": body.clientGroupID,
  "userID": userID
}

----------------------------------------

TITLE: Updating ReplicacheClientGroup JSON Object
DESCRIPTION: Shows how to update the ReplicacheClientGroup JSON object during the push operation.

LANGUAGE: json
CODE:
{
  "id": body.clientGroupID,
  "userID": userID
}

----------------------------------------

TITLE: Updating ReplicacheClient JSON Object
DESCRIPTION: Demonstrates how to update the ReplicacheClient JSON object with the new lastMutationID during the push operation.

LANGUAGE: json
CODE:
{
  "id": mutation.clientID,
  "clientGroupID": body.clientGroupID,
  "lastMutationID": nextMutationID
}

----------------------------------------

TITLE: Basic Usage Example
DESCRIPTION: Minimal configuration example for running the load generator with only required parameters

LANGUAGE: bash
CODE:
docker run -e ZERO_UPSTREAM_DB="postgresql://user:password@host.docker.internal:6434/postgres" \
  -e ZERO_PERTURB_TABLE="issue" \
  -e ZERO_PERTURB_KEY="id" \
  -e ZERO_PERTURB_BOOLS="open" \
  load-generator:latest

----------------------------------------

TITLE: Creating Default ReplicacheClientGroup JSON Object for Pull
DESCRIPTION: Shows how to create a default ReplicacheClientGroup JSON object when it doesn't exist in the database during the pull operation.

LANGUAGE: json
CODE:
{
  "id": body.clientGroupID,
  "userID": userID
}

----------------------------------------

TITLE: Configuring Replicache Pull URL in JavaScript
DESCRIPTION: Demonstrates how to set the pullURL option when creating a new Replicache instance. This URL specifies where the client should send pull requests.

LANGUAGE: javascript
CODE:
const rep = new Replicache({
  // ...
  pullURL: '/replicache-pull',
});

----------------------------------------

TITLE: HTTP POST Request for Replicache Pull
DESCRIPTION: Shows the HTTP method and path used for Replicache pull requests. Replicache always uses POST for pull requests.

LANGUAGE: http
CODE:
POST /replicache-pull HTTP/2

----------------------------------------

TITLE: HTTP Headers for Replicache Pull Request
DESCRIPTION: Illustrates the required HTTP headers sent with Replicache pull requests, including Content-type, Authorization, and a custom X-Replicache-RequestID header.

LANGUAGE: http
CODE:
Content-type: application/json
Authorization: <auth>
X-Replicache-RequestID: <request-id>

----------------------------------------

TITLE: TypeScript Definition of PatchOperation
DESCRIPTION: Defines the structure of PatchOperation, which represents the different types of operations that can be included in the patch array of a PullResponse.

LANGUAGE: typescript
CODE:
type PatchOperation =
  | {
      op: 'put';
      key: string;
      value: JSONValue;
    }
  | {op: 'del'; key: string}
  | {op: 'clear'};

----------------------------------------

TITLE: Configuring Push URL in Replicache Constructor
DESCRIPTION: Demonstrates how to specify the push URL when creating a new Replicache instance. The pushURL option is set to '/replicache-push'.

LANGUAGE: javascript
CODE:
const rep = new Replicache({
  // ...
  pushURL: '/replicache-push',
});

----------------------------------------

TITLE: HTTP POST Request for Replicache Push Endpoint
DESCRIPTION: Shows the HTTP method used for the push endpoint. Replicache always uses POST to send data to the push URL.

LANGUAGE: http
CODE:
POST /replicache-push HTTP/2

----------------------------------------

TITLE: HTTP Headers for Replicache Push Request
DESCRIPTION: Illustrates the HTTP headers sent with push requests. Includes Content-type, Authorization, and X-Replicache-RequestID headers.

LANGUAGE: http
CODE:
Content-type: application/json
Authorization: <auth>
X-Replicache-RequestID: <request-id>

----------------------------------------

TITLE: Obtaining Replicache License Key via NPX
DESCRIPTION: This command uses npx to run the latest version of Replicache and generate a license key. It prompts the user for information and then displays the generated key.

LANGUAGE: bash
CODE:
npx replicache@latest get-license

----------------------------------------

TITLE: Example Replicache License Key Output
DESCRIPTION: This snippet shows an example of the license key output generated by the 'get-license' command. The key is a string of characters and numbers.

LANGUAGE: plaintext
CODE:
l123d3baa14984beca21bc42aee593064

----------------------------------------

TITLE: Using TEST_LICENSE_KEY for Unit Testing
DESCRIPTION: This JavaScript code shows how to use the TEST_LICENSE_KEY constant for unit testing. It imports necessary components from Replicache and initializes a Replicache instance with the test key to avoid real license pings during automated tests.

LANGUAGE: javascript
CODE:
import {Replicache, TEST_LICENSE_KEY} from 'replicache';
...

test('my test', () => {
	const r = new Replicache({
		licenseKey: TEST_LICENSE_KEY,
		...
	});
  ...
});

----------------------------------------

TITLE: Installing Undo Library for Replicache
DESCRIPTION: Command to install the @rocicorp/undo library using npm.

LANGUAGE: bash
CODE:
npm install @rocicorp/undo

----------------------------------------

TITLE: Instantiating UndoManager in TypeScript
DESCRIPTION: Creates a new instance of the UndoManager class from the @rocicorp/undo library.

LANGUAGE: typescript
CODE:
const undoManager = new UndoManager();

----------------------------------------

TITLE: Implementing Undo for New Todo Item in React and TypeScript
DESCRIPTION: Demonstrates how to use the UndoManager to associate an executed mutation (adding a new todo) with its undo mutation (deleting the todo).

LANGUAGE: tsx
CODE:
  // new item with undo
  const handleNewItem = (text: string) => {
    const id = nanoid();
    undoManager.add({
      execute: () => {
        rep.mutate.putTodo({
          id,
          text: text,
          sort: todos.length > 0 ? todos[todos.length - 1].sort + 1 : 0,
          completed: false,
        });
      };
      undo: () => rep.mutate.deleteTodos([id]),
    });
  };

----------------------------------------

TITLE: Adding Keyboard Bindings for Undo/Redo in React
DESCRIPTION: Sets up keyboard event handlers and key mappings for undo and redo operations using the react-hotkeys library.

LANGUAGE: tsx
CODE:
  const handlers = {
    undo: () => undoManager.undo(),
    redo: () => undoManager.redo(),
  };

  const keyMap = {
    undo: ["ctrl+z", "command+z"],
    redo: ["ctrl+y", "command+shift+z", "ctrl+shift+z"],
  };

  return (
    <Hotkeys
      {...{
        keyMap,
        handlers,
      }}
    >
      ...
    </HotKeys>

----------------------------------------

TITLE: IndexedDB Read/Write Transaction Benchmarks
DESCRIPTION: Performance benchmark results showing latency and throughput metrics for IndexedDB read and write transactions using ArrayBuffer. Tests different payload sizes from 1 byte to 100MB and batch operations from 1x to 1000x. Each test includes percentile latencies and MB/s throughput measurements.

LANGUAGE: text
CODE:
idb read tx (arraybuffer) 1x1 B 50/75/90/95%=0.40,0.46,0.52,0.55ms/op 0.00 MB/s (1169 runs sampled)
idb read tx (arraybuffer) 1x1 KiB 50/75/90/95%=0.45,0.51,0.56,0.62ms/op 2.15 MB/s (991 runs sampled)
[...truncated for brevity...]

----------------------------------------

TITLE: IndexedDB Read/Write Performance Metrics
DESCRIPTION: Comprehensive benchmark results showing IndexedDB performance characteristics for read and write operations using ArrayBuffer data type. Tests cover various data sizes from 1 byte to 100MB with different batch quantities from 1x to 1000x operations. Metrics include 50th, 75th, 90th and 95th percentile latencies and throughput measurements.

LANGUAGE: text
CODE:
idb read tx (arraybuffer) 1x1 B 50/75/90/95%=0.13,0.17,0.17,0.21ms/op 0.01 MB/s (3229 runs sampled)
idb read tx (arraybuffer) 1x1 KiB 50/75/90/95%=0.16,0.17,0.17,0.20ms/op 6.10 MB/s (3218 runs sampled)
[...additional benchmark lines...]

----------------------------------------

TITLE: Analyzing IndexedDB Read/Write Transaction Performance Data
DESCRIPTION: Raw performance benchmark data showing IndexedDB read and write transaction metrics for ArrayBuffer operations. Each line shows the operation type, data size, number of operations, response time percentiles (50/75/90/95), and throughput in MB/s.

LANGUAGE: text
CODE:
idb read tx (arraybuffer) 1x1 B 50/75/90/95%=0.00,0.00,1.00,1.00ms/op Infinity MB/s (2162 runs sampled)
idb read tx (arraybuffer) 1x1 KiB 50/75/90/95%=0.00,0.00,1.00,1.00ms/op Infinity MB/s (1913 runs sampled)
[...additional benchmark data lines...]

----------------------------------------

TITLE: IndexedDB Performance Test Results
DESCRIPTION: Raw benchmark output showing latency percentiles (50/75/90/95%) and throughput in MB/s for IndexedDB read and write transactions. Tests were run with different combinations of transaction counts and buffer sizes.

LANGUAGE: text
CODE:
idb read tx (arraybuffer) 1x1 B 50/75/90/95%=0.00,1.00,1.00,1.00ms/op Infinity MB/s (1245 runs sampled)
idb read tx (arraybuffer) 1x1 KiB 50/75/90/95%=0.00,1.00,1.00,1.00ms/op Infinity MB/s (1185 runs sampled)
...

----------------------------------------

TITLE: Comparing API Changes for Replicache Release in Bash
DESCRIPTION: Commands to build the current version, download the last release, and compare the .d.ts files to identify API changes.

LANGUAGE: bash
CODE:
# BUILD
cd rocicorp/mono
npm run build

# DOWNLOAD
cd /tmp
npm pack replicache@$LAST_RELEASE_VERSION
tar -xvf replicache-$LAST_RELEASE_VERSION.tgz
cd -

# COMPARE
diff -u /tmp/package/out/replicache.d.ts packages/replicache/out/replicache.d.ts | less
# or
# code --diff /tmp/package/out/replicache.d.ts packages/replicache/out/replicache.d.ts

----------------------------------------

TITLE: Listing Commits Since Last Release in Bash
DESCRIPTION: Command to list all commits on the main branch from the commit prior to the last tag to HEAD, used for identifying changes since the last release.

LANGUAGE: bash
CODE:
git log --oneline replicache/v$LAST_RELEASE_VERSION^..HEAD

----------------------------------------

TITLE: Preparing Clean Checkout for Replicache Release in Bash
DESCRIPTION: Commands to create a clean checkout of the Replicache repository for the release process.

LANGUAGE: bash
CODE:
rm -rf /tmp/release
mkdir /tmp/release
cd /tmp/release
git clone --depth=1 git@github.com:rocicorp/mono.git
cd mono
npm install

----------------------------------------

TITLE: Bumping Replicache Version in Bash
DESCRIPTION: Commands to update the version number in package.json, synchronize package versions, and commit the changes.

LANGUAGE: bash
CODE:
vim packages/replicache/package.json
# Must be done in root of mono checkout
npx syncpack fix-mismatches
npm install
npm run build
git commit -a -m 'chore(replicache): Bump version to v$NEW_VERSION'

----------------------------------------

TITLE: Publishing Canary Release for Replicache in Bash
DESCRIPTION: Command to publish a canary release of Replicache to npm.

LANGUAGE: bash
CODE:
cd packages/replicache
npm publish --tag=canary

----------------------------------------

TITLE: Tagging Replicache Release in Bash
DESCRIPTION: Commands to tag the release on the branch and push the tag to the remote repository.

LANGUAGE: bash
CODE:
git tag replicache/v$NEW_VERSION
git push origin --tags

----------------------------------------

TITLE: Merging Replicache Release to Main in Bash
DESCRIPTION: Commands to merge the release tag into the main branch and push the changes.

LANGUAGE: bash
CODE:
git fetch -t
git merge replicache/v$NEW_VERSION
git push origin main

----------------------------------------

TITLE: Testing License Script for Replicache in Bash
DESCRIPTION: Command to test the get-license script using the canary release of Replicache.

LANGUAGE: bash
CODE:
npx replicache@canary get-license

----------------------------------------

TITLE: Updating Peer Libraries for Replicache in Bash
DESCRIPTION: Commands to update, tag, and publish canary versions of peer libraries that depend on Replicache.

LANGUAGE: bash
CODE:
git tag v$NEW_VERSION
git push origin --tags
npm publish --tag=canary

----------------------------------------

TITLE: Installing Canary Version in Sample Apps for Replicache in Bash
DESCRIPTION: Command to install the canary version of Replicache in sample applications for testing purposes.

LANGUAGE: bash
CODE:
npm add replicache@canary

----------------------------------------

TITLE: Publishing Replicache Release as Latest in Bash
DESCRIPTION: Command to add the latest tag to the new Replicache version on npm, making it the default version for installation.

LANGUAGE: bash
CODE:
npm dist-tag add replicache@$NEW_VERSION latest

----------------------------------------

TITLE: Publishing Private Replicache Release in Bash
DESCRIPTION: Commands to publish a private, non-minimized version of Replicache with sourcemaps for paying customers.

LANGUAGE: bash
CODE:
git checkout rocicorp-replicache

# Merge new release
git merge replicache/v$NEW_VERSION

# Verify that the only diff is the name and the sourcemap
git diff replicache/v$NEW_VERSION

git push origin rocicorp-replicache

npm publish

----------------------------------------

TITLE: Updating Replicache Documentation Branch in Bash
DESCRIPTION: Commands to update the docs branch with the latest release changes and push the updates.

LANGUAGE: bash
CODE:
git checkout docs
git pull
git reset --hard replicache/v$NEW_VERSION
git push origin docs

----------------------------------------

TITLE: Cherry-picking Documentation Changes for Replicache in Bash
DESCRIPTION: Commands to cherry-pick documentation changes onto the docs branch for immediate publication.

LANGUAGE: bash
CODE:
git checkout docs
git pull
# The '-x' appends the hash of the original commit to the cherry-pick'd commit.
# This makes it easier to find missing commits during releases.
git cherry-pick -x <hash-of-spruce-commit>
git push origin docs

----------------------------------------

TITLE: Installing Zero Package via npm
DESCRIPTION: This command installs the Zero package from the npm registry using npm (Node Package Manager).

LANGUAGE: bash
CODE:
npm install @rocicorp/zero

----------------------------------------

TITLE: Building and Packaging Zero Locally
DESCRIPTION: These commands clone the Rocicorp mono repository, install dependencies, build the project, navigate to the Zero package directory, and create a local package file.

LANGUAGE: bash
CODE:
git clone git@github.com:rocicorp/mono.git
cd mono
npm install
npm run build
cd packages/zero
npm pack

----------------------------------------

TITLE: Installing Locally Built Zero Package
DESCRIPTION: This command installs the locally built Zero package in another project. Replace <VERSION> with the actual version number of the package.

LANGUAGE: bash
CODE:
npm install /path/to/rocicorp-zero-<VERSION>.tgz

----------------------------------------

TITLE: Running Tests for Zero-Cache Project using npm
DESCRIPTION: This command executes the test suite for the zero-cache project. It requires Docker and uses Testcontainers with PostgreSQL.

LANGUAGE: bash
CODE:
npm run test

----------------------------------------

TITLE: Setting Up OTEL Trace Collection
DESCRIPTION: Steps to clone and run the docker-otel-lgtm repository and configure the trace collector endpoint in the environment configuration.

LANGUAGE: bash
CODE:
cd docker-otel-lgtm

LANGUAGE: bash
CODE:
./run-lgtm.sh

LANGUAGE: plaintext
CODE:
ZERO_LOG_TRACE_COLLECTOR = "http://localhost:4318/v1/traces"

----------------------------------------

TITLE: Converting AST to ZQL - Basic Usage
DESCRIPTION: Basic command to pipe AST JSON file content to the ast-to-zql converter tool using npx.

LANGUAGE: bash
CODE:
cat ast.json | npx ast-to-zql

----------------------------------------

TITLE: Converting AST to ZQL with Schema Mapping
DESCRIPTION: Extended command that includes a schema file for name mapping when converting AST to ZQL queries.

LANGUAGE: bash
CODE:
cat ast.json | npx ast-to-zql --schema schema.ts

----------------------------------------

TITLE: Building Docker Image for Load Generator
DESCRIPTION: Commands to build the Docker image for the load generator from the repository root

LANGUAGE: bash
CODE:
# From the root of the repository
docker build -t load-generator -f tools/load-generator/Dockerfile .

----------------------------------------

TITLE: Basic Load Generator Docker Configuration
DESCRIPTION: Basic configuration example showing how to run the load generator with essential environment variables including database connection, QPS, and table configuration

LANGUAGE: bash
CODE:
docker run -e ZERO_UPSTREAM_DB="postgresql://user:password@host.docker.internal:6434/postgres" \
  -e ZERO_QPS=20 \
  -e ZERO_PERTURB_TABLE="issue" \
  -e ZERO_PERTURB_KEY="id" \
  -e ZERO_PERTURB_BOOLS="open" \
  -e ZERO_PERTURB_INTS="modified" \
  load-generator:latest

----------------------------------------

TITLE: Advanced Load Generator Configuration
DESCRIPTION: Extended configuration example with higher QPS and multiple fields for both boolean and integer perturbation

LANGUAGE: bash
CODE:
docker run -e ZERO_UPSTREAM_DB="postgresql://user:password@host.docker.internal:6434/postgres" \
  -e ZERO_QPS=50 \
  -e ZERO_PERTURB_TABLE="issue" \
  -e ZERO_PERTURB_KEY="id" \
  -e ZERO_PERTURB_BOOLS="open,resolved" \
  -e ZERO_PERTURB_INTS="modified,priority" \
  load-generator:latest

----------------------------------------

TITLE: Installing Dependencies for ZBugs Project
DESCRIPTION: This command installs the necessary Node.js dependencies for the ZBugs project.

LANGUAGE: bash
CODE:
npm install

----------------------------------------

TITLE: Running Docker Compose for Postgres Database
DESCRIPTION: These commands navigate to the docker directory and start the Postgres database using Docker Compose.

LANGUAGE: bash
CODE:
cd docker
docker compose up

----------------------------------------

TITLE: Configuring Environment Variables for ZBugs
DESCRIPTION: This snippet shows the content of the .env file, which includes configuration for the zero-cache server, database connections, and various API keys.

LANGUAGE: ini
CODE:
#### zero.config.js Variables ####

# The "upstream" authoritative postgres database
# In the future we will support other types of upstreams besides PG
ZERO_UPSTREAM_DB = "postgresql://user:password@127.0.0.1:6434/postgres"

# Where to send custom mutations
ZERO_PUSH_URL = "http://localhost:5173/api/push"

# Place to store the SQLite data zero-cache maintains. This can be lost, but if
# it is, zero-cache will have to re-replicate next time it starts up.
ZERO_REPLICA_FILE = "/tmp/zbugs-sync-replica.db"

ZERO_LOG_LEVEL = "info"

# Use "json" for logs consumed by structured logging services.
ZERO_LOG_FORMAT = "text"

# Public key used to verify JWTs.
# You can create a JWK pair via `npm run create-keys`
# in the `zbugs` directory.
#
# The public key goes here and in `VITE_PUBLIC_JWK`.
# The private key goes in `PRIVATE_JWK`
ZERO_AUTH_JWK=''

#### ZBugs API Server Variables ####

# The client id for the GitHub OAuth app responisble for OAuth:
# https://docs.github.com/en/apps/creating-github-apps
# Rocicorp team, see:
# https://docs.google.com/document/d/1aGHaB0L15SY67wkXQMsST80uHh4-IooTUVzKcUlzjdk/edit#bookmark=id.bb6lqbetv2lm
GITHUB_CLIENT_ID = ""
# The secret for the client
GITHUB_CLIENT_SECRET = ""
# See comment on `ZERO_AUTH_JWK`
PRIVATE_JWK = ""


#### Vite Variables ####
VITE_PUBLIC_SERVER="http://localhost:4848"
# See comment on `ZERO_AUTH_JWK`
VITE_PUBLIC_JWK=''

# Discord webhook to send notifications to. Not required. Notifications won't
# be sent if absent.
DISCORD_WEBHOOK_URL=''

----------------------------------------

TITLE: Starting the Zero-Cache Server for ZBugs
DESCRIPTION: This command starts the zero-cache server for the ZBugs project.

LANGUAGE: bash
CODE:
npm run zero

----------------------------------------

TITLE: Running the ZBugs Web Application
DESCRIPTION: This command starts the development server for the ZBugs web application.

LANGUAGE: bash
CODE:
npm run dev

----------------------------------------

TITLE: Clearing the SQLite Replica Database
DESCRIPTION: This command removes the SQLite replica database file used by zero-cache.

LANGUAGE: bash
CODE:
rm /tmp/zbugs-sync-replica.db*

----------------------------------------

TITLE: Clearing the Upstream Postgres Database
DESCRIPTION: This command stops and removes the Docker containers and volumes for the upstream Postgres database.

LANGUAGE: bash
CODE:
docker compose down -v

----------------------------------------

TITLE: Fetching Large Dataset for ZBugs
DESCRIPTION: This script pulls a large dataset from S3 for use with the ZBugs project.

LANGUAGE: bash
CODE:
./get-data.sh

----------------------------------------

TITLE: Starting Docker Compose with 1GB Configuration
DESCRIPTION: This command starts Docker Compose using a configuration file for a 1GB dataset.

LANGUAGE: bash
CODE:
docker compose -f ./docker-compose-1gb.yml up

----------------------------------------

TITLE: Running Playwright Tests with Environment Variables
DESCRIPTION: Command for executing Playwright tests locally with UI mode and environment configuration. Requires ZERO_AUTH_JWK to be set from the public key generated in zbugs project.

LANGUAGE: bash
CODE:
URL="http://localhost:5174" PERCENT_DIRECT=1 npx playwright test --ui

----------------------------------------

TITLE: Playwright Test Error Message
DESCRIPTION: Error message encountered when attempting to run tests in headed mode, showing a TypeError related to Jest matchers object property redefinition.

LANGUAGE: typescript
CODE:
TypeError: Cannot redefine property: Symbol($$jest-matchers-object)
at /Users/aa/work/mono/node_modules/@vitest/expect/dist/index.js:589:10

----------------------------------------

TITLE: Implementing Push Handler for Per-Space Version Strategy in JSON
DESCRIPTION: JSON examples of default ReplicacheClientGroup and ReplicacheClient objects used in the push handler. These objects are created when no existing records are found and include the spaceID field for space partitioning.

LANGUAGE: json
CODE:
{
  "id": "body.clientGroupID",
  "spaceID": "spaceID",
  "userID": "userID"
}

LANGUAGE: json
CODE:
{
  "id": "mutation.clientID",
  "clientGroupID": "body.clientGroupID",
  "lastMutationID": 0,
  "lastModifiedVersion": "lastModifiedVersion"
}

LANGUAGE: json
CODE:
{
  "id": "body.clientGroupID",
  "spaceID": "request.params.spaceID",
  "version": "nextVersion"
}

LANGUAGE: json
CODE:
{
  "id": "body.clientGroupID",
  "userID": "userID",
  "spaceId": "spaceId"
}

LANGUAGE: json
CODE:
{
  "id": "mutation.clientID",
  "clientGroupID": "body.clientGroupID",
  "lastMutationID": "nextMutationID",
  "lastModifiedVersion": "nextVersion"
}

----------------------------------------

TITLE: Implementing Pull Handler for Per-Space Version Strategy in JSON
DESCRIPTION: JSON example of the default ReplicacheClientGroup object used in the pull handler. This object is created when no existing record is found and includes the userID field for authentication.

LANGUAGE: json
CODE:
{
  "id": "body.clientGroupID",
  "userID": "userID"
}

----------------------------------------

TITLE: Adding Replicache Pull Route to Express App in TypeScript
DESCRIPTION: This TypeScript snippet shows how to add the Replicache pull handler to an Express.js application by modifying the main server file.

LANGUAGE: typescript
CODE:
import { handlePull } from './pull';
//...
app.use(express.urlencoded({extended: true}), express.json(), errorHandler);

app.post('/api/replicache/pull', handlePull);

if (process.env.NODE_ENV === 'production') {
//...

----------------------------------------

TITLE: Implementing Cleanup for Pusher and Replicache
DESCRIPTION: Cleanup implementation to properly disconnect Pusher instances and close Replicache connection

LANGUAGE: typescript
CODE:
return () => {
  Pusher.instances.forEach(i => i.disconnect());
  void r.close();
};

----------------------------------------

TITLE: Embedding Replicache Mutators Example in HTML iframe
DESCRIPTION: This snippet demonstrates how to embed a CodeSandbox example of Replicache mutators using an HTML iframe. It includes various attributes for security and display settings.

LANGUAGE: html
CODE:
<iframe src="https://codesandbox.io/embed/replicache-mutators-13-f8v2k4?autoresize=1&fontsize=12&hidenavigation=1&theme=light&codemirror=1&view=split"
     style={'width':'100%','height':'350px', 'border':'1px solid rgb(222,221,221)', 'overflow':'hidden'}
     title="constructing-replicache"
     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>

----------------------------------------

TITLE: Embedding Interactive Replicache Subscription Demo
DESCRIPTION: Embedded CodeSandbox iframe showing a live demo of Replicache subscriptions, configured with specific styling and security parameters.

LANGUAGE: jsx
CODE:
<iframe src="https://codesandbox.io/embed/replicache-subscriptions-13-s5tdqk?autoresize=1&fontsize=12&hidenavigation=1&theme=light&codemirror=1&view=split"
     style={{'width':'100%','height':'350px', 'border':'1px solid rgb(222,221,221)', 'overflow':'hidden'}}
     title="constructing-replicache"
     allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
     sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>

----------------------------------------

TITLE: Initializing Replicache Instance with Name and License Key in JavaScript
DESCRIPTION: This code snippet demonstrates how to construct a Replicache instance using the required 'name' and 'licenseKey' parameters. The 'name' should typically be the logged-in user's ID to keep storage separate between users on the same device. The 'licenseKey' is used for licensing, with a tutorial key provided for this example.

LANGUAGE: javascript
CODE:
new Replicache({
  name: 'user-1234',
  licenseKey: TUTORIAL_LICENSE_KEY
});