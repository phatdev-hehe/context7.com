TITLE: Defining a gRPC Service in Protocol Buffers
DESCRIPTION: Defines the RouteGuide service with various RPC methods using protocol buffers syntax. Includes examples of simple RPC, server-side streaming, client-side streaming, and bidirectional streaming.

LANGUAGE: protobuf
CODE:
service RouteGuide {
  rpc GetFeature(Point) returns (Feature) {}
  rpc ListFeatures(Rectangle) returns (stream Feature) {}
  rpc RecordRoute(stream Point) returns (RouteSummary) {}
  rpc RouteChat(stream RouteNote) returns (stream RouteNote) {}
}

----------------------------------------

TITLE: Defining Basic gRPC Service in Protocol Buffers
DESCRIPTION: Demonstrates the basic structure of a gRPC service definition using protocol buffers, including a simple request-response service method with message definitions.

LANGUAGE: protobuf
CODE:
service HelloService {
  rpc SayHello (HelloRequest) returns (HelloResponse);
}

message HelloRequest {
  string greeting = 1;
}

message HelloResponse {
  string reply = 1;
}

----------------------------------------

TITLE: Starting a gRPC Server in C++
DESCRIPTION: Shows how to set up and start a gRPC server using ServerBuilder. This includes specifying the server address, registering the service, and starting the server.

LANGUAGE: cpp
CODE:
void RunServer(const std::string& db_path) {
  std::string server_address("0.0.0.0:50051");
  RouteGuideImpl service(db_path);

  ServerBuilder builder;
  builder.AddListeningPort(server_address, grpc::InsecureServerCredentials());
  builder.RegisterService(&service);
  std::unique_ptr<Server> server(builder.BuildAndStart());
  std::cout << "Server listening on " << server_address << std::endl;
  server->Wait();
}

----------------------------------------

TITLE: Defining a gRPC Service with Protocol Buffers
DESCRIPTION: This example shows how to define a gRPC service using protocol buffers. It includes a 'Greeter' service with a 'SayHello' RPC method, along with the request and response message definitions.

LANGUAGE: proto
CODE:
// The greeter service definition.
service Greeter {
  // Sends a greeting
  rpc SayHello (HelloRequest) returns (HelloReply) {}
}

// The request message containing the user's name.
message HelloRequest {
  string name = 1;
}

// The response message containing the greetings
message HelloReply {
  string message = 1;
}

----------------------------------------

TITLE: Configuring gRPC Service Settings with JSON
DESCRIPTION: Example service configuration that demonstrates setting load balancing policy to round robin and configuring different timeout values for specific services and methods. The config applies a default 1-second timeout globally while setting a 2-second timeout for specific service methods.

LANGUAGE: json
CODE:
{
  "loadBalancingConfig": [ { "round_robin": {} } ],
  "methodConfig": [
    {
      "name": [{}],
      "timeout": "1s"
    },
    {
      "name": [
        { "service": "foo", "method": "bar" },
        { "service": "baz" }
      ],
      "timeout": "2s"
    }
  ]
}

----------------------------------------

TITLE: Implementing Google Authentication in PHP
DESCRIPTION: This PHP code shows how to authenticate with Google services using a combination of SSL credentials and Google's application default credentials.

LANGUAGE: php
CODE:
function updateAuthMetadataCallback($context)
{
    $auth_credentials = ApplicationDefaultCredentials::getCredentials();
    return $auth_credentials->updateMetadata($metadata = [], $context->service_url);
}
$channel_credentials = Grpc\ChannelCredentials::createComposite(
    Grpc\ChannelCredentials::createSsl(file_get_contents('roots.pem')),
    Grpc\CallCredentials::createFromPlugin('updateAuthMetadataCallback')
);
$opts = [
  'credentials' => $channel_credentials
];
$client = new helloworld\GreeterClient('greeter.googleapis.com', $opts);

----------------------------------------

TITLE: Implementing Client-Side SSL/TLS Authentication in C++
DESCRIPTION: This snippet demonstrates how to create and use SSL/TLS channel credentials in C++ for secure communication with a gRPC server. It covers creating credentials, establishing a channel, and making RPC calls.

LANGUAGE: cpp
CODE:
// Create a default SSL ChannelCredentials object.
auto channel_creds = grpc::SslCredentials(grpc::SslCredentialsOptions());
// Create a channel using the credentials created in the previous step.
auto channel = grpc::CreateChannel(server_name, channel_creds);
// Create a stub on the channel.
std::unique_ptr<Greeter::Stub> stub(Greeter::NewStub(channel));
// Make actual RPC calls on the stub.
grpc::Status s = stub->sayHello(&context, *request, response);

----------------------------------------

TITLE: Defining Unary RPC Method
DESCRIPTION: Shows the definition of a unary RPC method where the client sends a single request and receives a single response.

LANGUAGE: protobuf
CODE:
rpc SayHello(HelloRequest) returns (HelloResponse);

----------------------------------------

TITLE: Handling Bidirectional Streaming RPC in C++
DESCRIPTION: Demonstrates how to handle a bidirectional streaming RPC call to the RouteChat method. This includes using a ClientReaderWriter to both send and receive multiple messages.

LANGUAGE: cpp
CODE:
std::shared_ptr<ClientReaderWriter<RouteNote, RouteNote> > stream(
    stub_->RouteChat(&context));
// Read and write messages using stream->Read() and stream->Write()

----------------------------------------

TITLE: Defining Server Streaming RPC Method
DESCRIPTION: Demonstrates the definition of a server streaming RPC where the server sends multiple responses for a single client request.

LANGUAGE: protobuf
CODE:
rpc LotsOfReplies(HelloRequest) returns (stream HelloResponse);

----------------------------------------

TITLE: Error Status Code Reference Table - Protocol Errors
DESCRIPTION: A reference table showing gRPC error status codes for protocol-specific issues like compression, authentication, and parsing errors.

LANGUAGE: markdown
CODE:
Case | Status code
-----|-----------
Could not decompress but compression algorithm supported | `GRPC_STATUS_INTERNAL`
Compression mechanism not supported by server | `GRPC_STATUS_UNIMPLEMENTED`
Flow-control resource limits reached | `GRPC_STATUS_RESOURCE_EXHAUSTED`
Flow-control protocol violation | `GRPC_STATUS_INTERNAL`
Error parsing returned status | `GRPC_STATUS_UNKNOWN`
Unauthenticated: credentials failed to get metadata | `GRPC_STATUS_UNAUTHENTICATED`
Invalid host set in authority metadata | `GRPC_STATUS_UNAUTHENTICATED`
Error parsing protocol buffer | `GRPC_STATUS_INTERNAL`

----------------------------------------

TITLE: Defining a Person Message in Protocol Buffers
DESCRIPTION: This snippet demonstrates how to define a simple message structure in a .proto file. It defines a 'Person' message with fields for name, id, and a boolean flag.

LANGUAGE: proto
CODE:
message Person {
  string name = 1;
  int32 id = 2;
  bool has_ponycopter = 3;
}

----------------------------------------

TITLE: Creating gRPC Client Stub in Java
DESCRIPTION: Shows how to create blocking and non-blocking stubs for the RouteGuide service in the client.

LANGUAGE: Java
CODE:
public RouteGuideClient(String host, int port) {
  this(ManagedChannelBuilder.forAddress(host, port).usePlaintext());
}

public RouteGuideClient(ManagedChannelBuilder<?> channelBuilder) {
  channel = channelBuilder.build();
  blockingStub = RouteGuideGrpc.newBlockingStub(channel);
  asyncStub = RouteGuideGrpc.newStub(channel);
}

----------------------------------------

TITLE: Setting Up Async gRPC Server
DESCRIPTION: Configures an asynchronous gRPC server with a completion queue and registers the service.

LANGUAGE: c++
CODE:
helloworld::Greeter::AsyncService service;
ServerBuilder builder;
builder.AddListeningPort("0.0.0.0:50051", InsecureServerCredentials());
builder.RegisterService(&service);
auto cq = builder.AddCompletionQueue();
auto server = builder.BuildAndStart();

----------------------------------------

TITLE: Registering gRPC Server Implementation in Go
DESCRIPTION: Function signature for registering a concrete server implementation with a gRPC server instance. Used to register service implementations before starting the server.

LANGUAGE: go
CODE:
func RegisterBarServer(s *grpc.Server, srv BarServer)

----------------------------------------

TITLE: Defining a gRPC Service in Protocol Buffers
DESCRIPTION: Defines the RouteGuide service with various RPC methods including simple, server-side streaming, client-side streaming, and bidirectional streaming.

LANGUAGE: proto
CODE:
service RouteGuide {
   // Obtains the feature at a given position.
   rpc GetFeature(Point) returns (Feature) {}

   // Obtains the Features available within the given Rectangle.
   rpc ListFeatures(Rectangle) returns (stream Feature) {}

   // Accepts a stream of Points on a route being traversed, returning a RouteSummary.
   rpc RecordRoute(stream Point) returns (RouteSummary) {}

   // Accepts a stream of RouteNotes sent while a route is being traversed,
   // while receiving other RouteNotes.
   rpc RouteChat(stream RouteNote) returns (stream RouteNote) {}
}

----------------------------------------

TITLE: Starting gRPC Server
DESCRIPTION: Python code to initialize and start a gRPC server with the RouteGuide service implementation.

LANGUAGE: python
CODE:
def serve():
    server = grpc.server(futures.ThreadPoolExecutor(max_workers=10))
    route_guide_pb2_grpc.add_RouteGuideServicer_to_server(RouteGuideServicer(), server)
    server.add_insecure_port("[::]:50051")
    server.start()
    server.wait_for_termination()

----------------------------------------

TITLE: Defining BenchmarkService Protocol Buffer Definition
DESCRIPTION: Core service definition that implements two methods: UnaryCall for simple request-response and StreamingCall for repeated ping-pong messages. This service is used across all language implementations for consistent testing.

LANGUAGE: protobuf
CODE:
service BenchmarkService {
  // UnaryCall - a unary RPC of a simple request
  // StreamingCall - a streaming RPC for ping-pong messages
}

----------------------------------------

TITLE: Creating a Custom Authentication Plugin in C++
DESCRIPTION: This snippet demonstrates how to create a custom authentication plugin in C++ by extending the MetadataCredentialsPlugin class. It sets a custom authentication ticket in the request headers.

LANGUAGE: cpp
CODE:
class MyCustomAuthenticator : public grpc::MetadataCredentialsPlugin {
 public:
  MyCustomAuthenticator(const grpc::string& ticket) : ticket_(ticket) {}

  grpc::Status GetMetadata(
      grpc::string_ref service_url, grpc::string_ref method_name,
      const grpc::AuthContext& channel_auth_context,
      std::multimap<grpc::string, grpc::string>* metadata) override {
    metadata->insert(std::make_pair("x-custom-auth-ticket", ticket_));
    return grpc::Status::OK;
  }

 private:
  grpc::string ticket_;
};

auto call_creds = grpc::MetadataCredentialsFromPlugin(
    std::unique_ptr<grpc::MetadataCredentialsPlugin>(
        new MyCustomAuthenticator("super-secret-ticket")));

----------------------------------------

TITLE: Defining Bidirectional Streaming RPC Method
DESCRIPTION: Illustrates the definition of a bidirectional streaming RPC where both client and server can send multiple messages independently.

LANGUAGE: protobuf
CODE:
rpc BidiHello(stream HelloRequest) returns (stream HelloResponse);

----------------------------------------

TITLE: Defining gRPC Service and Messages in Protocol Buffers
DESCRIPTION: This Protocol Buffers IDL defines the gRPC service YYAPI and its associated messages, including the APIGetMessages RPC with a REST mapping for grpc-gateway.

LANGUAGE: proto
CODE:
message APIRequest {
  string userID = 1;
  // Other fields omitted for clarity…
}

message APIFeedResponse {
  repeated APIPost messages = 1;
  // Other fields omitted for clarity…
}

message APIPost {
  string messageID = 1;
  string message = 2;
  // Other fields omitted for clarity…
}

service YYAPI {
  rpc APIGetMessages (APIRequest) returns (APIFeedResponse) {
    option (google.api.http) = {
      get: "/api/getMessages"
    };
  }
}

----------------------------------------

TITLE: Defining Bidirectional Streaming RPC in Protocol Buffers
DESCRIPTION: Example of defining a bidirectional streaming RPC method RouteChat in the RouteGuide service.

LANGUAGE: Protocol Buffers
CODE:
rpc RouteChat(stream RouteNote) returns (stream RouteNote) {}

----------------------------------------

TITLE: Defining gRPC Service in Protocol Buffers
DESCRIPTION: Defines the RouteGuide service with various RPC methods using protocol buffers syntax.

LANGUAGE: Protocol Buffers
CODE:
service RouteGuide {
  rpc GetFeature(Point) returns (Feature) {}
  rpc ListFeatures(Rectangle) returns (stream Feature) {}
  rpc RecordRoute(stream Point) returns (RouteSummary) {}
  rpc RouteChat(stream RouteNote) returns (stream RouteNote) {}
}

----------------------------------------

TITLE: Defining Client Streaming RPC Method
DESCRIPTION: Shows the definition of a client streaming RPC where the client sends multiple requests and receives a single response.

LANGUAGE: protobuf
CODE:
rpc LotsOfGreetings(stream HelloRequest) returns (HelloResponse);

----------------------------------------

TITLE: Implementing a gRPC Server in C++
DESCRIPTION: Demonstrates how to implement the RouteGuide service on the server side. Includes examples of handling different types of RPC calls.

LANGUAGE: cpp
CODE:
class RouteGuideImpl final : public RouteGuide::Service {
  Status GetFeature(ServerContext* context, const Point* point,
                    Feature* feature) override {
    feature->set_name(GetFeatureName(*point, feature_list_));
    feature->mutable_location()->CopyFrom(*point);
    return Status::OK;
  }

  Status ListFeatures(ServerContext* context, const Rectangle* rectangle,
                      ServerWriter<Feature>* writer) override {
    // Implementation...
  }

  Status RecordRoute(ServerContext* context,
                     ServerReader<Point>* reader,
                     RouteSummary* summary) override {
    // Implementation...
  }

  Status RouteChat(ServerContext* context,
                   ServerReaderWriter<RouteNote, RouteNote>* stream) override {
    // Implementation...
  }
};

----------------------------------------

TITLE: Implementing gRPC Client in Python
DESCRIPTION: Client implementation showing how to make RPC calls to both server methods.

LANGUAGE: python
CODE:
def run():
    with grpc.insecure_channel('localhost:50051') as channel:
        stub = helloworld_pb2_grpc.GreeterStub(channel)
        response = stub.SayHello(helloworld_pb2.HelloRequest(name='you'))
        print("Greeter client received: " + response.message)
        response = stub.SayHelloAgain(helloworld_pb2.HelloRequest(name='you'))
        print("Greeter client received: " + response.message)

----------------------------------------

TITLE: Implementing Client-Streaming RPC RecordRoute on Client
DESCRIPTION: Shows how to implement the client-side logic for the RecordRoute client-streaming RPC using a ClientWriteReactor. It demonstrates how to send multiple messages and handle the single response.

LANGUAGE: cpp
CODE:
class Recorder : public grpc::ClientWriteReactor<Point> {
 public:
  Recorder(RouteGuide::Stub* stub, float coord_factor,
           const std::vector<Feature>* feature_list)
      : coord_factor_(coord_factor),
        feature_list_(feature_list),
        generator_(
            std::chrono::system_clock::now().time_since_epoch().count()),
        feature_distribution_(0, feature_list->size() - 1),
        delay_distribution_(500, 1500) {
    stub->async()->RecordRoute(&context_, &stats_, this);
    // Use a hold since some StartWrites are invoked indirectly from a
    // delayed lambda in OnWriteDone rather than directly from the reaction
    // itself
    AddHold();
    NextWrite();
    StartCall();
  }
  void OnWriteDone(bool ok) override {
    // Delay and then do the next write or WritesDone
    alarm_.Set(
        std::chrono::system_clock::now() +
            std::chrono::milliseconds(delay_distribution_(generator_)),
        [this](bool /*ok*/) { NextWrite(); });
  }
  void OnDone(const Status& s) override {
    std::unique_lock<std::mutex> l(mu_);
    status_ = s;
    done_ = true;
    cv_.notify_one();
  }
  Status Await(RouteSummary* stats) {
    std::unique_lock<std::mutex> l(mu_);
    cv_.wait(l, [this] { return done_; });
    *stats = stats_;
    return std::move(status_);
  }

 private:
  void NextWrite() {
    if (points_remaining_ != 0) {
      const Feature& f =
          (*feature_list_)[feature_distribution_(generator_)];
      std::cout << "Visiting point "
                << f.location().latitude() / coord_factor_ << ", "
                << f.location().longitude() / coord_factor_ << std::endl;
      StartWrite(&f.location());
      points_remaining_--;
    } else {
      StartWritesDone();
      RemoveHold();
    }
  }
  ClientContext context_;
  float coord_factor_;
  int points_remaining_ = 10;
  Point point_;
  RouteSummary stats_;
  const std::vector<Feature>* feature_list_;
  std::default_random_engine generator_;
  std::uniform_int_distribution<int> feature_distribution_;
  std::uniform_int_distribution<int> delay_distribution_;
  grpc::Alarm alarm_;
  std::mutex mu_;
  std::condition_variable cv_;
  Status status_;
  bool done_ = false;
};

----------------------------------------

TITLE: Configuring Keepalive Pings in C++ gRPC
DESCRIPTION: Sets the keepalive time for gRPC channels in C++ to maintain HTTP/2 connections during periods of inactivity, allowing for quicker initial RPCs.

LANGUAGE: C++
CODE:
GRPC_ARG_KEEPALIVE_TIME_MS

----------------------------------------

TITLE: Implementing gRPC Server Methods in Java
DESCRIPTION: Java implementation of the Greeter service on the server-side, including both SayHello and SayHelloAgain methods.

LANGUAGE: java
CODE:
// Implementation of the gRPC service on the server-side.
private class GreeterImpl extends GreeterGrpc.GreeterImplBase {

  @Override
  public void sayHello(HelloRequest req, StreamObserver<HelloReply> responseObserver) {
    // Generate a greeting message for the original method
    HelloReply reply = HelloReply.newBuilder().setMessage("Hello " + req.getName()).build();

    // Send the reply back to the client.
    responseObserver.onNext(reply);

    // Indicate that no further messages will be sent to the client.
    responseObserver.onCompleted();
  }

  @Override
  public void sayHelloAgain(HelloRequest req, StreamObserver<HelloReply> responseObserver) {
    // Generate another greeting message for the new method.
    HelloReply reply = HelloReply.newBuilder().setMessage("Hello again " + req.getName()).build();

    // Send the reply back to the client.
    responseObserver.onNext(reply);

    // Indicate that no further messages will be sent to the client.
    responseObserver.onCompleted();
  }
}

----------------------------------------

TITLE: Implementing GRPCAuthorizationProtocol in Objective-C
DESCRIPTION: Example of implementing the GRPCAuthorizationProtocol for providing access tokens in Objective-C.

LANGUAGE: objective-c
CODE:
@interface TokenProvider : NSObject<GRPCAuthorizationProtocol>
...
@end

@implementation TokenProvider

- (void)getTokenWithHandler:(void (^)(NSString* token))handler {
  ...
}

@end

----------------------------------------

TITLE: Implementing Unary RPC GetFeature on Server
DESCRIPTION: Shows the implementation of the GetFeature unary RPC on the server side using a ServerUnaryReactor. It demonstrates how to set the response and finish the RPC.

LANGUAGE: cpp
CODE:
grpc::ServerUnaryReactor* GetFeature(CallbackServerContext* context,
                                     const Point* point,
                                     Feature* feature) override {
  feature->set_name(GetFeatureName(*point, feature_list_));
  feature->mutable_location()->CopyFrom(*point);
  auto* reactor = context->DefaultReactor();
  reactor->Finish(Status::OK);
  return reactor;
}

----------------------------------------

TITLE: Implementing gRPC Client in Kotlin
DESCRIPTION: Kotlin implementation of the gRPC client, calling both SayHello and SayHelloAgain methods.

LANGUAGE: kotlin
CODE:
class HelloWorldClient(
    private val channel: ManagedChannel
) : Closeable {
  private val stub: GreeterCoroutineStub = GreeterCoroutineStub(channel)

  suspend fun greet(name: String) {
    val request = helloRequest { this.name = name }
    val response = stub.sayHello(request)
    println("Received: ${response.message}")
    val againResponse = stub.sayHelloAgain(request)
    println("Received: ${againResponse.message}")
  }

  override fun close() {
    channel.shutdown().awaitTermination(5, TimeUnit.SECONDS)
  }
}

----------------------------------------

TITLE: Server Streaming Method Implementation
DESCRIPTION: Service stub signature for implementing a server-streaming RPC method that accepts a single request and returns multiple responses.

LANGUAGE: java
CODE:
public void serverStreamingExample(
    RequestType request,
    StreamObserver<ResponseType> responseObserver)

----------------------------------------

TITLE: Implementing gRPC Server in Python
DESCRIPTION: Server implementation of the Greeter service with two methods to handle client requests.

LANGUAGE: python
CODE:
class Greeter(helloworld_pb2_grpc.GreeterServicer):

    def SayHello(self, request, context):
        return helloworld_pb2.HelloReply(message=f"Hello, {request.name}!")

    def SayHelloAgain(self, request, context):
        return helloworld_pb2.HelloReply(message=f"Hello again, {request.name}!")

----------------------------------------

TITLE: Creating a gRPC Client Stub in C++
DESCRIPTION: Demonstrates how to create a gRPC channel and use it to create a client stub for making RPC calls to the server.

LANGUAGE: cpp
CODE:
public:
 RouteGuideClient(std::shared_ptr<ChannelInterface> channel,
                  const std::string& db)
     : stub_(RouteGuide::NewStub(channel)) {
   ...
 }

----------------------------------------

TITLE: Unary Service Method Implementation
DESCRIPTION: Service stub signature for implementing a unary RPC method that accepts a single request and returns a single response.

LANGUAGE: java
CODE:
public void unaryExample(
    RequestType request,
    StreamObserver<ResponseType> responseObserver)

----------------------------------------

TITLE: Handling Client-Side Streaming RPC in C++
DESCRIPTION: Shows how to perform a client-side streaming RPC call to the RecordRoute method. This includes using a ClientWriter to send multiple requests to the server.

LANGUAGE: cpp
CODE:
std::unique_ptr<ClientWriter<Point> > writer(
    stub_->RecordRoute(&context, &stats));
for (int i = 0; i < kPoints; i++) {
  const Feature& f = feature_list_[feature_distribution(generator)];
  if (!writer->Write(f.location())) {
    // Broken stream.
    break;
  }
}
writer->WritesDone();
Status status = writer->Finish();

----------------------------------------

TITLE: Calling a Simple RPC Method from a Kotlin Client
DESCRIPTION: Demonstrates how to call the GetFeature method from a Kotlin client.

LANGUAGE: kotlin
CODE:
suspend fun getFeature(latitude: Int, longitude: Int) {
  val request = point(latitude, longitude)
  val feature = stub.getFeature(request)
  if (feature.exists()) { /* ... */ }
}

----------------------------------------

TITLE: Defining a gRPC Service in Protocol Buffers
DESCRIPTION: Defines the RouteGuide service with various RPC methods using protocol buffers syntax.

LANGUAGE: protobuf
CODE:
service RouteGuide {
   // Obtains the feature at a given position.
   rpc GetFeature(Point) returns (Feature) {}

   // Obtains the Features available within the given Rectangle.
   rpc ListFeatures(Rectangle) returns (stream Feature) {}

   // Accepts a stream of Points on a route being traversed, returning a RouteSummary.
   rpc RecordRoute(stream Point) returns (RouteSummary) {}

   // Accepts a stream of RouteNotes sent while a route is being traversed,
   // while receiving other RouteNotes.
   rpc RouteChat(stream RouteNote) returns (stream RouteNote) {}
}

----------------------------------------

TITLE: Bidirectional Streaming Client Interface in Go
DESCRIPTION: Interface for the client-side handler of a bidirectional streaming RPC, providing methods to send and receive messages.

LANGUAGE: Go
CODE:
type <ServiceName>_FooClient interface {
	Send(*MsgA) error
	Recv() (*MsgB, error)
	grpc.ClientStream
}

----------------------------------------

TITLE: Implementing a Bidirectional Streaming RPC in Kotlin
DESCRIPTION: Implements the RouteChat method, which takes a stream of RouteNotes and returns a stream of RouteNotes.

LANGUAGE: kotlin
CODE:
override fun routeChat(requests: Flow<RouteNote>): Flow<RouteNote> =
  flow {
    requests.collect { note ->
      val notes: MutableList<RouteNote> = routeNotes.computeIfAbsent(note.location) {
        Collections.synchronizedList(mutableListOf<RouteNote>())
      }
      for (prevNote in notes.toTypedArray()) { // thread-safe snapshot
        emit(prevNote)
      }
      notes += note
    }
  }

----------------------------------------

TITLE: Implementing Bidirectional Streaming RPC RouteChat on Server
DESCRIPTION: Demonstrates the implementation of the RouteChat bidirectional streaming RPC on the server side using a ServerBidiReactor. It shows how to handle multiple client messages and send multiple responses.

LANGUAGE: cpp
CODE:
grpc::ServerBidiReactor<RouteNote, RouteNote>* RouteChat(
    CallbackServerContext* context) override {
  class Chatter : public grpc::ServerBidiReactor<RouteNote, RouteNote> {
   public:
    Chatter(absl::Mutex* mu, std::vector<RouteNote>* received_notes)
        : mu_(mu), received_notes_(received_notes) {
      StartRead(&note_);
    }

    void OnReadDone(bool ok) override {
      if (ok) {
        mu_->Lock();
        std::copy_if(received_notes_->begin(), received_notes_->end(),
                     std::back_inserter(to_send_notes_),
                     [this](const RouteNote& note) {
                       return note.location().latitude() ==
                                  note_.location().latitude() &&
                              note.location().longitude() ==
                                  note_.location().longitude();
                     });
        mu_->Unlock();
        notes_iterator_ = to_send_notes_.begin();
        NextWrite();
      } else {
        Finish(Status::OK);
      }
    }
    void OnWriteDone(bool /*ok*/) override { NextWrite(); }

    void OnDone() override {
      LOG(INFO) << "RPC Completed";
      delete this;
    }

    void OnCancel() override { LOG(ERROR) << "RPC Cancelled"; }

   private:
    void NextWrite() {
      if (notes_iterator_ != to_send_notes_.end()) {
        StartWrite(&*notes_iterator_);
        notes_iterator_++;
      } else {
        mu_->Lock();
        received_notes_->push_back(note_);
        mu_->Unlock();
        StartRead(&note_);
      }
    }

    RouteNote note_;
    absl::Mutex* mu_;
    std::vector<RouteNote>* received_notes_ ABSL_GUARDED_BY(mu_);
    std::vector<RouteNote> to_send_notes_;
    std::vector<RouteNote>::iterator notes_iterator_;
  };
  return new Chatter(&mu_, &received_notes_);
}

----------------------------------------

TITLE: Setting gRPC Deadlines in Java
DESCRIPTION: Illustrates setting a deadline for a gRPC client request in Java. It uses the withDeadlineAfter method of the blocking stub to set a timeout in milliseconds.

LANGUAGE: java
CODE:
response = blockingStub.withDeadlineAfter(deadlineMs, TimeUnit.MILLISECONDS).sayHello(request);

----------------------------------------

TITLE: Implementing PHP gRPC Client
DESCRIPTION: PHP code showing how to create a gRPC client and make different types of RPC calls including simple and streaming RPCs.

LANGUAGE: php
CODE:
$client = new Routeguide\RouteGuideClient('localhost:50051', [
    'credentials' => Grpc\ChannelCredentials::createInsecure(),
]);

$point = new Routeguide\Point();
$point->setLatitude(409146138);
$point->setLongitude(-746188906);
list($feature, $status) = $client->GetFeature($point)->wait();

----------------------------------------

TITLE: Calling a Client-Side Streaming RPC from a Kotlin Client
DESCRIPTION: Demonstrates how to call the RecordRoute method, sending a stream of points and receiving a summary.

LANGUAGE: kotlin
CODE:
suspend fun recordRoute(points: Flow<Point>) {
  println("*** RecordRoute")
  val summary = stub.recordRoute(points)
  println("Finished trip with ${summary.pointCount} points.")
  println("Passed ${summary.featureCount} features.")
  println("Travelled ${summary.distance} meters.")
  val duration = summary.elapsedTime.seconds
  println("It took $duration seconds.")
}

----------------------------------------

TITLE: Defining gRPC Service in Protobuf
DESCRIPTION: Protocol buffer service definition showing different types of RPC methods including simple, server-streaming, client-streaming, and bidirectional streaming.

LANGUAGE: protobuf
CODE:
service RouteGuide {
   ...
}

rpc GetFeature(Point) returns (Feature) {}

rpc ListFeatures(Rectangle) returns (stream Feature) {}

rpc RecordRoute(stream Point) returns (RouteSummary) {}

rpc RouteChat(stream RouteNote) returns (stream RouteNote) {}

----------------------------------------

TITLE: Implementing Server-Streaming RPC ListFeatures on Client
DESCRIPTION: Shows how to implement the client-side logic for the ListFeatures server-streaming RPC using a ClientReadReactor. It demonstrates how to handle multiple responses and manage the RPC lifecycle.

LANGUAGE: cpp
CODE:
class Reader : public grpc::ClientReadReactor<Feature> {
 public:
  Reader(RouteGuide::Stub* stub, float coord_factor,
         const routeguide::Rectangle& rect)
      : coord_factor_(coord_factor) {
    stub->async()->ListFeatures(&context_, &rect, this);
    StartRead(&feature_);
    StartCall();
  }
  void OnReadDone(bool ok) override {
    if (ok) {
      std::cout << "Found feature called " << feature_.name() << " at "
                << feature_.location().latitude() / coord_factor_ << ", "
                << feature_.location().longitude() / coord_factor_
                << std::endl;
      StartRead(&feature_);
    }
  }
  void OnDone(const Status& s) override {
    std::unique_lock<std::mutex> l(mu_);
    status_ = s;
    done_ = true;
    cv_.notify_one();
  }
  Status Await() {
    std::unique_lock<std::mutex> l(mu_);
    cv_.wait(l, [this] { return done_; });
    return std::move(status_);
  }

 private:
  ClientContext context_;
  float coord_factor_;
  Feature feature_;
  std::mutex mu_;
  std::condition_variable cv_;
  Status status_;
  bool done_ = false;
};

----------------------------------------

TITLE: Starting gRPC Server in Dart
DESCRIPTION: Example of starting a gRPC server for the RouteGuide service in Dart.

LANGUAGE: Dart
CODE:
Future<void> main(List<String> args) async {
  final server = grpc.Server.create([RouteGuideService()]);
  await server.serve(port: 8080);
  print('Server listening...');
}

----------------------------------------

TITLE: Implementing Client-Side Streaming RPC in Dart
DESCRIPTION: Example of implementing the RecordRoute client-side streaming RPC method in the RouteGuide service.

LANGUAGE: Dart
CODE:
@override
Future<RouteSummary> recordRoute(
    grpc.ServiceCall call, Stream<Point> request) async {
  int pointCount = 0;
  int featureCount = 0;
  double distance = 0.0;
  Point previous;
  final timer = Stopwatch();

  await for (var location in request) {
    if (!timer.isRunning) timer.start();
    pointCount++;
    final feature = featuresDb.firstWhereOrNull((f) => f.location == location);
    if (feature != null) {
      featureCount++;
    }
    // For each point after the first, add the incremental distance from the
    // previous point to the total distance value.
    if (previous != null) distance += _distance(previous, location);
    previous = location;
  }
  timer.stop();
  return RouteSummary()
    ..pointCount = pointCount
    ..featureCount = featureCount
    ..distance = distance.round()
    ..elapsedTime = timer.elapsed.inSeconds;
}

----------------------------------------

TITLE: Using gRPC-Web Client in JavaScript
DESCRIPTION: This JavaScript code snippet shows how to use the generated gRPC-Web client to make a request to a backend gRPC service. It demonstrates creating a client, setting up a request, and handling the response.

LANGUAGE: js
CODE:
const {GetTodoRequest} = require('./todos_pb.js');
const {TodoServiceClient} = require('./todos_grpc_web_pb.js');

const todoService = new proto.todos.TodoServiceClient('http://localhost:8080');
const todoId = 1234;

var getTodoRequest = new proto.todos.GetTodoRequest();
getTodoRequest.setId(todoId);

var metadata = {};
var getTodo = todoService.getTodoById(getTodoRequest, metadata, (err, response) => {
  if (err) {
    console.log(err);
  } else {
    const todo = response.todo();
    if (todo == null) {
      console.log(`A TODO with the ID ${todoId} wasn't found`);
    } else {
      console.log(`Fetched TODO with ID ${todoId}: ${todo.content()}`);
    }
  }
});

----------------------------------------

TITLE: Visualizing Caching and Logging Interceptor Order - Network-Side Logging
DESCRIPTION: Mermaid flowchart showing interceptor ordering with logging closer to the network layer, demonstrating how cache misses flow through the interceptor chain.

LANGUAGE: mermaid
CODE:
flowchart LR
APP(Application) --> INT1
INT1(Caching\nInterceptor) -->|Cache miss| INT2
INT2(Logging\nInterceptor) --> NET
NET(Network)

----------------------------------------

TITLE: Implementing Server-Side Streaming RPC in Dart
DESCRIPTION: Example of implementing the ListFeatures server-side streaming RPC method in the RouteGuide service.

LANGUAGE: Dart
CODE:
@override
Stream<Feature> listFeatures(
    grpc.ServiceCall call, Rectangle request) async* {
  final normalizedRectangle = _normalize(request);
  // For each feature, check if it is in the given bounding box
  for (var feature in featuresDb) {
    if (feature.name.isEmpty) continue;
    final location = feature.location;
    if (_contains(normalizedRectangle, location)) {
      yield feature;
    }
  }
}

----------------------------------------

TITLE: Implementing Bidirectional Streaming RPC in Dart
DESCRIPTION: Example of implementing the RouteChat bidirectional streaming RPC method in the RouteGuide service.

LANGUAGE: Dart
CODE:
@override
Stream<RouteNote> routeChat(
    grpc.ServiceCall call, Stream<RouteNote> request) async* {
  await for (var note in request) {
    final notes = routeNotes.putIfAbsent(note.location, () => <RouteNote>[]);
    for (var note in notes) yield note;
    notes.add(note);
  }
}

----------------------------------------

TITLE: Performing Client Authorization Check with ALTS in gRPC C++
DESCRIPTION: This code demonstrates how to perform a client authorization check using ALTS in a gRPC C++ server. It uses the AltsClientAuthzCheck function to validate the client's service account.

LANGUAGE: cpp
CODE:
#include <grpcpp/server_context.h>
#include <grpcpp/security/alts_util.h>

grpc::ServerContext* context;
grpc::Status status = experimental::AltsClientAuthzCheck(
    context->auth_context(), {"foo@iam.gserviceaccount.com"});

----------------------------------------

TITLE: Calling a Bidirectional Streaming RPC from a Kotlin Client
DESCRIPTION: Demonstrates how to call the RouteChat method, sending and receiving streams of RouteNotes.

LANGUAGE: kotlin
CODE:
suspend fun routeChat() {
  val requests = generateOutgoingNotes()
  stub.routeChat(requests).collect { note ->
    println("Got message \"${note.message}\" at ${note.location.toStr()}")
  }
  println("Finished RouteChat")
}

private fun generateOutgoingNotes(): Flow<RouteNote> = flow {
  val notes = listOf(/* ... */)
  for (note in notes) {
    println("Sending message \"${note.message}\" at ${note.location.toStr()}")
    emit(note)
    delay(500)
  }
}

----------------------------------------

TITLE: Visualizing Deadline Propagation in gRPC with Mermaid
DESCRIPTION: This Mermaid sequence diagram illustrates the process of deadline propagation in a gRPC system involving a client, a user server, and a billing server. It demonstrates how deadlines are converted to timeouts and propagated across services, and how the system handles deadline expiration.

LANGUAGE: mermaid
CODE:
%%{init: { "sequence": { "mirrorActors": false }}}%%
sequenceDiagram
  participant c as Client
  participant us as User Server
  participant bs as Billing Server
  note right of c: Request at 13:00:00<br>Should complete in 2s
  activate c
  c ->> us: GetUserProfile<br>(deadline: 13:00:02)
  activate us
  note right of us: 0.5s spent before<br>calling billing server
  us ->> bs: GetTransactionHistory<br>(timeout: 1.5s)
  activate bs
  bs ->> bs: Retrieve transactions
  note left of bs: It's 13:00:02<br>Time's up!
  note right of c: Stop waiting for server
  c ->> c: Stop waiting for server<br>DEADLINE_EXCEEDED
  deactivate c
  us ->> us: Stop waiting for server
  us -->> c: Cancel
  deactivate us
  bs -->> us: Cancel
  bs ->> bs: Clean up resources<br>(after noticing that the<br>call was cancelled)
  deactivate bs

----------------------------------------

TITLE: Implementing Server Authentication with SSL/TLS in Node.js
DESCRIPTION: This Node.js example shows how to create a gRPC stub with server authentication using SSL/TLS credentials.

LANGUAGE: js
CODE:
const root_cert = fs.readFileSync('path/to/root-cert');
const ssl_creds = grpc.credentials.createSsl(root_cert);
const stub = new helloworld.Greeter('myservice.example.com', ssl_creds);

----------------------------------------

TITLE: Creating gRPC Client Stub in Dart
DESCRIPTION: Example of creating a gRPC client stub to perform RPCs in Dart.

LANGUAGE: Dart
CODE:
stub = RouteGuideClient(channel,
    options: CallOptions(timeout: Duration(seconds: 30)));

----------------------------------------

TITLE: Implementing Custom Unary Reactor for GetFeature on Server
DESCRIPTION: Demonstrates a custom implementation of ServerUnaryReactor for the GetFeature RPC, including handling for RPC completion and cancellation.

LANGUAGE: cpp
CODE:
grpc::ServerUnaryReactor* GetFeature(grpc::CallbackServerContext* context,
                                     const Point* point,
                                     Feature* feature) override {
  class Reactor : public grpc::ServerUnaryReactor {
   public:
    Reactor(const Point& point, const std::vector<Feature>& feature_list,
            Feature* feature) {
      feature->set_name(GetFeatureName(point, feature_list));
      *feature->mutable_location() = point;
      Finish(grpc::Status::OK);
    }

   private:
    void OnDone() override {
      LOG(INFO) << "RPC Completed";
      delete this;
    }

    void OnCancel() override { LOG(ERROR) << "RPC Cancelled"; }
  };
  return new Reactor(*point, feature_list_, feature);
}

----------------------------------------

TITLE: Implementing Server-Side Service Definition
DESCRIPTION: Base service implementation for handling gRPC requests on the server side

LANGUAGE: java
CODE:
  static abstract class KeyValueServiceImplBase implements BindableService {
    public abstract void create(
        KvGson.CreateRequest request, StreamObserver<CreateResponse> responseObserver);

    public abstract void retrieve(/*...*/);

    public abstract void update(/*...*/);

    public abstract void delete(/*...*/);

    @Override
    public final ServerServiceDefinition bindService() {
      ServerServiceDefinition.Builder ssd = ServerServiceDefinition.builder(SERVICE_NAME);
      ssd.addMethod(CREATE_METHOD, ServerCalls.asyncUnaryCall(
          (request, responseObserver) -> create(request, responseObserver)));

      ssd.addMethod(RETRIEVE_METHOD, /*...*/);
      ssd.addMethod(UPDATE_METHOD, /*...*/);
      ssd.addMethod(DELETE_METHOD, /*...*/);
      return ssd.build();
    }
  }

----------------------------------------

TITLE: Bidirectional Streaming Client Method in Go
DESCRIPTION: Client-side interface signature for bidirectional streaming RPC methods. Handles streams in both directions.

LANGUAGE: go
CODE:
Foo(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[*RequestMsg, *ResponseMsg], error)

----------------------------------------

TITLE: Implementing Simple RPC Server Method in Java
DESCRIPTION: Shows the implementation of the getFeature method in the RouteGuideService class, handling a simple RPC call.

LANGUAGE: Java
CODE:
@Override
public void getFeature(Point request, StreamObserver<Feature> responseObserver) {
  responseObserver.onNext(checkFeature(request));
  responseObserver.onCompleted();
}

----------------------------------------

TITLE: Expanding Stream Window for Large Messages in gRPC-Go
DESCRIPTION: Optimization that bypasses stream-level flow control to request whole messages when there's an active read by the application. Provides 10x improvement for large messages on high-latency networks.

LANGUAGE: go
CODE:
// Reference implementation: https://github.com/grpc/grpc-go/pull/1248

----------------------------------------

TITLE: Creating ALTS Client Credentials in gRPC C++
DESCRIPTION: This snippet demonstrates how to create ALTS client credentials for establishing a secure channel in a gRPC C++ client. It uses the AltsCredentials class with default options.

LANGUAGE: cpp
CODE:
#include <grpcpp/grpcpp.h>
#include <grpcpp/security/credentials.h>

using grpc::experimental::AltsCredentials;
using grpc::experimental::AltsCredentialsOptions;

auto creds = AltsCredentials(AltsCredentialsOptions());
std::shared_ptr<grpc::Channel> channel = CreateChannel(server_address, creds);

----------------------------------------

TITLE: Implementing Unary RPC GetFeature on Client
DESCRIPTION: Shows how to call the GetFeature unary RPC on the client side using the asynchronous callback API. It demonstrates setting up the request, handling the response, and managing the RPC lifecycle.

LANGUAGE: cpp
CODE:
bool GetOneFeature(const Point& point, Feature* feature) {
  ClientContext context;
  bool result;
  std::mutex mu;
  std::condition_variable cv;
  bool done = false;
  stub_->async()->GetFeature(
      &context, &point, feature,
      [&result, &mu, &cv, &done, feature, this](Status status) {
        bool ret;
        if (!status.ok()) {
          std::cout << "GetFeature rpc failed." << std::endl;
          ret = false;
        } else if (!feature->has_location()) {
          std::cout << "Server returns incomplete feature." << std::endl;
          ret = false;
        } else if (feature->name().empty()) {
          std::cout << "Found no feature at "
                    << feature->location().latitude() / kCoordFactor_ << ", "
                    << feature->location().longitude() / kCoordFactor_
                    << std::endl;
          ret = true;
        } else {
          std::cout << "Found feature called " << feature->name() << " at "
                    << feature->location().latitude() / kCoordFactor_ << ", "
                    << feature->location().longitude() / kCoordFactor_
                    << std::endl;
          ret = true;
        }
        std::lock_guard<std::mutex> lock(mu);
        result = ret;
        done = true;
        cv.notify_one();
      });
  std::unique_lock<std::mutex> lock(mu);
  cv.wait(lock, [&done] { return done; });
  return result;
}

----------------------------------------

TITLE: Client-Streaming Method Client Interface in Go
DESCRIPTION: Client-side interface signature for client streaming RPC methods. Sends stream of requests and receives single response.

LANGUAGE: go
CODE:
Foo(ctx context.Context, opts ...grpc.CallOption) (grpc.ClientStreamingClient[*RequestMsg, *ResponseMsg], error)

----------------------------------------

TITLE: Bidirectional Streaming Method Interface in Go
DESCRIPTION: Server-side interface signature for bidirectional streaming RPC methods. Handles streams of requests and responses in both directions.

LANGUAGE: go
CODE:
Foo(grpc.BidiStreamingServer[*RequestMsg, *ResponseMsg]) error

----------------------------------------

TITLE: Implementing Simple Unary Interceptor in JavaScript
DESCRIPTION: Example implementation of a UnaryInterceptor that modifies both request and response messages by prepending strings.

LANGUAGE: javascript
CODE:
/**
 * @constructor
 * @implements {UnaryInterceptor}
 */
const SimpleUnaryInterceptor = function() {};

/** @override */
SimpleUnaryInterceptor.prototype.intercept = function(request, invoker) {
  // Update the request message before the RPC.
  const reqMsg = request.getRequestMessage();
  reqMsg.setMessage('[Intercept request]' + reqMsg.getMessage());

  // After the RPC returns successfully, update the response.
  return invoker(request).then((response) => {
    // You can also do something with response metadata here.
    console.log(response.getMetadata());

    // Update the response message.
    const responseMsg = response.getResponseMessage();
    responseMsg.setMessage('[Intercept response]' + responseMsg.getMessage());

    return response;
  });
};

----------------------------------------

TITLE: Performing Client Authorization Check with ALTS in gRPC Go
DESCRIPTION: Executes a client authorization check against specified service accounts. Verifies client credentials against allowed service account identities.

LANGUAGE: go
CODE:
import (
  "google.golang.org/grpc"
  "google.golang.org/grpc/credentials/alts"
)

err := alts.ClientAuthorizationCheck(ctx, []string{"foo@iam.gserviceaccount.com"})

----------------------------------------

TITLE: Performing Client Authorization Check in ALTS Java Server
DESCRIPTION: This code demonstrates how to perform a client authorization check on the server side using ALTS. It uses the AuthorizationUtil class to verify the client's service account.

LANGUAGE: java
CODE:
import io.grpc.alts.AuthorizationUtil;
import io.grpc.ServerCall;
import io.grpc.Status;

ServerCall<?, ?> call;
Status status = AuthorizationUtil.clientAuthorizationCheck(
    call, Lists.newArrayList("foo@iam.gserviceaccount.com"));

----------------------------------------

TITLE: Unary Method Server Interface in Go
DESCRIPTION: Server-side interface signature for unary RPC methods. Handles single request and returns single response.

LANGUAGE: go
CODE:
Foo(context.Context, *RequestMsg) (*ResponseMsg, error)

----------------------------------------

TITLE: Client-Streaming Method Interface in Go
DESCRIPTION: Server-side interface signature for client streaming RPC methods. Handles stream of requests and returns single response.

LANGUAGE: go
CODE:
Foo(grpc.ClientStreamingServer[*RequestMsg, *ResponseMsg]) error

----------------------------------------

TITLE: Implementing Stream Interceptor in JavaScript
DESCRIPTION: Implementation of a StreamInterceptor that uses the InterceptedStream wrapper to handle streaming responses.

LANGUAGE: javascript
CODE:
/**
 * @constructor
 * @implements {StreamInterceptor}
 */
const TestStreamInterceptor = function() {};

/** @override */
TestStreamInterceptor.prototype.intercept = function(request, invoker) {
  return new InterceptedStream(invoker(request));
};

----------------------------------------

TITLE: State Diagram of Wait-for-Ready Behavior in gRPC
DESCRIPTION: This state diagram shows the different channel states and transitions in gRPC, including IDLE, CONNECTING, READY, TRANSIENT_FAILURE, and Permanent Failure. It illustrates how the Wait-for-Ready feature affects the behavior in different states.

LANGUAGE: mermaid
CODE:
stateDiagram-v2
   state "Initiating Communication" as IC
   state "Channel State" as CS
   IC-->CS: Check Channel State
   state CS {
      state "Permanent Failure" as PF
      state "TRANSIENT_FAILURE" as TF
      IDLE --> CONNECTING
      CONNECTING --> READY
      READY-->[*]
      CONNECTING-->TF
      CONNECTING-->PF
      TF-->READY
      TF -->[*]: without\n wait-for-ready
      TF-->PF
      PF-->[*]
   }
  state "MSG sent" as MS
  state "RPC Failed" as RF
  CS-->WAIT:From IDLE /\nCONNECTING
  CS-->WAIT:From Transient\nFailure with\nWait-for-Ready
  WAIT-->CS:State Change 
  CS-->MS: From READY
  CS-->RF: From Permanent failure or\nTransient Failure without\nWait-for-Ready
  MS-->[*]
  RF-->[*]

----------------------------------------

TITLE: Making a Simple RPC Call in C++
DESCRIPTION: Shows how to make a simple RPC call to the GetFeature method using the client stub. This includes creating the request and response objects, and handling the response.

LANGUAGE: cpp
CODE:
bool GetOneFeature(const Point& point, Feature* feature) {
  ClientContext context;
  Status status = stub_->GetFeature(&context, point, feature);
  if (status.IsOk()) {
    std::cout << "Found feature called " << feature->name()  << " at "
              << feature->location().latitude()/kCoordFactor_ << ", "
              << feature->location().longitude()/kCoordFactor_ << std::endl;
    return true;
  } else {
    std::cout << "GetFeature rpc failed." << std::endl;
    return false;
  }
}

----------------------------------------

TITLE: Implementing Server-side Streaming RPC in Java
DESCRIPTION: Demonstrates the implementation of the listFeatures method, which handles server-side streaming.

LANGUAGE: Java
CODE:
@Override
public void listFeatures(Rectangle request, StreamObserver<Feature> responseObserver) {
  int left = min(request.getLo().getLongitude(), request.getHi().getLongitude());
  int right = max(request.getLo().getLongitude(), request.getHi().getLongitude());
  int top = max(request.getLo().getLatitude(), request.getHi().getLatitude());
  int bottom = min(request.getLo().getLatitude(), request.getHi().getLatitude());

  for (Feature feature : features) {
    if (!RouteGuideUtil.exists(feature)) {
      continue;
    }

    int lat = feature.getLocation().getLatitude();
    int lon = feature.getLocation().getLongitude();
    if (lon >= left && lon <= right && lat >= bottom && lat <= top) {
      responseObserver.onNext(feature);
    }
  }
  responseObserver.onCompleted();
}

----------------------------------------

TITLE: Server-Streaming Method Interface in Go
DESCRIPTION: Server-side interface signature for server streaming RPC methods. Handles single request and streams multiple responses.

LANGUAGE: go
CODE:
Foo(*RequestMsg, grpc.ServerStreamingServer[*ResponseMsg]) error

----------------------------------------

TITLE: Implementing Server Authorization with ALTS in gRPC C++
DESCRIPTION: This snippet illustrates how to implement server authorization using ALTS in a gRPC C++ client. It sets target service accounts in the AltsCredentialsOptions for server validation.

LANGUAGE: cpp
CODE:
#include <grpcpp/grpcpp.h>
#include <grpcpp/security/credentials.h>

using grpc::experimental::AltsCredentials;
using grpc::experimental::AltsCredentialsOptions;

AltsCredentialsOptions opts;
opts.target_service_accounts.push_back("expected_server_service_account1");
opts.target_service_accounts.push_back("expected_server_service_account2");
auto creds = AltsCredentials(opts);
std::shared_ptr<grpc::Channel> channel = CreateChannel(server_address, creds);

----------------------------------------

TITLE: Implementing a gRPC Server in Node.js
DESCRIPTION: Shows how to implement and start a gRPC server for the RouteGuide service in Node.js.

LANGUAGE: javascript
CODE:
function getServer() {
  var server = new grpc.Server();
  server.addService(routeguide.RouteGuide.service, {
    getFeature: getFeature,
    listFeatures: listFeatures,
    recordRoute: recordRoute,
    routeChat: routeChat
  });
  return server;
}
var routeServer = getServer();
routeServer.bindAsync('0.0.0.0:50051', grpc.ServerCredentials.createInsecure(), () => {
  routeServer.start();
});

----------------------------------------

TITLE: Checking gRPC Deadlines in Go
DESCRIPTION: Shows how to check if a gRPC request has been cancelled on the server side in Go. It uses the Err method of the context to determine if the context has been cancelled.

LANGUAGE: go
CODE:
if ctx.Err() == context.Canceled {
	return status.New(codes.Canceled, "Client cancelled, abandoning.")
}

----------------------------------------

TITLE: Defining gRPC Service in Protocol Buffers
DESCRIPTION: Example of defining a gRPC service and its methods using Protocol Buffers syntax.

LANGUAGE: protobuf
CODE:
service RouteGuide {
   // Obtains the feature at a given position.
   rpc GetFeature(Point) returns (Feature) {}

   // Obtains the Features available within the given Rectangle.
   rpc ListFeatures(Rectangle) returns (stream Feature) {}

   // Accepts a stream of Points on a route being traversed, returning a RouteSummary.
   rpc RecordRoute(stream Point) returns (RouteSummary) {}

   // Accepts a stream of RouteNotes sent while a route is being traversed,
   // while receiving other RouteNotes.
   rpc RouteChat(stream RouteNote) returns (stream RouteNote) {}
}

----------------------------------------

TITLE: Visualizing gRPC Flow Control Sequence
DESCRIPTION: A sequence diagram showing the interaction between sender and receiver applications and their respective gRPC frameworks during flow control. It illustrates the message writing process, flow control waiting, message sending, and acknowledgment mechanisms.

LANGUAGE: mermaid
CODE:
sequenceDiagram
    participant SA as Sender Application
    participant SG as Sender gRPC Framework
    participant RG as Receiver gRPC Framework
    participant RA as Receiver Application
  
  SA-)+SG: Stream Write
  alt sending too fast
    SG--)SG: Wait
  end
  alt allowed to send
    SG--)-SA: Write call returns
    SG->>RG:Send Msg
  end
  RA->>RG: Request message
  Note right of RA:  Request can be done either<br>after or before message arrives
  RG->>RA: Provide message
  RG->>SG: Send Ack w/ msg size
  opt waiting messages
    SG->>RG: Send Next Msg
  end

----------------------------------------

TITLE: Visualizing gRPC Load Balancing Flow with Mermaid
DESCRIPTION: A flowchart diagram showing the relationship between Name Resolver, Load Balancer, Channel, Picker, and Subchannels in gRPC load balancing implementation.

LANGUAGE: mermaid
CODE:
flowchart TD
NR(Name Resolver) -->|Provides addresses &\nLB config| LB(Load Balancer)
LB --> |Provides a picker| C(Channel)
C -->|Requests\na subchannel| P(Picker)
LB --> |Manages subchannels\nto backends| SC(Subchannel 1..n)
LB -. Creates .-> P
P --> |Picks one| SC

----------------------------------------

TITLE: Setting gRPC Deadlines in C++
DESCRIPTION: Demonstrates how to set a 100ms deadline for a gRPC client request using C++. It uses the ClientContext and chrono library to set a time point 100 milliseconds in the future.

LANGUAGE: cpp
CODE:
ClientContext context;
time_point deadline = std::chrono::system_clock::now() +
    std::chrono::milliseconds(100);
context.set_deadline(deadline);

----------------------------------------

TITLE: Implementing Simple RPC Method
DESCRIPTION: Python implementation of a simple RPC method that takes a Point and returns a Feature.

LANGUAGE: python
CODE:
def GetFeature(self, request, context):
    feature = get_feature(self.db, request)
    if feature is None:
        return route_guide_pb2.Feature(name="", location=request)
    else:
        return feature

----------------------------------------

TITLE: Implementing Bidirectional Streaming RPC RouteChat on Client
DESCRIPTION: Shows how to implement the client-side logic for the RouteChat bidirectional streaming RPC using a ClientBidiReactor. It demonstrates how to send multiple messages and handle multiple responses.

LANGUAGE: cpp
CODE:
class Chatter : public grpc::ClientBidiReactor<RouteNote, RouteNote> {
 public:
  explicit Chatter(RouteGuide::Stub* stub)
      : notes_{MakeRouteNote("First message", 0, 0),
               MakeRouteNote("Second message", 0, 1),
               MakeRouteNote("Third message", 1, 0),
               MakeRouteNote("Fourth message", 0, 0)},
        notes_iterator_(notes_.begin()) {
    stub->async()->RouteChat(&context_, this);
    NextWrite();
    StartRead(&server_note_);
    StartCall();
  }
  void OnWriteDone(bool ok) override {
    if (ok) {
      NextWrite();
    }
  }
  void OnReadDone(bool ok) override {
    if (ok) {
      std::cout << "Got message " << server_note_.message() << " at "
                << server_note_.location().latitude() << ", "
                << server_note_.location().longitude() << std::endl;
      StartRead(&server_note_);
    }
  }
  void OnDone(const Status& s) override {
    std::unique_lock<std::mutex> l(mu_);
    status_ = s;
    done_ = true;
    cv_.notify_one();
  }
  Status Await() {
    std::unique_lock<std::mutex> l(mu_);
    cv_.wait(l, [this] { return done_; });
    return std::move(status_);
  }

 private:
  void NextWrite() {
    if (notes_iterator_ != notes_.end()) {
      const auto& note = *notes_iterator_;
      std::cout << "Sending message " << note.message() << " at "
                << note.location().latitude() << ", "
                << note.location().longitude() << std::endl;
      StartWrite(&note);
      notes_iterator_++;
    } else {
      StartWritesDone();
    }
  }
  ClientContext context_;
  const std::vector<RouteNote> notes_;
  std::vector<RouteNote>::const_iterator notes_iterator_;
  RouteNote server_note_;
  std::mutex mu_;
  std::condition_variable cv_;
  Status status_;
  bool done_ = false;
};

----------------------------------------

TITLE: Creating ALTS Client Credentials in gRPC Python
DESCRIPTION: Demonstrates how to create and configure ALTS channel credentials for a gRPC client. The code establishes a secure channel using ALTS authentication.

LANGUAGE: python
CODE:
import grpc

channel_creds = grpc.alts_channel_credentials()
channel = grpc.secure_channel(address, channel_creds)

----------------------------------------

TITLE: Creating and Starting a gRPC Server in Kotlin
DESCRIPTION: Creates a gRPC server instance, adds the RouteGuide service, and starts the server.

LANGUAGE: kotlin
CODE:
class RouteGuideServer(
    val port: Int,
    val features: Collection<Feature> = Database.features(),
    val server: Server =
      ServerBuilder.forPort(port)
        .addService(RouteGuideService(features)).build()
) {

  fun start() {
    server.start()
    println("Server started, listening on $port")
    /* ... */
  }
  /* ... */
}

fun main(args: Array<String>) {
  val port = 8980
  val server = RouteGuideServer(port)
  server.start()
  server.awaitTermination()
 }

----------------------------------------

TITLE: Creating an Insecure gRPC Connection in PHP
DESCRIPTION: This PHP snippet shows how to create a gRPC client without any encryption or authentication.

LANGUAGE: php
CODE:
$client = new helloworld\GreeterClient('localhost:50051', [
    'credentials' => Grpc\ChannelCredentials::createInsecure(),
]);

----------------------------------------

TITLE: Implementing Server-Streaming RPC ListFeatures on Server
DESCRIPTION: Demonstrates the implementation of the ListFeatures server-streaming RPC on the server side using a ServerWriteReactor. It shows how to handle writing multiple responses and finishing the RPC.

LANGUAGE: cpp
CODE:
grpc::ServerWriteReactor<Feature>* ListFeatures(
    CallbackServerContext* context,
    const routeguide::Rectangle* rectangle) override {
  class Lister : public grpc::ServerWriteReactor<Feature> {
   public:
    Lister(const routeguide::Rectangle* rectangle,
           const std::vector<Feature>* feature_list)
        : left_((std::min)(rectangle->lo().longitude(),
                           rectangle->hi().longitude())),
          right_((std::max)(rectangle->lo().longitude(),
                            rectangle->hi().longitude())),
          top_((std::max)(rectangle->lo().latitude(),
                          rectangle->hi().latitude())),
          bottom_((std::min)(rectangle->lo().latitude(),
                             rectangle->hi().latitude())),
          feature_list_(feature_list),
          next_feature_(feature_list_->begin()) {
      NextWrite();
    }

    void OnWriteDone(bool ok) override {
      if (!ok) {
        Finish(Status(grpc::StatusCode::UNKNOWN, "Unexpected Failure"));
      }
      NextWrite();
    }

    void OnDone() override {
      LOG(INFO) << "RPC Completed";
      delete this;
    }

    void OnCancel() override { LOG(ERROR) << "RPC Cancelled"; }

   private:
    void NextWrite() {
      while (next_feature_ != feature_list_->end()) {
        const Feature& f = *next_feature_;
        next_feature_++;
        if (f.location().longitude() >= left_ &&
            f.location().longitude() <= right_ &&
            f.location().latitude() >= bottom_ &&
            f.location().latitude() <= top_) {
          StartWrite(&f);
          return;
        }
      }
      // Didn't write anything, all is done.
      Finish(Status::OK);
    }
    const long left_;
    const long right_;
    const long top_;
    const long bottom_;
    const std::vector<Feature>* feature_list_;
    std::vector<Feature>::const_iterator next_feature_;
  };
  return new Lister(rectangle, &feature_list_);
}

----------------------------------------

TITLE: RPC Cancellation Sequence Diagram
DESCRIPTION: A sequence diagram showing the propagation of cancellation from client through multiple servers.

LANGUAGE: mermaid
CODE:
sequenceDiagram
  Client ->> Server 1: Cancel
  Server 1 ->> Server 2: Cancel

----------------------------------------

TITLE: Implementing Server Authorization with ALTS in gRPC Go
DESCRIPTION: Configures ALTS client credentials with specific target service accounts for server authorization. Creates a client connection with enhanced security validation.

LANGUAGE: go
CODE:
import (
  "google.golang.org/grpc"
  "google.golang.org/grpc/credentials/alts"
)

clientOpts := alts.DefaultClientOptions()
clientOpts.TargetServiceAccounts = []string{expectedServerSA}
altsTC := alts.NewClientCreds(clientOpts)
conn, err := grpc.NewClient(serverAddr, grpc.WithTransportCredentials(altsTC))

----------------------------------------

TITLE: Using Generic Stub in C++ gRPC
DESCRIPTION: Demonstrates the use of gRPC::GenericStub for sending raw ByteBuffer data, which can be beneficial in cases of high contention or CPU-intensive proto serialization.

LANGUAGE: C++
CODE:
gRPC::GenericStub

----------------------------------------

TITLE: Calling a Server-Side Streaming RPC from a Kotlin Client
DESCRIPTION: Demonstrates how to call the ListFeatures method and process the stream of responses.

LANGUAGE: kotlin
CODE:
suspend fun listFeatures(lowLat: Int, lowLon: Int, hiLat: Int, hiLon: Int) {
  val request = Rectangle.newBuilder()
    .setLo(point(lowLat, lowLon))
    .setHi(point(hiLat, hiLon))
    .build()
  var i = 1
  stub.listFeatures(request).collect { feature ->
    println("Result #${i++}: $feature")
  }
}

----------------------------------------

TITLE: Installing Go plugins for protocol compiler
DESCRIPTION: Commands to install the protocol compiler plugins for Go and update the PATH to include the plugins.

LANGUAGE: sh
CODE:
go install google.golang.org/protobuf/cmd/protoc-gen-go@latest
go install google.golang.org/grpc/cmd/protoc-gen-go-grpc@latest

LANGUAGE: sh
CODE:
export PATH="$PATH:$(go env GOPATH)/bin"

----------------------------------------

TITLE: Creating a gRPC Client Stub in Kotlin
DESCRIPTION: Creates a gRPC channel and client stub for the RouteGuide service.

LANGUAGE: kotlin
CODE:
val channel = ManagedChannelBuilder.forAddress("localhost", 8980).usePlaintext().build()
val stub = RouteGuideCoroutineStub(channel)

----------------------------------------

TITLE: Configuring ALTS Client Credentials in gRPC Go
DESCRIPTION: Sets up ALTS transport credentials for a gRPC client using default options. Creates a secure client connection using the configured ALTS credentials.

LANGUAGE: go
CODE:
import (
  "google.golang.org/grpc"
  "google.golang.org/grpc/credentials/alts"
)

altsTC := alts.NewClientCreds(alts.DefaultClientOptions())
conn, err := grpc.NewClient(serverAddr, grpc.WithTransportCredentials(altsTC))

----------------------------------------

TITLE: Configuring Single-Threaded Unary-Stream in Python gRPC
DESCRIPTION: Sets an experimental channel option for single-threaded unary-stream implementation in Python gRPC, potentially improving message latency by up to 7%.

LANGUAGE: Python
CODE:
SingleThreadedUnaryStream

----------------------------------------

TITLE: Calling Bidirectional Streaming RPC in Dart
DESCRIPTION: Example of calling the RouteChat bidirectional streaming RPC method from a Dart client.

LANGUAGE: Dart
CODE:
Stream<RouteNote> outgoingNotes = ...;

final responses = stub.routeChat(outgoingNotes);
await for (var note in responses) {
  print('Got message ${note.message} at ${note.location.latitude}, ${note
      .location.longitude}');
}

----------------------------------------

TITLE: Updating the Client's Main Function
DESCRIPTION: Modifies the main function to call both 'SayHello' and 'SayHelloAgain' methods.

LANGUAGE: cpp
CODE:
int main(int argc, char** argv) {
  // ...
  std::string reply = greeter.SayHello(user);
  std::cout << "Greeter received: " << reply << std::endl;

  reply = greeter.SayHelloAgain(user);
  std::cout << "Greeter received: " << reply << std::endl;

  return 0;
}

----------------------------------------

TITLE: Accessing Flatbuffers gRPC Request in C++
DESCRIPTION: This snippet shows how to access data from a Flatbuffers-encoded gRPC request in C++. It demonstrates direct access to the flat object in the underlying gRPC slice.

LANGUAGE: cpp
CODE:
auto request = request_msg->GetRoot();
auto name = request->name()->str();

----------------------------------------

TITLE: Setting up ALTS Server Credentials in Java
DESCRIPTION: This code shows how to create a gRPC server with ALTS authentication using AltsServerBuilder. It requires the io.grpc.alts package and a custom service implementation.

LANGUAGE: java
CODE:
import io.grpc.alts.AltsServerBuilder;
import io.grpc.Server;

Server server = AltsServerBuilder.forPort(<port>)
    .addService(new MyServiceImpl()).build().start();

----------------------------------------

TITLE: Initializing ALTS Client Channel in Java
DESCRIPTION: This snippet demonstrates how to create a ManagedChannel using AltsChannelBuilder for ALTS authentication in a gRPC Java client. It requires the io.grpc.alts package.

LANGUAGE: java
CODE:
import io.grpc.alts.AltsChannelBuilder;
import io.grpc.ManagedChannel;

ManagedChannel managedChannel =
    AltsChannelBuilder.forTarget(serverAddress).build();

----------------------------------------

TITLE: Implementing Node.js gRPC Backend Server
DESCRIPTION: JavaScript implementation of the Echo service handler in Node.js backend server.

LANGUAGE: javascript
CODE:
function doEcho(call, callback) {
  callback(null, {message: call.request.message});
}

----------------------------------------

TITLE: Building the Example (Linux/macOS)
DESCRIPTION: Builds the Hello World example on Linux or macOS systems.

LANGUAGE: shell
CODE:
cd examples/cpp/helloworld
mkdir -p cmake/build
pushd cmake/build
cmake -DCMAKE_PREFIX_PATH=$MY_INSTALL_DIR ../..
make -j 4

----------------------------------------

TITLE: Implementing gRPC Server Methods in Node.js
DESCRIPTION: Node.js code implementing the sayHello and sayHelloAgain methods on the gRPC server.

LANGUAGE: js
CODE:
function sayHello(call, callback) {
  callback(null, {message: 'Hello ' + call.request.name});
}

function sayHelloAgain(call, callback) {
  callback(null, {message: 'Hello again, ' + call.request.name});
}

function main() {
  var server = new grpc.Server();
  server.addService(hello_proto.Greeter.service,
                         {sayHello: sayHello, sayHelloAgain: sayHelloAgain});
  server.bindAsync('0.0.0.0:50051', grpc.ServerCredentials.createInsecure(), () => {
    server.start();
  });
}

----------------------------------------

TITLE: Implementing a Simple RPC Method in Kotlin
DESCRIPTION: Implements the GetFeature method, which takes a Point and returns a Feature.

LANGUAGE: kotlin
CODE:
override suspend fun getFeature(request: Point): Feature =
    features.find { it.location == request } ?:
    // No feature was found, return an unnamed feature.
    Feature.newBuilder().apply { location = request }.build()

----------------------------------------

TITLE: Configuring ALTS Server Credentials in gRPC Go
DESCRIPTION: Initializes ALTS transport credentials for a gRPC server using default options. Creates a new gRPC server instance with the configured ALTS credentials.

LANGUAGE: go
CODE:
import (
  "google.golang.org/grpc"
  "google.golang.org/grpc/credentials/alts"
)

altsTC := alts.NewServerCreds(alts.DefaultServerOptions())
server := grpc.NewServer(grpc.Creds(altsTC))

----------------------------------------

TITLE: Implementing gRPC Client in Go
DESCRIPTION: Implementation of the RouteGuide client in Go, demonstrating how to make RPC calls using the generated client stub.

LANGUAGE: go
CODE:
var opts []grpc.DialOption
conn, err := grpc.NewClient(*serverAddr, opts...)
if err != nil {
  ...
}
defer conn.Close()
client := pb.NewRouteGuideClient(conn)

feature, err := client.GetFeature(context.Background(), &pb.Point{409146138, -746188906})

----------------------------------------

TITLE: Setting Environment Variables for gRPC Installation (Windows)
DESCRIPTION: Sets up environment variables for the gRPC installation directory and updates the PATH on Windows.

LANGUAGE: powershell
CODE:
set MY_INSTALL_DIR=%USERPROFILE%\cmake
mkdir %INSTALL_DIR%
set PATH=%PATH%;$MY_INSTALL_DIR\bin

----------------------------------------

TITLE: Initial gRPC Service Definition
DESCRIPTION: Protocol buffer definition for the basic Greeter service with a single SayHello method

LANGUAGE: protobuf
CODE:
// The greeting service definition.
service Greeter {
  // Sends a greeting
  rpc SayHello (HelloRequest) returns (HelloReply) {}
}

// The request message containing the user's name.
message HelloRequest {
  string name = 1;
}

// The response message containing the greetings
message HelloReply {
  string message = 1;
}

----------------------------------------

TITLE: Implementing a Server-Side Streaming RPC in Kotlin
DESCRIPTION: Implements the ListFeatures method, which takes a Rectangle and returns a stream of Features.

LANGUAGE: kotlin
CODE:
override fun listFeatures(request: Rectangle): Flow<Feature> =
  features.asFlow().filter { it.exists() && it.location in request }

----------------------------------------

TITLE: Implementing Google Token-Based Authentication in C++
DESCRIPTION: This example shows how to use Google's default credentials for authentication in C++. It's suitable for applications using Service Accounts or running in Google Compute Engine.

LANGUAGE: cpp
CODE:
auto creds = grpc::GoogleDefaultCredentials();
// Create a channel, stub and make RPC calls (same as in the previous example)
auto channel = grpc::CreateChannel(server_name, creds);
std::unique_ptr<Greeter::Stub> stub(Greeter::NewStub(channel));
grpc::Status s = stub->sayHello(&context, *request, response);

----------------------------------------

TITLE: Visualizing gRPC Server State Transitions during Shutdown using Mermaid
DESCRIPTION: This state diagram shows the different states a gRPC server goes through during the shutdown process. It illustrates the transition from serving to graceful shutdown, and then to either terminated state or forceful shutdown based on timeout conditions.

LANGUAGE: mermaid
CODE:
stateDiagram-v2
    [*] --> SERVING : Server Started
    SERVING --> GRACEFUL_SHUTDOWN : Graceful Shutdown Called (with Timeout)
    GRACEFUL_SHUTDOWN --> TERMINATED : In-Flight RPCs Completed (Before Timeout)
    GRACEFUL_SHUTDOWN --> TIMER_EXPIRED : Timeout Reached
    TIMER_EXPIRED --> TERMINATED : Forceful Shutdown Called

----------------------------------------

TITLE: Implementing gRPC Unary Call Benchmarking in Java
DESCRIPTION: This snippet demonstrates how to implement gRPC unary call benchmarking in Java. It creates a stub to send unary calls, measures latency, and repeats the process for 60 seconds. The code uses StreamObserver to handle responses and errors, and records latencies in microseconds.

LANGUAGE: java
CODE:
// This can be found in AsyncClient.java doUnaryCalls()
// Make stub to send unary call
final BenchmarkServiceStub stub = BenchmarkServiceGrpc.newStub(channel);
stub.unaryCall(request, new StreamObserver<SimpleResponse>() {
    long lastCall = System.nanoTime();
    // Do nothing on next
    @Override
    public void onNext(SimpleResponse value) {
    }

    @Override
    public void onError(Throwable t) {
        Status status = Status.fromThrowable(t);
        System.err.println("Encountered an error in unaryCall. Status is " + status);
        t.printStackTrace();

        future.cancel(true);
    }
    // Repeat if time isn't reached
    @Override
    public void onCompleted() {
        long now = System.nanoTime();
        // Record the latencies in microseconds
        histogram.recordValue((now - lastCall) / 1000);
        lastCall = now;

        Context prevCtx = Context.ROOT.attach();
        try {
            if (endTime > now) {
                stub.unaryCall(request, this);
            } else {
                future.done();
            }
        } finally {
            Context.current().detach(prevCtx);
        }
    }
});

----------------------------------------

TITLE: Creating a gRPC Client in Node.js
DESCRIPTION: Demonstrates how to create a gRPC client stub and call various types of RPC methods in Node.js.

LANGUAGE: javascript
CODE:
var stub = new routeguide.RouteGuide('localhost:50051', grpc.credentials.createInsecure());

// Simple RPC
var point = {latitude: 409146138, longitude: -746188906};
stub.getFeature(point, function(err, feature) {
  if (err) {
    // process error
  } else {
    // process feature
  }
});

// Server-side streaming RPC
var call = client.listFeatures(rectangle);
call.on('data', function(feature) {
  console.log('Found feature called "' + feature.name + '" at ' +
      feature.location.latitude/COORD_FACTOR + ', ' +
      feature.location.longitude/COORD_FACTOR);
});

// Client-side streaming RPC
var call = client.recordRoute(function(error, stats) {
  if (error) {
    callback(error);
  }
  console.log('Finished trip with', stats.point_count, 'points');
});

// Bidirectional streaming RPC
var call = client.routeChat();

----------------------------------------

TITLE: Implementing gRPC Service Methods in Dart Server
DESCRIPTION: Dart code implementing the SayHello and SayHelloAgain methods in the GreeterService class for the gRPC server.

LANGUAGE: dart
CODE:
class GreeterService extends GreeterServiceBase {
  @override
  Future<HelloReply> sayHello(ServiceCall call, HelloRequest request) async {
    return HelloReply()..message = 'Hello, ${request.name}!';
  }

  @override
  Future<HelloReply> sayHelloAgain(ServiceCall call, HelloRequest request) async {
    return HelloReply()..message = 'Hello again, ${request.name}!';
  }
}

----------------------------------------

TITLE: Implementing Server Authentication with SSL/TLS in Ruby
DESCRIPTION: This Ruby example demonstrates how to create a gRPC stub with server authentication using SSL/TLS credentials.

LANGUAGE: ruby
CODE:
creds = GRPC::Core::ChannelCredentials.new(load_certs)  # load_certs typically loads a CA roots file
stub = Helloworld::Greeter::Stub.new('myservice.example.com', creds)

----------------------------------------

TITLE: Configuring gRPC Retry Throttling in JSON
DESCRIPTION: An example JSON configuration for gRPC retry throttling, which helps prevent server overload due to retries by specifying maximum tokens and token ratio.

LANGUAGE: json
CODE:
"retryThrottling": {
  "maxTokens": 10,
  "tokenRatio": 0.1
}

----------------------------------------

TITLE: Installing Recent CMake Version on Linux
DESCRIPTION: Downloads and installs a recent version of CMake on Linux systems.

LANGUAGE: shell
CODE:
wget -q -O cmake-linux.sh https://github.com/Kitware/CMake/releases/download/v3.30.3/cmake-3.30.3-linux-x86_64.sh
sh cmake-linux.sh -- --skip-license --prefix=$MY_INSTALL_DIR
rm cmake-linux.sh

----------------------------------------

TITLE: Defining gRPC Service in Protocol Buffers
DESCRIPTION: Protocol buffer definition for a simple greeting service with SayHello and SayHelloAgain methods.

LANGUAGE: protobuf
CODE:
service Greeter {
  rpc SayHello (HelloRequest) returns (HelloReply) {}
  rpc SayHelloAgain (HelloRequest) returns (HelloReply) {}
}

message HelloRequest {
  string name = 1;
}

message HelloReply {
  string message = 1;
}

----------------------------------------

TITLE: Creating gRPC Client Stub in Go
DESCRIPTION: Function signature for creating a client stub for a gRPC service, which returns a concrete implementation of the client interface.

LANGUAGE: Go
CODE:
func BarClient(cc *grpc.ClientConn) BarClient

----------------------------------------

TITLE: Implementing Google Authentication in Node.js
DESCRIPTION: This Node.js code demonstrates how to authenticate with Google services using a combination of SSL credentials and Google's application default credentials.

LANGUAGE: js
CODE:
var GoogleAuth = require('google-auth-library'); // from https://www.npmjs.com/package/google-auth-library
...
var ssl_creds = grpc.credentials.createSsl(root_certs);
(new GoogleAuth()).getApplicationDefault(function(err, auth) {
  var call_creds = grpc.credentials.createFromGoogleCredential(auth);
  var combined_creds = grpc.credentials.combineChannelCredentials(ssl_creds, call_creds);
  var stub = new helloworld.Greeter('greeter.googleapis.com', combined_credentials);
});

----------------------------------------

TITLE: Defining UnaryInterceptor Interface in JavaScript
DESCRIPTION: Declaration of the UnaryInterceptor interface with an intercept method that handles request manipulation and response processing for unary RPCs.

LANGUAGE: javascript
CODE:
/*
* @interface
*/
const UnaryInterceptor = function() {};

/**
 * @template REQUEST, RESPONSE
 * @param {!Request<REQUEST, RESPONSE>} request
 * @param {function(!Request<REQUEST,RESPONSE>):!Promise<!UnaryResponse<RESPONSE>>}
 *     invoker
 * @return {!Promise<!UnaryResponse<RESPONSE>>}
 */
UnaryInterceptor.prototype.intercept = function(request, invoker) {};

----------------------------------------

TITLE: Defining gRPC Service in Protocol Buffers
DESCRIPTION: Example of defining a gRPC service and its methods using Protocol Buffers syntax.

LANGUAGE: proto
CODE:
option java_package = "io.grpc.examples";

service RouteGuide {
   ...
}

rpc GetFeature(Point) returns (Feature) {}

rpc ListFeatures(Rectangle) returns (stream Feature) {}

rpc RecordRoute(stream Point) returns (RouteSummary) {}

rpc RouteChat(stream RouteNote) returns (stream RouteNote) {}

----------------------------------------

TITLE: Updating the gRPC Server Implementation
DESCRIPTION: Implements the new 'SayHelloAgain' method in the server's C++ code.

LANGUAGE: cpp
CODE:
class GreeterServiceImpl final : public Greeter::Service {
  Status SayHello(ServerContext* context, const HelloRequest* request,
                  HelloReply* reply) override {
     // ...
  }

  Status SayHelloAgain(ServerContext* context, const HelloRequest* request,
                       HelloReply* reply) override {
    std::string prefix("Hello again ");
    reply->set_message(prefix + request->name());
    return Status::OK;
  }
};

----------------------------------------

TITLE: Implementing SayHelloAgain method in Go server
DESCRIPTION: Go function implementing the new SayHelloAgain method for the gRPC server.

LANGUAGE: go
CODE:
func (s *server) SayHelloAgain(ctx context.Context, in *pb.HelloRequest) (*pb.HelloReply, error) {
        return &pb.HelloReply{Message: "Hello again " + in.GetName()}, nil
}

----------------------------------------

TITLE: Implementing Google Authentication in Dart
DESCRIPTION: This Dart code demonstrates how to authenticate with Google services using a service account JSON file for credentials.

LANGUAGE: dart
CODE:
// Uses publicly trusted roots by default.
final channel = new ClientChannel('greeter.googleapis.com');
final serviceAccountJson =
     new File('service-account.json').readAsStringSync();
final credentials = new JwtServiceAccountAuthenticator(serviceAccountJson);
final client =
    new GreeterClient(channel, options: credentials.toCallOptions);

----------------------------------------

TITLE: Implementing Stream Wrapper for Interceptors in JavaScript
DESCRIPTION: Implementation of a ClientReadableStream wrapper that intercepts and modifies streaming responses.

LANGUAGE: javascript
CODE:
/**
 * A ClientReadableStream wrapper.
 *
 * @template RESPONSE
 * @implements {ClientReadableStream}
 * @constructor
 * @param {!ClientReadableStream<RESPONSE>} stream
 */
const InterceptedStream = function(stream) {
  this.stream = stream;
};

/** @override */
InterceptedStream.prototype.on = function(eventType, callback) {
  if (eventType == 'data') {
    const newCallback = (response) => {
      // Update the response message.
      const msg = response.getMessage();
      response.setMessage('[Intercept response]' + msg);
      // Pass along the updated response.
      callback(response);
    };
    // Register the new callback.
    this.stream.on(eventType, newCallback);
  } else {
    // You can also override 'status', 'end', and 'error' eventTypes.
    this.stream.on(eventType, callback);
  }
  return this;
};

/** @override */
InterceptedStream.prototype.cancel = function() {
  this.stream.cancel();
  return this;
};

----------------------------------------

TITLE: Defining Protocol Buffer Message Type
DESCRIPTION: Example of defining a Protocol Buffer message type Point for use in the RouteGuide service.

LANGUAGE: Protocol Buffers
CODE:
message Point {
  int32 latitude = 1;
  int32 longitude = 2;
}

----------------------------------------

TITLE: Defining gRPC Service in Protocol Buffers
DESCRIPTION: Example of a simple gRPC service definition using Protocol Buffers.

LANGUAGE: protobuf
CODE:
option objc_class_prefix = "AUTH";

service TestService {
  rpc UnaryCall(Request) returns (Response);
}

----------------------------------------

TITLE: Updating Go client to call SayHelloAgain
DESCRIPTION: Go code to add a call to the new SayHelloAgain method in the gRPC client.

LANGUAGE: go
CODE:
r, err = c.SayHelloAgain(ctx, &pb.HelloRequest{Name: *name})
if err != nil {
        log.Fatalf("could not greet: %v", err)
}
log.Printf("Greeting: %s", r.GetMessage())

----------------------------------------

TITLE: Creating gRPC Service Client in Objective-C
DESCRIPTION: Initialization of the RouteGuide service client with server connection settings and transport options.

LANGUAGE: objective-c
CODE:
static NSString * const kHostAddress = @"localhost:50051";
...
GRPCMutableCallOptions *options = [[GRPCMutableCallOptions alloc] init];
options.transport = GRPCDefaultTransportImplList.core_insecure;

RTGRouteGuide *service = [[RTGRouteGuide alloc] initWithHost:kHostAddress callOptions:options];

----------------------------------------

TITLE: Synchronized Key-Value Store Implementation
DESCRIPTION: Initial implementation using synchronized keyword to protect HashMap operations, limiting concurrent access.

LANGUAGE: java
CODE:
private final Map<ByteBuffer, ByteBuffer> store = new HashMap<>();

@Override
public synchronized void create(
    CreateRequest request, StreamObserver<CreateResponse> responseObserver) {
  ByteBuffer key = request.getKey().asReadOnlyByteBuffer();
  ByteBuffer value = request.getValue().asReadOnlyByteBuffer();
  simulateWork(WRITE_DELAY_MILLIS);
  if (store.putIfAbsent(key, value) == null) {
    responseObserver.onNext(CreateResponse.getDefaultInstance());
    responseObserver.onCompleted();
    return;
  }
  responseObserver.onError(Status.ALREADY_EXISTS.asRuntimeException());
}

----------------------------------------

TITLE: Server-Streaming Server Interface in Go
DESCRIPTION: Interface for the server-side handler of a server-streaming RPC, providing methods to send messages to the client.

LANGUAGE: Go
CODE:
type <ServiceName>_FooServer interface {
	Send(*MsgB) error
	grpc.ServerStream
}

----------------------------------------

TITLE: Defining gRPC Service in Protocol Buffers
DESCRIPTION: Protocol Buffer definition for the Greeter service with SayHello and SayHelloAgain methods.

LANGUAGE: proto
CODE:
// The greeting service definition.
service Greeter {
  // Sends a greeting
  rpc SayHello (HelloRequest) returns (HelloReply) {}
  // Sends another greeting
  rpc SayHelloAgain (HelloRequest) returns (HelloReply) {}
}

// The request message containing the user's name.
message HelloRequest {
  string name = 1;
}

// The response message containing the greetings
message HelloReply {
  string message = 1;
}

----------------------------------------

TITLE: Defining gRPC Service in Protocol Buffers
DESCRIPTION: Protocol Buffers definition for the Greeter service with SayHello and SayHelloAgain methods.

LANGUAGE: protobuf
CODE:
// The greeting service definition.
service Greeter {
  // Sends a greeting
  rpc SayHello (HelloRequest) returns (HelloReply) {}
  // Sends another greeting
  rpc SayHelloAgain (HelloRequest) returns (HelloReply) {}
}

// The request message containing the user's name.
message HelloRequest {
  string name = 1;
}

// The response message containing the greetings
message HelloReply {
  string message = 1;
}

----------------------------------------

TITLE: Maven Configuration for gRPC Code Generation
DESCRIPTION: Example Maven configuration using protobuf-maven-plugin to generate gRPC and Protocol Buffers code.

LANGUAGE: xml
CODE:
<build>
  <extensions>
    <extension>
      <groupId>kr.motd.maven</groupId>
      <artifactId>os-maven-plugin</artifactId>
      <version>1.4.1.Final</version>
    </extension>
  </extensions>
  <plugins>
    <plugin>
      <groupId>org.xolstice.maven.plugins</groupId>
      <artifactId>protobuf-maven-plugin</artifactId>
      <version>0.5.0</version>
      <configuration>
        <protocArtifact>com.google.protobuf:protoc:3.3.0:exe:${os.detected.classifier}</protocArtifact>
        <pluginId>grpc-java</pluginId>
        <pluginArtifact>io.grpc:protoc-gen-grpc-java:1.4.0:exe:${os.detected.classifier}</pluginArtifact>
      </configuration>
      <executions>
        <execution>
          <goals>
            <goal>compile</goal>
            <goal>compile-custom</goal>
          </goals>
        </execution>
      </executions>
    </plugin>
  </plugins>
</build>

----------------------------------------

TITLE: Implementing Server-Side gRPC Handler
DESCRIPTION: Server implementation of the Create operation handler using synchronized access to protect concurrent modifications. Simulates disk I/O with artificial delays.

LANGUAGE: java
CODE:
private final Map<ByteBuffer, ByteBuffer> store = new HashMap<>();

@Override
public synchronized void create(
    CreateRequest request, StreamObserver<CreateResponse> responseObserver) {
  ByteBuffer key = request.getKey().asReadOnlyByteBuffer();
  ByteBuffer value = request.getValue().asReadOnlyByteBuffer();
  simulateWork(WRITE_DELAY_MILLIS);
  if (store.putIfAbsent(key, value) == null) {
    responseObserver.onNext(CreateResponse.getDefaultInstance());
    responseObserver.onCompleted();
    return;
  }
  responseObserver.onError(Status.ALREADY_EXISTS.asRuntimeException());
}

----------------------------------------

TITLE: Concurrent Key-Value Store Implementation
DESCRIPTION: Optimized implementation using ConcurrentHashMap to allow concurrent operations on different keys.

LANGUAGE: java
CODE:
private final ConcurrentMap<ByteBuffer, ByteBuffer> store = new ConcurrentHashMap<>();

@Override
public void create(
    CreateRequest request, StreamObserver<CreateResponse> responseObserver) {
  ByteBuffer key = request.getKey().asReadOnlyByteBuffer();
  ByteBuffer value = request.getValue().asReadOnlyByteBuffer();
  simulateWork(WRITE_DELAY_MILLIS);
  if (store.putIfAbsent(key, value) == null) {
    responseObserver.onNext(CreateResponse.getDefaultInstance());
    responseObserver.onCompleted();
    return;
  }
  responseObserver.onError(Status.ALREADY_EXISTS.asRuntimeException());
}

----------------------------------------

TITLE: Installing Protoc on MacOS using Homebrew
DESCRIPTION: Commands to install the protocol buffer compiler on MacOS systems using the Homebrew package manager and verify the installed version.

LANGUAGE: sh
CODE:
brew install protobuf
protoc --version  # Ensure compiler version is 3+

----------------------------------------

TITLE: Defining gRPC service in Protocol Buffers
DESCRIPTION: Protocol Buffer definition for the Greeter service with SayHello and SayHelloAgain methods.

LANGUAGE: protobuf
CODE:
// The greeting service definition.
service Greeter {
  // Sends a greeting
  rpc SayHello (HelloRequest) returns (HelloReply) {}
  // Sends another greeting
  rpc SayHelloAgain (HelloRequest) returns (HelloReply) {}
}

// The request message containing the user's name.
message HelloRequest {
  string name = 1;
}

// The response message containing the greetings
message HelloReply {
  string message = 1;
}

----------------------------------------

TITLE: Gradle Configuration for gRPC Code Generation
DESCRIPTION: Example Gradle configuration using protobuf-gradle-plugin to generate gRPC and Protocol Buffers code.

LANGUAGE: gradle
CODE:
apply plugin: 'java'
apply plugin: 'com.google.protobuf'

buildscript {
  repositories {
    mavenCentral()
  }
  dependencies {
    classpath 'com.google.protobuf:protobuf-gradle-plugin:0.8.0'
  }
}

protobuf {
  protoc {
    artifact = "com.google.protobuf:protoc:3.2.0"
  }
  plugins {
    grpc {
      artifact = 'io.grpc:protoc-gen-grpc-java:1.4.0'
    }
  }
  generateProtoTasks {
    all()*.plugins {
      grpc {}
    }
  }
}

----------------------------------------

TITLE: Implementing Blocking gRPC Client Call
DESCRIPTION: Initial implementation of a client-side Create operation using blocking stub API. Shows how to make a synchronous RPC call to create a key-value pair with error handling for duplicate keys.

LANGUAGE: java
CODE:
private void doCreate(KeyValueServiceBlockingStub stub) {
  ByteString key = createRandomKey();
  try {
    CreateResponse res = stub.create(
        CreateRequest.newBuilder()
            .setKey(key)
            .setValue(randomBytes(MEAN_VALUE_SIZE))
            .build());
    if (!res.equals(CreateResponse.getDefaultInstance())) {
      throw new RuntimeException("Invalid response");
    }
  } catch (StatusRuntimeException e) {
    if (e.getStatus().getCode() == Code.ALREADY_EXISTS) {
      knownKeys.remove(key);
      logger.log(Level.INFO, "Key already existed", e);
    } else {
      throw e;
    }
  }
}

----------------------------------------

TITLE: Client-Streaming Method Signature for gRPC Client Stub in Go
DESCRIPTION: Signature for a client-streaming RPC method on the generated client stub, returning a client stream for sending messages.

LANGUAGE: Go
CODE:
Foo(ctx context.Context, opts ...grpc.CallOption) (<ServiceName>_FooClient, error)

----------------------------------------

TITLE: Regenerating gRPC code
DESCRIPTION: Command to recompile the updated .proto file and generate Go code for the gRPC service.

LANGUAGE: sh
CODE:
protoc --go_out=. --go_opt=paths=source_relative \
    --go-grpc_out=. --go-grpc_opt=paths=source_relative \
    helloworld/helloworld.proto

----------------------------------------

TITLE: Generating CommonJS Client Code from Proto Definition
DESCRIPTION: This command demonstrates how to use the protoc compiler to generate CommonJS client-side code from a .proto definition file for use with gRPC-Web.

LANGUAGE: sh
CODE:
protoc echo.proto \
  --js_out=import_style=commonjs:./output \
  --grpc-web_out=import_style=commonjs:./output

----------------------------------------

TITLE: Defining Simple RPC Method in Protocol Buffers
DESCRIPTION: Example of defining a simple RPC method GetFeature in the RouteGuide service.

LANGUAGE: Protocol Buffers
CODE:
rpc GetFeature(Point) returns (Feature) {}

----------------------------------------

TITLE: Checking gRPC Deadlines in Java
DESCRIPTION: Illustrates how to check if a gRPC request has been cancelled on the server side in Java. It uses the isCancelled method of the current Context to determine if the client has cancelled the request.

LANGUAGE: java
CODE:
if (Context.current().isCancelled()) {
  responseObserver.onError(Status.CANCELLED.withDescription("Cancelled by client").asRuntimeException());
  return;
}

----------------------------------------

TITLE: Implementing Simple RPC Method in Dart
DESCRIPTION: Example of implementing the GetFeature simple RPC method in the RouteGuide service.

LANGUAGE: Dart
CODE:
@override
Future<Feature> getFeature(grpc.ServiceCall call, Point request) async {
  return featuresDb.firstWhere((f) => f.location == request,
      orElse: () => Feature()..location = request);
}

----------------------------------------

TITLE: Installing Protoc on Windows using Winget
DESCRIPTION: Commands to install the protocol buffer compiler on Windows systems using the Winget package manager and verify the installed version.

LANGUAGE: sh
CODE:
> winget install protobuf
> protoc --version # Ensure compiler version is 3+

----------------------------------------

TITLE: Concurrent Update Operation with Retry Logic
DESCRIPTION: Implementation of the update operation using retry logic to handle concurrent modifications safely.

LANGUAGE: java
CODE:
@Override
public void update(
    UpdateRequest request, StreamObserver<UpdateResponse> responseObserver) {
  // ...
  ByteBuffer oldValue;
  do {
    oldValue = store.get(key);
    if (oldValue == null) {
      responseObserver.onError(Status.NOT_FOUND.asRuntimeException());
      return;
    }
  } while (!store.replace(key, oldValue, newValue));
  responseObserver.onNext(UpdateResponse.getDefaultInstance());
  responseObserver.onCompleted();
}

----------------------------------------

TITLE: Defining Server-Side Streaming RPC in Protocol Buffers
DESCRIPTION: Example of defining a server-side streaming RPC method ListFeatures in the RouteGuide service.

LANGUAGE: Protocol Buffers
CODE:
rpc ListFeatures(Rectangle) returns (stream Feature) {}

----------------------------------------

TITLE: Setting gRPC Deadlines in Go
DESCRIPTION: Shows how to set a deadline for a gRPC client request in Go. It uses the context package to create a new context with a deadline set to a specific duration from the current time.

LANGUAGE: go
CODE:
clientDeadline := time.Now().Add(time.Duration(*deadlineMs) * time.Millisecond)
ctx, cancel := context.WithDeadline(ctx, clientDeadline)

----------------------------------------

TITLE: Calling Streaming RPC Methods in Ruby
DESCRIPTION: Examples of calling server-side, client-side, and bidirectional streaming RPC methods using the gRPC client stub in Ruby.

LANGUAGE: ruby
CODE:
# Server-side streaming
resps = stub.list_features(LIST_FEATURES_RECT)
resps.each do |r|
  p "- found '#{r.name}' at #{r.location.inspect}"
end

# Client-side streaming
reqs = RandomRoute.new(features, points_on_route)
resp = stub.record_route(reqs.each)

# Bidirectional streaming
sleeping_enumerator = SleepingEnumerator.new(ROUTE_CHAT_NOTES, 1)
stub.route_chat(sleeping_enumerator.each_item) { |r| p "received #{r.inspect}" }

----------------------------------------

TITLE: gRPC-Web Streaming Implementation
DESCRIPTION: Server-side streaming implementation using gRPC-Web as an alternative to WebSockets.

LANGUAGE: javascript
CODE:
const { Empty } = require('./generated/common_pb.js');
const { DataServiceClient } = require('./generated/data_grpc_web_pb.js');

const client = new DataServiceClient('https://api.example.com');

const request = new Empty();

const stream = client.dataStream(request, {});

stream.on('data', (response) => {
  console.log(response.toObject());
});

stream.on('error', (err) => {
  console.error('Stream Error:', err);
});

stream.on('end', () => {
  console.log('Stream ended.');
});

----------------------------------------

TITLE: Defining gRPC Service for Person Search
DESCRIPTION: Protocol buffer and gRPC service definition for searching address book entries. Includes a search request message and streaming response service.

LANGUAGE: protobuf
CODE:
syntax = "proto3";
package tutorial;
import "addressbook.proto";

message PersonSearchRequest {
  repeated string name = 1;
  repeated int32 id = 2;
  repeated string phoneNumber = 3;
}

service PersonSearchService {
  rpc Search (PersonSearchRequest) returns (stream Person) {}
}

----------------------------------------

TITLE: Creating gRPC Client Channel in Dart
DESCRIPTION: Example of creating a gRPC client channel to communicate with the server in Dart.

LANGUAGE: Dart
CODE:
final channel = ClientChannel('127.0.0.1',
    port: 8080,
    options: const ChannelOptions(
        credentials: ChannelCredentials.insecure()));

----------------------------------------

TITLE: BDP Estimation and Dynamic Flow Control in gRPC-Go
DESCRIPTION: Implementation of Bandwidth Delay Product estimation to dynamically adjust flow control window sizes based on network conditions.

LANGUAGE: go
CODE:
// Reference implementation: https://github.com/grpc/grpc-go/pull/1310

----------------------------------------

TITLE: Defining gRPC Service in Protocol Buffers
DESCRIPTION: Definition of the RouteGuide service interface using protocol buffers, showing different types of RPC methods including unary, server streaming, client streaming and bidirectional streaming.

LANGUAGE: protobuf
CODE:
service RouteGuide {
   // Obtains the feature at a given position.
   rpc GetFeature(Point) returns (Feature) {}

   // Server streaming example
   rpc ListFeatures(Rectangle) returns (stream Feature) {}

   // Client streaming example
   rpc RecordRoute(stream Point) returns (RouteSummary) {}

   // Bidirectional streaming example
   rpc RouteChat(stream RouteNote) returns (stream RouteNote) {}
}

----------------------------------------

TITLE: Defining gRPC Service in Protocol Buffers
DESCRIPTION: Definition of the RouteGuide service interface using protocol buffers, showing different types of RPC methods including unary, server streaming, client streaming and bidirectional streaming.

LANGUAGE: protobuf
CODE:
service RouteGuide {
   // Obtains the feature at a given position.
   rpc GetFeature(Point) returns (Feature) {}

   // Server streaming example
   rpc ListFeatures(Rectangle) returns (stream Feature) {}

   // Client streaming example
   rpc RecordRoute(stream Point) returns (RouteSummary) {}

   // Bidirectional streaming example
   rpc RouteChat(stream RouteNote) returns (stream RouteNote) {}
}

----------------------------------------

TITLE: Building and Installing Android Client in Shell
DESCRIPTION: Builds the Android client application and installs it on the connected device using Gradle.

LANGUAGE: sh
CODE:
(cd android/helloworld; ../../gradlew installDebug)

----------------------------------------

TITLE: Calling Server-Side Streaming RPC in Dart
DESCRIPTION: Example of calling the ListFeatures server-side streaming RPC method from a Dart client.

LANGUAGE: Dart
CODE:
final rect = Rectangle()...; // initialize a Rectangle

try {
  await for (var feature in stub.listFeatures(rect)) {
    print(feature);
  }
catch (e) {
  print('ERROR: $e');
}

----------------------------------------

TITLE: Calling Simple RPC Method in Dart
DESCRIPTION: Example of calling the GetFeature simple RPC method from a Dart client.

LANGUAGE: Dart
CODE:
final point = Point()
  ..latitude = 409146138
  ..longitude = -746188906;
final feature = await stub.getFeature(point));

----------------------------------------

TITLE: Configuring Gradle for Kotlin gRPC JVM Project
DESCRIPTION: This snippet shows the build.gradle configuration for a Kotlin gRPC JVM project. It includes plugin applications, dependency declarations, and protobuf configuration.

LANGUAGE: groovy
CODE:
apply plugin: 'kotlin'
apply plugin: 'com.google.protobuf'

// Generate IntelliJ IDEA's .idea & .iml project files.
// protobuf-gradle-plugin automatically registers *.proto and the gen output files
// to IntelliJ as sources.
// For best results, install the Protobuf and Kotlin plugins for IntelliJ.
apply plugin: 'idea'

buildscript {
  ext.kotlin_version = '1.2.21'

  repositories {
    mavenCentral()
  }
  dependencies {
    classpath 'com.google.protobuf:protobuf-gradle-plugin:0.8.5'
    classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
  }
}

dependencies {
  compile "org.jetbrains.kotlin:kotlin-stdlib-jdk8:$kotlin_version"
  // The rest of the projects dep are added below, refer to example URL
}

// The standard protobuf block, same as normal gRPC Java projects
protobuf {
  protoc { artifact = 'com.google.protobuf:protoc:3.5.1-1' }
    plugins {
      grpc { artifact = "io.grpc:protoc-gen-grpc-java:${grpcVersion}" }
    }
    generateProtoTasks {
      all()*.plugins { grpc {} }
    }
}

----------------------------------------

TITLE: Cloning gRPC Repository
DESCRIPTION: Clones the gRPC repository with its submodules.

LANGUAGE: shell
CODE:
git clone --recurse-submodules -b v1.60.0 --depth 1 --shallow-submodules https://github.com/grpc/grpc

----------------------------------------

TITLE: Defining gRPC Service in Protocol Buffers
DESCRIPTION: Example of defining a gRPC service named RouteGuide using Protocol Buffers syntax.

LANGUAGE: Protocol Buffers
CODE:
service RouteGuide {
   ...
}

----------------------------------------

TITLE: Updating gRPC Client to Use New Method
DESCRIPTION: Dart code for the gRPC client, demonstrating how to call both the SayHello and SayHelloAgain methods on the Greeter service.

LANGUAGE: dart
CODE:
Future<void> main(List<String> args) async {
  final channel = ClientChannel(
    'localhost',
    port: 50051,
    options: const ChannelOptions(credentials: ChannelCredentials.insecure()),
  );
  final stub = GreeterClient(channel);

  final name = args.isNotEmpty ? args[0] : 'world';

  try {
    var response = await stub.sayHello(HelloRequest()..name = name);
    print('Greeter client received: ${response.message}');
    response = await stub.sayHelloAgain(HelloRequest()..name = name);
    print('Greeter client received: ${response.message}');
  } catch (e) {
    print('Caught error: $e');
  }
  await channel.shutdown();
}

----------------------------------------

TITLE: Calling Client-Side Streaming RPC in Dart
DESCRIPTION: Example of calling the RecordRoute client-side streaming RPC method from a Dart client.

LANGUAGE: Dart
CODE:
final random = Random();

// Generate a number of random points
Stream<Point> generateRoute(int count) async* {
  for (int i = 0; i < count; i++) {
    final point = featuresDb[random.nextInt(featuresDb.length)].location;
    yield point;
  }
}

final pointCount = random.nextInt(100) + 2; // Traverse at least two points

final summary = await stub.recordRoute(generateRoute(pointCount));
print('Route summary: $summary');

----------------------------------------

TITLE: Defining gRPC Service with Flatbuffers IDL
DESCRIPTION: This snippet demonstrates how to define a gRPC service using Flatbuffers as an Interface Definition Language (IDL). It includes message definitions and an RPC service declaration.

LANGUAGE: proto
CODE:
table HelloReply {
  message:string;
}

table HelloRequest {
  name:string;
}

table ManyHellosRequest {
  name:string;
  num_greetings:int;
}

rpc_service Greeter {
  SayHello(HelloRequest):HelloReply;
  SayManyHellos(ManyHellosRequest):HelloReply (streaming: "server");
}

----------------------------------------

TITLE: Using GrpcCleanupRule for Automatic Resource Cleanup in JUnit Tests
DESCRIPTION: This snippet demonstrates how to use the GrpcCleanupRule to automatically clean up gRPC resources in JUnit tests. Resources are registered with the rule, which handles graceful shutdown at the end of the test.

LANGUAGE: java
CODE:
public class MyTest {
  @Rule
  public GrpcCleanupRule grpcCleanup = new GrpcCleanupRule();
  ...
  private String serverName = InProcessServerBuilder.generateName();
  private Server server = grpcCleanup.register(InProcessServerBuilder
      .forName(serverName).directExecutor().addService(myServiceImpl).build().start());
  private ManagedChannel channel = grpcCleanup.register(InProcessChannelBuilder
      .forName(serverName).directExecutor().build());
  ...
}

----------------------------------------

TITLE: Using GrpcCleanupRule for Automatic Resource Cleanup in JUnit Tests
DESCRIPTION: This snippet demonstrates how to use the GrpcCleanupRule to automatically clean up gRPC resources in JUnit tests. Resources are registered with the rule, which handles graceful shutdown at the end of the test.

LANGUAGE: java
CODE:
public class MyTest {
  @Rule
  public GrpcCleanupRule grpcCleanup = new GrpcCleanupRule();
  ...
  private String serverName = InProcessServerBuilder.generateName();
  private Server server = grpcCleanup.register(InProcessServerBuilder
      .forName(serverName).directExecutor().addService(myServiceImpl).build().start());
  private ManagedChannel channel = grpcCleanup.register(InProcessChannelBuilder
      .forName(serverName).directExecutor().build());
  ...
}

----------------------------------------

TITLE: Configuring USB Port Forwarding for Android Device in Shell
DESCRIPTION: Sets up port forwarding from the Android device to the computer running the gRPC server using adb.

LANGUAGE: sh
CODE:
adb reverse tcp:8080 tcp:50051

----------------------------------------

TITLE: Running gRPC server and client
DESCRIPTION: Commands to compile and execute the server and client code for the gRPC example.

LANGUAGE: sh
CODE:
go run greeter_server/main.go

LANGUAGE: sh
CODE:
go run greeter_client/main.go

----------------------------------------

TITLE: Running gRPC Server in Dart
DESCRIPTION: Command to run the gRPC server for the RouteGuide service.

LANGUAGE: Shell
CODE:
dart bin/server.dart

----------------------------------------

TITLE: HTTP/2 Protocol Detection in Go
DESCRIPTION: Go code that routes requests to either gRPC or REST handlers based on protocol and content-type headers.

LANGUAGE: go
CODE:
if r.ProtoMajor == 2 && strings.Contains(r.Header.Get("Content-Type"), "application/grpc") {
	grpcServer.ServeHTTP(w, r)
} else {
	otherHandler.ServeHTTP(w, r)
}

----------------------------------------

TITLE: Installing Dart Protocol Compiler Plugin
DESCRIPTION: Command to install the protocol compiler plugin for Dart (protoc-gen-dart) using Dart's package manager.

LANGUAGE: sh
CODE:
dart pub global activate protoc_plugin

----------------------------------------

TITLE: Running gRPC Java Server
DESCRIPTION: Command to start the gRPC server example in Java.

LANGUAGE: sh
CODE:
./build/install/examples/bin/hello-world-server

----------------------------------------

TITLE: Running gRPC Kotlin Server
DESCRIPTION: Command to start the gRPC Kotlin server application.

LANGUAGE: shell
CODE:
./server/build/install/server/bin/hello-world-server

----------------------------------------

TITLE: Defining gRPC Service in Proto
DESCRIPTION: Defines the basic EchoService with a single RPC method that accepts and returns an EchoMessage.

LANGUAGE: proto
CODE:
service EchoService {
  rpc Echo(EchoMessage) returns (EchoMessage) {
  }
}

----------------------------------------

TITLE: Defining Protocol Buffer Message in Proto
DESCRIPTION: Defines the EchoMessage data structure containing a single string field 'value' used for the echo service.

LANGUAGE: proto
CODE:
message EchoMessage {
 string value = 1;
}

----------------------------------------

TITLE: Installing Dart Dependencies
DESCRIPTION: Command to download and install the required Dart package dependencies for the example project.

LANGUAGE: sh
CODE:
dart pub get

----------------------------------------

TITLE: Cloning gRPC Java Repository
DESCRIPTION: Command to clone the gRPC Java repository and change to the Android example directory.

LANGUAGE: sh
CODE:
git clone -b {{< param grpc_vers.java >}} https://github.com/grpc/grpc-java.git
cd grpc-java/examples/android

----------------------------------------

TITLE: Building and Installing gRPC (Linux/macOS)
DESCRIPTION: Builds and installs gRPC and Protocol Buffers on Linux or macOS systems.

LANGUAGE: shell
CODE:
cd grpc
mkdir -p cmake/build
pushd cmake/build
cmake -DgRPC_INSTALL=ON \
      -DgRPC_BUILD_TESTS=OFF \
      -DCMAKE_CXX_STANDARD=17 \
      -DCMAKE_INSTALL_PREFIX=$MY_INSTALL_DIR \
      ../..
make -j 4
make install
popd

----------------------------------------

TITLE: Adding REST Gateway Configuration in Proto
DESCRIPTION: Extends the EchoService definition with HTTP REST mapping options to enable the gRPC-REST gateway functionality.

LANGUAGE: proto
CODE:
service EchoService {
  rpc Echo(EchoMessage) returns (EchoMessage) {
    option (google.api.http) = {
      post: "/v1/echo"
      body: "*"
    };
  }
}

----------------------------------------

TITLE: Implementing gRPC Service in C++
DESCRIPTION: This C++ code implements the Greeter service with SayHello and SayHelloAgain methods in the server application.

LANGUAGE: c++
CODE:
class GreeterServiceImpl final : public Greeter::Service {
  Status SayHello(ServerContext* context, const HelloRequest* request,
                  HelloReply* reply) override {
    std::string prefix("Hello ");
    reply->set_message(prefix + request->name());
    return Status::OK;
  }
  Status SayHelloAgain(ServerContext* context, const HelloRequest* request,
                  HelloReply* reply) override {
    std::string prefix("Hello again ");
    reply->set_message(prefix + request->name());
    return Status::OK;
  }
};

----------------------------------------

TITLE: Cloning gRPC Java Repository in Shell
DESCRIPTION: Clones the gRPC Java repository from GitHub using a specific version tag.

LANGUAGE: sh
CODE:
git clone -b {{< param grpc_vers.java >}} https://github.com/grpc/grpc-java

----------------------------------------

TITLE: Building and Installing gRPC (Windows)
DESCRIPTION: Builds and installs gRPC and Protocol Buffers on Windows systems.

LANGUAGE: powershell
CODE:
mkdir "cmake\build"
pushd "cmake\build"
cmake -DgRPC_INSTALL=ON -DgRPC_BUILD_TESTS=OFF -DCMAKE_CXX_STANDARD=17 -DCMAKE_INSTALL_PREFIX=%MY_INSTALL_DIR% ../..
cmake --build . --config Release --target install -j 4
popd

----------------------------------------

TITLE: Installing CMake on Windows
DESCRIPTION: Installs CMake on Windows using Chocolatey.

LANGUAGE: powershell
CODE:
choco install cmake

----------------------------------------

TITLE: Defining Protocol Buffer Messages for Address Book
DESCRIPTION: Protocol buffer definition for an address book application with Person and AddressBook messages. Includes fields for name, ID, email, phone numbers, timestamp, and portrait image.

LANGUAGE: protobuf
CODE:
syntax = "proto3";
package tutorial;
import "google/protobuf/timestamp.proto";

message Person {
  string name = 1;
  int32 id = 2;  // Unique ID number for this person.
  string email = 3;

  enum PhoneType {
    MOBILE = 0;
    HOME = 1;
    WORK = 2;
  }

  message PhoneNumber {
    string number = 1;
    PhoneType type = 2;
  }

  repeated PhoneNumber phone = 4;
  google.protobuf.Timestamp last_updated = 5;
  bytes portrait_image = 6;
}

message AddressBook {
  repeated Person people = 1;
}

----------------------------------------

TITLE: Defining gRPC Service in Protocol Buffers
DESCRIPTION: This Protocol Buffers code defines the Greeter service with SayHello and SayHelloAgain methods, along with request and response message types.

LANGUAGE: protobuf
CODE:
// The greeting service definition.
service Greeter {
  // Sends a greeting
  rpc SayHello (HelloRequest) returns (HelloReply) {}
  // Sends another greeting
  rpc SayHelloAgain (HelloRequest) returns (HelloReply) {}
}

// The request message containing the user's name.
message HelloRequest {
  string name = 1;
}

// The response message containing the greetings
message HelloReply {
  string message = 1;
}

----------------------------------------

TITLE: Cloning gRPC Dart Repository
DESCRIPTION: Command to clone the gRPC Dart repository from GitHub.

LANGUAGE: Shell
CODE:
git clone --depth 1 https://github.com/grpc/grpc-dart

----------------------------------------

TITLE: Configuring Android Java gRPC Documentation Structure in YAML
DESCRIPTION: YAML front matter configuration that defines the documentation structure for Android Java gRPC implementation. Sets up page metadata, navigation links, and resource references for the Android Java platform.

LANGUAGE: yaml
CODE:
title: Android Java
layout: prog_lang_home
language: &lang Java
linkTitle: *lang
spelling: cSpell:ignore javadoc
api_path: grpc-java/javadoc
content:
  - learn_more:
    - "[Examples]($src_repo_url/tree/master/examples/android)"
  - reference:
    - "[API](api/)"
  - other:
    - "[Java (non-Android)](/docs/languages/java/)"
    - $src_repo_link
    - "[Download]($src_repo_url#download)"

----------------------------------------

TITLE: Setting Environment Variables for gRPC Installation (Linux/macOS)
DESCRIPTION: Sets up environment variables for the gRPC installation directory and updates the PATH.

LANGUAGE: shell
CODE:
export MY_INSTALL_DIR=$HOME/.local
mkdir -p $MY_INSTALL_DIR
export PATH="$MY_INSTALL_DIR/bin:$PATH"

----------------------------------------

TITLE: Defining gRPC Service with Protocol Buffers
DESCRIPTION: This snippet shows how to define a simple TODO service using Protocol Buffers. It includes message definitions for Todo and GetTodoRequest, as well as a TodoService with a GetTodoById method.

LANGUAGE: proto
CODE:
syntax = "proto3";

package todos;

message Todo {
  string content = 1;
  bool finished = 2;
}

message GetTodoRequest {
  int32 id = 1;
}

service TodoService {
  rpc GetTodoById (GetTodoRequest) returns (Todo);
}

----------------------------------------

TITLE: Defining gRPC Service in Protocol Buffers
DESCRIPTION: Definition of the RouteGuide service using protocol buffers, including various RPC method types: simple, server-streaming, client-streaming, and bidirectional streaming.

LANGUAGE: protobuf
CODE:
service RouteGuide {
   // Obtains the feature at a given position.
   rpc GetFeature(Point) returns (Feature) {}

   // Obtains the Features available within the given Rectangle.
   rpc ListFeatures(Rectangle) returns (stream Feature) {}

   // Accepts a stream of Points on a route being traversed
   rpc RecordRoute(stream Point) returns (RouteSummary) {}

   // Accepts a stream of RouteNotes sent while a route is being traversed
   rpc RouteChat(stream RouteNote) returns (stream RouteNote) {}
}

----------------------------------------

TITLE: Defining Markdown Frontmatter for Python gRPC Documentation
DESCRIPTION: This markdown frontmatter defines metadata for the Python gRPC documentation page, including the title, programming language home flag, source repository, and organized content links.

LANGUAGE: markdown
CODE:
---
title: Python
prog_lang_home: true
src_repo: https://github.com/grpc/grpc
content:
  - learn_more:
    - "[ALTS authentication](alts/)"
    - "[Additional docs]($src_repo_url/tree/master/doc/python)"
    - "[Examples]($src_repo_url/tree/master/examples/python)"
  - reference:
    - "[API](api/)"
    - "[Generated code](generated-code/)"
  - other:
    - "[grpc repo]($src_repo_url)"
    - "[Daily builds](daily-builds)"
---

----------------------------------------

TITLE: Generated BUILD File for Maven Jar
DESCRIPTION: Automatically generated BUILD file for maven_jar rule

LANGUAGE: python
CODE:
# DO NOT EDIT: automatically generated BUILD file for maven_jar rule com_google_guava_guava
java_import(
    name = 'jar',
    jars = ['guava-19.0.jar'],
    visibility = ['//visibility:public']
)

filegroup(
    name = 'file',
    srcs = ['guava-19.0.jar'],
    visibility = ['//visibility:public']
)

----------------------------------------

TITLE: Proto Language Rules Example
DESCRIPTION: Example showing how to generate outputs for multiple languages using proto_compile rule

LANGUAGE: python
CODE:
proto_compile(
   name = "pluriproto",
   protos = [":protos"],
   langs = [
       "//cpp",
       "//csharp",
       "//closure",
       "//ruby",
       "//java",
       "//java:nano",
       "//python",
       "//objc",
       "//node",
   ],
   verbose = 1,
   with_grpc = True,
 )

----------------------------------------

TITLE: Generated Go Interfaces for gRPC Service
DESCRIPTION: This Go code shows the client and server interfaces generated by the protoc compiler for the YYAPI gRPC service.

LANGUAGE: go
CODE:
type YYAPIClient interface {
  APIGetMessages(ctx context.Context, in *APIRequest, opts ...grpc.CallOption) (*APIFeedResponse, error)
}

func NewYYAPIClient(cc *grpc.ClientConn) YYAPIClient {
  // Code omitted for clarity..
}

type YYAPIServer interface {
  APIGetMessages(context.Context, *APIRequest) (*APIFeedResponse, error)
}

func RegisterYYAPIServer(s *grpc.Server, srv YYAPIServer) {
  // Code omitted for clarity..
}

----------------------------------------

TITLE: Using GRPCAuthorizationProtocol for gRPC Calls in Objective-C
DESCRIPTION: Demonstrates how to use a custom TokenProvider conforming to GRPCAuthorizationProtocol for gRPC calls.

LANGUAGE: objective-c
CODE:
GRPCMutableCallOptions *options = [[GRPCMutableCallOptions alloc] init];
options.authTokenProvider = [[TokenProvider alloc] init];
GRPCUnaryProtoCall *rpc = [client unaryCallWithMessage:myRequestMessage
                                       responseHandler:myResponseHandler
                                           callOptions:options] start];
[rpc start];

----------------------------------------

TITLE: Cloning gRPC Repository
DESCRIPTION: Command to clone the gRPC repository with its submodules

LANGUAGE: sh
CODE:
git clone --recurse-submodules -b {{< param grpc_vers.core >}} --depth 1 --shallow-submodules https://github.com/grpc/grpc

----------------------------------------

TITLE: Configuring User-Agent and Disallow Rules in robots.txt for gRPC
DESCRIPTION: This robots.txt configuration disallows access to '/get_grpcurl' and dynamically generates disallow rules for pages with 'noindex' in their parameters. It uses Go templating to iterate through pages and create rules.

LANGUAGE: robots.txt
CODE:
User-agent: *
Disallow: /get_grpcurl
{{ range .Pages -}}
{{ if in (lower .Params.robots) "noindex" -}}
Disallow: {{ .RelPermalink }}$
{{ end -}}
{{ end -}}

----------------------------------------

TITLE: Cloning rules_protobuf Repository
DESCRIPTION: Commands to clone and navigate to the rules_protobuf repository

LANGUAGE: bash
CODE:
git clone https://github.com/pubref/rules_protobuf
cd rules_protobuf
~/rules_protobuf$

----------------------------------------

TITLE: Generated Go Code for grpc-gateway REST Reverse Proxy
DESCRIPTION: This Go code snippet shows the generated function for registering the HTTP handlers that act as a reverse proxy, translating REST calls to gRPC calls.

LANGUAGE: go
CODE:
func RegisterYYAPIHandler(ctx context.Context, mux *runtime.ServeMux, conn *grpc.ClientConn) error {
  // Code omitted for clarity
}

----------------------------------------

TITLE: Creating Authenticated gRPC Call in Objective-C
DESCRIPTION: Code snippet demonstrating how to create a gRPC call with an OAuth2 access token in Objective-C.

LANGUAGE: objective-c
CODE:
GRPCMutableCallOptions *options = [[GRPCMutableCallOptions alloc] init];
options.oauth2AccessToken = myAccessToken;

GRPCUnaryProtoRPC *rpc = [client unaryCallWithMessage:myRequestMessage
                                      responseHandler:myResponseHandler
                                          callOptions:options];
[rpc start];

----------------------------------------

TITLE: Running the gRPC Server
DESCRIPTION: Starts the gRPC server for the Hello World example.

LANGUAGE: shell
CODE:
./greeter_server

----------------------------------------

TITLE: Benchmarking Java Code Execution using Interface and Loop
DESCRIPTION: This snippet demonstrates a method for benchmarking Java code execution by wrapping the code to be benchmarked in an interface and looping it for a set number of iterations. This approach helps discount any time spent checking the system time.

LANGUAGE: java
CODE:
interface Action {
    void execute();
}

// Sample benchmark of multiplication
Action a = new Action() {
    @Override
    public void execute() {
        int x = 1000 * 123456;
    }
}

for (int i = 0; i < 100; ++i) {
    a.execute();
}

----------------------------------------

TITLE: Optimized Non-Blocking gRPC Client Implementation
DESCRIPTION: Improved client implementation using ListenableFuture API for non-blocking calls with proper concurrency handling and rate limiting via semaphore.

LANGUAGE: java
CODE:
private final Semaphore limiter = new Semaphore(100);

private void doCreate(KeyValueServiceFutureStub stub, AtomicReference<Throwable> error)
    throws InterruptedException {
  limiter.acquire();
  ByteString key = createRandomKey();
  ListenableFuture<CreateResponse> res = stub.create(
      CreateRequest.newBuilder()
          .setKey(key)
          .setValue(randomBytes(MEAN_VALUE_SIZE))
          .build());
  res.addListener(() ->  {
    rpcCount.incrementAndGet();
    limiter.release();
  }, MoreExecutors.directExecutor());
  /* ... */
}

----------------------------------------

TITLE: Running gRPC Server and Client
DESCRIPTION: Commands to run the gRPC server and client in separate terminals.

LANGUAGE: sh
CODE:
node greeter_server.js

LANGUAGE: sh
CODE:
node greeter_client.js

----------------------------------------

TITLE: Loading gRPC Service Descriptors in Node.js
DESCRIPTION: Demonstrates how to load a .proto file and generate service descriptors in Node.js using the gRPC proto loader.

LANGUAGE: javascript
CODE:
var PROTO_PATH = __dirname + '/../../protos/route_guide.proto';
var grpc = require('@grpc/grpc-js');
var protoLoader = require('@grpc/proto-loader');
var packageDefinition = protoLoader.loadSync(
    PROTO_PATH,
    {keepCase: true,
     longs: String,
     enums: String,
     defaults: true,
     oneofs: true
    });
var protoDescriptor = grpc.loadPackageDefinition(packageDefinition);
var routeguide = protoDescriptor.routeguide;

----------------------------------------

TITLE: Starting gRPC Server in Ruby
DESCRIPTION: Code snippet demonstrating how to start a gRPC server for the RouteGuide service in Ruby.

LANGUAGE: ruby
CODE:
port = '0.0.0.0:50051'
s = GRPC::RpcServer.new
s.add_http2_port(port, :this_port_is_insecure)
GRPC.logger.info("... running insecurely on #{port}")
s.handle(ServerImpl.new(feature_db))
s.run_till_terminated_or_interrupted([1, 'int', 'SIGQUIT'])

----------------------------------------

TITLE: Envoy Proxy Configuration
DESCRIPTION: YAML configuration for Envoy proxy to enable gRPC-Web functionality.

LANGUAGE: yaml
CODE:
http_filters:
- name: envoy.filters.http.grpc_web
- name: envoy.filters.http.router

----------------------------------------

TITLE: Updating gRPC Client to Call New Method
DESCRIPTION: Node.js code updating the gRPC client to call both the sayHello and sayHelloAgain methods.

LANGUAGE: js
CODE:
function main() {
  var client = new hello_proto.Greeter('localhost:50051',
                                       grpc.credentials.createInsecure());
  client.sayHello({name: 'you'}, function(err, response) {
    console.log('Greeting:', response.message);
  });
  client.sayHelloAgain({name: 'you'}, function(err, response) {
    console.log('Greeting:', response.message);
  });
}

----------------------------------------

TITLE: Implementing gRPC Server in Kotlin
DESCRIPTION: Kotlin implementation of the Greeter service on the server side, including both SayHello and SayHelloAgain methods.

LANGUAGE: kotlin
CODE:
private class HelloWorldService : GreeterGrpcKt.GreeterCoroutineImplBase() {
  override suspend fun sayHello(request: HelloRequest) = helloReply {
    message = "Hello ${request.name}"
  }

  override suspend fun sayHelloAgain(request: HelloRequest) = helloReply {
    message = "Hello again ${request.name}"
  }
}

----------------------------------------

TITLE: Protocol Buffer Service Definition
DESCRIPTION: Protobuf definition file showing service and message definitions for a gRPC service.

LANGUAGE: proto
CODE:
syntax = "proto3";

package example;

service ExampleService {
  rpc GetExampleData(ExampleRequest) returns (ExampleResponse);
}

message ExampleRequest {
  string query = 1;
}

message ExampleResponse {
  repeated string data = 1;
}

----------------------------------------

TITLE: Optimizing JSON Encoding with Base64
DESCRIPTION: Custom Gson TypeAdapter implementation for efficient byte array encoding using Base64

LANGUAGE: java
CODE:
  private static final Gson gson =
      new GsonBuilder().registerTypeAdapter(byte[].class, new TypeAdapter<byte[]>() {
    @Override
    public void write(JsonWriter out, byte[] value) throws IOException {
      out.value(Base64.getEncoder().encodeToString(value));
    }

    @Override
    public byte[] read(JsonReader in) throws IOException {
      return Base64.getDecoder().decode(in.nextString());
    }
  }).create();

----------------------------------------

TITLE: Replacing Protobuf Components with JSON
DESCRIPTION: Diff showing the replacement of Protobuf components with JSON alternatives using Gson

LANGUAGE: diff
CODE:
- Protobuf wire encoding
- Protobuf generated message types
- gRPC generated stub types
+ JSON wire encoding
+ Gson message types

----------------------------------------

TITLE: Updating PATH for Protoc Plugin
DESCRIPTION: Command to update the PATH environment variable to include the location of the Dart protocol compiler plugin.

LANGUAGE: sh
CODE:
export PATH="$PATH:$HOME/.pub-cache/bin"

----------------------------------------

TITLE: Implementing RouteGuide Service in Dart
DESCRIPTION: Example of implementing the RouteGuide service class in Dart, extending the generated abstract class.

LANGUAGE: Dart
CODE:
class RouteGuideService extends RouteGuideServiceBase {
  Future<Feature> getFeature(grpc.ServiceCall call, Point request) async {
    ...
  }

  Stream<Feature> listFeatures(
      grpc.ServiceCall call, Rectangle request) async* {
    ...
  }

  Future<RouteSummary> recordRoute(
      grpc.ServiceCall call, Stream<Point> request) async {
    ...
  }

  Stream<RouteNote> routeChat(
      grpc.ServiceCall call, Stream<RouteNote> request) async* {
    ...
  }

  ...
}

----------------------------------------

TITLE: Bidirectional Streaming Server Interface in Go
DESCRIPTION: Interface for the server-side handler of a bidirectional streaming RPC, providing methods to send and receive messages.

LANGUAGE: Go
CODE:
type <ServiceName>_FooServer interface {
	Send(*MsgA) error
	Recv() (*MsgB, error)
	grpc.ServerStream
}

----------------------------------------

TITLE: Configuring Top-level Gradle for Kotlin Android gRPC Project
DESCRIPTION: This snippet shows the top-level build.gradle configuration for a Kotlin Android gRPC project. It includes buildscript configurations and repository declarations.

LANGUAGE: groovy
CODE:
buildscript {
  ext.kotlin_version = '1.2.21'

  repositories {
    google()
    jcenter()
  }
  dependencies {
    classpath 'com.android.tools.build:gradle:3.0.1'
    classpath "com.google.protobuf:protobuf-gradle-plugin:0.8.5"
    classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version"
  }
}

allprojects {
  repositories {
    google()
    jcenter()
  }
}

----------------------------------------

TITLE: Cloning gRPC-Dart Repository
DESCRIPTION: Git command to clone the gRPC-Dart repository from GitHub.

LANGUAGE: sh
CODE:
git clone https://github.com/grpc/grpc-dart

----------------------------------------

TITLE: Generating gRPC Code from Proto File
DESCRIPTION: Command to generate Dart gRPC code from the Protocol Buffer definition file.

LANGUAGE: Shell
CODE:
protoc -I protos/ protos/route_guide.proto --dart_out=grpc:lib/src/generated

----------------------------------------

TITLE: Implementing gRPC Server in Go
DESCRIPTION: Implementation of the RouteGuide server in Go, showing how to handle different RPC types including simple RPC, server streaming, client streaming and bidirectional streaming.

LANGUAGE: go
CODE:
type routeGuideServer struct {
        ...
}

func (s *routeGuideServer) GetFeature(ctx context.Context, point *pb.Point) (*pb.Feature, error) {
  for _, feature := range s.savedFeatures {
    if proto.Equal(feature.Location, point) {
      return feature, nil
    }
  }
  return &pb.Feature{Location: point}, nil
}

----------------------------------------

TITLE: Implementing gRPC Server in Go
DESCRIPTION: Implementation of the RouteGuide server in Go, showing how to handle different RPC types including simple RPC, server streaming, client streaming and bidirectional streaming.

LANGUAGE: go
CODE:
type routeGuideServer struct {
        ...
}

func (s *routeGuideServer) GetFeature(ctx context.Context, point *pb.Point) (*pb.Feature, error) {
  for _, feature := range s.savedFeatures {
    if proto.Equal(feature.Location, point) {
      return feature, nil
    }
  }
  return &pb.Feature{Location: point}, nil
}

----------------------------------------

TITLE: Displaying Markdown Table for Additional GKE Node Pools
DESCRIPTION: Markdown table showing the configuration of additional node pools used for ad hoc testing in the gRPC benchmarking cluster on GKE.

LANGUAGE: markdown
CODE:
| Pool name      | Node count | Machine type   | Kubernetes labels                                 |
| :------------- | ---------: | :------------- | :------------------------------------------------ |
| drivers        |          8 | e2-standard-8  | default-driver-pool:true,&nbsp;pool:drivers       |
| workers-8core  |          8 | e2-standard-8  | default-worker-pool:true,&nbsp;pool:workers-8core |
| workers-32core |          8 | e2-standard-32 | pool:workers-32core                               |

----------------------------------------

TITLE: Configuring Retry Throttling in gRPC Service Config
DESCRIPTION: JSON configuration for setting up retry throttling to prevent server overload. Specifies maxTokens for throttling limit and tokenRatio for token replenishment rate.

LANGUAGE: json
CODE:
"retryThrottling": {
  "maxTokens": 10,
  "tokenRatio": 0.1
}

----------------------------------------

TITLE: Running gRPC Server
DESCRIPTION: Command to start the gRPC server implemented in Dart.

LANGUAGE: sh
CODE:
dart bin/server.dart

----------------------------------------

TITLE: Defining Client-Side Streaming RPC in Protocol Buffers
DESCRIPTION: Example of defining a client-side streaming RPC method RecordRoute in the RouteGuide service.

LANGUAGE: Protocol Buffers
CODE:
rpc RecordRoute(stream Point) returns (RouteSummary) {}

----------------------------------------

TITLE: Running gRPC Client in Dart
DESCRIPTION: Command to run the gRPC client for the RouteGuide service.

LANGUAGE: Shell
CODE:
dart bin/client.dart

----------------------------------------

TITLE: Configuring Hedging Policy in gRPC Service Config
DESCRIPTION: JSON configuration for setting up hedging policy in gRPC. Defines maxAttempts for concurrent requests, hedgingDelay for request timing, and nonFatalStatusCodes for error handling.

LANGUAGE: json
CODE:
"hedgingPolicy": {
  "maxAttempts": INTEGER,
  "hedgingDelay": JSON proto3 Duration type,
  "nonFatalStatusCodes": JSON array of grpc status codes (int or string)
}

----------------------------------------

TITLE: Running Updated gRPC Client with Argument
DESCRIPTION: Command to run the updated gRPC client with a command-line argument for the name.

LANGUAGE: sh
CODE:
dart bin/client.dart Alice

----------------------------------------

TITLE: Defining gRPC Service in Protocol Buffers
DESCRIPTION: Protocol Buffer definition for the Greeter service, including the SayHello and SayHelloAgain methods with their request and response message types.

LANGUAGE: protobuf
CODE:
// The greeting service definition.
service Greeter {
  // Sends a greeting
  rpc SayHello (HelloRequest) returns (HelloReply) {}
  // Sends another greeting
  rpc SayHelloAgain (HelloRequest) returns (HelloReply) {}
}

// The request message containing the user's name.
message HelloRequest {
  string name = 1;
}

// The response message containing the greetings
message HelloReply {
  string message = 1;
}

----------------------------------------

TITLE: Registering gRPC Server Implementation in Go
DESCRIPTION: Function signature for registering a concrete implementation of a gRPC service server with a grpc.Server instance.

LANGUAGE: Go
CODE:
func RegisterBarServer(s *grpc.Server, srv BarServer)

----------------------------------------

TITLE: Changing to Example Directory
DESCRIPTION: Command to change the current directory to the helloworld example in the cloned repository.

LANGUAGE: sh
CODE:
cd grpc-dart/example/helloworld

----------------------------------------

TITLE: Server-Streaming Method Signature for gRPC Client Stub in Go
DESCRIPTION: Signature for a server-streaming RPC method on the generated client stub, returning a client stream for receiving messages.

LANGUAGE: Go
CODE:
Foo(ctx context.Context, in *MsgA, opts ...grpc.CallOption) (<ServiceName>_FooClient, error)

----------------------------------------

TITLE: Building the Example (Windows)
DESCRIPTION: Builds the Hello World example on Windows systems.

LANGUAGE: powershell
CODE:
cd examples/cpp/helloworld
mkdir "cmake\build"
pushd "cmake\build"
cmake -DCMAKE_INSTALL_PREFIX=%MY_INSTALL_DIR% ../..
cmake --build . --config Release -j 4
popd

----------------------------------------

TITLE: Calling Simple RPC Method in Ruby
DESCRIPTION: Example of calling a simple RPC method (GetFeature) using the gRPC client stub in Ruby.

LANGUAGE: ruby
CODE:
GET_FEATURE_POINTS = [
  Point.new(latitude:  409_146_138, longitude: -746_188_906),
  Point.new(latitude:  0, longitude: 0)
]

GET_FEATURE_POINTS.each do |pt|
  resp = stub.get_feature(pt)
  p "- found '#{resp.name}' at #{pt.inspect}"
end

----------------------------------------

TITLE: Core gRPC Status Codes Table
DESCRIPTION: Complete listing of gRPC status codes with their corresponding numeric IDs and detailed descriptions. Includes information about when each status code should be used and guidelines for choosing between similar status codes.

LANGUAGE: markdown
CODE:
| Code               | Id | Description |
|--------------------|--------|------------------------------------------------------------------------------------|
| OK                 | 0  | Not an error; returned on success. |
| CANCELLED          | 1  | The operation was cancelled, typically by the caller. |
| UNKNOWN            | 2  | Unknown error. For example, this error may be returned when a `Status` value received from another address space belongs to an error space that is not known in this address space. Also errors raised by APIs that do not return enough error information may be converted to this error. |
| INVALID_ARGUMENT   | 3  | The client specified an invalid argument. Note that this differs from `FAILED_PRECONDITION`. `INVALID_ARGUMENT` indicates arguments that are problematic regardless of the state of the system (e.g., a malformed file name). |
| DEADLINE_EXCEEDED  | 4  | The deadline expired before the operation could complete. For operations that change the state of the system, this error may be returned even if the operation has completed successfully. For example, a successful response from a server could have been delayed long enough for the deadline to expire.|
| NOT_FOUND          | 5  | Some requested entity (e.g., file or directory) was not found. Note to server developers: if a request is denied for an entire class of users, such as gradual feature rollout or undocumented allowlist, `NOT_FOUND` may be used. If a request is denied for some users within a class of users, such as user-based access control, `PERMISSION_DENIED` must be used. |
| ALREADY_EXISTS     | 6  | The entity that a client attempted to create (e.g., file or directory) already exists. |
| PERMISSION_DENIED  | 7  | The caller does not have permission to execute the specified operation. `PERMISSION_DENIED` must not be used for rejections caused by exhausting some resource (use `RESOURCE_EXHAUSTED` instead for those errors). `PERMISSION_DENIED` must not be used if the caller can not be identified (use `UNAUTHENTICATED` instead for those errors). This error code does not imply the request is valid or the requested entity exists or satisfies other pre-conditions. |
| RESOURCE_EXHAUSTED | 8 | Some resource has been exhausted, perhaps a per-user quota, or perhaps the entire file system is out of space. |
| FAILED_PRECONDITION | 9 | The operation was rejected because the system is not in a state required for the operation's execution. For example, the directory to be deleted is non-empty, an rmdir operation is applied to a non-directory, etc. Service implementors can use the following guidelines to decide between `FAILED_PRECONDITION`, `ABORTED`, and `UNAVAILABLE`: (a) Use `UNAVAILABLE` if the client can retry just the failing call. (b) Use `ABORTED` if the client should retry at a higher level (e.g., when a client-specified test-and-set fails, indicating the client should restart a read-modify-write sequence). (c) Use `FAILED_PRECONDITION` if the client should not retry until the system state has been explicitly fixed. E.g., if an "rmdir" fails because the directory is non-empty, `FAILED_PRECONDITION` should be returned since the client should not retry unless the files are deleted from the directory. |
| ABORTED            | 10 | The operation was aborted, typically due to a concurrency issue such as a sequencer check failure or transaction abort. See the guidelines above for deciding between `FAILED_PRECONDITION`, `ABORTED`, and `UNAVAILABLE`. |
| OUT_OF_RANGE       | 11 | The operation was attempted past the valid range. E.g., seeking or reading past end-of-file. Unlike `INVALID_ARGUMENT`, this error indicates a problem that may be fixed if the system state changes. For example, a 32-bit file system will generate `INVALID_ARGUMENT` if asked to read at an offset that is not in the range [0,2^32-1], but it will generate `OUT_OF_RANGE` if asked to read from an offset past the current file size. There is a fair bit of overlap between `FAILED_PRECONDITION` and `OUT_OF_RANGE`. We recommend using `OUT_OF_RANGE` (the more specific error) when it applies so that callers who are iterating through a space can easily look for an `OUT_OF_RANGE` error to detect when they are done. |
| UNIMPLEMENTED      | 12 | The operation is not implemented or is not supported/enabled in this service. |
| INTERNAL           | 13 | Internal errors. This means that some invariants expected by the underlying system have been broken. This error code is reserved for serious errors. |
| UNAVAILABLE        | 14 | The service is currently unavailable. This is most likely a transient condition, which can be corrected by retrying with a backoff. Note that it is not always safe to retry non-idempotent operations. |
| DATA_LOSS          | 15 | Unrecoverable data loss or corruption. |
| UNAUTHENTICATED    | 16 | The request does not have valid authentication credentials for the operation. |

----------------------------------------

TITLE: Core gRPC Status Codes Table
DESCRIPTION: Complete listing of gRPC status codes with their corresponding numeric IDs and detailed descriptions. Includes information about when each status code should be used and guidelines for choosing between similar status codes.

LANGUAGE: markdown
CODE:
| Code               | Id | Description |
|--------------------|--------|------------------------------------------------------------------------------------|
| OK                 | 0  | Not an error; returned on success. |
| CANCELLED          | 1  | The operation was cancelled, typically by the caller. |
| UNKNOWN            | 2  | Unknown error. For example, this error may be returned when a `Status` value received from another address space belongs to an error space that is not known in this address space. Also errors raised by APIs that do not return enough error information may be converted to this error. |
| INVALID_ARGUMENT   | 3  | The client specified an invalid argument. Note that this differs from `FAILED_PRECONDITION`. `INVALID_ARGUMENT` indicates arguments that are problematic regardless of the state of the system (e.g., a malformed file name). |
| DEADLINE_EXCEEDED  | 4  | The deadline expired before the operation could complete. For operations that change the state of the system, this error may be returned even if the operation has completed successfully. For example, a successful response from a server could have been delayed long enough for the deadline to expire.|
| NOT_FOUND          | 5  | Some requested entity (e.g., file or directory) was not found. Note to server developers: if a request is denied for an entire class of users, such as gradual feature rollout or undocumented allowlist, `NOT_FOUND` may be used. If a request is denied for some users within a class of users, such as user-based access control, `PERMISSION_DENIED` must be used. |
| ALREADY_EXISTS     | 6  | The entity that a client attempted to create (e.g., file or directory) already exists. |
| PERMISSION_DENIED  | 7  | The caller does not have permission to execute the specified operation. `PERMISSION_DENIED` must not be used for rejections caused by exhausting some resource (use `RESOURCE_EXHAUSTED` instead for those errors). `PERMISSION_DENIED` must not be used if the caller can not be identified (use `UNAUTHENTICATED` instead for those errors). This error code does not imply the request is valid or the requested entity exists or satisfies other pre-conditions. |
| RESOURCE_EXHAUSTED | 8 | Some resource has been exhausted, perhaps a per-user quota, or perhaps the entire file system is out of space. |
| FAILED_PRECONDITION | 9 | The operation was rejected because the system is not in a state required for the operation's execution. For example, the directory to be deleted is non-empty, an rmdir operation is applied to a non-directory, etc. Service implementors can use the following guidelines to decide between `FAILED_PRECONDITION`, `ABORTED`, and `UNAVAILABLE`: (a) Use `UNAVAILABLE` if the client can retry just the failing call. (b) Use `ABORTED` if the client should retry at a higher level (e.g., when a client-specified test-and-set fails, indicating the client should restart a read-modify-write sequence). (c) Use `FAILED_PRECONDITION` if the client should not retry until the system state has been explicitly fixed. E.g., if an "rmdir" fails because the directory is non-empty, `FAILED_PRECONDITION` should be returned since the client should not retry unless the files are deleted from the directory. |
| ABORTED            | 10 | The operation was aborted, typically due to a concurrency issue such as a sequencer check failure or transaction abort. See the guidelines above for deciding between `FAILED_PRECONDITION`, `ABORTED`, and `UNAVAILABLE`. |
| OUT_OF_RANGE       | 11 | The operation was attempted past the valid range. E.g., seeking or reading past end-of-file. Unlike `INVALID_ARGUMENT`, this error indicates a problem that may be fixed if the system state changes. For example, a 32-bit file system will generate `INVALID_ARGUMENT` if asked to read at an offset that is not in the range [0,2^32-1], but it will generate `OUT_OF_RANGE` if asked to read from an offset past the current file size. There is a fair bit of overlap between `FAILED_PRECONDITION` and `OUT_OF_RANGE`. We recommend using `OUT_OF_RANGE` (the more specific error) when it applies so that callers who are iterating through a space can easily look for an `OUT_OF_RANGE` error to detect when they are done. |
| UNIMPLEMENTED      | 12 | The operation is not implemented or is not supported/enabled in this service. |
| INTERNAL           | 13 | Internal errors. This means that some invariants expected by the underlying system have been broken. This error code is reserved for serious errors. |
| UNAVAILABLE        | 14 | The service is currently unavailable. This is most likely a transient condition, which can be corrected by retrying with a backoff. Note that it is not always safe to retry non-idempotent operations. |
| DATA_LOSS          | 15 | Unrecoverable data loss or corruption. |
| UNAUTHENTICATED    | 16 | The request does not have valid authentication credentials for the operation. |

----------------------------------------

TITLE: Server-Streaming Client Interface in Go
DESCRIPTION: Interface for the client-side handler of a server-streaming RPC, providing a method to receive messages from the server.

LANGUAGE: Go
CODE:
type <ServiceName>_FooClient interface {
	Recv() (*MsgB, error)
	grpc.ClientStream
}

----------------------------------------

TITLE: Updating the gRPC Service Definition
DESCRIPTION: Adds a new method 'SayHelloAgain' to the Greeter service in the Protocol Buffer definition.

LANGUAGE: protobuf
CODE:
// The greeting service definition.
service Greeter {
  // Sends a greeting
  rpc SayHello (HelloRequest) returns (HelloReply) {}
  // Sends another greeting
  rpc SayHelloAgain (HelloRequest) returns (HelloReply) {}
}

// The request message containing the user's name.
message HelloRequest {
  string name = 1;
}

// The response message containing the greetings
message HelloReply {
  string message = 1;
}

----------------------------------------

TITLE: Generating Ruby gRPC Code
DESCRIPTION: Command to generate Ruby gRPC client and server interfaces from the .proto service definition.

LANGUAGE: sh
CODE:
grpc_tools_ruby_protoc -I ../../protos --ruby_out=../lib --grpc_out=../lib ../../protos/route_guide.proto

----------------------------------------

TITLE: Generating Client Libraries with CocoaPods
DESCRIPTION: This command uses CocoaPods to generate and install the client library from .proto files and install dependencies.

LANGUAGE: sh
CODE:
cd ../../objective-c/helloworld
pod install

----------------------------------------

TITLE: Server-Streaming Method Signature for gRPC Server Interface in Go
DESCRIPTION: Signature for a server-streaming RPC method on the generated server interface, where MsgA is the client request and the server streams MsgB responses.

LANGUAGE: Go
CODE:
Foo(*MsgA, <ServiceName>_FooServer) error

----------------------------------------

TITLE: Defining gRPC Service Package in Protobuf
DESCRIPTION: Example of defining a service package and Java package in a .proto file using the java_package option.

LANGUAGE: protobuf
CODE:
package grpcexample;

option java_package = "io.grpc.examples";

----------------------------------------

TITLE: Updating the gRPC Client Implementation
DESCRIPTION: Adds a new method to call 'SayHelloAgain' in the client's C++ code.

LANGUAGE: cpp
CODE:
class GreeterClient {
 public:
  // ...
  std::string SayHello(const std::string& user) {
     // ...
  }

  std::string SayHelloAgain(const std::string& user) {
    // Follows the same pattern as SayHello.
    HelloRequest request;
    request.set_name(user);
    HelloReply reply;
    ClientContext context;

    // Here we can use the stub's newly available method we just added.
    Status status = stub_->SayHelloAgain(&context, request, &reply);
    if (status.ok()) {
      return reply.message();
    } else {
      std::cout << status.error_code() << ": " << status.error_message()
                << std::endl;
      return "RPC failed";
    }
  }

----------------------------------------

TITLE: Installing gRPC and gRPC Tools
DESCRIPTION: Commands for installing gRPC core library and tools for protocol buffer compilation.

LANGUAGE: sh
CODE:
python -m pip install grpcio
sudo python -m pip install grpcio
python -m pip install grpcio-tools

----------------------------------------

TITLE: Implementing Google Authentication in Ruby
DESCRIPTION: This Ruby code shows how to authenticate with Google services using a combination of SSL credentials and Google's application default credentials.

LANGUAGE: ruby
CODE:
require 'googleauth'  # from http://www.rubydoc.info/gems/googleauth/0.1.0
...
ssl_creds = GRPC::Core::ChannelCredentials.new(load_certs)  # load_certs typically loads a CA roots file
authentication = Google::Auth.get_application_default()
call_creds = GRPC::Core::CallCredentials.new(authentication.updater_proc)
combined_creds = ssl_creds.compose(call_creds)
stub = Helloworld::Greeter::Stub.new('greeter.googleapis.com', combined_creds)

----------------------------------------

TITLE: Implementing Google Authentication in Ruby
DESCRIPTION: This Ruby code shows how to authenticate with Google services using a combination of SSL credentials and Google's application default credentials.

LANGUAGE: ruby
CODE:
require 'googleauth'  # from http://www.rubydoc.info/gems/googleauth/0.1.0
...
ssl_creds = GRPC::Core::ChannelCredentials.new(load_certs)  # load_certs typically loads a CA roots file
authentication = Google::Auth.get_application_default()
call_creds = GRPC::Core::CallCredentials.new(authentication.updater_proc)
combined_creds = ssl_creds.compose(call_creds)
stub = Helloworld::Greeter::Stub.new('greeter.googleapis.com', combined_creds)

----------------------------------------

TITLE: Compiling gRPC Kotlin Client and Server
DESCRIPTION: Gradle command to compile the gRPC Kotlin client and server applications.

LANGUAGE: shell
CODE:
./gradlew installDist

----------------------------------------

TITLE: Installing Developer Tools with xcode-select
DESCRIPTION: This command installs the command line developer tools, which are required for building gRPC on iOS.

LANGUAGE: sh
CODE:
xcode-select --install

----------------------------------------

TITLE: Installing Dependencies with CocoaPods
DESCRIPTION: Command to install the necessary dependencies using CocoaPods.

LANGUAGE: sh
CODE:
pod install

----------------------------------------

TITLE: Java gRPC Server Implementation
DESCRIPTION: Java implementation of GreeterTimer server handling batch requests

LANGUAGE: java
CODE:
while (remaining-- > 0) {

    if (batchCount++ == batchSize) {
      BatchResponse response = BatchResponse.newBuilder()
        .setRemaining(remaining)
        .setBatchCount(batchCount)
        .setBatchTimeMillis(batchTime)
        .setErrCount(errCount)
        .build();
      observer.onNext(response);
    }

    blockingStub.sayHello(HelloRequest.newBuilder()
                          .setName("#" + remaining)
                          .build());
  }

----------------------------------------

TITLE: Cloning and Setting Up gRPC Node Example
DESCRIPTION: Commands to clone the gRPC-Node repository, navigate to the example directory, install dependencies, and move to the dynamic codegen 'hello, world' example.

LANGUAGE: sh
CODE:
# Clone the repository to get the example code
git clone -b {{< param grpc_vers.node >}} --depth 1 --shallow-submodules https://github.com/grpc/grpc-node
# Navigate to the node example
cd grpc-node/examples
# Install the example's dependencies
npm install
# Navigate to the dynamic codegen "hello, world" Node example:
cd helloworld/dynamic_codegen

----------------------------------------

TITLE: Cloning gRPC Java Repository
DESCRIPTION: Command to clone the gRPC Java repository from GitHub, specifying a particular branch and depth.

LANGUAGE: sh
CODE:
git clone -b {{< param grpc_vers.java >}} --depth 1 https://github.com/grpc/grpc-java

----------------------------------------

TITLE: Compiling gRPC Java Example
DESCRIPTION: Gradle command to compile the client and server for the gRPC Java example.

LANGUAGE: sh
CODE:
./gradlew installDist

----------------------------------------

TITLE: Cloning gRPC Repository in Bash
DESCRIPTION: Commands to clone the gRPC repository and navigate to the example project directory.

LANGUAGE: sh
CODE:
git clone -b {{< param grpc_vers.core >}} --depth 1 --shallow-submodules https://github.com/grpc/grpc
cd grpc
git submodule update --init
cd examples/objective-c/auth_sample

----------------------------------------

TITLE: Implementing Client-Side Streaming RPC in Android Java
DESCRIPTION: Code snippet demonstrating how to implement a client-side streaming RPC (RecordRoute) using the asynchronous stub in Android Java.

LANGUAGE: java
CODE:
private String recordRoute(List<Point> points, int numPoints, RouteGuideStub asyncStub)
        throws InterruptedException, RuntimeException {
    final StringBuffer logs = new StringBuffer();
    appendLogs(logs, "*** RecordRoute");

    final CountDownLatch finishLatch = new CountDownLatch(1);
    StreamObserver<RouteSummary> responseObserver = new StreamObserver<RouteSummary>() {
        @Override
        public void onNext(RouteSummary summary) {
            appendLogs(logs, "Finished trip with {0} points. Passed {1} features. "
                    + "Travelled {2} meters. It took {3} seconds.", summary.getPointCount(),
                    summary.getFeatureCount(), summary.getDistance(),
                    summary.getElapsedTime());
        }

        @Override
        public void onError(Throwable t) {
            failed = t;
            finishLatch.countDown();
        }

        @Override
        public void onCompleted() {
            appendLogs(logs, "Finished RecordRoute");
            finishLatch.countDown();
        }
    };

    StreamObserver<Point> requestObserver = asyncStub.recordRoute(responseObserver);
    try {
        // Send numPoints points randomly selected from the points list.
        Random rand = new Random();
        for (int i = 0; i < numPoints; ++i) {
            int index = rand.nextInt(points.size());
            Point point = points.get(index);
            appendLogs(logs, "Visiting point {0}, {1}", RouteGuideUtil.getLatitude(point),
                    RouteGuideUtil.getLongitude(point));
            requestObserver.onNext(point);
            // Sleep for a bit before sending the next one.
            Thread.sleep(rand.nextInt(1000) + 500);
            if (finishLatch.getCount() == 0) {
                // RPC completed or errored before we finished sending.
                // Sending further requests won't error, but they will just be thrown away.
                break;
            }
        }
    } catch (RuntimeException e) {
        // Cancel RPC
        requestObserver.onError(e);
        throw e;
    }
    // Mark the end of requests
    requestObserver.onCompleted();

    // Receiving happens asynchronously
    if (!finishLatch.await(1, TimeUnit.MINUTES)) {
        throw new RuntimeException(
               "Could not finish rpc within 1 minute, the server is likely down");
    }

    if (failed != null) {
        throw new RuntimeException(failed);
    }
    return logs.toString();
}

----------------------------------------

TITLE: Building the gRPC Website
DESCRIPTION: Command to generate the site files using Hugo. The generated files will be placed in the 'public' folder.

LANGUAGE: console
CODE:
$ npm run build

----------------------------------------

TITLE: Defining gRPC Service in Protocol Buffers
DESCRIPTION: Protocol Buffers definition for a Greeter service with SayHello and SayHelloAgain methods, including request and response message structures.

LANGUAGE: protobuf
CODE:
// The greeting service definition.
service Greeter {
  // Sends a greeting. Original method.
  rpc SayHello (HelloRequest) returns (HelloReply) {}
  // Sends another greeting. New method.
  rpc SayHelloAgain (HelloRequest) returns (HelloReply) {}
}

// The request message containing the user's name.
message HelloRequest {
  // The name of the user.
  string name = 1;
}

// The response message containing the greetings
message HelloReply {
  // The greeting message.
  string message = 1;
}

----------------------------------------

TITLE: Setting Up Project with Cocoapods
DESCRIPTION: Commands for cloning the repository and setting up the project using Cocoapods.

LANGUAGE: sh
CODE:
git clone -b {{vers}} --depth 1 --shallow-submodules https://github.com/grpc/grpc
cd grpc
git submodule update --init
cd examples/objective-c/route_guide
pod install

----------------------------------------

TITLE: Implementing Server Authentication with SSL/TLS in PHP
DESCRIPTION: This PHP example demonstrates how to create a gRPC client with server authentication using SSL/TLS credentials.

LANGUAGE: php
CODE:
$client = new helloworld\GreeterClient('myservice.example.com', [
    'credentials' => Grpc\ChannelCredentials::createSsl(file_get_contents('roots.pem')),
]);

----------------------------------------

TITLE: Demonstrating PHP Type Inconsistency
DESCRIPTION: This PHP code snippet shows inconsistent type usage for the 'hidePin' field, illustrating a common issue with REST APIs lacking strong typing.

LANGUAGE: php
CODE:
$yak->hidePin=false;

// Code omitted…
$yak->hidePin=true;

// Code omitted…
$yak->hidePin=0;

// Code omitted…
$yak->hidePin=1;

----------------------------------------

TITLE: Handling Inconsistent Field Names in PHP
DESCRIPTION: This PHP code demonstrates how servers sometimes need to handle inconsistent field names from clients, another issue that can arise with REST APIs.

LANGUAGE: php
CODE:
switch ($fieldName) {
  // Code omitted...
  case "recipientID":
  // This is being added because iOS is passing the recipientID
  // incorrectly and we still want to capture these events
  // … expected fall through …

  case "Recipientid":
    $this->yakkerEvent->recipientID = $value;
    break;
  // Code omitted...
}

----------------------------------------

TITLE: Implementing gRPC Client Methods in Java
DESCRIPTION: Java implementation of the client-side logic for interacting with the gRPC service, including calls to both SayHello and SayHelloAgain methods.

LANGUAGE: java
CODE:
// Client-side logic for interacting with the gRPC service.
public void greet(String name) {
  // Log a message indicating the intention to greet a user.
  logger.info("Will try to greet " + name + " ...");

  // Creating a request with the user's name.
  HelloRequest request = HelloRequest.newBuilder().setName(name).build();
  HelloReply response;
  try {
    // Call the original method on the server.
    response = blockingStub.sayHello(request);
  } catch (StatusRuntimeException e) {
    // Log a warning if the RPC fails.
    logger.log(Level.WARNING, "RPC failed: {0}", e.getStatus());
    return;
  }

  // Log the response from the original method.
  logger.info("Greeting: " + response.getMessage());

  try {
    // Call the new method on the server.
    response = blockingStub.sayHelloAgain(request);
  } catch (StatusRuntimeException e) {
    // Log a warning if the RPC fails.
    logger.log(Level.WARNING, "RPC failed: {0}", e.getStatus());
    return;
  }

  // Log the response from the new method.
  logger.info("Greeting: " + response.getMessage());
}

----------------------------------------

TITLE: Running gRPC Kotlin Client
DESCRIPTION: Command to run the gRPC Kotlin client application.

LANGUAGE: shell
CODE:
./client/build/install/client/bin/hello-world-client

----------------------------------------

TITLE: Defining gRPC Service with Protocol Buffers
DESCRIPTION: Protocol buffer definition for a simple Echo service with request and response message types.

LANGUAGE: protobuf
CODE:
message EchoRequest {
  string message = 1;
}

message EchoResponse {
  string message = 1;
}

service EchoService {
  rpc Echo(EchoRequest) returns (EchoResponse);
}

----------------------------------------

TITLE: gRPC-Web Client Implementation
DESCRIPTION: Implementation of a gRPC-Web client making a request using generated Protobuf definitions and client stub.

LANGUAGE: javascript
CODE:
const { ExampleRequest, ExampleResponse } = require('./generated/example_pb.js');
const { ExampleServiceClient } = require('./generated/example_grpc_web_pb.js');

const client = new ExampleServiceClient('https://api.example.com');

const request = new ExampleRequest();

client.getExampleData(request, {}, (err, response) => {
    if (err) {
        console.error('Error:', err);
    } else {
        console.log(response.toObject());
    }
});

----------------------------------------

TITLE: Cloning gRPC-Go repository
DESCRIPTION: Command to clone the gRPC-Go repository and change to the quick start example directory.

LANGUAGE: sh
CODE:
git clone -b {{< param grpc_vers.go >}} --depth 1 https://github.com/grpc/grpc-go

LANGUAGE: sh
CODE:
cd grpc-go/examples/helloworld

----------------------------------------

TITLE: Cloning gRPC Kotlin Repository
DESCRIPTION: Command to clone the gRPC Kotlin repository from GitHub.

LANGUAGE: shell
CODE:
git clone --depth 1 https://github.com/grpc/grpc-kotlin

----------------------------------------

TITLE: Writing JavaScript gRPC-Web Client
DESCRIPTION: Browser-side JavaScript client code using generated gRPC-Web stubs to make service calls.

LANGUAGE: javascript
CODE:
const {EchoRequest, EchoResponse} = require('./echo_pb.js');
const {EchoServiceClient} = require('./echo_grpc_web_pb.js');

var echoService = new EchoServiceClient('http://localhost:8080');

var request = new EchoRequest();
request.setMessage('Hello World!');

echoService.echo(request, {}, function(err, response) {
  // ...
});

----------------------------------------

TITLE: REST API Fetch Implementation
DESCRIPTION: Example of a traditional REST API call using the fetch API to retrieve JSON data from a service endpoint.

LANGUAGE: javascript
CODE:
fetch('https://api.example.com/data', {
    method: 'GET',
    headers: {
        'Accept': 'application/json',
    },
})
.then(response => response.json())
.then(data => console.log(data))
.catch(error => console.error('Error:', error));

----------------------------------------

TITLE: Manual Cleanup of gRPC Resources in JUnit Test Teardown
DESCRIPTION: This snippet demonstrates how to manually clean up gRPC server and channel resources in a JUnit test's tearDown method. It uses assertive shutdown to fail the test if cleanup is unsuccessful.

LANGUAGE: java
CODE:
public class MyTest {
  private Server server;
  private ManagedChannel channel;
  ...
  @After
  public void tearDown() throws InterruptedException {
    // assume channel and server are not null
    channel.shutdownNow();
    server.shutdownNow();
    // fail the test if cleanup is not successful
    assert channel.awaitTermination(5, TimeUnit.SECONDS) : "channel failed to shutdown";
    assert server.awaitTermination(5, TimeUnit.SECONDS) : "server failed to shutdown";
  }
  ...
}

----------------------------------------

TITLE: Running Updated gRPC Kotlin Client with Argument
DESCRIPTION: Command to run the updated gRPC Kotlin client application with a name argument.

LANGUAGE: shell
CODE:
./client/build/install/client/bin/hello-world-client Alice

----------------------------------------

TITLE: Running gRPC Java Client
DESCRIPTION: Command to run the gRPC client example in Java.

LANGUAGE: sh
CODE:
./build/install/examples/bin/hello-world-client

----------------------------------------

TITLE: Adjusting gRPC Deadlines with Options in Java
DESCRIPTION: Illustrates how to use command-line options to adjust gRPC deadlines dynamically in Java. It uses the @Option annotation to define an option for the deadline in milliseconds, which can be set at runtime.

LANGUAGE: java
CODE:
@Option(name="--deadline_ms", usage="Deadline in milliseconds.")
private int deadlineMs = 20*1000;

response = blockingStub.withDeadlineAfter(deadlineMs, TimeUnit.MILLISECONDS).sayHello(request);

----------------------------------------

TITLE: Adding gRPC to CMake Project Using FetchContent
DESCRIPTION: Demonstrates how to integrate gRPC into a CMake project using FetchContent. This approach allows automatic cloning and building of gRPC and its dependencies in a single step. The code sets up a minimum CMake version, declares the project, fetches gRPC from its repository, and links it to an executable.

LANGUAGE: cmake
CODE:
cmake_minimum_required(VERSION 3.15)
project(my_exe)

include(FetchContent)

FetchContent_Declare(
  gRPC
  GIT_REPOSITORY https://github.com/grpc/grpc
  GIT_TAG        v1.28.0
  )
set(FETCHCONTENT_QUIET OFF)
FetchContent_MakeAvailable(gRPC)

add_executable(my_exe my_exe.cc)
target_link_libraries(my_exe grpc++)

----------------------------------------

TITLE: Setting Android SDK Environment Variable
DESCRIPTION: Command to set the ANDROID_SDK_ROOT environment variable for locating the Android SDK installation.

LANGUAGE: shell
CODE:
export ANDROID_SDK_ROOT="<path-to-your-android-sdk>"

----------------------------------------

TITLE: Client-Streaming Client Interface in Go
DESCRIPTION: Interface for the client-side handler of a client-streaming RPC, providing methods to send messages and receive a response.

LANGUAGE: Go
CODE:
type <ServiceName>_FooClient interface {
	Send(*MsgA) error
	CloseAndRecv() (*MsgB, error)
	grpc.ClientStream
}

----------------------------------------

TITLE: Configuring gRPC Retry Policy in JSON
DESCRIPTION: An example JSON configuration for a gRPC retry policy, specifying parameters such as maximum attempts, initial backoff, maximum backoff, backoff multiplier, and retryable status codes.

LANGUAGE: json
CODE:
"retryPolicy": {
  "maxAttempts": 4,
  "initialBackoff": "0.1s",
  "maxBackoff": "1s",
  "backoffMultiplier": 2,
  "retryableStatusCodes": [
    "UNAVAILABLE"
  ]
}

----------------------------------------

TITLE: Configuring gRPC Retry Policy in JSON
DESCRIPTION: An example JSON configuration for a gRPC retry policy, specifying parameters such as maximum attempts, initial backoff, maximum backoff, backoff multiplier, and retryable status codes.

LANGUAGE: json
CODE:
"retryPolicy": {
  "maxAttempts": 4,
  "initialBackoff": "0.1s",
  "maxBackoff": "1s",
  "backoffMultiplier": 2,
  "retryableStatusCodes": [
    "UNAVAILABLE"
  ]
}

----------------------------------------

TITLE: Installing gRPC for Python
DESCRIPTION: Command to install the gRPC runtime for Python using pip package manager. This works on Linux, Mac, and Windows platforms.

LANGUAGE: bash
CODE:
pip install grpcio

----------------------------------------

TITLE: Installing gRPC for Node.js
DESCRIPTION: Command to install the gRPC runtime for Node.js using npm package manager. This works on Linux, Mac, and Windows platforms.

LANGUAGE: bash
CODE:
npm install grpc

----------------------------------------

TITLE: Cloning gRPC Kotlin Repository
DESCRIPTION: Git command to clone the gRPC Kotlin repository containing example code.

LANGUAGE: shell
CODE:
git clone https://github.com/grpc/grpc-kotlin

----------------------------------------

TITLE: Client-Streaming Method Signature for gRPC Server Interface in Go
DESCRIPTION: Signature for a client-streaming RPC method on the generated server interface, where the server receives a stream of messages from the client.

LANGUAGE: Go
CODE:
Foo(<ServiceName>_FooServer) error

----------------------------------------

TITLE: Warning: Server Request-Header Size Limit
DESCRIPTION: Warns about potential server-side limits on the size of request headers, with a suggested default of 8 KiB.

LANGUAGE: plaintext
CODE:
WARNING: Servers may limit the size of Request-Headers, with a default of 8 KiB suggested.

----------------------------------------

TITLE: Creating an Insecure gRPC Connection in Dart
DESCRIPTION: This Dart snippet demonstrates how to create a gRPC client channel and stub without any encryption or authentication.

LANGUAGE: dart
CODE:
final channel = new ClientChannel('localhost',
      port: 50051,
      options: const ChannelOptions(
          credentials: const ChannelCredentials.insecure()));
final stub = new GreeterClient(channel);

----------------------------------------

TITLE: Changing to Repository Directory
DESCRIPTION: Command to navigate to the root directory of the cloned repository

LANGUAGE: sh
CODE:
cd grpc-web

----------------------------------------

TITLE: Running gRPC Client
DESCRIPTION: Command to run the gRPC client implemented in Dart, which communicates with the server.

LANGUAGE: sh
CODE:
dart bin/client.dart

----------------------------------------

TITLE: Server Cancellation Flow Diagram
DESCRIPTION: A flowchart demonstrating how a server handles cancellation requests, including checking cancellation status and cleanup procedures.

LANGUAGE: mermaid
CODE:
flowchart LR
  subgraph Client
  end
  subgraph Server1
    direction TB
    cancelled{cancelled?} -->|false| perform("perform some work")
    perform --> cancelled
    cancelled -->|true| cleanup("cancel upstream RPCs")
    cleanup --> exit("exit RPC handler")
  end
  subgraph Server2
  end

  Client -->|CANCEL| Server1
  Server1 -->|CANCEL| Server2

----------------------------------------

TITLE: Basic gRPC Connection without Authentication in Ruby
DESCRIPTION: This Ruby code snippet shows how to create an insecure gRPC stub without any encryption or authentication.

LANGUAGE: ruby
CODE:
stub = Helloworld::Greeter::Stub.new('localhost:50051', :this_channel_is_insecure)

----------------------------------------

TITLE: Visualizing Graceful Shutdown Sequence in gRPC using Mermaid
DESCRIPTION: This diagram illustrates the sequence of events during a graceful shutdown process in gRPC. It shows how in-flight RPCs are handled, client detection of server shutdown, and the fallback to forceful shutdown if the timeout is reached.

LANGUAGE: mermaid
CODE:
sequenceDiagram
Client->>Server: New RPC Request 1
Client->>Server: New RPC Request 2
Server-->>Server: Graceful Shutdown Invoked
Server->>Client: Continues Processing In-Flight RPCs
Client->>Client: Detects server shutdown and finds other servers if available
alt RPCs complete within timeout
    Server->>Client: Completes RPC 1
    Server->>Client: Completes RPC 2
    Server-->>Server: Graceful Shutdown Complete
else Timeout reached
    Server->>Client: Forceful Shutdown Invoked, terminating pending RPCs
    Server-->>Server: Forceful Shutdown Complete
end

----------------------------------------

TITLE: Configuring gRPC Kotlin for Android in YAML
DESCRIPTION: This YAML configuration sets up metadata and links for the gRPC Kotlin implementation on Android. It defines the layout, language, API path, and various content sections including learning resources, references, and additional links.

LANGUAGE: YAML
CODE:
---
title: Kotlin for Android
layout: prog_lang_home
language: &lang Kotlin
linkTitle: *lang
api_path: https://javadocs.dev/io.grpc/grpc-kotlin-stub/latest
content:
  - learn_more:
    - "[Example]($src_repo_url/tree/master/examples/android)"
  - reference:
    - "[API](api/)"
  - other:
    - "[Kotlin](/docs/languages/kotlin/)"
    - $src_repo_link
    - "[Download](https://search.maven.org/search?q=g:io.grpc%20AND%20grpc-kotlin)"
---

----------------------------------------

TITLE: Changing Directory to Route Guide Example
DESCRIPTION: Command to change the current directory to the route guide example folder.

LANGUAGE: Shell
CODE:
cd grpc-dart/example/route_guide

----------------------------------------

TITLE: Error Status Code Reference Table - General Errors
DESCRIPTION: A reference table showing common gRPC error status codes for general error scenarios like cancellation, deadline expiration, and server issues.

LANGUAGE: markdown
CODE:
Case | Status code
-----|-----------
Client application cancelled the request | `GRPC_STATUS_CANCELLED`
Deadline expired before server returned status | `GRPC_STATUS_DEADLINE_EXCEEDED`
Method not found on server | `GRPC_STATUS_UNIMPLEMENTED`
Server shutting down | `GRPC_STATUS_UNAVAILABLE`
Server threw an exception | `GRPC_STATUS_UNKNOWN`

----------------------------------------

TITLE: Error Status Code Reference Table - General Errors
DESCRIPTION: A reference table showing common gRPC error status codes for general error scenarios like cancellation, deadline expiration, and server issues.

LANGUAGE: markdown
CODE:
Case | Status code
-----|-----------
Client application cancelled the request | `GRPC_STATUS_CANCELLED`
Deadline expired before server returned status | `GRPC_STATUS_DEADLINE_EXCEEDED`
Method not found on server | `GRPC_STATUS_UNIMPLEMENTED`
Server shutting down | `GRPC_STATUS_UNAVAILABLE`
Server threw an exception | `GRPC_STATUS_UNKNOWN`

----------------------------------------

TITLE: Sequence Diagram of Wait-for-Ready Behavior in gRPC
DESCRIPTION: This diagram illustrates the sequence of events when a client sends a message to a server, based on channel state and whether Wait-for-Ready is set. It shows different scenarios including READY, IDLE, CONNECTING, and TRANSIENT_FAILURE states.

LANGUAGE: mermaid
CODE:
sequenceDiagram
participant A as Application
participant RPC
participant CH as Channel
participant S as Server 
A->>RPC: Create RPC using stub
RPC->>CH: Initiate Communication
alt channel state: READY
  CH->>S: Send message
else Channel state: IDLE or CONNECTING
  CH-->>CH: Wait for state change
else Channel state: TRANSIENT_FAILURE
  alt with Wait-for-Ready
    CH-->>CH: Wait for channel<br>becoming READY<br>(or a permanent failure)
    CH->>S: Send message
  else without Wait-for-Ready
    CH->>A: Failure
  end
else Channel state is a Permanent Failure
    CH->>A: Failure
end

----------------------------------------

TITLE: YAML Frontmatter Configuration for GRPC API Reference
DESCRIPTION: YAML configuration block that defines metadata and build settings for a placeholder page that redirects to external API documentation. Includes title, link settings, weight for navigation ordering, and build parameters.

LANGUAGE: yaml
CODE:
title: API reference
linkTitle: API
weight: 90
# Note: this is a placeholder page. The URL to this page redirects elsewhere.
manualLinkTarget: _blank
_build: { render: link }

----------------------------------------

TITLE: Running the gRPC Client
DESCRIPTION: Runs the gRPC client for the Hello World example.

LANGUAGE: shell
CODE:
./greeter_client

----------------------------------------

TITLE: Creating gRPC Channel and Stubs in Android Java
DESCRIPTION: Code snippet showing how to create a gRPC channel and generate blocking and asynchronous stubs for the RouteGuide service.

LANGUAGE: java
CODE:
mChannel = ManagedChannelBuilder.forAddress(host, port).usePlaintext(true).build();

blockingStub = RouteGuideGrpc.newBlockingStub(mChannel);
asyncStub = RouteGuideGrpc.newStub(mChannel);

----------------------------------------

TITLE: Initializing Async gRPC Client
DESCRIPTION: Sets up an asynchronous gRPC client by creating a completion queue and initiating an RPC call.

LANGUAGE: c++
CODE:
CompletionQueue cq;
std::unique_ptr<ClientAsyncResponseReader<HelloReply> > rpc(
    stub_->AsyncSayHello(&context, request, &cq));

----------------------------------------

TITLE: Implementing CallData Class for Async Server
DESCRIPTION: Defines a CallData class that manages the state and lifecycle of individual RPC calls in the async server.

LANGUAGE: c++
CODE:
class CallData {
public:
  CallData(Greeter::AsyncService* service, ServerCompletionQueue* cq)
      : service_(service), cq_(cq), responder_(&ctx_), status_(CREATE) {
    Proceed();
  }

  void Proceed() {
    if (status_ == CREATE) {
      service_->RequestSayHello(&ctx_, &request_, &responder_, cq_, cq_,
                                this);
      status_ = PROCESS;
    } else if (status_ == PROCESS) {
      new CallData(service_, cq_);
      std::string prefix("Hello ");
      reply_.set_message(prefix + request_.name());
      responder_.Finish(reply_, Status::OK, this);
      status_ = FINISH;
    } else {
      GPR_ASSERT(status_ == FINISH);
      delete this;
    }
  }
}

----------------------------------------

TITLE: Downloading Pre-compiled Protoc Binary
DESCRIPTION: Command to download the pre-compiled protocol buffer compiler binary from GitHub releases using curl.

LANGUAGE: sh
CODE:
PB_REL="https://github.com/protocolbuffers/protobuf/releases"
curl -LO $PB_REL/download/v{{< param protoc-version >}}/protoc-{{< param protoc-version >}}-linux-x86_64.zip

----------------------------------------

TITLE: Installing Required Tools on macOS
DESCRIPTION: Installs essential build tools on macOS using Homebrew.

LANGUAGE: shell
CODE:
brew install autoconf automake libtool pkg-config

----------------------------------------

TITLE: Decoupling Application Reads from Connection Flow Control in gRPC-Go
DESCRIPTION: Implementation that separates connection-level flow control from application reads to prevent slow streams from hampering performance of other streams on the same connection.

LANGUAGE: go
CODE:
// Reference implementation: https://github.com/grpc/grpc-go/pull/1265

----------------------------------------

TITLE: Extracting Protoc Binary
DESCRIPTION: Command to extract the downloaded protocol buffer compiler binary to a local directory.

LANGUAGE: sh
CODE:
unzip protoc-{{< param protoc-version >}}-linux-x86_64.zip -d $HOME/.local

----------------------------------------

TITLE: Installing Required Tools on Linux
DESCRIPTION: Installs essential build tools on Linux using apt.

LANGUAGE: shell
CODE:
sudo apt install -y build-essential autoconf libtool pkg-config

----------------------------------------

TITLE: Graceful Cleanup of gRPC Resources in JUnit Test Teardown
DESCRIPTION: This snippet shows a more graceful approach to cleaning up gRPC resources in a JUnit test. It attempts a graceful shutdown first, then forces shutdown if necessary, ensuring resources are always cleaned up.

LANGUAGE: java
CODE:
public class MyTest {
  private Server server;
  private ManagedChannel channel;
  ...
  @After
  public void tearDown() throws InterruptedException {
    // assume channel and server are not null
    channel.shutdown();
    server.shutdown();
    // fail the test if cannot gracefully shutdown
    try {
      assert channel.awaitTermination(5, TimeUnit.SECONDS) : "channel cannot be gracefully shutdown";
      assert server.awaitTermination(5, TimeUnit.SECONDS) : "server cannot be gracefully shutdown";
    } finally {
      channel.shutdownNow();
      server.shutdownNow();
    }
  }
  ...
}

----------------------------------------

TITLE: Installing gRPC for Ruby
DESCRIPTION: Command to install the gRPC runtime for Ruby using gem package manager. This works on Linux, Mac, and Windows platforms.

LANGUAGE: bash
CODE:
gem install grpc

----------------------------------------

TITLE: Checking CMake Version
DESCRIPTION: Verifies the installed version of CMake.

LANGUAGE: shell
CODE:
cmake --version

----------------------------------------

TITLE: Adjusting gRPC Deadlines with Flags in C++
DESCRIPTION: Demonstrates how to use command-line flags to adjust gRPC deadlines dynamically in C++. It uses the gflags library to define a flag for the deadline in milliseconds, which can be set at runtime.

LANGUAGE: cpp
CODE:
#include <gflags/gflags.h>
DEFINE_int32(deadline_ms, 20*1000, "Deadline in milliseconds.");

ClientContext context;
time_point deadline = std::chrono::system_clock::now() +
    std::chrono::milliseconds(FLAGS_deadline_ms);
context.set_deadline(deadline);

----------------------------------------

TITLE: Installing gRPC for PHP
DESCRIPTION: Command to install the gRPC runtime for PHP using PECL package manager. This works on Linux, Mac, and Windows platforms.

LANGUAGE: bash
CODE:
pecl install grpc-beta

----------------------------------------

TITLE: Handling Server-Side Streaming RPC in C++
DESCRIPTION: Demonstrates how to handle a server-side streaming RPC call to the ListFeatures method. This includes using a ClientReader to read multiple responses from the server.

LANGUAGE: cpp
CODE:
std::unique_ptr<ClientReader<Feature> > reader(
    stub_->ListFeatures(&context, rect));
while (reader->Read(&feature)) {
  std::cout << "Found feature called "
            << feature.name() << " at "
            << feature.location().latitude()/kCoordFactor_ << ", "
            << feature.location().longitude()/kCoordFactor_ << std::endl;
}
Status status = reader->Finish();

----------------------------------------

TITLE: Defining WorkerService Protocol Buffer Interface
DESCRIPTION: Service definition that controls test workers to act as either clients or servers during benchmark tests. This is the core interface implemented by each language's performance testing worker.

LANGUAGE: protobuf
CODE:
service WorkerService {
  // Service for directing workers to act as client/server
  // for benchmark testing
}

----------------------------------------

TITLE: Installing Node LTS Using NVM
DESCRIPTION: Command to install the latest LTS release of Node using NVM (Node Version Manager).

LANGUAGE: console
CODE:
$ nvm install --lts

----------------------------------------

TITLE: Implementing Server Shutdown
DESCRIPTION: Shows proper shutdown sequence for the gRPC server and completion queue.

LANGUAGE: c++
CODE:
~ServerImpl() {
  server_->Shutdown();
  // Always shutdown the completion queue after the server.
  cq_->Shutdown();
}

----------------------------------------

TITLE: Defining gRPC Service Interface in Protocol Buffers
DESCRIPTION: Protocol buffer service definition showing different types of RPC methods including simple RPC, streaming RPC, and bidirectional streaming.

LANGUAGE: protobuf
CODE:
service RouteGuide {
   rpc GetFeature(Point) returns (Feature) {}
   rpc ListFeatures(Rectangle) returns (stream Feature) {}
   rpc RecordRoute(stream Point) returns (RouteSummary) {}
   rpc RouteChat(stream RouteNote) returns (stream RouteNote) {}
}

----------------------------------------

TITLE: Defining gRPC Service Interface in Protocol Buffers
DESCRIPTION: Protocol buffer service definition showing different types of RPC methods including simple RPC, streaming RPC, and bidirectional streaming.

LANGUAGE: protobuf
CODE:
service RouteGuide {
   rpc GetFeature(Point) returns (Feature) {}
   rpc ListFeatures(Rectangle) returns (stream Feature) {}
   rpc RecordRoute(stream Point) returns (RouteSummary) {}
   rpc RouteChat(stream RouteNote) returns (stream RouteNote) {}
}

----------------------------------------

TITLE: Installing NPM Packages and Git Submodules
DESCRIPTION: Command to install NPM packages and git submodules, including the Docsy theme.

LANGUAGE: console
CODE:
$ npm install

----------------------------------------

TITLE: Implementing HandleRpcs for Async Server
DESCRIPTION: Implements the main event loop that processes RPC events from the completion queue.

LANGUAGE: c++
CODE:
void HandleRpcs() {
  new CallData(&service_, cq_.get());
  void* tag;
  bool ok;
  while (true) {
    cq_->Next(&tag, &ok);
    GPR_ASSERT(ok);
    static_cast<CallData*>(tag)->Proceed();
  }
}

----------------------------------------

TITLE: Running gRPC Ruby Example
DESCRIPTION: Commands to build and run the gRPC Ruby example server and client.

LANGUAGE: sh
CODE:
cd examples/ruby
gem install bundler && bundle install
bundle exec route_guide/route_guide_server.rb ../python/route_guide/route_guide_db.json
# In a different terminal
bundle exec route_guide/route_guide_client.rb ../python/route_guide/route_guide_db.json

----------------------------------------

TITLE: Serving the gRPC Website Locally
DESCRIPTION: Command to serve the site locally at localhost:8888.

LANGUAGE: console
CODE:
$ npm run serve

----------------------------------------

TITLE: Building gRPC Project with Logging
DESCRIPTION: Command to build the project with verbose logging to show proto compilation process.

LANGUAGE: bash
CODE:
~/work/MyGreeter$ dotnet build -v:n

Build started 11/9/18 5:33:44 PM.
  1:7>Project "/home/kkm/work/MyGreeter/MyGreeter.csproj" on node 1 (Build target(s)).
   1>_Protobuf_CoreCompile:
      /home/kkm/.nuget/packages/grpc.tools/1.17.0/tools/linux_x64/protoc
        --csharp_out=obj/Debug/netstandard2.0
        --plugin=protoc-gen-grpc=/home/kkm/.nuget/packages/grpc.tools/1.17.0/tools/linux_x64/grpc_csharp_plugin
        --grpc_out=obj/Debug/netstandard2.0 --proto_path=/home/kkm/.nuget/packages/grpc.tools/1.17.0/build/native/include
        --proto_path=. --dependency_out=obj/Debug/netstandard2.0/da39a3ee5e6b4b0d_helloworld.protodep helloworld.proto
     CoreCompile:

        [ ... skipping long output ... ]

       MyGreeter -> /home/kkm/work/MyGreeter/bin/Debug/netstandard2.0/MyGreeter.dll

Build succeeded.

----------------------------------------

TITLE: Configuring Google Analytics in YAML
DESCRIPTION: YAML configuration snippet for setting up Google Analytics. Replace 'G-XXXXXXXXXX' with your actual GA Measurement ID.

LANGUAGE: yaml
CODE:
params:
  googleAnalytics: "G-XXXXXXXXXX" # Replace with your GA Measurement ID

----------------------------------------

TITLE: Fetching Docker Dependencies
DESCRIPTION: Docker compose command to pull required containers and tools for the example

LANGUAGE: sh
CODE:
docker-compose pull prereqs node-server envoy commonjs-client

----------------------------------------

TITLE: Configuring Hugo Front Matter for API Documentation
DESCRIPTION: YAML front matter configuration for a Hugo documentation page that defines metadata properties and rendering behavior. The page is configured as a redirect link with manual target settings.

LANGUAGE: yaml
CODE:
title: API reference
linkTitle: API
weight: 90
# Note: this is a placeholder page. The URL to this page redirects elsewhere.
manualLinkTarget: _blank
_build: { render: link }

----------------------------------------

TITLE: Serving gRPC Website with Production Environment
DESCRIPTION: Command to serve the site with Hugo environment set to production, ensuring Google Analytics and Google Tag Manager are active.

LANGUAGE: console
CODE:
$ HUGO_ENV=production npm run serve

----------------------------------------

TITLE: Cloning gRPC-Web Repository
DESCRIPTION: Command to clone the gRPC-Web repository containing the example code

LANGUAGE: sh
CODE:
git clone https://github.com/grpc/grpc-web

----------------------------------------

TITLE: Configuring YAML Frontmatter for gRPC Daily Builds Page
DESCRIPTION: YAML configuration block that defines metadata and build properties for a documentation page about gRPC daily builds. Sets up page title, robot directives, weight, manual link behavior and build rendering mode.

LANGUAGE: yaml
CODE:
---
title: Daily builds
robots: noindex, nofollow
weight: 90
# Note: this is a placeholder page. The URL to this page redirects elsewhere.
manualLinkTarget: _blank
_build: { render: link }
---

----------------------------------------

TITLE: Checking Internal Links of gRPC Website
DESCRIPTION: Command to check the internal links of the gRPC website using htmltest.

LANGUAGE: console
CODE:
$ npm run check-links

----------------------------------------

TITLE: Configuring Envoy Proxy for gRPC-Web
DESCRIPTION: Envoy proxy configuration for forwarding gRPC-Web requests to the backend server with CORS support.

LANGUAGE: yaml
CODE:
admin:
  address:
    socket_address: { address: 0.0.0.0, port_value: 9901 }

static_resources:
  listeners:
  - name: listener_0
    address:
      socket_address: { address: 0.0.0.0, port_value: 8080 }
    filter_chains:
    - filters:
      - name: envoy.http_connection_manager
        typed_config:
          "@type": type.googleapis.com/envoy.extensions.filters.network.http_connection_manager.v3.HttpConnectionManager
          codec_type: auto
          stat_prefix: ingress_http
          route_config:
            name: local_route
            virtual_hosts:
            - name: local_service
              domains: ["*"]
              routes:
              - match: { prefix: "/" }
                route: { cluster: echo_service }
          http_filters:
          - name: envoy.grpc_web
            typed_config:
              "@type": type.googleapis.com/envoy.extensions.filters.http.grpc_web.v3.GrpcWeb
          - name: envoy.filters.http.router
            typed_config:
              "@type": type.googleapis.com/envoy.extensions.filters.http.router.v3.Router
  clusters:
  - name: echo_service
    connect_timeout: 0.25s
    type: LOGICAL_DNS
    typed_extension_protocol_options:
      envoy.extensions.upstreams.http.v3.HttpProtocolOptions:
        "@type": type.googleapis.com/envoy.extensions.upstreams.http.v3.HttpProtocolOptions
        explicit_http_config:
          http2_protocol_options: {}
    lb_policy: ROUND_ROBIN
    load_assignment:
      cluster_name: echo_service
      endpoints:
        - lb_endpoints:
          - endpoint:
              address:
                socket_address:
                  address: node-server
                  port_value: 9090

----------------------------------------

TITLE: Server Setup Commands
DESCRIPTION: Shell commands to install and run the gRPC-gateway example server.

LANGUAGE: shell
CODE:
go get -u github.com/philips/grpc-gateway-example
grpc-gateway-example serve

----------------------------------------

TITLE: Initializing Hugo Front Matter Template
DESCRIPTION: A template for Hugo content pages that automatically formats the title by replacing hyphens with spaces and sets the current date. The draft status is set to true by default.

LANGUAGE: hugo
CODE:
---
title: "{{ replace .Name "-" " " | title }}"
date: {{ dateFormat "2006-01-02" .Date }}
draft: true
---

----------------------------------------

TITLE: Compiling and Running gRPC Server in Shell
DESCRIPTION: Compiles the gRPC server using Gradle and runs it, listening on port 50051.

LANGUAGE: sh
CODE:
./gradlew installDist
./build/install/examples/bin/hello-world-server

----------------------------------------

TITLE: Updating Android Client Implementation
DESCRIPTION: Kotlin code showing how to update the Android client to call both SayHello and SayHelloAgain methods and display the combined response.

LANGUAGE: kotlin
CODE:
val response = greeter.sayHello(request)
val againResponse = greeter.sayHelloAgain(request)
val message = "${response.message}\n${againResponse.message}"
responseText.text = message

----------------------------------------

TITLE: Configuring gRPC Blog Menu Item in YAML
DESCRIPTION: This YAML snippet defines the configuration for the gRPC blog menu item. It sets the title, link title, and weight for positioning in the main navigation menu.

LANGUAGE: yaml
CODE:
---
title: gRPC Blog
linkTitle: Blog
menu:
  main: {weight: 6}
---

----------------------------------------

TITLE: Setting Android SDK Environment Variable in Shell
DESCRIPTION: Sets the ANDROID_SDK_ROOT environment variable to the path of your Android SDK installation.

LANGUAGE: sh
CODE:
export ANDROID_SDK_ROOT="<path-to-your-android-sdk>"

----------------------------------------

TITLE: Configuring ALTS Server Credentials in gRPC C++
DESCRIPTION: This code shows how to set up ALTS server credentials when building a gRPC C++ server. It uses the AltsServerCredentials class with default options and adds a listening port with these credentials.

LANGUAGE: cpp
CODE:
#include <grpcpp/security/server_credentials.h>
#include <grpcpp/server.h>
#include <grpcpp/server_builder.h>

using grpc::experimental::AltsServerCredentials;
using grpc::experimental::AltsServerCredentialsOptions;

grpc::ServerBuilder builder;
builder.RegisterService(&service);
auto creds = AltsServerCredentials(AltsServerCredentialsOptions());
builder.AddListeningPort("[::]:<port>", creds);
std::unique_ptr<Server> server(builder.BuildAndStart());

----------------------------------------

TITLE: Configuring ALTS Server Credentials in gRPC C++
DESCRIPTION: This code shows how to set up ALTS server credentials when building a gRPC C++ server. It uses the AltsServerCredentials class with default options and adds a listening port with these credentials.

LANGUAGE: cpp
CODE:
#include <grpcpp/security/server_credentials.h>
#include <grpcpp/server.h>
#include <grpcpp/server_builder.h>

using grpc::experimental::AltsServerCredentials;
using grpc::experimental::AltsServerCredentialsOptions;

grpc::ServerBuilder builder;
builder.RegisterService(&service);
auto creds = AltsServerCredentials(AltsServerCredentialsOptions());
builder.AddListeningPort("[::]:<port>", creds);
std::unique_ptr<Server> server(builder.BuildAndStart());

----------------------------------------

TITLE: Defining YAML Frontmatter for Blog Post
DESCRIPTION: YAML frontmatter defining the title, date, and authors of the blog post about gRPC performance benchmarks on GKE.

LANGUAGE: yaml
CODE:
---
title: gRPC performance benchmarks on GKE
date: 2022-03-01
authors:
  - name: Paulo Castello da Costa
    link: https://github.com/paulosjca
  - name: Jan Tattermusch
    link: https://github.com/jtattermusch
---

----------------------------------------

TITLE: Implementing Server Authentication with SSL/TLS in Dart
DESCRIPTION: This Dart example shows how to create a gRPC client channel and stub with server authentication using SSL/TLS credentials.

LANGUAGE: dart
CODE:
// Load a custom roots file.
final trustedRoot = new File('roots.pem').readAsBytesSync();
final channelCredentials =
    new ChannelCredentials.secure(certificates: trustedRoot);
final channelOptions = new ChannelOptions(credentials: channelCredentials);
final channel = new ClientChannel('myservice.example.com',
    options: channelOptions);
final client = new GreeterClient(channel);

----------------------------------------

TITLE: Go gRPC Client Implementation
DESCRIPTION: Go implementation of GreeterTimer client handling streaming responses

LANGUAGE: go
CODE:
func submit(client greeterTimer.GreeterTimerClient, request *greeterTimer.TimerRequest) error {
	stream, err := client.TimeHello(context.Background(), request)
	if err != nil {
		log.Fatalf("could not submit request: %v", err)
	}
	for {
		batchResponse, err := stream.Recv()
		if err == io.EOF {
			return nil
		}
		if err != nil {
			log.Fatalf("error during batch recv: %v", err)
			return err
		}
		reportBatchResult(batchResponse)
	}
}

----------------------------------------

TITLE: Hugo Frontmatter Configuration for gRPC Docs
DESCRIPTION: YAML frontmatter configuration for the gRPC documentation homepage, specifying the title, menu position, and display options.

LANGUAGE: yaml
CODE:
---
title: Documentation
linkTitle: Docs
no_list: true
menu:
  main: {weight: 2}
---

----------------------------------------

TITLE: Checking gRPC Deadlines in C++
DESCRIPTION: Demonstrates how to check if a gRPC request has been cancelled on the server side in C++. It uses the IsCancelled method of the context object to determine if the client has cancelled the request or if the deadline has been exceeded.

LANGUAGE: cpp
CODE:
if (context->IsCancelled()) {
  return Status(StatusCode::CANCELLED, "Deadline exceeded or Client cancelled, abandoning.");
}

----------------------------------------

TITLE: Calculating Benchmark Iterations in Java
DESCRIPTION: This code snippet shows how to calculate the number of iterations needed for a benchmark to run for a set time (10 seconds in this case). It uses a warmup phase to clean out erratic JVM behavior and estimates the required iterations based on initial timing results.

LANGUAGE: java
CODE:
// This can be found in ProtobufBenchmarker.java benchmark()
int iterations = 1;
// Time action simply reports the time it takes to run a certain action for that number of iterations
long elapsed = timeAction(action, iterations);
while (elapsed < MIN_SAMPLE_TIME_MS) {
    iterations *= 2;
    elapsed = timeAction(action, iterations);
}
// Estimate number of iterations to run for 10 seconds
iterations = (int) ((TARGET_TIME_MS / (double) elapsed) * iterations);

----------------------------------------

TITLE: Creating New .NET Library Project
DESCRIPTION: Commands to create a new class library project using the dotnet CLI and view its contents.

LANGUAGE: bash
CODE:
~/work$ dotnet new classlib -o MyGreeter
The template "Class library" was created successfully.

~/work$ cd MyGreeter
~/work/MyGreeter$ ls -lF
total 12
-rw-rw-r-- 1 kkm kkm   86 Nov  9 16:10 Class1.cs
-rw-rw-r-- 1 kkm kkm  145 Nov  9 16:10 MyGreeter.csproj
drwxrwxr-x 2 kkm kkm 4096 Nov  9 16:10 obj/

----------------------------------------

TITLE: Piggyback Window Updates in gRPC-Go
DESCRIPTION: Optimization that combines stream-level and connection-level window updates into a single flush syscall to reduce overhead.

LANGUAGE: go
CODE:
// Reference implementation: https://github.com/grpc/grpc-go/pull/1273

----------------------------------------

TITLE: Binding Interceptors to gRPC-Web Clients in JavaScript
DESCRIPTION: Example showing how to bind both unary and stream interceptors when instantiating gRPC-Web clients.

LANGUAGE: javascript
CODE:
const promiseClient = new MyServicePromiseClient(
    host, creds, {'unaryInterceptors': [interceptor1, interceptor2, interceptor3]});

const client = new MyServiceClient(
    host, creds, {'streamInterceptors': [interceptor1, interceptor2, interceptor3]});

----------------------------------------

TITLE: Binding Interceptors to gRPC-Web Clients in JavaScript
DESCRIPTION: Example showing how to bind both unary and stream interceptors when instantiating gRPC-Web clients.

LANGUAGE: javascript
CODE:
const promiseClient = new MyServicePromiseClient(
    host, creds, {'unaryInterceptors': [interceptor1, interceptor2, interceptor3]});

const client = new MyServiceClient(
    host, creds, {'streamInterceptors': [interceptor1, interceptor2, interceptor3]});

----------------------------------------

TITLE: Configuring .NET Project File for gRPC
DESCRIPTION: XML configuration showing how to set up the project file to include proto files and properly reference the Grpc.Tools package with PrivateAssets.

LANGUAGE: xml
CODE:
<Project Sdk="Microsoft.NET.Sdk">

  <PropertyGroup>
    <TargetFramework>netstandard2.0</TargetFramework>
  </PropertyGroup>

  <ItemGroup>
    <PackageReference Include="Google.Protobuf" Version="3.6.1" />
    <PackageReference Include="Grpc" Version="1.17.0" />

    <!-- The Grpc.Tools package generates C# sources from .proto files during
         project build, but is not needed by projects using the built library.
         It's IMPORTANT to add the 'PrivateAssets="All"' to this reference: -->
    <PackageReference Include="Grpc.Tools" Version="1.17.0" PrivateAssets="All" />

    <!-- Explicitly include our helloworld.proto file by adding this line: -->
    <Protobuf Include="helloworld.proto" />
  </ItemGroup>

</Project>

----------------------------------------

TITLE: Implementing Gson Marshaller for gRPC
DESCRIPTION: Custom marshaller implementation for converting between Java objects and JSON using Gson

LANGUAGE: java
CODE:
  static <T> Marshaller<T> marshallerFor(Class<T> clz) {
    Gson gson = new Gson();
    return new Marshaller<T>() {
      @Override
      public InputStream stream(T value) {
        return new ByteArrayInputStream(gson.toJson(value, clz).getBytes(StandardCharsets.UTF_8));
      }

      @Override
      public T parse(InputStream stream) {
        return gson.fromJson(new InputStreamReader(stream, StandardCharsets.UTF_8), clz);
      }
    };
  }

----------------------------------------

TITLE: Adding Required NuGet Packages
DESCRIPTION: Commands to add necessary NuGet packages including Grpc, Grpc.Tools, and Google.Protobuf to the project.

LANGUAGE: bash
CODE:
~/work/MyGreeter$ dotnet add package Grpc
info : PackageReference for package 'Grpc' version '1.17.0' added to file '/home/kkm/work/MyGreeter/MyGreeter.csproj'.
~/work/MyGreeter$ dotnet add package Grpc.Tools
info : PackageReference for package 'Grpc.Tools' version '1.17.0' added to file '/home/kkm/work/MyGreeter/MyGreeter.csproj'.
~/work/MyGreeter$ dotnet add package Google.Protobuf
info : PackageReference for package 'Google.Protobuf' version '3.6.1' added to file '/home/kkm/work/MyGreeter/MyGreeter.csproj'.

----------------------------------------

TITLE: Creating Method Descriptors for gRPC Service
DESCRIPTION: Definition of gRPC method descriptors using custom marshallers

LANGUAGE: java
CODE:
  static final MethodDescriptor<CreateRequest, CreateResponse> CREATE_METHOD =
      MethodDescriptor.newBuilder(
          marshallerFor(CreateRequest.class),
          marshallerFor(CreateResponse.class))
          .setFullMethodName(
              MethodDescriptor.generateFullMethodName(SERVICE_NAME, "Create"))
          .setType(MethodType.UNARY)
          .build();

----------------------------------------

TITLE: Target Pattern Query Example
DESCRIPTION: Bazel query command to show all callable targets in examples folder

LANGUAGE: bash
CODE:
~/rules_protobuf$ bazel query //examples/... --output label_kind | sort | column -t

----------------------------------------

TITLE: Configuring App-level Gradle for Kotlin Android gRPC Project
DESCRIPTION: This snippet shows the app-level build.gradle configuration for a Kotlin Android gRPC project. It includes plugin applications, dependency declarations, and Android-specific configurations.

LANGUAGE: groovy
CODE:
apply plugin: 'com.android.application'
apply plugin: 'kotlin-android'
apply plugin: 'kotlin-android-extensions'
apply plugin: 'com.google.protobuf'

repositories {
  mavenCentral()
}

dependencies {
  compile "org.jetbrains.kotlin:kotlin-stdlib-jdk7:$kotlin_version"
  // refer to full example for remaining deps
}

protobuf {
  // The normal gRPC configuration for Android goes here
}

android {
  // Android Studio 3.1 does not automatically pick up 'src/main/kotlin' as source files
  sourceSets {
    main.java.srcDirs += 'src/main/kotlin'
  }
}

----------------------------------------

TITLE: Checking All Links of gRPC Website
DESCRIPTION: Command to check all links (internal and external) of the gRPC website using htmltest.

LANGUAGE: console
CODE:
$ npm run check-links:all

----------------------------------------

TITLE: Registering gRPC Resources with GrpcCleanupRule in Individual Test Methods
DESCRIPTION: This snippet shows how to use GrpcCleanupRule to register gRPC resources for cleanup within individual test methods, allowing for more flexible resource configuration per test.

LANGUAGE: java
CODE:
public class MyTest {
  @Rule
  public GrpcCleanupRule grpcCleanup = new GrpcCleanupRule();
  ...
  private String serverName = InProcessServerBuilder.generateName();
  private InProcessServerBuilder serverBuilder = InProcessServerBuilder
      .forName(serverName).directExecutor();
  private InProcessChannelBuilder channelBuilder = InProcessChannelBuilder
      .forName(serverName).directExecutor();
  ...

  @Test
  public void testFooBar() {
    ...
    grpcCleanup.register(
    	serverBuilder.addService(myServiceImpl).build().start());
    ManagedChannel channel = grpcCleanup.register(
    	channelBuilder.maxInboundMessageSize(1024).build());
    ...
  }
}

----------------------------------------

TITLE: Configuring Google Tag Manager in YAML
DESCRIPTION: YAML configuration snippet for setting up Google Tag Manager. Replace 'GTM-XXXXXXXX' with your actual GTM ID.

LANGUAGE: yaml
CODE:
params:
  gtmID: "GTM-XXXXXXXX" # Replace with your GTM ID

----------------------------------------

TITLE: WebSocket Implementation Example
DESCRIPTION: Traditional WebSocket implementation for real-time communication.

LANGUAGE: javascript
CODE:
const socket = new WebSocket('ws://example.com/data');

socket.onmessage = function(event) {
  const receivedData = JSON.parse(event.data);
  console.log(receivedData);
};

socket.onerror = function(error) {
  console.error('WebSocket Error:', error);
};

----------------------------------------

TITLE: Installing gRPC for Go
DESCRIPTION: Command to install the gRPC runtime for Go using the go get command. This works on Linux, Mac, and Windows platforms.

LANGUAGE: bash
CODE:
go get google.golang.org/grpc

----------------------------------------

TITLE: Visualizing Name Resolution Process in gRPC
DESCRIPTION: This diagram illustrates the sequence of interactions between the client, gRPC library, NameResolverProvider, and NameResolver during the custom name resolution process. It shows how a request is delegated and resolved using a custom name resolver.

LANGUAGE: mermaid
CODE:
sequenceDiagram
  Client ->> gRPC: Request to my-resolver:///my-service
  gRPC ->> NameResolverProvider: requests NameResolver
  NameResolverProvider -->> gRPC: returns NameResolver
  gRPC ->> NameResolver: delegates resolution
  NameResolver -->> gRPC: addresses

----------------------------------------

TITLE: Displaying Python gRPC Package Version for ARM64 Linux Support
DESCRIPTION: This code snippet shows the version number of the grpcio Python package that introduced pre-built wheels for ARM64 Linux.

LANGUAGE: Python
CODE:
v1.38.1

----------------------------------------

TITLE: Configuring Client Health Checking in gRPC Service Config (JSON)
DESCRIPTION: This JSON snippet demonstrates how to configure a gRPC client to perform health checks against the servers it connects to by modifying the service config of the channel. It specifies the service name to monitor for health.

LANGUAGE: json
CODE:
{
  "healthCheckConfig": {
    "serviceName": "foo"
  }
}

----------------------------------------

TITLE: Error Status Code Reference Table - Network Failures
DESCRIPTION: A reference table showing gRPC error status codes specific to network-related failures and timeouts.

LANGUAGE: markdown
CODE:
Case | Status code
-----|-----------
No data transmitted before deadline expires | `GRPC_STATUS_DEADLINE_EXCEEDED`
Some data transmitted before connection breaks | `GRPC_STATUS_UNAVAILABLE`

----------------------------------------

TITLE: Implementing Client-Streaming RPC RecordRoute on Server
DESCRIPTION: Demonstrates the implementation of the RecordRoute client-streaming RPC on the server side using a ServerReadReactor. It shows how to handle multiple client messages and send a single response.

LANGUAGE: cpp
CODE:
grpc::ServerReadReactor<Point>* RecordRoute(CallbackServerContext* context,
                                            RouteSummary* summary) override {
  class Recorder : public grpc::ServerReadReactor<Point> {
   public:
    Recorder(RouteSummary* summary, const std::vector<Feature>* feature_list)
        : start_time_(system_clock::now()),
          summary_(summary),
          feature_list_(feature_list) {
      StartRead(&point_);
    }

    void OnReadDone(bool ok) override {
      if (ok) {
        point_count_++;
        if (!GetFeatureName(point_, *feature_list_).empty()) {
          feature_count_++;
        }
        if (point_count_ != 1) {
          distance_ += GetDistance(previous_, point_);
        }
        previous_ = point_;
        StartRead(&point_);
      } else {
        summary_->set_point_count(point_count_);
        summary_->set_feature_count(feature_count_);
        summary_->set_distance(static_cast<long>(distance_));
        auto secs = std::chrono::duration_cast<std::chrono::seconds>(
            system_clock::now() - start_time_);
        summary_->set_elapsed_time(secs.count());
        Finish(Status::OK);
      }
    }

    void OnDone() override {
      LOG(INFO) << "RPC Completed";
      delete this;
    }

    void OnCancel() override { LOG(ERROR) << "RPC Cancelled"; }

   private:
    system_clock::time_point start_time_;
    RouteSummary* summary_;
    const std::vector<Feature>* feature_list_;
    Point point_;
    int point_count_ = 0;
    int feature_count_ = 0;
    float distance_ = 0.0;
    Point previous_;
  };
  return new Recorder(summary, &feature_list_);
}

----------------------------------------

TITLE: Unary Method Signature for gRPC Server Interface in Go
DESCRIPTION: Signature for a unary RPC method on the generated server interface, where MsgA is the client request and MsgB is the server response.

LANGUAGE: Go
CODE:
Foo(context.Context, *MsgA) (*MsgB, error)

----------------------------------------

TITLE: Client-Streaming Server Interface in Go
DESCRIPTION: Interface for the server-side handler of a client-streaming RPC, providing methods to receive messages from the client and send a response.

LANGUAGE: Go
CODE:
type <ServiceName>_FooServer interface {
	SendAndClose(*MsgA) error
	Recv() (*MsgB, error)
	grpc.ServerStream
}

----------------------------------------

TITLE: Implementing a Client-Side Streaming RPC in Kotlin
DESCRIPTION: Implements the RecordRoute method, which takes a stream of Points and returns a RouteSummary.

LANGUAGE: kotlin
CODE:
override suspend fun recordRoute(requests: Flow<Point>): RouteSummary {
  var pointCount = 0
  var featureCount = 0
  var distance = 0
  var previous: Point? = null
  val stopwatch = Stopwatch.createStarted(ticker)
  requests.collect { request ->
    pointCount++
    if (getFeature(request).exists()) {
      featureCount++
    }
    val prev = previous
    if (prev != null) {
      distance += prev distanceTo request
    }
    previous = request
  }
  return RouteSummary.newBuilder().apply {
    this.pointCount = pointCount
    this.featureCount = featureCount
    this.distance = distance
    this.elapsedTime = Durations.fromMicros(stopwatch.elapsed(TimeUnit.MICROSECONDS))
  }.build()
}

----------------------------------------

TITLE: Implementing Simple RPC Call in Objective-C
DESCRIPTION: Example of making a simple RPC call to GetFeature method with request/response handling.

LANGUAGE: objective-c
CODE:
RTGPoint *point = [RTGPoint message];
point.latitude = 40E7;
point.longitude = -74E7;

GRPCUnaryResponseHandler *handler =
    [[GRPCUnaryResponseHandler alloc] initWithResponseHandler:
        ^(RTGFeature *response, NSError *error) {
          if (response) {
            // Successful response received
          } else {
            // RPC error
          }
        }
                                        responseDispatchQueue:nil];

[[service getFeatureWithMessage:point responseHandler:handler callOptions:nil] start];

----------------------------------------

TITLE: Composer Autoload Configuration
DESCRIPTION: JSON configuration for composer.json to autoload the generated gRPC PHP classes.

LANGUAGE: json
CODE:
{
  "autoload": {
    "psr-4": {
      "": "route_guide/"
    }
  }
}

----------------------------------------

TITLE: Setting up ALTS Server Credentials in gRPC Python
DESCRIPTION: Shows how to configure ALTS server credentials and create a secure server endpoint. The code initializes a gRPC server with ALTS authentication support.

LANGUAGE: python
CODE:
import grpc

server = grpc.server(futures.ThreadPoolExecutor())
server_creds = grpc.alts_server_credentials()
server.add_secure_port(server_address, server_creds)

----------------------------------------

TITLE: Cloning gRPC Repository in Ruby
DESCRIPTION: Commands to clone the gRPC repository and navigate to the Ruby example directory.

LANGUAGE: sh
CODE:
git clone -b {{< param grpc_vers.core >}} --depth 1 --shallow-submodules https://github.com/grpc/grpc
cd grpc
cd examples/ruby/route_guide

----------------------------------------

TITLE: Implementing gRPC Service in Ruby
DESCRIPTION: Example of implementing the RouteGuide service in Ruby, including a simple RPC method and a server-side streaming method.

LANGUAGE: ruby
CODE:
class ServerImpl < RouteGuide::Service
  def get_feature(point, _call)
    name = @feature_db[{
      'longitude' => point.longitude,
      'latitude' => point.latitude }] || ''
    Feature.new(location: point, name: name)
  end

  def list_features(rectangle, _call)
    RectangleEnum.new(@feature_db, rectangle).each
  end
end

----------------------------------------

TITLE: Creating gRPC Client Stub in Ruby
DESCRIPTION: Code snippet showing how to create a gRPC client stub for the RouteGuide service in Ruby.

LANGUAGE: ruby
CODE:
stub = RouteGuide::Stub.new('localhost:50051')

----------------------------------------

TITLE: Package Configuration for gRPC-Web Project
DESCRIPTION: NPM package.json configuration with required dependencies for gRPC-Web project.

LANGUAGE: json
CODE:
{
  "name": "grpc-web-commonjs-example",
  "dependencies": {
    "google-protobuf": "^3.6.1",
    "grpc-web": "^0.4.0"
  },
  "devDependencies": {
    "browserify": "^16.2.2",
    "webpack": "^4.16.5",
    "webpack-cli": "^3.1.0"
  }
}

----------------------------------------

TITLE: Calling Simple RPC Method in Java Client
DESCRIPTION: Demonstrates how to call the simple RPC method getFeature from the client side.

LANGUAGE: Java
CODE:
Point request = Point.newBuilder().setLatitude(lat).setLongitude(lon).build();
Feature feature;
try {
  feature = blockingStub.getFeature(request);
} catch (StatusRuntimeException e) {
  logger.log(Level.WARNING, "RPC failed: {0}", e.getStatus());
  return;
}