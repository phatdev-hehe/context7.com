TITLE: Defining and Running a Video Conversion Task in TypeScript
DESCRIPTION: Demonstrates how to define a long-running task for video conversion using Trigger.dev v3. The task downloads a video, processes it with ffmpeg, uploads to S3, updates a database, and sends an email notification.

LANGUAGE: typescript
CODE:
import { logger, task } from "@trigger.dev/sdk/v3";
import { updateVideoUrl } from "../db.js";
import ffmpeg from "fluent-ffmpeg";
import { Readable } from "node:stream";
import type { ReadableStream } from "node:stream/web";
import * as fs from "node:fs/promises";
import * as path from "node:path";
import { S3Client, PutObjectCommand } from "@aws-sdk/client-s3";
import { sendEmail } from "../email.js";
import { getVideo } from "../db.js";

// Initialize S3 client
const s3Client = new S3Client({
  region: process.env.AWS_REGION,
});

export const convertVideo = task({
  id: "convert-video",
  retry: {
    maxAttempts: 5,
    minTimeoutInMs: 1000,
    maxTimeoutInMs: 10000,
    factor: 2,
  },
  run: async ({ videoId }: { videoId: string }) => {
    const { url, userId } = await getVideo(videoId);

    const outputPath = path.join("/tmp", `output_${videoId}.mp4`);

    const response = await fetch(url);

    await new Promise((resolve, reject) => {
      ffmpeg(Readable.fromWeb(response.body as ReadableStream))
        .videoFilters("scale=iw/2:ih/2")
        .output(outputPath)
        .on("end", resolve)
        .on("error", reject)
        .run();
    });

    const processedContent = await fs.readFile(outputPath);

    // Upload to S3
    const s3Key = `processed-videos/output_${videoId}.mp4`;

    const uploadParams = {
      Bucket: process.env.S3_BUCKET,
      Key: s3Key,
      Body: processedContent,
    };

    await s3Client.send(new PutObjectCommand(uploadParams));
    const s3Url = `https://${process.env.S3_BUCKET}.s3.amazonaws.com/${s3Key}`;

    logger.info("Video converted", { videoId, s3Url });

    // Update database
    await updateVideoUrl(videoId, s3Url);

    await sendEmail(
      userId,
      "Video Processing Complete",
      `Your video has been processed and is available at: ${s3Url}`
    );

    return { success: true, s3Url };
  },
});

----------------------------------------

TITLE: Generating Text and Images with OpenAI APIs using Trigger.dev in TypeScript
DESCRIPTION: This code defines a Trigger.dev task that uses OpenAI's GPT-4o for text generation and DALL-E 3 for image generation. It includes error handling, retries up to 3 times, and returns both the generated text and image URL.

LANGUAGE: typescript
CODE:
import { task } from "@trigger.dev/sdk/v3";
import OpenAI from "openai";

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

type Payload = {
  theme: string;
  description: string;
};

export const generateContent = task({
  id: "generate-content",
  retry: {
    maxAttempts: 3, // Retry up to 3 times
  },
  run: async ({ theme, description }: Payload) => {
    // Generate text
    const textResult = await openai.chat.completions.create({
      model: "gpt-4o",
      messages: generateTextPrompt(theme, description),
    });

    if (!textResult.choices[0]) {
      throw new Error("No content, retrying…");
    }

    // Generate image
    const imageResult = await openai.images.generate({
      model: "dall-e-3",
      prompt: generateImagePrompt(theme, description),
    });

    if (!imageResult.data[0]) {
      throw new Error("No image, retrying…");
    }

    return {
      text: textResult.choices[0],
      image: imageResult.data[0].url,
    };
  },
});

function generateTextPrompt(theme: string, description: string): any {
  return `Theme: ${theme}\n\nDescription: ${description}`;
}

function generateImagePrompt(theme: string, description: string): any {
  return `Theme: ${theme}\n\nDescription: ${description}`;
}

----------------------------------------

TITLE: Implementing Durable Video Processing Workflow
DESCRIPTION: Demonstrates how to implement a durable video processing workflow using Trigger.dev's Checkpoint-Resume System and idempotency keys. The task is broken down into subtasks for processing, uploading, and email notification, ensuring efficient retries and result caching.

LANGUAGE: typescript
CODE:
import { idempotencyKeys, logger, task } from "@trigger.dev/sdk/v3";
import { processVideo, sendUserEmail, uploadToS3 } from "./tasks.js";
import { updateVideoUrl } from "../db.js";

export const convertVideo = task({
  id: "convert-video",
  retry: {
    maxAttempts: 5,
    minTimeoutInMs: 1000,
    maxTimeoutInMs: 10000,
    factor: 2,
  },
  run: async ({ videoId }: { videoId: string }) => {
    // Automatically scope the idempotency key to this run, across retries
    const idempotencyKey = await idempotencyKeys.create(videoId);

    // Process video
    const { processedContent } = await processVideo
      .triggerAndWait({ videoId }, { idempotencyKey })
      .unwrap(); // Calling unwrap will return the output of the subtask, or throw an error if the subtask failed

    // Upload to S3
    const { s3Url } = await uploadToS3
      .triggerAndWait({ processedContent, videoId }, { idempotencyKey })
      .unwrap();

    // Update database
    await updateVideoUrl(videoId, s3Url);

    // Send email, we don't need to wait for this to finish
    await sendUserEmail.trigger({ videoId, s3Url }, { idempotencyKey });

    return { success: true, s3Url };
  },
});

LANGUAGE: typescript
CODE:
import { task, logger } from "@trigger.dev/sdk/v3";
import ffmpeg from "fluent-ffmpeg";
import { Readable } from "node:stream";
import type { ReadableStream } from "node:stream/web";
import * as fs from "node:fs/promises";
import * as path from "node:path";
import { S3Client, PutObjectCommand } from "@aws-sdk/client-s3";
import { sendEmail } from "../email.js";
import { getVideo } from "../db.js";

// Initialize S3 client
const s3Client = new S3Client({
  region: process.env.AWS_REGION,
});

export const processVideo = task({
  id: "process-video",
  run: async ({ videoId }: { videoId: string }) => {
    const { url } = await getVideo(videoId);

    const outputPath = path.join("/tmp", `output_${videoId}.mp4`);
    const response = await fetch(url);

    await logger.trace("ffmpeg", async (span) => {
      await new Promise((resolve, reject) => {
        ffmpeg(Readable.fromWeb(response.body as ReadableStream))
          .videoFilters("scale=iw/2:ih/2")
          .output(outputPath)
          .on("end", resolve)
          .on("error", reject)
          .run();
      });
    });

    const processedContent = await fs.readFile(outputPath);

    await fs.unlink(outputPath);

    return { processedContent: processedContent.toString("base64") };
  },
});

export const uploadToS3 = task({
  id: "upload-to-s3",
  run: async (payload: { processedContent: string; videoId: string }) => {
    const { processedContent, videoId } = payload;

    const s3Key = `processed-videos/output_${videoId}.mp4`;

    const uploadParams = {
      Bucket: process.env.S3_BUCKET,
      Key: s3Key,
      Body: Buffer.from(processedContent, "base64"),
    };

    await s3Client.send(new PutObjectCommand(uploadParams));
    const s3Url = `https://${process.env.S3_BUCKET}.s3.amazonaws.com/${s3Key}`;

    return { s3Url };
  },
});

export const sendUserEmail = task({
  id: "send-user-email",
  run: async ({ videoId, s3Url }: { videoId: string; s3Url: string }) => {
    const { userId } = await getVideo(videoId);

    return await sendEmail(
      userId,
      "Video Processing Complete",
      `Your video has been processed and is available at: ${s3Url}`
    );
  },
});

----------------------------------------

TITLE: Implementing Parent and Child Tasks with Checkpoint-Resume System
DESCRIPTION: Demonstrates how to implement parent and child tasks using Trigger.dev's Checkpoint-Resume System. The parent task triggers a child task and waits for its completion, showcasing the system's ability to handle task dependencies and long-running operations.

LANGUAGE: typescript
CODE:
import { task, wait } from "@trigger.dev/sdk/v3";

export const parentTask = task({
  id: "parent-task",
  run: async () => {
    console.log("Starting parent task");

    // This will cause the parent task to be checkpointed and suspended
    const result = await childTask.triggerAndWait({ data: "some data" });

    console.log("Child task result:", result);

    // This will also cause the task to be checkpointed and suspended
    await wait.for({ seconds: 30 });

    console.log("Resumed after 30 seconds");

    return "Parent task completed";
  },
});

export const childTask = task({
  id: "child-task",
  run: async (payload: { data: string }) => {
    console.log("Starting child task with data:", payload.data);

    // Simulate some work
    await sleep(5);

    return "Child task result";
  },
});

----------------------------------------

TITLE: Implementing News Article Verification System in TypeScript
DESCRIPTION: A comprehensive implementation of a news article verification system using the orchestrator-workers pattern. The system extracts claims from articles, verifies sources, and analyzes historical context using OpenAI models. It utilizes parallel processing and structured task management.

LANGUAGE: typescript
CODE:
import { openai } from "@ai-sdk/openai";
import { batch, logger, task } from "@trigger.dev/sdk/v3";
import { CoreMessage, generateText } from "ai";

// Define types for our workers' outputs
interface Claim {
  id: number;
  text: string;
}

interface SourceVerification {
  claimId: number;
  isVerified: boolean;
  confidence: number;
  explanation: string;
}

interface HistoricalAnalysis {
  claimId: number;
  feasibility: number;
  historicalContext: string;
}

// Worker 1: Claim Extractor
export const extractClaims = task({
  id: "extract-claims",
  run: async ({ article }: { article: string }) => {
    try {
      const messages: CoreMessage[] = [
        {
          role: "system",
          content:
            "Extract distinct factual claims from the news article. Format as numbered claims.",
        },
        {
          role: "user",
          content: article,
        },
      ];

      const response = await generateText({
        model: openai("o1-mini"),
        messages,
      });

      const claims = response.text
        .split("\n")
        .filter((line: string) => line.trim())
        .map((claim: string, index: number) => ({
          id: index + 1,
          text: claim.replace(/^\d+\.\s*/, ""),
        }));

      logger.info("Extracted claims", { claimCount: claims.length });
      return claims;
    } catch (error) {
      logger.error("Error in claim extraction", {
        error: error instanceof Error ? error.message : "Unknown error",
      });
      throw error;
    }
  },
});

// Worker 2: Source Verifier
export const verifySource = task({
  id: "verify-source",
  run: async (claim: Claim) => {
    const response = await generateText({
      model: openai("o1-mini"),
      messages: [
        {
          role: "system",
          content:
            "Verify this claim by considering recent news sources and official statements. Assess reliability.",
        },
        {
          role: "user",
          content: claim.text,
        },
      ],
      experimental_telemetry: {
        isEnabled: true,
        functionId: "verify-source",
      },
    });

    return {
      claimId: claim.id,
      isVerified: false,
      confidence: 0.7,
      explanation: response.text,
    };
  },
});

// Worker 3: Historical Context Analyzer
export const analyzeHistory = task({
  id: "analyze-history",
  run: async (claim: Claim) => {
    const response = await generateText({
      model: openai("o1-mini"),
      messages: [
        {
          role: "system",
          content:
            "Analyze this claim in historical context, considering past announcements and technological feasibility.",
        },
        {
          role: "user",
          content: claim.text,
        },
      ],
      experimental_telemetry: {
        isEnabled: true,
        functionId: "analyze-history",
      },
    });

    return {
      claimId: claim.id,
      feasibility: 0.8,
      historicalContext: response.text,
    };
  },
});

// Orchestrator
export const newsFactChecker = task({
  id: "news-fact-checker",
  run: async ({ article }: { article: string }) => {
    // Step 1: Extract claims
    const claimsResult = await batch.triggerByTaskAndWait([
      { task: extractClaims, payload: { article } },
    ]);

    if (!claimsResult.runs[0].ok) {
      logger.error("Failed to extract claims", {
        error: claimsResult.runs[0].error,
        runId: claimsResult.runs[0].id,
      });
      throw new Error(
        `Failed to extract claims: ${claimsResult.runs[0].error}`
      );
    }

    const claims = claimsResult.runs[0].output;

    // Step 2: Process claims in parallel
    const parallelResults = await batch.triggerByTaskAndWait([
      ...claims.map((claim) => ({ task: verifySource, payload: claim })),
      ...claims.map((claim) => ({ task: analyzeHistory, payload: claim })),
    ]);

    // Split and process results
    const verifications = parallelResults.runs
      .filter(
        (run): run is typeof run & { ok: true } =>
          run.ok && run.taskIdentifier === "verify-source"
      )
      .map((run) => run.output as SourceVerification);

    const historicalAnalyses = parallelResults.runs
      .filter(
        (run): run is typeof run & { ok: true } =>
          run.ok && run.taskIdentifier === "analyze-history"
      )
      .map((run) => run.output as HistoricalAnalysis);

    return { claims, verifications, historicalAnalyses };
  },
});

----------------------------------------

TITLE: Generating Text with OpenAI using Vercel AI SDK in TypeScript
DESCRIPTION: Implementation of a Trigger.dev task that uses the Vercel AI SDK to generate text using OpenAI's GPT-4 Turbo model. The task accepts a prompt as input and returns the AI-generated completion. Requires OpenAI API key as an environment variable.

LANGUAGE: typescript
CODE:
import { logger, task } from "@trigger.dev/sdk/v3";
import { generateText } from "ai";
// Install the package of the AI model you want to use, in this case OpenAI
import { openai } from "@ai-sdk/openai"; // Ensure OPENAI_API_KEY environment variable is set

export const openaiTask = task({
  id: "openai-text-generate",

  run: async (payload: { prompt: string }) => {
    const chatCompletion = await generateText({
      model: openai("gpt-4-turbo"),
      // Add a system message which will be included with the prompt
      system: "You are a friendly assistant!",
      // The prompt passed in from the payload
      prompt: payload.prompt,
    });

    // Log the generated text
    logger.log("chatCompletion text:" + chatCompletion.text);

    return chatCompletion;
  },
});

----------------------------------------

TITLE: Basic Schema Task Implementation with Zod
DESCRIPTION: Demonstrates basic usage of schemaTask with Zod schema validation, including payload validation before task execution.

LANGUAGE: typescript
CODE:
import { schemaTask } from "@trigger.dev/sdk/v3";
import { z } from "zod";

const myTask = schemaTask({
  id: "my-task",
  schema: z.object({
    name: z.string(),
    age: z.number(),
  }),
  run: async (payload) => {
    console.log(payload.name, payload.age);
  },
});

----------------------------------------

TITLE: Implementing OpenAI API Call with Retry in Trigger.dev
DESCRIPTION: This code snippet defines a Trigger.dev task that calls the OpenAI API with custom retry options. It handles potential API failures and empty responses by throwing errors, which triggers the retry mechanism.

LANGUAGE: typescript
CODE:
import { task } from "@trigger.dev/sdk/v3";
import OpenAI from "openai";

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

export const openaiTask = task({
  id: "openai-task",
  //specifying retry options overrides the defaults defined in your trigger.config file
  retry: {
    maxAttempts: 10,
    factor: 1.8,
    minTimeoutInMs: 500,
    maxTimeoutInMs: 30_000,
    randomize: false,
  },
  run: async (payload: { prompt: string }) => {
    //if this fails, it will throw an error and retry
    const chatCompletion = await openai.chat.completions.create({
      messages: [{ role: "user", content: payload.prompt }],
      model: "gpt-3.5-turbo",
    });

    if (chatCompletion.choices[0]?.message.content === undefined) {
      //sometimes OpenAI returns an empty response, let's retry by throwing an error
      throw new Error("OpenAI call failed");
    }

    return chatCompletion.choices[0].message.content;
  },
});

----------------------------------------

TITLE: Implementing LibreOffice PDF Conversion Task
DESCRIPTION: This task fetches a document from a given URL, converts it to PDF using LibreOffice, and uploads the result to an R2 storage bucket. It handles temporary file management, environment-specific configurations, and error handling.

LANGUAGE: typescript
CODE:
import { PutObjectCommand, S3Client } from "@aws-sdk/client-s3";
import { task } from "@trigger.dev/sdk/v3";
import libreoffice from "libreoffice-convert";
import { promisify } from "node:util";
import path from "path";
import fs from "fs";

const convert = promisify(libreoffice.convert);

// Initialize S3 client
const s3Client = new S3Client({
  // How to authenticate to R2: https://developers.cloudflare.com/r2/api/s3/tokens/
  region: "auto",
  endpoint: process.env.R2_ENDPOINT,
  credentials: {
    accessKeyId: process.env.R2_ACCESS_KEY_ID ?? "",
    secretAccessKey: process.env.R2_SECRET_ACCESS_KEY ?? "",
  },
});

export const libreOfficePdfConvert = task({
  id: "libreoffice-pdf-convert",
  run: async (payload: { documentUrl: string }, { ctx }) => {
    // Set LibreOffice path for production environment
    if (ctx.environment.type !== "DEVELOPMENT") {
      process.env.LIBREOFFICE_PATH = "/usr/bin/libreoffice";
    }

    try {
      // Create temporary file paths
      const inputPath = path.join(process.cwd(), `input_${Date.now()}.docx`);
      const outputPath = path.join(process.cwd(), `output_${Date.now()}.pdf`);

      // Download file from URL
      const response = await fetch(payload.documentUrl);
      const buffer = Buffer.from(await response.arrayBuffer());
      fs.writeFileSync(inputPath, buffer);

      const inputFile = fs.readFileSync(inputPath);
      // Convert to PDF using LibreOffice
      const pdfBuffer = await convert(inputFile, ".pdf", undefined);
      fs.writeFileSync(outputPath, pdfBuffer);

      // Upload to R2
      const key = `converted-pdfs/output_${Date.now()}.pdf`;
      await s3Client.send(
        new PutObjectCommand({
          Bucket: process.env.R2_BUCKET,
          Key: key,
          Body: fs.readFileSync(outputPath),
        })
      );

      // Cleanup temporary files
      fs.unlinkSync(inputPath);
      fs.unlinkSync(outputPath);

      return { pdfLocation: key };
    } catch (error) {
      console.error("Error converting PDF:", error);
      throw error;
    }
  },
});

----------------------------------------

TITLE: Implementing AI-Powered Copy Generation and Translation in TypeScript
DESCRIPTION: This code snippet defines a task that generates marketing copy based on a given subject and word count, validates the generated copy, and then translates it to a target language. It uses Vercel's AI SDK to interact with OpenAI models and includes telemetry for LLM logging.

LANGUAGE: typescript
CODE:
import { openai } from "@ai-sdk/openai";
import { task } from "@trigger.dev/sdk/v3";
import { generateText } from "ai";

export interface TranslatePayload {
  marketingSubject: string;
  targetLanguage: string;
  targetWordCount: number;
}

export const generateAndTranslateTask = task({
  id: "generate-and-translate-copy",
  maxDuration: 300, // Stop executing after 5 mins of compute
  run: async (payload: TranslatePayload) => {
    // Step 1: Generate marketing copy
    const generatedCopy = await generateText({
      model: openai("o1-mini"),
      messages: [
        {
          role: "system",
          content: "You are an expert copywriter.",
        },
        {
          role: "user",
          content: `Generate as close as possible to ${payload.targetWordCount} words of compelling marketing copy for ${payload.marketingSubject}`,
        },
      ],
      experimental_telemetry: {
        isEnabled: true,
        functionId: "generate-and-translate-copy",
      },
    });

    // Gate: Validate the generated copy meets the word count target
    const wordCount = generatedCopy.text.split(/\s+/).length;

    if (
      wordCount < payload.targetWordCount - 10 ||
      wordCount > payload.targetWordCount + 10
    ) {
      throw new Error(
        `Generated copy length (${wordCount} words) is outside acceptable range of ${
          payload.targetWordCount - 10
        }-${payload.targetWordCount + 10} words`
      );
    }

    // Step 2: Translate to target language
    const translatedCopy = await generateText({
      model: openai("o1-mini"),
      messages: [
        {
          role: "system",
          content: `You are an expert translator specializing in marketing content translation into ${payload.targetLanguage}.`,
        },
        {
          role: "user",
          content: `Translate the following marketing copy to ${payload.targetLanguage}, maintaining the same tone and marketing impact:\n\n${generatedCopy}`,
        },
      ],
      experimental_telemetry: {
        isEnabled: true,
        functionId: "generate-and-translate-copy",
      },
    });

    return {
      englishCopy: generatedCopy,
      translatedCopy,
    };
  },
});

----------------------------------------

TITLE: Implementing Hacker News Scraping and Summarization Tasks
DESCRIPTION: This code defines two tasks: a parent task that runs on a schedule to scrape Hacker News and coordinate article processing, and a child task that scrapes and summarizes individual articles. It uses BrowserBase, Puppeteer, OpenAI for summarization, and Resend for sending emails.

LANGUAGE: typescript
CODE:
import { render } from "@react-email/render";
import { logger, schedules, task, wait } from "@trigger.dev/sdk/v3";
import { OpenAI } from "openai";
import puppeteer from "puppeteer-core";
import { Resend } from "resend";
import { HNSummaryEmail } from "./summarize-hn-email";

const openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
const resend = new Resend(process.env.RESEND_API_KEY);

// Parent task (scheduled to run 9AM every weekday)
export const summarizeHackerNews = schedules.task({
  id: "summarize-hacker-news",
  cron: {
    pattern: "0 9 * * 1-5",
    timezone: "Europe/London",
  }, // Run at 9 AM, Monday to Friday
  run: async () => {
    // Connect to BrowserBase to proxy the scraping of the Hacker News articles
    const browser = await puppeteer.connect({
      browserWSEndpoint: `wss://connect.browserbase.com?apiKey=${process.env.BROWSERBASE_API_KEY}`,
    });
    logger.info("Connected to Browserbase");

    const page = await browser.newPage();

    // Navigate to Hacker News and scrape top 3 articles
    await page.goto("https://news.ycombinator.com/news", {
      waitUntil: "networkidle0",
    });
    logger.info("Navigated to Hacker News");

    const articles = await page.evaluate(() => {
      const items = document.querySelectorAll(".athing");
      return Array.from(items)
        .slice(0, 3)
        .map((item) => {
          const titleElement = item.querySelector(".titleline > a");
          const link = titleElement?.getAttribute("href");
          const title = titleElement?.textContent;
          return { title, link };
        });
    });
    logger.info("Scraped top 3 articles", { articles });

    await browser.close();
    await wait.for({ seconds: 5 });

    // Use batchTriggerAndWait to process articles
    const summaries = await scrapeAndSummarizeArticle
      .batchTriggerAndWait(
        articles.map((article) => ({
          payload: { title: article.title!, link: article.link! },
        }))
      )
      .then((batch) => batch.runs.filter((run) => run.ok).map((run) => run.output));

    // Send email using Resend
    await resend.emails.send({
      from: "Hacker News Summary <hi@demo.tgr.dev>",
      to: ["james@trigger.dev"],
      subject: "Your morning HN summary",
      html: render(<HNSummaryEmail articles={summaries} />),
    });

    logger.info("Email sent successfully");
  },
});

// Child task for scraping and summarizing individual articles
export const scrapeAndSummarizeArticle = task({
  id: "scrape-and-summarize-articles",
  retry: {
    maxAttempts: 3,
    minTimeoutInMs: 5000,
    maxTimeoutInMs: 10000,
    factor: 2,
    randomize: true,
  },
  run: async ({ title, link }: { title: string; link: string }) => {
    logger.info(`Summarizing ${title}`);

    const browser = await puppeteer.connect({
      browserWSEndpoint: `wss://connect.browserbase.com?apiKey=${process.env.BROWSERBASE_API_KEY}`,
    });
    const page = await browser.newPage();

    // Prevent all assets from loading, images, stylesheets etc
    await page.setRequestInterception(true);
    page.on("request", (request) => {
      if (["script", "stylesheet", "image", "media", "font"].includes(request.resourceType())) {
        request.abort();
      } else {
        request.continue();
      }
    });

    await page.goto(link, { waitUntil: "networkidle0" });
    logger.info(`Navigated to article: ${title}`);

    // Extract the main content of the article
    const content = await page.evaluate(() => {
      const articleElement = document.querySelector("article") || document.body;
      return articleElement.innerText.trim().slice(0, 1500); // Limit to 1500 characters
    });

    await browser.close();

    logger.info(`Extracted content for article: ${title}`, { content });

    // Summarize the content using ChatGPT
    const response = await openai.chat.completions.create({
      model: "gpt-4o",
      messages: [
        {
          role: "user",
          content: `Summarize this article in 2-3 concise sentences:\n\n${content}`,
        },
      ],
    });

    logger.info(`Generated summary for article: ${title}`);

    return {
      title,
      link,
      summary: response.choices[0].message.content,
    };
  },
});

----------------------------------------

TITLE: Implementing React Email Template and Send Function with Trigger.dev
DESCRIPTION: Creates a React email template component and implements a Trigger.dev task for sending emails using Resend. The implementation includes error handling, logging, and support for customizable email content through payload parameters.

LANGUAGE: tsx
CODE:
import { Body, Button, Container, Head, Heading, Html, Preview } from "@react-email/components";
import { logger, task } from "@trigger.dev/sdk/v3";
import { Resend } from "resend";

// Initialize Resend client
const resend = new Resend(process.env.RESEND_API_KEY);

// React Email template component
const EmailTemplate = ({ name, message }: { name: string; message: string }) => (
  <Html lang="en">
    <Head />
    <Preview>New message from {name}</Preview>
    <Body style={{ fontFamily: "Arial, sans-serif", margin: "0", padding: "0" }}>
      <Container style={{ padding: "20px", maxWidth: "600px" }}>
        <Heading>Hello from Acme Inc.</Heading>
        <p>Hi {name},</p>
        <p>{message}</p>
        <Button
          href="https://trigger.dev"
          style={{
            backgroundColor: "#0070f3",
            color: "white",
            padding: "12px 20px",
            borderRadius: "8px",
          }}
        >
          Go to Acme Inc.
        </Button>
      </Container>
    </Body>
  </Html>
);

export const sendEmail = task({
  id: "send-react-email",
  run: async (payload: {
    to: string;
    name: string;
    message: string;
    subject: string;
    from?: string;
  }) => {
    try {
      logger.info("Sending email using React.email and Resend", {
        to: payload.to,
      });

      // Send the email using Resend
      const { data, error } = await resend.emails.send({
        // The from address needs to be a verified email address you own
        from: payload.from || "email@acmeinc.com", // Default from address
        to: payload.to,
        subject: payload.subject,
        react: <EmailTemplate name={payload.name} message={payload.message} />,
      });

      if (error) {
        logger.error("Failed to send email", { error });
        throw new Error(`Failed to send email: ${error.message}`);
      }

      logger.info("Email sent successfully", { emailId: data?.id });

      // Return the response from Resend
      return {
        id: data?.id,
        status: "sent",
      };
    } catch (error) {
      logger.error("Unexpected error sending email", { error });
      throw error;
    }
  },
});

----------------------------------------

TITLE: Implementing Email Sequence Task with Resend in Trigger.dev
DESCRIPTION: This task sends a sequence of emails over several days using Resend. It demonstrates retry mechanisms for individual email sends and uses wait.for to pause between emails. The task handles user information and sends welcome and follow-up emails.

LANGUAGE: typescript
CODE:
import { Resend } from "resend";

const resend = new Resend(process.env.RESEND_ASP_KEY);

export const emailSequence = task({
  id: "email-sequence",
  run: async (payload: { userId: string; email: string; name: string }) => {
    console.log(`Start email sequence for user ${payload.userId}`, payload);

    //send the first email immediately
    const firstEmailResult = await retry.onThrow(
      async ({ attempt }) => {
        const { data, error } = await resend.emails.send({
          from: "hello@trigger.dev",
          to: payload.email,
          subject: "Welcome to Trigger.dev",
          html: `<p>Hello ${payload.name},</p><p>Welcome to Trigger.dev</p>`,
        });

        if (error) {
          //throwing an error will trigger a retry of this block
          throw error;
        }

        return data;
      },
      { maxAttempts: 3 }
    );

    //then wait 3 days
    await wait.for({ days: 3 });

    //send the second email
    const secondEmailResult = await retry.onThrow(
      async ({ attempt }) => {
        const { data, error } = await resend.emails.send({
          from: "hello@trigger.dev",
          to: payload.email,
          subject: "Some tips for you",
          html: `<p>Hello ${payload.name},</p><p>Here are some tips for you…</p>`,
        });

        if (error) {
          //throwing an error will trigger a retry of this block
          throw error;
        }

        return data;
      },
      { maxAttempts: 3 }
    );

    //etc...
  },
});

----------------------------------------

TITLE: Implementing Translation and Refinement Task in TypeScript
DESCRIPTION: A TypeScript implementation of a translation task using Vercel's AI SDK and OpenAI. The code implements an evaluator-optimizer pattern that generates translations and refines them based on feedback over multiple iterations, with a maximum of 10 attempts.

LANGUAGE: typescript
CODE:
import { task } from "@trigger.dev/sdk/v3";
import { generateText } from "ai";
import { openai } from "@ai-sdk/openai";

interface TranslationPayload {
  text: string;
  targetLanguage: string;
  previousTranslation?: string;
  feedback?: string;
  rejectionCount?: number;
}

export const translateAndRefine = task({
  id: "translate-and-refine",
  run: async (payload: TranslationPayload) => {
    const rejectionCount = payload.rejectionCount || 0;

    // Bail out if we've hit the maximum attempts
    if (rejectionCount >= 10) {
      return {
        finalTranslation: payload.previousTranslation,
        iterations: rejectionCount,
        status: "MAX_ITERATIONS_REACHED",
      };
    }

    // Generate translation (or refinement if we have previous feedback)
    const translationPrompt = payload.feedback
      ? `Previous translation: "${payload.previousTranslation}"\n\nFeedback received: "${payload.feedback}"\n\nPlease provide an improved translation addressing this feedback.`
      : `Translate this text into ${payload.targetLanguage}, preserving style and meaning: "${payload.text}"`;

    const translation = await generateText({
      model: openai("o1-mini"),
      messages: [
        {
          role: "system",
          content: `You are an expert literary translator into ${payload.targetLanguage}.
                   Focus on accuracy first, then style and natural flow.`,
        },
        {
          role: "user",
          content: translationPrompt,
        },
      ],
      experimental_telemetry: {
        isEnabled: true,
        functionId: "translate-and-refine",
      },
    });

    // Evaluate the translation
    const evaluation = await generateText({
      model: openai("o1-mini"),
      messages: [
        {
          role: "system",
          content: `You are an expert literary critic and translator focused on practical, high-quality translations.
                 Your goal is to ensure translations are accurate and natural, but not necessarily perfect.
                 This is iteration ${rejectionCount + 1} of a maximum 5 iterations.
                 
                 RESPONSE FORMAT:
                 - If the translation meets 90%+ quality: Respond with exactly "APPROVED" (nothing else)
                 - If improvements are needed: Provide only the specific issues that must be fixed
                 
                 Evaluation criteria:
                 - Accuracy of meaning (primary importance)
                 - Natural flow in the target language
                 - Preservation of key style elements
                 
                 DO NOT provide detailed analysis, suggestions, or compliments.
                 DO NOT include the translation in your response.
                 
                 IMPORTANT RULES:
                 - First iteration MUST receive feedback for improvement
                 - Be very strict on accuracy in early iterations
                 - After 3 iterations, lower quality threshold to 85%`,
        },
        {
          role: "user",
          content: `Original: "${payload.text}"
                 Translation: "${translation.text}"
                 Target Language: ${payload.targetLanguage}
                 Iteration: ${rejectionCount + 1}
                 Previous Feedback: ${payload.feedback ? `"${payload.feedback}"` : "None"}
                 
                 ${rejectionCount === 0 ? "This is the first attempt. Find aspects to improve." : 'Either respond with exactly "APPROVED" or provide only critical issues that must be fixed.'}`
        },
      ],
      experimental_telemetry: {
        isEnabled: true,
        functionId: "translate-and-refine",
      },
    });

    // If approved, return the final result
    if (evaluation.text.trim() === "APPROVED") {
      return {
        finalTranslation: translation.text,
        iterations: rejectionCount,
        status: "APPROVED",
      };
    }

    // If not approved, recursively call the task with feedback
    await translateAndRefine
      .triggerAndWait({
        text: payload.text,
        targetLanguage: payload.targetLanguage,
        previousTranslation: translation.text,
        feedback: evaluation.text,
        rejectionCount: rejectionCount + 1,
      })
      .unwrap();
  },
});

----------------------------------------

TITLE: Implementing Parallel Customer Service Response and Content Moderation in TypeScript
DESCRIPTION: Main implementation that defines three tasks: generating customer responses, checking for inappropriate content, and coordinating parallel execution. Uses OpenAI through Vercel's AI SDK and includes telemetry logging.

LANGUAGE: typescript
CODE:
import { openai } from "@ai-sdk/openai";
import { batch, task } from "@trigger.dev/sdk/v3";
import { generateText } from "ai";

// Task to generate customer response
export const generateCustomerResponse = task({
  id: "generate-customer-response",
  run: async (payload: { question: string }) => {
    const response = await generateText({
      model: openai("o1-mini"),
      messages: [
        {
          role: "system",
          content: "You are a helpful customer service representative.",
        },
        { role: "user", content: payload.question },
      ],
      experimental_telemetry: {
        isEnabled: true,
        functionId: "generate-customer-response",
      },
    });

    return response.text;
  },
});

// Task to check for inappropriate content
export const checkInappropriateContent = task({
  id: "check-inappropriate-content",
  run: async (payload: { text: string }) => {
    const response = await generateText({
      model: openai("o1-mini"),
      messages: [
        {
          role: "system",
          content:
            "You are a content moderator. Respond with 'true' if the content is inappropriate or contains harmful, threatening, offensive, or explicit content, 'false' otherwise.",
        },
        { role: "user", content: payload.text },
      ],
      experimental_telemetry: {
        isEnabled: true,
        functionId: "check-inappropriate-content",
      },
    });

    return response.text.toLowerCase().includes("true");
  },
});

// Main task that coordinates the parallel execution
export const handleCustomerQuestion = task({
  id: "handle-customer-question",
  run: async (payload: { question: string }) => {
    const {
      runs: [responseRun, moderationRun],
    } = await batch.triggerByTaskAndWait([
      {
        task: generateCustomerResponse,
        payload: { question: payload.question },
      },
      {
        task: checkInappropriateContent,
        payload: { text: payload.question },
      },
    ]);

    // Check moderation result first
    if (moderationRun.ok && moderationRun.output === true) {
      return {
        response:
          "I apologize, but I cannot process this request as it contains inappropriate content.",
        wasInappropriate: true,
      };
    }

    // Return the generated response if everything is ok
    if (responseRun.ok) {
      return {
        response: responseRun.output,
        wasInappropriate: false,
      };
    }

    // Handle any errors
    throw new Error("Failed to process customer question");
  },
});

----------------------------------------

TITLE: Defining Basic Trigger.dev Configuration in TypeScript
DESCRIPTION: This snippet shows a basic configuration for a Trigger.dev project, including project reference, task directories, and retry settings.

LANGUAGE: typescript
CODE:
import { defineConfig } from "@trigger.dev/sdk/v3";

export default defineConfig({
  // Your project ref (you can see it on the Project settings page in the dashboard)
  project: "<project ref>",
  //The paths for your trigger folders
  dirs: ["./trigger"],
  retries: {
    //If you want to retry a task in dev mode (when using the CLI)
    enabledInDev: false,
    //the default retry settings. Used if you don't specify on a task.
    default: {
      maxAttempts: 3,
      minTimeoutInMs: 1000,
      maxTimeoutInMs: 10000,
      factor: 2,
      randomize: true,
    },
  },
});

----------------------------------------

TITLE: Implementing Website Crawler with Firecrawl and Trigger.dev
DESCRIPTION: Creates a task that crawls an entire website using Firecrawl, with configurable URL limit and format options. Returns crawl results in LLM-ready format. Requires Firecrawl API key in environment variables.

LANGUAGE: typescript
CODE:
import FirecrawlApp from "@mendable/firecrawl-js";
import { task } from "@trigger.dev/sdk/v3";

// Initialize the Firecrawl client with your API key
const firecrawlClient = new FirecrawlApp({
  apiKey: process.env.FIRECRAWL_API_KEY, // Get this from your Firecrawl dashboard
});

export const firecrawlCrawl = task({
  id: "firecrawl-crawl",
  run: async (payload: { url: string }) => {
    const { url } = payload;

    // Crawl: scrapes all the URLs of a web page and return content in LLM-ready format
    const crawlResult = await firecrawlClient.crawlUrl(url, {
      limit: 100, // Limit the number of URLs to crawl
      scrapeOptions: {
        formats: ["markdown", "html"],
      },
    });

    if (!crawlResult.success) {
      throw new Error(`Failed to crawl: ${crawlResult.error}`);
    }

    return {
      data: crawlResult,
    };
  },
});

----------------------------------------

TITLE: Test Payload for Trigger.dev Task in JSON
DESCRIPTION: This JSON payload can be used to test the Trigger.dev task in the dashboard. It provides a theme and description for generating content about a beautiful sunset over the ocean.

LANGUAGE: json
CODE:
{
  "theme": "A beautiful sunset",
  "description": "A sunset over the ocean with a tiny yacht in the distance."
}

----------------------------------------

TITLE: Python Image Processing Script Implementation
DESCRIPTION: Core Python script that handles image processing operations using Pillow library. Includes functionality for resizing, format conversion, quality adjustment, and various image enhancements.

LANGUAGE: python
CODE:
from PIL import Image, ImageOps, ImageEnhance
import io
from io import BytesIO
import os
from typing import Tuple, List, Dict, Optional, Union
import logging
import sys
import json
import requests

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

class ImageProcessor:
    """Image processing utility for resizing, optimizing, and converting images."""

    # Supported formats for conversion
    SUPPORTED_FORMATS = ['JPEG', 'PNG', 'WEBP', 'GIF', 'AVIF']

    @staticmethod
    def open_image(image_data: Union[bytes, str]) -> Image.Image:
        """Open an image from bytes or file path."""
        try:
            if isinstance(image_data, bytes):
                return Image.open(io.BytesIO(image_data))
            else:
                return Image.open(image_data)
        except Exception as e:
            logger.error(f"Failed to open image: {e}")
            raise ValueError(f"Could not open image: {e}")

    @staticmethod
    def resize_image(
        img: Image.Image,
        width: Optional[int] = None,
        height: Optional[int] = None,
        maintain_aspect_ratio: bool = True
    ) -> Image.Image:
        """
        Resize an image to specified dimensions.

        Args:
            img: PIL Image object
            width: Target width (None to auto-calculate from height)
            height: Target height (None to auto-calculate from width)
            maintain_aspect_ratio: Whether to maintain the original aspect ratio

        Returns:
            Resized PIL Image
        """
        if width is None and height is None:
            return img  # No resize needed

        original_width, original_height = img.size

        if maintain_aspect_ratio:
            if width and height:
                # Calculate the best fit while maintaining aspect ratio
                ratio = min(width / original_width, height / original_height)
                new_width = int(original_width * ratio)
                new_height = int(original_height * ratio)
            elif width:
                # Calculate height based on width
                ratio = width / original_width
                new_width = width
                new_height = int(original_height * ratio)
            else:
                # Calculate width based on height
                ratio = height / original_height
                new_width = int(original_width * ratio)
                new_height = height
        else:
            # Force exact dimensions
            new_width = width if width else original_width
            new_height = height if height else original_height

        return img.resize((new_width, new_height), Image.LANCZOS)

    @staticmethod
    def optimize_image(
        img: Image.Image,
        quality: int = 85,
        format: Optional[str] = None
    ) -> Tuple[bytes, str]:
        """
        Optimize an image for web delivery.

        Args:
            img: PIL Image object
            quality: JPEG/WebP quality (0-100)
            format: Output format (JPEG, PNG, WEBP, etc.)

        Returns:
            Tuple of (image_bytes, format)
        """
        if format is None:
            format = img.format or 'JPEG'

        format = format.upper()
        if format not in ImageProcessor.SUPPORTED_FORMATS:
            format = 'JPEG'  # Default to JPEG if unsupported format

        # Convert mode if needed
        if format == 'JPEG' and img.mode in ('RGBA', 'P'):
            img = img.convert('RGB')

        # Save to bytes
        buffer = io.BytesIO()

        if format == 'JPEG':
            img.save(buffer, format=format, quality=quality, optimize=True)
        elif format == 'PNG':
            img.save(buffer, format=format, optimize=True)
        elif format == 'WEBP':
            img.save(buffer, format=format, quality=quality)
        elif format == 'AVIF':
            img.save(buffer, format=format, quality=quality)
        else:
            img.save(buffer, format=format)

        buffer.seek(0)
        return buffer.getvalue(), format.lower()

    @staticmethod
    def apply_filters(
        img: Image.Image,
        brightness: Optional[float] = None,
        contrast: Optional[float] = None,
        sharpness: Optional[float] = None,
        grayscale: bool = False
    ) -> Image.Image:
        """
        Apply various filters and enhancements to an image.

        Args:
            img: PIL Image object
            brightness: Brightness factor (0.0-2.0, 1.0 is original)
            contrast: Contrast factor (0.0-2.0, 1.0 is original)
            sharpness: Sharpness factor (0.0-2.0, 1.0 is original)
            grayscale: Convert to grayscale if True

        Returns:
            Processed PIL Image
        """
        # Apply grayscale first if requested
        if grayscale:
            img = ImageOps.grayscale(img)
            # Convert back to RGB if other filters will be applied
            if any(x is not None for x in [brightness, contrast, sharpness]):
                img = img.convert('RGB')

        # Apply enhancements
        if brightness is not None:
            img = ImageEnhance.Brightness(img).enhance(brightness)

        if contrast is not None:
            img = ImageEnhance.Contrast(img).enhance(contrast)

        if sharpness is not None:
            img = ImageEnhance.Sharpness(img).enhance(sharpness)

        return img

    @staticmethod
    def process_image(
        image_data: Union[bytes, str],
        width: Optional[int] = None,
        height: Optional[int] = None,
        maintain_aspect_ratio: bool = True,
        quality: int = 85,
        output_format: Optional[str] = None,
        brightness: Optional[float] = None,
        contrast: Optional[float] = None,
        sharpness: Optional[float] = None,
        grayscale: bool = False
    ) -> Dict:
        """
        Process an image with all available options.

        Args:
            image_data: Image bytes or file path
            width: Target width
            height: Target height
            maintain_aspect_ratio: Whether to maintain aspect ratio
            quality: Output quality
            output_format: Output format
            brightness: Brightness adjustment
            contrast: Contrast adjustment
            sharpness: Sharpness adjustment
            grayscale: Convert to grayscale

        Returns:
            Dict with processed image data and metadata
        """
        # Open the image
        img = ImageProcessor.open_image(image_data)
        original_format = img.format
        original_size = img.size

        # Apply filters
        img = ImageProcessor.apply_filters(
            img,
            brightness=brightness,
            contrast=contrast,
            sharpness=sharpness,
            grayscale=grayscale
        )

        # Resize if needed
        if width or height:
            img = ImageProcessor.resize_image(
                img,
                width=width,
                height=height,
                maintain_aspect_ratio=maintain_aspect_ratio
            )

        # Optimize and get bytes
        processed_bytes, actual_format = ImageProcessor.optimize_image(
            img,
            quality=quality,
            format=output_format
        )

        # Return result with metadata
        return {
            "processed_image": processed_bytes,
            "format": actual_format,
            "original_format": original_format,
            "original_size": original_size,
            "new_size": img.size,
            "file_size_bytes": len(processed_bytes)
        }

def process_image(url, height, width, quality):
    # Download image from URL
    response = requests.get(url)
    img = Image.open(BytesIO(response.content))

    # Resize
    img = img.resize((int(width), int(height)), Image.Resampling.LANCZOS)

    # Save with quality setting
    output_path = f"/tmp/processed_{width}x{height}.jpg"
    img.save(output_path, "JPEG", quality=int(quality))

    return output_path

if __name__ == "__main__":
    url = sys.argv[1]
    height = int(sys.argv[2])
    width = int(sys.argv[3])
    quality = int(sys.argv[4])
    maintain_aspect_ratio = sys.argv[5].lower() == 'true'
    output_format = sys.argv[6]
    brightness = float(sys.argv[7]) if sys.argv[7] != 'null' else None
    contrast = float(sys.argv[8]) if sys.argv[8] != 'null' else None
    sharpness = float(sys.argv[9]) if sys.argv[9] != 'null' else None
    grayscale = sys.argv[10].lower() == 'true'

    processor = ImageProcessor()
    result = processor.process_image(
        requests.get(url).content,
        width=width,
        height=height,
        maintain_aspect_ratio=maintain_aspect_ratio,
        quality=quality,
        output_format=output_format,
        brightness=brightness,
        contrast=contrast,
        sharpness=sharpness,
        grayscale=grayscale
    )

    output_path = f"/tmp/processed_{width}x{height}.{result['format']}"
    with open(output_path, 'wb') as f:
        f.write(result['processed_image'])

    print(json.dumps({
        "outputPath": output_path,
        "format": result['format'],
        "originalSize": result['original_size'],
        "newSize": result['new_size'],
        "fileSizeBytes": result['file_size_bytes']
    }))

----------------------------------------

TITLE: Adding Lifecycle Functions to Trigger.dev Configuration in TypeScript
DESCRIPTION: This snippet shows how to add lifecycle functions (onStart, onSuccess, onFailure, init) to the Trigger.dev configuration for task event handling.

LANGUAGE: typescript
CODE:
import { defineConfig } from "@trigger.dev/sdk/v3";

export default defineConfig({
  project: "<project ref>",
  // Your other config settings...
  onSuccess: async (payload, output, { ctx }) => {
    console.log("Task succeeded", ctx.task.id);
  },
  onFailure: async (payload, error, { ctx }) => {
    console.log("Task failed", ctx.task.id);
  },
  onStart: async (payload, { ctx }) => {
    console.log("Task started", ctx.task.id);
  },
  init: async (payload, { ctx }) => {
    console.log("I run before any task is run");
  },
});

----------------------------------------

TITLE: PDF to Image Conversion Task Implementation
DESCRIPTION: Complete task implementation that downloads a PDF, converts it to images using MuPDF, and uploads the resulting images to Cloudflare R2 storage. Includes error handling and cleanup operations.

LANGUAGE: typescript
CODE:
import { logger, task } from "@trigger.dev/sdk/v3";
import { PutObjectCommand, S3Client } from "@aws-sdk/client-s3";
import { execSync } from "child_process";
import fs from "fs";
import path from "path";

// Initialize S3 client
const s3Client = new S3Client({
  region: "auto",
  endpoint: process.env.S3_ENDPOINT,
  credentials: {
    accessKeyId: process.env.R2_ACCESS_KEY_ID ?? "",
    secretAccessKey: process.env.R2_SECRET_ACCESS_KEY ?? "",
  },
});

export const pdfToImage = task({
  id: "pdf-to-image",
  run: async (payload: { pdfUrl: string; documentId: string }) => {
    logger.log("Converting PDF to images", payload);

    const pdfPath = `/tmp/${payload.documentId}.pdf`;
    const outputDir = `/tmp/${payload.documentId}`;

    // Download PDF and convert to images using MuPDF
    execSync(`curl -s -o ${pdfPath} ${payload.pdfUrl}`);
    fs.mkdirSync(outputDir, { recursive: true });
    execSync(`mutool convert -o ${outputDir}/page-%d.png ${pdfPath}`);

    // Upload images to R2
    const uploadedUrls = [];
    for (const file of fs.readdirSync(outputDir)) {
      const s3Key = `images/${payload.documentId}/${file}`;
      const uploadParams = {
        Bucket: process.env.S3_BUCKET,
        Key: s3Key,
        Body: fs.readFileSync(path.join(outputDir, file)),
        ContentType: "image/png",
      };

      logger.log("Uploading to R2", uploadParams);

      await s3Client.send(new PutObjectCommand(uploadParams));
      const s3Url = `https://${process.env.S3_BUCKET}.r2.cloudflarestorage.com/${s3Key}`;
      uploadedUrls.push(s3Url);
      logger.log("Image uploaded to R2", { url: s3Url });
    }

    // Clean up
    fs.rmSync(outputDir, { recursive: true, force: true });
    fs.unlinkSync(pdfPath);

    logger.log("All images uploaded to R2", { urls: uploadedUrls });

    return {
      imageUrls: uploadedUrls,
    };
  },
});

----------------------------------------

TITLE: Implementing Advanced Error Handling for OpenAI API in TypeScript
DESCRIPTION: Shows how to implement advanced error handling and custom retry logic for OpenAI API calls, including rate limit handling and quota management.

LANGUAGE: typescript
CODE:
import { task } from "@trigger.dev/sdk/v3";
import { calculateISO8601DurationOpenAIVariantResetAt, openai } from "./openai.js";

export const openaiTask = task({
  id: "openai-task",
  retry: {
    maxAttempts: 1,
  },
  run: async (payload: { prompt: string }) => {
    const chatCompletion = await openai.chat.completions.create({
      messages: [{ role: "user", content: payload.prompt }],
      model: "gpt-3.5-turbo",
    });

    return chatCompletion.choices[0].message.content;
  },
  handleError: async (payload, error, { ctx, retryAt }) => {
    if (error instanceof OpenAI.APIError) {
      if (!error.status) {
        return {
          skipRetrying: true,
        };
      }

      if (error.status === 429 && error.type === "insufficient_quota") {
        return {
          skipRetrying: true,
        };
      }

      if (!error.headers) {
        //returning undefined means the normal retrying logic will be used
        return;
      }

      const remainingRequests = error.headers["x-ratelimit-remaining-requests"];
      const requestResets = error.headers["x-ratelimit-reset-requests"];

      if (typeof remainingRequests === "string" && Number(remainingRequests) === 0) {
        return {
          retryAt: calculateISO8601DurationOpenAIVariantResetAt(requestResets),
        };
      }

      const remainingTokens = error.headers["x-ratelimit-remaining-tokens"];
      const tokensResets = error.headers["x-ratelimit-reset-tokens"];

      if (typeof remainingTokens === "string" && Number(remainingTokens) === 0) {
        return {
          retryAt: calculateISO8601DurationOpenAIVariantResetAt(tokensResets),
        };
      }
    }
  },
});

----------------------------------------

TITLE: Implementing Retry Logic for HTTP Requests in TypeScript
DESCRIPTION: Demonstrates how to use retry.fetch() for HTTP requests with conditional retrying based on response status and headers.

LANGUAGE: typescript
CODE:
import { task, logger, retry } from "@trigger.dev/sdk/v3";

export const taskWithFetchRetries = task({
  id: "task-with-fetch-retries",
  run: async ({ payload, ctx }) => {
    //if the Response is a 429 (too many requests), it will retry using the data from the response. A lot of good APIs send these headers.
    const headersResponse = await retry.fetch("http://my.host/test-headers", {
      retry: {
        byStatus: {
          "429": {
            strategy: "headers",
            limitHeader: "x-ratelimit-limit",
            remainingHeader: "x-ratelimit-remaining",
            resetHeader: "x-ratelimit-reset",
            resetFormat: "unix_timestamp_in_ms",
          },
        },
      },
    });
    const json = await headersResponse.json();
    logger.info("Fetched headers response", { json });

    //if the Response is a 500-599 (issue with the server you're calling), it will retry up to 10 times with exponential backoff
    const backoffResponse = await retry.fetch("http://my.host/test-backoff", {
      retry: {
        byStatus: {
          "500-599": {
            strategy: "backoff",
            maxAttempts: 10,
            factor: 2,
            minTimeoutInMs: 1_000,
            maxTimeoutInMs: 30_000,
            randomize: false,
          },
        },
      },
    });
    const json2 = await backoffResponse.json();
    logger.info("Fetched backoff response", { json2 });

    //You can additionally specify a timeout. In this case if the response takes longer than 1 second, it will retry up to 5 times with exponential backoff
    const timeoutResponse = await retry.fetch("https://httpbin.org/delay/2", {
      timeoutInMs: 1000,
      retry: {
        timeout: {
          maxAttempts: 5,
          factor: 1.8,
          minTimeoutInMs: 500,
          maxTimeoutInMs: 30_000,
          randomize: false,
        },
      },
    });
    const json3 = await timeoutResponse.json();
    logger.info("Fetched timeout response", { json3 });

    return {
      result: "success",
      payload,
      json,
      json2,
      json3,
    };
  },
});

----------------------------------------

TITLE: CSV Task Implementation in Trigger.dev
DESCRIPTION: The main task code that processes CSV files by downloading, parsing, and distributing rows into batches. Uses metadata.parent for progress updates.

LANGUAGE: typescript
CODE:
Reference file: src/trigger/csv.ts
// Implementation details found in GitHub repository

----------------------------------------

TITLE: Scheduling Reminder Email with wait.until in TypeScript
DESCRIPTION: This snippet demonstrates how to create a task that waits until a specified date before sending a reminder email. It uses the wait.until function to pause execution and the resend.emails.send method to send the email.

LANGUAGE: typescript
CODE:
export const sendReminderEmail = task({
  id: "send-reminder-email",
  run: async (payload: { to: string; name: string; date: string }) => {
    //wait until the date
    await wait.until({ date: new Date(payload.date) });

    //todo send email
    const { data, error } = await resend.emails.send({
      from: "hello@trigger.dev",
      to: payload.to,
      subject: "Don't forget…",
      html: `<p>Hello ${payload.name},</p><p>...</p>`,
    });
  },
});

----------------------------------------

TITLE: Implementing Stripe Webhook Handler in Next.js
DESCRIPTION: This code snippet demonstrates how to create a Stripe webhook handler route in Next.js. It listens for POST requests, verifies the Stripe signature, and triggers a task when a 'checkout.session.completed' event is received.

LANGUAGE: typescript
CODE:
// app/api/stripe-webhook/route.ts
import { NextResponse } from "next/server";
import { tasks } from "@trigger.dev/sdk/v3";
import Stripe from "stripe";
import type { stripeCheckoutCompleted } from "@/trigger/stripe-checkout-completed";
//     👆 **type-only** import

export async function POST(request: Request) {
  const signature = request.headers.get("stripe-signature");
  const payload = await request.text();

  if (!signature || !payload) {
    return NextResponse.json(
      { error: "Invalid Stripe payload/signature" },
      {
        status: 400,
      }
    );
  }

  const event = Stripe.webhooks.constructEvent(
    payload,
    signature,
    process.env.STRIPE_WEBHOOK_SECRET as string
  );

  // Perform the check based on the event type
  switch (event.type) {
    case "checkout.session.completed": {
      // Trigger the task only if the event type is "checkout.session.completed"
      const { id } = await tasks.trigger<typeof stripeCheckoutCompleted>(
        "stripe-checkout-completed",
        event.data.object
      );
      return NextResponse.json({ runId: id });
    }
    default: {
      // Return a response indicating that the event is not handled
      return NextResponse.json(
        { message: "Event not handled" },
        {
          status: 200,
        }
      );
    }
  }
}

----------------------------------------

TITLE: Web Scraping with Puppeteer and BrowserBase Proxy in Trigger.dev
DESCRIPTION: This task demonstrates web scraping using Puppeteer with a BrowserBase proxy to extract the GitHub stars count from the Trigger.dev landing page. It emphasizes the importance of using a proxy for web scraping tasks.

LANGUAGE: typescript
CODE:
import { logger, task } from "@trigger.dev/sdk/v3";
import puppeteer from "puppeteer-core";

export const puppeteerScrapeWithProxy = task({
  id: "puppeteer-scrape-with-proxy",
  run: async () => {
    const browser = await puppeteer.connect({
      browserWSEndpoint: `wss://connect.browserbase.com?apiKey=${process.env.BROWSERBASE_API_KEY}`,
    });

    const page = await browser.newPage();

    try {
      // Navigate to the target website
      await page.goto("https://trigger.dev", { waitUntil: "networkidle0" });

      // Scrape the GitHub stars count
      const starCount = await page.evaluate(() => {
        const starElement = document.querySelector(".github-star-count");
        const text = starElement?.textContent ?? "0";
        const numberText = text.replace(/[^0-9]/g, "");
        return parseInt(numberText);
      });

      logger.info("GitHub star count", { starCount });

      return { starCount };
    } catch (error) {
      logger.error("Error during scraping", {
        error: error instanceof Error ? error.message : String(error),
      });
      throw error;
    } finally {
      await browser.close();
    }
  },
});

----------------------------------------

TITLE: Python PDF Form Data Extraction Script
DESCRIPTION: Python script that downloads a PDF from a URL and extracts form field data using PyMuPDF. Handles various field types and returns structured JSON output.

LANGUAGE: python
CODE:
import fitz  # PyMuPDF
import requests
import os
import json
import sys
from urllib.parse import urlparse

def download_pdf(url):
    """Download PDF from URL to a temporary file"""
    response = requests.get(url)
    response.raise_for_status()

    # Get filename from URL or use default
    filename = os.path.basename(urlparse(url).path) or "downloaded.pdf"
    filepath = os.path.join("/tmp", filename)

    with open(filepath, 'wb') as f:
        f.write(response.content)
    return filepath

def extract_form_data(pdf_path):
    """Extract form data from a PDF file."""
    doc = fitz.open(pdf_path)
    form_data = {}

    for page_num, page in enumerate(doc):
        fields = page.widgets()
        for field in fields:
            field_name = field.field_name or f"unnamed_field_{page_num}_{len(form_data)}"
            field_type = field.field_type_string
            field_value = field.field_value

            # For checkboxes, convert to boolean
            if field_type == "CheckBox":
                field_value = field_value == "Yes"

            form_data[field_name] = {
                "type": field_type,
                "value": field_value,
                "page": page_num + 1
            }

    return form_data

def main():
    if len(sys.argv) < 2:
        print(json.dumps({"error": "PDF URL is required as an argument"}), file=sys.stderr)
        return 1

    url = sys.argv[1]

    try:
        pdf_path = download_pdf(url)
        form_data = extract_form_data(pdf_path)

        # Convert to JSON for structured output
        structured_output = json.dumps(form_data, indent=2)
        print(structured_output)
        return 0
    except Exception as e:
        print(json.dumps({"error": str(e)}), file=sys.stderr)
        return 1

if __name__ == "__main__":
    sys.exit(main())

----------------------------------------

TITLE: Generating PDF and Uploading to R2 using Trigger.dev in TypeScript
DESCRIPTION: This task generates a PDF using react-pdf, saves it to Cloudflare R2, and returns the bucket and key of the uploaded file. It requires R2 credentials and endpoint to be set as environment variables.

LANGUAGE: typescript
CODE:
import { logger, task } from "@trigger.dev/sdk/v3";
import { renderToBuffer, Document, Page, Text, View } from "@react-pdf/renderer";
import { PutObjectCommand, S3Client } from "@aws-sdk/client-s3";

// Initialize R2 client
const r2Client = new S3Client({
  // How to authenticate to R2: https://developers.cloudflare.com/r2/api/s3/tokens/
  region: "auto",
  endpoint: process.env.R2_ENDPOINT,
  credentials: {
    accessKeyId: process.env.R2_ACCESS_KEY_ID ?? "",
    secretAccessKey: process.env.R2_SECRET_ACCESS_KEY ?? "",
  },
});

export const generateResumePDF = task({
  id: "generate-resume-pdf",
  run: async (payload: { text: string }) => {
    // Log the payload
    logger.log("Generating PDF resume", payload);

    // Render the ResumeDocument component to a PDF buffer
    const pdfBuffer = await renderToBuffer(
      <Document>
        <Page size="A4">
          <View>
            <Text>{payload.text}</Text>
          </View>
        </Page>
      </Document>
    );

    // Generate a unique filename based on the text and current timestamp
    const filename = `${payload.text.replace(/\s+/g, "-").toLowerCase()}-${Date.now()}.pdf`;

    // Set the R2 key for the PDF file
    const r2Key = `resumes/${filename}`;

    // Set the upload parameters for R2
    const uploadParams = {
      Bucket: process.env.R2_BUCKET,
      Key: r2Key,
      Body: pdfBuffer,
      ContentType: "application/pdf",
    };

    // Log the upload parameters
    logger.log("Uploading to R2 with params", uploadParams);

    // Upload the PDF to R2
    await r2Client.send(new PutObjectCommand(uploadParams));

    // Return the Bucket and R2 key for the uploaded PDF
    return {
      Bucket: process.env.R2_BUCKET,
      Key: r2Key,
    };
  },
});

----------------------------------------

TITLE: Video Compression Task with FFmpeg
DESCRIPTION: Implementation of a video compression task that fetches a video, compresses it using FFmpeg with H.264 codec, and uploads to R2 storage. Includes compression settings for video and audio quality.

LANGUAGE: typescript
CODE:
import { PutObjectCommand, S3Client } from "@aws-sdk/client-s3";
import { logger, task } from "@trigger.dev/sdk/v3";
import ffmpeg from "fluent-ffmpeg";
import fs from "fs/promises";
import fetch from "node-fetch";
import { Readable } from "node:stream";
import os from "os";
import path from "path";

// Initialize S3 client
const s3Client = new S3Client({
  region: "auto",
  endpoint: process.env.R2_ENDPOINT,
  credentials: {
    accessKeyId: process.env.R2_ACCESS_KEY_ID ?? "",
    secretAccessKey: process.env.R2_SECRET_ACCESS_KEY ?? "",
  },
});

export const ffmpegCompressVideo = task({
  id: "ffmpeg-compress-video",
  run: async (payload: { videoUrl: string }) => {
    const { videoUrl } = payload;

    const tempDirectory = os.tmpdir();
    const outputPath = path.join(tempDirectory, `output_${Date.now()}.mp4`);

    const response = await fetch(videoUrl);

    await new Promise((resolve, reject) => {
      if (!response.body) {
        return reject(new Error("Failed to fetch video"));
      }

      ffmpeg(Readable.from(response.body))
        .outputOptions([
          "-c:v libx264",
          "-crf 28",
          "-preset veryslow",
          "-vf scale=iw/2:ih/2",
          "-c:a aac",
          "-b:a 64k",
          "-ac 1",
        ])
        .output(outputPath)
        .on("end", resolve)
        .on("error", reject)
        .run();
    });

    const compressedVideo = await fs.readFile(outputPath);
    const compressedSize = compressedVideo.length;

    logger.log(`Compressed video size: ${compressedSize} bytes`);
    logger.log(`Temporary compressed video file created`, { outputPath });

    const r2Key = `processed-videos/${path.basename(outputPath)}`;

    const uploadParams = {
      Bucket: process.env.R2_BUCKET,
      Key: r2Key,
      Body: compressedVideo,
    };

    await s3Client.send(new PutObjectCommand(uploadParams));
    logger.log(`Compressed video saved to your r2 bucket`, { r2Key });

    await fs.unlink(outputPath);
    logger.log(`Temporary compressed video file deleted`, { outputPath });

    return {
      Bucket: process.env.R2_BUCKET,
      r2Key,
    };
  },
});

----------------------------------------

TITLE: Configuring Trigger.dev with Sentry Integration
DESCRIPTION: Setup configuration for integrating Sentry error tracking with Trigger.dev. Includes source map uploading, environment initialization, and error handling setup. Requires SENTRY_AUTH_TOKEN and SENTRY_DSN environment variables.

LANGUAGE: typescript
CODE:
import { defineConfig } from "@trigger.dev/sdk/v3";
import { esbuildPlugin } from "@trigger.dev/build/extensions";
import { sentryEsbuildPlugin } from "@sentry/esbuild-plugin";
import * as Sentry from "@sentry/node";

export default defineConfig({
  project: "<project ref>",
  // Your other config settings...
  build: {
    extensions: [
      esbuildPlugin(
        sentryEsbuildPlugin({
          org: "<your-sentry-org>",
          project: "<your-sentry-project>",
          // Find this auth token in settings -> developer settings -> auth tokens
          authToken: process.env.SENTRY_AUTH_TOKEN,
        }),
        { placement: "last", target: "deploy" }
      ),
    ],
  },
  init: async () => {
    Sentry.init({
      // The Data Source Name (DSN) is a unique identifier for your Sentry project.
      dsn: process.env.SENTRY_DSN,
      // Update this to match the environment you want to track errors for
      environment: process.env.NODE_ENV === "production" ? "production" : "development",
    });
  },
  onFailure: async (payload, error, { ctx }) => {
    Sentry.captureException(error, {
      extra: {
        payload,
        ctx,
      },
    });
  },
});

----------------------------------------

TITLE: Implementing Email Sequence Task with Resend and Trigger.dev in TypeScript
DESCRIPTION: Creates a task that sends a welcome email immediately followed by a tips email after 3 days. Each email send operation is wrapped in a retry mechanism that attempts up to 3 times on failure. The task uses wait.for to create delays between emails.

LANGUAGE: typescript
CODE:
import { Resend } from "resend";

const resend = new Resend(process.env.RESEND_ASP_KEY);

export const emailSequence = task({
  id: "email-sequence",
  run: async (payload: { userId: string; email: string; name: string }) => {
    console.log(`Start email sequence for user ${payload.userId}`, payload);

    // Send the first email immediately
    const firstEmailResult = await retry.onThrow(
      async ({ attempt }) => {
        const { data, error } = await resend.emails.send({
          from: "hello@trigger.dev",
          to: payload.email,
          subject: "Welcome to Trigger.dev",
          html: `<p>Hello ${payload.name},</p><p>Welcome to Trigger.dev</p>`,
        });

        if (error) {
          // Throwing an error will trigger a retry of this block
          throw error;
        }

        return data;
      },
      { maxAttempts: 3 }
    );

    // Then wait 3 days
    await wait.for({ days: 3 });

    // Send the second email
    const secondEmailResult = await retry.onThrow(
      async ({ attempt }) => {
        const { data, error } = await resend.emails.send({
          from: "hello@trigger.dev",
          to: payload.email,
          subject: "Some tips for you",
          html: `<p>Hello ${payload.name},</p><p>Here are some tips for you…</p>`,
        });

        if (error) {
          // Throwing an error will trigger a retry of this block
          throw error;
        }

        return data;
      },
      { maxAttempts: 3 }
    );

    //etc...
  },
});

----------------------------------------

TITLE: Implementing JWT Authentication for Supabase in TypeScript
DESCRIPTION: Demonstrates how to create a JWT token for a user and initialize a Supabase client with that token. The code includes error handling for missing environment variables and sets up authentication headers with a one-hour expiration time.

LANGUAGE: typescript
CODE:
async run(payload: { user_id: string }) {
    const { user_id } = payload;

    // Optional error handling
    const jwtSecret = process.env.SUPABASE_JWT_SECRET;
    if (!jwtSecret) {
      throw new Error(
        "SUPABASE_JWT_SECRET is not defined in environment variables"
      );
    }

    // Create a JWT token for the user that expires in 1 hour
    const token = jwt.sign({ sub: user_id }, jwtSecret, { expiresIn: "1h" });

    // Initialize the Supabase client with the JWT token
    const supabase = createClient(
      // These details can be found in your Supabase project settings under `Data API`
      process.env.SUPABASE_URL as string,
      process.env.SUPABASE_ANON_KEY as string,
      {
        global: {
          headers: {
            Authorization: `Bearer ${token}`,
          },
        },
      }
    );

----------------------------------------

TITLE: Implementing Webhook Handler with Next.js App Router
DESCRIPTION: Creates a webhook handler endpoint using Next.js App Router that processes POST requests and triggers a hello world task. Uses the new App Router conventions and NextResponse for handling responses.

LANGUAGE: typescript
CODE:
import type { helloWorldTask } from "@/trigger/example";
import { tasks } from "@trigger.dev/sdk/v3";
import { NextResponse } from "next/server";

export async function POST(req: Request) {
  // Parse the webhook payload
  const payload = await req.json();

  // Trigger the helloWorldTask with the webhook data as the payload
  await tasks.trigger<typeof helloWorldTask>("hello-world", payload);

  return NextResponse.json("OK", { status: 200 });
}

----------------------------------------

TITLE: Defining Basic Scheduled Task with Payload Handling
DESCRIPTION: Shows how to define a scheduled task with access to payload properties including timestamps, timezone, and upcoming schedule information.

LANGUAGE: typescript
CODE:
import { schedules } from "@trigger.dev/sdk/v3";

export const firstScheduledTask = schedules.task({
  id: "first-scheduled-task",
  run: async (payload) => {
    console.log(payload.timestamp);
    console.log(payload.lastTimestamp);
    console.log(payload.timezone);
    const formatted = payload.timestamp.toLocaleString("en-US", {
      timeZone: payload.timezone,
    });
    console.log(payload.scheduleId);
    console.log(payload.externalId);
    console.log(payload.upcoming);
  },
});

----------------------------------------

TITLE: Inserting New User in Supabase Database using Trigger.dev
DESCRIPTION: Task implementation for adding a new user to a Supabase database table. Uses JWT authentication and includes error handling for database operations. Requires Supabase JWT secret, URL, and anonymous key as environment variables.

LANGUAGE: typescript
CODE:
import { createClient } from "@supabase/supabase-js";
import { task } from "@trigger.dev/sdk/v3";
import jwt from "jsonwebtoken";
import { Database } from "database.types";

export const supabaseDatabaseInsert = task({
  id: "add-new-user",
  run: async (payload: { userId: string }) => {
    const { userId } = payload;

    const jwtSecret = process.env.SUPABASE_JWT_SECRET;
    if (!jwtSecret) {
      throw new Error("SUPABASE_JWT_SECRET is not defined in environment variables");
    }

    const token = jwt.sign({ sub: userId }, jwtSecret, { expiresIn: "1h" });

    const supabase = createClient<Database>(
      process.env.SUPABASE_URL as string,
      process.env.SUPABASE_ANON_KEY as string,
      {
        global: {
          headers: {
            Authorization: `Bearer ${token}`,
          },
        },
      }
    );

    const { error } = await supabase.from("user_subscriptions").insert({
      user_id: userId,
    });

    if (error) {
      throw new Error(`Failed to insert new user: ${error.message}`);
    }

    return {
      message: `New user added successfully: ${userId}`,
    };
  },
});

----------------------------------------

TITLE: Implementing Idempotency with Retry Logic in TypeScript
DESCRIPTION: This snippet demonstrates how to use idempotency keys in a task with retry logic. It creates a unique idempotency key for each task run and triggers a child task only once across all retries.

LANGUAGE: typescript
CODE:
import { idempotencyKeys, task } from "@trigger.dev/sdk/v3";

export const myTask = task({
  id: "my-task",
  retry: {
    maxAttempts: 4,
  },
  run: async (payload: any) => {
    // This idempotency key will be unique to this task run, meaning the childTask will only be triggered once across all retries
    const idempotencyKey = await idempotencyKeys.create("my-task-key");

    // childTask will only be triggered once with the same idempotency key
    await childTask.trigger({ foo: "bar" }, { idempotencyKey });

    // Do something else, that may throw an error and cause the task to be retried
    throw new Error("Something went wrong");
  },
});

----------------------------------------

TITLE: Implementing Init Function for Tasks in TypeScript
DESCRIPTION: Shows how to use the init function in a task, which runs before each attempt. This example demonstrates returning data from init that can be used in other lifecycle functions.

LANGUAGE: typescript
CODE:
export const taskWithInitReturn = task({
  id: "task-with-init-return",
  init: async (payload, { ctx }) => {
    return { someData: "someValue" };
  },
  run: async (payload: any, { ctx, init }) => {
    console.log(init.someData); // "someValue"
  },
});

----------------------------------------

TITLE: Configuring Single Task Concurrency in TypeScript
DESCRIPTION: Demonstrates how to set up a task with a concurrency limit of 1, ensuring only one instance runs at a time.

LANGUAGE: typescript
CODE:
export const oneAtATime = task({
  id: "one-at-a-time",
  queue: {
    concurrencyLimit: 1,
  },
  run: async (payload) => {
    //...
  },
});

----------------------------------------

TITLE: Implementing Fal.ai Image to Cartoon Conversion Task in TypeScript
DESCRIPTION: A Trigger.dev task that processes images through Fal.ai's cartoon conversion API and uploads results to Cloudflare R2. Requires Fal.ai API key and Cloudflare R2 credentials. Uses AWS SDK for S3-compatible storage operations.

LANGUAGE: typescript
CODE:
import { logger, task } from "@trigger.dev/sdk/v3";
import { PutObjectCommand, S3Client } from "@aws-sdk/client-s3";
import * as fal from "@fal-ai/serverless-client";
import fetch from "node-fetch";
import { z } from "zod";

// Initialize fal.ai client
fal.config({
  credentials: process.env.FAL_KEY, // Get this from your fal.ai dashboard
});

// Initialize S3-compatible client for Cloudflare R2
const s3Client = new S3Client({
  // How to authenticate to R2: https://developers.cloudflare.com/r2/api/s3/tokens/
  region: "auto",
  endpoint: process.env.R2_ENDPOINT,
  credentials: {
    accessKeyId: process.env.R2_ACCESS_KEY_ID ?? "",
    secretAccessKey: process.env.R2_SECRET_ACCESS_KEY ?? "",
  },
});

export const FalResult = z.object({
  images: z.tuple([z.object({ url: z.string() })]),
});

export const falAiImageToCartoon = task({
  id: "fal-ai-image-to-cartoon",
  run: async (payload: { imageUrl: string; fileName: string }) => {
    logger.log("Converting image to cartoon", payload);

    // Convert image to cartoon using fal.ai
    const result = await fal.subscribe("fal-ai/flux/dev/image-to-image", {
      input: {
        prompt: "Turn the image into a cartoon in the style of a Pixar character",
        image_url: payload.imageUrl,
      },
      onQueueUpdate: (update) => {
        logger.info("Fal.ai processing update", { update });
      },
    });

    const $result = FalResult.parse(result);
    const [{ url: cartoonImageUrl }] = $result.images;

    // Download the cartoon image
    const imageResponse = await fetch(cartoonImageUrl);
    const imageBuffer = await imageResponse.arrayBuffer().then(Buffer.from);

    // Upload to Cloudflare R2
    const r2Key = `cartoons/${payload.fileName}`;
    const uploadParams = {
      Bucket: process.env.R2_BUCKET,
      Key: r2Key,
      Body: imageBuffer,
      ContentType: "image/png",
    };

    logger.log("Uploading cartoon to R2", { key: r2Key });
    await s3Client.send(new PutObjectCommand(uploadParams));

    logger.log("Cartoon uploaded to R2", { key: r2Key });

    return {
      originalUrl: payload.imageUrl,
      cartoonUrl: `File uploaded to storage at: ${r2Key}`,
    };
  },
});

----------------------------------------

TITLE: Implementing Sharp Image Processing Task with Trigger.dev in TypeScript
DESCRIPTION: This code implements a Trigger.dev task for processing images using Sharp. It resizes an image, adds a watermark, and uploads the result to R2 storage. The task uses external services and libraries such as AWS S3, Sharp, and the Node.js file system.

LANGUAGE: typescript
CODE:
import { S3Client } from "@aws-sdk/client-s3";
import { Upload } from "@aws-sdk/lib-storage";
import { logger, task } from "@trigger.dev/sdk/v3";
import fs from "fs/promises";
import os from "os";
import path from "path";
import sharp from "sharp";

// Initialize R2 client using your R2 account details
const r2Client = new S3Client({
  region: "auto",
  endpoint: process.env.R2_ENDPOINT,
  credentials: {
    accessKeyId: process.env.R2_ACCESS_KEY_ID ?? "",
    secretAccessKey: process.env.R2_SECRET_ACCESS_KEY ?? "",
  },
});

export const sharpProcessImage = task({
  id: "sharp-process-image",
  retry: { maxAttempts: 1 },
  run: async (payload: { imageUrl: string; watermarkUrl: string }) => {
    const { imageUrl, watermarkUrl } = payload;
    const outputPath = path.join(os.tmpdir(), `output_${Date.now()}.jpg`);

    const [imageResponse, watermarkResponse] = await Promise.all([
      fetch(imageUrl),
      fetch(watermarkUrl),
    ]);
    const imageBuffer = await imageResponse.arrayBuffer();
    const watermarkBuffer = await watermarkResponse.arrayBuffer();

    await sharp(Buffer.from(imageBuffer))
      .resize(800, 800) // Resize the image to 800x800px
      .composite([
        {
          input: Buffer.from(watermarkBuffer),
          gravity: "southeast", // Position the watermark in the bottom-right corner
        },
      ])
      .jpeg() // Convert to jpeg
      .toBuffer() // Convert to buffer
      .then(async (outputBuffer) => {
        await fs.writeFile(outputPath, outputBuffer); // Write the buffer to file

        const r2Key = `processed-images/${path.basename(outputPath)}`;
        const uploadParams = {
          Bucket: process.env.R2_BUCKET,
          Key: r2Key,
          Body: await fs.readFile(outputPath),
        };

        const upload = new Upload({
          client: r2Client,
          params: uploadParams,
        });

        await upload.done();
        logger.log("Image uploaded to R2 storage.", {
          path: `/${process.env.R2_BUCKET}/${r2Key}`,
        });

        await fs.unlink(outputPath); // Clean up the temporary file
        return { r2Key };
      });
  },
});

----------------------------------------

TITLE: Setting Request-Specific Retry Options in Trigger.dev SDK
DESCRIPTION: Demonstrates how to override retry settings for individual SDK requests using the requestOptions parameter. Shows example of disabling retries for a specific API call.

LANGUAGE: typescript
CODE:
import { runs } from "@trigger.dev/sdk/v3";

async function main() {
  const run = await runs.retrieve("run_1234", {
    retry: {
      maxAttempts: 1, // Disable retries
    },
  });
}

----------------------------------------

TITLE: Implementing Python Web Crawler with Crawl4AI and Playwright
DESCRIPTION: This Python script uses Crawl4AI and Playwright to create a headless browser web crawler. It supports proxy configuration and converts the crawled content to markdown format.

LANGUAGE: python
CODE:
import asyncio
import sys
import os
from crawl4ai import *
from crawl4ai.async_configs import BrowserConfig

async def main(url: str):
    # Get proxy configuration from environment variables
    proxy_url = os.environ.get("PROXY_URL")
    proxy_username = os.environ.get("PROXY_USERNAME")
    proxy_password = os.environ.get("PROXY_PASSWORD")

    # Configure the proxy
    browser_config = None
    if proxy_url:
        if proxy_username and proxy_password:
            # Use authenticated proxy
            proxy_config = {
                "server": proxy_url,
                "username": proxy_username,
                "password": proxy_password
            }
            browser_config = BrowserConfig(proxy_config=proxy_config)
        else:
            # Use simple proxy
            browser_config = BrowserConfig(proxy=proxy_url)
    else:
        browser_config = BrowserConfig()

    async with AsyncWebCrawler(config=browser_config) as crawler:
        result = await crawler.arun(
            url=url,
        )
        print(result.markdown)

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print("Usage: python crawl-url.py <url>")
        sys.exit(1)
    url = sys.argv[1]
    asyncio.run(main(url))

----------------------------------------

TITLE: Triggering a Background Task in TypeScript
DESCRIPTION: Shows how to trigger a background task from a Next.js API route. The task is triggered asynchronously, allowing the API to respond quickly while the task runs in the background.

LANGUAGE: typescript
CODE:
import { NextResponse } from "next/server";
import { tasks } from "@trigger.dev/sdk/v3";
import type { convertVideo } from "./trigger/video";
//     👆 **type-only** import

export async function POST(request: Request) {
  const body = await request.json();

  // Trigger the task, this will return before the task is completed
  const handle = await tasks.trigger<typeof convertVideo>("convert-video", body);

  return NextResponse.json(handle);
}

----------------------------------------

TITLE: Subscribing to a Run with Trigger.dev Realtime API in TypeScript
DESCRIPTION: Demonstrates how to use the runs.subscribeToRun function to subscribe to a specific run and receive real-time updates. This snippet shows how to trigger a task and then iterate over the async iterator to log run updates.

LANGUAGE: typescript
CODE:
import { runs, tasks } from "@trigger.dev/sdk/v3";

// Somewhere in your backend code
async function myBackend() {
  const handle = await tasks.trigger("my-task", { some: "data" });

  for await (const run of runs.subscribeToRun(handle.id)) {
    // This will log the run every time it changes
    console.log(run);
  }
}

----------------------------------------

TITLE: Specifying Machine Requirements for Tasks in TypeScript
DESCRIPTION: Shows how to set machine requirements for a task that needs more resources. This example uses a preset for a larger machine with 4 vCPU and 8 GB RAM.

LANGUAGE: typescript
CODE:
export const heavyTask = task({
  id: "heavy-task",
  machine: {
    preset: "large-1x", // 4 vCPU, 8 GB RAM
  },
  run: async (payload: any, { ctx }) => {
    //...
  },
});

----------------------------------------

TITLE: Thumbnail Generation Task with FFmpeg
DESCRIPTION: Task for generating video thumbnails using FFmpeg, capturing frame at 5-second mark and uploading to R2 storage. Includes image size configuration and proper file cleanup.

LANGUAGE: typescript
CODE:
import { PutObjectCommand, S3Client } from "@aws-sdk/client-s3";
import { logger, task } from "@trigger.dev/sdk/v3";
import ffmpeg from "fluent-ffmpeg";
import fs from "fs/promises";
import fetch from "node-fetch";
import { Readable } from "node:stream";
import os from "os";
import path from "path";

const s3Client = new S3Client({
  region: "auto",
  endpoint: process.env.R2_ENDPOINT,
  credentials: {
    accessKeyId: process.env.R2_ACCESS_KEY_ID ?? "",
    secretAccessKey: process.env.R2_SECRET_ACCESS_KEY ?? "",
  },
});

export const ffmpegGenerateThumbnail = task({
  id: "ffmpeg-generate-thumbnail",
  run: async (payload: { videoUrl: string }) => {
    const { videoUrl } = payload;

    const tempDirectory = os.tmpdir();
    const outputPath = path.join(tempDirectory, `thumbnail_${Date.now()}.jpg`);

    const response = await fetch(videoUrl);

    await new Promise((resolve, reject) => {
      if (!response.body) {
        return reject(new Error("Failed to fetch video"));
      }
      ffmpeg(Readable.from(response.body))
        .screenshots({
          count: 1,
          folder: "/tmp",
          filename: path.basename(outputPath),
          size: "320x240",
          timemarks: ["5"],
        })
        .on("end", resolve)
        .on("error", reject);
    });

    const thumbnail = await fs.readFile(outputPath);

    const r2Key = `thumbnails/${path.basename(outputPath)}`;

    const uploadParams = {
      Bucket: process.env.R2_BUCKET,
      Key: r2Key,
      Body: thumbnail,
    };

    await s3Client.send(new PutObjectCommand(uploadParams));
    const r2Url = `https://${process.env.R2_ACCOUNT_ID}.r2.cloudflarestorage.com/${process.env.R2_BUCKET}/${r2Key}`;
    logger.log("Thumbnail uploaded to R2", { url: r2Url });

    await fs.unlink(outputPath);

    logger.log(`Thumbnail uploaded to S3: ${r2Url}`);

    return {
      thumbnailBuffer: thumbnail,
      thumbnailPath: outputPath,
      r2Url,
    };
  },
});

----------------------------------------

TITLE: Creating a Hello World Task in TypeScript
DESCRIPTION: Demonstrates how to create a simple task that logs a message. The task is exported and includes a unique ID and a run function that accepts a payload with a message.

LANGUAGE: typescript
CODE:
import { task } from "@trigger.dev/sdk/v3";

export const helloWorld = task({
  id: "hello-world",
  run: async (payload: { message: string }) => {
    console.log(payload.message);
  },
});

----------------------------------------

TITLE: Subscribing to Batch Runs in Trigger.dev Realtime API
DESCRIPTION: Illustrates how to use the runs.subscribeToBatch function to subscribe to all runs triggered in a specific batch. This snippet subscribes to runs in the batch with ID 'batch-id' and logs each run update.

LANGUAGE: typescript
CODE:
import { runs } from "@trigger.dev/sdk/v3";

// Somewhere in your backend code
for await (const run of runs.subscribeToBatch("batch-id")) {
  // This will log the run every time it changes, for all runs in the batch with the ID "batch-id"
  console.log(run);
}

----------------------------------------

TITLE: Configuring Task Retries in TypeScript
DESCRIPTION: Illustrates how to set retry options for a task, including maximum attempts, retry factor, and timeout settings. This allows for fine-tuning the task's resilience to failures.

LANGUAGE: typescript
CODE:
export const taskWithRetries = task({
  id: "task-with-retries",
  retry: {
    maxAttempts: 10,
    factor: 1.8,
    minTimeoutInMs: 500,
    maxTimeoutInMs: 30_000,
    randomize: false,
  },
  run: async (payload: any, { ctx }) => {
    //...
  },
});

----------------------------------------

TITLE: Implementing Deepgram Audio Transcription Task in TypeScript
DESCRIPTION: Creates a Trigger.dev task that transcribes audio using Deepgram's API. The task accepts an audio URL, processes it using the Nova-2 model with smart formatting and speaker diarization, and returns the transcription results.

LANGUAGE: typescript
CODE:
import { createClient } from "@deepgram/sdk";
import { logger, task } from "@trigger.dev/sdk/v3";

// Initialize the Deepgram client, using your Deepgram API key (you can find this in your Deepgram account settings).
const deepgram = createClient(process.env.DEEPGRAM_SECRET_KEY);

export const deepgramTranscription = task({
  id: "deepgram-transcribe-audio",
  run: async (payload: { audioUrl: string }) => {
    const { audioUrl } = payload;

    logger.log("Transcribing audio from URL", { audioUrl });

    // Transcribe the audio using Deepgram
    const { result, error } = await deepgram.listen.prerecorded.transcribeUrl(
      {
        url: audioUrl,
      },
      {
        model: "nova-2", // Use the Nova 2 model for the transcription
        smart_format: true, // Automatically format transcriptions to improve readability
        diarize: true, // Recognize speaker changes and assign a speaker to each word in the transcript
      }
    );

    if (error) {
      logger.error("Failed to transcribe audio", { error });
      throw error;
    }

    console.dir(result, { depth: null });

    // Extract the transcription from the result
    const transcription = result.results.channels[0].alternatives[0].paragraphs?.transcript;

    logger.log(`Generated transcription: ${transcription}`);

    return {
      result,
    };
  },
});

----------------------------------------

TITLE: Using useTaskTrigger Hook in React
DESCRIPTION: Example of using the useTaskTrigger hook to trigger a task from a React component, including error handling and loading states.

LANGUAGE: typescript
CODE:
"use client"; // This is needed for Next.js App Router or other RSC frameworks

import { useTaskTrigger } from "@trigger.dev/react-hooks";
import type { myTask } from "@/trigger/myTask";
//     👆 This is the type of your task

export function MyComponent({ publicAccessToken }: { publicAccessToken: string }) {
  //                         pass the type of your task here 👇
  const { submit, handle, error, isLoading } = useTaskTrigger<typeof myTask>("my-task", {
    accessToken: publicAccessToken, // 👈 this is the "trigger" token
  });

  if (error) {
    return <div>Error: {error.message}</div>;
  }

  if (handle) {
    return <div>Run ID: {handle.id}</div>;
  }

  return (
    <button onClick={() => submit({ foo: "bar" })} disabled={isLoading}>
      {isLoading ? "Loading..." : "Trigger Task"}
    </button>
  );
}

----------------------------------------

TITLE: Handling API Errors in Trigger.dev SDK
DESCRIPTION: Example showing how to catch and handle API errors using try-catch blocks with the Trigger.dev SDK. Demonstrates error type checking and accessing error details including status, headers, and body.

LANGUAGE: typescript
CODE:
import { runs, APIError } from "@trigger.dev/sdk/v3";

async function main() {
  try {
    const run = await runs.retrieve("run_1234");
  } catch (error) {
    if (error instanceof ApiError) {
      console.error(`API error: ${error.status}, ${error.headers}, ${error.body}`);
    } else {
      console.error(`Unknown error: ${error.message}`);
    }
  }
}

----------------------------------------

TITLE: Configuring Trigger.dev Build with Python and Playwright Extensions
DESCRIPTION: This snippet shows how to configure the Trigger.dev build process to include Python and Playwright extensions. It sets up the necessary environment for running Python scripts and using a headless Chromium browser.

LANGUAGE: typescript
CODE:
import { defineConfig } from "@trigger.dev/sdk/v3";
import { pythonExtension } from "@trigger.dev/python/extension";
import type { BuildContext, BuildExtension } from "@trigger.dev/core/v3/build";

export default defineConfig({
  project: "<project ref>",
  // Your other config settings...
  build: {
    extensions: [
      // This is required to use the Python extension
      pythonExtension(),
      // This is required to create a headless chromium browser with Playwright
      installPlaywrightChromium(),
    ],
  },
});

// This is a custom build extension to install Playwright and Chromium
export function installPlaywrightChromium(): BuildExtension {
  return {
    name: "InstallPlaywrightChromium",
    onBuildComplete(context: BuildContext) {
      const instructions = [
        // Base and Chromium dependencies
        `RUN apt-get update && apt-get install -y --no-install-recommends \
          curl unzip npm libnspr4 libatk1.0-0 libatk-bridge2.0-0 libatspi2.0-0 \
          libasound2 libnss3 libxcomposite1 libxdamage1 libxfixes3 libxrandr2 \
          libgbm1 libxkbcommon0 \
          && apt-get clean && rm -rf /var/lib/apt/lists/*`,

        // Install Playwright and Chromium
        `RUN npm install -g playwright`,
        `RUN mkdir -p /ms-playwright`,
        `RUN PLAYWRIGHT_BROWSERS_PATH=/ms-playwright python -m playwright install --with-deps chromium`,
      ];

      context.addLayer({
        id: "playwright",
        image: { instructions },
        deploy: {
          env: {
            PLAYWRIGHT_BROWSERS_PATH: "/ms-playwright",
            PLAYWRIGHT_SKIP_BROWSER_DOWNLOAD: "1",
            PLAYWRIGHT_SKIP_BROWSER_VALIDATION: "1",
          },
          override: true,
        },
      });
    },
  };
}

----------------------------------------

TITLE: Configuring Global Task Lifecycle Functions in TypeScript
DESCRIPTION: Shows how to set up global onStart, onSuccess, and onFailure functions in the trigger.config.ts file. These functions will be called for all tasks in the project.

LANGUAGE: typescript
CODE:
import { defineConfig } from "@trigger.dev/sdk/v3";

export default defineConfig({
  project: "proj_1234",
  onStart: async (payload, { ctx }) => {
    console.log("Task started", ctx.task.id);
  },
  onSuccess: async (payload, output, { ctx }) => {
    console.log("Task succeeded", ctx.task.id);
  },
  onFailure: async (payload, error, { ctx }) => {
    console.log("Task failed", ctx.task.id);
  },
});

----------------------------------------

TITLE: Customizing Build Configuration in Trigger.dev TypeScript
DESCRIPTION: This snippet demonstrates how to customize the build process in Trigger.dev, including specifying external packages and JSX options.

LANGUAGE: typescript
CODE:
import { defineConfig } from "@trigger.dev/sdk/v3";

export default defineConfig({
  project: "<project ref>",
  // Your other config settings...
  build: {
    // Don't bundle these packages
    external: ["header-generator"],
    jsx: {
      // Use the Fragment component instead of React.Fragment
      fragment: "Fragment",
      // Use the h function instead of React.createElement
      factory: "h",
      // Turn off automatic runtime
      automatic: false,
    },
    conditions: ["react-server"],
  },
});

----------------------------------------

TITLE: Setting Queue Options for Task Concurrency in TypeScript
DESCRIPTION: Demonstrates how to configure queue options for a task to control concurrency. This example sets a concurrency limit of 1, ensuring the task runs one at a time.

LANGUAGE: typescript
CODE:
export const oneAtATime = task({
  id: "one-at-a-time",
  queue: {
    concurrencyLimit: 1,
  },
  run: async (payload: any, { ctx }) => {
    //...
  },
});

----------------------------------------

TITLE: Configuring Task Directories and Ignore Patterns in TypeScript
DESCRIPTION: This snippet demonstrates how to specify task directories and set ignore patterns for file exclusion in the Trigger.dev configuration.

LANGUAGE: typescript
CODE:
import { defineConfig } from "@trigger.dev/sdk/v3";

export default defineConfig({
  project: "<project ref>",
  dirs: ["./trigger"],
  ignorePatterns: ["**/*.my-test.ts"],
});

----------------------------------------

TITLE: Implementing onFailure Function for Tasks in TypeScript
DESCRIPTION: Demonstrates how to add an onFailure function to a task, which is called when a task run fails after exhausting all retries. It's useful for error notifications or logging.

LANGUAGE: typescript
CODE:
export const taskWithOnFailure = task({
  id: "task-with-on-failure",
  onFailure: async (payload, error, { ctx }) => {
    //...
  },
  run: async (payload: any, { ctx }) => {
    //...
  },
});

----------------------------------------

TITLE: Server Actions Implementation for Trigger.dev Tasks
DESCRIPTION: Implements server actions in Next.js to trigger tasks using a dedicated actions file and client-side button component.

LANGUAGE: typescript
CODE:
"use server";

import type { helloWorldTask } from "@/trigger/example";
import { tasks } from "@trigger.dev/sdk/v3";

export async function myTask() {
  try {
    const handle = await tasks.trigger<typeof helloWorldTask>("hello-world", "James");
    return { handle };
  } catch (error) {
    console.error(error);
    return { error: "something went wrong" };
  }
}

LANGUAGE: typescript
CODE:
"use client";

import { myTask } from "./actions";

export default function Home() {
  return (
    <main className="flex min-h-screen flex-col items-center justify-center p-24">
      <button onClick={async () => { await myTask(); }}>
        Trigger my task
      </button>
    </main>
  );
}

----------------------------------------

TITLE: Uploading to Supabase Storage using AWS S3 Client
DESCRIPTION: Implementation of a Trigger.dev task that uploads files to Supabase Storage using the AWS S3 client. Requires Supabase region, project ID, and S3 access credentials as environment variables.

LANGUAGE: typescript
CODE:
import { PutObjectCommand, S3Client } from "@aws-sdk/client-s3";
import { logger, task } from "@trigger.dev/sdk/v3";
import fetch from "node-fetch";

// Initialize S3 client for Supabase Storage
const s3Client = new S3Client({
  region: process.env.SUPABASE_REGION,
  endpoint: `https://${process.env.SUPABASE_PROJECT_ID}.supabase.co/storage/v1/s3`,
  credentials: {
    accessKeyId: process.env.SUPABASE_ACCESS_KEY_ID ?? "",
    secretAccessKey: process.env.SUPABASE_SECRET_ACCESS_KEY ?? "",
  },
});

export const supabaseStorageUploadS3 = task({
  id: "supabase-storage-upload-s3",
  run: async (payload: { videoUrl: string }) => {
    const { videoUrl } = payload;

    // Fetch the video as an ArrayBuffer
    const response = await fetch(videoUrl);
    const videoArrayBuffer = await response.arrayBuffer();
    const videoBuffer = Buffer.from(videoArrayBuffer);

    const bucket = "my_bucket";
    const objectKey = `video_${Date.now()}.mp4`;

    // Upload the video directly to Supabase Storage
    await s3Client.send(
      new PutObjectCommand({
        Bucket: bucket,
        Key: objectKey,
        Body: videoBuffer,
      })
    );
    logger.log(`Video uploaded to Supabase Storage bucket`, { objectKey });

    // Return the video object key
    return {
      objectKey,
      bucket: bucket,
    };
  },
});

----------------------------------------

TITLE: Task Chaining with triggerAndWait
DESCRIPTION: Example showing how to trigger a task from within another task and wait for its result

LANGUAGE: typescript
CODE:
export const parentTask = task({
  id: "parent-task",
  run: async (payload: string) => {
    const result = await childTask.triggerAndWait("some-data");
    if (result.ok) {
      console.log("Result", result.output);
    } else {
      console.error("Error", result.error);
    }
  },
});

----------------------------------------

TITLE: Schema Task Implementation Examples
DESCRIPTION: Collection of schema task implementations using different validation libraries including Yup, Superstruct, ArkType, Effect/schema, Runtypes, Valibot, Typebox, and custom parser.

LANGUAGE: typescript
CODE:
import { schemaTask } from "@trigger.dev/sdk/v3";
import * as yup from "yup";

export const yupTask = schemaTask({
  id: "types/yup",
  schema: yup.object({
    bar: yup.string().required(),
    baz: yup.string().default("foo"),
  }),
  run: async (payload) => {
    console.log(payload.bar, payload.baz);
  },
});

----------------------------------------

TITLE: Configuring and Using Trigger.dev Management API in TypeScript
DESCRIPTION: This snippet demonstrates how to import, configure, and use the Trigger.dev management API in a TypeScript environment. It shows how to set up the API with a secret key and list runs with specific parameters.

LANGUAGE: typescript
CODE:
import { configure, runs } from "@trigger.dev/sdk/v3";

configure({
  // this is the default and if the `TRIGGER_SECRET_KEY` environment variable is set, can omit calling configure
  secretKey: process.env["TRIGGER_SECRET_KEY"],
});

async function main() {
  const runs = await runs.list({
    limit: 10,
    status: ["COMPLETED"],
  });
}

main().catch(console.error);

----------------------------------------

TITLE: Configuring Production Deployment Workflow in GitHub Actions
DESCRIPTION: GitHub Actions workflow configuration for deploying Trigger.dev tasks to production environment. Triggers on push to main branch and requires TRIGGER_ACCESS_TOKEN secret.

LANGUAGE: yaml
CODE:
name: Deploy to Trigger.dev (prod)

on:
  push:
    branches:
      - main

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Use Node.js 20.x
        uses: actions/setup-node@v4
        with:
          node-version: "20.x"

      - name: Install dependencies
        run: npm install

      - name: 🚀 Deploy Trigger.dev
        env:
          TRIGGER_ACCESS_TOKEN: ${{ secrets.TRIGGER_ACCESS_TOKEN }}
        run: |
          npx trigger.dev@latest deploy

----------------------------------------

TITLE: Pages Router API Implementation for Trigger.dev
DESCRIPTION: Creates an API route handler in Next.js Pages Router to trigger tasks with proper type safety and error handling.

LANGUAGE: typescript
CODE:
import { helloWorldTask } from "@/trigger/example";
import { tasks } from "@trigger.dev/sdk/v3";
import type { NextApiRequest, NextApiResponse } from "next";

export default async function handler(req: NextApiRequest, res: NextApiResponse<{ id: string }>) {
  const handle = await tasks.trigger<typeof helloWorldTask>("hello-world", "James");
  res.status(200).json(handle);
}

----------------------------------------

TITLE: Adding Cleanup Function to Tasks in TypeScript
DESCRIPTION: Illustrates how to add a cleanup function to a task, which runs after the main task execution regardless of success or failure. It's useful for resource cleanup or logging.

LANGUAGE: typescript
CODE:
export const taskWithCleanup = task({
  id: "task-with-cleanup",
  cleanup: async (payload, { ctx }) => {
    //...
  },
  run: async (payload: any, { ctx }) => {
    //...
  },
});

----------------------------------------

TITLE: Type-safe Metadata Implementation
DESCRIPTION: Example of implementing type-safe metadata using Zod schema validation.

LANGUAGE: typescript
CODE:
import { task, metadata } from "@trigger.dev/sdk/v3";
import { z } from "zod";

const Metadata = z.object({
  user: z.object({
    name: z.string(),
    id: z.string(),
  }),
  date: z.coerce.date(),
});

type Metadata = z.infer<typeof Metadata>;

function getMetadata() {
  return Metadata.parse(metadata.current());
}

export const myTask = task({
  id: "my-task",
  run: async (payload: { message: string }) => {
    const metadata = getMetadata();
    console.log(metadata.user.name);
    console.log(metadata.user.id);
    console.log(metadata.date);
  },
});

----------------------------------------

TITLE: Self-hosted Deployment Workflow in GitHub Actions
DESCRIPTION: GitHub Actions workflow for deploying Trigger.dev in self-hosted environments. Includes Docker setup and additional configuration for custom API endpoints.

LANGUAGE: yaml
CODE:
name: Deploy to Trigger.dev (self-hosted)

on:
  push:
    branches:
      - main

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Use Node.js 20.x
        uses: actions/setup-node@v4
        with:
          node-version: "20.x"

      - name: Install dependencies
        run: npm install

      # docker setup - part 1
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # docker setup - part 2
      - name: Login to DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: 🚀 Deploy Trigger.dev
        env:
          TRIGGER_ACCESS_TOKEN: ${{ secrets.TRIGGER_ACCESS_TOKEN }}
          # required when self-hosting
          TRIGGER_API_URL: ${{ secrets.TRIGGER_API_URL }}
        # deploy with additional flags
        run: |
          npx trigger.dev@latest deploy --self-hosted --push

----------------------------------------

TITLE: Using useRealtimeRunWithStreams Hook in React
DESCRIPTION: Shows how to use the useRealtimeRunWithStreams hook to subscribe to a run and receive streams emitted by the task. It includes examples of basic usage and type inference for streams.

LANGUAGE: tsx
CODE:
"use client"; // This is needed for Next.js App Router or other RSC frameworks

import { useRealtimeRunWithStreams } from "@trigger.dev/react-hooks";

export function MyComponent({
  runId,
  publicAccessToken,
}: {
  runId: string;
  publicAccessToken: string;
}) {
  const { run, streams, error } = useRealtimeRunWithStreams(runId, {
    accessToken: publicAccessToken,
  });

  if (error) return <div>Error: {error.message}</div>;

  return (
    <div>
      <div>Run: {run.id}</div>
      <div>
        {Object.keys(streams).map((stream) => (
          <div key={stream}>Stream: {stream}</div>
        ))}
      </div>
    </div>
  );
}

----------------------------------------

TITLE: Generating PDF from Webpage with Puppeteer and Trigger.dev
DESCRIPTION: This task uses Puppeteer to generate a PDF from the Trigger.dev landing page and upload it to Cloudflare R2. It demonstrates more advanced Puppeteer usage and integration with cloud storage.

LANGUAGE: typescript
CODE:
import { logger, task } from "@trigger.dev/sdk/v3";
import puppeteer from "puppeteer";
import { PutObjectCommand, S3Client } from "@aws-sdk/client-s3";

// Initialize S3 client
const s3Client = new S3Client({
  region: "auto",
  endpoint: process.env.S3_ENDPOINT,
  credentials: {
    accessKeyId: process.env.R2_ACCESS_KEY_ID ?? "",
    secretAccessKey: process.env.R2_SECRET_ACCESS_KEY ?? "",
  },
});

export const puppeteerWebpageToPDF = task({
  id: "puppeteer-webpage-to-pdf",
  run: async () => {
    const browser = await puppeteer.launch();
    const page = await browser.newPage();
    const response = await page.goto("https://trigger.dev");
    const url = response?.url() ?? "No URL found";

    // Generate PDF from the web page
    const generatePdf = await page.pdf();

    logger.info("PDF generated from URL", { url });

    await browser.close();

    // Upload to R2
    const s3Key = `pdfs/test.pdf`;
    const uploadParams = {
      Bucket: process.env.S3_BUCKET,
      Key: s3Key,
      Body: generatePdf,
      ContentType: "application/pdf",
    };

    logger.log("Uploading to R2 with params", uploadParams);

    // Upload the PDF to R2 and return the URL.
    await s3Client.send(new PutObjectCommand(uploadParams));
    const s3Url = `https://${process.env.S3_BUCKET}.s3.amazonaws.com/${s3Key}`;
    logger.log("PDF uploaded to R2", { url: s3Url });
    return { pdfUrl: s3Url };
  },
});

----------------------------------------

TITLE: Atomic Deploys with Vercel GitHub Integration
DESCRIPTION: GitHub Actions workflow for atomic deploys using Vercel's GitHub integration. It waits for Vercel deployment, deploys to Trigger.dev, and then promotes the Vercel deployment.

LANGUAGE: yaml
CODE:
name: Deploy to Trigger.dev (prod)

on:
  push:
    branches:
      - main

concurrency:
  group: ${{ github.workflow }}
  cancel-in-progress: true

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Use Node.js 20.x
        uses: actions/setup-node@v4
        with:
          node-version: "20.x"

      - name: Install dependencies
        run: npm install

      - name: Wait for vercel deployment (push)
        id: wait-for-vercel
        uses: ludalex/vercel-wait@v1
        with:
          project-id: ${{ secrets.VERCEL_PROJECT_ID }}
          team-id: ${{ secrets.VERCEL_SCOPE_NAME }}
          token: ${{ secrets.VERCEL_TOKEN }}
          sha: ${{ github.sha }}

      - name: 🚀 Deploy Trigger.dev
        id: deploy-trigger
        env:
          TRIGGER_ACCESS_TOKEN: ${{ secrets.TRIGGER_ACCESS_TOKEN }}
        run: |
          npx trigger.dev@latest deploy

      - name: Promote Vercel deploy
        run: npx vercel promote $VERCEL_DEPLOYMENT_ID --yes --token $VERCEL_TOKEN --scope $VERCEL_SCOPE_NAME
        env:
          VERCEL_DEPLOYMENT_ID: ${{ steps.wait-for-vercel.outputs.deployment-id }}
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          VERCEL_SCOPE_NAME: ${{ secrets.VERCEL_SCOPE_NAME }}

----------------------------------------

TITLE: Implementing onStart Function for Tasks in TypeScript
DESCRIPTION: Demonstrates how to use the onStart function in a task, which is called when a task run starts. It's useful for notifications or logging at the beginning of a task execution.

LANGUAGE: typescript
CODE:
export const taskWithOnStart = task({
  id: "task-with-on-start",
  onStart: async (payload, { ctx }) => {
    //...
  },
  run: async (payload: any, { ctx }) => {
    //...
  },
});

----------------------------------------

TITLE: Implementing Payload-based Idempotency in TypeScript
DESCRIPTION: This snippet demonstrates how to implement payload-based idempotency by hashing the payload and using the hash as the idempotency key. It uses Node.js crypto to create a SHA-256 hash of the payload.

LANGUAGE: typescript
CODE:
import { idempotencyKeys, task } from "@trigger.dev/sdk/v3";
import { createHash } from "node:crypto";

// Somewhere in your code
const idempotencyKey = await idempotencyKeys.create(hash(childPayload));
// childTask will only be triggered once with the same idempotency key
await tasks.trigger("child-task", { some: "payload" }, { idempotencyKey });

// Create a hash of the payload using Node.js crypto
// Ideally, you'd do a stable serialization of the payload before hashing, to ensure the same payload always results in the same hash
function hash(payload: any): string {
  const hash = createHash("sha256");
  hash.update(JSON.stringify(payload));
  return hash.digest("hex");
}

----------------------------------------

TITLE: Implementing Route Handler in Next.js App Router
DESCRIPTION: Creates a route handler in Next.js App Router to trigger a hello world task. Supports both standard and edge runtime.

LANGUAGE: typescript
CODE:
import type { helloWorldTask } from "@/trigger/example";
import { tasks } from "@trigger.dev/sdk/v3";
import { NextResponse } from "next/server";

export async function GET() {
  const handle = await tasks.trigger<typeof helloWorldTask>("hello-world", "James");
  return NextResponse.json(handle);
}

----------------------------------------

TITLE: Using useRealtimeRun Hook in React
DESCRIPTION: Demonstrates how to use the useRealtimeRun hook to subscribe to a run by its ID. It shows basic usage, type inference, and handling of completion callbacks.

LANGUAGE: tsx
CODE:
"use client"; // This is needed for Next.js App Router or other RSC frameworks

import { useRealtimeRun } from "@trigger.dev/react-hooks";

export function MyComponent({
  runId,
  publicAccessToken,
}: {
  runId: string;
  publicAccessToken: string;
}) {
  const { run, error } = useRealtimeRun(runId, {
    accessToken: publicAccessToken,
  });

  if (error) return <div>Error: {error.message}</div>;

  return <div>Run: {run.id}</div>;
}

----------------------------------------

TITLE: Accessing Raw HTTP Responses in Trigger.dev API (TypeScript)
DESCRIPTION: This snippet demonstrates how to use the Trigger.dev SDK to retrieve run data and access the underlying HTTP response details. It showcases two methods: using the withResponse() helper and the asResponse() method to obtain raw response information.

LANGUAGE: typescript
CODE:
import { runs } from "@trigger.dev/sdk/v3";

async function main() {
  const { data: run, response: raw } = await runs.retrieve("run_1234").withResponse();

  console.log(raw.status);
  console.log(raw.headers);

  const response = await runs.retrieve("run_1234").asResponse(); // Returns a Response object

  console.log(response.status);
  console.log(response.headers);
}

----------------------------------------

TITLE: Setting Max Duration for Specific Run
DESCRIPTION: Shows how to set maximum duration when triggering a specific task run, including both timed and unlimited duration options.

LANGUAGE: typescript
CODE:
import { maxDurationTask } from "./trigger/max-duration-task";
import { timeout } from "@trigger.dev/sdk/v3";

// Trigger the task with a maxDuration of 300 seconds
const run = await maxDurationTask.trigger(
  { foo: "bar" },
  {
    maxDuration: 300, // 300 seconds or 5 minutes
  }
);

// Trigger the task with no maxDuration
const run = await maxDurationTask.trigger(
  { foo: "bar" },
  {
    maxDuration: timeout.None, // No max duration
  }
);

----------------------------------------

TITLE: Configuring Trigger.dev for Puppeteer
DESCRIPTION: This snippet shows how to configure the trigger.config.ts file to use Puppeteer with Trigger.dev. It imports the necessary modules and defines the configuration including the Puppeteer extension.

LANGUAGE: typescript
CODE:
import { defineConfig } from "@trigger.dev/sdk/v3";
import { puppeteer } from "@trigger.dev/build/extensions/puppeteer";

export default defineConfig({
  project: "<project ref>",
  // Your other config settings...
  build: {
    // This is required to use the Puppeteer library
    extensions: [puppeteer()],
  },
});

----------------------------------------

TITLE: Configuring FFmpeg Build Extension in Trigger.dev
DESCRIPTION: This snippet demonstrates how to add the FFmpeg build extension to a Trigger.dev project configuration. It imports necessary modules and defines the configuration with the FFmpeg extension.

LANGUAGE: typescript
CODE:
import { defineConfig } from "@trigger.dev/sdk/v3";
import { ffmpeg } from "@trigger.dev/build/extensions/core";

export default defineConfig({
  project: "<project ref>",
  // Your other config settings...
  build: {
    extensions: [ffmpeg()],
  },
});

----------------------------------------

TITLE: Implementing Atomic Deploys with GitHub Actions and Vercel CLI
DESCRIPTION: GitHub Actions workflow that demonstrates atomic deploys using Trigger.dev and Vercel CLI. It deploys tasks to Trigger.dev without promotion, captures the version, and deploys to Vercel with the correct task version.

LANGUAGE: yaml
CODE:
name: Deploy to Trigger.dev (prod)
on:
  push:
    branches:
      - main
concurrency:
  group: ${{ github.workflow }}
  cancel-in-progress: true
jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Use Node.js 20.x
        uses: actions/setup-node@v4
        with:
          node-version: "20.x"

      - name: Install dependencies
        run: npm install

      - name: Deploy Trigger.dev
        id: deploy-trigger
        env:
          TRIGGER_ACCESS_TOKEN: ${{ secrets.TRIGGER_ACCESS_TOKEN }}
        run: |
          npx trigger.dev@latest deploy --skip-promotion

      - name: Deploy to Vercel
        run: npx vercel --yes --prod -e TRIGGER_VERSION=$TRIGGER_VERSION --token $VERCEL_TOKEN
        env:
          VERCEL_TOKEN: ${{ secrets.VERCEL_TOKEN }}
          TRIGGER_VERSION: ${{ steps.deploy-trigger.outputs.deploymentVersion }}

      - name: Promote Trigger.dev Version
        if: false
        run: npx trigger.dev@latest promote $TRIGGER_VERSION
        env:
          TRIGGER_ACCESS_TOKEN: ${{ secrets.TRIGGER_ACCESS_TOKEN }}
          TRIGGER_VERSION: ${{ steps.deploy-trigger.outputs.deploymentVersion }}

----------------------------------------

TITLE: Implementing Stripe Webhook Handler in Remix
DESCRIPTION: This code snippet shows how to set up a Stripe webhook handler in a Remix application. It validates the Stripe webhook payload, constructs the event, and triggers a task for 'checkout.session.completed' events.

LANGUAGE: typescript
CODE:
// app/webhooks.stripe.ts
import { type ActionFunctionArgs, json } from "@remix-run/node";
import type { stripeCheckoutCompleted } from "src/trigger/stripe-webhook";
//     👆 **type-only** import
import { tasks } from "@trigger.dev/sdk/v3";
import Stripe from "stripe";

export async function action({ request }: ActionFunctionArgs) {
  // Validate the Stripe webhook payload
  const signature = request.headers.get("stripe-signature");
  const payload = await request.text();

  if (!signature || !payload) {
    return json({ error: "Invalid Stripe payload/signature" }, { status: 400 });
  }

  const event = Stripe.webhooks.constructEvent(
    payload,
    signature,
    process.env.STRIPE_WEBHOOK_SECRET as string
  );

  // Perform the check based on the event type
  switch (event.type) {
    case "checkout.session.completed": {
      // Trigger the task only if the event type is "checkout.session.completed"
      const { id } = await tasks.trigger<typeof stripeCheckoutCompleted>(
        "stripe-checkout-completed",
        event.data.object
      );
      return json({ runId: id });
    }
    default: {
      // Return a response indicating that the event is not handled
      return json({ message: "Event not handled" }, { status: 200 });
    }
  }
}

----------------------------------------

TITLE: Configuring Global Retry Options in Trigger.dev SDK
DESCRIPTION: Shows how to configure global retry behavior for all SDK requests using the configure function. Includes options for maximum attempts, timeout ranges, backoff factor, and randomization.

LANGUAGE: typescript
CODE:
import { configure } from "@trigger.dev/sdk/v3";

configure({
  requestOptions: {
    retry: {
      maxAttempts: 5,
      minTimeoutInMs: 1000,
      maxTimeoutInMs: 5000,
      factor: 1.8,
      randomize: true,
    },
  },
});

----------------------------------------

TITLE: Setting Default Machine Configuration in Trigger.dev
DESCRIPTION: This snippet shows how to set a default machine configuration for all tasks in a Trigger.dev project. It uses the 'small-2x' preset in the trigger.config.ts file.

LANGUAGE: typescript
CODE:
import type { TriggerConfig } from "@trigger.dev/sdk/v3";

export const config: TriggerConfig = {
  machine: "small-2x",
  // ... other config
};

----------------------------------------

TITLE: Configuring Audio Waveform Extension in trigger.dev Project
DESCRIPTION: This code snippet shows how to add the audioWaveform build extension to a trigger.dev project configuration. It imports the necessary functions from the SDK and the audioWaveform extension, then adds the extension to the build configuration.

LANGUAGE: typescript
CODE:
import { defineConfig } from "@trigger.dev/sdk/v3";
import { audioWaveform } from "@trigger.dev/build/extensions/audioWaveform";

export default defineConfig({
  project: "<project ref>",
  // Your other config settings...
  build: {
    extensions: [audioWaveform()], // uses verson 1.1.0 of audiowaveform by default
  },
});

----------------------------------------

TITLE: Configuring Authentication Methods in Trigger.dev SDK
DESCRIPTION: Demonstrates how to authenticate with Trigger.dev using both secret key and personal access token methods. Shows the difference in runs.list() implementation between the two authentication types, where personal access token requires additional projectRef parameter.

LANGUAGE: typescript
CODE:
import { configure, runs } from "@trigger.dev/sdk/v3";

// Using secretKey authentication
configure({
  secretKey: process.env["TRIGGER_SECRET_KEY"], // starts with tr_dev_ or tr_prod_
});

function secretKeyExample() {
  return runs.list({
    limit: 10,
    status: ["COMPLETED"],
  });
}

// Using personalAccessToken authentication
configure({
  secretKey: process.env["TRIGGER_ACCESS_TOKEN"], // starts with tr_pat_
});

function personalAccessTokenExample() {
  // Notice the projectRef argument is required when using a personalAccessToken
  return runs.list("prof_1234", {
    limit: 10,
    status: ["COMPLETED"],
    projectRef: "tr_proj_1234567890",
  });
}

----------------------------------------

TITLE: Using String Idempotency Keys in TypeScript
DESCRIPTION: This code demonstrates how to use a string directly as an idempotency key when triggering a task, without first creating it with idempotencyKeys.create.

LANGUAGE: typescript
CODE:
import { myTask } from "./trigger/myTasks";

// You can also pass an array of strings to create a idempotency key
await myTask.trigger({ some: "data" }, { idempotencyKey: myUser.id });

----------------------------------------

TITLE: Sharing Queue Concurrency Between Multiple Tasks
DESCRIPTION: Shows how to create a shared queue with concurrency limits that can be used across multiple tasks.

LANGUAGE: typescript
CODE:
export const myQueue = queue({
  name: "my-queue",
  concurrencyLimit: 1,
});

export const task1 = task({
  id: "task-1",
  queue: myQueue,
  run: async (payload: { message: string }) => {
    // ...
  },
});

export const task2 = task({
  id: "task-2",
  queue: myQueue,
  run: async (payload: { message: string }) => {
    // ...
  },
});

----------------------------------------

TITLE: Installing System Packages with aptGet in Trigger.dev Configuration
DESCRIPTION: This snippet demonstrates how to use the aptGet extension to install system packages, specifically ffmpeg, in the Trigger.dev configuration. It imports necessary modules and defines the configuration with the aptGet extension.

LANGUAGE: typescript
CODE:
import { defineConfig } from "@trigger.dev/sdk/v3";
import { aptGet } from "@trigger.dev/build/extensions/core";

export default defineConfig({
  project: "<project ref>",
  // Your other config settings...
  build: {
    extensions: [aptGet({ packages: ["ffmpeg"] })],
  },
});

----------------------------------------

TITLE: Implementing OpenAI Streaming Task
DESCRIPTION: Example of using the Streams API with OpenAI SDK to stream LLM model output in realtime. Demonstrates stream registration and consumption within a task.

LANGUAGE: typescript
CODE:
import { task, metadata } from "@trigger.dev/sdk/v3";
import OpenAI from "openai";

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

export type STREAMS = {
  openai: OpenAI.ChatCompletionChunk;
};

export const myTask = task({
  id: "my-task",
  run: async (payload: { prompt: string }) => {
    const completion = await openai.chat.completions.create({
      messages: [{ role: "user", content: payload.prompt }],
      model: "gpt-3.5-turbo",
      stream: true,
    });

    const stream = await metadata.stream("openai", completion);

    let text = "";

    for await (const chunk of stream) {
      logger.log("Received chunk", { chunk });
      text += chunk.choices.map((choice) => choice.delta?.content).join("");
    }

    return { text };
  },
});

----------------------------------------

TITLE: Subscribing to Run Updates using Trigger.dev SDK
DESCRIPTION: Example showing how to subscribe to changes for a specific run using an async iterator. The function yields run object updates until the run is completed.

LANGUAGE: typescript
CODE:
import { runs } from "@trigger.dev/sdk/v3";

for await (const run of runs.subscribeToRun("run_1234")) {
  console.log(run);
}

----------------------------------------

TITLE: Uploading Environment Variables with Personal Access Token
DESCRIPTION: Shows how to upload environment variables using a personal access token, demonstrating the required projectRef and environment arguments specific to PAT authentication.

LANGUAGE: typescript
CODE:
import { configure, envvars } from "@trigger.dev/sdk/v3";

configure({
  secretKey: process.env["TRIGGER_ACCESS_TOKEN"], // starts with tr_pat_
});

await envvars.upload("proj_1234", "dev", {
  variables: {
    MY_ENV_VAR: "MY_ENV_VAR_VALUE",
  },
  override: true,
});

----------------------------------------

TITLE: Batch Triggering Tasks with Idempotency Keys
DESCRIPTION: This snippet shows how to use idempotency keys when batch triggering tasks. It demonstrates creating unique idempotency keys for each task in the batch.

LANGUAGE: typescript
CODE:
import { tasks } from "@trigger.dev/sdk/v3";

await tasks.batchTrigger("my-task", [
  {
    payload: { some: "data" },
    options: { idempotencyKey: await idempotencyKeys.create(myUser.id) },
  },
]);

----------------------------------------

TITLE: Dynamic Concurrency Override Example
DESCRIPTION: Demonstrates how to dynamically override task concurrency limits when triggering runs based on conditions.

LANGUAGE: typescript
CODE:
export const generatePullRequest = task({
  id: "generate-pull-request",
  queue: {
    concurrencyLimit: 1,
  },
  run: async (payload) => {
    //todo generate a PR using OpenAI
  },
});

LANGUAGE: typescript
CODE:
export async function POST(request: Request) {
  const data = await request.json();

  if (data.branch === "main") {
    const handle = await generatePullRequest.trigger(data, {
      queue: {
        name: "main-branch",
        concurrencyLimit: 10,
      },
    });

    return Response.json(handle);
  } else {
    const handle = await generatePullRequest.trigger(data);
    return Response.json(handle);
  }
}

----------------------------------------

TITLE: Configuring Basic Prisma Extension in Trigger.dev
DESCRIPTION: This snippet demonstrates how to set up the basic prismaExtension in a Trigger.dev project configuration file. It includes options for specifying the Prisma version and schema location.

LANGUAGE: typescript
CODE:
import { defineConfig } from "@trigger.dev/sdk/v3";
import { prismaExtension } from "@trigger.dev/build/extensions/prisma";

export default defineConfig({
  project: "<project ref>",
  // Your other config settings...
  build: {
    extensions: [
      prismaExtension({
        version: "5.19.0", // optional, we'll automatically detect the version if not provided
        schema: "prisma/schema.prisma",
      }),
    ],
  },
});

----------------------------------------

TITLE: Configuring OpenTelemetry Instrumentations in Trigger.dev
DESCRIPTION: Demonstrates how to configure OpenTelemetry instrumentations for Prisma and AWS SDK in a Trigger.dev project. This setup enables detailed tracing and logging for these libraries within Trigger.dev tasks.

LANGUAGE: typescript
CODE:
import { defineConfig } from "@trigger.dev/sdk/v3";
import { PrismaInstrumentation } from "@prisma/instrumentation";
import { AwsInstrumentation } from "@opentelemetry/instrumentation-aws-sdk";

export default defineConfig({
  project: "<your-project-ref>",
  instrumentations: [new PrismaInstrumentation(), new AwsInstrumentation()],
});

----------------------------------------

TITLE: Filtering Runs by Tags in TypeScript
DESCRIPTION: Shows how to use the runs.list() function to filter runs by tags and status in the SDK.

LANGUAGE: typescript
CODE:
import { runs } from "@trigger.dev/sdk/v3";

// Loop through all runs with the tag "user_123456" that have completed
for await (const run of runs.list({ tag: "user_123456", status: ["COMPLETED"] })) {
  console.log(run.id, run.taskIdentifier, run.finishedAt, run.tags);
}

----------------------------------------

TITLE: Subtask Queue Implementation
DESCRIPTION: Demonstrates how subtasks handle queue inheritance and concurrency settings independently from parent tasks.

LANGUAGE: typescript
CODE:
export const parentTask = task({
  id: "parent-task",
  run: async (payload) => {
    await subtask.triggerAndWait(payload);
  },
});

export const subtask = task({
  id: "subtask",
  run: async (payload) => {
    //...
  },
});

----------------------------------------

TITLE: Configuring emitDecoratorMetadata in trigger.dev TypeScript Configuration
DESCRIPTION: This snippet demonstrates how to import and use the emitDecoratorMetadata build extension in a trigger.dev project's configuration file. It enables support for the emitDecoratorMetadata TypeScript compiler option, which is often required for certain ORMs like TypeORM.

LANGUAGE: typescript
CODE:
import { defineConfig } from "@trigger.dev/sdk/v3";
import { emitDecoratorMetadata } from "@trigger.dev/build/extensions/typescript";

export default defineConfig({
  project: "<project ref>",
  // Your other config settings...
  build: {
    extensions: [emitDecoratorMetadata()],
  },
});

----------------------------------------

TITLE: Using useRealtimeRunsWithTag Hook in React
DESCRIPTION: Shows how to use the useRealtimeRunsWithTag hook to subscribe to multiple runs with a specific tag. It includes examples of basic usage and type inference for multiple task types.

LANGUAGE: tsx
CODE:
"use client"; // This is needed for Next.js App Router or other RSC frameworks

import { useRealtimeRunsWithTag } from "@trigger.dev/react-hooks";

export function MyComponent({ tag }: { tag: string }) {
  const { runs, error } = useRealtimeRunsWithTag(tag);

  if (error) return <div>Error: {error.message}</div>;

  return (
    <div>
      {runs.map((run) => (
        <div key={run.id}>Run: {run.id}</div>
      ))}
    </div>
  );
}

----------------------------------------

TITLE: Configuring VS Code Launch Settings for Trigger.dev Debugging
DESCRIPTION: VS Code launch configuration that enables debugging of Trigger.dev tasks in development mode. The configuration uses Node.js debugger with source maps enabled and skips internal Node.js files for cleaner debugging experience.

LANGUAGE: json
CODE:
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "Trigger.dev: Dev",
      "type": "node",
      "request": "launch",
      "cwd": "${workspaceFolder}",
      "runtimeExecutable": "npx",
      "runtimeArgs": ["trigger.dev@latest", "dev"],
      "skipFiles": ["<node_internals>/**"],
      "sourceMaps": true
    }
  ]
}

----------------------------------------

TITLE: Checkpoint-Resume System Flow Diagram
DESCRIPTION: A Mermaid sequence diagram illustrating the flow of parent and child tasks using the Checkpoint-Resume System in Trigger.dev. It shows the process of task execution, checkpointing, resource management, and task resumption.

LANGUAGE: mermaid
CODE:
sequenceDiagram
    participant App
    participant Trigger.dev
    participant Parent Task
    participant Child Task
    participant CR System
    participant Storage

    App->>Trigger.dev: Trigger parent task
    Trigger.dev->>Parent Task: Start execution
    Parent Task->>Child Task: Trigger child task
    Parent Task->>CR System: Request snapshot
    CR System->>Storage: Store snapshot
    CR System-->>Parent Task: Confirm snapshot stored
    Parent Task->>Trigger.dev: Release resources

    Child Task->>Trigger.dev: Complete execution
    Trigger.dev->>CR System: Request parent task restoration
    CR System->>Storage: Retrieve snapshot
    CR System->>Parent Task: Restore state
    Parent Task->>Trigger.dev: Resume execution
    Parent Task->>Trigger.dev: Complete execution

----------------------------------------

TITLE: Getting Run Cost and Duration in Trigger.dev Task
DESCRIPTION: Example showing how to track compute costs and duration within a task execution using usage.getCurrent(). Demonstrates how waits don't affect compute time and costs in the cloud product.

LANGUAGE: typescript
CODE:
export const heavyTask = task({
  id: "heavy-task",
  machine: {
    preset: "medium-2x",
  },
  run: async (payload, { ctx }) => {
    // Do some compute
    const result = await convertVideo(payload.videoUrl);

    // Get the current cost and duration up until this line of code
    // This includes the compute time of the previous lines
    let currentUsage = usage.getCurrent();
    /* currentUsage = {
        compute: {
          attempt: {
            costInCents: 0.01700,
            durationMs: 1000,
          },
          total: {
            costInCents: 0.0255,
            durationMs: 1500,
          },
        },
        baseCostInCents: 0.0025,
        totalCostInCents: 0.028,
      } 
      */

    // In the cloud product we do not count waits towards the compute cost or duration.
    // We also don't include time between attempts or before the run starts executing your code.
    // So this line does not affect the cost or duration.
    await wait.for({ seconds: 5 });

    // This will give the same result as before the wait.
    currentUsage = usage.getCurrent();

    // Do more compute
    const result = await convertVideo(payload.videoUrl);

    // This would give a different value
    currentUsage = usage.getCurrent();
  },
});

----------------------------------------

TITLE: Implementing Wait Until Function in TypeScript
DESCRIPTION: Example of using wait.until() function with idempotency keys to handle timed delays in task execution. The function allows waiting until a specific datetime with optional idempotency controls.

LANGUAGE: typescript
CODE:
await wait.until(new Date("2022-01-01T00:00:00Z"), { idempotencyKey: "first-wait" });
await wait.until(new Date("2022-01-01T00:00:00Z"), { idempotencyKey: "second-wait" });

----------------------------------------

TITLE: Filtering Runs in Trigger.dev using TypeScript
DESCRIPTION: Demonstrates how to apply multiple filters when listing runs in Trigger.dev.

LANGUAGE: typescript
CODE:
import { runs } from "@trigger.dev/sdk/v3";

const response = await runs.list({
  status: ["QUEUED", "EXECUTING"], // Filter by status
  taskIdentifier: ["my-task", "my-other-task"], // Filter by task identifier
  from: new Date("2024-04-01T00:00:00Z"), // Filter by created at
  to: new Date(),
  version: "20241127.2", // Filter by deployment version,
  tag: ["tag1", "tag2"], // Filter by tags
  batch: "batch_1234", // Filter by batch ID
  schedule: "sched_1234", // Filter by schedule ID
});

----------------------------------------

TITLE: Using Trigger.dev CLI Commands
DESCRIPTION: Demonstrates various CLI commands for Trigger.dev, including login, initialization, local development, and deployment. Also shows how to use profiles for different accounts or instances.

LANGUAGE: bash
CODE:
npx trigger.dev@latest login # Log in to your Trigger.dev account
npx trigger.dev@latest init # Initialize Trigger.dev in your project
npx trigger.dev@latest dev # Run your tasks locally
npx trigger.dev@latest deploy # Deploy your tasks to the Trigger.dev instance

LANGUAGE: bash
CODE:
npx trigger.dev@latest login --profile <profile> -a https://trigger.example.com # Log in to a specific profile into a self-hosted instance
npx trigger.dev@latest dev --profile <profile> # Initialize Trigger.dev in your project
npx trigger.dev@latest deploy --profile <profile> # Deploy your tasks to the Trigger.dev instance

----------------------------------------

TITLE: Listing Runs with Pagination in Trigger.dev using TypeScript
DESCRIPTION: Demonstrates how to list runs in a specific environment with pagination and filtering options.

LANGUAGE: typescript
CODE:
import { runs } from "@trigger.dev/sdk/v3";

// Get the first page of runs, returning up to 20 runs
let page = await runs.list({ limit: 20 });

for (const run of page.data) {
  console.log(run);
}

// Keep getting the next page until there are no more runs
while (page.hasNextPage()) {
  page = await page.getNextPage();
  // Do something with the next page of runs
}

----------------------------------------

TITLE: Configuring Prisma Build Extension
DESCRIPTION: Configuration setup for Trigger.dev build extension to include Prisma client in the build process. Specifies project reference and Prisma schema location.

LANGUAGE: javascript
CODE:
export default defineConfig({
  project: "<project ref>", // Your project reference
  // Your other config settings...
  build: {
    extensions: [
      prismaExtension({
        version: "5.20.0", // optional, we'll automatically detect the version if not provided
        // update this to the path of your Prisma schema file
        schema: "prisma/schema.prisma",
      }),
    ],
  },
});

----------------------------------------

TITLE: Canceling a Run using the Trigger.dev API in TypeScript
DESCRIPTION: Shows how to cancel an in-progress run using the Trigger.dev API.

LANGUAGE: typescript
CODE:
await runs.cancel(runId);

----------------------------------------

TITLE: Triggering a Task with Idempotency Key in TypeScript
DESCRIPTION: Demonstrates how to trigger a task with an idempotency key to prevent duplicate executions.

LANGUAGE: typescript
CODE:
await yourTask.trigger({ foo: "bar" }, { idempotencyKey: "unique-key" });

----------------------------------------

TITLE: Configuring Python Extension in Trigger.dev
DESCRIPTION: Basic configuration setup for adding Python support to a Trigger.dev project using pythonExtension in the trigger.config.ts file

LANGUAGE: typescript
CODE:
import { defineConfig } from "@trigger.dev/sdk/v3";
import { pythonExtension } from "@trigger.dev/python/extension";

export default defineConfig({
  project: "<project ref>",
  build: {
    extensions: [pythonExtension()],
  },
});

----------------------------------------

TITLE: Using useRealtimeTaskTriggerWithStreams Hook in React
DESCRIPTION: Example of using the useRealtimeTaskTriggerWithStreams hook to trigger a task, subscribe to real-time updates, and receive streams emitted by the task in a React component.

LANGUAGE: typescript
CODE:
"use client"; // This is needed for Next.js App Router or other RSC frameworks

import { useRealtimeTaskTriggerWithStreams } from "@trigger.dev/react-hooks";
import type { myTask } from "@/trigger/myTask";

type STREAMS = {
  openai: string; // this is the type of each "part" of the stream
};

export function MyComponent({ publicAccessToken }: { publicAccessToken: string }) {
  const { submit, run, streams, error, isLoading } = useRealtimeTaskTriggerWithStreams<
    typeof myTask,
    STREAMS
  >("my-task", {
    accessToken: publicAccessToken,
  });

  if (error) {
    return <div>Error: {error.message}</div>;
  }

  if (streams && run) {
    const text = streams.openai?.map((part) => part).join("");

    return (
      <div>
        <div>Run ID: {run.id}</div>
        <div>{text}</div>
      </div>
    );
  }

  return (
    <button onClick={() => submit({ foo: "bar" })} disabled={isLoading}>
      {isLoading ? "Loading..." : "Trigger Task"}
    </button>
  );
}

----------------------------------------

TITLE: Retrieving a Single Run in Trigger.dev using TypeScript
DESCRIPTION: Shows how to fetch a single run by its ID in Trigger.dev.

LANGUAGE: typescript
CODE:
import { runs } from "@trigger.dev/sdk/v3";

const run = await runs.retrieve(runId);

----------------------------------------

TITLE: Configuring Trigger.dev Build Settings
DESCRIPTION: Configuration file setup for Trigger.dev that marks the PostgreSQL client (pg) as an external dependency to ensure proper runtime loading from node_modules.

LANGUAGE: javascript
CODE:
import { defineConfig } from "@trigger.dev/sdk/v3";

export default defineConfig({
  project: "<project ref>", // Your project reference
  // Your other config settings...
  build: {
    externals: ["pg"],
  },
});

----------------------------------------

TITLE: Setting Trigger.dev API Key in Environment
DESCRIPTION: Set the TRIGGER_SECRET_KEY environment variable with the API key from the Trigger.dev dashboard to run tasks against the deployed version.

LANGUAGE: txt
CODE:
TRIGGER_SECRET_KEY="tr_prod_abc123"

----------------------------------------

TITLE: Creating Basic Public Access Token in TypeScript
DESCRIPTION: Demonstrates how to create a basic public access token with no permissions using the auth module from Trigger.dev SDK.

LANGUAGE: tsx
CODE:
import { auth } from "@trigger.dev/sdk/v3";

const publicToken = await auth.createPublicToken(); // 👈 this public access token has no permissions, so is pretty useless!

----------------------------------------

TITLE: Scheduling a Delayed Run in Trigger.dev using TypeScript
DESCRIPTION: Demonstrates how to schedule a run to start after a specified delay.

LANGUAGE: typescript
CODE:
await yourTask.trigger({ foo: "bar" }, { delay: "1h" });

----------------------------------------

TITLE: Configuring Default Max Duration in Trigger.dev Config
DESCRIPTION: Sets the default maximum duration for all tasks in the project configuration file. This setting can be overridden for specific tasks or runs.

LANGUAGE: typescript
CODE:
import { defineConfig } from "@trigger.dev/sdk/v3";

export default defineConfig({
  project: "proj_gtcwttqhhtlasxgfuhxs",
  maxDuration: 60, // 60 seconds or 1 minute
});

----------------------------------------

TITLE: Triggering Deployed Trigger.dev Tasks
DESCRIPTION: Trigger deployed tasks using the same method as local tasks, but with the production API key set in the environment.

LANGUAGE: ts
CODE:
import { myTask } from "./trigger/tasks";

await myTask.trigger({ foo: "bar" });

----------------------------------------

TITLE: Accessing Context in a trigger.dev Task (TypeScript)
DESCRIPTION: This example demonstrates how to use the context object (ctx) within a trigger.dev task. It shows how to access the environment type and conditionally execute code based on that information.

LANGUAGE: typescript
CODE:
import { task } from "@trigger.dev/sdk/v3";

export const parentTask = task({
  id: "parent-task",
  run: async (payload: { message: string }, { ctx }) => {
    
    if (ctx.environment.type === "DEVELOPMENT") {
      return;
    }
  },
});

----------------------------------------

TITLE: Configuring esbuild Plugin in trigger.dev
DESCRIPTION: This snippet shows how to use the esbuildPlugin extension to add the Sentry esbuild plugin to the build process. It demonstrates setting up the plugin with environment variables and specifying placement and target options.

LANGUAGE: typescript
CODE:
import { defineConfig } from "@trigger.dev/sdk/v3";
import { esbuildPlugin } from "@trigger.dev/build/extensions";
import { sentryEsbuildPlugin } from "@sentry/esbuild-plugin";

export default defineConfig({
  project: "<project ref>",
  // Your other config settings...
  build: {
    extensions: [
      esbuildPlugin(
        sentryEsbuildPlugin({
          org: process.env.SENTRY_ORG,
          project: process.env.SENTRY_PROJECT,
          authToken: process.env.SENTRY_AUTH_TOKEN,
        }),
        // optional - only runs during the deploy command, and adds the plugin to the end of the list of plugins
        { placement: "last", target: "deploy" }
      ),
    ],
  },
});

----------------------------------------

TITLE: Creating Idempotency Keys in Backend Code
DESCRIPTION: This snippet illustrates how to create and use idempotency keys in backend code, outside of a task context. It demonstrates creating keys from multiple strings and triggering tasks with idempotency.

LANGUAGE: typescript
CODE:
import { idempotencyKeys, tasks } from "@trigger.dev/sdk/v3";

// You can also pass an array of strings to create a idempotency key
const idempotencyKey = await idempotencyKeys.create([myUser.id, "my-task"]);
await tasks.trigger("my-task", { some: "data" }, { idempotencyKey });

----------------------------------------

TITLE: Replaying a Run in Trigger.dev using TypeScript
DESCRIPTION: Shows how to create a new run with the same payload as a previous run for debugging or recovery purposes.

LANGUAGE: typescript
CODE:
await runs.replay(runId);

----------------------------------------

TITLE: Monitoring Task Duration Using Usage Utility
DESCRIPTION: Demonstrates how to inspect CPU time of a task during execution using the usage utility. Shows task configuration with custom max duration.

LANGUAGE: typescript
CODE:
import { task, usage } from "@trigger.dev/sdk/v3";

export const maxDurationTask = task({
  id: "max-duration-task",
  maxDuration: 300, // 300 seconds or 5 minutes
  run: async (payload: any, { ctx }) => {
    let currentUsage = usage.getCurrent();

    currentUsage.attempt.durationMs; // The CPU time in milliseconds since the start of the run
  },
});

----------------------------------------

TITLE: Version-Locking Trigger.dev Tasks
DESCRIPTION: Specify a version when triggering a task to run against a specific version of the code, useful for maintaining consistency across runs.

LANGUAGE: ts
CODE:
await myTask.trigger({ foo: "bar" }, { version: "20250228.1" });

----------------------------------------

TITLE: Creating Global Idempotency Keys in TypeScript
DESCRIPTION: This code shows how to create a globally unique idempotency key using the 'scope' option. This ensures that only a single task run will be triggered with this key, regardless of the current task run.

LANGUAGE: typescript
CODE:
import { idempotencyKeys, task } from "@trigger.dev/sdk/v3";

export const myTask = task({
  id: "my-task",
  retry: {
    maxAttempts: 4,
  },
  run: async (payload: any) => {
    // This idempotency key will be globally unique, meaning only a single task run will be triggered with this key
    const idempotencyKey = await idempotencyKeys.create("my-task-key", { scope: "global" });

    // childTask will only be triggered once with the same idempotency key
    await childTask.trigger({ foo: "bar" }, { idempotencyKey });
  },
});

----------------------------------------

TITLE: Batch Triggering with Tags in TypeScript
DESCRIPTION: Shows how to add tags when batch triggering multiple runs. Each batch item can have its own tags specified in the options.

LANGUAGE: typescript
CODE:
const batch = await myTask.batchTrigger([
  {
    payload: { message: "foo" },
    options: { tags: "product_123456" },
  },
  {
    payload: { message: "bar" },
    options: { tags: ["user_123456", "product_3456789"] },
  },
]);

----------------------------------------

TITLE: Disabling Max Duration for a Task
DESCRIPTION: Demonstrates how to disable the maximum duration limit for a specific task using timeout.None.

LANGUAGE: typescript
CODE:
import { task, timeout } from "@trigger.dev/sdk/v3";

export const maxDurationTask = task({
  id: "max-duration-task",
  maxDuration: timeout.None, // No max duration
  run: async (payload: any, { ctx }) => {
    //...
  },
});

----------------------------------------

TITLE: Triggering Trigger.dev v2 Jobs
DESCRIPTION: Example of triggering v2 Trigger.dev jobs using client.sendEvent for eventTrigger and invoke for invokeTrigger.

LANGUAGE: typescript
CODE:
async function yourBackendFunction() {
  //1. for `eventTrigger` you use `client.sendEvent`
  const event = await client.sendEvent({
    name: "openai.tasks",
    payload: { prompt: "Create a good programming joke about background jobs" },
  });

  //2. for `invokeTrigger` you'd call `invoke` on the job
  const { id } = await invocableJob.invoke({
    prompt: "What is the meaning of life?",
  });
}

----------------------------------------

TITLE: Per-Tenant Queue Configuration
DESCRIPTION: Shows how to implement per-user/tenant queue management using concurrencyKey for different service tiers.

LANGUAGE: typescript
CODE:
export async function POST(request: Request) {
  const data = await request.json();

  if (data.isFreeUser) {
    const handle = await generatePullRequest.trigger(data, {
      queue: {
        name: "free-users",
        concurrencyLimit: 1,
      },
      concurrencyKey: data.userId,
    });
    return Response.json(handle);
  } else {
    const handle = await generatePullRequest.trigger(data, {
      queue: {
        name: "paid-users",
        concurrencyLimit: 10,
      },
      concurrencyKey: data.userId,
    });
    return Response.json(handle);
  }
}

----------------------------------------

TITLE: Deploying to Staging Environment in Trigger.dev
DESCRIPTION: Deploy tasks to a staging environment using the --env flag with the deploy command, allowing for testing before production deployment.

LANGUAGE: bash
CODE:
npx trigger.dev deploy --env staging

----------------------------------------

TITLE: Sequin Database Configuration SQL Commands
DESCRIPTION: SQL commands for setting up Sequin publication and replication slot in Postgres database.

LANGUAGE: sql
CODE:
create publication sequin_pub for all tables;
select pg_create_logical_replication_slot('sequin_slot', 'pgoutput');

----------------------------------------

TITLE: Configuring additionalFiles Extension in trigger.config.ts
DESCRIPTION: This snippet demonstrates how to import and use the additionalFiles build extension in the trigger.config.ts file. It shows how to specify files and globs to be copied to the build directory for both dev and deploy commands.

LANGUAGE: typescript
CODE:
import { defineConfig } from "@trigger.dev/sdk/v3";
import { additionalFiles } from "@trigger.dev/build/extensions/core";

export default defineConfig({
  project: "<project ref>",
  // Your other config settings...
  build: {
    extensions: [
      additionalFiles({ files: ["wrangler/wrangler.toml", "./assets/**", "./fonts/**"] }),
    ],
  },
});

----------------------------------------

TITLE: Accessing Max Duration in Run Context
DESCRIPTION: Demonstrates how to access the configured maximum duration value within the task run context.

LANGUAGE: typescript
CODE:
import { task } from "@trigger.dev/sdk/v3";

export const maxDurationTask = task({
  id: "max-duration-task",
  maxDuration: 300, // 300 seconds or 5 minutes
  run: async (payload: any, { ctx }) => {
    console.log(ctx.run.maxDuration); // 300
  },
});

----------------------------------------

TITLE: Defining a Trigger.dev v3 Task with OpenAI Integration
DESCRIPTION: Example of a v3 Trigger.dev task using the official OpenAI SDK, demonstrating simplified syntax without timeouts and cacheKeys.

LANGUAGE: typescript
CODE:
import { logger, task, wait } from "@trigger.dev/sdk/v3";

//1. Official OpenAI SDK
import OpenAI from "openai";
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
});

//2. Jobs don't exist now, use "task"
export const openaiTask = task({
  id: "openai-task",
  //3. Retries happen if a task throws an error that isn't caught
  //   The default settings are in your trigger.config.ts (used if not overriden here)
  retry: {
    maxAttempts: 3,
  },
  run: async (payload: { prompt: string }) => {
    //4. Use the official SDK
    //5. No timeouts, so this can take a long time
    const chatCompletion = await openai.chat.completions.create({
      messages: [{ role: "user", content: payload.prompt }],
      model: "gpt-3.5-turbo",
    });

    const result = chatCompletion.choices[0]?.message.content;
    if (!result) {
      //6. throwing an error at the top-level will retry the task (if retries are enabled)
      throw new Error("No result from OpenAI");
    }

    //7. No need to use runTask, just call the function
    const dbRow = await saveToDb(result);

    //8. You can provide seconds, minutes, hours etc.
    //   You don't need cacheKeys in v3
    await wait.for({ minutes: 5 });

    //9. You can return anything that's serializable using SuperJSON
    //   That includes undefined, Date, bigint, RegExp, Set, Map, Error and URL.
    return result;
  },
});

----------------------------------------

TITLE: Next.js API Route Handler for Sequin Webhooks
DESCRIPTION: Implements a Next.js API route handler that receives webhooks from Sequin and triggers the embedding generation task.

LANGUAGE: typescript
CODE:
import type { createEmbeddingForPost } from "@/trigger/create-embedding-for-post";
import { tasks } from "@trigger.dev/sdk/v3";
import { NextResponse } from "next/server";

export async function POST(req: Request) {
  const authHeader = req.headers.get("authorization");
  if (!authHeader || authHeader !== `Bearer ${process.env.SEQUIN_WEBHOOK_SECRET}`) {
    return NextResponse.json({ error: "Unauthorized" }, { status: 401 });
  }
  const payload = await req.json();
  const handle = await tasks.trigger<typeof createEmbeddingForPost>(
    "create-embedding-for-post",
    payload
  );

  return NextResponse.json(handle);
}

----------------------------------------

TITLE: Installing Specific Package Versions with aptGet in Trigger.dev
DESCRIPTION: This example shows how to install a specific version of a package using the aptGet extension in Trigger.dev. It demonstrates installing ffmpeg version 6.0-4 in the configuration.

LANGUAGE: typescript
CODE:
import { defineConfig } from "@trigger.dev/sdk/v3";

export default defineConfig({
  project: "<project ref>",
  // Your other config settings...
  build: {
    extensions: [aptGet({ packages: ["ffmpeg=6.0-4"] })],
  },
});

----------------------------------------

TITLE: Adding Tags Inside Run Function in TypeScript
DESCRIPTION: Example of adding tags during task execution using the tags.add() function. Also shows how to access existing tags from the context.

LANGUAGE: typescript
CODE:
import { task, tags } from "@trigger.dev/sdk/v3";

export const myTask = task({
  id: "my-task",
  run: async (payload: { message: string }, { ctx }) => {
    // Get the tags from when the run was triggered using the context
    // This is not updated if you add tags during the run
    logger.log("Tags from the run context", { tags: ctx.run.tags });

    // Add tags during the run (a single string or array of strings)
    await tags.add("product_1234567");
  },
});

----------------------------------------

TITLE: Running Python Scripts in Trigger.dev Tasks
DESCRIPTION: Examples of executing Python scripts within Trigger.dev tasks, including both standard and streaming output options.

LANGUAGE: typescript
CODE:
import { task } from "@trigger.dev/sdk/v3";
import { python } from "@trigger.dev/python";

export const myScript = task({
  id: "my-python-script",
  run: async () => {
    const result = await python.runScript("my_script.py", ["hello", "world"]);
    return result.stdout;
  },
});

export const myStreamingScript = task({
  id: "my-streaming-python-script",
  run: async () => {
    // You can also stream the output of the script
    const result = python.stream.runScript("my_script.py", ["hello", "world"]);

    // result is an async iterable/readable stream
    for await (const chunk of streamingResult) {
      logger.debug("convert-url-to-markdown", {
        url: payload.url,
        chunk,
      });
    }
  },
});

----------------------------------------

TITLE: Implementing Webhook Handler in Remix
DESCRIPTION: Creates a webhook handler route in Remix that receives POST requests and triggers a Trigger.dev task. The handler processes the incoming JSON payload and forwards it to a predefined hello-world task.

LANGUAGE: typescript
CODE:
import type { ActionFunctionArgs } from "@remix-run/node";
import { tasks } from "@trigger.dev/sdk/v3";
import { helloWorldTask } from "src/trigger/example";

export async function action({ request }: ActionFunctionArgs) {
  const payload = await request.json();

  // Trigger the helloWorldTask with the webhook data as the payload
  await tasks.trigger<typeof helloWorldTask>("hello-world", payload);

  return new Response("OK", { status: 200 });
}

----------------------------------------

TITLE: Adding Tags When Triggering Run in TypeScript
DESCRIPTION: Demonstrates how to add tags when triggering a task run using the trigger method. Tags can be specified as an array in the options parameter.

LANGUAGE: typescript
CODE:
const handle = await myTask.trigger(
  { message: "hello world" },
  { tags: ["user_123456", "org_abcdefg"] }
);

----------------------------------------

TITLE: Creating Embedding Generation Task in TypeScript
DESCRIPTION: Implements a Trigger.dev task that generates embeddings for post content using OpenAI. The task receives database change events from Sequin and updates embeddings in a Postgres database.

LANGUAGE: typescript
CODE:
import { task } from "@trigger.dev/sdk/v3";
import { OpenAI } from "openai";
import { upsertEmbedding } from "../util";

const openai = new OpenAI({
apiKey: process.env.OPENAI_API_KEY,
});

export const createEmbeddingForPost = task({
id: "create-embedding-for-post",
run: async (payload: {
record: {
id: number;
title: string;
body: string;
author: string;
createdAt: string;
embedding: string | null;
},
metadata: {
table_schema: string,
table_name: string,
consumer: {
id: string;
name: string;
};
};
}) => {
const content = `${payload.record.title}\n\n${payload.record.body}`;
const embedding = (await openai.embeddings.create({
model: "text-embedding-ada-002",
input: content,
})).data[0].embedding;

await upsertEmbedding(embedding, payload.record.id);

return {
...payload.record,
embedding: JSON.stringify(embedding),
};
}
});

----------------------------------------

TITLE: Externals Configuration in Build Extension
DESCRIPTION: Example of adding external dependencies using the externalsForTarget hook.

LANGUAGE: typescript
CODE:
import { defineConfig } from "@trigger.dev/sdk/v3";

export default defineConfig({
  project: "my-project",
  build: {
    extensions: [
      {
        name: "my-extension",
        externalsForTarget: async (target) => {
          return ["my-dependency"];
        },
      },
    ],
  },
});

----------------------------------------

TITLE: Generating Public Access Token for Client-Side Authentication in Trigger.dev SDK (TypeScript)
DESCRIPTION: This snippet shows how to generate a public access token for client-side authentication when using the subscribeToRunsWithTag function. It uses the auth.createPublicToken function to create a token with specific read scopes.

LANGUAGE: typescript
CODE:
import { auth } from "@trigger.dev/sdk/v3";

// Somewhere in your backend code
const publicToken = await auth.createPublicToken({
  scopes: {
    read: {
      tags: ["user:1234"],
    },
  },
});

----------------------------------------

TITLE: Initializing Trigger.dev Config File
DESCRIPTION: Shows creation of trigger.config.ts file and /trigger directory structure mentioned in the guide. However, actual code implementation is imported from external snippets.

LANGUAGE: typescript
CODE:
trigger.config.ts

----------------------------------------

TITLE: Vercel Configuration for Remix
DESCRIPTION: Vercel deployment configuration specifying build commands and framework settings

LANGUAGE: json
CODE:
{
  "buildCommand": "npm run vercel-build",
  "devCommand": "npm run dev",
  "framework": "remix",
  "installCommand": "npm install",
  "outputDirectory": "build/client"
}

----------------------------------------

TITLE: Custom ESBuild Plugin Integration
DESCRIPTION: Example of adding a custom esbuild plugin in the onBuildStart hook.

LANGUAGE: typescript
CODE:
import { defineConfig } from "@trigger.dev/sdk/v3";

export default defineConfig({
  project: "my-project",
  build: {
    extensions: [
      {
        name: "my-extension",
        onBuildStart: async (context) => {
          context.registerPlugin({
            name: "my-plugin",
            setup(build) {
              build.onLoad({ filter: /.*/, namespace: "file" }, async (args) => {
                return {
                  contents: "console.log('Hello, world!')",
                  loader: "js",
                };
              });
            },
          });
        },
      },
    ],
  },
});

----------------------------------------

TITLE: Type-Safe Tag-Based Run Subscription with Multiple Tasks
DESCRIPTION: Shows how to use type inference with subscribeToRunsWithTag function for multiple possible task types. This example demonstrates subscribing to runs with a specific tag and handling different task types with type safety.

LANGUAGE: typescript
CODE:
import { runs } from "@trigger.dev/sdk/v3";
import type { myTask, myOtherTask } from "./trigger/my-task";

// Somewhere in your backend code
for await (const run of runs.subscribeToRunsWithTag<typeof myTask | typeof myOtherTask>("my-tag")) {
  // You can narrow down the type based on the taskIdentifier
  switch (run.taskIdentifier) {
    case "my-task": {
      console.log("Run output:", run.output.foo); // This will be type-safe
      break;
    }
    case "my-other-task": {
      console.log("Run output:", run.output.bar); // This will be type-safe
      break;
    }
  }
}

----------------------------------------

TITLE: Setting Token Expiration Time
DESCRIPTION: Shows how to create a public access token with a custom expiration time using different time formats.

LANGUAGE: typescript
CODE:
import { auth } from "@trigger.dev/sdk/v3";

const publicToken = await auth.createPublicToken({
  expirationTime: "1hr",
});

----------------------------------------

TITLE: Defining Stripe Checkout Completed Task in Trigger.dev
DESCRIPTION: This code snippet defines a task in Trigger.dev that is triggered when a 'checkout.session.completed' event is received from Stripe. It provides a skeleton for handling the event payload.

LANGUAGE: typescript
CODE:
import { task } from "@trigger.dev/sdk/v3";
import type stripe from "stripe";

export const stripeCheckoutCompleted = task({
  id: "stripe-checkout-completed",
  run: async (payload: stripe.Checkout.Session) => {
    // Add your custom logic for handling the checkout.session.completed event here
  },
});

----------------------------------------

TITLE: Propagating Tags to Child Runs in TypeScript
DESCRIPTION: Demonstrates how to propagate tags from a parent run to child runs by passing them through the trigger options.

LANGUAGE: typescript
CODE:
export const myTask = task({
  id: "my-task",
  run: async (payload: Payload, { ctx }) => {
    // Pass the tags from ctx into the child run
    const { id } = await otherTask.trigger(
      { message: "triggered from myTask" },
      { tags: ctx.run.tags }
    );
  },
});

----------------------------------------

TITLE: Adding Prisma Instrumentation
DESCRIPTION: Configuration for OpenTelemetry instrumentation to log Prisma queries and mutations. Includes both Prisma and OpenAI instrumentations.

LANGUAGE: javascript
CODE:
import { defineConfig } from "@trigger.dev/sdk/v3";
import { PrismaInstrumentation } from "@prisma/instrumentation";
import { OpenAIInstrumentation } from "@traceloop/instrumentation-openai";

export default defineConfig({
  //..other stuff
  instrumentations: [new PrismaInstrumentation(), new OpenAIInstrumentation()],
});

----------------------------------------

TITLE: Build Layer Addition in onBuildComplete
DESCRIPTION: Example of adding a build layer after build completion using onBuildComplete hook.

LANGUAGE: typescript
CODE:
import { defineConfig } from "@trigger.dev/sdk/v3";

export default defineConfig({
  project: "my-project",
  build: {
    extensions: [
      {
        name: "my-extension",
        onBuildComplete: async (context, manifest) => {
          context.addLayer({
            id: "more-dependencies",
            dependencies,
          });
        },
      },
    ],
  },
});

----------------------------------------

TITLE: Stream Subscription Implementation
DESCRIPTION: Example showing how to subscribe to streams from a backend context using the runs.subscribeToRun method.

LANGUAGE: typescript
CODE:
import { runs } from "@trigger.dev/sdk/v3";
import type { myTask, STREAMS } from "./trigger/my-task";

async function subscribeToStream(runId: string) {
  for await (const part of runs.subscribeToRun<typeof myTask>(runId).withStreams<STREAMS>()) {
    switch (part.type) {
      case "run": {
        console.log("Received run", part.run);
        break;
      }
      case "openai": {
        console.log("Received OpenAI chunk", part.chunk);
        break;
      }
    }
  }
}

----------------------------------------

TITLE: Creating Public Access Token with Run Read Permissions
DESCRIPTION: Shows how to create a token with read permissions for all runs, which is useful for debugging but may not be recommended for production use.

LANGUAGE: typescript
CODE:
import { auth } from "@trigger.dev/sdk/v3";

const publicToken = await auth.createPublicToken({
  scopes: {
    read: {
      runs: true, // ❌ this token can read all runs, possibly useful for debugging/testing
    },
  },
});

----------------------------------------

TITLE: Testing Webhook Handler with cURL
DESCRIPTION: Command for testing the webhook handler endpoint locally using cURL. Sends a POST request with sample JSON data to trigger the webhook handler.

LANGUAGE: bash
CODE:
curl -X POST -H "Content-Type: application/json" -d '{"Name": "John Doe", "Age": "87"}' http://localhost:3000/api/webhook-handler

----------------------------------------

TITLE: Configuring Prisma Schema with Multiple Generators
DESCRIPTION: Example of a Prisma schema file with multiple generators, demonstrating how to specify the client generator in the Trigger.dev configuration.

LANGUAGE: prisma
CODE:
datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DATABASE_URL_UNPOOLED")
}

generator client {
  provider        = "prisma-client-js"
}

generator kysely {
  provider     = "prisma-kysely"
  output       = "../../src/kysely"
  enumFileName = "enums.ts"
  fileName     = "types.ts"
}

LANGUAGE: typescript
CODE:
import { defineConfig } from "@trigger.dev/sdk/v3";
import { prismaExtension } from "@trigger.dev/build/extensions/prisma";

export default defineConfig({
  project: "<project ref>",
  build: {
    extensions: [
      prismaExtension({
        schema: "prisma/schema.prisma",
        clientGenerator: "client",
      }),
    ],
  },
});

----------------------------------------

TITLE: Initializing Redis Client with Error Handling in TypeScript
DESCRIPTION: This code snippet creates a Redis client using the 'ioredis' package and sets up error handling. It logs any errors that occur and prevents them from crashing the application if not explicitly handled.

LANGUAGE: typescript
CODE:
import Redis from "ioredis";
import { logger } from "@trigger.dev/core";

export function createClient() {
  const client = new Redis(process.env.REDIS_URL!, {
    maxRetriesPerRequest: null,
  });

  client.on("error", (error) => {
    logger.error("Redis error", { error });
  });

  return client;
}

----------------------------------------

TITLE: Preventing Retries Using AbortTaskRunError in TypeScript
DESCRIPTION: Demonstrates how to use AbortTaskRunError to prevent retries when specific conditions are met, such as empty responses from an API.

LANGUAGE: typescript
CODE:
import { task, AbortTaskRunError } from "@trigger.dev/sdk/v3";

export const openaiTask = task({
  id: "openai-task",
  run: async (payload: { prompt: string }) => {
    //if this fails, it will throw an error and stop retrying
    const chatCompletion = await openai.chat.completions.create({
      messages: [{ role: "user", content: payload.prompt }],
      model: "gpt-3.5-turbo",
    });

    if (chatCompletion.choices[0]?.message.content === undefined) {
      // If OpenAI returns an empty response, abort retrying
      throw new AbortTaskRunError("OpenAI call failed");
    }

    return chatCompletion.choices[0].message.content;
  },
});

----------------------------------------

TITLE: Next.js Client Component Implementation
DESCRIPTION: Example of creating a client-side TriggerProvider component for Next.js applications.

LANGUAGE: tsx
CODE:
"use client";

import { TriggerAuthContext } from "@trigger.dev/react-hooks";

export function TriggerProvider({
  accessToken,
  children,
}: {
  accessToken: string;
  children: React.ReactNode;
}) {
  return (
    <TriggerAuthContext.Provider
      value={{
        accessToken,
      }}
    >
      {children}
    </TriggerAuthContext.Provider>
  );
}

----------------------------------------

TITLE: Creating Trigger Public Token in TypeScript
DESCRIPTION: Examples of creating trigger public tokens with various options using the auth.createTriggerPublicToken function.

LANGUAGE: typescript
CODE:
import { auth } from "@trigger.dev/sdk/v3";
// Somewhere in your backend code
const triggerToken = await auth.createTriggerPublicToken("my-task");

LANGUAGE: typescript
CODE:
import { auth } from "@trigger.dev/sdk/v3";
// Somewhere in your backend code
const triggerToken = await auth.createTriggerPublicToken("my-task", {
  expirationTime: "24hr",
});

LANGUAGE: typescript
CODE:
import { auth } from "@trigger.dev/sdk/v3";
// Somewhere in your backend code
const triggerToken = await auth.createTriggerPublicToken(["my-task-1", "my-task-2"]);

LANGUAGE: typescript
CODE:
import { auth } from "@trigger.dev/sdk/v3";

// Somewhere in your backend code
const triggerToken = await auth.createTriggerPublicToken("my-task", {
  multipleUse: true, // ❌ Use this with caution!
});

----------------------------------------

TITLE: Implementing Bun Example Task
DESCRIPTION: Example TypeScript task implementation using Bun's SQLite functionality to demonstrate basic task setup and database operations.

LANGUAGE: typescript
CODE:
import { Database } from "bun:sqlite";
import { task } from "@trigger.dev/sdk/v3";

export const bunTask = task({
  id: "bun-task",
  run: async (payload: { query: string }) => {
    const db = new Database(":memory:");
    const query = db.query("select 'Hello world' as message;");
    console.log(query.get()); // => { message: "Hello world" }

    return {
      message: "Query executed",
    };
  },
});

----------------------------------------

TITLE: Using Audio Waveform Build Extension
DESCRIPTION: Configure the audioWaveform build extension to include Audio Waveform in the Trigger.dev build process.

LANGUAGE: typescript
CODE:
import { defineConfig } from "@trigger.dev/sdk/v3";
import { audioWaveform } from "@trigger.dev/build/extensions/audioWaveform";

export default defineConfig({
  project: "<project ref>",
  build: {
    extensions: [audioWaveform()],
  },
});

----------------------------------------

TITLE: Overriding Machine Configuration when Triggering Trigger.dev Task
DESCRIPTION: This snippet demonstrates how to override the machine configuration when triggering a task. It specifies the 'large-2x' preset for a single execution of the task.

LANGUAGE: typescript
CODE:
await tasks.trigger<typeof heavyTask>(
  "heavy-task",
  { message: "hello world" },
  { machine: "large-2x" }
);

----------------------------------------

TITLE: Implementing Retry Logic for Specific Code Blocks in TypeScript
DESCRIPTION: Shows how to use the retry.onThrow() function to retry specific blocks of code within a task, with custom retry settings.

LANGUAGE: typescript
CODE:
import { task, logger, retry } from "@trigger.dev/sdk/v3";

export const retryOnThrow = task({
  id: "retry-on-throw",
  run: async (payload: any) => {
    //Will retry up to 3 times. If it fails 3 times it will throw.
    const result = await retry.onThrow(
      async ({ attempt }) => {
        //throw on purpose the first 2 times, obviously this is a contrived example
        if (attempt < 3) throw new Error("failed");
        //...
        return {
          foo: "bar",
        };
      },
      { maxAttempts: 3, randomize: false }
    );

    //this will log out after 3 attempts of retry.onThrow
    logger.info("Result", { result });
  },
});

----------------------------------------

TITLE: Installing Bun CLI Commands
DESCRIPTION: CLI commands for installing Trigger.dev in a Bun project using different package managers.

LANGUAGE: bash
CODE:
npx trigger.dev@latest init --runtime bun

LANGUAGE: bash
CODE:
pnpm dlx trigger.dev@latest init --runtime bun

LANGUAGE: bash
CODE:
yarn dlx trigger.dev@latest init --runtime bun

----------------------------------------

TITLE: Using Trigger.dev CLI with Dry Run and Custom Env File
DESCRIPTION: Examples of using the Trigger.dev CLI with the dry run option and specifying a custom environment file.

LANGUAGE: sh
CODE:
npx trigger.dev@latest deploy --dry-run

LANGUAGE: sh
CODE:
npx trigger.dev@latest dev --env-file ../../.env
npx trigger.dev@latest deploy --env-file ../../.env

----------------------------------------

TITLE: Retrieving Environment Variable using OpenAPI GET Request in trigger.dev
DESCRIPTION: This OpenAPI specification defines the GET request to retrieve a specific environment variable for a project in trigger.dev. It includes the endpoint path with parameters for project reference, environment, and variable name.

LANGUAGE: openapi
CODE:
v3-openapi GET /api/v1/projects/{projectRef}/envvars/{env}/{name}

----------------------------------------

TITLE: Configuring Multiple Tasks with Retrying in TypeScript
DESCRIPTION: Demonstrates how to set up multiple tasks with different retry configurations, allowing for independent retrying and logging of each task.

LANGUAGE: typescript
CODE:
import { task } from "@trigger.dev/sdk/v3";

export const myTask = task({
  id: "my-task",
  retry: {
    maxAttempts: 10,
  },
  run: async (payload: string) => {
    const result = await otherTask.triggerAndWait("some data");
    //...do other stuff
  },
});

export const otherTask = task({
  id: "other-task",
  retry: {
    maxAttempts: 5,
  },
  run: async (payload: string) => {
    return {
      foo: "bar",
    };
  },
});

----------------------------------------

TITLE: Basic React Hook Usage with Authentication
DESCRIPTION: Example showing how to use the useRealtimeRun hook with direct authentication via access token.

LANGUAGE: tsx
CODE:
import { useRealtimeRun } from "@trigger.dev/react-hooks";

export function MyComponent({
  runId,
  publicAccessToken,
}: {
  runId: string;
  publicAccessToken: string;
}) {
  const { run, error } = useRealtimeRun(runId, {
    accessToken: publicAccessToken, // This is required
    baseURL: "https://your-trigger-dev-instance.com", // optional, only needed if you are self-hosting Trigger.dev
  });

  // ...
}

----------------------------------------

TITLE: Configuring Trigger.dev with defineConfig
DESCRIPTION: Update the trigger.config.ts file to use the new defineConfig function for configuration.

LANGUAGE: typescript
CODE:
import { defineConfig } from "@trigger.dev/sdk/v3";

export default defineConfig({
  project: "<project ref>",
});

----------------------------------------

TITLE: File Structure Reference - Next.js LLM Evaluator
DESCRIPTION: Lists the key files and components that make up the LLM evaluation system, including the batch processing logic, evaluation components, and realtime hooks implementation.

LANGUAGE: plaintext
CODE:
src/trigger/batch.ts
src/components/llm-evaluator.tsx
src/components/evals/Anthropic.tsx
src/components/evals/XAI.tsx
src/components/evals/OpenAI.tsx

----------------------------------------

TITLE: Declarative Schedule Definition
DESCRIPTION: Examples of defining schedules declaratively using cron syntax, including timezone specification.

LANGUAGE: typescript
CODE:
export const firstScheduledTask = schedules.task({
  id: "first-scheduled-task",
  cron: "0 */2 * * *",
  run: async (payload, { ctx }) => {
    //do something
  },
});

LANGUAGE: typescript
CODE:
export const secondScheduledTask = schedules.task({
  id: "second-scheduled-task",
  cron: {
    pattern: "0 5 * * *",
    timezone: "Asia/Tokyo",
  },
  run: async (payload) => {},
});

----------------------------------------

TITLE: GET Environment Variables Endpoint Specification
DESCRIPTION: OpenAPI specification for retrieving environment variables. The endpoint requires a project reference and environment identifier as path parameters.

LANGUAGE: openapi
CODE:
GET /api/v1/projects/{projectRef}/envvars/{env}

----------------------------------------

TITLE: Creating Database Task with Drizzle ORM in TypeScript
DESCRIPTION: Implements a task to add new users to a PostgreSQL database using Drizzle ORM. The task accepts user details as payload and returns the created user information. Requires a configured users table schema with name, age, and email fields.

LANGUAGE: typescript
CODE:
import { eq } from "drizzle-orm";
import { task } from "@trigger.dev/sdk/v3";
import { users } from "src/db/schema";
import { drizzle } from "drizzle-orm/node-postgres";

// Initialize Drizzle client
const db = drizzle(process.env.DATABASE_URL!);

export const addNewUser = task({
  id: "drizzle-add-new-user",
  run: async (payload: typeof users.$inferInsert) => {
    // Create new user
    const [user] = await db.insert(users).values(payload).returning();

    return {
      createdUser: user,
      message: "User created and updated successfully",
    };
  },
});

----------------------------------------

TITLE: Version Pinning Configuration in package.json
DESCRIPTION: Package.json script configuration for version pinning in Trigger.dev deployments. Ensures consistent versions between CLI and packages.

LANGUAGE: json
CODE:
{
  "scripts": {
    "deploy:trigger-prod": "npx trigger.dev@3.0.0 deploy",
    "deploy:trigger": "npx trigger.dev@3.0.0 deploy --env staging"
  }
}

----------------------------------------

TITLE: Defining Multiple Tasks in Trigger.dev
DESCRIPTION: Example of defining multiple tasks in a single file using Trigger.dev's named exports pattern

LANGUAGE: typescript
CODE:
export const longRunningTask = task({
  id: "longRunningTask",
  run: async (payload: any) => {
    //...do stuff
  },
});

export const otherTask = task({
  id: "otherTask",
  run: async (payload: any) => {
    //...do different stuff
  },
});

----------------------------------------

TITLE: Installing Trigger.dev SDK via Package Managers
DESCRIPTION: Commands to install the @trigger.dev/sdk package using npm, pnpm, or yarn. This package is required for using the Trigger.dev management API.

LANGUAGE: bash
CODE:
npm i @trigger.dev/sdk@latest

LANGUAGE: bash
CODE:
pnpm add @trigger.dev/sdk@latest

LANGUAGE: bash
CODE:
yarn add @trigger.dev/sdk@latest

----------------------------------------

TITLE: Creating package.json for Fixture
DESCRIPTION: Template for creating a package.json file in a new fixture folder, including engine specifications for pnpm and yarn.

LANGUAGE: json
CODE:
{
  "name": "<fixture-name>",
  "private": true,
  "engines": {
    "pnpm": "8.15.5",
    "yarn": "4.2.2"
  },
  "packageManager": "pnpm@8.15.5"
}

----------------------------------------

TITLE: Using useRealtimeTaskTrigger Hook in React
DESCRIPTION: Example of using the useRealtimeTaskTrigger hook to trigger a task and subscribe to real-time updates in a single step within a React component.

LANGUAGE: typescript
CODE:
"use client"; // This is needed for Next.js App Router or other RSC frameworks

import { useRealtimeTaskTrigger } from "@trigger.dev/react-hooks";
import type { myTask } from "@/trigger/myTask";

export function MyComponent({ publicAccessToken }: { publicAccessToken: string }) {
  const { submit, run, error, isLoading } = useRealtimeTaskTrigger<typeof myTask>("my-task", {
    accessToken: publicAccessToken,
  });

  if (error) {
    return <div>Error: {error.message}</div>;
  }

  // This is the realtime run object, which will automatically update when the run changes
  if (run) {
    return <div>Run ID: {run.id}</div>;
  }

  return (
    <button onClick={() => submit({ foo: "bar" })} disabled={isLoading}>
      {isLoading ? "Loading..." : "Trigger Task"}
    </button>
  );
}

----------------------------------------

TITLE: Logging in to Trigger.dev CLI
DESCRIPTION: Log in to the Trigger.dev CLI to authenticate and link your account before deploying tasks.

LANGUAGE: bash
CODE:
npx trigger.dev login

----------------------------------------

TITLE: Basic Build Extension Configuration in TypeScript
DESCRIPTION: Simple example of configuring a build extension that logs a message when the build starts.

LANGUAGE: typescript
CODE:
import { defineConfig } from "@trigger.dev/sdk/v3";

export default defineConfig({
  project: "my-project",
  build: {
    extensions: [
      {
        name: "my-extension",
        onBuildStart: async (context) => {
          console.log("Build starting!");
        },
      },
    ],
  },
});

----------------------------------------

TITLE: Triggering Tasks in Trigger.dev
DESCRIPTION: Example of triggering a task in Trigger.dev with payload data

LANGUAGE: typescript
CODE:
"use server";

import { longRunningTask } from "@/trigger/someTasks";

export async function runLongRunningTask() {
  return await longRunningTask.trigger({ foo: "bar" });
}

----------------------------------------

TITLE: Executing Trigger.dev CLI Login Command with NPM
DESCRIPTION: This command uses NPX to run the latest version of the Trigger.dev CLI and execute the login command.

LANGUAGE: bash
CODE:
npx trigger.dev@latest login

----------------------------------------

TITLE: Configuring Trigger for Fixture
DESCRIPTION: Example of a trigger configuration file specifying the project name and trigger directories.

LANGUAGE: javascript
CODE:
export const config = {
  project: "<fixture-name>",
  triggerDirectories: ["./trigger"],
};

----------------------------------------

TITLE: Configuring additionalPackages in Trigger.dev
DESCRIPTION: This snippet demonstrates how to import and use the additionalPackages build extension in the trigger.config.ts file. It allows including additional packages in the build that are not automatically included via imports, useful for CLI tools to be invoked in tasks.

LANGUAGE: typescript
CODE:
import { defineConfig } from "@trigger.dev/sdk/v3";
import { additionalPackages } from "@trigger.dev/build/extensions/core";

export default defineConfig({
  project: "<project ref>",
  // Your other config settings...
  build: {
    extensions: [additionalPackages({ packages: ["wrangler"] })],
  },
});

----------------------------------------

TITLE: Setting Environment Variables for Trigger.dev SDK Configuration
DESCRIPTION: Demonstrates how to set environment variables for automatic SDK configuration, including the secret key and API URL.

LANGUAGE: bash
CODE:
TRIGGER_SECRET_KEY="tr_dev_…"

TRIGGER_API_URL="https://trigger.example.com"

----------------------------------------

TITLE: Executing Trigger.dev CLI Login Command with Yarn
DESCRIPTION: This command uses Yarn to run the latest version of the Trigger.dev CLI and execute the login command.

LANGUAGE: bash
CODE:
yarn dlx trigger.dev@latest login

----------------------------------------

TITLE: Bundling All ESM Packages in trigger.dev Configuration
DESCRIPTION: This snippet shows how to configure trigger.dev to bundle all ESM packages using a regex pattern. It uses the dependenciesToBundle property in the TriggerConfig object to specify that all packages should be bundled.

LANGUAGE: typescript
CODE:
import type { TriggerConfig } from "@trigger.dev/sdk/v3";

export const config: TriggerConfig = {
  //..other stuff
  dependenciesToBundle: [/.*/],
};

----------------------------------------

TITLE: Combining useTaskTrigger and useRealtimeRun Hooks in React
DESCRIPTION: Example of using both useTaskTrigger and useRealtimeRun hooks to trigger a task and subscribe to real-time updates in a React component.

LANGUAGE: typescript
CODE:
"use client"; // This is needed for Next.js App Router or other RSC frameworks

import { useTaskTrigger, useRealtimeRun } from "@trigger.dev/react-hooks";
import type { myTask } from "@/trigger/myTask";
//     👆 This is the type of your task

export function MyComponent({ publicAccessToken }: { publicAccessToken: string }) {
  //                         pass the type of your task here 👇
  const { submit, handle, error, isLoading } = useTaskTrigger<typeof myTask>("my-task", {
    accessToken: publicAccessToken, // 👈 this is the "trigger" token
  });

  //     use the handle object to preserve type-safety 👇
  const { run, error: realtimeError } = useRealtimeRun(handle, {
    accessToken: handle?.publicAccessToken,
    enabled: !!handle, // Only subscribe to the run if the handle is available
  });

  if (error) {
    return <div>Error: {error.message}</div>;
  }

  if (handle) {
    return <div>Run ID: {handle.id}</div>;
  }

  if (realtimeError) {
    return <div>Error: {realtimeError.message}</div>;
  }

  if (run) {
    return <div>Run ID: {run.id}</div>;
  }

  return (
    <button onClick={() => submit({ foo: "bar" })} disabled={isLoading}>
      {isLoading ? "Loading..." : "Trigger Task"}
    </button>
  );
}

----------------------------------------

TITLE: Creating Public Access Token with Specific Run Access
DESCRIPTION: Demonstrates creating a token with read permissions for specific run IDs, providing better security control.

LANGUAGE: typescript
CODE:
import { auth } from "@trigger.dev/sdk/v3";

const publicToken = await auth.createPublicToken({
  scopes: {
    read: {
      runs: ["run_1234", "run_5678"], // ✅ this token can read only these runs
    },
  },
});

----------------------------------------

TITLE: Installing trigger.dev Update Command - NPM
DESCRIPTION: Updates trigger.dev using NPM package manager via npx.

LANGUAGE: bash
CODE:
npx trigger.dev@latest update

----------------------------------------

TITLE: Manually Configuring Trigger.dev SDK in TypeScript
DESCRIPTION: Shows how to manually configure the Trigger.dev SDK using the 'configure' method, setting the secret key and base URL.

LANGUAGE: typescript
CODE:
import { configure } from "@trigger.dev/sdk/v3";
import { myTask } from "./trigger/myTasks";

configure({
  secretKey: "tr_dev_1234", // WARNING: Never actually hardcode your secret key like this
  baseURL: "https://mytrigger.example.com", // Optional
});

async function triggerTask() {
  await myTask.trigger({ userId: "1234" }); // This will use the secret key and base URL you configured
}

----------------------------------------

TITLE: Executing logout command with trigger.dev CLI using pnpm
DESCRIPTION: This command logs out the user from the trigger.dev CLI using pnpm as the package manager. It uses pnpm dlx to run the latest version of the trigger.dev package.

LANGUAGE: bash
CODE:
pnpm dlx trigger.dev@latest logout

----------------------------------------

TITLE: Bundling Individual Packages in trigger.dev Configuration
DESCRIPTION: This snippet demonstrates how to configure trigger.dev to bundle specific packages using a combination of regex patterns and package names. It uses the dependenciesToBundle property in the TriggerConfig object to specify which packages should be bundled.

LANGUAGE: typescript
CODE:
import type { TriggerConfig } from "@trigger.dev/sdk/v3";

export const config: TriggerConfig = {
  //..other stuff
  //either regex or strings of package names
  dependenciesToBundle: [/@sindresorhus/, "escape-string-regexp"],
};

----------------------------------------

TITLE: Creating Video Processing Task in TypeScript
DESCRIPTION: Implements a Trigger.dev task that processes video URLs, extracts audio using FFmpeg, transcribes with Deepgram, and updates Supabase database records. Requires @deepgram/sdk, @supabase/supabase-js, and fluent-ffmpeg dependencies.

LANGUAGE: typescript
CODE:
import { createClient as createDeepgramClient } from "@deepgram/sdk";
import { createClient as createSupabaseClient } from "@supabase/supabase-js";
import { logger, task } from "@trigger.dev/sdk/v3";
import ffmpeg from "fluent-ffmpeg";
import fs from "fs";
import { Readable } from "node:stream";
import os from "os";
import path from "path";
import { Database } from "../../database.types";

const supabase = createSupabaseClient<Database>(
  process.env.SUPABASE_PROJECT_URL as string,
  process.env.SUPABASE_SERVICE_ROLE_KEY as string
);

const deepgram = createDeepgramClient(process.env.DEEPGRAM_SECRET_KEY);

export const videoProcessAndUpdate = task({
  id: "video-process-and-update",
  run: async (payload: { videoUrl: string; id: number }) => {
    const { videoUrl, id } = payload;

    logger.log(`Processing video at URL: ${videoUrl}`);

    const tempDirectory = os.tmpdir();
    const outputPath = path.join(tempDirectory, `audio_${Date.now()}.wav`);

    const response = await fetch(videoUrl);

    await new Promise((resolve, reject) => {
      if (!response.body) {
        return reject(new Error("Failed to fetch video"));
      }

      ffmpeg(Readable.from(response.body))
        .outputOptions([
          "-vn",
          "-acodec pcm_s16le",
          "-ar 44100",
          "-ac 2",
        ])
        .output(outputPath)
        .on("end", resolve)
        .on("error", reject)
        .run();
    });

    logger.log(`Audio extracted from video`, { outputPath });

    const { result, error } = await deepgram.listen.prerecorded.transcribeFile(
      fs.readFileSync(outputPath),
      {
        model: "nova-2",
        smart_format: true,
        diarize: true,
      }
    );

    if (error) {
      throw error;
    }

    const transcription = result.results.channels[0].alternatives[0].paragraphs?.transcript;

    logger.log(`Transcription: ${transcription}`);

    fs.unlinkSync(outputPath);
    logger.log(`Temporary audio file deleted`, { outputPath });

    const { error: updateError } = await supabase
      .from("video_transcriptions")
      .update({ transcription: transcription })
      .eq("id", id);

    if (updateError) {
      throw new Error(`Failed to update transcription: ${updateError.message}`);
    }

    return {
      message: `Summary of the audio: ${transcription}`,
      result,
    };
  },
});

----------------------------------------

TITLE: Executing logout command with trigger.dev CLI using yarn
DESCRIPTION: This command logs out the user from the trigger.dev CLI using yarn as the package manager. It uses yarn dlx to run the latest version of the trigger.dev package.

LANGUAGE: bash
CODE:
yarn dlx trigger.dev@latest logout

----------------------------------------

TITLE: Extracted Build Extension Function in TypeScript
DESCRIPTION: Example showing how to define a build extension as a separate function using the BuildExtension type.

LANGUAGE: typescript
CODE:
import { defineConfig } from "@trigger.dev/sdk/v3";
import { BuildExtension } from "@trigger.dev/build";

export default defineConfig({
  project: "my-project",
  build: {
    extensions: [myExtension()],
  },
});

function myExtension(): BuildExtension {
  return {
    name: "my-extension",
    onBuildStart: async (context) => {
      console.log("Build starting!");
    },
  };
}

----------------------------------------

TITLE: Initializing Run Metadata in Trigger.dev
DESCRIPTION: Shows how to attach initial metadata when triggering a task run using the trigger function.

LANGUAGE: typescript
CODE:
const handle = await myTask.trigger(
  { message: "hello world" },
  { metadata: { user: { name: "Eric", id: "user_1234" } } }
);

----------------------------------------

TITLE: Starting Trigger.dev MCP Server with Custom Port
DESCRIPTION: This command starts the Trigger.dev Model Context Protocol (MCP) server using a custom port (3334 in this example). It demonstrates how to specify a different port for the MCP server.

LANGUAGE: bash
CODE:
trigger dev --mcp --mcp-port 3334

----------------------------------------

TITLE: Executing Trigger.dev CLI Login Command with PNPM
DESCRIPTION: This command uses PNPM to run the latest version of the Trigger.dev CLI and execute the login command.

LANGUAGE: bash
CODE:
pnpm dlx trigger.dev@latest login

----------------------------------------

TITLE: Configuring Vercel Environment Variable Sync in Trigger.dev
DESCRIPTION: Configuration setup in trigger.config.ts to enable automatic syncing of Vercel environment variables. Requires VERCEL_ACCESS_TOKEN and VERCEL_PROJECT_ID environment variables, with optional VERCEL_TEAM_ID for team projects.

LANGUAGE: typescript
CODE:
import { defineConfig } from "@trigger.dev/sdk/v3";
import { syncVercelEnvVars } from "@trigger.dev/build/extensions/core";

export default defineConfig({
  project: "<project ref>",
  // Your other config settings...
  build: {
    // Add the syncVercelEnvVars build extension
    extensions: [syncVercelEnvVars()],
  },
});

----------------------------------------

TITLE: Running trigger.dev init command with pnpm
DESCRIPTION: This command initializes a trigger.dev project using pnpm as the package manager.

LANGUAGE: bash
CODE:
pnpm dlx trigger.dev@latest init

----------------------------------------

TITLE: Updating Submodule to Specific Commit
DESCRIPTION: Command to checkout a specific commit in the submodule using its SHA.

LANGUAGE: shell script
CODE:
git checkout -q <sha>

----------------------------------------

TITLE: Running Trigger.dev in Development Mode
DESCRIPTION: The 'trigger.dev dev' command is used to run tasks locally during development. This command enables developers to test and debug their trigger.dev tasks in a local environment.

LANGUAGE: bash
CODE:
trigger.dev dev

----------------------------------------

TITLE: Deploying Trigger.dev with Vercel Environment Sync
DESCRIPTION: Command to deploy the Trigger.dev project and initiate the environment variable sync process from Vercel.

LANGUAGE: bash
CODE:
npx trigger.dev@latest deploy

----------------------------------------

TITLE: Running trigger.dev init command with yarn
DESCRIPTION: This command initializes a trigger.dev project using yarn as the package manager.

LANGUAGE: bash
CODE:
yarn dlx trigger.dev@latest init

----------------------------------------

TITLE: Entering Submodule Directory
DESCRIPTION: Command to change directory to the 'protos' submodule.

LANGUAGE: shell script
CODE:
cd protos

----------------------------------------

TITLE: Using throwIfInThePast Option with wait.until in TypeScript
DESCRIPTION: This snippet shows how to use the throwIfInThePast option with wait.until. When set to true, it will throw an error if the specified date is already in the past when the function is called.

LANGUAGE: typescript
CODE:
await wait.until({ date: new Date(date), throwIfInThePast: true });

----------------------------------------

TITLE: Updating concurrency limit handling in TypeScript
DESCRIPTION: Allows setting concurrencyLimit to null to remove the concurrency limit on the queue.

LANGUAGE: typescript
CODE:
- Allow setting concurrencyLimit to null to signal removing the concurrency limit on the queue ([#1653](https://github.com/triggerdotdev/trigger.dev/pull/1653))

----------------------------------------

TITLE: Updating Idempotency Key with Custom TTL in TypeScript
DESCRIPTION: Demonstrates how to use the new idempotencyKeyTTL parameter when triggering tasks with idempotency keys. This allows customization of how long the idempotency key remains valid.

LANGUAGE: typescript
CODE:
await myTask.batchTrigger([{ payload: { foo: "bar" } }], {
  idempotencyKey: "my-key",
  idempotencyKeyTTL: "60s",
});
// Works for individual items as well:
await myTask.batchTrigger([
  { payload: { foo: "bar" }, options: { idempotencyKey: "my-key", idempotencyKeyTTL: "60s" } },
]);
// And `trigger`:
await myTask.trigger({ foo: "bar" }, { idempotencyKey: "my-key", idempotencyKeyTTL: "60s" });

----------------------------------------

TITLE: Retry Process for Durable Execution
DESCRIPTION: A Mermaid sequence diagram illustrating the retry process for a durable execution workflow in Trigger.dev. It shows how tasks are retried and how cached results are used for completed subtasks.

LANGUAGE: mermaid
CODE:
sequenceDiagram
  participant Main as Main Task
  participant Process as Process Video
  participant Upload as Upload to S3
  participant DB as Update Database
  participant Email as Send Email

  Main->>Process: triggerAndWait (1st attempt)
  Process-->>Main: Return result
  Main->>Upload: triggerAndWait (1st attempt)
  Upload-->>Main: Return result
  Main->>DB: Update
  Main->>Email: triggerAndWait (1st attempt)
  Email--xMain: Fail
  Main-->>Main: Schedule retry

  Main->>Process: triggerAndWait (2nd attempt)
  Process-->>Main: Return cached result
  Main->>Upload: triggerAndWait (2nd attempt)
  Upload-->>Main: Return cached result
  Main->>DB: Update (idempotent)
  Main->>Email: triggerAndWait (2nd attempt)
  Email-->>Main: Success

----------------------------------------

TITLE: Installing trigger.dev Update Command - PNPM
DESCRIPTION: Updates trigger.dev using PNPM package manager via dlx.

LANGUAGE: bash
CODE:
pnpm dlx trigger.dev@latest update

----------------------------------------

TITLE: Installing Protobuf Compiler on Linux
DESCRIPTION: Command to install the protobuf compiler on Linux using apt package manager.

LANGUAGE: sh
CODE:
apt install -y protobuf-compiler

----------------------------------------

TITLE: Improving deploy timeout handling in TypeScript
DESCRIPTION: Fixes deploy timeout issues and improves the output of logs when deploying.

LANGUAGE: typescript
CODE:
- Fixed deploy timeout issues and improve the output of logs when deploying ([#1661](https://github.com/triggerdotdev/trigger.dev/pull/1661))

----------------------------------------

TITLE: Running list-profiles Command with PNPM in Bash
DESCRIPTION: This snippet shows how to execute the list-profiles command using PNPM in a Bash environment. It uses pnpm dlx to run the latest version of trigger.dev CLI.

LANGUAGE: bash
CODE:
pnpm dlx trigger.dev@latest list-profiles

----------------------------------------

TITLE: Installing trigger.dev Update Command - Yarn
DESCRIPTION: Updates trigger.dev using Yarn package manager via dlx.

LANGUAGE: bash
CODE:
yarn dlx trigger.dev@latest update

----------------------------------------

TITLE: Accessing Environment Variables in Python
DESCRIPTION: Example of accessing environment variables within a Python script

LANGUAGE: python
CODE:
import os

print(os.environ["MY_ENV_VAR"])

----------------------------------------

TITLE: Retrieving a Typed Run from Trigger Response in Trigger.dev using TypeScript
DESCRIPTION: Shows how to retrieve a typed run directly from a trigger response in Trigger.dev.

LANGUAGE: typescript
CODE:
import { runs, tasks } from "@trigger.dev/sdk/v3";
import type { myTask } from "./trigger/myTask";

const response = await tasks.trigger<typeof myTask>({ foo: "bar" });
const run = await runs.retrieve(response);

console.log(run.payload.foo); // string
console.log(run.output.bar); // string

----------------------------------------

TITLE: Adding run completion submission with acknowledgment in TypeScript
DESCRIPTION: Adds a new run completion submission message with acknowledgment and timeout support for sendWithAck.

LANGUAGE: typescript
CODE:
- Add new run completion submission message with ack ([#1711](https://github.com/triggerdotdev/trigger.dev/pull/1711))
- Add timeout support to sendWithAck

----------------------------------------

TITLE: Fixing asResponse and withResponse functionality in TypeScript
DESCRIPTION: Fixes an issue with asResponse and withResponse not working on runs.retrieve.

LANGUAGE: typescript
CODE:
- Fixed issue with asResponse and withResponse not working on runs.retrieve ([#1648](https://github.com/triggerdotdev/trigger.dev/pull/1648))

----------------------------------------

TITLE: Running list-profiles Command with Yarn in Bash
DESCRIPTION: This snippet illustrates how to run the list-profiles command using Yarn in a Bash environment. It uses yarn dlx to execute the latest version of trigger.dev CLI.

LANGUAGE: bash
CODE:
yarn dlx trigger.dev@latest list-profiles

----------------------------------------

TITLE: Running list-profiles Command with NPM in Bash
DESCRIPTION: This snippet demonstrates how to run the list-profiles command using NPM in a Bash environment. It uses npx to execute the latest version of trigger.dev CLI.

LANGUAGE: bash
CODE:
npx trigger.dev@latest list-profiles

----------------------------------------

TITLE: Streaming Python Script Output
DESCRIPTION: Example of streaming output from a Python script execution using python.stream.runScript

LANGUAGE: typescript
CODE:
import { task } from "@trigger.dev/sdk/v3";
import { python } from "@trigger.dev/python";

export const myStreamingScript = task({
  id: "my-streaming-python-script",
  run: async () => {
    const result = python.stream.runScript("./python/my_script.py", ["hello", "world"]);

    for await (const chunk of streamingResult) {
      console.log(chunk);
    }
  },
});

----------------------------------------

TITLE: Version Updates and Changes Format
DESCRIPTION: Standardized changelog format showing version numbers, patch changes, and dependency updates for the @trigger.dev/build package.

LANGUAGE: markdown
CODE:
## 3.3.17

### Patch Changes

- Updated dependencies:
  - `@trigger.dev/core@3.3.17`

----------------------------------------

TITLE: Running CLI whoami Command with NPM
DESCRIPTION: Executes the trigger.dev CLI whoami command using NPM to display current logged-in user and project details.

LANGUAGE: bash
CODE:
npx trigger.dev@latest whoami

----------------------------------------

TITLE: Importing CLI Development Commands Documentation
DESCRIPTION: Import statement for including CLI development command documentation from an external MDX snippet file.

LANGUAGE: mdx
CODE:
import CliDevCommands from "/snippets/cli-commands-develop.mdx";

<CliDevCommands />

----------------------------------------

TITLE: Installing Python Extension Package
DESCRIPTION: Command to install the @trigger.dev/python package using npm

LANGUAGE: bash
CODE:
npm add @trigger.dev/python

----------------------------------------

TITLE: Retrieving a Typed Run in Trigger.dev using TypeScript
DESCRIPTION: Demonstrates how to retrieve a run with correct typing for payload and output.

LANGUAGE: typescript
CODE:
import { runs } from "@trigger.dev/sdk/v3";
import type { myTask } from "./trigger/myTask";

const run = await runs.retrieve<typeof myTask>(runId);

console.log(run.payload.foo); // string
console.log(run.output.bar); // string

----------------------------------------

TITLE: Configuring package.json for Concurrent Next.js and Trigger.dev Development
DESCRIPTION: This snippet shows how to modify the scripts section in package.json to enable concurrent running of Next.js and Trigger.dev servers. It uses npx concurrently to run both servers simultaneously with color-coded output.

LANGUAGE: json
CODE:
{
  "scripts": {
    "trigger:dev": "npx trigger.dev@latest dev",
    "dev": "npx concurrently --kill-others --names \"next,trigger\" --prefix-colors \"yellow,blue\" \"next dev\" \"npm run trigger:dev\""
  }
}

----------------------------------------

TITLE: Starting Email Development Server
DESCRIPTION: Command to start the development server for the emails module using pnpm run with filter flag.

LANGUAGE: sh
CODE:
pnpm run dev --filter emails

----------------------------------------

TITLE: Executing logout command with trigger.dev CLI using npm
DESCRIPTION: This command logs out the user from the trigger.dev CLI using npm as the package manager. It uses npx to run the latest version of the trigger.dev package.

LANGUAGE: bash
CODE:
npx trigger.dev@latest logout

----------------------------------------

TITLE: Specifying FFmpeg Version in Trigger.dev Build Extension
DESCRIPTION: This code shows how to specify a particular version of FFmpeg when adding the build extension to a Trigger.dev project. It allows for version control of the FFmpeg installation.

LANGUAGE: typescript
CODE:
import { defineConfig } from "@trigger.dev/sdk/v3";
import { ffmpeg } from "@trigger.dev/build/extensions/core";

export default defineConfig({
  project: "<project ref>",
  // Your other config settings...
  build: {
    extensions: [ffmpeg({ version: "6.0-4" })],
  },
});

----------------------------------------

TITLE: Installing Docker Engine on Ubuntu
DESCRIPTION: Complete sequence of commands to install Docker Engine on Ubuntu, including repository setup, GPG key installation, and package installation.

LANGUAGE: shell
CODE:
sudo apt update

LANGUAGE: shell
CODE:
sudo apt install apt-transport-https ca-certificates curl software-properties-common

LANGUAGE: shell
CODE:
curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg

LANGUAGE: shell
CODE:
echo "deb [arch=amd64 signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null

LANGUAGE: shell
CODE:
sudo apt update

LANGUAGE: shell
CODE:
sudo apt install docker-ce docker-ce-cli containerd.io

LANGUAGE: shell
CODE:
docker --version

----------------------------------------

TITLE: Running trigger.dev init command with npm
DESCRIPTION: This command initializes a trigger.dev project using npm as the package manager.

LANGUAGE: bash
CODE:
npx trigger.dev@latest init

----------------------------------------

TITLE: Self-Hosted Docker Hub Deployment
DESCRIPTION: Example of deploying to Docker Hub in a self-hosted setup, including loading the image and specifying registry details

LANGUAGE: bash
CODE:
npx trigger.dev@latest deploy \
  --self-hosted \
  --load-image \
  --registry docker.io \
  --namespace mydockerhubusername

----------------------------------------

TITLE: Configuring Multiple Prisma Schemas in Trigger.dev
DESCRIPTION: This snippet demonstrates how to configure multiple prismaExtensions for different Prisma schemas within the same Trigger.dev project.

LANGUAGE: typescript
CODE:
prismaExtension({
  schema: 'prisma/schema/main.prisma',
  version: '6.2.0',
  migrate: false,
}),
prismaExtension({
  schema: 'prisma/schema/secondary.prisma',
  version: '6.2.0',
  migrate: false,
}),

----------------------------------------

TITLE: Listing All Runs using Async Iterator in Trigger.dev with TypeScript
DESCRIPTION: Shows how to use an Async Iterator to list all runs in Trigger.dev.

LANGUAGE: typescript
CODE:
import { runs } from "@trigger.dev/sdk/v3";

for await (const run of runs.list({ limit: 20 })) {
  console.log(run);
}

----------------------------------------

TITLE: Deploying Trigger.dev Tasks Using CLI
DESCRIPTION: Commands for deploying Trigger.dev tasks using the CLI with different package managers. The command uses the latest version of trigger.dev to perform the deployment.

LANGUAGE: bash
CODE:
npx trigger.dev@latest deploy

LANGUAGE: bash
CODE:
pnpm dlx trigger.dev@latest deploy

LANGUAGE: bash
CODE:
yarn dlx trigger.dev@latest deploy

----------------------------------------

TITLE: Building Packages for Snapshot in Trigger.dev
DESCRIPTION: Command to build the packages for a snapshot release. This filters the build process to include only @trigger.dev/* and trigger.dev packages.

LANGUAGE: sh
CODE:
pnpm run build --filter "@trigger.dev/*" --filter "trigger.dev"

----------------------------------------

TITLE: Importing Deploy Commands Component in MDX
DESCRIPTION: Imports a reusable MDX component containing deploy command documentation from the snippets directory.

LANGUAGE: mdx
CODE:
import CliDeployCommands from "/snippets/cli-commands-deploy.mdx";

<CliDeployCommands />

----------------------------------------

TITLE: Promoting Trigger.dev Version with NPM
DESCRIPTION: Command to promote a specific version of a Trigger.dev deployment using NPM package manager. The version parameter specifies the previously deployed version to promote.

LANGUAGE: bash
CODE:
npx trigger.dev@latest promote [version]

----------------------------------------

TITLE: Configuring Prisma Extension with TypedSQL in Trigger.dev
DESCRIPTION: This snippet shows how to enable TypedSQL support in the prismaExtension configuration for a Trigger.dev project.

LANGUAGE: typescript
CODE:
import { defineConfig } from "@trigger.dev/sdk/v3";

export default defineConfig({
  project: "<project ref>",
  // Your other config settings...
  build: {
    extensions: [
      prismaExtension({
        schema: "prisma/schema.prisma",
        typedSql: true,
      }),
    ],
  },
});

----------------------------------------

TITLE: Creating Snapshot Version in Trigger.dev
DESCRIPTION: Command to create a snapshot version for pre-release. The 'prerelease' tag should be replaced with the appropriate tag for the snapshot.

LANGUAGE: sh
CODE:
pnpm exec changeset version --snapshot prerelease

----------------------------------------

TITLE: Importing CLI Deploy Commands Component in MDX
DESCRIPTION: Imports a component containing CLI deploy command documentation from a snippets directory.

LANGUAGE: jsx
CODE:
import CliDeployCommands from "/snippets/cli-commands-deploy.mdx";

<CliDeployCommands />

----------------------------------------

TITLE: Starting Next.js Development Server
DESCRIPTION: Commands to start the Next.js development server using different package managers (npm, pnpm, yarn).

LANGUAGE: bash
CODE:
npm run dev

LANGUAGE: bash
CODE:
pnpm run dev

LANGUAGE: bash
CODE:
yarn dev

----------------------------------------

TITLE: Configuring Prisma Schema with Multiple Generators
DESCRIPTION: This Prisma schema snippet demonstrates how to define multiple generators, including prisma-client-js, prisma-kysely, and prisma-json-types-generator.

LANGUAGE: prisma
CODE:
datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DATABASE_URL_UNPOOLED")
}

// We only want to generate the prisma-client-js generator
generator client {
  provider        = "prisma-client-js"
}

generator kysely {
  provider     = "prisma-kysely"
  output       = "../../src/kysely"
  enumFileName = "enums.ts"
  fileName     = "types.ts"
}

generator json {
  provider = "prisma-json-types-generator"
}

----------------------------------------

TITLE: Task Scheduling in Trigger.dev
DESCRIPTION: Example of creating a scheduled task using Trigger.dev's schedules functionality

LANGUAGE: typescript
CODE:
import { schedules } from "@trigger.dev/sdk/v3";

export const sendMondayNewletter = schedules.task({
  id: "send-monday-newsletter",
  run: async (payload) => {
    // business logic here
  },
});

----------------------------------------

TITLE: Running Trigger.dev Development Server
DESCRIPTION: Commands to start the Trigger.dev development server using different package managers. Uses the latest version of trigger.dev CLI.

LANGUAGE: bash
CODE:
npx trigger.dev@latest dev

LANGUAGE: bash
CODE:
pnpm dlx trigger.dev@latest dev

LANGUAGE: bash
CODE:
yarn dlx trigger.dev@latest dev

----------------------------------------

TITLE: Adding Changesets in Trigger.dev
DESCRIPTION: Command to add a new changeset for package updates. This should be used when making changes to public packages.

LANGUAGE: sh
CODE:
pnpm run changeset:add

----------------------------------------

TITLE: Importing CLI Development Commands Documentation in MDX
DESCRIPTION: Import statement to include CLI development command documentation from an external MDX snippet file.

LANGUAGE: mdx
CODE:
import CliDevelopCommands from '/snippets/cli-commands-develop.mdx';

<CliDevelopCommands/>

----------------------------------------

TITLE: Running Remix App with Package Managers
DESCRIPTION: Commands to start the Remix application using npm, pnpm, or yarn. This runs the development server for the Remix app.

LANGUAGE: bash
CODE:
npm run dev

LANGUAGE: bash
CODE:
pnpm run dev

LANGUAGE: bash
CODE:
yarn dev

----------------------------------------

TITLE: Implementing Trigger.dev Task in Supabase Edge Function (TypeScript)
DESCRIPTION: This code snippet shows how to implement a Trigger.dev task within a Supabase edge function. It imports necessary types and functions, sets up a Deno server, and triggers a 'hello-world' task with a custom payload.

LANGUAGE: typescript
CODE:
// Setup type definitions for built-in Supabase Runtime APIs
import "jsr:@supabase/functions-js/edge-runtime.d.ts";
// Import the Trigger.dev SDK - replace "<your-sdk-version>" with the version of the SDK you are using, e.g. "3.0.0". You can find this in your package.json file.
import { tasks } from "npm:@trigger.dev/sdk@3.0.0/v3";
// Import your task type from your /trigger folder
import type { helloWorldTask } from "../../../src/trigger/example.ts";
//     👆 **type-only** import

Deno.serve(async () => {
  await tasks.trigger<typeof helloWorldTask>(
    // Your task id
    "hello-world",
    // Your task payload
    "Hello from a Supabase Edge Function!"
  );
  return new Response("OK");
});

----------------------------------------

TITLE: Implementing Time Delays in trigger.dev Tasks using wait.for()
DESCRIPTION: This code snippet shows how to use the wait.for() function to introduce time delays of different durations within a trigger.dev task. It demonstrates delays ranging from seconds to years, allowing for easy implementation of timed operations without complex scheduling logic.

LANGUAGE: typescript
CODE:
export const veryLongTask = task({
  id: "very-long-task",
  run: async (payload) => {
    await wait.for({ seconds: 5 });

    await wait.for({ minutes: 10 });

    await wait.for({ hours: 1 });

    await wait.for({ days: 1 });

    await wait.for({ weeks: 1 });

    await wait.for({ months: 1 });

    await wait.for({ years: 1 });
  },
});

----------------------------------------

TITLE: Promoting Trigger.dev Version with PNPM
DESCRIPTION: Command to promote a specific version of a Trigger.dev deployment using PNPM package manager. The version parameter specifies the previously deployed version to promote.

LANGUAGE: bash
CODE:
pnpm dlx trigger.dev@latest promote [version]

----------------------------------------

TITLE: Installing corepack globally in Node.js
DESCRIPTION: This command installs the latest version of corepack globally to resolve the 'Cannot find matching keyid' error in Node.js v22.

LANGUAGE: shell
CODE:
npm i -g corepack@latest

----------------------------------------

TITLE: Creating Task Trigger Route in Remix
DESCRIPTION: Implementation of a Remix API route that triggers a hello-world task using Trigger.dev SDK

LANGUAGE: typescript
CODE:
import type { helloWorldTask } from "../../src/trigger/example";
import { tasks } from "@trigger.dev/sdk/v3";

export async function loader() {
  const handle = await tasks.trigger<typeof helloWorldTask>("hello-world", "James");

  return new Response(JSON.stringify(handle), {
    headers: { "Content-Type": "application/json" },
  });
}

----------------------------------------

TITLE: Task Scheduling in Defer.run
DESCRIPTION: Example of creating a scheduled task using Defer.run's cron functionality

LANGUAGE: typescript
CODE:
import { defer } from "@defer/client";

async function sendMondayNewletter() {
  // business logic here
}

export default defer.cron(sendMondayNewletter, "0 0 * * 1");

----------------------------------------

TITLE: Basic Deployment Commands
DESCRIPTION: Shows how to deploy using different package managers (npm, pnpm, yarn)

LANGUAGE: bash
CODE:
npx trigger.dev@latest deploy

LANGUAGE: bash
CODE:
pnpm dlx trigger.dev@latest deploy

LANGUAGE: bash
CODE:
yarn dlx trigger.dev@latest deploy

----------------------------------------

TITLE: Configuring Trigger.dev Dev Dependencies
DESCRIPTION: Example of adding Trigger.dev CLI as a dev dependency in package.json with specific version.

LANGUAGE: json
CODE:
{
  "devDependencies": {
    "trigger.dev": "3.0.0"
  }
}

----------------------------------------

TITLE: Task Test Payload Example
DESCRIPTION: Sample JSON payload for testing the Prisma user creation task through the Trigger.dev dashboard.

LANGUAGE: json
CODE:
{
  "name": "<a-name>", // e.g. "John Doe"
  "email": "<a-email>", // e.g. "john@doe.test"
  "id": "<a-number>" // e.g. 12345
}

----------------------------------------

TITLE: Configuring Yarn for Fixture
DESCRIPTION: YAML configuration for .yarnrc.yaml to avoid generating .pnp files and use node-modules linker.

LANGUAGE: yaml
CODE:
nodeLinker: node-modules

----------------------------------------

TITLE: Implementing Webhook Handler with Next.js Pages Router
DESCRIPTION: Creates a webhook handler endpoint using Next.js Pages Router that receives POST requests and triggers a hello world task. The handler parses the webhook payload and uses the Trigger.dev SDK to execute the task.

LANGUAGE: typescript
CODE:
import { helloWorldTask } from "@/trigger/example";
import { tasks } from "@trigger.dev/sdk/v3";
import type { NextApiRequest, NextApiResponse } from "next";

export default async function handler(req: NextApiRequest, res: NextApiResponse) {
  // Parse the webhook payload
  const payload = req.body;

  // Trigger the helloWorldTask with the webhook data as the payload
  await tasks.trigger<typeof helloWorldTask>("hello-world", payload);

  res.status(200).json({ message: "OK" });
}

----------------------------------------

TITLE: Configuring Prisma Build Extension
DESCRIPTION: Set up the Prisma build extension to support Prisma in Trigger.dev tasks, including schema path and optional migration.

LANGUAGE: typescript
CODE:
import { defineConfig } from "@trigger.dev/sdk/v3";
import { prismaExtension } from "@trigger.dev/build/extensions/prisma";

export default defineConfig({
  project: "<project ref>",
  build: {
    extensions: [
      prismaExtension({
        schema: "prisma/schema.prisma",
        migrate: true,
        directUrlEnvVarName: "DATABASE_URL_UNPOOLED",
      }),
    ],
  },
});

----------------------------------------

TITLE: Testing Payload for LibreOffice PDF Conversion Task
DESCRIPTION: This JSON snippet provides the structure for the payload used to test the LibreOffice PDF conversion task. It requires a documentUrl parameter specifying the URL of the document to be converted.

LANGUAGE: json
CODE:
{
  "documentUrl": "<a-document-url>" // Replace <a-document-url> with the URL of the document you want to convert
}

----------------------------------------

TITLE: Installing Fixture Dependencies
DESCRIPTION: Commands to install dependencies and generate lockfiles for a fixture project.

LANGUAGE: bash
CODE:
cd packages/cli-v3/e2e/fixtures/<fixture-name>
corepack use pnpm@8.15.5
pnpm install jsdom

----------------------------------------

TITLE: Configuring TypeScript Workspace Paths for Trigger.dev Packages
DESCRIPTION: TypeScript configuration file that sets up path aliases for all Trigger.dev packages, enabling local development with workspace dependencies. Includes compiler options and path mappings for SDK, integrations, and core packages.

LANGUAGE: json
CODE:
{
  "extends": "@trigger.dev/tsconfig/node18.json",
  "include": ["./src/**/*.ts"],
  "compilerOptions": {
    "baseUrl": ".",
    "lib": ["DOM", "DOM.Iterable"],
    "paths": {
      "@/*": ["./src/*"],
      "@trigger.dev/sdk": ["../../packages/trigger-sdk/src/index"],
      "@trigger.dev/sdk/*": ["../../packages/trigger-sdk/src/*"],
      "@trigger.dev/express": ["../../packages/express/src/index"],
      "@trigger.dev/express/*": ["../../packages/express/src/*"],
      "@trigger.dev/core": ["../../packages/core/src/index"],
      "@trigger.dev/core/*": ["../../packages/core/src/*"],
      "@trigger.dev/integration-kit": ["../../packages/integration-kit/src/index"],
      "@trigger.dev/integration-kit/*": ["../../packages/integration-kit/src/*"],
      "@trigger.dev/github": ["../../integrations/github/src/index"],
      "@trigger.dev/github/*": ["../../integrations/github/src/*"],
      "@trigger.dev/slack": ["../../integrations/slack/src/index"],
      "@trigger.dev/slack/*": ["../../integrations/slack/src/*"],
      "@trigger.dev/openai": ["../../integrations/openai/src/index"],
      "@trigger.dev/openai/*": ["../../integrations/openai/src/*"],
      "@trigger.dev/resend": ["../../integrations/resend/src/index"],
      "@trigger.dev/resend/*": ["../../integrations/resend/src/*"],
      "@trigger.dev/typeform": ["../../integrations/typeform/src/index"],
      "@trigger.dev/typeform/*": ["../../integrations/typeform/src/*"],
      "@trigger.dev/plain": ["../../integrations/plain/src/index"],
      "@trigger.dev/plain/*": ["../../integrations/plain/src/*"],
      "@trigger.dev/supabase": ["../../integrations/supabase/src/index"],
      "@trigger.dev/supabase/*": ["../../integrations/supabase/src/*"],
      "@trigger.dev/stripe": ["../../integrations/stripe/src/index"],
      "@trigger.dev/stripe/*": ["../../integrations/stripe/src/*"],
      "@trigger.dev/sendgrid": ["../../integrations/sendgrid/src/index"],
      "@trigger.dev/sendgrid/*": ["../../integrations/sendgrid/src/*"],
      "@trigger.dev/airtable": ["../../integrations/airtable/src/index"],
      "@trigger.dev/airtable/*": ["../../integrations/airtable/src/*"]
    }
  }
}

----------------------------------------

TITLE: Triggering Tasks in Defer.run
DESCRIPTION: Example of triggering a task in Defer.run using server actions

LANGUAGE: typescript
CODE:
"use server";

import longRunningTask from "@/defer/longRunningTask";

export async function runLongRunningTask() {
  return await longRunningTask();
}

----------------------------------------

TITLE: Correctly Passing Event Handler to React Button Component in TSX
DESCRIPTION: This snippet demonstrates the correct way to pass an event handler to a React Button component using an arrow function. This approach ensures that the handler is called with the correct context and any necessary arguments.

LANGUAGE: tsx
CODE:
<Button onClick={() => myTask()}>Trigger my task</Button>

----------------------------------------

TITLE: Using Emit Decorator Metadata Build Extension
DESCRIPTION: Configure the emitDecoratorMetadata build extension to enable decorator metadata in the Trigger.dev build process.

LANGUAGE: typescript
CODE:
import { defineConfig } from "@trigger.dev/sdk/v3";
import { emitDecoratorMetadata } from "@trigger.dev/build/extensions/typescript";

export default defineConfig({
  project: "<project ref>",
  build: {
    extensions: [emitDecoratorMetadata()],
  },
});

----------------------------------------

TITLE: Test Payload for Email Sequence Task
DESCRIPTION: Example JSON payload for testing the email sequence task in the dashboard. Includes required fields for userId, email, and name.

LANGUAGE: json
CODE:
{
  "userId": "123",
  "email": "<your-test-email>", // Replace with your test email
  "name": "Alice Testington"
}

----------------------------------------

TITLE: Creating Trigger Task for Fixture
DESCRIPTION: Example of creating a simple 'Hello World' trigger task in JavaScript for the fixture project.

LANGUAGE: javascript
CODE:
import { task } from "@trigger.dev/sdk/v3";

export const helloWorldTask = task({
  id: "hello-world",
  run: async (payload) => {
    console.log("Hello, World!", payload);
  },
});

----------------------------------------

TITLE: Configuring Service Role Authentication for Supabase in TypeScript
DESCRIPTION: Shows how to create a Supabase client with admin-level privileges using a service role key. This setup bypasses Row Level Security policies and provides unrestricted database access.

LANGUAGE: typescript
CODE:
const supabase = createClient<Database>(
  // These details can be found in your Supabase project settings under `API`
  process.env.SUPABASE_PROJECT_URL as string, // e.g. https://abc123.supabase.co - replace 'abc123' with your project ID
  process.env.SUPABASE_SERVICE_ROLE_KEY as string // Your service role secret key
);

// Your task

----------------------------------------

TITLE: Updating Trigger.dev CLI in devDependencies
DESCRIPTION: Update the trigger.dev CLI package to version 3.0.0 or higher in the project's devDependencies.

LANGUAGE: json
CODE:
"trigger.dev": "^3.0.0",

----------------------------------------

TITLE: Test Payload for Fal.ai Image Conversion Task
DESCRIPTION: JSON payload structure for testing the image conversion task through the Trigger.dev dashboard. Requires an image URL and desired filename for storage.

LANGUAGE: json
CODE:
"imageUrl": "<image-url>", // Replace with the URL of the image you want to convert to a cartoon
"fileName": "<file-name>" // Replace with the name you want to save the file as in Cloudflare R2

----------------------------------------

TITLE: Configuring Dev Dependencies for CLI
DESCRIPTION: Package.json configuration snippet showing how to add trigger.dev as a workspace development dependency for use in new projects.

LANGUAGE: json
CODE:
//...
"devDependencies": {
    "trigger.dev": "workspace:*",
    //...
}
//...

----------------------------------------

TITLE: Running Trigger.dev Webapp Development Server
DESCRIPTION: Command to start the local development server for the webapp using pnpm workspace filtering

LANGUAGE: sh
CODE:
pnpm run dev --filter webapp

----------------------------------------

TITLE: Subscribing to Run Changes with Tag in Trigger.dev SDK (TypeScript)
DESCRIPTION: This snippet demonstrates how to use the subscribeToRunsWithTag function to subscribe to all changes to runs with a specific tag. It returns an async iterator that yields the run object whenever a run with the specified tag is updated.

LANGUAGE: typescript
CODE:
import { runs } from "@trigger.dev/sdk/v3";

for await (const run of runs.subscribeToRunsWithTag("user:1234")) {
  console.log(run);
}

----------------------------------------

TITLE: Setting up Trigger.dev NPM Scripts
DESCRIPTION: Configuration of NPM scripts in package.json for running Trigger.dev dev and deploy commands.

LANGUAGE: json
CODE:
{
  "scripts": {
    "dev:trigger": "trigger dev",
    "deploy:trigger": "trigger deploy"
  }
}

----------------------------------------

TITLE: Using ESBuild Plugin Extension with Sentry
DESCRIPTION: Configure the esbuildPlugin extension to use Sentry's ESBuild plugin for automatic sourcemap uploading.

LANGUAGE: typescript
CODE:
import { defineConfig } from "@trigger.dev/sdk/v3";
import { esbuildPlugin } from "@trigger.dev/build/extensions";
import { sentryEsbuildPlugin } from "@sentry/esbuild-plugin";

export default defineConfig({
  project: "<project ref>",
  build: {
    extensions: [
      esbuildPlugin(
        sentryEsbuildPlugin({
          org: process.env.SENTRY_ORG,
          project: process.env.SENTRY_PROJECT,
          authToken: process.env.SENTRY_AUTH_TOKEN,
        }),
        { placement: "last", target: "deploy" }
      ),
    ],
  },
});

----------------------------------------

TITLE: Example Payload for News Fact Checker
DESCRIPTION: Sample JSON payload for testing the news fact checker system. Contains a test article about Tesla's battery technology announcements.

LANGUAGE: json
CODE:
{
  "article": "Tesla announced a new breakthrough in battery technology today. The company claims their new batteries will have 50% more capacity and cost 30% less to produce. Elon Musk stated this development will enable electric vehicles to achieve price parity with gasoline cars by 2024. The new batteries are scheduled to enter production next quarter at the Texas Gigafactory."
}

----------------------------------------

TITLE: Batch Trigger Example with TypeScript
DESCRIPTION: Example showing how to trigger multiple different tasks in a single batch using the batch.trigger method.

LANGUAGE: typescript
CODE:
import { batch } from "@trigger.dev/sdk/v3";
import type { myTask1, myTask2 } from "./trigger/tasks";

// Somewhere in your backend code
const response = await batch.trigger<typeof myTask1 | typeof myTask2>([
  { id: "task1", payload: { foo: "bar" } },
  { id: "task2", payload: { baz: "qux" } },
]);

for (const run of response.runs) {
  if (run.ok) {
    console.log(run.output);
  } else {
    console.error(run.error);
  }
}

----------------------------------------

TITLE: Starting the trigger.dev Supervisor
DESCRIPTION: This command starts the trigger.dev Supervisor using the pnpm package manager.

LANGUAGE: sh
CODE:
pnpm dev

----------------------------------------

TITLE: Using Latest Trigger.dev CLI with npx
DESCRIPTION: Command to run the latest version of the Trigger.dev CLI using npx, replacing the old beta version usage.

LANGUAGE: sh
CODE:
npx trigger.dev@latest dev

----------------------------------------

TITLE: Test Payload Example in JSON
DESCRIPTION: Example JSON payload for testing the customer question handling workflow.

LANGUAGE: json
CODE:
{
  "question": "Can you explain 2FA?"
}

----------------------------------------

TITLE: TypeORM Integration Example
DESCRIPTION: Example showing how to use TypeORM with decorator support in Trigger.dev tasks

LANGUAGE: typescript
CODE:
import "reflect-metadata";
import { DataSource } from "typeorm";
import { Entity, Column, PrimaryColumn } from "typeorm";

@Entity()
export class Photo {
  @PrimaryColumn()
  id!: number;

  @Column()
  name!: string;

  @Column() 
  description!: string;

  @Column()
  filename!: string;

  @Column()
  views!: number;

  @Column()
  isPublished!: boolean;
}

----------------------------------------

TITLE: Publishing Snapshot in Trigger.dev
DESCRIPTION: Command to publish the snapshot version. The 'prerelease' tag should be replaced with the appropriate tag for the snapshot. This command publishes without creating a git tag.

LANGUAGE: sh
CODE:
pnpm exec changeset publish --no-git-tag --snapshot --tag prerelease

----------------------------------------

TITLE: Creating Public Access Token for Batch Subscription
DESCRIPTION: Demonstrates how to generate a public access token with specific batch read permissions using the auth.createPublicToken function. This is necessary for client-side authentication when subscribing to batch updates.

LANGUAGE: typescript
CODE:
import { auth } from "@trigger.dev/sdk/v3";

// Somewhere in your backend code
const publicToken = await auth.createPublicToken({
  scopes: {
    read: {
      batch: ["batch_1234"],
    },
  },
});

----------------------------------------

TITLE: Package.json Configuration for Concurrent Execution
DESCRIPTION: Script configuration in package.json for running multiple development servers concurrently, including Trigger.dev and framework-specific servers.

LANGUAGE: json
CODE:
"scripts": {
  "dev": "concurrently --raw --kill-others npm:dev:*",
  "dev:trigger": "npx trigger.dev@latest dev",
  // Add your framework-specific dev script here, for example:
  // "dev:next": "next dev",
  // "dev:remix": "remix dev",
  //...
}

----------------------------------------

TITLE: Updating Trigger.dev SDK Package Version in package.json
DESCRIPTION: Update the @trigger.dev/sdk package to version 3.0.0 or higher in the project's package.json file.

LANGUAGE: json
CODE:
"@trigger.dev/sdk": "^3.0.0",

----------------------------------------

TITLE: Installing Trigger.dev using NPM
DESCRIPTION: Initializes a new Trigger.dev project using NPM package manager. Creates necessary configuration files and project structure.

LANGUAGE: bash
CODE:
npx trigger.dev@latest init

----------------------------------------

TITLE: Installing Protobuf Compiler on Mac
DESCRIPTION: Command to install the protobuf compiler on macOS using Homebrew.

LANGUAGE: sh
CODE:
brew install protobuf

----------------------------------------

TITLE: React Streaming Component Implementation
DESCRIPTION: React component example using useRealtimeRunWithStreams hook to subscribe to and display streaming data.

LANGUAGE: tsx
CODE:
import { useRealtimeRunWithStreams } from "@trigger.dev/react-hooks";
import type { myTask, STREAMS } from "./trigger/my-task";

function MyComponent({ runId, publicAccessToken }: { runId: string; publicAccessToken: string }) {
  const { run, streams } = useRealtimeRunWithStreams<typeof myTask, STREAMS>(runId, {
    accessToken: publicAccessToken,
  });

  if (!run) {
    return <div>Loading...</div>;
  }

  return (
    <div>
      <h1>Run ID: {run.id}</h1>
      <h2>Streams:</h2>
      <ul>
        {Object.entries(streams).map(([key, value]) => (
          <li key={key}>
            <strong>{key}</strong>: {JSON.stringify(value)}
          </li>
        ))}
      </ul>
    </div>
  );
}

----------------------------------------

TITLE: Batch Task Triggering
DESCRIPTION: Example of triggering multiple runs of a task in batch with payload options

LANGUAGE: typescript
CODE:
import { tasks } from "@trigger.dev/sdk/v3";
import type { emailSequence } from "~/trigger/emails";

export async function POST(request: Request) {
  const data = await request.json();
  const batchHandle = await tasks.batchTrigger<typeof emailSequence>("email-sequence",
    data.users.map((u) => ({ 
      payload: { to: u.email, name: u.name },
      options: { delay: "1h" }
    }))
  );
  return Response.json(batchHandle);
}

----------------------------------------

TITLE: Installing Trigger.dev using Yarn
DESCRIPTION: Initializes a new Trigger.dev project using Yarn package manager. Creates necessary configuration files and project structure.

LANGUAGE: bash
CODE:
yarn dlx trigger.dev@latest init

----------------------------------------

TITLE: Updating Git Submodules
DESCRIPTION: Commands to synchronize and update Git submodules recursively.

LANGUAGE: shell script
CODE:
git submodule sync --recursive
git submodule update --init --recursive

----------------------------------------

TITLE: Configuring Staging Deployment Workflow in GitHub Actions
DESCRIPTION: GitHub Actions workflow configuration for deploying Trigger.dev tasks to staging environment. Triggered manually through workflow_dispatch and deploys to staging environment.

LANGUAGE: yaml
CODE:
name: Deploy to Trigger.dev (staging)

on:
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Use Node.js 20.x
        uses: actions/setup-node@v4
        with:
          node-version: "20.x"

      - name: Install dependencies
        run: npm install

      - name: 🚀 Deploy Trigger.dev
        env:
          TRIGGER_ACCESS_TOKEN: ${{ secrets.TRIGGER_ACCESS_TOKEN }}
        run: |
          npx trigger.dev@latest deploy --env staging

----------------------------------------

TITLE: Subscribing to Batch Runs with Trigger.dev SDK
DESCRIPTION: Example showing how to subscribe to all changes for runs in a batch using an async iterator. The code continuously yields run objects for each update in the specified batch until manually broken.

LANGUAGE: typescript
CODE:
import { runs } from "@trigger.dev/sdk/v3";

for await (const run of runs.subscribeToBatch("batch_1234")) {
  console.log(run);
}

----------------------------------------

TITLE: Testing Payload for PDF Generation Task in JSON
DESCRIPTION: This JSON payload can be used to test the PDF generation task in the Trigger.dev dashboard. It provides a simple text input for the PDF content.

LANGUAGE: json
CODE:
{
  "text": "Hello, world!"
}

----------------------------------------

TITLE: Schedule Management Operations
DESCRIPTION: Collection of SDK operations for managing schedules including retrieval, listing, updating, activation, and deletion.

LANGUAGE: typescript
CODE:
const retrievedSchedule = await schedules.retrieve(scheduleId);

const allSchedules = await schedules.list();

const updatedSchedule = await schedules.update(scheduleId, {
  task: firstScheduledTask.id,
  cron: "0 0 1 * *",
  externalId: "ext_1234444",
  deduplicationKey: "my-deduplication-key",
});

const deactivatedSchedule = await schedules.deactivate(scheduleId);

const activatedSchedule = await schedules.activate(scheduleId);

const deletedSchedule = await schedules.del(scheduleId);

const timezones = await schedules.timezones();

----------------------------------------

TITLE: Marking Next.js Routes as Dynamic for Trigger.dev SDK Compatibility
DESCRIPTION: This code snippet demonstrates how to mark a Next.js route as dynamic to prevent build-time errors when using the Trigger.dev SDK. By adding this line to a route file, you force Next.js to render the page dynamically, allowing access to runtime environment variables.

LANGUAGE: typescript
CODE:
export const dynamic = "force-dynamic";

----------------------------------------

TITLE: RunEngine System Architecture Diagram
DESCRIPTION: Mermaid diagram showing the relationships between different systems in the RunEngine, including core dependencies and shared resources.

LANGUAGE: mermaid
CODE:
graph TD
    RE[RunEngine]
    DS[DequeueSystem]
    RAS[RunAttemptSystem]
    ESS[ExecutionSnapshotSystem]
    WS[WaitpointSystem]
    BS[BatchSystem]
    ES[EnqueueSystem]
    CS[CheckpointSystem]
    DRS[DelayedRunSystem]
    TS[TtlSystem]
    WFS[WaitingForWorkerSystem]

    %% Core Dependencies
    RE --> DS
    RE --> RAS
    RE --> ESS
    RE --> WS
    RE --> BS
    RE --> ES
    RE --> CS
    RE --> DRS
    RE --> TS
    RE --> WFS

    %% System Dependencies
    DS --> ESS
    DS --> RAS

    RAS --> ESS
    RAS --> WS
    RAS --> BS

    WS --> ESS
    WS --> ES

    ES --> ESS

    CS --> ESS
    CS --> ES

    DRS --> ES

    WFS --> ES

    TS --> WS

    %% Shared Resources
    subgraph Resources
        PRI[(Prisma)]
        LOG[Logger]
        TRC[Tracer]
        RQ[RunQueue]
        RL[RunLocker]
        EB[EventBus]
        WRK[Worker]
        RCQ[ReleaseConcurrencyQueue]
    end

    %% Resource Dependencies
    RE -.-> Resources
    DS & RAS & ESS & WS & BS & ES & CS & DRS & TS & WFS -.-> Resources

----------------------------------------

TITLE: Replaying a Run Using the trigger.dev SDK in TypeScript
DESCRIPTION: This snippet demonstrates how to replay a run using the trigger.dev SDK. It uses the 'runs.replay()' method, passing in the run ID to initiate a replay.

LANGUAGE: typescript
CODE:
const replayedRun = await runs.replay(run.id);

----------------------------------------

TITLE: Advanced Schema Task with Input/Output Types
DESCRIPTION: Demonstrates schema task with different input/output types using Zod's type coercion and default values.

LANGUAGE: typescript
CODE:
import { schemaTask } from "@trigger.dev/sdk/v3";
import { z } from "zod";

const myTask = schemaTask({
  id: "my-task",
  schema: z.object({
    name: z.string().default("John"),
    age: z.number(),
    dob: z.coerce.date(),
  }),
  run: async (payload) => {
    console.log(payload.name, payload.age);
  },
});

----------------------------------------

TITLE: Basic Setup Commands for Trigger.dev
DESCRIPTION: Commands to clone repository and start Trigger.dev services

LANGUAGE: bash
CODE:
git clone https://github.com/triggerdotdev/docker
cd docker
./start.sh # hint: you can append -d to run in detached mode

----------------------------------------

TITLE: Running the Documentation Server
DESCRIPTION: Command to start the development server for the documentation site using PNPM workspace filter

LANGUAGE: shell
CODE:
pnpm run dev --filter docs

----------------------------------------

TITLE: Accessing Metadata in Task Runs
DESCRIPTION: Demonstrates how to access metadata within a task run using metadata.get() and metadata.current() methods.

LANGUAGE: typescript
CODE:
import { task, metadata } from "@trigger.dev/sdk/v3";

export const myTask = task({
  id: "my-task",
  run: async (payload: { message: string }) => {
    // Get the whole metadata object
    const currentMetadata = metadata.current();
    console.log(currentMetadata);

    // Get a specific key
    const user = metadata.get("user");
    console.log(user.name); // "Eric"
  },
});

----------------------------------------

TITLE: Creating Public Access Token for Run Subscription
DESCRIPTION: Demonstrates how to generate a public access token with specific run read permissions for client-side authentication.

LANGUAGE: typescript
CODE:
import { auth } from "@trigger.dev/sdk/v3";

// Somewhere in your backend code
const publicToken = await auth.createPublicToken({
  scopes: {
    read: {
      runs: ["run_1234"],
    },
  },
});

----------------------------------------

TITLE: Sample JSON Payload for Testing OpenAI Task
DESCRIPTION: This JSON snippet provides a sample payload for testing the OpenAI task in the Trigger.dev dashboard. It includes a prompt to be sent to the OpenAI API.

LANGUAGE: json
CODE:
{
  "prompt": "What is the meaning of life?"
}

----------------------------------------

TITLE: Adding onSuccess Function to Tasks in TypeScript
DESCRIPTION: Shows how to implement an onSuccess function for a task, which is called when a task run succeeds. It can be used for notifications, logging, or syncing state after successful execution.

LANGUAGE: typescript
CODE:
export const taskWithOnSuccess = task({
  id: "task-with-on-success",
  onSuccess: async (payload, output, { ctx }) => {
    //...
  },
  run: async (payload: any, { ctx }) => {
    //...
  },
});

----------------------------------------

TITLE: Package.json Scripts for Remix Deployment
DESCRIPTION: NPM scripts configuration for building and deploying Remix application to Vercel

LANGUAGE: json
CODE:
{
    "scripts": {
        "build": "remix vite:build",
        "dev": "remix vite:dev",
        "lint": "eslint --ignore-path .gitignore --cache --cache-location ./node_modules/.cache/eslint .",
        "start": "remix-serve ./build/server/index.js",
        "typecheck": "tsc",
        "vercel-build": "remix vite:build && cp -r ./public ./build/client"
    }
}

----------------------------------------

TITLE: Local Development URL
DESCRIPTION: Local development server URL where the documentation can be accessed

LANGUAGE: plaintext
CODE:
http://localhost:3050

----------------------------------------

TITLE: Using Additional Packages Build Extension
DESCRIPTION: Configure the additionalPackages build extension to include extra packages in the Trigger.dev build.

LANGUAGE: typescript
CODE:
import { defineConfig } from "@trigger.dev/sdk/v3";
import { additionalPackages } from "@trigger.dev/build/extensions/core";

export default defineConfig({
  project: "<project ref>",
  build: {
    extensions: [additionalPackages({ packages: ["wrangler"] })],
  },
});

----------------------------------------

TITLE: Triggering a Task from Backend Code in TypeScript
DESCRIPTION: Shows how to trigger a previously defined task from other parts of the codebase. It imports the task, triggers it with a payload, and logs the resulting handle ID.

LANGUAGE: typescript
CODE:
import { helloWorld } from "./trigger/hello-world";

async function triggerHelloWorld() {
  const handle = await helloWorld.trigger({ message: "Hello world!" });
  console.log("Task is running with handle", handle.id);
}

----------------------------------------

TITLE: Running Trigger.dev Development Server
DESCRIPTION: CLI commands for starting the Trigger.dev development server with different package managers.

LANGUAGE: bash
CODE:
npx trigger.dev@latest dev

LANGUAGE: bash
CODE:
pnpm dlx trigger.dev@latest dev

LANGUAGE: bash
CODE:
yarn dlx trigger.dev@latest dev

----------------------------------------

TITLE: Basic Python Command Execution in Trigger.dev
DESCRIPTION: Example of running basic Python commands using the low-level run function.

LANGUAGE: typescript
CODE:
import { task } from "@trigger.dev/sdk/v3";
import { python } from "@trigger.dev/python";

export const pythonVersionTask = task({
  id: "python-version-task",
  run: async () => {
    const result = await python.run(["--version"]);
    return result.stdout; // Expected output: Python 3.12.8
  },
});

----------------------------------------

TITLE: Dynamic Multi-tenant Schedule Implementation
DESCRIPTION: Implementation of user-specific schedules with reminder task definition and schedule creation.

LANGUAGE: typescript
CODE:
export const reminderTask = schedules.task({
  id: "todo-reminder",
  run: async (payload) => {
    if (!payload.externalId) {
      throw new Error("externalId is required");
    }
    const user = await db.getUser(payload.externalId);
    await sendReminderEmail(user);
  },
});

LANGUAGE: typescript
CODE:
export async function POST(request: Request) {
  const data = await request.json();
  const createdSchedule = await schedules.create({
    task: reminderTask.id,
    cron: "0 8 * * *",
    timezone: data.timezone,
    externalId: data.userId,
    deduplicationKey: `${data.userId}-reminder`,
  });
  return Response.json(createdSchedule);
}

----------------------------------------

TITLE: Type-Safe Run Subscription in Trigger.dev Realtime API
DESCRIPTION: Demonstrates how to use type inference with the subscribeToRun function to get type-safe access to the run's payload and output. This example shows how to infer types from a specific task and use them in the subscription.

LANGUAGE: typescript
CODE:
import { runs, tasks } from "@trigger.dev/sdk/v3";
import type { myTask } from "./trigger/my-task";

// Somewhere in your backend code
async function myBackend() {
  const handle = await tasks.trigger("my-task", { some: "data" });

  for await (const run of runs.subscribeToRun<typeof myTask>(handle.id)) {
    // This will log the run every time it changes
    console.log(run.payload.some);

    if (run.output) {
      // This will log the output if it exists
      console.log(run.output.some);
    }
  }
}

----------------------------------------

TITLE: Creating Test Task for Sentry Error Tracking
DESCRIPTION: Example task implementation that deliberately throws an error to test Sentry integration. Includes custom error message and additional context for error tracking.

LANGUAGE: typescript
CODE:
import { task } from "@trigger.dev/sdk/v3";

export const sentryErrorTest = task({
  id: "sentry-error-test",
  retry: {
    // Only retry once
    maxAttempts: 1,
  },
  run: async () => {
    const error = new Error("This is a custom error that Sentry will capture");
    error.cause = { additionalContext: "This is additional context" };
    throw error;
  },
});

----------------------------------------

TITLE: Rendering Navigation Cards using JSX Components
DESCRIPTION: JSX code that creates a responsive grid of navigation cards using CardGroup and Card components. Each card links to different sections of the Trigger.dev documentation, including tasks overview, writing tasks, CLI deployment, and GitHub actions deployment.

LANGUAGE: jsx
CODE:
<CardGroup cols={2}>
  <Card title="Tasks overview" icon="diagram-subtask" href="/tasks/overview">
    Learn what tasks are and their options
  </Card>
   <Card title="Writing tasks" icon="pen-nib" href="/writing-tasks-introduction">
    Learn how to write your own tasks
  </Card>
  <Card title="Deploy using the CLI" icon="terminal" href="/cli-deploy">
    Learn how to deploy your task manually using the CLI
  </Card>
   <Card title="Deploy using GitHub actions" icon="github" href="/github-actions">
    Learn how to deploy your task using GitHub actions
  </Card>
</CardGroup>

----------------------------------------

TITLE: Database Utility Functions in TypeScript
DESCRIPTION: Implements database utility functions for upserting embeddings into a Postgres database using the pg client.

LANGUAGE: typescript
CODE:
import pg from "pg";

export async function upsertEmbedding(embedding: number[], id: number) {
  const client = new pg.Client({
    connectionString: process.env.DATABASE_URL,
  });
  await client.connect();

  try {
    const query = `
      INSERT INTO post_embeddings (id, embedding)
      VALUES ($2, $1)
      ON CONFLICT (id)
      DO UPDATE SET embedding = $1
    `;
    const values = [JSON.stringify(embedding), id];

    const result = await client.query(query, values);
    console.log(`Updated record in database. Rows affected: ${result.rowCount}`);

    return result.rowCount;
  } catch (error) {
    console.error("Error updating record in database:", error);
    throw error;
  } finally {
    await client.end();
  }
}

----------------------------------------

TITLE: Running the main webapp for trigger.dev
DESCRIPTION: Command to start the main webapp for trigger.dev using pnpm.

LANGUAGE: bash
CODE:
pnpm run dev --filter webapp

----------------------------------------

TITLE: Task Triggering with Schema Validation
DESCRIPTION: Shows how to trigger tasks with schema validation and demonstrates validation behavior.

LANGUAGE: typescript
CODE:
import { tasks } from "@trigger.dev/sdk/v3";
import { myTask } from "./trigger/myTasks";

// This will call the schema parser function and validate the payload
await myTask.trigger({ name: "Alice", age: "oops" }); // this will throw an error

// This will NOT call the schema parser function
await tasks.trigger<typeof myTask>("my-task", { name: "Alice", age: "oops" }); // this will not throw an error

----------------------------------------

TITLE: Accessing Trigger.dev API Endpoint
DESCRIPTION: URL to visit in the browser to trigger the Trigger.dev task. The port number should match the one used by the Remix app.

LANGUAGE: bash
CODE:
http://localhost:3000/api/trigger

----------------------------------------

TITLE: Specifying Python Dependencies for Web Crawler
DESCRIPTION: This requirements.txt file lists the necessary Python packages for the web crawler project, including Crawl4AI, Playwright, and a specific version of urllib3.

LANGUAGE: txt
CODE:
crawl4ai
playwright
urllib3<2.0.0

----------------------------------------

TITLE: Starting Next.js Development Server
DESCRIPTION: Commands to start the Next.js development server using different package managers. The server can be started using npm, yarn, pnpm, or bun.

LANGUAGE: bash
CODE:
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev

----------------------------------------

TITLE: Retrieving Timezones OpenAPI Endpoint
DESCRIPTION: OpenAPI specification for the GET endpoint that returns timezone information. Endpoint path is /api/v1/timezones.

LANGUAGE: openapi
CODE:
GET /api/v1/timezones

----------------------------------------

TITLE: Subscribing to Runs with Specific Tags in Trigger.dev Realtime API
DESCRIPTION: Shows how to use the runs.subscribeToRunsWithTag function to subscribe to all runs that include a specific tag. This example subscribes to runs with the tag 'user:1234' and logs each run update.

LANGUAGE: typescript
CODE:
import { runs } from "@trigger.dev/sdk/v3";

// Somewhere in your backend code
for await (const run of runs.subscribeToRunsWithTag("user:1234")) {
  // This will log the run every time it changes, for all runs with the tag "user:1234"
  console.log(run);
}

----------------------------------------

TITLE: Deploying Trigger.dev Project
DESCRIPTION: Command line instructions for deploying the Trigger.dev project with Sentry integration using different package managers.

LANGUAGE: bash
CODE:
npx trigger.dev@latest deploy

LANGUAGE: bash
CODE:
pnpm dlx trigger.dev@latest deploy

LANGUAGE: bash
CODE:
yarn dlx trigger.dev@latest deploy

----------------------------------------

TITLE: Starting Trigger.dev Development Server
DESCRIPTION: Commands to run the Trigger.dev development server using npm, pnpm, or yarn. This is part of the initial setup process for Trigger.dev integration.

LANGUAGE: bash
CODE:
npx trigger.dev@latest dev

LANGUAGE: bash
CODE:
pnpm dlx trigger.dev@latest dev

LANGUAGE: bash
CODE:
yarn dlx trigger.dev@latest dev

----------------------------------------

TITLE: Postgres Test Container Example
DESCRIPTION: Example of using PostgreSQL test container with Prisma client for database testing.

LANGUAGE: typescript
CODE:
import { postgresTest } from "@internal/testcontainers";

describe("postgresTest", () => {
  postgresTest("should use postgres", async ({ prisma }) => {
    // prisma is an instance of PrismaClient
  });
});

----------------------------------------

TITLE: Implementing Supabase Edge Function Handler
DESCRIPTION: Creates a Deno server that handles incoming webhook requests from Supabase, extracting video information and triggering the video processing task through Trigger.dev.

LANGUAGE: typescript
CODE:
import "jsr:@supabase/functions-js/edge-runtime.d.ts";
import { tasks } from "npm:@trigger.dev/sdk@latest/v3";
import type { videoProcessAndUpdate } from "../../../src/trigger/videoProcessAndUpdate.ts";

Deno.serve(async (req) => {
  const payload = await req.json();

  const videoUrl = payload.record.video_url;
  const id = payload.record.id;

  await tasks.trigger<typeof videoProcessAndUpdate>("video-process-and-update", { videoUrl, id });
  console.log(payload ?? "No name provided");

  return new Response("ok");
});

----------------------------------------

TITLE: CSV Processor Component Implementation
DESCRIPTION: React component that handles file uploads and displays progress using the realtime validator hook.

LANGUAGE: typescript
CODE:
Reference file: src/components/CSVProcessor.tsx
// Implementation details found in GitHub repository

----------------------------------------

TITLE: Running Trigger.dev Dev Server with Package Managers
DESCRIPTION: Commands to start the Trigger.dev development server using different package managers (npm, pnpm, yarn). The server watches the /trigger directory for changes, handles task registration, and manages communication with the Trigger.dev platform. It can also update @trigger.dev/* packages automatically.

LANGUAGE: bash
CODE:
npx trigger.dev@latest dev

LANGUAGE: bash
CODE:
pnpm dlx trigger.dev@latest dev

LANGUAGE: bash
CODE:
yarn dlx trigger.dev@latest dev

----------------------------------------

TITLE: Combined Container Test Example
DESCRIPTION: Example of using both Redis and PostgreSQL containers in a single test setup.

LANGUAGE: typescript
CODE:
import { containerTest } from "@internal/testcontainers";

describe("containerTest", () => {
  containerTest("should use container", async ({ prisma, redisOptions }) => {
    // container has both prisma and redis
  });
});

----------------------------------------

TITLE: Defining Trigger.dev Task for URL to Markdown Conversion
DESCRIPTION: This TypeScript code defines a Trigger.dev task that runs a Python script to convert a given URL to markdown. It handles proxy configuration and uses the python.runScript method to execute the Python script.

LANGUAGE: typescript
CODE:
import { logger, schemaTask, task } from "@trigger.dev/sdk/v3";
import { python } from "@trigger.dev/python";
import { z } from "zod";

export const convertUrlToMarkdown = schemaTask({
  id: "convert-url-to-markdown",
  schema: z.object({
    url: z.string().url(),
  }),
  run: async (payload) => {
    // Pass through any proxy environment variables
    const env = {
      PROXY_URL: process.env.PROXY_URL,
      PROXY_USERNAME: process.env.PROXY_USERNAME,
      PROXY_PASSWORD: process.env.PROXY_PASSWORD,
    };

    const result = await python.runScript("./src/python/crawl-url.py", [payload.url], { env });

    logger.debug("convert-url-to-markdown", {
      url: payload.url,
      result,
    });

    return result.stdout;
  },
});

----------------------------------------

TITLE: Using SWR Hook for Run Data Fetching
DESCRIPTION: Implementation of the useRun hook for fetching and displaying run data with TypeScript support.

LANGUAGE: tsx
CODE:
"use client";

import { useRun } from "@trigger.dev/react-hooks";
import type { myTask } from "@/trigger/myTask";

export function MyComponent({ runId }: { runId: string }) {
  const { run, error, isLoading } = useRun<typeof myTask>(runId, {
    refreshInterval: 0, // Disable polling
  });

  if (isLoading) return <div>Loading...</div>;
  if (error) return <div>Error: {error.message}</div>;

  return <div>Run: {run.id}</div>;
}

----------------------------------------

TITLE: Triggering Task with Auto-generated Token
DESCRIPTION: Demonstrates how to trigger a task and receive an auto-generated public access token for frontend use.

LANGUAGE: typescript
CODE:
import { tasks } from "@trigger.dev/sdk/v3";

const handle = await tasks.trigger("my-task", { some: "data" });

console.log(handle.publicAccessToken);

----------------------------------------

TITLE: Building the v3 CLI for trigger.dev
DESCRIPTION: Command to build the v3 CLI using pnpm. This needs to be done every time code changes are made to the CLI.

LANGUAGE: bash
CODE:
pnpm run build --filter trigger.dev

----------------------------------------

TITLE: Promoting Trigger.dev Version with Yarn
DESCRIPTION: Command to promote a specific version of a Trigger.dev deployment using Yarn package manager. The version parameter specifies the previously deployed version to promote.

LANGUAGE: bash
CODE:
yarn dlx trigger.dev@latest promote [version]

----------------------------------------

TITLE: Creating a Worker Group in trigger.dev using cURL
DESCRIPTION: This snippet demonstrates how to create a worker group using a cURL command to the trigger.dev API. It requires setting the API URL, worker group name, and an admin personal access token.

LANGUAGE: sh
CODE:
api_url=http://localhost:3030
wg_name=my-worker

# edit this
admin_pat=tr_pat_...

curl -sS \
    -X POST \
    "$api_url/admin/api/v1/workers" \
    -H "Authorization: Bearer $admin_pat" \
    -H "Content-Type: application/json" \
    -d "{\"name\": \"$wg_name\"}"

----------------------------------------

TITLE: Test Payload for PDF Conversion Task
DESCRIPTION: Example JSON payload for testing the PDF to image conversion task in the dashboard.

LANGUAGE: json
CODE:
{
  "pdfUrl": "https://pdfobject.com/pdf/sample.pdf",
  "documentId": "unique-document-id"
}

----------------------------------------

TITLE: Authentication Context Provider Setup
DESCRIPTION: Implementation of TriggerAuthContext provider for centralized authentication management.

LANGUAGE: tsx
CODE:
import { TriggerAuthContext } from "@trigger.dev/react-hooks";

export function SetupTrigger({ publicAccessToken }: { publicAccessToken: string }) {
  return (
    <TriggerAuthContext.Provider
      value={{
        accessToken: publicAccessToken,
        baseURL: "https://your-trigger-dev-instance.com",
      }}
    >
      <MyComponent />
    </TriggerAuthContext.Provider>
  );
}

----------------------------------------

TITLE: Deploy Command Structure
DESCRIPTION: Shows the basic command structure with optional path argument

LANGUAGE: bash
CODE:
npx trigger.dev@latest deploy [path]

----------------------------------------

TITLE: Configuring Environment Variables for trigger.dev Supervisor
DESCRIPTION: This snippet shows how to create and edit the .env file for configuring the trigger.dev Supervisor. It involves copying the example file and setting the TRIGGER_WORKER_TOKEN.

LANGUAGE: sh
CODE:
cp .env.example .env

# Then edit your .env and set this to the token.plaintext value
TRIGGER_WORKER_TOKEN=tr_wgt_...

----------------------------------------

TITLE: Updating User Subscription in Supabase Database using Trigger.dev
DESCRIPTION: Task implementation for updating user subscriptions in a Supabase database table. Handles both insert and update operations based on existing user records. Includes type checking for plan types and comprehensive error handling. Uses service role authentication.

LANGUAGE: typescript
CODE:
import { createClient } from "@supabase/supabase-js";
import { AbortTaskRunError, task } from "@trigger.dev/sdk/v3";
import { Database } from "database.types";

type PlanType = "hobby" | "pro" | "enterprise";

const supabase = createClient<Database>(
  process.env.SUPABASE_PROJECT_URL as string,
  process.env.SUPABASE_SERVICE_ROLE_KEY as string
);

export const supabaseUpdateUserSubscription = task({
  id: "update-user-subscription",
  run: async (payload: { userId: string; newPlan: PlanType }) => {
    const { userId, newPlan } = payload;

    if (!["hobby", "pro", "enterprise"].includes(newPlan)) {
      throw new AbortTaskRunError(
        `Invalid plan type: ${newPlan}. Allowed types are 'hobby', 'pro', or 'enterprise'.`
      );
    }

    const { data: existingSubscriptions } = await supabase
      .from("user_subscriptions")
      .select("user_id")
      .eq("user_id", userId);

    if (!existingSubscriptions || existingSubscriptions.length === 0) {
      const { error: insertError } = await supabase.from("user_subscriptions").insert({
        user_id: userId,
        plan: newPlan,
        updated_at: new Date().toISOString(),
      });

      if (insertError) {
        throw new Error(`Failed to insert user subscription: ${insertError.message}`);
      }
    } else {
      const { error: updateError } = await supabase
        .from("user_subscriptions")
        .update({ plan: newPlan, updated_at: new Date().toISOString() })
        .eq("user_id", userId);

      if (updateError) {
        throw new Error(`Failed to update user subscription: ${updateError.message}`);
      }
    }

    return {
      userId,
      newPlan,
    };
  },
});

----------------------------------------

TITLE: Installing Trigger.dev React Hooks Package
DESCRIPTION: Commands for installing the @trigger.dev/react-hooks package using different package managers.

LANGUAGE: bash
CODE:
npm add @trigger.dev/react-hooks

LANGUAGE: bash
CODE:
pnpm add @trigger.dev/react-hooks

LANGUAGE: bash
CODE:
yarn install @trigger.dev/react-hooks

----------------------------------------

TITLE: Performing Dry Run Deployment in Trigger.dev
DESCRIPTION: Execute a dry run of the deployment process to inspect the built tasks and dependencies without actually deploying.

LANGUAGE: bash
CODE:
npx trigger.dev deploy --dry-run

----------------------------------------

TITLE: Running Trigger.dev Development Environment
DESCRIPTION: Command to start the Trigger.dev development environment with required services

LANGUAGE: bash
CODE:
pnpm run dev --filter webapp --filter coordinator --filter docker-provider

----------------------------------------

TITLE: Using Metadata in Task Lifecycle Hooks
DESCRIPTION: Shows how to use metadata operations within task lifecycle hooks and configuration.

LANGUAGE: typescript
CODE:
import { task, metadata } from "@trigger.dev/sdk/v3";

export const myTask = task({
  id: "my-task",
  run: async (payload: { message: string }) => {
    // Your run function work here
  },
  onStart: async () => {
    metadata.set("progress", 0.5);
  },
  onSuccess: async () => {
    metadata.set("progress", 1.0);
  },
});

LANGUAGE: typescript
CODE:
import { defineConfig, metadata } from "@trigger.dev/sdk/v3";

export default defineConfig({
  project: "proj_1234",
  onStart: async () => {
    metadata.set("progress", 0.5);
  },
});

----------------------------------------

TITLE: Creating Additional Worker Groups with Project Default in trigger.dev
DESCRIPTION: This snippet demonstrates how to create additional worker groups and set them as the default for a specific project using a cURL command to the trigger.dev API. It requires setting the API URL, worker group name, admin personal access token, and project ID.

LANGUAGE: sh
CODE:
api_url=http://localhost:3030
wg_name=my-worker

# edit these
admin_pat=tr_pat_...
project_id=clsw6q8wz...

curl -sS \
    -X POST \
    "$api_url/admin/api/v1/workers" \
    -H "Authorization: Bearer $admin_pat" \
    -H "Content-Type: application/json" \
    -d "{
        \"name\": \"$wg_name\",
        \"makeDefaultForProjectId\": \"$project_id\"
    }"

----------------------------------------

TITLE: Configuring Trigger.dev Build Settings for Puppeteer
DESCRIPTION: This snippet shows how to configure the trigger.config.ts file to include Puppeteer as a build extension. It defines the project reference and adds the necessary build settings for using Puppeteer in the Trigger.dev environment.

LANGUAGE: typescript
CODE:
import { defineConfig } from "@trigger.dev/sdk/v3";
import { puppeteer } from "@trigger.dev/build/extensions/puppeteer";

export default defineConfig({
  project: "<project ref>",
  // Your other config settings...
  build: {
    // This is required to use the Puppeteer library
    extensions: [puppeteer()],
  },
});

----------------------------------------

TITLE: Using Google Credentials in trigger.dev Tasks
DESCRIPTION: Code example showing how to decode and use Google credentials from a base64-encoded environment variable.

LANGUAGE: typescript
CODE:
import { google } from "googleapis";

const credentials = JSON.parse(
  Buffer.from(process.env.GOOGLE_CREDENTIALS_BASE64, "base64").toString("utf8")
);

const auth = new google.auth.GoogleAuth({
  credentials,
  scopes: ["https://www.googleapis.com/auth/cloud-platform"],
});

const client = await auth.getClient();

----------------------------------------

TITLE: Measuring Code Block Cost and Duration
DESCRIPTION: Shows how to measure the cost and duration of a specific block of code using usage.measure() wrapper function in Trigger.dev tasks.

LANGUAGE: typescript
CODE:
const { result, compute } = await usage.measure(async () => {
  //...Do something for 1 second
  return {
    foo: "bar",
  };
});

logger.info("Result", { result, compute });
/* result = {
    foo: "bar"
  }
  compute = {
    costInCents: 0.01700,
    durationMs: 1000,
  }
*/

----------------------------------------

TITLE: Building and Running Trigger.dev Webapp Docker Container
DESCRIPTION: Commands to build a Docker image for the webapp and start an interactive shell session within the container

LANGUAGE: sh
CODE:
pnpm run docker:build:webapp
docker run -it triggerdotdev-webapp sh

----------------------------------------

TITLE: Configuring FFmpeg Build Extension in Trigger.dev
DESCRIPTION: Configuration setup to enable FFmpeg extension in Trigger.dev project. Requires adding @trigger.dev/build to devDependencies.

LANGUAGE: typescript
CODE:
import { ffmpeg } from "@trigger.dev/build/extensions/core";
import { defineConfig } from "@trigger.dev/sdk/v3";

export default defineConfig({
  project: "<project ref>",
  // Your other config settings...
  build: {
    extensions: [ffmpeg()],
  },
});

----------------------------------------

TITLE: Vercel Environment Variable Sync Configuration
DESCRIPTION: Demonstrates how to use syncVercelEnvVars extension to sync environment variables from a Vercel project. Requires Vercel access token and project ID.

LANGUAGE: typescript
CODE:
import { defineConfig } from "@trigger.dev/sdk/v3";
import { syncVercelEnvVars } from "@trigger.dev/build/extensions/core";

export default defineConfig({
  project: "<project ref>",
  // Your other config settings...
  build: {
    // This will automatically use the VERCEL_ACCESS_TOKEN and VERCEL_PROJECT_ID environment variables
    extensions: [syncVercelEnvVars()],
  },
});

LANGUAGE: typescript
CODE:
import { defineConfig } from "@trigger.dev/sdk/v3";
import { syncVercelEnvVars } from "@trigger.dev/build/extensions/core";

export default defineConfig({
  project: "<project ref>",
  // Your other config settings...
  build: {
    extensions: [
      syncVercelEnvVars({
        projectId: "your-vercel-project-id",
        vercelAccessToken: "your-vercel-access-token",
        vercelTeamId: "your-vercel-team-id", // optional
      }),
    ],
  },
});

----------------------------------------

TITLE: Setting Global Version for Trigger.dev Tasks
DESCRIPTION: Use the TRIGGER_VERSION environment variable to set a global version for all tasks to run against.

LANGUAGE: bash
CODE:
TRIGGER_VERSION=20250228.1

----------------------------------------

TITLE: Configuring Python Extension in Trigger.dev
DESCRIPTION: Basic configuration setup for the Python extension in trigger.config.ts, including options for requirements file, custom Python binary path, and script patterns.

LANGUAGE: typescript
CODE:
import { defineConfig } from "@trigger.dev/sdk/v3";
import { pythonExtension } from "@trigger.dev/python/extension";

export default defineConfig({
  project: "<project ref>",
  build: {
    extensions: [
      pythonExtension({
        requirementsFile: "./requirements.txt", // Optional: Path to your requirements file
        devPythonBinaryPath: ".venv/bin/python", // Optional: Custom Python binary path
        scripts: ["src/python/**/*.py"], // Glob pattern for Python scripts
      }),
    ],
  },
});

----------------------------------------

TITLE: Retrieving Multiple Runs Cost and Duration
DESCRIPTION: Demonstrates how to retrieve and aggregate cost information for multiple runs using runs.list() with filtering by tags.

LANGUAGE: typescript
CODE:
import { runs } from "@trigger.dev/sdk/v3";

let totalCost = 0;
for await (const run of runs.list({ tag: "user_123456" })) {
  totalCost += run.costInCents + run.baseCostInCents;
  console.log(run.costInCents, run.baseCostInCents, run.durationMs);
}

console.log("Total cost", totalCost);

----------------------------------------

TITLE: Installing Email Dependencies
DESCRIPTION: Command to install dependencies for the emails module using pnpm package manager with filter flag.

LANGUAGE: sh
CODE:
pnpm install --filter emails

----------------------------------------

TITLE: Task Test Payload Example
DESCRIPTION: JSON payload structure for testing the user creation task, demonstrating the required fields for creating a new user record.

LANGUAGE: json
CODE:
{
  "name": "<a-name>", // e.g. "John Doe"
  "age": "<an-age>", // e.g. 25
  "email": "<an-email>" // e.g. "john@doe.test"
}

----------------------------------------

TITLE: Infisical Integration for Environment Variable Sync
DESCRIPTION: Shows how to sync environment variables from Infisical to Trigger.dev using the syncEnvVars extension and Infisical SDK. Requires Infisical credentials to be set in environment variables.

LANGUAGE: typescript
CODE:
import { defineConfig } from "@trigger.dev/sdk/v3";
import { syncEnvVars } from "@trigger.dev/build/extensions/core";
import { InfisicalSDK } from "@infisical/sdk";

export default defineConfig({
  build: {
    extensions: [
      syncEnvVars(async (ctx) => {
        const client = new InfisicalSDK();

        await client.auth().universalAuth.login({
          clientId: process.env.INFISICAL_CLIENT_ID!,
          clientSecret: process.env.INFISICAL_CLIENT_SECRET!,
        });

        const { secrets } = await client.secrets().listSecrets({
          environment: ctx.environment,
          projectId: process.env.INFISICAL_PROJECT_ID!,
        });

        return secrets.map((secret) => ({
          name: secret.secretKey,
          value: secret.secretValue,
        }));
      }),
    ],
  },
});

----------------------------------------

TITLE: Retrieving Single Run Cost and Duration
DESCRIPTION: Shows how to retrieve cost and duration information for a single run using the runs.retrieve() method from the Trigger.dev SDK.

LANGUAGE: typescript
CODE:
import { runs } from "@trigger.dev/sdk/v3";

const run = await runs.retrieve("run-id");
console.log(run.costInCents, run.baseCostInCents, run.durationMs);
const totalCost = run.costInCents + run.baseCostInCents;

----------------------------------------

TITLE: Testing Local CLI with Job Catalogs
DESCRIPTION: Commands to install dependencies and test the local CLI using job catalogs from the references directory.

LANGUAGE: sh
CODE:
pnpm i
pnpm exec trigger <command>

----------------------------------------

TITLE: Defining a Trigger.dev v2 Job with OpenAI Integration
DESCRIPTION: Example of a v2 Trigger.dev job using the OpenAI integration, demonstrating the use of client.defineJob, eventTrigger, and io.runTask for handling long-running operations.

LANGUAGE: typescript
CODE:
import { client } from "~/trigger";
import { eventTrigger } from "@trigger.dev/sdk";

//1. A Trigger.dev integration for OpenAI
import { OpenAI } from "@trigger.dev/openai";
const openai = new OpenAI({
  id: "openai",
  apiKey: process.env["OPENAI_API_KEY"]!,
});

//2. Use the client to define a "Job"
client.defineJob({
  id: "openai-tasks",
  name: "OpenAI Tasks",
  version: "0.0.1",
  trigger: eventTrigger({
    name: "openai.tasks",
    schema: z.object({
      prompt: z.string(),
    }),
  }),
  //3. integrations are added and come through to `io` in the run fn
  integrations: {
    openai,
  },
  run: async (payload, io, ctx) => {
    //4. You use `io` to get the integration
    //5. Also note that "backgroundCreate" was needed for OpenAI
    //   to do work that lasted longer than your serverless timeout
    const chatCompletion = await io.openai.chat.completions.backgroundCreate(
      //6. You needed to add "cacheKeys" to any "task"
      "background-chat-completion",
      {
        messages: [{ role: "user", content: payload.prompt }],
        model: "gpt-3.5-turbo",
      }
    );

    const result = chatCompletion.choices[0]?.message.content;
    if (!result) {
      //7. throwing an error at the top-level in v2 failed the task immediately
      throw new Error("No result from OpenAI");
    }

    //8. io.runTask needed to be used to prevent work from happening twice
    const dbRow = await io.runTask("store-in-db", async (task) => {
      //9. Custom logic can be put here
      //   Anything returned must be JSON-serializable, so no Date objects etc.
      return saveToDb(result);
    });

    //10. Wait for 5 minutes.
    //    You need a cacheKey and the 2nd param is a number
    await io.wait("wait some time", 60 * 5);

    //11. Anything returned must be JSON-serializable, so no Date objects etc.
    return result;
  },
});

----------------------------------------

TITLE: Basic Environment Variable Sync Configuration in TypeScript
DESCRIPTION: Demonstrates basic usage of syncEnvVars build extension to manually sync environment variables to Trigger.dev. The callback function returns an array of environment variables to be synced.

LANGUAGE: typescript
CODE:
import { defineConfig } from "@trigger.dev/sdk/v3";
import { syncEnvVars } from "@trigger.dev/build/extensions/core";

export default defineConfig({
  build: {
    extensions: [
      syncEnvVars(async (ctx) => {
        return [
          { name: "SECRET_KEY", value: "secret-value" },
          { name: "ANOTHER_SECRET", value: "another-secret-value" },
        ];
      }),
    ],
  },
});

----------------------------------------

TITLE: Deploying Trigger.dev Tasks using CLI
DESCRIPTION: Use the Trigger.dev CLI to deploy tasks to production. This command builds and uploads your tasks to the Trigger.dev cloud or self-hosted instance.

LANGUAGE: bash
CODE:
npx trigger.dev@latest deploy

LANGUAGE: bash
CODE:
pnpm dlx trigger.dev@latest deploy

LANGUAGE: bash
CODE:
yarn dlx trigger.dev@latest deploy

----------------------------------------

TITLE: Running the Trigger.dev CLI E2E Test Suite
DESCRIPTION: Command to run the v3 CLI E2E test suite, with optional environment variables for specifying fixture and package manager.

LANGUAGE: bash
CODE:
pnpm --filter trigger.dev run test:e2e

LANGUAGE: bash
CODE:
MOD=server-only PM=yarn pnpm --filter trigger.dev run test:e2e

----------------------------------------

TITLE: Throwing Out of Memory Error in Trigger.dev Task
DESCRIPTION: This snippet shows how to explicitly throw an Out of Memory error in a Trigger.dev task. This can be useful when using native packages that detect impending memory exhaustion.

LANGUAGE: typescript
CODE:
import {  task } from "@trigger.dev/sdk/v3";
import { OutOfMemoryError } from "@trigger.dev/sdk/v3";

export const yourTask = task({
  id: "your-task",
  machine: "medium-1x",
  run: async (payload: any, { ctx }) => {
    //...

    throw new OutOfMemoryError();
  },
});

----------------------------------------

TITLE: Building the Trigger.dev CLI
DESCRIPTION: Command to build the Trigger.dev CLI before running the E2E test suite.

LANGUAGE: bash
CODE:
pnpm run build --filter trigger.dev

----------------------------------------

TITLE: Triggering Trigger.dev v3 Tasks
DESCRIPTION: Example of triggering v3 Trigger.dev tasks using the unified trigger() method.

LANGUAGE: typescript
CODE:
async function yourBackendFunction() {
  //call `trigger()` on any task
  const handle = await openaiTask.trigger({
    prompt: "Tell me a programming joke",
  });
}

----------------------------------------

TITLE: Rendering Setup Steps for Node.js Trigger.dev Integration
DESCRIPTION: This snippet renders the setup steps for integrating Trigger.dev with a Node.js project. It uses the imported MDX components to display each step of the process.

LANGUAGE: MDX
CODE:
<Steps>
  <CliInitStep />
  <CliDevStep />
  <CliRunTestStep />
  <CliViewRunStep />
</Steps>

----------------------------------------

TITLE: Configuring Machine Resources for Trigger.dev Task
DESCRIPTION: This snippet demonstrates how to set the machine configuration for a Trigger.dev task. It uses the 'large-1x' preset, which allocates more resources than the default.

LANGUAGE: typescript
CODE:
import {  task } from "@trigger.dev/sdk/v3";

export const heavyTask = task({
  id: "heavy-task",
  machine: "large-1x",
  run: async ({ payload, ctx }) => {
    //...
  },
});

----------------------------------------

TITLE: Configuring TypeScript for Fixture
DESCRIPTION: Template for tsconfig.json file to be added to the fixture project for TypeScript configuration.

LANGUAGE: json
CODE:
{
  "include": ["src/**/*.ts", "trigger.config.ts"],
  "compilerOptions": {
    "target": "es2022",
    "lib": ["ES2022", "DOM", "DOM.Iterable"],
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "moduleDetection": "force",
    "verbatimModuleSyntax": false,
    "jsx": "react",
    "strict": true,
    "alwaysStrict": true,
    "strictPropertyInitialization": false,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "noUnusedLocals": false,
    "noUnusedParameters": false,
    "noImplicitAny": true,
    "noImplicitReturns": true,
    "noImplicitThis": true,
    "noFallthroughCasesInSwitch": true,
    "resolveJsonModule": true,
    "removeComments": false,
    "esModuleInterop": true,
    "emitDecoratorMetadata": false,
    "experimentalDecorators": false,
    "downlevelIteration": true,
    "isolatedModules": true,
    "noUncheckedIndexedAccess": true,
    "pretty": true
  }
}

----------------------------------------

TITLE: Trigger.dev Architecture Sequence Diagram
DESCRIPTION: A Mermaid sequence diagram illustrating the high-level architecture of Trigger.dev, showing the interaction between the application, Trigger.dev, and the task worker.

LANGUAGE: mermaid
CODE:
sequenceDiagram
  participant App
  participant Trigger.dev
  participant Task Worker

  App->>Trigger.dev: Trigger task
  Trigger.dev-->>App: Task handle
  Trigger.dev->>Task Worker: Run task
  Task Worker-->>Trigger.dev: Task completed

----------------------------------------

TITLE: Using batchTrigger for Multiple Task Execution in trigger.dev
DESCRIPTION: Demonstrates the correct approach to trigger multiple tasks by using batchTrigger() instead of calling trigger() in a loop. This method helps avoid API rate limits by allowing up to 100 tasks to be triggered in a single API call.

LANGUAGE: javascript
CODE:
batchTrigger()

LANGUAGE: javascript
CODE:
trigger()

----------------------------------------

TITLE: Passing Environment Variables to Python Scripts
DESCRIPTION: Example of passing custom environment variables when executing a Python script

LANGUAGE: typescript
CODE:
import { task } from "@trigger.dev/sdk/v3";
import { python } from "@trigger.dev/python";

export const myScript = task({
  id: "my-python-script",
  run: async () => {
    const result = await python.runScript("./python/my_script.py", ["hello", "world"], {
      env: {
        MY_ENV_VAR: "my value",
      },
    });
    return result.stdout;
  },
});

----------------------------------------

TITLE: Executing Inline Python Code
DESCRIPTION: Example of running inline Python code within a Trigger.dev task using the python.runInline function

LANGUAGE: typescript
CODE:
import { task } from "@trigger.dev/sdk/v3";
import { python } from "@trigger.dev/python";

export const myScript = task({
  id: "my-python-script",
  run: async () => {
    const result = await python.runInline(`print("Hello, world!")`);    return result.stdout;
  },
});

----------------------------------------

TITLE: Implementing Structured Logging in TypeScript with trigger.dev
DESCRIPTION: Demonstrates how to use the logger object for structured logging with different log levels (debug, log, info, warn, error). Each log entry requires a message and a key-value object for structured data.

LANGUAGE: typescript
CODE:
import { task, logger } from "@trigger.dev/sdk/v3";

export const loggingExample = task({
  id: "logging-example",
  run: async (payload: { data: Record<string, string> }) => {
    //the first parameter is the message, the second parameter must be a key-value object (Record<string, unknown>)
    logger.debug("Debug message", payload.data);
    logger.log("Log message", payload.data);
    logger.info("Info message", payload.data);
    logger.warn("You've been warned", payload.data);
    logger.error("Error message", payload.data);
  },
});

----------------------------------------

TITLE: Adding manual checkpoint schema in TypeScript
DESCRIPTION: Adds support for a manual checkpoint schema.

LANGUAGE: typescript
CODE:
- Add manual checkpoint schema ([#1709](https://github.com/triggerdotdev/trigger.dev/pull/1709))

----------------------------------------

TITLE: Specifying External Dependencies in Trigger.dev Config
DESCRIPTION: Configure external dependencies that should not be bundled in the Trigger.dev build process.

LANGUAGE: typescript
CODE:
import { defineConfig } from "@trigger.dev/sdk/v3";

export default defineConfig({
  project: "<project ref>",
  build: {
    external: ["native-module"],
  },
});

----------------------------------------

TITLE: Incorrectly Passing Event Handler to React Button Component in TSX
DESCRIPTION: This snippet shows an incorrect way of passing an event handler to a React Button component. This method may not work as expected because the function might require specific arguments or context that are not available when the event occurs.

LANGUAGE: tsx
CODE:
<Button onClick={myTask}>Trigger my task</Button>

----------------------------------------

TITLE: Log Size Limits Configuration
DESCRIPTION: Detailed configuration of log size limits including attribute counts, span limits, event limits, and packet length restrictions for the Trigger.dev platform.

LANGUAGE: markdown
CODE:
#### Attribute Limits
- Span Attribute Count Limit: 256
- Log Attribute Count Limit: 256
- Span Attribute Value Length Limit: 1028 characters
- Log Attribute Value Length Limit: 1028 characters

#### Event and Link Limits
- Span Event Count Limit: 10
- Link Count Limit: 2
- Attributes per Link Limit: 10
- Attributes per Event Limit: 10

#### I/O Packet Length Limit
128 KB (131,072 bytes)

#### Attribute Clipping Behavior
- Attributes exceeding the value length limit (1028 characters) are discarded.
- If the total number of attributes exceeds 256, additional attributes are not included.

#### Attribute Value Size Calculation
- Strings: Actual length of the string
- Numbers: 8 bytes
- Booleans: 4 bytes
- Arrays: Sum of the sizes of all elements
- Undefined or null: 0 bytes

----------------------------------------

TITLE: Python Requirements File Example
DESCRIPTION: Example requirements.txt file showing how to specify Python package dependencies with version numbers.

LANGUAGE: plaintext
CODE:
pandas==1.3.3
numpy==1.21.2

----------------------------------------

TITLE: Using Sync Environment Variables Build Extension
DESCRIPTION: Configure the syncEnvVars build extension to synchronize environment variables in the Trigger.dev build process.

LANGUAGE: typescript
CODE:
import { defineConfig } from "@trigger.dev/sdk/v3";
import { syncEnvVars } from "@trigger.dev/build/extensions/core";

export default defineConfig({
  project: "<project ref>",
  build: {
    extensions: [
      syncEnvVars(async (params) => {
        return {
          MY_ENV_VAR: "my-value",
        };
      }),
    ],
  },
});

----------------------------------------

TITLE: Configuring Virtual Environment
DESCRIPTION: Configuration for specifying a custom Python binary path for virtual environment support

LANGUAGE: typescript
CODE:
import { defineConfig } from "@trigger.dev/sdk/v3";
import { pythonExtension } from "@trigger.dev/python/extension";

export default defineConfig({
  project: "<project ref>",
  build: {
    extensions: [
      pythonExtension({
        devPythonBinaryPath: ".venv/bin/python",
      }),
    ],
  },
});

----------------------------------------

TITLE: Configuring External Packages in Trigger.dev
DESCRIPTION: Add external packages to the build configuration to handle native code files that can't be bundled, such as .node files.

LANGUAGE: ts
CODE:
import { defineConfig } from "@trigger.dev/sdk/v3";

export default defineConfig({
  project: "<project ref>",
  // Your other config settings...
  build: {
    external: ["your-node-package"],
  },
});

----------------------------------------

TITLE: Python Dependencies Configuration
DESCRIPTION: Requirements file specifying Python package dependencies needed for image processing functionality, including Pillow for image manipulation and other utility packages.

LANGUAGE: plaintext
CODE:
# Core dependencies
Pillow==10.2.0            # Image processing library
python-dotenv==1.0.0      # Environment variable management
requests==2.31.0          # HTTP requests
numpy==1.26.3             # Numerical operations (for advanced processing)

# Optional enhancements
opencv-python==4.8.1.78   # For more advanced image processing

----------------------------------------

TITLE: Batch Triggering Multiple Tasks
DESCRIPTION: Examples showing how to trigger multiple different tasks in a single batch operation using the new batch.trigger and batch.triggerByTask methods.

LANGUAGE: typescript
CODE:
import { batch } from "@trigger.dev/sdk/v3";
import type { myTask1, myTask2 } from "./trigger/tasks";

const response = await batch.trigger<typeof myTask1 | typeof myTask2>([
  { id: "task1", payload: { foo: "bar" } },
  { id: "task2", payload: { baz: "qux" } }
]);

for (const run of response.runs) {
  if (run.ok) {
    console.log(run.output);
  } else {
    console.error(run.error);
  }
}

----------------------------------------

TITLE: Deploying to Self-Hosted Trigger.dev Instance
DESCRIPTION: Command to deploy to a self-hosted Trigger.dev instance with custom registry and namespace settings.

LANGUAGE: sh
CODE:
npx trigger.dev@latest deploy \
  --self-hosted \
  --load-image \
  --registry docker.io \
  --namespace mydockerhubusername

----------------------------------------

TITLE: Configuring Telemetry Opt-Out in Trigger.dev CLI
DESCRIPTION: This snippet describes how to opt-out of sending telemetry data in Trigger.dev. It can be done either through a CLI flag or by setting an environment variable.

LANGUAGE: markdown
CODE:
<ParamField body="Skip telemetry" type="--skip-telemetry">
  Opt-out of sending telemetry data. This can also be done via the `TRIGGER_TELEMETRY_DISABLED` environment variable. Just set it to anything other than an empty string.
</ParamField>

----------------------------------------

TITLE: Trigger.dev Image Processing Task Implementation
DESCRIPTION: TypeScript task that handles image processing requests by executing a Python script and uploading results to S3. Includes input validation, error handling, and cleanup operations.

LANGUAGE: typescript
CODE:
import { schemaTask } from "@trigger.dev/sdk/v3";
import { z } from "zod";
import { python } from "@trigger.dev/python";
import { promises as fs } from "fs";
import { S3Client } from "@aws-sdk/client-s3";
import { Upload } from "@aws-sdk/lib-storage";

// Initialize S3 client
const s3Client = new S3Client({
  region: "auto",
  endpoint: process.env.S3_ENDPOINT,
  credentials: {
    accessKeyId: process.env.S3_ACCESS_KEY_ID ?? "",
    secretAccessKey: process.env.S3_SECRET_ACCESS_KEY ?? "",
  },
});

// Define the input schema with Zod
const imageProcessingSchema = z.object({
  imageUrl: z.string().url(),
  height: z.number().positive().optional().default(800),
  width: z.number().positive().optional().default(600),
  quality: z.number().min(1).max(100).optional().default(85),
  maintainAspectRatio: z.boolean().optional().default(true),
  outputFormat: z.enum(["jpeg", "png", "webp", "gif", "avif"]).optional().default("jpeg"),
  brightness: z.number().optional(),
  contrast: z.number().optional(),
  sharpness: z.number().optional(),
  grayscale: z.boolean().optional().default(false),
});

// Define the output schema
const outputSchema = z.object({
  url: z.string().url(),
  key: z.string(),
  format: z.string(),
  originalSize: z.object({
    width: z.number(),
    height: z.number(),
  }),
  newSize: z.object({
    width: z.number(),
    height: z.number(),
  }),
  fileSizeBytes: z.number(),
  exitCode: z.number(),
});

export const processImage = schemaTask({
  id: "process-image",
  schema: imageProcessingSchema,
  run: async (payload, io) => {
    const {
      imageUrl,
      height,
      width,
      quality,
      maintainAspectRatio,
      outputFormat,
      brightness,
      contrast,
      sharpness,
      grayscale,
    } = payload;

    try {
      // Run the Python script
      const result = await python.runScript("./src/python/image-processing.py", [
        imageUrl,
        height.toString(),
        width.toString(),
        quality.toString(),
        maintainAspectRatio.toString(),
        outputFormat,
        brightness?.toString() || "null",
        contrast?.toString() || "null",
        sharpness?.toString() || "null",
        grayscale.toString(),
      ]);

      const { outputPath, format, originalSize, newSize, fileSizeBytes } = JSON.parse(
        result.stdout
      );

      // Read file once
      const fileContent = await fs.readFile(outputPath);

      try {
        // Upload to S3
        const key = `processed-images/${Date.now()}-${outputPath.split("/").pop()}`;
        await new Upload({
          client: s3Client,
          params: {
            Bucket: process.env.S3_BUCKET!,
            Key: key,
            Body: fileContent,
            ContentType: `image/${format}`,
          },
        }).done();

        return {
          url: `${process.env.S3_PUBLIC_URL}/${key}`,
          key,
          format,
          originalSize,
          newSize,
          fileSizeBytes,
          exitCode: result.exitCode,
        };
      } finally {
        // Always clean up the temp file
        await fs.unlink(outputPath).catch(console.error);
      }
    } catch (error) {
      throw new Error(
        `Processing failed: ${error instanceof Error ? error.message : "Unknown error"}`
      );
    }
  },
});

----------------------------------------

TITLE: Starting Ngrok HTTP Tunnel
DESCRIPTION: Command to start an Ngrok HTTP tunnel for local development

LANGUAGE: bash
CODE:
ngrok http <your-app-port>

----------------------------------------

TITLE: Running Trigger.dev CLI Development Commands
DESCRIPTION: Commands for running Trigger.dev CLI in development mode using the latest version.

LANGUAGE: sh
CODE:
npx trigger.dev@latest dev

LANGUAGE: sh
CODE:
npx trigger.dev@latest deploy

----------------------------------------

TITLE: Documenting CLI Environment File Parameter
DESCRIPTION: This code snippet defines a parameter field for a CLI tool. The parameter '--env-file' allows loading environment variables from a file, which are then applied to the CLI process's environment (process.env) but not to the tasks' environments.

LANGUAGE: jsx
CODE:
<ParamField body="Env file" type="--env-file">
  Load environment variables from a file. This will only hydrate the `process.env` of the CLI
  process, not the tasks.
</ParamField>

----------------------------------------

TITLE: Configuring Python Requirements
DESCRIPTION: Configuration for including Python package dependencies using a requirements.txt file

LANGUAGE: typescript
CODE:
import { defineConfig } from "@trigger.dev/sdk/v3";
import { pythonExtension } from "@trigger.dev/python/extension";

export default defineConfig({
  project: "<project ref>",
  build: {
    extensions: [
      pythonExtension({
        requirementsFile: "./requirements.txt",
      }),
    ],
  },
});

----------------------------------------

TITLE: Defining Help Parameter for CLI Command in HTML
DESCRIPTION: This code snippet defines a parameter field for a CLI command that displays help information. It uses the 'ParamField' component to specify the parameter name, type, and description.

LANGUAGE: html
CODE:
<ParamField body="Help" type="--help | -h">
  Shows the help information for the command.
</ParamField>

----------------------------------------

TITLE: Python Dependencies Configuration
DESCRIPTION: Requirements file specifying Python package dependencies needed for PDF processing, including PyMuPDF for PDF handling and requests for HTTP operations.

LANGUAGE: plaintext
CODE:
PyMuPDF==1.23.8
requests==2.31.0

----------------------------------------

TITLE: CLI Authentication for Local Development
DESCRIPTION: Command to authenticate the Trigger.dev CLI for local development

LANGUAGE: bash
CODE:
pnpm exec trigger login -a http://localhost:3030 --profile local

----------------------------------------

TITLE: Specifying Package Versions in additionalPackages
DESCRIPTION: This snippet shows how to specify a particular version of a package when using the additionalPackages build extension. It uses the '@' symbol to define the version number for the 'wrangler' package.

LANGUAGE: typescript
CODE:
import { defineConfig } from "@trigger.dev/sdk/v3";

export default defineConfig({
  project: "<project ref>",
  // Your other config settings...
  build: {
    extensions: [additionalPackages({ packages: ["wrangler@1.19.0"] })],
  },
});

----------------------------------------

TITLE: Running Trigger.dev Dev Server - Package Manager Commands
DESCRIPTION: Commands to start the Trigger.dev development server using different package managers (npm, pnpm, yarn). The server executes tasks and provides dashboard integration.

LANGUAGE: bash
CODE:
npx trigger.dev@latest dev

LANGUAGE: bash
CODE:
pnpm dlx trigger.dev@latest dev

LANGUAGE: bash
CODE:
yarn dlx trigger.dev@latest dev

----------------------------------------

TITLE: Implementing PDF Processing Task with Trigger.dev
DESCRIPTION: Task implementation that runs a Python script to process PDF forms. Handles script execution and parses the returned JSON output containing extracted form data.

LANGUAGE: typescript
CODE:
import { task } from "@trigger.dev/sdk/v3";
import { python } from "@trigger.dev/python";

export const processPdfForm = task({
  id: "process-pdf-form",
  run: async (payload: { pdfUrl: string }, io: any) => {
    const { pdfUrl } = payload;
    const args = [pdfUrl];

    const result = await python.runScript("./src/python/extract-pdf-form.py", args);

    // Parse the JSON output from the script
    let formData;
    try {
      formData = JSON.parse(result.stdout);
    } catch (error) {
      throw new Error(`Failed to parse JSON output: ${result.stdout}`);
    }

    return {
      formData,
      stderr: result.stderr,
      exitCode: result.exitCode,
    };
  },
});

----------------------------------------

TITLE: Running and Deploying Trigger.dev Projects
DESCRIPTION: Commands for running and deploying Trigger.dev projects in development mode

LANGUAGE: bash
CODE:
pnpm exec trigger dev --profile local

pnpm exec trigger deploy --self-hosted --load-image --profile local

----------------------------------------

TITLE: Build Target Specific Logic
DESCRIPTION: Example showing how to implement different behavior based on build target (dev vs deploy).

LANGUAGE: typescript
CODE:
import { defineConfig } from "@trigger.dev/sdk/v3";

export default defineConfig({
  project: "my-project",
  build: {
    extensions: [
      {
        name: "my-extension",
        onBuildStart: async (context) => {
          if (context.target === "dev") {
            console.log("Building for dev");
          } else {
            console.log("Building for deploy");
          }
        },
      },
    ],
  },
});

----------------------------------------

TITLE: Build Target Specific Logic
DESCRIPTION: Example showing how to implement different behavior based on build target (dev vs deploy).

LANGUAGE: typescript
CODE:
import { defineConfig } from "@trigger.dev/sdk/v3";

export default defineConfig({
  project: "my-project",
  build: {
    extensions: [
      {
        name: "my-extension",
        onBuildStart: async (context) => {
          if (context.target === "dev") {
            console.log("Building for dev");
          } else {
            console.log("Building for deploy");
          }
        },
      },
    ],
  },
});

----------------------------------------

TITLE: Defining Project Path Parameter Field in HTML
DESCRIPTION: HTML markup for documenting a project path parameter that specifies the path to the project, with a default value of the current directory.

LANGUAGE: html
CODE:
<ParamField body="Project path" type="[path]">
  The path to the project. Defaults to the current directory.
</ParamField>

----------------------------------------

TITLE: Executing Python Script Files
DESCRIPTION: Example of running a Python script file with arguments using the python.runScript function

LANGUAGE: typescript
CODE:
import { task } from "@trigger.dev/sdk/v3";
import { python } from "@trigger.dev/python";

export const myScript = task({
  id: "my-python-script",
  run: async () => {
    const result = await python.runScript("./python/my_script.py", ["hello", "world"]);
    return result.stdout;
  },
});

----------------------------------------

TITLE: Installing TriggerKit Plugin for SvelteKit Integration with Trigger.dev
DESCRIPTION: This command installs the TriggerKit plugin, which enables seamless integration between SvelteKit and Trigger.dev. The plugin allows direct use of SvelteKit functions in Trigger.dev projects.

LANGUAGE: bash
CODE:
npm i triggerkit

----------------------------------------

TITLE: VS Code Debug Configuration
DESCRIPTION: Launch configuration for debugging Trigger.dev tasks in VS Code.

LANGUAGE: json
CODE:
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "Trigger.dev: Dev",
      "type": "node",
      "request": "launch",
      "cwd": "${workspaceFolder}",
      "runtimeExecutable": "npx",
      "runtimeArgs": ["trigger.dev@0.0.0-prerelease-20240911144933", "dev"],
      "skipFiles": ["<node_internals>/**"],
      "sourceMaps": true
    }
  ]
}

----------------------------------------

TITLE: Running the main webapp for trigger.dev
DESCRIPTION: Command to start the main webapp for trigger.dev using pnpm.

LANGUAGE: bash
CODE:
pnpm run dev --filter webapp

----------------------------------------

TITLE: Configuring Custom Telemetry Exporters in Trigger.dev TypeScript
DESCRIPTION: This snippet shows how to set up a custom telemetry exporter (Axiom) in the Trigger.dev configuration for sending logs to external services.

LANGUAGE: typescript
CODE:
import { defineConfig } from "@trigger.dev/sdk/v3";
import { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-proto';

// Initialize OTLP trace exporter with the endpoint URL and headers
const axiomExporter = new OTLPTraceExporter({
  url: 'https://api.axiom.co/v1/traces',
  headers: {
    'Authorization': `Bearer ${process.env.AXIOM_API_TOKEN}`,
    'X-Axiom-Dataset': process.env.AXIOM_DATASET
  },
});

export default defineConfig({
  project: "<project ref>",
  // Your other config settings...
  telemetry: {
    instrumentations: [
      // Your instrumentations here
    ],
    exporters: [axiomExporter],
  },
});

----------------------------------------

TITLE: Accessing Environment Variables in Node.js
DESCRIPTION: Demonstrates how to access environment variables in Node.js applications using the process.env object.

LANGUAGE: javascript
CODE:
process.env.MY_ENV_VAR

----------------------------------------

TITLE: Build Extension Configuration for Prisma
DESCRIPTION: Example of configuring Prisma support using the new build extension system.

LANGUAGE: typescript
CODE:
import { defineConfig } from "@trigger.dev/sdk/v3";
import { prismaExtension } from "@trigger.dev/build/extensions/prisma";

export default defineConfig({
  project: "<project ref>",
  build: {
    extensions: [
      prismaExtension({
        schema: "prisma/schema.prisma",
      }),
    ],
  },
});

----------------------------------------

TITLE: Creating a new profile for trigger.dev CLI
DESCRIPTION: Command to create a new profile for the trigger.dev CLI if already logged in. This allows for multiple configurations.

LANGUAGE: bash
CODE:
pnpm exec trigger login -a http://localhost:3030 --profile local

----------------------------------------

TITLE: Custom Tracing Implementation with OpenTelemetry
DESCRIPTION: Shows how to implement custom traces using the logger.trace function. The example demonstrates creating a new OTEL trace, setting attributes, and returning values from within the trace.

LANGUAGE: typescript
CODE:
import { logger, task } from "@trigger.dev/sdk/v3";

export const customTrace = task({
  id: "custom-trace",
  run: async (payload) => {
    //you can wrap code in a trace, and set attributes
    const user = await logger.trace("fetch-user", async (span) => {
      span.setAttribute("user.id", "1");

      //...do stuff

      //you can return a value
      return {
        id: "1",
        name: "John Doe",
        fetchedAt: new Date(),
      };
    });

    const usersName = user.name;
  },
});

----------------------------------------

TITLE: Defining Tasks in Defer.run
DESCRIPTION: Example of defining a long-running task using Defer.run's default export pattern

LANGUAGE: typescript
CODE:
import { defer } from "@defer/client";

async function longRunningTask() {
  // runs a fake task for 30s
  await performLongRunningTask();
}

export default defer(longRunningTask);

----------------------------------------

TITLE: Configuring Python Scripts Directory
DESCRIPTION: Configuration for including Python scripts from a specific directory in the build process

LANGUAGE: typescript
CODE:
import { defineConfig } from "@trigger.dev/sdk/v3";
import { pythonExtension } from "@trigger.dev/python/extension";

export default defineConfig({
  project: "<project ref>",
  build: {
    extensions: [
      pythonExtension({
        scripts: ["./python/**/*.py"],
      }),
    ],
  },
});

----------------------------------------

TITLE: Docker Experimental Configuration
DESCRIPTION: JSON configuration to enable experimental features in Docker daemon

LANGUAGE: json
CODE:
{
  "experimental": true
}

----------------------------------------

TITLE: Using Preview Release CLI Commands
DESCRIPTION: Demonstrates how to use the preview release version of the CLI via npx.

LANGUAGE: sh
CODE:
# old way
npx trigger.dev@latest dev

# using the preview release
npx trigger.dev@0.0.0-prerelease-20240911144933 dev

----------------------------------------

TITLE: Changing directory to v3-catalog
DESCRIPTION: Command to change the current directory to the v3-catalog folder.

LANGUAGE: bash
CODE:
cd references/v3-catalog

----------------------------------------

TITLE: Creating package.json for Trigger.dev SDK Compatibility
DESCRIPTION: This snippet provides a basic package.json configuration required for the Trigger.dev SDK to work correctly. It includes TypeScript as a dev dependency. Users should update the TypeScript version to the latest available version.

LANGUAGE: json
CODE:
{
  "devDependencies": {
    "typescript": "^5.6.2"
  }
}

----------------------------------------

TITLE: Configuring Trigger.dev Build Settings with Python Extension
DESCRIPTION: Configuration setup for Trigger.dev project with Python build extension. Specifies requirements file path, Python binary location, and script paths for execution.

LANGUAGE: typescript
CODE:
import { pythonExtension } from "@trigger.dev/python/extension";
import { defineConfig } from "@trigger.dev/sdk/v3";

export default defineConfig({
  runtime: "node",
  project: "<your-project-ref>",
  // Your other config settings...
  build: {
    extensions: [
      pythonExtension({
        // The path to your requirements.txt file
        requirementsFile: "./requirements.txt",
        // The path to your Python binary
        devPythonBinaryPath: `venv/bin/python`,
        // The paths to your Python scripts to run
        scripts: ["src/python/**/*.py"],
      }),
    ],
  },
});

----------------------------------------

TITLE: Updating Package Version in package.json
DESCRIPTION: Shows how to update the @trigger.dev/sdk package version to use the preview release.

LANGUAGE: json
CODE:
"@trigger.dev/sdk": "0.0.0-prerelease-20240911144933"

----------------------------------------

TITLE: Creating a new profile for trigger.dev CLI
DESCRIPTION: Command to create a new profile for the trigger.dev CLI if already logged in. This allows for multiple configurations.

LANGUAGE: bash
CODE:
pnpm exec trigger login -a http://localhost:3030 --profile local

----------------------------------------

TITLE: Imperative Schedule Creation
DESCRIPTION: Examples of creating schedules programmatically using the SDK, including basic and advanced configuration options.

LANGUAGE: typescript
CODE:
const createdSchedule = await schedules.create({
  task: firstScheduledTask.id,
  cron: "0 0 * * *",
  deduplicationKey: "my-deduplication-key",
});

LANGUAGE: typescript
CODE:
const createdSchedule = await schedules.create({
  task: firstScheduledTask.id,
  cron: "0 0 * * *",
  timezone: "America/New_York",
  externalId: "user_123456",
  deduplicationKey: "user_123456-todo_reminder",
});

----------------------------------------

TITLE: Updated Configuration with defineConfig
DESCRIPTION: Shows the new configuration format using defineConfig from @trigger.dev/sdk/v3.

LANGUAGE: typescript
CODE:
import { defineConfig } from "@trigger.dev/sdk/v3";

export default defineConfig({
  project: "<project ref>",
});

----------------------------------------

TITLE: Setting Puppeteer Executable Path Environment Variable (Bash)
DESCRIPTION: This snippet provides the environment variable that needs to be set in the Trigger.dev dashboard. It specifies the path to the Google Chrome executable, which is required for Puppeteer to function properly.

LANGUAGE: bash
CODE:
PUPPETEER_EXECUTABLE_PATH: "/usr/bin/google-chrome-stable",

----------------------------------------

TITLE: Rendering Accordion Component for Trigger.dev Limit Increase Information
DESCRIPTION: This code snippet renders an Accordion component that explains how users can request increased usage limits for Trigger.dev. It includes information about contacting support, potential future paid plans, and links to Discord and pricing details.

LANGUAGE: JSX
CODE:
<Accordion title="How to increase these limits?">
  These are soft-limits and can be increased. Before we introduce paid plans in July you can request
  more [on Discord](https://trigger.dev/discord) or by [contacting us](https://trigger.dev/contact).
  If you increase these defaults you may have to subscribe to a paid plan when we introduce them.
  For more details on the v3 Cloud pricing see the [pricing
  details](https://trigger.dev/pricing).
</Accordion>

----------------------------------------

TITLE: Importing Supabase Documentation Cards Component in MDX
DESCRIPTION: Imports a reusable documentation component called SupabaseDocsCards from the snippets directory and renders it in the page.

LANGUAGE: mdx
CODE:
import SupabaseDocsCards from "/snippets/supabase-docs-cards.mdx";

<SupabaseDocsCards />

----------------------------------------

TITLE: Importing MDX Components for Node.js Setup Guide
DESCRIPTION: This snippet imports various MDX components used throughout the setup guide. These components likely contain reusable content for different parts of the setup process.

LANGUAGE: MDX
CODE:
import Prerequisites from "/snippets/framework-prerequisites.mdx";
import CliInitStep from "/snippets/step-cli-init.mdx";
import CliDevStep from "/snippets/step-cli-dev.mdx";
import CliRunTestStep from "/snippets/step-run-test.mdx";
import CliViewRunStep from "/snippets/step-view-run.mdx";
import UsefulNextSteps from "/snippets/useful-next-steps.mdx";

----------------------------------------

TITLE: Configuring Trigger.dev with LibreOffice Package
DESCRIPTION: This snippet shows how to configure a Trigger.dev project to include the LibreOffice package using the aptGet build extension. It adds LibreOffice to the project configuration, enabling its use in the deployment environment.

LANGUAGE: typescript
CODE:
import { aptGet } from "@trigger.dev/build/extensions/core";
import { defineConfig } from "@trigger.dev/sdk/v3";

export default defineConfig({
  project: "<project ref>",
  // Your other config settings...
  build: {
    extensions: [
      aptGet({
        packages: ["libreoffice"],
      }),
    ],
  },
});

----------------------------------------

TITLE: Sample Post Creation SQL
DESCRIPTION: Example SQL command for inserting a test post into the database.

LANGUAGE: sql
CODE:
insert into
posts (title, body, author)
values
  (
    'The Future of AI',
    'An insightful look into how artificial intelligence is shaping the future of technology and society.',
    'Alice H Johnson'
  );

----------------------------------------

TITLE: Testing Sharp Image Processing Task with JSON Payload
DESCRIPTION: This JSON snippet provides a sample payload for testing the Sharp image processing task in the Trigger.dev dashboard. It includes URLs for the input image and watermark image.

LANGUAGE: json
CODE:
{
  "imageUrl": "<an-image-url.jpg>", // Replace with a URL to a JPEG image
  "watermarkUrl": "<an-image-url.png>" // Replace with a URL to a PNG watermark image
}

----------------------------------------

TITLE: Deleting Environment Variables via REST API
DESCRIPTION: OpenAPI specification for deleting an environment variable from a trigger.dev project. The endpoint requires the project reference, environment name, and variable name as path parameters.

LANGUAGE: openapi
CODE:
DELETE /api/v1/projects/{projectRef}/envvars/{env}/{name}

----------------------------------------

TITLE: Testing Webhook with cURL Command
DESCRIPTION: Command to test the webhook handler locally by sending a POST request with sample JSON data using cURL. This allows developers to verify the webhook implementation works correctly.

LANGUAGE: bash
CODE:
curl -X POST -H "Content-Type: application/json" -d '{"Name": "John Doe", "Age": "87"}' http://localhost:5173/api/webhook-handler

----------------------------------------

TITLE: Test Payload for OpenAI Text Generation Task
DESCRIPTION: Example JSON payload for testing the OpenAI text generation task in the Trigger.dev dashboard.

LANGUAGE: json
CODE:
{
  "prompt": "What is the meaning of life?"
}

----------------------------------------

TITLE: Configuring Puppeteer Extension in Trigger.dev Config (TypeScript)
DESCRIPTION: This snippet shows how to add the Puppeteer build extension to the Trigger.dev configuration file. It imports the necessary modules and defines the config with the Puppeteer extension enabled.

LANGUAGE: typescript
CODE:
import { defineConfig } from "@trigger.dev/sdk/v3";
import { puppeteer } from "@trigger.dev/build/extensions/puppeteer";

export default defineConfig({
  project: "<project ref>",
  // Your other config settings...
  build: {
    extensions: [puppeteer()],
  },
});

----------------------------------------

TITLE: Test Payload for Email Task
DESCRIPTION: Example JSON payload for testing the email sending task in the Trigger.dev dashboard. Includes required fields for recipient, name, message, and subject.

LANGUAGE: json
CODE:
{
  "to": "recipient@example.com",
  "name": "Jane Doe",
  "message": "Thank you for signing up for our service!",
  "subject": "Welcome to Acme Inc."
}

----------------------------------------

TITLE: Setting Time-to-Live (TTL) for a Task Run in TypeScript
DESCRIPTION: Illustrates how to set a TTL when triggering a run to automatically expire queued tasks.

LANGUAGE: typescript
CODE:
await yourTask.trigger({ foo: "bar" }, { ttl: "10m" });

----------------------------------------

TITLE: Task Testing Payload
DESCRIPTION: JSON payload structure for testing the Supabase Storage upload tasks in the dashboard.

LANGUAGE: json
CODE:
{
  "videoUrl": "<a-video-url>" // Replace <a-video-url> with the URL of the video you want to upload
}

----------------------------------------

TITLE: Testing Crawler Task Configuration
DESCRIPTION: JSON payload configuration for testing the crawl task through the Trigger.dev dashboard.

LANGUAGE: json
CODE:
"url": "<url-to-crawl>" // Replace with the URL you want to crawl

----------------------------------------

TITLE: Rescheduling a Delayed Run in Trigger.dev using TypeScript
DESCRIPTION: Demonstrates how to update a delayed run with a new delay in Trigger.dev.

LANGUAGE: typescript
CODE:
import { runs } from "@trigger.dev/sdk/v3";

await runs.reschedule(runId, { delay: "1h" });

----------------------------------------

TITLE: Configuring Build Settings for MuPDF Integration in Trigger.dev
DESCRIPTION: Configuration setup in trigger.config.ts to include necessary packages (mupdf-tools and curl) for PDF processing.

LANGUAGE: typescript
CODE:
export default defineConfig({
  project: "<project ref>",
  // Your other config settings...
  build: {
    extensions: [aptGet({ packages: ["mupdf-tools", "curl"] })],
  },
});

----------------------------------------

TITLE: Configuring Prisma Extension with Specific Client Generator in Trigger.dev
DESCRIPTION: This snippet demonstrates how to configure the prismaExtension to use a specific client generator when multiple generators are defined in the Prisma schema.

LANGUAGE: typescript
CODE:
import { defineConfig } from "@trigger.dev/sdk/v3";
import { prismaExtension } from "@trigger.dev/build/extensions/prisma";

export default defineConfig({
  project: "<project ref>",
  // Your other config settings...
  build: {
    extensions: [
      prismaExtension({
        schema: "prisma/schema.prisma",
        clientGenerator: "client",
      }),
    ],
  },
});

----------------------------------------

TITLE: Audio Extraction Task with FFmpeg
DESCRIPTION: Task implementation for extracting audio from video files using FFmpeg, converting to WAV format, and uploading to R2 storage. Configures audio settings like sample rate and channels.

LANGUAGE: typescript
CODE:
import { PutObjectCommand, S3Client } from "@aws-sdk/client-s3";
import { logger, task } from "@trigger.dev/sdk/v3";
import ffmpeg from "fluent-ffmpeg";
import fs from "fs/promises";
import fetch from "node-fetch";
import { Readable } from "node:stream";
import os from "os";
import path from "path";

const s3Client = new S3Client({
  region: "auto",
  endpoint: process.env.R2_ENDPOINT,
  credentials: {
    accessKeyId: process.env.R2_ACCESS_KEY_ID ?? "",
    secretAccessKey: process.env.R2_SECRET_ACCESS_KEY ?? "",
  },
});

export const ffmpegExtractAudio = task({
  id: "ffmpeg-extract-audio",
  run: async (payload: { videoUrl: string }) => {
    const { videoUrl } = payload;

    const tempDirectory = os.tmpdir();
    const outputPath = path.join(tempDirectory, `audio_${Date.now()}.wav`);

    const response = await fetch(videoUrl);

    await new Promise((resolve, reject) => {
      if (!response.body) {
        return reject(new Error("Failed to fetch video"));
      }

      ffmpeg(Readable.from(response.body))
        .outputOptions([
          "-vn",
          "-acodec pcm_s16le",
          "-ar 44100",
          "-ac 2",
        ])
        .output(outputPath)
        .on("end", resolve)
        .on("error", reject)
        .run();
    });

    const audioBuffer = await fs.readFile(outputPath);
    const audioSize = audioBuffer.length;

    logger.log(`Extracted audio size: ${audioSize} bytes`);
    logger.log(`Temporary audio file created`, { outputPath });

    const r2Key = `extracted-audio/${path.basename(outputPath)}`;

    const uploadParams = {
      Bucket: process.env.R2_BUCKET,
      Key: r2Key,
      Body: audioBuffer,
    };

    await s3Client.send(new PutObjectCommand(uploadParams));
    logger.log(`Extracted audio saved to your R2 bucket`, { r2Key });

    await fs.unlink(outputPath);
    logger.log(`Temporary audio file deleted`, { outputPath });

    return {
      Bucket: process.env.R2_BUCKET,
      r2Key,
    };
  },
});

----------------------------------------

TITLE: Project Structure Example 1
DESCRIPTION: Directory structure for Turborepo monorepo with Trigger.dev and Prisma as separate packages

LANGUAGE: plaintext
CODE:
|
| — apps/
|   | — web/                    # Next.js frontend application
|   |   | — app/                # Next.js app router
|   |   |   | — api/
|   |   |   |   | — actions.ts  # Server actions for triggering tasks
|   |   |   | — page.tsx        # Main page with "Add new user" button
|   |   |   | — layout.tsx      # App layout
|   |   | — package.json        # Dependencies including @repo/db and @repo/tasks
|   |
|   | — docs/                   # Documentation app (not fully implemented)
|
| — packages/
|   | — database/               # Prisma database package (@repo/db)
|   |   | — prisma/
|   |   |   | — schema.prisma   # Database schema definition
|   |   | — generated/          # Generated Prisma client (gitignored)
|   |   | — src/
|   |   |   | — index.ts        # Exports from the database package
|   |   | — package.json        # Database package dependencies
|   |
|   | — tasks/                  # Trigger.dev tasks package (@repo/tasks)
|   |   | — src/
|   |   |   | — index.ts        # Exports from the tasks package
|   |   |   | — trigger/
|   |   |       | — index.ts    # Exports the tasks
|   |   |       | — addNewUser.ts # Task implementation for adding users
|   |   | — trigger.config.ts   # Trigger.dev configuration
|   |   | — package.json        # Tasks package dependencies
|   |
|   | — ui/                     # UI components package (referenced but not detailed)
|
| — turbo.json                  # Turborepo configuration
| — package.json                # Root package.json with workspace config

----------------------------------------

TITLE: Subscribing to Real-time Run Updates in Trigger.dev using TypeScript
DESCRIPTION: Shows how to subscribe to changes to a specific run in real-time in Trigger.dev.

LANGUAGE: typescript
CODE:
import { runs } from "@trigger.dev/sdk/v3";

for await (const run of runs.subscribeToRun(runId)) {
  console.log(run);
}

----------------------------------------

TITLE: Testing Scraper Task Configuration
DESCRIPTION: JSON payload configuration for testing the scrape task through the Trigger.dev dashboard.

LANGUAGE: json
CODE:
"url": "<url-to-scrape>" // Replace with the URL you want to scrape

----------------------------------------

TITLE: Example Test Payload for Image Generation Task
DESCRIPTION: JSON payload example for testing the image generation task, including a sample image URL and prompt for generating a Christmas-themed dog image.

LANGUAGE: json
CODE:
{
  "imageUrl": "https://static.vecteezy.com/system/resources/previews/005/857/332/non_2x/funny-portrait-of-cute-corgi-dog-outdoors-free-photo.jpg",
  "prompt": "Dress this dog for Christmas"
}

----------------------------------------

TITLE: Project Structure Example 2
DESCRIPTION: Directory structure for Turborepo monorepo with Prisma as a package and Trigger.dev in Next.js app

LANGUAGE: plaintext
CODE:
|
| — apps/
|   | — web/                       # Next.js frontend application
|   |   | — app/                   # Next.js app router
|   |   |   | — api/
|   |   |   |   | — actions.ts     # Server actions for triggering tasks
|   |   |   | — page.tsx           # Main page with "Add new user" button
|   |   | — src/
|   |   |   | — trigger/
|   |   |       | — addNewUser.ts  # Task implementation for adding users
|   |   | — trigger.config.ts      # Trigger.dev configuration
|   |   | — package.json           # Dependencies including @repo/db
|   |
|   | — docs/                      # Documentation app
|       | — app/
|           | — page.tsx           # Docs landing page
|
| — packages/
|   | — database/                  # Prisma database package (@repo/db)
|   |   | — prisma/
|   |   |   | — schema.prisma      # Database schema definition
|   |
|   | — ui/                        # UI components package
|
| — turbo.json                     # Turborepo configuration
| — package.json                   # Root package.json with workspace config

----------------------------------------

TITLE: Listing Python Package Dependencies
DESCRIPTION: A requirements.txt file specifying exact versions of Python packages and their dependencies. The file shows both direct dependencies and their sub-dependencies, with comments indicating which packages require each dependency.

LANGUAGE: plaintext
CODE:
aiofiles==24.1.0
    # via crawl4ai
aiohappyeyeballs==2.6.1
    # via aiohttp
aiohttp==3.11.14
    # via
    #   crawl4ai
    #   litellm
aiosignal==1.3.2
    # via aiohttp
aiosqlite==0.21.0
    # via crawl4ai
# ... [truncated for brevity]

----------------------------------------

TITLE: Logging in to trigger.dev CLI
DESCRIPTION: Command to log in to the trigger.dev CLI using the local development server. This is required for first-time setup.

LANGUAGE: bash
CODE:
pnpm exec trigger login -a http://localhost:3030

----------------------------------------

TITLE: Configuring Prisma Extension with Migrations in Trigger.dev
DESCRIPTION: This snippet shows how to configure the prismaExtension to run migrations during the build process. It includes options for specifying the schema, enabling migrations, and setting a direct database URL environment variable.

LANGUAGE: typescript
CODE:
import { defineConfig } from "@trigger.dev/sdk/v3";
import { prismaExtension } from "@trigger.dev/build/extensions/prisma";

export default defineConfig({
  project: "<project ref>",
  // Your other config settings...
  build: {
    extensions: [
      prismaExtension({
        schema: "prisma/schema.prisma",
        migrate: true,
        directUrlEnvVarName: "DATABASE_URL_UNPOOLED", // optional - the name of the environment variable that contains the direct database URL if you are using a direct database URL
      }),
    ],
  },
});

----------------------------------------

TITLE: Test Payload for Deepgram Transcription Task
DESCRIPTION: Sample JSON payload for testing the Deepgram transcription task in the dashboard. Uses a demo audio file from Deepgram.

LANGUAGE: json
CODE:
{
  "audioUrl": "https://dpgr.am/spacewalk.wav"
}

----------------------------------------

TITLE: Installing Dependencies with PNPM
DESCRIPTION: Command to install project dependencies using PNPM package manager

LANGUAGE: shell
CODE:
pnpm install

----------------------------------------

TITLE: Executing Tests with PNPM Filter
DESCRIPTION: Commands for running tests in specific workspaces using PNPM workspace filtering.

LANGUAGE: bash
CODE:
pnpm run test --filter webapp

----------------------------------------

TITLE: Running the v3 CLI for trigger.dev
DESCRIPTION: Command to start the v3 CLI in development mode, which will output messages and start a background worker.

LANGUAGE: bash
CODE:
pnpm exec trigger dev

----------------------------------------

TITLE: Configuring Test Payload for Copy Generation and Translation Task
DESCRIPTION: This JSON snippet provides an example payload for testing the 'generate-and-translate-copy' task. It specifies the marketing subject, target language, and desired word count for the generated copy.

LANGUAGE: json
CODE:
{
  marketingSubject: "The controversial new Jaguar electric concept car",
  targetLanguage: "Spanish",
  targetWordCount: 100,
}

----------------------------------------

TITLE: Running Single Test File
DESCRIPTION: Command for executing tests on a specific file after changing to the target directory.

LANGUAGE: bash
CODE:
cd apps/webapp
pnpm run test ./src/components/Button.test.ts

----------------------------------------

TITLE: Logging in to trigger.dev CLI
DESCRIPTION: Command to log in to the trigger.dev CLI using the local development server. This is required for first-time use.

LANGUAGE: bash
CODE:
pnpm exec trigger login -a http://localhost:3030

----------------------------------------

TITLE: Using Pre-built FFmpeg Extension in Trigger.dev
DESCRIPTION: Demonstrates how to import and configure a pre-built extension (ffmpeg) from the @trigger.dev/build package in the project configuration file.

LANGUAGE: typescript
CODE:
import { defineConfig } from "@trigger.dev/sdk/v3";
import { ffmpeg } from "@trigger.dev/build/extensions/core";

export default defineConfig({
  project: "my-project",
  build: {
    extensions: [ffmpeg()],
  },
});

----------------------------------------

TITLE: Task Documentation Structure in MDX
DESCRIPTION: MDX table structure defining the documentation topics and their descriptions for Trigger.dev tasks

LANGUAGE: mdx
CODE:
import ExamplesCards from "/snippets/examples-cards.mdx";

<ExamplesCards />

----------------------------------------

TITLE: Redis Test Container Example
DESCRIPTION: Example of using Redis test container for integration testing with the internal testcontainers library.

LANGUAGE: typescript
CODE:
import { redisTest } from "@internal/testcontainers";
import { createRedisClient } from "@internal/redis";

describe("redisTest", () => {
  redisTest("should use redis", async ({ redisOptions }) => {
    const redis = createRedisClient(redisOptions);

    await redis.set("test", "test");
    const result = await redis.get("test");
    expect(result).toEqual("test");
  });
});

----------------------------------------

TITLE: Building the v3 CLI for trigger.dev
DESCRIPTION: Command to build the v3 CLI using pnpm. This needs to be done after any code changes to the CLI.

LANGUAGE: bash
CODE:
pnpm run build --filter trigger.dev

----------------------------------------

TITLE: Task Implementation with NestJS (Anti-pattern)
DESCRIPTION: Example showing how NestJS implementation in tasks can cause error suppression, which should be avoided.

LANGUAGE: typescript
CODE:
export const simplestTask = task({
  id: "nestjs-example",
  run: async (payload) => {
    //by doing this you're swallowing any errors
    const app = await NestFactory.createApplicationContext(AppModule);
    await app.init();

    //etc...
  },
});

----------------------------------------

TITLE: Building CLI and Deploying Reference Project for trigger.dev
DESCRIPTION: These commands build the CLI and deploy a reference project for trigger.dev. It includes an additional network flag for Linux environments.

LANGUAGE: sh
CODE:
pnpm exec trigger deploy --self-hosted

# The additional network flag is required on linux
pnpm exec trigger deploy --self-hosted --network host

----------------------------------------

TITLE: Trigger Config with TypeORM Initialization
DESCRIPTION: Configuration example showing how to initialize TypeORM in the Trigger.dev config file

LANGUAGE: typescript
CODE:
import type { TriggerConfig } from "@trigger.dev/sdk/v3";
import { AppDataSource } from "@/trigger/orm";

export const config: TriggerConfig = {
  // ... other options here
  init: async (payload, { ctx }) => {
    await AppDataSource.initialize();
  },
};

----------------------------------------

TITLE: Configuring Basic Build Extension in Trigger.dev
DESCRIPTION: Example of implementing a basic custom build extension in the trigger.config.ts file. Shows how to define an extension with an onBuildStart hook that executes when the build process begins.

LANGUAGE: typescript
CODE:
import { defineConfig } from "@trigger.dev/sdk/v3";

export default defineConfig({
  project: "my-project",
  build: {
    extensions: [
      {
        name: "my-extension",
        onBuildStart: async (context) => {
          console.log("Build starting!");
        },
      },
    ],
  },
});

----------------------------------------

TITLE: Setting Task-Specific Max Duration
DESCRIPTION: Shows how to configure maximum duration for a specific task, overriding the default configuration.

LANGUAGE: typescript
CODE:
import { task } from "@trigger.dev/sdk/v3";

export const maxDurationTask = task({
  id: "max-duration-task",
  maxDuration: 300, // 300 seconds or 5 minutes
  run: async (payload: any, { ctx }) => {
    //...
  },
});

----------------------------------------

TITLE: Creating Concurrent Index in SQL
DESCRIPTION: SQL command to create a concurrent index on a large table, ensuring the operation doesn't block other database operations. This approach is recommended for adding indexes to production databases.

LANGUAGE: sql
CODE:
CREATE INDEX CONCURRENTLY IF NOT EXISTS "JobRun_eventId_idx" ON "JobRun" ("eventId");

----------------------------------------

TITLE: Triggering Tasks with Machine Presets
DESCRIPTION: Examples showing how to trigger tasks with specific machine presets, including using batch triggers and wait options.

LANGUAGE: typescript
CODE:
// Regular trigger with machine preset
await childTask.trigger({ message: "Hello, world!" }, { machine: "small-2x" });

// Batch trigger with different machine presets
await childTask.batchTrigger([
  { payload: { message: "Hello, world!" }, options: { machine: "micro" } },
  { payload: { message: "Hello, world!" }, options: { machine: "large-1x" } }
]);

----------------------------------------

TITLE: React Import Solution
DESCRIPTION: Solutions for 'React is not defined' errors by either importing React or configuring TSConfig.

LANGUAGE: typescript
CODE:
import React from "react";

LANGUAGE: json
CODE:
{
  "compilerOptions": {
    "jsx": "react-jsx"
  }
}

----------------------------------------

TITLE: Processing Alert Webhooks in Remix with trigger.dev SDK
DESCRIPTION: This code snippet demonstrates how to handle alert webhooks in a Remix application using the trigger.dev SDK. It includes error handling and processing for different alert types.

LANGUAGE: typescript
CODE:
import { ActionFunctionArgs, json } from "@remix-run/server-runtime";
import { webhooks, WebhookError } from "@trigger.dev/sdk/v3";

export async function action({ request }: ActionFunctionArgs) {
  // Make sure this is a POST request
  if (request.method !== "POST") {
    return json({ error: "Method not allowed" }, { status: 405 });
  }

  try {
    // Construct and verify the webhook event
    // This secret can be found on your Alerts page when you create a webhook alert
    const event = await webhooks.constructEvent(request, process.env.ALERT_WEBHOOK_SECRET!);

    // Process the event based on its type
    switch (event.type) {
      case "alert.run.failed": {
        console.log("[Webhook Internal Test] Run failed alert webhook received", { event });
        break;
      }
      case "alert.deployment.success": {
        console.log("[Webhook Internal Test] Deployment success alert webhook received", { event });
        break;
      }
      case "alert.deployment.failed": {
        console.log("[Webhook Internal Test] Deployment failed alert webhook received", { event });
        break;
      }
      default: {
        console.log("[Webhook Internal Test] Unhandled webhook type", { event });
      }
    }

    // Return a success response
    return json({ received: true }, { status: 200 });
  } catch (err) {
    // Handle webhook errors
    if (err instanceof WebhookError) {
      console.error("Webhook error:", { message: err.message });
      return json({ error: err.message }, { status: 400 });
    }

    if (err instanceof Error) {
      console.error("Error processing webhook:", { message: err.message });
      return json({ error: err.message }, { status: 400 });
    }

    // Handle other errors
    console.error("Error processing webhook:", { err });
    return json({ error: "Internal server error" }, { status: 500 });
  }
}

----------------------------------------

TITLE: Manual Pagination Using Helper Methods in Trigger.dev API
DESCRIPTION: Shows how to manually handle pagination using helper methods like hasNextPage() and getNextPage(). This approach provides more control over the pagination process and allows for custom handling of each page of results.

LANGUAGE: typescript
CODE:
import { runs } from "@trigger.dev/sdk/v3";

async function main() {
  let page = await runs.list({ limit: 10 });

  for (const run of page.data) {
    console.log(run);
  }

  while (page.hasNextPage()) {
    page = await page.getNextPage();
    // ... do something with the next page
  }
}

----------------------------------------

TITLE: Building Dependencies and Running Tests
DESCRIPTION: Commands for building workspace dependencies before running tests in a specific directory.

LANGUAGE: bash
CODE:
pnpm run build --filter webapp
cd apps/webapp
pnpm run test ./src/components/Button.test.ts

----------------------------------------

TITLE: Auto-pagination Using For-Await Syntax in Trigger.dev API
DESCRIPTION: Demonstrates how to use the 'for await...of' syntax to automatically iterate through paginated results from the Trigger.dev API. This approach simplifies collecting all items across multiple pages into a single array.

LANGUAGE: typescript
CODE:
import { runs } from "@trigger.dev/sdk/v3";

async function fetchAllRuns() {
  const allRuns = [];

  for await (const run of runs.list({ limit: 10 })) {
    allRuns.push(run);
  }

  return allRuns;
}

----------------------------------------

TITLE: GitHub Actions Workflow with Typechecking
DESCRIPTION: Example of a GitHub Actions workflow that includes typechecking before deploying to Trigger.dev.

LANGUAGE: yaml
CODE:
- name: Install dependencies
  run: npm install

- name: Typecheck
  run: npx tsc

- name: 🚀 Deploy Trigger.dev
  env:
    TRIGGER_ACCESS_TOKEN: ${{ secrets.TRIGGER_ACCESS_TOKEN }}
  run: |
    npx trigger.dev@latest deploy

----------------------------------------

TITLE: Using Additional Files Build Extension
DESCRIPTION: Configure the additionalFiles build extension to include extra files in the Trigger.dev build.

LANGUAGE: typescript
CODE:
import { defineConfig } from "@trigger.dev/sdk/v3";
import { additionalFiles } from "@trigger.dev/build/extensions/core";

export default defineConfig({
  project: "<project ref>",
  build: {
    extensions: [
      additionalFiles({ files: ["wrangler/wrangler.toml", "./assets/**", "./fonts/**"] }),
    ],
  },
});

----------------------------------------

TITLE: Updating Trigger.dev Packages via CLI
DESCRIPTION: Command to update all Trigger.dev packages in a project to their latest versions using npx.

LANGUAGE: sh
CODE:
npx trigger.dev@latest update

----------------------------------------

TITLE: Importing Example Cards Component in JSX
DESCRIPTION: Imports and renders an ExamplesCards component that likely contains a collection of example implementations and guides for Trigger.dev.

LANGUAGE: jsx
CODE:
import ExamplesCards from "/snippets/examples-cards.mdx";

<ExamplesCards />

----------------------------------------

TITLE: Accessing Test Endpoint
DESCRIPTION: Example URL to test the Trigger.dev setup by accessing the hello-world endpoint on the local development server.

LANGUAGE: bash
CODE:
http://localhost:3000/api/hello-world

----------------------------------------

TITLE: Initializing Supabase Project with CLI
DESCRIPTION: This command initializes a new Supabase project using the Supabase CLI. It's recommended to use VS Code and accept the option to generate VS Code settings for Deno, as well as install any recommended extensions.

LANGUAGE: bash
CODE:
supabase init

----------------------------------------

TITLE: Installing Trigger.dev using PNPM
DESCRIPTION: Initializes a new Trigger.dev project using PNPM package manager. Creates necessary configuration files and project structure.

LANGUAGE: bash
CODE:
pnpm dlx trigger.dev@latest init

----------------------------------------

TITLE: Running Concurrent Next.js and Trigger.dev Development Servers
DESCRIPTION: This command starts both the Next.js application and Trigger.dev development server concurrently in the same terminal window, using the configured scripts from package.json.

LANGUAGE: bash
CODE:
npm run dev

----------------------------------------

TITLE: Defining CLI Parameter for Skipping Update Check in trigger.dev
DESCRIPTION: This snippet defines a CLI parameter '--skip-update-check' which allows users to skip checking for updates to the @trigger.dev package. It uses a custom ParamField component to display the parameter information.

LANGUAGE: markdown
CODE:
<ParamField body="Skip update check" type="--skip-update-check">
  Skip checking for `@trigger.dev` package updates.
</ParamField>

----------------------------------------

TITLE: Defining Project Reference Parameter in trigger.dev CLI
DESCRIPTION: HTML markup defining a required project reference parameter for the CLI. The parameter can be specified using either --project-ref or -p flags when no config file is present.

LANGUAGE: html
CODE:
<ParamField body="Project ref" type="--project-ref | -p">
  The project ref. Required if there is no config file.
</ParamField>

----------------------------------------

TITLE: Log Level Parameter Documentation
DESCRIPTION: Defines the log level parameter field for the CLI with options ranging from debug to none. The parameter can be specified using either --log-level or -l flags, with a default value of 'log'. This setting only affects CLI logging, not task logging.

LANGUAGE: markdown
CODE:
<ParamField body="Log level" type="--log-level | -l">
  The CLI log level to use. Options are `debug`, `info`, `log`, `warn`, `error`, and `none`. This does not affect the log level of your trigger.dev tasks. Defaults to `log`.
</ParamField>

----------------------------------------

TITLE: Specifying Custom Config File in Trigger.dev CLI
DESCRIPTION: This snippet demonstrates how to use the '--config' or '-c' parameter to specify a custom configuration file for the Trigger.dev CLI. The default configuration file name is 'trigger.config.ts' if not specified.

LANGUAGE: typescript
CODE:
trigger.config.ts

----------------------------------------

TITLE: Concurrent Server Execution Command
DESCRIPTION: Command using the concurrently package to run multiple development servers simultaneously, specifically for running Remix and Trigger.dev servers together.

LANGUAGE: typescript
CODE:
concurrently --raw --kill-others npm:dev:remix npm:dev:trigger

----------------------------------------

TITLE: Using Webhook Events in Trigger.dev
DESCRIPTION: Example showing how to construct and verify webhook events using the SDK's webhooks utility functions. Returns a typed object for alert events.

LANGUAGE: typescript
CODE:
const event = await webhooks.constructEvent(request, process.env.ALERT_WEBHOOK_SECRET!);

----------------------------------------

TITLE: Running Inline Python Code in Trigger.dev
DESCRIPTION: Example of executing inline Python code directly within a Trigger.dev task.

LANGUAGE: typescript
CODE:
import { task } from "@trigger.dev/sdk/v3";
import { python } from "@trigger.dev/python";

export const myTask = task({
  id: "to_datetime-task",
  run: async () => {
    const result = await python.runInline(`
import pandas as pd

pd.to_datetime("${+new Date() / 1000}")
`);
    return result.stdout;
  },
});

----------------------------------------

TITLE: Starting Trigger.dev MCP Server with Default Port
DESCRIPTION: This command starts the Trigger.dev Model Context Protocol (MCP) server using the default port 3333. The MCP server allows interaction with Trigger.dev in agentic LLM workflows.

LANGUAGE: bash
CODE:
trigger dev --mcp

----------------------------------------

TITLE: Updating SDK in Fixtures
DESCRIPTION: Commands to update the @trigger.dev/sdk package in fixture projects for different package managers.

LANGUAGE: bash
CODE:
cd packages/cli-v3/e2e/fixtures/<fixture-name>
rm -rf **/node_modules
corepack use pnpm@8.15.5
rm -rf **/node_modules
npm install
rm -rf **/node_modules
corepack use yarn@4.2.2
rm -rf **/node_modules

----------------------------------------

TITLE: Running CLI in Development Mode
DESCRIPTION: Commands to start the CLI in development mode with watch functionality from the cli-v3 package directory.

LANGUAGE: sh
CODE:
cd packages/cli-v3
pnpm run dev

----------------------------------------

TITLE: Wait Point Management Example in TypeScript
DESCRIPTION: Implementation example showing how to create, manage and use waitpoints in task flows, including creating, retrieving, completing and failing waitpoints.

LANGUAGE: typescript
CODE:
const waitpoint = await waitpoints.create({ idempotencyKey: `purchase-${payload.cart.id}` });
const waitpoint = await waitpoints.retrieve(waitpoint.id);
const waitpoint = await waitpoints.complete(waitpoint.id, result);
const waitpoint = await waitpoints.fail(waitpoint.id, error);

export const approvalFlow = task({
  id: "approvalFlow",
  run: async (payload) => {
    //...do stuff

    const result = await wait.forWaitpoint(waitpoint.id, { timeout: "1h" });
    if (!result.ok) {
      //...timeout
    }

    //...do more stuff
  },
});

----------------------------------------

TITLE: Committing Submodule Changes
DESCRIPTION: Command to commit the updated submodule reference in the main project.

LANGUAGE: shell script
CODE:
git commit -am "chore: updating protos submodule for @trigger.dev/otlp-importer"

----------------------------------------

TITLE: Returning to Main Directory
DESCRIPTION: Command to navigate back to the parent directory from the submodule.

LANGUAGE: shell script
CODE:
cd ../

----------------------------------------

TITLE: Useful SQL Commands for Index Management
DESCRIPTION: A set of SQL commands for creating indexes safely, checking the status of index creation, and verifying the existence of an index. These commands are helpful when managing indexes on large tables.

LANGUAGE: sql
CODE:
-- creates an index safely, this can take a long time (2 mins maybe)
CREATE INDEX CONCURRENTLY IF NOT EXISTS "JobRun_eventId_idx" ON "JobRun" ("eventId");
-- checks the status of an index
SELECT * FROM pg_stat_progress_create_index WHERE relid = '"JobRun"'::regclass;
-- checks if the index is there
SELECT * FROM pg_indexes WHERE tablename = 'JobRun' AND indexname = 'JobRun_eventId_idx';

----------------------------------------

TITLE: Switching Database Volumes in Bash
DESCRIPTION: Commands to switch between different database volumes for local development, allowing developers to work on different branches without wiping out their local database.

LANGUAGE: bash
CODE:
DB_VOLUME=database-data-alt pnpm run docker

LANGUAGE: bash
CODE:
pnpm run docker

----------------------------------------

TITLE: Production Task Testing Command
DESCRIPTION: Curl command for testing the deployed task endpoint in production

LANGUAGE: bash
CODE:
curl -X POST https://your-app.vercel.app/api/hello-world \
-H "Content-Type: application/json" \
-d '{"name": "James"}'

----------------------------------------

TITLE: Edge Runtime Task API Configuration
DESCRIPTION: Configuration for running Trigger.dev tasks in Vercel Edge Functions with type-safe imports and POST handling

LANGUAGE: typescript
CODE:
import { tasks } from "@trigger.dev/sdk/v3";
import type { helloWorldTask } from "../../src/trigger/example";

export const config = {
  runtime: "edge",
};
export async function action({ request }: { request: Request }) {
  const payload = await request.json();
  const handle = await tasks.trigger<typeof helloWorldTask>("hello-world", payload);
  return new Response(JSON.stringify(handle), {
    headers: { "Content-Type": "application/json" },
  });
}

----------------------------------------

TITLE: Realtime CSV Validator Hook Implementation
DESCRIPTION: Custom hook that integrates with useRealtimeRun to track CSV processing progress in realtime.

LANGUAGE: typescript
CODE:
Reference file: src/hooks/useRealtimeCSVValidator.ts
// Implementation details found in GitHub repository

----------------------------------------

TITLE: Example Translation Task Payload in JSON
DESCRIPTION: A sample JSON payload for testing the translation task, containing a literary text to be translated into French.

LANGUAGE: json
CODE:
{
  "text": "In the twilight of his years, the old clockmaker's hands, once steady as the timepieces he crafted, now trembled like autumn leaves in the wind.",
  "targetLanguage": "French"
}

----------------------------------------

TITLE: Base64 Encoding Google Credentials
DESCRIPTION: Command to convert Google credential JSON file to base64 format for secure storage.

LANGUAGE: bash
CODE:
base64 -i path/to/your/service-account-file.json

----------------------------------------

TITLE: Configuring Environment Variable Sync with Infisical
DESCRIPTION: Example configuration for syncing environment variables from Infisical to trigger.dev using the syncEnvVars build extension.

LANGUAGE: typescript
CODE:
import { defineConfig } from "@trigger.dev/sdk/v3";
import { syncEnvVars } from "@trigger.dev/build/extensions/core";
import { InfisicalSDK } from "@infisical/sdk";

export default defineConfig({
  build: {
    extensions: [
      syncEnvVars(async (ctx) => {
        const client = new InfisicalSDK();

        await client.auth().universalAuth.login({
          clientId: process.env.INFISICAL_CLIENT_ID!,
          clientSecret: process.env.INFISICAL_CLIENT_SECRET!,
        });

        const { secrets } = await client.secrets().listSecrets({
          environment: ctx.environment,
          projectId: process.env.INFISICAL_PROJECT_ID!,
        });

        return secrets.map((secret) => ({
          name: secret.secretKey,
          value: secret.secretValue,
        }));
      }),
    ],
  },
});

----------------------------------------

TITLE: Running the v3 CLI for trigger.dev
DESCRIPTION: Command to start the v3 CLI in development mode, which will output messages and start a background worker.

LANGUAGE: bash
CODE:
pnpm exec trigger dev

----------------------------------------

TITLE: Starting Next.js Development Server
DESCRIPTION: Commands to start the Next.js development server using different package managers including npm, yarn, pnpm, and bun. The server will run on localhost:3000 by default.

LANGUAGE: bash
CODE:
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev

----------------------------------------

TITLE: Starting Next.js Development Server
DESCRIPTION: Commands to start the Next.js development server using different package managers including npm, yarn, pnpm, and bun. The server will run on localhost:3000 by default.

LANGUAGE: bash
CODE:
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev

----------------------------------------

TITLE: Changing directory to v3-catalog
DESCRIPTION: Command to change the current directory to the v3-catalog folder.

LANGUAGE: bash
CODE:
cd references/v3-catalog

----------------------------------------

TITLE: Setting up Ngrok Authentication for Local Development
DESCRIPTION: Command for configuring Ngrok authentication token for local development tunneling

LANGUAGE: bash
CODE:
ngrok config add-authtoken <your-auth-token>