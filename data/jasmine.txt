TITLE: Defining a Jasmine Test Suite and Spec
DESCRIPTION: Shows how to create a basic test suite with a spec using the 'describe' and 'it' functions, along with an expectation using the 'expect' function.

LANGUAGE: javascript
CODE:
describe("A suite", function() {
    it("contains a spec with an expectation", function() {
        expect(true).toBe(true);
    });
});

----------------------------------------

TITLE: Handling Promise Failures in Jasmine Tests
DESCRIPTION: Illustrates how to handle failures when using promises in Jasmine tests. A rejected Promise will cause the spec to fail.

LANGUAGE: javascript
CODE:
beforeEach(function() {
  return somePromiseReturningFunction();
});

it('does a thing', function() {
  // Since `.then` propagates rejections, this test will fail if
  // the promise returned by asyncFunctionThatMightFail is rejected.
  return asyncFunctionThatMightFail().then(function(value) {
    // ...
  });
});

function somePromiseReturningFunction() {
  return new Promise(function(resolve, reject) {
    if (everythingIsOk()) {
      resolve();
    } else {
      reject();
    }
  });
}

----------------------------------------

TITLE: Handling Promise Failures in Jasmine Tests
DESCRIPTION: Illustrates how to handle failures when using promises in Jasmine tests. A rejected Promise will cause the spec to fail.

LANGUAGE: javascript
CODE:
beforeEach(function() {
  return somePromiseReturningFunction();
});

it('does a thing', function() {
  // Since `.then` propagates rejections, this test will fail if
  // the promise returned by asyncFunctionThatMightFail is rejected.
  return asyncFunctionThatMightFail().then(function(value) {
    // ...
  });
});

function somePromiseReturningFunction() {
  return new Promise(function(resolve, reject) {
    if (everythingIsOk()) {
      resolve();
    } else {
      reject();
    }
  });
}

----------------------------------------

TITLE: Testing Async Code with async/await in Jasmine
DESCRIPTION: Demonstrates how to use async/await for testing asynchronous code in Jasmine. This approach is often the most convenient for writing async tests.

LANGUAGE: javascript
CODE:
beforeEach(async function() {
  await someLongSetupFunction();
});

it('does a thing', async function() {
  const result = await someAsyncFunction();
  expect(result).toEqual(someExpectedValue);
});

----------------------------------------

TITLE: Asynchronous Testing in Jasmine
DESCRIPTION: Demonstrates how to write asynchronous tests in Jasmine using async/await syntax and setting custom timeouts for long-running tests.

LANGUAGE: javascript
CODE:
describe("Using async/await", function() {
    beforeEach(async function() {
        await soon();
        value = 0;
    });

    it("supports async execution of test preparation and expectations", async function() {
        await soon();
        value++;
        expect(value).toBeGreaterThan(0);
    });

    function soon() {
        return new Promise(function(resolve, reject) {
            setTimeout(function() {
                resolve();
            }, 1);
        });
    }
});

----------------------------------------

TITLE: Using Jasmine's beforeEach and afterEach Hooks
DESCRIPTION: Demonstrates how to use setup and teardown functions in Jasmine tests, including beforeEach, afterEach, beforeAll, and afterAll hooks.

LANGUAGE: javascript
CODE:
describe("A suite with some shared setup", function() {
    let foo = 0;

    beforeEach(function() {
        foo += 1;
    });

    afterEach(function() {
        foo = 0;
    });

    beforeAll(function() {
        foo = 1;
    });

    afterAll(function() {
        foo = 0;
    });
});

----------------------------------------

TITLE: Testing Async Code with Promises in Jasmine
DESCRIPTION: Shows how to use promises for testing asynchronous code in Jasmine. This method provides more control and can use either the built-in Promise type or a library.

LANGUAGE: javascript
CODE:
beforeEach(function() {
  return new Promise(function(resolve, reject) {
    // do something asynchronous
    resolve();
  });
});

it('does a thing', function() {
  return someAsyncFunction().then(function (result) {
    expect(result).toEqual(someExpectedValue);
  });
});

----------------------------------------

TITLE: Modern Async Test Implementation Using async/await in Jasmine
DESCRIPTION: Shows the recommended modern approach for handling async tests using async/await syntax, which provides cleaner and more reliable async test implementation.

LANGUAGE: javascript
CODE:
it('signals completion at the right time', async function() {
  await doSomethingAsync();
  doSomethingThatThrows();
});

----------------------------------------

TITLE: Testing Async Code with Callbacks in Jasmine
DESCRIPTION: Demonstrates how to use callbacks for testing asynchronous code in Jasmine. This is a lower-level mechanism useful for testing callback-based code.

LANGUAGE: javascript
CODE:
beforeEach(function(done) {
  setTimeout(function() {
    // do some stuff
    done();
  }, 100);
});


it('does a thing', function(done) {
  someAsyncFunction(function(result) {
    expect(result).toEqual(someExpectedValue);
    done();
  });
});

----------------------------------------

TITLE: Implementing a Custom Reporter in JavaScript for Jasmine
DESCRIPTION: This code snippet demonstrates the implementation of a custom reporter object for Jasmine. It includes methods for different stages of test execution such as suite and spec starts and completions, as well as overall test run start and completion. The reporter logs various details about the test execution to the console.

LANGUAGE: javascript
CODE:
const myReporter = {
  jasmineStarted: function(suiteInfo) {
    console.log('Running suite with ' + suiteInfo.totalSpecsDefined);
  },

  suiteStarted: function(result) {
    console.log('Suite started: ' + result.description
      + ' whose full description is: ' + result.fullName);
  },

  specStarted: async function(result) {
    await somethingAsync();
    console.log('Spec started: ' + result.description
      + ' whose full description is: ' + result.fullName);
  },

  specDone: function(result) {
    console.log('Spec: ' + result.description + ' was ' + result.status);

    for (const expectation of result.failedExpectations) {
      console.log('Failure: ' + expectation.message);
      console.log(expectation.stack);
    }

    console.log(result.passedExpectations.length);
  },

  suiteDone: function(result) {
    console.log('Suite: ' + result.description + ' was ' + result.status);
    for (const expectation of result.failedExpectations) {
      console.log('Suite ' + expectation.message);
      console.log(expectation.stack);
    }
  },

  jasmineDone: function(result) {
    console.log('Finished suite: ' + result.overallStatus);
    for (const expectation of result.failedExpectations) {
      console.log('Global ' + expectation.message);
      console.log(expectation.stack);
    }
  }
};

----------------------------------------

TITLE: Implementing Inline Describe/It Loops in Jasmine Tests
DESCRIPTION: Demonstrates using a for loop to generate multiple similar test blocks for different properties of an Element class. This approach helps avoid duplicate test code when testing multiple properties that should behave similarly.

LANGUAGE: javascript
CODE:
describe('Element', function() {
  beforeEach(function() {
    this.subject = new Element();
  });

  for (const name of ['x', 'y', 'width', 'height']) {
    describe(name, function() {
      it('returns a number', function() {
        expect(typeof this.subject[name]()).toBe('number');
      });
    });
  };
});

----------------------------------------

TITLE: Creating Reusable Test Behavior Functions in Jasmine
DESCRIPTION: Shows how to create a shared test behavior function that can be reused across multiple test suites. The example demonstrates testing common pet behaviors across different animal classes.

LANGUAGE: javascript
CODE:
function itActsLikeAPet() {
  it('can be fed', function() {
    this.subject.feed();
    expect(this.subject.hungry()).toBe(false);
  });

  it('can be watered', function() {
    this.subject.drink();
    expect(this.subject.thirsty()).toBe(false);
  });
}

describe('Dog', function() {
  beforeEach(function() {
    this.subject = new Dog();
  });

  itActsLikeAPet();

  it('can bark', function() {
    this.subject.bark();
  });
});

describe('Cat', function() {
  beforeEach(function() {
    this.subject = new Cat();
  });

  itActsLikeAPet();

  it('can meow', function() {
    this.subject.meow();
  });
});

----------------------------------------

TITLE: Configuring Jasmine in Node.js
DESCRIPTION: Example configuration file (jasmine.json) for specifying test files, helpers, and environment settings in a Jasmine project.

LANGUAGE: javascript
CODE:
{
  "spec_dir": "spec",
  "spec_files": [
    "**/*[sS]pec.?(m)js",
    "!**/*nospec.js"
  ],
  "helpers": [
    "helpers/**/*.?(m)js"
  ],
  "env": {
    "failSpecWithNoExpectations": false,
    "stopSpecOnExpectationFailure": false,
    "stopOnSpecFailure": false,
    "random": false
  }
}

----------------------------------------

TITLE: Registering Custom Equality Tester in Jasmine
DESCRIPTION: Shows how to register a custom equality tester in Jasmine using beforeEach hook and jasmine.addCustomEqualityTester method.

LANGUAGE: javascript
CODE:
beforeEach(function() {
  jasmine.addCustomEqualityTester(myCustomTester);
});

----------------------------------------

TITLE: Creating and Using Jasmine Spies
DESCRIPTION: Shows how to create and use spies in Jasmine for tracking function calls and arguments, including manual spy creation and spy objects.

LANGUAGE: javascript
CODE:
describe("A spy", function() {
    let foo, bar = null;

    beforeEach(function() {
        foo = {
            setBar: function(value) {
                bar = value;
            }
        };

        spyOn(foo, 'setBar');

        foo.setBar(123);
        foo.setBar(456, 'another param');
    });

    it("tracks that the spy was called", function() {
        expect(foo.setBar).toHaveBeenCalled();
    });
});

----------------------------------------

TITLE: Defining Custom Matcher Factory in JavaScript
DESCRIPTION: Creates a custom matcher named 'toBeGoofy' that checks if an object's 'hyuk' property matches the expected value. The matcher factory returns an object with a compare function that determines if the actual value is 'goofy' based on the criteria.

LANGUAGE: javascript
CODE:
const customMatchers = {
    toBeGoofy: function (matchersUtil) {
        return {
            compare: function (actual, expected) {
                if (expected === undefined) {
                    expected = '';
                }
                const result = {};
                result.pass = matchersUtil.equals(actual.hyuk,
                    "gawrsh" + expected);
                if (result.pass) {
                    result.message = "Expected " + actual +
                        " not to be quite so goofy";
                } else {
                    result.message = "Expected " + actual +
                        " to be goofy, but it was not very goofy";
                }
                return result;
            }
        }
    }
};

----------------------------------------

TITLE: Using Jasmine's Mock Clock for Time-based Async Tests
DESCRIPTION: Shows how to use Jasmine's mock clock to test time-based asynchronous operations synchronously. This approach can make tests easier to write and faster to run.

LANGUAGE: javascript
CODE:
function doSomethingLater(callback) {
  setTimeout(function() {
    callback(12345);
  }, 10000);
}

describe('doSomethingLater', function() {
  beforeEach(function() {
    jasmine.clock().install();
  });

  afterEach(function() {
    jasmine.clock().uninstall();
  });

  it('does something after 10 seconds', function() {
    const callback = jasmine.createSpy('callback');
    doSomethingLater(callback);
    jasmine.clock().tick(10000);
    expect(callback).toHaveBeenCalledWith(12345);
  });
});

----------------------------------------

TITLE: Handling Failures with async/await in Jasmine Tests
DESCRIPTION: Shows how to handle failures when using async/await in Jasmine tests. Failures can be indicated by returning a rejected promise or throwing an error.

LANGUAGE: javascript
CODE:
beforeEach(async function() {
  // Will fail if the promise returned by
  // someAsyncFunction is rejected.
  await someAsyncFunction();
});

it('does a thing', async function() {
  // Will fail if doSomethingThatMightThrow throws.
  doSomethingThatMightThrow();

  // Will fail if the promise returned by
  // asyncFunctionThatMightFail is rejected.
  const value = await asyncFunctionThatMightFail();
  // ...
});

----------------------------------------

TITLE: Using Jasmine Clock for Time-Dependent Tests
DESCRIPTION: Shows how to use Jasmine Clock to control time in tests, including mocking setTimeout, setInterval, and the Date object.

LANGUAGE: javascript
CODE:
describe("Manually ticking the Jasmine Clock", function() {
    let timerCallback;

    beforeEach(function() {
        timerCallback = jasmine.createSpy("timerCallback");
        jasmine.clock().install();
    });

    afterEach(function() {
        jasmine.clock().uninstall();
    });

    it("causes a timeout to be called synchronously", function() {
        setTimeout(function() {
            timerCallback();
        }, 100);

        expect(timerCallback).not.toHaveBeenCalled();

        jasmine.clock().tick(101);

        expect(timerCallback).toHaveBeenCalled();
    });
});

----------------------------------------

TITLE: Handling Failures with Callbacks in Jasmine Tests
DESCRIPTION: Demonstrates how to handle failures when using callbacks in Jasmine tests. The done function can be used to fail the spec using done.fail() or by passing an Error directly to done.

LANGUAGE: javascript
CODE:
beforeEach(function(done) {
  setTimeout(function() {
    try {
      riskyThing();
      done();
    } catch (e) {
      done.fail(e);
    }
  });
});

beforeEach(function(done) {
  setTimeout(function() {
    let err = null;

    try {
      riskyThing();
    } catch (e) {
      err = e;
    }

    done(err);
  });
});

----------------------------------------

TITLE: Setting Up AJAX Responses Ahead of Time
DESCRIPTION: Shows how to pre-define AJAX responses using jasmine.Ajax.stubRequest() for immediate response when a request is made.

LANGUAGE: javascript
CODE:
jasmine.Ajax.stubRequest('/another/url').andReturn({
    "responseText": 'immediate response'
});

const xhr = new XMLHttpRequest();
xhr.onreadystatechange = function(args) {
    if (this.readyState == this.DONE) {
        doneFn(this.responseText);
    }
};

xhr.open("GET", "/another/url");
xhr.send();

expect(doneFn).toHaveBeenCalledWith('immediate response');

----------------------------------------

TITLE: Creating Getter and Setter Spies in Jasmine
DESCRIPTION: This snippet demonstrates how to create spies for both getter and setter properties using spyOnProperty. It shows setting a return value for a getter spy and using callThrough for a setter spy.

LANGUAGE: javascript
CODE:
it("allows you to create spies for either type", function() {
  spyOnProperty(someObject, "myValue", "get").and.returnValue(30);
  spyOnProperty(someObject, "myValue", "set").and.callThrough();
});

----------------------------------------

TITLE: Using Custom Equality Testers in Jasmine Tests
DESCRIPTION: Demonstrates how to use custom equality testers in Jasmine test cases, including direct comparisons and nested equality checks.

LANGUAGE: javascript
CODE:
it('is equal using a custom tester', function () {
  expect('abc').toEqual(' a ');
});

it('is not equal using a custom tester', function () {
  expect('abc').not.toEqual('abc');
});

it('works even in nested equality tests', function () {
  expect(['abc', '123'].toEqual([' a ', ' 1 ']);
});

----------------------------------------

TITLE: Refactored Jasmine Test Setup with Helper Function
DESCRIPTION: Improved implementation that moves shared setup logic into a helper function and ensures each test explicitly controls its setup requirements. This approach provides better clarity and maintainability.

LANGUAGE: javascript
CODE:
describe('When the user is logged in', function() {
  it('does some things that apply to any user', function() {
    logIn(MyFixtures.anyUser);
    // ...
  });

  describe('as an admin', function() {
    beforeEach(function() {
      logIn(MyFixtures.adminUser);
    });

    it('shows the admin controls', function() {
      // ...
    });
  });

  describe('as a non-admin', function() {
    beforeEach(function() {
      logIn(MyFixtures.nonAdminUser);
    });

    it('does not show the admin controls', function() {
      // ...
    });
  });

  function logIn(user) {
    // Do something, potentially complicated, that causes the system to run
    // with `user` logged in.
  }
});

----------------------------------------

TITLE: Defining Custom Equality Tester Function in JavaScript
DESCRIPTION: Creates a custom equality tester function that compares two strings by checking if the first character of the first string matches the second character of the second string. Returns true/false for string comparisons or undefined for other types.

LANGUAGE: javascript
CODE:
function myCustomTester(first, second) {
  if (typeof first === 'string' && typeof second === 'string') {
    return first[0] === second[1];
  }
}

----------------------------------------

TITLE: Safe Spy Promise Rejection Using callFake
DESCRIPTION: Improved approach using callFake to create rejected promises only when the spy is called, preventing unhandled rejection errors.

LANGUAGE: javascript
CODE:
it('does not cause an unhandled promise rejection', async function() {
  const foo = jasmine.createSpy('foo')
    .and.callFake(() => Promise.reject(new Error('nope')));
  await expectAsync(doSomething(foo)).toBeRejected();
});

----------------------------------------

TITLE: Using Jasmine as a Library in Node.js
DESCRIPTION: Example of using Jasmine programmatically as a library, including configuration loading and execution.

LANGUAGE: javascript
CODE:
const Jasmine = require('jasmine');
const runner = new Jasmine();

runner.loadConfigFile('spec/support/jasmine.json');

runner.loadConfig({
    spec_dir: 'spec',
    spec_files: [
        'appSpec.js',
        'requests/**/*[sS]pec.js',
        'utils/**/*[sS]pec.js'
    ],
    helpers: [
        'helpers/**/*.js'
    ]
});

runner.configureDefaultReporter({
    timer: new jasmine.jasmine.Timer(),
    print: function() {
        process.stdout.write(arguments);
    },
    showColors: true
});

runner.execute();

----------------------------------------

TITLE: Initializing a Jasmine Project in Node.js
DESCRIPTION: Command to initialize a Jasmine project, creating a spec directory and configuration file.

LANGUAGE: sh
CODE:
npx jasmine init

----------------------------------------

TITLE: TypeScript Module Mocking Implementation
DESCRIPTION: Example of module mocking in TypeScript with CommonJS output.

LANGUAGE: typescript
CODE:
// aModule.ts
import {theString} from './anotherModule';

export function quote() {
    return '"' + theString() + '"';
}

LANGUAGE: typescript
CODE:
// aModuleSpec.ts
import "jasmine";
import {quote} from '../src/aModule';
import * as anotherModule from '../src/anotherModule';

describe('aModule', function() {
    describe('quote', function() {
        it('quotes the string returned by theString', function() {
            spyOn(anotherModule, 'theString').and.returnValue('a more different string');
            expect(quote()).toEqual('"a more different string"');
        });
    });
});

----------------------------------------

TITLE: Using IIFE to Wrap Async Function in Jasmine Test
DESCRIPTION: This snippet demonstrates how to use an Immediately Invoked Function Expression (IIFE) to wrap an async function in a Jasmine test, allowing the use of await with a callback.

LANGUAGE: javascript
CODE:
it('does something', function(done) {
  (async function () {
    const something = await doSomethingAsync();
    doSomethingElseAsync(something, function(result) {
      expect(result).toBe(/*...*/);
      done();
    });
  })();
});

----------------------------------------

TITLE: Generating Example Specs in Jasmine for Node.js
DESCRIPTION: Command to generate example spec and source files for a Jasmine project.

LANGUAGE: sh
CODE:
npx jasmine examples

----------------------------------------

TITLE: Implementing Parameterized Tests in Jasmine
DESCRIPTION: Demonstrates how to create parameterized tests in Jasmine by using an array of test cases and iterating through them with a for...of loop. The example tests an add function with multiple input combinations.

LANGUAGE: javascript
CODE:
function add(a, b) {
    return a + b;
}

describe('add', function() {
    const cases = [
        {first: 3, second: 3, sum: 6},
        {first: 10, second: 4, sum: 14},
        {first: 7, second: 1, sum: 8}
    ];

    for (const {first, second, sum} of cases) {
        it(`returns ${sum} for ${first} and ${second}`, function () {
            expect(add(first, second)).toEqual(sum);
        });
    }
});

----------------------------------------

TITLE: Using Jasmine-Ajax in a Single Spec with withMock
DESCRIPTION: Demonstrates how to use jasmine.Ajax.withMock() to mock AJAX calls within a single spec, automatically installing and uninstalling the mock.

LANGUAGE: javascript
CODE:
jasmine.Ajax.withMock(function() {
    const xhr = new XMLHttpRequest();
    xhr.onreadystatechange = function(args) {
        if (this.readyState == this.DONE) {
            doneFn(this.responseText);
        }
    };

    xhr.open("GET", "/some/cool/url");
    xhr.send();

    expect(doneFn).not.toHaveBeenCalled();

    jasmine.Ajax.requests.mostRecent().respondWith({
        "status": 200,
        "responseText": 'in spec response'
    });

    expect(doneFn).toHaveBeenCalledWith('in spec response');
});

----------------------------------------

TITLE: Installing and Uninstalling Jasmine-Ajax for Suite-Wide Usage
DESCRIPTION: Shows how to install jasmine-ajax in a beforeEach block and uninstall it in an afterEach block for suite-wide mocking of AJAX calls.

LANGUAGE: javascript
CODE:
beforeEach(function() {
    jasmine.Ajax.install();
});

afterEach(function() {
    jasmine.Ajax.uninstall();
});

----------------------------------------

TITLE: Preventing Unhandled Promise Rejection by Reordering Code
DESCRIPTION: This snippet demonstrates how to prevent the unhandled promise rejection by reordering the code. The rejection is handled immediately after creation, before any async operations.

LANGUAGE: javascript
CODE:
it('causes an unhandled rejection', async function() {
  const rejected = Promise.reject(new Error('nope'));
  let rejection;
  try {
    await rejected;
  } catch (e) {
    rejection = e;
  }
  await somethingAsync();
  // Do something with `rejection`
});

----------------------------------------

TITLE: Filtering Jasmine Specs in Node.js
DESCRIPTION: Commands for running specific specs by filename or name pattern using Jasmine CLI.

LANGUAGE: sh
CODE:
npx jasmine "spec/**/critical/*Spec.js"

LANGUAGE: sh
CODE:
npx jasmine spec/currentSpec.js

LANGUAGE: sh
CODE:
npx jasmine --filter "adapter21*"

----------------------------------------

TITLE: Mocking AJAX Requests and Specifying Responses
DESCRIPTION: Demonstrates how to make an AJAX request, mock its response, and test the outcome using jasmine-ajax. It shows how to specify the response status, content type, and response text.

LANGUAGE: javascript
CODE:
const xhr = new XMLHttpRequest();
xhr.onreadystatechange = function(args) {
    if (this.readyState == this.DONE) {
        doneFn(this.responseText);
    }
};

xhr.open("GET", "/some/cool/url");
xhr.send();

expect(jasmine.Ajax.requests.mostRecent().url)
    .toBe('/some/cool/url');
expect(doneFn).not.toHaveBeenCalled();

jasmine.Ajax.requests.mostRecent().respondWith({
    "status": 200,
    "contentType": 'text/plain',
    "responseText": 'awesome response'
});

expect(doneFn).toHaveBeenCalledWith('awesome response');

----------------------------------------

TITLE: Promise Rejection with Error Object Example
DESCRIPTION: Demonstrates how rejecting a Promise with an Error object enables Jasmine to display a stack trace. This is the recommended way to reject promises in tests when you want to trace the failure origin.

LANGUAGE: javascript
CODE:
Promise.reject(new Error("out of cheese"))

----------------------------------------

TITLE: Updating Env#execute Usage in JavaScript
DESCRIPTION: Demonstrates the change in how Env#execute is called in Jasmine 5.0, moving from a callback-based approach to an async/await pattern. This change affects users who directly call Env#execute or handle exceptions from it.

LANGUAGE: javascript
CODE:
try {
    env.execute(null, function () {
        // Handle completion
    });
} catch (e) {
    // Handle failures to start
}

LANGUAGE: javascript
CODE:
try {
    const jasmineDoneInfo = await env.execute();
} catch (e) {
    // Handle failures to start, which are now delivered via promise rejection
    // rather than synchronous throw
}

----------------------------------------

TITLE: Configuring Import Maps for Browser ES Modules
DESCRIPTION: Example of using import maps in jasmine-browser.json to override module resolution for mocking in browser environments.

LANGUAGE: json
CODE:
{
  "srcDir": "src",
  "importMap": {
    "moduleRootDir": "mockModules",
    "imports": {
      "anotherModule": "./anotherModule.mjs"
    }
  }
}

----------------------------------------

TITLE: Using throwUnless with waitFor in Jasmine Tests
DESCRIPTION: Shows how to properly assert conditions within testing-library's waitFor function using throwUnless instead of the standard Jasmine expect. This approach allows for proper asynchronous testing of DOM elements.

LANGUAGE: javascript
CODE:
await waitFor(function() {
    throwUnless(myDialogElement).toHaveClass('open');
});

----------------------------------------

TITLE: Testing loadThing Function with Jasmine Spies in JavaScript
DESCRIPTION: This snippet shows how to test the loadThing function using Jasmine spies. It includes two test cases: one to verify the correct URL is fetched, and another to ensure the response is stored correctly.

LANGUAGE: javascript
CODE:
describe('loadThing', function() {
  it('fetches the correct URL', function() {
    const fetch = jasmine.createSpy('fetch')
      .and.returnValue(new Promise(function() {}));

    loadThing(17, {}, fetch);

    expect(fetch).toHaveBeenCalledWith('http://example.com/api/things/17');
  });

  it('stores the thing', function() {
    const payload = {
      id: 17,
      name: 'the thing you requested'
    };
    const response = {
      json: function() {
        return payload;
      }
    };
    const thingStore = {};
    const fetch = jasmine.createSpy('fetch')
      .and.returnValue(Promise.resolve(response));

    loadThing(17, thingStore, fetch);

    expect(thingStore[17]).toEqual(payload);
  });
});

----------------------------------------

TITLE: Browser ES Module Implementation
DESCRIPTION: Implementation of source and mock modules for browser ES module testing.

LANGUAGE: javascript
CODE:
// src/anotherModule.mjs
export function theString() {
    return 'the string';
}

LANGUAGE: javascript
CODE:
// mockModules/anotherModule.mjs
export let theString = jasmine.createSpy('theString');

afterEach(function() {
    theString = jasmine.createSpy('theString');
});

----------------------------------------

TITLE: Configuring Jasmine in Ruby
DESCRIPTION: Demonstrates advanced Jasmine configuration options in Ruby, including rack handlers, server ports, and custom formatters.

LANGUAGE: ruby
CODE:
Jasmine.configure do |config|
  # You can add rack handlers for specific urls
  config.add_rack_path '/something' do
    [200]
  end
  # And mount other rack applications
  config.add_rack_app MyRackApp
  # You can configure the port that the `rake jasmine` command starts a server on
  config.server_port = 12345
  # You can configure the port that the `rake jasmine:ci` command starts it's server on
  config.ci_port = 54321
  # You can add [custom formatters](#section-Custom_Formatters)
  config.formatters << My::Custom::Formatter
  # You can use a [custom runner](#section-Custom_Runners)
  # The `runner` option on config should be a lambda or Proc that receives a formatter
  # and server url and returns a constructed runner object. The lambda allows you to
  # configure other options that need to be configured at initialization time.
  config.runner = lambda do |formatter, server_url|
    My::Custom::Runner.new(formatter, server_url, 100)
  end
end

----------------------------------------

TITLE: Updating Clock Tick Handling - JavaScript
DESCRIPTION: Demonstrates the correct way to handle clock ticks in Jasmine 4.0 without making reentrant calls.

LANGUAGE: javascript
CODE:
it('does not make a reentrant call to tick()', function() {
  const foo = jasmine.createSpy('foo');
  const bar = jasmine.createSpy('bar');

  setTimeout(function() {
    foo();
  }, 1);

  setTimeout(function() {
    bar();
  }, 10);

  jasmine.clock().tick(1);
  expect(foo).toHaveBeenCalled();
  jasmine.clock().tick(9);
  expect(bar).toHaveBeenCalled();
});

----------------------------------------

TITLE: CommonJS Module Mocking Implementation
DESCRIPTION: Example of module mocking in Node.js CommonJS environment without additional tools.

LANGUAGE: javascript
CODE:
// aModule.js
const anotherModule = require('./anotherModule.js');

function quote() {
    return '"' + anotherModule.theString() + '"';
}

module.exports = { quote };

LANGUAGE: javascript
CODE:
// aModuleSpec.js
const anotherModule = require('../anotherModule');
const subject = require('../aModule');

describe('aModule', function() {
    describe('quote', function () {
        it('quotes the string returned by theString', function () {
            spyOn(anotherModule, 'theString').and.returnValue('a more different string');
            expect(anotherModule.theString()).toEqual('a more different string');
            expect(subject.quote()).toEqual('"a more different string"');
        });
    });
});

----------------------------------------

TITLE: Installing Jasmine with npm in Node.js
DESCRIPTION: Commands for installing Jasmine locally or globally using npm. Local installation is recommended for better version control.

LANGUAGE: sh
CODE:
npm install --save-dev jasmine

LANGUAGE: sh
CODE:
npm install -g jasmine

----------------------------------------

TITLE: Using Custom Tester in Regular Assertions
DESCRIPTION: Illustrates how to use custom asymmetric equality testers in standard Jasmine equality checks, both with simple values and objects.

LANGUAGE: javascript
CODE:
expect(10).toEqual(multipleOf(5));

expect({ x: 3, y: 9 }).toEqual({ x: multipleOf(3), y: multipleOf(3) });

----------------------------------------

TITLE: Initializing jasmine-core without globals
DESCRIPTION: Shows how to initialize jasmine-core directly without global functions. Uses the noGlobals() method instead of boot().

LANGUAGE: javascript
CODE:
const jasmine = require('jasmine-core').noGlobals().jasmine;

----------------------------------------

TITLE: Setting failSpecWithNoExpectations in Jasmine Boot.js
DESCRIPTION: Configuration example for the standalone Jasmine distribution, showing how to set failSpecWithNoExpectations in the boot.js config object.

LANGUAGE: javascript
CODE:
{
  config: {
    failSpecWithNoExpectations: true
  }
}

----------------------------------------

TITLE: Demonstrating Unhandled Promise Rejection in Jasmine Test
DESCRIPTION: This snippet shows an async test that causes an unhandled promise rejection due to the order of operations. The rejection is created before an async operation, leading to the runtime detecting it as unhandled.

LANGUAGE: javascript
CODE:
it('causes an unhandled rejection', async function() {
  const rejected = Promise.reject(new Error('nope'));
  await somethingAsync();
  try {
    await rejected;
  } catch (e) {
    // Do something with the error
  }
});

----------------------------------------

TITLE: Importing Jasmine functions in spec files
DESCRIPTION: Demonstrates how to import Jasmine functions in spec and helper files when not using global functions. Uses destructuring assignment with the noGlobals() method.

LANGUAGE: javascript
CODE:
const {describe, beforeEach, it, expect, jasmine} = require('jasmine-core').noGlobals();

----------------------------------------

TITLE: Incorrect Nested BeforeEach Implementation in Jasmine
DESCRIPTION: Example showing problematic test setup pattern where inner describes attempt to override setup from outer describes. This approach doesn't work because inner beforeEach blocks run after outer ones.

LANGUAGE: javascript
CODE:
// DOES NOT WORK
describe('When the user is logged in', function() {
  let user = MyFixtures.anyUser

  beforeEach(function() {
    // Do something, potentially complicated, that causes the system to run
    // with `user` logged in.
  });

  it('does some things that apply to any user', function() {
    // ...
  });

  describe('as an admin', function() {
    beforeEach(function() {
      user = MyFixtures.adminUser;
    });

    it('shows the admin controls', function() {
      // ...
    });
  });

  describe('as a non-admin', function() {
    beforeEach(function() {
      user = MyFixtures.nonAdminUser;
    });

    it('does not show the admin controls', function() {
      // ...
    });
  });
});

----------------------------------------

TITLE: Incorrect Async Callback Testing Approach in JavaScript
DESCRIPTION: This snippet demonstrates an incorrect approach to testing async callbacks, which may pass even if the callback is never called.

LANGUAGE: javascript
CODE:
// WARNING: Does not work
it("calls the onData callback with the expected args", async function() {
  const subject = new DataFetcher();
  subject.onData(function(data) {
    expect(data).toEqual(expectedData);
  });

  await subject.fetch();
});

----------------------------------------

TITLE: Initializing Jasmine for parallel running without globals
DESCRIPTION: Demonstrates how to initialize Jasmine for parallel running without global functions. Uses ParallelRunner with numWorkers and globals options.

LANGUAGE: javascript
CODE:
const ParallelRunner = require('jasmine/parallel');
const runner = new ParallelRunner({
    numWorkers: 3,
    globals: false
});

----------------------------------------

TITLE: Writing Jasmine Tests with Multiple Expectations
DESCRIPTION: This snippet shows a Jasmine test with multiple expectations that can be difficult to debug due to similar failure messages.

LANGUAGE: javascript
CODE:
it('has multiple expectations', function() {
  expect(munge()).toEqual(1);
  expect(spindle()).toEqual(2);
  expect(frobnicate()).toEqual(3);
});

----------------------------------------

TITLE: Incorrect Testing of Multiple Async Signals in Jasmine
DESCRIPTION: This snippet illustrates an incorrect way of testing code that signals completion in multiple ways (promise and callback) in a Jasmine test.

LANGUAGE: javascript
CODE:
// WARNING: does not work correctly
it('provides the fetched data to observers', async function(done) {
  const fetch = function() {
    return Promise.resolve(/*...*/);
  };
  const subscriber = function(result) {
    expect(result).toEqual(/*...*/);
    done();
  };
  const subject = new DataLoader(fetch);

  subject.subscribe(subscriber);
  await subject.load(/*...*/);
});

----------------------------------------

TITLE: Implementing Custom Async Matcher in Jasmine
DESCRIPTION: Creates an asynchronous custom matcher 'toBeResolvedToGoofy' that checks if a promise resolves to an object with a 'goofy' hyuk property. The matcher handles promises and returns a promise that resolves to the comparison result.

LANGUAGE: javascript
CODE:
const customAsyncMatchers = {
    toBeResolvedToGoofy: function (matchersUtil) {
        return {
            compare: function (actualPromise, expected) {
                if (!actualPromise || typeof actualPromise.then !== 'function') {
                    throw new Error('Expected toBeResolvedToGoofy to be called on a promise.');
                }
                if (expected === undefined) {
                    expected = '';
                }
                return actualPromise.then(function (actual) {
                    const result = {};
                    result.pass = matchersUtil.equals(actual.hyuk, "gawrsh" + expected);
                    if (result.pass) {
                        result.message = "Expected a promise not to resolve to something quite so goofy";
                    } else {
                        result.message = "Expected a promise to resolve to something goofy, but it was not very goofy";
                    }
                    return result;
                });
            }
        }
    }
};

----------------------------------------

TITLE: Temporary Spy Strategy with Error Throwing in Jasmine
DESCRIPTION: Shows how to temporarily set and then remove a spy strategy that throws an error. The example creates spy objects with multiple methods and demonstrates error handling.

LANGUAGE: javascript
CODE:
it("throws if you call any methods", function() {
  jasmine.setDefaultSpyStrategy(and => and.throwError(new Error("Do Not Call Me")));
  const program = jasmine.createSpyObj(["start", "stop", "examine"]);
  jasmine.setDefaultSpyStrategy();

  expect(() => {
    program.start();
  }).toThrowError("Do Not Call Me");
});

----------------------------------------

TITLE: Potentially Problematic Spy Promise Rejection
DESCRIPTION: Example showing how creating a rejected promise directly can lead to unhandled promise rejection errors. This approach is not recommended as it may cause test failures.

LANGUAGE: javascript
CODE:
it('might cause an unhandled promise rejection', async function() {
  const foo = jasmine.createSpy('foo')
    .and.returnValue(Promise.reject(new Error('nope')));
  await expectAsync(doSomething(foo)).toBeRejected();
});

----------------------------------------

TITLE: Using Custom Async Matcher in Jasmine Tests
DESCRIPTION: Shows how to register and use the custom async matcher 'toBeResolvedToGoofy' in Jasmine test specs. The matcher is added using jasmine.addAsyncMatchers and then used with expectAsync to test promise resolutions.

LANGUAGE: javascript
CODE:
describe("Custom async matcher: 'toBeResolvedToGoofy'", function() {
    beforeEach(function() {
        jasmine.addAsyncMatchers(customAsyncMatchers);
    });

    it("is available on an expectation", async function() {
        await expectAsync(Promise.resolve({
            hyuk: 'gawrsh'
        })).toBeResolvedToGoofy();
    });

    it("can take an 'expected' parameter", async function() {
        await expectAsync(Promise.resolve({
            hyuk: 'gawrsh is fun'
        })).toBeResolvedToGoofy(' is fun');
    });

    it("can be negated", async function() {
        await expectAsync(Promise.resolve({
            hyuk: 'this is fun'
        })).not.toBeResolvedToGoofy();
    });
});

----------------------------------------

TITLE: TypeScript Configuration for Type Checking in Jasmine Tests
DESCRIPTION: Configuration setup for TypeScript with noEmit flag to enable type checking without file emission. This is commonly used alongside compile-on-the-fly approaches.

LANGUAGE: typescript
CODE:
{
  "noEmit": true
}

----------------------------------------

TITLE: Safely Checking Object Types in JavaScript
DESCRIPTION: These methods demonstrate how to safely check if an object is an instance of a type that might not exist in all environments. They are part of Jasmine's core functionality.

LANGUAGE: JavaScript
CODE:
function isAsymmetricEqualityTester(obj) {
  return obj && isA_('asymmetricMatch', obj);
}

function isSet(obj) {
  return obj && typeof Set !== 'undefined' && obj instanceof Set;
}

function isMap(obj) {
  return obj && typeof Map !== 'undefined' && obj instanceof Map;
}

function isTypedArray(obj) {
  return obj && typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer;
}

----------------------------------------

TITLE: Implementing Jasmine Test with Complex Objects
DESCRIPTION: Example test comparing arrays of cell objects in a Sudoku game implementation, demonstrating the need for custom formatting.

LANGUAGE: javascript
CODE:
it('compares some cells', function() {
    const expectedCells = [
        {correctValue: 4, entry: null},
        {correctValue: 1, entry: {pencil: true, numbers: [1, 2]}},
        {correctValue: 5, entry: {pencil: false, number: 3}}
    ];
    const actualCells = [
        {correctValue: 4, entry: null},
        {correctValue: 1, entry: {pencil: false, number: 2}},
        {correctValue: 5, entry: {pencil: false, number: 4}}
    ];

    expect(actualCells).toEqual(expectedCells);
});

----------------------------------------

TITLE: Running Jasmine in Continuous Integration
DESCRIPTION: This command runs Jasmine in a Continuous Integration environment.

LANGUAGE: sh
CODE:
jasmine ci

----------------------------------------

TITLE: Running Jasmine CI in Ruby
DESCRIPTION: Executes Jasmine tests in a CI environment, with options for randomization and seed specification.

LANGUAGE: sh
CODE:
rake jasmine:ci
rake jasmine:ci[true]
rake jasmine:ci[true,4321]

----------------------------------------

TITLE: Creating Custom Object Formatter Function
DESCRIPTION: Implementation of a custom formatter function that formats cell objects into a more readable string representation.

LANGUAGE: javascript
CODE:
function formatCell(val) {
    if (val.hasOwnProperty('entry') && val.hasOwnProperty('correctValue')) {
        const entries = val.entry.pencil
            ? 'pencil entries: ' + val.entry.numbers.join(',')
            : 'entry: ' + val.entry.number;

        return '<cell ' + entries + ', correct: ' + val.correctValue + '>';
    }
}

----------------------------------------

TITLE: Configuring External Scripts in Jasmine Browser Runner (JavaScript)
DESCRIPTION: This snippet shows how to include an external script URL (jQuery in this case) in the srcFiles configuration for jasmine-browser-runner. It also includes a wildcard pattern for local JavaScript files.

LANGUAGE: javascript
CODE:
  // ...
  srcFiles: [
    "https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.0/jquery.min.js",
    "**/*.js"
  ],
  // ...

----------------------------------------

TITLE: Updating node_boot.js Import in JavaScript
DESCRIPTION: Shows the change in how the boot function is imported from jasmine-core in Node.js environments. This mainly affects library authors who wrap jasmine-core for Node.js.

LANGUAGE: javascript
CODE:
const boot = require('jasmine-core/node_boot.js');

LANGUAGE: javascript
CODE:
const boot = require('jasmine-core').boot;

----------------------------------------

TITLE: Registering Custom Object Formatter
DESCRIPTION: Shows how to register a custom object formatter with Jasmine using beforeEach hook.

LANGUAGE: javascript
CODE:
beforeEach(function() {
    jasmine.addCustomObjectFormatter(formatCell);
});

----------------------------------------

TITLE: Configuring PhantomJS Runner in Jasmine YAML
DESCRIPTION: Shows YAML configuration options for the PhantomJS runner in Jasmine, including console log display and viewport size settings.

LANGUAGE: yaml
CODE:
show_console_log: true
phantom_config_script: 'relative/path/from/project/root.js'

----------------------------------------

TITLE: Overriding jasmine-core dependency in package.json for Karma
DESCRIPTION: This JSON snippet demonstrates how to use an NPM override in package.json to specify a newer version of jasmine-core for use with karma-jasmine. It overrides the default jasmine-core dependency to allow use of version 5.x or higher.

LANGUAGE: json
CODE:
{
    // ...
    "overrides": {
        "karma-jasmine": {
            "jasmine-core": "^5.0.0"
        }
    }
}

----------------------------------------

TITLE: Implementing Custom Matchers with Formatters
DESCRIPTION: Examples of correct and incorrect ways to implement custom matchers that work with custom object formatters.

LANGUAGE: javascript
CODE:
jasmine.addMatchers({
    // OK: Jasmine will format expected and actual correctly.
    toBeFoo: function (matchersUtil) {
        return {
            compare: function (actual, expected) {
                return {
                    pass: matchersUtil.equals(actual, expected)
                };
            }
        }
    },

    // OK: Uses pp to format expected and actual.
    toBeBar: function (matchersUtil) {
        return {
            compare: function (actual, expected) {
                return {
                    pass: matchersUtil.equals(actual, expected),
                    message: 'Expected ' + matchersUtil.pp(actual) + ' to be bar like ' + 
                        matchersUtil.pp(expected)
                };
            }
        }
    },

    // Won't use custom object formatters.
    toBeBaz: function (matchersUtil) {
        return {
            compare: function (actual, expected) {
                return {
                    pass: matchersUtil.equals(actual, expected),
                    message: 'Expected ' + actual + ' to be baz like ' + expected
                };
            }
        }
    }
});

----------------------------------------

TITLE: Handling CSS and Image Imports
DESCRIPTION: JavaScript configuration to ignore CSS and image imports during testing using ignore-styles package.

LANGUAGE: javascript
CODE:
import 'ignore-styles';

----------------------------------------

TITLE: Updating Jasmine API docs (Bash)
DESCRIPTION: Commands to update local copies of Jasmine and regenerate API documentation.

LANGUAGE: bash
CODE:
bundle exec rake update_edge_jasmine
bundle exec rake update_edge_jasmine_npm
bundle exec rake update_edge_jasmine_browser
npm run jsdoc
node locco.js
bundle exec rake serve

----------------------------------------

TITLE: Changing Spy Strategy with Reference in Jasmine
DESCRIPTION: This example shows how to save a reference to a property spy and change its strategy later. It demonstrates creating a getter spy in a beforeEach block and modifying its return value in a test.

LANGUAGE: javascript
CODE:
beforeEach(function() {
  this.propertySpy = spyOnProperty(someObject, "myValue", "get").and.returnValue(1);
});

it("lets you change the spy strategy later", function() {
  this.propertySpy.and.returnValue(3);
  expect(someObject.myValue).toEqual(3);
});

----------------------------------------

TITLE: Submitting changes to Jasmine docs (Bash)
DESCRIPTION: Git commands for committing changes and creating a pull request for Jasmine documentation updates.

LANGUAGE: bash
CODE:
git commit -am 'Add some docs'
git push origin my-new-docs

----------------------------------------

TITLE: Exporting Function with Module Import in TypeScript
DESCRIPTION: TypeScript code showing the import of a function from another module and its usage within an exported function.

LANGUAGE: javascript
CODE:
import {theString} from './anotherModule';

export function quote() {
    return '"' + theString() + '"';
}

----------------------------------------

TITLE: Changing Spy Strategy with Object.getOwnPropertyDescriptor in Jasmine
DESCRIPTION: This snippet illustrates how to change a property spy's strategy using Object.getOwnPropertyDescriptor. It's useful when saving a reference to the spy is not convenient.

LANGUAGE: javascript
CODE:
beforeEach(function() {
  spyOnProperty(someObject, "myValue", "get").and.returnValue(1);
});

it("lets you change the spy strategy later", function() {
  Object.getOwnPropertyDescriptor(someObject, "myValue").get.and.returnValue(3);
  expect(someObject.myValue).toEqual(3);
});

----------------------------------------

TITLE: Compiled JavaScript Output for Module Import and Function Export
DESCRIPTION: The compiled JavaScript output from TypeScript, showing how module imports and function exports are transformed for CommonJS.

LANGUAGE: javascript
CODE:
const anotherModule_1 = require("./anotherModule");
function quote() {
    return '"' + (0, anotherModule_1.theString)() + '"';
}
// ...

----------------------------------------

TITLE: Installing Dependencies and Running Tests in TypeScript Project
DESCRIPTION: Shell commands for installing dependencies, building the project, and running tests.

LANGUAGE: shell
CODE:
npm install
npm run build
npm test

----------------------------------------

TITLE: Creating Spy Object with Multiple Properties in Jasmine
DESCRIPTION: This example demonstrates creating a spy object with multiple properties using createSpyObj. It also shows how to change the spy strategy for a property using Object.getOwnPropertyDescriptor.

LANGUAGE: javascript
CODE:
it("creates a spy object with properties", function() {
  let obj = createSpyObj("myObject", {}, { x: 3, y: 4 });
  expect(obj.x).toEqual(3);

  Object.getOwnPropertyDescriptor(obj, "x").get.and.returnValue(7);
  expect(obj.x).toEqual(7);
});

----------------------------------------

TITLE: Configuring Jekyll Page Layout for Jasmine Docs
DESCRIPTION: Jekyll front matter configuration that sets the page layout to FAQ style for proper formatting of documentation content.

LANGUAGE: markdown
CODE:
---
layout: faq
---

----------------------------------------

TITLE: Apache License 2.0 Boilerplate Notice
DESCRIPTION: Standard boilerplate text for applying the Apache License 2.0 to software projects. This notice should be included in source files with appropriate comment syntax and project-specific information.

LANGUAGE: text
CODE:
Copyright [yyyy] [name of copyright owner]

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

----------------------------------------

TITLE: Testing Async Callbacks with Value Capture in JavaScript
DESCRIPTION: This snippet demonstrates how to test an async callback by capturing the received data and asserting it after the asynchronous operation completes.

LANGUAGE: javascript
CODE:
it("calls the onData callback with the expected args", async function() {
  const subject = new DataFetcher();
  let receivedData;
  subject.onData(function(data) {
    receivedData = data;
  });

  await subject.fetch();

  expect(receivedData).toEqual(expectedData);
});

----------------------------------------

TITLE: Apache License 2.0 Copyright Notice Template
DESCRIPTION: Standard copyright notice template for applying the Apache License 2.0 to a work. Fields in brackets should be replaced with actual information.

LANGUAGE: text
CODE:
Copyright [yyyy] [name of copyright owner]

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

----------------------------------------

TITLE: Apache License 2.0 Boilerplate Notice
DESCRIPTION: Standard boilerplate notice text to be included when applying the Apache License 2.0 to a work. Fields in brackets should be replaced with actual information.

LANGUAGE: text
CODE:
Copyright [yyyy] [name of copyright owner]

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

----------------------------------------

TITLE: Testing Async Callbacks with Jasmine Spy in JavaScript
DESCRIPTION: This snippet shows how to use a Jasmine spy to test an async callback, providing better failure messages.

LANGUAGE: javascript
CODE:
it("calls the onData callback with the expected args", async function() {
  const subject = new DataFetcher();
  const callback = jasmine.createSpy('onData callback');
  subject.onData(callback);

  await subject.fetch();

  expect(callback).toHaveBeenCalledWith(expectedData);
});

----------------------------------------

TITLE: Apache License 2.0 Boilerplate Notice
DESCRIPTION: Standard boilerplate text to apply the Apache License 2.0 to a software project. This notice should be included in source files with appropriate comment syntax and updated copyright information.

LANGUAGE: text
CODE:
Copyright [yyyy] [name of copyright owner]

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

----------------------------------------

TITLE: Another Incorrect Async Callback Testing Approach in JavaScript
DESCRIPTION: This snippet shows another incorrect method for testing async callbacks, which may cause spec execution to interleave with other specs and lead to misrouted errors.

LANGUAGE: javascript
CODE:
// WARNING: Does not work
it("calls the onData callback with the expected args", function(done) {
  const subject = new DataFetcher();
  subject.onData(function(data) {
    expect(data).toEqual(expectedData);
    done();
  });

  subject.fetch();
});

----------------------------------------

TITLE: Incorrect Async Test Implementation in Jasmine
DESCRIPTION: Examples of incorrect async test implementations that signal completion too early, leading to unreliable error reporting. Shows both synchronous and async callback variations that fail to properly handle asynchronous operations.

LANGUAGE: javascript
CODE:
// WARNING: does not work correctly
it('tries to be both sync and async', function() {
  // 1. doSomethingAsync() is called 
  doSomethingAsync(function() {
    // 3. The callback is called
    doSomethingThatMightThrow();
  });
  // 2. Spec returns, which tells Jasmine that it's done
});

// WARNING: does not work correctly
it('is async but signals completion too early', function(done) {
  // 1. doSomethingAsync() is called 
  doSomethingAsync(function() {
    // 3. The callback is called
    doSomethingThatThrows();
  });
  // 2. Spec calls done(), which tells Jasmine that it's done
  done();
});

----------------------------------------

TITLE: Correct Async Test Implementation with Callbacks in Jasmine
DESCRIPTION: Demonstrates the proper way to implement async tests using callbacks by ensuring the done() callback is called only after all async operations complete.

LANGUAGE: javascript
CODE:
it('signals completion at the right time', function(done) {
  // 1. doSomethingAsync() is called 
  doSomethingAsync(function() {
    // 2. The callback is called
    doSomethingThatThrows();
    // 3. If we get this far without an error being thrown, the spec calls
    // done(), which tells Jasmine that it's done
    done();
  });
});

----------------------------------------

TITLE: Incorrect Usage of Async Function with Callback in Jasmine
DESCRIPTION: This snippet demonstrates an incorrect way of combining async/await with a callback in a Jasmine test. It highlights the problem of using both a callback and an implicitly returned promise.

LANGUAGE: javascript
CODE:
// WARNING: does not work correctly
it('does something', async function(done) {
  const something = await doSomethingAsync();
  doSomethingElseAsync(something, function(result) {
    expect(result).toBe(/*...*/);
    done();
  });
});

----------------------------------------

TITLE: Correct Usage of Async/Await in Jasmine Test
DESCRIPTION: This snippet shows the correct way to use async/await in a Jasmine test. It converts the callback-based function to a promise and uses await to handle asynchronous operations.

LANGUAGE: javascript
CODE:
it('does something', async function(/* Note: no done param */) {
  const something = await doSomethingAsync();
  const result = await new Promise(function(resolve, reject) {
    doSomethingElseAsync(something, function(r) {
      resolve(r);
    });
  });
  expect(result).toBe(/*...*/);
});

----------------------------------------

TITLE: Using Promise Chaining in Jasmine Test
DESCRIPTION: This snippet shows how to use promise chaining with .then() instead of async/await in a Jasmine test, providing another way to handle asynchronous operations.

LANGUAGE: javascript
CODE:
it('does something', function(done) {
  doSomethingAsync().then(function(something) {
    doSomethingElseAsync(something, function(result) {
      expect(result).toBe(170);
      done();
    });
  });
});

----------------------------------------

TITLE: Correct Testing of Consistent Async Signals in Jasmine
DESCRIPTION: This snippet demonstrates the correct way to test code that consistently signals completion using promises in a Jasmine test. It uses async/await and jasmine.createSpy() for reliable asynchronous testing.

LANGUAGE: javascript
CODE:
it('provides the fetched data to observers', async function(/* Note: no done param */) {
  const fetch = function() {
    return Promise.resolve(/*...*/);
  };
  const subscriber = jasmine.createSpy('subscriber');
  const subject = new DataLoader(fetch);

  subject.subscribe(subscriber);
  // Await the returned promise. This will fail the spec if the promise
  // is rejected or isn't resolved before the spec timeout.
  await subject.load(/*...*/);
  // The subscriber should have been called by now. If not,
  // that's a bug in DataLoader, and we want the following to fail.
  expect(subscriber).toHaveBeenCalledWith(/*...*/);
});

----------------------------------------

TITLE: Implementing DataLoader Class in JavaScript
DESCRIPTION: This snippet defines a DataLoader class with methods for subscribing to success and error events, and a load method. It serves as the code under test.

LANGUAGE: javascript
CODE:
// in DataLoader.js
class DataLoader {
  constructor(fetch) {
    // ...
  }

  subscribe(subscriber) {
    // ...
  }

  onError(errorSubscriber) {
    // ...
  }

  load() {
    // ...
  }
}

----------------------------------------

TITLE: Testing Asynchronous DataLoader with Promise.race in Jasmine
DESCRIPTION: This snippet demonstrates how to test the DataLoader class using Jasmine. It uses Promise.race to handle both success and error callbacks, allowing the test to wait for either outcome.

LANGUAGE: javascript
CODE:
// in DataLoaderSpec.js
it('provides the fetched data to observers', async function() {
  const fetch = function() {
    return Promise.resolve(/*...*/);
  };
  let resolveSubscriberPromise, rejectErrorPromise;
  const subscriberPromise = new Promise(function(resolve) {
    resolveSubscriberPromise = resolve;
  });
  const errorPromise = new Promise(function(resolve, reject) {
    rejectErrorPromise = reject;
  });
  const subject = new DataLoader(fetch);

  subject.subscribe(resolveSubscriberPromise);
  subject.onError(rejectErrorPromise);
  const result = await Promise.race([subscriberPromise, errorPromise]);

  expect(result).toEqual(/*...*/);
});

----------------------------------------

TITLE: Incorrect Usage of Async Function with describe() in Jasmine
DESCRIPTION: This code snippet demonstrates an incorrect attempt to use an async function with Jasmine's describe() method. It's shown as a warning of what not to do when trying to generate specs from asynchronously loaded data.

LANGUAGE: javascript
CODE:
// WARNING: does not work
describe('Something', async function() {
   const scenarios = await fetchSceanrios();
   
   for (const scenario of scenarios) {
       it(scenario.name, function() {
           // ...
       });
   }
});

----------------------------------------

TITLE: Correct Asynchronous Test Generation in Jasmine using ES Modules
DESCRIPTION: This code snippet shows the correct way to generate test specs from asynchronously loaded data in Jasmine. It uses top-level await to fetch scenarios before calling describe(), which allows for dynamic test generation based on the fetched data.

LANGUAGE: javascript
CODE:
const scenarios = await fetchSceanrios();

describe('Something', function() {
   for (const scenario of scenarios) {
       it(scenario.name, function() {
           // ...
       });
   }
});

----------------------------------------

TITLE: Testing Async Behavior with Immediate Resolution in Jasmine
DESCRIPTION: This snippet demonstrates how to test a React component that fetches data asynchronously using Enzyme and Jasmine-Enzyme. It shows how to mock the API client, render the component, and assert the expected behavior after the async operation completes.

LANGUAGE: javascript
CODE:
describe('When data is fetched', () => {
  it('renders the data list with the result', async () => {
    const payload = [/*...*/];
    const apiClient = {
      getData: () => Promise.resolve(payload);
    };

    // Render the component under test
    const subject = mount(<DataLoader apiClient={apiClient} />);
    
    // Wait until after anything that's already queued
    await Promise.resolve();
    subject.update();

    const dataList = subject.find(DataList);
    expect(dataList).toExist();
    expect(dataList).toHaveProp('data', payload);
  });
});

----------------------------------------

TITLE: Testing Async Behavior with Polling in Jasmine
DESCRIPTION: This snippet illustrates an alternative approach to testing async behavior by polling until the desired component is rendered. It uses a custom polling function to repeatedly check for the presence of a specific component, making it more resilient to changes in the async flow of the code under test.

LANGUAGE: javascript
CODE:
describe('When data is fetched', () => {
  it('renders the data list with the result', async () => {
    const payload = [/*...*/];
    const apiClient = {
      getData: () => Promise.resolve(payload);
    };

    // Render the component under test
    const subject = mount(<DataLoader apiClient={apiClient} />);

    // Wait until the DataList is rendered
    const dataList = await new Promise(resolve => {
      function poll() {
        subject.update();
        const target = subject.find(DataList);

        if (target.exists()) {
          resolve(target);
        } else {
          setTimeout(poll, 50);
        }
      }
      poll();
    });
    
    expect(dataList).toHaveProp('data', payload);
  });
});

----------------------------------------

TITLE: Configuring Jasmine to Stop on First Expectation Failure
DESCRIPTION: This snippet shows how to configure Jasmine to stop a spec at the first expectation failure by setting the 'oneFailurePerSpec' or 'stopSpecOnExpectationFailure' option to true. The exact method depends on how Jasmine is being used in the project.

LANGUAGE: javascript
CODE:
// For standalone distribution: Edit boot.js or use UI option
// For jasmine NPM package: In spec/support/jasmine.json
{
  "stopSpecOnExpectationFailure": true
}

// For jasmine-core direct usage:
Env.configure({
  oneFailurePerSpec: true
});

----------------------------------------

TITLE: Demonstrating Error Object Usage in Jasmine Tests
DESCRIPTION: Shows contrasting examples of throwing and rejecting promises with both non-Error values (which won't show stack traces) and Error objects (which will show stack traces). Demonstrates the recommended approach for error handling in Jasmine tests.

LANGUAGE: javascript
CODE:
// NOT RECOMMENDED
describe('Failures that will not have stack traces', function() {
  it('throws a non-Error', function() {
    throw 'nope';
  });

  it('rejects with a non-Error', function() {
    return Promise.reject('nope');
  });
});

// RECOMMENDED
describe('Failures that will have stack traces', function() {
  it('throws an Error', function() {
    throw new Error('nope');
  });

  it('rejects with an Error', function() {
    return Promise.reject(new Error('nope'));
  });
});

----------------------------------------

TITLE: Using Jasmine's withContext for Clearer Failure Messages
DESCRIPTION: This snippet demonstrates how to use Jasmine's 'withContext' method to add extra context to matcher failure messages, making it easier to identify which expectation failed.

LANGUAGE: javascript
CODE:
it('has multiple expectations with some context', function() {
  expect(munge()).withContext('munge').toEqual(1);
  expect(spindle()).withContext('spindle').toEqual(2);
  expect(frobnicate()).withContext('frobnicate').toEqual(3);
});

----------------------------------------

TITLE: Implementing loadThing Function with Fetch in JavaScript
DESCRIPTION: This snippet demonstrates how to implement a loadThing function that uses fetch to make an HTTP request. The function takes a thingId, thingStore, and fetch as parameters, allowing for easy mocking in tests.

LANGUAGE: javascript
CODE:
async function loadThing(thingId, thingStore, fetch) {
  const url = `http://example.com/api/things/{id}`;
  const response = await fetch(url);
  thingStore[thingId] = response.json();
}

// somewhere else
await loadThing(thingId, thingStore, fetch);

----------------------------------------

TITLE: Testing localStorage with spyOn in Jasmine
DESCRIPTION: Example showing a problematic approach to testing localStorage using spyOn, which fails in Firefox and Safari 17 due to browser security measures preventing property overwrites on localStorage.

LANGUAGE: javascript
CODE:
it('sets foo to bar on localStorage', function() {
    spyOn(localStorage, 'setItem');
    localStorage.setItem('foo', 'bar');
    expect(localStorage.setItem).toHaveBeenCalledWith('foo', 'bar');
});

----------------------------------------

TITLE: Testing localStorage State in Jasmine
DESCRIPTION: Alternative approach to testing localStorage by checking its state directly using getItem instead of spying on method calls. This approach works across all browsers.

LANGUAGE: javascript
CODE:
it('sets foo to bar on localStorage', function() {
   localStorage.setItem('foo', 'bar');
   expect(localStorage.getItem('foo')).toEqual('bar');
});

----------------------------------------

TITLE: Safe Spy Promise Rejection Using rejectWith
DESCRIPTION: Clearest approach using the dedicated rejectWith spy strategy to handle promise rejections in tests.

LANGUAGE: javascript
CODE:
it('does not cause an unhandled promise rejection', async function() {
  const foo = jasmine.createSpy('foo')
    .and.rejectWith(new Error('nope'));
  await expectAsync(doSomething(foo)).toBeRejected();
});

----------------------------------------

TITLE: Installing Jasmine using pip
DESCRIPTION: This command installs Jasmine using pip, the Python package installer.

LANGUAGE: sh
CODE:
pip install jasmine

----------------------------------------

TITLE: Initializing a Jasmine project
DESCRIPTION: This command initializes a new Jasmine project by creating a spec directory and configuration YAML file.

LANGUAGE: sh
CODE:
jasmine init

----------------------------------------

TITLE: Starting the Jasmine server
DESCRIPTION: This command starts the Jasmine server on the default port 8888.

LANGUAGE: sh
CODE:
jasmine server

----------------------------------------

TITLE: Starting Jasmine server on a custom port
DESCRIPTION: This command starts the Jasmine server on a custom port (1337) using the -p flag.

LANGUAGE: sh
CODE:
jasmine server -p 1337

----------------------------------------

TITLE: Setting browser for Jasmine CI using environment variable
DESCRIPTION: This command sets the browser for Jasmine CI using an environment variable.

LANGUAGE: sh
CODE:
export JASMINE_BROWSER=chrome
jasmine ci

----------------------------------------

TITLE: Setting browser for Jasmine CI using command-line flag
DESCRIPTION: This command sets the browser for Jasmine CI using a command-line flag.

LANGUAGE: sh
CODE:
jasmine ci --browser firefox

----------------------------------------

TITLE: Running Jasmine CI with a specific seed
DESCRIPTION: This command runs Jasmine CI with a specific randomization seed for debugging purposes.

LANGUAGE: sh
CODE:
jasmine ci --seed 4321

----------------------------------------

TITLE: Installing Jasmine Gem in Ruby
DESCRIPTION: Adds the Jasmine gem to the project's Gemfile for installation via Bundler.

LANGUAGE: ruby
CODE:
gem 'jasmine'

----------------------------------------

TITLE: Installing Jasmine in Rails Project
DESCRIPTION: Generates default Jasmine configuration files in a Rails project using a Rails generator.

LANGUAGE: sh
CODE:
rails g jasmine:install

----------------------------------------

TITLE: Installing Jasmine in Non-Rails Ruby Project
DESCRIPTION: Initializes Jasmine in a non-Rails Ruby project using the Jasmine command-line tool.

LANGUAGE: sh
CODE:
jasmine init

----------------------------------------

TITLE: Installing Jasmine Example Specs
DESCRIPTION: Generates example Jasmine specs and implementations in Rails and non-Rails projects.

LANGUAGE: sh
CODE:
rails g jasmine:examples
jasmine examples

----------------------------------------

TITLE: Running Jasmine Server in Ruby
DESCRIPTION: Starts a Jasmine server for continuous testing in a browser environment.

LANGUAGE: sh
CODE:
rake jasmine

----------------------------------------

TITLE: Configuring PhantomJS Page Object in JavaScript
DESCRIPTION: Demonstrates how to configure the PhantomJS page object for Jasmine tests, setting viewport size.

LANGUAGE: javascript
CODE:
exports.configure = function(page) {
  page.viewportSize = {
    width: 340,
    height: 220
  };
};

----------------------------------------

TITLE: Implementing Custom Formatter for Jasmine in Ruby
DESCRIPTION: Shows how to create a custom formatter for Jasmine CI output in Ruby, implementing 'format' and 'done' methods.

LANGUAGE: ruby
CODE:
class My::Custom::Formatter
  # `format` is called by the runner every time it gets a batch of results from the page.
  # The parameter will be an array of `Jasmine::Result` objects
  def format(results)
    results.each do |result|
      puts result.status
    end
  end

  # `done` will be called by the runner after all results have come in.
  def done
    puts 'Done running tests'
  end
end

----------------------------------------

TITLE: Implementing Custom Runner for Jasmine in Ruby
DESCRIPTION: Demonstrates how to create a custom runner for Jasmine CI in Ruby, using PhantomJS to execute tests and process results.

LANGUAGE: ruby
CODE:
class My::Custom::Runner
  def initialize(formatter, jasmine_server_url, result_batch_size)
    # The formatter passed in is responsible for making sure all configured
    # formatters receive the same messages.
    @formatter = formatter
    # The `jasmine_server_url` is the full http://<host>:<port> url where
    # the jasmine server was started
    @jasmine_server_url = jasmine_server_url
    @result_batch_size = result_batch_size
  end

  # `run` is responsible coordinating the test run.
  def run
    # Here we're using Phantom to load the page and run the specs
    command = "#{Phantomjs.path} 'phantom_run.js' #{@jasmine_server_url} #{@result_batch_size}"
    IO.popen(command) do |output|
      # The `phantom_jasmine_run.js` script writes out batches of results as JSON
      output.each do |line|
        raw_results = JSON.parse(line, :max_nesting => false)
        # Formatters expect to get `Jasmine::Result` objects.
        # It is the runner's job to convert the result objects from the page,
        # and pass them to the `format` method of their formatter.
        results = raw_results.map { |r| Result.new(r) }
        @formatter.format(results)
      end
    end
    # When the tests have finished, call `done` on the formatter to run any
    # necessary completion logic.
    @formatter.done
  end

  # If the runner needs some javascript to be loaded into the page as part of the load,
  # it returns the full path in `boot_js`
  def boot_js
    File.expand_path('runner_boot.js', __FILE__)
  end
end

----------------------------------------

TITLE: Running Jasmine Specs in Node.js
DESCRIPTION: Commands for running all specs, specific spec files, or specs matching a glob pattern using Jasmine CLI.

LANGUAGE: sh
CODE:
npx jasmine spec/appSpec.js

LANGUAGE: sh
CODE:
npx jasmine "**/model/**/critical/**/*Spec.js"

----------------------------------------

TITLE: Setting up local environment for Jasmine docs (Bash)
DESCRIPTION: Steps to prepare the local environment for contributing to Jasmine documentation. Includes forking the repo, creating a feature branch, and installing dependencies.

LANGUAGE: bash
CODE:
git checkout -b my-new-docs
gem install bundler
bundle
bundle install --path vendor/bundle
npm install

----------------------------------------

TITLE: Setting up GitHub Pages for Jasmine docs demo (Bash)
DESCRIPTION: Steps to create a gh-pages branch and push it to GitHub for setting up a live demo of documentation changes.

LANGUAGE: bash
CODE:
git checkout master
git checkout -b gh-pages
git push -u origin HEAD

----------------------------------------

TITLE: Updating GitHub Pages demo for Jasmine docs (Bash)
DESCRIPTION: Commands to update the gh-pages branch with the latest changes from a feature branch for demonstrating documentation updates.

LANGUAGE: bash
CODE:
git checkout gh-pages
git reset --hard my-complicated-change
git push -f

----------------------------------------

TITLE: HTML Structure for Jasmine 3.0 Upgrade Documentation
DESCRIPTION: HTML markup that creates the upgrade guide page title and provides a link to the official release notes on GitHub.

LANGUAGE: html
CODE:
<h1>Upgrading to Jasmine 3.0</h1>

See the 
<a href="https://github.com/jasmine/jasmine/blob/main/release_notes/3.0.md">jasmine-core 3.0 release notes</a>
for information about upgrading to Jasmine 3.0.

----------------------------------------

TITLE: Fixing BeforeEach Suite Cleanup Example - JavaScript
DESCRIPTION: Demonstrates how to properly structure beforeEach and afterEach cleanup to avoid test pollution when failures occur.

LANGUAGE: javascript
CODE:
describe('Outer suite', function() {
  beforeEach(function() {
    setSomeGlobalState();
    possiblyFail();
  });

  describe('inner suite', function() {
    it('does something', function() { /*...*/ });

    // This afterEach function should be moved up to the outer suite.
    afterEach(function() {
      cleanUpTheGlobalState();
    });
  });
});

----------------------------------------

TITLE: Updating Custom Matchers - JavaScript
DESCRIPTION: Shows how to update custom matchers to handle custom equality testers in the new style for Jasmine 4.0.

LANGUAGE: javascript
CODE:
jasmine.addMatchers({
  toContain42: function(matchersUtil) {
    return {
      compare: function(actual, expected) {
        return {
          pass: matchersUtil.contains(actual, 42)
        };
      }
    };
  }
});

----------------------------------------

TITLE: Apache License 2.0 Boilerplate Notice
DESCRIPTION: Standard boilerplate notice text to be included when applying the Apache License 2.0 to a work. Fields in brackets should be replaced with appropriate identifying information.

LANGUAGE: text
CODE:
Copyright [yyyy] [name of copyright owner]

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

----------------------------------------

TITLE: Apache License 2.0 Boilerplate Notice Template
DESCRIPTION: Standard boilerplate notice template for applying the Apache License to new works. Includes placeholders for copyright year and owner information.

LANGUAGE: text
CODE:
Copyright [yyyy] [name of copyright owner]

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

----------------------------------------

TITLE: Applying Apache License 2.0 Boilerplate Notice
DESCRIPTION: Standard boilerplate notice text for applying the Apache License 2.0 to a work. Replace bracketed fields with actual copyright information.

LANGUAGE: text
CODE:
Copyright [yyyy] [name of copyright owner]

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

----------------------------------------

TITLE: Apache License 2.0 Boilerplate Notice Template
DESCRIPTION: Standard boilerplate notice text for applying the Apache License to a work, including placeholders for copyright information.

LANGUAGE: text
CODE:
Copyright [yyyy] [name of copyright owner]

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

----------------------------------------

TITLE: Installing and Running Jasmine Tests with npm
DESCRIPTION: Commands for installing dependencies and running tests in a Node.js project using npm. These commands set up the testing environment and execute the test suite.

LANGUAGE: shell
CODE:
npm install
npm test

----------------------------------------

TITLE: Installing and Running TestDouble with Jasmine
DESCRIPTION: Basic npm commands to install dependencies and run tests. Requires Node.js with ES modules support and TestDouble loader configuration.

LANGUAGE: shell
CODE:
npm install
npm test

----------------------------------------

TITLE: Building and Running TestDouble with TypeScript and ES Modules
DESCRIPTION: Commands to install dependencies, build the project, and run tests for a TestDouble setup with TypeScript and ES modules.

LANGUAGE: shell
CODE:
npm install
npm run build
npm test

----------------------------------------

TITLE: Installing and Running Jasmine Tests with npm
DESCRIPTION: These commands install the necessary dependencies and run the Jasmine tests. The test command assumes Firefox and GeckoDriver are installed, while an alternative serve command is provided for other browsers.

LANGUAGE: shell
CODE:
npm install
npm test

----------------------------------------

TITLE: Installing and Running Tests for TestDouble Module Mocking in Node.js
DESCRIPTION: This snippet shows the shell commands to install dependencies and run tests for the TestDouble module mocking example. It uses npm for package management and test execution.

LANGUAGE: shell
CODE:
npm install
npm test

----------------------------------------

TITLE: Resolving npm Audit Warnings for Jasmine Dependencies
DESCRIPTION: Common terminal commands to resolve npm audit warnings by updating packages or regenerating the package lock file. These commands include npm audit fix, npm update for specific packages, or recreating package-lock.json.

LANGUAGE: bash
CODE:
npm audit fix
npm update <name of package>
rm package-lock.json && npm install

----------------------------------------

TITLE: Demonstrating JSDoc Comment Syntax in JavaScript
DESCRIPTION: This snippet shows the syntax for a JSDoc comment. These comments start with '/**' and are used for documenting public interfaces in Jasmine.

LANGUAGE: javascript
CODE:
/**

----------------------------------------

TITLE: Checking for URL Support in JavaScript
DESCRIPTION: This snippet demonstrates how to check for the presence of the URL constructor in the environment. It's used to conditionally run tests that depend on URL functionality.

LANGUAGE: JavaScript
CODE:
function hasUrl() {
  if (typeof URL === 'function') {
    try {
      new URL('http://localhost');
      return true;
    } catch (e) {
      return false;
    }
  }
  return false;
}

function requireUrls() {
  return hasUrl() ? it : xit;
}

----------------------------------------

TITLE: Browser Module Script Configuration - HTML
DESCRIPTION: HTML script tag configuration for testing ES modules in browser-based Jasmine setups

LANGUAGE: html
CODE:
<script type="module">

----------------------------------------

TITLE: NPM Package Module Configuration - JSON
DESCRIPTION: Package.json configuration to enable ES module support in NPM-based Jasmine setups

LANGUAGE: json
CODE:
"type": "module"

----------------------------------------

TITLE: Configuring failSpecWithNoExpectations in Jasmine JSON Config
DESCRIPTION: Example configuration in jasmine.json to make specs fail when they contain no expectations. This setting can be added to spec/support/jasmine.json when using the jasmine NPM package.

LANGUAGE: json
CODE:
{
  "failSpecWithNoExpectations": true
}

----------------------------------------

TITLE: Implementing Safe Multiple Done Calls in Jasmine Tests (JavaScript)
DESCRIPTION: This code snippet demonstrates how to wrap the `done` callback to ignore all but the first call, mimicking the behavior of Jasmine 2-3. It includes a helper function `allowUnsafeMultipleDone` and an example test case that calls `done` twice.

LANGUAGE: javascript
CODE:
function allowUnsafeMultipleDone(fn) {
  return function(done) {
    let doneCalled = false;
    fn(function(err) {
      if (!doneCalled) {
        done(err);
        doneCalled = true;
      }
    });
  }
}

it('calls done twice', allowUnsafeMultipleDone(function(done) {
  setTimeout(done);
  setTimeout(function() {
    // This code may interleave with subsequent specs or even run after Jasmine
    // has finished executing.
    done();
  }, 50);
}));

----------------------------------------

TITLE: Using Custom Tester with Jasmine Spies
DESCRIPTION: Demonstrates how to use the custom asymmetric equality tester with Jasmine spies to verify function calls with specific numeric parameters.

LANGUAGE: javascript
CODE:
spyOn(Buffer, 'alloc').and.callThrough();

Buffer.alloc(2048);

expect(Buffer.alloc).toHaveBeenCalledWith(multipleOf(1024));

----------------------------------------

TITLE: Nesting Custom Tester in Objects
DESCRIPTION: Shows how to use custom asymmetric equality testers within objects alongside Jasmine's built-in testers like jasmine.any().

LANGUAGE: javascript
CODE:
spyOn(request, 'post');

request.post({ name: 'Jan Jansen', age: 40 });

expect(request.post).toHaveBeenCalledWith({ name: jasmine.any(String), age: multipleOf(10) });