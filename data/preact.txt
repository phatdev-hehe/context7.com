TITLE: Creating Functional Components in Preact
DESCRIPTION: Demonstrates how to create a basic functional component that receives props and renders content. Shows proper naming convention with uppercase first letter.

LANGUAGE: jsx
CODE:
function MyComponent(props) {
  return <div>My name is {props.name}.</div>;
}

// Usage
const App = <MyComponent name="John Doe" />;

// Renders: <div>My name is John Doe.</div>
render(App, document.body);

----------------------------------------

TITLE: Basic Preact Usage Without Build Tools
DESCRIPTION: Simple example showing how to use Preact directly in the browser without any build tools using ES modules.

LANGUAGE: html
CODE:
<script type="module">
  import { h, render } from 'https://esm.sh/preact';

  // Create your app
  const app = h('h1', null, 'Hello World!');

  render(app, document.body);
</script>

----------------------------------------

TITLE: Using useState Hook for State Management in Preact
DESCRIPTION: This snippet shows how to use the useState hook to manage state in a functional component, including increment and decrement functions.

LANGUAGE: jsx
CODE:
const Counter = () => {
  const [count, setCount] = useState(0);
  const increment = () => setCount(count + 1);
  const decrement = () => setCount((currentCount) => currentCount - 1);

  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increment}>Increment</button>
      <button onClick={decrement}>Decrement</button>
    </div>
  )
}

----------------------------------------

TITLE: Building Todo Application with Preact Hooks and Local Storage
DESCRIPTION: A complete Todo application implementation using Preact hooks (useState, useEffect) with local storage persistence. The application supports adding new todos, toggling their completion status, and maintains state across page reloads using localStorage.

LANGUAGE: jsx
CODE:
import { render } from 'preact';
import { useState, useEffect } from 'preact/hooks'

const getTodos = async () => {
  try {
    return JSON.parse(localStorage.todos)
  } catch (e) {
    return [
      { id: 1, text: 'learn Preact', done: true },
      { id: 2, text: 'make an awesome app', done: false },
    ]
  }
}

function ToDos() {
  const [todos, setTodos] = useState([])

  useEffect(() => {
    getTodos().then(todos => {
      setTodos(todos)
    })
  }, [])

  useEffect(() => {
    localStorage.todos = JSON.stringify(todos)
  }, [todos])

  function toggle(id) {
    setTodos(todos => {
      return todos.map(todo => {
        if (todo.id === id) {
          todo = { ...todo, done: !todo.done }
        }
        return todo
      })
    })
  }

  function addTodo(e) {
    e.preventDefault()
    const form = e.target
    const text = form.todo.value
    setTodos(todos => {
      const id = todos.length + 1
      const newTodo = { id, text, done: false }
      return todos.concat(newTodo)
    })
    form.reset()
  }

  return (
    <div>
      <ul style={{ listStyle: 'none', padding: 0 }}>
        {todos.map(todo => (
          <li key={todo.id}>
            <label style={{ display: 'block' }}>
              <input type="checkbox" checked={todo.done} onClick={() => toggle(todo.id)} />
              {' ' + todo.text}
            </label>
          </li>
        ))}
      </ul>
      <form onSubmit={addTodo}>
        <input name="todo" placeholder="Add ToDo [enter]" />
      </form>
    </div>
  )
}

render(<ToDos />, document.getElementById("app"));

----------------------------------------

TITLE: Rendering a Preact Component to the DOM
DESCRIPTION: Demonstrates how to use the render() function to insert a Preact component into the DOM tree.

LANGUAGE: jsx
CODE:
// --repl
// DOM tree before render:
// <div id="container"></div>

import { render } from 'preact';

const Foo = () => <div>foo</div>;

render(<Foo />, document.getElementById('container'));

// After render:
// <div id="container">
//  <div>foo</div>
// </div>

----------------------------------------

TITLE: Defining a Preact Component in JavaScript
DESCRIPTION: Demonstrates how to import and extend the Component class to create a stateful Preact component.

LANGUAGE: javascript
CODE:
import { Component } from 'preact';

class MyComponent extends Component {
  // (see below)
}

----------------------------------------

TITLE: Creating and Rendering a Virtual DOM Element with JSX
DESCRIPTION: Demonstrates how to use JSX syntax to create a Virtual DOM element and render it, equivalent to the previous createElement() example.

LANGUAGE: jsx
CODE:
import { createElement, render } from 'preact';

let vdom = <p class="big">Hello World!</p>;

render(vdom, document.body);

----------------------------------------

TITLE: Simple Global State with Signals in Preact
DESCRIPTION: Demonstrates how Signals simplify global state management in Preact components with direct value access and automatic updates.

LANGUAGE: jsx
CODE:
import { render } from "preact";
import { signal } from "@preact/signals";

const count = signal(0);

function Counter() {
 return (
   <button onClick={() => count.value++}>
     Value: {count.value}
   </button>
 );
}

render(<Counter />, document.getElementById("app"));

----------------------------------------

TITLE: Implementing Counter Component with Preact Hooks
DESCRIPTION: A simple counter component demonstrating state management using Preact's useState hook. Shows increment and decrement functionality with button controls.

LANGUAGE: jsx
CODE:
function Counter() {
  const [value, setValue] = useState(0);

  return (
    <>
      <div>Counter: {value}</div>
      <button onClick={() => setValue(value + 1)}>Increment</button>
      <button onClick={() => setValue(value - 1)}>Decrement</button>
    </>
  )
}

----------------------------------------

TITLE: Setting up a Context Provider in Preact
DESCRIPTION: Shows how to set up a Context Provider component to make the context available to descendant components. The example uses the Theme context and sets its value to 'dark'.

LANGUAGE: jsx
CODE:
import { createContext } from "preact";

export const Theme = createContext("light");

function App() {
  return (
    <Theme.Provider value="dark">
      <SomeComponent />
    </Theme.Provider>
  );
}

----------------------------------------

TITLE: Implementing render() Method in a Preact Component
DESCRIPTION: Shows how to implement the required render() method in a Preact component, which returns a Virtual DOM Element based on props and state.

LANGUAGE: jsx
CODE:
import { Component } from 'preact';

class MyComponent extends Component {
	render(props, state) {
		// props is the same as this.props
		// state is the same as this.state

		return <h1>Hello, {props.name}!</h1>;
	}
}

----------------------------------------

TITLE: Creating Basic Function Component in Preact
DESCRIPTION: Demonstrates how to create a simple button component that accepts props and returns a Virtual DOM element.

LANGUAGE: jsx
CODE:
function MyButton(props) {
  return <button class="my-button">{props.text}</button>
}

----------------------------------------

TITLE: Implementing Context with useContext Hook in Preact
DESCRIPTION: This snippet demonstrates how to use the useContext hook to access context values in a functional component.

LANGUAGE: jsx
CODE:
const Theme = createContext('light');

function DisplayTheme() {
  const theme = useContext(Theme);
  return <p>Active theme: {theme}</p>;
}

function App() {
  return (
    <Theme.Provider value="light">
      <OtherComponent>
        <DisplayTheme />
      </OtherComponent>
    </Theme.Provider>
  )
}

----------------------------------------

TITLE: Implementing a Counter Component with Hooks in Preact
DESCRIPTION: This snippet shows how to create the same counter component using functional syntax and hooks in Preact. It uses useState and useCallback hooks.

LANGUAGE: jsx
CODE:
function Counter() {
  const [value, setValue] = useState(0);
  const increment = useCallback(() => {
    setValue(value + 1);
  }, [value]);

  return (
    <div>
      <p>Counter: {value}</p>
      <button onClick={increment}>Increment</button>
    </div>
  );
}

----------------------------------------

TITLE: Using Hooks in Preact X
DESCRIPTION: Demonstrates the usage of Hooks in Preact X, specifically useState and useCallback, to manage state and memoize callbacks in functional components.

LANGUAGE: jsx
CODE:
function Counter() {
  const [value, setValue] = useState(0);
  const increment = useCallback(() => setValue(value + 1), [value]);

  return (
    <div>
      Counter: {value}
      <button onClick={increment}>Increment</button>
    </div>
  );
}

----------------------------------------

TITLE: Using Local State with Signals in Preact Components
DESCRIPTION: Demonstrates how to use signals for local state management within Preact components using hooks.

LANGUAGE: jsx
CODE:
import { useSignal, useComputed } from "@preact/signals";

function Counter() {
  const count = useSignal(0);
  const double = useComputed(() => count.value * 2);

  return (
    <div>
      <p>{count} x 2 = {double}</p>
      <button onClick={() => count.value++}>click me</button>
    </div>
  );
}

----------------------------------------

TITLE: Creating Error Boundaries in Preact
DESCRIPTION: Implementation of an error boundary component that catches rendering errors and provides fallback content.

LANGUAGE: jsx
CODE:
class ErrorBoundary extends Component {
  constructor() {
    super();
    this.state = { errored: false };
  }

  static getDerivedStateFromError(error) {
    return { errored: true };
  }

  componentDidCatch(error, errorInfo) {
    errorReportingService(error, errorInfo);
  }

  render(props, state) {
    if (state.errored) {
      return <p>Something went badly wrong</p>;
    }
    return props.children;
  }
}

----------------------------------------

TITLE: Typing Hooks in Preact
DESCRIPTION: Examples of using typed hooks in Preact, including useState, useEffect, useContext, useRef, and useReducer.

LANGUAGE: tsx
CODE:
const Counter = ({ initial = 0 }) => {
  const [clicks, setClicks] = useState(initial);
  return (
    <>
      <p>Clicks: {clicks}</p>
      <button onClick={() => setClicks(clicks + 1)}>+</button>
      <button onClick={() => setClicks(clicks - 1)}>-</button>
    </>
  );
};

LANGUAGE: typescript
CODE:
interface StateType {
  count: number;
}

interface ActionType {
  type: "reset" | "decrement" | "increment";
}

const initialState = { count: 0 };

function reducer(state: StateType, action: ActionType) {
  switch (action.type) {
    case "reset":
      return initialState;
    case "increment":
      return { count: state.count + 1 };
    case "decrement":
      return { count: state.count - 1 };
    default:
      return state;
  }
}

----------------------------------------

TITLE: Basic Text Input Implementation in Preact
DESCRIPTION: Examples of implementing a basic text input field using both class and hooks approaches. Shows how to handle input changes and update state accordingly.

LANGUAGE: jsx
CODE:
class BasicInput extends Component {
  state = { name: '' };

  onInput = e => this.setState({ name: e.currentTarget.value });

  render(_, { name }) {
    return (
      <div class="form-example">
        <label>
          Name:{' '}
          <input onInput={this.onInput} />
        </label>
        <p>Hello {name}</p>
      </div>
    );
  }
}

LANGUAGE: jsx
CODE:
function BasicInput() {
  const [name, setName] = useState('');

  return (
    <div class="form-example">
      <label>
        Name:{' '}
        <input onInput={(e) => setName(e.currentTarget.value)} />
      </label>
      <p>Hello {name}</p>
    </div>
  );
}

----------------------------------------

TITLE: Basic Preact SSR Implementation
DESCRIPTION: Simple example demonstrating basic server-side rendering of a Preact component using preact-render-to-string.

LANGUAGE: jsx
CODE:
import render from 'preact-render-to-string';
import { h } from 'preact';

const name = 'Preact User!'
const App = <div class="foo">Hello {name}</div>;

console.log(render(App));
// <div class="foo">Hello Preact User!</div>

----------------------------------------

TITLE: Implementing Basic Counter with Signals in Preact
DESCRIPTION: Demonstrates the basic usage of signals and computed values in a Preact counter component. Shows how to create signals, compute derived values, and update signal values within event handlers.

LANGUAGE: jsx
CODE:
import { render } from "preact";
import { signal, computed } from "@preact/signals";

const count = signal(0);
const double = computed(() => count.value * 2);

function Counter() {
  return (
    <button onClick={() => count.value++}>
      {count} x 2 = {double}
    </button>
  );
}

render(<Counter />, document.getElementById("app"));

----------------------------------------

TITLE: Building a Todo List UI with Signals in Preact
DESCRIPTION: Shows how to create a UI for a todo list application using signals in Preact.

LANGUAGE: jsx
CODE:
function TodoList() {
  const onInput = event => (text.value = event.currentTarget.value);

  return (
    <>
      <input value={text.value} onInput={onInput} />
      <button onClick={addTodo}>Add</button>
      <ul>
        {todos.value.map(todo => (
          <li>
            {todo.text}{' '}
            <button onClick={() => removeTodo(todo)}>❌</button>
          </li>
        ))}
      </ul>
    </>
  );
}

----------------------------------------

TITLE: Implementing State in Preact Class Components
DESCRIPTION: This snippet demonstrates how to use state in a Preact class component. It shows how to initialize state, update it using setState(), and render different content based on the state value.

LANGUAGE: jsx
CODE:
class MyButton extends Component {
  state = { clicked: false }

  handleClick = () => {
    this.setState({ clicked: true })
  }

  render() {
    return (
      <button onClick={this.handleClick}>
        {this.state.clicked ? 'Clicked' : 'No clicks yet'}
      </button>
    )
  }
}

----------------------------------------

TITLE: Creating Context in Preact
DESCRIPTION: Demonstrates how to create multiple contexts using the createContext function from Preact. This snippet shows the creation of Theme, User, and Locale contexts with initial values.

LANGUAGE: jsx
CODE:
import { createContext } from "preact";

export const Theme = createContext("light");
export const User = createContext({ name: "Guest" });
export const Locale = createContext(null);

----------------------------------------

TITLE: Basic Preact Class Component
DESCRIPTION: Demonstrates converting a simple element into a class-based component structure.

LANGUAGE: jsx
CODE:
import { h, render, Component } from 'preact';

class App extends Component {
  render() {
    return <h1>Hello, world!</h1>;
  }
}

render(<App />, document.getElementById("app"));

----------------------------------------

TITLE: Context with useContext Hook
DESCRIPTION: Shows how to use the useContext hook to consume context values in a more concise way compared to the Consumer pattern.

LANGUAGE: jsx
CODE:
import { createContext } from 'preact'
import { useContext } from 'preact/hooks'

const Username = createContext()

export default function App() {
  return (
    <Username.Provider value="Bob">
      <div>
        <p>
          <User />
        </p>
      </div>
    </Username.Provider>
  )
}

function User() {
  const username = useContext(Username)
  return <span>{username}</span>
}

----------------------------------------

TITLE: Implementing Todo List Component in Preact
DESCRIPTION: This snippet defines a TodoList component using Preact. It manages a list of todos, allows adding new items, marking them as complete, and removing them. The component also tracks the count of completed todos.

LANGUAGE: JavaScript
CODE:
import { render, Component } from 'preact';

class TodoList extends Component {
	state = {
		todos: [
			{ text: "Write my first post", completed: true },
			{ text: "Buy new groceries", completed: false },
			{ text: "Walk the dog", completed: false },
		],
		newItem: ''
	};

	setNewItem = e => {
		this.setState({ newItem: e.target.value });
	};

	addTodo = e => {
		e.preventDefault();

		let { todos, newItem } = this.state;
		todos = todos.concat({ text: newItem, completed: false });
		this.setState({ todos, newItem: '' });  // Reset input value on add
	};

	completeTodo = (index) => {
		let { todos } = this.state;
		todos[index].completed = !todos[index].completed;
		this.setState({ todos });
	};

	removeTodo = (index) => {
		let { todos } = this.state;
		todos.splice(index, 1);
		this.setState({ todos });
	};

	completedCount = () => {
		return this.state.todos.filter(todo => todo.completed).length;
	};

	render({}, { todos, newItem }) {
		return (
			<form onSubmit={this.addTodo}>
				<input type="text" value={newItem} onInput={this.setNewItem} />
				<button onClick={this.addTodo}>Add</button>
				<ul>
					{todos.map((todo, index) => (
						<li>
							<label>
								<input
									type="checkbox"
									checked={todo.completed}
									onInput={() => this.completeTodo(index)}
								/>
								{todo.completed ? <s>{todo.text}</s> : todo.text}
							</label>
							{' '}
							<button type="button" onClick={() => this.removeTodo(index)}>❌</button>
						</li>
					))}
				</ul>
				<p>Completed count: {this.completedCount()}</p>
			</form>
		);
	}
}

----------------------------------------

TITLE: Basic Server-Side Rendering with Preact
DESCRIPTION: Demonstrates basic server-side rendering implementation using Preact and Express.js. Shows how to render a component to string and serve it.

LANGUAGE: javascript
CODE:
// server.js
import { h } from 'preact'
import preactRenderToString from 'preact-render-to-string'

// ...remaining express.js setup

const HomePage = () => {
  return h('h1', {}, 'hello')
}

app.get('/', async (req, res) => {
  res.send(preactRenderToString(h(HomePage, {})))
})

----------------------------------------

TITLE: Using Refs in Function Components with Hooks
DESCRIPTION: Shows how to use the useRef and useEffect hooks to create and use refs in function components, focusing an input after the component is rendered.

LANGUAGE: jsx
CODE:
import { useRef, useEffect } from 'preact/hooks';

export default function App() {
  // create or retrieve our ref:  (hook slot 0)
  const input = useRef()

  // the callback here will run after <App> is rendered:
  useEffect(() => {
    // access the associated DOM element:
    input.current.focus()
  }, [])

  return <input ref={input} />
}

----------------------------------------

TITLE: Consuming Context with Consumer Component in Preact
DESCRIPTION: Demonstrates how to use the Context.Consumer component to access context values in class components. The example shows a ThemedButton component that uses the ThemePrimary context.

LANGUAGE: jsx
CODE:
const ThemePrimary = createContext("#673ab8");

function ThemedButton() {
  return (
    <ThemePrimary.Consumer>
      {theme => <button style={{ background: theme }}>Themed Button</button>}
    </ThemePrimary.Consumer>
  );
}

function App() {
  return (
    <ThemePrimary.Provider value="#8f61e1">
      <SomeComponent>
        <ThemedButton />
      </SomeComponent>
    </ThemePrimary.Provider>
  );
}

----------------------------------------

TITLE: Initializing Preact Debug Tools in JSX
DESCRIPTION: Demonstrates how to import and initialize Preact debug tools in the main entry file of a Preact application. This setup enables integration with Preact Devtools and additional debugging features.

LANGUAGE: jsx
CODE:
// Must be the first import
import "preact/debug";
import { render } from 'preact';
import App from './components/App';

render(<App />, document.getElementById('root'));

----------------------------------------

TITLE: Creating a Web Component from a Preact Component
DESCRIPTION: Shows how to create a web component from a Preact component using preact-custom-element. It demonstrates registering a component, specifying observed attributes, and using the resulting custom element in HTML.

LANGUAGE: jsx
CODE:
import register from 'preact-custom-element';

const Greeting = ({ name = 'World' }) => (
  <p>Hello, {name}!</p>
);

register(Greeting, 'x-greeting', ['name'], { shadow: false });

LANGUAGE: html
CODE:
<x-greeting name="Billy Jo"></x-greeting>

----------------------------------------

TITLE: Implementing Error Boundaries with componentDidCatch in Preact X
DESCRIPTION: Shows how to use componentDidCatch to handle errors in component lifecycles and render user-friendly error messages.

LANGUAGE: jsx
CODE:
class Catcher extends Component {
  state = { errored: false }

  componentDidCatch(error) {
    this.setState({ errored: true });
  }

  render(props, state) {
    if (state.errored) {
      return <p>Something went badly wrong</p>;
    }
    return props.children;
  }
}

----------------------------------------

TITLE: Creating and Managing Todo List State with Signals
DESCRIPTION: Demonstrates how to model a todo list application state using signals, including adding and removing items.

LANGUAGE: javascript
CODE:
import { signal } from "@preact/signals";

const todos = signal([
  { text: "Buy groceries" },
  { text: "Walk the dog" },
]);

const text = signal("");

function addTodo() {
  todos.value = [...todos.value, { text: text.value }];
  text.value = "";
}

function removeTodo(todo) {
  todos.value = todos.value.filter(t => t !== todo);
}

----------------------------------------

TITLE: Implementing Class Components with Lifecycle Methods in Preact
DESCRIPTION: Example of a class component implementing a clock with state management and lifecycle methods componentDidMount and componentWillUnmount.

LANGUAGE: jsx
CODE:
class Clock extends Component {

  constructor() {
    super();
    this.state = { time: Date.now() };
  }

  // Lifecycle: Called whenever our component is created
  componentDidMount() {
    // update time every second
    this.timer = setInterval(() => {
      this.setState({ time: Date.now() });
    }, 1000);
  }

  // Lifecycle: Called just before our component will be destroyed
  componentWillUnmount() {
    // stop when not renderable
    clearInterval(this.timer);
  }

  render() {
    let time = new Date(this.state.time).toLocaleTimeString();
    return <span>{time}</span>;
  }
}

----------------------------------------

TITLE: Creating Shadow DOM Web Components with Preact
DESCRIPTION: Illustrates how to create a web component with Shadow DOM using Preact and preact-custom-element. It shows defining a component with shadow DOM and using named slots for content projection.

LANGUAGE: jsx
CODE:
function TextSection({ heading, content }) {
	return (
		<div>
			<h1>{heading}</h1>
			<p>{content}</p>
		</div>
	);
}

register(TextSection, 'text-section', [], { shadow: true });

LANGUAGE: html
CODE:
<text-section>
  <span slot="heading">Nice heading</span>
  <span slot="content">Great content</span>
</text-section>

----------------------------------------

TITLE: Finding Elements by Role and Accessible Name in Preact Tests
DESCRIPTION: Example of finding elements in Preact tests using the 'role' and 'accessible name' attributes, which is recommended for better accessibility testing.

LANGUAGE: jsx
CODE:
import { render, fireEvent, screen } from '@testing-library/preact';

test('should be able to sign in', async () => {
  render(<MyLoginForm />);
  
  const field = await screen.findByRole('textbox', { name: 'Sign In' });
  
  fireEvent.change(field, { value: 'user123' });
})

----------------------------------------

TITLE: Implementing a Counter Component with Class Syntax in Preact
DESCRIPTION: This snippet demonstrates how to create a simple counter component using class syntax in Preact. It includes state management and an increment method.

LANGUAGE: jsx
CODE:
class Counter extends Component {
  state = {
    value: 0
  };

  increment = () => {
    this.setState(prev => ({ value: prev.value +1 }));
  };

  render(props, state) {
    return (
      <div>
        <p>Counter: {state.value}</p>
        <button onClick={this.increment}>Increment</button>
      </div>
    );
  }
}

----------------------------------------

TITLE: Using hydrate() for Server-Side Rendering in Preact
DESCRIPTION: Shows how to use the hydrate() function for efficient client-side initialization when using server-side rendering.

LANGUAGE: jsx
CODE:
// --repl
import { hydrate } from 'preact';

const Foo = () => <div>foo</div>;
hydrate(<Foo />, document.getElementById('container'));

----------------------------------------

TITLE: Suspense and Lazy Loading Setup
DESCRIPTION: Implementation of lazy loading components using Preact's Suspense and lazy features for code splitting.

LANGUAGE: jsx
CODE:
// main.js
import { Suspense, lazy } from 'preact/compat';

// Creation of the lazy component
const HomePage = lazy(() => import('./pages/home'));

const Main = () => {
    return (
        <Suspense fallback={<p>Loading</p>}>
            <HomePage />
        </Suspense>
    );
};

----------------------------------------

TITLE: Enabling Preact Debug Messages in JavaScript
DESCRIPTION: Demonstrates how to enable helpful warnings, errors, and developer tools for Preact applications by importing the debug module.

LANGUAGE: javascript
CODE:
import "preact/debug";

----------------------------------------

TITLE: Computed Signals Implementation
DESCRIPTION: Shows how to create computed signals that derive values from other signals using compute functions.

LANGUAGE: javascript
CODE:
import { signal, computed } from "@preact/signals-core";

const s1 = signal("Hello");
const s2 = signal("World");

const c = computed(() => {
  return s1.value + " " + s2.value;
});

console.log(c.value); // Console: Hello World

----------------------------------------

TITLE: Using Fragment in Preact to Render Multiple Elements
DESCRIPTION: Shows how to use the Fragment component to return multiple sibling elements without a wrapper DOM element.

LANGUAGE: jsx
CODE:
// --repl
import { Fragment, render } from 'preact';

render(
  <Fragment>
    <div>A</div>
    <div>B</div>
    <div>C</div>
  </Fragment>,
  document.getElementById('container')
);
// Renders:
// <div id="container>
//   <div>A</div>
//   <div>B</div>
//   <div>C</div>
// </div>

----------------------------------------

TITLE: Implementing Error Boundary Component in Preact
DESCRIPTION: Shows how to create an Error Boundary component using both getDerivedStateFromError and componentDidCatch methods to handle errors gracefully. The component captures errors and displays a fallback error message.

LANGUAGE: jsx
CODE:
import { Component } from 'preact'

class ErrorBoundary extends Component {
  state = { error: null }

  static getDerivedStateFromError(error) {
    return { error: error.message }
  }

  componentDidCatch(error) {
    console.error(error)
    this.setState({ error: error.message })
  }

  render() {
    if (this.state.error) {
      return <p>Oh no! We ran into an error: {this.state.error}</p>
    }
    return this.props.children
  }
}

----------------------------------------

TITLE: Updating Context Dynamically in Preact
DESCRIPTION: Demonstrates how to update context values dynamically using component state. The example includes a ThemePicker component that allows changing the theme color, which is then consumed by a ThemedButton component.

LANGUAGE: jsx
CODE:
const ThemePrimary = createContext(null);

function ThemedButton() {
  const { theme } = useContext(ThemePrimary);
  return <button style={{ background: theme }}>Themed Button</button>;
}

function ThemePicker() {
  const { theme, setTheme } = useContext(ThemePrimary);
  return (
    <input
      type="color"
      value={theme}
      onChange={e => setTheme(e.currentTarget.value)}
    />
  );
}

function App() {
  const [theme, setTheme] = useState("#673ab8");
  return (
    <ThemePrimary.Provider value={{ theme, setTheme }}>
      <SomeComponent>
        <ThemedButton />
        {" - "}
        <ThemePicker />
      </SomeComponent>
    </ThemePrimary.Provider>
  );
}

----------------------------------------

TITLE: Creating References in Preact (Class and Function Components)
DESCRIPTION: Demonstrates how to create refs using createRef for class components and useRef for function components. Both methods create a stable object with a 'current' property.

LANGUAGE: jsx
CODE:
import { createRef } from "preact";

class MyComponent extends Component {
  countRef = createRef();
  inputRef = createRef(null);

  // ...
}

LANGUAGE: jsx
CODE:
import { useRef } from "preact/hooks";

function MyComponent() {
  const countRef = useRef();
  const inputRef = useRef(null);

  // ...
}

----------------------------------------

TITLE: Creating Virtual DOM Elements with Preact.h()
DESCRIPTION: Shows how to create Preact Virtual DOM elements using the h() function (createElement equivalent). Demonstrates various ways to specify attributes and nest children elements.

LANGUAGE: javascript
CODE:
import { h } from 'preact';

h('div', { id: 'foo' }, 'Hello!');
// <div id="foo">Hello!</div>

h('div', { id: 'foo' }, 'Hello', null, ['Preact!']);
// <div id="foo">Hello Preact!</div>

h(
	'div',
	{ id: 'foo' },
	h('span', null, 'Hello!')
);
// <div id="foo"><span>Hello!</span></div>

----------------------------------------

TITLE: Configuring TypeScript for Preact JSX
DESCRIPTION: TypeScript configuration options for transpiling JSX to Preact-compatible JavaScript. Includes settings for both classic and automatic transforms.

LANGUAGE: json
CODE:
// Classic Transform
{
  "compilerOptions": {
    "jsx": "react",
    "jsxFactory": "h",
    "jsxFragmentFactory": "Fragment",
    //...
  }
}

LANGUAGE: json
CODE:
// Automatic Transform, available in TypeScript >= 4.1.1
{
  "compilerOptions": {
    "jsx": "react-jsx",
    "jsxImportSource": "preact",
    //...
  }
}

----------------------------------------

TITLE: Creating a Custom Counter Hook in Preact
DESCRIPTION: This snippet demonstrates how to create a custom hook for counter functionality, which can be reused across multiple components.

LANGUAGE: jsx
CODE:
function useCounter() {
  const [value, setValue] = useState(0);
  const increment = useCallback(() => {
    setValue(value + 1);
  }, [value]);
  return { value, increment };
}

function CounterA() {
  const { value, increment } = useCounter();
  return (
    <div>
      <p>Counter A: {value}</p>
      <button onClick={increment}>Increment</button>
    </div>
  );
}

function CounterB() {
  const { value, increment } = useCounter();
  return (
    <div>
      <h1>Counter B: {value}</h1>
      <p>I'm a nice counter</p>
      <button onClick={increment}>Increment</button>
    </div>
  );
}

----------------------------------------

TITLE: Typing References in Preact
DESCRIPTION: Example of using typed references in Preact components with createRef and generic type binding.

LANGUAGE: tsx
CODE:
import { h, Component, createRef } from "preact";

class Foo extends Component {
  ref = createRef<HTMLAnchorElement>();

  componentDidMount() {
    console.log(this.ref.current);
  }

  render() {
    return <div ref={this.ref}>Foo</div>;
  }
}

----------------------------------------

TITLE: Using useRef Hook for DOM References in Preact
DESCRIPTION: This snippet shows how to use the useRef hook to create a reference to a DOM element and focus an input element.

LANGUAGE: jsx
CODE:
function Foo() {
  const input = useRef(null);
  const onClick = () => input.current && input.current.focus();

  return (
    <>
      <input ref={input} />
      <button onClick={onClick}>Focus input</button>
    </>
  );
}

----------------------------------------

TITLE: Creating Virtual DOM Elements with h() in Preact
DESCRIPTION: Demonstrates various ways to use the h() function (also known as createElement()) to create Virtual DOM Elements in Preact.

LANGUAGE: javascript
CODE:
import { h } from 'preact';

h('div', { id: 'foo' }, 'Hello!');
// <div id="foo">Hello!</div>

h('div', { id: 'foo' }, 'Hello', null, ['Preact!']);
// <div id="foo">Hello Preact!</div>

h(
	'div',
	{ id: 'foo' },
	h('span', null, 'Hello!')
);
// <div id="foo"><span>Hello!</span></div>

----------------------------------------

TITLE: Implementing Side Effects with useEffect in Preact Function Components
DESCRIPTION: This snippet demonstrates how to use the useEffect hook to create side effects in a function component. It shows how to focus an input element after rendering and how to trigger effects based on state changes.

LANGUAGE: jsx
CODE:
import { useRef, useEffect } from 'preact/hooks';

export default function App() {
  const input = useRef()

  // the callback here will run after <App> is rendered:
  useEffect(() => {
    // access the associated DOM element:
    input.current.focus()
  }, [])

  return <input ref={input} />
}

----------------------------------------

TITLE: Implementing and Testing a Custom Hook in Preact
DESCRIPTION: Example of implementing a custom hook (useCounter) and testing it using the renderHook function from Preact Testing Library.

LANGUAGE: jsx
CODE:
import { useState, useCallback } from 'preact/hooks';

const useCounter = () => {
  const [count, setCount] = useState(0);
  const increment = useCallback(() => setCount(c => c + 1), []);
  return { count, increment };
}

import { renderHook, act } from '@testing-library/preact';
import useCounter from './useCounter';

test('should increment counter', () => {
  const { result } = renderHook(() => useCounter());

  expect(result.current.count).toBe(0);

  act(() => {
    result.current.increment();
  });

  expect(result.current.count).toBe(1);
});

----------------------------------------

TITLE: Typing Class Components in Preact
DESCRIPTION: Example of typing a class component in Preact, including prop and state interfaces, and using generics with the Component class.

LANGUAGE: tsx
CODE:
interface ExpandableProps {
  title: string;
};

interface ExpandableState {
  toggled: boolean;
};

class Expandable extends Component<ExpandableProps, ExpandableState> {
  constructor(props: ExpandableProps) {
    super(props);
    this.state = {
      toggled: false
    };
  }
  render() {
    return (
      <div class="expandable">
        <h2>
          {this.props.title}{" "}
          <button
            onClick={() => this.setState({ toggled: !this.state.toggled })}
          >
            Toggle
          </button>
        </h2>
        <div hidden={this.state.toggled}>{this.props.children}</div>
      </div>
    );
  }
}

----------------------------------------

TITLE: Using Fragments in Preact
DESCRIPTION: Examples of using Fragments to return multiple elements without adding extra DOM nodes, including usage with lists and loops.

LANGUAGE: jsx
CODE:
function TodoItems() {
  return (
    <Fragment>
      <li>A</li>
      <li>B</li>
      <li>C</li>
    </Fragment>
  )
}

const App = (
  <ul>
    <TodoItems />
    <li>D</li>
  </ul>
);

render(App, container);

----------------------------------------

TITLE: Using Preact's act Function for State Updates in Tests
DESCRIPTION: JavaScript and JSX code showing how to use Preact's act function to handle state updates in tests when directly calling event handlers.

LANGUAGE: js
CODE:
import { act } from 'preact/test-utils';

LANGUAGE: jsx
CODE:
it('should increment after "Increment" button is clicked', () => {
    const wrapper = mount(<Counter initialCount={5}/>);
    const onClick = wrapper.find('button').props().onClick;

    act(() => {
      // Invoke the button's click handler, but this time directly, instead of
      // via an Enzyme API
      onClick();
    });
    // Refresh Enzyme's view of the output
    wrapper.update();

    expect(wrapper.text()).to.include('Current value: 6');
});

----------------------------------------

TITLE: Implementing Suspense in Preact
DESCRIPTION: Demonstrates using Suspense and lazy loading to handle asynchronous component loading with fallback content.

LANGUAGE: jsx
CODE:
import { Suspense, lazy } from 'preact/compat';

const SomeComponent = lazy(() => import('./SomeComponent'));

// Usage
<Suspense fallback={<div>loading...</div>}>
  <Foo>
    <SomeComponent />
  </Foo>
</Suspense>

----------------------------------------

TITLE: Dynamic Dependencies in Computed Signals
DESCRIPTION: Demonstrates how computed signals can handle dynamic dependencies that change based on conditions.

LANGUAGE: javascript
CODE:
import { signal, computed } from "@preact/signals-core";

const choice = signal(true);
const funk = signal("Uptown");
const purple = signal("Haze");

const c = computed(() => {
  if (choice.value) {
    console.log(funk.value, "Funk");
  } else {
    console.log("Purple", purple.value);
  }
});

----------------------------------------

TITLE: Managing Global App State with Signals and Context
DESCRIPTION: Shows how to create and manage global application state using signals and Preact's context API.

LANGUAGE: jsx
CODE:
import { createContext } from "preact";
import { useContext } from "preact/hooks";
import { createAppState } from "./my-app-state";

const AppState = createContext();

render(
  <AppState.Provider value={createAppState()}>
    <App />
  </AppState.Provider>
);

function App() {
  const state = useContext(AppState);
  return <p>{state.completed}</p>;
}

----------------------------------------

TITLE: Comparing JSX Output in React and Preact
DESCRIPTION: Shows the difference in compiled JSX output between React and Preact, highlighting Preact's more concise representation.

LANGUAGE: javascript
CODE:
// Preact:
h(
  'a',
  { href:'/' },
  h('span', null, 'Home')
);

// React:
React.createElement(
  'a',
  { href:'/' },
  React.createElement('span', null, 'Home')
);

----------------------------------------

TITLE: Writing Enzyme Tests for Preact Counter Component
DESCRIPTION: JSX code demonstrating how to write Enzyme tests for the Preact Counter component, including checking initial render and simulating button clicks.

LANGUAGE: jsx
CODE:
import { expect } from 'chai';
import { h } from 'preact';
import { mount } from 'enzyme';

import Counter from '../src/Counter';

describe('Counter', () => {
  it('should display initial count', () => {
    const wrapper = mount(<Counter initialCount={5}/>);
    expect(wrapper.text()).to.include('Current value: 5');
  });

  it('should increment after "Increment" button is clicked', () => {
    const wrapper = mount(<Counter initialCount={5}/>);

    wrapper.find('button').simulate('click');

    expect(wrapper.text()).to.include('Current value: 6');
  });
});

----------------------------------------

TITLE: Comparing Children API Usage in React and Preact
DESCRIPTION: Illustrates the difference in handling children between React's Children API and Preact's direct approach.

LANGUAGE: jsx
CODE:
// React:
function App(props) {
  return <Modal content={Children.only(props.children)} />
}

// Preact: use props.children directly:
function App(props) {
  return <Modal content={props.children} />
}

// React
function App(props) {
  const cols = Children.count(props.children);
  return <div data-columns={cols}>{props.children}</div>
}

// Preact
function App(props) {
  const cols = toChildArray(props.children).length;
  return <div data-columns={cols}>{props.children}</div>
}

----------------------------------------

TITLE: Comparing Children API Usage in React and Preact
DESCRIPTION: Illustrates the difference in handling children between React's Children API and Preact's direct approach.

LANGUAGE: jsx
CODE:
// React:
function App(props) {
  return <Modal content={Children.only(props.children)} />
}

// Preact: use props.children directly:
function App(props) {
  return <Modal content={props.children} />
}

// React
function App(props) {
  const cols = Children.count(props.children);
  return <div data-columns={cols}>{props.children}</div>
}

// Preact
function App(props) {
  const cols = toChildArray(props.children).length;
  return <div data-columns={cols}>{props.children}</div>
}

----------------------------------------

TITLE: Updating state correctly in Preact X
DESCRIPTION: Demonstrates the correct way to update state in Preact X using a callback function, as state updates are no longer synchronous.

LANGUAGE: jsx
CODE:
this.state = { counter: 0 };

// Preact X
this.setState(prevState => {
  // Alternatively return `null` here to abort the state update
  return { counter: prevState.counter + 1 };
});

----------------------------------------

TITLE: Traditional State Management Patterns
DESCRIPTION: Shows examples of traditional selector-based and wrapper function-based state management approaches, highlighting their complexity compared to Signals.

LANGUAGE: js
CODE:
// Selector based subscription :(
function Counter() {
  const value = useSelector(state => state.count);
  // ...
}

// Wrapper function based subscription :(
const counterState = new Counter();

const Counter = observe(props => {
  const value = counterState.count;
  // ...
});

----------------------------------------

TITLE: Complete Example of External DOM Manipulation in Preact
DESCRIPTION: This example demonstrates a full Preact component that prevents re-rendering and allows for external DOM manipulation. It includes lifecycle methods for handling props, mounting, and unmounting.

LANGUAGE: jsx
CODE:
class Example extends Component {
  shouldComponentUpdate() {
    // do not re-render via diff:
    return false;
  }

  componentWillReceiveProps(nextProps) {
    // you can do something with incoming props here if you need
  }

  componentDidMount() {
    // now mounted, can freely modify the DOM:
    let thing = document.createElement('maybe-a-custom-element');
    this.base.appendChild(thing);
  }

  componentWillUnmount() {
    // component is about to be removed from the DOM, perform any cleanup.
  }

  render() {
    return <div class="example" />;
  }
}

----------------------------------------

TITLE: Radio and Checkbox Implementation in Preact
DESCRIPTION: Demonstration of implementing radio buttons and checkboxes with state management and conditional rendering.

LANGUAGE: jsx
CODE:
class BasicRadioButton extends Component {
  state = {
    allowContact: false,
    contactMethod: ''
  };

  toggleContact = () => this.setState({ allowContact: !this.state.allowContact });
  setRadioValue = e => this.setState({ contactMethod: e.currentTarget.value });

  render(_, { allowContact }) {
    return (
      <div class="form-example">
        <label>
          Allow contact:{' '}
          <input type="checkbox" onClick={this.toggleContact} />
        </label>
        <label>
          Phone:{' '}
          <input type="radio" name="contact" value="phone" onClick={this.setRadioValue} disabled={!allowContact} />
        </label>
        <label>
          Email:{' '}
          <input type="radio" name="contact" value="email" onClick={this.setRadioValue} disabled={!allowContact} />
        </label>
        <label>
          Mail:{' '}
          <input type="radio" name="contact" value="mail" onClick={this.setRadioValue} disabled={!allowContact} />
        </label>
        <p>
          You {allowContact ? 'have allowed' : 'have not allowed'} contact {allowContact && ` via ${this.state.contactMethod}`}
        </p>
      </div>
    );
  }
}

----------------------------------------

TITLE: Implementing forwardRef in Preact
DESCRIPTION: Shows how to use forwardRef to pass refs through component boundaries to inner DOM elements.

LANGUAGE: jsx
CODE:
import { createRef, render } from 'preact';
import { forwardRef } from 'preact/compat';

const MyComponent = forwardRef((props, ref) => {
  return <div ref={ref}>Hello world</div>;
})

// Usage: `ref` will hold the reference to the inner `div` instead of
// `MyComponent`
const ref = createRef();
render(<MyComponent ref={ref} />, dom)

----------------------------------------

TITLE: Implementing Prerendering in Preact Application
DESCRIPTION: This code snippet shows how to modify a Preact application to support prerendering by switching from 'render' to 'hydrate' and adding a 'prerender' export function.

LANGUAGE: diff
CODE:
// src/index.jsx
-import { render } from 'preact';
+import { hydrate, prerender as ssr } from 'preact-iso';

function App() {
    return <h1>Hello World!</h1>
}

-render(<App />, document.getElementById('app'));
+if (typeof window !== 'undefined') {
+	hydrate(<App />, document.getElementById('app'));
+}

+export async function prerender(data) {
+    return await ssr(<App {...data} />)
+}

----------------------------------------

TITLE: Using Callback Refs in Preact (Class and Function Components)
DESCRIPTION: Demonstrates the use of callback refs in Preact, where a function is passed to the ref prop. The function receives the DOM node as an argument and can optionally return a cleanup function.

LANGUAGE: jsx
CODE:
import { render, Component } from "preact";

class MyInput extends Component {
  render() {
    return (
      <input ref={(dom) => {
        console.log('Mounted:', dom);

        // As of Preact 10.23.0, you can optionally return a cleanup function
        return () => {
          console.log('Unmounted:', dom);
        };
      }} />
    );
  }
}

render(<MyInput />, document.getElementById("app"));

LANGUAGE: jsx
CODE:
import { render } from "preact";

function MyInput() {
  return (
    <input ref={(dom) => {
      console.log('Mounted:', dom);

      // As of Preact 10.23.0, you can optionally return a cleanup function
      return () => {
        console.log('Unmounted:', dom);
      };
    }} />
  );
}

render(<MyInput />, document.getElementById("app"));

----------------------------------------

TITLE: Using Effects with Signals
DESCRIPTION: Shows how to use effects to react to signal changes outside of the component tree.

LANGUAGE: javascript
CODE:
import { signal, computed, effect } from "@preact/signals";

const name = signal("Jane");
const surname = signal("Doe");
const fullName = computed(() => `${name.value} ${surname.value}`);

effect(() => console.log(fullName.value));

name.value = "John";

----------------------------------------

TITLE: Updating Root Render for Preact
DESCRIPTION: Example of updating the root render call when switching from React to Preact.

LANGUAGE: js
CODE:
- ReactDOM.render(<App />, document.getElementById('app'));
+ render(<App />, document.body);

----------------------------------------

TITLE: Batching Signal Updates
DESCRIPTION: Demonstrates how to use the batch function to combine multiple signal updates into a single update.

LANGUAGE: javascript
CODE:
function addTodo() {
  batch(() => {
    todos.value = [...todos.value, { text: text.value }];
    text.value = "";
  });
}

----------------------------------------

TITLE: Creating and Updating a Signal in JavaScript
DESCRIPTION: Demonstrates how to create a signal, read its value, and update it.

LANGUAGE: javascript
CODE:
import { signal } from "@preact/signals";

const count = signal(0);

console.log(count.value);   // 0

count.value += 1;

console.log(count.value);  // 1

----------------------------------------

TITLE: Basic Preact Rendering
DESCRIPTION: Shows how to render a simple Preact component into the DOM using the render() function.

LANGUAGE: jsx
CODE:
import { render } from 'preact';

const App = <h1>Hello World!</h1>;

// Inject our app into the DOM
render(App, document.getElementById('app'));

----------------------------------------

TITLE: Client-Side Hydration Implementation
DESCRIPTION: Shows how to implement client-side hydration for Preact components. Includes mounting a Counter component to an existing DOM element.

LANGUAGE: javascript
CODE:
// client.js
import { hydrate } from 'preact'
import Counter from './Counter'

const main = () => {
  // assuming the server rendered the component with the following ID as well.
  const container = document.getElementById('counter')
  hydrate(h(Counter, {}), container)
}

main()

----------------------------------------

TITLE: Setting Complex Properties on Web Components in Preact
DESCRIPTION: Illustrates how to set complex property values on a custom web component using Preact. It shows defining a custom element with a setter and using it in a Preact component.

LANGUAGE: jsx
CODE:
customElements.define('context-menu', class extends HTMLElement {
  set position({ x, y }) {
    this.style.cssText = `left:${x}px; top:${y}px;`;
  }
});

function Foo() {
  return <context-menu position={{ x: 10, y: 20 }}> ... </context-menu>;
}

----------------------------------------

TITLE: Setting a Custom VNode Option Hook in Preact
DESCRIPTION: Demonstrates how to set a custom vnode option hook in Preact while preserving the previous hook's functionality. This example logs each vnode and calls the original hook if it exists.

LANGUAGE: javascript
CODE:
import { options } from 'preact';

// Store previous hook
const oldHook = options.vnode;

// Set our own options hook
options.vnode = vnode => {
  console.log("Hey I'm a vnode", vnode);

  // Call previously defined hook if there was any
  if (oldHook) {
    oldHook(vnode);
  }
}

----------------------------------------

TITLE: Implementing Resumed Hydration in Preact
DESCRIPTION: Demonstrates the suspended hydration feature where components can become interactive progressively while maintaining server-rendered DOM content. Shows nested Suspense boundaries with lazy-loaded components.

LANGUAGE: jsx
CODE:
const App = () => {
  return (
    <>
      <Header>
      <main>
        <Suspense>
          <LazyArticleHeader />
          <Suspense>
            <article>
              <LazyContents />
            </article>
          </Suspense>
        </Suspense>
      </main>
    </>
  )
}

----------------------------------------

TITLE: Typing Context in Preact
DESCRIPTION: Examples of creating and using typed context in Preact, including inference and explicit typing.

LANGUAGE: tsx
CODE:
import { h, createContext } from "preact";

const AppContext = createContext({
  authenticated: true,
  lang: "en",
  theme: "dark"
});

LANGUAGE: tsx
CODE:
interface AppContextValues {
  authenticated: boolean;
  lang: string;
  theme: string;
}

const AppContext = createContext<Partial<AppContextValues>>({});

function App() {
  return (
    <AppContext.Provider
      value={{
        lang: "de"
      }}
    >
      <ComponentThatUsesAppContext />
    </AppContext.Provider>
  );

----------------------------------------

TITLE: Implementing a Counter Component in Preact
DESCRIPTION: Example of a Counter component in Preact that displays an initial value and provides a button to increment it.

LANGUAGE: jsx
CODE:
import { h } from 'preact';
import { useState } from 'preact/hooks';

export function Counter({ initialCount }) {
  const [count, setCount] = useState(initialCount);
  const increment = () => setCount(count + 1);

  return (
    <div>
      Current value: {count}
      <button onClick={increment}>Increment</button>
    </div>
  );
}

----------------------------------------

TITLE: Installing Preact SSR Package
DESCRIPTION: Command to install the preact-render-to-string package for server-side rendering capabilities.

LANGUAGE: bash
CODE:
npm install -S preact-render-to-string

----------------------------------------

TITLE: Conditionally Loading Preact Debug Tools in JSX
DESCRIPTION: Shows how to conditionally import Preact debug tools only in development mode, allowing for automatic removal in production builds to optimize bundle size.

LANGUAGE: jsx
CODE:
// Must be the first import
if (process.env.NODE_ENV==='development') {
  // Must use require here as import statements are only allowed
  // to exist at top-level.
  require("preact/debug");
}

import { render } from 'preact';
import App from './components/App';

render(<App />, document.getElementById('root'));

----------------------------------------

TITLE: Async SSR Implementation
DESCRIPTION: Example showing how to use renderToStringAsync for server-side rendering of components with async dependencies.

LANGUAGE: jsx
CODE:
import { renderToStringAsync } from 'preact-render-to-string';
import { Main } from './main';

const main = async () => {
    // Rendering of lazy components
    const html = await renderToStringAsync(<Main />);

    console.log(html);
    // <h1>Home page</h1>
};

// Execution & error handling
main().catch((error) => {
    console.error(error);
});

----------------------------------------

TITLE: Babel Configuration for JSX with Preact
DESCRIPTION: Configuration for @babel/plugin-transform-react-jsx to enable JSX support in Preact applications.

LANGUAGE: json
CODE:
{
  "plugins": [
    ["@babel/plugin-transform-react-jsx", {
      "pragma": "h",
      "pragmaFrag": "Fragment"
    }]
  ]
}

----------------------------------------

TITLE: Webpack Server Configuration
DESCRIPTION: Server-side webpack configuration for building the Node.js application with Preact support.

LANGUAGE: javascript
CODE:
const path = require('path')
const nodeExternals = require('webpack-node-externals')

module.exports = {
  mode: process.env.NODE_ENV != 'production' ? 'development' : 'production',
  target: 'node',
  entry: path.resolve(__dirname, './src/server/app.js'),
  output: {
    filename: 'server.js',
    path: path.resolve(__dirname, './dist'),
  },
  stats: 'errors-warnings',
  resolve: {
    extensions: ['.js', '.jsx'],
  },
  module: {
    rules: [{ test: /\.jsx?$/, loader: 'babel-loader' }],
  },
  externals: [nodeExternals()],
}

----------------------------------------

TITLE: Generating Unique IDs with useId Hook in Preact
DESCRIPTION: This snippet shows how to use the useId hook to generate unique identifiers for form elements and other use cases.

LANGUAGE: jsx
CODE:
const App = props => {
  const mainId = useId();
  const inputId = useId();

  useLayoutEffect(() => {
    document.getElementById(inputId).focus()
  }, [])
  
  return (
    <main id={mainId}>
      <input id={inputId}>
    </main>
  )
};

----------------------------------------

TITLE: Implementing PureComponent in Preact
DESCRIPTION: Example showing how to use PureComponent from preact/compat to automatically skip unnecessary re-renders through shallow prop comparison.

LANGUAGE: jsx
CODE:
import { render } from 'preact';
import { PureComponent } from 'preact/compat';

class Foo extends PureComponent {
  render(props) {
    console.log("render")
    return <div />
  }
}

const dom = document.getElementById('root');
render(<Foo value="3" />, dom);
// Logs: "render"

// Render a second time, doesn't log anything
render(<Foo value="3" />, dom);

----------------------------------------

TITLE: Rendering Web Components in Preact JSX
DESCRIPTION: Demonstrates how to render a custom web component in Preact using JSX syntax. It shows defining a custom element and then using it in a Preact component.

LANGUAGE: jsx
CODE:
customElements.define('x-foo', class extends HTMLElement {
  // ...
});

function Foo() {
  return <x-foo />;
}

----------------------------------------

TITLE: Enabling Prerendering in Vite Config
DESCRIPTION: This snippet shows how to enable prerendering by setting the 'prerender' option in the Vite configuration file.

LANGUAGE: diff
CODE:
// vite.config.js
import { defineConfig } from 'vite';
import preact from '@preact/preset-vite';

// https://vitejs.dev/config/
export default defineConfig({
	plugins: [
		preact({
+			prerender: { enabled: true }
		}),
	],
});

----------------------------------------

TITLE: Installing Enzyme and Preact Adapter
DESCRIPTION: Command to install Enzyme and the Preact adapter for unit testing Preact applications.

LANGUAGE: bash
CODE:
npm install --save-dev enzyme enzyme-adapter-preact-pure

----------------------------------------

TITLE: Defining Observed Attributes for Web Components in Preact
DESCRIPTION: Demonstrates different ways to specify observed attributes for a web component created from a Preact component. It shows using static properties and PropTypes for attribute definition.

LANGUAGE: jsx
CODE:
import register from 'preact-custom-element';

class Greeting extends Component {
  static tagName = 'x-greeting';
  static observedAttributes = ['name'];

  render({ name }) {
    return <p>Hello, {name}!</p>;
  }
}
register(Greeting);

// Other option: use PropTypes:
function FullName({ first, last }) {
  return <span>{first} {last}</span>
}

FullName.propTypes = {
  first: Object,   // you can use PropTypes, or this
  last: Object     // trick to define un-typed props.
};

register(FullName, 'full-name');

----------------------------------------

TITLE: Handling Dynamic Children with Keys in Preact JSX
DESCRIPTION: Illustrates the correct way to assign unique keys when rendering dynamic lists of children in Preact, which is crucial for efficient reconciliation and avoiding key-related warnings.

LANGUAGE: jsx
CODE:
const persons = [
  { name: 'John', age: 22 },
  { name: 'Sarah', age: 24}
];

// Somewhere later in your component
<div>
  {persons.map(({ name, age }) => {
    return <p key={name}>{name}, Age: {age}</p>;
  })}
</div>

----------------------------------------

TITLE: Using Hooks in Preact Function Components
DESCRIPTION: Demonstrates the correct usage of React hooks within a Preact function component, emphasizing that hooks can only be used inside component render methods.

LANGUAGE: jsx
CODE:
function Foo() {
  const [value, setValue] = useState(0);
  return <button onClick={() => setValue(value + 1)}>{value}</button>;
}

----------------------------------------

TITLE: Interactive Error Example with Error Boundary in Preact
DESCRIPTION: Demonstrates a practical implementation of error handling with a Clicker component that intentionally throws an error, and an App component that catches and displays the error message.

LANGUAGE: jsx
CODE:
import { render, Component } from 'preact';
import { useState } from 'preact/hooks';

function Clicker() {
  const [clicked, setClicked] = useState(false);

  if (clicked) {
    throw new Error('I am erroring');
  }

  return <button onClick={() => setClicked(true)}>Click Me</button>;
}

class App extends Component {
  state = { error: null };

  componentDidCatch(error) {
    this.setState({ error: error.message });
  }

  render() {
    const { error } = this.state;
    if (error) {
      return <p>Oh no! There was an error: {error}</p>
    }
    return <Clicker />;
  }
}

render(<App />, document.getElementById("app"));

----------------------------------------

TITLE: Using toChildArray() to Handle Children in Preact Components
DESCRIPTION: Shows how to use the toChildArray() helper function to consistently handle children props in Preact components, regardless of their structure.

LANGUAGE: jsx
CODE:
import { toChildArray } from 'preact';

function Foo(props) {
  const count = toChildArray(props.children).length;
  return <div>I have {count} children</div>;
}

// props.children is "bar"
render(
  <Foo>bar</Foo>,
  container
);

// props.children is [<p>A</p>, <p>B</p>]
render(
  <Foo>
    <p>A</p>
    <p>B</p>
  </Foo>,
  container
);

----------------------------------------

TITLE: Implementing a Counter with useReducer Hook in Preact
DESCRIPTION: This snippet demonstrates how to use the useReducer hook to manage more complex state logic in a counter component.

LANGUAGE: jsx
CODE:
const initialState = 0;
const reducer = (state, action) => {
  switch (action) {
    case 'increment': return state + 1;
    case 'decrement': return state - 1;
    case 'reset': return 0;
    default: throw new Error('Unexpected action');
  }
};

function Counter() {
  const [count, dispatch] = useReducer(reducer, initialState);
  return (
    <div>
      {count}
      <button onClick={() => dispatch('increment')}>+1</button>
      <button onClick={() => dispatch('decrement')}>-1</button>
      <button onClick={() => dispatch('reset')}>reset</button>
    </div>
  );
}

----------------------------------------

TITLE: Using JavaScript Expressions in JSX
DESCRIPTION: Shows how to incorporate JavaScript expressions within JSX using curly braces for dynamic class names and content.

LANGUAGE: jsx
CODE:
let maybeBig = Math.random() > .5 ? 'big' : 'small';

let vdom = <p class={maybeBig}>Hello {40 + 2}!</p>;

----------------------------------------

TITLE: Cloning and Modifying Elements with cloneElement() in Preact
DESCRIPTION: Demonstrates how to use cloneElement() to create a shallow copy of a Virtual DOM Element and modify its props.

LANGUAGE: jsx
CODE:
function Linkout(props) {
  // add target="_blank" to the link:
  return cloneElement(props.children, { target: '_blank' });
}
render(<Linkout><a href="/">home</a></Linkout>);
// <a href="/" target="_blank">home</a>

----------------------------------------

TITLE: Preventing Component Re-rendering in Preact
DESCRIPTION: This snippet demonstrates how to prevent a Preact component from re-rendering by implementing the shouldComponentUpdate lifecycle method. This allows external libraries to freely manipulate the component's DOM.

LANGUAGE: jsx
CODE:
class Block extends Component {
  shouldComponentUpdate() {
    return false;
  }
}

----------------------------------------

TITLE: Correctly Rendering JSX Elements in Preact
DESCRIPTION: Shows the correct way to render a pre-defined JSX element in Preact, avoiding the 'Passed a JSX literal as JSX twice' error.

LANGUAGE: jsx
CODE:
const Foo = <div>foo</div>;
render(Foo, dom);

----------------------------------------

TITLE: Event Handling in Preact JSX
DESCRIPTION: Demonstration of handling click events in Preact using the onClick prop with a handler function.

LANGUAGE: jsx
CODE:
function clicked() {
  console.log('clicked')
}
<button onClick={clicked}>

----------------------------------------

TITLE: Basic Signal Usage in JavaScript
DESCRIPTION: Demonstrates creation and usage of basic signals for storing and updating reactive values.

LANGUAGE: javascript
CODE:
import { signal } from "@preact/signals-core";

const s = signal(0);
console.log(s.value); // Console: 0

s.value = 1;
console.log(s.value); // Console: 1

----------------------------------------

TITLE: Using Components with JSX and createElement
DESCRIPTION: Shows how to use a component in JSX and its equivalent createElement syntax.

LANGUAGE: javascript
CODE:
let vdom = <MyButton text="Click Me!" />

// remember createElement? here's what the line above compiles to:
let vdom = createElement(MyButton, { text: "Click Me!" })

----------------------------------------

TITLE: Creating Portals in Preact
DESCRIPTION: Example of using Portals to render components into DOM nodes outside the main app hierarchy.

LANGUAGE: html
CODE:
<html>
  <body>
    <!-- App is rendered here -->
    <div id="app"></div>
    <!-- Modals should be rendered here -->
    <div id="modals"></div>
  </body>
</html>

LANGUAGE: jsx
CODE:
import { createPortal } from 'preact/compat';
import MyModal from './MyModal';

function App() {
  const container = document.getElementById('modals');
  return (
    <div>
      I'm app
      {createPortal(<MyModal />, container)}
    </div>
  )
}

----------------------------------------

TITLE: Implementing Context API in Preact X
DESCRIPTION: Shows how to use the createContext API in Preact X to create a theme context and consume it in nested components.

LANGUAGE: jsx
CODE:
const Theme = createContext('light');

function ThemedButton(props) {
  return (
    <Theme.Consumer>
      {theme => <div>Active theme: {theme}</div>}
    </Theme.Consumer>
  );
}

function App() {
  return (
    <Theme.Provider value="dark">
      <SomeComponent>
        <ThemedButton />
      </SomeComponent>
    </Theme.Provider>
  );
}

----------------------------------------

TITLE: Installing Preact Testing Library via npm
DESCRIPTION: Command to install the testing-library Preact adapter using npm.

LANGUAGE: bash
CODE:
npm install --save-dev @testing-library/preact

----------------------------------------

TITLE: Rendering Components to DOM
DESCRIPTION: Example of rendering a component into the document body using Preact's render function.

LANGUAGE: jsx
CODE:
import { render } from 'preact';

render(<MyButton text="Click me!" />, document.body)

----------------------------------------

TITLE: Typing Events in Preact
DESCRIPTION: Examples of typing event handlers in Preact components, including explicit typing and type inference.

LANGUAGE: tsx
CODE:
import type { JSX } from "preact";

export class Button extends Component {
  handleClick(event: JSX.TargetedMouseEvent<HTMLButtonElement>) {
    alert(event.currentTarget.tagName); // Alerts BUTTON
  }

  render() {
    return (
      <button onClick={this.handleClick}>
        {this.props.children}
      </button>
    );
  }
}

----------------------------------------

TITLE: Initializing Todo List State with Preact Signals
DESCRIPTION: Sets up the initial state for the todo list using Preact Signals. It creates a signal for the list of todos and a computed signal for the count of completed todos.

LANGUAGE: JavaScript
CODE:
import { signal, computed } from '@preact/signals';

const todos = signal([
	{ text: 'Write my first post', completed: true },
	{ text: 'Buy new groceries', completed: false },
	{ text: 'Walk the dog', completed: false }
]);

const completedCount = computed(
	() => todos.value.filter(todo => todo.completed).length
);

const newItem = signal('');

----------------------------------------

TITLE: Using State in Preact Function Components with Hooks
DESCRIPTION: This example illustrates how to use the useState hook to manage state in a Preact function component. It shows how to initialize state, update it using the setter function, and render different content based on the state value.

LANGUAGE: jsx
CODE:
import { useState } from 'preact/hooks'

const MyButton = () => {
  const [clicked, setClicked] = useState(false)

  const handleClick = () => {
    setClicked(true)
  }

  return (
    <button onClick={handleClick}>
      {clicked ? 'Clicked' : 'No clicks yet'}
    </button>
  )
}

----------------------------------------

TITLE: Async Component Definition
DESCRIPTION: Example of a simple home page component that will be loaded asynchronously.

LANGUAGE: jsx
CODE:
// page/home.js
export default () => {
    return <h1>Home page</h1>;
};

----------------------------------------

TITLE: Rendering We Are Using Component in JSX
DESCRIPTION: This snippet renders a custom 'we-are-using' component within a div with the class 'breaker'. It's likely used to display a list or grid of companies using Preact.

LANGUAGE: jsx
CODE:
<div class="breaker">
  <we-are-using></we-are-using>
</div>

----------------------------------------

TITLE: Handling children diffing in Preact X render function
DESCRIPTION: Demonstrates the change in behavior of the render function in Preact X, where it always diffs existing children inside the container.

LANGUAGE: jsx
CODE:
// Existing markup:
<body>
  <div>hello</div>
</body>

render(<p>foo</p>, document.body);
render(<p>bar</p>, document.body);

// Preact X output:
<body>
  <p>bar</p>
  <div>hello</div>
</body>

----------------------------------------

TITLE: Implementing Ref-based Input Focus in Preact
DESCRIPTION: A practical example of using refs in a function component to focus an input field when a button is clicked.

LANGUAGE: jsx
CODE:
import { render } from 'preact';
import { useRef } from 'preact/hooks';

function App() {
  const input = useRef();

  function onClick() {
    input.current.focus();
  }

  return (
    <div>
      <input ref={input} defaultValue="Hello World!" />
      <button onClick={onClick}>Focus input</button>
    </div>
  );
}

render(<App />, document.getElementById("app"));

----------------------------------------

TITLE: Implementing a Simple Preact Counter Component
DESCRIPTION: JSX code for a basic Preact Counter component that displays a count and provides an increment button.

LANGUAGE: jsx
CODE:
import { h } from 'preact';
import { useState } from 'preact/hooks';

export default function Counter({ initialCount }) {
  const [count, setCount] = useState(initialCount);
  const increment = () => setCount(count + 1);

  return (
    <div>
      Current value: {count}
      <button onClick={increment}>Increment</button>
    </div>
  );
}

----------------------------------------

TITLE: Implementing Hot Module Replacement with Preact
DESCRIPTION: JavaScript code demonstrating how to implement Hot Module Replacement (HMR) with Preact's render function.

LANGUAGE: js
CODE:
let root;

function init() {
  root = render(<App />, document.body, root);
}
init();

// example: Re-render on Webpack HMR update:
if (module.hot) module.hot.accept('./app', init);

----------------------------------------

TITLE: Using Multiple useEffect Hooks in Preact Function Components
DESCRIPTION: This example shows how to use multiple useEffect hooks in a single component to handle different side effects. It demonstrates running effects on initial render and in response to state changes.

LANGUAGE: js
CODE:
import { useEffect, useState } from 'preact/hooks';

export default function App() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    console.log('<App> was just rendered for the first time')
  }, [])

  useEffect(() => {
    console.log('count value was changed to: ', count)
  }, [count])
  //  ^ run this any time `count` changes, and on the first render

  return <button onClick={() => setCount(count+1)}>{count}</button>
}

----------------------------------------

TITLE: Pretty Print Rendering
DESCRIPTION: Example of rendering with the pretty option for human-readable output with proper indentation.

LANGUAGE: jsx
CODE:
import render from 'preact-render-to-string/jsx';
import { h } from 'preact';

const Foo = () => <div>foo</div>;
const App = <div class="foo"><Foo /></div>;

console.log(render(App, {}, { pretty: true }));
// Logs:
// <div class="foo">
//   <div>foo</div>
// </div>

----------------------------------------

TITLE: Manual State Update Example
DESCRIPTION: Example showing how to handle manual state updates in Enzyme tests

LANGUAGE: javascript
CODE:
it('should increment after "Increment" button is clicked', () => {
    const wrapper = mount(<Counter initialCount={5}/>);
    const onClick = wrapper.find('button').props().onClick;

    // Invoke the button's click handler, but this time directly, instead of
    // via an Enzyme API
    onClick();

    // Refresh Enzyme's view of the output
    wrapper.update();

    expect(wrapper.text()).to.include('Current value: 6');
});

----------------------------------------

TITLE: JSX Mode Rendering
DESCRIPTION: Example of JSX mode rendering which outputs JSX-style syntax, useful for snapshot testing.

LANGUAGE: jsx
CODE:
import render from 'preact-render-to-string/jsx';
import { h } from 'preact';

const App = <div data-foo={true} />;

console.log(render(App));
// Logs: <div data-foo={true} />

----------------------------------------

TITLE: Implementing Side Effects in Preact Class Components
DESCRIPTION: This snippet demonstrates how to use lifecycle methods to create side effects in a class component. It shows how to fetch data when a component mounts and update the component's state.

LANGUAGE: jsx
CODE:
import { Component } from 'preact';

export default class App extends Component {
  // this gets called after the component is first rendered:
  componentDidMount() {
    // get JSON user info, store in `state.user`:
    fetch('/api/user')
      .then(response => response.json())
      .then(user => {
        this.setState({ user })
      })
  }

  render(props, state) {
    const { user } = state;

    // if we haven't received data yet, show a loading indicator:
    if (!user) return <div>Loading...</div>

    // we have data! show the username we got back from the API:
    return (
      <div>
        <h2>Hello, {user.username}!</h2>
      </div>
    )
  }
}

----------------------------------------

TITLE: Installing Preact X using npm
DESCRIPTION: Command to install the latest version of Preact using npm package manager.

LANGUAGE: bash
CODE:
npm install preact

----------------------------------------

TITLE: Styling for Spiral Animation
DESCRIPTION: CSS styles for the spiral animation including cursor styling, animation transitions, and layout configuration. Includes styles for the main container, cursor appearance, and animation picker UI.

LANGUAGE: css
CODE:
html, body {
	height: 100%;
	background: #222;
	font: 100%/1.21 'Helvetica Neue',helvetica,sans-serif;
	text-rendering: optimizeSpeed;
	color: #888;
	overflow: hidden;
}

#main {
	position: absolute;
	left: 0;
	top: 0;
	width: 100%;
	height: 100%;
	overflow: hidden;
}

.cursor {
	position: absolute;
	left: 0;
	top: 0;
	width: 8px;
	height: 8px;
	margin: -5px 0 0 -5px;
	border: 2px solid #F00;
	border-radius: 50%;
	transform-origin: 50% 50%;
	transition: all 250ms ease;
	transition-property: width, height, margin;
	pointer-events: none;
	overflow: hidden;
	font-size: 9px;
	line-height: 25px;
	text-indent: 15px;
	white-space: nowrap;

	&.label {
		overflow: visible;
	}

	&.big {
		width: 24px;
		height: 24px;
		margin: -13px 0 0 -13px;
	}

	.label {
		position: absolute;
		left: 0;
		top: 0;
		z-index: 10;
	}
}

.animation-picker {
	position: fixed;
	display: inline-block;
	right: 0;
	top: 0;
	padding: 10px;
	background: #000;
	color: #BBB;
	z-index: 1000;

	select {
		font-size: 100%;
		margin-left: 5px;
	}
}

----------------------------------------

TITLE: Exercise: Modifying useEffect Dependencies in Preact
DESCRIPTION: This exercise demonstrates how to modify the dependencies array of a useEffect hook to log every time a state variable changes, rather than only on initial render.

LANGUAGE: jsx
CODE:
import { render } from 'preact';
import { useEffect, useState } from 'preact/hooks';

function App() {
  const [count, setCount] = useState(0);

  useEffect(() => {
    console.log('Count is now: ', count)
  }, [count]);
  // ^^ start here!

  return <button onClick={() => setCount(count+1)}>{count}</button>
}

render(<App />, document.getElementById("app"));

----------------------------------------

TITLE: Comparing Component Rendering in React and Preact
DESCRIPTION: Illustrates the difference in component rendering between React and Preact, showcasing Preact's convenient render arguments feature.

LANGUAGE: jsx
CODE:
// Works in both Preact and React
class Foo extends Component {
  state = { age: 1 };

  render() {
    return <div>Name: {this.props.name}, Age: {this.state.age}</div>;
  }
}

// Only works in Preact
class Foo extends Component {
  state = { age: 1 };

  render({ name }, { age }) {
    return <div>Name: {name}, Age: {age}</div>;
  }
}

----------------------------------------

TITLE: Comparing Component Rendering in React and Preact
DESCRIPTION: Illustrates the difference in component rendering between React and Preact, showcasing Preact's convenient render arguments feature.

LANGUAGE: jsx
CODE:
// Works in both Preact and React
class Foo extends Component {
  state = { age: 1 };

  render() {
    return <div>Name: {this.props.name}, Age: {this.state.age}</div>;
  }
}

// Only works in Preact
class Foo extends Component {
  state = { age: 1 };

  render({ name }, { age }) {
    return <div>Name: {name}, Age: {age}</div>;
  }
}

----------------------------------------

TITLE: Using BoundComponent in Preact Link Implementation
DESCRIPTION: Demonstrates practical usage of the BoundComponent class by creating a Link component that automatically binds its click handler. Shows how to use the binds() method to access bound methods in render.

LANGUAGE: javascript
CODE:
class Link extends BoundComponent {
    bind = ['click'];
    click() {
        open(this.props.href);
    }
    render({ children }) {
        let { click } = this.binds();
        return <span onClick={ click }>{ children }</span>;
    }
}

render(
    <Link href="http://example.com">Click Me</Link>,
    document.body
);

----------------------------------------

TITLE: Error Handling Setup Code in Preact
DESCRIPTION: Setup code that configures error handling options and validates error handling implementation. Includes custom error detection for rendering Error objects directly.

LANGUAGE: js
CODE:
useResult(function(result) {
  var options = require('preact').options;

  var oe = options.__e;
  options.__e = function(error, s) {
    if (/objects are not valid/gi.test(error)) {
      throw Error('It looks like you might be trying to render an Error object directly: try storing `error.message` instead of `error` itself.');
    }
    oe.apply(this, arguments);
    setTimeout(function() {
      if (result.output.textContent.match(/error/i)) {
        solutionCtx.setSolved(true);
      }
    }, 10);
  };

  return function () {
    options.__e = oe;
  };
}, []);

----------------------------------------

TITLE: Comparing SVG Attribute Handling in React and Preact
DESCRIPTION: Shows how Preact allows direct use of SVG attributes as-written, unlike React which requires camelCase attribute names.

LANGUAGE: jsx
CODE:
// React
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48">
  <circle fill="none" strokeWidth="2" strokeLinejoin="round" cx="24" cy="24" r="20" />
</svg>
// Preact (note stroke-width and stroke-linejoin)
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48">
  <circle fill="none" stroke-width="2" stroke-linejoin="round" cx="24" cy="24" r="20" />
</svg>

----------------------------------------

TITLE: Comparing SVG Attribute Handling in React and Preact
DESCRIPTION: Shows how Preact allows direct use of SVG attributes as-written, unlike React which requires camelCase attribute names.

LANGUAGE: jsx
CODE:
// React
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48">
  <circle fill="none" strokeWidth="2" strokeLinejoin="round" cx="24" cy="24" r="20" />
</svg>
// Preact (note stroke-width and stroke-linejoin)
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48">
  <circle fill="none" stroke-width="2" stroke-linejoin="round" cx="24" cy="24" r="20" />
</svg>

----------------------------------------

TITLE: Implementing Suspense-based Fetching for Isomorphic Content
DESCRIPTION: This example shows how to implement a suspense-based fetching mechanism for isomorphic content retrieval during prerendering.

LANGUAGE: jsx
CODE:
// src/use-fetch.js
import { useState } from "preact/hooks";

const cache = new Map();

async function load(url) {
	const res = await fetch(url);
	if (res.ok) return await res.text();
	throw new Error(`Failed to fetch ${url}!`);
}

// Simple suspense-based fetch mechanism with caching
export function useFetch(url) {
	const [_, update] = useState({});

	let data = cache.get(url);
	if (!data) {
		data = load(url);
		cache.set(url, data);
		data.then(
			(res) => update((data.res = res)),
			(err) => update((data.err = err)),
		);
	}

	if (data.res) return data.res;
	if (data.err) throw data.err;
	throw data;
}

LANGUAGE: jsx
CODE:
// src/index.jsx
import { hydrate, prerender as ssr } from 'preact-iso';
import { useFetch } from './use-fetch.js';

function App() {
    return (
        <div>
            <Suspense fallback={<p>Loading...</p>}>
                <Article />
            </Suspense>
        </div>
    );
}

function Article() {
	const data = useFetch("/my-local-article.txt");
	return <p>{data}</p>;
}

if (typeof window !== 'undefined') {
	hydrate(<App />, document.getElementById('app'));
}

export async function prerender(data) {
    return await ssr(<App {...data} />)
}

----------------------------------------

TITLE: Creating a Todo List Component in Preact JSX
DESCRIPTION: This code snippet implements a Todo List component using Preact's class-based component syntax. It demonstrates state management, event handling, and rendering of dynamic lists.

LANGUAGE: jsx
CODE:
export default class TodoList extends Component {
    state = { todos: [], text: '' };
    setText = e => {
        this.setState({ text: e.currentTarget.value });
    };
    addTodo = () => {
        let { todos, text } = this.state;
        todos = todos.concat({ text });
        this.setState({ todos, text: '' });
    };
    render({ }, { todos, text }) {
        return (
            <form onSubmit={this.addTodo} action="javascript:">
                <label>
                  <span>Add Todo</span>
                  <input value={text} onInput={this.setText} />
                </label>
                <button type="submit">Add</button>
                <ul>
                    { todos.map( todo => (
                        <li>{todo.text}</li>
                    )) }
                </ul>
            </form>
        );
    }
}

----------------------------------------

TITLE: Rendering Preact Todo List Component
DESCRIPTION: This snippet demonstrates how to render the TodoList component to the DOM using Preact's render function. It targets an element with the id 'app' as the mounting point.

LANGUAGE: JavaScript
CODE:
render(<TodoList />, document.getElementById('app'));

----------------------------------------

TITLE: HTML Template Generation with Bundle Injection
DESCRIPTION: Helper function to generate HTML template and inject client-side bundles using webpack manifest.

LANGUAGE: javascript
CODE:
import manifest from '../../dist/js/manifest.json'

export const withManifestBundles = ({ styles, body }) => {
  const bundledScripts = Object.keys(manifest).map(key => {
    const scriptPath = `/public/js/${manifest[key]}`
    return `<script src=${scriptPath}></script>`
  })

  return `<html lang="en">
    <head>
      <meta charset="UTF-8" />
      <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <style id="_goober">
        ${styles}
      </style>
    </head>

    <body>
      ${body}
    </body>
    ${bundledScripts.join('')}
  </html>`
}

----------------------------------------

TITLE: Rendering Preact Application to DOM
DESCRIPTION: Uses Preact's render function to mount the TodoList component to the DOM. This is the entry point for the application.

LANGUAGE: JavaScript
CODE:
import { render } from 'preact';

render(<TodoList />, document.getElementById('app'));

----------------------------------------

TITLE: Fetching GitHub Stars with Preact Component
DESCRIPTION: This snippet shows a Preact component that fetches and displays the number of GitHub stars for a given repository. It demonstrates async/await usage in componentDidMount and conditional rendering.

LANGUAGE: jsx
CODE:
export default class Stars extends Component {
    async componentDidMount() {
        let stars = await githubStars(this.props.repo);
        this.setState({ stars });
    }
    render({ repo }, { stars=0 }) {
        let url = `https://github.com/${repo}`;
        return (
            <a href={url} class="stars">
                ⭐️ {stars} Stars
            </a>
        );
    }
}

----------------------------------------

TITLE: Implementing Todo List Functions in JavaScript
DESCRIPTION: Defines functions for adding and removing todos from the list. These functions update the todos signal, triggering re-renders of the component.

LANGUAGE: JavaScript
CODE:
function addTodo(e) {
	e.preventDefault();

	todos.value = [...todos.value, { text: newItem.value, completed: false }];
	newItem.value = ''; // Reset input value on add
}

function removeTodo(index) {
	todos.value.splice(index, 1);
	todos.value = [...todos.value];
}

----------------------------------------

TITLE: Select Element Implementation in Preact
DESCRIPTION: Example of implementing a select dropdown component with state management using both class and hooks approaches.

LANGUAGE: jsx
CODE:
class MySelect extends Component {
  state = { value: '' };

  onChange = e => {
    this.setState({ value: e.currentTarget.value });
  }

  render(_, { value }) {
    return (
      <div class="form-example">
        <select onChange={this.onChange}>
          <option value="A">A</option>
          <option value="B">B</option>
          <option value="C">C</option>
        </select>
        <p>You selected: {value}</p>
      </div>
    );
  }
}

----------------------------------------

TITLE: Enabling Preact Debug Mode
DESCRIPTION: Demonstrates how to enable debug mode in Preact by importing the debug module at the top of the main entry file.

LANGUAGE: javascript
CODE:
import "preact/debug";

----------------------------------------

TITLE: Implementing Dot Component in Preact
DESCRIPTION: Reusable component for rendering individual dots in the spiral. Implements performance optimization through shouldComponentUpdate and handles positioning and styling of dots.

LANGUAGE: javascript
CODE:
class Dot extends Component {
	shouldComponentUpdate({ x, y, big, label, color }) {
		return (
			x !== this.props.x ||
			y !== this.props.y ||
			big !== this.props.big ||
			label !== this.props.label ||
			color !== this.props.color
		);
	}

	render({ x = 0, y = 0, label, color, big }) {
		let style = {
			transform: `translate(${x}px, ${y}px) scale(${big ? 2 : 1})`,
			borderColor: color
		};
		let className = `dot ${big ? ' big' : ''} ${label ? ' label' : ''}`;
		return (
			<div class={className} style={style}>
				{label && (
					<span class="label">
						{x},{y}
					</span>
				)}
			</div>
		);
	}
}

----------------------------------------

TITLE: Using globalThis for Data Passing in Prerendering
DESCRIPTION: This example demonstrates how to use globalThis to pass data around during prerendering, including setting document titles and meta tags.

LANGUAGE: javascript
CODE:
// src/title-util.js
import { useEffect } from 'preact/hooks';

/**
 * Set `document.title` or `globalThis.title`
 * @param {string} title
 */
export function useTitle(title) {
	if (typeof window === 'undefined') {
		globalThis.title = createTitle(title);
	}
	useEffect(() => {
		if (title) {
			document.title = createTitle(title);
		}
	}, [title]);
}

LANGUAGE: jsx
CODE:
// src/index.jsx
import { LocationProvider, Router, hydrate, prerender as ssr } from 'preact-iso';

import { useTitle } from './title-util.js'

function App() {
    return (
        <LocationProvider>
            <main>
                <Home path="/" />
                <NotFound default />
            </main>
        </LocationProvider>
    );
}

function Home() {
    useTitle('Preact - Home');
    return <h1>Hello World!</h1>;
}

function NotFound() {
    useTitle('Preact - 404');
    return <h1>Page Not Found</h1>;
}

if (typeof window !== 'undefined') {
    hydrate(<App />, document.getElementById('app'));
}

export async function prerender(data) {
    const { html, links } = await ssr(<App {...data} />);

    return {
        html,
        links,
        head: {
            title: globalThis.title,
            elements: new Set([
                { type: 'meta', props: { property: 'og:title', content: globalThis.title } },
            ])
        }
    };
}

----------------------------------------

TITLE: Implementing Spiral Component in Preact
DESCRIPTION: Main component that creates an animated spiral of dots following pointer movement. Uses requestAnimationFrame for smooth animation and manages state for pointer position and animation count.

LANGUAGE: javascript
CODE:
class Spiral extends Component {
	state = { x: 0, y: 0, big: false, count: 0 };

	handlePointerMove = e => {
		this.setState({ x: e.pageX, y: e.pageY });
	};

	handlePointerDownUp = e => {
		this.setState({ big: e.type === 'pointerdown' });
	};

	increment = () => {
		this.setState({ count: this.state.count + 1 });
		this.raf = requestAnimationFrame(this.increment);
	};

	componentDidMount() {
		this.increment();
	}

	componentWillUnmount() {
		cancelAnimationFrame(this.raf);
	}

	render({}, { x, y, big, count }) {
		let max = (COUNT + Math.sin((count / 90) * 2 * Math.PI) * COUNT * 0.5) | 0,
			dots = [];

		for (let i = max; i--; ) {
			let f = (i / max) * LOOPS,
				angle = f * 2 * Math.PI,
				dx = x + Math.sin(angle) * (20 + i * 2),
				dy = y + Math.cos(angle) * (20 + i * 2),
				color = `hsl(${(f * 255 + count * 10) % 255}, 100%, 50%)`;
			dots[i] = <Dot x={dx | 0} y={dy | 0} big={big} color={color} />;
		}

		return (
			<div
				id="spiral"
				onPointerMove={this.handlePointerMove}
				onPointerDown={this.handlePointerDownUp}
				onPointerUp={this.handlePointerDownUp}
			>
				<Dot x={x} y={y} big={big} label />
				{dots}
			</div>
		);
	}
}

----------------------------------------

TITLE: Input Event Handling in Preact vs React
DESCRIPTION: Demonstrates the difference in handling input events between Preact (using onInput) and React (using onChange).

LANGUAGE: jsx
CODE:
// React
<input onChange={e => console.log(e.currentTarget.value)} />

// Preact
<input onInput={e => console.log(e.currentTarget.value)} />

----------------------------------------

TITLE: Implementing Counter Component with Preact Hooks
DESCRIPTION: Creates a Counter component using Preact's useState hook for state management. The component renders a container with increment/decrement buttons and a readonly input displaying the current count. Uses htm template literal syntax for markup.

LANGUAGE: javascript
CODE:
import { render } from 'preact';
import { useState } from 'preact/hooks';
import { html } from 'htm/preact';

export function Counter() {
	const [count, setCount] = useState(0);

	return html`
		<div class="counter-container">
			<button onClick=${() => setCount(count + 1)}>Increment</button>
			<input readonly value=${count} />
			<button onClick=${() => setCount(count - 1)}>Decrement</button>
		</div>
	`;
}

render(<Counter />, document.getElementById('app'));

----------------------------------------

TITLE: Creating and Rendering a Simple Preact Component
DESCRIPTION: Shows how to create a basic Preact component as a function and render it to the DOM using JSX syntax.

LANGUAGE: jsx
CODE:
import { createElement } from 'preact';

export default function App() {
	return (
		<p class="big">Hello World!</p>
	)
}

render(<App />, document.getElementById("app"));

----------------------------------------

TITLE: JSX Transformation in Preact vs React
DESCRIPTION: Shows how JSX is transformed differently in Preact and React, with Preact using a shorter, unnamespaced pragma.

LANGUAGE: javascript
CODE:
// Preact:
h(
  'a',
  { href:'/' },
  h('span', null, 'Home')
);

// React:
React.createElement(
  'a',
  { href:'/' },
  React.createElement('span', null, 'Home')
);

----------------------------------------

TITLE: Implementing a Counter Component in Preact JSX
DESCRIPTION: This snippet demonstrates a simple Counter component using Preact hooks. It showcases state management with useState and event handling for increment and decrement actions.

LANGUAGE: jsx
CODE:
function Counter() {
  const [value, setValue] = useState(0);

  return (
    <>
      <div>Counter: {value}</div>
      <button onClick={() => setValue(value + 1)}>Increment</button>
      <button onClick={() => setValue(value - 1)}>Decrement</button>
    </>
  )
}

----------------------------------------

TITLE: Full API Example for Prerendering
DESCRIPTION: This example demonstrates the full API for prerendering, including adding custom links, configuring head elements, and setting language and title attributes.

LANGUAGE: jsx
CODE:
// src/index.jsx

// ...

export async function prerender(data) {
	const { html, links: discoveredLinks } = ssr(<App />);

	return {
		html,
		// Optionally add additional links that should be
		// prerendered (if they haven't already been -- these will be deduped)
		links: new Set([...discoveredLinks, '/foo', '/bar']),
		// Optionally configure and add elements to the `<head>` of
		// the prerendered HTML document
		head: {
			// Sets the "lang" attribute: `<html lang="en">`
			lang: 'en',
			// Sets the title for the current page: `<title>My cool page</title>`
			title: 'My cool page',
			// Sets any additional elements you want injected into the `<head>`:
			//   <link rel="stylesheet" href="foo.css">
			//   <meta property="og:title" content="Social media title">
			elements: new Set([
				{ type: 'link', props: { rel: 'stylesheet', href: 'foo.css' } },
				{ type: 'meta', props: { property: 'og:title', content: 'Social media title' } }
			])
		}
	}
}

----------------------------------------

TITLE: Children API Usage in Preact vs React
DESCRIPTION: Illustrates how Preact simplifies handling of children props compared to React's Children API.

LANGUAGE: jsx
CODE:
// React
function App(props) {
  const cols = Children.count(props.children);
  return <div data-columns={cols}>{props.children}</div>
}

// Preact
function App(props) {
  const cols = toChildArray(props.children).length;
  return <div data-columns={cols}>{props.children}</div>
}

----------------------------------------

TITLE: Configuring Web Crawler Access in Robots.txt
DESCRIPTION: Standard robots.txt configuration that allows all web crawlers (*) to access all content with no path restrictions. This is the most permissive crawler configuration possible.

LANGUAGE: robots.txt
CODE:
User-agent: *
Disallow:

----------------------------------------

TITLE: SVG Attribute Handling in Preact vs React
DESCRIPTION: Illustrates how Preact handles SVG attributes differently from React, allowing direct use of kebab-case attribute names.

LANGUAGE: jsx
CODE:
// React
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48">
  <circle fill="none" strokeWidth="2" strokeLinejoin="round" cx="24" cy="24" r="20" />
</svg>
// Preact (note stroke-width and stroke-linejoin)
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 48 48">
  <circle fill="none" stroke-width="2" stroke-linejoin="round" cx="24" cy="24" r="20" />
</svg>

----------------------------------------

TITLE: Rendering Error Page Message in Markdown
DESCRIPTION: Basic markdown content displaying an error message with a navigation link to the homepage when a page is not found.

LANGUAGE: markdown
CODE:
# Error

Yikes, looks like that page vanished.

Time to head [Home](/)

----------------------------------------

TITLE: Importing Preact and Hooks
DESCRIPTION: Imports necessary functions from Preact and Preact hooks for rendering and state management.

LANGUAGE: JavaScript
CODE:
import { render, createContext } from 'preact';
import { useState, useMemo, useContext } from 'preact/hooks';

----------------------------------------

TITLE: Component Rendering with Props and State in Preact
DESCRIPTION: Shows how Preact allows passing props and state as parameters to the render method of class components for convenience.

LANGUAGE: jsx
CODE:
class Foo extends Component {
  state = { age: 1 };

  render({ name }, { age }) {
    return <div>Name: {name}, Age: {age}</div>;
  }
}

----------------------------------------

TITLE: Babel Configuration for Preact JSX
DESCRIPTION: Babel configuration to transform JSX for Preact instead of React.

LANGUAGE: json
CODE:
{
  "plugins": [
    [
      "@babel/plugin-transform-react-jsx",
      { "runtime": "automatic", "importSource": "preact" }
    ]
  ]
}

----------------------------------------

TITLE: Simple Clock Component Implementation
DESCRIPTION: Basic implementation of a Clock component that displays current time

LANGUAGE: javascript
CODE:
import { h, render, Component } from 'preact';

class Clock extends Component {
	render() {
		let time = new Date().toLocaleTimeString();
		return <span>{ time }</span>;
	}
}

// render an instance of Clock into <body>:
render(<Clock />, document.body);

----------------------------------------

TITLE: Implementing Counter Component
DESCRIPTION: Defines a Counter component that uses the shared context to display and increment the count.

LANGUAGE: JSX
CODE:
function Counter() {
	const { count, increment } = useContext(CounterContext);

	return (
		<div style={{ background: '#eee', padding: '10px' }}>
			<p>Count: {count}</p>
			<button onClick={increment}>Add</button>
		</div>
	);
}

----------------------------------------

TITLE: Basic JSX Rendering in Preact
DESCRIPTION: Demonstrates rendering a simple JSX structure with event handling using Preact's render function

LANGUAGE: javascript
CODE:
import { h, render } from 'preact';

render((
	<div id="foo">
		<span>Hello, world!</span>
		<button onClick={ e => alert("hi!") }>Click Me</button>
	</div>
), document.body);

----------------------------------------

TITLE: Using Legacy Context API in Preact
DESCRIPTION: Illustrates the use of the legacy Context API in Preact. This approach uses the getChildContext method to provide context and accesses it via the second argument in function components or this.context in class components.

LANGUAGE: jsx
CODE:
function ThemedButton(_props, context) {
  return (
    <button style={{ background: context.theme }}>
      Themed Button
    </button>
  );
}

class App extends Component {
  getChildContext() {
    return {
      theme: "#673ab8"
    }
  }

  render() {
    return (
      <div>
        <SomeOtherComponent>
          <ThemedButton />
        </SomeOtherComponent>
      </div>
    );
  }
}

----------------------------------------

TITLE: Implementing Counter Component with Preact and Signals
DESCRIPTION: This snippet creates a Counter component using Preact and Preact Signals. It includes buttons to increment and decrement a count value, which is displayed in a read-only input field. The component is then rendered to the DOM.

LANGUAGE: JavaScript
CODE:
import { render } from 'preact';
import { signal } from '@preact/signals';

const count = signal(0);

function Counter() {
	return (
		<div class="counter-container">
			<button onClick={() => count.value++}>Increment</button>
			<input readonly value={count} />
			<button onClick={() => count.value--}>Decrement</button>
		</div>
	);
}

render(<Counter />, document.getElementById('app'));

----------------------------------------

TITLE: Importing Preact Components (Named Import)
DESCRIPTION: Demonstrates how to import specific components from Preact using named imports and configure JSX transformation

LANGUAGE: javascript
CODE:
import { h, render, Component } from 'preact';

// Tell Babel to transform JSX into h() calls:
/** @jsx h */

----------------------------------------

TITLE: CDN Integration for Preact
DESCRIPTION: Example of including Preact via CDN in HTML

LANGUAGE: html
CODE:
<script src="https://cdn.jsdelivr.net/npm/preact/dist/preact.min.js"></script>

----------------------------------------

TITLE: Shorthand DOM Mutation Prevention in Preact
DESCRIPTION: Arrow function implementation of shouldComponentUpdate for preventing component re-renders.

LANGUAGE: javascript
CODE:
class Block extends Component {
  shouldComponentUpdate = () => false;
}

----------------------------------------

TITLE: Implementing Counter Component with Preact in JavaScript/JSX
DESCRIPTION: This code snippet defines a Counter component using Preact. It maintains a count state and provides buttons to increment and decrement the count. The component is then rendered to the DOM.

LANGUAGE: JavaScript
CODE:
import { Component, render } from 'preact';

class Counter extends Component {
	state = { count: 0 };

	render({}, { count }) {
		return (
			<div class="counter-container">
				<button onClick={() => this.setState({ count: count + 1 })}>
					Increment
				</button>
				<input readonly value={count} />
				<button onClick={() => this.setState({ count: count - 1 })}>
					Decrement
				</button>
			</div>
		);
	}
}

render(<Counter />, document.getElementById('app'));

----------------------------------------

TITLE: Basic DOM Mutation Prevention in Preact
DESCRIPTION: Simple implementation of shouldComponentUpdate to prevent Preact from re-rendering a component, allowing external DOM mutations.

LANGUAGE: javascript
CODE:
class Block extends Component {
  shouldComponentUpdate() {
    return false;
  }
}

----------------------------------------

TITLE: Adding Prerender Attribute to Script Tag
DESCRIPTION: This snippet demonstrates how to add the 'prerender' attribute to the script tag in the HTML file to indicate where the prerender function is located.

LANGUAGE: diff
CODE:
// index.html
-<script type="module" src="/src/index.jsx"></script>
+<script prerender type="module" src="/src/index.jsx"></script>

----------------------------------------

TITLE: Rendering Preact Application
DESCRIPTION: Mounts the Example component to the DOM element with id 'app'.

LANGUAGE: JavaScript
CODE:
render(<Example />, document.getElementById('app'));

----------------------------------------

TITLE: Using Unique IDs as Keys in Preact Lists
DESCRIPTION: This example demonstrates a better approach to using keys in Preact lists by utilizing unique IDs for each todo item instead of array indices or non-unique values.

LANGUAGE: jsx
CODE:
const todos = [
  { id: 1, text: 'wake up' },
  { id: 2, text: 'make bed' }
]

export default function ToDos() {
  return (
    <ul>
      {todos.map(todo => (
        <li key={todo.id}>
          {todo.text}
        </li>
      ))}
    </ul>
  )
}

----------------------------------------

TITLE: Using linkState for Simplified State Management in Preact
DESCRIPTION: Demonstrates the usage of linkState utility to create concise state bindings. This approach reduces boilerplate code while maintaining performance through handler caching.

LANGUAGE: javascript
CODE:
import linkState from 'linkstate';

class Foo extends Component {
	render({ }, { text }) {
		return <input value={text} onInput={linkState(this, 'text')} />;
	}
}

----------------------------------------

TITLE: Implementing Keys in a Preact Todo List
DESCRIPTION: This snippet shows how to add keys to list items in a Preact Todo list component. It uses the todo string itself as the key, improving rendering efficiency.

LANGUAGE: jsx
CODE:
export default function TodoList() {
  const [todos, setTodos] = useState(['wake up', 'make bed'])

  function wakeUp() {
    setTodos(['make bed'])
  }

  return (
    <div>
      <ul>
        {todos.map(todo => (
          <li key={todo}>{todo}</li>
        ))}
      </ul>
      <button onClick={wakeUp}>I'm Awake!</button>
    </div>
  )
}

----------------------------------------

TITLE: Rendering Todo List Component with Preact JSX
DESCRIPTION: Defines the TodoList component using Preact's JSX syntax. It renders the list of todos, handles user interactions, and displays the count of completed todos.

LANGUAGE: JSX
CODE:
function TodoList() {
	const onInput = event => (newItem.value = event.target.value);

	return (
		<form onSubmit={addTodo}>
			<input type="text" value={newItem.value} onInput={onInput} />
			<button onClick={addTodo}>Add</button>
			<ul>
				{todos.value.map((todo, index) => (
					<li>
						<label>
							<input
								type="checkbox"
								checked={todo.completed}
								onInput={() => {
									todo.completed = !todo.completed;
									todos.value = [...todos.value];
								}}
							/>
							{todo.completed ? <s>{todo.text}</s> : todo.text}
						</label>{' '}
						<button type="button" onClick={() => removeTodo(index)}>❌</button>
					</li>
				))}
			</ul>
			<p>Completed count: {completedCount.value}</p>
		</form>
	);
}

----------------------------------------

TITLE: Combining Keys and Side Effects in Preact
DESCRIPTION: This exercise combines the use of keys with side effects in Preact. It fetches todos asynchronously, stores them in state, and renders them with proper keys.

LANGUAGE: jsx
CODE:
import { render } from 'preact';
import { useState, useEffect } from 'preact/hooks';

const wait = ms => new Promise(r => setTimeout(r, ms))

const getTodos = async () => {
  await wait(500);
  return [
    { id: 1, text: 'learn Preact', done: false },
    { id: 2, text: 'make an awesome app', done: false },
  ]
}

function TodoList() {
  const [todos, setTodos] = useState([])

  useEffect(() => {
    getTodos().then(todos => {
      setTodos(todos)
    })
  }, [])

  return (
    <ul>
      {todos.map(todo => (
        <li key={todo.id}>
          {todo.text}
        </li>
      ))}
    </ul>
  )
}

render(<TodoList />, document.getElementById("app"));

----------------------------------------

TITLE: Configuring Browserify Alias for Preact
DESCRIPTION: Package.json configuration to alias React imports to preact-compat using Browserify with aliasify.

LANGUAGE: json
CODE:
{
  "aliasify": {
    "aliases": {
      "react": "preact-compat",
      "react-dom": "preact-compat"
    }
  }
}

----------------------------------------

TITLE: Setting up Preact Documentation Repo (Bash)
DESCRIPTION: Commands to install dependencies and start the development server for the Preact documentation website. This allows contributors to work on the site locally.

LANGUAGE: bash
CODE:
$ npm install

$ npm run dev

----------------------------------------

TITLE: Basic Context Usage in Preact
DESCRIPTION: Demonstrates basic context creation and usage with Provider/Consumer pattern to share a username value through components.

LANGUAGE: jsx
CODE:
import { createContext } from 'preact'

const Username = createContext()

export default function App() {
  return (
    <Username.Provider value="Bob">
      <div>
        <p>
          <Username.Consumer>
            {username => (
              <span>{username}</span>
            )}
          </Username.Consumer>
        </p>
      </div>
    </Username.Provider>
  )
}

----------------------------------------

TITLE: Traditional DOM Event Handling in JavaScript
DESCRIPTION: Example of registering a click event handler using the traditional DOM API with addEventListener.

LANGUAGE: javascript
CODE:
function clicked() {
  console.log('clicked')
}
const myButton = document.getElementById('my-button')
myButton.addEventListener('click', clicked)

----------------------------------------

TITLE: Nested Route Context Implementation
DESCRIPTION: Shows how to implement nested routing using context to manage path segments and route matching.

LANGUAGE: jsx
CODE:
import { createContext } from 'preact'
import { useContext } from 'preact/hooks'

const Path = createContext(location.pathname)

function Route(props) {
  const path = useContext(Path)
  const isMatch = path.startsWith(props.path)
  const innerPath = path.substring(props.path.length)
  return isMatch && (
    <Path.Provider value={innerPath}>
      {props.children}
    </Path.Provider>
  )
}

----------------------------------------

TITLE: Blog Overview Component Integration in HTML
DESCRIPTION: HTML structure combining markdown frontmatter with a custom blog-overview web component and a donation call-to-action section.

LANGUAGE: html
CODE:
<div><blog-overview></blog-overview></div>

<div>
  <hr />
  <h2>Like what you see?</h2>
  <p>
    Preact is free to use so that everyone can take part in building on
    the web. Thanks to all the awesome sponsors who make working on Preact
    possible! If you want to become one of them, consider
    <a href="https://opencollective.com/preact">a donation</a>.
  </p>
</div>

----------------------------------------

TITLE: Using Refs in Class Components
DESCRIPTION: Demonstrates how to use refs in a class component by creating them as class properties and accessing them in lifecycle methods like componentDidMount.

LANGUAGE: jsx
CODE:
import { createRef, Component } from 'preact';

export default class App extends Component {
  input = createRef()

  // this function runs after <App> is rendered
  componentDidMount() {
    // access the associated DOM element:
    this.input.current.focus();
  }

  render() {
    return <input ref={this.input} />
  }
}

----------------------------------------

TITLE: Repository Result Item Component in Preact
DESCRIPTION: A presentation component that renders individual repository search results, displaying the repository name as a link, star count, and description.

LANGUAGE: JavaScript
CODE:
const Result = result => (
	<div class="list-item">
		<div>
			<a href={result.html_url} target="_blank" rel="noopener noreferrer">
				{result.full_name}
			</a>
			{' - '}
			<strong>{result.stargazers_count}</strong>
		</div>
		<p>{result.description}</p>
	</div>
);

----------------------------------------

TITLE: Event Bubbling Control with State Management
DESCRIPTION: Illustrates a scenario dealing with event bubbling and state management, showing how event-clock implementation prevents unintended state toggles during event propagation.

LANGUAGE: jsx
CODE:
const App = () => {
  const [toggled, setToggled] = useState(false);

  return toggled ? (
    <div onClick={() => setToggled(false)}>
      <span>clear</span>
    </div> 
  ) : (
    <div>
      <button
        onClick={() => setToggled(true)}
      >toggle on</button>
    </div>
  )
}

----------------------------------------

TITLE: Using Refs with DOM Elements in JSX
DESCRIPTION: Shows how to create a ref and pass it to a Virtual DOM element, then access the corresponding HTML element to perform actions like focusing an input.

LANGUAGE: jsx
CODE:
import { createRef } from 'preact';

// create a ref:
const input = createRef()

// pass the ref as a prop on a Virtual DOM element:
render(<input ref={input} />, document.body)

// access the associated DOM element:
input.current // an HTML <input> element
input.current.focus() // focus the input!

----------------------------------------

TITLE: Comparing Event Handling in React and Preact
DESCRIPTION: Demonstrates the difference in handling input changes between React (onChange) and Preact (onInput).

LANGUAGE: jsx
CODE:
// React
<input onChange={e => console.log(e.currentTarget.value)} />

// Preact
<input onInput={e => console.log(e.currentTarget.value)} />

----------------------------------------

TITLE: Creating and Using Refs in JavaScript
DESCRIPTION: Demonstrates how to create, read, update, and pass around ref objects using the createRef function from Preact.

LANGUAGE: javascript
CODE:
import { createRef } from 'preact'

// create a ref:
const ref = createRef('initial value')
// { current: 'initial value' }

// read a ref's current value:
ref.current === 'initial value'

// update a ref's current value:
ref.current = 'new value'

// pass refs around:
console.log(ref) // { current: 'new value' }

----------------------------------------

TITLE: Server App Implementation with Bundle Manifest
DESCRIPTION: Server-side implementation showing how to render components and include client-side bundles using a manifest file.

LANGUAGE: javascript
CODE:
import preactRenderToString from 'preact-render-to-string'
import HomePage from '../pages/HomePage.js'
import { h } from 'preact'
import { withManifestBundles } from '../lib/html.js'

const app = express()

app.get('/', async (req, res) => {
  res.send(
    withManifestBundles({
      body: preactRenderToString(h(HomePage, {})),
    })
  )
})

----------------------------------------

TITLE: Conditional Component Rendering
DESCRIPTION: Shows how to conditionally render different components based on props using ternary operators.

LANGUAGE: jsx
CODE:
function MediaPlayer(props) {
  return (
    <div>
      {props.playing ? (
        <MyButton text="Stop" />
      ) : (
        <MyButton text="Play" />
      )}
    </div>
  )
}

----------------------------------------

TITLE: Manual Aliasing in Node without module-alias
DESCRIPTION: Node.js script to manually alias React modules to Preact using internal Node.js module system properties.

LANGUAGE: js
CODE:
var React = require('react')
var ReactDOM = require('react-dom')
var ReactDOMServer = require('react-dom/server')
var CreateReactClass = require('create-react-class')
var Preact = require('preact-compat/dist/preact-compat.min')
var Module = module.constructor
Module._cache[require.resolve('react')].exports = Preact
Module._cache[require.resolve('react-dom')].exports = Preact
Module._cache[require.resolve('create-react-class')].exports.default = Preact.createClass

----------------------------------------

TITLE: Preact with HTM (Alternative to JSX)
DESCRIPTION: Implementation using HTM as a JSX alternative that works in standard JavaScript without build steps.

LANGUAGE: html
CODE:
<script type="module">
  import { h, render } from 'https://esm.sh/preact';
  import htm from 'https://esm.sh/htm';

  // Initialize htm with Preact
  const html = htm.bind(h);

  function App (props) {
    return html`<h1>Hello ${props.name}!</h1>`;
  }

  render(html`<${App} name="World" />`, document.body);
</script>

----------------------------------------

TITLE: Complete Preact App with Click Handler
DESCRIPTION: Final implementation of the Preact application with a functional click handler that logs to the console.

LANGUAGE: jsx
CODE:
import { render } from "preact";

function App() {
  const clicked = () => {
    console.log('hi')
  }

  return (
    <div>
      <p class="count">Count:</p>
      <button onClick={clicked}>Click Me!</button>
    </div>
  )
}

render(<App />, document.getElementById("app"));

----------------------------------------

TITLE: Creating and Rendering a Virtual DOM Element with createElement()
DESCRIPTION: Shows how to use Preact's createElement() function to create a Virtual DOM element and render it to the document body.

LANGUAGE: jsx
CODE:
import { createElement, render } from 'preact';

let vdom = createElement(
  'p',              // a <p> element
  { class: 'big' }, // with class="big"
  'Hello World!'    // and the text "Hello World!"
);

render(vdom, document.body);

----------------------------------------

TITLE: Initial Preact App Setup
DESCRIPTION: Basic Preact application setup with a button component awaiting click handler implementation.

LANGUAGE: jsx
CODE:
import { render } from "preact";

function App() {
  return (
    <div>
      <p class="count">Count:</p>
      <button>Click Me!</button>
    </div>
  )
}

render(<App />, document.getElementById("app"));

----------------------------------------

TITLE: Webpack React-to-Preact Aliasing Configuration
DESCRIPTION: Webpack configuration for aliasing React imports to Preact compatibility layer.

LANGUAGE: javascript
CODE:
const config = {
   //...snip
  "resolve": {
    "alias": {
      "react": "preact/compat",
      "react-dom/test-utils": "preact/test-utils",
      "react-dom": "preact/compat",     // Must be below test-utils
      "react/jsx-runtime": "preact/jsx-runtime"
    },
  }
}

----------------------------------------

TITLE: Interactive Preact Component Example
DESCRIPTION: An interactive example of a Preact component rendering a styled paragraph, used as a starting point for tutorial exercises.

LANGUAGE: jsx
CODE:
import { createElement, render } from 'preact';

function App() {
  return (
    <p class="big">Hello World!</p>
  );
}

render(<App />, document.getElementById("app"));

----------------------------------------

TITLE: Implementing App Component with Context Provider
DESCRIPTION: Defines the main App component that manages the counter state and provides it to child components using Context.Provider.

LANGUAGE: JSX
CODE:
function App() {
	const [count, setCount] = useState(0);

	function increment() {
		setCount(count + 1);
	}

	const counter = useMemo(() => ({ count, increment }), [count]);

	return (
		<CounterContext.Provider value={counter}>
			<div style={{ display: 'flex', gap: '20px' }}>
				<Counter />
				<Counter />
				<Counter />
			</div>
		</CounterContext.Provider>
	);
}

----------------------------------------

TITLE: Basic Import Map Setup with Preact
DESCRIPTION: Demonstrates basic usage of Import Maps with Preact and HTM to create a simple Hello World application. Shows how to configure module resolution and handle external dependencies.

LANGUAGE: html
CODE:
<!DOCTYPE html>
<html>
  <head>
    <script type="importmap">
      {
        "imports": {
          "preact": "https://esm.sh/preact@10.23.1",
          "htm/preact": "https://esm.sh/htm@3.1.1/preact?external=preact"
        }
      }
    </script>
  </head>
  <body>
    <div id="app"></div>

    <script type="module">
      import { render } from 'preact';
      import { html } from 'htm/preact';

      export function App() {
        return html`<h1>Hello, World!</h1>`;
      }

      render(html`<${App} />`, document.getElementById('app'));
    </script>
  </body>
</html>

----------------------------------------

TITLE: Correct Ways to Render Preact Components
DESCRIPTION: Demonstrates the correct methods for rendering Preact components, avoiding common pitfalls like direct invocation.

LANGUAGE: jsx
CODE:
const App = () => <div>foo</div>;

// DON'T: Invoking components directly means they won't be counted as a
// VNode and hence not be able to use functionality relating to vnodes.
render(App(), rootElement); // ERROR
render(App, rootElement); // ERROR

// DO: Passing components using createElement() or JSX allows Preact to render correctly:
render(createElement(App), rootElement); // success
render(<App />, rootElement); // success

----------------------------------------

TITLE: Creating Counter Context
DESCRIPTION: Creates a context for sharing counter state across components.

LANGUAGE: JavaScript
CODE:
const CounterContext = createContext(null);

----------------------------------------

TITLE: Creating a Virtual DOM Element with HTM
DESCRIPTION: Demonstrates how to use HTM (Hyperscript Tagged Markup) to create a Virtual DOM element, an alternative to JSX that doesn't require compilation.

LANGUAGE: javascript
CODE:
import { html } from 'htm/preact';

let maybeBig = Math.random() > .5 ? 'big' : 'small';

let vdom = html`<p class=${maybeBig}>Hello ${40 + 2}!</p>`;

----------------------------------------

TITLE: Import Map Configuration for Preact with Hooks and Signals
DESCRIPTION: Example of configuring Import Maps to include Preact Hooks, Signals, and HTM support. Shows proper external dependency handling to avoid duplication.

LANGUAGE: html
CODE:
<script type="importmap">
  {
    "imports": {
      "preact": "https://esm.sh/preact@10.23.1",
      "preact/": "https://esm.sh/preact@10.23.1/",
      "@preact/signals": "https://esm.sh/@preact/signals@1.3.0?external=preact",
      "htm/preact": "https://esm.sh/htm@3.1.1/preact?external=preact"
    }
  }
</script>

----------------------------------------

TITLE: Enzyme Rendering Modes Example
DESCRIPTION: Demonstration of Enzyme's three rendering modes: mount, shallow, and render

LANGUAGE: javascript
CODE:
import { mount, shallow, render } from 'enzyme';

// Render the full component tree:
const wrapper = mount(<MyComponent prop="value"/>);

// Render only `MyComponent`'s direct output (ie. "mock" child components
// to render only as placeholders):
const wrapper = shallow(<MyComponent prop="value"/>);

// Render the full component tree to an HTML string, and parse the result:
const wrapper = render(<MyComponent prop="value"/>);

----------------------------------------

TITLE: Configuring Enzyme for Preact
DESCRIPTION: Setup code to configure Enzyme to use the Preact adapter

LANGUAGE: javascript
CODE:
import { configure } from 'enzyme';
import Adapter from 'enzyme-adapter-preact-pure';

configure({ adapter: new Adapter });

----------------------------------------

TITLE: HTM Counter Component Example
DESCRIPTION: Demonstrates using HTM with Preact to create a counter component with hooks and custom button components. Shows HTM's template literal syntax as an alternative to JSX.

LANGUAGE: javascript
CODE:
import { render } from 'preact';
import { useState } from 'preact/hooks';
import { html } from 'htm/preact';

function Button({ action, children }) {
	return html`<button onClick=${action}>${children}</button>`;
}

function Counter() {
	const [count, setCount] = useState(0);

	return html`
		<div class="counter-container">
			<${Button} action=${() => setCount(count + 1)}>Increment<//>>
			<input readonly value=${count} />
			<${Button} action=${() => setCount(count - 1)}>Decrement<//>)
		</div>
	`;
}

----------------------------------------

TITLE: Installing Enzyme with Preact Adapter
DESCRIPTION: npm command to install Enzyme and the Preact adapter as development dependencies

LANGUAGE: bash
CODE:
npm install --save-dev enzyme enzyme-adapter-preact-pure

----------------------------------------

TITLE: Creating Custom Render Function with Context Providers in Preact
DESCRIPTION: Example of creating a custom render function that includes context providers, useful for testing components that depend on shared context state.

LANGUAGE: jsx
CODE:
// helpers.js
import { render as originalRender } from '@testing-library/preact';
import { createMemoryHistory } from 'history';
import { FooContext } from './foo';

const history = createMemoryHistory();

export function render(vnode) {
  return originalRender(
    <FooContext.Provider value="foo">
      <Router history={history}>
        {vnode}
      </Router>
    </FooContext.Provider>
  );
}

// Usage like usual. Look ma, no providers!
render(<MyComponent />)

----------------------------------------

TITLE: Creating a Stateless Functional Component in Preact
DESCRIPTION: This example demonstrates how to create a Stateless Functional Component in Preact using an arrow function and destructuring.

LANGUAGE: javascript
CODE:
const Link = ({ children, ...props }) => (
	<a {...props}>{ children }</a>
);

----------------------------------------

TITLE: Shallow Rendering Example
DESCRIPTION: Demonstration of shallow rendering which only renders the top level of components.

LANGUAGE: jsx
CODE:
import { shallow } from 'preact-render-to-string';
import { h } from 'preact';

const Foo = () => <div>foo</div>;
const App = <div class="foo"><Foo /></div>;

console.log(shallow(App));
// <div class="foo"><Foo /></div>

----------------------------------------

TITLE: Using Spread Operator with Props in Preact
DESCRIPTION: This snippet shows how to use the spread operator to pass all props directly to a child element in a Preact component.

LANGUAGE: javascript
CODE:
class Link extends Component {
	render(props) {
		return <a {...props} />;
	}
}

----------------------------------------

TITLE: Typing Function Components in Preact
DESCRIPTION: Examples of typing function components in Preact, including prop interfaces, default props, and using the FunctionComponent type.

LANGUAGE: tsx
CODE:
interface MyComponentProps {
  name: string;
  age: number;
};

function MyComponent({ name, age }: MyComponentProps) {
  return (
    <div>
      My name is {name}, I am {age.toString()} years old.
    </div>
  );
}

LANGUAGE: tsx
CODE:
import { h, FunctionComponent } from "preact";

const Card: FunctionComponent<{ title: string }> = ({ title, children }) => {
  return (
    <div class="card">
      <h1>{title}</h1>
      {children}
    </div>
  );
};

----------------------------------------

TITLE: Installing Signals Package
DESCRIPTION: Command to install the @preact/signals package using npm.

LANGUAGE: bash
CODE:
npm install @preact/signals

----------------------------------------

TITLE: Destructuring Props in a Preact Component
DESCRIPTION: This example demonstrates how to use ES6 destructuring to simplify prop handling in a Preact component's render method.

LANGUAGE: javascript
CODE:
class Link extends Component {
	render({ href, children }) {
		return <a {...{ href, children }} />;
	}
}

----------------------------------------

TITLE: Configuring Babel for Preact JSX
DESCRIPTION: Babel configuration to set the JSX pragma to 'h' for Preact.

LANGUAGE: json
CODE:
{
  "plugins": [
    ["transform-react-jsx", { "pragma": "h" }]
  ]
}

----------------------------------------

TITLE: Implementing a Basic Link Component in Preact
DESCRIPTION: This snippet demonstrates how to create a basic Link component using a class-based approach in Preact. It renders an anchor tag with href and children props.

LANGUAGE: javascript
CODE:
class Link extends Component {
	render(props, state) {
		return <a href={props.href}>{ props.children }</a>;
	}
}

----------------------------------------

TITLE: Configuring Babel for TypeScript and Preact
DESCRIPTION: Babel configuration for transpiling TypeScript with Preact JSX support. Includes settings for preserving JSX and using Babel for transpilation.

LANGUAGE: json
CODE:
{
  "compilerOptions": {
    "jsx": "preserve",
    "jsxFactory": "h",
    "jsxFragmentFactory": "Fragment",
    //...
  }
}

LANGUAGE: javascript
CODE:
{
  presets: [
    "@babel/env",
    ["@babel/typescript", { jsxPragma: "h" }],
  ],
  plugins: [
    ["@babel/transform-react-jsx", { pragma: "h" }]
  ],
}

----------------------------------------

TITLE: Installing Preact
DESCRIPTION: Command to install Preact package using npm.

LANGUAGE: bash
CODE:
npm install --save preact  # or: npm i -S preact

----------------------------------------

TITLE: Creating a Virtual DOM Object in JavaScript
DESCRIPTION: Demonstrates how to create a simple Virtual DOM object representing a paragraph element with a class and text content.

LANGUAGE: javascript
CODE:
let vdom = {
  type: 'p',         // a <p> element
  props: {
    class: 'big',    // with class="big"
    children: [
      'Hello World!' // and the text "Hello World!"
    ]
  }
}

----------------------------------------

TITLE: Updating import statements for Preact X
DESCRIPTION: Examples of how to update import statements when migrating from Preact 8.x to Preact X, including the recommended use of named exports.

LANGUAGE: js
CODE:
// Preact 8.x
import Preact from "preact";

// Preact X
import * as preact from "preact";

// Preferred: Named exports (works in 8.x and Preact X)
import { h, Component } from "preact";

----------------------------------------

TITLE: Creating Preact Class Alias
DESCRIPTION: JavaScript module to alias create-react-class to Preact's createClass function.

LANGUAGE: js
CODE:
import { createClass } from 'preact-compat/dist/preact-compat.min'
export default createClass

----------------------------------------

TITLE: Using memo HOC in Preact
DESCRIPTION: Demonstrates using the memo higher-order component for optimizing functional components with optional custom comparison functions.

LANGUAGE: jsx
CODE:
import { memo } from 'preact/compat';

function MyComponent(props) {
  return <div>Hello {props.name}</div>
}

// Usage with default comparison function
const Memoed = memo(MyComponent);

// Usage with custom comparison function
const Memoed2 = memo(MyComponent, (prevProps, nextProps) => {
  // Only re-render when `name' changes
  return prevProps.name === nextProps.name;
})

----------------------------------------

TITLE: Radio Button Group Implementation with Basic linkState in Preact
DESCRIPTION: Example showing an incorrect implementation of radio button groups using basic linkState. This demonstrates common pitfalls in state management.

LANGUAGE: javascript
CODE:
import linkState from 'linkstate';

class Foo extends Component {
  render({ }, { yes, no }) {
    return (
      <div>
        <input type="radio" name="demo"
          value="yes" checked={yes}
          onChange={linkState(this, 'yes')}
        />
        <input type="radio" name="demo"
          value="no" checked={no}
          onChange={linkState(this, 'no')}
        />
      </div>
    );
  }
}

----------------------------------------

TITLE: Using toChildArray for props.children in Preact X
DESCRIPTION: Shows how to use the toChildArray function to ensure props.children is always an array in Preact X, which is necessary when using array methods on children.

LANGUAGE: jsx
CODE:
import { toChildArray } from "preact";

function Foo(props) {
  const count = toChildArray(props.children).length;
  return <div>I have {count} children </div>;
}

----------------------------------------

TITLE: Custom Event Handler Equivalent to linkState in Preact
DESCRIPTION: Illustrates the internal workings of linkState by showing an equivalent manual event handler implementation. This demonstrates how linkState processes event paths.

LANGUAGE: javascript
CODE:
// this handler returned from linkState:
handler = linkState(this, 'thing', 'foo.bar');

// ...is functionally equivalent to:
handler = event => {
  this.setState({
    thing: event.foo.bar
  });
}

----------------------------------------

TITLE: Implementing Counter Component with Preact Hooks
DESCRIPTION: This snippet defines a Counter component using Preact hooks. It maintains a count state and provides buttons to increment and decrement the count. The component is then rendered to the DOM.

LANGUAGE: JavaScript
CODE:
import { render } from 'preact';
import { useState } from 'preact/hooks';

function Counter() {
	const [count, setCount] = useState(0);

	return (
		<div class="counter-container">
			<button onClick={() => setCount(count + 1)}>Increment</button>
			<input readonly value={count} />
			<button onClick={() => setCount(count - 1)}>Decrement</button>
		</div>
	);
}

render(<Counter />, document.getElementById('app'));

----------------------------------------

TITLE: Implementing Fragments in Preact X
DESCRIPTION: Demonstrates how to use Fragments in Preact X to return multiple nodes from a component without an extra wrapping DOM element.

LANGUAGE: jsx
CODE:
function Foo() {
  return (
    <>
      <div>A</div>
      <div>B</div>
    </>
  )
}

----------------------------------------

TITLE: Implementing a Ticking Clock Component
DESCRIPTION: Shows how to create a Clock component that updates every second using Preact's component lifecycle methods. This example demonstrates state management and interval handling.

LANGUAGE: javascript
CODE:
import { h, render, Component } from 'preact';

class Clock extends Component {
	constructor() {
		super();
		// set initial time:
		this.state = { time: Date.now() };
	}

	componentDidMount() {
		// update time every second
		this.timer = setInterval(() => {
			this.setState({ time: Date.now() });
		}, 1000);
	}

	componentWillUnmount() {
		// stop when not renderable
		clearInterval(this.timer);
	}

	render(props, state) {
		let time = new Date(state.time).toLocaleTimeString();
		return <span>{ time }</span>;
	}
}

// render an instance of Clock into <body>:
render(<Clock />, document.body);

----------------------------------------

TITLE: Creating a Counter Component with Preact Hooks
DESCRIPTION: This snippet demonstrates how to create a counter component using Preact hooks. It uses useState to manage the count state and updates it when a button is clicked. The component renders the current count and a button to increment it.

LANGUAGE: jsx
CODE:
import { render } from 'preact';
import { useState } from 'preact/hooks';

function MyButton(props) {
  return <button style={props.style} onClick={props.onClick}>{props.children}</button>
}

function App() {
  const [count, setCount] = useState(0)

  const clicked = () => {
    setCount(count + 1)
  }

  return (
    <div>
      <p class="count">Count: {count}</p>
      <MyButton style={{ color: 'purple' }} onClick={clicked}>Click me</MyButton>
    </div>
  )
}

render(<App />, document.getElementById("app"));

----------------------------------------

TITLE: Creating a Simple Clock Component
DESCRIPTION: Demonstrates how to create a basic Preact component that displays the current time. This example shows the component structure and how to use the render method.

LANGUAGE: javascript
CODE:
import { h, render, Component } from 'preact';

class Clock extends Component {
	render() {
		let time = new Date().toLocaleTimeString();
		return <span>{ time }</span>;
	}
}

// render an instance of Clock into <body>:
render(<Clock />, document.body);

----------------------------------------

TITLE: Using CSS Custom Properties in Preact X
DESCRIPTION: Demonstrates how to use CSS variables (custom properties) in Preact X components for styling.

LANGUAGE: jsx
CODE:
function Foo(props) {
  return <div style={{ '--theme-color': 'blue' }}>{props.children}</div>;
}

----------------------------------------

TITLE: Shorthand DOM Mutation Prevention in Preact
DESCRIPTION: Alternative arrow function syntax for implementing shouldComponentUpdate to prevent component re-rendering.

LANGUAGE: javascript
CODE:
class Block extends Component {
  shouldComponentUpdate = () => false;
}

----------------------------------------

TITLE: Installing Preact and preact-compat
DESCRIPTION: Command to install Preact and preact-compat packages using npm.

LANGUAGE: bash
CODE:
npm i -S preact preact-compat

----------------------------------------

TITLE: Importing React Compatibility Layer in Preact X
DESCRIPTION: Shows the updated import statement for the React compatibility layer in Preact X, which is now included in the core package.

LANGUAGE: js
CODE:
// Preact 8.x
import React from "preact-compat";

// Preact X
import React from "preact/compat";

----------------------------------------

TITLE: Basic DOM Mutation Prevention in Preact
DESCRIPTION: Simple implementation of shouldComponentUpdate to prevent Preact from re-rendering a component. This allows external DOM mutations to persist.

LANGUAGE: javascript
CODE:
class Block extends Component {
  shouldComponentUpdate() {
    return false;
  }
}

----------------------------------------

TITLE: Configuring Babel for JSX Transformation (Default Import)
DESCRIPTION: Demonstrates Babel configuration for transforming JSX into preact.h() calls when using default import of Preact, with examples for different Babel versions.

LANGUAGE: json
CODE:
{
  "plugins": [
    ["@babel/plugin-transform-react-jsx", { "pragma":"preact.h" }]
  ]
}

----------------------------------------

TITLE: Embedding Preact Branding Component in Markdown
DESCRIPTION: This snippet demonstrates how to include a custom 'branding' component within a Markdown file. The component likely renders various Preact logo and symbol variations for visual reference.

LANGUAGE: html
CODE:
<branding></branding>

----------------------------------------

TITLE: Using Preact.render() Function
DESCRIPTION: Demonstrates how to use Preact's render() function to mount components to the DOM. Shows both appending new elements and replacing existing DOM nodes.

LANGUAGE: javascript
CODE:
import { render } from 'preact';

// These examples show how render() behaves in a page with the following markup:
// <div id="container">
//   <h1>My App</h1>
// </div>

const container = document.getElementById('container');

render(MyComponent, container);
// Append MyComponent to container
//
// <div id="container">
//   <h1>My App</h1>
//   <MyComponent />
// </div>

const existingNode = container.querySelector('h1');

render(MyComponent, container, existingNode);
// Diff MyComponent against <h1>My App</h1>
//
// <div id="container">
//   <MyComponent />
// </div>

----------------------------------------

TITLE: Effects Implementation with Signals
DESCRIPTION: Shows how to create and use effects that automatically react to signal changes.

LANGUAGE: javascript
CODE:
import { signal, computed, effect } from "@preact/signals-core";

const count = signal(1);
const double = computed(() => count.value * 2);
const quadruple = computed(() => double.value * 2);

effect(() => {
  console.log("quadruple is now", quadruple.value);
});

----------------------------------------

TITLE: Class Component Implementation
DESCRIPTION: Example of creating a class-based component with lifecycle methods in Preact.

LANGUAGE: jsx
CODE:
import { Component } from 'preact';

class MyButton extends Component {
  componentDidMount() {
    console.log('Hello from a new <MyButton> component!')
  }
  componentDidUpdate() {
    console.log('A <MyButton> component was updated!')
  }
  render(props) {
    return <button class="my-button">{props.children}</button>
  }
}

----------------------------------------

TITLE: Hyperscript Example in Preact
DESCRIPTION: Demonstrates Preact's h() function usage, which is a more generalized version of React.createElement. Shows how to create nested elements using the hyperscript pattern.

LANGUAGE: javascript
CODE:
h('a', { href:'/' }, h('span', null, 'Home'))

----------------------------------------

TITLE: Using Custom Elements in Markdown (Markdown)
DESCRIPTION: Example of using custom Preact components within Markdown content for the Preact documentation. This demonstrates how to create dynamic or repeated content like logos and jumbotrons.

LANGUAGE: markdown
CODE:
## Example Page

<!-- Jumbotron and Logo are actually Preact components! -->
<jumbotron>
    <h1><logo text>Preact</logo></h1>
</jumbotron>

----------------------------------------

TITLE: Error Handling with useErrorBoundary Hook in Preact
DESCRIPTION: This snippet demonstrates how to use the useErrorBoundary hook to catch and handle errors in child components.

LANGUAGE: jsx
CODE:
const App = props => {
  const [error, resetError] = useErrorBoundary(
    error => callMyApi(error.message)
  );
  
  if (error) {
    return (
      <div>
        <p>{error.message}</p>
        <button onClick={resetError}>Try again</button>
      </div>
    );
  } else {
    return <div>{props.children}</div>
  }
};

----------------------------------------

TITLE: Creating Mixin-Enabled Component in Preact
DESCRIPTION: Implements a MixedComponent class that extends Preact's Component to support mixing in additional methods and properties. The constructor automatically assigns mixin properties to the component instance.

LANGUAGE: javascript
CODE:
class MixedComponent extends Component {
    constructor() {
        super();
        (this.mixins || []).forEach( m => Object.assign(this, m) );
    }
}

----------------------------------------

TITLE: Implementing Controlled Checkbox Component in Preact
DESCRIPTION: This code snippet demonstrates how to create a controlled checkbox component in Preact. It uses the onClick event instead of onChange to toggle the checkbox state, and updates the component's state to reflect the new value.

LANGUAGE: javascript
CODE:
class MyForm extends Component {
    toggle = e => {
        let checked = !this.state.checked;
        this.setState({ checked });
    };
    render({ }, { checked }) {
        return (
            <label>
                <input
                    type="checkbox"
                    checked={checked}
                    onClick={this.toggle} />
            </label>
        );
    }
}

----------------------------------------

TITLE: Importing Preact Components (Named Import)
DESCRIPTION: Demonstrates how to import specific components from Preact using named imports. This method is suitable for highly structured applications.

LANGUAGE: javascript
CODE:
import { h, render, Component } from 'preact';

// Tell Babel to transform JSX into h() calls:
/** @jsx h */

----------------------------------------

TITLE: Complete Ticking Clock Component
DESCRIPTION: Full implementation of a Clock component with lifecycle methods for updating time every second

LANGUAGE: javascript
CODE:
import { h, render, Component } from 'preact';

class Clock extends Component {
	constructor() {
		super();
		// set initial time:
		this.state.time = Date.now();
	}

	componentDidMount() {
		// update time every second
		this.timer = setInterval(() => {
			this.setState({ time: Date.now() });
		}, 1000);
	}

	componentWillUnmount() {
		// stop when not renderable
		clearInterval(this.timer);
	}

	render(props, state) {
		let time = new Date(state.time).toLocaleTimeString();
		return <span>{ time }</span>;
	}
}

// render an instance of Clock into <body>:
render(<Clock />, document.body);

----------------------------------------

TITLE: Importing Preact (Default Import)
DESCRIPTION: Shows how to import Preact as a default import, which is quick and doesn't need updating when using different parts of the library.

LANGUAGE: javascript
CODE:
import preact from 'preact';

// Tell Babel to transform JSX into preact.h() calls:
/** @jsx preact.h */

----------------------------------------

TITLE: Consuming Context with useContext Hook in Preact
DESCRIPTION: Shows how to use the useContext hook to access context values in function components. The example demonstrates a ThemedButton component using the ThemePrimary context.

LANGUAGE: jsx
CODE:
const ThemePrimary = createContext("#673ab8");

function ThemedButton() {
  const theme = useContext(ThemePrimary);
  return <button style={{ background: theme }}>Themed Button</button>;
}

function App() {
  return (
    <ThemePrimary.Provider value="#8f61e1">
      <SomeComponent>
        <ThemedButton />
      </SomeComponent>
    </ThemePrimary.Provider>
  );
}

----------------------------------------

TITLE: Loading Preact via CDN
DESCRIPTION: Demonstrates how to include Preact in an HTML file using a CDN link, both as a regular script and as a JavaScript module.

LANGUAGE: html
CODE:
<script src="https://cdn.jsdelivr.net/npm/preact/dist/preact.min.js"></script>

<!-- To load Preact as a JS Module: -->
<script src="https://cdn.jsdelivr.net/npm/preact/dist/preact.mjs" type="module"></script>

----------------------------------------

TITLE: Extending JSX Types in Preact
DESCRIPTION: Examples of extending built-in JSX types for custom elements and attributes in Preact.

LANGUAGE: tsx
CODE:
// global.d.ts

declare global {
  namespace preact.JSX {
    interface IntrinsicElements {
      'loading-bar': { showing: boolean };
    }
  }
}

export {}

LANGUAGE: tsx
CODE:
// global.d.ts

declare global {
  namespace preact.JSX {
    interface HTMLAttributes {
      custom?: string | undefined;
    }
  }
}

export {}

----------------------------------------

TITLE: Configuring Babel for JSX Transformation (Named Import)
DESCRIPTION: Shows how to configure Babel to transform JSX into h() calls for named imports of Preact, with examples for different Babel versions.

LANGUAGE: json
CODE:
{
  "plugins": [
    ["@babel/plugin-transform-react-jsx", { "pragma":"h" }]
  ]
}

----------------------------------------

TITLE: Importing Preact (Default Import)
DESCRIPTION: Shows how to import Preact using default import syntax and configure JSX transformation

LANGUAGE: javascript
CODE:
import preact from 'preact';

// Tell Babel to transform JSX into preact.h() calls:
/** @jsx preact.h */

----------------------------------------

TITLE: Rendering JSX with Preact
DESCRIPTION: Illustrates how to use Preact's h() and render() functions to create and render JSX elements to the DOM. This example creates a div with a span and a button.

LANGUAGE: javascript
CODE:
import { h, render } from 'preact';

render((
	<div id="foo">
		<span>Hello, world!</span>
		<button onClick={ e => alert("hi!") }>Click Me</button>
	</div>
), document.body);

----------------------------------------

TITLE: Removing preact-compat package
DESCRIPTION: Command to remove the now unnecessary preact-compat package using npm.

LANGUAGE: bash
CODE:
npm remove preact-compat

----------------------------------------

TITLE: Implementing Component State Using ES7 Class Properties in Preact
DESCRIPTION: Example showing how to update component state using ES7 class properties and arrow functions. This approach provides better runtime performance compared to inline arrow functions.

LANGUAGE: javascript
CODE:
class Foo extends Component {
	updateText = e => {
		this.setState({ text: e.target.value });
	};
	render({ }, { text }) {
		return <input value={text} onInput={this.updateText} />;
	}
}

----------------------------------------

TITLE: Testing Counter Component with Async Query in Preact
DESCRIPTION: Example of testing the Counter component using an async-first approach with the 'findBy' query in Preact Testing Library.

LANGUAGE: jsx
CODE:
test('should increment counter', async () => {
  render(<Counter initialCount={5}/>);

  fireEvent.click(screen.getByText('Increment'));

  await screen.findByText('Current value: 6');
  
  expect(screen.getByText("Current value: 6")).toBeInTheDocument();
});

----------------------------------------

TITLE: Configuring Webpack Alias for Preact
DESCRIPTION: Webpack configuration to alias React imports to preact-compat.

LANGUAGE: json
CODE:
{
  "resolve": {
    "alias": {
      "react": "preact-compat",
      "react-dom": "preact-compat"
    }
  }
}

----------------------------------------

TITLE: Using Signals in a Preact Component
DESCRIPTION: Shows how to use signals within a Preact component for automatic re-rendering on value changes.

LANGUAGE: jsx
CODE:
import { signal } from "@preact/signals";

const count = signal(0);

function Counter() {
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => count.value++}>click me</button>
    </div>
  );
}

----------------------------------------

TITLE: Configuring Parcel Alias for Preact
DESCRIPTION: Package.json configuration to alias React imports to preact-compat using Parcel.

LANGUAGE: json
CODE:
{
  "alias": {
    "react": "preact-compat",
    "react-dom": "preact-compat"
  }
}

----------------------------------------

TITLE: Storing Local Values with Refs in Preact (Class and Function Components)
DESCRIPTION: Illustrates how to use refs to store local values, such as interval IDs, in both class and function components. This example implements a simple clock that can be started and stopped.

LANGUAGE: jsx
CODE:
import { render, Component, createRef } from "preact";

class SimpleClock extends Component {
  state = {
    time: Date.now(),
  };
  intervalId = createRef(null);

  startClock = () => {
    this.setState({ time: Date.now() });
    this.intervalId.current = setInterval(() => {
      this.setState({ time: Date.now() });
    }, 1000);
  };

  stopClock = () => {
    clearInterval(this.intervalId.current);
  };


  render(_, { time }) {
    const formattedTime = new Date(time).toLocaleTimeString();

    return (
      <div>
        <button onClick={this.startClock}>Start Clock</button>
        <time dateTime={formattedTime}>{formattedTime}</time>
        <button onClick={this.stopClock}>Stop Clock</button>
      </div>
    );
  }
}

render(<SimpleClock />, document.getElementById("app"));

LANGUAGE: jsx
CODE:
import { render } from "preact";
import { useState, useRef } from "preact/hooks";

function SimpleClock() {
  const [time, setTime] = useState(Date.now());
  const intervalId = useRef(null);

  const startClock = () => {
    setTime(Date.now());
    intervalId.current = setInterval(() => {
      setTime(Date.now());
    }, 1000);
  };

  const stopClock = () => {
    clearInterval(intervalId.current);
  };

  const formattedTime = new Date(time).toLocaleTimeString();

  return (
    <div>
      <button onClick={startClock}>Start Clock</button>
      <time dateTime={formattedTime}>{formattedTime}</time>
      <button onClick={stopClock}>Stop Clock</button>
    </div>
  );
}

render(<SimpleClock />, document.getElementById("app"));

----------------------------------------

TITLE: Aliasing React to Preact in Node using module-alias
DESCRIPTION: Node.js script to alias React imports to preact-compat using the module-alias package.

LANGUAGE: js
CODE:
var path = require('path')
var moduleAlias = require('module-alias')

moduleAlias.addAliases({
  'react': 'preact-compat/dist/preact-compat.min',
  'react-dom': 'preact-compat/dist/preact-compat.min',
  'create-react-class': path.resolve(__dirname, './create-preact-class')
})

----------------------------------------

TITLE: Clock Component with Lifecycle Methods
DESCRIPTION: Implements a ticking clock component demonstrating component lifecycle methods and interval-based state updates.

LANGUAGE: jsx
CODE:
import { h, render, Component } from 'preact';

class Clock extends Component {
  state = { time: Date.now() };

  componentDidMount() {
    this.timer = setInterval(() => {
      this.setState({ time: Date.now() });
    }, 1000);
  }

  componentWillUnmount() {
    clearInterval(this.timer);
  }

  render() {
    let time = new Date(this.state.time).toLocaleTimeString();
    return <span>{time}</span>;
  }
}

render(<Clock />, document.getElementById("app"));

----------------------------------------

TITLE: Rendering a Link Component in Preact JSX
DESCRIPTION: This snippet shows how to instantiate and render the Link component in Preact using JSX syntax.

LANGUAGE: xml
CODE:
<Link href="http://example.com">Some Text</Link>

----------------------------------------

TITLE: Using Test IDs for Element Selection in Preact Tests
DESCRIPTION: Example of using test IDs (data attributes) to select elements in Preact tests when content-based selection is not suitable.

LANGUAGE: jsx
CODE:
function Foo({ onClick }) {
  return (
    <button onClick={onClick} data-testid="foo">
      click here
    </button>
  );
}

// Only works if the text stays the same
fireEvent.click(screen.getByText('click here'));

// Works if we change the text
fireEvent.click(screen.getByTestId('foo'));

----------------------------------------

TITLE: Sample Counter Component Implementation
DESCRIPTION: Example Preact component that implements a simple counter with increment functionality

LANGUAGE: javascript
CODE:
import { Component, h } from 'preact';

export default class Counter extends Component {
  constructor(props) {
    super(props);

    this.state = {
      count: props.initialCount,
    };
  };

  render() {
    const increment = () => this.setState(({ count }) => ({
      count: count + 1,
    }));

    return (
      <div>
        Current value: {this.state.count}
        <button onClick={increment}>Increment</button>
      </div>
    );
  }
}

----------------------------------------

TITLE: Rendering App Component
DESCRIPTION: Renders the App component to the DOM, targeting an element with id 'app'.

LANGUAGE: JavaScript
CODE:
render(<App />, document.getElementById('app'));

----------------------------------------

TITLE: Counter Component Unit Tests
DESCRIPTION: Example test suite using Enzyme to test the Counter component's functionality

LANGUAGE: javascript
CODE:
import { expect } from 'chai';
import { h } from 'preact';
import { mount } from 'enzyme';

import Counter from '../src/Counter';

describe('Counter', () => {
  it('should display initial count', () => {
    const wrapper = mount(<Counter initialCount={5}/>);
    expect(wrapper.text()).to.include('Current value: 5');
  });

  it('should increment after "Increment" button is clicked', () => {
    const wrapper = mount(<Counter initialCount={5}/>);

    wrapper.find('button').simulate('click');

    expect(wrapper.text()).to.include('Current value: 6');
  });
});

----------------------------------------

TITLE: GitHub Repository Search Component Implementation in Preact
DESCRIPTION: Main Example component that fetches GitHub repository data using the search API and renders the results. Uses useState for data management and useEffect for API calls.

LANGUAGE: JavaScript
CODE:
import { render } from 'preact';
import { useState, useEffect } from 'preact/hooks';

const SEARCH = 'https://api.github.com/search/repositories';

function Example() {
	const [items, setItems] = useState([]);

	useEffect(() => {
		fetch(`${SEARCH}?q=preact`)
			.then(res => res.json())
			.then(data => setItems((data && data.items) || []));
	}, []);

	return (
		<div>
			<h1 style="text-align:center; font-weight: 200">Example</h1>
			<div class="list">
				{items.map(result => (
					<Result {...result} />
				))}
			</div>
		</div>
	);
}

----------------------------------------

TITLE: Creating Todo List Component in Preact
DESCRIPTION: A TodoList class component implementing a basic task management system with state handling for adding new todos and displaying the list.

LANGUAGE: jsx
CODE:
export default class TodoList extends Component {
    state = { todos: [], text: '' };
    setText = e => {
        this.setState({ text: e.currentTarget.value });
    };
    addTodo = () => {
        let { todos, text } = this.state;
        todos = todos.concat({ text });
        this.setState({ todos, text: '' });
    };
    render({ }, { todos, text }) {
        return (
            <form onSubmit={this.addTodo} action="javascript:">
                <label>
                  <span>Add Todo</span>
                  <input value={text} onInput={this.setText} />
                </label>
                <button type="submit">Add</button>
                <ul>
                    { todos.map( todo => (
                        <li>{todo.text}</li>
                    )) }
                </ul>
            </form>
        );
    }
}

----------------------------------------

TITLE: React to Preact Aliasing with Import Maps
DESCRIPTION: Configuration for aliasing React imports to Preact's compatibility layer, enabling use of React-based libraries with Preact.

LANGUAGE: html
CODE:
<script type="importmap">
  {
    "imports": {
      "preact": "https://esm.sh/preact@10.23.1",
      "preact/": "https://esm.sh/preact@10.23.1/",
      "react": "https://esm.sh/preact@10.23.1/compat",
      "react/": "https://esm.sh/preact@10.23.1/compat/",
      "react-dom": "https://esm.sh/preact@10.23.1/compat",
      "@mui/material": "https://esm.sh/@mui/material@5.16.7?external=react,react-dom"
    }
  }
</script>

----------------------------------------

TITLE: Complete External DOM Mutation Example in Preact
DESCRIPTION: Comprehensive example showing a component that manages external DOM mutations, including lifecycle methods for setup and cleanup.

LANGUAGE: javascript
CODE:
class Example extends Component {
  shouldComponentUpdate() {
    // do not re-render via diff:
    return false;
  }

  componentWillReceiveProps(nextProps) {
    // you can do something with incoming props here if you need
  }

  componentDidMount() {
    // now mounted, can freely modify the DOM:
    let thing = document.createElement('maybe-a-custom-element');
    this.base.appendChild(thing);
  }

  componentWillUnmount() {
    // component is about to be removed from the DOM, perform any cleanup.
  }

  render() {
    return <div class="example" />;
  }
}

----------------------------------------

TITLE: Demonstrating Invalid JSX Usage in Preact
DESCRIPTION: Illustrates an incorrect way of passing a JSX literal as a component, which will trigger a Preact debug warning. This helps developers understand and avoid common JSX-related errors.

LANGUAGE: jsx
CODE:
const Foo = <div>foo</div>;
// Invalid: Foo already contains a JSX-Element
render(<Foo />, dom);

----------------------------------------

TITLE: Complete External DOM Mutation Example in Preact
DESCRIPTION: Full component implementation showing lifecycle methods for managing external DOM mutations, including initial render, prop updates, mounting, and cleanup.

LANGUAGE: javascript
CODE:
class Example extends Component {
  shouldComponentUpdate() {
    // do not re-render via diff:
    return false;
  }

  componentWillReceiveProps(nextProps) {
    // you can do something with incoming props here if you need
  }

  componentDidMount() {
    // now mounted, can freely modify the DOM:
    let thing = document.createElement('maybe-a-custom-element');
    this.base.appendChild(thing);
  }

  componentWillUnmount() {
    // component is about to be removed from the DOM, perform any cleanup.
  }

  render() {
    return <div class="example" />;
  }
}

----------------------------------------

TITLE: Rendering a Todo List without Keys in Preact
DESCRIPTION: This snippet demonstrates a simple Todo list component in Preact without using keys. It shows how Preact might incorrectly update the list when items are removed.

LANGUAGE: jsx
CODE:
export default function TodoList() {
  const [todos, setTodos] = useState(['wake up', 'make bed'])

  function wakeUp() {
    setTodos(['make bed'])
  }

  return (
    <div>
      <ul>
        {todos.map(todo => (
          <li>{todo}</li>
        ))}
      </ul>
      <button onClick={wakeUp}>I'm Awake!</button>
    </div>
  )
}

----------------------------------------

TITLE: Fetching GitHub Stars Component in Preact
DESCRIPTION: A component that fetches and displays GitHub repository stars count using async/await and lifecycle methods.

LANGUAGE: jsx
CODE:
export default class Stars extends Component {
    async componentDidMount() {
        let stars = await githubStars(this.props.repo);
        this.setState({ stars });
    }
    render({ repo }, { stars=0 }) {
        let url = `https://github.com/${repo}`;
        return (
            <a href={url} class="stars">
                ⭐️ {stars} Stars
            </a>
        );
    }
}

----------------------------------------

TITLE: Handling Custom Events from Web Components in Preact
DESCRIPTION: Demonstrates how to handle custom events from web components in Preact. It shows the difference between built-in DOM events and custom element events, emphasizing the importance of correct event naming.

LANGUAGE: jsx
CODE:
// Built-in DOM event: listens for a "click" event
<input onClick={() => console.log('click')} />

// Custom Element: listens for "TabChange" event (case-sensitive!)
<tab-bar onTabChange={() => console.log('tab change')} />

// Corrected: listens for "tabchange" event (lower-case)
<tab-bar ontabchange={() => console.log('tab change')} />

----------------------------------------

TITLE: Authentication Context Example
DESCRIPTION: Implements a realistic authentication context pattern with user state management and login/logout functionality.

LANGUAGE: jsx
CODE:
import { createContext } from 'preact'
import { useState, useMemo, useContext } from 'preact/hooks'

const AuthContext = createContext()

export default function App() {
  const [user, setUser] = useState(null)

  const auth = useMemo(() => {
    return { user, setUser }
  }, [user])

  return (
    <AuthContext.Provider value={auth}>
      <div class="app">
        {auth.user && <p>Welcome {auth.user.name}!</p>}
        <Login />
      </div>
    </AuthContext.Provider>
  )
}

----------------------------------------

TITLE: Creating Basic Preact Component with Render Method
DESCRIPTION: Demonstrates how to create a basic Preact component by extending the Component class and implementing the required render() method. Shows how to access props and state within the render function.

LANGUAGE: jsx
CODE:
import { Component } from 'preact';

class MyComponent extends Component {
	render(props, state) {
		// props === this.props
		// state === this.state

		return <h1>Hello, {props.name}!</h1>;
	}
}

----------------------------------------

TITLE: Managing Side Effects with useEffect Hook in Preact
DESCRIPTION: This snippet shows how to use the useEffect hook to manage side effects, such as updating the document title and handling window resize events.

LANGUAGE: jsx
CODE:
function PageTitle(props) {
  useEffect(() => {
    document.title = props.title;
  }, [props.title]);

  return <h1>{props.title}</h1>;
}

function WindowWidth(props) {
  const [width, setWidth] = useState(0);

  function onResize() {
    setWidth(window.innerWidth);
  }

  useEffect(() => {
    window.addEventListener('resize', onResize);
    return () => window.removeEventListener('resize', onResize);
  }, []);

  return <p>Window width: {width}</p>;
}

----------------------------------------

TITLE: Interactive Form Component in Preact
DESCRIPTION: Shows how to create an interactive form component with state management and event handling.

LANGUAGE: jsx
CODE:
import { h, render, Component } from 'preact';

class App extends Component {
  state = { value: '', name: 'world' }

  onInput = ev => {
    this.setState({ value: ev.currentTarget.value });
  }

  onSubmit = ev => {
    ev.preventDefault();
    this.setState({ name: this.state.value });
  }

  render() {
    return (
      <div>
        <h1>Hello, {this.state.name}!</h1>
        <form onSubmit={this.onSubmit}>
          <input type="text" value={this.state.value} onInput={this.onInput} />
          <button type="submit">Update</button>
        </form>
      </div>
    );
  }
}

render(<App />, document.getElementById("app"));

----------------------------------------

TITLE: Nesting Components in Preact
DESCRIPTION: Demonstrates component composition by creating a MediaPlayer component that contains multiple button components.

LANGUAGE: jsx
CODE:
function MediaPlayer() {
  return (
    <div>
      <MyButton text="Play" />
      <MyButton text="Stop" />
    </div>
  )
}

render(<MediaPlayer />, document.body)