TITLE: Adding User-Based Access Control to Schema
DESCRIPTION: This snippet demonstrates how to add user-based access control policies to various models in the schema, including User, Space, List, and Todo.

LANGUAGE: zmodel
CODE:
model User {
  ...

  // everyone can sign up
  @@allow('create', true)

  // full access by oneself
  @@allow('all', auth() == this)
}

model Space {
  ...

  ownerId Int @default(auth().id)
}

model List {
  ...

  ownerId Int @default(auth().id)

  // owner has full access
  @@allow('all', auth() == owner)
}

model Todo {
  ...

  ownerId Int @default(auth().id)

  // owner and list owner has full access
  @@allow('all', auth() == owner || auth() == list.owner)
}

----------------------------------------

TITLE: Implementing Security Rules with ZenStack ORM
DESCRIPTION: Shows how to implement chat message security using ZenStack ORM's declarative access control. The schema defines User and Chat models with security rules that control read, create, and update operations.

LANGUAGE: zmodel
CODE:
model User {
  id Int @id @default(autoincrement())
  username String
  sent Chat[] @relation('sent')
  received Chat[] @relation('received')

  // allow user to read his own profile
  @@allow('read', auth() == this)
}

model Chat {
  id Int @id @default(autoincrement())
  subject String
  fromUser User @relation('sent', fields: [fromUserId], references: [id])
  fromUserId Int
  toUser User @relation('received', fields: [toUserId], references: [id])
  toUserId Int

  // allow user to read his own chats
  @@allow('read', auth() == fromUser || auth() == toUser)

  // allow user to create a chat as sender
  @@allow('create', auth() == fromUser)

  // allow sender to update a chat, but disallow to change sender
  @@allow('update', auth() == fromUser && auth() == future().fromUser)
}

----------------------------------------

TITLE: Defining Database Schema with ZModel
DESCRIPTION: This ZModel schema defines the data structure for the Todo List application, including List and Todo models. It uses ZenStack's extended Prisma schema syntax.

LANGUAGE: zmodel
CODE:
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator js {
  provider = "prisma-client-js"
}

// Todo list
model List {
  id        String        @id @default(cuid())
  createdAt DateTime      @default(now())
  title     String
  private   Boolean       @default(false)
  orgId     String?
  ownerId   String
  todos     Todo[]
}

// Todo item
model Todo {
  id          String    @id @default(cuid())
  title       String
  completedAt DateTime?
  list        List      @relation(fields: [listId], references: [id], onDelete: Cascade)
  listId      String
}

----------------------------------------

TITLE: ABAC Sample Code in TypeScript
DESCRIPTION: Illustrates how to use the ABAC schema with ZenStack-enhanced PrismaClient to create users and resources, and enforce attribute-based access control.

LANGUAGE: typescript
CODE:
// create two users
const emily = await prisma.user.create({
    data: { name: 'Emily', reputation: 100 },
});
const adam = await prisma.user.create({
    data: { name: 'Adam', reputation: 5 },
});

// create an enhanced PrismaClient for each user
const emilyDb = enhance(prisma, { user: emily });
const adamDb = enhance(prisma, { user: adam });

// Emily can create a resource because she has enough reputation
const res = await emilyDb.resource.create({
  data: { name: 'resource1', owner: { connect: { id: emily.id } } },
});
console.log('Resource created by Emily:', inspect(res));

// Adam can't create a resource because he has insufficient reputation
await expect(
  adamDb.resource.create({
    data: { name: 'resource2', owner: { connect: { id: adam.id } } },
  })
).rejects.toThrow();

// Adam shouldn't see the resource because it's not published
let allResourcesByAdam = await adamDb.resource.findMany();
console.log('All resources read by Adam:', inspect(allResourcesByAdam));
expect(allResourcesByAdam).toHaveLength(0);

// Emily should be able to publish the resource
await emilyDb.resource.update({
  where: { id: res.id },
  data: { published: true },
});
console.log('Resource published by Emily');

// ❌ Adam should now be able to see the resource
allResourcesByAdam = await adamDb.resource.findMany();
console.log('All resources read by Adam:', inspect(allResourcesByAdam));
expect(allResourcesByAdam).toHaveLength(1);

----------------------------------------

TITLE: Implementing Next.js Signup Page with NextAuth
DESCRIPTION: A React component for user registration that uses NextAuth for authentication and TanStack Query hooks for user creation. Includes form handling, error management, and redirection after successful signup.

LANGUAGE: tsx
CODE:
'use client';

import { signIn } from 'next-auth/react';
import Link from 'next/link';
import { useState, type FormEvent } from 'react';
import { useCreateUser } from '~/lib/hooks';

export default function Signup() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const { mutate: signup, error: signupError } = useCreateUser({
    onSuccess: async () => {
      // sign-up succeeded, sign in with the credentials
      const signInResult = await signIn('credentials', {
        redirect: false,
        email,
        password,
      });
      if (signInResult?.ok) {
        window.location.href = '/';
      } else {
        console.error('Signin failed:', signInResult?.error);
      }
    },
  });

  const _err = signupError as { info?: { code?: string } };
  const errMsg = _err
    ? _err.info?.code === 'P2002' // P2002 is the Prisma error code for unique constraint failure
      ? 'Email already exists'
      : `Unexpected error occurred: ${JSON.stringify(_err)}`
    : '';

  function onSignup(e: FormEvent<HTMLFormElement>) {
    e.preventDefault();
    signup({ data: { email, password } });
  }

  return (
    <div className="mx-auto flex h-screen flex-col items-center justify-center">
      <div className="mb-10 flex items-center space-x-4">
        <h1 className="text-4xl">Welcome to Todo</h1>
      </div>
      <div className="flex w-full max-w-screen-sm items-center justify-center rounded-lg">
        <div className="w-full space-y-8 p-16">
          <h2 className="text-3xl font-bold">Create a Free Account</h2>
          <form className="mt-8 space-y-6" action="#" onSubmit={onSignup}>
            <div>
              <label htmlFor="email" className="label">
                Your email
              </label>
              <input
                type="email"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                className="input input-bordered w-full"
                placeholder="Email address"
                required
              />
            </div>
            <div>
              <label htmlFor="password" className="label">
                Your password
              </label>
              <input
                type="password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                placeholder="••••••••"
                className="input input-bordered w-full"
                required
              />
            </div>

            {errMsg && <p className="text-sm text-red-600">{errMsg}</p>}

            <button className="btn btn-primary mt-4" type="submit">
              Create account
            </button>
            <div>
              Already have an account?{' '}
              <Link href="/signin" className="text-primary">
                Login here
              </Link>
            </div>
          </form>
        </div>
      </div>
    </div>
  );

----------------------------------------

TITLE: Defining ABAC Schema with ZenStack
DESCRIPTION: Demonstrates how to define an Attribute-Based Access Control (ABAC) schema using ZenStack's ZModel language, including User and Resource models with attribute-based rules.

LANGUAGE: zmodel
CODE:
model User {
  id Int @id @default(autoincrement())
  name String
  reputation Int @default(1) // controls if a user can create a resource
  ownedResources Resource[]
}

model Resource {
  id Int @id @default(autoincrement())
  name String
  published Boolean @default(false)
  owner User @relation(fields: [ownerId], references: [id])
  ownerId Int

  // user can create resources if he has enough reputation
  @@allow('create', auth().reputation >= 100)

  // published resources can be read by anyone
  @@allow('read', published)

  // owner has full access
  @@allow('read,update,delete', owner == auth())
}

----------------------------------------

TITLE: Defining Model-Level Deny Policy in ZenStack
DESCRIPTION: Alternative example using @@deny attribute to achieve the same read policy for published posts in a Post model.

LANGUAGE: zmodel
CODE:
model Post {
    id Int @id
    title String
    published Boolean @default(false)

    @@allow('read', true)
    @@deny('read', !published)
}

----------------------------------------

TITLE: Defining User and Post Models in ZModel
DESCRIPTION: ZModel schema definition for User and Post models, including access policies for create, read, and update operations.

LANGUAGE: zmodel
CODE:
model User {
    id String @id @default(cuid())
    email String @unique @email
    password String @password @omit @length(8, 16)
    posts Post[]

    // everybody can signup
    @@allow('create,read', true)

    // full access by self
    @@allow('all', auth() == this)
}

model Post {
    id String @id @default(cuid())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
    title String @length(1, 256)
    published Boolean @default(false)
    author User? @relation(fields: [authorId], references: [id])
    authorId String? @default(auth().id)

    // allow read for all signin users
    @@allow('read', auth() != null && published)

    // full access by author
    @@allow('all', author == auth())
}

----------------------------------------

TITLE: Defining Data Models and Access Policies with ZenStack
DESCRIPTION: This code snippet demonstrates how to use ZenStack to define data models for a SaaS development management tool. It includes models for Space, User, SpaceBase (abstract), SpaceUser, and Bug, along with access policies and relationships between them.

LANGUAGE: zmodel
CODE:
/*
 * Model for a team space 
 */
model Space {
    id String @id @default(uuid())
    members SpaceUser[]
    bug Bug[]
    // require login
    @@deny('all', auth() == null)

    // everyone can create a space
    @@allow('create', true)

    // any user in the space can read the space
    @@allow('read', members?[owner == auth()])
}

/*
 * Model for a user
 */
model User {
    id String @id @default(uuid())
    password String? @password @omit
    name String?
    spaces SpaceUser[]
    bug Bug[]

    // can be created by anyone, even not logged in
    @@allow('create', true)

    // can be read by users sharing any space
    @@allow('read', spaces?[space.members?[owner == auth()]])

    // full access by oneself
    @@allow('all', auth() == this)
}

/*
* Base model for all models in a space
*/
abstract model SpaceBase {
    id String @id @default(uuid())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
    owner User @relation(fields: [ownerId], references: [id], onDelete: Cascade)
    ownerId String
    space Space @relation(fields: [spaceId], references: [id], onDelete: Cascade)
    spaceId String
    @@allow('read', owner == auth() || space.members?[owner == auth()] )
    @@allow('create', owner == auth() && space.members?[owner == auth()])
    @@allow('update', owner == auth() && space.members?[owner == auth()] && future().owner == owner)
    @@allow('delete', owner == auth())
}

/*
 * Model representing membership of a user in a space
 */
model SpaceUser extends SpaceBase {
    nickName String
}

/*
 * Model for a bug
 */
model Bug extends SpaceBase {
    title String
    priority Int
    ..
}

----------------------------------------

TITLE: Defining Multi-Tenancy Schema with ZenStack
DESCRIPTION: Shows how to define a Multi-Tenancy schema using ZenStack's ZModel language, including User, Org, OrgMember, and Resource models with complex access control rules.

LANGUAGE: zmodel
CODE:
model User {
  id Int @id @default(autoincrement())
  name String
  reputation Int @default(1)
  memberships OrgMember[]
  ownedResources Resource[]

  // can be created by anyone, even not logged in
  @@allow('create', true)

  // can be read by users sharing any org
  @@allow('read', memberships?[org.members?[user == auth()]])

  // full access by oneself
  @@allow('all', auth() == this)
}

model Org {
  id Int @id @default(autoincrement())
  name String
  members OrgMember[]
  resources Resource[]

  // require login
  @@deny('all', auth() == null)

  // everyone can create an org
  @@allow('create', true)

  // any user in the org can read the org
  @@allow('read', members?[user == auth()])

  // org admin can update and delete
  @@allow('update,delete', members?[user == auth() && role == 'ADMIN'])
}

model OrgMember {
  id Int @id @default(autoincrement())
  org Org @relation(fields: [orgId], references: [id])
  orgId Int
  user User @relation(fields: [userId], references: [id])
  userId Int
  role String // "ADMIN", "MEMBER"

  // require login
  @@deny('all', auth() == null)

  // org admin can create/update/delete
  @@allow('create,update,delete', org.members?[user == auth() && role == 'ADMIN'])

  // user can read members of an org if he's a member of it
  @@allow('read', org.members?[user == auth()])
}

model Resource {
  id Int @id @default(autoincrement())
  name String
  public Boolean @default(false)
  owner User @relation(fields: [ownerId], references: [id])
  ownerId Int
  org Org @relation(fields: [orgId], references: [id])
  orgId Int

  // require login
  @@deny('all', auth() == null)

  // can be read by owner or org members (if public) 
  @@allow('read', owner == auth() || (org.members?[user == auth()] && public))

  // when create, owner must be set to current user, and user must be in the org
  @@allow('create', owner == auth() && org.members?[user == auth()])

  // can be updated by owner
  // update is not allowed to change owner
  @@allow('update', owner == auth() && future().owner == owner)

  // can be deleted by owner
  @@allow('delete', owner == auth())
}

----------------------------------------

TITLE: Access Control Attributes in ZenStack Schema
DESCRIPTION: Demonstrates the usage of @@allow and @@deny attributes for controlling model operations. The attributes accept operation types (create/read/update/delete or 'all') and a boolean expression as parameters. Rules are evaluated with deny rules taking precedence over allow rules.

LANGUAGE: prisma
CODE:
@@allow("create,read", boolean_expression)\n@@deny("all", boolean_expression)

----------------------------------------

TITLE: Access Policy Examples
DESCRIPTION: Shows how to define access policies for models with various conditions.

LANGUAGE: zmodel
CODE:
model Post {
    // reject all operations if user's not logged in
    @@deny('all', auth() == null)

    // allow all operations if the entity's owner matches the current user
    @@allow('all', auth() == owner)

    // posts are readable to anyone
    @allow('read', true)
}

----------------------------------------

TITLE: Defining ACL Schema with ZenStack
DESCRIPTION: Shows how to define an Access Control List (ACL) schema using ZenStack's ZModel language, including User, Access, and Resource models with access control rules.

LANGUAGE: zmodel
CODE:
model User {
  id Int @id @default(autoincrement())
  name String
  access Access[]
  ownedResources Resource[]
}

model Access {
  id Int @id @default(autoincrement())
  user User @relation(fields: [userId], references: [id])
  userId Int
  resource Resource @relation(fields: [resourceId], references: [id])
  resourceId Int

  // view permission
  view Boolean?

  // manage permission
  manage Boolean?

  // resource owner has full control over its access list
  @@allow('all', resource.owner == auth())
}

model Resource {
  id Int @id @default(autoincrement())
  name String
  owner User @relation(fields: [ownerId], references: [id])
  ownerId Int
  access Access[]

  // owner has full control
  @@allow('all', owner == auth())

  // readable if there exists a "read" permission for the current user
  @@allow('read', access?[user == auth() && view])

  // writeable if there exists a "manage" permission for the current user
  @@allow('update,delete', access?[user == auth() && manage])
}

----------------------------------------

TITLE: Defining RBAC Schema with ZenStack
DESCRIPTION: Illustrates how to define a Role-Based Access Control (RBAC) schema using ZenStack's ZModel language, including User, Role, Permission, and Resource models.

LANGUAGE: zmodel
CODE:
model User {
  id Int @id @default(autoincrement())
  name String
  roles Role[]
}

model Role {
  id Int @id @default(autoincrement())
  name String
  users User[] // users belonging to the role
  permissions Permission[] // permissions assigned to the role
}

model Permission {
  id Int @id @default(autoincrement())
  name String // "view" or "manage", use an enum if database supports it
  roles Role[]
}

model Resource {
  id Int @id @default(autoincrement())
  name String

  @@allow('read', auth().roles?[permissions?[name == 'view']])
  @@allow('all', auth().roles?[permissions?[name == 'manage']])
}

----------------------------------------

TITLE: Defining Auth Model in ZModel
DESCRIPTION: This snippet shows how to define a User model as the default auth model and use it in policy rules for a Post model. It demonstrates valid and invalid usage of the auth() function.

LANGUAGE: zmodel
CODE:
model User {
    id Int @id
    role String
    posts Post[]
}

model Post {
    id Int @id
    title String
    author User @relation(fields: [authorId], references: [id])
    authorId Int

    // ✅ valid rule
    @@allow('all', auth().role == 'ADMIN')

    // ❌ invalid rule, `subscribed` field doesn't exist in `User` model
    @@allow('all', auth().subscribed == true) 
}

----------------------------------------

TITLE: Mounting API with Next.js App Router
DESCRIPTION: TypeScript code for creating a request handler in a Next.js API endpoint using the App Router. It demonstrates how to set up the NextRequestHandler with a custom getPrisma function.

LANGUAGE: typescript
CODE:
import { NextRequestHandler } from '@zenstackhq/server/next';
import type { NextRequest } from "next/server";
import { enhance } from '@zenstackhq/runtime';
import { prisma } from '~/lib/db.ts';
import { getSessionUser } from '~/lib/auth.ts';

// create an enhanced Prisma client with user context
function getPrisma(req: NextRequest) {
    // getSessionUser extracts the current session user from the request, its
    // implementation depends on your auth solution
    return enhance(prisma, { user: getSessionUser(req) });
}

const handler = NextRequestHandler({ getPrisma, useAppDir: true });

export {
  handler as GET,
  handler as POST,
  handler as PUT,
  handler as PATCH,
  handler as DELETE,
};

----------------------------------------

TITLE: User Model Definition in ZenStack
DESCRIPTION: ZModel schema definition for User model with password authentication and access policies.

LANGUAGE: zmodel
CODE:
model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime?
  password      String @password @omit
  image         String?
  accounts      Account[]
  sessions      Session[]
  posts         Post[]

  @@allow('create,read', true)
  @@allow('update,delete', auth() == this)
}

----------------------------------------

TITLE: Mounting API with Next.js App Router
DESCRIPTION: TypeScript code for creating a request handler in a Next.js API endpoint using the App Router. It demonstrates how to set up the NextRequestHandler with a custom getPrisma function.

LANGUAGE: typescript
CODE:
import { NextRequestHandler } from '@zenstackhq/server/next';
import type { NextRequest } from "next/server";
import { enhance } from '@zenstackhq/runtime';
import { prisma } from '~/lib/db.ts';
import { getSessionUser } from '~/lib/auth.ts';

// create an enhanced Prisma client with user context
function getPrisma(req: NextRequest) {
    // getSessionUser extracts the current session user from the request, its
    // implementation depends on your auth solution
    return enhance(prisma, { user: getSessionUser(req) });
}

const handler = NextRequestHandler({ getPrisma, useAppDir: true });

export {
  handler as GET,
  handler as POST,
  handler as PUT,
  handler as PATCH,
  handler as DELETE,
};

----------------------------------------

TITLE: Writing Conditions with auth() in ZModel
DESCRIPTION: This snippet demonstrates various ways to use the auth() function in policy rules, including checking for anonymous users and comparing auth() with other fields.

LANGUAGE: zmodel
CODE:
model Post {
    ...
    author User @relation(fields: [authorId], references: [id])
    authorId Int

    // allow all login users to read
    @@allow('read', auth() != null)

    // allow update only by the author
    @@allow('update', auth() == author)
}

----------------------------------------

TITLE: Next.js API Route Handler for ZenStack CRUD Operations
DESCRIPTION: Implementation of Next.js API route handler that exposes ZenStack's automatic CRUD endpoints with authentication integration

LANGUAGE: typescript
CODE:
async function getPrisma() {
  const reqHeaders = await headers();
  const sessionResult = await auth.api.getSession({
    headers: reqHeaders,
  });

  if (!sessionResult) {
    return enhance(prisma);
  }

  let organizationId: string | undefined = undefined;
  let organizationRole: string | undefined = undefined;
  const { session } = sessionResult;

  if (session.activeOrganizationId) {
    organizationId = session.activeOrganizationId;
    const org = await auth.api.getFullOrganization({ headers: reqHeaders });
    if (org?.members) {
      const myMember = org.members.find(
          (m) => m.userId === session.userId
      );
      organizationRole = myMember?.role;
    }
  }

  const userContext = {
    userId: session.userId,
    organizationId,
    organizationRole,
  };
  return enhance(prisma, { user: userContext });
}

----------------------------------------

TITLE: Defining Access Policies for Post Model in ZenStack
DESCRIPTION: This snippet shows how to define access policies for the Post model using ZenStack's declarative syntax. It includes rules for create, update, read, and delete operations, implementing multi-tenancy and soft delete functionality.

LANGUAGE: typescript
CODE:
abstract model organizationBaseEntity {
    id String @id @default(uuid())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
    isDeleted Boolean @default(false) @omit
    isPublic Boolean @default(false)
    owner User @relation(fields: [ownerId], references: [id], onDelete: Cascade)
    ownerId String
    org Organization @relation(fields: [orgId], references: [id], onDelete: Cascade)
    orgId String
    groups Group[]

    // when create, owner must be set to current user, and user must be in the organization
    @@allow('create', owner == auth() && org.members?[id == auth().id])
    // only the owner can update it and is not allowed to change the owner
    @@allow('update', owner == auth() && org.members?[id == auth().id] && future().owner == owner)
    // allow owner to read
    @@allow('read', owner == auth())
    // allow shared group members to read it
    @@allow('read', groups?[users?[id == auth().id]])
    // allow organization to access if public
    @@allow('read', isPublic && org.members?[id == auth().id])
    // can not be read if deleted
    @@deny('all', isDeleted == true)
}

model Post extends organizationBaseEntity {
    title String
    content String
}

----------------------------------------

TITLE: Defining EnhancementContext Type in TypeScript
DESCRIPTION: Defines the type for the context used in evaluating access policies. It includes an optional user object that provides values for the auth() function in access policies.

LANGUAGE: typescript
CODE:
type EnhancementContext = {
    user?: Record<string, unknown>
};

----------------------------------------

TITLE: Creating Enhanced PrismaClient with ZenStack
DESCRIPTION: Demonstrates how to create an enhanced PrismaClient instance with ZenStack, which enforces access control rules based on the current user.

LANGUAGE: typescript
CODE:
const db = enhance(prisma, { user: currentUser });

----------------------------------------

TITLE: Defining Field-Level Validation Rules in ZModel
DESCRIPTION: This snippet demonstrates how to use field-level attributes for defining validation rules in a User model. It includes examples of email validation, URL validation, string length constraints, and numeric range checks.

LANGUAGE: zmodel
CODE:
model User {
    id Int @id
    email String @unique @email @endsWith('@zenstack.dev')
    imgUrl String? @url
    password String @length(min: 8, max: 32)
    age Int @gt(0) @lt(120)
}

----------------------------------------

TITLE: Configuring Database Data Source
DESCRIPTION: Shows how to configure database connections using environment variables or direct connection strings.

LANGUAGE: zmodel
CODE:
datasource db {
    provider = "postgresql"
    url = "postgresql://postgres:abc123@localhost:5432/todo?schema=public"
}

LANGUAGE: zmodel
CODE:
datasource db {
    provider = "postgresql"
    url = env("DATABASE_URL")
}

----------------------------------------

TITLE: Configuring Database Data Source
DESCRIPTION: Shows how to configure database connections using environment variables or direct connection strings.

LANGUAGE: zmodel
CODE:
datasource db {
    provider = "postgresql"
    url = "postgresql://postgres:abc123@localhost:5432/todo?schema=public"
}

LANGUAGE: zmodel
CODE:
datasource db {
    provider = "postgresql"
    url = env("DATABASE_URL")
}

----------------------------------------

TITLE: Defining Database Schema with ZenStack
DESCRIPTION: This code snippet shows the database schema definition for the blog application using ZenStack's ZModel language, which extends Prisma's schema language with access control annotations.

LANGUAGE: zmodel
CODE:
generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider = "sqlite"
    url      = "file:./db.sqlite"
}

model User {
    id Int @id @default(autoincrement())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
    email String @unique
    password String @password @omit
    name String?
    role String @default('Author') // Author, Editor, Admin
    posts Post[]

    @@allow('all', true)
}

model Post {
    id Int @id @default(autoincrement())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
    title String
    content String
    status String @default('Draft') // Draft, Submitted, Published
    user User @relation(fields: [userId], references: [id], onDelete: Cascade)
    userId Int

    @@allow('all', true)
}

----------------------------------------

TITLE: Defining Data Model with ZModel Schema
DESCRIPTION: Example of defining a Post model using ZModel language (Prisma schema superset) with access control policies and React hook generation configuration

LANGUAGE: zmodel
CODE:
model Post {
  id        String @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  title     String
  published Boolean @default(false)
  author    User @relation(fields: [authorId], references: [id])
  authorId  String

  // author has full access
  @@allow('all', auth() == author)

  // logged-in users can view published posts
  @@allow('read', auth() != null && published)
}

// generate swr hooks under ./src/lib/hook
plugin reactHooks {
  provider = '@zenstackhq/swr'
  output = "./src/lib/hook"
}

----------------------------------------

TITLE: Creating TypeScript Client for API Consumption
DESCRIPTION: Example of using generated TypeScript types to create a strongly-typed API client for consuming the Pet Store API.

LANGUAGE: typescript
CODE:
import fetch, { Headers, Request, Response } from 'node-fetch';
import { Fetcher } from 'openapi-typescript-fetch';
import { paths } from './client-types';

// polyfill `fetch` for node
if (!globalThis.fetch) {
    globalThis.fetch = fetch as any;
    globalThis.Headers = Headers as any;
    globalThis.Request = Request as any;
    globalThis.Response = Response as any;
}

async function main() {
    const fetcher = Fetcher.for<paths>();
    fetcher.configure({
        baseUrl: 'http://localhost:3000',
    });

    const login = fetcher.path('/api/login').method('post').create();
    const { data: loginResult } = await login({
        email: 'tom@pet.inc',
        password: 'abc123',
    });
    // loginResult is typed as { id: string, email: string, token: string }
    console.log('Login result:', JSON.stringify(loginResult, undefined, 2));
    const token = loginResult.token;

    // get orders together with their pets
    const getOrders = fetcher.path(`/api/order/findMany`).method('get').create();
    const { data: orders } = await getOrders(
        { q: JSON.stringify({ include: { pets: true } }) },
        { headers: { Authorization: `Bearer ${token}` } }
    );
    console.log('Orders:', JSON.stringify(orders, undefined, 2));
}

main();

----------------------------------------

TITLE: Mounting ZenStack Middleware in Express.js
DESCRIPTION: Example of how to integrate ZenStack into an Express.js project using the ZenStackMiddleware. It shows the setup process including importing necessary modules, creating a Prisma client, and configuring the middleware.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client';
import { enhance } from '@zenstackhq/runtime';
import { ZenStackMiddleware } from '@zenstackhq/server/express';
import express from 'express';

const prisma = new PrismaClient();
const app = express();

app.use(express.json());

app.use(
    '/api/model',
    ZenStackMiddleware({
        // getSessionUser extracts the current session user from the request, its
        // implementation depends on your auth solution
        getPrisma: (request) => enhance(prisma, { user: getSessionUser(request) }),
    })
);

----------------------------------------

TITLE: Defining Access Control Policies with ZenStack
DESCRIPTION: This code snippet shows how to define access control policies for the User and Post models using ZenStack's policy language, ensuring proper authorization for different user roles.

LANGUAGE: zmodel
CODE:
model User {
  ...

  // all logged in users can read all users
  @@allow('read', auth() != null)
 
  // a user can update himself, and an admin can update any user
  @@allow('all', auth() == this || auth().role == 'Admin')
}

model Post {
  ...

  // admins have full access to all posts
  @@allow('all', auth().role == 'Admin')

  // authors can create new posts for themselves with "Draft" status
  @@allow('create', auth() == user && status == 'Draft')

  // post owner can read their own posts
  @@allow('read', auth() == user)

  // non-draft posts can be read by all logged in users
  @@allow('read', auth() != null && status != 'Draft')

  // update rules for "Author"
  @@allow('update',
      auth().role == 'Author' // user is an author
      && auth() == user // user is the post owner
      && status != 'Published' // published posts can't be updated
      && future().status != 'Published' // can't change status to "Published"
  )

  // update rules for "Editor"
  @@allow('update', auth().role == 'Editor' && status != 'Draft')

  // owner or admin can delete a post if it's not published
  @@allow('delete', auth() == user && status != 'Published')
}

----------------------------------------

TITLE: Configuring ZenStack with Vercel Edge Runtime in Next.js RSC
DESCRIPTION: This snippet demonstrates how to set up a Next.js React Server Component (RSC) to use ZenStack with Vercel Edge Runtime. It includes creating a new PrismaClient instance for each request, which is crucial in edge environments.

LANGUAGE: typescript
CODE:
import { createPrisma } from '~/lib/db';
import { getSessionUser } from '~/lib/auth';

export default async function Page() {
  ...

  // IMPORTANT: in edge environment you must create a new `PrismaClient` for each request
  // https://github.com/prisma/prisma/issues/20566#issuecomment-2021594203
  const prisma = createPrisma();
  const db = enhance(prisma, { user: getSessionUser() });
  const posts = await db.post.findMany();
  ...
}

export const runtime = 'edge';

----------------------------------------

TITLE: Defining ZModel Schema for Blog Post App in ZenStack
DESCRIPTION: This snippet shows a simplified ZModel schema for a blog post application, including data models for Post and User with access policies.

LANGUAGE: zmodel
CODE:
datasource db {
    provider = 'postgresql'
    url = env('DATABASE_URL')
}

generator js {
    provider = 'prisma-client-js'
}

plugin hooks {
    provider = '@zenstackhq/tanstack-query'
    output = 'lib/hooks'
    target = 'react'
}

enum Role {
    USER
    ADMIN
}

model Post {
    id        String  @id @default(cuid())
    title     String
    published Boolean @default(false)
    author    User    @relation(fields: [authorId], references: [id])
    authorId  String  @default(auth().id)

    @@allow('all', auth() == author)
    @@allow('read', auth() != null && published )
    @@allow('read', auth().role == 'ADMIN')
}

model User {
    id       String  @id @default(cuid())
    name     String?
    email    String? @unique
    password String  @password @omit
    role     Role    @default(USER)
    posts    Post[]
    
    @@allow('create,read', true)
    @@allow('update,delete', auth() == this)
}

----------------------------------------

TITLE: Enhancing PrismaClient with ZenStack Runtime
DESCRIPTION: This code snippet shows how to create an enhanced PrismaClient using ZenStack's runtime. The enhanced client automatically enforces access policies defined in the schema.

LANGUAGE: typescript
CODE:
import { Prisma } from '@prisma/client';
import { enhance } from '@zenstackhq/runtime';
import { getCurrentUser } from './auth';

const prisma = new PrismaClient();

// `db` has the same typing as `prisma`, but it automatically
// enforces access policies
const db = enhance(prisma, { user: getCurrentUser() });

----------------------------------------

TITLE: Enhancing Prisma Client with ZenStack Features in TypeScript
DESCRIPTION: The enhance function is the simplest way to include all essential enhancements offered by ZenStack, including access policies, field validation, field omission, and password hashing. It's equivalent to calling withOmit(withPassword(withPolicy(prisma, options))).

LANGUAGE: typescript
CODE:
function enhance<DbClient extends object>(
    prisma: DbClient,
    context?: WithPolicyContext,
    options?: EnhancementOptions
): DbClient;

----------------------------------------

TITLE: User Model with OpenAPI Metadata (RPC Flavor)
DESCRIPTION: Example of a User model with OpenAPI metadata configuration using RPC flavor, including security, custom operations, and deprecation settings

LANGUAGE: zmodel
CODE:
model User {
    id String @id
    email String @unique

    @@openapi.meta({
        security: [ { basic: [] } ],
        tagDescription: 'Operations for managing users',
        findMany: {
            description: 'Find users matching the given conditions'
        },
        delete: {
            method: 'put',
            path: 'dodelete',
            description: 'Delete a unique user',
            summary: 'Delete a user yeah yeah',
            tags: ['delete', 'user'],
        },
        createMany: {
            security: [],
            deprecated: true
        }
    })
}

----------------------------------------

TITLE: ZModel Access Policy Example
DESCRIPTION: Example of defining access policies on a Post model.

LANGUAGE: zmodel
CODE:
model Post {
    // reject all operations if user's not logged in
    @@deny('all', auth() == null)

    // allow all operations if the entity's owner matches the current user
    @@allow('all', auth() == owner)

    // posts are readable to anyone
    @allow('read', true)
}

----------------------------------------

TITLE: Initializing ZenStack Project
DESCRIPTION: Demonstrates how to initialize a ZenStack project using the CLI, with examples for default and custom configurations.

LANGUAGE: bash
CODE:
npx zenstack init

LANGUAGE: bash
CODE:
npx zenstack init -p pnpm --prisma prisma/my.schema myapp

----------------------------------------

TITLE: Using enhanced PrismaClient in Next.js route handler
DESCRIPTION: This snippet demonstrates how to use an enhanced PrismaClient in a Next.js route handler. It retrieves the current authenticated user, creates an enhanced PrismaClient, and returns all posts.

LANGUAGE: typescript
CODE:
import { auth } from '~/auth';
import { prisma } from '~/db';

export async function GET(request: Request) {
  const authObj = await auth();
  const db = enhance(prisma, { user: authObj?.user });
  return db.post.findMany()
}

----------------------------------------

TITLE: Implementing Access Control with ZModel
DESCRIPTION: This snippet demonstrates how to define access control rules for the List model using ZModel's @@allow and @@deny attributes.

LANGUAGE: zmodel
CODE:
model List {
  ...

  // deny anonymous access
  @@deny('all', auth() == null)

  // tenant segregation: deny access if the user's current org doesn't match
  @@deny('all', auth().currentOrgId != orgId)

  // owner/admin has full access
  @@allow('all', auth().userId == ownerId || auth().currentOrgRole == 'org:admin')

  // can be read by org members if not private
  @@allow('read', !private)

  // when create, owner must be set to current user
  @@allow('create', ownerId == auth().userId)
}

----------------------------------------

TITLE: Defining Access Policies with ZenStack
DESCRIPTION: Using ZenStack's ZModel to define data schema and access policies for User and Post models.

LANGUAGE: zmodel
CODE:
model User {
  id Int @id @default(autoincrement())
  email String @unique @allow('read', auth() == this) // #1
  name String?
  role String @default("USER")
  posts Post[]

  @@allow('all', auth() == this) // #2
  @@allow('read', true) // #3
}

model Post {
  id Int @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  title String
  content String?
  published Boolean @default(false) @allow('update', auth().role == "EDITOR") // #4
  author User? @relation(fields: [authorId], references: [id])
  authorId Int?

  @@allow('all', auth() == author || auth().role == 'EDITOR') // #5
  @@allow('read', published) // #6
}

----------------------------------------

TITLE: Importing Enhanced Prisma Types in TypeScript
DESCRIPTION: Demonstrates how to import and use enhanced Prisma types from ZenStack's runtime models instead of @prisma/client. Shows usage with model types and input types for database operations.

LANGUAGE: typescript
CODE:
import type { Post, Prisma } from '@zenstackhq/runtime/models'
import { getEnhancedPrisma } from '~/db'

const db = getEnhancedPrisma();

// explicitly refer to the enhanced model type
const post: Post = await db.post.findUnique({...});

// explicitly refer to the enhanced input type
const createInput: Prisma.PostCreateInput = { ... };
await db.post.create({ data: createInput });

----------------------------------------

TITLE: Initializing ZenStack Project
DESCRIPTION: Demonstrates how to initialize a ZenStack project using the CLI, with examples for default and custom configurations.

LANGUAGE: bash
CODE:
npx zenstack init

LANGUAGE: bash
CODE:
npx zenstack init -p pnpm --prisma prisma/my.schema myapp

----------------------------------------

TITLE: Defining Data Models with Prisma in ZenStack
DESCRIPTION: This code snippet demonstrates how to define data models for User and Post entities using Prisma's schema language in ZenStack. It showcases the simplicity of defining relationships, field types, and enums.

LANGUAGE: zmodel
CODE:
model User {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  email     String   @unique
  name      String?
  role      Role     @default(USER)
  posts     Post[]
}

model Post {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  published Boolean  @default(false)
  title     String   @db.VarChar(255)
  author    User?    @relation(fields: [authorId], references: [id])
  authorId  Int?
}

enum Role {
  USER
  ADMIN
}

----------------------------------------

TITLE: Defining Data Model with ZModel
DESCRIPTION: ZModel schema definition for the signup form including validation rules and access control

LANGUAGE: zmodel
CODE:
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = 'sqlite'
  url      = 'file:./dev.db'
}

model Signup {
  id Int @id @default(autoincrement())
  name String
  email String @email @endsWith("@zenstack.dev", 'Must be a @zenstack.dev email')
  adult Boolean
  beverage String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@allow('create,read', true)

  @@validate(beverage in ['SODA', 'COFFEE', 'BEER', 'COCKTAIL'], 'Please choose a valid beverage')

  @@validate(adult || beverage in ['SODA', 'COFFEE'], 'You must be an adult to drink alcohol')
}

----------------------------------------

TITLE: Defining Abstract and Extended Models in ZenStack
DESCRIPTION: This snippet demonstrates how to create an abstract 'Base' model with common fields and access rules, and then extend it with specific models like 'Post' and 'ToDo'. It showcases model inheritance in ZenStack.

LANGUAGE: tsx
CODE:
abstract model Base {
    id Int @id @default(autoincrement())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt()

    //Logged-in users can view
    @@allow('read', auth() != null)

}

model Post extends Base
{
    title String
    content String?
    viewCount Int @default(0)
}

model ToDo extends Base
{
    title String
    completed Boolean @default(false)
}

----------------------------------------

TITLE: Markdown Generator Plugin Implementation
DESCRIPTION: Complete implementation of a plugin that generates markdown documentation from ZModel schema, including policy rules and model descriptions.

LANGUAGE: typescript
CODE:
import { type PluginOptions } from '@zenstackhq/sdk';
import {
    isDataModel,
    type DataModel,
    type Model,
} from '@zenstackhq/sdk/ast';
import fs from 'fs';

export const name = 'Markdown';

export default async function run(model: Model, options: PluginOptions) {
    // process options
    const title = options.title ?? 'My Application Model';
    const description = options.description ?? 'Description of my application';

    // get all data models
    const dataModels = model.declarations.filter((x): x is DataModel =>
        isDataModel(x)
    );

    // TOC
    const toc = dataModels.map((x) => `- [${x.name}](#${x.name})`).join('\n');

    // data model docs
    const dataModelDocs = generateDataModelDocs(dataModels);

    fs.writeFileSync(
        'schema.md',
        `# ${title}
    
${description}
    
${toc}
    
${dataModelDocs}
    `
    );
}

----------------------------------------

TITLE: Markdown Generator Plugin Implementation
DESCRIPTION: Complete implementation of a plugin that generates markdown documentation from ZModel schema, including policy rules and model descriptions.

LANGUAGE: typescript
CODE:
import { type PluginOptions } from '@zenstackhq/sdk';
import {
    isDataModel,
    type DataModel,
    type Model,
} from '@zenstackhq/sdk/ast';
import fs from 'fs';

export const name = 'Markdown';

export default async function run(model: Model, options: PluginOptions) {
    // process options
    const title = options.title ?? 'My Application Model';
    const description = options.description ?? 'Description of my application';

    // get all data models
    const dataModels = model.declarations.filter((x): x is DataModel =>
        isDataModel(x)
    );

    // TOC
    const toc = dataModels.map((x) => `- [${x.name}](#${x.name})`).join('\n');

    // data model docs
    const dataModelDocs = generateDataModelDocs(dataModels);

    fs.writeFileSync(
        'schema.md',
        `# ${title}
    
${description}
    
${toc}
    
${dataModelDocs}
    `
    );
}

----------------------------------------

TITLE: Defining Abstract and Extended Models in ZenStack
DESCRIPTION: This snippet demonstrates how to create an abstract 'Base' model with common fields and access rules, and then extend it with specific models like 'Post' and 'ToDo'. It showcases model inheritance in ZenStack.

LANGUAGE: tsx
CODE:
abstract model Base {
    id Int @id @default(autoincrement())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt()

    //Logged-in users can view
    @@allow('read', auth() != null)

}

model Post extends Base
{
    title String
    content String?
    viewCount Int @default(0)
}

model ToDo extends Base
{
    title String
    completed Boolean @default(false)
}

----------------------------------------

TITLE: Defining ZModel Schema with Clerk Integration
DESCRIPTION: Schema definition showing how to configure User and Post models with Clerk integration. The User model is marked as ignored since Clerk handles user storage, while Post model includes access policies based on authentication.

LANGUAGE: zmodel
CODE:
model User {
    id String @id
    @@ignore
}

model Post {
  id String @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  title String
  published Boolean @default(false)
  authorId String // stores Clerk's user ID

  // author has full access
  @@allow('all', auth() != null && auth().id == authorId)

  // logged-in users can view published posts
  @@allow('read', auth() != null && published)
}

----------------------------------------

TITLE: Defining Asset and Video Models with ZModel
DESCRIPTION: This snippet demonstrates how to use ZModel, ZenStack's schema language, to define an Asset base model and a Video model that extends it. It showcases custom attributes for access policies and model inheritance.

LANGUAGE: zmodel
CODE:
abstract model Asset {
  id Int
  createdAt DateTime @default(now)
  viewCount Int @default(0)
  owner User @relation(fields: [ownerId], references: [id])
  ownerId Int

  // custom attributes for defining access policies
  @@allow('read', true)
  @@allow('all', owner == auth())
}

// model inheritance with "extends"
model Video extends Asset {
  duration Int
  url String
}

----------------------------------------

TITLE: Enhancing PrismaClient with ZenStack in TypeScript
DESCRIPTION: Demonstrates how to use the enhance function to create an enhanced PrismaClient wrapper. It includes setting up the session context and specifying enhancement kinds.

LANGUAGE: typescript
CODE:
const session = getSession();
const enhancedClient = enhance(prisma,
  { user: session.user },
  { kinds: ['policy', 'password']}
);

----------------------------------------

TITLE: Applying Access Policies to Prisma Client with withPolicy in TypeScript
DESCRIPTION: The withPolicy function enhances a Prisma client with access policy and field validation features. It requires a context object with user information for evaluating access policies.

LANGUAGE: typescript
CODE:
function withPolicy<DbClient extends object>(
    prisma: DbClient,
    context?: WithPolicyContext,
    options?: WithPolicyOptions
): DbClient;

----------------------------------------

TITLE: Defining Data Models with ZenStack
DESCRIPTION: ZenStack schema definition for User, Pet, and Order models, including relationships and access control rules.

LANGUAGE: zmodel
CODE:
datasource db {
    provider = 'sqlite'
    url = 'file:./petstore.db'
}

generator client {
    provider = "prisma-client-js"
}

model User {
    id String @id @default(cuid())
    email String @unique
    password String @password @omit
    orders Order[]

    // everybody can signup
    @@allow('create', true)

    // user profile is publicly readable
    @@allow('read', true)
}

model Pet {
    id String @id @default(cuid())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
    name String
    category String
    order Order? @relation(fields: [orderId], references: [id])
    orderId String?

    // unsold pets are readable to all; sold ones are readable to buyers only
    @@allow('read', orderId == null || order.user == auth())

    // only allow update to 'orderId' field if it's not set yet (unsold)
    @@allow('update', name == future().name && category == future().category && orderId == null )
}

model Order {
    id String @id @default(cuid())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
    pets Pet[]
    user User @relation(fields: [userId], references: [id])
    userId String

    // users can read their orders
    @@allow('read,create', auth() == user)
}

----------------------------------------

TITLE: Defining ZenStack Schema for Blog Application
DESCRIPTION: Defines the data model for a blog application using ZenStack's schema language, including User, Profile, Post, and Comment models.

LANGUAGE: zmodel
CODE:
model User {
    id Int @id @default(autoincrement())
    email String
    posts Post[]
}

model Profile {
    id Int @id @default(autoincrement())
    gender String
    user User @relation(fields: [userId], references: [id])
    userId Int @unique
}

model Post {
    id Int @id @default(autoincrement())
    title String
    published Boolean @default(false)
    viewCount Int @default(0)
    author User @relation(fields: [authorId], references: [id])
    authorId Int
    comments Comment[]
}

model Comment {
    id Int @id @default(autoincrement())
    content String
    post Post @relation(fields: [postId], references: [id])
    postId Int
}

----------------------------------------

TITLE: Defining ZenStack Schema for Blog Application
DESCRIPTION: Defines the data model for a blog application using ZenStack's schema language, including User, Profile, Post, and Comment models.

LANGUAGE: zmodel
CODE:
model User {
    id Int @id @default(autoincrement())
    email String
    posts Post[]
}

model Profile {
    id Int @id @default(autoincrement())
    gender String
    user User @relation(fields: [userId], references: [id])
    userId Int @unique
}

model Post {
    id Int @id @default(autoincrement())
    title String
    published Boolean @default(false)
    viewCount Int @default(0)
    author User @relation(fields: [authorId], references: [id])
    authorId Int
    comments Comment[]
}

model Comment {
    id Int @id @default(autoincrement())
    content String
    post Post @relation(fields: [postId], references: [id])
    postId Int
}

----------------------------------------

TITLE: Field-Level Validation in ZModel Schema
DESCRIPTION: Demonstrates basic field-level validation attributes in ZModel for validating user data including email, image URL, password, and age constraints.

LANGUAGE: zmodel
CODE:
model User {
    id Int @id
    email String @unique @email @endsWith('@zenstack.dev')
    imgUrl String? @url
    password String @length(min: 8, max: 32)
    age Int @gt(0) @lt(120)
}

----------------------------------------

TITLE: Defining Access Policies with ZenStack in Prisma Schema
DESCRIPTION: This code snippet demonstrates how to define access policies directly in the Prisma schema using ZenStack. It shows access rules for the Post model, including conditions for different user roles and publication status.

LANGUAGE: prisma
CODE:
model Post {
    id Int @id @default(autoincrement())
    title String
    published Boolean @default(false)
    author User? @relation(fields: [authorId], references: [id], onDelete: Cascade)
    authorId Int?
    space Space? @relation(fields: [spaceId], references: [id], onDelete: Cascade)
    spaceId Int?
  
    @@allow('all', 
        auth() == author // author has full access
        || space.owner == auth() // space owner has full access
        || space.members?[user == auth() && role == ADMIN]) // space admin has full access
  
    // published posts can be read by anyone in the space
    @@allow('read', published && space.members?[user == auth()])
}

----------------------------------------

TITLE: Overriding Model-Level Policies in ZenStack
DESCRIPTION: Demonstrates how to override model-level policies using field-level policies with the override flag set to true.

LANGUAGE: zmodel
CODE:
model Post {
    ...
    published Boolean @allow('update', auth().role == EDITOR, true)

    @@allow('update', !published)
}

----------------------------------------

TITLE: Overriding Model-Level Policies in ZenStack
DESCRIPTION: Demonstrates how to override model-level policies using field-level policies with the override flag set to true.

LANGUAGE: zmodel
CODE:
model Post {
    ...
    published Boolean @allow('update', auth().role == EDITOR, true)

    @@allow('update', !published)
}

----------------------------------------

TITLE: Defining Post and Comment Models with Access Control in ZModel
DESCRIPTION: This ZModel schema defines Post and Comment models with access control policies using the @@allow attribute. It implements a hybrid RBAC and ABAC model, controlling access based on user roles and post publication status.

LANGUAGE: zmodel
CODE:
model Post {
  id        Int      @id @default(autoincrement())
  title     String
  body      String
  comments  Comment[]
  user      User     @relation(fields: [userId], references: [id])
  userId    Int
  createdAt DateTime @default(now())
  published Boolean @default(false)

  // 🔐 Admin user can do everything to his own posts
  @@allow('all', auth().roles == 'admin' && auth() == user)

  // 🔐 Posts are visible to everyone if published
  @@allow('read', published)
}

model Comment {
  id        Int      @id @default(autoincrement())
  name      String
  body      String
  post      Post     @relation(fields: [postId], references: [id])
  postId    Int
  createdAt DateTime @default(now())

  // 🔐 Moderator user can do everything to comments
  @@allow('all', auth().roles == 'moderator')

  // 🔐 Everyone is allowed to view and create comments for published posts
  @@allow('create,read', post.published)
}

----------------------------------------

TITLE: ZenStack Data Model with Access Policies
DESCRIPTION: Data model definition with access control policies for User and Post entities

LANGUAGE: zmodel
CODE:
model User {
    id Int @id() @default(autoincrement())
    email String @unique()
    name String?
    posts Post[]

    @@allow('read', true)
}

model Post {
    id Int @id() @default(autoincrement())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt()
    title String
    content String?
    published Boolean @default(false)
    viewCount Int @default(0)
    author User? @relation(fields: [authorId], references: [id])
    authorId Int? @default(auth().id)

    @@allow('all', auth() == author)
    @@allow('read', auth() != null && published)
}

----------------------------------------

TITLE: Defining Cascade Delete Relationship in ZModel
DESCRIPTION: Illustrates how to define a cascade delete relationship between User and Post models in ZModel. This configuration ensures that when a User is deleted, associated Posts are automatically deleted and relevant queries are invalidated.

LANGUAGE: zmodel
CODE:
model User {
    ...
    posts Post[]
}

model Post {
    ...
    user User @relation(fields: [userId], references: [id], onDelete: Cascade)
    userId Int
}

----------------------------------------

TITLE: Creating Enhanced PrismaClient with User Context
DESCRIPTION: This helper function creates an enhanced PrismaClient that enforces access policies based on the current user's context.

LANGUAGE: typescript
CODE:
import { enhance } from "@zenstackhq/runtime";
import { stackServerApp } from "~/stack";

export async function getUserDb() {
  const stackAuthUser = await stackServerApp.getUser();
  const currentTeam = stackAuthUser?.selectedTeam;

  // by default StackAuth's team members have "admin" or "member" role
  const perm =
    currentTeam && (await stackAuthUser.getPermission(currentTeam, "admin"));

  const user = stackAuthUser
    ? {
        userId: stackAuthUser.id,
        currentTeamId: stackAuthUser.selectedTeam?.id,
        currentTeamRole: perm ? "admin" : "member",
      }
    : undefined; // anonymous
  return enhance(prisma, { user });
}

----------------------------------------

TITLE: Using Member Access Expression in ZenStack Policy
DESCRIPTION: This snippet illustrates how to use a member access expression to access a field from another expression in a policy rule.

LANGUAGE: zmodel
CODE:
model Post {
    id Int @id
    published Boolean
    @@allow('read', auth().role == 'READ') // `auth().role` is a Member Access Expression
}

----------------------------------------

TITLE: Defining Cascade Delete Relationship in ZModel
DESCRIPTION: Illustrates how to define a cascade delete relationship between User and Post models in ZModel. This configuration ensures that when a User is deleted, associated Posts are automatically deleted and relevant queries are invalidated.

LANGUAGE: zmodel
CODE:
model User {
    ...
    posts Post[]
}

model Post {
    ...
    user User @relation(fields: [userId], references: [id], onDelete: Cascade)
    userId Int
}

----------------------------------------

TITLE: Defining Access Policy in ZModel
DESCRIPTION: Example of defining access policies for a Post model using ZModel syntax, demonstrating author access and published post visibility rules.

LANGUAGE: zmodel
CODE:
model Post {
    id        String @id @default(cuid())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
    title     String
    published Boolean @default(false)
    author    User @relation(fields: [authorId], references: [id])
    authorId  String

    // author has full access
    @@allow('all', auth() == author)

    // logged-in users can view published posts
    @@allow('read', auth() != null && published)
}

----------------------------------------

TITLE: Installing tRPC Plugin
DESCRIPTION: NPM installation command for the tRPC plugin

LANGUAGE: bash
CODE:
npm install --save-dev @zenstackhq/trpc

----------------------------------------

TITLE: Defining Access Policies in ZenStack Schema (Pet Store Example)
DESCRIPTION: This snippet demonstrates how to define access policies for a pet store scenario using ZenStack's schema language. It shows two different approaches to restricting pet additions to orders based on their current order status.

LANGUAGE: zmodel
CODE:
model Order
{
  pets Pet[]

  // The user could only create an order if all the pets in the order have not been added to any order yet.
  @@allow('create', !pets?[orderId != null])
}

LANGUAGE: zmodel
CODE:
model Pet
{
  orderId String
  order Order @relation(fields: [orderId], references: [id])

  // The pet could only be added to an order if it has not been added to any order yet.
  @@allow('update', orderId == null || future().orderId == orderId)
}

----------------------------------------

TITLE: Defining Todo App Schema with Duplicated Access Policies
DESCRIPTION: This snippet shows a ZModel schema for a Todo application with List and Todo models, demonstrating the duplication of access policies between parent and child models.

LANGUAGE: zmodel
CODE:
model List {
  id       Int @id
  name     String
  public   Boolean
  author   User @relation(fields: [authorId], references: [id])
  authorId Int
  todos    Todo[]

  @@allow('all', auth() == author)
  @@allow('read', public)
}

model Todo {
  id     Int @id
  name   String
  list   List @relation(fields: [listId], references: [id])
  listId Int

  @@allow('all', auth() == list.author)
  @@allow('read', list.public)
}

----------------------------------------

TITLE: Initializing RESTful API Handler in Next.js
DESCRIPTION: Example of setting up a RESTful API handler in Next.js using ZenStack's NextRequestHandler and RestApiHandler.

LANGUAGE: typescript
CODE:
import { NextRequestHandler } from '@zenstackhq/server/next';
import RestApiHandler from '@zenstackhq/server/api/rest';
import { getPrisma } from '../../lib/db';

export default NextRequestHandler({ 
    getPrisma,
    handler: RestApiHandler({ endpoint: 'http://myhost/api' }) 
});

----------------------------------------

TITLE: Mounting ZenStack API in SvelteKit Server Hooks
DESCRIPTION: TypeScript code for creating a SvelteKit server hooks file to mount the ZenStack API. It includes setting up an enhanced Prisma client with user context and creating the hooks handler.

LANGUAGE: typescript
CODE:
import { SvelteKitHandler } from '@zenstackhq/server/sveltekit';
import { enhance } from '@zenstackhq/runtime';
import { getSessionUser } from '$lib/auth.ts';

// create an enhanced Prisma client with user context
function getPrisma(event: RequestEvent) {
    // getSessionUser extracts the current session user from the request, its
    // implementation depends on your auth solution
    return enhance({ user: getSessionUser(event) });
}

// create the hooks handler with the `getPrisma` hook
export const handle = SvelteKitHandler({ prefix: '/api/model', getPrisma });

----------------------------------------

TITLE: Implementing NextAuth Configuration
DESCRIPTION: NextAuth setup with credentials provider and JWT session strategy

LANGUAGE: typescript
CODE:
import { PrismaAdapter } from '@next-auth/prisma-adapter';
import { PrismaClient } from '@prisma/client';
import { compare } from 'bcryptjs';
import NextAuth, { NextAuthOptions } from 'next-auth';
import CredentialsProvider from 'next-auth/providers/credentials';
import { prisma } from 'server/db';

export const authOptions: NextAuthOptions = {
    adapter: PrismaAdapter(prisma),

    session: {
        strategy: 'jwt',
    },

    providers: [
        CredentialsProvider({
            credentials: {
                email: {
                    type: 'email',
                },
                password: {
                    type: 'password',
                },
            },
            authorize: authorize(prisma),
        }),
    ],

    callbacks: {
        async session({ session, token }) {
            return {
                ...session,
                user: {
                    ...session.user,
                    id: token.sub!,
                },
            };
        },
    },
};

----------------------------------------

TITLE: Refactoring Todo App Schema with 'check' Function
DESCRIPTION: This snippet demonstrates how to use the 'check' function to eliminate duplication in access policies between the List and Todo models in the ZModel schema.

LANGUAGE: zmodel
CODE:
model List {
  id       Int @id
  name     String
  public   Boolean
  author   User @relation(fields: [authorId], references: [id])
  authorId Int
  todos    Todo[]

  @@allow('all', auth() == author)
  @@allow('read', public)
}

model Todo {
  id     Int @id
  name   String
  list   List @relation(fields: [listId], references: [id])
  listId Int

  @@allow('all', check(list))
}

----------------------------------------

TITLE: Defining ZenStack Model with Access Policies
DESCRIPTION: ZModel file defining the Post model with access control policies using ZenStack.

LANGUAGE: typescript
CODE:
model Post {
    id Int @id @default(autoincrement())
    name String
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    createdBy User @relation(fields: [createdById], references: [id])
    createdById String

    published Boolean @default(false)

    @@index([name])

    // 🔐 author has full access
    @@allow('all', auth() == createdBy)

    // 🔐 logged-in users can view published posts
    @@allow('read', auth() != null && published)
}

----------------------------------------

TITLE: User Model Schema Definition
DESCRIPTION: ZenStack schema definition for User model with password authentication and access policies

LANGUAGE: zmodel
CODE:
model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime?
  password      String @password @omit
  image         String?
  accounts      Account[]
  sessions      Session[]
  posts         Post[]

  @@allow('create,read', true)
  @@allow('update,delete', auth() == this)
}

----------------------------------------

TITLE: Polymorphic Content Models with Table Inheritance
DESCRIPTION: Schema definitions showing table inheritance pattern for polymorphic content types

LANGUAGE: tsx
CODE:
model Content {
  id String @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  published Boolean @default(false)
  author User @relation(fields: [authorId], references: [id])
  authorId String
  contentType String
  likes Like[]
  post Post?

  @@allow('all', auth() == author)
  @@allow('read', auth() != null && published)
}

model Post {
  id String @id @default(cuid())
  title String
  content Content @relation(fields: [id], references: [id], onDelete: Cascade, onUpdate: Cascade)

  @@allow('create,delete', auth() == content.author)
  @@allow('read', auth() != null)
}

----------------------------------------

TITLE: Implementing CRUD API with ZenStack and Next.js
DESCRIPTION: Example of implementing a CRUD API using ZenStack with Next.js, demonstrating how to enhance PrismaClient with access control and create a request handler.

LANGUAGE: typescript
CODE:
// pages/api/model/[...path].ts
import { enhance } from '@zenstackhq/runtime';
import NextRequestHandler from '@zenstackhq/server/next';
import { getSessionUser } from '~/server/auth';

export default NextRequestHandler({
    // The `enhance` API creates a access-control-enabled wrapper around PrismaClient
    // The implementation of `getSessionUser` depends on your authentication solution
    getPrisma: (req, res) => enhance(prisma, { user: getSessionUser(req, res) })
});

----------------------------------------

TITLE: Defining Todo List and Item Models in ZenStack
DESCRIPTION: This snippet defines the data models for Todo lists and items using ZenStack's schema language. It includes relationships between models and basic field definitions.

LANGUAGE: zmodel
CODE:
model List {
    id String @id @default(uuid())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
    space Space @relation(fields: [spaceId], references: [id], onDelete: Cascade)
    spaceId String
    owner User @relation(fields: [ownerId], references: [id], onDelete: Cascade)
    ownerId String
    title String @length(1, 100)
    // whether it is private
    private Boolean @default(false)
    todos Todo[]
}

model Todo {
    id String @id @default(uuid())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
    owner User @relation(fields: [ownerId], references: [id], onDelete: Cascade)
    ownerId String
    list List @relation(fields: [listId], references: [id], onDelete: Cascade)
    listId String
    title String @length(1, 100)
    // completed time
    completedAt DateTime?
}

----------------------------------------

TITLE: Defining Data Models with ZenStack
DESCRIPTION: Schema definition for Booking and InvitedUser models with access control policies using ZenStack's .zmodel format

LANGUAGE: zmodel
CODE:
model Booking {
  id           String   @id() @default(cuid())
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  email        String
  notes        String
  startAt      DateTime
  duration     Int
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId       String
  invitedUsers InvitedUser[]

  @@allow('create', true)
  @@allow('all', auth() == user)
  @@allow('read', invitedUsers?[user == auth()])
}

----------------------------------------

TITLE: Defining Post Model in ZModel
DESCRIPTION: Example model definition showing field validation attributes and model-level validation rules

LANGUAGE: zmodel
CODE:
model Post {
  id Int @id @default(autoincrement())
  title String @length(10, 255)
  published Boolean @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  author User @relation(fields: [authorId], references: [id])
  authorId Int

  @@validate(regex(title, "^[A-Za-z0-9 ]+$"))
}

----------------------------------------

TITLE: Defining User Model for NextAuth in ZModel
DESCRIPTION: Sample User model definition compatible with NextAuth's CredentialsProvider, including access policies and field validations.

LANGUAGE: zmodel
CODE:
model User {
    id String @id @default(cuid())
    email String @unique @email
    emailVerified DateTime?
    password String @password @omit
    name String?
    image String? @url

    // open to signup
    @@allow('create', true)

    // full access by oneself
    @@allow('all', auth() == this)
}

----------------------------------------

TITLE: Implementing RESTful API with ZenStack Middleware
DESCRIPTION: Integrates ZenStack middleware with Express.js to create RESTful CRUD APIs for all resources.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client';
import { ZenStackMiddleware } from '@zenstackhq/server/express';
import RestApiHandler from '@zenstackhq/server/api/rest';
import express from 'express';

const app = express();
app.use(express.json());

const prisma = new PrismaClient();

// create a RESTful-style API handler
const apiHandler = RestApiHandler({ endpoint: 'http://localhost:3000/api' });

app.use('/api', ZenStackMiddleware({ 
    getPrisma: () => prisma,
    handler: apiHandler 
}));

export default app;

----------------------------------------

TITLE: Configuring ZenStack Fastify Plugin
DESCRIPTION: Example of registering the ZenStack Fastify plugin with server configuration. Shows how to set up API routes with prefix and session user authentication.

LANGUAGE: typescript
CODE:
import { enhance } from '@zenstackhq/runtime';
import { ZenStackFastifyPlugin } from '@zenstackhq/server/fastify';
import { prisma } from './db.ts';
import { getSessionUser } from './auth.ts';

const server = fastify();

// serve OpenAPI at /api/model
server.register(ZenStackFastifyPlugin, {
    prefix: '/api/model',
    // getSessionUser extracts the current session user from the request, its
    // implementation depends on your auth solution
    getPrisma: (request) => enhance(prisma, { user: getSessionUser(request) }),
});

----------------------------------------

TITLE: Mounting ZenStack API Handler in Nuxt
DESCRIPTION: Code demonstrating how to create a Nuxt server event handler that mounts ZenStack API endpoints. Shows integration with Prisma client enhancement and session user authentication.

LANGUAGE: typescript
CODE:
import { enhance } from '@zenstackhq/runtime';
import { createEventHandler } from '@zenstackhq/server/nuxt';
import { getSessionUser } from '~/server/auth';
import { prisma } from '~/server/prisma';

export default createEventHandler({
    getPrisma: async (event) => {
        return enhance(prisma, { user: getSessionUser(event) });
    },
});

----------------------------------------

TITLE: Defining Encrypted Fields in ZModel
DESCRIPTION: This snippet shows how to mark a field for encryption in a ZModel definition using the @encrypted attribute.

LANGUAGE: zmodel
CODE:
model User {
  id         String @id @default(cuid())
  someSecret String @encrypted
}

----------------------------------------

TITLE: Mounting ZenStack API Handler in Nuxt
DESCRIPTION: Code demonstrating how to create a Nuxt server event handler that mounts ZenStack API endpoints. Shows integration with Prisma client enhancement and session user authentication.

LANGUAGE: typescript
CODE:
import { enhance } from '@zenstackhq/runtime';
import { createEventHandler } from '@zenstackhq/server/nuxt';
import { getSessionUser } from '~/server/auth';
import { prisma } from '~/server/prisma';

export default createEventHandler({
    getPrisma: async (event) => {
        return enhance(prisma, { user: getSessionUser(event) });
    },
});

----------------------------------------

TITLE: Defining Post Model in ZModel
DESCRIPTION: Example model definition showing field validation attributes and model-level validation rules

LANGUAGE: zmodel
CODE:
model Post {
  id Int @id @default(autoincrement())
  title String @length(10, 255)
  published Boolean @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  author User @relation(fields: [authorId], references: [id])
  authorId Int

  @@validate(regex(title, "^[A-Za-z0-9 ]+$"))
}

----------------------------------------

TITLE: Defining ZenStack Schema for Todo App
DESCRIPTION: ZModel schema definition for the Todo application, including models for Space, SpaceUser, User, List, and Todo with their relationships and attributes.

LANGUAGE: zmodel
CODE:
datasource db {
  provider = "sqlite"
  url      = "file:./dev.db"
}

generator js {
  provider = "prisma-client-js"
}

// where users can collaborate on todo lists and items
model Space {
  id Int @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  name String
  slug String @unique
  owner User @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  ownerId Int
  members SpaceUser[]
  lists List[]
}

// a join table for many-to-many relation between `Space` and `User`
model SpaceUser {
  id Int @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  space Space @relation(fields: [spaceId], references: [id], onDelete: Cascade)
  spaceId Int
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId Int
  role String @default("USER")

  @@unique([userId, spaceId])
}

// user
model User {
  id Int @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  email String @unique
  name String?
  spaces SpaceUser[] // user's space membership
  lists List[]
  todos Todo[]
  ownedSpaces Space[] // spaces owned by the user
}

// todo list
model List {
  id Int @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  space Space @relation(fields: [spaceId], references: [id], onDelete: Cascade)
  spaceId Int
  owner User @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  ownerId Int
  title String
  private Boolean @default(false)
  todos Todo[]
}

// todo item
model Todo {
  id Int @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  owner User @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  ownerId Int
  list List @relation(fields: [listId], references: [id], onDelete: Cascade)
  listId Int
  title String
  completedAt DateTime?
}

----------------------------------------

TITLE: ZenStack Access Control Schema
DESCRIPTION: Extends the data models with access control policies using ZenStack's ZModel syntax to restrict data access based on user regions.

LANGUAGE: zmodel
CODE:
model Product {
  ...
  @@allow('read', auth() != null)
}

model Order {
  ...
  @@allow('read', auth().region == region)
}

model OrderItem {
  ...
  @@allow('read', auth().region == order.region)
}

view OrderItemDetail {
  ...
  @@allow('read', auth().region == region)
}

----------------------------------------

TITLE: RPC Flavor User Model Configuration
DESCRIPTION: Example of configuring a User model with OpenAPI metadata using RPC flavor, including security, operations customization, and documentation.

LANGUAGE: zmodel
CODE:
model User {
    id String @id
    email String @unique

    @@openapi.meta({
        security: [ { basic: [] } ],
        tagDescription: 'Operations for managing users',
        findMany: {
            description: 'Find users matching the given conditions'
        },
        delete: {
            method: 'put',
            path: 'dodelete',
            description: 'Delete a unique user',
            summary: 'Delete a user yeah yeah',
            tags: ['delete', 'user'],
        },
        createMany: {
            security: [],
            deprecated: true
        }
    })
}

----------------------------------------

TITLE: Adding Custom Error Messages to Field-Level Validation in ZModel
DESCRIPTION: This example shows how to add custom error messages to field-level validation attributes in a User model. It demonstrates customizing messages for email and password validation rules.

LANGUAGE: zmodel
CODE:
model User {
    ...
    email String @unique @email('must be a valid email')
    password String @length(min: 8, max: 32, message: 'must be between 8 and 32 characters long')
}

----------------------------------------

TITLE: Integrating ZenStack Middleware with Express.js
DESCRIPTION: Integration of ZenStack middleware with Express.js, including user authentication and enhanced Prisma client setup.

LANGUAGE: typescript
CODE:
import { enhance } from '@zenstackhq/runtime';
import type { Request } from 'express';

function getUser(req: Request) {
    const token = req.headers.authorization?.split(' ')[1];
    console.log('TOKEN:', token);
    if (!token) {
        return undefined;
    }
    try {
        const decoded: any = jwt.verify(token, process.env.JWT_SECRET!);
        return { id: decoded.sub };
    } catch {
        // bad token
        return undefined;
    }
}

app.use(
    '/api',
    ZenStackMiddleware({
        getPrisma: (req) => {
            return enhance(prisma, { user: getUser(req) });
        },
    })
);

----------------------------------------

TITLE: Creating Next.js Project with create-t3-app
DESCRIPTION: Command to create a new Next.js project using create-t3-app with Tailwind, NextAuth, Prisma, and app router.

LANGUAGE: bash
CODE:
npx create-t3-app@latest --tailwind --nextAuth --prisma --appRouter --CI my-todo-app

----------------------------------------

TITLE: User-Based Access Control in ZModel
DESCRIPTION: This snippet demonstrates how to implement user-based access control for User, List, and Todo models using ZenStack's policy rules.

LANGUAGE: zmodel
CODE:
model User {
  ...

  // everyone can sign up
  @@allow('create', true)

  // full access by oneself
  @@allow('all', auth() == this)
}

model List {
  ...

  // owner has full access
  @@allow('all', auth() == owner)
}

model Todo {
  ...

  // owner and list owner has full access
  @@allow('all', auth() == owner || auth() == list.owner)
}

----------------------------------------

TITLE: Creating Next.js Project with create-t3-app
DESCRIPTION: Command to create a new Next.js project using create-t3-app with Tailwind, NextAuth, Prisma, and app router.

LANGUAGE: bash
CODE:
npx create-t3-app@latest --tailwind --nextAuth --prisma --appRouter --CI my-todo-app

----------------------------------------

TITLE: Defining Types for JSON Fields in ZModel
DESCRIPTION: This snippet demonstrates how to define custom types for JSON fields in ZModel, including nested types.

LANGUAGE: zmodel
CODE:
type Address {
  state String
  city String
  zip String
}

type Profile {
  name String
  age Int
  address Address?
}

----------------------------------------

TITLE: Initializing RESTful API Handler for Next.js
DESCRIPTION: Sets up the RESTful API handler for a Next.js application, defining the handler for various HTTP methods.

LANGUAGE: typescript
CODE:
import { NextRequestHandler } from '@zenstackhq/server/next';
import { RestApiHandler } from '@zenstackhq/server/api';
import { getPrisma } from '~/lib/db';

const handler = NextRequestHandler({
    getPrisma,
    useAppDir: true,
    handler: RestApiHandler({ endpoint: 'http://myhost/api' })    
});

export {
  handler as GET,
  handler as POST,
  handler as PUT,
  handler as PATCH,
  handler as DELETE,
};

----------------------------------------

TITLE: Authentication Middleware Implementation
DESCRIPTION: Express middleware to require and validate X-USER-ID header for authentication

LANGUAGE: typescript
CODE:
app.use((req, res, next) => {
    const userId = req.header('X-USER-ID');
    if (!userId || Number.isNaN(parseInt(userId))) {
        res.status(403).json({ error: 'unauthorized' });
    } else {
        next();
    }
});

----------------------------------------

TITLE: Defining Post Model with Access Policies in ZModel
DESCRIPTION: This snippet defines a Post model with access policies using ZModel syntax. It includes fields for id, title, author relation, and published status, along with a read permission rule.

LANGUAGE: zmodel
CODE:
model Post {
  id Int @id @default(autoincrement())
  title String
  author User @relation(fields: [authorId], references: [id])
  authorId Int
  published Boolean @default(false)

  @@allow('read', published || authorId == auth().id)
}

----------------------------------------

TITLE: Implementing Optimistic Updates with SWR Hooks
DESCRIPTION: Example of using optimistic updates with SWR hooks generated by the @zenstackhq/swr plugin.

LANGUAGE: ts
CODE:
const { trigger: create } = useCreatePost({ optimisticUpdate: true });

function onCreatePost() {
    create({ ... })
}

----------------------------------------

TITLE: Using Reference Expression in ZenStack Policy
DESCRIPTION: This snippet demonstrates how to use a reference expression to access a model field in a policy rule.

LANGUAGE: zmodel
CODE:
model Post {
    ...
    published Boolean
    @@allow('read', published) // `published` is a Reference Expression
}

----------------------------------------

TITLE: Modeling Polymorphic Relations in ZModel
DESCRIPTION: This snippet shows how to define a polymorphic hierarchy using the @@delegate attribute in ZModel.

LANGUAGE: zmodel
CODE:
model User {
  id Int @id @default(autoincrement())
  contents Content[]
}

model Content {
  id Int @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  published Boolean @default(false)
  owner User @relation(fields: [ownerId], references: [id])
  ownerId Int
  contentType String

  @@delegate(contentType)
}

model Post extends Content {
  title String
}

model Video extends Content {
  name String
  duration Int
}

----------------------------------------

TITLE: Defining User Model with Password Hashing in ZenStack
DESCRIPTION: Basic user model schema demonstrating the @password attribute for automatic password hashing using bcryptjs.

LANGUAGE: zmodel
CODE:
model User {
    id Int @id @default(autoincrement())
    email String @unique
    password String? @password
}

----------------------------------------

TITLE: Implementing Computed Fields with Extended Prisma Client in TypeScript
DESCRIPTION: This example demonstrates how to implement computed fields using Prisma Client Extensions. It adds a 'myTitle' computed field to the 'post' model that prefixes the original title with 'MyTitle:'.

LANGUAGE: typescript
CODE:
const extendedPrisma = prisma.$extends({
  result: {
    post: {
      myTitle: {
        needs: { title: true },
        compute(post) {
          return 'MyTitle: ' + post.title;
        },
      },
    },
  },
});

const enhanced = enhance(extendedPrisma);
const post = await enhanced.post.findFirst();

----------------------------------------

TITLE: Basic ZModel Authorization Schema
DESCRIPTION: Demonstrates basic authorization rules for User and Post models using ZModel's policy attributes. Shows how to implement simple user-based access control.

LANGUAGE: zmodel
CODE:
model User {
    id Int @id
    email String
}

model Post {
    id Int @id
    title String
    content String
    published Boolean @default(false)
    author User @relation(fields: [authorId], references: [id])
    authorId Int String

    // published posts are readable to all login users
    @@allow('read', auth() != null && published)

    // author has full access
    @@allow('all', auth() == author)
}

----------------------------------------

TITLE: Defining EnhancementOptions Type in TypeScript
DESCRIPTION: Defines the type for options used in the enhance function. It includes various configuration options such as enhancement kinds, logging, error transformation, transaction settings, and encryption.

LANGUAGE: typescript
CODE:
type TransactionIsolationLevel =
    | 'ReadUncommitted'
    | 'ReadCommitted'
    | 'RepeatableRead'
    | 'Snapshot'
    | 'Serializable';

type SimpleEncryption = {
    encryptionKey: Uint8Array;
    decryptionKeys?: Uint8Array[];
}

type CustomEncryption = {
    encrypt: (model: string, field: FieldInfo, plain: string) => Promise<string>;
    decrypt: (model: string, field: FieldInfo, cipher: string) => Promise<string>;
};

type EnhancementOptions = {
    kinds?: EnhancementKind[];
    logPrismaQuery?: boolean;
    errorTransformer?: ErrorTransformer;
    transactionMaxWait?: number;
    transactionTimeout?: number;
    transactionIsolationLevel?: TransactionIsolationLevel;
    encryption?: SimpleEncryption | CustomEncryption;
};

----------------------------------------

TITLE: Creating Enhanced Prisma Client with Clerk Auth (Next.js Pages Router)
DESCRIPTION: This snippet demonstrates how to create an enhanced Prisma client that enforces access policies using Clerk authentication in a Next.js Pages Router setup.

LANGUAGE: typescript
CODE:
import type { NextApiRequest } from 'next';
import { enhance } from '@zenstackhq/runtime';
import { getAuth } from '@clerk/nextjs/server';
import { prisma } from '../lib/db';

async function getPrisma(req: NextApiRequest) {
  const auth = getAuth(req);
  // create a wrapper of Prisma client that enforces access policy
  return enhance(prisma, { user: auth ? { id: auth.userId } : undefined });
}

----------------------------------------

TITLE: Throwing PrismaClientKnownRequestError in TypeScript
DESCRIPTION: This snippet demonstrates how ZenStack throws a PrismaClientKnownRequestError with code 'P2004' when an operation is rejected by access policies or fails validation rules. It includes additional metadata about the error reason.

LANGUAGE: typescript
CODE:
throw new PrismaClientKnownRequestError(message, {
    clientVersion: getVersion(),
    code: 'P2004',
    meta: ...
});

----------------------------------------

TITLE: Using Query and Mutation Hooks in React
DESCRIPTION: Example of using generated query and mutation hooks in a React component for fetching and creating posts.

LANGUAGE: typescript
CODE:
import { useFindManyPost, useCreatePost } from '../lib/hooks';

const Posts = ({ userId }: { userId: string }) => {
    const create = useCreatePost();

    const { data: posts } = useFindManyPost({
        include: { author: true },
        orderBy: { createdAt: 'desc' },
    });

    async function onCreatePost() {
        create.mutate({
            data: {
                title: 'My awesome post',
                authorId: userId,
            },
        });
    }

    return (
        <>
            <button onClick={onCreatePost}>Create</button>
            <ul>
                {posts?.map((post) => (
                    <li key={post.id}>
                        {post.title} by {post.author.email}
                    </li>
                ))}
            </ul>
        </>
    );
};

----------------------------------------

TITLE: Creating Enhanced PrismaClient with ZenStack
DESCRIPTION: TypeScript code to create an enhanced PrismaClient with ZenStack, including user context for authentication.

LANGUAGE: typescript
CODE:
const session = await auth();
const user = session?.user?.id ? { id: session.user.id } : undefined;
const db = enhance(prisma, { user });

----------------------------------------

TITLE: Checking Read Permission for Anonymous User in TypeScript
DESCRIPTION: This code demonstrates how to use the 'check' API to verify if an anonymous user can read posts.

LANGUAGE: typescript
CODE:
const db = enhance(prisma); // enhance without a user context
await canRead = await db.post.check({ operation: 'read' });

----------------------------------------

TITLE: Adding Field-Level Policies to List and Todo Models in ZenStack
DESCRIPTION: This snippet demonstrates adding field-level policies to prevent the 'ownerId' field from being updated in both List and Todo models.

LANGUAGE: zmodel
CODE:
model List {
    ...
    ownerId Int @deny('update', true)
}

model Todo {
    ...
    ownerId Int @deny('update', true)
}

----------------------------------------

TITLE: Creating PrismaClient Instance
DESCRIPTION: Code to create and export a PrismaClient instance for database operations.

LANGUAGE: ts
CODE:
import { PrismaClient } from '@prisma/client';
export const prisma = new PrismaClient();

----------------------------------------

TITLE: ZModel Data Validation Example
DESCRIPTION: Example of field and model-level validation rules.

LANGUAGE: zmodel
CODE:
model User {
    id String @id
    handle String @regex("^[0-9a-zA-Z]{4,16}$")
    email String? @email @endsWith("@myorg.com", "must be an email from myorg.com")
    profileImage String? @url
    age Int @gte(18)
    activated Boolean @default(false)

    @@validate(!activated || email != null, "activated user must have an email")
}

----------------------------------------

TITLE: Using Enhanced Type Utility in TypeScript
DESCRIPTION: Shows how to use the Enhanced type utility to infer the enhanced PrismaClient type from an original PrismaClient instance. Works with both raw PrismaClient and instances with Client Extensions.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client';
import type { Enhanced } from '@zenstackhq/runtime';

const prisma = new PrismaClient();

type EnhancedPrismaClient = Enhanced<typeof prisma>;

----------------------------------------

TITLE: Implementing Automatic CRUD API with Next.js
DESCRIPTION: Next.js API route handler that creates an enhanced Prisma client and sets up automatic CRUD endpoints using ZenStack's NextRequestHandler.

LANGUAGE: typescript
CODE:
import { auth } from '@/auth';
import { prisma } from '@/db';
import { enhance } from '@zenstackhq/runtime';
import { NextRequestHandler } from '@zenstackhq/server/next';

// create an enhanced Prisma client with user context
async function getPrisma() {
  const session = await auth();
  const user = session?.user?.id ? { id: session.user.id } : undefined;
  return enhance(prisma, { user });
}

const handler = NextRequestHandler({ getPrisma, useAppDir: true });

export {
    handler as DELETE,
    handler as GET,
    handler as PATCH,
    handler as POST,
    handler as PUT,
};

----------------------------------------

TITLE: Registering ZenStack Module in NestJS
DESCRIPTION: Example of registering the ZenStack module in a NestJS application module using registerAsync. Shows how to set up the enhanced Prisma service with dependency injection.

LANGUAGE: typescript
CODE:
import { ZenStackModule } from '@zenstackhq/server/nestjs';
import { enhance } from '@zenstackhq/runtime';
import { PrismaService } from './prisma.service';

@Module({
  imports: [
    ZenStackModule.registerAsync({
      useFactory: (prisma: PrismaService) => {
        return {
          getEnhancedPrisma: () => enhance(prisma, { user: ... }),
        };
      },
      inject: [PrismaService],
      extraProviders: [PrismaService],
    }),
  ],
})
export class AppModule {}

----------------------------------------

TITLE: Updating API to Use User-bound Prisma Client
DESCRIPTION: Changes the API to use getPrisma(req) instead of the global prisma client to enforce access policies.

LANGUAGE: typescript
CODE:
app.get(`/post`, async (req, res) => {
    const post = await getPrisma(req).post.findMany({
        include: { author: true },
    });
    res.json(post);
});

----------------------------------------

TITLE: Setting Up React Query Client and Provider
DESCRIPTION: React component setup for QueryClient, QueryClientProvider, and ZenStackHooksProvider.

LANGUAGE: typescript
CODE:
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { Provider as ZenStackHooksProvider } from '../lib/hooks';

const queryClient = new QueryClient();

function App({ Component, pageProps: { session, ...pageProps } }: AppProps) {
    return (
        <QueryClientProvider client={queryClient}>
            <ZenStackHooksProvider value={{ endpoint: '/api/model' }}>
                <AppContent />
            </ZenStackHooksProvider>
        </QueryClientProvider>
    );
}

----------------------------------------

TITLE: Querying Polymorphic Relations in TypeScript
DESCRIPTION: This snippet shows various ways to query and manipulate polymorphic relations using the enhanced PrismaClient.

LANGUAGE: typescript
CODE:
const user = await db.user.create({ data: { id: 1 } });

const post = await db.post.create({
  data: {
    owner: { connect: { id: user.id } }, 
    title: 'Post1' 
  },
});

const video = await db.video.create({
  data: {
    owner: { connect: { id: user.id } },
    name: 'Video1',
    duration: 100,
  }
});

console.log('All posts:', inspect(await db.post.findMany()));

console.log('All contents:', inspect(await db.content.findMany()));

const firstContent = await db.content.findFirstOrThrow();
if (firstContent.contentType === 'Post') {
  console.log('Post title:', firstContent.title);
} else {
  console.log('Video name:', firstContent.name);
}

await db.user.update({
  where: { id: user.id },
  data: {
    contents: { 
      updateMany: { where: {}, data: { published: true } } 
    },
  },
});

await db.content.deleteMany();

console.log('All posts after delete:', inspect(await db.post.findMany()));

----------------------------------------

TITLE: Role-Based Access Control Schema
DESCRIPTION: Implements RBAC with user and admin roles, demonstrating role-based permissions for Post model access.

LANGUAGE: zmodel
CODE:
enum Role {
    USER
    ADMIN
}

model User {
    id Int @id
    email String
    role Role @default(USER)
}

model Post {
    id Int @id
    title String
    content String
    author User @relation(fields: [authorId], references: [id])
    authorId Int String

    // everyone can read posts
    @@allow('read', true)

    // admins have full access
    @@allow('all', auth().role == ADMIN)
}

----------------------------------------

TITLE: Defining Field-Level Policy for Post Model in ZenStack
DESCRIPTION: Example showing how to define a field-level policy that restricts updating the 'published' field to users with EDITOR role.

LANGUAGE: zmodel
CODE:
model Post {
    ...
    published Boolean @allow('update', auth().role == EDITOR)
}

----------------------------------------

TITLE: Configuring Core Prisma Plugin in ZModel
DESCRIPTION: This snippet demonstrates how to explicitly declare and configure the @core/prisma plugin in a ZModel file. It shows how to customize the output location of the generated Prisma schema file.

LANGUAGE: zmodel
CODE:
plugin prisma {
    provider = "@core/prisma"
    output = "src/db/prisma/schema.prisma"
}

----------------------------------------

TITLE: Post Model Definition with Relations
DESCRIPTION: ZModel schema for Post model with user relations and access control policies

LANGUAGE: zmodel
CODE:
model Post {
  id        String @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  title     String
  published Boolean @default(false)
  author    User @relation(fields: [authorId], references: [id])
  authorId  String @default(auth().id)

  @@allow('all', auth() == author)
  @@allow('read', auth() != null && published)
}

----------------------------------------

TITLE: Implementing Model-Level Validation in ZModel
DESCRIPTION: This snippet illustrates how to use the @@validate attribute for model-level validation in a User model. It shows a rule that ensures an activated user must have an email address.

LANGUAGE: zmodel
CODE:
model User {
    id String @id
    email String? @unique
    activated Boolean @default(false)
    @@validate(!activated || email != null, "activated user must have an email")
}

----------------------------------------

TITLE: Defining Custom Auth Type in ZModel
DESCRIPTION: This snippet shows how to define a custom Auth type in ZModel for cases where user data is not stored locally. It includes fields for id, role, and permissions, and uses the @@auth attribute.

LANGUAGE: zmodel
CODE:
type Auth {
  id          String @id
  role        String
  permissions String[]
  @@auth
}

----------------------------------------

TITLE: Enhanced Prisma Client Setup
DESCRIPTION: Helper functions to create a user-bound Prisma client with access policy enforcement

LANGUAGE: typescript
CODE:
import { Request } from 'express';
import { enhance } from '@zenstackhq/runtime';

function getUserId(req: Request) {
    return parseInt(req.header('X-USER-ID')!);
}

function getPrisma(req: Request) {
    const userId = getUserId(req);
    const user = Number.isNaN(userId) ? undefined : { id: userId };
    return enhance(prisma, { user });
}

----------------------------------------

TITLE: Adding Admin Role Support in ZenStack Schema
DESCRIPTION: This code snippet demonstrates how to modify the ZenStack schema to support an admin role, including adding an enum for user roles, updating the SpaceUser model, and modifying access policies in the SpaceBase model.

LANGUAGE: zmodel
CODE:
/*
 * Enum for user's role in a space
 */
enum SpaceUserRole {
    USER
    ADMIN
}

model SpaceUser extends SpaceBase {
    role SpaceUserRole
    ...
}

abstract model SpaceBase {
    ...
    //allow admin user to do anything
    @@allow('all', space.members?[role == ADMIN])
}

----------------------------------------

TITLE: Slug Format Validation
DESCRIPTION: Implements regex validation for Space model's slug field to enforce alphanumeric format.

LANGUAGE: zmodel
CODE:
model Space {
     ...
     slug String @unique @regex('^[0-9a-zA-Z]{4,16}$')
}

----------------------------------------

TITLE: Configuring Core Prisma Plugin in ZModel
DESCRIPTION: This snippet demonstrates how to explicitly declare and configure the @core/prisma plugin in a ZModel file. It shows how to customize the output location of the generated Prisma schema file.

LANGUAGE: zmodel
CODE:
plugin prisma {
    provider = "@core/prisma"
    output = "src/db/prisma/schema.prisma"
}

----------------------------------------

TITLE: Adding Authorization Rules to Data Models
DESCRIPTION: Defines access control rules for Pet and Order models using ZenStack's @@allow syntax.

LANGUAGE: zmodel
CODE:
model Pet {
    id String @id @default(cuid())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
    name String
    category String
    order Order? @relation(fields: [orderId], references: [id])
    orderId String?

    // unsold pets are readable to all; sold ones are readable to buyers only
    @@allow('read', orderId == null || order.user == auth())

    // only allow update to 'orderId' field if it's not set yet (unsold)
    @@allow('update', name == future().name && category == future().category && orderId == null )
}

model Order {
    id String @id @default(cuid())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
    pets Pet[]
    user User @relation(fields: [userId], references: [id])
    userId String

    // users can read their orders
    @@allow('read,create', auth() == user)
}

----------------------------------------

TITLE: Type and Model Field Definition Example
DESCRIPTION: Demonstrates defining types and using them in models with JSON fields.

LANGUAGE: zmodel
CODE:
type Profile {
    email String @email
    name String
}

model User {
    id String @id
    profile Profile? @json
}

----------------------------------------

TITLE: ZenStack Enhanced Schema with Access Policies
DESCRIPTION: Demonstrates how to add access control policies to Prisma schema using ZenStack extensions.

LANGUAGE: zmodel
CODE:
model User {
    id String @id
    email String
    password String
    posts Post[]

    // policy: everybody can signup
    @@allow('create', true)
    // policy: allow full CRUD by self
    @@allow('all', auth() == this)
}
model Post {
    id String @id
    title String
    published Boolean @default(false)
    author User @relation(fields: [authorId], references: [id])
    authorId String

    // policy: allow logged-in users to read published posts
    @@allow('read', auth() != null && published)
    // policy: allow full CRUD by author
    // auth() is a built-in function that returns current user
    @@allow('all', author == auth())
}

----------------------------------------

TITLE: React Component for Todo Lists Management
DESCRIPTION: React component implementing the UI for displaying and managing todo lists with ZenStack's generated hooks

LANGUAGE: typescript
CODE:
export default function TodoListsCard() {
  const { data: todoLists } = useFindManyTodoList({
    orderBy: { createdAt: 'desc' },
  });

  const { mutateAsync: del, isPending: isDeleting } = useDeleteTodoList();

  async function onDelete(id: string) {
    await del({ where: { id } });
  }

  return (
    <Card>
      <CardHeader>
        <CardTitle>Todo List</CardTitle>
      </CardHeader>
      <CardContent>
        <div>
          {todoLists?.map((list) => (
            <div key={list.id}>
              <p>{list.name}</p>
              <p>{list.createdAt.toLocaleString()}</p>
              <Button disabled={isDeleting} onClick={() => onDelete(list.id)}>
                Delete
              </Button>
            </div>
          ))}
        </div>
      </CardContent>
    </Card>
  );
}

----------------------------------------

TITLE: Type-Safe tRPC Router Query
DESCRIPTION: Demonstrates ZenStack's enhanced tRPC router with Prisma-like type safety and field selection.

LANGUAGE: typescript
CODE:
const result = await trpc.todo.findMany.query({
  select: {
    id: true,
    title: true,
    done: true
  }
})

----------------------------------------

TITLE: Server-Side Database Utilities
DESCRIPTION: Helper functions for database operations with enhanced Prisma client implementing access policies

LANGUAGE: typescript
CODE:
import { enhance } from '@zenstackhq/runtime';

export function getEnhancedPrisma(userId: string) {
    return enhance(prisma, { user: { id: userId } });
}

----------------------------------------

TITLE: Configuring ZenStack Fastify Plugin
DESCRIPTION: Example of registering the ZenStack Fastify plugin with route prefix and session user configuration. The plugin enables CRUD API endpoints and integrates with Prisma enhanced by access policies.

LANGUAGE: typescript
CODE:
import { enhance } from '@zenstackhq/runtime';
import { ZenStackFastifyPlugin } from '@zenstackhq/server/fastify';
import { prisma } from './db.ts';
import { getSessionUser } from './auth.ts';

const server = fastify();

// serve OpenAPI at /api/model
server.register(ZenStackFastifyPlugin, {
    prefix: '/api/model',
    // getSessionUser extracts the current session user from the request, its
    // implementation depends on your auth solution
    getPrisma: (request) => enhance(prisma, { user: getSessionUser(request) }),
});

----------------------------------------

TITLE: Enabling Permission Checker in ZModel Configuration
DESCRIPTION: This snippet shows how to enable the generatePermissionChecker flag in the ZModel configuration to opt-in for the 'check' API feature.

LANGUAGE: zmodel
CODE:
plugin enhancer {
  provider = '@core/enhancer'
  generatePermissionChecker = true
}

----------------------------------------

TITLE: Setting Up Context Provider in React
DESCRIPTION: Example of setting up the ZenStack hooks context provider in a React application.

LANGUAGE: tsx
CODE:
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { Provider as ZenStackHooksProvider } from '../lib/hooks';
import type { FetchFn } from '@zenstackhq/tanstack-query/runtime';

// custom fetch function that adds a custom header
const myFetch: FetchFn = (url, options) => {
    options = options ?? {};
    options.headers = {
        ...options.headers,
        'x-my-custom-header': 'hello world',
    };
    return fetch(url, options);
};

const queryClient = new QueryClient();

function MyApp({ Component, pageProps: { session, ...pageProps } }: AppProps) {
    return (
        <QueryClientProvider client={queryClient}>
            <ZenStackHooksProvider value={{ endpoint: '/api/model', fetch: myFetch }}>
                <AppContent />
            </ZenStackHooksProvider>
        </QueryClientProvider>
    );
}

----------------------------------------

TITLE: Integrating ZenStack with Express.js
DESCRIPTION: Example of how to integrate ZenStack into an Express.js project using the ZenStackMiddleware. It demonstrates importing necessary modules, creating a Prisma client, and setting up the middleware.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client';
import { enhance } from '@zenstackhq/runtime';
import { ZenStackMiddleware } from '@zenstackhq/server/express';
import express from 'express';

const prisma = new PrismaClient();
const app = express();

app.use(express.json());

app.use(
    '/api/model',
    ZenStackMiddleware({
        // getSessionUser extracts the current session user from the request, its
        // implementation depends on your auth solution
        getPrisma: (request) => enhance(prisma, { user: getSessionUser(request) }),
    })
);

----------------------------------------

TITLE: Configuring tRPC Context with Enhanced Prisma Client
DESCRIPTION: Example of creating a tRPC context with an enhanced PrismaClient that includes access control

LANGUAGE: typescript
CODE:
export const createContext = async ({ req, res }: CreateNextContextOptions) => {
    const session = await getServerAuthSession({ req, res });
    return {
        session,
        // use access-control-enabled db client
        prisma: enhance(prisma, { user: session?.user }),
    };
};

----------------------------------------

TITLE: Installing ZenStack CLI Package
DESCRIPTION: Command to install the ZenStack CLI package as a development dependency using npm.

LANGUAGE: bash
CODE:
npm install --save-dev zenstack@latest

----------------------------------------

TITLE: Initializing ZenStack Project from Existing Prisma Project
DESCRIPTION: Use the ZenStack CLI to initialize a ZenStack project from an existing Prisma project. This command copies the Prisma schema to a ZModel file and installs necessary dependencies.

LANGUAGE: bash
CODE:
npx zenstack@latest init

----------------------------------------

TITLE: Creating Enhanced Prisma Client with Auth0 User
DESCRIPTION: Basic setup for creating a Prisma client enhanced with Auth0 user authentication data.

LANGUAGE: typescript
CODE:
export const getPrisma = async (req) => {
  const user = await getAuthenticatedAuth0User(req);
  return enhance(user);
};

----------------------------------------

TITLE: Enhanced ZenStack Server with Access Policies
DESCRIPTION: Implementation of ZenStack server with user authentication and access policy enforcement

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client';
import { enhance } from '@zenstackhq/runtime';
import { ZenStackMiddleware } from '@zenstackhq/server/express';
import express, { Request } from 'express';

const app = express();
app.use(express.json());

const prisma = new PrismaClient();

function getUser(req: Request) {
    if (req.headers['x-user-id']) {
        return { id: parseInt(req.headers['x-user-id'] as string) };
    } else {
        return undefined;
    }
}

app.use('/api/rpc', 
    ZenStackMiddleware({ 
        getPrisma: (req) => enhance(prisma, { user: getUser(req) })
    })
);

----------------------------------------

TITLE: Post Model Server Functions
DESCRIPTION: Server-side functions for post CRUD operations with access control.

LANGUAGE: typescript
CODE:
import type { User } from '@prisma/client';
import { getEnhancedPrisma } from '~/db.server';

export function getPosts({ userId }: { userId: User['id'] }) {
    return getEnhancedPrisma(userId).post.findMany({
        orderBy: { updatedAt: 'desc' },
    });
}

export function createPost({ body, title, userId }: Post & { userId: User['id'] }) {
    return getEnhancedPrisma(userId).post.create({
        data: { title, body },
    });
}

----------------------------------------

TITLE: Generating TypeScript Files with Custom Output
DESCRIPTION: Command for generating enhancer code as TypeScript files instead of compiled JavaScript, using both --no-compile and --output flags

LANGUAGE: bash
CODE:
zenstack generate --no-compile --output src/lib/zenstack

----------------------------------------

TITLE: Current User Session Management
DESCRIPTION: Implementation of user session management with database verification.

LANGUAGE: typescript
CODE:
const currentUser = async (req) => {
  const session = await getSession(req); 

  if (!session?.user.sub) { 
    throw new Error('UNAUTHENTICATED');
  }

  const dbUser = await prisma.user.findUnique({ 
    where: { id: session.user.sub },
  }); 
  
  return {
    id: session.user.sub,
    dbUserExists: !isNull(dbUser),
  };
};

export const getPrisma = async (req) => {
  const user = await currentUser(req);
  return enhance(user);
};

----------------------------------------

TITLE: ZenStack Data Model with Access Policies
DESCRIPTION: Demonstrates how to define data models and access policies using ZenStack's ZModel DSL, including tenant isolation rules.

LANGUAGE: zmodel
CODE:
abstract model Basic {
    id String @id @default(uuid())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
    owner User @relation(fields: [ownerId], references: [id], onDelete: Cascade)
    ownerId String
    space Space @relation(fields: [spaceId], references: [id], onDelete: Cascade)
    spaceId String

    @@allow('read', owner == auth() || space.members?[user == auth()] )
    @@allow('create', owner == auth() && space.members?[user == auth()])
    @@allow('update', owner == auth() && space.members?[user == auth()] && future().owner == owner)
    @@allow('delete', owner == auth())
}

----------------------------------------

TITLE: Defining User Role Enum
DESCRIPTION: Example of defining an enum for user roles.

LANGUAGE: zmodel
CODE:
enum UserRole {
    USER
    ADMIN
}

----------------------------------------

TITLE: Using Infinite Query in React
DESCRIPTION: Example of using ZenStack-generated infinite query hook for pagination in a React component.

LANGUAGE: tsx
CODE:
import { useInfiniteFindManyPost } from '../lib/hooks';

// post list component with infinite loading
const Posts = () => {
    const PAGE_SIZE = 10;

    const fetchArgs = {
        include: { author: true },
        orderBy: { createdAt: 'desc' as const },
        take: PAGE_SIZE,
    };

    const { data, fetchNextPage, hasNextPage } = useInfiniteFindManyPost(fetchArgs, {
        getNextPageParam: (lastPage, pages) => {
            if (lastPage.length < PAGE_SIZE) {
                return undefined;
            }
            const fetched = pages.flatMap((item) => item).length;
            return {
                ...fetchArgs,
                skip: fetched,
            };
        },
    });    

    return (
        <>
            <ul>
                {data?.pages.map((posts, i) => (
                    <React.Fragment key={i}>
                        {posts?.map((post) => (
                            <li key={post.id}>
                                {post.title} by {post.author.email}
                            </li>
                        ))}
                    </React.Fragment>
                ))}
            </ul>
            {hasNextPage && (
                <button onClick={() => fetchNextPage()}>
                    Load more
                </button>
            )}
        </>
    );
};

----------------------------------------

TITLE: Enhanced Prisma Client Setup
DESCRIPTION: Helper function to create an access-policy-enabled Prisma client instance

LANGUAGE: typescript
CODE:
import { enhance } from '@zenstackhq/runtime';

export function getEnhancedPrisma(userId: string) {
    return enhance(prisma, { user: { id: userId } });
}

----------------------------------------

TITLE: Using Infinite Query in React
DESCRIPTION: Example of using ZenStack-generated infinite query hook for pagination in a React component.

LANGUAGE: tsx
CODE:
import { useInfiniteFindManyPost } from '../lib/hooks';

// post list component with infinite loading
const Posts = () => {
    const PAGE_SIZE = 10;

    const fetchArgs = {
        include: { author: true },
        orderBy: { createdAt: 'desc' as const },
        take: PAGE_SIZE,
    };

    const { data, fetchNextPage, hasNextPage } = useInfiniteFindManyPost(fetchArgs, {
        getNextPageParam: (lastPage, pages) => {
            if (lastPage.length < PAGE_SIZE) {
                return undefined;
            }
            const fetched = pages.flatMap((item) => item).length;
            return {
                ...fetchArgs,
                skip: fetched,
            };
        },
    });    

    return (
        <>
            <ul>
                {data?.pages.map((posts, i) => (
                    <React.Fragment key={i}>
                        {posts?.map((post) => (
                            <li key={post.id}>
                                {post.title} by {post.author.email}
                            </li>
                        ))}
                    </React.Fragment>
                ))}
            </ul>
            {hasNextPage && (
                <button onClick={() => fetchNextPage()}>
                    Load more
                </button>
            )}
        </>
    );
};

----------------------------------------

TITLE: Defining ZModel Schema with Supabase Auth Integration
DESCRIPTION: Schema definition for User and Post models with access policies configured for Supabase Auth integration. Includes UUID-based relationships and authorization rules.

LANGUAGE: zmodel
CODE:
model User {
    id String @id @db.Uuid
    posts Post[]
    ... // other fields

    @@allow('read', true)
}

model Post {
    id String @id @db.Uuid
    title String
    author User @relation(fields: [authorId], references: [id])
    authorId String @db.Uuid

    @@allow('all', author == auth())
}

----------------------------------------

TITLE: Demonstrating Post Creation with Automatic Owner Assignment in ZenStack V2
DESCRIPTION: This snippet illustrates the simplified post creation process in ZenStack V2, where the owner ID is automatically assigned using the auth() function in the schema.

LANGUAGE: jsx
CODE:
//schema.zmodel
model Post {
  ...
  owner User @relation(fields: [ownerId], references: [id])
  ownerId Int @default(auth().id) // <- assign ownerId automatically
}

//xxx.ts
const db = enhance(prisma, { user });
await db.post.create({ data: { title: 'Post1' } });

----------------------------------------

TITLE: Configuring Key Rotation for Encryption in TypeScript
DESCRIPTION: This snippet demonstrates how to set up key rotation by specifying multiple decryption keys when creating an enhanced PrismaClient.

LANGUAGE: typescript
CODE:
const db = enhance(prisma, { user }, {
  encryption: {
    encryptionKey: encryptionKey,
    decryptionKeys: [oldKey1, oldKey2, ...]
  }
});

----------------------------------------

TITLE: Attempting to Update List Owner in ZenStack REPL
DESCRIPTION: This JavaScript code snippet demonstrates an attempt to update the owner of a List entity, which should be denied due to the field-level policy.

LANGUAGE: js
CODE:
db.list.update({ where: { id: 1 }, data: { owner: { connect: 2 } } })

----------------------------------------

TITLE: Configuring Transaction Isolation Level in PrismaClient
DESCRIPTION: Demonstrates how to set the minimum required transaction isolation level (Repeatable Read) when creating a PrismaClient instance. This configuration ensures proper enforcement of access policies.

LANGUAGE: typescript
CODE:
const prisma = new PrismaClient({
  transactionOptions: {
    isolationLevel: Prisma.TransactionIsolationLevel.RepeatableRead,
  },
});

----------------------------------------

TITLE: Implementing Computed Fields Extension
DESCRIPTION: Example of adding a computed field to the Post model that transforms the title field

LANGUAGE: typescript
CODE:
const extendedPrisma = prisma.$extends({
  result: {
    post: {
      myTitle: {
        needs: { title: true },
        compute(post) {
          return 'MyTitle: ' + post.title;
        },
      },
    },
  },
});

const enhanced = enhance(extendedPrisma);
const post = await enhanced.post.findFirst();

----------------------------------------

TITLE: Enhanced PrismaClient Setup with Access Control
DESCRIPTION: Code snippet showing how to create an enhanced PrismaClient that automatically enforces access control policies.

LANGUAGE: typescript
CODE:
const userId = await requireUserId(request);

const user = await prisma.user.findUniqueOrThrow({
  where: { id: userId },
  select: { id: true, region: true },
});

const db = enhance(prisma, { user });

----------------------------------------

TITLE: Configuring ZenStack Schema in package.json
DESCRIPTION: Illustrates how to specify the ZModel schema location in the project's package.json file.

LANGUAGE: json
CODE:
{
  "zenstack": {
    "schema": "./db/schema.zmodel"
  }
}

----------------------------------------

TITLE: Generated Post Schema Definition
DESCRIPTION: TypeScript code showing the generated Zod schema for the Post model with all fields

LANGUAGE: typescript
CODE:
const PostSchema = z.object({
  id: z.number(),
  title: z.string().min(10).max(255),
  published: z.boolean(),
  createdAt: z.date(),
  updatedAt: z.date(),
  author: z.record(z.unknown()).optional(),
  authorId: z.number(),
});

----------------------------------------

TITLE: Main CLI Usage Overview
DESCRIPTION: Shows the main usage pattern and available commands for the ZenStack CLI tool

LANGUAGE: bash
CODE:
zenstack [options] [command]

ζ ZenStack is a Prisma power pack for building full-stack apps.

Documentation: https://zenstack.dev.

Options:
  -v --version           display CLI version
  -h, --help             display help for command

Commands:
  info [path]            Get information of installed ZenStack and related packages.
  init [options] [path]  Initialize an existing project for ZenStack.
  generate [options]     Generates RESTful API and Typescript client for your data model.
  repl [options]         Start a REPL session.
  format [options]       Format a ZenStack schema file.
  help [command]         Display help for a command.

----------------------------------------

TITLE: Using Permission Check Hook in React Component
DESCRIPTION: This snippet shows how to use the generated useCheckPost hook to check permissions in a React component.

LANGUAGE: typescript
CODE:
import { useCheckPost } from '~/lib/hooks';

const { data: canReadDrafts } = useCheckPost({
  operation: 'read',
  where: { published: false } 
});

----------------------------------------

TITLE: Creating User with Posts using RESTful Handler
DESCRIPTION: Example of creating a user and attaching two posts using the RESTful API handler with fetch. The request follows JSON:API specification format and returns the created user with relationship links.

LANGUAGE: typescript
CODE:
const r = await fetch(`/api/user`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/vnd.api+json' },
    body: JSON.stringify({
        data: {
            type: 'user',
            attributes: {
                email: 'user1@abc.com'
            },
            relationships: {
                posts: {
                    data: [
                        { type: 'post', id: 1 },
                        { type: 'post', id: 2 }
                    ]
                }
            }
        }
    })
});

console.log(await r.json());

LANGUAGE: json
CODE:
{
    "jsonapi": { "version": "1.1" },
    "data": {
        "type": "user",
        "id": 1,
        "attributes": {
            "email": "user1@abc.com"
        },
        "links": {
            "self": "http://localhost/api/user/1"
        },
        "relationships": {
            "posts": {
                "links": {
                    "self": "http://localhost/api/user/1/relationships/posts",
                    "related": "http://localhost/api/user/1/posts"
                },
                "data": [
                    { "type": "post", "id": 1 },
                    { "type": "post", "id": 2 }
                ]
            }
        }
    }
}

----------------------------------------

TITLE: Implementing Access Control Policies for Todo Lists
DESCRIPTION: This snippet demonstrates how to define access control policies for Todo lists using ZenStack's declarative syntax. It includes rules for reading, creating, updating, and deleting lists based on user permissions and list privacy settings.

LANGUAGE: zmodel
CODE:
model List {
    ...
    // require login
    @@deny('all', auth() == null)

    // can be read by owner or space members (only if not private)
    @@allow('read', owner == auth() || (space.members?[user == auth()] && !private))

    // when create, owner must be set to current user, and user must be in the space
    @@allow('create', owner == auth() && space.members?[user == auth()])

    // when create, owner must be set to current user, and user must be in the space
    // update is not allowed to change owner
    @@allow('update', owner == auth() && space.members?[user == auth()] && future().owner == owner)

    // can be deleted by owner
    @@allow('delete', owner == auth())
}

----------------------------------------

TITLE: Using Generated Schemas
DESCRIPTION: Example of importing and using the generated Zod schemas in TypeScript

LANGUAGE: typescript
CODE:
import { PostCreateSchema } from '@zenstackhq/runtime/zod/models';

PostCreateSchema.parse(data);

----------------------------------------

TITLE: Configuring ZenStack tRPC Plugin
DESCRIPTION: Example schema showing tRPC plugin configuration in a ZModel file

LANGUAGE: typescript
CODE:
plugin trpc {
  provider = '@zenstackhq/trpc'
  output = 'server/routers/generated'
  generateModelActions = 'create,update,findUnique,findMany'
}

model User {
  id            String    @id @default(cuid())
  email         String
  posts         Post[]

  // everyone can signup, and user profile is also publicly readable
  @@allow('create,read', true)
}

model Post {
  id        String @id @default(cuid())
  title     String
  published Boolean @default(false)
  author    User @relation(fields: [authorId], references: [id])
  authorId  String

  // author has full access
  @@allow('all', auth() == author)

  // logged-in users can view published posts
  @@allow('read', auth() != null && published)
}

----------------------------------------

TITLE: Defining ZenStack Schema with SWR Plugin
DESCRIPTION: Example of a ZenStack schema file that includes the SWR plugin configuration and model definitions.

LANGUAGE: zmodel
CODE:
plugin hooks {
  provider = '@zenstackhq/swr'
  output = "./src/lib/hooks"
}

model User {
  id            String    @id @default(cuid())
  email         String
  posts         Post[]

  // everyone can signup, and user profile is also publicly readable
  @@allow('create,read', true)
}

model Post {
  id        String @id @default(cuid())
  title     String
  published Boolean @default(false)
  author    User @relation(fields: [authorId], references: [id])
  authorId  String

  // author has full access
  @@allow('all', auth() == author)

  // logged-in users can view published posts
  @@allow('read', auth() != null && published)
}

----------------------------------------

TITLE: Generated Post Schema Definition
DESCRIPTION: TypeScript code showing the generated Zod schema for the Post model with all fields

LANGUAGE: typescript
CODE:
const PostSchema = z.object({
  id: z.number(),
  title: z.string().min(10).max(255),
  published: z.boolean(),
  createdAt: z.date(),
  updatedAt: z.date(),
  author: z.record(z.unknown()).optional(),
  authorId: z.number(),
});

----------------------------------------

TITLE: Implementing Post Listing API
DESCRIPTION: Express route handler for listing all blog posts with author information

LANGUAGE: typescript
CODE:
app.get(`/post`, async (req, res) => {
    const post = await prisma.post.findMany({
        include: { author: true },
    });
    res.json(post);
});

----------------------------------------

TITLE: Implementing Post Listing API
DESCRIPTION: Express route handler for listing all blog posts with author information

LANGUAGE: typescript
CODE:
app.get(`/post`, async (req, res) => {
    const post = await prisma.post.findMany({
        include: { author: true },
    });
    res.json(post);
});

----------------------------------------

TITLE: RBAC Sample Code in TypeScript
DESCRIPTION: Shows how to use the RBAC schema with ZenStack-enhanced PrismaClient to create users, roles, permissions, and resources, and enforce access control.

LANGUAGE: typescript
CODE:
const prisma = new PrismaClient();

// create a "view" permission and a "manage" permission
const viewPerm = await prisma.permission.create({
  data: { name: 'view' },
});
const managePerm = await prisma.permission.create({
  data: { name: 'manage' },
});

// create a "manager" role and a "staff" role
const managerRole = await prisma.role.create({
  data: {
    name: 'manager',
    permissions: { connect: [{ id: managePerm.id }] },
  },
});
const staffRole = await prisma.role.create({
  data: {
    name: 'staff',
    permissions: { connect: [{ id: viewPerm.id }] },
  },
});

// create two users, Emily (manager) and Adam (staff)
// note that we need to make sure "roles.permissions" are included in the
// returned result because they are used in the access rules
const emily = await prisma.user.create({
  data: { name: 'Emily', roles: { connect: { id: managerRole.id } } },
  include: { roles: { include: { permissions: true } } },
});
const adam = await prisma.user.create({
  data: { name: 'Adam', roles: { connect: { id: staffRole.id } } },
  include: { roles: { include: { permissions: true } } },
});

// create an enhanced PrismaClient for each user
const emilyDb = enhance(prisma, { user: emily });
const adamDb = enhance(prisma, { user: adam });

// ❌ Adam shouldn't be able to create a resource
await expect(
  adamDb.resource.create({ data: { name: 'resource1' } })
).rejects.toThrow();

// Emily should be able to create a resource
const res = await emilyDb.resource.create({ data: { name: 'resource1' } });
console.log('Resource created by Emily:', inspect(res));

// Adam should be able to read the resource
const resByAdam = await adamDb.resource.findUnique({ where: { id: res.id } });
console.log('Resource read by Adam:', inspect(resByAdam));
expect(resByAdam).toBeTruthy();

// ❌ Adam shouldn't be able to delete the resource
await expect(
  adamDb.resource.delete({ where: { id: res.id } })
).rejects.toThrow();

// Emily should be able to delete the resource
await emilyDb.resource.delete({ where: { id: res.id } });
console.log('Resource deleted by Emily');

----------------------------------------

TITLE: Query Key Structure for SWR Hooks
DESCRIPTION: Example of the query key structure used by the SWR hooks generated by the @zenstackhq/swr plugin.

LANGUAGE: ts
CODE:
JSON.stringify({ 
    prefix: 'zenstack',
    model: 'User', 
    operation: 'findUnique', 
    args: { where: { id: '1' } }, 
    flags: { infinite: false } 
})

----------------------------------------

TITLE: Installing and Configuring ZenStack Markdown Plugin
DESCRIPTION: These snippets show how to install the ZenStack Markdown plugin via npm and add it to the ZModel schema file.

LANGUAGE: bash
CODE:
npm i -D zenstack-markdown

LANGUAGE: zmodel
CODE:
plugin zenstackmd {
    provider = 'zenstack-markdown'
}

LANGUAGE: bash
CODE:
OPENAI_API_KEY=xxxx
XAI_API_KEY=xxxxx
ANTHROPIC_API_KEY=xxxx

----------------------------------------

TITLE: Creating User with Posts using RPC Handler
DESCRIPTION: Example of creating a user with two associated posts using the RPC-style API handler with fetch. The request includes nested creation of posts and returns the created user with their posts.

LANGUAGE: typescript
CODE:
const r = await fetch(`/api/user/create`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
        include: { posts: true },
        data: {
            email: 'user1@abc.com',
            posts: {
                create: [{ title: 'Post 1' }, { title: 'Post 2' }],
            },
        },
    }),
});

console.log(await r.json());

LANGUAGE: json
CODE:
{
    "id": 1,
    "email": "user1@abc.com",
    "posts": [
        {
            "id": 1,
            "createdAt": "2023-03-14T07:45:04.036Z",
            "updatedAt": "2023-03-14T07:45:04.036Z",
            "title": "Post 1",
            "authorId": 1
        },
        {
            "id": 2,
            "createdAt": "2023-03-14T07:45:04.036Z",
            "updatedAt": "2023-03-14T07:45:04.036Z",
            "title": "Post 2",
            "authorId": 1
        }
    ]
}

----------------------------------------

TITLE: Basic Prisma Schema Definition
DESCRIPTION: Defines basic data models for a blogging application using Prisma schema language.

LANGUAGE: zmodel
CODE:
model User {
    id String @id
    email String
    password String
    posts Post[]
}

model Post {
    id String @id
    title String
    published Boolean @default(false)
    author User @relation(fields: [authorId], references: [id])
    authorId String
}

----------------------------------------

TITLE: Implementing Infinite Query with SWR Hooks
DESCRIPTION: Example of implementing infinite query functionality using SWR hooks generated by the @zenstackhq/swr plugin.

LANGUAGE: tsx
CODE:
import type { Post } from '@prisma/client';
import { useInfiniteFindManyPost } from '../lib/hooks';

// post list component with infinite loading
const Posts = ({ userId }: { userId: string }) => {

    const PAGE_SIZE = 10;

    const { data: pages, size, setSize } = useInfiniteFindManyPost(
        (pageIndex, previousPageData) => {
            if (previousPageData && !previousPageData.length) {
                return null;
            }
            return {
                include: { author: true },
                orderBy: { createdAt: 'desc' },
                take: PAGE_SIZE,
                skip: pageIndex * PAGE_SIZE,
            };
        }
    );

    const isEmpty = pages?.[0]?.length === 0;
    const isReachingEnd = isEmpty || (pages && pages[pages.length - 1].length < PAGE_SIZE);

    return (
        <>
            <ul>
                {pages?.map((posts, index) => (
                    <React.Fragment key={index}>
                        {posts?.map((post) => (
                            <li key={post.id}>
                                {post.title} by {post.author.email}
                            </li>
                        ))}
                    </React.Fragment>
                ))}
            </ul>

            {!isReachingEnd && (
                <button onClick={() => setSize(size + 1)}>
                    Load more
                </button>
            )}
        </>
    );
};

----------------------------------------

TITLE: Implementing Access Control Rules with ZenStack
DESCRIPTION: Demonstrates how to define access control rules for Post model including user and group-based permissions

LANGUAGE: zmodel
CODE:
model User {
  id Int @id @default(autoincrement())
  username String
  groups Group[]
  posts Post[]
}

model Group {
  id Int @id @default(autoincrement())
  name String
  users User[]
  posts Post[]
}

model Post {
  id Int @id @default(autoincrement())
  title String
  slug String @unique
  groups Group[]
  users User[]

  // if the current user is in the user list of the post, update is allowed
  @@allow('read,update', users?[id == auth().id])

  // if the current user is in any group of the group list of the post,
  // update is allowed
  @@allow('read,update', groups?[users?[id == auth().id]])

  // ... other permissions
}

----------------------------------------

TITLE: Configuring ZenStackHooksProvider in React
DESCRIPTION: Example of setting up the ZenStackHooksProvider with custom fetch function in a React application.

LANGUAGE: tsx
CODE:
import { FetchFn, Provider as ZenStackHooksProvider } from '../lib/hooks';

// custom fetch function that adds a custom header
const myFetch: FetchFn = (url, options) => {
    options = options ?? {};
    options.headers = {
        ...options.headers,
        'x-my-custom-header': 'hello world',
    };
    return fetch(url, options);
};

function MyApp({ Component, pageProps: { session, ...pageProps } }: AppProps) {
    return (
        <ZenStackHooksProvider value={{ endpoint: '/api/model', fetch: myFetch }}>
            <AppContent />
        </ZenStackHooksProvider>
    );
}

----------------------------------------

TITLE: Demonstrating GitHub Copilot's Adaptability to Unknown Languages
DESCRIPTION: An image showing GitHub Copilot's effectiveness in working with a custom DSL based on Prisma ORM, despite not being explicitly trained on it.

LANGUAGE: markdown
CODE:
![Unknown language](unknown-language.png)

----------------------------------------

TITLE: Specifying Custom Auth Model with @@auth Attribute
DESCRIPTION: This snippet demonstrates how to use a model not named 'User' as the auth model by adding the @@auth attribute to it.

LANGUAGE: zmodel
CODE:
model MyUser {
    id Int @id
    role String
    posts Post[]

    @@auth
}

----------------------------------------

TITLE: Defining Database Schema with Prisma
DESCRIPTION: Prisma schema definition for the blogging app, including User, Post, Account, Session, and VerificationToken models.

LANGUAGE: zmodel
CODE:
datasource db {
  provider = "sqlite"
  url      = "file:./dev.db"
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id            String    @id() @default(cuid())
  name          String?
  email         String?   @unique()
  emailVerified DateTime?
  image         String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt()
  accounts      Account[]
  sessions      Session[]
  password      String
  posts         Post[]
}

model Post {
  id        String   @id() @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt()
  title     String
  content   String
  status    String   @default("draft")
  author    User     @relation(fields: [authorId], references: [id])
  authorId  String
}

model Account {
  ...
}

model Session {
  ...
}

model VerificationToken {
  ...
}

----------------------------------------

TITLE: Creating a Todo List Component in React
DESCRIPTION: This snippet shows the implementation of a Todo list component in React. It includes functionality for displaying list details, deleting lists, and handling user interactions.

LANGUAGE: tsx
CODE:
import { LockClosedIcon, TrashIcon } from '@heroicons/react/24/outline';
import { useList } from '@lib/hooks';
import { List } from '@prisma/client';
import { customAlphabet } from 'nanoid';
import { User } from 'next-auth';
import Image from 'next/image';
import Link from 'next/link';
import { useRouter } from 'next/router';
import Avatar from './Avatar';
import TimeInfo from './TimeInfo';

type Props = {
    value: List & { owner: User };
    deleted?: (value: List) => void;
};

export default function TodoList({ value, deleted }: Props) {
    const router = useRouter();

    const { del } = useList();

    const deleteList = async () => {
        if (confirm('Are you sure to delete this list?')) {
            await del({ where: { id: value.id } });
            if (deleted) {
                deleted(value);
            }
        }
    };
    // html
    return (...}
}

----------------------------------------

TITLE: PostgREST API Usage Examples in TypeScript
DESCRIPTION: Demonstrates common PostgREST API operations including fetching, filtering, relation loading and creation.

LANGUAGE: typescript
CODE:
// fetching a single user
GET /user?id=1

// search with filters
GET /user?age=gte.18&paid=is.true

// fetch with relation
GET /user?select=last_name,post(title)

// create
POST /user
{ "name": "J Doe", "age": 23 }

----------------------------------------

TITLE: Multiple Base Model Inheritance Example
DESCRIPTION: Shows how to inherit from multiple abstract models in a single concrete model.

LANGUAGE: zmodel
CODE:
abstract model Base1 { ... }

abstract model Base2 { ... }

model Post extends Base1, Base2 { ... }

----------------------------------------

TITLE: Basic Prisma Pulse Stream Usage in TypeScript
DESCRIPTION: Demonstrates how to use the basic stream() API to subscribe to all data change events for the User model.

LANGUAGE: typescript
CODE:
const stream = await prisma.user.stream()

for await (const event of stream) {
  console.log('just received an event:', event)
}

----------------------------------------

TITLE: Multiple Base Model Inheritance Example
DESCRIPTION: Shows how to inherit from multiple abstract models in a single concrete model.

LANGUAGE: zmodel
CODE:
abstract model Base1 { ... }

abstract model Base2 { ... }

model Post extends Base1, Base2 { ... }

----------------------------------------

TITLE: Defining Data Models with Prisma Schema
DESCRIPTION: Example of a basic Prisma schema showing User and Post models with relationships and enums

LANGUAGE: zmodel
CODE:
model User {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  email     String   @unique
  name      String?
  role      Role     @default(USER)
  posts     Post[]
}

model Post {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  published Boolean  @default(false)
  title     String   @db.VarChar(255)
  author    User?    @relation(fields: [authorId], references: [id])
  authorId  Int?
}

enum Role {
  USER
  ADMIN
}

----------------------------------------

TITLE: ZenStack Generate Command Examples
DESCRIPTION: Shows usage examples for the generate command with different configuration options

LANGUAGE: bash
CODE:
npx zenstack generate

npx zenstack generate --schema src/my.zmodel

----------------------------------------

TITLE: Using Now Function in ZenStack Policy
DESCRIPTION: This example demonstrates the use of the now() function to compare with a timestamp field in a policy rule.

LANGUAGE: zmodel
CODE:
@@allow('read', future().updatedAt < now())

----------------------------------------

TITLE: Defining User and Group Models with ZenStack
DESCRIPTION: Shows how to define basic User and Group models using ZenStack schema syntax

LANGUAGE: zmodel
CODE:
model User {
  id Int @id @default(autoincrement())
  username String
  groups Group[]
}

model Group {
  id Int @id @default(autoincrement())
  name String
  users User[]
}

----------------------------------------

TITLE: Defining Database Schema with Drizzle ORM in TypeScript
DESCRIPTION: This code snippet demonstrates how to define a database schema using Drizzle ORM. It includes tables for users, spaces, space users, and posts, along with their relationships and constraints.

LANGUAGE: typescript
CODE:
export const spaceUserRoleEnum = pgEnum('SpaceUserRole', ['MEMBER', 'ADMIN']);

// User table
export const users = pgTable(
    'users',
    {
        id: serial('id').primaryKey(),
        email: varchar('email', { length: 256 }).notNull(),
    },
    (users) => {
        return {
            emailIndex: uniqueIndex('email_idx').on(users.email),
        };
    }
);

// Space table
export const spaces = pgTable(
    'spaces',
    {
        id: serial('id').primaryKey(),
        slug: varchar('slug', { length: 8 }).notNull(),
        name: varchar('name', { length: 256 }).notNull(),
        ownerId: integer('ownerId').references(() => users.id, {
            onDelete: 'cascade',
        }),
    },
    (spaces) => {
        return {
            slugIndex: uniqueIndex('slug_idx').on(spaces.slug),
        };
    }
);

// Space <-> User join table
export const spaceUsers = pgTable(
    'spaceUsers',
    {
        id: serial('id').primaryKey(),
        spaceId: integer('spaceId').references(() => spaces.id, {
            onDelete: 'cascade',
        }),
        userId: integer('userId').references(() => users.id, {
            onDelete: 'cascade',
        }),
        role: spaceUserRoleEnum('role').notNull().default('MEMBER'),
    },
    (spaceUsers) => {
        return {
            uniqueSpaceUser: uniqueIndex('space_user_idx').on(
                spaceUsers.spaceId,
                spaceUsers.userId
            ),
        };
    }
);

// Post table
export const posts = pgTable('posts', {
    id: serial('id').primaryKey(),
    title: varchar('title', { length: 256 }).notNull(),
    published: boolean('published').default(false),
    spaceId: integer('spaceId').references(() => spaces.id, {
        onDelete: 'cascade',
    }),
    authorId: integer('authorId').references(() => users.id, {
        onDelete: 'cascade',
    }),
});

----------------------------------------

TITLE: Creating Enhanced Prisma Client with ZenStack
DESCRIPTION: Setup for enhanced Prisma client with automatic access policy validation and user context.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client';
import { validateRequest } from './auth';
import { enhance } from '@zenstackhq/runtime';

export const prisma = new PrismaClient();

export async function getEnhancedPrisma(): Promise<PrismaClient> {
  const { user } = await validateRequest();
  return enhance(prisma, { user: {id: user?.id!}});
}

----------------------------------------

TITLE: Initializing RPC API Handler for Next.js
DESCRIPTION: Sets up the RPC API Handler for a Next.js project. It uses NextRequestHandler and RPCApiHandler from ZenStack, and requires a getPrisma function for database access.

LANGUAGE: typescript
CODE:
import { NextRequestHandler } from '@zenstackhq/server/next';
import RPCApiHandler from '@zenstackhq/server/api/rpc';
import { getPrisma } from '../../lib/db';

export default NextRequestHandler({ 
    getPrisma, 
    handler: RPCApiHandler() // you can also omit it since `RPCApiHandler` is the default
});

----------------------------------------

TITLE: Defining Access Control Model in ZenStack
DESCRIPTION: Example of defining a Post model with access control policies using ZenStack's schema extension on top of Prisma. Shows how to implement role-based access control for post visibility.

LANGUAGE: typescript
CODE:
model Post {
    id String @id
    title String
    published Boolean @default(false)
    author User @relation(fields: [authorId], references: [id])
    authorId String

    // 🔐 author can read his own posts; other users can read published ones
    @@allow('read', auth() == author || published)
    ...
}

----------------------------------------

TITLE: Customizing user object in ZenStack GraphQLYoga plugin
DESCRIPTION: TypeScript code demonstrating how to customize the user object passed to the ZenStack GraphQLYoga plugin in RedwoodJS.

LANGUAGE: typescript
CODE:
useZenStack(db, async (currentUser) => {
  const typedUser = currentUser as { id: string };
  const dbUser = await db.user.findUnique({ 
    where: { id: typedUser.id },
    // select more fields
    select: { id: true, role: true }
  });
  return dbUser;
});

----------------------------------------

TITLE: Implementing Logging with Prisma Client Extensions
DESCRIPTION: Demonstrates how to add logging for specific operations, such as deleting a published post.

LANGUAGE: typescript
CODE:
const xprisma = prisma.$extends({
    name: 'logging',
    query: {
        post: {
            async delete({ args, query }) {
                const found = await prisma.post.findUnique({
                    select: { title: true, published: true },
                    where: args.where,
                });
                if (found && found.published) {
                    myLogger.warn(`Deleting published post: ${found.title}`);
                }
                return query(args);
            },
        },
    },
});

----------------------------------------

TITLE: Customizing user object in ZenStack GraphQLYoga plugin
DESCRIPTION: TypeScript code demonstrating how to customize the user object passed to the ZenStack GraphQLYoga plugin in RedwoodJS.

LANGUAGE: typescript
CODE:
useZenStack(db, async (currentUser) => {
  const typedUser = currentUser as { id: string };
  const dbUser = await db.user.findUnique({ 
    where: { id: typedUser.id },
    // select more fields
    select: { id: true, role: true }
  });
  return dbUser;
});

----------------------------------------

TITLE: Configuring TanStack Query Plugin
DESCRIPTION: Nuxt plugin to enable and configure TanStack Query for the application.

LANGUAGE: ts
CODE:
import { VueQueryPlugin, QueryClient } from '@tanstack/vue-query';

export default defineNuxtPlugin((nuxt) => {
    const queryClient = new QueryClient();
    nuxt.vueApp.use(VueQueryPlugin, { queryClient });
});

----------------------------------------

TITLE: Prisma Data Model Schema
DESCRIPTION: Defines the core data models for an e-commerce system including User, Product, Order, and OrderItem entities along with a helper view.

LANGUAGE: prisma
CODE:
model User {
  id String @id @default(cuid())
  email String @unique
  password String
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  region String
}

model Product {
  id String @id @default(cuid())
  name String
  category String
  price Float
  orderItems OrderItem[]
}

model Order {
  id String @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  items OrderItem[]
  region String
}

model OrderItem {
  id String @id @default(cuid())
  quantity Int
  productId String
  orderId String
  product Product @relation(fields: [productId], references: [id], onDelete: Cascade)
  order Order @relation(fields: [orderId], references: [id], onDelete: Cascade)
}

view OrderItemDetail {
  id String @id
  createdAt DateTime
  updatedAt DateTime
  region String
  product String
  category String
  unitPrice Float
  quantity Int
  subtotal Float
}

----------------------------------------

TITLE: Strongly Typed JSON Field Definition in ZenStack
DESCRIPTION: Definition of a strongly typed JSON field using ZenStack's type system and @json decorator.

LANGUAGE: zmodel
CODE:
type Metadata {
  width Int
  height Int
  format String
}

model Image {
  id Int @id @default(autoincrement())
  metadata Metadata @json
}

----------------------------------------

TITLE: Querying Posts with ZenStack
DESCRIPTION: Example of a query that may not behave as expected with automatic optimistic updates. The query filters for published posts, but newly created unpublished posts may still appear in the result set.

LANGUAGE: javascript
CODE:
useFindManyPost({ where: { published: true }})

----------------------------------------

TITLE: Reading a Concrete Entity with Enhanced PrismaClient
DESCRIPTION: This snippet demonstrates how to read a Video entity using the enhanced PrismaClient. The runtime merges the fields from both Asset and Video tables.

LANGUAGE: typescript
CODE:
const video = await db.video.findFirst();

----------------------------------------

TITLE: Implementing Access Control with Prisma Client Extensions
DESCRIPTION: Shows how to implement access control rules using Client Extensions in an Express.js application.

LANGUAGE: typescript
CODE:
function getAuthorizedDb(prisma: PrismaClient, userId: number) {
    return prisma.$extends({
        name: 'authorize',
        query: {
            post: {
                async findMany({ args, query }) {
                    return query({ ...args, where: { authorId: userId } });
                },
            },
        },
    });
}

app.get('/posts', (req, res) => {
    const userId = req.userId; // provided by some authentication middleware
    return getPosts(getAuthorizedDb(userId));
});

----------------------------------------

TITLE: Using enhance Function with Prisma Client in TypeScript
DESCRIPTION: Example of using the enhance function to create an enhanced Prisma client with ZenStack features. It takes the original Prisma client and a context object containing the user session.

LANGUAGE: typescript
CODE:
const session = getSession();
const enhancedClient = enhance(prisma, { user: session.user });

----------------------------------------

TITLE: Implementing Authentication API Handler in Next.js
DESCRIPTION: This code snippet shows the implementation of a login API handler in Next.js, which validates user credentials and issues a JWT token upon successful authentication.

LANGUAGE: typescript
CODE:
import { compare } from "bcryptjs";
import { sign } from "jsonwebtoken";
import { db } from "~/server/db";

export async function POST(request: Request) {
  const { email, password }: { email: string; password: string } =
    await request.json();

  const user = await db.user.findUnique({ where: { email } });
  if (!user) {
    return new Response("invalid email and password combination", {
      status: 401,
    });
  }

  if (!(await compare(password, user.password))) {
    return new Response("invalid email and password combination", {
      status: 401,
    });
  }

  return Response.json({
    id: user.id,
    email: user.email,
    token: sign(
      { sub: user.id.toString(), email: user.email, role: user.role },
      process.env.JWT_SECRET!,
    ),
  });
}

----------------------------------------

TITLE: Enhancing PrismaClient for Polymorphic Relations in TypeScript
DESCRIPTION: This snippet demonstrates how to create an enhanced PrismaClient with the 'delegate' enhancement kind enabled for polymorphic relations.

LANGUAGE: typescript
CODE:
const db = enhance(prisma, { user });

LANGUAGE: typescript
CODE:
const db = enhance(prisma, { user }, { kinds: ['delegate', 'policy'] });

----------------------------------------

TITLE: Combining Generated Components into Final Document in TypeScript
DESCRIPTION: This snippet demonstrates how to combine all the generated components (AI-generated content and Mermaid diagrams) into the final markdown document.

LANGUAGE: typescript
CODE:
const modelChapter = dataModels
        .map((x) => {
            return [
                `### ${x.name}`,
                mermaidGenerator.generate(x),
                object.models
                    .find((model) => model.name === x.name)
                    ?.access_control_policies.map((x) => `- ${x}`)
                    .join('\n'),
            ].join('\n');
        })
        .join('\n');

 const content = [
        `# Technical Design Document`,
        '> Generated by [`ZenStack-markdown`](https://github.com/jiashengguo/zenstack-markdown)',
        `${object.overview.description}`,
        `## Functionality`,
        `${object.overview.functionality}`,
        '## Models:',
        dataModels.map((x) => `- [${x.name}](#${x.name})`).join('\n'),
        modelChapter,
    ].join('\n\n');

----------------------------------------

TITLE: Defining User Type and Post Model in ZModel
DESCRIPTION: This snippet demonstrates how to define a User type and a Post model in ZModel, including access policies for blog posts.

LANGUAGE: zmodel
CODE:
type User {
  id String @id
}

model Post {
  id String @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  title String
  published Boolean @default(false)
  authorId String // stores Clerk's user ID

  // author has full access
  @@allow('all', auth() != null && auth().id == authorId)

  // logged-in users can view published posts
  @@allow('read', auth() != null && published)
}

----------------------------------------

TITLE: Generating ZenStack Modules for Source Tree Inclusion
DESCRIPTION: This command demonstrates how to use the ZenStack CLI to generate supporting modules into a specific output directory, allowing them to be committed to the repository.

LANGUAGE: bash
CODE:
npx zenstack generate --output ./zenstack

----------------------------------------

TITLE: Generating ZenStack Files with Custom Output Directory
DESCRIPTION: Command for generating enhancer code with a custom output directory specified using the --output flag

LANGUAGE: bash
CODE:
zenstack generate --output src/lib/zenstack

----------------------------------------

TITLE: Configuring Better-auth with Prisma Adapter
DESCRIPTION: Configuration for Better-auth using the Prisma adapter for database integration

LANGUAGE: typescript
CODE:
export const auth = betterAuth({
  appName: 'Better Auth Demo',
  database: prismaAdapter(prisma, {
      provider: 'sqlite',
  }),
  ...
});

----------------------------------------

TITLE: Implementing Post Management with Server Components and Actions
DESCRIPTION: Server Component for post management, including creation, toggling publish status, and deletion using Server Actions and ZenStack for access control.

LANGUAGE: typescript
CODE:
import { enhance } from "@zenstackhq/runtime";
import { revalidatePath } from "next/cache";
import { z } from "zod";
import { getServerAuthSession } from "~/server/auth";
import { db } from "~/server/db";

async function getEnhancedDb() {
  const session = await getServerAuthSession();
  return enhance(db, {
    user: session?.user ? { id: session.user.id } : undefined,
  });
}

const createSchema = z.object({ name: z.string() });
async function create(formData: FormData) {
  "use server";

  const session = await getServerAuthSession();
  if (!session) {
    return { error: "not logged in" };
  }

  const parsed = createSchema.parse(Object.fromEntries(formData));
  const db = await getEnhancedDb();
  await db.post.create({
    data: {
      name: parsed.name,
      createdBy: { connect: { id: session?.user.id } },
    },
  });
  revalidatePath("/");
}

const togglePublishedSchema = z.object({ id: z.coerce.number() });
async function togglePublished(formData: FormData) {
  "use server";

  const parsed = togglePublishedSchema.parse(Object.fromEntries(formData));
  const db = await getEnhancedDb();
  const curr = await db.post.findUnique({ where: { id: parsed.id } });
  if (!curr) {
    return { error: "post not found" };
  }
  await db.post.update({
    where: { id: parsed.id },
    data: { published: !curr.published },
  });

  revalidatePath("/");
}

const deleteSchema = z.object({ id: z.coerce.number() });
async function deletePost(formData: FormData) {
  "use server";

  const parsed = deleteSchema.parse(Object.fromEntries(formData));
  const db = await getEnhancedDb();
  await db.post.delete({
    where: { id: parsed.id },
  });
  revalidatePath("/");
}

const Posts = async () => {
  const db = await getEnhancedDb();
  const posts = await db.post.findMany({
    include: { createdBy: true },
    orderBy: { createdAt: "desc" },
  });

  return (
    <div>
      <form action={create}>
        <input type="text" name="name" />
        <input type="submit" value="+ Create Post" />
      </form>

      <ul>
        {posts?.map((post) => (
          <li key={post.id}>
            <p>
              {post.name} by {post.createdBy.email}
            </p>
            <div>
              <form action={togglePublished}>
                <input type="hidden" name="id" value={post.id} />
                <input type="submit" value={post.published ? "Unpublish": "Publish"} />
              </form>
              <form action={deletePost}>
                <input type="hidden" name="id" value={post.id} />
                <input type="submit" value="Delete" />
              </form>
            </div>
          </li>
        ))}
      </ul>
    </div>
  );
};

----------------------------------------

TITLE: PostgREST SQL Access Policy Definition
DESCRIPTION: Shows how to define row-level security policies in PostgreSQL for PostgREST.

LANGUAGE: sql
CODE:
-- users have full access to their own posts
CREATE POLICY post_owner_policy ON post
    USING (owner = current_user);

-- public posts are readable to all
CREATE POLICY post_read_policy ON post FOR SELECT
    USING (published = true);

----------------------------------------

TITLE: Declaring @core/zod Plugin in ZModel
DESCRIPTION: Example of how to declare and configure the @core/zod plugin in a ZModel file.

LANGUAGE: zmodel
CODE:
plugin zod {
  provider = '@core/zod'
}

----------------------------------------

TITLE: Declaring @core/zod Plugin in ZModel
DESCRIPTION: Example of how to declare and configure the @core/zod plugin in a ZModel file.

LANGUAGE: zmodel
CODE:
plugin zod {
  provider = '@core/zod'
}

----------------------------------------

TITLE: Implementing Row-Level Security in PostgreSQL
DESCRIPTION: Demonstrates how to set up row-level security policies in PostgreSQL to control access to post resources based on ownership and publication status.

LANGUAGE: sql
CODE:
CREATE POLICY post_owner_policy ON post
    USING (owner = current_user);

CREATE POLICY post_read_policy ON post FOR SELECT
    USING (published = true);

----------------------------------------

TITLE: Combined Pre and Post-Update Rules in ZenStack
DESCRIPTION: Shows how to combine pre-update and post-update conditions in a single rule, checking both the published status and revision number.

LANGUAGE: zmodel
CODE:
model Post {
    ...
    published Boolean
    revision Int

    @@allow('update', !published && future().revision > revision)
}

----------------------------------------

TITLE: Generating Mermaid ERD Diagram in TypeScript
DESCRIPTION: This class demonstrates how to generate a Mermaid ERD diagram from the data model, including relationships between entities.

LANGUAGE: typescript
CODE:
export default class MermaidGenerator {
    generate(dataModel: DataModel) {
        const fields = dataModel.fields
            .filter((x) => !isRelationshipField(x))
            .map((x) => {
                return [
                    x.type.type || x.type.reference?.ref?.name,
                    x.name,
                    isIdField(x) ? 'PK' : isForeignKeyField(x) ? 'FK' : '',
                    x.type.optional ? '"?"' : '',
                ].join(' ');
            })
            .map((x) => `  ${x}`)
            .join('\n');

        const relations = dataModel.fields
            .filter((x) => isRelationshipField(x))
            .map((x) => {
                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
                const oppositeModel = x.type.reference!.ref as DataModel;

                const oppositeField = oppositeModel.fields.find(
                    (x) => x.type.reference?.ref == dataModel
                ) as DataModelField;

                const currentType = x.type;
                const oppositeType = oppositeField.type;

                let relation = '';

                if (currentType.array && oppositeType.array) {
                    //many to many
                    relation = '}o--o{';
                } else if (currentType.array && !oppositeType.array) {
                    //one to many
                    relation = '||--o{';
                } else if (!currentType.array && oppositeType.array) {
                    //many to one
                    relation = '}o--||';
                } else {
                    //one to one
                    relation = currentType.optional ? '||--o|' : '|o--||';
                }

                return [`"${dataModel.name}"`, relation, `"${oppositeField.$container.name}": ${x.name}`].join(' ');
            })
            .join('\n');

        return ['```mermaid', 'erDiagram', `"${dataModel.name}" {\n${fields}\n}`, relations, '```'].join('\n');
    }
}

----------------------------------------

TITLE: Configuring API Endpoint for Query Hooks
DESCRIPTION: Adds script setup code to app.vue to configure the API endpoint used by the generated query hooks.

LANGUAGE: html
CODE:
<script setup lang="ts">
import { provideHooksContext } from './lib/hooks';

// Provide tanstack-query context
// Use an absolute endpoint so server-side fetch works too
provideHooksContext({
    endpoint: 'http://localhost:3000/api/model',
});
</script>

----------------------------------------

TITLE: User Queries in ZenStack REPL
DESCRIPTION: These REPL commands demonstrate how to set the current user and perform queries based on user-based access control.

LANGUAGE: javascript
CODE:
.auth { id: 1 }
db.user.findMany();

LANGUAGE: javascript
CODE:
.auth { id: 2 }
db.user.findMany();

LANGUAGE: javascript
CODE:
db.list.create({ data: { title: 'Grocery', owner: { connect: { email: 'rachel@zenstack.dev' } }, space: { connect: { slug: 'central-perk' } } } })

LANGUAGE: javascript
CODE:
db.list.create({ data: { title: 'Grocery', owner: { connect: { email: 'joey@zenstack.dev' } }, space: { connect: { slug: 'central-perk' } } } })

----------------------------------------

TITLE: Implementing Optimistic Updates - TypeScript
DESCRIPTION: Example demonstrating how to implement fine-grained optimistic updates using the new optimisticUpdateProvider callback

LANGUAGE: typescript
CODE:
useCreatePost({
  optimisticUpdateProvider: ({ queryModel, queryOperation, queryArgs, currentData, mutationArgs }) => {
    return { kind: 'Update', data: ... /* computed result */ };
  }
});

----------------------------------------

TITLE: Defining Data Models and Access Control with ZenStack
DESCRIPTION: Example of using ZenStack to define User and Todo models with access control policies, extending Prisma's data modeling capabilities.

LANGUAGE: zmodel
CODE:
model User {
  id String @default(cuid())
  email String @unique @email
  name String
  todos Todo[]

  // 🔐 user can fully control himself (`auth()` represents the current user)
  @@allow('all', auth() == this)

  // 🔐 user profiles are readable to all login users
  // `auth() == null` means the user is anonymous
  @@allow('read', auth() != null)
}

model Todo {
  id String @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  title String
  published Boolean @default(false)
  owner User @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  ownerId String

  // 🔐 owner has full access
  @@allow('all', auth() == owner)

  // 🔐 published todos are readable to all users (even anonymous)
  @@allow('read', published)
}

----------------------------------------

TITLE: Implementing Model-Level Methods with Extended Prisma Client in TypeScript
DESCRIPTION: This example demonstrates how to implement a model-level method 'getFeeds()' using Prisma Client Extensions. It shows how to extend the Prisma Client, enhance it with ZenStack, and use the new method.

LANGUAGE: typescript
CODE:
const extendedPrisma = prisma.$extends({
  model: {
    post: {
      async getFeeds() {
          const context = Prisma.getExtensionContext(this);
          return context.findMany();
      },
    },
  },
});

const db = enhance(extendedPrisma);
const feeds = await db.post.getFeeds();

----------------------------------------

TITLE: Initializing RESTful API Handler in SvelteKit
DESCRIPTION: Example of setting up a RESTful API handler in SvelteKit using ZenStack's SvelteKitHandler.

LANGUAGE: typescript
CODE:
import zenstack from '@zenstackhq/server/sveltekit';
import RestApiHandler from '@zenstackhq/server/api/rest';
import { getPrisma } from './lib/db';

export const handle = zenstack.SvelteKitHandler({
    prefix: '/api/model',
    getPrisma,
    handler: RestApiHandler({ endpoint: 'http://myhost/api/model' })
});

----------------------------------------

TITLE: Main Schema File with Imports
DESCRIPTION: Example of main schema file (schema.zmodel) that imports the base model and defines concrete models extending from it.

LANGUAGE: tsx
CODE:
import "base"
model User extends Base {
    name String
}

model Post extends Base {
    title String
    content String?
    viewCount Int @default(0)
    comment Comment[]
}

model Comment extends Base {
    content String
    post Post @relation(fields: [postId], references: [id])
    postId Int
}

----------------------------------------

TITLE: Complete OpenAPI Plugin Configuration Example
DESCRIPTION: Full example of configuring the OpenAPI plugin in a schema file, including database configuration and plugin settings

LANGUAGE: zmodel
CODE:
datasource db {
    provider = 'sqlite'
    url = 'file:./dev.db'
}

plugin openapi {
    provider = '@zenstackhq/openapi'
    output = './openapi.yaml'
    title = 'My awesome API'
    version = '0.5.0'
    summary = 'Created with ZenStack'
    description = 'My awesome API created with ZenStack'
    prefix = '/api'
}

----------------------------------------

TITLE: Implementing Model-Level Methods with Extended Prisma Client in TypeScript
DESCRIPTION: This example demonstrates how to implement a model-level method 'getFeeds()' using Prisma Client Extensions. It shows how to extend the Prisma Client, enhance it with ZenStack, and use the new method.

LANGUAGE: typescript
CODE:
const extendedPrisma = prisma.$extends({
  model: {
    post: {
      async getFeeds() {
          const context = Prisma.getExtensionContext(this);
          return context.findMany();
      },
    },
  },
});

const db = enhance(extendedPrisma);
const feeds = await db.post.getFeeds();

----------------------------------------

TITLE: Generating Object with Vercel AI SDK in TypeScript
DESCRIPTION: This snippet shows how to use the Vercel AI SDK's generateObject function to get a structured response from the AI model.

LANGUAGE: typescript
CODE:
const { object } = await generateObject({
        model
        schema
        prompt
    });

----------------------------------------

TITLE: Zod Plugin Declaration
DESCRIPTION: Configuration for enabling the Zod plugin in ZModel

LANGUAGE: zmodel
CODE:
plugin zod {
  provider = '@core/zod'
}

----------------------------------------

TITLE: Demonstrating Post Creation with Owner Assignment in ZenStack V1
DESCRIPTION: This snippet shows how to create a post with an owner in ZenStack V1, requiring explicit assignment of the owner ID.

LANGUAGE: jsx
CODE:
//schema.zmodel
model Post {
  ...
  owner User @relation(fields: [ownerId], references: [id])
  ownerId Int
}

//xxx.ts
const db = enhance(prisma, { user });
await db.post.create({
  data: {
   owner: { connect: { id: user.id } },
   title: 'Post1'
  }
})

----------------------------------------

TITLE: Configuring PrismaClient Logging Level
DESCRIPTION: Demonstrates how to enable info level logging on PrismaClient instance to view query logs.

LANGUAGE: typescript
CODE:
const prisma = new PrismaClient({ log: ['info'] });

----------------------------------------

TITLE: Installing ZenStack RedwoodJS Package
DESCRIPTION: Command to set up ZenStack integration in a RedwoodJS project

LANGUAGE: bash
CODE:
yarn rw setup package @zenstackhq/redwood

----------------------------------------

TITLE: Demonstrating 'check' Function Usage in ZModel
DESCRIPTION: This snippet shows various ways to use the 'check' function in ZModel schemas, including explicit operation specification, default operation, and combining with other conditions.

LANGUAGE: zmodel
CODE:
model Child {
  parent Parent
  @@allow('read', check(parent, 'update'))
}

model Child {
  ...
  parent Parent

  @@allow('read', check(parent)) // here the operation is implicitly 'read'
}

model Child {
  ...
  parent Parent

  @@allow('all', check(parent))
}

model Child {
  ...
  parent Parent

  @@allow('read', check(parent) || auth().status == 'PAID')
}

----------------------------------------

TITLE: ZenStack REPL Session Example
DESCRIPTION: Demonstrates interactive usage of the REPL session with PrismaClient methods

LANGUAGE: typescript
CODE:
> prisma.user.findMany()
[
  {
    id: '7aa301d2-7a29-4e1e-a041-822913a3ea78',
    createdAt: 2023-09-05T04:04:43.793Z,
    updatedAt: 2023-09-05T04:04:43.793Z,
    email: 'yiming@whimslab.io',
    ...
  }
]

> .auth { id: '7aa301d2-7a29-4e1e-a041-822913a3ea78' }
Auth user: { id: '7aa301d2-7a29-4e1e-a041-822913a3ea78' }. Use ".auth" to switch to anonymous.

> .table
Table output: true

> db.list.findMany({select: { title: true, private: true}})
┌─────────┬────────────────────────────────────────────────────┬─────────┐
│ (index) │                       title                        │ private │
├─────────┼────────────────────────────────────────────────────┼─────────┤
│    0    │                        'L1'                        │  false  │
│    1    │               'Wonderful new world'                │  false  │
│    2    │ 'Model for a space in which users can collaborate' │  false  │
└─────────┴────────────────────────────────────────────────────┴─────────┘

----------------------------------------

TITLE: NextAuth Frontend Sign-in Implementation
DESCRIPTION: Client-side implementation of sign-in functionality using NextAuth.

LANGUAGE: typescript
CODE:
import { signIn } from "next-auth/react";

async function onSignin(email: string, password: string) {
  const result = await signIn("credentials", {
    redirect: false,
    email,
    password,
  });

  if (result?.ok) {
    Router.push("/");
  } else {
    alert("Sign in failed");
  }
}

----------------------------------------

TITLE: Postgres Row Level Security Policy
DESCRIPTION: Example of implementing Row Level Security (RLS) in PostgreSQL for tenant isolation.

LANGUAGE: sql
CODE:
CREATE POLICY tenant_user_isolation_policy ON tenant_user
USING (tenant_id::TEXT = current_user);

----------------------------------------

TITLE: REST Flavor User Model Configuration
DESCRIPTION: Example of configuring a User model with OpenAPI metadata using REST flavor, demonstrating basic security and documentation setup.

LANGUAGE: zmodel
CODE:
model User {
    id String @id
    email String @unique

    @@openapi.meta({
        security: [ { basic: [] } ],
        tagDescription: 'Operations for managing users',
    })
}

----------------------------------------

TITLE: Configuring Prisma Client Logging in TypeScript
DESCRIPTION: This code demonstrates how to configure Prisma Client to log 'info' level messages, which is necessary to see ZenStack's query logs on the console.

LANGUAGE: typescript
CODE:
const prisma = new PrismaClient({ log: ['info'] });

----------------------------------------

TITLE: Running Prisma Database Migrations
DESCRIPTION: Commands for running database migrations in development and deployment environments.

LANGUAGE: bash
CODE:
npx prisma migrate dev

LANGUAGE: bash
CODE:
npx prisma migrate deploy

----------------------------------------

TITLE: Runtime Validation with Zod Schemas
DESCRIPTION: Example of using generated Zod schemas for runtime validation of JSON data.

LANGUAGE: typescript
CODE:
import { MetadataSchema } from '@zenstackhq/runtime/zod/models';

const image = await db.image.findFirstOrThrow();
const metadata = MetadataSchema.parse(image.metadata);

----------------------------------------

TITLE: Limiting Result Batch Size with Prisma Client Extensions
DESCRIPTION: Shows how to implement a safety guard that limits the number of returned rows for all 'findMany' queries.

LANGUAGE: typescript
CODE:
const MAX_ROWS = 100;
const xprisma = prisma.$extends({
    name: 'max-rows',
    query: {
        $allModels: {
            async findMany({ args, query }) {
                return query({ ...args, take: args.take || MAX_ROWS });
            },
        },
    },
});

----------------------------------------

TITLE: Configuring tRPC v11 Router
DESCRIPTION: TypeScript code for setting up the main tRPC v11 router using generated routes

LANGUAGE: typescript
CODE:
import { createRouter } from './generated/routers';

const t = initTRPC.context<Context>().create();

export const procedure = t.publicProcedure;
export const createTRPCRouter = t.createRouter;

...

export const appRouter = createRouter();
export type AppRouter = typeof appRouter;

----------------------------------------

TITLE: Defining access policies in ZModel for RedwoodJS
DESCRIPTION: ZModel schema defining a Post model with access policies for a blog application in RedwoodJS.

LANGUAGE: zmodel
CODE:
model Post {
  id        Int      @id @default(autoincrement())
  title     String
  body      String
  comments  Comment[]
  user      User     @relation(fields: [userId], references: [id])
  userId    Int
  createdAt DateTime @default(now())
  published Boolean @default(true)

  // 🔐 Admin user can do everything to his own posts
  @@allow('all', auth().roles == 'admin' && auth() == user)

  // 🔐 Posts are visible to everyone if published
  @@allow('read', published)
}

----------------------------------------

TITLE: Server-side Request Hook
DESCRIPTION: SvelteKit server hook implementation for user authentication and database access control.

LANGUAGE: typescript
CODE:
import { env } from '$env/dynamic/private';
import { JWT_TOKEN_COOKIE_NAME } from '$lib/auth';
import { prisma } from '$lib/db';
import type { Handle } from '@sveltejs/kit';
import { enhance } from '@zenstackhq/runtime';
import jwt from 'jsonwebtoken';

const auth = (async ({ event, resolve }) => {
    const token = event.cookies.get(JWT_TOKEN_COOKIE_NAME);
    if (token) {
        try {
            const decoded = jwt.verify(token, env.JWT_SECRET);
            const user = await prisma.user.findUnique({
                where: { id: decoded.sub as string }
            });
            if (user) {
                event.locals.user = user;
            } else {
                console.warn('User not found:', decoded.sub);
                event.cookies.delete(JWT_TOKEN_COOKIE_NAME, { path: '/' });
            }
        } catch {
            event.cookies.delete(JWT_TOKEN_COOKIE_NAME, { path: '/' });
        }
    }

    event.locals.db = enhance(prisma, {
        user: event.locals.user ? { id: event.locals.user.id } : undefined
    });

    return resolve(event);
}) satisfies Handle;

export const handle = auth;

----------------------------------------

TITLE: Configuring SWR Plugin
DESCRIPTION: Example of configuring a SWR plugin for data fetching.

LANGUAGE: zmodel
CODE:
plugin swr {
    provider = '@zenstackhq/swr'
    output = 'lib/hooks'
}

----------------------------------------

TITLE: Basic JSON Type Usage in TypeScript
DESCRIPTION: Example of using JSON data with type casting in TypeScript.

LANGUAGE: typescript
CODE:
type Metadata {
  width: number
  height: number
  format: string
}

const image = await prisma.image.findFirstOrThrow();
// an explicit cast into the desired type
const metadata = image.metadata as Metadata;
console.log('Image dimensions:', metadata.width, 'by', metadata.height);

----------------------------------------

TITLE: OpenAPI Security Scheme Configuration in ZModel
DESCRIPTION: Example of configuring security schemes in the OpenAPI plugin including basic auth, bearer token, and API key authentication.

LANGUAGE: zmodel
CODE:
plugin openapi {
    provider = '@zenstackhq/openapi'
    securitySchemes = {
        basic: { type: 'http', scheme: 'basic' },
        bearer: { type: 'http', scheme: 'bearer', bearerFormat: 'JWT' },
        apiKey: { type: 'apiKey', in: 'header', name: 'X-API-KEY' }
    }
}

----------------------------------------

TITLE: Implementing Backend API Route
DESCRIPTION: Next.js API route implementation using enhanced PrismaClient for data validation

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client';
import { enhance } from '@zenstackhq/runtime';
import { NextResponse } from 'next/server';

const db = enhance(new PrismaClient());

export async function POST(request: Request) {
    const data = await request.json();
    try {
        const result = await db.signup.create({ data });
        return NextResponse.json(result, { status: 201 });
    } catch (err: any) {
        return NextResponse.json({ error: err.message }, { status: 400 });
    }
}

----------------------------------------

TITLE: Creating Post Component
DESCRIPTION: Vue component for rendering and managing individual blog posts.

LANGUAGE: html
CODE:
<script setup lang="ts">
import { useDeletePost, useUpdatePost } from '~/lib/hooks';

const props = defineProps({
    id: String,
    title: String,
    author: {
        type: Object,
        default: () => ({ email: '' }),
    },
    published: Boolean,
});

const updatePost = useUpdatePost();
const deletePost = useDeletePost();

const onTogglePublish = async () => {
    try {
        await updatePost.mutateAsync({
            where: { id: props.id },
            data: { published: !props.published },
        });
    } catch (err: any) {
        alert(err.info?.message ?? err);
    }
};

const onDelete = async () => {
    try {
        await deletePost.mutateAsync({ where: { id: props.id } });
    } catch (err: any) {
        alert(err.info?.message ?? err);
    }
};
</script>

<template>
    <div class="flex justify-center">
        <div class="min-w-80">
            <span class="mr-4 text-lg font-semibold">{{ title }}</span
            ><span>by {{ author.email }}</span>
        </div>
        <div class="ml-8 space-x-2">
            <NButton @click="onTogglePublish">{{
                published ? 'Unpublish' : 'Publish'
            }}</NButton>
            <NButton @click="onDelete">Delete</NButton>
        </div>
    </div>
</template>

----------------------------------------

TITLE: Using Case-Insensitive Contains Function in ZenStack Policy
DESCRIPTION: This example demonstrates how to use the contains() function with case-insensitive comparison in a policy rule.

LANGUAGE: zmodel
CODE:
@@allow('read', contains(title, 'zenstack', true))

----------------------------------------

TITLE: Using Debug Commands in REPL
DESCRIPTION: Example of using debug commands in the REPL environment to inspect ZenStack queries.

LANGUAGE: javascript
CODE:
.auth { id: 1 }
.debug
db.list.findMany()

----------------------------------------

TITLE: Defining Post Model with Access Policy in ZModel
DESCRIPTION: This snippet defines a Post model in ZModel with an id, title, content, and published fields. It includes an access policy allowing read access only for published posts.

LANGUAGE: zmodel
CODE:
model Post {
  id Int @id @default(autoincrement())
  title String
  content String?
  published Boolean @default(false)

  @@allow('read', published)
}

----------------------------------------

TITLE: Error Message from pnpm Implementation
DESCRIPTION: Error stack trace showing the model metadata loading failure when using pnpm in a monorepo structure.

LANGUAGE: typescript
CODE:
Error: Model meta cannot be loaded
    at getDefaultModelMeta (/Users/jiasheng/branch/typescript_remix/node_modules/.pnpm/@zenstackhq+runtime@1.0.0-alpha.55_@prisma+client@4.11.0/node_modules/@zenstackhq/src/enhancements/model-meta.ts:12:15)
    at withPassword (/Users/jiasheng/branch/typescript_remix/node_modules/.pnpm/@zenstackhq+runtime@1.0.0-alpha.55_@prisma+client@4.11.0/node_modules/@zenstackhq/src/enhancements/password.ts:16:56)
    at withPresets (/Users/jiasheng/branch/typescript_remix/node_modules/.pnpm/@zenstackhq+runtime@1.0.0-alpha.55_@prisma+client@4.11.0/node_modules/@zenstackhq/src/enhancements/preset.ts:25:44)

----------------------------------------

TITLE: Creating SvelteKit Project
DESCRIPTION: Command to create a new SvelteKit project using npm, selecting the Skeleton project template with TypeScript, ESLint, and Prettier.

LANGUAGE: bash
CODE:
npm create svelte@latest my-blog-app

----------------------------------------

TITLE: Disabling ZenStack Telemetry Using Environment Variable
DESCRIPTION: Shows how to disable ZenStack's telemetry collection by setting the DO_NOT_TRACK environment variable to 1. This follows the Console Do Not Track convention for respecting user privacy preferences.

LANGUAGE: bash
CODE:
DO_NOT_TRACK=1 npx zenstack ...

----------------------------------------

TITLE: Implementing Home Page in Nuxt
DESCRIPTION: Creates the main page component for listing and creating blog posts, utilizing the generated hooks for data fetching and mutations.

LANGUAGE: html
CODE:
<script setup lang="ts">
import { useFindManyPost, useCreatePost } from '~/lib/hooks';

const title = ref('');
const createPost = useCreatePost();
const { session } = useAuth();

const onCreatePost = async () => {
    try {
        await createPost.mutateAsync({
            data: {
                author: { connect: { id: session.value!.id } },
                title: title.value,
                content: 'My awesome content',
            },
        });
        title.value = '';
    } catch (err: any) {
        alert(err.info?.message ?? err);
    }
};
const { data: posts } = useFindManyPost({ include: { author: true } });
</script>

<template>
    <h1 class="text-2xl font-bold my-4">My Awesome Blog</h1>
    <div v-if="session?.id">
        <div class="flex justify-center">
            <NTextInput
                v-model="title"
                placeholder="Title"
                class="w-1/2 mr-4"
                @keyup.enter="onCreatePost"
            />
            <NButton @click="onCreatePost">Create Post</NButton>
        </div>
        <ul v-if="posts" class="py-8 space-y-2">
            <li v-for="post in posts" :key="post.id">
                <Post v-bind="post" />
            </li>
        </ul>
    </div>
</template>

----------------------------------------

TITLE: Implementing Soft Delete with Prisma Client Extensions
DESCRIPTION: Demonstrates how to implement soft delete functionality for all models using Client Extensions.

LANGUAGE: typescript
CODE:
const xprisma = prisma.$extends({
    name: 'soft-delete',
    query: {
        $allModels: {
            async findMany({ args, query }) {
                args.where = { deleted: false, ...args };
                return query(args);
            },

            async delete({ model, args }) {
                return (prisma as any)[model].update({
                    ...args,
                    data: { deleted: true },
                });
            },
        },
    },
});

----------------------------------------

TITLE: Defining Post Model with Access Policy in ZModel
DESCRIPTION: This snippet defines a Post model in ZModel with an id, title, content, and published fields. It includes an access policy allowing read access only for published posts.

LANGUAGE: zmodel
CODE:
model Post {
  id Int @id @default(autoincrement())
  title String
  content String?
  published Boolean @default(false)

  @@allow('read', published)
}

----------------------------------------

TITLE: Implementing To-One Relations in ZenStack Policy Rules
DESCRIPTION: Demonstrates how to write policy rules accessing to-one relations using dot notation for field access

LANGUAGE: zmodel
CODE:
model List {
  id Int
  private Boolean
}

model Todo {
  id Int
  list List @relation(...)

  // `list` references a to-one relation
  @@allow('update', !list.private)
}

----------------------------------------

TITLE: Creating SvelteKit Project
DESCRIPTION: Command to create a new SvelteKit project using npm, selecting the Skeleton project template with TypeScript, ESLint, and Prettier.

LANGUAGE: bash
CODE:
npm create svelte@latest my-blog-app

----------------------------------------

TITLE: Using Enhanced PrismaClient with Typed JSON
DESCRIPTION: Example of using the ZenStack-enhanced PrismaClient to work with typed JSON fields.

LANGUAGE: typescript
CODE:
import { enhance } from '@zenstackhq/runtime';

const db = enhance(prisma);
const image = await db.image.findFirstOrThrow();

// image.metadata is now directly typed as { width: number, height: number, format: string }
console.log('Image dimensions:', image.metadata.width, 'by', image.metadata.height);

----------------------------------------

TITLE: Example: Count Query
DESCRIPTION: Example of using generated hooks for counting records with filters

LANGUAGE: tsx
CODE:
const { data } = useCountTodo({ where: { owner: { id: 1 } } });

----------------------------------------

TITLE: Example: Count Query
DESCRIPTION: Example of using generated hooks for counting records with filters

LANGUAGE: tsx
CODE:
const { data } = useCountTodo({ where: { owner: { id: 1 } } });

----------------------------------------

TITLE: Querying User with Omitted Password in JavaScript REPL
DESCRIPTION: This JavaScript snippet shows how to query a user after applying the @omit attribute, demonstrating that the password field is excluded from the result.

LANGUAGE: javascript
CODE:
.auth { id: 1 }
db.user.findFirst();

----------------------------------------

TITLE: Implementing Query-Level Overrides with Extended Prisma Client in TypeScript
DESCRIPTION: This snippet shows how to implement query-level overrides using Prisma Client Extensions. It overrides the 'findMany' method for the 'post' model to log query arguments before executing the query.

LANGUAGE: typescript
CODE:
const extendedPrisma = prisma.$extends({
  query: {
    post: {
      findMany({ query, args }) {
        console.log('Query args:', inspect(args, { depth: null }));
        return query(args);
      },
    },
  },
});

const enhanced = enhance(extendedPrisma);
const posts = await enhanced.post.findMany();

----------------------------------------

TITLE: Updating Records with Prisma Client - Post v4.5.0
DESCRIPTION: Example showing how to update a record with version increment using Prisma Client after version 4.5.0, demonstrating optimistic concurrency control.

LANGUAGE: tsx
CODE:
    await client.seat.update({
        data: {
            userId: userId,
            version: {
                increment: 1,
            },
        },
        where: {
            id: availableSeat.id,
        },
    });

----------------------------------------

TITLE: Using withPolicy Function with Prisma Client in TypeScript
DESCRIPTION: Example of using the withPolicy function to create an enhanced Prisma client with access policies. It filters posts based on the current user's permissions.

LANGUAGE: typescript
CODE:
const session = getSession();
const enhanced = withPolicy(prisma, { user: session.user });
// only posts belonging to the current user are returned
const posts = enhanced.post.findMany();

----------------------------------------

TITLE: Adding Custom Method to Prisma User Model
DESCRIPTION: Demonstrates how to add a custom 'signUp' method to the User model using Prisma Client Extensions.

LANGUAGE: typescript
CODE:
const xprisma = prisma.$extends({
    model: {
        user: {
            async signUp(email: string) {
                return prisma.user.create({ data: { email } });
            },
        },
    },
});

const user = await xprisma.user.signUp('john@prisma.io');

----------------------------------------

TITLE: Running Database Seed Command
DESCRIPTION: Command to execute the Prisma database seed script.

LANGUAGE: bash
CODE:
npx prisma db seed

----------------------------------------

TITLE: Setting up Next.js API Endpoint Handler
DESCRIPTION: Implementation of a Next.js API endpoint that uses an enhanced Prisma client to enforce access policies

LANGUAGE: typescript
CODE:
const prisma = new PrismaClient();

export default requestHandler({
    getPrisma: async (req, res) => {
        const user = await getSessionUser(req, res);
        return enhance(prisma, { user });
    },
});

----------------------------------------

TITLE: Generating ZenStack Artifacts
DESCRIPTION: Command to generate ZenStack artifacts, including Prisma schema and client.

LANGUAGE: bash
CODE:
npx zenstack generate

----------------------------------------

TITLE: Initializing ZenStack in Nuxt Project
DESCRIPTION: Runs the ZenStack CLI to prepare the Nuxt project for using ZenStack, including installing Prisma dependencies.

LANGUAGE: bash
CODE:
npx zenstack@1 init

----------------------------------------

TITLE: Working Extension Pattern After Enhancement
DESCRIPTION: Corrected example showing how to properly reference enhanced client within extensions

LANGUAGE: typescript
CODE:
const enhanced = enhance(prisma);
const db = enhanced.$extends({
  model: {
    post: {
      async getFeeds() {
          return enhanced.post.findMany();
      },
    },
  },
});

const feeds = await db.post.getFeeds();

----------------------------------------

TITLE: Example: Nested Create Mutation
DESCRIPTION: Example of using generated hooks for nested data creation

LANGUAGE: tsx
CODE:
const { mutate } = useCreateList();

function onCreateList() {
  mutate({
    data: { 
      title: 'My List',
      todos: {
        create: [
          { name: 'Todo 1' },
          { name: 'Todo 2' }
        ]
      }
    }
  })
}

----------------------------------------

TITLE: Example: Nested Create Mutation
DESCRIPTION: Example of using generated hooks for nested data creation

LANGUAGE: tsx
CODE:
const { mutate } = useCreateList();

function onCreateList() {
  mutate({
    data: { 
      title: 'My List',
      todos: {
        create: [
          { name: 'Todo 1' },
          { name: 'Todo 2' }
        ]
      }
    }
  })
}

----------------------------------------

TITLE: Querying Posts with Prisma ORM in TypeScript
DESCRIPTION: This code snippet shows how to query posts readable by the current user using Prisma ORM. It demonstrates Prisma's graph-like query syntax for traversing relationships and applying complex filtering conditions.

LANGUAGE: typescript
CODE:
prisma.post.findMany({
    include: { author: true },
    where: {
        spaceId: space.id,
        OR: [
            // 1. published and current user is a member of the space
            {
                published: true,
                space: { members: { some: { userId: req.uid! } } },
            },            
            // 2. authored by the current user
            { authorId: req.uid! },
            // 3. belongs to space owned by the current user
            { space: { ownerId: req.uid! } },
            // 4. belongs to space where the current user is an admin
            { 
                space: {
                    members: {
                        some: {
                            userId: req.uid!,
                            role: 'ADMIN' 
                        }
                    }
                }
            }
        ]
    }
});

----------------------------------------

TITLE: Implementing Custom Attributes with Comments in Prisma
DESCRIPTION: This snippet demonstrates how to use triple slash comments to add custom attributes in a Prisma schema, specifically for zod-prisma and prisma-nestjs-graphql.

LANGUAGE: prisma
CODE:
model Post {
  id String @id @default(uuid()) /// @zod.uuid()
  /// @zod.max(255, { message: "The title must be shorter than 256 characters" })
  title String
  contents String /// @zod.max(10240)
}

model User {
    id String @id @default(cuid())
    /// @HideField()
    password String
    /// @HideField({ output: true, input: true })
    secret String
    /// @HideField({ match: '@(User|Comment)Create*Input' })
    createdAt DateTime @default(now())
}

----------------------------------------

TITLE: Base Schema File Definition
DESCRIPTION: Example of a separate base schema file (base.zmodel) containing abstract model definition with common fields and access rules.

LANGUAGE: tsx
CODE:
abstract model Base {
    id Int @id @default(autoincrement())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt()
    published Boolean @default(true)

    // author has full access
    @@allow('all', auth() != null && published)
}

----------------------------------------

TITLE: Implementing ZenStack with Cloudflare Workers
DESCRIPTION: This code demonstrates how to use ZenStack-enhanced PrismaClient in Cloudflare Workers. It shows configuration for a Neon database and includes important imports from the edge-specific runtime package.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client';
import { PrismaNeon } from '@prisma/adapter-neon';
import { Pool } from '@neondatabase/serverless';
import { enhance } from '@zenstackhq/runtime/edge';
import { getSessionUser } from './auth';

export default {
  async fetch(request: Request, env: Env, ctx: ExecutionContext): Promise<Response> {
    const neon = new Pool({ connectionString: env.DATABASE_URL });
    const adapter = new PrismaNeon(neon);
    const prisma = new PrismaClient({ adapter });
    const db = enhance(prisma, { user: getSessionUser(request) });
    const posts = await db.post.findMany();  
    return Response.json(posts);
  }
};

----------------------------------------

TITLE: Configuring TanStack Query Plugin
DESCRIPTION: Sets up a Nuxt plugin to enable TanStack Query for data fetching and state management.

LANGUAGE: typescript
CODE:
import { VueQueryPlugin, QueryClient } from '@tanstack/vue-query';

export default defineNuxtPlugin((nuxt) => {
    const queryClient = new QueryClient();
    nuxt.vueApp.use(VueQueryPlugin, { queryClient });
});

----------------------------------------

TITLE: Base Schema File Definition
DESCRIPTION: Example of a separate base schema file (base.zmodel) containing abstract model definition with common fields and access rules.

LANGUAGE: tsx
CODE:
abstract model Base {
    id Int @id @default(autoincrement())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt()
    published Boolean @default(true)

    // author has full access
    @@allow('all', auth() != null && published)
}

----------------------------------------

TITLE: Querying Posts with ZenStack in TypeScript
DESCRIPTION: This code snippet shows how to query posts using ZenStack, which simplifies the query by enforcing access policies defined in the schema. It demonstrates a more straightforward query structure compared to raw Prisma or Drizzle queries.

LANGUAGE: typescript
CODE:
db.post.findMany({
    include: { author: true },
    where: {
        space: { slug: req.params.slug },
    },
});

----------------------------------------

TITLE: Basic JSON Field Definition in Prisma
DESCRIPTION: Basic example showing how to define a JSON field in a Prisma model without type safety.

LANGUAGE: zmodel
CODE:
model Image {
  id Int @id @default(autoincrement())
  metadata Json
}

----------------------------------------

TITLE: Demonstrating ZenStack Query Key Structure
DESCRIPTION: Shows the structure of ZenStack's query key tuple used for cache management, including model, operation, args, and flags.

LANGUAGE: typescript
CODE:
['zenstack', model, operation, args, flags]

----------------------------------------

TITLE: User Model with Omitted Password Field
DESCRIPTION: Enhanced user model showing how to omit sensitive password field from query results using @omit attribute.

LANGUAGE: zmodel
CODE:
model User {
    ...
    password String? @password @omit
}

----------------------------------------

TITLE: Using Generated TanStack Query Hooks in React Component
DESCRIPTION: Example of using ZenStack-generated TanStack Query hooks in a React component to fetch and display todos with their owners.

LANGUAGE: typescript
CODE:
// get a published todos with their owners, and bind the result to UI
const Todos = () => {
  // `todos` is typed as `(Todo & { owner: User })[]`
  const { data: todos } = useFindManyTodo({
    where: { published: true },
    include: { owner: true }
  });
  
  return (<ul>
    { todos.map((todo) => (
  	    <li key={todo.id}>{todo.title} by {todo.owner.name}</li> 
  	  )) }
  </ul>);
}

// create a todo
const { mutate: create } = useCreateTodo();
function onCreate() {
  create({ 
    data: { 
      title: 'Get things done',
      owner: { connect: { id: userId } } 
    }
  });
}

----------------------------------------

TITLE: Defining Database Schema with Prisma ORM
DESCRIPTION: This code snippet shows how to define the same database schema using Prisma ORM. It includes models for User, Space, SpaceUser, and Post, along with their relationships and enums.

LANGUAGE: prisma
CODE:
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id              Int         @id @default(autoincrement())
  email           String      @unique
  posts           Post[]
  spaceMembership SpaceUser[]
  ownedSpaces     Space[]
}

model Space {
  id      Int         @id @default(autoincrement())
  owner   User        @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  ownerId Int
  name    String
  slug    String      @unique
  posts   Post[]
  members SpaceUser[]
}

enum SpaceUserRole {
  MEMBER
  ADMIN
}

model SpaceUser {
  id      Int           @id @default(autoincrement())
  space   Space         @relation(fields: [spaceId], references: [id], onDelete: Cascade)
  spaceId Int
  user    User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId  Int
  role    SpaceUserRole @default(MEMBER)

  @@unique([spaceId, userId])
}

model Post {
  id        Int     @id @default(autoincrement())
  title     String
  published Boolean @default(false)
  author    User?   @relation(fields: [authorId], references: [id], onDelete: Cascade)
  authorId  Int?
  space     Space?  @relation(fields: [spaceId], references: [id], onDelete: Cascade)
  spaceId   Int?
}

----------------------------------------

TITLE: Preventing Owner Modification in ZenStack List Model
DESCRIPTION: This snippet demonstrates how to use a post-update rule to prevent the modification of the owner field in a List model.

LANGUAGE: zmodel
CODE:
model List {
    ...

    @@deny('update', future().owner != owner)
}

----------------------------------------

TITLE: Creating a Simple Stored Procedure in PostgreSQL
DESCRIPTION: Shows how to create a basic stored procedure in PostgreSQL that adds two integers, which can then be exposed as an API endpoint by PostgREST.

LANGUAGE: sql
CODE:
; A stored procedure to add two integers

CREATE FUNCTION add_them(a integer, b integer)
RETURNS integer AS $$
  SELECT a + b;
$$ LANGUAGE SQL IMMUTABLE;

----------------------------------------

TITLE: Initializing ZenStack for Access Control
DESCRIPTION: Command to initialize ZenStack in the project for handling access control policies.

LANGUAGE: bash
CODE:
npx zenstack@latest init

----------------------------------------

TITLE: Creating PrismaClient Instance
DESCRIPTION: Creates and exports a PrismaClient instance for database operations.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client';
export const prisma = new PrismaClient();

----------------------------------------

TITLE: Implementing Role-Based Access Control in RedwoodJS Service
DESCRIPTION: This JavaScript code demonstrates how to implement role-based access control in a RedwoodJS service function for deleting comments, using the requireAuth helper to restrict access to users with the 'moderator' role.

LANGUAGE: javascript
CODE:
export const deleteComment = ({ id }) => {
  requireAuth({ roles: 'moderator' })
  return db.comment.delete({
    where: { id },
  });
}

----------------------------------------

TITLE: Testing Database Exposure via Supabase API in Bash
DESCRIPTION: This Bash command sends an HTTP request to the Supabase API to test if the database is exposed to direct requests. It uses curl to query a specific table and includes the necessary headers for authentication.

LANGUAGE: bash
CODE:
curl '{SUPABASE_PROJECT_URL}/rest/v1/{DATABASE_TABLE}?select=*' \
-H "apikey: SUPABASE_ANON_KEY" \
-H "Authorization: Bearer SUPABASE_ANON_KEY"

----------------------------------------

TITLE: Training ML Model with PostgresML
DESCRIPTION: Demonstrates how to load data, train a classifier, and make predictions using PostgresML for handwritten digit recognition.

LANGUAGE: sql
CODE:
SELECT * FROM pgml.load_dataset('digits');

LANGUAGE: sql
CODE:
SELECT * FROM pgml.train(
    'Handwritten Digit Image Classifier',
    algorithm => 'xgboost',
    'classification',
    'pgml.digits',
    'target'
);

LANGUAGE: sql
CODE:
SELECT
    target,
    pgml.predict('Handwritten Digit Image Classifier', image) AS prediction
FROM pgml.digits 
LIMIT 10;

----------------------------------------

TITLE: Installing tRPC Plugin
DESCRIPTION: Command to install the ZenStack tRPC plugin package

LANGUAGE: bash
CODE:
npm install -D @zenstackhq/trpc@latest

----------------------------------------

TITLE: Using Enhanced Prisma Client in RedwoodJS Services
DESCRIPTION: These JavaScript code snippets demonstrate how to use the enhanced Prisma Client in RedwoodJS service functions. The authDb() helper is used to create a client instance that enforces access policies for each request.

LANGUAGE: javascript
CODE:
export const posts = () => {
  return authDb().post.findMany();
}

export const comments = ({ postId }) => {
  return authDb.comment.findMany();
}

export const createComment = ({ input }) => {
  return authDb().comment.create({
    data: input,
  });
}

----------------------------------------

TITLE: Implementing Row-Level Security in PostgreSQL
DESCRIPTION: Demonstrates how to implement chat message security using PostgreSQL's row-level security features. The code creates a chat table and defines policies to ensure users can only see and modify their own messages.

LANGUAGE: sql
CODE:
CREATE TABLE chat (
    message_uuid    UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    message_from    NAME      NOT NULL DEFAULT current_user,
    message_to      NAME      NOT NULL,
    message_subject VARCHAR(64) NOT NULL,
);

CREATE POLICY chat_policy ON chat
    USING ((message_to = current_user) OR (message_from = current_user))
    WITH CHECK (message_from = current_user)

----------------------------------------

TITLE: Illustrating Comment Generation in GitHub Copilot
DESCRIPTION: An image showcasing GitHub Copilot's ability to generate contextually appropriate code comments and continue existing comment threads.

LANGUAGE: markdown
CODE:
![Comments generation](comment-gen.png)

----------------------------------------

TITLE: Installing ZenStack Server Package
DESCRIPTION: Command to install the required ZenStack server package using npm.

LANGUAGE: bash
CODE:
npm install @zenstackhq/server

----------------------------------------

TITLE: Installing ZenStack CLI Package
DESCRIPTION: Install the ZenStack CLI package as a development dependency using npm.

LANGUAGE: bash
CODE:
npm install --save-dev zenstack@1

----------------------------------------

TITLE: Generating ZenStack Artifacts
DESCRIPTION: Shows how to generate Prisma schema and other artifacts using the ZenStack CLI, with examples for default and custom schema locations.

LANGUAGE: bash
CODE:
npx zenstack generate

LANGUAGE: bash
CODE:
npx zenstack generate --schema src/my.zmodel

----------------------------------------

TITLE: Optimizing Todo Model Access Policy with check() Function
DESCRIPTION: Simplified access policy implementation using the check() attribute function to delegate authorization decisions to the parent List model, reducing code duplication.

LANGUAGE: zmodel
CODE:
model Todo {
    ...

    // full access if the parent list is readable
    @@allow('all', check(list, 'read'))
}

----------------------------------------

TITLE: Example of Supabase API Request in Bash
DESCRIPTION: This is a concrete example of the Supabase API request using curl. It demonstrates how to structure the URL and headers with actual values, querying the 'User' table.

LANGUAGE: bash
CODE:
curl 'https://jypbzsozorjnogibmfhu.supabase.co/rest/v1/User?select=*' \
-H "apikey: eyOiJIUzJhbGciI1..." \
-H "Authorization: Bearer eyOiJIUzJhbGciI1..."

----------------------------------------

TITLE: Installing ZenStack Server Package
DESCRIPTION: Command to install the ZenStack server package using npm.

LANGUAGE: bash
CODE:
npm install @zenstackhq/server

----------------------------------------

TITLE: Installing ZenStack Server Package
DESCRIPTION: Command to install the ZenStack server package using npm.

LANGUAGE: bash
CODE:
npm install @zenstackhq/server

----------------------------------------

TITLE: Posts Page Component Implementation
DESCRIPTION: React component for displaying and managing blog posts with authentication and routing

LANGUAGE: tsx
CODE:
export default function PostsPage() {
    const data = useLoaderData<typeof loader>();
    const user = useUser();

    return (
        <div className="flex h-full min-h-screen flex-col">
            <header className="flex items-center justify-between bg-slate-800 p-4 text-white">
                <h1 className="text-3xl font-bold">
                    <Link to=".">Posts</Link>
                </h1>
                <p>{user.email}</p>
                <Form action="/logout" method="post">
                    <button type="submit" className="rounded bg-slate-600 py-2 px-4 text-blue-100 hover:bg-blue-500 active:bg-blue-600">
                        Logout
                    </button>
                </Form>
            </header>
            <!-- Rest of the component implementation -->
        </div>
    );
}

----------------------------------------

TITLE: Creating Enhanced Prisma Client with ZenStack in RedwoodJS
DESCRIPTION: This JavaScript code defines a helper function to create an enhanced Prisma Client instance using ZenStack's runtime API. The enhanced client applies access policies based on the current user's context.

LANGUAGE: javascript
CODE:
import { enhance } from '@zenstackhq/runtime';

/*
 * Returns ZenStack wrapped Prisma Client with access policies enabled.
 */
export function authDb() {
  return enhance(db, { user: context.currentUser });
}

----------------------------------------

TITLE: Creating Express.js Server Entry Point
DESCRIPTION: Basic Express.js server setup in TypeScript, including JSON body parser and a simple 'Hello World' route.

LANGUAGE: typescript
CODE:
import express from 'express';

const app = express();

// enable JSON body parser
app.use(express.json());

app.get('/', (req, res) => {
    res.send('Hello World!');
});

app.listen(3000, () => console.log('🚀 Server ready at: http://localhost:3000'));

----------------------------------------

TITLE: NextAuth Configuration with Credentials Provider
DESCRIPTION: Configuration for NextAuth.js using credentials-based authentication with password hashing.

LANGUAGE: typescript
CODE:
import { PrismaAdapter } from '@next-auth/prisma-adapter';
import type { PrismaClient } from '@prisma/client';
import { compare } from 'bcryptjs';
import type { GetServerSidePropsContext } from 'next';
import NextAuth, { getServerSession, type DefaultSession, type NextAuthOptions } from 'next-auth';
import CredentialsProvider from 'next-auth/providers/credentials';
import { db } from './db';

// ... rest of the auth configuration code

----------------------------------------

TITLE: Error Response Format for RPC API Handler
DESCRIPTION: Defines the structure of error responses from the RPC API Handler. It includes fields for indicating Prisma errors, policy violations, error codes, messages, and additional reasons for failures.

LANGUAGE: typescript
CODE:
{
    // true to indicate the failure is due to a Prisma error
    prisma?: boolean;

    // true to indicate the failure is due to access policy violation
    rejectedByPolicy?: boolean;

    // original Prisma error code, available when `prisma` is true
    code?: string;

    // error message
    message: string;

    // extra reason about why a failure happened (e.g., 'RESULT_NOT_READABLE' indicates
    // a mutation succeeded but the result cannot be read back due to access policy)
    reason?: string;
}

----------------------------------------

TITLE: Permission Denied Response Example
DESCRIPTION: Example JSON response when database access is properly secured.

LANGUAGE: json
CODE:
{
   "code": "42501",
   "details": null,
   "hint": null,
   "message": "permission denied for table User"
}

----------------------------------------

TITLE: Using Polymorphic TypeScript Types in ZenStack
DESCRIPTION: This snippet shows how to use polymorphic TypeScript types generated by ZenStack, which provide a more accurate representation of the polymorphic model structure.

LANGUAGE: typescript
CODE:
import type { Prisma } from '@zenstackhq/runtime/models';

const where: Prisma.PostWhereInput = {}
console.log(where.published); // `PostWhereInput` has the `published` field

----------------------------------------

TITLE: Filtered Prisma Pulse Stream in TypeScript
DESCRIPTION: Shows how to apply filters to the stream() API to receive only specific events matching certain conditions.

LANGUAGE: typescript
CODE:
const stream = await prisma.user.stream({
  create: {
    name: { not: null },
  },
});

----------------------------------------

TITLE: Configuring Netlify Deployment
DESCRIPTION: TOML configuration for including ZenStack files in Netlify deployment

LANGUAGE: toml
CODE:
[functions]
  included_files = ["node_modules/.zenstack/*"]

----------------------------------------

TITLE: Implementing Server Hook for Authentication
DESCRIPTION: Server-side hook to handle authentication, decode JWT tokens, and enhance Prisma client with access policies.

LANGUAGE: typescript
CODE:
import { env } from '$env/dynamic/private';
import { JWT_TOKEN_COOKIE_NAME } from '$lib/auth';
import { prisma } from '$lib/db';
import type { Handle } from '@sveltejs/kit';
import { enhance } from '@zenstackhq/runtime';
import jwt from 'jsonwebtoken';

const auth = (async ({ event, resolve }) => {
    const token = event.cookies.get(JWT_TOKEN_COOKIE_NAME);
    if (token) {
        try {
            const decoded = jwt.verify(token, env.JWT_SECRET);
            const user = await prisma.user.findUnique({
                where: { id: decoded.sub as string }
            });
            if (user) {
                event.locals.user = user;
            } else {
                console.warn('User not found:', decoded.sub);
                event.cookies.delete(JWT_TOKEN_COOKIE_NAME, { path: '/' });
            }
        } catch {
            event.cookies.delete(JWT_TOKEN_COOKIE_NAME, { path: '/' });
        }
    }

    // create an enhanced PrismaClient that recognizes access policies
    event.locals.db = enhance(prisma, {
        user: event.locals.user ? { id: event.locals.user.id } : undefined
    });

    return resolve(event);
}) satisfies Handle;

export const handle = auth;

----------------------------------------

TITLE: Implementing RPC API Handler in Nuxt
DESCRIPTION: Configuration for setting up the RPC API handler in a Nuxt application.

LANGUAGE: typescript
CODE:
import { createEventHandler } from '@zenstackhq/server/nuxt';
import { RPCApiHandler } from '@zenstackhq/server/api';
import { getPrisma } from './lib/db';

export default createEventHandler({
    handler: RPCApiHandler(), // you can also omit it since `RPCApiHandler` is the default
    getPrisma
});

----------------------------------------

TITLE: Initializing tRPC Router
DESCRIPTION: Example of creating and exporting a tRPC router using the generated CRUD router

LANGUAGE: typescript
CODE:
import { createRouter as createCRUDRouter } from './generated/routers';
import { initTRPC } from '@trpc/server';
import { type Context } from '../context';

const t = initTRPC.context<Context>().create();

export const appRouter = createCRUDRouter(t.router, t.procedure);
export type AppRouter = typeof appRouter;

----------------------------------------

TITLE: Implementing RPC with tRPC
DESCRIPTION: Demonstrates setting up type-safe RPC endpoints using tRPC, including server router configuration and client-side usage.

LANGUAGE: ts
CODE:
const appRouter = router({
  user: {
    // list users
    list: publicProcedure.query(() => db.user.findMany()),

    // create a user
    create: publicProcedure
      .input(z.object({ name: z.string() }))
      .mutation(async ({ input }) => db.user.create(input))
  },
});

// Export type router type signature, this is used by the client.
export type AppRouter = typeof appRouter;

const server = createHTTPServer({
  router: appRouter,
});

server.listen(3000);

LANGUAGE: ts
CODE:
const trpc = createTRPCClient<AppRouter>({
  links: [
    httpBatchLink({
      url: 'http://localhost:3000',
    }),
  ],
});

const users = await trpc.user.list.query();
console.log('Users:', users);

const createdUser = await trpc.user.create.mutate({ name: 'trpc lover' });
console.log('Created user:', createdUser);

----------------------------------------

TITLE: Installing @zenstackhq/swr Plugin
DESCRIPTION: Command to install the @zenstackhq/swr plugin using npm.

LANGUAGE: bash
CODE:
npm install @zenstackhq/swr

----------------------------------------

TITLE: Conditional BCrypt Hash Function Selection
DESCRIPTION: Runtime detection code to choose appropriate bcryptjs hash function based on environment.

LANGUAGE: typescript
CODE:
const hashFunc = typeof EdgeRuntime === 'string' 
    ? require('bcryptjs').hashSync 
    : require('bcryptjs').hash;

----------------------------------------

TITLE: Configuring ZenStackHooksProvider in React
DESCRIPTION: Example of setting up the ZenStackHooksProvider context in a React application, including a custom fetch function for adding headers.

LANGUAGE: typescript
CODE:
import { FetchFn, Provider as ZenStackHooksProvider } from '../lib/hooks';

// custom fetch function that adds a custom header
const myFetch: FetchFn = (url, options) => {
    options = options ?? {};
    options.headers = {
        ...options.headers,
        'x-my-custom-header': 'hello world',
    };
    return fetch(url, options);
};

function MyApp({ Component, pageProps: { session, ...pageProps } }: AppProps) {
    return (
        <ZenStackHooksProvider value={{ endpoint: '/api/model', fetch: myFetch }}>
            <AppContent />
        </ZenStackHooksProvider>
    );
}

----------------------------------------

TITLE: Enabling OpenAPI Generation with ZenStack
DESCRIPTION: Configuring ZenStack to generate OpenAPI specification for the RESTful API.

LANGUAGE: zmodel
CODE:
plugin openapi {
  provider = '@zenstackhq/openapi'
  flavor = 'rest'
  output = 'openapi.yaml'
}

----------------------------------------

TITLE: String Manipulation in ZenStack Policy
DESCRIPTION: Shows how to use the contains() function for string manipulation in a ZenStack policy rule, with an option for case-insensitive comparison.

LANGUAGE: zmodel
CODE:
model Post {
    id Int @id
    title String
    @@allow('read', contains(title, 'zenstack'))
}

@@allow('read', contains(title, 'zenstack', true))

----------------------------------------

TITLE: Error Response Format
DESCRIPTION: Structure of error responses returned by the API endpoints.

LANGUAGE: typescript
CODE:
{
    prisma?: boolean;
    rejectedByPolicy?: boolean;
    code?: string;
    message: string;
    reason?: string;
}

----------------------------------------

TITLE: Using Query and Mutation Hooks in React
DESCRIPTION: Example of using ZenStack-generated query and mutation hooks in a React component.

LANGUAGE: tsx
CODE:
import { useFindManyPost, useCreatePost } from '../lib/hooks';

// post list component
const Posts = ({ userId }: { userId: string }) => {
    const create = useCreatePost();

    // list all posts that're visible to the current user, together with their authors
    const { data: posts } = useFindManyPost({
        include: { author: true },
        orderBy: { createdAt: 'desc' },
    });

    async function onCreatePost() {
        create.mutate({
            data: {
                title: 'My awesome post',
                authorId: userId,
            },
        });
    }

    return (
        <>
            <button onClick={onCreatePost}>Create</button>
            <ul>
                {posts?.map((post) => (
                    <li key={post.id}>
                        {post.title} by {post.author.email}
                    </li>
                ))}
            </ul>
        </>
    );
};

----------------------------------------

TITLE: Checking Read Permission for Unpublished Posts (Authenticated User) in TypeScript
DESCRIPTION: This code demonstrates how to use the 'check' API to verify if an authenticated user (user#1) can read unpublished posts.

LANGUAGE: typescript
CODE:
const db = enhance(prisma, { user: { id: 1 } }); // enhance with user context
await canRead = await db.post.check({ operation: 'read', where: { published: false } });

----------------------------------------

TITLE: Checking Read Permission for Unpublished Posts (Authenticated User) in TypeScript
DESCRIPTION: This code demonstrates how to use the 'check' API to verify if an authenticated user (user#1) can read unpublished posts.

LANGUAGE: typescript
CODE:
const db = enhance(prisma, { user: { id: 1 } }); // enhance with user context
await canRead = await db.post.check({ operation: 'read', where: { published: false } });

----------------------------------------

TITLE: Model-Level Validation in ZModel
DESCRIPTION: Demonstrates model-level validation using @@validate attribute to enforce rules across multiple fields.

LANGUAGE: zmodel
CODE:
model User {
    id String @id
    email String? @unique
    activated Boolean @default(false)
    @@validate(!activated || email != null, "activated user must have an email")
}

----------------------------------------

TITLE: Defining a Post Model with Validation in ZModel
DESCRIPTION: Example of a Post model definition in ZModel with field validation attributes and a model-level validation rule.

LANGUAGE: zmodel
CODE:
model Post {
  id Int @id @default(autoincrement())
  title String @length(10, 255)
  published Boolean @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  author User @relation(fields: [authorId], references: [id])
  authorId Int

  @@validate(regex(title, "^[A-Za-z0-9 ]+$"))
}

----------------------------------------

TITLE: Soft Deleting a Post in ZenStack
DESCRIPTION: This curl command shows how to perform a soft delete operation on a post by updating its isDeleted field to true, demonstrating ZenStack's soft delete functionality.

LANGUAGE: bash
CODE:
curl -X PUT \
-H "X-USER-ID: robin@prisma.io" -H "Content-Type: application/json" \
-d '{"data":{ "type":"post", "attributes":{  "isDeleted": true } } }'\
localhost:3000/api/post/slack

----------------------------------------

TITLE: Seeding Sample Data in ZenStack Project
DESCRIPTION: This command is used to seed sample data into the ZenStack project for testing and demonstration purposes.

LANGUAGE: bash
CODE:
npm run seed

----------------------------------------

TITLE: Prisma Schema with Triple Slash Comment Hack
DESCRIPTION: Example of using triple slash comments in Prisma schema to add custom metadata for generators like TypeGraphQL. This approach is preserved when migrating to ZenStack.

LANGUAGE: zmodel
CODE:
model User {
  id Int @default(autoincrement()) @id
  email String  @unique
  /// @TypeGraphQL.omit(output: true, input: true)
  password String
  posts Post[]
}

----------------------------------------

TITLE: Example API Response Format
DESCRIPTION: Structure of the API response data format for a findMany query.

LANGUAGE: json
CODE:
{
    "data": [ { "id": 1, "title": "Hello World" } ]
}

----------------------------------------

TITLE: Basic ZenStack Plugin Structure in TypeScript
DESCRIPTION: Demonstrates the minimum required structure for a ZenStack plugin, including required exports and function signature.

LANGUAGE: typescript
CODE:
import type { PluginOptions } from '@zenstackhq/sdk';
import type { DMMF } from '@zenstackhq/sdk/prisma';
import type { Model } from '@zenstackhq/sdk/ast';

export const name = 'My Plugin';

export default async function run(model: Model, options: PluginOptions, dmmf: DMMF.Document) {
    ...
}

----------------------------------------

TITLE: Defining Field-Level Policy for Post Model in ZenStack
DESCRIPTION: This snippet demonstrates how to define a field-level policy for the 'published' field in a Post model, allowing only users with the EDITOR role to update it.

LANGUAGE: zmodel
CODE:
model Post {
    ...
    published Boolean @allow('update', auth().role == EDITOR)
}

----------------------------------------

TITLE: Testing Invalid Email Validation
DESCRIPTION: JavaScript example showing validation error when creating a user with invalid email.

LANGUAGE: javascript
CODE:
db.user.create({ data: { email: 'xyz.abc' } })

----------------------------------------

TITLE: Example API Response Format
DESCRIPTION: Structure of the API response data format for a findMany query.

LANGUAGE: json
CODE:
{
    "data": [ { "id": 1, "title": "Hello World" } ]
}

----------------------------------------

TITLE: Configuring @core/prisma Plugin in ZModel
DESCRIPTION: Example configuration for the @core/prisma plugin in a ZModel schema file. Sets custom output path and enables formatting of the generated Prisma schema.

LANGUAGE: zmodel
CODE:
plugin prisma {
    provider = '@core/prisma'
    output = './src/prisma/schema.prisma'
    format = true
}

----------------------------------------

TITLE: Defining Basic Prisma Relations in ZModel
DESCRIPTION: This snippet demonstrates how to define basic relations between User and Post models using ZModel syntax.

LANGUAGE: zmodel
CODE:
model User {
  id Int @id @default(autoincrement())
  posts Post[]
}

model Post {
  id Int @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  title String
  owner User @relation(fields: [ownerId], references: [id])
  ownerId Int
}

----------------------------------------

TITLE: Initializing RESTful API Handler for Nuxt
DESCRIPTION: Sets up the RESTful API handler for a Nuxt application in the server API file.

LANGUAGE: typescript
CODE:
import { createEventHandler } from '@zenstackhq/server/nuxt';
import { RestApiHandler } from '@zenstackhq/server/api';
import { getPrisma } from './lib/db';

export default createEventHandler({
    handler: RestApiHandler({ endpoint: 'http://myhost/api/model' })
    getPrisma
});

----------------------------------------

TITLE: Configuring @core/model-meta Plugin in ZModel
DESCRIPTION: Example of how to configure the @core/model-meta plugin in a ZModel schema file. This snippet shows how to set custom output directory and disable compilation.

LANGUAGE: zmodel
CODE:
plugin meta {
  provider = '@core/model-meta'
  output = 'src/lib/zenstack'
  compile = false
}

----------------------------------------

TITLE: Using HasEvery Function with Array in ZenStack Policy
DESCRIPTION: This snippet demonstrates the use of the hasEvery() function to check if an array field contains all specified values in a policy rule.

LANGUAGE: zmodel
CODE:
model Post {
    id Int @id
    tags String[]
    @@allow('read', has(tags, ['zenstack', 'prisma']))
}

----------------------------------------

TITLE: Creating a New List with Joey's Authentication in ZenStack REPL
DESCRIPTION: This JavaScript code snippet shows how to create a new List entity using Joey's authentication in the ZenStack REPL.

LANGUAGE: js
CODE:
.auth { id: 1 }
db.list.create({ data: { title: "Joey' List", private: true, owner: { connect: { id: 1 } }, space: { connect: { id: 1 } } } })

----------------------------------------

TITLE: Creating Enhanced Prisma Client with Auth Context
DESCRIPTION: Setup for creating an enhanced Prisma client that automatically handles access policies and validation rules based on the authenticated user.

LANGUAGE: typescript
CODE:
import type { NextApiRequest, NextApiResponse } from 'next';
import { getServerSession } from 'next-auth';
import { enhance } from '@zenstackhq/runtime';
import { authOptions } from '../../pages/api/auth/[...nextauth]';
import { prisma } from '../../../server/db/client';

async function getPrisma(req: NextApiRequest, res: NextApiResponse) {
    const session = await getServerSession(req, res, authOptions);
    // create a wrapper of Prisma client that enforces access policy,
    // data validation, and @password, @omit behaviors
    return enhance(prisma, { user: session?.user });
}

----------------------------------------

TITLE: Implementing Booking List Page
DESCRIPTION: React component for displaying the list of bookings with loader function for data fetching

LANGUAGE: tsx
CODE:
export async function loader({ request }: LoaderArgs) {
    const userId = await requireUserId(request);
    const bookings = await getBookingItems({ userId });
    return json({ bookings });
}

----------------------------------------

TITLE: Creating a New List with Joey's Authentication in ZenStack REPL
DESCRIPTION: This JavaScript code snippet shows how to create a new List entity using Joey's authentication in the ZenStack REPL.

LANGUAGE: js
CODE:
.auth { id: 1 }
db.list.create({ data: { title: "Joey' List", private: true, owner: { connect: { id: 1 } }, space: { connect: { id: 1 } } } })

----------------------------------------

TITLE: Non-Working Extension Pattern
DESCRIPTION: Example demonstrating incorrect way of applying extensions to an enhanced client

LANGUAGE: typescript
CODE:
const enhanced = enhance(prisma);
const db = enhanced.$extends({
  model: {
    post: {
      async getFeeds() {
          const context = Prisma.getExtensionContext(this);
          return context.findMany();
      },
    },
  },
});

const feeds = await db.post.getFeeds();

----------------------------------------

TITLE: Generated PostCreateScalarSchema Zod Definition
DESCRIPTION: Example of a generated Zod schema for validating the input for creating a Post model, including only scalar fields.

LANGUAGE: typescript
CODE:
const PostCreateScalarSchema = z.object({
  id: z.number().optional(),
  title: z.string().min(10).max(255),
  published: z.boolean().optional(),
  createdAt: z.date().optional(),
  updatedAt: z.date().optional(),
});

----------------------------------------

TITLE: Mounting API with Next.js Pages Router
DESCRIPTION: TypeScript code for creating a request handler in a Next.js API endpoint using the Pages Router. It shows how to set up the NextRequestHandler with a custom getPrisma function.

LANGUAGE: typescript
CODE:
import { NextRequestHandler } from '@zenstackhq/server/next';
import type { NextApiRequest, NextApiResponse } from 'next';
import { enhance } from '@zenstackhq/runtime';
import { prisma } from '~/lib/db.ts';
import { getSessionUser } from '~/lib/auth.ts';

// create an enhanced Prisma client with user context
function getPrisma(req: NextApiRequest, res: NextApiResponse) {
    // getSessionUser extracts the current session user from the request, its
    // implementation depends on your auth solution
    return enhance(prisma, { user: getSessionUser(req, res) });
}

// create the request handler with the `getPrisma` hook
export default NextRequestHandler({ getPrisma });

----------------------------------------

TITLE: Mounting API with Next.js Pages Router
DESCRIPTION: TypeScript code for creating a request handler in a Next.js API endpoint using the Pages Router. It shows how to set up the NextRequestHandler with a custom getPrisma function.

LANGUAGE: typescript
CODE:
import { NextRequestHandler } from '@zenstackhq/server/next';
import type { NextApiRequest, NextApiResponse } from 'next';
import { enhance } from '@zenstackhq/runtime';
import { prisma } from '~/lib/db.ts';
import { getSessionUser } from '~/lib/auth.ts';

// create an enhanced Prisma client with user context
function getPrisma(req: NextApiRequest, res: NextApiResponse) {
    // getSessionUser extracts the current session user from the request, its
    // implementation depends on your auth solution
    return enhance(prisma, { user: getSessionUser(req, res) });
}

// create the request handler with the `getPrisma` hook
export default NextRequestHandler({ getPrisma });

----------------------------------------

TITLE: Installing ZenStack Server Package
DESCRIPTION: Command to install the required ZenStack server package using npm.

LANGUAGE: bash
CODE:
npm install @zenstackhq/server

----------------------------------------

TITLE: User Model with OpenAPI Metadata (REST Flavor)
DESCRIPTION: Example of a User model with OpenAPI metadata configuration using REST flavor, demonstrating basic security configuration

LANGUAGE: zmodel
CODE:
model User {
    id String @id
    email String @unique

    @@openapi.meta({
        security: [ { basic: [] } ],
        tagDescription: 'Operations for managing users',
    })
}

----------------------------------------

TITLE: Cloning ZenStack Sample Project
DESCRIPTION: Command to clone the sample Todo project repository and checkout the 'part1' branch as a starting point for exploring the plugin system.

LANGUAGE: bash
CODE:
git clone --branch part1 https://github.com/zenstackhq/the-complete-guide-sample.git my-todo-app

----------------------------------------

TITLE: Implementing Signup Page with Server Action
DESCRIPTION: Server Component for user signup using a Server Action to handle form submission and user creation.

LANGUAGE: typescript
CODE:
import { hashSync } from "bcryptjs";
import type { NextPage } from "next";
import Link from "next/link";
import { redirect } from "next/navigation";
import { z } from "zod";
import { db } from "~/server/db";

const signupSchema = z.object({
  email: z.string().email(),
  password: z.string(),
});

const Signup: NextPage = () => {
  async function signup(formData: FormData) {
    "use server";

    const parsed = signupSchema.parse(Object.fromEntries(formData));

    try {
      const user = await db.user.create({
        data: {
          email: parsed.email,
          password: hashSync(parsed.password),
        },
      });
      console.log("User created:", user);
    } catch (err: any) {
      console.error(err);
      if (err.info?.prisma && err.info?.code === "P2002") {
        return { message: "User already exists" };
      } else {
        return { message: "An unknown error occurred" };
      }
    }

    redirect("/");
  }

  return (
    <div>
      <h1>Sign up</h1>
      <form action={signup}>
        <div>
          <label htmlFor="email">
            Email
          </label>
          <input name="email" type="email" />
        </div>
        <div>
          <label htmlFor="password">
            Password
          </label>
          <input name="password" type="password" />
        </div>
        <input type="submit" value="Create account" />
      </form>
    </div>
  );
};

export default Signup;

----------------------------------------

TITLE: Implementing Permission Checking with ZenStack
DESCRIPTION: Shows how to implement permission checking by creating an access-control-enabled Prisma client wrapper

LANGUAGE: typescript
CODE:
// update-post.ts: function for updating a post
import { prisma } from './db';
import { getSessionUser } from './auth';

export function updatePost(request: Request, slug: string, data: PostUpdateInput) {
    const user = await getSessionUser(req);

    // get an access-control enabled Prisma wrapper
    // the "user" context value supports the `auth()`
    // function in the permission rules
    const db = enhance(prisma, { user });

    // error will be thrown if the current user doesn't
    // have permission
    return db.post.update({ where: { slug }, data });
}

----------------------------------------

TITLE: Generating Prisma Client
DESCRIPTION: Command to generate type-safe Prisma client for database access.

LANGUAGE: bash
CODE:
npx prisma generate

----------------------------------------

TITLE: Cloning Specific Branch of ZenStack Sample Project
DESCRIPTION: Command to clone the 'part3' branch of the ZenStack sample todo application repository, which demonstrates CRUD API implementation.

LANGUAGE: bash
CODE:
git clone --branch v1-part3 https://github.com/zenstackhq/the-complete-guide-sample.git my-todo-app

----------------------------------------

TITLE: Configuring tRPC Plugin in Schema
DESCRIPTION: ZModel configuration to enable tRPC router generation with specified output directory

LANGUAGE: zmodel
CODE:
plugin trpc {
    provider = '@zenstackhq/trpc'
    output = 'src/server/routers/generated'
}

----------------------------------------

TITLE: Implementing Refine Data Provider
DESCRIPTION: TypeScript code implementing the getList method of a Refine Data Provider, translating Refine's data structure to match the ZenStack API.

LANGUAGE: typescript
CODE:
export const dataProvider: DataProvider = {

  getList: async function <TData extends BaseRecord = BaseRecord>(
      params: GetListParams
  ): Promise<GetListResponse<TData>> {
    const queryArgs: any = {};

    // filtering
    if (params.filters && params.filters.length > 0) {
      const filters = params.filters.map((filter) =>
          transformFilter(filter)
      );
      if (filters.length > 1) {
          queryArgs.where = { AND: filters };
      } else {
          queryArgs.where = filters[0];
      }
    }

    // sorting
    if (params.sorters && params.sorters.length > 0) {
      queryArgs.orderBy = params.sorters.map((sorter) => ({
          [sorter.field]: sorter.order,
      }));
    }

    // pagination
    if (
      params.pagination?.mode === 'server' &&
      params.pagination.current !== undefined &&
      params.pagination.pageSize !== undefined
    ) {
      queryArgs.take = params.pagination.pageSize;
      queryArgs.skip =
          (params.pagination.current - 1) * params.pagination.pageSize;
    }

    // call the API to fetch data and count
    const [data, count] = await Promise.all([
      fetchData(params.resource, '/findMany', queryArgs),
      fetchData(params.resource, '/count', queryArgs),
    ]);

    return { data, total: count };
  },

  ...
};

----------------------------------------

TITLE: Creating Enhanced Prisma Client with Clerk Auth (Next.js App Router)
DESCRIPTION: This snippet shows how to create an enhanced Prisma client that enforces access policies using Clerk authentication in a Next.js App Router setup.

LANGUAGE: typescript
CODE:
import { enhance } from '@zenstackhq/runtime';
import { auth } from "@clerk/nextjs/server";
import { prisma } from '../lib/db';

async function getPrisma() {
  const authObject = await auth();
  // create a wrapper of Prisma client that enforces access policy
  return enhance(prisma, {
    user: authObject.userId ? { id: authObject.userId } : undefined,
  });
}

----------------------------------------

TITLE: Next.js API Route Handler Setup
DESCRIPTION: Implementation of Next.js API route handler using ZenStack to provide CRUD operations.

LANGUAGE: typescript
CODE:
import { prisma } from '@/server/db';
import { NextRequestHandler } from '@zenstackhq/server/next';

const handler = NextRequestHandler({
  getPrisma: () => prisma,
  useAppDir: true,
});

export {
  handler as DELETE,
  handler as GET,
  handler as PATCH,
  handler as POST,
  handler as PUT,
};

----------------------------------------

TITLE: Updating User with Nested Post Creation in TypeScript
DESCRIPTION: Shows a TypeScript mutation that updates a User and creates a nested Post. This operation would trigger automatic invalidation of queries related to both User and Post models.

LANGUAGE: typescript
CODE:
updateUser({ where: { id: userId }, posts: { create: { title: 'post1' } } });

----------------------------------------

TITLE: Checking Read Permission for Unpublished Posts (Anonymous User) in TypeScript
DESCRIPTION: This snippet shows how to check if an anonymous user can read unpublished posts using the 'check' API.

LANGUAGE: typescript
CODE:
const db = enhance(prisma); // enhance without a user context
await canRead = await db.post.check({ operation: 'read', where: { published: false } });

----------------------------------------

TITLE: Implementing findManyAndCount with Prisma - Basic Approach
DESCRIPTION: Basic implementation of findManyAndCount functionality using Prisma transactions to fetch both items and count in separate queries

LANGUAGE: typescript
CODE:
const { items, count } = await prisma.$transaction(async (tx) => {
    const items = await tx.user.findMany(query);
    const count = await tx.user.count({ where: query.where });
    return { items, count };
});

----------------------------------------

TITLE: Creating Todo Component in React with TypeScript
DESCRIPTION: This code snippet defines a React component for managing a single Todo item. It includes functionality for updating and deleting Todos, and handles optimistic UI updates.

LANGUAGE: tsx
CODE:
import type { Todo } from "@prisma/client";
import { useDeleteTodo, useUpdateTodo } from "~/lib/hooks";

type Props = {
  value: Todo;
  optimistic?: boolean;
};

export default function TodoComponent({ value, optimistic }: Props) {
  const update = useUpdateTodo();
  const del = useDeleteTodo();

  function onDelete() {
    del.mutate({ where: { id: value.id } });
  }

  function onToggleCompleted(completed: boolean) {
    if (completed === !!value.completedAt) {
      return;
    }
    update.mutate({
      where: { id: value.id },
      data: { completedAt: completed ? new Date() : null },
    });
  }

  return (
    <div className="flex w-96 flex-col items-center rounded-lg border px-8 py-4">
      <div className="flex w-full justify-between">
        <h3
          className={`flex items-center text-xl
                        ${
                          value.completedAt
                            ? "italic text-gray-400 line-through"
                            : "text-gray-700"
                        }
                    }`}
        >
          {value.title}
          {optimistic && (
            <span className="loading loading-spinner loading-sm ml-1"></span>
          )}
        </h3>
        <div className="flex">
          <input
            type="checkbox"
            className="checkbox mr-2"
            checked={!!value.completedAt}
            onChange={(e) => onToggleCompleted(e.currentTarget.checked)}
          />
          <button className="btn btn-ghost btn-xs" onClick={onDelete}>
            Delete
          </button>
        </div>
      </div>
    </div>
  );
}

----------------------------------------

TITLE: Providing TanStack Query Context
DESCRIPTION: Script setup code to provide the TanStack Query context with the API endpoint.

LANGUAGE: html
CODE:
<script setup lang="ts">
import { provideHooksContext } from './lib/hooks';

// Provide tanstack-query context
// Use an absolute endpoint so server-side fetch works too
provideHooksContext({
    endpoint: 'http://localhost:3000/api/model',
});
</script>

----------------------------------------

TITLE: Implementing Query-Level Override Extensions
DESCRIPTION: Example of query-level extension that logs query arguments while maintaining ZenStack's access control

LANGUAGE: typescript
CODE:
const extendedPrisma = prisma.$extends({
  query: {
    post: {
      findMany({ query, args }) {
        console.log('Query args:', inspect(args, { depth: null }));
        return query(args);
      },
    },
  },
});

const enhanced = enhance(extendedPrisma);
const posts = await enhanced.post.findMany();

----------------------------------------

TITLE: Defining a User Model in ZenStack
DESCRIPTION: This snippet demonstrates how to define a simple User model using ZenStack's zmodel syntax. It includes an id field as the primary key and a unique email field.

LANGUAGE: zmodel
CODE:
model User {
    id Int @id
    email String @unique
}

----------------------------------------

TITLE: Defining a User Model in ZenStack
DESCRIPTION: This snippet demonstrates how to define a simple User model using ZenStack's zmodel syntax. It includes an id field as the primary key and a unique email field.

LANGUAGE: zmodel
CODE:
model User {
    id Int @id
    email String @unique
}

----------------------------------------

TITLE: Mounting automatic CRUD API with ZenStack's Next.js server adapter
DESCRIPTION: This snippet shows how to use ZenStack's Next.js server adapter to automatically serve a complete set of CRUD API. It creates an enhanced PrismaClient using the authenticated user and sets up route handlers for various HTTP methods.

LANGUAGE: typescript
CODE:
import { enhance } from '@zenstackhq/runtime';
import { NextRequestHandler } from '@zenstackhq/server/next';
import { auth } from '~/auth';
import { prisma } from '~/db';

async function getPrisma() {
  const authObj = await auth();
  return enhance(prisma, { user: authObj?.user });
}

const handler = NextRequestHandler({ getPrisma, useAppDir: true });

export {
  handler as DELETE,
  handler as GET,
  handler as PATCH,
  handler as POST,
  handler as PUT
};

----------------------------------------

TITLE: Creating Enhanced Prisma Client with Clerk Authentication
DESCRIPTION: TypeScript function to create an enhanced Prisma client that enforces access policies and data validation rules. It uses Clerk's authentication context to provide user information to the enhancement wrapper.

LANGUAGE: typescript
CODE:
import type { NextApiRequest } from 'next';
import { enhance } from '@zenstackhq/runtime';
import { getAuth } from '@clerk/nextjs/server';
import { prisma } from '../lib/db';

async function getPrisma(req: NextApiRequest) {
    const auth = getAuth(req);
    // create a wrapper of Prisma client that enforces access policy,
    // data validation, and @password, @omit behaviors
    return enhance(prisma, { user: auth ? { id: auth.userId } : undefined });
}

----------------------------------------

TITLE: Firebase Security Rules Implementation
DESCRIPTION: Shows how to implement document-level security rules in Firebase for article access control.

LANGUAGE: sql
CODE:
service cloud.firestore {
  match /databases/{database}/documents {
    match /articles/{articleId} {
      allow read: if isUserAuthorizedToRead(articleId);
    }
    function isUserAuthorizedToRead(articleId) {
      let userAcl = exists(/databases/$(database)/documents/accessControlList/$(request.auth.uid) + '_' + articleId);
      if (userAcl) return true;
      let groups = get(/databases/$(database)/documents/users/$(request.auth.uid)).data.groups;
      for (let group in groups) {
        let groupAcl = exists(/databases/$(database)/documents/accessControlList/$(group) + '_' + articleId);
        if (groupAcl) return true;
      }
      return false;
    }
  }
}

----------------------------------------

TITLE: Creating React Server Components in Next.js
DESCRIPTION: Shows implementation of a React Server Component that executes exclusively on the server side, demonstrating access to server-only resources.

LANGUAGE: tsx
CODE:
export function ServerComponent() {
    console.log('This will only be printed on the server');
    return (
        <div>
            <h1>Server Component</h1>
            <p>My secret key: {process.env.MY_SECRET_ENV}</p>
        </div>
    );
}

----------------------------------------

TITLE: Rendering Themed Image Component in Markdown
DESCRIPTION: This code snippet shows the usage of the 'ThemedImage' component to display an image with different sources for light and dark themes. It sets the alt text and specifies image paths for both themes.

LANGUAGE: markdown
CODE:
<ThemedImage
    alt="Feature Prototyping Workflow"
    sources={{
        light: useBaseUrl('/img/dev-workflow-light.png'),
        dark: useBaseUrl('/img/dev-workflow-dark.png'),
    }}
/>

----------------------------------------

TITLE: JSON Response with Serialization Metadata
DESCRIPTION: This JSON snippet shows the response format for a query that returns data requiring serialization, including metadata for deserialization.

LANGUAGE: json
CODE:
{
   "data" : {
      "createdAt" : "2023-11-08T04:38:53.385Z",
      "id" : 1,
      "ownerId" : 1,
      "private" : false,
      "spaceId" : 1,
      "title" : "Grocery",
      "updatedAt" : "2023-11-09T04:52:57.987Z"
   },
   "meta" : {
      "serialization" : {
         "values" : {
            "createdAt" : [ "Date" ],
            "updatedAt" : [ "Date" ]
         }
      }
   }
}

----------------------------------------

TITLE: Extending SpaceBase Model for Task Management
DESCRIPTION: This snippet shows how to add a new Task model by extending the SpaceBase abstract model, demonstrating the ease of adding new features without code duplication.

LANGUAGE: zmodel
CODE:
/*
 * Model for a task
 */
model Task extends SpaceBase {
    title String
    size Int
}

----------------------------------------

TITLE: Creating Todo List Page in Next.js with TypeScript
DESCRIPTION: This code snippet creates a Next.js page component for managing a list of Todos. It includes functionality for creating new Todos and rendering existing ones using the TodoComponent.

LANGUAGE: tsx
CODE:
"use client";

import { useSession } from "next-auth/react";
import { useParams } from "next/navigation";
import { useState } from "react";
import TodoComponent from "~/components/TodoComponent";
import { useCreateTodo, useFindManyTodo, useFindUniqueList } from "~/lib/hooks";

export default function TodoList() {
  const { listId } = useParams<{ listId: string }>();
  const { data: session } = useSession();

  const { data: list } = useFindUniqueList(
    {
      where: { id: listId },
    },
    { enabled: !!session?.user },
  );

  const { mutate: create } = useCreateTodo();
  const { data: todos } = useFindManyTodo(
    {
      where: { listId },
      orderBy: { createdAt: "desc" as const },
    },
    { enabled: !!session?.user },
  );

  const [title, setTitle] = useState("");

  function onCreate() {
    create({
      data: {
        title,
        owner: { connect: { id: session?.user.id } },
        list: { connect: { id: listId } },
      },
    });
    setTitle("");
  }

  if (!session?.user || !list) {
    return <></>;
  }

  return (
    <div>
      <div className="container mx-auto flex w-full flex-col items-center py-12">
        <h1 className="mb-4 text-2xl font-semibold">{list.title}</h1>
        <div className="flex space-x-2">
          <input
            type="text"
            placeholder="Type a title and press enter"
            className="input input-bordered mt-2 w-72 max-w-xs"
            value={title}
            autoFocus
            onKeyUp={(e) => {
              if (e.key === "Enter") {
                onCreate();
              }
            }}
            onChange={(e) => {
              setTitle(e.currentTarget.value);
            }}
          />
        </div>
        <ul className="flex w-auto flex-col space-y-4 py-8">
          {todos?.map((todo) => (
            <TodoComponent
              key={todo.id}
              value={todo}
              optimistic={todo.$optimistic}
            />
          ))}
        </ul>
      </div>
    </div>
  );
}

----------------------------------------

TITLE: JSON Response with Serialization Metadata
DESCRIPTION: This JSON snippet shows the response format for a query that returns data requiring serialization, including metadata for deserialization.

LANGUAGE: json
CODE:
{
   "data" : {
      "createdAt" : "2023-11-08T04:38:53.385Z",
      "id" : 1,
      "ownerId" : 1,
      "private" : false,
      "spaceId" : 1,
      "title" : "Grocery",
      "updatedAt" : "2023-11-09T04:52:57.987Z"
   },
   "meta" : {
      "serialization" : {
         "values" : {
            "createdAt" : [ "Date" ],
            "updatedAt" : [ "Date" ]
         }
      }
   }
}

----------------------------------------

TITLE: Firebase Security Rules Example
DESCRIPTION: Example of Firebase's DSL for enforcing access control rules on documents

LANGUAGE: tsx
CODE:
service cloud.firestore {
  match /databases/{database}/documents {
    match /posts/{postId} {
      allow read: if true;
      allow write: if request.auth != null && request.auth.uid == resource.data.authorId;
    }
  }
}

----------------------------------------

TITLE: Installing ZenStack Server Package
DESCRIPTION: Command to install the required ZenStack server package using npm.

LANGUAGE: bash
CODE:
npm install @zenstackhq/server

----------------------------------------

TITLE: Todo App Schema with Relation-Based Access Control
DESCRIPTION: Complete schema implementation showing authorization rules for a Todo application with space-based access control

LANGUAGE: zmodel
CODE:
model Space {
  ...

  // require login
  @@deny('all', auth() == null)

  // everyone can create a space
  @@allow('create', true)

  // users in the space can read the space
  @@allow('read', members?[user == auth()])

  // space admin can update and delete
  @@allow('update,delete', members?[user == auth() && role == 'ADMIN'])
}

----------------------------------------

TITLE: Todo App Schema with Relation-Based Access Control
DESCRIPTION: Complete schema implementation showing authorization rules for a Todo application with space-based access control

LANGUAGE: zmodel
CODE:
model Space {
  ...

  // require login
  @@deny('all', auth() == null)

  // everyone can create a space
  @@allow('create', true)

  // users in the space can read the space
  @@allow('read', members?[user == auth()])

  // space admin can update and delete
  @@allow('update,delete', members?[user == auth() && role == 'ADMIN'])
}

----------------------------------------

TITLE: ZModel Auth and User Model Definition
DESCRIPTION: ZModel definitions for Auth type and User model with authentication policies.

LANGUAGE: zmodel
CODE:
type Auth {
  id             String      @id
  @@auth
}

model User {
  id               String          @id
  name             String?
  email            String?

  @@allow('create, read, update, delete', auth().id == this.id)
}

----------------------------------------

TITLE: JWT Verification with Auth0
DESCRIPTION: Implementation of JWT verification using Auth0 JWKS for authentication and session creation.

LANGUAGE: typescript
CODE:
export const getPrismaJWT = async (req) => {
  try {
    const jwks = jose.createRemoteJWKSet(new URL(process.env.AUTH0_JWKS_URI));
    const token = toString(req.headers.get('authorization')).replace('Bearer ', '');
    const res = await jose.jwtVerify(token, jwks, {
      issuer: `${process.env.AUTH0_ISSUER_BASE_URL}/`,
      audience: process.env.AUTH0_AUDIENCE,
      algorithms: ['RS256'],
    });
  
    const userId = res.payload.sub;
    const user = {
      id: userId,
      specialKey: res.payload.metadata.specialKey
    };
  
    return enhance(prisma, {user});
  catch (err) {
    // unauthenticated error
  }  
};

----------------------------------------

TITLE: Using SWR Query and Mutation Hooks in React Component
DESCRIPTION: Example of a React component using SWR query and mutation hooks generated by the @zenstackhq/swr plugin.

LANGUAGE: tsx
CODE:
import type { Post } from '@prisma/client';
import { useFindManyPost, useCreatePost } from '../lib/hooks';

// post list component
const Posts = ({ userId }: { userId: string }) => {
    const { trigger: createPost } = useCreatePost();

    // list all posts that're visible to the current user, together with their authors
    const { data: posts } = useFindManyPost({
        include: { author: true },
        orderBy: { createdAt: 'desc' },
    });

    function onCreatePost() {
        createPost({
            data: {
                title: 'My awesome post',
                authorId: userId,
            },
        });
    }

    return (
        <>
            <button onClick={onCreatePost}>Create</button>
            <ul>
                {posts?.map((post) => (
                    <li key={post.id}>
                        {post.title} by {post.author.email}
                    </li>
                ))}
            </ul>
        </>
    );
};

----------------------------------------

TITLE: Configuring Custom Encryption in TypeScript
DESCRIPTION: This snippet shows how to set up custom encryption by providing custom encrypt and decrypt functions when creating an enhanced PrismaClient.

LANGUAGE: typescript
CODE:
async function myEncrypt(model: string, field: FieldInfo, plain: string) {
  ...
}

async function myDecrypt(model: string, field: FieldInfo, cipher: string) {
  ...
}

const db = enhance(prisma, { user }, {
  encryption: {
    encrypt: myEncrypt,
    decrypt: myDecrypt
  }
});

----------------------------------------

TITLE: Adding OrganizationSwitcher Component in Next.js Layout
DESCRIPTION: This snippet shows how to integrate Clerk's OrganizationSwitcher component into the Next.js layout file. It adds organization management and switching functionality to the application header.

LANGUAGE: tsx
CODE:
import { OrganizationSwitcher } from "@clerk/nextjs";
...

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <ClerkProvider>
      <html lang="en">
        <body>
          <header>
            <SignedOut>
              <SignInButton />
            </SignedOut>
            <SignedIn>
              <div>
                <OrganizationSwitcher />
                <UserButton />
              </div>
            </SignedIn>
          </header>
        </body>
      </html>
    </ClerkProvider>
  );
}

----------------------------------------

TITLE: Enabling Optimistic Updates for Todo Operations in TypeScript
DESCRIPTION: This code snippet demonstrates how to enable automatic optimistic updates for Todo creation, update, and deletion operations using ZenStack's generated hooks.

LANGUAGE: typescript
CODE:
// For creating Todos
const { mutate: create } = useCreateTodo(undefined, true, true);

// For updating Todos
const update = useUpdateTodo(undefined, true, true);

// For deleting Todos
const del = useDeleteTodo(undefined, true, true);

----------------------------------------

TITLE: Starting Next.js Development Server
DESCRIPTION: Command to start the Next.js development server for testing the authentication implementation.

LANGUAGE: bash
CODE:
npm run dev

----------------------------------------

TITLE: Creating User with Posts using RPC-style API Handler in TypeScript
DESCRIPTION: This snippet demonstrates how to create a user with two associated posts using the RPC-style API handler. It uses the fetch API to make a POST request to the '/api/user/create' endpoint.

LANGUAGE: typescript
CODE:
// create a user with two posts
const r = await fetch(`/api/user/create`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
        include: { posts: true },
        data: {
            email: 'user1@abc.com',
            posts: {
                create: [{ title: 'Post 1' }, { title: 'Post 2' }],
            },
        },
    }),
});

console.log(await r.json());

----------------------------------------

TITLE: Installing ZenStack GraphQLYoga plugin in RedwoodJS
DESCRIPTION: TypeScript code to install the ZenStack GraphQLYoga plugin in the GraphQL handler of a RedwoodJS project.

LANGUAGE: typescript
CODE:
import { useZenStack } from '@zenstackhq/redwood'
import { db } from 'src/lib/db'
import { createGraphQLHandler } from '@redwoodjs/graphql-server'
...

export const handler = createGraphQLHandler({
  ...
  extraPlugins: [useZenStack(db)],
})

----------------------------------------

TITLE: Configuring Encryption with Default Settings in TypeScript
DESCRIPTION: This code demonstrates how to configure encryption settings when creating an enhanced PrismaClient using the default encryption method.

LANGUAGE: typescript
CODE:
function getEncryptionKey(): Uint8Array {
    // return a 32-byte key
}

const db = enhance(prisma, { user }, {
  encryption: {
    encryptionKey: getEncryptionKey()
  }
});

----------------------------------------

TITLE: Providing Current User to ZenStack
DESCRIPTION: This TypeScript snippet shows how to provide the current user to ZenStack when calling the enhance function.

LANGUAGE: typescript
CODE:
// `getCurrentUser` is an authentication API that extracts 
// the current user from the request
const user = await getCurrentUser(request);

// create an enhanced Prisma Client for the user, the `user` object
// provides value for the `auth()` function in policy rules
const db = enhance(prisma, { user })

----------------------------------------

TITLE: Example Debug Query Output
DESCRIPTION: Shows an example of the logged Prisma query output when debug logging is enabled, demonstrating the structure of access policy conditions.

LANGUAGE: javascript
CODE:
prisma:info [policy] `findMany` list:
{
  where: {
    AND: [
      { NOT: { OR: [] } },
      {
        OR: [
          { owner: { is: { id: 1 } } },
          {
            AND: [
              {
                space: {
                  members: {
                    some: { user: { is: { id: 1 } } }
                  }
                }
              },
              { NOT: { private: true } }
            ]
          }
        ]
      }
    ]
  }
}

----------------------------------------

TITLE: Content Class Diagram in Mermaid
DESCRIPTION: Class diagram showing the inheritance relationship between different content types (Post, Image, Video)

LANGUAGE: mermaid
CODE:
classDiagram
    Content <|-- Post
    Content <|-- Image
    Content <|-- Video
    Content : +String id
    Content : +Date created
    Content : +Date updated
    Content: +bool published
    Content: +string AuthorId
    class Post{
      +String title
      +String content
    }
    class Image{
      +string url
      +int size
    }
    class Video{
      +string url
      +int duration
    }

----------------------------------------

TITLE: Installing ZenStack using CLI Initialization
DESCRIPTION: Command to initialize ZenStack in an existing TypeScript project using the CLI tool.

LANGUAGE: bash
CODE:
npx zenstack@latest init

----------------------------------------

TITLE: Implementing Row Level Security in PostgreSQL for Blog Posts
DESCRIPTION: SQL code demonstrating how to set up row-level security policies in Supabase for blog posts, controlling access for post owners and public readers.

LANGUAGE: sql
CODE:
# Simple RLS for blog posts

# owner has full access to her own posts
CREATE POLICY post_owner_policy ON post
    USING (owner = current_user);

# all users can read published posts
CREATE POLICY post_read_policy ON post FOR SELECT
    USING (published = true);

----------------------------------------

TITLE: Providing Current User to ZenStack
DESCRIPTION: This TypeScript snippet shows how to provide the current user to ZenStack when calling the enhance function.

LANGUAGE: typescript
CODE:
// `getCurrentUser` is an authentication API that extracts 
// the current user from the request
const user = await getCurrentUser(request);

// create an enhanced Prisma Client for the user, the `user` object
// provides value for the `auth()` function in policy rules
const db = enhance(prisma, { user })

----------------------------------------

TITLE: Implementing a ZenStack Plugin to Access Custom Attributes
DESCRIPTION: This TypeScript code demonstrates how to implement a ZenStack plugin that can access custom attributes defined in ZModel.

LANGUAGE: typescript
CODE:
import { DMMF } from "@prisma/generator-helper";
import { PluginOptions } from "@zenstackhq/sdk";
import { Model } from "@zenstackhq/sdk/ast";

export default async function run(
  model: Model,
  options: PluginOptions,
  dmmf: DMMF.Document
) {
   const userModel = models.find((m) => m.name === 'User');
   const userModelAttributes = userModel?.attributes;

   const emailField = userModel?.fields.find((f) => f.name === 'email');
   const emailFieldAttributes = emailField?.attributes;

   const passwordField = userModel?.fields.find((f) => f.name === 'password');
   const passwordFieldAttributes = passwordField?.attributes;
}

----------------------------------------

TITLE: Modeling Relationships in Prisma Schema
DESCRIPTION: This example shows how to define a one-to-many relationship between User and Post models in Prisma schema. It uses the @relation attribute to connect the models with a foreign key.

LANGUAGE: zmodel
CODE:
model User {
    id Int @id @default(@autoincrement())
    ...
    posts Post[]
}

model Post {
    id Int @id @default(@autoincrement())
    title String
    author User @relation(fields: [authorId], references: [id])
    authorId Int
}

----------------------------------------

TITLE: Creating Next.js Homepage with Session Display
DESCRIPTION: A simple Next.js page component that displays the current user's email using NextAuth session data.

LANGUAGE: tsx
CODE:
'use client';

import { useSession } from "next-auth/react";

export default function Home() {
  const { data: session } = useSession();
  return (
    <div className="flex h-screen w-screen items-center justify-center">
      {session?.user && <h1>Welcome {session?.user?.email}</h1>}
    </div>
  );

----------------------------------------

TITLE: Updating Records with Prisma Client - Pre v4.5.0
DESCRIPTION: Example showing how to update records using updateMany with version check before Prisma 4.5.0, implementing optimistic concurrency control with additional count verification.

LANGUAGE: tsx
CODE:
const seats = await client.seat.updateMany({
  data: {
    claimedBy: userEmail,
    version: {
      increment: 1,
    },
  },
  where: {
    id: availableSeat.id,
    version: availableSeat.version, 
})

if (seats.count === 0) {
  throw new Error(`That seat is already booked! Please try again.`)
}

----------------------------------------

TITLE: Configuring PrismaClient Logging
DESCRIPTION: Demonstrates how to enable info level logging when initializing PrismaClient to see ZenStack's injected queries.

LANGUAGE: typescript
CODE:
const prisma = new PrismaClient({ log: ['info'] });

----------------------------------------

TITLE: Warrant.dev API Usage Examples
DESCRIPTION: JSON examples showing how to use the Warrant.dev REST API for authorization.

LANGUAGE: json
CODE:
{
  "type": "article",
  "relations": {
    "viewer": {}
  }
}

LANGUAGE: json
CODE:
{
  "objectType": "article",
  "objectId": "1",
  "relation": "viewer",
  "subject": {
    "objectType": "user",
    "objectId": "d6ed6474-784e-407e-a1ea-42a91d4c52b9"
  }
}

LANGUAGE: json
CODE:
{
  "warrants": [
    {
      "objectType": "article",
      "objectId": "1",
      "relation": "viewer",
      "subject": {
        "objectType": "user",
        "objectId": "d6ed6474-784e-407e-a1ea-42a91d4c52b9"
      }
    }
  ]
}

----------------------------------------

TITLE: Creating Next.js Project with T3 Stack
DESCRIPTION: Initialize a new Next.js project using create-t3-app with Prisma, NextAuth, and TailwindCSS configurations

LANGUAGE: bash
CODE:
npx create-t3-app@latest --prisma --nextAuth --tailwind --appRouter --CI my-blog-app
cd my-blog-app

----------------------------------------

TITLE: Prisma Soft Delete Middleware Implementation
DESCRIPTION: Code showing how Prisma handles soft delete operations by converting delete operations to updates.

LANGUAGE: tsx
CODE:
if (params.action == 'delete') {
        // Delete queries
        // Change action to an update
        params.action = 'update'
        params.args['data'] = { deleted: true }
      }
      if (params.action == 'deleteMany') {
        // Delete many queries
        params.action = 'updateMany'
        if (params.args.data != undefined) {
          params.args.data['deleted'] = true
        } else {
          params.args['data'] = { deleted: true }
        }
      }

----------------------------------------

TITLE: REPL Query Result Example
DESCRIPTION: Sample output from testing the authorization rules showing a successful query result

LANGUAGE: js
CODE:
[
  {
    id: 1,
    createdAt: 2023-11-08T04:38:53.385Z,
    updatedAt: 2023-11-08T04:38:53.385Z,
    spaceId: 1,
    ownerId: 2,
    title: 'Grocery',
    private: false
  }
]

----------------------------------------

TITLE: Initializing ZenStack Schema
DESCRIPTION: Data model definition for User and Post entities with access control policies using ZModel syntax.

LANGUAGE: zmodel
CODE:
model User {
    id String @id @default(cuid())
    email String @unique @email
    password String @password @omit @length(8, 16)
    posts Post[]

    // everybody can signup
    @@allow('create,read', true)

    // full access by self
    @@allow('all', auth() == this)
}

model Post {
    id String @id @default(cuid())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
    title String @length(1, 256)
    published Boolean @default(false)
    author User? @relation(fields: [authorId], references: [id])
    authorId String?

    // allow read for all signin users
    @@allow('read', auth() != null && published)

    // full access by author
    @@allow('all', author == auth())
}

----------------------------------------

TITLE: ZModel Schema with Custom Attributes
DESCRIPTION: Improved version of the Prisma schema using ZModel's custom attributes. This approach provides better type-safety and compiler checks while maintaining compatibility with existing Prisma generators.

LANGUAGE: zmodel
CODE:
attribute @TypeGraphQL.omit(output: Boolean?, input: Boolean?)

model User {
  id Int @default(autoincrement()) @id
  email String  @unique
  password String @TypeGraphQL.omit(output: true, input: true)
  posts Post[]
}

----------------------------------------

TITLE: Creating Supabase Database Trigger for User Synchronization
DESCRIPTION: SQL trigger setup to automatically synchronize new user records from Supabase Auth to the application's User table. Includes function definition and trigger creation.

LANGUAGE: sql
CODE:
create function public.handle_new_user()
returns trigger
language plpgsql
security definer set search_path = public
as $$
begin
  insert into public."User" (id)
  values (new.id);
  return new;
end;
$$;

create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

----------------------------------------

TITLE: Creating New List with Client Component and Server Action
DESCRIPTION: This snippet shows a client component for creating a new list and a server action to handle the creation process.

LANGUAGE: tsx
CODE:
"use client";

import { createList } from "~/app/actions";

export default function CreateList() {
  function onCreate() {
    const title = prompt("Enter a title for your list");
    if (title) {
      createList(title);
    }
  }

  return (
    <button onClick={onCreate}>
      Create a list
    </button>
  );
}

LANGUAGE: typescript
CODE:
'use server';

import { revalidatePath } from "next/cache";
import { getUserDb } from "~/server/db";

export async function createList(title: string) {
  const db = await getUserDb();
  await db.list.create({ data: { title } });
  revalidatePath("/");
}

----------------------------------------

TITLE: Creating Nuxt Project with Local Auth
DESCRIPTION: Commands to create a new Nuxt project using a local authentication example as a starter.

LANGUAGE: bash
CODE:
npx degit nuxt/examples/auth/local my-nuxt-blog
cd my-nuxt-blog
npm install
npm run dev

----------------------------------------

TITLE: Configuring Plugin in ZModel Schema
DESCRIPTION: Shows how to declare and configure a plugin in a ZModel schema file. The example configures the OpenAPI plugin with output path, title, and version settings.

LANGUAGE: zmodel
CODE:
plugin openapi {
    provider = "@zenstackhq/openapi"
    output = "openapi.yaml"
    title = "My Todo API"
    version = "1.0.0"
}

----------------------------------------

TITLE: ZenStack Schema Configuration
DESCRIPTION: ZModel schema configuration to generate React Query hooks.

LANGUAGE: zmodel
CODE:
plugin hooks {
  provider = '@zenstackhq/tanstack-query'
  target = 'react'
  output = 'src/hooks'
}

----------------------------------------

TITLE: Registering ZenStack schema locations in package.json
DESCRIPTION: JSON configuration in api/package.json to specify the locations of ZenStack schema files.

LANGUAGE: json
CODE:
{
  ...
  "zenstack": {
    "schema": "db/schema.zmodel",
    "prisma": "db/schema.prisma"
  }
}

----------------------------------------

TITLE: Installing ZenStack Runtime Package
DESCRIPTION: Command to install the ZenStack runtime package as a regular project dependency using npm.

LANGUAGE: bash
CODE:
npm install @zenstackhq/runtime@latest

----------------------------------------

TITLE: Using PrismaClient Check API Example
DESCRIPTION: Example demonstrating how to use the check API to verify if the current user has permission to read published posts.

LANGUAGE: typescript
CODE:
const db = enhance(prisma, { user: getCurrentUser() });

// check if the current user can read published posts
await canRead = await db.post.check({
  operation: 'read',
  where: { published: true }
});

----------------------------------------

TITLE: Configuring Root Layout with Query Provider
DESCRIPTION: Integration of Query Provider into the Next.js root layout component

LANGUAGE: tsx
CODE:
import QueryClientProvider from '~/components/QueryClientProvider';

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en">
      <body className={`font-sans ${inter.variable}`}>
        <QueryClientProvider>
          <NextAuthSessionProvider>{children}</NextAuthSessionProvider>
        </QueryClientProvider>
      </body>
    </html>
  );
}

----------------------------------------

TITLE: Generating OpenAPI Specification with ZenStack
DESCRIPTION: Configuration for generating OpenAPI specification using ZenStack's OpenAPI plugin.

LANGUAGE: zmodel
CODE:
plugin openapi {
    provider = '@zenstackhq/openapi'
    prefix = '/api'
    title = 'Pet Store API'
    version = '0.1.0'
    description = 'My awesome pet store API'
    output = 'petstore-api.json'
}

----------------------------------------

TITLE: Implementing Hono Middleware for CRUD Operations
DESCRIPTION: Example of creating and configuring a Hono middleware handler for automatic CRUD operations. Shows integration with PrismaClient, enhancement with user context, and middleware mounting.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client';
import { enhance } from '@zenstackhq/runtime';
import { createHonoHandler } from '@zenstackhq/server/hono';
import { Context, Hono } from 'hono';

const prisma = new PrismaClient();
const app = new Hono();

app.use(
    '/api/model/*',
    createHonoHandler({
        getPrisma: (ctx) => {
            return enhance(prisma, { user: getCurrentUser(ctx) });
        },
    })
);

function getCurrentUser(ctx: Context) {
    // the implementation depends on your authentication mechanism
    ...
}

----------------------------------------

TITLE: Basic Post-Update Revision Check in ZenStack
DESCRIPTION: Demonstrates how to implement a basic post-update check that ensures the new revision number is greater than the current one using the future() function.

LANGUAGE: zmodel
CODE:
model Post {
    ...
    revision Int

    @@allow('update', future().revision > revision)
}

----------------------------------------

TITLE: NextAuth Configuration with Credentials Provider
DESCRIPTION: Configuration for NextAuth.js using credentials-based authentication with password hashing and JWT sessions

LANGUAGE: typescript
CODE:
import { PrismaAdapter } from "@auth/prisma-adapter";
import type { PrismaClient } from "@prisma/client";
import { compare } from "bcryptjs";
import type { GetServerSidePropsContext } from "next";
import NextAuth, {
  getServerSession,
  type DefaultSession,
  type NextAuthOptions,
} from "next-auth";
import CredentialsProvider from "next-auth/providers/credentials";
import { db } from "./db";
import { Adapter } from "next-auth/adapters";

export const authOptions: NextAuthOptions = {
  session: {
    strategy: "jwt",
  },
  callbacks: {
    session({ session, token }) {
      if (session.user) {
        session.user.id = token.sub!;
      }
      return session;
    },
  },
  adapter: PrismaAdapter(db) as Adapter,
  providers: [
    CredentialsProvider({
      credentials: {
        email: { type: "email" },
        password: { type: "password" },
      },
      authorize: authorize(db),
    }),
  ],
};

----------------------------------------

TITLE: Database Schema ERD Diagram
DESCRIPTION: Entity Relationship Diagram showing the Northwind database schema structure with relationships between tables.

LANGUAGE: mermaid
CODE:
erDiagram
	Category {
		Int id PK
		String name
		String description
	}
	Customer {
		String id PK
		String name
		String contactName
		String contactTitle
		String address
		String city
		String postalCode
		String country
	}
	Employee {
		Int id PK
		String lastName
		String firstName
		String title
		String region
	}
	OrderDetail {
		Int orderId
		Int productId
		Float unitPrice
		Int quantity
		Float discount
	}
	Order {
		Int id PK
		String customerId
		Int employeeId
		DateTime orderDate
		DateTime shippedDate
	}
	Product {
		Int id PK
		String name
		Int categoryId
		Float unitPrice
	}
	Order ||--|{ OrderDetail : details
	Order }o--|| Customer : customer
	Order }o--|| Employee : employee
	OrderDetail }o--|| Product : product
	Product }o--|| Category : category

----------------------------------------

TITLE: Basic Post-Update Revision Check in ZenStack
DESCRIPTION: Demonstrates how to implement a basic post-update check that ensures the new revision number is greater than the current one using the future() function.

LANGUAGE: zmodel
CODE:
model Post {
    ...
    revision Int

    @@allow('update', future().revision > revision)
}

----------------------------------------

TITLE: ZModel Enum Definition
DESCRIPTION: Example of defining an enum type.

LANGUAGE: zmodel
CODE:
enum UserRole {
    USER
    ADMIN
}

----------------------------------------

TITLE: Implementing Authentication in Express.js
DESCRIPTION: Implementation of login route in Express.js, including JWT token generation and password comparison.

LANGUAGE: typescript
CODE:
import dotenv from 'dotenv';
import jwt from 'jsonwebtoken';
import { compareSync } from 'bcryptjs';

// load .env environment variables
dotenv.config();

app.post('/api/login', async (req, res) => {
    const { email, password } = req.body;
    const user = await prisma.user.findFirst({
        where: { email },
    });
    if (!user || !compareSync(password, user.password)) {
        res.status(401).json({ error: 'Invalid credentials' });
    } else {
        // sign a JWT token and return it in the response
        const token = jwt.sign({ sub: user.id }, process.env.JWT_SECRET!);
        res.json({ id: user.id, email: user.email, token });
    }
});

----------------------------------------

TITLE: Email Validation Implementation
DESCRIPTION: Shows how to implement email validation for User model.

LANGUAGE: zmodel
CODE:
model User {
    ...
    email String @unique @email
}

----------------------------------------

TITLE: Updating redwood.toml for ZenStack CLI plugin
DESCRIPTION: Configuration update in redwood.toml to allow the ZenStack CLI plugin in the RedwoodJS project.

LANGUAGE: yaml
CODE:
[[experimental.cli.plugins]]
package = "@zenstackhq/redwood"
enabled = true

----------------------------------------

TITLE: Implementing Multi-Tenant Client Manager with Prisma and NestJS
DESCRIPTION: Shows how to manage multiple database connections for different tenants using a client manager class in NestJS. Handles dynamic client creation and caching based on tenant ID.

LANGUAGE: typescript
CODE:
@Injectable()
class PrismaClientManager{
  private clients: { [key: string]: PrismaClient } = {};

  getTenantId(request: Request): string {
    ...
  }

  getClient(request: Request): PrismaClient {
    const tenantId = this.getTenantId(request);
    let client = this.clients[tenantId];
    if (!client) {
      const databaseUrl = process.env.DATABASE_URL!.replace('public', tenantId);

      client = new PrismaClient({
        datasources: {
          db: {
            url: databaseUrl,
          },
        },
      });

      this.clients[tenantId] = client;
    }

    return client;
  }
}

----------------------------------------

TITLE: Creating NestJS Project
DESCRIPTION: Command to create a new NestJS project using the CLI.

LANGUAGE: bash
CODE:
npx @nestjs/cli@latest new -p npm my-blog-app
cd my-blog-app

----------------------------------------

TITLE: Creating a Concrete Entity with Enhanced PrismaClient
DESCRIPTION: This code snippet shows how to create a Video entity using the enhanced PrismaClient. The runtime transforms this operation to create both an Asset and a Video record.

LANGUAGE: typescript
CODE:
await db.video.create({ 
  data: { ownerId: userId, duration: 100, url: '...' }
});

----------------------------------------

TITLE: Example: Nested Read Query with Filtering
DESCRIPTION: Example of using generated hooks for nested data querying with filters and sorting

LANGUAGE: tsx
CODE:
const { data } = useFindManyTodo({
  where: { owner: { id: 1 } },
  include: { list: true },
  orderBy: { createdAt: 'desc' }
});

----------------------------------------

TITLE: Customizing Prisma Query Behavior
DESCRIPTION: Shows how to customize the 'findMany' query for the User model to always filter for users over 18 years old.

LANGUAGE: typescript
CODE:
const xprisma = prisma.$extends({
    query: {
        user: {
            async findMany({ model, operation, args, query }) {
                args.where = { age: { gt: 18 }, ...args.where };
                return query(args);
            },
        },
    },
});

await xprisma.user.findMany(); // returns users whose age is greater than 18

----------------------------------------

TITLE: CASL Authorization Implementation
DESCRIPTION: Example of implementing authorization logic using the CASL library in JavaScript.

LANGUAGE: tsx
CODE:
function isReadable(acl, user) {
  return acl.some(permission => {
    return (
      (permission.userId === user.id || user.groups.includes(permission.groupId)) 
			&& permission.action === 'read'
    );
  });
}

const articleAbility = (user, article) => defineAbility((can) => {
  if (isReadable(article.acl, user)) {
    can('read', 'Article', { id: article.id });
  }
});

const ability = articleAbility(user1, article1);
ability.can('read', 'Article', article1);

----------------------------------------

TITLE: Example: Nested Read Query with Filtering
DESCRIPTION: Example of using generated hooks for nested data querying with filters and sorting

LANGUAGE: tsx
CODE:
const { data } = useFindManyTodo({
  where: { owner: { id: 1 } },
  include: { list: true },
  orderBy: { createdAt: 'desc' }
});

----------------------------------------

TITLE: Creating a New List with Client Component and Server Action
DESCRIPTION: This set of snippets shows a client component for creating a new list and a corresponding server action to handle the creation.

LANGUAGE: tsx
CODE:
"use client";

import { createList } from "~/app/actions";

export default function CreateList() {
  function onCreate() {
    const title = prompt("Enter a title for your list");
    if (title) {
      createList(title);
    }
  }

  return (
    <button onClick={onCreate}>
      Create a list
    </button>
  );
}

LANGUAGE: typescript
CODE:
'use server';

import { revalidatePath } from "next/cache";
import { getUserDb } from "~/server/db";

export async function createList(title: string) {
  const db = await getUserDb();
  await db.list.create({ data: { title } });
  revalidatePath("/");
}

----------------------------------------

TITLE: Creating Express.js Server Entry Point
DESCRIPTION: Sets up the main Express.js server file with a basic route and JSON body parser.

LANGUAGE: typescript
CODE:
import express from 'express';

const app = express();

// enable JSON body parser
app.use(express.json());

app.get('/', (req, res) => {
    res.send('Hello World!');
});

export default app;

----------------------------------------

TITLE: Configuring GraphQL Handler with ZenStack
DESCRIPTION: TypeScript code to set up GraphQL handler with ZenStack plugin for access policy enforcement

LANGUAGE: typescript
CODE:
import { useZenStack } from '@zenstackhq/redwood'
import { db } from 'src/lib/db'
import { createGraphQLHandler } from '@redwoodjs/graphql-server'

export const handler = createGraphQLHandler({
  ...
  extraPlugins: [useZenStack(db)],
})

----------------------------------------

TITLE: NestJS PrismaService Implementation
DESCRIPTION: Service class extending PrismaClient for database connection management in NestJS.

LANGUAGE: typescript
CODE:
import { Injectable, OnModuleInit } from '@nestjs/common';
import { PrismaClient } from '@prisma/client';

@Injectable()
export class PrismaService extends PrismaClient implements OnModuleInit {
  async onModuleInit() {
    await this.$connect();
  }
}

----------------------------------------

TITLE: ZenStack API Route Handler
DESCRIPTION: Implementation of the Next.js API route handler for ZenStack CRUD operations with authentication.

LANGUAGE: typescript
CODE:
import { NextRequestHandler } from '@zenstackhq/server/next';
import { enhance } from '@zenstackhq/runtime';
import type { NextApiRequest, NextApiResponse } from 'next';
import { getServerAuthSession } from '../../../server/auth';
import { prisma } from '../../../server/db';

async function getPrisma(req: NextApiRequest, res: NextApiResponse) {
    const session = await getServerAuthSession({ req, res });
    return enhance(prisma, { user: session?.user });
}

export default NextRequestHandler({ getPrisma });

----------------------------------------

TITLE: Polymorphic UI Component Implementation
DESCRIPTION: React component implementation for rendering different content types dynamically

LANGUAGE: tsx
CODE:
const PolymorphicContent = ({
  content,
}: {
  content: Content;
}) => {
  const Component = ContentComponents[content.contentType];
  return Component ? <Component content={content} /> : null;
};

----------------------------------------

TITLE: Installing ZenStack Server Package
DESCRIPTION: Command to install the ZenStack server package via npm

LANGUAGE: bash
CODE:
npm install @zenstackhq/server

----------------------------------------

TITLE: ZModel Plugin Configuration
DESCRIPTION: Shows how to configure a tRPC CRUD router plugin in ZModel

LANGUAGE: zmodel
CODE:
plugin trpc {
    provider = "@zenstackhq/trpc"
    output   = "src/generated"
}

----------------------------------------

TITLE: Defining Auth Type for Access Control
DESCRIPTION: This ZModel snippet defines an Auth type to represent the current user's authentication context, used in access control policies.

LANGUAGE: zmodel
CODE:
type Auth {
  // Current user's ID
  userId         String  @id

  // User's current organization ID
  currentOrgId   String?

  // User's role in the current organization
  currentOrgRole Role?

  @@auth
}

----------------------------------------

TITLE: Setting up tRPC Context
DESCRIPTION: TypeScript code for setting up tRPC context with enhanced Prisma client for access control

LANGUAGE: typescript
CODE:
import { enhance } from '@zenstackhq/runtime';
import { prisma } from './db';
import { getSessionUser } from './auth';

export const createContext = async ({ req, res }: CreateNextContextOptions) => {
    return {
        ...,
        // use access-control-enabled Prisma client
        prisma: await enhance(prisma, { user: getSessionUser(req, res) }),
    };
};

----------------------------------------

TITLE: Setting up tRPC Context
DESCRIPTION: TypeScript code for setting up tRPC context with enhanced Prisma client for access control

LANGUAGE: typescript
CODE:
import { enhance } from '@zenstackhq/runtime';
import { prisma } from './db';
import { getSessionUser } from './auth';

export const createContext = async ({ req, res }: CreateNextContextOptions) => {
    return {
        ...,
        // use access-control-enabled Prisma client
        prisma: await enhance(prisma, { user: getSessionUser(req, res) }),
    };
};

----------------------------------------

TITLE: Setting up tRPC Context
DESCRIPTION: TypeScript code for creating tRPC context with enhanced Prisma client for access control

LANGUAGE: typescript
CODE:
import { enhance } from '@zenstackhq/runtime';
import { prisma } from './db';
import { getSessionUser } from './auth';

export const createContext = async ({ req, res }: CreateNextContextOptions) => {
    return {
        ...,
        // use access-control-enabled Prisma client
        prisma: await enhance(prisma, { user: getSessionUser(req, res) }),
    };
};

----------------------------------------

TITLE: Deploying RedwoodJS with ZenStack to Vercel
DESCRIPTION: Deployment command for a RedwoodJS project using ZenStack, specifically for deploying to Vercel.

LANGUAGE: bash
CODE:
yarn rw @zenstackhq generate && yarn rw deploy vercel

----------------------------------------

TITLE: Implementing User Authentication with Prisma
DESCRIPTION: Replaces the content of db.ts to use Prisma for user creation and retrieval in authentication flow.

LANGUAGE: typescript
CODE:
import type { User } from '@prisma/client';
import { prisma } from '~/server/prisma';

export async function findUserByEmail(email: string) {
    return prisma.user.findUnique({ where: { email } });
}

export async function createUser(user: Omit<User, 'id'>) {
    return prisma.user.create({
        data: user,
    });
}

----------------------------------------

TITLE: Querying Data with ZenStack REPL
DESCRIPTION: JavaScript commands to query data using the ZenStack REPL, demonstrating how to retrieve user and space information.

LANGUAGE: javascript
CODE:
prisma.user.findFirst()

LANGUAGE: javascript
CODE:
prisma.space.findFirst({ include: { members: true } })

----------------------------------------

TITLE: Revoking Supabase Anonymous Privileges
DESCRIPTION: SQL commands to revoke current and default privileges from the anonymous role in Supabase.

LANGUAGE: sql
CODE:
-- Revoke current privileges
REVOKE SELECT ON ALL TABLES IN SCHEMA public FROM anon;
REVOKE USAGE ON ALL SEQUENCES IN SCHEMA public FROM anon;
REVOKE EXECUTE ON ALL FUNCTIONS IN SCHEMA public FROM anon;

-- Revoke default privileges for future objects
ALTER DEFAULT PRIVILEGES IN SCHEMA public REVOKE ALL ON TABLES FROM anon;
ALTER DEFAULT PRIVILEGES IN SCHEMA public REVOKE ALL ON FUNCTIONS FROM anon;
ALTER DEFAULT PRIVILEGES IN SCHEMA public REVOKE ALL ON SEQUENCES FROM anon;

----------------------------------------

TITLE: Implementing Postgres Row-Level Security Policies
DESCRIPTION: Example of creating RLS policies in Postgres to control access to blog posts. Shows how to set up owner-specific access and public read access for published posts.

LANGUAGE: sql
CODE:
-- Simple RLS for blog posts

-- owner has full access to her own posts
CREATE POLICY post_owner_policy ON post
    USING (owner = current_user);

-- all users can read published posts
CREATE POLICY post_read_policy ON post FOR SELECT
    USING (published = true);

----------------------------------------

TITLE: Creating Express Project with Prisma
DESCRIPTION: Initial setup commands to create a new Express.js project using Prisma's example template

LANGUAGE: bash
CODE:
npx degit prisma/prisma-examples/typescript/rest-express my-blog-app
cd my-blog-app
npm install

----------------------------------------

TITLE: Querying Data with ZenStack REPL
DESCRIPTION: JavaScript commands to query data using the ZenStack REPL, demonstrating how to retrieve user and space information.

LANGUAGE: javascript
CODE:
prisma.user.findFirst()

LANGUAGE: javascript
CODE:
prisma.space.findFirst({ include: { members: true } })

----------------------------------------

TITLE: Enabling Debug Logging in ZenStack
DESCRIPTION: Shows how to enable debug logging when creating an enhanced PrismaClient instance. This allows viewing the queries that ZenStack injects for access policy enforcement.

LANGUAGE: typescript
CODE:
const db = enhance(prisma, { user }, { logPrismaQuery: true })

----------------------------------------

TITLE: Enabling Debug Logging in ZenStack
DESCRIPTION: Shows how to enable debug logging when creating an enhanced PrismaClient instance. This allows viewing the queries that ZenStack injects for access policy enforcement.

LANGUAGE: typescript
CODE:
const db = enhance(prisma, { user }, { logPrismaQuery: true })

----------------------------------------

TITLE: Generating ZenStack schema and client in RedwoodJS
DESCRIPTION: Command to regenerate the Prisma schema, PrismaClient, and supporting modules for access policy enforcement in a RedwoodJS project using ZenStack.

LANGUAGE: bash
CODE:
yarn rw @zenstackhq generate

----------------------------------------

TITLE: Serving OpenAPI Spec with Swagger UI in Express
DESCRIPTION: TypeScript code to integrate Swagger UI into an Express application, serving the generated OpenAPI specification.

LANGUAGE: typescript
CODE:
import swaggerUI from 'swagger-ui-express';
app.use(
    '/api/docs',
    swaggerUI.serve,
    swaggerUI.setup(require('./todo-api.json'))
);

----------------------------------------

TITLE: Configuring Build Script for Vercel Deployment with ZenStack
DESCRIPTION: This snippet shows how to set up a build script in package.json for deploying a ZenStack-enhanced Next.js application to Vercel. It includes running ZenStack generate, Next.js build, and Prisma migrations.

LANGUAGE: json
CODE:
{
  "scripts": {
    "vercel-build": "zenstack generate && next build && prisma migrate deploy"
  }
}

----------------------------------------

TITLE: Installing ZenStack Server Package for SvelteKit
DESCRIPTION: Command to install the ZenStack server package using npm.

LANGUAGE: bash
CODE:
npm install @zenstackhq/server

----------------------------------------

TITLE: Creating User with Password in ZenStack
DESCRIPTION: Example of creating a new user with a password using ZenStack's enhanced Prisma client.

LANGUAGE: javascript
CODE:
db.user.create({ data: { email: 'ross@zenstack.dev', password: 'abc123' }})

----------------------------------------

TITLE: Integrating Third-Party Models in ZenStack
DESCRIPTION: This code snippet illustrates how ZenStack can potentially standardize the integration of third-party services by representing their data models as part of the application's schema. It includes examples for NextAuth, PayPal, and Shopify.

LANGUAGE: zmodel
CODE:
// nextauth
model Account {
    id                String  @id @default(cuid())
    userId            String
    type              String
    provider          String
    providerAccountId String
    refresh_token     String? // @db.Text
    access_token      String? // @db.Text
    expires_at        Int?
    token_type        String?
    scope             String?
    id_token          String? // @db.Text
    session_state     String?
    user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)
    @@unique([provider, providerAccountId])
}

// paypal
model Payment {
    id      Int    @id @default(autoincrement())
    orderID String
    status  String
}

// shopify
model Order{
    id                   Int    @id
    billing_address      Address
    cart_token           String
    checkout_token       String
    client_details       ClientDetail
    current_total_price  Int
}

----------------------------------------

TITLE: Sample Debug Output
DESCRIPTION: Shows an example of the debug output format when inspecting a findMany query with policy rules.

LANGUAGE: javascript
CODE:
prisma:info [policy] `findMany` list:
{
  where: {
    AND: [
      { NOT: { OR: [] } },
      {
        OR: [
          { owner: { is: { id: 1 } } },
          {
            AND: [
              {
                space: {
                  members: {
                    some: { user: { is: { id: 1 } } }
                  }
                }
              },
              { NOT: { private: true } }
            ]
          }
        ]
      }
    ]
  }
}

----------------------------------------

TITLE: Configuring @core/prisma Plugin in ZModel
DESCRIPTION: Example of how to configure the @core/prisma plugin in a ZModel schema file. This snippet demonstrates setting custom output path for the generated Prisma schema.

LANGUAGE: zmodel
CODE:
plugin prisma {
    provider = '@core/prisma'
    output = './src/prisma/schema.prisma'
}

----------------------------------------

TITLE: Sample Debug Output
DESCRIPTION: Shows an example of the debug output format when inspecting a findMany query with policy rules.

LANGUAGE: javascript
CODE:
prisma:info [policy] `findMany` list:
{
  where: {
    AND: [
      { NOT: { OR: [] } },
      {
        OR: [
          { owner: { is: { id: 1 } } },
          {
            AND: [
              {
                space: {
                  members: {
                    some: { user: { is: { id: 1 } } }
                  }
                }
              },
              { NOT: { private: true } }
            ]
          }
        ]
      }
    ]
  }
}

----------------------------------------

TITLE: Querying full List object using cURL
DESCRIPTION: This cURL command sends a request to find the first List with all fields included. The response will include non-JSON-serializable fields like dates.

LANGUAGE: bash
CODE:
curl "http://localhost:3000/api/rpc/list/findFirst" -H "x-user-id: 1"

----------------------------------------

TITLE: Permission Checking Implementation - TypeScript
DESCRIPTION: Example showing how to use the new permission checker API to verify user access rights without executing database operations

LANGUAGE: typescript
CODE:
const db = enhance(prisma, { user: getCurrentUser() });

// check if the current user can read published posts
await canRead = await db.post.check({
  operation: 'read',
  where: { published: true }
});

----------------------------------------

TITLE: Initializing ZenStack Project with Custom Prisma Schema Location
DESCRIPTION: Initialize a ZenStack project specifying a non-standard location for the Prisma schema file using the '--prisma' option.

LANGUAGE: bash
CODE:
npx zenstack@latest init --prisma prisma/my.schema

----------------------------------------

TITLE: ZenStack User Model Schema
DESCRIPTION: Define the User model with authentication and access policies using ZenStack schema

LANGUAGE: zmodel
CODE:
model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime?
  password      String @password @omit
  image         String?
  accounts      Account[]
  sessions      Session[]
  posts         Post[]

  @@allow('create,read', true)
  @@allow('update,delete', auth() == this)
}

----------------------------------------

TITLE: Enabling Optimistic Updates in ZenStack Hooks
DESCRIPTION: Code snippets showing how to enable optimistic updates in ZenStack hooks for creating, updating, and deleting Todos. These modifications improve UI responsiveness by updating the interface before server confirmation.

LANGUAGE: tsx
CODE:
const { mutate: create } = useCreateTodo({ optimisticUpdate: true });
const update = useUpdateTodo({ optimisticUpdate: true });
const del = useDeleteTodo({ optimisticUpdate: true });

----------------------------------------

TITLE: Using Strongly-Typed JSON Fields in ZModel Data Models
DESCRIPTION: This snippet shows how to use custom types to define strongly-typed JSON fields in data models using the @json attribute.

LANGUAGE: zmodel
CODE:
model User {
  id String @id @default(cuid())
  profile Profile @json

  @@allow('all', true)
}

----------------------------------------

TITLE: Testing Authorization Rules in ZenStack REPL
DESCRIPTION: Example of testing the implemented authorization rules using ZenStack REPL with user authentication

LANGUAGE: js
CODE:
.auth { id: 1 }
db.list.findMany()

----------------------------------------

TITLE: Querying and Manipulating Data with ZenStack RPC API
DESCRIPTION: This snippet demonstrates various operations using the ZenStack RPC API, including finding all posts, querying with filters, including related data, creating, updating, and deleting posts. It showcases the API's alignment with Prisma's query syntax.

LANGUAGE: typescript
CODE:
// find all posts
GET /api/model/post/findMany
=> [{ id: 1, title: 'Hello World', ... }, ...}]

// find all published posts, the "q" parameter is `{"where":{"published":true}}` url-encoded
GET /api/model/post/findMany?q=%7B%22where%22%3A%7B%22published%22%3Atrue%7D%7D
=> [{ id: 1, title: 'Hello World', ... }, ...}]

// find all posts with their authors, the "q" parameter is `{"include":{"author":true}}` url-encoded
GET /api/model/post/findMany?q=%7B%22include%22%3A%7B%22author%22%3Atrue%7D%7D
=> [{ id: 1, title: 'Hello World', author: { id: 1, name: 'Joey', ... } }, ...}]

// create a post for user#1
POST /api/model/post/create
{
    "data": {
        "title": "Hello World",
        "author": { "connect": { "id": 1 } }
    }
}

// update a post
POST /api/model/post/update
{
    "where": { "id": 1 },
    "data": { "title": "Hello New World!" }
}

// delete a post
DELETE /api/model/post/delete
{
    "where": { "id": 1 }
}

----------------------------------------

TITLE: NextAuth Configuration Setup
DESCRIPTION: Configuration for NextAuth authentication including Prisma adapter and credentials provider.

LANGUAGE: typescript
CODE:
import NextAuth, { type NextAuthOptions } from 'next-auth';
import { PrismaAdapter } from '@next-auth/prisma-adapter';
import CredentialsProvider from 'next-auth/providers/credentials';
import { prisma } from '../../../server/db';
import type { PrismaClient } from '@prisma/client';

export const authOptions: NextAuthOptions = {
  ...
  adapter: PrismaAdapter(prisma),
  providers: [
    CredentialsProvider({
      credentials: {
        email: { type: 'email'},
        password: { type: 'password' },
      },
      authorize: authorize(prisma),
    }),
  ],
};

function authorize(prisma: PrismaClient) {
  return async (
    credentials: Record<'email' | 'password', string> | undefined
  ) => {
    // verify email password against database
    ..
  };
}

export default NextAuth(authOptions);

----------------------------------------

TITLE: Testing Authorization Rules in ZenStack REPL
DESCRIPTION: Example of testing the implemented authorization rules using ZenStack REPL with user authentication

LANGUAGE: js
CODE:
.auth { id: 1 }
db.list.findMany()

----------------------------------------

TITLE: Querying Full List Object with Curl in Bash
DESCRIPTION: This bash snippet demonstrates how to make an HTTP request to retrieve the full List object using curl.

LANGUAGE: bash
CODE:
curl "http://localhost:3000/api/rpc/list/findFirst" -H "x-user-id: 1"

----------------------------------------

TITLE: Creating Todo Component with ZenStack Hooks
DESCRIPTION: A React component for managing individual Todo items with update and delete functionality. Uses ZenStack-generated hooks for data mutations and includes UI elements for toggling completion status and deletion.

LANGUAGE: tsx
CODE:
import type { Todo } from "@prisma/client";
import { useDeleteTodo, useUpdateTodo } from "~/lib/hooks";

type Props = {
  value: Todo;
  optimistic?: boolean;
};

export default function TodoComponent({ value, optimistic }: Props) {
  const update = useUpdateTodo();
  const del = useDeleteTodo();

  function onDelete() {
    del.mutate({ where: { id: value.id } });
  }

  function onToggleCompleted(completed: boolean) {
    if (completed === !!value.completedAt) {
      return;
    }
    update.mutate({
      where: { id: value.id },
      data: { completedAt: completed ? new Date() : null },
    });
  }

  return (
    <div className="flex w-96 flex-col items-center rounded-lg border px-8 py-4">
      <div className="flex w-full justify-between">
        <h3
          className={`flex items-center text-xl
                        ${value.completedAt
                            ? "italic text-gray-400 line-through"
                            : "text-gray-700"
                        }}`}
        >
          {value.title}
          {optimistic && (
            <span className="loading loading-spinner loading-sm ml-1"></span>
          )}
        </h3>
        <div className="flex">
          <input
            type="checkbox"
            className="checkbox mr-2"
            checked={!!value.completedAt}
            onChange={(e) => onToggleCompleted(e.currentTarget.checked)}
          />
          <button className="btn btn-ghost btn-xs" onClick={onDelete}>
            Delete
          </button>
        </div>
      </div>
    </div>
  );

----------------------------------------

TITLE: Configuring OpenAPI Plugin in ZModel
DESCRIPTION: ZModel configuration to add the OpenAPI plugin, specifying output file, API title, version, and flavor.

LANGUAGE: zmodel
CODE:
plugin openapi {
    provider = "@zenstackhq/openapi"
    output = "todo-api.json"
    title = "My Todo API"
    version = "1.0.0"
    flavor = "rpc"
}

----------------------------------------

TITLE: NextAuth Configuration with Credentials
DESCRIPTION: Configure NextAuth to use credential-based authentication with JWT sessions

LANGUAGE: typescript
CODE:
import { PrismaAdapter } from "@auth/prisma-adapter";
import type { PrismaClient } from "@prisma/client";
import { compare } from "bcryptjs";
import {
  getServerSession,
  type DefaultSession,
  type NextAuthOptions,
} from "next-auth";
import { type Adapter } from "next-auth/adapters";
import CredentialsProvider from "next-auth/providers/credentials";

import { db } from "~/server/db";

declare module "next-auth" {
  interface Session extends DefaultSession {
    user: {
      id: string;
    } & DefaultSession["user"];
  }
}

export const authOptions: NextAuthOptions = {
  session: {
    strategy: "jwt",
  },
  callbacks: {
    session({ session, token }) {
      if (session.user) {
        session.user.id = token.sub!;
      }
      return session;
    },
  },
  adapter: PrismaAdapter(db) as Adapter,
  providers: [
    CredentialsProvider({
      credentials: {
        email: { type: "email" },
        password: { type: "password" },
      },
      authorize: authorize(db),
    }),
  ],
};

function authorize(prisma: PrismaClient) {
  return async (
    credentials: Record<"email" | "password", string> | undefined,
  ) => {
    if (!credentials) throw new Error("Missing credentials");
    if (!credentials.email)
      throw new Error('"email" is required in credentials');
    if (!credentials.password)
      throw new Error('"password" is required in credentials');
    const maybeUser = await prisma.user.findFirst({
      where: { email: credentials.email },
      select: { id: true, email: true, password: true },
    });
    if (!maybeUser?.password) return null;
    const isValid = await compare(credentials.password, maybeUser.password);
    if (!isValid) return null;
    return { id: maybeUser.id, email: maybeUser.email };
  };
};

export const getServerAuthSession = () => getServerSession(authOptions);

----------------------------------------

TITLE: Using Generated TypeScript Types for JSON Fields
DESCRIPTION: This snippet demonstrates how to import and use the TypeScript types generated by ZenStack for custom JSON field types.

LANGUAGE: typescript
CODE:
import type { Profile } from '@zenstackhq/runtime/models';

const profile: Profile = {
  name: 'Alice',
  age: 30,
  address: { state: 'WA', city: 'Seattle', zip: '98019' }
};

----------------------------------------

TITLE: Implementing Access Control Policies for List Model
DESCRIPTION: This ZModel snippet demonstrates how to define access control policies for the List model using ZenStack's @@allow and @@deny attributes.

LANGUAGE: zmodel
CODE:
model List {
  ...

  // deny anonymous access
  @@deny('all', auth() == null)

  // tenant segregation: deny access if the user's current org doesn't match
  @@deny('all', auth().currentOrgId != orgId)

  // owner/admin has full access
  @@allow('all', auth().userId == ownerId || auth().currentOrgRole == 'org:admin')

  // can be read by org members if not private
  @@allow('read', !private)

  // when create, owner must be set to current user
  @@allow('create', ownerId == auth().userId)
}

----------------------------------------

TITLE: Accessing Custom Attributes in Prisma Generator
DESCRIPTION: This TypeScript code demonstrates how to access custom attributes defined in comments within a Prisma generator.

LANGUAGE: typescript
CODE:
const userModel = datamodel.models.find((model) => model.name === 'User');
console.log(`user model attribute: ${userModel?.documentation}`);

const emailField = userModel?.fields.find((field) => field.name === 'email');
console.log(`email field attribute: ${emailField?.documentation}`);

const passwordField = userModel?.fields.find((field) => field.name === 'password');
console.log(`password field attribute: ${passwordField?.documentation}`);

----------------------------------------

TITLE: Using auth() in @default() Attribute
DESCRIPTION: This snippet shows how to use the auth() function in the @default() attribute to automatically set the owner of a resource to the current user.

LANGUAGE: zmodel
CODE:
model Resource {
    ...
    owner User @relation(fields: [ownerId], references: [id])
    ownerId Int @default(auth().id)

    @@allow('create', owner == auth())
}

----------------------------------------

TITLE: Initializing RESTful API Handler for SvelteKit
DESCRIPTION: Configures the RESTful API handler for a SvelteKit application in the server hooks file.

LANGUAGE: typescript
CODE:
import { SvelteKitHandler } from '@zenstackhq/server/sveltekit';
import { RestApiHandler } from '@zenstackhq/server/api';
import { getPrisma } from './lib/db';

export const handle = SvelteKitHandler({
    prefix: '/api/model',
    getPrisma,
    handler: RestApiHandler({ endpoint: 'http://myhost/api/model' })
});

----------------------------------------

TITLE: Using auth() in @default() Attribute
DESCRIPTION: This snippet shows how to use the auth() function in the @default() attribute to automatically set the owner of a resource to the current user.

LANGUAGE: zmodel
CODE:
model Resource {
    ...
    owner User @relation(fields: [ownerId], references: [id])
    ownerId Int @default(auth().id)

    @@allow('create', owner == auth())
}

----------------------------------------

TITLE: Cloning and Checking Out Sample Project in Bash
DESCRIPTION: Command to clone the sample Todo project repository and check out the 'part2' branch, which serves as the starting point for this guide.

LANGUAGE: bash
CODE:
git clone --branch part2 https://github.com/zenstackhq/the-complete-guide-sample.git my-todo-app

----------------------------------------

TITLE: ZModel Inheritance Example - Base Model
DESCRIPTION: Shows how to create an abstract base model with common fields and access policies

LANGUAGE: zmodel
CODE:
abstract model Base {
    id Int @id @default(autoincrement())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt()
    published Boolean @default(true)

    // author has full access
    @@allow('all', auth() != null && published)
}

----------------------------------------

TITLE: Creating Express.js Project with Prisma
DESCRIPTION: Commands to create a new Express.js project using Prisma's sample project, initialize the database, and start the development server.

LANGUAGE: bash
CODE:
npx degit prisma/prisma-examples/typescript/rest-express my-blog-app
cd my-blog-app
npm install

npx prisma db push
npx prisma db seed
npm run dev

----------------------------------------

TITLE: Configuring tRPC v10 Plugin
DESCRIPTION: ZModel configuration for tRPC v10 router generation

LANGUAGE: zmodel
CODE:
plugin trpc {
    provider = '@zenstackhq/trpc'
    output = 'src/server/routers/generated'
}

----------------------------------------

TITLE: Model Inheritance Example
DESCRIPTION: Shows how to use model inheritance with abstract base models.

LANGUAGE: zmodel
CODE:
abstract model Basic {
    id String @id
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

model User extends Basic {
    name String 
}

----------------------------------------

TITLE: Project Directory Structure
DESCRIPTION: Example of a monorepo project structure showing the placement of node_modules and package configuration files.

LANGUAGE: bash
CODE:
▸ apps
▾ common
    package.json
  ▾ node_modules
    ▸ zenstack
    ▸ @zenstackhq/runtime
    ...
pnpm-workspace.yaml
pnpm-lock.yaml

----------------------------------------

TITLE: Generated Prisma Schema Output
DESCRIPTION: Shows the resulting Prisma schema after processing the abstract model inheritance. Demonstrates how the abstract model fields are merged into concrete models.

LANGUAGE: zmodel
CODE:
/// @@allow('all', auth() != null && published)
model User {
    name String
    id Int @id() @default(autoincrement())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt()
    published Boolean @default(true)
}

/// @@allow('all', auth() != null && published)
model Post {
    title String
    content String?
    viewCount Int @default(0)
    comment Comment[]
    id Int @id() @default(autoincrement())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt()
    published Boolean @default(true)
}

/// @@allow('all', auth() != null && published)
model Comment {
    content String
    post Post @relation(fields: [postId], references: [id])
    postId Int
    id Int @id() @default(autoincrement())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt()
    published Boolean @default(true)
}

----------------------------------------

TITLE: Generated Prisma Schema Output
DESCRIPTION: Shows the resulting Prisma schema after processing the abstract model inheritance. Demonstrates how the abstract model fields are merged into concrete models.

LANGUAGE: zmodel
CODE:
/// @@allow('all', auth() != null && published)
model User {
    name String
    id Int @id() @default(autoincrement())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt()
    published Boolean @default(true)
}

/// @@allow('all', auth() != null && published)
model Post {
    title String
    content String?
    viewCount Int @default(0)
    comment Comment[]
    id Int @id() @default(autoincrement())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt()
    published Boolean @default(true)
}

/// @@allow('all', auth() != null && published)
model Comment {
    content String
    post Post @relation(fields: [postId], references: [id])
    postId Int
    id Int @id() @default(autoincrement())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt()
    published Boolean @default(true)
}

----------------------------------------

TITLE: Cloning ZenStack Sample Project with Git
DESCRIPTION: Command to clone the completed sample project from the 'part1' branch of the ZenStack guide repository. This provides access to the implementation examples discussed throughout the guide.

LANGUAGE: bash
CODE:
git clone --branch part1 https://github.com/zenstackhq/the-complete-guide-sample.git my-todo-app

----------------------------------------

TITLE: Configuring Seed Script in package.json
DESCRIPTION: JSON configuration to add the seed script to package.json for Prisma seeding.

LANGUAGE: json
CODE:
{
    "prisma": {
        "seed": "ts-node prisma/seed.ts"
    }
}

----------------------------------------

TITLE: Pushing Schema to Database
DESCRIPTION: Command to push the generated Prisma schema to the database.

LANGUAGE: bash
CODE:
npx prisma db push

----------------------------------------

TITLE: Pushing Schema to Database
DESCRIPTION: Command to push the generated Prisma schema to the database.

LANGUAGE: bash
CODE:
npx prisma db push

----------------------------------------

TITLE: Defining Blog Post Model Schema
DESCRIPTION: ZModel schema definition for Post model with access control policies using @@allow attributes

LANGUAGE: zmodel
CODE:
model Post {
  id String @id @default(cuid())
  title String
  body String
  published Boolean @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user User @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  userId String

  @@allow('all', auth() == user)
  @@allow('read', auth() != null && published)
}

----------------------------------------

TITLE: Importing ZenStack Enhance API from Generated Modules
DESCRIPTION: This code snippet shows how to import the ZenStack enhance API directly from the pre-generated modules in the source tree, avoiding the need to run zenstack generate during deployment.

LANGUAGE: typescript
CODE:
import { enhance } from './zenstack/enhance';

----------------------------------------

TITLE: Serving OpenAPI Spec with Swagger UI in Express
DESCRIPTION: Configure the Express application to serve the generated OpenAPI specification using Swagger UI.

LANGUAGE: typescript
CODE:
import swaggerUI from 'swagger-ui-express';
app.use(
    '/api/docs',
    swaggerUI.serve,
    swaggerUI.setup(require('./todo-api.json'))
);

----------------------------------------

TITLE: Scaffolding Remix Project with Indie Stack
DESCRIPTION: Commands to create a new Remix project using the indie-stack template with TypeScript and SQLite database

LANGUAGE: bash
CODE:
npx create-remix@latest --template remix-run/indie-stack cal-com-clone

----------------------------------------

TITLE: Querying and Manipulating Data with ZenStack RESTful API
DESCRIPTION: This snippet demonstrates various HTTP requests to interact with the ZenStack RESTful API. It includes examples of GET requests for retrieving posts with filtering and including related data, as well as POST, PATCH, and DELETE requests for creating, updating, and deleting posts.

LANGUAGE: typescript
CODE:
// find all posts
GET /api/model/post
=> 
{
    "jsonapi": { "version": "1.0" },
    "data": [
        { "type": "post", "id": "1", "attributes": { "title": "Hello World", ... }, ... },
        ...
    ],
    ...
}

// find all published posts
GET /api/model/post?filter[published]=true
=>
{
    "jsonapi": { "version": "1.0" },
    "data": [
        { "type": "post", "id": "1", "attributes": { "title": "Hello World", ... }, ... },
        ...
    ],
    ...
}

// find all posts with their authors
GET /api/model/post?include=author
=>
{
    "jsonapi": { "version": "1.0" },
    "data": [
        { 
            "type": "post", 
            "id": "1", 
            "attributes": { "title": "Hello World", ... },
            "relationships": {
                "author": { "data": { "type": "user", "id": "1" } }
            }
        },
        ...
    ],
    "included": [
        { "type": "user", "id": "1", "attributes": { "name": "Joey", ... } },
        ...
    ],
    ...
}

// create a post for user#1
POST /api/model/post
{
    "data": {
        "type": "post",
        "attributes": {
            "title": "Hello World"
        },
        "relationships": {
            "author": { "data": { "type": "user", "id": "1" } }
        }
    }
}

// update a post
PATCH /api/model/post/1
{
    "data": {
        "type": "post",
        "id": "1",
        "attributes": {
            "title": "Hello New World!"
        }
    }
}

// delete a post
DELETE /api/model/post/1

----------------------------------------

TITLE: Defining Blog Post Schema with Access Control
DESCRIPTION: ZModel schema definition for Post model including access control rules using @@allow attributes.

LANGUAGE: zmodel
CODE:
model Post {
  id String @id @default(cuid())
  title String
  body String
  published Boolean @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  user User @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  userId String @default(auth().id)

  @@allow('all', auth() == user)
  @@allow('read', auth() != null && published)
}

----------------------------------------

TITLE: Querying and Manipulating Data with ZenStack RESTful API
DESCRIPTION: This snippet demonstrates various HTTP requests to interact with the ZenStack RESTful API. It includes examples of GET requests for retrieving posts with filtering and including related data, as well as POST, PATCH, and DELETE requests for creating, updating, and deleting posts.

LANGUAGE: typescript
CODE:
// find all posts
GET /api/model/post
=> 
{
    "jsonapi": { "version": "1.0" },
    "data": [
        { "type": "post", "id": "1", "attributes": { "title": "Hello World", ... }, ... },
        ...
    ],
    ...
}

// find all published posts
GET /api/model/post?filter[published]=true
=>
{
    "jsonapi": { "version": "1.0" },
    "data": [
        { "type": "post", "id": "1", "attributes": { "title": "Hello World", ... }, ... },
        ...
    ],
    ...
}

// find all posts with their authors
GET /api/model/post?include=author
=>
{
    "jsonapi": { "version": "1.0" },
    "data": [
        { 
            "type": "post", 
            "id": "1", 
            "attributes": { "title": "Hello World", ... },
            "relationships": {
                "author": { "data": { "type": "user", "id": "1" } }
            }
        },
        ...
    ],
    "included": [
        { "type": "user", "id": "1", "attributes": { "name": "Joey", ... } },
        ...
    ],
    ...
}

// create a post for user#1
POST /api/model/post
{
    "data": {
        "type": "post",
        "attributes": {
            "title": "Hello World"
        },
        "relationships": {
            "author": { "data": { "type": "user", "id": "1" } }
        }
    }
}

// update a post
PATCH /api/model/post/1
{
    "data": {
        "type": "post",
        "id": "1",
        "attributes": {
            "title": "Hello New World!"
        }
    }
}

// delete a post
DELETE /api/model/post/1

----------------------------------------

TITLE: Cloning ZenStack Sample Project
DESCRIPTION: Command to clone the completed sample project from the 'v1-part1' branch of the ZenStack guide repository

LANGUAGE: bash
CODE:
git clone --branch v1-part1 https://github.com/zenstackhq/the-complete-guide-sample.git my-todo-app

----------------------------------------

TITLE: Installing ZenStack Plugin using NPM
DESCRIPTION: Demonstrates how to install a ZenStack plugin (OpenAPI in this example) as a development dependency using npm.

LANGUAGE: bash
CODE:
npm install --save-dev @zenstackhq/openapi

----------------------------------------

TITLE: Cloning ZenStack Tutorial Sample Repository
DESCRIPTION: Command to clone the sample project repository and checkout the part3 branch containing the completed code for the API generation section.

LANGUAGE: bash
CODE:
git clone --branch part3 https://github.com/zenstackhq/the-complete-guide-sample.git my-todo-app

----------------------------------------

TITLE: Using Generated Hooks for Data Access
DESCRIPTION: React component example showing how to use generated hooks to fetch and display posts with type-safe queries

LANGUAGE: typescript
CODE:
import { usePost } from '../lib/hooks';

const Posts: FC = () => {
    const { findMany } = usePost();

    const posts = findMany({
        where: { published: false },
        include: { author: true },
        orderBy: { updatedAt: 'desc' },
    });

    return (
        <ul>
            {posts.map((post) => (
                <li key={post.id}>
                    {post.title} by {post.author.e}
                </li>
            ))}
        </ul>
    );
};

----------------------------------------

TITLE: Defining User Model with Omitted Password in ZModel
DESCRIPTION: This snippet demonstrates how to use the @omit attribute to exclude the password field from query results.

LANGUAGE: zmodel
CODE:
model User {
    ...
    password String? @password @omit
}

----------------------------------------

TITLE: Installing Extensions to Enhanced Prisma Client in TypeScript
DESCRIPTION: This snippet demonstrates how to install extensions to an already enhanced Prisma Client, a feature available since v2.9.0. It adds a 'getFeeds' method to the 'post' model after enhancing the Prisma Client with ZenStack.

LANGUAGE: typescript
CODE:
const db = enhance(prisma);
const extended = db.$extends({
  model: {
    post: {
      async getFeeds() {
          const context = Prisma.getExtensionContext(this);
          return context.findMany();
      },
    },
  },
});

const feeds = await extended.post.getFeeds();
// `feeds` will only contain published posts

----------------------------------------

TITLE: Prisma Schema Definition
DESCRIPTION: Data model definition for User and Post entities with SQLite database configuration.

LANGUAGE: zmodel
CODE:
datasource db {
  provider = "sqlite"
  url = "file:./dev.db"
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id Int @id() @default(autoincrement())
  name String
  posts Post[]
}

model Post {
  id Int @id() @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt()
  title String
  published Boolean @default(false)
  author User @relation(fields: [authorId], references: [id])
  authorId Int @default(auth().id)
}

----------------------------------------

TITLE: Edge Runtime Error Messages
DESCRIPTION: Collection of common error messages encountered in Vercel edge runtime.

LANGUAGE: plaintext
CODE:
Compiler edge-server unexpectedly exited with code: null and signal: SIGTERM

----------------------------------------

TITLE: Adding SelectedTeamSwitcher Component in Next.js Layout
DESCRIPTION: This snippet shows how to integrate StackAuth's SelectedTeamSwitcher component into the Next.js layout for team management UI.

LANGUAGE: tsx
CODE:
import { SelectedTeamSwitcher } from "@stackframe/stack";
...

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en">
      <body>
        <StackProvider app={stackServerApp}>
          <StackTheme>
            <header>
              <SelectedTeamSwitcher />
            </header>
            <main>{children}</main>
          </StackTheme>
        </StackProvider>
      </body>
    </html>
  );
}

----------------------------------------

TITLE: Installing ZenStack Using Init Command
DESCRIPTION: Initialize ZenStack in an existing TypeScript project using the npx command.

LANGUAGE: bash
CODE:
npx zenstack@1 init

----------------------------------------

TITLE: ZenStack Schema Definition
DESCRIPTION: ZenStack schema example showing how to define access control rules within the data model.

LANGUAGE: zmodel
CODE:
model User {
  ...
  groups Group[]
}

model Group {
  ...
  members User[]
}

model AccessControlList {
  user User?
  userId Int?
  group Group?
  groupId Int?
  article Article?
  articleId Int?
}

model Article {
  accessList AccessControlList[]

  @@allow('read', 
    accessList?[
      user == auth() 
      || accessList?[user.groups?[members?[id == auth().id]]]]
  )
}

----------------------------------------

TITLE: Generating Schema and Starting REPL in Bash
DESCRIPTION: These Bash commands regenerate the schema, push database changes, and start the REPL for testing the new model.

LANGUAGE: bash
CODE:
npx zenstack generate
npx prisma db push
npx zenstack repl

----------------------------------------

TITLE: Initializing ZenStack in SvelteKit Project
DESCRIPTION: Command to initialize ZenStack in the SvelteKit project, preparing it for use with ZenStack features.

LANGUAGE: bash
CODE:
npx zenstack@latest init

----------------------------------------

TITLE: Building CRUD UI with React-Admin
DESCRIPTION: This code snippet demonstrates how to create a CRUD UI for users and posts using React-Admin components, including list views, create forms, and edit forms.

LANGUAGE: typescript
CODE:
const AdminApp = () => (
  <Admin dataProvider={dataProvider} authProvider={authProvider}>
    <Resource
      name="user"
      list={ListGuesser}
      edit={EditGuesser}
      create={UserCreate}
      hasCreate={true}
      recordRepresentation="name"
    />
    <Resource
      name="post"
      list={PostList}
      edit={EditGuesser}
      create={PostCreate}
      hasCreate={true}
      recordRepresentation="title"
    />
  </Admin>
);

export const UserCreate = () => (
  <Create>
    <SimpleForm>
      <TextInput source="email" type="email" validate={required()} />
      <PasswordInput source="password" validate={required()} />
      <TextInput source="name" validate={required()} />
      <SelectInput
        source="role"
        choices={[
          { id: "Author", name: "Author" },
          { id: "Editor", name: "Editor" },
          { id: "Admin", name: "Admin" },
        ]}
        defaultValue={"Author"}
      />
    </SimpleForm>
  </Create>
);

const PostList = () => (
  <List>
    <Datagrid rowClick="edit">
      <TextField source="id" />
      <TextField source="title" />
      <TextField source="content" />
      <DateField source="createdAt" />
      <DateField source="updatedAt" />
      <ReferenceField source="userId" reference="user" />
    </Datagrid>
  </List>
);

export const PostCreate = () => (
  <Create>
    <SimpleForm>
      <ReferenceInput source="userId" reference="user">
        <SelectInput />
      </ReferenceInput>
      <TextInput source="title" validate={required()} />
      <TextInput source="content" multiline rows={5} validate={required()} />
      <SelectInput
        source="status"
        choices={[
          { id: "Draft", name: "Draft" },
          { id: "Submitted", name: "Submitted" },
          { id: "Published", name: "Published" },
        ]}
        defaultValue={"Draft"}
      />
    </SimpleForm>
  </Create>
);

export default AdminApp;

----------------------------------------

TITLE: Initializing ZenStack Project with Specific Package Manager
DESCRIPTION: Initialize a ZenStack project explicitly specifying the package manager to use with the '--package-manager' option.

LANGUAGE: bash
CODE:
npx zenstack@latest init --package-manager pnpm

----------------------------------------

TITLE: Querying User with Nested Posts in TypeScript
DESCRIPTION: Demonstrates a TypeScript query using useFindUniqueUser to fetch a user with their associated posts. This query would be automatically invalidated if a new Post is created for the user.

LANGUAGE: typescript
CODE:
useFindUniqueUser({ where: { id: userId }, include: { posts: true } });

----------------------------------------

TITLE: Configuring Post Model with Manual Owner Assignment - ZModel & TypeScript
DESCRIPTION: Example showing how to set up a Post model with manual owner assignment in V1, requiring explicit owner connection when creating posts

LANGUAGE: zmodel
CODE:
model User {
  id Int @default(autoincrement())
}

model Post {
  id Int @default(autoincrement())
  title String
  owner User @relation(fields: [ownerId], references: [id])
  ownerId Int
}

LANGUAGE: typescript
CODE:
const db = enhance(prisma, { user });
await db.post.create({
  data: {
   owner: { connect: { id: user.id } },
   title: 'Post1'
  }
})

----------------------------------------

TITLE: Creating Database Seed Script
DESCRIPTION: TypeScript script to seed the database with initial data for the Todo application.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

async function main() {
    // clean up
    await prisma.user.deleteMany();
    await prisma.space.deleteMany();

    const joey = await prisma.user.create({
        data: {
            email: 'joey@zenstack.dev',
            name: 'Joey'
        }
    });
    console.log('User created:', joey);

    const rachel = await prisma.user.create({
        data: {
            email: 'rachel@zenstack.dev',
            name: 'Rachel'
        }
    });
    console.log('User created:', rachel);

    const centralPerk = await prisma.space.create({
        data: {
            name: 'Central Perk',
            slug: 'central-perk',
            owner: { connect: { id: rachel.id } },
            members: {
                create: [
                    {
                        user: { connect: { id: joey.id } },
                        role: 'USER'
                    },
                    {
                        user: { connect: { id: rachel.id } },
                        role: 'ADMIN'
                    }
                ]
            }
        }
    });
    console.log('Space created:', centralPerk);

    const rachelPersonal = await prisma.space.create({
        data: {
            name: "Rachel's Personal Space",
            slug: 'rachel',
            owner: { connect: { id: rachel.id } },
            members: {
                create: [
                    {
                        user: { connect: { id: rachel.id } },
                        role: 'ADMIN'
                    }
                ]
            }
        }
    });
    console.log('Space created:', rachelPersonal);
}

main()
    .then(async () => {
        await prisma.$disconnect();
    })
    .catch(async (e) => {
        console.error(e);
        await prisma.$disconnect();
        process.exit(1);
    });

----------------------------------------

TITLE: Creating Database Seed Script
DESCRIPTION: TypeScript script to seed the database with initial data for the Todo application.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

async function main() {
    // clean up
    await prisma.user.deleteMany();
    await prisma.space.deleteMany();

    const joey = await prisma.user.create({
        data: {
            email: 'joey@zenstack.dev',
            name: 'Joey'
        }
    });
    console.log('User created:', joey);

    const rachel = await prisma.user.create({
        data: {
            email: 'rachel@zenstack.dev',
            name: 'Rachel'
        }
    });
    console.log('User created:', rachel);

    const centralPerk = await prisma.space.create({
        data: {
            name: 'Central Perk',
            slug: 'central-perk',
            owner: { connect: { id: rachel.id } },
            members: {
                create: [
                    {
                        user: { connect: { id: joey.id } },
                        role: 'USER'
                    },
                    {
                        user: { connect: { id: rachel.id } },
                        role: 'ADMIN'
                    }
                ]
            }
        }
    });
    console.log('Space created:', centralPerk);

    const rachelPersonal = await prisma.space.create({
        data: {
            name: "Rachel's Personal Space",
            slug: 'rachel',
            owner: { connect: { id: rachel.id } },
            members: {
                create: [
                    {
                        user: { connect: { id: rachel.id } },
                        role: 'ADMIN'
                    }
                ]
            }
        }
    });
    console.log('Space created:', rachelPersonal);
}

main()
    .then(async () => {
        await prisma.$disconnect();
    })
    .catch(async (e) => {
        console.error(e);
        await prisma.$disconnect();
        process.exit(1);
    });

----------------------------------------

TITLE: React Table Implementation with Prisma
DESCRIPTION: Core implementation of React Table component using Prisma data and React Query hooks.

LANGUAGE: tsx
CODE:
const queryInclude = {
  include: {
    order: { include: { employee: true } },
    product: { include: { category: true } },
  },
} satisfies Prisma.OrderDetailFindManyArgs;

const columnHelper = createColumnHelper<Prisma.OrderDetailGetPayload<typeof queryInclude>>();

const columns = [
  columnHelper.accessor('order.id', { header: () => <span>Order ID</span> }),

  columnHelper.accessor('order.orderDate', {
      cell: (info) => info.getValue()?.toLocaleDateString(),
      header: () => <span>Date</span>,
  }),

  columnHelper.accessor('order.employee.firstName', {
      header: () => <span>Employee</span>,
  }),
];

export const OrderDetails = () => {
  const { data } = useFindManyOrderDetail({
    ...queryInclude,
  });
  
  const table = useReactTable({
    data: orders ?? [],
    columns,
    getCoreRowModel: getCoreRowModel(),
  });
}

----------------------------------------

TITLE: SQL Query for ACL-based Authorization
DESCRIPTION: Demonstrates a basic SQL query implementation for checking article read permissions based on user and group access control lists.

LANGUAGE: sql
CODE:
SELECT DISTINCT Article.*
FROM Article
JOIN AccessControlList ON AccessControlList.resource_id = Article.id
LEFT JOIN USER ON AccessControlList.user_id = User.id
LEFT JOIN GROUP ON AccessControlList.group_id = Group.id
WHERE (User.id = CURRENT_USER_ID
       OR Group.id IN
         (SELECT group_id
          FROM UserGroup
          WHERE user_id = CURRENT_USER_ID))
  AND AccessControlList.permission = 'read';

----------------------------------------

TITLE: Implementing ZenStack CRUD API Handler in Next.js
DESCRIPTION: This code snippet shows how to set up a ZenStack CRUD API handler in Next.js, which automatically generates RESTful endpoints based on the database schema and handles authentication.

LANGUAGE: typescript
CODE:
import { type AuthUser, enhance } from "@zenstackhq/runtime";
import RestApiHandler from "@zenstackhq/server/api/rest";
import { NextRequestHandler } from "@zenstackhq/server/next";
import { type JwtPayload, verify } from "jsonwebtoken";
import type { NextRequest } from "next/server";
import { db } from "~/server/db";

async function getPrisma(req: NextRequest) {
  let user: AuthUser | undefined;
  const auth = req.headers.get("authorization");
  if (auth) {
    const token = auth.split("Bearer ")[1];
    if (token) {
      const decoded = verify(token, process.env.JWT_SECRET!) as JwtPayload;
      user = {
        id: parseInt(decoded.sub!),
        role: decoded.role as string,
      };
    }
  }

  return enhance(db, { user });
}

const handler = NextRequestHandler({
  getPrisma,
  handler: RestApiHandler({ endpoint: "http://localhost:3000" }),
  useAppDir: true,
});

export {
  handler as DELETE,
  handler as GET,
  handler as PATCH,
  handler as POST,
  handler as PUT,
};

----------------------------------------

TITLE: ZModel Schema with Custom Attribute
DESCRIPTION: Equivalent ZModel schema using custom attributes instead of triple slash comments. This approach provides better type safety and compiler checks while still generating compatible Prisma schema.

LANGUAGE: zmodel
CODE:
attribute @TypeGraphQL.omit(output: Boolean?, input: Boolean?)

model User {
  id Int @default(autoincrement()) @id
  email String  @unique
  password String @TypeGraphQL.omit(output: true, input: true)
  posts Post[]
}

----------------------------------------

TITLE: Initializing RESTful API Handler in ZenStack
DESCRIPTION: Shows how to create a RESTful API handler using JSON:API as the transport format, with a custom endpoint configuration.

LANGUAGE: typescript
CODE:
import { RestApiHandler } from '@zenstackhq/server/api';
const handler = RestApiHandler({ endpoint: 'http://myhost/api' });

----------------------------------------

TITLE: Initializing RESTful API Handler in ZenStack
DESCRIPTION: Shows how to create a RESTful API handler using JSON:API as the transport format, with a custom endpoint configuration.

LANGUAGE: typescript
CODE:
import { RestApiHandler } from '@zenstackhq/server/api';
const handler = RestApiHandler({ endpoint: 'http://myhost/api' });

----------------------------------------

TITLE: Vector Operations with pgvector
DESCRIPTION: Shows how to create tables with vector columns, insert vector data, create HNSW index, and perform nearest neighbor searches using PostgreSQL's pgvector extension.

LANGUAGE: sql
CODE:
-- Create a table with a vector column
CREATE TABLE items (id bigserial PRIMARY KEY, embedding vector(3));

-- Insert vectors
INSERT INTO items (embedding) VALUES ('[1,2,3]'), ('[4,5,6]');

-- Create an "HNSW" index for L2 distance search
CREATE INDEX ON items USING hnsw (embedding vector_l2_ops);

-- Get the nearest neighbors by L2 distance
SELECT * FROM items ORDER BY embedding <-> '[3,1,2]' LIMIT 5;

----------------------------------------

TITLE: Pagination in PostgREST Queries
DESCRIPTION: Demonstrates how to implement pagination in PostgREST queries using limit and offset parameters.

LANGUAGE: ts
CODE:
// Get 15 users starting at offset 30
GET /user?limit=15&offset=30

----------------------------------------

TITLE: Setting up Database and Server
DESCRIPTION: Commands to initialize the database with seed data and start the development server

LANGUAGE: bash
CODE:
npx prisma db push
npx prisma db seed
npm run dev

----------------------------------------

TITLE: Installing Dependencies for OpenAPI and Swagger UI
DESCRIPTION: Commands to install the necessary npm packages for generating OpenAPI specs and serving them with Swagger UI.

LANGUAGE: bash
CODE:
npm install --save-dev @zenstackhq/openapi
npm install swagger-ui-express
npm install -D @types/swagger-ui-express

----------------------------------------

TITLE: Registering Access Control Provider in Refine Component
DESCRIPTION: React code snippet showing how to register the Access Control Provider in the top-level Refine component.

LANGUAGE: tsx
CODE:
<Refine 
  accessControlProvider={ accessControlProvider }
  ...
/>

----------------------------------------

TITLE: Demonstrating GitHub Copilot's Creative Suggestions
DESCRIPTION: An image showing GitHub Copilot's ability to generate creative suggestions, including business ideas, domain names, and slogans.

LANGUAGE: markdown
CODE:
![Slogan generation](slogan-gen.png)

----------------------------------------

TITLE: Enabling Encryption Enhancement in TypeScript
DESCRIPTION: This code shows how to explicitly enable the encryption enhancement when creating an enhanced PrismaClient.

LANGUAGE: typescript
CODE:
const db = enhance(prisma, { user }, {
  kinds: ['policy', 'encryption'],
  ...
});

----------------------------------------

TITLE: Configuring Netlify for ZenStack in RedwoodJS
DESCRIPTION: TOML configuration for Netlify to include ZenStack generated files in the deployment of a RedwoodJS project.

LANGUAGE: toml
CODE:
[functions]
  included_files = ["node_modules/.zenstack/*"]

----------------------------------------

TITLE: Initializing a TypeScript Project with try-prisma
DESCRIPTION: Commands to create a new TypeScript CLI project using try-prisma and initialize it for ZenStack.

LANGUAGE: bash
CODE:
npx try-prisma@latest -n my-todo-app -t orm/script --install npm
cd my-todo-app
npx zenstack@latest init

----------------------------------------

TITLE: Using EnhancedPrismaService in NestJS Controller
DESCRIPTION: Example of using EnhancedPrismaService in a NestJS controller to automatically apply access policies.

LANGUAGE: typescript
CODE:
export class DeclarativeController {
  constructor(private readonly enhancedPrisma: EnhancedPrismaService) {}

  @Get('users')
  async getAllUsers() {
    // just do a simple `findMany` call, the `email` field is automatically 
    // excluded based on the access policy
    return this.enhancedPrisma.user.findMany();
  }

  @Get('feed')
  async getFilteredPosts(...): Promise<PostModel[]> {
    const searchCondition = ...; // search conditions for filtering title, etc.

    return this.enhancedPrisma.post.findMany({
      // no need to filter for "published: true" or current user anymore
      where: searchCondition,
      // no need to exclude `email` field anymore
      include: { author: true },
      ...
    });
  }
}

----------------------------------------

TITLE: Updating ZModel Schema with User Roles
DESCRIPTION: Updated ZModel schema introducing user roles (Reader and Writer) and corresponding access control rules for the Post model.

LANGUAGE: zmodel
CODE:
model User {
  ...

  role          String    @default('Reader')
}

model Post {
  ...

  // allow read for all signin users
  @@allow('read', auth() != null && status == 'published')

  // allow "Writer" users to create
  @@allow('create', auth().role == 'Writer')

  // full access by author
  @@allow('read,update,delete', author == auth())
}

----------------------------------------

TITLE: Configuring Next.js for ZenStack Compatibility
DESCRIPTION: This code snippet shows how to configure Next.js 13 and above to resolve compatibility issues with the @zenstackhq/runtime package. It adds the package to the serverComponentsExternalPackages list in the experimental configuration.

LANGUAGE: javascript
CODE:
{
  ...
  experimental: {
    serverComponentsExternalPackages: [
      "@zenstackhq/runtime"
    ],
  }
}

----------------------------------------

TITLE: Enabling Server Actions in Next.js Configuration
DESCRIPTION: Configuration to enable the experimental Server Actions feature in Next.js.

LANGUAGE: typescript
CODE:
const config = {
  experimental: {
    serverActions: true
  },
};

----------------------------------------

TITLE: Creating TanStack Query Provider Component
DESCRIPTION: React component setup for TanStack Query client provider

LANGUAGE: tsx
CODE:
'use client';

import { QueryClient, QueryClientProvider } from '@tanstack/react-query';

type Props = {
  children: React.ReactNode;
};

const queryClient = new QueryClient();

function Provider({ children }: Props) {
  return <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>;
}

export default Provider;

----------------------------------------

TITLE: Installing @zenstackhq/tanstack-query Plugin
DESCRIPTION: Command to install the @zenstackhq/tanstack-query plugin for ZenStack using npm.

LANGUAGE: bash
CODE:
npm install --save-dev @zenstackhq/tanstack-query

----------------------------------------

TITLE: ZenStack Schema Definition
DESCRIPTION: ZenStack schema showing authorization rules for Todo app entities with inheritance

LANGUAGE: tsx
CODE:
abstract model BaseEntity {
    id        String   @id @default(uuid())
    space     Space    @relation(fields: [spaceId], references: [id], onDelete: Cascade)
    spaceId   String
    owner     User     @relation(fields: [ownerId], references: [id], onDelete: Cascade)
    ownerId   String   @default(auth().id)

    // can be read by owner or space members 
    @@allow('read', owner == auth() || (space.members?[user == auth()]))

    // when create, owner must be set to current user, and user must be in the space
    @@allow('create', owner == auth() && space.members?[user == auth()])

    // when create, owner must be set to current user, and user must be in the space
    // update is not allowed to change owner
    @@allow('update', owner == auth() && space.members?[user == auth()] && future().owner == owner)

    // can be deleted by owner
    @@allow('delete', owner == auth())
}

----------------------------------------

TITLE: Using Enhanced Prisma Client in REPL
DESCRIPTION: Shows how to use the enhanced Prisma Client in a REPL environment. The 'db' variable provides access to the enhanced client, demonstrating a simple query operation.

LANGUAGE: javascript
CODE:
db.user.findMany();

----------------------------------------

TITLE: Defining ZModel Schema with Access Policies
DESCRIPTION: Example of a ZModel schema defining a Post model with access policies

LANGUAGE: zmodel
CODE:
model Post {
  id        Int      @id @default(autoincrement())
  title     String
  body      String
  comments  Comment[]
  user      User     @relation(fields: [userId], references: [id])
  userId    Int
  createdAt DateTime @default(now())
  published Boolean @default(true)

  @@allow('all', auth().roles == 'admin' && auth() == user)
  @@allow('read', published)
}

----------------------------------------

TITLE: Installing @zenstackhq/tanstack-query Plugin
DESCRIPTION: Command to install the @zenstackhq/tanstack-query plugin for ZenStack using npm.

LANGUAGE: bash
CODE:
npm install --save-dev @zenstackhq/tanstack-query

----------------------------------------

TITLE: ZenStack Frontend Query Hook
DESCRIPTION: Shows how to use ZenStack's generated frontend query hooks with type safety, similar to Prisma client syntax.

LANGUAGE: typescript
CODE:
const { data } = useTodo.findMany({
  select: {
    id: true,
    title: true,
    done: true
  }
})

----------------------------------------

TITLE: Configuring Zod Schemas in ZenStack Factory
DESCRIPTION: Example showing how to configure custom Zod schemas in the ZenStack factory configuration for input validation.

LANGUAGE: typescript
CODE:
factory({
    ...
    zodSchemas: require('./zod'),
});

----------------------------------------

TITLE: Configuring Zod Schemas in ZenStack Factory
DESCRIPTION: Example showing how to configure custom Zod schemas in the ZenStack factory configuration for input validation.

LANGUAGE: typescript
CODE:
factory({
    ...
    zodSchemas: require('./zod'),
});

----------------------------------------

TITLE: Adding Access Control Rules to ZModel Schema
DESCRIPTION: ZModel schema with added access control rules using the @@allow directive for User and Post models.

LANGUAGE: zmodel
CODE:
model User {
  ...

  // everybody can signup
  @@allow('create', true)

  // full access by self
  @@allow('all', auth() == this)
}


model Post {
  ...

  // allow read for all signin users
  @@allow('read', auth() != null && status == 'published')

  // full access by author
  @@allow('all', author == auth())
}

----------------------------------------

TITLE: ZModel Inheritance Example - Extended Models
DESCRIPTION: Demonstrates extending base model to create User, Post, and Comment models

LANGUAGE: zmodel
CODE:
import "base"
model User extends Base {
    name String
}

model Post extends Base {
    title String
    content String?
    viewCount Int @default(0)
    comment Comment[]
}

model Comment extends Base {
    content String
    post Post @relation(fields: [postId], references: [id])
    postId Int
}

----------------------------------------

TITLE: Fetching a Single User with PostgREST
DESCRIPTION: Demonstrates how to fetch a single user resource using PostgREST's query syntax, which differs from traditional RESTful conventions by using query parameters instead of nested routes.

LANGUAGE: ts
CODE:
GET /user?id=1

----------------------------------------

TITLE: Controlling Exposed Endpoints with Next.js Middleware
DESCRIPTION: TypeScript code for a Next.js middleware that controls which API endpoints are exposed. This example demonstrates how to disallow listing all User entities.

LANGUAGE: typescript
CODE:
import { type NextRequest, NextResponse } from 'next/server';

export function middleware(request: NextRequest) {
    const url = new URL(request.url);
    if (
        request.method === 'GET' &&
        url.pathname.match(/^\/api\/model\/user\/?$/)
    ) {
        return NextResponse.json({ error: 'Not allowed' }, { status: 405 });
    }
}

export const config = {
    matcher: '/api/model/:path*',
};

----------------------------------------

TITLE: Setting up ZenStack in RedwoodJS project
DESCRIPTION: Command to set up ZenStack in a RedwoodJS project. This installs necessary dependencies and configures the project for ZenStack integration.

LANGUAGE: bash
CODE:
yarn rw setup package @zenstackhq/redwood

----------------------------------------

TITLE: Querying Posts with User Authentication in ZenStack
DESCRIPTION: This curl command demonstrates how to query posts from the ZenStack-generated API with user authentication, simulating different user access levels.

LANGUAGE: bash
CODE:
curl -H "X-USER-ID: robin@prisma.io" localhost:3000/api/post

----------------------------------------

TITLE: ZenStack Schema Configuration
DESCRIPTION: JSON configuration in package.json to specify schema file locations

LANGUAGE: json
CODE:
{
  "zenstack": {
    "schema": "db/schema.zmodel",
    "prisma": "db/schema.prisma"
  }
}

----------------------------------------

TITLE: Implementing Todo Item Component in React
DESCRIPTION: This snippet demonstrates the implementation of a Todo item component in React. It includes functionality for toggling completion status, deleting items, and updating the UI.

LANGUAGE: tsx
CODE:
import { TrashIcon } from '@heroicons/react/24/outline';
import { useTodo } from '@lib/hooks';
import { Todo, User } from '@prisma/client';
import { ChangeEvent } from 'react';
import Avatar from './Avatar';
import TimeInfo from './TimeInfo';

type Props = {
    value: Todo & { owner: User };
    updated?: (value: Todo) => any;
    deleted?: (value: Todo) => any;
};

export default function TodoComponent({ value, updated, deleted }: Props) {
    const { update, del } = useTodo();

    const deleteTodo = async () => {
        await del({ where: { id: value.id } });
        if (deleted) {
            deleted(value);
        }
    };

    const toggleCompleted = async (completed: boolean) => {
        if (completed === !!value.completedAt) {
            return;
        }
        const newValue = await update({
            where: { id: value.id },
            data: { completedAt: completed ? new Date() : null },
        });
        if (updated && newValue) {
            updated(newValue);
        }
    };
    // html
    return (...);
}

----------------------------------------

TITLE: Generating ZenStack Support Modules
DESCRIPTION: Command to generate JavaScript modules that support the enforcement of ZenStack policies.

LANGUAGE: bash
CODE:
npx zenstack generate

----------------------------------------

TITLE: Implementing Database Middleware for Tenant Isolation
DESCRIPTION: Example of a traditional middleware approach to implementing tenant isolation by filtering database queries

LANGUAGE: typescript
CODE:
const databaseMiddleware = (req, res, next) => {
    const incomingMessage = req as IncomingMessage;
    const serverResponse = res as ServerResponse;

    // Get the tenant ID from the request object
    const tenantId = incomingMessage.tenantId;

    // Add the tenant ID filter to all database queries
    addTenantIdFilter(tenantId);

    next();
};

const addTenantIdFilter = (tenantId: string) => {
    // Implement the logic to add the tenant ID filter to all database queries
    // ...
};

----------------------------------------

TITLE: Implementing NextAuth Session Provider
DESCRIPTION: Creates a session provider component for NextAuth integration to handle authentication state.

LANGUAGE: tsx
CODE:
'use client';

import { SessionProvider } from 'next-auth/react';
import React from 'react';

type Props = {
  children: React.ReactNode;
};
function NextAuthSessionProvider({ children }: Props) {
  return <SessionProvider>{children}</SessionProvider>;
}

export default NextAuthSessionProvider;

----------------------------------------

TITLE: Creating EnhancedPrismaService with ZenStack
DESCRIPTION: Implementing an EnhancedPrismaService that wraps PrismaService and applies ZenStack's access policies.

LANGUAGE: typescript
CODE:
import { Injectable } from '@nestjs/common';
import type { PrismaClient } from '@prisma/client';
import { enhance } from '@zenstackhq/runtime';
import { ClsService } from 'nestjs-cls';
import { PrismaService } from '../prisma.service';

@Injectable()
export class EnhancedPrismaService {
  constructor(
    private readonly prismaService: PrismaService,
    private readonly clsService: ClsService,
  ) {}

  private get enhancedPrisma() {
    return enhance(this.prismaService, { user: this.clsService.get('user') });
  }

  get user(): PrismaClient['user'] {
    return this.enhancedPrisma.user;
  }
  get post(): PrismaClient['post'] {
    return this.enhancedPrisma.post;
  }
}

----------------------------------------

TITLE: Generating OpenAPI Specification
DESCRIPTION: Configures the OpenAPI plugin in ZenStack to generate API documentation.

LANGUAGE: zmodel
CODE:
plugin openapi {
    provider = '@zenstackhq/openapi'
    prefix = '/api'
    flavor = 'rest'
    title = 'Pet Store API'
    specVersion = '3.0.0'
    version = '0.1.0'
    description = 'My awesome pet store API'
    output = 'petstore-api.json'
    securitySchemes = { 
        myBearer: { type: 'http', scheme: 'bearer', bearerFormat: 'JWT' }
    }
}

----------------------------------------

TITLE: Deserializing Data with SuperJSON in TypeScript
DESCRIPTION: This TypeScript snippet demonstrates how to use SuperJSON to deserialize the response data, restoring proper Date types for createdAt and updatedAt fields.

LANGUAGE: typescript
CODE:
import SuperJSON from 'superjson';

SuperJSON.deserialize({
    json: {
        "createdAt" : "2023-11-08T04:38:53.385Z",
        "id" : 1,
        "ownerId" : 1,
        "private" : false,
        "spaceId" : 1,
        "title" : "Grocery",
        "updatedAt" : "2023-11-09T04:52:57.987Z"
   },
   meta: {
        "values" : {
            "createdAt" : [ "Date" ],
            "updatedAt" : [ "Date" ]
        }
    }
});

----------------------------------------

TITLE: Creating React-Admin Auth Provider
DESCRIPTION: This code snippet demonstrates the implementation of a React-Admin auth provider, which handles authentication-related operations like login, logout, and checking auth status.

LANGUAGE: typescript
CODE:
import type { AuthProvider } from "react-admin";

const authProvider: AuthProvider = {
  login: ({ username, password }) => {
    return fetch("/api/auth/login", {
      method: "POST",
      body: JSON.stringify({ email: username, password }),
    })
      .then((resp) => {
        if (resp.status < 200 || resp.status >= 300) {
          throw new Error(resp.statusText);
        }
        return resp.json();
      })
      .then((auth) => {
        localStorage.setItem("auth", JSON.stringify(auth));
      });
  },

  logout: () => {
    localStorage.removeItem("auth");
    return Promise.resolve();
  },

  checkAuth: () =>
    localStorage.getItem("auth") ? Promise.resolve() : Promise.reject(),

  checkError: (error) => {
    const status = error.status;
    if (status === 401) {
      localStorage.removeItem("auth");
      return Promise.reject();
    }
    return Promise.resolve();
  },

  getIdentity: () => {
    const auth = localStorage.getItem("auth");
    if (!auth) {
      return Promise.reject("not authenticated");
    }
    try {
      const { id, email }: { id: number; email: string } = JSON.parse(auth);
      return Promise.resolve({ id, email });
    } catch (error) {
      return Promise.reject(error);
    }
  },

  getPermissions: () => Promise.resolve(""),
};

export default authProvider;

----------------------------------------

TITLE: Schema Definition for Blog Application
DESCRIPTION: ZModel schema defining data models for a blog application including User, Profile, Post, and Comment entities.

LANGUAGE: zmodel
CODE:
model User {
    id Int @id @default(autoincrement())
    email String
    posts Post[]
}

model Profile {
    id Int @id @default(autoincrement())
    gender String
    user User @relation(fields: [userId], references: [id])
    userId Int @unique
}

model Post {
    id Int @id @default(autoincrement())
    title String
    published Boolean @default(false)
    viewCount Int @default(0)
    author User @relation(fields: [authorId], references: [id])
    authorId Int
    comments Comment[]
}

model Comment {
    id Int @id @default(autoincrement())
    content String
    post Post @relation(fields: [postId], references: [id])
    postId Int
}

----------------------------------------

TITLE: Initializing RPC API Handler in ZenStack
DESCRIPTION: Demonstrates how to create an RPC-style API handler that mirrors PrismaClient's API functionality across the network.

LANGUAGE: typescript
CODE:
import { RPCApiHandler } from '@zenstackhq/server/api';
const handler = RPCApiHandler();

----------------------------------------

TITLE: Initializing Next.js 13 Project with create-t3-app
DESCRIPTION: Command to create a new Next.js 13 project using create-t3-app with TypeScript, App router, TailwindCSS, Prisma, and NextAuth.

LANGUAGE: bash
CODE:
npm create t3-app@latest

----------------------------------------

TITLE: Initializing RPC API Handler in ZenStack
DESCRIPTION: Demonstrates how to create an RPC-style API handler that mirrors PrismaClient's API functionality across the network.

LANGUAGE: typescript
CODE:
import { RPCApiHandler } from '@zenstackhq/server/api';
const handler = RPCApiHandler();

----------------------------------------

TITLE: Configuring Tailwind with DaisyUI
DESCRIPTION: Updates Tailwind configuration to include the DaisyUI plugin for UI components.

LANGUAGE: javascript
CODE:
module.exports = {
  //...
  plugins: [require("daisyui")],
}

----------------------------------------

TITLE: Installing TanStack Query Dependencies
DESCRIPTION: Command to install the required TanStack Query and ZenStack packages

LANGUAGE: bash
CODE:
npm install @tanstack/react-query @zenstackhq/tanstack-query

----------------------------------------

TITLE: Configuring Tailwind with DaisyUI
DESCRIPTION: Updates Tailwind configuration to include the DaisyUI plugin for UI components.

LANGUAGE: javascript
CODE:
module.exports = {
  //...
  plugins: [require("daisyui")],
}

----------------------------------------

TITLE: Installing ZenStack Server Package
DESCRIPTION: Command to install the @zenstackhq/server package using npm.

LANGUAGE: bash
CODE:
npm install @zenstackhq/server

----------------------------------------

TITLE: Configuring Seed Script in package.json
DESCRIPTION: JSON configuration to add the seed script to the package.json file.

LANGUAGE: json
CODE:
{
    "prisma": {
        "seed": "ts-node prisma/seed.ts"
    }
}

----------------------------------------

TITLE: Enhancing PrismaClient with Supabase Auth Context
DESCRIPTION: TypeScript implementation for creating an enhanced PrismaClient that incorporates Supabase authentication context for access policy enforcement. Uses Next.js auth helpers.

LANGUAGE: typescript
CODE:
import { enhance } from '@zenstackhq/runtime';
import { createRouteHandlerClient } from '@supabase/auth-helpers-nextjs';
import { prisma } from '@lib/db';

async function getPrisma() {
    const supabase = createRouteHandlerClient({ cookies });
    const { data: user } = await supabase.auth.getUser();
    const uid = user.user?.id;
    const contextUser = uid ? { id: uid } : undefined;
    return enhance(prisma, { user: contextUser });
}

----------------------------------------

TITLE: Configuring ZenStack Plugin for TanStack Query Hook Generation
DESCRIPTION: Configuration for ZenStack plugin to generate TanStack Query hooks from the schema, specifying output directory and target framework.

LANGUAGE: zmodel
CODE:
plugin hooks {
  provider = '@zenstackhq/tanstack-query'
  output = './src/lib/hooks'
  target = 'react' // target framework: "react", "vue", or "svelte"
}

----------------------------------------

TITLE: Mounting CRUD Service in Nuxt
DESCRIPTION: Creates an event handler to mount CRUD APIs for all models, using ZenStack's enhanced PrismaClient.

LANGUAGE: typescript
CODE:
import { enhance } from '@zenstackhq/runtime';
import { createEventHandler } from '@zenstackhq/server/nuxt';
import { prisma } from '~/server/prisma';

export default createEventHandler({
    getPrisma: async (event) => {
        const session = await useAuthSession(event);
        return enhance(prisma, {
            user: session.data.id ? { id: session.data.id } : undefined,
        });
    },
});

----------------------------------------

TITLE: Implementing SSR Data Loading with Next.js
DESCRIPTION: Demonstrates server-side data fetching and rendering using Next.js getServerSideProps. Shows how to fetch GitHub repository data and pass it to a page component.

LANGUAGE: tsx
CODE:
import type { InferGetServerSidePropsType, GetServerSideProps } from 'next'
 
type Repo = {
  name: string
  stargazers_count: number
}

export const getServerSideProps = (async () => {
  const res = await fetch('https://api.github.com/repos/vercel/next.js')
  const repo: Repo = await res.json()
  return { props: { repo } }
}) satisfies GetServerSideProps<{ repo: Repo }>

export default function Page({
  repo,
}: InferGetServerSidePropsType<typeof getServerSideProps>) {
  return (
    <main>
      <p>{repo.stargazers_count}</p>
    </main>
  )
}

----------------------------------------

TITLE: Cloning the Sample Project for ZenStack Guide Part 2
DESCRIPTION: Command to clone the 'part2' branch of the sample project repository for the ZenStack guide. This allows users to access the completed code up to the end of the plugin system section.

LANGUAGE: bash
CODE:
git clone --branch part2 https://github.com/zenstackhq/the-complete-guide-sample.git my-todo-app

----------------------------------------

TITLE: Enhanced PrismaClient Implementation
DESCRIPTION: Shows how to create an enhanced PrismaClient that enforces access policies while maintaining Prisma's query API.

LANGUAGE: typescript
CODE:
import { PrismaClient} from '@prisma/client';
import { enhance } from '@zenstackhq/runtime';
import { getCurrentUser } from '@/lib/auth';

const prisma = new PrismaClient();

// create an enhanced PrismaClient with a user context that provides 
// value for the "auth()" function in policy rules
const db = enhance(prisma, { user: getCurrentUser() });

// will only return posts readable to the current user
const posts = await db.post.findMany();

// will be rejected if the current user is not the author
await db.post.update({ where: { id: postId }, data: { ... } });

----------------------------------------

TITLE: JSON Response for User Creation with RESTful API Handler
DESCRIPTION: This snippet shows the expected JSON:API formatted output from creating a user and attaching two posts using the RESTful API handler. It includes the user's data, relationships, and links.

LANGUAGE: json
CODE:
{
    "jsonapi": { "version": "1.1" },
    "data": {
        "type": "user",
        "id": 1,
        "attributes": {
            "email": "user1@abc.com",
        },
        "links": {
            "self": "http://localhost/api/user/1",
        },
        "relationships": {
            "posts": {
                "links": {
                    "self": "http://localhost/api/user/1/relationships/posts",
                    "related": "http://localhost/api/user/1/posts",
                },
                "data": [
                    { "type": "post", "id": 1 },
                    { "type": "post", "id": 2 },
                ],
            },
        },
    },
}

----------------------------------------

TITLE: Cloning the Sample Project for ZenStack Guide Part 2
DESCRIPTION: Command to clone the 'part2' branch of the sample project repository for the ZenStack guide. This allows users to access the completed code up to the end of the plugin system section.

LANGUAGE: bash
CODE:
git clone --branch part2 https://github.com/zenstackhq/the-complete-guide-sample.git my-todo-app

----------------------------------------

TITLE: Checking Permissions with Django-Guardian
DESCRIPTION: Shows two methods of checking permissions in Django-Guardian: using ObjectPermissionChecker and decorators

LANGUAGE: python
CODE:
user1 = User.objects.get(username='user1')
post1 = Post.objects.get(slug='post1')

from guardian.core import ObjectPermissionChecker
checker = ObjectPermissionChecker(user1)
if checker.has_perm('change_post', post1):
  # update logic here

LANGUAGE: python
CODE:
from guardian.decorators import permission_required_or_403

@permission_required_or_403('change_post', (Post, 'slug', 'post_slug'))
def edit_post(request, post_slug):
  # update logic here

----------------------------------------

TITLE: JSON Field Validation with Constraints
DESCRIPTION: Example of adding validation constraints to JSON field types and handling validation errors.

LANGUAGE: zmodel
CODE:
type Metadata {
  width Int @gt(0) @lt(10000)
  height Int @gt(0) @lt(10000)
  format String
}

----------------------------------------

TITLE: CRUD Controller Implementation
DESCRIPTION: NestJS controller implementing CRUD operations for User and Post entities.

LANGUAGE: typescript
CODE:
import { Body, Controller, Get, Param, Post, Put } from '@nestjs/common';
import { PrismaService } from './prisma.service';

@Controller()
export class AppController {
  constructor(private readonly prismaService: PrismaService) {}

  @Post('users')
  async signup(@Body() userData: { name: string }) {
    return this.prismaService.user.create({ data: userData });
  }

  @Get('posts')
  async getAllPosts() {
    return this.prismaService.post.findMany();
  }

  @Post('posts')
  async createDraft(@Body() postData: { title: string; authorId: number }) {
    return this.prismaService.post.create({
      data: postData,
    });
  }

  @Put('posts/publish/:id')
  async publishPost(@Param('id') id: string) {
    return this.prismaService.post.update({
      where: { id: Number(id) },
      data: { published: true },
    });
  }
}

----------------------------------------

TITLE: Modifying User Model in ZenStack Schema
DESCRIPTION: Updates the User model in schema.zmodel to add a name field and make user profiles public.

LANGUAGE: typescript
CODE:
model User {
    id String @id @default(cuid())
    email String @unique @email
+   name String?
    password String @password @omit @length(8, 16)
    posts Post[]

    // everybody can signup
    @@allow('create', true)

+   // user profiles are public
+   @@allow('read', true)

    // full access by self
    @@allow('all', auth() == this)
}

----------------------------------------

TITLE: Inserting Data with PostgREST
DESCRIPTION: Shows how to insert new data using PostgREST's API, using a POST request with a JSON payload.

LANGUAGE: ts
CODE:
POST /user
{ "name": "J Doe", "age": 23 }

----------------------------------------

TITLE: Configuring AsyncLocalStorage with nest-cls
DESCRIPTION: Setting up AsyncLocalStorage using the nest-cls package to store user identity information.

LANGUAGE: typescript
CODE:
import { ClsModule } from 'nestjs-cls';

@Module({
  imports: [
    ClsModule.forRoot({
      middleware: {
        mount: true,
        setup: (cls, req) => {
          const userId = req.headers['x-user-id'];
          const userRole = req.headers['x-user-role'] ?? 'USER';
          cls.set(
            'user',
            userId ? { id: Number(userId), role: userRole } : undefined,
          );
        },
      },
    }),
  ],
  controllers: [AppController],
  providers: [PrismaService],
})
export class AppModule implements NestModule {
}

----------------------------------------

TITLE: JSON Response for User Creation with RPC-style API Handler
DESCRIPTION: This snippet shows the expected JSON output from creating a user with two posts using the RPC-style API handler. It includes the user's ID, email, and the details of the created posts.

LANGUAGE: json
CODE:
{
    "id": 1,
    "email": "user1@abc.com",
    "posts": [
        {
            "id": 1,
            "createdAt": "2023-03-14T07:45:04.036Z",
            "updatedAt": "2023-03-14T07:45:04.036Z",
            "title": "Post 1",
            "authorId": 1
        },
        {
            "id": 2,
            "createdAt": "2023-03-14T07:45:04.036Z",
            "updatedAt": "2023-03-14T07:45:04.036Z",
            "title": "Post 2",
            "authorId": 1
        }
    ]
}

----------------------------------------

TITLE: Generating ZenStack and Pushing Schema
DESCRIPTION: Commands to generate ZenStack files and push the schema to the database.

LANGUAGE: bash
CODE:
npx zenstack generate && npx prisma db push

----------------------------------------

TITLE: ZenStack RPC Middleware Integration
DESCRIPTION: Implementation of ZenStack middleware with RPC-style API endpoints using Express

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client';
import { ZenStackMiddleware } from '@zenstackhq/server/express';
import express from 'express';

const app = express();
app.use(express.json());

const prisma = new PrismaClient();
app.use('/api/rpc', ZenStackMiddleware({ getPrisma: () => prisma }));

app.listen(3000, () => console.log('🚀 Server ready at: http://localhost:3000'));

----------------------------------------

TITLE: Implementing RPC API Handler in Next.js
DESCRIPTION: Configuration for setting up the RPC API handler in a Next.js application using the app directory structure.

LANGUAGE: typescript
CODE:
import { NextRequestHandler } from '@zenstackhq/server/next';
import { RestApiHandler } from '@zenstackhq/server/api';
import { getPrisma } from '~/lib/db';

const handler = NextRequestHandler({
    getPrisma,
    useAppDir: true,
    handler: RPCApiHandler() // you can also omit it since `RPCApiHandler` is the default
});

export {
  handler as GET,
  handler as POST,
  handler as PUT,
  handler as PATCH,
  handler as DELETE,
};

----------------------------------------

TITLE: Enhanced Prisma Client Wrapper
DESCRIPTION: Helper function to create an access-policy-enabled Prisma client instance.

LANGUAGE: typescript
CODE:
import { enhance } from '@zenstackhq/runtime';

export function getEnhancedPrisma(userId: string) {
    return enhance(prisma, { user: { id: userId } });
}

----------------------------------------

TITLE: Creating tRPC Context with Enhanced Prisma Client
DESCRIPTION: Example of creating a tRPC context with an enhanced Prisma client that enforces access control policies

LANGUAGE: typescript
CODE:
export const createContext = async ({ req, res }: CreateNextContextOptions) => {
    const session = await getServerAuthSession({ req, res });
    return {
        session,
        // use access-control-enabled db client
        prisma: enhance(prisma, { user: session?.user }),
    };
};

----------------------------------------

TITLE: Configuring NextAuth with Credentials Provider
DESCRIPTION: Configuration for NextAuth using a Credentials provider with email/password authentication and bcryptjs for password hashing.

LANGUAGE: typescript
CODE:
import { compare } from "bcryptjs";

export const authOptions: NextAuthOptions = {
  session: {
    strategy: "jwt",
  },
  callbacks: {
    session({ session, token }) {
      if (session.user) {
        session.user.id = token.sub!;
      }
      return session;
    },
  },
  adapter: PrismaAdapter(db),
  providers: [
    CredentialsProvider({
      credentials: {
        email: { type: "email" },
        password: { type: "password" },
      },
      authorize,
    }),
  ],
};

async function authorize(
  credentials: Record<"email" | "password", string> | undefined,
) {
  if (!credentials?.email) {
    throw new Error('"email" is required in credentials');
  }

  if (!credentials?.password) {
    throw new Error('"password" is required in credentials');
  }

  const maybeUser = await db.user.findFirst({
    where: { email: credentials.email },
    select: { id: true, email: true, password: true },
  });

  if (!maybeUser) {
    return null;
  }

  if (!await compare(credentials.password, maybeUser.password)) {
    return null;
  }

  return { id: maybeUser.id, email: maybeUser.email };
}

----------------------------------------

TITLE: Configuring NextAuth with Credentials Provider
DESCRIPTION: Configuration for NextAuth using a Credentials provider with email/password authentication and bcryptjs for password hashing.

LANGUAGE: typescript
CODE:
import { compare } from "bcryptjs";

export const authOptions: NextAuthOptions = {
  session: {
    strategy: "jwt",
  },
  callbacks: {
    session({ session, token }) {
      if (session.user) {
        session.user.id = token.sub!;
      }
      return session;
    },
  },
  adapter: PrismaAdapter(db),
  providers: [
    CredentialsProvider({
      credentials: {
        email: { type: "email" },
        password: { type: "password" },
      },
      authorize,
    }),
  ],
};

async function authorize(
  credentials: Record<"email" | "password", string> | undefined,
) {
  if (!credentials?.email) {
    throw new Error('"email" is required in credentials');
  }

  if (!credentials?.password) {
    throw new Error('"password" is required in credentials');
  }

  const maybeUser = await db.user.findFirst({
    where: { email: credentials.email },
    select: { id: true, email: true, password: true },
  });

  if (!maybeUser) {
    return null;
  }

  if (!await compare(credentials.password, maybeUser.password)) {
    return null;
  }

  return { id: maybeUser.id, email: maybeUser.email };
}

----------------------------------------

TITLE: Configuring TanStack Query Plugin in ZModel Schema
DESCRIPTION: This code snippet demonstrates how to add the TanStack Query plugin to the ZModel schema for generating React hooks.

LANGUAGE: zmodel
CODE:
plugin hooks {
  provider = '@zenstackhq/tanstack-query'
  target = 'react'
  version = 'v5'
  output = 'src/lib/hooks'
}

----------------------------------------

TITLE: Defining Prisma Schema for Blog App
DESCRIPTION: Prisma schema definition for User and Post models in a blog application.

LANGUAGE: zmodel
CODE:
model User {
  id Int @id @default(autoincrement())
  email String @unique
  name String?
  role String @default("USER") // USER or EDITOR
  posts Post[]
}

model Post {
  id Int @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  title String
  content String?
  published Boolean @default(false)
  author User? @relation(fields: [authorId], references: [id])
  authorId Int?
}

----------------------------------------

TITLE: Prisma Find Operation Middleware
DESCRIPTION: Middleware code for handling find operations with soft delete filtering in Prisma.

LANGUAGE: tsx
CODE:
if (params.action === 'findUnique' || params.action === 'findFirst') {
    // Change to findFirst - you cannot filter
    // by anything except ID / unique with findUnique
    params.action = 'findFirst';
    // Add 'deleted' filter
    // ID filter maintained
    params.args.where['deleted'] = false;
}
if (params.action === 'findMany') {
    // Find many queries
    if (params.args.where) {
        if (params.args.where.deleted == undefined) {
            // Exclude deleted records if they have not been explicitly requested
            params.args.where['deleted'] = false;
        }
    } else {
        params.args['where'] = { deleted: false };
    }
}

----------------------------------------

TITLE: Updating User with Nested Post Creation in TypeScript
DESCRIPTION: Shows how to update a User while creating a nested Post in TypeScript. This mutation will trigger automatic invalidation of related queries like useFindManyPost().

LANGUAGE: typescript
CODE:
updateUser({ where: { id: userId }, posts: { create: { title: 'post1' } } });

----------------------------------------

TITLE: Defining Zod Schema for AI Response in TypeScript
DESCRIPTION: This snippet defines a Zod schema to structure the expected response from the AI model, ensuring type safety in the generated documentation.

LANGUAGE: typescript
CODE:
const schema = z.object({
    overview: z.object({
        description: z.string(),
        functionality: z.string(),
    }),
    models: z.array(
        z.object({
            name: z.string(),
            access_control_policies: z.array(z.string()),
        })
    ),
});

----------------------------------------

TITLE: Installing ZenStack Server Dependencies
DESCRIPTION: Commands for installing Express framework and ZenStack server package dependencies

LANGUAGE: bash
CODE:
npm install express @zenstackhq/server
npm install --save-dev @types/express tsx

----------------------------------------

TITLE: Setting up NextAuth PrismaAdapter
DESCRIPTION: Configuration for NextAuth using PrismaAdapter to handle persistence of auth-related entities.

LANGUAGE: typescript
CODE:
import { PrismaAdapter } from "@next-auth/prisma-adapter";
import NextAuth, { type NextAuthOptions } from 'next-auth';
import { prisma } from "../../../server/db/client";

export const authOptions: NextAuthOptions = {
    // install Prisma adapter
    adapter: PrismaAdapter(prisma),
    ...
};

export default NextAuth(authOptions);

----------------------------------------

TITLE: Running Prisma Migrate for Development
DESCRIPTION: This command synchronizes the local database with the Prisma schema and generates a migration record for schema reconstruction during deployment.

LANGUAGE: bash
CODE:
npx prisma migrate dev

----------------------------------------

TITLE: Modifying ZenStack Schema for User Model
DESCRIPTION: Updates to the schema.zmodel file to add a name field to the User model and make it readable by all users.

LANGUAGE: diff
CODE:
model User {
    id String @id @default(cuid())
    email String @unique @email
+   name String?
    password String @password @omit @length(8, 16)
    posts Post[]

    // everybody can signup
    @@allow('create', true)

+   // user profiles are public
+   @@allow('read', true)

    // full access by self
    @@allow('all', auth() == this)
}

----------------------------------------

TITLE: JSON Response for Simple Query
DESCRIPTION: This JSON snippet shows the response format for a query that returns fully JSON-serializable data without extra metadata.

LANGUAGE: json
CODE:
{
    "data": {
        "id":1,
        "title":"Grocery"
    }
}

----------------------------------------

TITLE: Implementing ZenStack CRUD Middleware
DESCRIPTION: Creating a NestJS middleware that wraps ZenStack's Express middleware for automatic CRUD API generation.

LANGUAGE: typescript
CODE:
import { Injectable, NestMiddleware } from '@nestjs/common';
import { enhance } from '@zenstackhq/runtime';
import RESTHandler from '@zenstackhq/server/api/rest';
import { ZenStackMiddleware } from '@zenstackhq/server/express';
import { Request, Response } from 'express';
import { PrismaService } from '../prisma.service';

@Injectable()
export class CrudMiddleware implements NestMiddleware {
  constructor(private readonly prismaService: PrismaService) {}

  use(req: Request, _res: Response, next: (error?: any) => void) {
    // base url for RESTful resource linkage
    const baseUrl = `${req.protocol}://${req.headers.host}${req.baseUrl}`;

    // get the current user from request
    const userId = req.headers['x-user-id'];
    const userRole = req.headers['x-user-role'] ?? 'USER';
    const user = userId ? { id: Number(userId), role: userRole } : undefined;

    // construct an Express middleware and forward the request/response
    const inner = ZenStackMiddleware({
      // get an enhanced PrismaClient for the current user
      getPrisma: () => enhance(this.prismaService, { user }),
      // use RESTful style API
      handler: RESTHandler({ endpoint: baseUrl }),
    });
    inner(req, _res, next);
  }}

----------------------------------------

TITLE: Creating NestJS Project with Prisma
DESCRIPTION: Command to create a new NestJS project with Prisma using the 'try-prisma' package.

LANGUAGE: bash
CODE:
npx try-prisma@latest --template typescript/rest-nestjs

----------------------------------------

TITLE: ZenStack Enhanced Schema with Access Policies
DESCRIPTION: Extended schema using ZenStack showing access control policies for User and Post models

LANGUAGE: zmodel
CODE:
model User {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  email     String   @unique
  name      String?
  role      Role     @default(USER)
  posts     Post[]

  //everyone can signup, and user profile is also publicly readable
  @@allow('create,read', true)

  // only the user can update or delete their own profile
  @@allow('update,delete', auth() == this)
}

model Post {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  published Boolean  @default(false)
  title     String   @db.VarChar(255)
  author    User?    @relation(fields: [authorId], references: [id])
  authorId  Int?

  // author has full access
  @@allow('all', auth() == author)

  // ADMIN has full access
  @@allow('all', auth().role == ADMIN)

  // logged-in users can view published posts
  @@allow('read', auth() != null && published)
}

enum Role {
  USER
  ADMIN
}

----------------------------------------

TITLE: Displaying ZenStack CLI Usage and Commands
DESCRIPTION: Shows the main usage syntax for the ZenStack CLI, including available options and commands.

LANGUAGE: bash
CODE:
zenstack [options] [command]

ζ ZenStack is a Prisma power pack for building full-stack apps.

Documentation: https://zenstack.dev.

Options:
  -v --version           display CLI version
  -h, --help             display help for command

Commands:
  info [path]            Get information of installed ZenStack and related packages.
  init [options] [path]  Initialize an existing project for ZenStack.
  generate [options]     Generates RESTful API and Typescript client for your data model.
  repl [options]         Start a REPL session.
  format [options]       Format a ZenStack schema file.
  check [options]        Check a ZenStack schema file for syntax or semantic errors.
  help [command]         Display help for a command.

----------------------------------------

TITLE: Implementing Next.js Middleware for Endpoint Control
DESCRIPTION: Next.js middleware implementation to control API endpoint access, specifically preventing listing of User entities

LANGUAGE: typescript
CODE:
import { type NextRequest, NextResponse } from 'next/server';

export function middleware(request: NextRequest) {
    const url = new URL(request.url);
    if (
        request.method === 'GET' &&
        url.pathname.match(/^\/api\/model\/user\/?$/)
    ) {
        return NextResponse.json({ error: 'Not allowed' }, { status: 405 });
    }
}

export const config = {
    matcher: '/api/model/:path*',
};

----------------------------------------

TITLE: Creating Helper Methods for User-bound Prisma Client
DESCRIPTION: Adds helper methods to get a Prisma client bound to the current user identity using ZenStack's enhance function.

LANGUAGE: typescript
CODE:
import { Request } from 'express';
import { enhance } from '@zenstackhq/runtime';

function getUserId(req: Request) {
    return parseInt(req.header('X-USER-ID')!);
}

// Gets a Prisma client bound to the current user identity
function getPrisma(req: Request) {
    const userId = getUserId(req);
    const user = Number.isNaN(userId) ? undefined : { id: userId };
    return enhance(prisma, { user });
}

----------------------------------------

TITLE: Implementing ZenStack Next.js Server Adapter for Edge Runtime
DESCRIPTION: This code snippet shows how to set up a Next.js API route using ZenStack's server adapter for edge runtime. It creates a new PrismaClient for each request and handles various HTTP methods.

LANGUAGE: typescript
CODE:
import { NextRequestHandler } from '@zenstackhq/server/next';
import { createPrisma } from '~/lib/db';
import { getSessionUser } from '~/lib/auth';

function getEnhancedPrisma(req: Request) {
  // IMPORTANT: in edge environment you must create a new `PrismaClient` for each request
  // https://github.com/prisma/prisma/issues/20566#issuecomment-2021594203
  const prisma = createPrisma();
  return enhance(prisma, { user: getSessionUser(req) });
}

const handler = NextRequestHandler({ getPrisma: (req) => getEnhancedPrisma(req), useAppDir: true });

export {
  handler as DELETE,
  handler as GET,
  handler as PATCH,
  handler as POST,
  handler as PUT,
};

export const runtime = 'edge';
export const dynamic = 'force-dynamic';

----------------------------------------

TITLE: LLM Integration with Mindsdb
DESCRIPTION: Demonstrates how to integrate OpenAI's LLM capabilities into SQL workflows using Mindsdb, including model creation and querying.

LANGUAGE: sql
CODE:
CREATE ML_ENGINE openai_engine
FROM openai
USING
    api_key = 'your-openai-api-key';

CREATE MODEL my_openai_model
PREDICT answer
USING
    engine = 'openai',
    question_column = 'question',
    model_name = 'openai_model_name'
    api_key = 'YOUR_OPENAI_API_KEY;

LANGUAGE: sql
CODE:
SELECT question, answer
FROM my_openai_model
WHERE question = 'Where is Stockholm located?';

----------------------------------------

TITLE: Installing Additional Utility Packages
DESCRIPTION: Command to install nanoid utility package.

LANGUAGE: bash
CODE:
npm install nanoid

----------------------------------------

TITLE: Illustrating Function Body Generation in GitHub Copilot
DESCRIPTION: An image demonstrating GitHub Copilot's capability to generate function bodies based on context and function signatures.

LANGUAGE: markdown
CODE:
![Function body generation](function-gen.png)

----------------------------------------

TITLE: User Schema Definition in ZModel
DESCRIPTION: Data model definition for user authentication using ZModel schema syntax.

LANGUAGE: zmodel
CODE:
model User {
  id            String    @id @default(cuid())
  name          String?
  email         String?   @unique
  emailVerified DateTime?
  image         String?
  accounts      Account[]
  sessions      Session[]
}

----------------------------------------

TITLE: Creating Post List Page in SvelteKit
DESCRIPTION: Svelte component for the main post list page, including create, toggle publish, and delete functionality for posts.

LANGUAGE: svelte
CODE:
<script lang="ts">
    import { enhance } from '$app/forms';
    import type { ActionData, PageData } from './$types';

    export let data: PageData;
    export let form: ActionData;
</script>

<main class="flex flex-col min-h-screen items-center justify-center gap-12 px-4 py-16 text-white bg-gradient-to-b from-[#2e026d] to-[#15162c]"
>
    <h1 class="text-5xl font-extrabold">My Awesome Blog</h1>

    {#if data.user}
        <div class="flex flex-col">
            <div class="flex gap-4">
                <h3 class="text-lg">Welcome back, {data.user.email}</h3>
                <form method="post" action="?/signOut">
                    <button type="submit" class="text-gray-300 underline">Sign out</button>
                </form>
            </div>

            <section class="mt-10 container flex flex-col text-white">
                <!-- create post -->
                <form method="post" action="?/create" use:enhance>
                    <input
                        name="title"
                        type="text"
                        placeholder="Post title"
                        required
                        class="text-lg text-black px-4 py-2 rounded mr-2"
                    />
                    <button class="rounded border border-white px-4 py-2 text-lg" type="submit"
                        >+ Create</button
                    >
                </form>

                <!-- post list -->
                <ul class="container mt-8 flex flex-col gap-2">
                    {#each data.posts as post (post.id)}
                        <li class="flex items-end justify-between gap-4">
                            <!-- post info -->
                            <p class={`text-2xl ${!post.published ? 'text-gray-400' : ''}`}>
                                {post.title}
                                <span class="text-lg"> by {post.author.email}</span>
                            </p>

                            <!-- post management -->
                            <div class="flex w-32 justify-end gap-1 text-left">
                                <form method="post" action="?/togglePublish" use:enhance>
                                    <input type="hidden" name="id" value={post.id} />
                                    <button class="underline" type="submit">
                                        {post.published ? 'Unpublish' : 'Publish'}
                                    </button>
                                </form>
                                <form method="post" action="?/delete" use:enhance>
                                    <input type="hidden" name="id" value={post.id} />
                                    <button class="underline" type="submit">Delete</button>
                                </form>
                            </div>
                        </li>
                    {/each}
                </ul>

                {#if form?.error}
                    <p class="text-red-500 mt-4">{form.error}</p>
                {/if}
            </section>
        </div>
    {:else}
        <div class="flex gap-4 text-2xl">
            <a href="/signin" class="rounded-lg border px-4 py-2">Signin</a>
            <a href="/signup" class="rounded-lg border px-4 py-2">Signup</a>
        </div>
    {/if}
</main>

----------------------------------------

TITLE: Disabling ZenStack Telemetry Using Environment Variable
DESCRIPTION: Shows how to disable telemetry collection in ZenStack by setting the DO_NOT_TRACK environment variable to 1 before running ZenStack commands.

LANGUAGE: bash
CODE:
DO_NOT_TRACK=1 npx zenstack ...

----------------------------------------

TITLE: Updating Post Creation API with User Authentication
DESCRIPTION: Modifies the POST /post API to use extracted user id instead of passing in user email when creating a new post.

LANGUAGE: typescript
CODE:
app.post(`/post`, async (req, res) => {
    const { title, content } = req.body;
    const result = await prisma.post.create({
        data: {
            title,
            content,
            author: { connect: { id: getUserId(req) } },
        },
    });
    res.json(result);
});

----------------------------------------

TITLE: Creating tRPC App Router
DESCRIPTION: Example of creating and exporting a tRPC app router using the generated CRUD router

LANGUAGE: typescript
CODE:
import { createRouter as createCRUDRouter } from './generated/routers';
import { initTRPC } from '@trpc/server';
import { type Context } from '../context';

const t = initTRPC.context<Context>().create();

export const appRouter = createCRUDRouter(t.router, t.procedure);
export type AppRouter = typeof appRouter;

----------------------------------------

TITLE: Creating tRPC App Router
DESCRIPTION: Example of creating and exporting a tRPC app router using the generated CRUD router

LANGUAGE: typescript
CODE:
import { createRouter as createCRUDRouter } from './generated/routers';
import { initTRPC } from '@trpc/server';
import { type Context } from '../context';

const t = initTRPC.context<Context>().create();

export const appRouter = createCRUDRouter(t.router, t.procedure);
export type AppRouter = typeof appRouter;

----------------------------------------

TITLE: Defining ZenStack Schema with SWR Plugin
DESCRIPTION: Example of a ZenStack schema file that includes the @zenstackhq/swr plugin configuration and defines User and Post models with access rules.

LANGUAGE: zmodel
CODE:
plugin hooks {
  provider = '@zenstackhq/swr'
  output = "./src/lib/hooks"
}

model User {
  id            String    @id @default(cuid())
  email         String
  posts         Post[]

  // everyone can signup, and user profile is also publicly readable
  @@allow('create,read', true)
}

model Post {
  id        String @id @default(cuid())
  title     String
  published Boolean @default(false)
  author    User @relation(fields: [authorId], references: [id])
  authorId  String

  // author has full access
  @@allow('all', auth() == author)

  // logged-in users can view published posts
  @@allow('read', auth() != null && published)
}

----------------------------------------

TITLE: Defining Custom Attributes in ZenStack's ZModel
DESCRIPTION: This ZModel code shows how to define and use custom attributes in ZenStack, which provides a more intuitive syntax compared to the comments workaround.

LANGUAGE: prisma
CODE:
model User {
    id        String @id
    email     String @email
    password  String @password @omit
    // everyone can signup, and user profile is also publicly readable
    @@allow('create,read', true)
}

----------------------------------------

TITLE: Installing tRPC Plugin with NPM
DESCRIPTION: Command to install the @zenstackhq/trpc plugin as a development dependency

LANGUAGE: bash
CODE:
npm install --save-dev @zenstackhq/trpc

----------------------------------------

TITLE: Implementing Firebase Authentication with Email/Password
DESCRIPTION: Example of implementing email/password authentication using Firebase Auth service.

LANGUAGE: typescript
CODE:
import { getAuth, signInWithEmailAndPassword } from 'firebase/auth';

const auth = getAuth();

async function onSignin(email: string, password: string) {
  try {
    await signInWithEmailAndPassword(auth, email, password);
    Router.push('/');
  } catch (err) {
    alert('Unable to sign in: ' + (err as Error).message);
  }
}

----------------------------------------

TITLE: Creating Database and Auth Utilities
DESCRIPTION: TypeScript code for setting up Prisma client and JWT token creation utility for authentication.

LANGUAGE: typescript
CODE:
// db.ts
import { PrismaClient } from '@prisma/client';
export const prisma = new PrismaClient();

// auth.ts
import { env } from '$env/dynamic/private';
import type { User } from '@prisma/client';
import jwt from 'jsonwebtoken';

export const JWT_TOKEN_COOKIE_NAME = 'ZenStack-Blog-Token';

export function createToken(user: User) {
	return jwt.sign(
		{
			sub: user.id,
			email: user.email
		},
		env.JWT_SECRET,
		{ expiresIn: '7d' }
	);
}

----------------------------------------

TITLE: Custom Validation Messages in ZModel
DESCRIPTION: Shows how to add custom error messages to validation attributes for email and password fields.

LANGUAGE: zmodel
CODE:
model User {
    ...
    email String @unique @email('must be a valid email')
    password String @length(min: 8, max: 32, message: 'must be between 8 and 32 characters long')
}

----------------------------------------

TITLE: Creating Nuxt Project from Template
DESCRIPTION: Uses degit to clone a Nuxt project template with local authentication, then installs dependencies and starts the development server.

LANGUAGE: bash
CODE:
npx degit nuxt/examples/auth/local my-nuxt-blog
cd my-nuxt-blog
npm install
npm run dev

----------------------------------------

TITLE: Creating Next.js Project with T3 Stack
DESCRIPTION: Commands to create a new Next.js project using create-t3-app with Prisma, NextAuth and TailwindCSS dependencies.

LANGUAGE: bash
CODE:
npx create-t3-app@latest --prisma --nextAuth --tailwind --CI my-blog-app
cd my-blog-app
npm run dev

----------------------------------------

TITLE: Defining AI Prompt for Documentation Generation in TypeScript
DESCRIPTION: This snippet shows the prompt used to instruct the AI model to generate documentation from the ZModel schema.

LANGUAGE: typescript
CODE:
const prompt = `
    You are the expert of ZenStack open-source toolkit. 
    You will generate a technical design document from a provided ZModel schema file that help developer understand the structure and behavior of the application. 
    The document should include the following sections:
    1. Overview 
        a. A short paragraph for the high-level description of this app
        b. Functionality
    2. an array of model. Each model has below two information:
        a. model name
        b. array of access policies explained by plain text
    here is the ZModel schema file:
    \`\`\`zmodel
    ${zmodel}
    \`\`\`
    `;

----------------------------------------

TITLE: ZModel Custom Attributes Example
DESCRIPTION: Demonstrates ZModel's native custom attributes for password hashing and field omission

LANGUAGE: zmodel
CODE:
model User {
    id Int @default(autoincrement()) @id
    email String @unique
    password String @omit @password
}

----------------------------------------

TITLE: ZModel Custom Attributes Example
DESCRIPTION: Demonstrates ZModel's native custom attributes for password hashing and field omission

LANGUAGE: zmodel
CODE:
model User {
    id Int @default(autoincrement()) @id
    email String @unique
    password String @omit @password
}

----------------------------------------

TITLE: Browser Configuration for Crypto Package
DESCRIPTION: Package.json configuration to handle crypto module compatibility in edge runtime.

LANGUAGE: json
CODE:
{
  "browser": {
    "crypto": false
  }
}

----------------------------------------

TITLE: Installing Dependencies for ZenStack Website
DESCRIPTION: Command to install project dependencies using pnpm package manager.

LANGUAGE: bash
CODE:
$ pnpm install

----------------------------------------

TITLE: Mounting CRUD Service for ZenStack
DESCRIPTION: Code to create an enhanced PrismaClient and mount CRUD APIs for all models.

LANGUAGE: ts
CODE:
import { enhance } from '@zenstackhq/runtime';
import { createEventHandler } from '@zenstackhq/server/nuxt';
import { prisma } from '~/server/prisma';

export default createEventHandler({
    getPrisma: async (event) => {
        const session = await useAuthSession(event);
        return enhance(prisma, {
            user: session.data.id ? { id: session.data.id } : undefined,
        });
    },
});

----------------------------------------

TITLE: Creating Enhanced PrismaClient with User Context
DESCRIPTION: This TypeScript function creates an enhanced PrismaClient instance with the current user's context for enforcing access control policies.

LANGUAGE: typescript
CODE:
import { auth } from "@clerk/nextjs/server";
import { Role } from "@prisma/client";
import { enhance } from "@zenstackhq/runtime";

export async function getUserDb() {
  // get the current user's information from Clerk
  const { userId, orgId, orgRole } = await auth();

  // create an enhanced Prisma Client with proper user context
  const user = userId
    ? {
        userId,
        currentOrgId: orgId,
        currentOrgRole: orgRole
      }
    : undefined; // anonymous
  return enhance(prisma, { user });
}

----------------------------------------

TITLE: Creating Post Component in Nuxt
DESCRIPTION: Implements a Vue component for rendering and managing individual blog posts, including publish/unpublish and delete functionality.

LANGUAGE: html
CODE:
<script setup lang="ts">
import { useDeletePost, useUpdatePost } from '~/lib/hooks';

const props = defineProps({
    id: String,
    title: String,
    author: {
        type: Object,
        default: () => ({ email: '' }),
    },
    published: Boolean,
});

const updatePost = useUpdatePost();
const deletePost = useDeletePost();

const onTogglePublish = async () => {
    try {
        await updatePost.mutateAsync({
            where: { id: props.id },
            data: { published: !props.published },
        });
    } catch (err: any) {
        alert(err.info?.message ?? err);
    }
};

const onDelete = async () => {
    try {
        await deletePost.mutateAsync({ where: { id: props.id } });
    } catch (err: any) {
        alert(err.info?.message ?? err);
    }
};
</script>

<template>
    <div class="flex justify-center">
        <div class="min-w-80">
            <span class="mr-4 text-lg font-semibold">{{ title }}</span
            ><span>by {{ author.email }}</span>
        </div>
        <div class="ml-8 space-x-2">
            <NButton @click="onTogglePublish">{{
                published ? 'Unpublish' : 'Publish'
            }}</NButton>
            <NButton @click="onDelete">Delete</NButton>
        </div>
    </div>
</template>

----------------------------------------

TITLE: Attempting Data Creation with Enhanced Prisma Client
DESCRIPTION: This TypeScript code snippet shows an attempt to create a user using an enhanced Prisma Client. It demonstrates that without explicit access policies, this operation will result in a runtime error due to ZenStack's 'secure by default' approach.

LANGUAGE: typescript
CODE:
const prisma = new PrismaClient();
const db = enhance(prisma);
await db.user.create({ data: { email: 'zen@stack.dev'} });

----------------------------------------

TITLE: Creating Post Component in Nuxt
DESCRIPTION: Implements a Vue component for rendering and managing individual blog posts, including publish/unpublish and delete functionality.

LANGUAGE: html
CODE:
<script setup lang="ts">
import { useDeletePost, useUpdatePost } from '~/lib/hooks';

const props = defineProps({
    id: String,
    title: String,
    author: {
        type: Object,
        default: () => ({ email: '' }),
    },
    published: Boolean,
});

const updatePost = useUpdatePost();
const deletePost = useDeletePost();

const onTogglePublish = async () => {
    try {
        await updatePost.mutateAsync({
            where: { id: props.id },
            data: { published: !props.published },
        });
    } catch (err: any) {
        alert(err.info?.message ?? err);
    }
};

const onDelete = async () => {
    try {
        await deletePost.mutateAsync({ where: { id: props.id } });
    } catch (err: any) {
        alert(err.info?.message ?? err);
    }
};
</script>

<template>
    <div class="flex justify-center">
        <div class="min-w-80">
            <span class="mr-4 text-lg font-semibold">{{ title }}</span
            ><span>by {{ author.email }}</span>
        </div>
        <div class="ml-8 space-x-2">
            <NButton @click="onTogglePublish">{{
                published ? 'Unpublish' : 'Publish'
            }}</NButton>
            <NButton @click="onDelete">Delete</NButton>
        </div>
    </div>
</template>

----------------------------------------

TITLE: Creating Next.js Project with T3 Stack
DESCRIPTION: Initialize a new Next.js project using create-t3-app with Prisma, NextAuth, and TailwindCSS configurations

LANGUAGE: bash
CODE:
npx create-t3-app@latest --prisma --nextAuth --tailwind --CI my-blog-app
cd my-blog-app

----------------------------------------

TITLE: NextAuth Configuration Setup
DESCRIPTION: Configuration for NextAuth.js using credentials provider with password-based authentication

LANGUAGE: typescript
CODE:
import { PrismaAdapter } from "@auth/prisma-adapter";
import type { PrismaClient } from "@prisma/client";
import { compare } from "bcryptjs";
import {
  getServerSession,
  type DefaultSession,
  type NextAuthOptions,
} from "next-auth";
import { type Adapter } from "next-auth/adapters";
import CredentialsProvider from "next-auth/providers/credentials";

import { db } from "~/server/db";

declare module "next-auth" {
  interface Session extends DefaultSession {
    user: {
      id: string;
    } & DefaultSession["user"];
  }
}

export const authOptions: NextAuthOptions = {
  session: {
    strategy: "jwt",
  },
  callbacks: {
    session({ session, token }) {
      if (session.user) {
        session.user.id = token.sub!;
      }
      return session;
    },
  },
  adapter: PrismaAdapter(db) as Adapter,
  providers: [
    CredentialsProvider({
      credentials: {
        email: { type: "email" },
        password: { type: "password" },
      },
      authorize: authorize(db),
    }),
  ],
};

----------------------------------------

TITLE: Importing ZenStack Init Component in JSX/MDX
DESCRIPTION: Imports a ZenStack initialization documentation component from a markdown file and renders it within a tip block using MDX syntax

LANGUAGE: jsx
CODE:
import ZenStackInit from './_zenstack-init.md'

:::tip

<ZenStackInit />

:::

----------------------------------------

TITLE: Preventing Owner Field Updates in ZenStack
DESCRIPTION: Demonstrates how to prevent updates to specific fields (in this case, the owner field) using a post-update deny rule.

LANGUAGE: zmodel
CODE:
model List {
    ...

    @@deny('update', future().owner != owner)
}

----------------------------------------

TITLE: Attempting Data Creation with Enhanced Prisma Client
DESCRIPTION: TypeScript example showing an attempt to create a user using an enhanced Prisma Client. This operation fails due to ZenStack's 'secure by default' policy, requiring explicit access rules.

LANGUAGE: typescript
CODE:
const prisma = new PrismaClient();
const db = enhance(prisma);
await db.user.create({ data: { email: 'zen@stack.dev'} });

----------------------------------------

TITLE: Initializing ZenStack Project with Specific Package Manager
DESCRIPTION: Initialize a ZenStack project using a specific package manager with the '--package-manager' option. Supported values are npm, pnpm, and yarn.

LANGUAGE: bash
CODE:
npx zenstack@1 init --package-manager pnpm

----------------------------------------

TITLE: Using REPL Commands for ZenStack Debugging
DESCRIPTION: This snippet illustrates the use of REPL commands to enable debugging output and execute a query. It shows how to authenticate, enable debugging, and perform a 'findMany' operation.

LANGUAGE: javascript
CODE:
.auth { id: 1 }
.debug
db.list.findMany()

----------------------------------------

TITLE: Implementing Refine Access Control Provider
DESCRIPTION: TypeScript code implementing a Refine Access Control Provider that uses ZenStack's check API to determine user permissions.

LANGUAGE: typescript
CODE:
export const accessControlProvider: AccessControlProvider = {
  can: async ({ resource, action }: CanParams): Promise<CanReturnType> => {
    if (action === 'create') {
      // make a request to "/api/model/:resource/check?q={operation:'create'}"
      let url = `/api/model/${resource}/check`;
      url +=
        '?q=' +
        encodeURIComponent(
            JSON.stringify({
                operation: 'create',
            })
        );
      const resp = await fetch(url);
      if (!resp.ok) {
        return { can: false };
      } else {
        const { data } = await resp.json();
        return { can: data };
      }
    }

    return { can: true };
  },

  options: {
    buttons: {
        enableAccessControl: true,
        hideIfUnauthorized: false,
    },
    queryOptions: {},
  },
};

----------------------------------------

TITLE: Using HasSome Function with Array in ZenStack Policy
DESCRIPTION: This example illustrates how to use the hasSome() function to check if an array field contains any of the specified values in a policy rule.

LANGUAGE: zmodel
CODE:
model Post {
    id Int @id
    tags String[]
    @@allow('read', hasSome(tags, ['zenstack', 'prisma']))
}

----------------------------------------

TITLE: Configuring OpenAPI Plugin in ZModel (ZModel)
DESCRIPTION: This snippet shows how to declare and configure the OpenAPI plugin in a ZModel file. It specifies the provider, output file, API title, and version.

LANGUAGE: zmodel
CODE:
plugin openapi {
    provider = "@zenstackhq/openapi"
    output = "openapi.yaml"
    title = "My Todo API"
    version = "1.0.0"
}

----------------------------------------

TITLE: Implementing Next.js Signin Page
DESCRIPTION: A React component for user authentication using NextAuth. Includes form handling, error management, and navigation between signup and signin pages.

LANGUAGE: tsx
CODE:
'use client';

import { signIn } from 'next-auth/react';
import Link from 'next/link';
import { useState, type FormEvent } from 'react';

export default function Signup() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [errMsg, setErrMsg] = useState('');

  async function onSignin(e: FormEvent<HTMLFormElement>) {
    e.preventDefault();
    const signInResult = await signIn('credentials', {
      redirect: false,
      email,
      password,
    });
    if (signInResult?.ok) {
      window.location.href = '/';
    } else {
      setErrMsg(`Signin failed. Please check your email and password.`);
    }
  }

  return (
    <div className="mx-auto flex h-screen flex-col items-center justify-center">
      <div className="mb-10 flex items-center space-x-4">
        <h1 className="text-4xl">Welcome to Todo</h1>
      </div>
      <div className="flex w-full max-w-screen-sm items-center justify-center rounded-lg">
        <div className="w-full space-y-8 p-16">
          <h2 className="text-3xl font-bold">Sign in to your account</h2>
          <form className="mt-8 space-y-6" action="#" onSubmit={onSignin}>
            <div>
              <label htmlFor="email" className="label">
                Your email
              </label>
              <input
                type="email"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
                className="input input-bordered w-full"
                placeholder="Email address"
                required
              />
            </div>
            <div>
              <label htmlFor="password" className="label">
                Your password
              </label>
              <input
                type="password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                placeholder="••••••••"
                className="input input-bordered w-full"
                required
              />
            </div>

            {errMsg && <p className="text-sm text-red-600">{errMsg}</p>}

            <button className="btn btn-primary mt-4" type="submit">
              Create account
            </button>
            <div>
              Not registered?{' '}
              <Link href="/signup" className="text-primary">
                Create account
              </Link>
            </div>
          </form>
        </div>
      </div>
    </div>
  );

----------------------------------------

TITLE: Using This Expression in ZenStack Policy
DESCRIPTION: This example shows how to use the 'this' keyword to refer to the containing model in a policy rule.

LANGUAGE: zmodel
CODE:
model User {
    id Int @id
    @@allow('all', auth() == this) // `this` is a This Expression
}

----------------------------------------

TITLE: ZenStack Schema Generation and Database Commands
DESCRIPTION: Commands for generating schema, pushing to database, and starting REPL environment.

LANGUAGE: bash
CODE:
npx zenstack generate
npx prisma db push
npx zenstack repl

----------------------------------------

TITLE: Implementing Todo List Page with ZenStack Queries
DESCRIPTION: A Next.js page component that manages a list of Todos, including creation, display, and management functionality. Uses ZenStack-generated hooks for data fetching and creation.

LANGUAGE: tsx
CODE:
"use client";

import { useSession } from "next-auth/react";
import { useParams } from "next/navigation";
import { useState } from "react";
import TodoComponent from "~/components/TodoComponent";
import { useCreateTodo, useFindManyTodo, useFindUniqueList } from "~/lib/hooks";

export default function TodoList() {
  const { listId } = useParams<{ listId: string }>();
  const { data: session } = useSession();

  const { data: list } = useFindUniqueList(
    {
      where: { id: listId },
    },
    { enabled: !!session?.user },
  );

  const { mutate: create } = useCreateTodo();
  const { data: todos } = useFindManyTodo(
    {
      where: { listId },
      orderBy: { createdAt: "desc" as const },
    },
    { enabled: !!session?.user },
  );

  const [title, setTitle] = useState("");

  function onCreate() {
    create({
      data: {
        title,
        owner: { connect: { id: session?.user.id } },
        list: { connect: { id: listId } },
      },
    });
    setTitle("");
  }

  if (!session?.user || !list) {
    return <></>;
  }

  return (
    <div>
      <div className="container mx-auto flex w-full flex-col items-center py-12">
        <h1 className="mb-4 text-2xl font-semibold">{list.title}</h1>
        <div className="flex space-x-2">
          <input
            type="text"
            placeholder="Type a title and press enter"
            className="input input-bordered mt-2 w-72 max-w-xs"
            value={title}
            autoFocus
            onKeyUp={(e) => {
              if (e.key === "Enter") {
                onCreate();
              }
            }}
            onChange={(e) => {
              setTitle(e.currentTarget.value);
            }}
          />
        </div>
        <ul className="flex w-auto flex-col space-y-4 py-8">
          {todos?.map((todo) => (
            <TodoComponent
              key={todo.id}
              value={todo}
              optimistic={todo.$optimistic}
            />
          ))}
        </ul>
      </div>
    </div>
  );
}

----------------------------------------

TITLE: Using This Expression in ZenStack Policy
DESCRIPTION: This example shows how to use the 'this' keyword to refer to the containing model in a policy rule.

LANGUAGE: zmodel
CODE:
model User {
    id Int @id
    @@allow('all', auth() == this) // `this` is a This Expression
}

----------------------------------------

TITLE: Generating ZModel Content from AST in TypeScript
DESCRIPTION: This snippet shows how to use the ZModelCodeGenerator from ZenStack SDK to generate ZModel content from the AST.

LANGUAGE: typescript
CODE:
import { ZModelCodeGenerator } from '@zenstackhq/sdk';
const zModelGenerator = new ZModelCodeGenerator();
const zmodel = zModelGenerator.generate(model);

----------------------------------------

TITLE: Sample ZModel Schema
DESCRIPTION: Example ZModel schema showing datasource configuration and model definitions with relationships and access controls.

LANGUAGE: zmodel
CODE:
datasource db {
    provider = 'sqlite'
    url = 'file:.dev.db'
}

model User {
    id Int @id @default(autoincrement())
    posts Post[]
}

model Post {
    id Int @id @default(autoincrement())
    title String
    author User @relation(fields: [authorId], references: [id])
    authorId Int

    @@allow('all', auth() == author)
}

----------------------------------------

TITLE: Adding Password Field to User Model in ZModel
DESCRIPTION: This snippet shows how to add a password field to an existing User model, using the @password attribute for automatic hashing.

LANGUAGE: zmodel
CODE:
model User {
    ...
    password String? @password
}

----------------------------------------

TITLE: Combining Pre-Update and Post-Update Checks in ZenStack
DESCRIPTION: This example shows how to combine pre-update and post-update checks in a single rule, ensuring a post is not published and its revision is increasing.

LANGUAGE: zmodel
CODE:
model Post {
    ...
    published Boolean
    revision Int

    @@allow('update', !published && future().revision > revision)
}

----------------------------------------

TITLE: Sample Query Debug Output
DESCRIPTION: Example of the debug output showing how ZenStack transforms queries to enforce access policies.

LANGUAGE: javascript
CODE:
prisma:info [policy] `findMany` list:
{
  where: {
    AND: [
      { NOT: { OR: [] } },
      {
        OR: [
          { owner: { is: { id: 1 } } },
          {
            AND: [
              {
                space: {
                  members: {
                    some: { user: { is: { id: 1 } } }
                  }
                }
              },
              { NOT: { private: true } }
            ]
          }
        ]
      }
    ]
  }
}

----------------------------------------

TITLE: Installing Prisma and NextAuth Dependencies
DESCRIPTION: Commands to install Prisma and NextAuth dependencies for the project.

LANGUAGE: bash
CODE:
npm install --save-dev prisma
npm install @prisma/client next-auth@beta

----------------------------------------

TITLE: Adding Password Field to User Model in ZModel
DESCRIPTION: This snippet shows how to add a password field to an existing User model, using the @password attribute for automatic hashing.

LANGUAGE: zmodel
CODE:
model User {
    ...
    password String? @password
}

----------------------------------------

TITLE: Referencing Model Field in ZenStack Policy
DESCRIPTION: Demonstrates how to reference a model field in a ZenStack policy rule using a Reference Expression.

LANGUAGE: zmodel
CODE:
model Post {
    ...
    published Boolean
    @@allow('read', published) // `published` is a Reference Expression
}

----------------------------------------

TITLE: React Auth0 User Profile Component
DESCRIPTION: React component implementing Auth0 user profile creation and database integration.

LANGUAGE: typescript
CODE:
import React from "react";
import { useAuth0 } from "@auth0/auth0-react";

const Profile = () => {
  const { user, isAuthenticated, isLoading } = useAuth0();

  const createUser = useCallback(async (event: FormEvent<HTMLFormElement>) => {
    const formData = new FormData(event.currentTarget);
    const name = formData.get('name');

    try {
      await fetch('/api/create-user', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            id: user.sub,
            name: name,
          }),
        });
    } catch(error){...}

  return <UserForm onSubmit={createUser}/>
};

----------------------------------------

TITLE: Defining Model-Level Allow Policy in ZenStack
DESCRIPTION: Example of using @@allow attribute to define a read policy for published posts in a Post model.

LANGUAGE: zmodel
CODE:
model Post {
    id Int @id
    title String
    published Boolean @default(false)

    // published posts are readable
    @@allow('read', published)
}

----------------------------------------

TITLE: Initializing ZenStack Project
DESCRIPTION: Command to initialize the project for ZenStack, which installs dependencies and copies the Prisma schema to a ZModel file.

LANGUAGE: bash
CODE:
npx zenstack@latest init

----------------------------------------

TITLE: Defining Post Model with Access Policies in ZModel
DESCRIPTION: Example of a Post model definition with access policies using ZModel syntax, demonstrating author permissions and published post visibility rules.

LANGUAGE: zmodel
CODE:
model Post {
    id        String @id @default(cuid())
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
    title     String
    published Boolean @default(false)
    author    User @relation(fields: [authorId], references: [id])
    authorId  String

    // author has full access
    @@allow('all', auth() == author)

    // logged-in users can view published posts
    @@allow('read', auth() != null && published)
}

----------------------------------------

TITLE: Using Custom Auth Model in ZModel
DESCRIPTION: This example demonstrates how to use a custom model (not named 'User') as the auth model by adding the @@auth attribute.

LANGUAGE: zmodel
CODE:
model MyUser {
    id Int @id
    role String
    posts Post[]

    @@auth
}

----------------------------------------

TITLE: Basic SQL Analytics Query
DESCRIPTION: SQL query to count pages created in the previous month.

LANGUAGE: sql
CODE:
SELECT COUNT(*) FROM pages
WHERE created_at >= DATE_TRUNC('month', CURRENT_DATE - INTERVAL '1' MONTH)
AND created_at < DATE_TRUNC('month', CURRENT_DATE)

----------------------------------------

TITLE: Reading a Base Entity with Enhanced PrismaClient
DESCRIPTION: This code snippet shows how to read an Asset entity using the enhanced PrismaClient. The runtime includes related concrete entities and merges their fields based on the discriminator.

LANGUAGE: typescript
CODE:
const asset = await db.asset.findFirst();

----------------------------------------

TITLE: Using Enhanced Prisma Client in REPL
DESCRIPTION: Examples of using the enhanced Prisma Client in a REPL environment to perform database operations.

LANGUAGE: bash
CODE:
npx zenstack repl

LANGUAGE: javascript
CODE:
db.user.findMany();

LANGUAGE: javascript
CODE:
[]

----------------------------------------

TITLE: Error Message for Dynamic Module Loading
DESCRIPTION: Example error message when attempting to dynamically load modules in edge runtime.

LANGUAGE: plaintext
CODE:
Error: Dynamic require of "[Module Name]" is not supported.

----------------------------------------

TITLE: Initializing Supabase Client and Querying Data in TypeScript
DESCRIPTION: TypeScript code showing how to initialize the Supabase client and make a database query using the Supabase JavaScript SDK.

LANGUAGE: typescript
CODE:
// Initialize the JS client
import { createClient } from '@supabase/supabase-js';
const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

// Make a request
const { data: todos, error } = await supabase.from('todos').select('*');

----------------------------------------

TITLE: Next.js Configuration for ZenStack
DESCRIPTION: Configure Next.js to handle external packages for server components

LANGUAGE: javascript
CODE:
const config = {
  experimental: {
    serverComponentsExternalPackages: ["@zenstackhq/runtime"],
  }
};

----------------------------------------

TITLE: ZModel Enhanced User Model Example
DESCRIPTION: Demonstrates ZModel's custom attributes for validation, password handling, and access policies

LANGUAGE: zmodel
CODE:
model User {
    id Int @id @default(autoincrement())

    // during create and update, ZenStack validates the field is a valid email address
    email String @unique @email

    // the field is automatically hashed upon saving, and omitted from query results
    password String @omit @password

    // access policy: open to sign up
    @@allow('create', true)

    // access policy: the user has full access to self
    @@allow('all', auth() == this)
}

----------------------------------------

TITLE: Creating Enhanced Prisma Client in TypeScript
DESCRIPTION: Demonstrates how to create and use an enhanced Prisma Client instance by wrapping a regular Prisma Client. Shows basic database operations with the enhanced client.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client';
import { enhance } from '@zenstackhq/runtime';

const prisma = new PrismaClient();
const db = enhance(prisma);

// db has the same typing as prisma
await db.user.findMany();
await db.user.create({ data: { email: 'zen@stack.dev'} });

----------------------------------------

TITLE: Implementing List Management UI with Next.js and ZenStack
DESCRIPTION: React component implementing list management functionality within spaces using ZenStack hooks for data fetching and mutation.

LANGUAGE: tsx
CODE:
'use client';

import { useSession } from 'next-auth/react';
import Link from 'next/link';
import { useParams } from 'next/navigation';
import { useCreateList, useFindManyList, useFindUniqueSpace } from '~/lib/hooks';

export default function SpaceHome() {
    const { slug } = useParams<{ slug: string }>();

    const { data: session } = useSession();

    const { data: space } = useFindUniqueSpace({ where: { slug } }, { enabled: !!session?.user });

    const { data: lists } = useFindManyList(
        {
            where: { space: { slug } },
            include: { owner: true },
            orderBy: { updatedAt: 'desc' },
        },
        { enabled: !!session?.user },
    );

    const { mutate: createList } = useCreateList();

    function onCreateList() {
        const title = prompt('Enter a title for your list');
        if (title) {
            createList({
                data: {
                    title,
                    space: { connect: { id: space?.id } },
                    owner: { connect: { id: session?.user.id } },
                },
            });
        }
    }

    if (!session?.user || !space || !lists) return null;

    return (
        <div className="container mx-auto mt-16">
            <h1 className="text-center text-3xl">
                Welcome to Space <span className="italic">{space.name}</span>
            </h1>
            <div className="p-8">
                <button className="btn btn-primary btn-wide" onClick={onCreateList}>
                    Create a list
                </button>

                <ul className="mt-8 flex flex-wrap gap-6">
                    {lists?.map((list) => (
                        <Link href={`/spaces/${slug}/${list.id}`} key={list.id}>
                            <li className="flex h-32 w-72 items-center justify-center rounded-lg border text-2xl">
                                {list.title}
                            </li>
                        </Link>
                    ))}
                </ul>
            </div>
        </div>
    );
}

----------------------------------------

TITLE: ZModel Enhanced User Model Example
DESCRIPTION: Demonstrates ZModel's custom attributes for validation, password handling, and access policies

LANGUAGE: zmodel
CODE:
model User {
    id Int @id @default(autoincrement())

    // during create and update, ZenStack validates the field is a valid email address
    email String @unique @email

    // the field is automatically hashed upon saving, and omitted from query results
    password String @omit @password

    // access policy: open to sign up
    @@allow('create', true)

    // access policy: the user has full access to self
    @@allow('all', auth() == this)
}

----------------------------------------

TITLE: Supabase RLS Policy Definition
DESCRIPTION: Basic RLS policy example for PostgreSQL giving owners full access to their posts

LANGUAGE: sql
CODE:
-- owner has full access to her own posts
CREATE POLICY post_owner_policy ON post
    USING (owner = current_user);

----------------------------------------

TITLE: Installing ZenStack Server Package
DESCRIPTION: Command to install the ZenStack server package using npm package manager

LANGUAGE: bash
CODE:
npm install @zenstackhq/server

----------------------------------------

TITLE: Using Prisma Client for Database Operations
DESCRIPTION: Examples of using PrismaClient for creating users, creating related records, and querying data with relationships.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient();

// create a user
await prisma.user.create({
    data: { email: 'user1@abc.com' }
});

// create a user together with two related posts
await prisma.user.create({ 
    data: {
        email: 'user2@abc.com',
        posts: {
            create: [
                { title: 'Post 1' },
                { title: 'Post 2' }
            ]
        }
    }
});

// find posts with title containing some text, and return the author of each post together
const posts = prisma.post.findMany({
    where: { title: { contains: 'ZenStack' } },
    include: { author: true }
});

// here the `posts` is smartly inferred to be typed `Array<Post & { author: User }>`
console.log(posts[0].author.email);

----------------------------------------

TITLE: Listing Installed ZenStack Packages
DESCRIPTION: Command to list all installed ZenStack packages and their versions, checking for updates.

LANGUAGE: bash
CODE:
npx zenstack info

----------------------------------------

TITLE: Using Prisma Client for Database Operations
DESCRIPTION: Examples of using PrismaClient for creating users, creating related records, and querying data with relationships.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient();

// create a user
await prisma.user.create({
    data: { email: 'user1@abc.com' }
});

// create a user together with two related posts
await prisma.user.create({ 
    data: {
        email: 'user2@abc.com',
        posts: {
            create: [
                { title: 'Post 1' },
                { title: 'Post 2' }
            ]
        }
    }
});

// find posts with title containing some text, and return the author of each post together
const posts = prisma.post.findMany({
    where: { title: { contains: 'ZenStack' } },
    include: { author: true }
});

// here the `posts` is smartly inferred to be typed `Array<Post & { author: User }>`
console.log(posts[0].author.email);

----------------------------------------

TITLE: Creating a New Next.js Project with Dependencies
DESCRIPTION: Command to create a new Next.js project using create-t3-app with Prisma, NextAuth and TailwindCSS

LANGUAGE: bash
CODE:
npx create-t3-app@latest --prisma --nextAuth --tailwind --CI my-saas-app
cd my-saas-app
npm run dev

----------------------------------------

TITLE: Auth Type Definition in ZModel
DESCRIPTION: ZModel type definition for Auth0 authentication object structure.

LANGUAGE: zmodel
CODE:
type Auth {
  id         String @id
  specialKey String
  @@auth
}

----------------------------------------

TITLE: Defining Basic Prisma Data Model
DESCRIPTION: Example of defining a simple User model in Prisma schema with primary key, unique field, and optional field.

LANGUAGE: zmodel
CODE:
model User {
    id Int @id @default(autoincrement())
    email String @unique
    name String?
}

----------------------------------------

TITLE: Type-Safe Query with Prisma Client
DESCRIPTION: Demonstrates type-safe query selection using Prisma client in TypeScript, showing field selection and type inference capabilities.

LANGUAGE: typescript
CODE:
const result = await prisma.movie.findMany({
  select: {
    id: true,
    title: true,
    year: true
  }
})

----------------------------------------

TITLE: Implementing Access Control in NestJS Controller
DESCRIPTION: Examples of manual access control implementation in NestJS controllers for user and post endpoints.

LANGUAGE: typescript
CODE:
@Get('users')
async getAllUsers() {
  return this.prismaService.user.findMany({
    // make sure to exclude "email" field
    select: { id: true, name: true, role: true },
  });
}

private get currentUser() {
  const id = this.clsService.get('userId');
  const role = this.clsService.get('userRole') ?? 'USER';
  // undefined means anonymous user
  return id ? { id: Number(id), role } : undefined;
}

private makePostAuthFilter() {
  // user is editor, or post is published or user is author
  return this.currentUser
    ? this.currentUser.role === 'EDITOR'
      ? {}
      : { OR: [{ published: true }, { author: { id: this.currentUser.id } }] }
    : { published: true };
}

@Get('post')
async getFilteredPosts(...): Promise<PostModel[]> {
  const searchFilter = ...; // search conditions for filtering title, etc.
  const authFilter = this.makePostAuthFilter();

  return this.prismaService.post.findMany({
    where: { AND: [searchFilter, authFilter] },
    // make sure to exclude "email" field; needed in all routes that fetch posts
    include: { author: { select: { id: true, name: true, role: true } } },
    ...
  });
}

@Put('publish/:id')
async togglePublishPost(@Param('id') id: string): Promise<PostModel> {
  if (this.currentUser?.role !== 'EDITOR') {
    throw new UnauthorizedException('You are not authorized to publish posts');
  }
  ...
}

----------------------------------------

TITLE: ZModel Multi-file Import Example
DESCRIPTION: Demonstrates how to break down schemas into multiple files using imports

LANGUAGE: zmodel
CODE:
import "user"
import "post"

LANGUAGE: zmodel
CODE:
model User {
    id Int @id @default(autoincrement())
    email String @unique
    posts Post[]
}

LANGUAGE: zmodel
CODE:
model Post {
    id Int @id @default(autoincrement())
    title String
    author User @relation(fields: [authorId], references: [id])
    authorId Int
}

----------------------------------------

TITLE: Defining Prisma Model Relationships
DESCRIPTION: Demonstration of one-to-many relationship between User and Post models using @relation attribute and foreign key.

LANGUAGE: zmodel
CODE:
model User {
    id Int @id @default(@autoincrement())
    ...
    posts Post[]
}

model Post {
    id Int @id @default(@autoincrement())
    title String
    author User @relation(fields: [authorId], references: [id])
    authorId Int
}

----------------------------------------

TITLE: Using Search Function in ZenStack Policy
DESCRIPTION: This snippet illustrates the use of the search() function for full-text search in a policy rule.

LANGUAGE: zmodel
CODE:
@@allow('read', contains(title, 'zenstack is awesome'))

----------------------------------------

TITLE: ZModel Schema with Model Inheritance
DESCRIPTION: Shows how to use model inheritance and relationships in a full schema

LANGUAGE: zmodel
CODE:
import "base"
model User extends Base {
    name String
}

model Post extends Base {
    title String
    content String?
    viewCount Int @default(0)
    comment Comment[]
}

model Comment extends Base {
    content String
    post Post @relation(fields: [postId], references: [id])
    postId Int
}

----------------------------------------

TITLE: Installing ZenStack Server Package
DESCRIPTION: Command to install the ZenStack server package using npm.

LANGUAGE: bash
CODE:
npm install @zenstackhq/server

----------------------------------------

TITLE: Adding Custom Field to Prisma Query Result
DESCRIPTION: Demonstrates how to add a computed 'fullName' field to the User model query results using Client Extensions.

LANGUAGE: typescript
CODE:
const xprisma = prisma.$extends({
    result: {
        user: {
            fullName: {
                needs: { firstName: true, lastName: true },
                compute(user) {
                    return `${user.firstName} ${user.lastName}`;
                },
            },
        },
    },
});

const user = await xprisma.user.findFirst();
console.log(user.fullName);

----------------------------------------

TITLE: Basic ZModel User Model with TypeGraphQL Comment Example
DESCRIPTION: Demonstrates how TypeGraphQL traditionally handled custom attributes through comments in Prisma schema

LANGUAGE: zmodel
CODE:
model User {
    id Int @default(autoincrement()) @id
    email String @unique
    /// @TypeGraphQL.omit(output: true, input: true)
    password String
}

----------------------------------------

TITLE: ZenStack Module Registration Type Definitions
DESCRIPTION: Type definitions for the ZenStack module registration options, including async configuration options and module options interfaces.

LANGUAGE: typescript
CODE:
interface ZenStackModuleAsyncOptions {
  imports?: Array<Type<any> | DynamicModule | Promise<DynamicModule> | ForwardReference>;
  global?: boolean;
  exportToken?: string;
  useFactory: (...args: unknown[]) => Promise<ZenStackModuleOptions> | ZenStackModuleOptions;
  inject?: FactoryProvider['inject'];
  extraProviders?: Provider[];
}

interface ZenStackModuleOptions {
  getEnhancedPrisma: (model?: string | symbol) => unknown;
}

----------------------------------------

TITLE: Creating User with Password in JavaScript REPL
DESCRIPTION: This JavaScript snippet demonstrates creating a new user with a password in the REPL, which will trigger the automatic hashing.

LANGUAGE: javascript
CODE:
db.user.create({ data: { email: 'ross@zenstack.dev', password: 'abc123' }})

----------------------------------------

TITLE: Creating ZenStack Plugin Structure in TypeScript
DESCRIPTION: This snippet demonstrates the basic structure of a ZenStack plugin, including the named export for the plugin name and the default function export containing the plugin logic.

LANGUAGE: typescript
CODE:
import type { PluginOptions } from '@zenstackhq/sdk';
import type { DMMF } from '@zenstackhq/sdk/prisma';
import type { Model } from '@zenstackhq/sdk/ast';

export const name = 'ZenStack MarkDown';

export default async function run(model: Model, options: PluginOptions, dmmf: DMMF.Document) {
    ...
}

----------------------------------------

TITLE: Generating Prisma Client
DESCRIPTION: This command generates a type-safe Prisma client for database access based on the defined schema.

LANGUAGE: bash
CODE:
npx prisma generate

----------------------------------------

TITLE: Querying User with Raw Prisma Client in JavaScript
DESCRIPTION: This snippet shows how to query the created user using the raw Prisma Client, revealing the hashed password.

LANGUAGE: javascript
CODE:
prisma.user.findFirst({ orderBy: { id: 'desc' } });

----------------------------------------

TITLE: Integrating QueryClientProvider in Next.js Layout
DESCRIPTION: This snippet shows how to integrate the QueryClientProvider into the root layout of a Next.js application.

LANGUAGE: tsx
CODE:
import QueryClientProvider from '~/components/QueryClientProvider';

export default function RootLayout({ children }: { children: React.ReactNode }) {
  return (
    <html lang="en">
      <body className={`font-sans ${inter.variable}`}>
        <QueryClientProvider>
          <NextAuthSessionProvider>{children}</NextAuthSessionProvider>
        </QueryClientProvider>
      </body>
    </html>
  );
}

----------------------------------------

TITLE: ZModel Model Inheritance
DESCRIPTION: Example of model inheritance using abstract models.

LANGUAGE: zmodel
CODE:
abstract model Basic {
    id String @id
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt
}

model User extends Basic {
    name String 
}

----------------------------------------

TITLE: Sample ZModel Schema Definition
DESCRIPTION: Example of a basic ZModel schema showing datasource configuration and model definitions with relationships and access control.

LANGUAGE: zmodel
CODE:
datasource db {
    provider = 'sqlite'
    url = 'file:.dev.db'
}

model User {
    id Int @id @default(autoincrement())
    posts Post[]
}

model Post {
    id Int @id @default(autoincrement())
    title String
    author User @relation(fields: [authorId], references: [id])
    authorId Int

    @@allow('all', auth() == author)
}

----------------------------------------

TITLE: Extending organizationBaseEntity for ToDo Model in ZenStack
DESCRIPTION: This snippet demonstrates how to create a new ToDo model by extending the organizationBaseEntity, inheriting all common permissions and adding a specific update policy for shared users.

LANGUAGE: typescript
CODE:
model ToDo extends organizationBaseEntity {
    name String
    isCompleted Boolean @default(false)

    @@allow('update', groups?[users?[id == auth().id]] )
}

----------------------------------------

TITLE: Installing OpenAPI Plugin with NPM
DESCRIPTION: Command to install the @zenstackhq/openapi plugin as a development dependency.

LANGUAGE: bash
CODE:
npm install --save-dev @zenstackhq/openapi

----------------------------------------

TITLE: Generating ZenStack Supporting Modules for Source Tree
DESCRIPTION: This command demonstrates how to use the ZenStack CLI to generate supporting modules into the source tree, allowing for deployment without running the CLI during the build process.

LANGUAGE: bash
CODE:
npx zenstack generate --output ./zenstack

----------------------------------------

TITLE: Installing OpenAPI Plugin with NPM
DESCRIPTION: Command to install the @zenstackhq/openapi plugin as a development dependency.

LANGUAGE: bash
CODE:
npm install --save-dev @zenstackhq/openapi

----------------------------------------

TITLE: Querying and Modifying Posts using RPC API Endpoints
DESCRIPTION: Demonstrates various HTTP requests for finding, creating, updating, and deleting posts using the RPC API flavor. Includes examples of query parameters for filtering and including related data.

LANGUAGE: typescript
CODE:
// find all posts
GET /api/model/post/findMany
=> [{ id: 1, title: 'Hello World', ... }, ...}]

// find all published posts, the "q" parameter is `{"where":{"published":true}}` url-encoded
GET /api/model/post/findMany?q=%7B%22where%22%3A%7B%22published%22%3Atrue%7D%7D
=> [{ id: 1, title: 'Hello World', ... }, ...}]

// find all posts with their authors, the "q" parameter is `{"include":{"author":true}}` url-encoded
GET /api/model/post/findMany?q=%7B%22include%22%3A%7B%22author%22%3Atrue%7D%7D
=> [{ id: 1, title: 'Hello World', author: { id: 1, name: 'Joey', ... } }, ...}]

// create a post for user#1
POST /api/model/post/create
{
    "data": {
        "title": "Hello World",
        "author": { "connect": { "id": 1 } }
    }
}

// update a post
POST /api/model/post/update
{
    "where": { "id": 1 },
    "data": { "title": "Hello New World!" }
}

// delete a post
DELETE /api/model/post/delete
{
    "where": { "id": 1 }
}

----------------------------------------

TITLE: Creating Enhanced PrismaClient with User Information in TypeScript
DESCRIPTION: This TypeScript snippet demonstrates how to create an enhanced PrismaClient using the enhance API from ZenStack. It includes fetching the current user and passing the user information to the enhance function.

LANGUAGE: typescript
CODE:
const user = await getCurrentUser(); // your implementation
const db = enhance(prisma, { user });

----------------------------------------

TITLE: Creating Enhanced PrismaClient with User Information in TypeScript
DESCRIPTION: This TypeScript snippet demonstrates how to create an enhanced PrismaClient using the enhance API from ZenStack. It includes fetching the current user and passing the user information to the enhance function.

LANGUAGE: typescript
CODE:
const user = await getCurrentUser(); // your implementation
const db = enhance(prisma, { user });

----------------------------------------

TITLE: Disabling Automatic Query Invalidation
DESCRIPTION: Example of disabling automatic query invalidation for a specific mutation hook.

LANGUAGE: ts
CODE:
useCreatePost({ revalidate: false });

----------------------------------------

TITLE: Querying List Data with Curl in Bash
DESCRIPTION: This snippet demonstrates how to make an HTTP request to find the first List with selected fields using curl.

LANGUAGE: bash
CODE:
curl "http://localhost:3000/api/rpc/list/findFirst?q=%7B%22select%22%3A%7B%22id%22%3Atrue%2C%22title%22%3Atrue%7D%7D" -H "x-user-id: 1"

----------------------------------------

TITLE: Deserialized JavaScript Object
DESCRIPTION: This JavaScript snippet shows the result of deserializing the data, with createdAt and updatedAt properly converted to Date objects.

LANGUAGE: javascript
CODE:
{
    createdAt: 2023-11-08T04:38:53.385Z,
    id: 1,
    ownerId: 1,
    private: false,
    spaceId: 1,
    title: 'Grocery',
    updatedAt: 2023-11-09T04:52:57.987Z
}

----------------------------------------

TITLE: Adding Validation Attributes to JSON Field Types in ZModel
DESCRIPTION: This snippet shows how to add validation attributes to fields in custom types for JSON fields, which will be enforced during mutations.

LANGUAGE: zmodel
CODE:
type Profile {
  name String
  age Int @gte(18) @lt(150) // must be between 18 and 150
  address Address?
}

----------------------------------------

TITLE: Deserialized JavaScript Object
DESCRIPTION: This JavaScript snippet shows the result of deserializing the data, with createdAt and updatedAt properly converted to Date objects.

LANGUAGE: javascript
CODE:
{
    createdAt: 2023-11-08T04:38:53.385Z,
    id: 1,
    ownerId: 1,
    private: false,
    spaceId: 1,
    title: 'Grocery',
    updatedAt: 2023-11-09T04:52:57.987Z
}

----------------------------------------

TITLE: Mounting CRUD API with ZenStack Server Adapter
DESCRIPTION: Setting up a Next.js API route to handle CRUD operations using ZenStack's server adapter.

LANGUAGE: typescript
CODE:
import { enhance } from '@zenstackhq/runtime';
import { NextRequestHandler } from '@zenstackhq/server/next';
import { getServerSession } from 'next-auth';
import { authOptions } from '~/server/auth';
import { db } from '~/server/db';

async function getPrisma() {
  const session = await getServerSession(authOptions);
  return enhance(db, { user: session?.user });
}

const handler = NextRequestHandler({ getPrisma, useAppDir: true });

export { handler as DELETE, handler as GET, handler as PATCH, handler as POST, handler as PUT };

----------------------------------------

TITLE: Setting up ZenStack CRUD API Routes
DESCRIPTION: Implements API routes for CRUD operations using ZenStack's Next.js adapter with authentication integration.

LANGUAGE: typescript
CODE:
import { enhance } from '@zenstackhq/runtime';
import { NextRequestHandler } from '@zenstackhq/server/next';
import { getServerSession } from 'next-auth';
import { authOptions } from '~/server/auth';
import { db } from '~/server/db';

async function getPrisma() {
  const session = await getServerSession(authOptions);
  const user = session ? { id: session.user.id } : undefined;
  return enhance(db, { user });
}

const handler = NextRequestHandler({ getPrisma, useAppDir: true });

export { handler as DELETE, handler as GET, handler as PATCH, handler as POST, handler as PUT };

----------------------------------------

TITLE: Setting up ZenStack CRUD API Routes
DESCRIPTION: Implements API routes for CRUD operations using ZenStack's Next.js adapter with authentication integration.

LANGUAGE: typescript
CODE:
import { enhance } from '@zenstackhq/runtime';
import { NextRequestHandler } from '@zenstackhq/server/next';
import { getServerSession } from 'next-auth';
import { authOptions } from '~/server/auth';
import { db } from '~/server/db';

async function getPrisma() {
  const session = await getServerSession(authOptions);
  const user = session ? { id: session.user.id } : undefined;
  return enhance(db, { user });
}

const handler = NextRequestHandler({ getPrisma, useAppDir: true });

export { handler as DELETE, handler as GET, handler as PATCH, handler as POST, handler as PUT };

----------------------------------------

TITLE: Implementing List Management UI in Next.js
DESCRIPTION: Shows the implementation of a list management UI within a space, using ZenStack hooks for querying and mutating data. It demonstrates fetching lists, creating new lists, and leveraging automatic query invalidation.

LANGUAGE: tsx
CODE:
'use client';

import { useSession } from 'next-auth/react';
import Link from 'next/link';
import { useParams } from 'next/navigation';
import { useCreateList, useFindManyList, useFindUniqueSpace } from '~/lib/hooks';

export default function SpaceHome() {
  const { slug } = useParams<{ slug: string }>();

  const { data: session } = useSession();

  const { data: space } = useFindUniqueSpace({ where: { slug } }, { enabled:!!session?.user });

  const { data: lists } = useFindManyList(
    {
      where: { space: { slug } },
      include: { owner: true },
      orderBy: { updatedAt: 'desc' },
    },
    { enabled: !!session?.user },
  );

  const { mutate: createList } = useCreateList();

  function onCreateList() {
    const title = prompt('Enter a title for your list');
    if (title) {
      createList({
        data: {
          title,
          space: { connect: { id: space?.id } },
        },
      });
    }
  }

  if (!session?.user || !space || !lists) return null;

  return (
    <div className="container mx-auto mt-16">
      <h1 className="text-center text-3xl">
        Welcome to Space <span className="italic">{space.name}</span>
      </h1>
      <div className="p-8">
        <button className="btn btn-primary btn-wide" onClick={onCreateList}>
          Create a list
        </button>

        <ul className="mt-8 flex flex-wrap gap-6">
          {lists?.map((list) => (
            <Link href={`/spaces/${slug}/${list.id}`} key={list.id}>
              <li className="flex h-32 w-72 items-center justify-center rounded-lg border text-2xl">
                {list.title}
              </li>
            </Link>
          ))}
        </ul>
      </div>
    </div>
  );
}

----------------------------------------

TITLE: Defining Access Policies for Polymorphic Models in ZModel
DESCRIPTION: This snippet demonstrates how to add access policies to polymorphic models in ZModel, which are inherited by sub-models.

LANGUAGE: zmodel
CODE:
model User {
  id Int @id @default(autoincrement())
  contents Content[]

  @@allow('create,read', true)
  @@allow('all', auth() == this)
}

model Content {
  id Int @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  owner User @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  ownerId Int
  published Boolean @default(false)
  contentType String

  @@delegate(contentType)

  @@allow('read', published)
  @@allow('all', auth() == owner)
}

model Post extends Content {
  title String
}

model Video extends Content {
  name String
  duration Int
}

----------------------------------------

TITLE: Throwing PrismaClientKnownRequestError in TypeScript
DESCRIPTION: Demonstrates how ZenStack throws a PrismaClientKnownRequestError with code P2004 when an operation is rejected by access policies or fails data validation rules. The error includes a meta field with additional information about the rejection reason.

LANGUAGE: typescript
CODE:
throw new PrismaClientKnownRequestError(message, {
    clientVersion: getVersion(),
    code: 'P2004',
    meta: ...
});

----------------------------------------

TITLE: Defining Auth Model in ZModel
DESCRIPTION: This snippet shows how to define a User model that serves as the auth model, and how to use it in policy rules for a Post model.

LANGUAGE: zmodel
CODE:
model User {
    id Int @id
    role String
    posts Post[]
}

model Post {
    id Int @id
    title String
    author User @relation(fields: [authorId], references: [id])
    authorId Int

    // ✅ valid rule
    @@allow('all', auth().role == 'ADMIN')

    // ❌ invalid rule, `subscribed` field doesn't exist in `User` model
    @@allow('all', auth().subscribed == true) 
}

----------------------------------------

TITLE: Implementing Space Management UI in Next.js
DESCRIPTION: Demonstrates the implementation of a space management UI using ZenStack hooks for querying and mutating data. It shows how to fetch spaces, create new spaces, and handle automatic query invalidation.

LANGUAGE: tsx
CODE:
'use client';

import { nanoid } from 'nanoid';
import type { NextPage } from 'next';
import { signOut, useSession } from 'next-auth/react';
import Link from 'next/link';
import { useCreateSpace, useFindManySpace } from '~/lib/hooks';

const Home: NextPage = () => {
  const { data: session } = useSession();
  const { mutate: createSpace } = useCreateSpace();
  const { data: spaces } = useFindManySpace({ orderBy: { createdAt: 'desc' } });

  function onCreateSpace() {
    const name = prompt('Enter a name for your space');
    if (name) {
      createSpace({
        data: {
          name,
          slug: nanoid(6),
          owner: { connect: { id: session?.user.id } },
          // add the creating user as an admin member
          members: {
            create: {
              user: { connect: { id: session?.user.id } },
              role: 'ADMIN',
            },
          },
        },
      });
    }
  }

  return (
    <div className="container mx-auto flex justify-center">
      {session?.user ? (
        <div className="mt-8 flex w-full flex-col items-center">
          <h1 className="text-center text-2xl">
            Welcome {session.user.email}{' '}
            <button
                className="btn btn-ghost btn-xs mt-4"
                onClick={() => signOut({ callbackUrl: '/signin' })}
            >
              Logout
            </button>
          </h1>

          <div className="w-full p-8">
            <h2 className="mb-8 text-xl">
              Choose a space to start, or{' '}
              <button className="btn btn-link p-0 text-xl" onClick={onCreateSpace}>
                create a new one.
              </button>
            </h2>

            <ul className="flex gap-4">
              {spaces?.map((space) => (
                <Link href={`/spaces/${space.slug}`} key={space.id}>
                  <li className="flex h-32 w-72 items-center justify-center rounded-lg border text-2xl">
                    {space.name}
                  </li>
                </Link>
              ))}
            </ul>
          </div>
        </div>
      ) : (
        <div>
          Please{' '}
          <Link href="/signin">
            <button className="btn btn-link p-0">login</button>
          </Link>{' '}
          to get started
        </div>
      )}
    </div>
  );
};

export default Home;

----------------------------------------

TITLE: Implementing Space Management UI in Next.js
DESCRIPTION: Demonstrates the implementation of a space management UI using ZenStack hooks for querying and mutating data. It shows how to fetch spaces, create new spaces, and handle automatic query invalidation.

LANGUAGE: tsx
CODE:
'use client';

import { nanoid } from 'nanoid';
import type { NextPage } from 'next';
import { signOut, useSession } from 'next-auth/react';
import Link from 'next/link';
import { useCreateSpace, useFindManySpace } from '~/lib/hooks';

const Home: NextPage = () => {
  const { data: session } = useSession();
  const { mutate: createSpace } = useCreateSpace();
  const { data: spaces } = useFindManySpace({ orderBy: { createdAt: 'desc' } });

  function onCreateSpace() {
    const name = prompt('Enter a name for your space');
    if (name) {
      createSpace({
        data: {
          name,
          slug: nanoid(6),
          owner: { connect: { id: session?.user.id } },
          // add the creating user as an admin member
          members: {
            create: {
              user: { connect: { id: session?.user.id } },
              role: 'ADMIN',
            },
          },
        },
      });
    }
  }

  return (
    <div className="container mx-auto flex justify-center">
      {session?.user ? (
        <div className="mt-8 flex w-full flex-col items-center">
          <h1 className="text-center text-2xl">
            Welcome {session.user.email}{' '}
            <button
                className="btn btn-ghost btn-xs mt-4"
                onClick={() => signOut({ callbackUrl: '/signin' })}
            >
              Logout
            </button>
          </h1>

          <div className="w-full p-8">
            <h2 className="mb-8 text-xl">
              Choose a space to start, or{' '}
              <button className="btn btn-link p-0 text-xl" onClick={onCreateSpace}>
                create a new one.
              </button>
            </h2>

            <ul className="flex gap-4">
              {spaces?.map((space) => (
                <Link href={`/spaces/${space.slug}`} key={space.id}>
                  <li className="flex h-32 w-72 items-center justify-center rounded-lg border text-2xl">
                    {space.name}
                  </li>
                </Link>
              ))}
            </ul>
          </div>
        </div>
      ) : (
        <div>
          Please{' '}
          <Link href="/signin">
            <button className="btn btn-link p-0">login</button>
          </Link>{' '}
          to get started
        </div>
      )}
    </div>
  );
};

export default Home;

----------------------------------------

TITLE: Implementing Soft Delete with Access Policy in ZenStack (TSX)
DESCRIPTION: This snippet demonstrates the initial elegant solution for implementing soft delete in ZenStack using a boolean field and an access policy to hide deleted records.

LANGUAGE: tsx
CODE:
model Post {
  ...
  deleted Boolean @default(false) @omit
  @@deny('read', deleted)
  ...
}

----------------------------------------

TITLE: TypeGraphQL Prisma Example - Custom Attribute Hack
DESCRIPTION: Example showing how TypeGraphQL Prisma traditionally handled custom attributes through code comments

LANGUAGE: zmodel
CODE:
model User {
    id Int @default(autoincrement()) @id
    email String @unique
    /// @TypeGraphQL.omit(output: true, input: true)
    password String
}

----------------------------------------

TITLE: Importing React Components for Image Display in Markdown
DESCRIPTION: This code snippet demonstrates the import of React components used to display a themed image in a Markdown document. It imports 'useBaseUrl' from Docusaurus and a custom 'ThemedImage' component.

LANGUAGE: markdown
CODE:
import useBaseUrl from '@docusaurus/useBaseUrl';
import ThemedImage from '@theme/ThemedImage';

----------------------------------------

TITLE: Configuring Post Model with Automatic Owner Assignment - ZModel & TypeScript
DESCRIPTION: Enhanced version showing automatic owner assignment using auth().id in @default attribute, simplifying post creation

LANGUAGE: zmodel
CODE:
model User {
  id Int @default(autoincrement())
}

model Post {
  id Int @default(autoincrement())
  title String
  owner User @relation(fields: [ownerId], references: [id])
  ownerId Int @default(auth().id)
}

LANGUAGE: typescript
CODE:
const db = enhance(prisma, { user });
await db.post.create({ data: { title: 'Post1' } });

----------------------------------------

TITLE: ZModel Plugin Configuration Example
DESCRIPTION: Example of configuring a tRPC CRUD router plugin in ZModel

LANGUAGE: zmodel
CODE:
plugin trpc {
    provider = "@zenstackhq/trpc"
    output   = "src/generated"
}

----------------------------------------

TITLE: Configuring Build Script for Vercel Deployment with ZenStack
DESCRIPTION: This snippet shows how to set up a build script in package.json that includes ZenStack generation, Next.js build, and Prisma migration for deploying to Vercel.

LANGUAGE: json
CODE:
{
  "scripts": {
    "vercel-build": "zenstack generate && next build && prisma migrate deploy"
  }
}

----------------------------------------

TITLE: Rendering Todo Lists with React Server Component
DESCRIPTION: This React Server Component fetches and renders todo lists for the current user, applying access control through the enhanced PrismaClient.

LANGUAGE: tsx
CODE:
export default async function TodoLists() {
  const db = await getUserDb();

  // enhanced PrismaClient automatically filters out
  // the lists that the user doesn't have access to
  const lists = await db.list.findMany({
    orderBy: { updatedAt: "desc" },
  });

  return (
    <div>
      <div>
        {/* client component for creating a new List */}
        <CreateList />

        <ul>
          {lists?.map((list) => (
            <Link href={`/lists/${list.id}`} key={list.id}>
              <li>{list.title}</li>
            </Link>
          ))}
        </ul>
      </div>
    </div>
  );
}

----------------------------------------

TITLE: Configuring Build Script for Vercel Deployment with ZenStack
DESCRIPTION: This snippet shows how to set up a build script in package.json that includes ZenStack generation, Next.js build, and Prisma migration for deploying to Vercel.

LANGUAGE: json
CODE:
{
  "scripts": {
    "vercel-build": "zenstack generate && next build && prisma migrate deploy"
  }
}

----------------------------------------

TITLE: Building Static Content for ZenStack Website
DESCRIPTION: Command to generate static content into the 'build' directory, which can be served using any static content hosting service.

LANGUAGE: bash
CODE:
$ pnpm build

----------------------------------------

TITLE: ZModel Database Configuration
DESCRIPTION: Shows how to configure database connection in ZModel

LANGUAGE: zmodel
CODE:
datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

----------------------------------------

TITLE: Implementing Soft Delete with Unique Constraint in ZenStack (TSX)
DESCRIPTION: This snippet shows a more practical solution for implementing soft delete in ZenStack, using an integer timestamp for deletion and creating a unique constraint that includes the deleted field.

LANGUAGE: tsx
CODE:
model Post {
    id String @id @default(uuid())
    // name should be unique
    name String
    // when deleting, set it to the timestamp of deletion
    deleted Int @default(0) @omit

    @@unique([name, deleted])
    @@deny('read', deleted != 0)
}

----------------------------------------

TITLE: Creating ZModel Schema for Todo List Application
DESCRIPTION: This snippet defines the database schema using ZModel language, which extends Prisma schema with access control capabilities.

LANGUAGE: zmodel
CODE:
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator js {
  provider = "prisma-client-js"
}

// Todo list
model List {
  id        String        @id @default(cuid())
  createdAt DateTime      @default(now())
  title     String
  private   Boolean       @default(false)
  orgId     String?
  ownerId   String
  todos     Todo[]
}

// Todo item
model Todo {
  id          String    @id @default(cuid())
  title       String
  completedAt DateTime?
  list        List      @relation(fields: [listId], references: [id], onDelete: Cascade)
  listId      String
}

----------------------------------------

TITLE: Creating User with Posts using RESTful API Handler in TypeScript
DESCRIPTION: This snippet demonstrates how to create a user and attach two posts using the RESTful API handler. It uses the fetch API to make a POST request to the '/api/user' endpoint with JSON:API formatted data.

LANGUAGE: typescript
CODE:
// create a user and attach two posts
const r = await fetch(`/api/user`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/vnd.api+json' },
    body: JSON.stringify({
        data: {
            type: 'user',
            attributes: {
                email: 'user1@abc.com'
            },
            relationships: {
                posts: {
                    data: [
                        { type: 'post', id: 1 },
                        { type: 'post', id: 2 }
                    ]
                }
            }
        }
    })
});

console.log(await r.json());

----------------------------------------

TITLE: Querying Todos with Prisma in TypeScript
DESCRIPTION: Example of using Prisma to query todos with their owners, demonstrating type inference for query results.

LANGUAGE: typescript
CODE:
// `todos` is typed as `(Todo & { owner: User })[]`
const todos = await prisma.todo.findMany({
  where: { published: true },
  include: { owner: true }
});

----------------------------------------

TITLE: Defining Data Models with ZenStack
DESCRIPTION: Creates data models for User, Pet, and Order using ZenStack's schema language.

LANGUAGE: zmodel
CODE:
datasource db {
  provider  = "postgresql"
  url       = env("POSTGRES_PRISMA_URL")
  directUrl = env("POSTGRES_URL_NON_POOLING")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id       String  @id @default(cuid())
  email    String  @unique
  password String
  orders   Order[]
}

model Pet {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  name      String
  category  String
  order     Order?   @relation(fields: [orderId], references: [id])
  orderId   String?
}

model Order {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  pets      Pet[]
  user      User     @relation(fields: [userId], references: [id])
  userId    String
}

----------------------------------------

TITLE: Demonstrating Tailwind CSS Autocompletion in GitHub Copilot
DESCRIPTION: An image showing GitHub Copilot's ability to autocomplete Tailwind CSS classes without explicit configuration.

LANGUAGE: markdown
CODE:
![Tailwind Completion](tailwind.png)

----------------------------------------

TITLE: Implementing RPC API Handler in SvelteKit
DESCRIPTION: Configuration for setting up the RPC API handler in a SvelteKit application using hooks.

LANGUAGE: typescript
CODE:
import { SvelteKitHandler } from '@zenstackhq/server/sveltekit';
import { RPCApiHandler } from '@zenstackhq/server/api';
import { getPrisma } from './lib/db';

export const handle = SvelteKitHandler({
    prefix: '/api/model',
    handler: RPCApiHandler(), // you can also omit it since `RPCApiHandler` is the default
    getPrisma
});

----------------------------------------

TITLE: Adding Custom Method to Prisma Client
DESCRIPTION: Shows how to add a custom '$log' method to the Prisma client using Client Extensions.

LANGUAGE: typescript
CODE:
const xprisma = prisma.$extends({
    client: {
        $log: (s: string) => console.log(s),
    },
});

prisma.$log('Hello world');

----------------------------------------

TITLE: Adding Custom Method to Prisma Client
DESCRIPTION: Shows how to add a custom '$log' method to the Prisma client using Client Extensions.

LANGUAGE: typescript
CODE:
const xprisma = prisma.$extends({
    client: {
        $log: (s: string) => console.log(s),
    },
});

prisma.$log('Hello world');

----------------------------------------

TITLE: Defining GraphQL Mutations with Role-Based Access Control in RedwoodJS
DESCRIPTION: This GraphQL schema defines mutations for creating, updating, and deleting posts, with role-based access control using the @requireAuth directive to restrict access to users with the 'admin' role.

LANGUAGE: graphql
CODE:
type Mutation {
  createPost(input: CreatePostInput!): Post! @requireAuth(roles: ["admin"])
  updatePost(id: Int!, input: UpdatePostInput!): Post! @requireAuth(roles: ["admin"])
  deletePost(id: Int!): Post! @requireAuth(roles: ["admin"])
}

----------------------------------------

TITLE: Showcasing Context Inference in GitHub Copilot
DESCRIPTION: An image highlighting GitHub Copilot's ability to infer context and suggest appropriate field names based on form data type definitions.

LANGUAGE: markdown
CODE:
![Ability to draw inferences](draw-inferences.png)

----------------------------------------

TITLE: Initializing RPC API Handler for SvelteKit
DESCRIPTION: Configures the RPC API Handler for a SvelteKit project. It uses the SvelteKitHandler from ZenStack, sets up a prefix for API routes, and requires a getPrisma function for database access.

LANGUAGE: typescript
CODE:
import zenstack from '@zenstackhq/server/sveltekit';
import RPCApiHandler from '@zenstackhq/server/api/rpc';
import { getPrisma } from './lib/db';

export const handle = zenstack.SvelteKitHandler({
    prefix: '/api/model',
    handler: RPCApiHandler(), // you can also omit it since `RPCApiHandler` is the default
    getPrisma
});

----------------------------------------

TITLE: Prisma Client Usage Example
DESCRIPTION: Shows how to use Prisma's generated TypeScript client for database operations.

LANGUAGE: typescript
CODE:
// the result is typed as: User & { posts: Post[] }
const userWithPosts = await prisma.user.findUnique({
    where: { id: userId },
    include: { posts: true },
});

----------------------------------------

TITLE: Implementing Swagger UI for API Documentation
DESCRIPTION: Integration of Swagger UI with Express.js to serve API documentation, including merging of ZenStack-generated spec with custom JSDoc annotations.

LANGUAGE: typescript
CODE:
import expressJSDocSwagger from 'express-jsdoc-swagger';

// load the CRUD API spec from the JSON file generated by `zenstack`
const crudApiSpec = require('./petstore-api.json');

// options for loading the extra OpenAPI from JSDoc
const swaggerOptions = {
    info: {
        version: '0.1.0',
        title: 'Pet Store API',
    },
    filesPattern: './app.ts', // scan app.ts for OpenAPI JSDoc
    baseDir: __dirname,
    exposeApiDocs: true,
    apiDocsPath: '/v3/api-docs', // serve the merged JSON specifcation at /v3/api-docs
};

// merge two specs and serve the UI
expressJSDocSwagger(app)(swaggerOptions, crudApiSpec);

----------------------------------------

TITLE: Using Enhanced PrismaClient with Strongly-Typed JSON Fields in TypeScript
DESCRIPTION: This snippet demonstrates how to use the enhanced PrismaClient to perform type-safe mutations and queries with strongly-typed JSON fields.

LANGUAGE: typescript
CODE:
import { enhance } from '@zenstackhq/runtime';
import { prisma } from '~/db';

const db = enhance(prisma);

// The following create call results in a type error because of the
// incorrect type of the `age` field
await db.user.create({
  data: {
    profile: { name: 'Alice', age: '30' /* incorrect type */ }
  }
});

// The query result is typed as:
// {
//   id: string;
//   profile: {
//     name: string;
//     age: number;
//     address?: {
//       state: string;
//       city: string;
//       zip: string;
//     } | null;
//   };
// }
await user = await db.user.findFirstOrThrow();

----------------------------------------

TITLE: Installing ZenStack and TanStack Query Dependencies
DESCRIPTION: This snippet shows how to install the necessary dependencies for using ZenStack with TanStack Query in a React project.

LANGUAGE: bash
CODE:
npm install @tanstack/react-query @zenstackhq/tanstack-query

----------------------------------------

TITLE: Implementing Access Control Policies in ZenStack
DESCRIPTION: This snippet shows how to define access control policies directly in the data model using ZenStack. It demonstrates the declarative approach to specifying who can perform what actions on which resources.

LANGUAGE: zmodel
CODE:
model Post {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  published Boolean  @default(false)
  title     String
  content   String?
  author    User     @relation(fields: [authorId], references: [id])
  authorId  Int

  // author has full access
  @@allow('all', auth() == author)

  // logged-in users can view published posts
  @@allow('read', auth() != null && published)

  // admin has full access
  @@allow('all', auth().role == 'ADMIN')
}

----------------------------------------

TITLE: Initializing Express.js Project with TypeScript
DESCRIPTION: Commands to create a new Express.js project with TypeScript support, including installation of necessary dependencies and initialization of TypeScript configuration.

LANGUAGE: bash
CODE:
mkdir express-petstore
cd express-petstore
npm init -y
npm install express
npm install -D typescript tsx @types/node @types/express
npx tsc --init

----------------------------------------

TITLE: Creating Database Trigger for User Synchronization
DESCRIPTION: SQL trigger setup to automatically synchronize new users from Supabase Auth to the custom User table. Includes function definition and trigger creation.

LANGUAGE: sql
CODE:
create function public.handle_new_user()
returns trigger
language plpgsql
security definer set search_path = public
as $$
begin
  insert into public."User" (id)
  values (new.id);
  return new;
end;
$$;

create trigger on_auth_user_created
  after insert on auth.users
  for each row execute procedure public.handle_new_user();

----------------------------------------

TITLE: Querying Posts with Drizzle ORM in TypeScript
DESCRIPTION: This code snippet demonstrates how to query posts readable by the current user using Drizzle ORM. It includes complex conditions for filtering posts based on publication status, authorship, and user roles.

LANGUAGE: typescript
CODE:
db
    .selectDistinctOn([posts.id], {
        id: posts.id,
        title: posts.title,
        published: posts.published,
        author: { id: users.id, email: users.email },
    })
    .from(posts)
    .where(eq(posts.spaceId, space.id))
    .leftJoin(users, eq(posts.authorId, users.id))
    .leftJoin(spaces, eq(posts.spaceId, spaces.id))
    .leftJoin(
        spaceUsers,
        and(
            eq(spaceUsers.spaceId, spaces.id),
            eq(spaceUsers.userId, req.uid!)
        )
    )
    .where(
        or(
            // 1. published and current user is a member of the space
            and(
                eq(posts.published, true),
                eq(spaceUsers.userId, req.uid!)
            ),
            // 2. authored by the current user
            eq(posts.authorId, req.uid!),
            // 3. belongs to space owned by the current user
            eq(spaces.ownerId, req.uid!),
            // 4. belongs to space where the current user is an admin
            eq(spaceUsers.role, 'ADMIN')
        )
    );

----------------------------------------

TITLE: Implementing a Prisma Generator to Access Custom Attributes
DESCRIPTION: This TypeScript code shows how to implement a Prisma generator that can access custom attributes defined in comments.

LANGUAGE: typescript
CODE:
import { DMMF, generatorHandler, GeneratorOptions } from '@prisma/generator-helper';
import { getDMMF } from '@prisma/internals';

generatorHandler({
    onManifest: () => ({
        prettyName: 'My Generator',
    }),
    onGenerate: async (options: GeneratorOptions) => {
        const prismaClientDmmf = await getDMMF({
            datamodel: options.datamodel,
        });

        const models: DMMF.Model[] = prismaClientDmmf.datamodel.models;
        console.log(models);
    },
});

----------------------------------------

TITLE: Configuring ZenStack CRUD Middleware in NestJS
DESCRIPTION: Installing the ZenStack CRUD middleware in the NestJS application module.

LANGUAGE: typescript
CODE:
@Module(...)
export class AppModule implements NestModule {
  configure(consumer: MiddlewareConsumer) {
    consumer.apply(CrudMiddleware).forRoutes('/api/zen');
  }
}

----------------------------------------

TITLE: Querying User with Nested Posts in TypeScript
DESCRIPTION: Demonstrates a TypeScript query using useFindUniqueUser to fetch a user with their associated posts. This query will be automatically invalidated if a new Post is created.

LANGUAGE: typescript
CODE:
useFindUniqueUser({ where: { id: userId }, include: { posts: true } });

----------------------------------------

TITLE: Creating Prisma Client Generator
DESCRIPTION: Example of configuring a Prisma Client generator with custom output path.

LANGUAGE: zmodel
CODE:
generator client {
  provider = "prisma-client-js"
  output   = "./generated/prisma-client-js"

----------------------------------------

TITLE: Selecting AI Model with Vercel AI SDK in TypeScript
DESCRIPTION: This snippet demonstrates how to use the Vercel AI SDK to select an AI model based on available API keys in the environment.

LANGUAGE: typescript
CODE:
let model: LanguageModel;

if (process.env.OPENAI_API_KEY) {
    model = openai('gpt-4-turbo');
} else if (process.env.XAI_API_KEY) {
    model = xai('grok-beta');
}
...

----------------------------------------

TITLE: Creating Prisma Client Generator
DESCRIPTION: Example of configuring a Prisma Client generator with custom output path.

LANGUAGE: zmodel
CODE:
generator client {
  provider = "prisma-client-js"
  output   = "./generated/prisma-client-js"

----------------------------------------

TITLE: Using Has Function with Array in ZenStack Policy
DESCRIPTION: This example shows how to use the has() function to check if an array field contains a specific value in a policy rule.

LANGUAGE: zmodel
CODE:
model Post {
    id Int @id
    tags String[]
    @@allow('read', has(tags, 'zenstack'))
}

----------------------------------------

TITLE: Using Has Function with Array in ZenStack Policy
DESCRIPTION: This example shows how to use the has() function to check if an array field contains a specific value in a policy rule.

LANGUAGE: zmodel
CODE:
model Post {
    id Int @id
    tags String[]
    @@allow('read', has(tags, 'zenstack'))
}

----------------------------------------

TITLE: Importing ZModel Files
DESCRIPTION: Demonstrates how to import other ZModel files using relative, absolute or module paths.

LANGUAGE: zmodel
CODE:
// there is a file called "user.zmodel" in the same directory
import "user"

----------------------------------------

TITLE: Rendering Todo Lists with React Server Component
DESCRIPTION: This React Server Component fetches and renders the todo lists for the current user, using the enhanced PrismaClient for access control.

LANGUAGE: tsx
CODE:
export default async function TodoLists() {
  const db = await getUserDb();

  // enhanced PrismaClient automatically filters out
  // the lists that the user doesn't have access to
  const lists = await db.list.findMany({
    orderBy: { updatedAt: "desc" },
  });

  return (
    <div>
      <div>
        {/* client component for creating a new List */}
        <CreateList />

        <ul>
          {lists?.map((list) => (
            <Link href={`/lists/${list.id}`} key={list.id}>
              <li>{list.title}</li>
            </Link>
          ))}
        </ul>
      </div>
    </div>
  );
}

----------------------------------------

TITLE: Importing ZModel Files
DESCRIPTION: Demonstrates how to import other ZModel files using relative, absolute or module paths.

LANGUAGE: zmodel
CODE:
// there is a file called "user.zmodel" in the same directory
import "user"

----------------------------------------

TITLE: Providing Current User in TypeScript
DESCRIPTION: This pseudo-code demonstrates how to provide the current user information when enhancing the Prisma Client with ZenStack.

LANGUAGE: typescript
CODE:
// `getCurrentUser` is an authentication API that extracts 
// the current user from the request
const user = await getCurrentUser(request);

// create an enhanced Prisma Client for the user, the `user` object
// provides value for the `auth()` function in policy rules
const db = enhance(prisma, { user })

----------------------------------------

TITLE: Posts List Page Component
DESCRIPTION: Remix route component for displaying and managing blog posts with authentication.

LANGUAGE: tsx
CODE:
import type { LoaderArgs } from '@remix-run/node';
import { json } from '@remix-run/node';
import { Form, Link, NavLink, Outlet, useLoaderData } from '@remix-run/react';
import { getPosts } from '~/models/post.server';
import { requireUserId } from '~/session.server';
import { useUser } from '~/utils';

export async function loader({ request }: LoaderArgs) {
    const userId = await requireUserId(request);
    const posts = await getPosts({ userId });
    return json({ posts });
}

export default function PostsPage() {
    const data = useLoaderData<typeof loader>();
    const user = useUser();
    // ... rest of the component implementation
}

----------------------------------------

TITLE: Defining User and Post Models with ZModel
DESCRIPTION: Schema definition for User and Post models with access policy rules. The User model is synchronized with Supabase Auth, and Post model includes relationship and access controls.

LANGUAGE: zmodel
CODE:
model User {
    id String @id @db.Uuid
    posts Post[]
    ... // other fields

    @@allow('read', true)
}

model Post {
    id String @id @db.Uuid
    title String
    author User @relation(fields: [authorId], references: [id])
    authorId String @db.Uuid

    @@allow('all', author == auth())
}

----------------------------------------

TITLE: Creating New Remix Project with CLI
DESCRIPTION: Initialize a new Remix project using create-remix CLI with TypeScript template.

LANGUAGE: bash
CODE:
npx create-remix@latest --template remix-run/indie-stack my-blog-app
cd my-blog-app
npm run dev

----------------------------------------

TITLE: Adding RESTful API Flavor
DESCRIPTION: Extending the Express app to include a RESTful API flavor using ZenStack middleware.

LANGUAGE: typescript
CODE:
import RESTHandler from '@zenstackhq/server/api/rest';

app.use('/api/rest', 
    ZenStackMiddleware({ 
        handler: RESTHandler({ endpoint: 'http://localhost:3000/api/rest' }),
        getPrisma: (req) => enhance(prisma, { user: getUser(req) })
    })
);

----------------------------------------

TITLE: Starting Local Development Server for ZenStack Website
DESCRIPTION: Command to start a local development server, which opens a browser window and reflects most changes live without server restart.

LANGUAGE: bash
CODE:
$ pnpm start

----------------------------------------

TITLE: Implementing Custom Server Adapter for ZenStack
DESCRIPTION: Example of implementing a custom server adapter to directly interact with the API handler. Shows how to process handler results and customize response headers with complete control over the response flow.

LANGUAGE: typescript
CODE:
import RESTHandler from '@zenstackhq/server/api/rest';

app.use('/api/rpc-custom', async (req: Request, res: Response) => {
    const url = req.protocol + '://' + req.get('host') + req.originalUrl;
    const searchParams = new URL(url).searchParams;
    const query = Object.fromEntries(searchParams);
    const handler = RPCHandler();

    const { status, body } = await handler({
        method: req.method,
        path: req.path,
        query,
        requestBody: req.body,
        prisma: enhance(prisma, { user: getUser(req) }) as any,
    });

    res.status(status)
        .header('x-requested-by', req.header('x-user-id'))
        .json(body);
});

----------------------------------------

TITLE: Implementing Authentication Middleware in Express.js
DESCRIPTION: Adds a simple middleware to require X-USER-ID header for authentication in Express.js.

LANGUAGE: typescript
CODE:
app.use((req, res, next) => {
    const userId = req.header('X-USER-ID');
    if (!userId || Number.isNaN(parseInt(userId))) {
        res.status(403).json({ error: 'unauthorized' });
    } else {
        next();
    }
});

----------------------------------------

TITLE: Importing and Rendering ZenStack Initialization Component in JSX
DESCRIPTION: This snippet imports a ZenStack initialization component from a Markdown file and renders it within an info block. It's likely part of a React-based documentation system.

LANGUAGE: jsx
CODE:
import ZenStackInit from './_zenstack-init.md'

:::info

<ZenStackInit />

:::

----------------------------------------

TITLE: Configuring Tailwind for daisyUI
DESCRIPTION: Adding daisyUI plugin to Tailwind configuration file.

LANGUAGE: javascript
CODE:
module.exports = {
  //...
  plugins: [require("daisyui")],
}