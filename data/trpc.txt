TITLE: Creating Basic Query and Mutation Procedures in TypeScript with tRPC
DESCRIPTION: This snippet demonstrates how to create basic query and mutation procedures using tRPC. It includes a 'hello' query that returns a message and a 'goodbye' mutation that signs a guestbook and returns a message.

LANGUAGE: typescript
CODE:
import { initTRPC } from '@trpc/server';
import { z } from 'zod';

const t = initTRPC.context<{ signGuestBook: () => Promise<void> }>().create();

export const router = t.router;
export const publicProcedure = t.procedure;

const appRouter = router({
  // Queries are the best place to fetch data
  hello: publicProcedure.query(() => {
    return {
      message: 'hello world',
    };
  }),

  // Mutations are the best place to do things like updating a database
  goodbye: publicProcedure.mutation(async (opts) => {
    await opts.ctx.signGuestBook();

    return {
      message: 'goodbye!',
    };
  }),
});

----------------------------------------

TITLE: Initializing tRPC Instance in TypeScript
DESCRIPTION: Basic initialization of a tRPC instance, creating and exporting router and procedure objects. This setup should be done once per application to avoid conflicts.

LANGUAGE: typescript
CODE:
import { initTRPC } from '@trpc/server';

// You can use any variable name you like.
// We use t to keep things simple.
const t = initTRPC.create();

export const router = t.router;
export const publicProcedure = t.procedure;

----------------------------------------

TITLE: Implementing tRPC Queries and Mutations in React Component
DESCRIPTION: Demonstrates how to use tRPC's React Query integration to make API calls within a React component. Shows usage of both queries (useQuery) and mutations (useMutation) with type-safe parameters and responses.

LANGUAGE: tsx
CODE:
import { trpc } from '../utils/trpc';

export default function IndexPage() {
  const helloQuery = trpc.hello.useQuery({ name: 'Bob' });
  const goodbyeMutation = trpc.goodbye.useMutation();

  return (
    <div>
      <p>{helloQuery.data?.greeting}</p>

      <button onClick={() => goodbyeMutation.mutate()}>Say Goodbye</button>
    </div>
  );
}

----------------------------------------

TITLE: Configuring Custom Error Formatter in tRPC Server
DESCRIPTION: Demonstrates how to set up a custom error formatter in tRPC server configuration. This example specifically handles Zod validation errors by flattening them when the error code is BAD_REQUEST.

LANGUAGE: typescript
CODE:
import { initTRPC } from '@trpc/server';

export const t = initTRPC.context<Context>().create({
  errorFormatter(opts) {
    const { shape, error } = opts;
    return {
      ...shape,
      data: {
        ...shape.data,
        zodError:
          error.code === 'BAD_REQUEST' && error.cause instanceof ZodError
            ? error.cause.flatten()
            : null,
      },
    };
  },
});

----------------------------------------

TITLE: Using tRPC Client for Queries and Mutations in TypeScript
DESCRIPTION: Demonstrates how to use the tRPC client to make queries and mutations with full type inference.

LANGUAGE: typescript
CODE:
const user = await trpc.userById.query('1');

const createdUser = await trpc.userCreate.mutate({ name: 'sachinraja' });

----------------------------------------

TITLE: Basic Usage of TanStack React Query with tRPC in TypeScript/React
DESCRIPTION: Shows the basic usage of TanStack React Query with tRPC, including creating query options, mutation options, and working with query keys. It demonstrates how to use useQuery, useMutation, and interact with the QueryClient.

LANGUAGE: tsx
CODE:
export default function Basics() {
  const trpc = useTRPC();
  const queryClient = useQueryClient();

  // Create QueryOptions which can be passed to query hooks
  const myQueryOptions = trpc.path.to.query.queryOptions({ /** inputs */ })
  const myQuery = useQuery(myQueryOptions)
  // or:
  // useSuspenseQuery(myQueryOptions)
  // useInfiniteQuery(myQueryOptions)

  // Create MutationOptions which can be passed to useMutation
  const myMutationOptions = trpc.path.to.mutation.mutationOptions()
  const myMutation = useMutation(myMutationOptions)

  // Create a QueryKey which can be used to manipulated many methods
  // on TanStack's QueryClient in a type-safe manner
  const myQueryKey = trpc.path.to.query.queryKey()

  const invalidateMyQueryKey = () => {
    queryClient.invalidateQueries({ queryKey: myQueryKey })
  }

  return (
    // Your app here
  )
}

----------------------------------------

TITLE: Basic tRPC Procedure Implementation
DESCRIPTION: Demonstrates how to create basic query and mutation procedures using tRPC. Shows initialization of tRPC, defining a router, and creating basic procedures for fetching and updating data.

LANGUAGE: typescript
CODE:
import { initTRPC } from '@trpc/server';
import { z } from 'zod';

const t = initTRPC.context<{ signGuestBook: () => Promise<void> }>().create();

export const router = t.router;
export const publicProcedure = t.procedure;

const appRouter = router({
  hello: publicProcedure.query(() => {
    return {
      message: 'hello world',
    };
  }),

  goodbye: publicProcedure.mutation(async (opts) => {
    await opts.ctx.signGuestBook();

    return {
      message: 'goodbye!',
    };
  }),
});

----------------------------------------

TITLE: Implementing Reusable Base Procedures
DESCRIPTION: Shows how to create reusable base procedures for authentication and organization-specific operations. Includes middleware for user authentication and organization membership validation.

LANGUAGE: typescript
CODE:
import { initTRPC, TRPCError } from '@trpc/server';
import { z } from 'zod';

type Organization = {
  id: string;
  name: string;
};
type Membership = {
  role: 'ADMIN' | 'MEMBER';
  Organization: Organization;
};
type User = {
  id: string;
  memberships: Membership[];
};
type Context = {
  user: User | null;
};

const t = initTRPC.context<Context>().create();

export const publicProcedure = t.procedure;

export const authedProcedure = t.procedure.use(async function isAuthed(opts) {
  const { ctx } = opts;
  if (!ctx.user) {
    throw new TRPCError({ code: 'UNAUTHORIZED' });
  }

  return opts.next({
    ctx: {
      user: ctx.user,
    },
  });
});

export const organizationProcedure = authedProcedure
  .input(z.object({ organizationId: z.string() }))
  .use(function isMemberOfOrganization(opts) {
    const membership = opts.ctx.user.memberships.find(
      (m) => m.Organization.id === opts.input.organizationId,
    );
    if (!membership) {
      throw new TRPCError({
        code: 'FORBIDDEN',
      });
    }
    return opts.next({
      ctx: {
        Organization: membership.Organization,
      },
    });
  });

----------------------------------------

TITLE: Implementing Reusable Base Procedures
DESCRIPTION: Shows how to create reusable base procedures for authentication and organization-specific operations. Includes middleware for user authentication and organization membership validation.

LANGUAGE: typescript
CODE:
import { initTRPC, TRPCError } from '@trpc/server';
import { z } from 'zod';

type Organization = {
  id: string;
  name: string;
};
type Membership = {
  role: 'ADMIN' | 'MEMBER';
  Organization: Organization;
};
type User = {
  id: string;
  memberships: Membership[];
};
type Context = {
  user: User | null;
};

const t = initTRPC.context<Context>().create();

export const publicProcedure = t.procedure;

export const authedProcedure = t.procedure.use(async function isAuthed(opts) {
  const { ctx } = opts;
  if (!ctx.user) {
    throw new TRPCError({ code: 'UNAUTHORIZED' });
  }

  return opts.next({
    ctx: {
      user: ctx.user,
    },
  });
});

export const organizationProcedure = authedProcedure
  .input(z.object({ organizationId: z.string() }))
  .use(function isMemberOfOrganization(opts) {
    const membership = opts.ctx.user.memberships.find(
      (m) => m.Organization.id === opts.input.organizationId,
    );
    if (!membership) {
      throw new TRPCError({
        code: 'FORBIDDEN',
      });
    }
    return opts.next({
      ctx: {
        Organization: membership.Organization,
      },
    });
  });

----------------------------------------

TITLE: Comprehensive Context and Procedure Setup in tRPC (TypeScript)
DESCRIPTION: Provides a comprehensive example of setting up context, initializing tRPC, and creating protected and public procedures. It includes context creation, tRPC initialization, and definition of protected and public procedures.

LANGUAGE: typescript
CODE:
// @filename: context.ts
import type { CreateNextContextOptions } from '@trpc/server/adapters/next';
import { getSession } from 'next-auth/react';

export async function createContext(opts: CreateNextContextOptions) {
  const session = await getSession({ req: opts.req });

  return {
    session,
  };
}

export type Context = Awaited<ReturnType<typeof createContext>>;

// @filename: trpc.ts
import { initTRPC, TRPCError } from '@trpc/server';
import { Context } from './context';

const t = initTRPC.context<Context>().create();


export const router = t.router;

export const publicProcedure = t.procedure;

export const protectedProcedure = t.procedure.use(function isAuthed(opts) {
  if (!opts.ctx.session?.user?.email) {
    throw new TRPCError({
      code: 'UNAUTHORIZED',
    });
  }
  return opts.next({
    ctx: {
      session: opts.ctx.session,
    },
  });
});

----------------------------------------

TITLE: Implementing SSG with tRPC in Next.js Page Component
DESCRIPTION: Complete implementation of a Next.js page component using tRPC with Static Site Generation. Shows how to fetch data using getStaticProps, define static paths, and render the component with prefetched data. Includes error handling and data display logic.

LANGUAGE: tsx
CODE:
import { createServerSideHelpers } from '@trpc/react-query/server';
import {
  GetStaticPaths,
  GetStaticPropsContext,
  InferGetStaticPropsType,
} from 'next';
import { prisma } from 'server/context';
import { appRouter } from 'server/routers/_app';
import superjson from 'superjson';
import { trpc } from 'utils/trpc';

export async function getStaticProps(
  context: GetStaticPropsContext<{ id: string }>,
) {
  const helpers = createServerSideHelpers({
    router: appRouter,
    ctx: {},
    transformer: superjson, // optional - adds superjson serialization
  });
  const id = context.params?.id as string;

  // prefetch `post.byId`
  await helpers.post.byId.prefetch({ id });

  return {
    props: {
      trpcState: helpers.dehydrate(),
      id,
    },
    revalidate: 1,
  };
}

export const getStaticPaths: GetStaticPaths = async () => {
  const posts = await prisma.post.findMany({
    select: {
      id: true,
    },
  });

  return {
    paths: posts.map((post) => ({
      params: {
        id: post.id,
      },
    })),
    fallback: 'blocking',
  };
};

export default function PostViewPage(
  props: InferGetStaticPropsType<typeof getStaticProps>,
) {
  const { id } = props;
  const postQuery = trpc.post.byId.useQuery({ id });

  if (postQuery.status !== 'success') {
    return <>Loading...</>;
  }
  const { data } = postQuery;
  return (
    <>
      <h1>{data.title}</h1>
      <em>Created {data.createdAt.toLocaleDateString('en-us')}</em>

      <p>{data.text}</p>

      <h2>Raw data:</h2>
      <pre>{JSON.stringify(data, null, 4)}</pre>
    </>
  );
}

----------------------------------------

TITLE: Initializing tRPC Router with Greeting Procedure in TypeScript
DESCRIPTION: This snippet initializes a tRPC instance, creates a router, and defines a public procedure for a greeting endpoint. It uses Zod for input validation and exports the router type. The greeting procedure takes a name input and returns a greeting string.

LANGUAGE: typescript
CODE:
import { initTRPC } from '@trpc/server';
import z from 'zod';

const t = initTRPC.create();

const router = t.router;
const publicProcedure = t.procedure;

const appRouter = router({
  greeting: publicProcedure
    .input(z.object({ name: z.string() }))
    .query((opts) => {
      const { input } = opts;
      //      ^?

      return `Hello ${input.name}` as const;
  }),
});

export type AppRouter = typeof appRouter;

----------------------------------------

TITLE: Defining Basic tRPC Router with Greeting Endpoint
DESCRIPTION: Example of creating a basic tRPC router with a single query procedure that returns a greeting message. Shows how to export router types for client-side usage.

LANGUAGE: typescript
CODE:
import { publicProcedure, router } from './trpc';

const appRouter = router({
  greeting: publicProcedure.query(() => 'hello tRPC v10!'),
});

// Export only the type of a router!
// This prevents us from importing server code on the client.
export type AppRouter = typeof appRouter;

----------------------------------------

TITLE: Configuring tRPC Server Instance
DESCRIPTION: Initializes the tRPC backend instance and exports reusable router and procedure helpers

LANGUAGE: typescript
CODE:
import { initTRPC } from '@trpc/server';

const t = initTRPC.create();

export const router = t.router;
export const publicProcedure = t.procedure;

----------------------------------------

TITLE: Defining Basic tRPC Router with Greeting Endpoint
DESCRIPTION: Example of creating a basic tRPC router with a single query procedure that returns a greeting message. Shows how to export router types for client-side usage.

LANGUAGE: typescript
CODE:
import { publicProcedure, router } from './trpc';

const appRouter = router({
  greeting: publicProcedure.query(() => 'hello tRPC v10!'),
});

// Export only the type of a router!
// This prevents us from importing server code on the client.
export type AppRouter = typeof appRouter;

----------------------------------------

TITLE: Initializing and Starting tRPC HTTP Server in TypeScript
DESCRIPTION: This code creates an HTTP server using tRPC's createHTTPServer function, configures it with an appRouter, and starts the server to listen on port 3000. The server will handle API requests based on the defined router.

LANGUAGE: typescript
CODE:
const { listen } = createHTTPServer({
  router: appRouter,
});

// The API will now be listening on port 3000!
listen(3000);

----------------------------------------

TITLE: Configuring App Component with tRPC and React Query
DESCRIPTION: Demonstrates how to set up the App component with tRPC and React Query providers. It includes creating a QueryClient and tRPC client, and wrapping the application with necessary providers.

LANGUAGE: tsx
CODE:
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { createTRPCClient, httpBatchLink } from '@trpc/client';
import { useState } from 'react';
import { TRPCProvider, useTRPC } from './utils/trpc';

function makeQueryClient() {
  return new QueryClient({
    defaultOptions: {
      queries: {
        // With SSR, we usually want to set some default staleTime
        // above 0 to avoid refetching immediately on the client
        staleTime: 60 * 1000,
      },
    },
  });
}

let browserQueryClient: QueryClient | undefined = undefined;

function getQueryClient() {
  if (typeof window === 'undefined') {
    // Server: always make a new query client
    return makeQueryClient();
  } else {
    // Browser: make a new query client if we don't already have one
    // This is very important, so we don't re-make a new client if React
    // suspends during the initial render. This may not be needed if we
    // have a suspense boundary BELOW the creation of the query client
    if (!browserQueryClient) browserQueryClient = makeQueryClient();
    return browserQueryClient;
  }
}

export function App() {
  const queryClient = getQueryClient();
  const [trpcClient] = useState(() =>
    createTRPCClient<AppRouter>({
      links: [
        httpBatchLink({
          url: 'http://localhost:2022',
        }),
      ],
    }),
  );

  return (
    <QueryClientProvider client={queryClient}>
      <TRPCProvider trpcClient={trpcClient} queryClient={queryClient}>
        {/* Your app here */}
      </TRPCProvider>
    </QueryClientProvider>
  );
}

----------------------------------------

TITLE: Creating Context from Request Headers in tRPC
DESCRIPTION: Demonstrates how to create a context function that extracts and validates user information from request headers using JWT tokens. The context is created for each incoming request and makes user data available to all resolvers.

LANGUAGE: typescript
CODE:
import * as trpcNext from '@trpc/server/adapters/next';
import { decodeAndVerifyJwtToken } from './somewhere/in/your/app/utils';

export async function createContext({
  req,
  res,
}: trpcNext.CreateNextContextOptions) {
  async function getUserFromHeader() {
    if (req.headers.authorization) {
      const user = await decodeAndVerifyJwtToken(
        req.headers.authorization.split(' ')[1],
      );
      return user;
    }
    return null;
  }
  const user = await getUserFromHeader();

  return {
    user,
  };
}
export type Context = Awaited<ReturnType<typeof createContext>>;

----------------------------------------

TITLE: Middleware-based Authorization in tRPC
DESCRIPTION: Demonstrates how to implement authorization using tRPC middleware, creating a reusable protected procedure that can be applied to multiple routes. Includes type-safe context narrowing.

LANGUAGE: typescript
CODE:
import { initTRPC, TRPCError } from '@trpc/server';
import type { Context } from '../context';

export const t = initTRPC.context<Context>().create();

export const protectedProcedure = t.procedure.use(
  async function isAuthed(opts) {
    const { ctx } = opts;
    if (!ctx.user) {
      throw new TRPCError({ code: 'UNAUTHORIZED' });
    }
    return opts.next({
      ctx: {
        user: ctx.user,
      },
    });
  },
);

t.router({
  hello: t.procedure
    .input(z.string().nullish())
    .query((opts) => `hello ${opts.input ?? opts.ctx.user?.name ?? 'world'}`),
  admin: t.router({
    secret: protectedProcedure.query((opts) => {
      return {
        secret: 'sauce',
      };
    }),
  }),
});

----------------------------------------

TITLE: Initializing tRPC Backend in TypeScript
DESCRIPTION: Creates a tRPC instance and exports reusable router and procedure helpers. This should be done once per backend.

LANGUAGE: typescript
CODE:
import { initTRPC } from '@trpc/server';

const t = initTRPC.create();

export const router = t.router;
export const publicProcedure = t.procedure;

----------------------------------------

TITLE: Basic Next.js tRPC API Handler Implementation
DESCRIPTION: Sets up a basic tRPC API handler for Next.js using createNextApiHandler. Creates an endpoint at pages/api/trpc/[trpc].ts that handles all tRPC requests.

LANGUAGE: typescript
CODE:
import { createNextApiHandler } from '@trpc/server/adapters/next';
import { createContext } from '../../../server/trpc/context';
import { appRouter } from '../../../server/trpc/router/_app';

// @link https://nextjs.org/docs/api-routes/introduction
export default createNextApiHandler({
  router: appRouter,
  createContext,
});

----------------------------------------

TITLE: Customizing tRPC Initialization with Method Chaining
DESCRIPTION: Demonstrates how to use method chaining to customize the tRPC initialization. This example sets up context and metadata for the router.

LANGUAGE: typescript
CODE:
const t = initTRPC.context<Context>().meta<Meta>().create({
  /* [...] */
});

----------------------------------------

TITLE: Basic Next.js tRPC API Handler Implementation
DESCRIPTION: Shows how to create a basic tRPC API handler for Next.js using createNextApiHandler. This setup connects the tRPC router with Next.js API routes.

LANGUAGE: typescript
CODE:
import { createNextApiHandler } from '@trpc/server/adapters/next';
import { createContext } from '../../../server/trpc/context';
import { appRouter } from '../../../server/trpc/router/_app';

// @link https://nextjs.org/docs/api-routes/introduction
export default createNextApiHandler({
  router: appRouter,
  createContext,
});

----------------------------------------

TITLE: tRPC Router Implementation
DESCRIPTION: Implements a basic tRPC router with a hello world query procedure using Zod for input validation.

LANGUAGE: typescript
CODE:
import { z } from 'zod';
import { procedure, router } from '../trpc';

export const appRouter = router({
  hello: procedure
    .input(
      z.object({
        text: z.string(),
      }),
    )
    .query((opts) => {
      return {
        greeting: `hello ${opts.input.text}`,
      };
    }),
});

export type AppRouter = typeof appRouter;

----------------------------------------

TITLE: Next.js App Configuration
DESCRIPTION: Configures the Next.js _app.tsx file with tRPC HOC wrapper.

LANGUAGE: typescript
CODE:
import type { AppType } from 'next/app';
import { trpc } from '../utils/trpc';

const MyApp: AppType = ({ Component, pageProps }) => {
  return <Component {...pageProps} />;
};

export default trpc.withTRPC(MyApp);

----------------------------------------

TITLE: Initializing tRPC Server with Greeting Procedure in TypeScript
DESCRIPTION: Sets up a tRPC server with a 'greeting' procedure that takes a name input and returns a greeting message. Uses Zod for input validation and defines the AppRouter type for client-side type inference.

LANGUAGE: typescript
CODE:
import { initTRPC } from '@trpc/server';
import z from 'zod';

const t = initTRPC.create();

const appRouter = t.router({
  greeting: t.procedure
    .input(z.object({ name: z.string() }))
    .query((opts) => {
      const { input } = opts;
      return `Hello ${input.name}` as const;
  }),
});

export type AppRouter = typeof appRouter;

----------------------------------------

TITLE: Initializing tRPC Backend in TypeScript
DESCRIPTION: Sets up the tRPC backend using initTRPC, creates a context, and defines base router and procedure helpers.

LANGUAGE: typescript
CODE:
import { initTRPC } from '@trpc/server';
import { cache } from 'react';

export const createTRPCContext = cache(async () => {
  return { userId: 'user_123' };
});

const t = initTRPC.create();

export const createTRPCRouter = t.router;
export const createCallerFactory = t.createCallerFactory;
export const baseProcedure = t.procedure;

----------------------------------------

TITLE: Initializing tRPC Backend in Next.js
DESCRIPTION: TypeScript code for initializing the tRPC backend in a Next.js project. It creates a router and procedure helper using initTRPC.

LANGUAGE: typescript
CODE:
import { initTRPC } from '@trpc/server';

// Avoid exporting the entire t-object
// since it's not very descriptive.
// For instance, the use of a t variable
// is common in i18n libraries.
const t = initTRPC.create();

// Base router and procedure helpers
export const router = t.router;
export const procedure = t.procedure;

----------------------------------------

TITLE: Next.js App Configuration
DESCRIPTION: Configures the Next.js _app.tsx file with tRPC HOC wrapper.

LANGUAGE: typescript
CODE:
import type { AppType } from 'next/app';
import { trpc } from '../utils/trpc';

const MyApp: AppType = ({ Component, pageProps }) => {
  return <Component {...pageProps} />;
};

export default trpc.withTRPC(MyApp);

----------------------------------------

TITLE: Using tRPC Queries and Mutations
DESCRIPTION: Example of using tRPC hooks to perform queries and mutations in a React component.

LANGUAGE: tsx
CODE:
import React from "react";
import { trpc } from '../utils/trpc';

export default function IndexPage() {
  const userQuery = trpc.getUser.useQuery({ id: 'id_bilbo' });
  const userCreator = trpc.createUser.useMutation();

  return (
    <div>
      <p>{userQuery.data?.name}</p>

      <button onClick={() => userCreator.mutate({ name: 'Frodo' })}>
        Create Frodo
      </button>
    </div>
  );
}

----------------------------------------

TITLE: Middleware-Based Authorization in tRPC
DESCRIPTION: Demonstrates how to implement authorization using tRPC middleware, creating a reusable protected procedure that can be applied to multiple routes. Includes type-safe context handling and router configuration.

LANGUAGE: typescript
CODE:
import { initTRPC, TRPCError } from '@trpc/server';

export const t = initTRPC.context<Context>().create();

export const protectedProcedure = t.procedure.use(
  async function isAuthed(opts) {
    const { ctx } = opts;
    if (!ctx.user) {
      throw new TRPCError({ code: 'UNAUTHORIZED' });
    }
    return opts.next({
      ctx: {
        user: ctx.user,
      },
    });
  },
);

t.router({
  hello: t.procedure
    .input(z.string().nullish())
    .query((opts) => `hello ${opts.input ?? opts.ctx.user?.name ?? 'world'}`),
  admin: t.router({
    secret: protectedProcedure.query((opts) => {
      return {
        secret: 'sauce',
      };
    }),
  }),
});

----------------------------------------

TITLE: Initializing tRPC Server and Defining Router in TypeScript
DESCRIPTION: This snippet shows the process of creating a tRPC server instance, defining a router with a 'greeting' procedure, and exporting the router type. It uses Zod for input validation and demonstrates type inference in the query handler.

LANGUAGE: typescript
CODE:
import { initTRPC } from '@trpc/server';
import z from 'zod';

const t = initTRPC.create();

const router = t.router;
const publicProcedure = t.procedure;

const appRouter = router({
  greeting: publicProcedure
    .input(z.object({ name: z.string() }))
    .query((opts) => {
      const { input } = opts;
      //      ^?

      return `Hello ${input.name}` as const;
  }),
});

export type AppRouter = typeof appRouter;

----------------------------------------

TITLE: Configuring Basic SSR with tRPC in Next.js
DESCRIPTION: Implementation of basic SSR configuration for tRPC using createTRPCNext with header forwarding and separate client/server logic. Includes httpBatchLink setup and proper header handling for SSR functionality.

LANGUAGE: typescript
CODE:
import { httpBatchLink } from '@trpc/client';
import { createTRPCNext } from '@trpc/next';
import { ssrPrepass } from '@trpc/next/ssrPrepass';
import superjson from 'superjson';
import type { AppRouter } from './api/trpc/[trpc]';

export const trpc = createTRPCNext<AppRouter>({
  ssr: true,
  ssrPrepass,
  config(opts) {
    const { ctx } = opts;
    if (typeof window !== 'undefined') {
      // during client requests
      return {
        links: [
          httpBatchLink({
            url: '/api/trpc',
          }),
        ],
      };
    }

    return {
      links: [
        httpBatchLink({
          // The server needs to know your app's full url
          url: `${getBaseUrl()}/api/trpc`,
          /**
           * Set custom request headers on every request from tRPC
           * @see https://trpc.io/docs/v10/header
           */
          headers() {
            if (!ctx?.req?.headers) {
              return {};
            }
            // To use SSR properly, you need to forward client headers to the server
            // This is so you can pass through things like cookies when we're server-side rendering
            return {
              cookie: ctx.req.headers.cookie,
            };
          },
        }),
      ],
    };
  },
});

----------------------------------------

TITLE: Initializing tRPC Router Configuration in TypeScript
DESCRIPTION: Sets up a basic tRPC router with query and mutation procedures using Zod for input validation.

LANGUAGE: typescript
CODE:
import { initTRPC } from '@trpc/server';
import { z } from "zod";
const t = initTRPC.create();

const appRouter = t.router({
  getUser: t.procedure.input(z.object({ id: z.string() })).query(() => ({ name: 'foo' })),
  createUser: t.procedure.input(z.object({ name: z.string() })).mutation(() => 'bar'),
});
export type AppRouter = typeof appRouter;

----------------------------------------

TITLE: Querying Data with TanStack React Query and tRPC in TypeScript/React
DESCRIPTION: Demonstrates how to use the useQuery hook from TanStack React Query with tRPC. It shows how to create a query for a greeting procedure with a name parameter.

LANGUAGE: tsx
CODE:
import { useQuery } from '@tanstack/react-query';
import { useTRPC } from './trpc';

function Users() {
  const trpc = useTRPC();

  const greetingQuery = useQuery(trpc.greeting.queryOptions({ name: 'Jerry' }));

  // greetingQuery.data === 'Hello Jerry'
}

----------------------------------------

TITLE: Defining Context Type in tRPC Initialization (TypeScript)
DESCRIPTION: Demonstrates how to define the context type when initializing tRPC using initTRPC. It shows two methods: inferring the type from a function's return type and explicitly defining the type.

LANGUAGE: typescript
CODE:
import * as trpc from '@trpc/server';
import { initTRPC } from '@trpc/server';
import type { CreateNextContextOptions } from '@trpc/server/adapters/next';
import { getSession } from 'next-auth/react';

export const createContext = async (opts: CreateNextContextOptions) => {
  const session = await getSession({ req: opts.req });

  return {
    session,
  };
};

const t1 = initTRPC.context<typeof createContext>().create();
t1.procedure.use(({ ctx }) => { ... });

type Context = Awaited<ReturnType<typeof createContext>>;
const t2 = initTRPC.context<Context>().create();
t2.procedure.use(({ ctx }) => { ... });

----------------------------------------

TITLE: Configuring Basic SSR with tRPC in Next.js
DESCRIPTION: Implementation of basic SSR configuration for tRPC using createTRPCNext with header forwarding and separate client/server logic. Includes httpBatchLink setup and proper header handling for SSR functionality.

LANGUAGE: typescript
CODE:
import { httpBatchLink } from '@trpc/client';
import { createTRPCNext } from '@trpc/next';
import { ssrPrepass } from '@trpc/next/ssrPrepass';
import superjson from 'superjson';
import type { AppRouter } from './api/trpc/[trpc]';

export const trpc = createTRPCNext<AppRouter>({
  ssr: true,
  ssrPrepass,
  config(opts) {
    const { ctx } = opts;
    if (typeof window !== 'undefined') {
      // during client requests
      return {
        links: [
          httpBatchLink({
            url: '/api/trpc',
          }),
        ],
      };
    }

    return {
      links: [
        httpBatchLink({
          // The server needs to know your app's full url
          url: `${getBaseUrl()}/api/trpc`,
          /**
           * Set custom request headers on every request from tRPC
           * @see https://trpc.io/docs/v10/header
           */
          headers() {
            if (!ctx?.req?.headers) {
              return {};
            }
            // To use SSR properly, you need to forward client headers to the server
            // This is so you can pass through things like cookies when we're server-side rendering
            return {
              cookie: ctx.req.headers.cookie,
            };
          },
        }),
      ],
    };
  },
});

----------------------------------------

TITLE: Inferring Input and Output Types from tRPC Router
DESCRIPTION: Demonstrates how to use inferRouterInputs and inferRouterOutputs helper types to extract typed inputs and outputs from tRPC procedures.

LANGUAGE: typescript
CODE:
import type { inferRouterInputs, inferRouterOutputs } from '@trpc/server';
import type { AppRouter } from './server';

type RouterInput = inferRouterInputs<AppRouter>;
type RouterOutput = inferRouterOutputs<AppRouter>;

type PostCreateInput = RouterInput['post']['create'];
type PostCreateOutput = RouterOutput['post']['create'];

----------------------------------------

TITLE: Using Inferred Procedure Types
DESCRIPTION: Demonstrates how to use inferProcedureBuilderResolverOptions to create strongly-typed helper functions that work with procedure builders. Includes example of separating procedure handler logic.

LANGUAGE: typescript
CODE:
async function getMembersOfOrganization(
  opts: inferProcedureBuilderResolverOptions<typeof organizationProcedure>,
) {
  const { ctx, input } = opts;

  return await prisma.user.findMany({
    where: {
      membership: {
        organizationId: ctx.Organization.id,
      },
    },
  });
}
export const appRouter = t.router({
  listMembers: organizationProcedure.query(async (opts) => {
    const members = await getMembersOfOrganization(opts);
    return members;
  }),
});

----------------------------------------

TITLE: Configuring tRPC Provider with React Query
DESCRIPTION: Sets up tRPC and React Query providers with HTTP batch link configuration and authentication headers. Uses useState for SSR compatibility.

LANGUAGE: tsx
CODE:
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { httpBatchLink } from '@trpc/client';
import React, { useState } from 'react';
import { trpc } from './utils/trpc';

export function App() {
  const [queryClient] = useState(() => new QueryClient());
  const [trpcClient] = useState(() =>
    trpc.createClient({
      links: [
        httpBatchLink({
          url: 'http://localhost:3000/trpc',

          // You can pass any HTTP headers you wish here
          async headers() {
            return {
              authorization: getAuthCookie(),
            };
          },
        }),
      ],
    }),
  );

  return (
    <trpc.Provider client={trpcClient} queryClient={queryClient}>
      <QueryClientProvider client={queryClient}>
        {/* Your app here */}
      </QueryClientProvider>
    </trpc.Provider>
  );
}

----------------------------------------

TITLE: Setting up tRPC Provider in React TypeScript
DESCRIPTION: Configures the tRPC Provider component to connect the React application to the tRPC API. Uses QueryClient from @tanstack/react-query and creates a tRPC client.

LANGUAGE: typescript
CODE:
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { trpc } from '~/utils/trpc';
import React, { useState } from 'react';

export function App() {
  const [queryClient] = useState(() => new QueryClient());
  const [trpcClient] = useState(() =>
    trpc.createClient({
      url: 'http://localhost:5000/trpc',
    }),
  );
  return (
    <trpc.Provider client={trpcClient} queryClient={queryClient}>
      <QueryClientProvider client={queryClient}>
        {/* Your app here */}
      </QueryClientProvider>
    </trpc.Provider>
  );
}

----------------------------------------

TITLE: Context Extension with Protected Procedure in tRPC
DESCRIPTION: Demonstrates context extension by creating a protected procedure that ensures user authentication and provides type-safe access to the user object in subsequent middleware or procedures.

LANGUAGE: typescript
CODE:
const protectedProcedure = publicProcedure.use(async function isAuthed(opts) {
  const { ctx } = opts;
  if (!ctx.user) {
    throw new TRPCError({ code: 'UNAUTHORIZED' });
  }

  return opts.next({
    ctx: {
      user: ctx.user,
    },
  });
});

----------------------------------------

TITLE: Merging Child Routers in tRPC
DESCRIPTION: Shows how to merge multiple router modules under specific namespaces in a main app router. Includes setup of user and post routers with their respective procedures.

LANGUAGE: typescript
CODE:
import { router } from '../trpc';
import { z } from 'zod';

import { userRouter } from './user';
import { postRouter } from './post';

const appRouter = router({
  user: userRouter, // put procedures under "user" namespace
  post: postRouter, // put procedures under "post" namespace
});

export type AppRouter = typeof appRouter;

----------------------------------------

TITLE: Configuring tRPC Provider with React Query
DESCRIPTION: Sets up tRPC and React Query providers with HTTP batch link configuration and authentication headers. Uses useState for SSR compatibility.

LANGUAGE: tsx
CODE:
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { httpBatchLink } from '@trpc/client';
import React, { useState } from 'react';
import { trpc } from './utils/trpc';

export function App() {
  const [queryClient] = useState(() => new QueryClient());
  const [trpcClient] = useState(() =>
    trpc.createClient({
      links: [
        httpBatchLink({
          url: 'http://localhost:3000/trpc',

          // You can pass any HTTP headers you wish here
          async headers() {
            return {
              authorization: getAuthCookie(),
            };
          },
        }),
      ],
    }),
  );

  return (
    <trpc.Provider client={trpcClient} queryClient={queryClient}>
      <QueryClientProvider client={queryClient}>
        {/* Your app here */}
      </QueryClientProvider>
    </trpc.Provider>
  );
}

----------------------------------------

TITLE: Adding Input-Validated Query to tRPC Router in TypeScript
DESCRIPTION: Adds a 'userById' query procedure with input validation using Zod.

LANGUAGE: typescript
CODE:
import { z } from 'zod';

const appRouter = router({
  // ...
  userById: publicProcedure
    .input(z.string())
    .query(async (opts) => {
      const { input } = opts;
      const user = await db.user.findById(input);
      return user;
    }),
});

----------------------------------------

TITLE: Installing tRPC Next.js Starter Template
DESCRIPTION: Commands to create a new Next.js project with tRPC and Prisma using different package managers. The example creates a full-stack application with typesafe API integration.

LANGUAGE: sh
CODE:
# yarn
yarn create next-app --example https://github.com/trpc/trpc --example-path examples/next-prisma-starter trpc-prisma-starter

# npm
npx create-next-app --example https://github.com/trpc/trpc --example-path examples/next-prisma-starter trpc-prisma-starter

# pnpm
pnpm create next-app --example https://github.com/trpc/trpc --example-path examples/next-prisma-starter trpc-prisma-starter

# bun
bunx create-next-app --example https://github.com/trpc/trpc --example-path examples/next-prisma-starter trpc-prisma-starter

# deno
deno init --npm next-app --example https://github.com/trpc/trpc --example-path examples/next-prisma-starter trpc-prisma-starter

----------------------------------------

TITLE: Configuring Basic tRPC Server with TypeScript
DESCRIPTION: Complete example of setting up a tRPC server with TypeScript, including context creation, router initialization, procedure definition with Zod validation, and HTTP server setup. Demonstrates creating a basic greeting endpoint with type safety.

LANGUAGE: typescript
CODE:
import { initTRPC } from '@trpc/server';
import {
  CreateHTTPContextOptions,
  createHTTPServer,
} from '@trpc/server/adapters/standalone';
import { z } from 'zod';

// Initialize a context for the server
function createContext(opts: CreateHTTPContextOptions) {
  return {};
}

// Get the context type
type Context = Awaited<ReturnType<typeof createContext>>;

// Initialize tRPC
const t = initTRPC.context<Context>().create();

// Create main router
const appRouter = t.router({
  // Greeting procedure
  greeting: t.procedure
    .input(
      z.object({
        name: z.string(),
      }),
    )
    .query(({ input }) => `Hello, ${input.name}!`),
});

// Export the app router type to be imported on the client side
export type AppRouter = typeof appRouter;

// Create HTTP server
const { listen } = createHTTPServer({
  router: appRouter,
  createContext,
});

// Listen on port 2022
listen(2022);

----------------------------------------

TITLE: Creating tRPC Router with Typed Metadata in TypeScript
DESCRIPTION: This snippet demonstrates how to create a tRPC router with typed metadata. It defines a Meta interface with an authRequired property and initializes the router with this metadata type.

LANGUAGE: typescript
CODE:
import { initTRPC } from '@trpc/server';

// [...]

interface Meta {
  authRequired: boolean;
}

export const t = initTRPC.context<Context>().meta<Meta>().create();

export const appRouter = t.router({
  // [...]
});

----------------------------------------

TITLE: Using tRPC useQuery in React Component
DESCRIPTION: React component implementation demonstrating how to use the useQuery hook with and without arguments, showing proper usage patterns and data rendering.

LANGUAGE: tsx
CODE:
import { trpc } from '../utils/trpc';

export function MyComponent() {
  // input is optional, so we don't have to pass second argument
  const helloNoArgs = trpc.hello.useQuery();
  const helloWithArgs = trpc.hello.useQuery({ text: 'client' });

  return (
    <div>
      <h1>Hello World Example</h1>
      <ul>
        <li>
          helloNoArgs ({helloNoArgs.status}):{' '}
          <pre>{JSON.stringify(helloNoArgs.data, null, 2)}</pre>
        </li>
        <li>
          helloWithArgs ({helloWithArgs.status}):{' '}
          <pre>{JSON.stringify(helloWithArgs.data, null, 2)}</pre>
        </li>
      </ul>
    </div>
  );
}

----------------------------------------

TITLE: Configuring tRPC Client with Custom Headers in TypeScript
DESCRIPTION: This snippet demonstrates how to set up a tRPC client with custom headers using httpBatchLink. It includes a function to set an authentication token and dynamically add it to request headers.

LANGUAGE: typescript
CODE:
// Import the router type from your server file
import type { AppRouter } from '@/server/routers/app';
import { httpBatchLink } from '@trpc/client';
import { createTRPCNext } from '@trpc/next';

let token: string;

export function setToken(newToken: string) {
  /**
   * You can also save the token to cookies, and initialize from
   * cookies above.
   */
  token = newToken;
}

export const trpc = createTRPCNext<AppRouter>({
  config(opts) {
    return {
      links: [
        httpBatchLink({
          url: 'http://localhost:3000/api/trpc',
          /**
           * Headers will be called on each request.
           */
          headers() {
            return {
              Authorization: token,
            };
          },
        }),
      ],
    };
  },
});

----------------------------------------

TITLE: Implementing Request Logging Middleware in tRPC
DESCRIPTION: Creates a logging middleware that tracks request timing and logs the duration for both successful and failed requests. Includes path and request type in the logged metadata.

LANGUAGE: typescript
CODE:
export const loggedProcedure = publicProcedure.use(async (opts) => {
  const start = Date.now();

  const result = await opts.next();

  const durationMs = Date.now() - start;
  const meta = { path: opts.path, type: opts.type, durationMs };

  result.ok
    ? console.log('OK request timing:', meta)
    : console.error('Non-OK request timing', meta);

  return result;
});

----------------------------------------

TITLE: Next.js API Handler Configuration
DESCRIPTION: Creates the Next.js API handler for tRPC endpoints using the createNextApiHandler.

LANGUAGE: typescript
CODE:
import * as trpcNext from '@trpc/server/adapters/next';
import { appRouter } from '../../../server/routers/_app';

export default trpcNext.createNextApiHandler({
  router: appRouter,
  createContext: () => ({}),
});

----------------------------------------

TITLE: Resolver-Based Authorization in tRPC
DESCRIPTION: Shows how to implement authorization checks directly within tRPC resolvers. Includes examples of both public and protected routes with authorization checks in the resolver logic.

LANGUAGE: typescript
CODE:
import { initTRPC, TRPCError } from '@trpc/server';
import type { Context } from '../context';

export const t = initTRPC.context<Context>().create();

const appRouter = t.router({
  hello: t.procedure
    .input(z.string().nullish())
    .query((opts) => `hello ${opts.input ?? opts.ctx.user?.name ?? 'world'}`),
  secret: t.procedure.query((opts) => {
    if (!opts.ctx.user) {
      throw new TRPCError({ code: 'UNAUTHORIZED' });
    }
    return {
      secret: 'sauce',
    };
  }),
});

----------------------------------------

TITLE: tRPC Runtime Configuration Interface
DESCRIPTION: Interface definition for tRPC root configuration options, including transformer settings, error formatting, server environment controls, and development mode flags.

LANGUAGE: typescript
CODE:
export interface RootConfig<TTypes extends RootTypes> {
  /**
   * Use a data transformer
   * @see https://trpc.io/docs/v11/data-transformers
   */
  transformer: TTypes['transformer'];

  /**
   * Use custom error formatting
   * @see https://trpc.io/docs/v11/error-formatting
   */
  errorFormatter: ErrorFormatter<TTypes['ctx'], any>;

  /**
   * Allow `@trpc/server` to run in non-server environments
   * @warning **Use with caution**, this should likely mainly be used within testing.
   * @default false
   */
  allowOutsideOfServer: boolean;

  /**
   * Is this a server environment?
   * @warning **Use with caution**, this should likely mainly be used within testing.
   * @default typeof window === 'undefined' || 'Deno' in window || process.env.NODE_ENV === 'test'
   */
  isServer: boolean;

  /**
   * Is this development?
   * Will be used to decide if the API should return stack traces
   * @default process.env.NODE_ENV !== 'production'
   */
  isDev: boolean;
}

----------------------------------------

TITLE: Next.js API Handler Configuration
DESCRIPTION: Creates the Next.js API handler for tRPC endpoints using the createNextApiHandler.

LANGUAGE: typescript
CODE:
import * as trpcNext from '@trpc/server/adapters/next';
import { appRouter } from '../../../server/routers/_app';

export default trpcNext.createNextApiHandler({
  router: appRouter,
  createContext: () => ({}),
});

----------------------------------------

TITLE: Exporting tRPC API Handler for Next.js
DESCRIPTION: TypeScript code for exporting the tRPC API handler using the Next.js adapter. It creates a Next.js API route that handles tRPC requests.

LANGUAGE: typescript
CODE:
import * as trpcNext from '@trpc/server/adapters/next';
import { appRouter } from '../../../server/routers/_app';

// export API handler
// @link https://trpc.io/docs/server/adapters
export default trpcNext.createNextApiHandler({
  router: appRouter,
  createContext: () => ({}),
});

----------------------------------------

TITLE: Inner and Outer Context Implementation
DESCRIPTION: Demonstrates how to implement separated inner and outer context patterns for different usage scenarios including testing and server-side helpers.

LANGUAGE: typescript
CODE:
import type { CreateNextContextOptions } from '@trpc/server/adapters/next';
import { getSessionFromCookie, type Session } from './auth';

interface CreateInnerContextOptions extends Partial<CreateNextContextOptions> {
  session: Session | null;
}

export async function createContextInner(opts?: CreateInnerContextOptions) {
  return {
    prisma,
    session: opts.session,
  };
}

export async function createContext(opts: CreateNextContextOptions) {
  const session = getSessionFromCookie(opts.req);

  const contextInner = await createContextInner({ session });

  return {
    ...contextInner,
    req: opts.req,
    res: opts.res,
  };
}

export type Context = Awaited<ReturnType<typeof createContextInner>>;

----------------------------------------

TITLE: Creating tRPC Context in TypeScript
DESCRIPTION: Defines a context creation function for tRPC that extracts user information from request headers. This context is used in each request handled by the tRPC router.

LANGUAGE: typescript
CODE:
import { FetchCreateContextFnOptions } from '@trpc/server/adapters/fetch';

export function createContext({
  req,
  resHeaders,
}: FetchCreateContextFnOptions) {
  const user = { name: req.headers.get('username') ?? 'anonymous' };
  return { req, resHeaders, user };
}

export type Context = Awaited<ReturnType<typeof createContext>>;

----------------------------------------

TITLE: Defining useQuery Hook Interface in TypeScript
DESCRIPTION: TypeScript interface definition for the useQuery hook and its options, extending react-query's UseQueryOptions with tRPC-specific configuration options including SSR control, abort behavior, and context passing.

LANGUAGE: tsx
CODE:
function useQuery(
  input: TInput,
  opts?: UseTRPCQueryOptions;
)

interface UseTRPCQueryOptions
  extends UseQueryOptions {
  trpc: {
    ssr?: boolean;
    abortOnUnmount?: boolean;
    context?: Record<string, unknown>;
  }
}

----------------------------------------

TITLE: Configuring WebSocket Server in tRPC
DESCRIPTION: Setup for a WebSocket server with tRPC integration, including connection handling and keepalive configuration

LANGUAGE: typescript
CODE:
import { applyWSSHandler } from '@trpc/server/adapters/ws';
import ws from 'ws';
import { appRouter } from './routers/app';
import { createContext } from './trpc';

const wss = new ws.Server({
  port: 3001,
});
const handler = applyWSSHandler({
  wss,
  router: appRouter,
  createContext,
  keepAlive: {
    enabled: true,
    pingMs: 30000,
    pongWaitMs: 5000,
  },
});

wss.on('connection', (ws) => {
  console.log(`➕➕ Connection (${wss.clients.size})`);
  ws.once('close', () => {
    console.log(`➖➖ Connection (${wss.clients.size})`);
  });
});
console.log('✅ WebSocket Server listening on ws://localhost:3001');

process.on('SIGTERM', () => {
  console.log('SIGTERM');
  handler.broadcastReconnectNotification();
  wss.close();
});

----------------------------------------

TITLE: Integrating tRPC with Express using Adapter
DESCRIPTION: Example of using the tRPC Express adapter to convert a tRPC router into an Express middleware. It sets up the Express app with the tRPC router and starts the server.

LANGUAGE: typescript
CODE:
import { initTRPC } from '@trpc/server';
import * as trpcExpress from '@trpc/server/adapters/express';
import express from 'express';

// created for each request
const createContext = ({
  req,
  res,
}: trpcExpress.CreateExpressContextOptions) => ({}); // no context
type Context = Awaited<ReturnType<typeof createContext>>;

const t = initTRPC.context<Context>().create();
const appRouter = t.router({
  // [...]
});

const app = express();

app.use(
  '/trpc',
  trpcExpress.createExpressMiddleware({
    router: appRouter,
    createContext,
  }),
);

app.listen(4000);

----------------------------------------

TITLE: Configuring Separate Upload/Download Transformers in tRPC
DESCRIPTION: Implementing separate transformers for upload (SuperJSON) and download (Devalue) in tRPC. This configuration allows for optimized performance in data transformation.

LANGUAGE: typescript
CODE:
import { uneval } from 'devalue';
import superjson from 'superjson';

// [...]

export const transformer = {
  input: superjson,
  output: {
    serialize: (object) => uneval(object),
    // This `eval` only ever happens on the **client**
    deserialize: (object) => eval(`(${object})`),
  },
};

----------------------------------------

TITLE: Configuring tRPC Client with Caching in Next.js
DESCRIPTION: Sets up tRPC client configuration with SSR and response caching. Includes HTTP batch link setup and cache control headers with stale-while-revalidate strategy.

LANGUAGE: typescript
CODE:
import { httpBatchLink } from '@trpc/client';
import { createTRPCNext } from '@trpc/next';
import type { AppRouter } from '../server/routers/_app';

export const trpc = createTRPCNext<AppRouter>({
  config(opts) {
    if (typeof window !== 'undefined') {
      return {
        links: [
          httpBatchLink({
            url: '/api/trpc',
          }),
        ],
      };
    }

    const url = process.env.VERCEL_URL
      ? `https://${process.env.VERCEL_URL}/api/trpc`
      : 'http://localhost:3000/api/trpc';

    return {
      links: {
        http: httpBatchLink({
          url,
        }),
      },
    };
  },
  ssr: true,
  responseMeta(opts) {
    const { clientErrors } = opts;

    if (clientErrors.length) {
      return {
        status: clientErrors[0].data?.httpStatus ?? 500,
      };
    }

    const ONE_DAY_IN_SECONDS = 60 * 60 * 24;
    return {
      headers: {
        'cache-control': `s-maxage=1, stale-while-revalidate=${ONE_DAY_IN_SECONDS}`,
      },
    };
  },
});

----------------------------------------

TITLE: tRPC Runtime Configuration Interface
DESCRIPTION: Defines the interface for tRPC runtime configuration. This includes options for data transformation, error formatting, environment settings, and more.

LANGUAGE: typescript
CODE:
export interface RuntimeConfig<TTypes extends RootConfigTypes> {
  /**
   * Use a data transformer
   * @see https://trpc.io/docs/data-transformers
   */
  transformer: TTypes['transformer'];

  /**
   * Use custom error formatting
   * @see https://trpc.io/docs/error-formatting
   */
  errorFormatter: ErrorFormatter<TTypes['ctx'], any>;

  /**
   * Allow `@trpc/server` to run in non-server environments
   * @warning **Use with caution**, this should likely mainly be used within testing.
   * @default false
   */
  allowOutsideOfServer: boolean;

  /**
   * Is this a server environment?
   * @warning **Use with caution**, this should likely mainly be used within testing.
   * @default typeof window === 'undefined' || 'Deno' in window || process.env.NODE_ENV === 'test'
   */
  isServer: boolean;

  /**
   * Is this development?
   * Will be used to decide if the API should return stack traces
   * @default process.env.NODE_ENV !== 'production'
   */
  isDev: boolean;
}

----------------------------------------

TITLE: Configuring tRPC Query Behavior
DESCRIPTION: Examples showing how to configure tRPC query refetching behavior, both per-query and globally. Demonstrates setting refetchOnMount and refetchOnWindowFocus options.

LANGUAGE: tsx
CODE:
const data = trpc.example.useQuery(
  undefined,
  { refetchOnMount: false, refetchOnWindowFocus: false },
);

LANGUAGE: tsx
CODE:
import { httpBatchLink } from '@trpc/client';
import { createTRPCNext } from '@trpc/next';
import superjson from 'superjson';
import type { AppRouter } from './api/trpc/[trpc]';
export const trpc = createTRPCNext<AppRouter>({
  config(opts) {
    return {
      links: [
        httpBatchLink({
          url: `${getBaseUrl()}/api/trpc`,
        }),
      ],
      queryClientConfig: {
        defaultOptions: {
          queries: {
            refetchOnMount: false,
            refetchOnWindowFocus: false,
          },
        },
      },
    };
  },
});

----------------------------------------

TITLE: Setting up tRPC with Next.js App Component
DESCRIPTION: Basic setup for integrating tRPC with a Next.js _app.tsx file using the withTRPC HOC wrapper.

LANGUAGE: typescript
CODE:
import { trpc } from '~/utils/trpc';
import type { AppProps } from 'next/app';
import React from 'react';

const MyApp: AppType = ({ Component, pageProps }: AppProps) => {
  return <Component {...pageProps} />;
};

export default trpc.withTRPC(MyApp);

----------------------------------------

TITLE: Configuring Next.js _app.tsx with tRPC
DESCRIPTION: TypeScript code for wrapping the root Next.js app component with the tRPC HOC. This enables tRPC functionality throughout the application.

LANGUAGE: typescript
CODE:
import type { AppType } from 'next/app';
import { trpc } from '../utils/trpc';

const MyApp: AppType = ({ Component, pageProps }) => {
  return <Component {...pageProps} />;
};

export default trpc.withTRPC(MyApp);

----------------------------------------

TITLE: Configuring tRPC Client with Links in TypeScript
DESCRIPTION: This snippet demonstrates how to configure a tRPC client with multiple links, including a logger link and an HTTP batch link. It shows the basic structure of link composition in a tRPC Next.js setup.

LANGUAGE: typescript
CODE:
import { httpBatchLink, loggerLink } from '@trpc/client';
import { createTRPCNext } from '@trpc/next';

export default createTRPCNext<AppRouter>({
  config() {
    const url = `http://localhost:3000`;

    return {
      links: [
        loggerLink(),
        httpBatchLink({
          url,
        }),
      ],
    };
  },
});

----------------------------------------

TITLE: Setting up tRPC Provider in Next.js App Component
DESCRIPTION: Shows how to wrap a Next.js application with tRPC provider using the withTRPC higher-order component. This setup is required to enable tRPC functionality throughout the application.

LANGUAGE: typescript
CODE:
import { trpc } from '~/utils/trpc';
import type { AppProps } from 'next/app';
import React from 'react';

const MyApp: AppType = ({ Component, pageProps }: AppProps) => {
  return <Component {...pageProps} />;
};

export default trpc.withTRPC(MyApp);

----------------------------------------

TITLE: Initializing HTTP Batch Link in TypeScript
DESCRIPTION: Basic setup of httpBatchLink in a tRPC client. Creates a client instance with httpBatchLink configured to send requests to a specified URL.

LANGUAGE: typescript
CODE:
import { createTRPCClient, httpBatchLink } from '@trpc/client';
import type { AppRouter } from '../server';

const client = createTRPCClient<AppRouter>({
  links: [
    httpBatchLink({
      url: 'http://localhost:3000',
    }),
    // transformer,
  ],
});

----------------------------------------

TITLE: Configuring tRPC Backend Router with Mutation
DESCRIPTION: Sets up a tRPC router with a login mutation procedure that accepts a name input and returns user data. Uses Zod for input validation and demonstrates basic mutation setup pattern.

LANGUAGE: tsx
CODE:
import { initTRPC } from '@trpc/server';
import { z } from 'zod';

export const t = initTRPC.create();

export const appRouter = t.router({
  // Create procedure at path 'login'
  // The syntax is identical to creating queries
  login: t.procedure
    // using zod schema to validate and infer input values
    .input(
      z.object({
        name: z.string(),
      }),
    )
    .mutation((opts) => {
      // Here some login stuff would happen
      return {
        user: {
          name: opts.input.name,
          role: 'ADMIN',
        },
      };
    }),
});

----------------------------------------

TITLE: Implementing AWS Lambda Request Handler
DESCRIPTION: Setup of the AWS Lambda request handler with context creation for API Gateway integration. Shows how to create the handler with router and context configuration.

LANGUAGE: typescript
CODE:
import { CreateAWSLambdaContextOptions, awsLambdaRequestHandler } from '@trpc/server/adapters/aws-lambda';

const appRouter = /* ... */;

// created for each request
const createContext = ({
  event,
  context,
}: CreateAWSLambdaContextOptions<APIGatewayProxyEventV2>) => ({}) // no context
type Context = Awaited<ReturnType<typeof createContext>>;

export const handler = awsLambdaRequestHandler({
  router: appRouter,
  createContext,
})

----------------------------------------

TITLE: Input Merging with Middleware in tRPC
DESCRIPTION: Shows how to stack multiple input validators using middleware to build more complex validation types. Combines a base townName validation with additional name validation.

LANGUAGE: typescript
CODE:
const baseProcedure = t.procedure
  .input(z.object({ townName: z.string() }))
  .use((opts) => {
    const input = opts.input;
    console.log(`Handling request with user from: ${input.townName}`);
    return opts.next();
  });

export const appRouter = t.router({
  hello: baseProcedure
    .input(
      z.object({
        name: z.string(),
      }),
    )
    .query((opts) => {
      const input = opts.input;
      return {
        greeting: `Hello ${input.name}, my friend from ${input.townName}`,
      };
    }),
});

----------------------------------------

TITLE: Implementing Context Extension Middleware in tRPC
DESCRIPTION: This snippet demonstrates how to use context extension in tRPC middleware to modify the context in a type-safe manner, ensuring non-null user data.

LANGUAGE: typescript
CODE:
type Context = {
  // user is nullable
  user?: {
    id: string;
  };
};

const protectedProcedure = publicProcedure.use(async function isAuthed(opts) {
  const { ctx } = opts;
  // `ctx.user` is nullable
  if (!ctx.user) {
    throw new TRPCError({ code: 'UNAUTHORIZED' });
  }

  return opts.next({
    ctx: {
      // ✅ user value is known to be non-null now
      user: ctx.user,
    },
  });
});

protectedProcedure.query(({ ctx }) => ctx.user);

----------------------------------------

TITLE: Implementing tRPC Mutation in React Component
DESCRIPTION: Shows how to use the useMutation hook in a React component to handle login functionality. Includes error handling and loading state management.

LANGUAGE: tsx
CODE:
import { trpc } from '../utils/trpc';

export function MyComponent() {
  const mutation = trpc.login.useMutation();

  const handleLogin = () => {
    const name = 'John Doe';

    mutation.mutate({ name });
  };

  return (
    <div>
      <h1>Login Form</h1>
      <button onClick={handleLogin} disabled={mutation.isPending}>
        Login
      </button>

      {mutation.error && <p>Something went wrong! {mutation.error.message}</p>}
    </div>
  );
}

----------------------------------------

TITLE: Extracting HTTP Status Code from Error in TypeScript
DESCRIPTION: Shows how to use the getHTTPStatusCodeFromError helper function to extract the HTTP status code from a TRPCError.

LANGUAGE: typescript
CODE:
import { getHTTPStatusCodeFromError } from '@trpc/server/http';

// Example error you might get if your input validation fails
const error: TRPCError = {
  name: 'TRPCError',
  code: 'BAD_REQUEST',
  message: '"password" must be at least 4 characters',
};

if (error instanceof TRPCError) {
  const httpCode = getHTTPStatusCodeFromError(error);
  console.log(httpCode); // 400
}

----------------------------------------

TITLE: Creating Custom HTTP Server with tRPC Handler in TypeScript
DESCRIPTION: This code snippet shows how to create a custom HTTP server using Node.js's createServer function and integrate it with tRPC's createHTTPHandler. This approach allows for more flexibility in handling requests before passing them to the tRPC handler.

LANGUAGE: typescript
CODE:
import { createServer } from 'http';
import { initTRPC } from '@trpc/server';
import { createHTTPHandler } from '@trpc/server/adapters/standalone';

const handler = createHTTPHandler({
  router: appRouter,
  createContext() {
    return {};
  },
});

createServer((req, res) => {
  /**
   * Handle the request however you like,
   * just call the tRPC handler when you're ready
   */

  handler(req, res);
}).listen(3333);

----------------------------------------

TITLE: Creating a Custom tRPC Link in TypeScript
DESCRIPTION: This example illustrates how to create a custom tRPC link. It demonstrates the structure of a link function, including operation handling, subscribing to the next link, and using the observer pattern to propagate results.

LANGUAGE: typescript
CODE:
import { TRPCLink } from '@trpc/client';
import { observable } from '@trpc/server/observable';
import type { AppRouter } from '~/server/routers/_app';

export const customLink: TRPCLink<AppRouter> = () => {
  // here we just got initialized in the app - this happens once per app
  // useful for storing cache for instance
  return ({ next, op }) => {
    // this is when passing the result to the next link

    // each link needs to return an observable which propagates results
    return observable((observer) => {
      console.log('performing operation:', op);
      const unsubscribe = next(op).subscribe({
        next(value) {
          console.log('we received value', value);
          observer.next(value);
        },
        error(err) {
          console.log('we received error', err);
          observer.error(err);
        },
        complete() {
          observer.complete();
        },
      });

      return unsubscribe;
    });
  };
};

----------------------------------------

TITLE: Handling tRPC Errors in React Component
DESCRIPTION: Shows how to handle custom formatted errors in a React component using tRPC mutation. Includes error checking and display of Zod validation errors.

LANGUAGE: tsx
CODE:
export function MyComponent() {
  const mutation = trpc.addPost.useMutation();

  useEffect(() => {
    mutation.mutate({ title: 'example' });
  }, []);

  if (mutation.error?.data?.zodError) {
    // zodError will be inferred
    return (
      <pre>Error: {JSON.stringify(mutation.error.data.zodError, null, 2)}</pre>
    );
  }
  return <>[...]</>;
}

----------------------------------------

TITLE: Defining useQuery Signature in TypeScript
DESCRIPTION: Describes the function signature and options interface for the useQuery hook in tRPC. It includes tRPC-specific options for SSR, abort on unmount, and context.

LANGUAGE: tsx
CODE:
function useQuery(
  input: TInput | SkipToken,
  opts?: UseTRPCQueryOptions;
)

interface UseTRPCQueryOptions
  extends UseQueryOptions {
  trpc: {
    ssr?: boolean;
    abortOnUnmount?: boolean;
    context?: Record<string, unknown>;
  }
}

----------------------------------------

TITLE: Configuring tRPC Client with WebSocket Transport
DESCRIPTION: Client-side setup for tRPC with WebSocket transport configuration

LANGUAGE: typescript
CODE:
import { createTRPCClient, createWSClient, wsLink } from '@trpc/client';
import type { AppRouter } from '../path/to/server/trpc';

const wsClient = createWSClient({
  url: `ws://localhost:3001`,
});

const client = createTRPCClient<AppRouter>({
  links: [
    wsLink({
      client: wsClient,
    }),
  ],
});

----------------------------------------

TITLE: Basic Input Validation with Zod in tRPC
DESCRIPTION: Demonstrates how to set up basic input validation for a tRPC procedure using Zod schema validation. The example validates an object with a name string property.

LANGUAGE: typescript
CODE:
import { initTRPC } from '@trpc/server';
import { z } from 'zod';

export const t = initTRPC.create();
const publicProcedure = t.procedure;

export const appRouter = t.router({
  hello: publicProcedure
    .input(
      z.object({
        name: z.string(),
      }),
    )
    .query((opts) => {
      const name = opts.input.name;
      return {
        greeting: `Hello ${opts.input.name}`,
      };
    }),
});

----------------------------------------

TITLE: Configuring tRPC Client with Links in Next.js
DESCRIPTION: Example of setting up tRPC client configuration with logger and HTTP batch links in a Next.js application. Shows how to chain multiple links together in the client configuration.

LANGUAGE: typescript
CODE:
import { httpBatchLink, loggerLink } from '@trpc/client';
import { createTRPCNext } from '@trpc/next';

export default createTRPCNext<AppRouter>({
  config() {
    const url = `http://localhost:3000`;

    return {
      links: [
        loggerLink(),
        httpBatchLink({
          url,
        }),
      ],
    };
  },
});

----------------------------------------

TITLE: Recommended File Structure Example
DESCRIPTION: Shows the recommended file structure for a tRPC project with Next.js, including directory organization for API routes, routers, and utilities.

LANGUAGE: graphql
CODE:
.
├── prisma  # <-- if prisma is added
│   └── [..]
├── src
│   ├── pages
│   │   ├── _app.tsx  # <-- add `withTRPC()`-HOC here
│   │   ├── api
│   │   │   └── trpc
│   │   │       └── [trpc].ts  # <-- tRPC HTTP handler
│   │   └── [..]
│   ├── server
│   │   ├── routers
│   │   │   ├── _app.ts  # <-- main app router
│   │   │   ├── post.ts  # <-- sub routers
│   │   │   └── [..]
│   │   ├── context.ts   # <-- create app context
│   │   └── trpc.ts      # <-- procedure helpers
│   └── utils
│       └── trpc.ts  # <-- your typesafe tRPC hooks
└── [..]

----------------------------------------

TITLE: Custom Function-based Validator in tRPC
DESCRIPTION: Demonstrates how to create a basic custom validator using pure functions without external libraries. Shows both input and output validation for string types.

LANGUAGE: typescript
CODE:
import { initTRPC } from '@trpc/server';

export const t = initTRPC.create();
const publicProcedure = t.procedure;

export const appRouter = t.router({
  hello: publicProcedure
    .input((value): string => {
      if (typeof value === 'string') {
        return value;
      }
      throw new Error('Input is not a string');
    })
    .output((value): string => {
      if (typeof value === 'string') {
        return value;
      }
      throw new Error('Output is not a string');
    })
    .query((opts) => {
      const { input } = opts;
      return `hello ${input}`;
    }),
});

----------------------------------------

TITLE: Implementing Infinite Query Procedure with tRPC and Prisma in TypeScript
DESCRIPTION: This snippet demonstrates how to set up a tRPC procedure for infinite queries using Prisma. It includes input validation with Zod and cursor-based pagination.

LANGUAGE: tsx
CODE:
import { initTRPC } from '@trpc/server';
import { z } from 'zod';
import { Context } from './[trpc]';

export const t = initTRPC.create();

export const appRouter = t.router({
  infinitePosts: t.procedure
    .input(
      z.object({
        limit: z.number().min(1).max(100).nullish(),
        cursor: z.number().nullish(), // <-- "cursor" needs to exist, but can be any type
        direction: z.enum(['forward', 'backward']), // optional, useful for bi-directional query
      }),
    )
    .query(async (opts) => {
      const { input } = opts;
      const limit = input.limit ?? 50;
      const { cursor } = input;
      const items = await prisma.post.findMany({
        take: limit + 1, // get an extra item at the end which we'll use as next cursor
        where: {
          title: {
            contains: 'Prisma' /* Optional filter */,
          },
        },
        cursor: cursor ? { myCursor: cursor } : undefined,
        orderBy: {
          myCursor: 'asc',
        },
      });
      let nextCursor: typeof cursor | undefined = undefined;
      if (items.length > limit) {
        const nextItem = items.pop();
        nextCursor = nextItem!.myCursor;
      }

      return {
        items,
        nextCursor,
      };
    }),
});

----------------------------------------

TITLE: Basic tRPC Input Validation with Zod
DESCRIPTION: Demonstrates how to implement basic input validation for a tRPC procedure using Zod. The example shows validation of a name parameter using an object schema.

LANGUAGE: typescript
CODE:
import { initTRPC } from '@trpc/server';
import { z } from 'zod';

export const t = initTRPC.create();
const publicProcedure = t.procedure;

export const appRouter = t.router({
  hello: publicProcedure
    .input(
      z.object({
        name: z.string(),
      }),
    )
    .query((opts) => {
      const name = opts.input.name;
      return {
        greeting: `Hello ${opts.input.name}`,
      };
    }),
});

----------------------------------------

TITLE: Merging with Child Routers in tRPC
DESCRIPTION: This snippet shows how to merge routers using child routers in tRPC. It demonstrates the creation of an app router that combines user and post routers as namespaces.

LANGUAGE: typescript
CODE:
import { router } from '../trpc';
import { z } from 'zod';

import { userRouter } from './user';
import { postRouter } from './post';

const appRouter = router({
  user: userRouter, // put procedures under "user" namespace
  post: postRouter, // put procedures under "post" namespace
});

// You can then access the merged route with
// http://localhost:3000/trpc/<NAMESPACE>.<PROCEDURE>

export type AppRouter = typeof appRouter;

----------------------------------------

TITLE: Using tRPC Client for Queries and Mutations in TypeScript
DESCRIPTION: This snippet shows how to use the initialized tRPC client to make type-safe API calls. It includes examples of querying user data and creating a new user through mutation.

LANGUAGE: typescript
CODE:
const bilbo = await client.getUser.query('id_bilbo');
// => { id: 'id_bilbo', name: 'Bilbo' };

const frodo = await client.createUser.mutate({ name: 'Frodo' });
// => { id: 'id_frodo', name: 'Frodo' };

----------------------------------------

TITLE: Using zAsyncIterable for Output Validation in tRPC Subscriptions
DESCRIPTION: This snippet demonstrates how to use the zAsyncIterable helper to validate the output of a tRPC subscription procedure. It ensures that each yielded value conforms to a specific schema.

LANGUAGE: typescript
CODE:
import { publicProcedure, router } from '../trpc';
import { zAsyncIterable } from './zAsyncIterable';

export const appRouter = router({
  mySubscription: publicProcedure
    .input(
      z.object({
        lastEventId: z.coerce.number().min(0).optional(),
      }),
    )
    .output(
      zAsyncIterable({
        yield: z.object({
          count: z.number(),
        }),
        tracked: true,
      }),
    )
    .subscription(async function* (opts) {
      let index = opts.input.lastEventId ?? 0;
      while (true) {
        index++;
        yield tracked(index, {
          count: index,
        });

        await new Promise((resolve) => setTimeout(resolve, 1000));
      }
    }),
});

----------------------------------------

TITLE: Initializing and Using tRPC Client in TypeScript
DESCRIPTION: This snippet demonstrates how to create a tRPC client, configure it with an HTTP batch link, and make a query to a server. It includes importing necessary types and functions, setting up the client, and executing a query.

LANGUAGE: typescript
CODE:
import { createTRPCClient, httpBatchLink } from '@trpc/client';
// Importing the router type from the server file
import type { AppRouter } from './server';

// Initializing the tRPC client
const trpc = createTRPCClient<AppRouter>({
  links: [
    httpBatchLink({
      url: 'http://localhost:3000/trpc',
    }),
  ],
});

async function main() {
  // Querying the greeting
  const helloResponse = await trpc.greeting.query({
    name: 'world',
  });

  console.log('helloResponse', helloResponse); // Hello world
}

main();

----------------------------------------

TITLE: Implementing Different Upload/Download Transformers
DESCRIPTION: Setup for using different transformers for upload (SuperJSON) and download (devalue) operations.

LANGUAGE: bash
CODE:
yarn add superjson devalue

LANGUAGE: typescript
CODE:
import { uneval } from 'devalue';
import superjson from 'superjson';

export const transformer = {
  input: superjson,
  output: {
    serialize: (object) => uneval(object),
    deserialize: (object) => (0, eval)(`(${object})`),
  },
};

----------------------------------------

TITLE: Creating WebSocket Server for tRPC
DESCRIPTION: Sets up a WebSocket server using the 'ws' package and applies the tRPC WebSocket handler. It also includes event listeners for connections and server shutdown.

LANGUAGE: typescript
CODE:
import { applyWSSHandler } from '@trpc/server/adapters/ws';
import ws from 'ws';
import { appRouter } from './routers/app';
import { createContext } from './trpc';

const wss = new ws.Server({
  port: 3001,
});
const handler = applyWSSHandler({ wss, router: appRouter, createContext });

wss.on('connection', (ws) => {
  console.log(`➕➕ Connection (${wss.clients.size})`);
  ws.once('close', () => {
    console.log(`➖➖ Connection (${wss.clients.size})`);
  });
});
console.log('✅ WebSocket Server listening on ws://localhost:3001');

process.on('SIGTERM', () => {
  console.log('SIGTERM');
  handler.broadcastReconnectNotification();
  wss.close();
});

----------------------------------------

TITLE: Using tRPC Query in React Component
DESCRIPTION: Demonstrates how to use tRPC queries in a React component. This example fetches a greeting using the trpc.greeting.useQuery hook and handles loading and error states.

LANGUAGE: typescript
CODE:
import { trpc } from '~/utils/trpc';

export function Hello() {
  const { data, error, status } = trpc.greeting.useQuery({ name: 'tRPC' });

  if (error) {
    return <p>{error.message}</p>;
  }

  if (status !== 'success') {
    return <p>Loading...</p>;
  }

  return <div>{data && <p>{data.greeting}</p>}</div>;
}

----------------------------------------

TITLE: Merging Routers with t.mergeRouters in tRPC
DESCRIPTION: This snippet demonstrates how to merge routers using t.mergeRouters in tRPC. It shows how to combine user and post routers into a single flat namespace.

LANGUAGE: typescript
CODE:
import { router, publicProcedure, mergeRouters } from '../trpc';
import { z } from 'zod';

import { userRouter } from './user';
import { postRouter } from './post';

const appRouter = mergeRouters(userRouter, postRouter)

export type AppRouter = typeof appRouter;

----------------------------------------

TITLE: Setting up tRPC with Vercel Edge Runtime
DESCRIPTION: Code for creating a Vercel Edge Runtime function that uses tRPC. This setup handles incoming fetch events and routes them through the tRPC handler.

LANGUAGE: typescript
CODE:
import { fetchRequestHandler } from '@trpc/server/adapters/fetch';
import { createContext } from './context';
import { appRouter } from './router';

addEventListener('fetch', (event) => {
  return event.respondWith(
    fetchRequestHandler({
      endpoint: '/trpc',
      req: event.request,
      router: appRouter,
      createContext,
    }),
  );
});

----------------------------------------

TITLE: Adding Subscription Procedure in tRPC Server Router
DESCRIPTION: Demonstrates how to add a subscription procedure to a tRPC router using an EventEmitter. It includes a subscription for 'onAdd' events and a mutation procedure for adding new posts.

LANGUAGE: typescript
CODE:
import { EventEmitter } from 'events';
import { initTRPC } from '@trpc/server';
import { observable } from '@trpc/server/observable';
import { z } from 'zod';

// create a global event emitter (could be replaced by redis, etc)
const ee = new EventEmitter();

const t = initTRPC.create();

export const appRouter = t.router({
  onAdd: t.procedure.subscription(() => {
    // return an `observable` with a callback which is triggered immediately
    return observable<Post>((emit) => {
      const onAdd = (data: Post) => {
        // emit data to client
        emit.next(data);
      };

      // trigger `onAdd()` when `add` is triggered in our event emitter
      ee.on('add', onAdd);

      // unsubscribe function when client disconnects or stops subscribing
      return () => {
        ee.off('add', onAdd);
      };
    });
  }),
  add: t.procedure
    .input(
      z.object({
        id: z.string().uuid().optional(),
        text: z.string().min(1),
      }),
    )
    .mutation(async (opts) => {
      const post = { ...opts.input }; /* [..] add to db */

      ee.emit('add', post);
      return post;
    }),
});

----------------------------------------

TITLE: Configuring tRPC Client for WebSocket Communication
DESCRIPTION: Shows how to set up the tRPC client to use WebSocket transport for communication with the server. It creates a persistent WebSocket connection and configures the client with a WebSocket link.

LANGUAGE: typescript
CODE:
import { httpBatchLink } from '@trpc/client/links/httpBatchLink';
import { createWSClient, wsLink } from '@trpc/client/links/wsLink';

// create persistent WebSocket connection
const wsClient = createWSClient({
  url: `ws://localhost:3001`,
});

// configure TRPCClient to use WebSockets transport
const client = createTRPCClient<AppRouter>({
  links: [
    wsLink({
      client: wsClient,
    }),
  ],
});

----------------------------------------

TITLE: Creating Post Router in tRPC
DESCRIPTION: This snippet demonstrates the creation of a post router in tRPC. It includes procedures for creating and listing posts, using Zod for input validation.

LANGUAGE: typescript
CODE:
import { router, publicProcedure } from '../trpc';
import { z } from 'zod';
export const postRouter = router({
  create: publicProcedure
    .input(
      z.object({
        title: z.string(),
      }),
    )
    .mutation((opts) => {
      const { input } = opts;
      //        ^?
      // [...]
    }),
  list: publicProcedure.query(() => {
    // ...
    return [];
  }),
});

----------------------------------------

TITLE: Package Reference in Markdown
DESCRIPTION: Lists the main tRPC packages that are covered by this test suite, including server, client, react-query, and next components.

LANGUAGE: markdown
CODE:
# @trpc/tests

This is the home for the entire test suite for `trpc`, including `@trpc/server`, `@trpc/client`, `@trpc/react-query` & `@trpc/next`.

----------------------------------------

TITLE: Creating tRPC Client and Querying Server in TypeScript
DESCRIPTION: Demonstrates how to create a tRPC client that connects to the server using httpBatchLink. Shows how to query the 'greeting' procedure with type safety and inferred return types.

LANGUAGE: typescript
CODE:
import { createTRPCClient, httpBatchLink } from '@trpc/client';
import type { AppRouter } from './server';

const trpc = createTRPCClient<AppRouter>({
  links: [
    httpBatchLink({
      url: 'http://localhost:3000',
    }),
  ],
});

const res = await trpc.greeting.query({ name: 'John' });
//    ^?

----------------------------------------

TITLE: Using Batch Requests with tRPC Client (TypeScript)
DESCRIPTION: This code snippet shows how to use batching with the configured tRPC client. It demonstrates making multiple queries in a single HTTP request using Promise.all.

LANGUAGE: typescript
CODE:
const somePosts = await Promise.all([
  trpc.post.byId.query(1),
  trpc.post.byId.query(2),
  trpc.post.byId.query(3),
]);

----------------------------------------

TITLE: Integrating tRPC with Astro
DESCRIPTION: Code snippet showing how to integrate tRPC with Astro using the fetch adapter. This setup handles all HTTP methods for tRPC endpoints.

LANGUAGE: typescript
CODE:
import { fetchRequestHandler } from '@trpc/server/adapters/fetch';
import type { APIRoute } from 'astro';
import { createContext } from '../../server/context';
import { appRouter } from '../../server/router';

export const all: APIRoute = (opts) => {
  return fetchRequestHandler({
    endpoint: '/trpc',
    req: opts.request,
    router: appRouter,
    createContext,
  });
};

----------------------------------------

TITLE: Integrating tRPC with Express using the adapter
DESCRIPTION: Demonstrates how to use the tRPC Express adapter to convert a tRPC router into an Express middleware. It includes context creation and server setup.

LANGUAGE: typescript
CODE:
import { initTRPC } from '@trpc/server';
import * as trpcExpress from '@trpc/server/adapters/express';

// created for each request
const createContext = ({
  req,
  res,
}: trpcExpress.CreateExpressContextOptions) => ({}); // no context
type Context = Awaited<ReturnType<typeof createContext>>;

const t = initTRPC.context<Context>().create();
const appRouter = t.router({
  // [...]
});

const app = express();

app.use(
  '/trpc',
  trpcExpress.createExpressMiddleware({
    router: appRouter,
    createContext,
  }),
);

app.listen(4000);

----------------------------------------

TITLE: Creating a Protected Router Helper Function in tRPC
DESCRIPTION: This helper function creates a protected router that enforces authorization for all downstream procedures. It throws an UNAUTHORIZED error if the user is not authenticated.

LANGUAGE: typescript
CODE:
import * as trpc from '@trpc/server';
import { Context } from './context';

export function createProtectedRouter() {
  return trpc.router<Context>().middleware(({ ctx, next }) => {
    if (!ctx.user) {
      throw new trpc.TRPCError({ code: 'UNAUTHORIZED' });
    }
    return next({
      ctx: {
        ...ctx,
        // infers that `user` is non-nullable to downstream procedures
        user: ctx.user,
      },
    });
  });
}

----------------------------------------

TITLE: Creating a tRPC router in TypeScript
DESCRIPTION: Example of implementing a tRPC router with query and mutation procedures. It demonstrates input validation using Zod and defines types for the API.

LANGUAGE: typescript
CODE:
import { initTRPC } from '@trpc/server';
import { z } from 'zod';

export const t = initTRPC.create();

export const appRouter = t.router({
  getUser: t.procedure.input(z.string()).query((opts) => {
    opts.input; // string
    return { id: opts.input, name: 'Bilbo' };
  }),
  createUser: t.procedure
    .input(z.object({ name: z.string().min(5) }))
    .mutation(async (opts) => {
      // use your ORM of choice
      return await UserModel.create({
        data: opts.input,
      });
    }),
});

// export type definition of API
export type AppRouter = typeof appRouter;

----------------------------------------

TITLE: Using useQuery Hook in React Component with tRPC
DESCRIPTION: Shows how to use the useQuery hook in a React component to fetch data from the tRPC backend. It includes examples of queries with and without arguments.

LANGUAGE: tsx
CODE:
import { trpc } from '../utils/trpc';

export function MyComponent() {
  // input is optional, so we don't have to pass second argument
  const helloNoArgs = trpc.hello.useQuery();
  const helloWithArgs = trpc.hello.useQuery({ text: 'client' });

  return (
    <div>
      <h1>Hello World Example</h1>
      <ul>
        <li>
          helloNoArgs ({helloNoArgs.status}):{' '}
          <pre>{JSON.stringify(helloNoArgs.data, null, 2)}</pre>
        </li>
        <li>
          helloWithArgs ({helloWithArgs.status}):{' '}
          <pre>{JSON.stringify(helloWithArgs.data, null, 2)}</pre>
        </li>
      </ul>
    </div>
  );
}

----------------------------------------

TITLE: Installing tRPC Dependencies for Express
DESCRIPTION: Command to install required dependencies for using tRPC with Express. Zod is included but optional.

LANGUAGE: bash
CODE:
yarn add @trpc/server zod

----------------------------------------

TITLE: Server-Side Call in Next.js API Endpoint with Error Handling
DESCRIPTION: This snippet demonstrates how to use the tRPC caller in a Next.js API endpoint, including error handling for both tRPC and general errors.

LANGUAGE: typescript
CODE:
import { TRPCError } from '@trpc/server';
import { getHTTPStatusCodeFromError } from '@trpc/server/http';
import { appRouter } from '~/server/routers/_app';
import type { NextApiRequest, NextApiResponse } from 'next';

type ResponseData = {
  data?: {
    postTitle: string;
  };
  error?: {
    message: string;
  };
};

export default async (
  req: NextApiRequest,
  res: NextApiResponse<ResponseData>,
) => {
  /** We want to simulate an error, so we pick a post ID that does not exist in the database. */
  const postId = `this-id-does-not-exist-${Math.random()}`;

  const caller = appRouter.createCaller({});

  try {
    // the server-side call
    const postResult = await caller.post.byId({ id: postId });

    res.status(200).json({ data: { postTitle: postResult.title } });
  } catch (cause) {
    // If this a tRPC error, we can extract additional information.
    if (cause instanceof TRPCError) {
      // We can get the specific HTTP status code coming from tRPC (e.g. 404 for `NOT_FOUND`).
      const httpStatusCode = getHTTPStatusCodeFromError(cause);

      res.status(httpStatusCode).json({ error: { message: cause.message } });
      return;
    }

    // This is not a tRPC error, so we don't have specific information.
    res.status(500).json({
      error: { message: `Error while accessing post with ID ${postId}` },
    });
  }
};

----------------------------------------

TITLE: Creating Next.js tRPC Prisma Starter with create-next-app
DESCRIPTION: This command uses create-next-app to set up a Next.js project with tRPC and Prisma integration. It clones the example from the tRPC GitHub repository.

LANGUAGE: bash
CODE:
yarn create next-app --example https://github.com/trpc/trpc --example-path examples/next-prisma-starter trpc-prisma-starter

----------------------------------------

TITLE: Creating tRPC Router in TypeScript
DESCRIPTION: Example of creating a tRPC router with query and mutation procedures using Zod for input validation. This router defines endpoints for getting and creating users.

LANGUAGE: typescript
CODE:
import { initTRPC } from '@trpc/server';
import { z } from 'zod';

type User = {
  id: string;
  name: string;
  bio?: string;
};

const users: Record<string, User> = {};

export const t = initTRPC.create();

export const appRouter = t.router({
  getUserById: t.procedure.input(z.string()).query((opts) => {
    return users[opts.input]; // input type is string
  }),
  createUser: t.procedure
    .input(
      z.object({
        name: z.string().min(3),
        bio: z.string().max(142).optional(),
      }),
    )
    .mutation((opts) => {
      const id = Date.now().toString();
      const user: User = { id, ...opts.input };
      users[user.id] = user;
      return user;
    }),
});

// export type definition of API
export type AppRouter = typeof appRouter;

----------------------------------------

TITLE: Using Middleware with router.createCaller() in TypeScript
DESCRIPTION: This example shows how to create a router with a protected procedure using middleware, and demonstrates both failing and successful server-side calls using router.createCaller().

LANGUAGE: typescript
CODE:
import { initTRPC, TRPCError } from '@trpc/server';

type Context = {
  user?: {
    id: string;
  };
};
const t = initTRPC.context<Context>().create();

const protectedProcedure = t.procedure.use((opts) => {
  const { ctx } = opts;
  if (!ctx.user) {
    throw new TRPCError({
      code: 'UNAUTHORIZED',
      message: 'You are not authorized',
    });
  }

  return opts.next({
    ctx: {
      // Infers that the `user` is non-nullable
      user: ctx.user,
    },
  });
});

const router = t.router({
  secret: protectedProcedure.query((opts) => opts.ctx.user),
});

{
  // ❌ this will return an error because there isn't the right context param
  const caller = router.createCaller({});

  const result = await caller.secret();
}

{
  // ✅ this will work because user property is present inside context param
  const authorizedCaller = router.createCaller({
    user: {
      id: 'KATT',
    },
  });
  const result = await authorizedCaller.secret();
}

----------------------------------------

TITLE: Basic tRPC useQueries Implementation
DESCRIPTION: Demonstrates how to use the useQueries hook to fetch multiple posts by their IDs. This example shows the basic usage pattern where an array of post IDs is mapped to individual queries.

LANGUAGE: tsx
CODE:
const Component = (props: { postIds: string[] }) => {
  const postQueries = trpc.useQueries((t) =>
    props.postIds.map((id) => t.post.byId({ id })),
  );

  return <>{/* [...] */}</>;
};

----------------------------------------

TITLE: Creating a Reusable API Procedure with Context Checking in tRPC (TypeScript)
DESCRIPTION: Shows how to create a reusable API procedure that checks for the presence of req and res in the context. This procedure can be used to ensure that these properties are available in API calls.

LANGUAGE: typescript
CODE:
export const apiProcedure = publicProcedure.use((opts) => {
  if (!opts.ctx.req || !opts.ctx.res) {
    throw new Error('You are missing `req` or `res` in your call.');
  }
  return opts.next({
    ctx: {
      req: opts.ctx.req,
      res: opts.ctx.res,
    },
  });
});

----------------------------------------

TITLE: Using Context in Server-Side Call with tRPC (TypeScript)
DESCRIPTION: Demonstrates how to use context in a server-side call with tRPC. The createContext function is called to create the context for the caller.

LANGUAGE: typescript
CODE:
import { createContext } from './context';
import { createCaller } from './router';

const caller = createCaller(await createContext());

----------------------------------------

TITLE: Implementing loggerLink in tRPC Client Configuration (TypeScript)
DESCRIPTION: This snippet demonstrates how to import and add the loggerLink to the links array in a tRPC client configuration. It includes an example of conditional logging based on the environment and error conditions.

LANGUAGE: typescript
CODE:
import { createTRPCProxyClient, httpBatchLink, loggerLink } from '@trpc/client';
import type { AppRouter } from '../server';

const client = createTRPCProxyClient<AppRouter>({
  links: [
    /**
     * The function passed to enabled is an example in case you want to the link to
     * log to your console in development and only log errors in production
     */
    loggerLink({
      enabled: (opts) =>
        (process.env.NODE_ENV === 'development' &&
          typeof window !== 'undefined') ||
        (opts.direction === 'down' && opts.result instanceof Error),
    }),
    httpBatchLink({
      url: 'http://localhost:3000',
    }),
  ],
});

----------------------------------------

TITLE: Creating Context for Server-Side Helpers in tRPC (TypeScript)
DESCRIPTION: Shows how to create and use context with server-side helpers in tRPC. The createContext function is called to provide context for the createServerSideHelpers function.

LANGUAGE: typescript
CODE:
import { createServerSideHelpers } from '@trpc/react-query/server';
import { createContext } from './context';
import { appRouter } from './router';

const helpers = createServerSideHelpers({
  router: appRouter,
  ctx: await createContext(),
});

----------------------------------------

TITLE: WebSocket Context Creation with Authentication
DESCRIPTION: Implementation of context creation for WebSocket connections with authentication support

LANGUAGE: typescript
CODE:
import type { CreateWSSContextFnOptions } from '@trpc/server/adapters/ws';

export const createContext = async (opts: CreateWSSContextFnOptions) => {
  const token = opts.info.connectionParams?.token;

  return {};
};

export type Context = Awaited<ReturnType<typeof createContext>>;

----------------------------------------

TITLE: Basic Server-Side Caller Implementation in TypeScript
DESCRIPTION: Demonstrates setting up a basic tRPC router with post management functionality and using createCallerFactory to make server-side calls. Shows how to create a caller with context and execute queries and mutations.

LANGUAGE: typescript
CODE:
import { initTRPC } from '@trpc/server';
import { z } from 'zod';

type Context = {
  foo: string;
};

const t = initTRPC.context<Context>().create();

const publicProcedure = t.procedure;
const { createCallerFactory, router } = t;

interface Post {
  id: string;
  title: string;
}
const posts: Post[] = [
  {
    id: '1',
    title: 'Hello world',
  },
];
const appRouter = router({
  post: router({
    add: publicProcedure
      .input(
        z.object({
          title: z.string().min(2),
        }),
      )
      .mutation((opts) => {
        const post: Post = {
          ...opts.input,
          id: `${Math.random()}`,
        };
        posts.push(post);
        return post;
      }),
    list: publicProcedure.query(() => posts),
  }),
});

const createCaller = createCallerFactory(appRouter);

const caller = createCaller({
  foo: 'bar',
});

const addedPost = await caller.post.add({
  title: 'How to make server-side call in tRPC',
});

const postList = await caller.post.list();

----------------------------------------

TITLE: Configuring tRPC for SolidStart in TypeScript
DESCRIPTION: Sets up a tRPC endpoint for SolidStart using the fetch adapter. This configuration allows SolidStart to handle both GET and POST tRPC requests using the defined router and context.

LANGUAGE: typescript
CODE:
import { fetchRequestHandler } from '@trpc/server/adapters/fetch';
import type { APIEvent } from 'solid-start';
import { createContext } from '../../server/context';
import { appRouter } from '../../server/router';

const handler = (event: APIEvent) =>
  fetchRequestHandler({
    endpoint: '/api/trpc',
    req: event.request,
    router: appRouter,
    createContext,
  });
export { handler as GET, handler as POST };

----------------------------------------

TITLE: Configuring CORS for Standalone tRPC Server in TypeScript
DESCRIPTION: This snippet demonstrates how to add CORS support to a standalone tRPC server using the cors package. It shows how to configure the server to allow CORS for all origins, which is useful for development but should be configured more strictly in production.

LANGUAGE: typescript
CODE:
import { initTRPC } from '@trpc/server';
import { createHTTPServer } from '@trpc/server/adapters/standalone';
import cors from 'cors';

createHTTPServer({
  middleware: cors(),
  router: appRouter,
  createContext() {
    console.log('context 3');
    return {};
  },
}).listen(3333);

----------------------------------------

TITLE: Implementing SuperJSON in tRPC Client
DESCRIPTION: Configuration of SuperJSON transformer in tRPC client setup using createTRPCProxyClient.

LANGUAGE: typescript
CODE:
import { createTRPCProxyClient } from '@trpc/client';
import type { AppRouter } from '~/server/routers/_app';
import superjson from 'superjson';

export const client = createTRPCProxyClient<AppRouter>({
  transformer: superjson,
  // [...]
});

----------------------------------------

TITLE: Dynamically Loading tRPC Routers
DESCRIPTION: Illustrates how to implement lazy loading of routers using experimental_lazy function. Shows two approaches: direct import for single exports and specified import for multiple exports.

LANGUAGE: typescript
CODE:
import { experimental_lazy } from '@trpc/server';
import { router } from '../trpc';

export const appRouter = router({
  // Option 1: Short-hand lazy load the greeting router if you have exactly 1 export and it is the router
  greeting: experimental_lazy(() => import('./greeting.js')),
  // Option 2: Alternative way to lazy load if you have more than 1 export
  user: experimental_lazy(() => import('./user.js').then((m) => m.userRouter)),
});
export type AppRouter = typeof appRouter;

----------------------------------------

TITLE: Integration Testing with tRPC Caller
DESCRIPTION: Shows how to use the caller in integration tests to verify router functionality. Demonstrates testing post creation and retrieval.

LANGUAGE: typescript
CODE:
import { inferProcedureInput } from '@trpc/server';
import { createContextInner } from '../context';
import { AppRouter, createCaller } from './_app';

test('add and get post', async () => {
  const ctx = await createContextInner({});
  const caller = createCaller(ctx);

  const input: inferProcedureInput<AppRouter['post']['add']> = {
    text: 'hello test',
    title: 'hello test',
  };

  const post = await caller.post.add(input);
  const byId = await caller.post.byId({ id: post.id });

  expect(byId).toMatchObject(input);
});

----------------------------------------

TITLE: Disabling Request Batching on Next.js tRPC Server (TypeScript)
DESCRIPTION: This snippet shows how to disable request batching on a Next.js tRPC server by configuring the createNextApiHandler.

LANGUAGE: typescript
CODE:
export default trpcNext.createNextApiHandler({
  // [...]
  // 👇 disable batching
  batching: {
    enabled: false,
  },
});

----------------------------------------

TITLE: Configuring SuperJSON Transformer in tRPC Client
DESCRIPTION: Adding SuperJSON transformer to the tRPC client creation. This ensures consistent data transformation on both server and client sides.

LANGUAGE: typescript
CODE:
import { createTRPCClient } from '@trpc/client';
import type { AppRouter } from '~/server/routers/_app';
import superjson from 'superjson';

export const client = createTRPCClient<AppRouter>({
  links: [
    httpLink({
      url: 'http://localhost:3000',
      // transformer: superjson
    }),
  ],
});

----------------------------------------

TITLE: Implementing Admin Authorization Middleware in tRPC
DESCRIPTION: This snippet demonstrates how to create an admin-only procedure using tRPC middleware. It checks if the user is an admin before allowing access to the procedure.

LANGUAGE: typescript
CODE:
import { TRPCError, initTRPC } from '@trpc/server';

interface Context {
  user?: {
    id: string;
    isAdmin: boolean;
    // [..]
  };
}

const t = initTRPC.context<Context>().create();
export const publicProcedure = t.procedure;
export const router = t.router;

export const adminProcedure = publicProcedure.use(async (opts) => {
  const { ctx } = opts;
  if (!ctx.user?.isAdmin) {
    throw new TRPCError({ code: 'UNAUTHORIZED' });
  }
  return opts.next({
    ctx: {
      user: ctx.user,
    },
  });
});

----------------------------------------

TITLE: Installing tRPC Server Dependencies
DESCRIPTION: Command to install the required tRPC server package using yarn.

LANGUAGE: bash
CODE:
yarn add @trpc/server

----------------------------------------

TITLE: Protected Procedure with Context Middleware
DESCRIPTION: Demonstrates implementing protected procedures using middleware to check authentication context. Includes examples of both authorized and unauthorized calls.

LANGUAGE: typescript
CODE:
import { initTRPC, TRPCError } from '@trpc/server';

type Context = {
  user?: {
    id: string;
  };
};
const t = initTRPC.context<Context>().create();

const protectedProcedure = t.procedure.use((opts) => {
  const { ctx } = opts;
  if (!ctx.user) {
    throw new TRPCError({
      code: 'UNAUTHORIZED',
      message: 'You are not authorized',
    });
  }

  return opts.next({
    ctx: {
      user: ctx.user,
    },
  });
});

const router = t.router({
  secret: protectedProcedure.query((opts) => opts.ctx.user),
});

// ❌ Unauthorized call
const caller = router.createCaller({});

// ✅ Authorized call
const authorizedCaller = router.createCaller({
  user: {
    id: 'KATT',
  },
});

----------------------------------------

TITLE: Disabling Request Batching on tRPC Server (TypeScript)
DESCRIPTION: This code demonstrates how to disable request batching on the tRPC server side using the createHTTPServer function.

LANGUAGE: typescript
CODE:
import { createHTTPServer } from '@trpc/server/adapters/standalone';

createHTTPServer({
  // [...]
  // 👇 disable batching
  batching: {
    enabled: false,
  },
});

----------------------------------------

TITLE: Disabling Request Batching on tRPC Server (TypeScript)
DESCRIPTION: This code demonstrates how to disable request batching on the tRPC server side using the createHTTPServer function.

LANGUAGE: typescript
CODE:
import { createHTTPServer } from '@trpc/server/adapters/standalone';

createHTTPServer({
  // [...]
  // 👇 disable batching
  batching: {
    enabled: false,
  },
});

----------------------------------------

TITLE: Disabling Request Batching on tRPC Server (TypeScript)
DESCRIPTION: This code demonstrates how to disable request batching on the tRPC server side using the createHTTPServer function.

LANGUAGE: typescript
CODE:
import { createHTTPServer } from '@trpc/server/adapters/standalone';

createHTTPServer({
  // [...]
  // 👇 disable batching
  batching: {
    enabled: false,
  },
});

----------------------------------------

TITLE: Using Batch Queries with Promise.all
DESCRIPTION: Example of batching multiple queries into a single HTTP request using Promise.all. This approach combines multiple post queries into one network request and database query for better performance.

LANGUAGE: typescript
CODE:
const somePosts = await Promise.all([
  trpc.post.byId.query(1),
  trpc.post.byId.query(2),
  trpc.post.byId.query(3),
]);

----------------------------------------

TITLE: Installing tRPC Dependencies for Next.js
DESCRIPTION: Command to install necessary tRPC dependencies for a Next.js project using npm. This includes server, client, react-query integration, Next.js integration, and Zod for validation.

LANGUAGE: bash
CODE:
npm install @trpc/server @trpc/client @trpc/react-query @trpc/next @tanstack/react-query@4 zod

----------------------------------------

TITLE: Error Handling with Custom Handler
DESCRIPTION: Shows how to implement custom error handling for server-side calls using onError option. Demonstrates error logging and custom error response handling.

LANGUAGE: typescript
CODE:
import { initTRPC } from '@trpc/server';
import { z } from 'zod';

const t = initTRPC
  .context<{
    foo?: 'bar';
  }>()
  .create();

const router = t.router({
  greeting: t.procedure.input(z.object({ name: z.string() })).query((opts) => {
    if (opts.input.name === 'invalid') {
      throw new Error('Invalid name');
    }

    return `Hello ${opts.input.name}`;
  }),
});

const caller = router.createCaller(
  {
    /* context */
  },
  {
    onError: (opts) => {
      console.error('An error occurred:', opts.error);
    },
  },
);

----------------------------------------

TITLE: Implementing Server-Side Helpers in Next.js getServerSideProps
DESCRIPTION: This example demonstrates how to use server-side helpers in a Next.js page component. It shows prefetching a query, dehydrating the state, and using the prefetched data in the component.

LANGUAGE: typescript
CODE:
import { createServerSideHelpers } from '@trpc/react-query/server';
import { GetServerSidePropsContext, InferGetServerSidePropsType } from 'next';
import { appRouter } from 'server/routers/_app';
import superjson from 'superjson';
import { trpc } from 'utils/trpc';

export async function getServerSideProps(
  context: GetServerSidePropsContext<{ id: string }>,
) {
  const helpers = createServerSideHelpers({
    router: appRouter,
    ctx: {},
    transformer: superjson,
  });
  const id = context.params?.id as string;

  /*
   * Prefetching the `post.byId` query.
   * `prefetch` does not return the result and never throws - if you need that behavior, use `fetch` instead.
   */
  await helpers.post.byId.prefetch({ id });

  // Make sure to return { props: { trpcState: helpers.dehydrate() } }
  return {
    props: {
      trpcState: helpers.dehydrate(),
      id,
    },
  };
}

export default function PostViewPage(
  props: InferGetServerSidePropsType<typeof getServerSideProps>,
) {
  const { id } = props;
  const postQuery = trpc.post.byId.useQuery({ id });
  if (postQuery.status !== 'success') {
    // won't happen since the query has been prefetched
    return <>Loading...</>;
  }
  const { data } = postQuery;
  return (
    <>
      <h1>{data.title}</h1>
      <em>Created {data.createdAt.toLocaleDateString()}</em>
      <p>{data.text}</p>
      <h2>Raw data:</h2>
      <pre>{JSON.stringify(data, null, 4)}</pre>
    </>
  );
}

----------------------------------------

TITLE: Configuring TRPCClient for WebSocket Transport
DESCRIPTION: Demonstrates how to configure the TRPCClient to use WebSocket transport for all operations. It creates a persistent WebSocket connection and uses the wsLink.

LANGUAGE: typescript
CODE:
import { createTRPCProxyClient, createWSClient, wsLink } from '@trpc/client';
import type { AppRouter } from '../path/to/server/trpc';

// create persistent WebSocket connection
const wsClient = createWSClient({
  url: `ws://localhost:3001`,
});

// configure TRPCClient to use WebSockets transport
const client = createTRPCProxyClient<AppRouter>({
  links: [
    wsLink({
      client: wsClient,
    }),
  ],
});

----------------------------------------

TITLE: Defining tRPC Context Type with Next.js Integration
DESCRIPTION: Demonstrates how to define and type a tRPC context using Next.js authentication, showing context type definition and procedure usage.

LANGUAGE: typescript
CODE:
import * as trpc from '@trpc/server';
import { initTRPC } from '@trpc/server';
import type { CreateNextContextOptions } from '@trpc/server/adapters/next';
import { getSession } from 'next-auth/react';

export const createContext = async (opts: CreateNextContextOptions) => {
  const session = await getSession({ req: opts.req });

  return {
    session,
  };
};

export type Context = Awaited<ReturnType<typeof createContext>>;
const t = initTRPC.context<Context>().create();

t.procedure.use((opts) => {
  opts.ctx;

  return opts.next();
});

----------------------------------------

TITLE: Implementing Streaming Mode with unstable_httpBatchStreamLink
DESCRIPTION: Advanced implementation using unstable_httpBatchStreamLink for streaming responses. This setup enables immediate response streaming as data becomes available, rather than waiting for all requests to complete.

LANGUAGE: typescript
CODE:
import {
  createTRPCProxyClient,
  unstable_httpBatchStreamLink,
} from '@trpc/client';
import type { AppRouter } from '../server';

const client = createTRPCProxyClient<AppRouter>({
  links: [
    unstable_httpBatchStreamLink({
      url: 'http://localhost:3000',
    }),
  ],
});

----------------------------------------

TITLE: Using router.createCaller() for Mutation in TypeScript
DESCRIPTION: This snippet demonstrates creating a router with a mutation procedure and using router.createCaller() to make a server-side call to add a post.

LANGUAGE: typescript
CODE:
import { initTRPC } from '@trpc/server';
import { z } from 'zod';

const posts = ['One', 'Two', 'Three'];

const t = initTRPC.create();
const router = t.router({
  post: t.router({
    add: t.procedure.input(z.string()).mutation((opts) => {
      posts.push(opts.input);
      return posts;
    }),
  }),
});

const caller = router.createCaller({});
const result = await caller.post.add('Four');

----------------------------------------

TITLE: Implementing Inner and Outer Context in tRPC (TypeScript)
DESCRIPTION: Demonstrates the implementation of inner and outer context in tRPC. Inner context is used for database connections and testing, while outer context is used for request-dependent data like user sessions.

LANGUAGE: typescript
CODE:
import type { CreateNextContextOptions } from '@trpc/server/adapters/next';
import { getSessionFromCookie, type Session } from './auth';

interface CreateInnerContextOptions extends Partial<CreateNextContextOptions> {
  session: Session | null;
}

export async function createContextInner(opts?: CreateInnerContextOptions) {
  return {
    prisma,
    session: opts.session,
  };
}

export async function createContext(opts: CreateNextContextOptions) {
  const session = getSessionFromCookie(opts.req);

  const contextInner = await createContextInner({ session });

  return {
    ...contextInner,
    req: opts.req,
    res: opts.res,
  };
}

export type Context = Awaited<ReturnType<typeof createContextInner>>;

----------------------------------------

TITLE: Creating Query Client Factory for tRPC
DESCRIPTION: Exports a function to create a QueryClient instance with custom configuration for dehydration and hydration.

LANGUAGE: typescript
CODE:
import {
  defaultShouldDehydrateQuery,
  QueryClient,
} from '@tanstack/react-query';
import superjson from 'superjson';

export function makeQueryClient() {
  return new QueryClient({
    defaultOptions: {
      queries: {
        staleTime: 30 * 1000,
      },
      dehydrate: {
        shouldDehydrateQuery: (query) =>
          defaultShouldDehydrateQuery(query) ||
          query.state.status === 'pending',
      },
    },
  });
}

----------------------------------------

TITLE: Configuring tRPC Server with API Response Caching
DESCRIPTION: Server-side implementation of tRPC with API response caching. Includes context creation, router setup with a cached slow query example, and response metadata configuration for public routes.

LANGUAGE: typescript
CODE:
import { initTRPC } from '@trpc/server';
import * as trpcNext from '@trpc/server/adapters/next';

export const createContext = async ({
  req,
  res,
}: trpcNext.CreateNextContextOptions) => {
  return {
    req,
    res,
    prisma,
  };
};

type Context = Awaited<ReturnType<typeof createContext>>;

export const t = initTRPC.context<Context>().create();

const waitFor = async (ms: number) =>
  new Promise((resolve) => setTimeout(resolve, ms));

export const appRouter = t.router({
  public: t.router({
    slowQueryCached: t.procedure.query(async (opts) => {
      await waitFor(5000); // wait for 5s

      return {
        lastUpdated: new Date().toJSON(),
      };
    }),
  }),
});

export type AppRouter = typeof appRouter;

export default trpcNext.createNextApiHandler({
  router: appRouter,
  createContext,
  responseMeta(opts) {
    const { ctx, paths, errors, type } = opts;
    const allPublic = paths && paths.every((path) => path.includes('public'));
    const allOk = errors.length === 0;
    const isQuery = type === 'query';

    if (ctx?.res && allPublic && allOk && isQuery) {
      const ONE_DAY_IN_SECONDS = 60 * 60 * 24;
      return {
        headers: new Headers([
          [
            'cache-control',
            `s-maxage=1, stale-while-revalidate=${ONE_DAY_IN_SECONDS}`,
          ],
        ]),
      };
    }
    return {};
  },
});

----------------------------------------

TITLE: Defining TRPCSubscriptionResult Type in TypeScript
DESCRIPTION: This snippet defines the TypeScript type for the return value of the useSubscription hook. It includes properties for subscription status, data, error handling, and a reset function.

LANGUAGE: typescript
CODE:
type TRPCSubscriptionResult<TOutput, TError> = {
  /**
   * The current status of the subscription.
   * Will be one of: `'idle'`, `'connecting'`, `'pending'`, or `'error'`.
   *
   * - `idle`: subscription is disabled or ended
   * - `connecting`: trying to establish a connection
   * - `pending`: connected to the server, receiving data
   * - `error`: an error occurred and the subscription is stopped
   */
  status: 'idle' | 'connecting' | 'pending' | 'error';
  /**
   * The last data received from the subscription.
   */
  data: TOutput | undefined;
  /**
   * The last error received - will be `null` whenever the status is `'pending'` or `'idle'`
   * - has a value only when the status is `'error'`
   * - *may* have a value when the status is `'connecting'`
   */
  error: TRPCClientError | null;
  /**
   * Function to reset the subscription.
   */
  reset: () => void;
};

----------------------------------------

TITLE: Configuring tRPC Server with API Response Caching
DESCRIPTION: Server-side implementation of tRPC with API response caching. Includes context creation, router setup with a cached slow query example, and response metadata configuration for public routes.

LANGUAGE: typescript
CODE:
import { initTRPC } from '@trpc/server';
import * as trpcNext from '@trpc/server/adapters/next';

export const createContext = async ({
  req,
  res,
}: trpcNext.CreateNextContextOptions) => {
  return {
    req,
    res,
    prisma,
  };
};

type Context = Awaited<ReturnType<typeof createContext>>;

export const t = initTRPC.context<Context>().create();

const waitFor = async (ms: number) =>
  new Promise((resolve) => setTimeout(resolve, ms));

export const appRouter = t.router({
  public: t.router({
    slowQueryCached: t.procedure.query(async (opts) => {
      await waitFor(5000); // wait for 5s

      return {
        lastUpdated: new Date().toJSON(),
      };
    }),
  }),
});

export type AppRouter = typeof appRouter;

export default trpcNext.createNextApiHandler({
  router: appRouter,
  createContext,
  responseMeta(opts) {
    const { ctx, paths, errors, type } = opts;
    const allPublic = paths && paths.every((path) => path.includes('public'));
    const allOk = errors.length === 0;
    const isQuery = type === 'query';

    if (ctx?.res && allPublic && allOk && isQuery) {
      const ONE_DAY_IN_SECONDS = 60 * 60 * 24;
      return {
        headers: new Headers([
          [
            'cache-control',
            `s-maxage=1, stale-while-revalidate=${ONE_DAY_IN_SECONDS}`,
          ],
        ]),
      };
    }
    return {};
  },
});

----------------------------------------

TITLE: Creating Custom Hook for Post Creation in TypeScript
DESCRIPTION: Implements a custom React hook for creating posts using inferred types from the tRPC router. It includes options for React Query and handles cache invalidation on successful post creation.

LANGUAGE: typescript
CODE:
import {
  trpc,
  type ReactQueryOptions,
  type RouterInputs,
  type RouterOutputs,
} from './trpc';

type PostCreateOptions = ReactQueryOptions['post']['create'];

function usePostCreate(options?: PostCreateOptions) {
  const utils = trpc.useUtils();

  return trpc.post.create.useMutation({
    ...options,
    onSuccess(post) {
      // invalidate all queries on the post router
      // when a new post is created
      utils.post.invalidate();
      options?.onSuccess?.(post);
    },
  });
}

----------------------------------------

TITLE: Creating Custom Hook for Post Creation in TypeScript
DESCRIPTION: Implements a custom React hook for creating posts using inferred types from the tRPC router. It includes options for React Query and handles cache invalidation on successful post creation.

LANGUAGE: typescript
CODE:
import {
  trpc,
  type ReactQueryOptions,
  type RouterInputs,
  type RouterOutputs,
} from './trpc';

type PostCreateOptions = ReactQueryOptions['post']['create'];

function usePostCreate(options?: PostCreateOptions) {
  const utils = trpc.useUtils();

  return trpc.post.create.useMutation({
    ...options,
    onSuccess(post) {
      // invalidate all queries on the post router
      // when a new post is created
      utils.post.invalidate();
      options?.onSuccess?.(post);
    },
  });
}

----------------------------------------

TITLE: Configuring Global Request Aborting in tRPC with Next.js
DESCRIPTION: This snippet shows how to globally configure tRPC to abort all requests on component unmount. It uses the createTRPCNext function and sets the abortOnUnmount option to true in the configuration callback.

LANGUAGE: typescript
CODE:
import { createTRPCNext } from '@trpc/next';

export const trpc = createTRPCNext<AppRouter>({
  config() {
    return {
      // ...
      abortOnUnmount: true,
    };
  },
});

----------------------------------------

TITLE: DataTransformer Interface Definition
DESCRIPTION: TypeScript interface definitions for data transformers, including input and output transformer specifications.

LANGUAGE: typescript
CODE:
export interface DataTransformer {
  serialize(object: any): any;
  deserialize(object: any): any;
}

interface InputDataTransformer extends DataTransformer {
  serialize(object: any): any;
  deserialize(object: any): any;
}

interface OutputDataTransformer extends DataTransformer {
  serialize(object: any): any;
  deserialize(object: any): any;
}

export interface CombinedDataTransformer {
  input: InputDataTransformer;
  output: OutputDataTransformer;
}

----------------------------------------

TITLE: WebSocket Link Interface Definitions
DESCRIPTION: Type definitions for WebSocket link options and client configuration, including URL, WebSocket implementation, retry delay, and lifecycle callbacks

LANGUAGE: typescript
CODE:
export interface WebSocketLinkOptions {
  client: TRPCWebSocketClient;
}

function createWSClient(opts: WebSocketClientOptions) => TRPCWebSocketClient

export interface WebSocketClientOptions {
  url: string;
  WebSocket?: typeof WebSocket;
  retryDelayMs?: typeof retryDelay;
  onOpen?: () => void;
  onClose?: (cause?: { code?: number }) => void;
}

----------------------------------------

TITLE: Input Merging with tRPC Middleware
DESCRIPTION: Shows how to stack multiple input validators using middleware to create more complex validation types. Includes a base procedure with town name validation that gets merged with additional input requirements.

LANGUAGE: typescript
CODE:
const baseProcedure = t.procedure
  .input(z.object({ townName: z.string() }))
  .use((opts) => {
    const input = opts.input;
    console.log(`Handling request with user from: ${input.townName}`);
    return opts.next();
  });

export const appRouter = t.router({
  hello: baseProcedure
    .input(
      z.object({
        name: z.string(),
      }),
    )
    .query((opts) => {
      const input = opts.input;
      return {
        greeting: `Hello ${input.name}, my friend from ${input.townName}`,
      };
    }),
});

----------------------------------------

TITLE: DataTransformer Interface Definition
DESCRIPTION: TypeScript interface definitions for data transformers, including input and output transformer specifications.

LANGUAGE: typescript
CODE:
export interface DataTransformer {
  serialize(object: any): any;
  deserialize(object: any): any;
}

interface InputDataTransformer extends DataTransformer {
  serialize(object: any): any;
  deserialize(object: any): any;
}

interface OutputDataTransformer extends DataTransformer {
  serialize(object: any): any;
  deserialize(object: any): any;
}

export interface CombinedDataTransformer {
  input: InputDataTransformer;
  output: OutputDataTransformer;
}

----------------------------------------

TITLE: Resolver-based Authorization in tRPC
DESCRIPTION: Shows how to implement authorization checks directly in tRPC resolvers. Includes examples of both public and protected routes with authorization checks in the resolver logic.

LANGUAGE: typescript
CODE:
import { initTRPC, TRPCError } from '@trpc/server';
import type { Context } from '../context';

export const t = initTRPC.context<Context>().create();

const appRouter = t.router({
  hello: t.procedure
    .input(z.string().nullish())
    .query((opts) => `hello ${opts.input ?? opts.ctx.user?.name ?? 'world'}`),
  secret: t.procedure.query((opts) => {
    if (!opts.ctx.user) {
      throw new TRPCError({ code: 'UNAUTHORIZED' });
    }
    return {
      secret: 'sauce',
    };
  }),
});

----------------------------------------

TITLE: Creating Custom Hook for Fetching Post by ID in TypeScript
DESCRIPTION: Implements a custom React hook for fetching a post by ID using inferred types from the tRPC router. It utilizes React Query options and router input types for type safety.

LANGUAGE: typescript
CODE:
import { ReactQueryOptions, RouterInputs, trpc } from './trpc';

type PostByIdOptions = ReactQueryOptions['post']['byId'];
type PostByIdInput = RouterInputs['post']['byId'];

function usePostById(input: PostByIdInput, options?: PostByIdOptions) {
  return trpc.post.byId.useQuery(input, options);
}

----------------------------------------

TITLE: Initializing WebSocket Client with tRPC
DESCRIPTION: Demonstrates how to create a tRPC client using WebSocket connection by initializing a WebSocket client and configuring it with wsLink

LANGUAGE: typescript
CODE:
import { createTRPCProxyClient, createWSClient, wsLink } from '@trpc/client';
import type { AppRouter } from '../server';

const wsClient = createWSClient({
  url: 'ws://localhost:3000',
});

const trpcClient = createTRPCProxyClient<AppRouter>({
  links: [wsLink<AppRouter>({ client: wsClient })],
});

----------------------------------------

TITLE: Creating and Using a Caller with createCallerFactory in TypeScript
DESCRIPTION: This snippet demonstrates how to create a caller using createCallerFactory, define a router with procedures, and make server-side calls to add and list posts.

LANGUAGE: typescript
CODE:
import { initTRPC } from '@trpc/server';
import { z } from 'zod';

type Context = {
  foo: string;
};

const t = initTRPC.context<Context>().create();

const publicProcedure = t.procedure;
const { createCallerFactory, router } = t;

interface Post {
  id: string;
  title: string;
}
const posts: Post[] = [
  {
    id: '1',
    title: 'Hello world',
  },
];
const appRouter = router({
  post: router({
    add: publicProcedure
      .input(
        z.object({
          title: z.string().min(2),
        }),
      )
      .mutation((opts) => {
        const post: Post = {
          ...opts.input,
          id: `${Math.random()}`,
        };
        posts.push(post);
        return post;
      }),
    list: publicProcedure.query(() => posts),
  }),
});

// 1. create a caller-function for your router
const createCaller = createCallerFactory(appRouter);

// 2. create a caller using your `Context`
const caller = createCaller({
  foo: 'bar',
});

// 3. use the caller to add and list posts
const addedPost = await caller.post.add({
  title: 'How to make server-side call in tRPC',
});

const postList = await caller.post.list();

----------------------------------------

TITLE: Configuring tRPC Client for Cross-Origin Cookie Transmission in TypeScript
DESCRIPTION: This code snippet demonstrates how to create a tRPC client that sends cookies cross-origin. It uses the httpBatchLink and modifies the fetch options to include credentials. This setup is necessary when the API is on a different origin than the front-end.

LANGUAGE: typescript
CODE:
import { createTRPCClient, httpBatchLink } from '@trpc/client';

const client = createTRPCClient<AppRouter>({
  links: [
    httpBatchLink({
      url: 'YOUR_SERVER_URL',
      fetch(url, options) {
        return fetch(url, {
          ...options,
          credentials: 'include',
        });
      },
    }),
  ],
});

----------------------------------------

TITLE: Configuring tRPC Client for Cross-Origin Cookie Transmission in TypeScript
DESCRIPTION: This code snippet demonstrates how to create a tRPC client that sends cookies cross-origin. It uses the httpBatchLink and modifies the fetch options to include credentials. This setup is necessary when the API is on a different origin than the front-end.

LANGUAGE: typescript
CODE:
import { createTRPCClient, httpBatchLink } from '@trpc/client';

const client = createTRPCClient<AppRouter>({
  links: [
    httpBatchLink({
      url: 'YOUR_SERVER_URL',
      fetch(url, options) {
        return fetch(url, {
          ...options,
          credentials: 'include',
        });
      },
    }),
  ],
});

----------------------------------------

TITLE: Implementing Basic tRPC Subscription in TypeScript
DESCRIPTION: This snippet demonstrates how to create a basic tRPC subscription using an EventEmitter. It sets up a procedure that yields new posts as they are added.

LANGUAGE: typescript
CODE:
import { initTRPC } from '@trpc/server';

const t = initTRPC.create();

const ee = new EventEmitter();

export const appRouter = router({
  onPostAdd: publicProcedure.subscription(async function* (opts) {
    // listen for new events
    for await (const [data] of on(ee, 'add', {
      // Passing the AbortSignal from the request automatically cancels the event emitter when the request is aborted
      signal: opts.signal,
    })) {
      const post = data as Post;
      yield post;
    }
  }),
});

----------------------------------------

TITLE: tRPC Error Formatter Interface Definition
DESCRIPTION: Defines the structure of the error formatter function parameters and the default error shape in tRPC. Shows all available properties passed to the errorFormatter function.

LANGUAGE: typescript
CODE:
{
  error: TRPCError;
  type: ProcedureType | 'unknown';
  path: string | undefined;
  input: unknown;
  ctx: undefined | TContext;
  shape: DefaultErrorShape; // the default error shape
}

----------------------------------------

TITLE: Creating Abstract Types for Router Factory in TypeScript
DESCRIPTION: Demonstrates how to create abstract types for a router factory, enabling the creation of reusable React components that can work with different router instances. It uses types from '@trpc/react-query/shared'.

LANGUAGE: typescript
CODE:
import { t, publicProcedure } from './trpc';

import { RouterLike, UtilsLike } from '@trpc/react-query/shared';

export function createMyRouter() {
  return t.router({
    createThing: publicProcedure
      .input(ThingRequest)
      .output(Thing)
      .mutation(/* do work */),
    listThings: publicProcedure
      .input(ThingQuery)
      .output(ThingArray)
      .query(/* do work */),
  })
}

type MyRouterType = ReturnType<typeof createMyRouter>
export MyRouterLike = RouterLike<MyRouterType>
export MyRouterUtilsLike = UtilsLike<MyRouterType>

----------------------------------------

TITLE: Creating Custom HTTP Server with tRPC Handler in TypeScript
DESCRIPTION: This snippet demonstrates how to create a custom HTTP server using Node.js http module and integrate it with a tRPC handler created by createHTTPHandler function.

LANGUAGE: typescript
CODE:
import { createServer } from 'http';
import { initTRPC } from '@trpc/server';
import { createHTTPHandler } from '@trpc/server/adapters/standalone';

const handler = createHTTPHandler({
  router: appRouter,
  createContext() {
    return {};
  },
});

createServer((req, res) => {
  /**
   * Handle the request however you like,
   * just call the tRPC handler when you're ready
   */

  handler(req, res);
}).listen(3001);

----------------------------------------

TITLE: Creating Abstract Types for Router Factory in TypeScript
DESCRIPTION: Demonstrates how to create abstract types for a router factory, enabling the creation of reusable React components that can work with different router instances. It uses types from '@trpc/react-query/shared'.

LANGUAGE: typescript
CODE:
import { t, publicProcedure } from './trpc';

import { RouterLike, UtilsLike } from '@trpc/react-query/shared';

export function createMyRouter() {
  return t.router({
    createThing: publicProcedure
      .input(ThingRequest)
      .output(Thing)
      .mutation(/* do work */),
    listThings: publicProcedure
      .input(ThingQuery)
      .output(ThingArray)
      .query(/* do work */),
  })
}

type MyRouterType = ReturnType<typeof createMyRouter>
export MyRouterLike = RouterLike<MyRouterType>
export MyRouterUtilsLike = UtilsLike<MyRouterType>

----------------------------------------

TITLE: Configuring tRPC Query Options per Query
DESCRIPTION: Example showing how to configure individual tRPC query options to disable automatic refetching on mount and window focus. This is useful for static data that doesn't need to be refreshed on the client side.

LANGUAGE: tsx
CODE:
const data = trpc.example.useQuery(
  undefined,
  { refetchOnMount: false, refetchOnWindowFocus: false },
);

----------------------------------------

TITLE: Error Formatter Properties Interface
DESCRIPTION: Defines the structure of properties passed to the errorFormatter function in tRPC, following JSON-RPC 2.0 specification.

LANGUAGE: typescript
CODE:
{
  error: TRPCError;
  type: ProcedureType | 'unknown';
  path: string | undefined;
  input: unknown;
  ctx: undefined | TContext;
  shape: DefaultErrorShape; // the default error shape
}

----------------------------------------

TITLE: Creating Context from Request Headers in tRPC
DESCRIPTION: Demonstrates how to create a context function that extracts and verifies JWT tokens from request headers. The context is created for each incoming request and makes user information available to all resolvers.

LANGUAGE: typescript
CODE:
import * as trpcNext from '@trpc/server/adapters/next';
import { decodeAndVerifyJwtToken } from './somewhere/in/your/app/utils';

export async function createContext({
  req,
  res,
}: trpcNext.CreateNextContextOptions) {
  async function getUserFromHeader() {
    if (req.headers.authorization) {
      const user = await decodeAndVerifyJwtToken(
        req.headers.authorization.split(' ')[1],
      );
      return user;
    }
    return null;
  }
  const user = await getUserFromHeader();

  return {
    user,
  };
}
export type Context = Awaited<ReturnType<typeof createContext>>;

----------------------------------------

TITLE: Creating Context from Request Headers in tRPC
DESCRIPTION: Demonstrates how to create a context function that extracts and verifies JWT tokens from request headers. The context is created for each incoming request and makes user information available to all resolvers.

LANGUAGE: typescript
CODE:
import * as trpcNext from '@trpc/server/adapters/next';
import { decodeAndVerifyJwtToken } from './somewhere/in/your/app/utils';

export async function createContext({
  req,
  res,
}: trpcNext.CreateNextContextOptions) {
  async function getUserFromHeader() {
    if (req.headers.authorization) {
      const user = await decodeAndVerifyJwtToken(
        req.headers.authorization.split(' ')[1],
      );
      return user;
    }
    return null;
  }
  const user = await getUserFromHeader();

  return {
    user,
  };
}
export type Context = Awaited<ReturnType<typeof createContext>>;

----------------------------------------

TITLE: Configuring tRPC Client with Custom Headers in TypeScript
DESCRIPTION: This snippet demonstrates how to set up a tRPC client with custom headers using httpBatchLink. It includes a function to dynamically set an authorization token and configure headers for each request.

LANGUAGE: typescript
CODE:
// Import the router type from your server file
import type { AppRouter } from '@/server/routers/app';
import { httpBatchLink } from '@trpc/client';
import { createTRPCNext } from '@trpc/next';

let token: string;

export function setToken(newToken: string) {
  /**
   * You can also save the token to cookies, and initialize from
   * cookies above.
   */
  token = newToken;
}

export const trpc = createTRPCNext<AppRouter>({
  config(opts) {
    return {
      links: [
        httpBatchLink({
          url: 'http://localhost:3000/api/trpc',
          /**
           * Headers will be called on each request.
           */
          headers() {
            return {
              Authorization: token,
            };
          },
        }),
      ],
    };
  },
});

----------------------------------------

TITLE: Configuring tRPC for Remix in TypeScript
DESCRIPTION: Sets up a tRPC endpoint for Remix using the fetch adapter. This configuration allows Remix to handle both GET and POST tRPC requests using the defined router and context.

LANGUAGE: typescript
CODE:
import type { ActionFunctionArgs, LoaderFunctionArgs } from '@remix-run/node';
import { fetchRequestHandler } from '@trpc/server/adapters/fetch';
import { createContext } from '~/server/context';
import { appRouter } from '~/server/router';

export const loader = async (args: LoaderFunctionArgs) => {
  return handleRequest(args);
};
export const action = async (args: ActionFunctionArgs) => {
  return handleRequest(args);
};
function handleRequest(args: LoaderFunctionArgs | ActionFunctionArgs) {
  return fetchRequestHandler({
    endpoint: '/trpc',
    req: args.request,
    router: appRouter,
    createContext,
  });
}

----------------------------------------

TITLE: Using Abstract Router Types in React Components
DESCRIPTION: Shows how to use the abstract router types in React components, allowing for the creation of generic components that can work with different router instances. It demonstrates querying, mutation, and cache invalidation.

LANGUAGE: typescript
CODE:
import type { MyRouterLike, MyRouterUtilsLike, trpc, useUtils } from './trpc';

type MyGenericComponentProps = {
  route: MyRouterLike;
  utils: MyRouterUtilsLike;
};

function MyGenericComponent(props: MyGenericComponentProps) {
  const { route } = props;
  const thing = route.listThings.useQuery({
    filter: 'qwerty',
  });

  const mutation = route.doThing.useMutation({
    onSuccess() {
      props.utils.listThings.invalidate();
    },
  });

  function handleClick() {
    mutation.mutate({
      name: 'Thing 1',
    });
  }

  return; /* ui */
}

function MyPageComponent() {
  const utils = useUtils();

  return (
    <MyGenericComponent
      route={trpc.deep.route.things}
      utils={utils.deep.route.things}
    />
  );
}

function MyOtherPageComponent() {
  const utils = useUtils();

  return (
    <MyGenericComponent
      route={trpc.different.things}
      utils={utils.different.things}
    />
  );
}

----------------------------------------

TITLE: Configuring httpLink in tRPC TypeScript Client
DESCRIPTION: This snippet demonstrates how to import and configure the httpLink in a tRPC client. It shows setting up a client with the httpLink, specifying the server URL.

LANGUAGE: typescript
CODE:
import { createTRPCClient, httpLink } from '@trpc/client';
import type { AppRouter } from '../server';

const client = createTRPCClient<AppRouter>({
  links: [
    httpLink({
      url: 'http://localhost:3000',
      // transformer,
    }),
  ],
});

----------------------------------------

TITLE: Creating tRPC Context in TypeScript
DESCRIPTION: Sample code for creating a tRPC context that includes user information from request headers. This context is created for each request.

LANGUAGE: typescript
CODE:
import { FetchCreateContextFnOptions } from '@trpc/server/adapters/fetch';

export function createContext({
  req,
  resHeaders,
}: FetchCreateContextFnOptions) {
  const user = { name: req.headers.get('username') ?? 'anonymous' };
  return { req, resHeaders, user };
}

export type Context = Awaited<ReturnType<typeof createContext>>;

----------------------------------------

TITLE: Configuring tRPC with SSR and Response Caching in Next.js
DESCRIPTION: This snippet demonstrates how to configure tRPC in a Next.js application with SSR enabled and response caching. It sets up the tRPC client, enables SSR, and implements response metadata for caching.

LANGUAGE: tsx
CODE:
export default withTRPC({
  config({ ctx }) {
    if (typeof window !== 'undefined') {
      return {
        url: '/api/trpc',
      };
    }

    const url = process.env.VERCEL_URL
      ? `https://${process.env.VERCEL_URL}/api/trpc`
      : 'http://localhost:3000/api/trpc';

    return {
      url,
    };
  },
  ssr: true,
  responseMeta({ ctx, clientErrors }) {
    if (clientErrors.length) {
      // propagate http first error from API calls
      return {
        status: clientErrors[0].data?.httpStatus ?? 500,
      };
    }

    // cache request for 1 day + revalidate once every second
    const ONE_DAY_IN_SECONDS = 60 * 60 * 24;
    return {
      headers: {
        'cache-control': `s-maxage=1, stale-while-revalidate=${ONE_DAY_IN_SECONDS}`,
      },
    };
  },
})(MyApp);

----------------------------------------

TITLE: Defining getQueryKey Function Signatures for tRPC Queries and Routers
DESCRIPTION: TypeScript function signatures for getQueryKey, used with tRPC queries and routers. It includes overloads for different use cases and defines the QueryType enum.

LANGUAGE: typescript
CODE:
// Queries
function getQueryKey(
  procedure: AnyQueryProcedure,
  input?: DeepPartial<TInput>,
  type?: QueryType; /** @default 'any' */
): TRPCQueryKey;

// Routers
function getQueryKey(
  router: AnyRouter,
): TRPCQueryKey;

type QueryType = "query" | "infinite" | "any";
// for useQuery ──┘         │            │
// for useInfiniteQuery ────┘            │
// will match all ───────────────────────┘

----------------------------------------

TITLE: Throwing TRPCError in Server Procedure
DESCRIPTION: Demonstrates how to throw a custom TRPCError within a tRPC procedure on the server side.

LANGUAGE: typescript
CODE:
import { initTRPC, TRPCError } from '@trpc/server';

const t = initTRPC.create();

const appRouter = t.router({
  hello: t.procedure.query(() => {
    throw new TRPCError({
      code: 'INTERNAL_SERVER_ERROR',
      message: 'An unexpected error occurred, please try again later.',
      // optional: pass the original error to retain stack trace
      cause: theError,
    });
  }),
});

// [...]

----------------------------------------

TITLE: Creating tRPC Caller for Server Components
DESCRIPTION: Sets up a tRPC caller for use in server components, allowing for prefetching queries and direct router calls.

LANGUAGE: tsx
CODE:
import 'server-only';

import { createTRPCOptionsProxy } from '@trpc/tanstack-react-query';
import { cache } from 'react';
import { createTRPCContext } from './init';
import { makeQueryClient } from './query-client';
import { appRouter } from './routers/_app';

export const getQueryClient = cache(makeQueryClient);

export const trpc = createTRPCOptionsProxy({
  ctx: createTRPCContext,
  router: appRouter,
  queryClient: getQueryClient,
});

export const caller = appRouter.createCaller(createTRPCContext);

----------------------------------------

TITLE: Configuring Per-Request Abort on Unmount in tRPC with Next.js
DESCRIPTION: This snippet shows how to override the global abort behavior for a specific request. It uses the trpc.useQuery hook and sets the abortOnUnmount option to true in the trpc configuration object for that particular query.

LANGUAGE: typescript
CODE:
// @filename: pages/posts/[id].tsx
// @noErrors
import { trpc } from '~/utils/trpc';

const PostViewPage: NextPageWithLayout = () => {
  const id = useRouter().query.id as string;
  const postQuery = trpc.post.byId.useQuery({ id }, { trpc: { abortOnUnmount: true } });

  return (...)
}

----------------------------------------

TITLE: Starting the Next.js development server
DESCRIPTION: This command starts the Next.js development server for the project, allowing developers to work on and test the tRPC integration.

LANGUAGE: bash
CODE:
npm run dev        # starts next.js

----------------------------------------

TITLE: Implementing Per-Route Authentication with tRPC Metadata in TypeScript
DESCRIPTION: This example shows how to use tRPC metadata for per-route authentication settings. It defines a Meta interface, creates an authenticated procedure, and implements a router with both public and protected routes.

LANGUAGE: typescript
CODE:
import { initTRPC } from '@trpc/server';

// [...]

interface Meta {
  authRequired: boolean;
}

export const t = initTRPC.context<Context>().meta<Meta>().create();

export const authedProcedure = t.procedure.use(async (opts) => {
  const { meta, next, ctx } = opts;
  // only check authorization if enabled
  if (meta?.authRequired && !ctx.user) {
    throw new TRPCError({ code: 'UNAUTHORIZED' });
  }
  return next();
});

export const appRouter = t.router({
  hello: authedProcedure.meta({ authRequired: false }).query(() => {
    return {
      greeting: 'hello world',
    };
  }),
  protectedHello: authedProcedure.meta({ authRequired: true }).query(() => {
    return {
      greeting: 'hello-world',
    };
  }),
});

----------------------------------------

TITLE: Creating tRPC Router in TypeScript
DESCRIPTION: Example of creating a tRPC router with query and mutation procedures. It demonstrates input validation using Zod and basic CRUD operations.

LANGUAGE: typescript
CODE:
import { initTRPC } from '@trpc/server';
import { z } from 'zod';

export const t = initTRPC.create();

export const appRouter = t.router({
  getUser: t.procedure.input(z.string()).query((opts) => {
    opts.input; // string
    return { id: opts.input, name: 'Bilbo' };
  }),
  createUser: t.procedure
    .input(z.object({ name: z.string().min(5) }))
    .mutation(async (opts) => {
      // use your ORM of choice
      return await UserModel.create({
        data: opts.input,
      });
    }),
});

// export type definition of API
export type AppRouter = typeof appRouter;

----------------------------------------

TITLE: Configuring Per-Request Aborting in tRPC with Next.js
DESCRIPTION: This snippet demonstrates how to override the global aborting behavior for individual requests. It uses the trpc.useQuery hook with the abortOnUnmount option set to true in the trpc configuration object.

LANGUAGE: typescript
CODE:
import { trpc } from '~/utils/trpc';

const PostViewPage: NextPageWithLayout = () => {
  const id = useRouter().query.id as string;
  const postQuery = trpc.post.byId.useQuery({ id }, { trpc: { abortOnUnmount: true } });

  return (...)
}

----------------------------------------

TITLE: Implementing Conditional SSR for tRPC
DESCRIPTION: Demonstrates how to implement conditional SSR based on request properties, specifically checking if the request comes from a bot. Includes the same basic configuration as the standard SSR setup but with a conditional SSR callback.

LANGUAGE: typescript
CODE:
import { httpBatchLink } from '@trpc/client';
import { createTRPCNext } from '@trpc/next';
import superjson from 'superjson';
import type { AppRouter } from './api/trpc/[trpc]';

export const trpc = createTRPCNext<AppRouter>({
  config(opts) {
    const { ctx } = opts;
    if (typeof window !== 'undefined') {
      // during client requests
      return {
        transformer: superjson, // optional - adds superjson serialization
        links: [
          httpBatchLink({
            url: '/api/trpc',
          }),
        ],
      };
    }

    return {
      transformer: superjson, // optional - adds superjson serialization
      links: [
        httpBatchLink({
          // The server needs to know your app's full url
          url: `${getBaseUrl()}/api/trpc`,
          /**
           * Set custom request headers on every request from tRPC
           * @see https://trpc.io/docs/v10/header
           */
          headers() {
            if (!ctx?.req?.headers) {
              return {};
            }
            // To use SSR properly, you need to forward client headers to the server
            // This is so you can pass through things like cookies when we're server-side rendering
            return {
              cookie: ctx.req.headers.cookie,
            };
          },
        }),
      ],
    };
  },
  ssr(opts) {
    // only SSR if the request is coming from a bot
    return opts.ctx?.req?.headers['user-agent']?.includes('bot');
  },
});

----------------------------------------

TITLE: Creating Query Client Factory for tRPC
DESCRIPTION: Defines a function to create a QueryClient instance with default options for stale time and dehydration.

LANGUAGE: typescript
CODE:
import {
  defaultShouldDehydrateQuery,
  QueryClient,
} from '@tanstack/react-query';
import superjson from 'superjson';

export function makeQueryClient() {
  return new QueryClient({
    defaultOptions: {
      queries: {
        staleTime: 30 * 1000,
      },
      dehydrate: {
        shouldDehydrateQuery: (query) =>
          defaultShouldDehydrateQuery(query) ||
          query.state.status === 'pending',
      },
    },
  });
}

----------------------------------------

TITLE: Integrating tRPC with Remix
DESCRIPTION: Code snippet showing how to integrate tRPC with Remix. This setup handles both loader and action requests for tRPC endpoints.

LANGUAGE: typescript
CODE:
import type { ActionArgs, LoaderArgs } from '@remix-run/node';
import { fetchRequestHandler } from '@trpc/server/adapters/fetch';
import { createContext } from '~/server/context';
import { appRouter } from '~/server/router';

export const loader = async (args: LoaderArgs) => {
  return handleRequest(args);
};
export const action = async (args: ActionArgs) => {
  return handleRequest(args);
};
function handleRequest(args: LoaderArgs | ActionArgs) {
  return fetchRequestHandler({
    endpoint: '/trpc',
    req: args.request,
    router: appRouter,
    createContext,
  });
}

----------------------------------------

TITLE: Creating Query Options with tRPC in TypeScript
DESCRIPTION: Demonstrates how to create query options using tRPC's queryOptions method. It shows how to provide input parameters and additional TanStack React Query options.

LANGUAGE: typescript
CODE:
const queryOptions = trpc.path.to.query.queryOptions(
  {
    /** input */
  },
  {
    // Any Tanstack React Query options
    stateTime: 1000,
  },
);

----------------------------------------

TITLE: Implementing AWS Lambda Request Handler for tRPC
DESCRIPTION: Example of using the AWS Lambda adapter for tRPC. It shows how to create a context for each request and set up the Lambda handler using the awsLambdaRequestHandler function.

LANGUAGE: typescript
CODE:
import { CreateAWSLambdaContextOptions, awsLambdaRequestHandler } from '@trpc/server/adapters/aws-lambda';

const appRouter = /* ... */;

// created for each request
const createContext = ({
  event,
  context,
}: CreateAWSLambdaContextOptions<APIGatewayProxyEventV2>) => ({}) // no context
type Context = Awaited<ReturnType<typeof createContext>>;

export const handler = awsLambdaRequestHandler({
  router: appRouter,
  createContext,
})

----------------------------------------

TITLE: Initializing Server-Side Helpers with External Router in TypeScript
DESCRIPTION: This code shows how to set up server-side helpers using the external router method in tRPC. It's used when you don't have direct access to the tRPC router, such as in a Next.js application with a separate API.

LANGUAGE: typescript
CODE:
import { createTRPCClient } from '@trpc/client';
import { createServerSideHelpers } from '@trpc/react-query/server';
import superjson from 'superjson';

const proxyClient = createTRPCClient<AppRouter>({
  links: [
    httpBatchLink({
      url: 'http://localhost:3000/api/trpc',
    }),
  ],
});

const helpers = createServerSideHelpers({
  client: proxyClient,
});

----------------------------------------

TITLE: Implementing Output Validation with Superstruct in tRPC
DESCRIPTION: Example of using Superstruct schema validation to validate both input and output in a tRPC router. The validator ensures the input is a string and the output contains a greeting string property.

LANGUAGE: tsx
CODE:
import * as trpc from '@trpc/server';
import * as t from 'superstruct';

// [...]

export const appRouter = trpc.router<Context>().query('hello', {
  input: t.string(),
  output: t.object({
    greeting: t.string(),
  }),
  resolve({ input }) {
    return { greeting: input };
  },
});

export type AppRouter = typeof appRouter;

----------------------------------------

TITLE: Initializing tRPC Backend in TypeScript
DESCRIPTION: Sets up the tRPC backend using initTRPC, creates a context, and defines base router and procedure helpers.

LANGUAGE: typescript
CODE:
import { initTRPC } from '@trpc/server';
import { cache } from 'react';

export const createTRPCContext = cache(async () => {
  return { userId: 'user_123' };
});

const t = initTRPC.create();

export const createTRPCRouter = t.router;
export const createCallerFactory = t.createCallerFactory;
export const baseProcedure = t.procedure;

----------------------------------------

TITLE: Integrating tRPC with SolidStart
DESCRIPTION: Code snippet demonstrating how to integrate tRPC with SolidStart. This setup handles both GET and POST requests for tRPC endpoints.

LANGUAGE: typescript
CODE:
import { fetchRequestHandler } from '@trpc/server/adapters/fetch';
import type { APIEvent } from 'solid-start';
import { createContext } from '../../server/context';
import { appRouter } from '../../server/router';

const handler = (event: APIEvent) =>
  fetchRequestHandler({
    endpoint: '/api/trpc',
    req: event.request,
    router: appRouter,
    createContext,
  });
export { handler as GET, handler as POST };

----------------------------------------

TITLE: Implementing Streaming Responses with Async Generators in tRPC
DESCRIPTION: Demonstrates how to use async generators in tRPC to implement streaming responses on the backend. It yields values over time to simulate a stream of data.

LANGUAGE: tsx
CODE:
import { publicProcedure, router } from './trpc';

const appRouter = router({
  iterable: publicProcedure.query(async function* () {
    for (let i = 0; i < 3; i++) {
      await new Promise((resolve) => setTimeout(resolve, 500));
      yield i;
    }
  }),
});

export type AppRouter = typeof appRouter;

----------------------------------------

TITLE: Configuring Fastify Server with tRPC
DESCRIPTION: Setup of Fastify server with tRPC plugin configuration, including error handling and server startup.

LANGUAGE: typescript
CODE:
import {
  fastifyTRPCPlugin,
  FastifyTRPCPluginOptions,
} from '@trpc/server/adapters/fastify';
import fastify from 'fastify';
import { createContext } from './context';
import { appRouter, type AppRouter } from './router';

const server = fastify({
  maxParamLength: 5000,
});

server.register(fastifyTRPCPlugin, {
  prefix: '/trpc',
  trpcOptions: {
    router: appRouter,
    createContext,
    onError({ path, error }) {
      console.error(`Error in tRPC handler on path '${path}':`, error);
    },
  } satisfies FastifyTRPCPluginOptions<AppRouter>['trpcOptions'],
});

(async () => {
  try {
    await server.listen({ port: 3000 });
  } catch (err) {
    server.log.error(err);
    process.exit(1);
  }
})();

----------------------------------------

TITLE: Implementing Output Validation with Yup in tRPC
DESCRIPTION: Example of using Yup schema validation to validate query output in a tRPC router. The output validator ensures the response contains a required greeting string property.

LANGUAGE: tsx
CODE:
import * as trpc from '@trpc/server';
import * as yup from 'yup';

// [...]

export const appRouter = trpc.router<Context>().query('hello', {
  output: yup.object({
    greeting: yup.string().required(),
  }),
  resolve() {
    return { greeting: 'hello!' };
  },
});

export type AppRouter = typeof appRouter;

----------------------------------------

TITLE: Accessing tRPC Data in Server Component
DESCRIPTION: Demonstrates how to directly invoke a tRPC procedure in a server component to access data.

LANGUAGE: tsx
CODE:
import { trpc } from '~/trpc/server';

export default async function Home() {
  const greeting = await trpc.hello();

  return <div>{greeting.greeting}</div>;
}

----------------------------------------

TITLE: Setting up tRPC with Cloudflare Workers
DESCRIPTION: Code for creating a Cloudflare Worker that uses tRPC. This setup handles incoming requests and routes them through the tRPC handler.

LANGUAGE: typescript
CODE:
import { fetchRequestHandler } from '@trpc/server/adapters/fetch';
import { createContext } from './context';
import { appRouter } from './router';

export default {
  async fetch(request: Request): Promise<Response> {
    return fetchRequestHandler({
      endpoint: '/trpc',
      req: request,
      router: appRouter,
      createContext,
    });
  },
};

----------------------------------------

TITLE: CORS-Enabled Next.js tRPC Handler
DESCRIPTION: Enhanced version of the tRPC API handler that includes CORS headers and OPTIONS request handling. Demonstrates how to modify the response headers before passing to the tRPC handler.

LANGUAGE: typescript
CODE:
import { createNextApiHandler } from '@trpc/server/adapters/next';
import { createContext } from '../../../server/trpc/context';
import { appRouter } from '../../../server/trpc/router/_app';

const nextApiHandler = createNextApiHandler({
  router: appRouter,
  createContext,
});

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse,
) {
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Request-Method', '*');
  res.setHeader('Access-Control-Allow-Methods', 'OPTIONS, GET');
  res.setHeader('Access-Control-Allow-Headers', '*');

  if (req.method === 'OPTIONS') {
    res.writeHead(200);
    return res.end();
  }

  return nextApiHandler(req, res);
}

----------------------------------------

TITLE: tRPC Router Method Chaining
DESCRIPTION: Demonstrates how to chain multiple procedure definitions in a tRPC router. Shows adding both 'hello' and 'bye' query endpoints.

LANGUAGE: tsx
CODE:
import * as trpc from '@trpc/server';

// [...]

export const appRouter = trpc
  .router<Context>()
  .query('hello', {
    resolve() {
      return {
        text: `hello world`,
      };
    },
  })
  .query('bye', {
    resolve() {
      return {
        text: `goodbye`,
      };
    },
  });

export type AppRouter = typeof appRouter;

----------------------------------------

TITLE: Integrating tRPC with Oak in Deno
DESCRIPTION: Code snippet demonstrating how to use tRPC with the Oak framework in Deno. This setup creates an Oak application and router to handle tRPC requests.

LANGUAGE: typescript
CODE:
import { Application, Router } from 'https://deno.land/x/oak/mod.ts';
import { fetchRequestHandler } from 'npm:@trpc/server/adapters/fetch';
import { createContext } from './context.ts';
import { appRouter } from './router.ts';

const app = new Application();
const router = new Router();

router.all('/trpc/(.*)', async (ctx) => {
  const res = await fetchRequestHandler({
    endpoint: '/trpc',
    req: new Request(ctx.request.url, {
      headers: ctx.request.headers,
      body:
        ctx.request.method !== 'GET' && ctx.request.method !== 'HEAD'
          ? ctx.request.body({ type: 'stream' }).value
          : void 0,
      method: ctx.request.method,
    }),
    router: appRouter,
    createContext,
  });

  ctx.response.status = res.status;
  ctx.response.headers = res.headers;
  ctx.response.body = res.body;
});

app.use(router.routes());
app.use(router.allowedMethods());

await app.listen({ port: 3000 });

----------------------------------------

TITLE: Implementing useSubscription Hook in React Component
DESCRIPTION: This example demonstrates how to use the useSubscription hook in a React component. It subscribes to a 'onNumber' procedure, updates state with received data, and handles different subscription statuses.

LANGUAGE: tsx
CODE:
import { trpc } from '../utils/trpc';

export function MyComponent() {
  const [numbers, setNumbers] = React.useState<number[]>([]);

  const result = trpc.onNumber.useSubscription(undefined, {
    onData: (num) => {
      setNumbers((prev) => [...prev, num]);
    },
  });

  return (
    <div>
      <h1>Subscription Example</h1>
      <p>
        {result.status}: <pre>{JSON.stringify(result.data, null, 2)}</pre>
      </p>
      <h2>Previous numbers:</h2>
      <ul>
        {numbers.map((num, i) => (
          <li key={i}>{num}</li>
        ))}
      </ul>

      {result.status === 'error' && (
        <button onClick={() => result.reset()}>
          Something went wrong - restart the subscription
        </button>
      )}
    </div>
  );
}

----------------------------------------

TITLE: Implementing Combined Transformer in tRPC Client
DESCRIPTION: Configuration of combined transformer in tRPC client setup

LANGUAGE: typescript
CODE:
import { transformer } from '../utils/trpc';

// [...]

export const client = createTRPCClient<AppRouter>({
  // [...]
  transformer: transformer,
});

----------------------------------------

TITLE: tRPC Router with Yup Input Validation
DESCRIPTION: Example showing how to use Yup for input validation in a tRPC router. Requires a text string input and returns a greeting message.

LANGUAGE: tsx
CODE:
import * as trpc from '@trpc/server';
import * as yup from 'yup';

// [...]

export const appRouter = trpc.router<Context>().query('hello', {
  input: yup.object({
    text: yup.string().required(),
  }),
  resolve({ input }) {
    return {
      greeting: `hello ${input?.text ?? 'world'}`,
    };
  },
});

export type AppRouter = typeof appRouter;

----------------------------------------

TITLE: Implementing API Response Caching with tRPC in Next.js
DESCRIPTION: This snippet shows how to implement API response caching using tRPC in a Next.js application. It includes creating a context, defining a router with a cached query, and setting up the API handler with caching metadata.

LANGUAGE: tsx
CODE:
import * as trpc from '@trpc/server';
import { inferAsyncReturnType } from '@trpc/server';
import * as trpcNext from '@trpc/server/adapters/next';

export const createContext = async ({
  req,
  res,
}: trpcNext.CreateNextContextOptions) => {
  return {
    req,
    res,
    prisma,
  };
};

type Context = inferAsyncReturnType<typeof createContext>;

export function createRouter() {
  return trpc.router<Context>();
}

const waitFor = async (ms: number) =>
  new Promise((resolve) => setTimeout(resolve, ms));

export const appRouter = createRouter().query('public.slow-query-cached', {
  async resolve({ ctx }) {
    await waitFor(5000); // wait for 5s

    return {
      lastUpdated: new Date().toJSON(),
    };
  },
});

// Exporting type _type_ AppRouter only exposes types that can be used for inference
// https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-8.html#type-only-imports-and-export
export type AppRouter = typeof appRouter;

// export API handler
export default trpcNext.createNextApiHandler({
  router: appRouter,
  createContext,
  responseMeta({ ctx, paths, type, errors }) {
    // assuming you have all your public routes with the keyword `public` in them
    const allPublic = paths && paths.every((path) => path.includes('public'));
    // checking that no procedures errored
    const allOk = errors.length === 0;
    // checking we're doing a query request
    const isQuery = type === 'query';

    if (ctx?.res && allPublic && allOk && isQuery) {
      // cache request for 1 day + revalidate once every second
      const ONE_DAY_IN_SECONDS = 60 * 60 * 24;
      return {
        headers: {
          'cache-control': `s-maxage=1, stale-while-revalidate=${ONE_DAY_IN_SECONDS}`,
        },
      };
    }
    return {};
  },
});

----------------------------------------

TITLE: Creating Query Filters with tRPC in TypeScript
DESCRIPTION: Demonstrates how to create query filters using tRPC's queryFilter method. It shows how to provide input parameters and define a predicate function for filtering queries.

LANGUAGE: typescript
CODE:
const queryFilter = trpc.path.to.query.queryFilter(
  {
    /** input */
  },
  {
    // Any Tanstack React Query filter
    predicate: (query) => {
      query.state.data;
    },
  },
);

----------------------------------------

TITLE: Creating Next.js Prisma Starter with tRPC
DESCRIPTION: Command to create a new Next.js project with tRPC and Prisma integration using create-next-app. Includes E2E testing and ESLint configuration.

LANGUAGE: bash
CODE:
yarn create next-app --example https://github.com/trpc/trpc --example-path examples/next-prisma-starter trpc-prisma-starter

----------------------------------------

TITLE: Adding Combined Transformer to tRPC Router
DESCRIPTION: Implementation of combined transformer in tRPC router configuration

LANGUAGE: typescript
CODE:
import * as trpc from '@trpc/server';
import { transformer } from '../../utils/trpc';

export const appRouter = trpc.router().transformer(transformer);
// .query(...)

----------------------------------------

TITLE: tRPC Router with Zod Input Validation
DESCRIPTION: Implementation of a tRPC router using Zod for input validation. Defines an optional text input parameter and returns a customized greeting.

LANGUAGE: tsx
CODE:
import * as trpc from '@trpc/server';
import { z } from 'zod';

// [...]

export const appRouter = trpc.router<Context>().query('hello', {
  input: z
    .object({
      text: z.string().nullish(),
    })
    .nullish(),
  resolve({ input }) {
    return {
      greeting: `hello ${input?.text ?? 'world'}`,
    };
  },
});

export type AppRouter = typeof appRouter;

----------------------------------------

TITLE: Configuring Split Link for Conditional Batching in tRPC
DESCRIPTION: Demonstrates how to use splitLink in tRPC to conditionally enable or disable batching based on a context property. It configures both httpBatchLink and httpLink.

LANGUAGE: typescript
CODE:
import { httpBatchLink } from '@trpc/client/links/httpBatchLink';
import { httpLink } from '@trpc/client/links/httpLink';
import { splitLink } from '@trpc/client/links/splitLink';
import { withTRPC } from '@trpc/next';

// [..]
export default withTRPC<AppRouter>({
  config() {
    const url = `http://localhost:3000`;

    return {
      links: [
        splitLink({
          condition(op) {
            // check for context property `skipBatch`
            return op.context.skipBatch === true;
          },
          // when condition is true, use normal request
          true: httpLink({
            url,
          }),
          // when condition is false, use batching
          false: httpBatchLink({
            url,
          }),
        }),
      ],
    };
  },
})(MyApp);

----------------------------------------

TITLE: Starting Express tRPC Server and Client
DESCRIPTION: Command to start both the Express server and tRPC client simultaneously. This runs the development environment where you can test type-safety between client and server interactions.

LANGUAGE: bash
CODE:
yarn start

----------------------------------------

TITLE: Creating Next.js TodoMVC Example with tRPC
DESCRIPTION: Command to create a new Next.js TodoMVC project with tRPC and Prisma integration using create-next-app. Features SSG implementation.

LANGUAGE: bash
CODE:
yarn create next-app --example https://github.com/trpc/trpc --example-path examples/next-prisma-todomvc trpc-todo

----------------------------------------

TITLE: DataTransformer Interface Definition
DESCRIPTION: TypeScript interface definitions for data transformer and combined data transformer types

LANGUAGE: typescript
CODE:
type DataTransformer = {
  serialize(object: any): any;
  deserialize(object: any): any;
};

type CombinedDataTransformer = {
  input: DataTransformer;
  output: DataTransformer;
};

----------------------------------------

TITLE: Creating tRPC React Hooks
DESCRIPTION: Creates type-safe React hooks from the AppRouter type signature using createTRPCReact.

LANGUAGE: typescript
CODE:
import { createTRPCReact } from '@trpc/react-query';
import type { AppRouter } from '../server/router';

export const trpc = createTRPCReact<AppRouter>();

----------------------------------------

TITLE: Merging Routers with Prefixes in tRPC (TypeScript)
DESCRIPTION: This code snippet demonstrates how to create separate routers for posts and users, and then merge them into a main app router with prefixes. It utilizes TypeScript 4.1 template literal types for type-safe prefixing.

LANGUAGE: typescript
CODE:
const createRouter = () => {
  return trpc.router<Context>();
};

const posts = createRouter()
  .mutation('create', {
    input: z.object({
      title: z.string(),
    }),
    resolve: ({ input }) => {
      // ..
      return {
        id: 'xxxx',
        ...input,
      };
    },
  })
  .query('list', {
    resolve() {
      // ..
      return [];
    },
  });

const users = createRouter().query('list', {
  resolve() {
    // ..
    return [];
  },
});

const appRouter = createRouter()
  .merge('user.', users) // prefix user procedures with "user."
  .merge('post.', posts); // prefix post procedures with "post."

----------------------------------------

TITLE: Implementing Recursive Proxy Handler for tRPC Client
DESCRIPTION: Implementation of a recursive proxy handler that maps client-side procedure calls to server requests. Handles property access and function invocation through Proxy objects.

LANGUAGE: typescript
CODE:
interface ProxyCallbackOptions {
  path: readonly string[];
  args: readonly unknown[];
}

type ProxyCallback = (opts: ProxyCallbackOptions) => unknown;

function createRecursiveProxy(callback: ProxyCallback, path: readonly string[]) {
  const proxy: unknown = new Proxy(
    () => {
      // dummy no-op function
    },
    {
      get(_obj, key) {
        if (typeof key !== 'string') return undefined;
        return createRecursiveProxy(callback, [...path, key]);
      },
      apply(_1, _2, args) {
        return callback({
          path,
          args,
        });
      },
    },
  );

  return proxy;
}

----------------------------------------

TITLE: Using tRPC Query with Custom Context to Skip Batching
DESCRIPTION: Shows how to use a tRPC query with a custom context to skip batching for a specific request in a React component.

LANGUAGE: typescript
CODE:
export function MyComponent() {
  const postsQuery = trpc.useQuery(['posts'], {
    context: {
      skipBatch: true,
    },
  });
  return (
    <pre>{JSON.stringify(postsQuery.data ?? null, null, 4)}</pre>
  )
})

----------------------------------------

TITLE: Installing and Initializing tRPC FormData Example Project
DESCRIPTION: Commands to create a new Next.js project with tRPC and FormData integration. Includes project creation, dependency installation, and development server startup.

LANGUAGE: bash
CODE:
npx create-next-app --example https://github.com/trpc/trpc --example-path examples/next-formdata trpc-formdata
cd trpc-formdata
npm i
npm run dev

----------------------------------------

TITLE: Initializing tRPC Client with HTTP Link
DESCRIPTION: Example showing how to create a tRPC client instance with httpLink configuration. The httpLink is configured with a base URL for API communication.

LANGUAGE: typescript
CODE:
import { createTRPCProxyClient, httpLink } from '@trpc/client';
import type { AppRouter } from '../server';

const client = createTRPCProxyClient<AppRouter>({
  links: [
    httpLink({
      url: 'http://localhost:3000',
    }),
  ],
});

----------------------------------------

TITLE: Installing SuperJSON and Devalue for Separate Upload/Download Transformers
DESCRIPTION: Command to install SuperJSON and Devalue packages for implementing different transformers for upload and download in tRPC.

LANGUAGE: bash
CODE:
yarn add superjson devalue

----------------------------------------

TITLE: Installing WebSocket Dependencies for Fastify
DESCRIPTION: Command to install the @fastify/websocket plugin, which is required for enabling WebSocket support in Fastify for tRPC subscriptions.

LANGUAGE: bash
CODE:
yarn add @fastify/websocket

----------------------------------------

TITLE: Creating User Router in tRPC
DESCRIPTION: This snippet shows the creation of a user router in tRPC. It includes a procedure for listing users.

LANGUAGE: typescript
CODE:
import { router, publicProcedure } from '../trpc';
import { z } from 'zod';
export const userRouter = router({
  list: publicProcedure.query(() => {
    // [..]
    return [];
  }),
});

----------------------------------------

TITLE: Implementing Custom Output Validation in tRPC
DESCRIPTION: Example of using a custom validation function to validate query output in a tRPC router. The validator checks if the output is an object with a greeting string property.

LANGUAGE: tsx
CODE:
import * as trpc from '@trpc/server';
import * as t from 'superstruct';

// [...]

export const appRouter = trpc.router<Context>().query('hello', {
  output: (value: any) => {
    if (value && typeof value.greeting === 'string') {
      return { greeting: value.greeting };
    }
    throw new Error('Greeting not found');
  },
  // expects return type of { greeting: string }
  resolve() {
    return { greeting: 'hello!' };
  },
});

export type AppRouter = typeof appRouter;

----------------------------------------

TITLE: Configuring Maximum Batch Size in Next.js with tRPC
DESCRIPTION: Shows how to set a maximum batch size for tRPC requests in a Next.js application to prevent HTTP 413 errors. It uses the httpBatchLink and sets maxBatchSize to 10.

LANGUAGE: typescript
CODE:
import { httpBatchLink } from '@trpc/client/links/httpBatchLink';
import { withTRPC } from '@trpc/next';
import { AppType } from 'next/dist/shared/lib/utils';
import type { AppRouter } from 'pages/api/trpc/[trpc]';

const MyApp: AppType = ({ Component, pageProps }) => {
  return <Component {...pageProps} />;
};

export default withTRPC<AppRouter>({
  config() {
    return {
      links: [
        httpBatchLink({
          url: '/api/trpc',
          maxBatchSize: 10, // a reasonable size
        }),
      ],
    };
  },
})(MyApp);

----------------------------------------

TITLE: Installing and Running tRPC Development Server
DESCRIPTION: Commands to install dependencies and start the development server for a tRPC project. Requires Node.js version 18 or higher for global fetch support.

LANGUAGE: bash
CODE:
npm i
npm run dev

----------------------------------------

TITLE: Configuring SuperJSON in Next.js tRPC Setup
DESCRIPTION: Integration of SuperJSON transformer in Next.js tRPC client configuration.

LANGUAGE: typescript
CODE:
import { createTRPCNext } from '@trpc/next';
import type { AppRouter } from '~/server/routers/_app';
import superjson from 'superjson';

export const trpc = createTRPCNext<AppRouter>({
  config({ ctx }) {
    return {
      transformer: superjson,
    };
  },
  // [...]
});

----------------------------------------

TITLE: FormData Input Validation in tRPC
DESCRIPTION: Example of handling FormData input validation in tRPC procedures. Uses Zod's instanceof validator to validate FormData objects.

LANGUAGE: typescript
CODE:
import { initTRPC } from '@trpc/server';
import { z } from 'zod';

export const t = initTRPC.create();
const publicProcedure = t.procedure;

export const appRouter = t.router({
  hello: publicProcedure.input(z.instanceof(FormData)).query((opts) => {
    const data = opts.input;
    return {
      greeting: `Hello ${data.get('name')}`,
    };
  }),
});

----------------------------------------

TITLE: Creating Context for tRPC with Fastify
DESCRIPTION: Example of creating a context function for tRPC that includes request and response objects from Fastify, as well as a user object derived from request headers.

LANGUAGE: typescript
CODE:
import { CreateFastifyContextOptions } from '@trpc/server/adapters/fastify';

export function createContext({ req, res }: CreateFastifyContextOptions) {
  const user = { name: req.headers.username ?? 'anonymous' };

  return { req, res, user };
}

export type Context = Awaited<ReturnType<typeof createContext>>;

----------------------------------------

TITLE: Using getQueryKey with React Query in tRPC
DESCRIPTION: Example of using getQueryKey with tRPC and React Query hooks. It demonstrates checking if a query is fetching, setting query defaults for a router, and using tRPC hooks.

LANGUAGE: tsx
CODE:
import { useIsFetching, useQueryClient } from '@tanstack/react-query';
import { getQueryKey } from '@trpc/react-query';
import { trpc } from '~/utils/trpc';

function MyComponent() {
  const queryClient = useQueryClient();

  const posts = trpc.post.list.useQuery();

  // See if a query is fetching
  const postListKey = getQueryKey(trpc.post.list, undefined, 'query');
  const isFetching = useIsFetching(postListKey);

  // Set some query defaults for an entire router
  const postKey = getQueryKey(trpc.post);
  queryClient.setQueryDefaults(postKey, { staleTime: 30 * 60 * 1000 });

  // ...
}

----------------------------------------

TITLE: Configuring SuperJSON in Next.js tRPC Setup
DESCRIPTION: Integration of SuperJSON transformer in Next.js tRPC client configuration.

LANGUAGE: typescript
CODE:
import { createTRPCNext } from '@trpc/next';
import type { AppRouter } from '~/server/routers/_app';
import superjson from 'superjson';

export const trpc = createTRPCNext<AppRouter>({
  config({ ctx }) {
    return {
      transformer: superjson,
    };
  },
  // [...]
});

----------------------------------------

TITLE: Configuring SuperJSON in Next.js tRPC Setup
DESCRIPTION: Integration of SuperJSON transformer in Next.js tRPC client configuration.

LANGUAGE: typescript
CODE:
import { createTRPCNext } from '@trpc/next';
import type { AppRouter } from '~/server/routers/_app';
import superjson from 'superjson';

export const trpc = createTRPCNext<AppRouter>({
  config({ ctx }) {
    return {
      transformer: superjson,
    };
  },
  // [...]
});

----------------------------------------

TITLE: Default Error Shape Interface in tRPC
DESCRIPTION: This code defines the structure of the default error shape in tRPC. It includes interfaces for DefaultErrorData and DefaultErrorShape, specifying the properties of the error object.

LANGUAGE: typescript
CODE:
interface DefaultErrorData {
  code: TRPC_ERROR_CODE_KEY;
  httpStatus: number;
  path?: string;
  stack?: string;
}

interface DefaultErrorShape
  extends TRPCErrorShape<TRPC_ERROR_CODE_NUMBER, DefaultErrorData> {
  message: string;
  code: TRPC_ERROR_CODE_NUMBER;
}

----------------------------------------

TITLE: Using getQueryKey with React Query in tRPC
DESCRIPTION: Example of using getQueryKey with tRPC and React Query hooks. It demonstrates checking if a query is fetching, setting query defaults for a router, and using tRPC hooks.

LANGUAGE: tsx
CODE:
import { useIsFetching, useQueryClient } from '@tanstack/react-query';
import { getQueryKey } from '@trpc/react-query';
import { trpc } from '~/utils/trpc';

function MyComponent() {
  const queryClient = useQueryClient();

  const posts = trpc.post.list.useQuery();

  // See if a query is fetching
  const postListKey = getQueryKey(trpc.post.list, undefined, 'query');
  const isFetching = useIsFetching(postListKey);

  // Set some query defaults for an entire router
  const postKey = getQueryKey(trpc.post);
  queryClient.setQueryDefaults(postKey, { staleTime: 30 * 60 * 1000 });

  // ...
}

----------------------------------------

TITLE: Defining LoggerLinkOptions Interface for tRPC (TypeScript)
DESCRIPTION: This code snippet defines the LoggerLinkOptions interface used in the loggerLink function. It specifies the options available for customizing the logger behavior, including the logger function, enabling conditions, console object, and color mode.

LANGUAGE: typescript
CODE:
type LoggerLinkOptions<TRouter extends AnyRouter> = {
  logger?: LogFn<TRouter>;
  /**
   * It is a function that returns a condition that determines whether to enable the logger.
   * It is true by default.
   */
  enabled?: EnabledFn<TRouter>;
  /**
   * Used in the built-in defaultLogger
   */
  console?: ConsoleEsque;
  /**
   * Color mode used in the default logger.
   * @default typeof window === 'undefined' ? 'ansi' : 'css'
   */
  colorMode?: 'ansi' | 'css';
};

----------------------------------------

TITLE: Handling Authentication Token in tRPC Mutation
DESCRIPTION: This snippet shows how to update the authentication token after a successful login mutation. It uses the onSuccess callback of a tRPC mutation to set the token for subsequent requests.

LANGUAGE: typescript
CODE:
const loginMut = trpc.auth.login.useMutation({
  onSuccess(opts) {
    token = opts.accessToken;
  },
});

----------------------------------------

TITLE: Configuring Global Abort on Unmount in tRPC with Next.js
DESCRIPTION: This snippet demonstrates how to configure tRPC to abort all requests on component unmount globally. It uses the createTRPCNext function and sets the abortOnUnmount option to true in the configuration.

LANGUAGE: typescript
CODE:
// @filename: utils.ts
// @noErrors
import { createTRPCNext } from '@trpc/next';

export const trpc = createTRPCNext<AppRouter>({
  config() {
    return {
      // ...
      abortOnUnmount: true,
    };
  },
});

----------------------------------------

TITLE: Initializing tRPC Server Actions Base Setup
DESCRIPTION: Basic setup for tRPC server actions including initialization and caller configuration with Next.js adapter. Defines metadata interface and creates base procedure builder.

LANGUAGE: typescript
CODE:
import { initTRPC, TRPCError } from '@trpc/server';
import { experimental_nextAppDirCaller } from '@trpc/server/adapters/next-app-dir';

interface Meta {
  span: string;
}

export const t = initTRPC.meta<Meta>().create();

const serverActionProcedure = t.procedure.experimental_caller(
  experimental_nextAppDirCaller({
    pathExtractor: ({ meta }) => (meta as Meta).span,
  }),
);

----------------------------------------

TITLE: Adding Custom Error Formatting in tRPC Server
DESCRIPTION: This snippet shows how to add custom error formatting to a tRPC router. It extends the default error shape with additional data, specifically handling Zod validation errors.

LANGUAGE: typescript
CODE:
const router = trpc.router<Context>().formatError(({ shape, error }) => {
  return {
    ...shape,
    data: {
      ...shape.data,
      zodError:
        error.code === 'BAD_REQUEST' && error.cause instanceof ZodError
          ? error.cause.flatten()
          : null,
    },
  };
});

----------------------------------------

TITLE: Defining getMutationKey Function Signature for tRPC Mutations
DESCRIPTION: TypeScript function signature for getMutationKey, used with tRPC mutations. It returns a TRPCMutationKey for a given mutation procedure.

LANGUAGE: typescript
CODE:
function getMutationKey(procedure: AnyMutationProcedure): TRPCMutationKey;

----------------------------------------

TITLE: Configuring Cross-Domain Authentication in TypeScript
DESCRIPTION: Example of setting up cross-domain authentication using withCredentials for HTTP subscription links.

LANGUAGE: typescript
CODE:
unstable_httpSubscriptionLink({
  url: 'https://example.com/api/trpc',
  eventSourceOptions() {
    return {
      withCredentials: true,
    };
  },
});

----------------------------------------

TITLE: HTTP Batch Link Interface Definitions
DESCRIPTION: TypeScript interface definitions for HTTPBatchLinkOptions and HTTPLinkOptions, showing all available configuration options for the httpBatchLink.

LANGUAGE: typescript
CODE:
export interface HTTPBatchLinkOptions extends HTTPLinkOptions {
  maxURLLength?: number;
}

export interface HTTPLinkOptions {
  url: string;
  /**
   * Add ponyfill for fetch
   */
  fetch?: typeof fetch;
  /**
   * Add ponyfill for AbortController
   */
  AbortController?: typeof AbortController | null;
  /**
   * Data transformer
   * @see https://trpc.io/docs/data-transformers
   **/
  transformer?: DataTransformerOptions;
  /**
   * Headers to be set on outgoing requests or a callback that of said headers
   * @see http://trpc.io/docs/header
   */
  headers?:
    | HTTPHeaders
    | ((opts: { opList: Operation[] }) => HTTPHeaders | Promise<HTTPHeaders>);
}

----------------------------------------

TITLE: Configuring Express.js Adapter for tRPC
DESCRIPTION: Setup for the Express.js adapter that converts tRPC router into Express middleware. Includes context creation and middleware configuration.

LANGUAGE: typescript
CODE:
import * as trpcExpress from '@trpc/server/adapters/express';

const appRouter = /* ... */;

const app = express();

// created for each request
const createContext = ({
  req,
  res,
}: trpcExpress.CreateExpressContextOptions) => ({}) // no context
type Context = trpc.inferAsyncReturnType<typeof createContext>;

app.use(
  '/trpc',
  trpcExpress.createExpressMiddleware({
    router: appRouter,
    createContext,
  })
);

app.listen(4000);

----------------------------------------

TITLE: Creating tRPC Router Setup with TypeScript
DESCRIPTION: Example setup of a tRPC router with query and mutation procedures for a posts API. Demonstrates basic procedure definitions with input validation using Zod.

LANGUAGE: typescript
CODE:
type Post = { id: string; title: string };
const posts: Post[] = [];

const appRouter = router({
  post: router({
    byId: publicProcedure
      .input(z.object({ id: z.string() }))
      .query(({ input }) => {
        const post = posts.find((p) => p.id === input.id);
        if (!post) throw new TRPCError({ code: "NOT_FOUND" });
        return post;
      }),
    byTitle: publicProcedure
      .input(z.object({ title: z.string() }))
      .query(({ input }) => {
        const post = posts.find((p) => p.title === input.title);
        if (!post) throw new TRPCError({ code: "NOT_FOUND" });
        return post;
      }),
    create: publicProcedure
      .input(z.object({ title: z.string() }))
      .mutation(({ input }) => {
        const post = { id: uuid(), ...input };
        posts.push(post);
        return post;
      }),
  }),
});

----------------------------------------

TITLE: Implementing AWS Lambda Request Handler for tRPC
DESCRIPTION: Shows how to use the tRPC AWS Lambda adapter to create a handler for API Gateway requests. It includes context creation and exports the handler function.

LANGUAGE: typescript
CODE:
import { CreateAWSLambdaContextOptions, awsLambdaRequestHandler } from '@trpc/server/adapters/aws-lambda';

const appRouter = /* ... */;

// created for each request
const createContext = ({
  event,
  context,
}: CreateAWSLambdaContextOptions) => ({}) // no context
type Context = trpc.inferAsyncReturnType<typeof createContext>;

export const handler = awsLambdaRequestHandler({
  router: appRouter,
  createContext,
})

----------------------------------------

TITLE: formatError Function Properties in tRPC
DESCRIPTION: This snippet outlines the properties passed to the formatError function in tRPC. It includes details about the error object, procedure type, path, input, context, and default error shape.

LANGUAGE: typescript
CODE:
{
  error: TRPCError;
  type: ProcedureType | 'unknown';
  path: string | undefined;
  input: unknown;
  ctx: undefined | TContext;
  shape: DefaultErrorShape; // the default error shape
}

----------------------------------------

TITLE: Configuring httpLink in Next.js tRPC Client (TypeScript)
DESCRIPTION: This snippet demonstrates how to configure the httpLink in a Next.js tRPC client setup when disabling request batching.

LANGUAGE: typescript
CODE:
import type { AppRouter } from '@/server/routers/app';
import { httpLink } from '@trpc/client';
import { createTRPCNext } from '@trpc/next';

export const trpc = createTRPCNext<AppRouter>({
  config() {
    return {
      links: [
        httpLink({
          url: '/api/trpc',
        }),
      ],
    };
  },
});

----------------------------------------

TITLE: Encoding Batched tRPC Query Inputs (TypeScript)
DESCRIPTION: Shows how to encode inputs for batched tRPC queries. The example demonstrates encoding multiple inputs into a single query parameter.

LANGUAGE: typescript
CODE:
encodeURIComponent(
  JSON.stringify({
    0: '1', // <-- input for `postById`
    1: '1', // <-- input for `relatedPosts`
  }),
);

----------------------------------------

TITLE: Disabling Server-Side Batching in tRPC
DESCRIPTION: Example of disabling request batching on the server side using the allowBatching option in both standalone HTTP server and Next.js configurations.

LANGUAGE: typescript
CODE:
import { createHTTPServer } from '@trpc/server/adapters/standalone';

createHTTPServer({
  // [...]
  // 👇 disable batching
  allowBatching: false,
});

----------------------------------------

TITLE: Configuring loggerLink in tRPC Client (TypeScript)
DESCRIPTION: This snippet demonstrates how to import and configure the loggerLink in a tRPC client setup. It shows how to enable logging based on the environment and error conditions.

LANGUAGE: typescript
CODE:
import { createTRPCClient, httpBatchLink, loggerLink } from '@trpc/client';
import type { AppRouter } from '../server';

const client = createTRPCClient<AppRouter>({
  links: [
    /**
     * The function passed to enabled is an example in case you want to the link to
     * log to your console in development and only log errors in production
     */
    loggerLink({
      enabled: (opts) =>
        (process.env.NODE_ENV === 'development' &&
          typeof window !== 'undefined') ||
        (opts.direction === 'down' && opts.result instanceof Error),
    }),
    httpBatchLink({
      url: 'http://localhost:3000',
    }),
  ],
});

----------------------------------------

TITLE: Installing tRPC Packages with npm
DESCRIPTION: Command to install tRPC packages and dependencies using npm. This includes server, client, React integration, and Next.js utilities.

LANGUAGE: bash
CODE:
npm install @trpc/server @trpc/client @trpc/react react-query@3 @trpc/next

----------------------------------------

TITLE: Configuring tRPC with SSR in Next.js _app.tsx
DESCRIPTION: This code snippet demonstrates how to set up tRPC with server-side rendering in a Next.js application's _app.tsx file. It includes configuration for both client-side and server-side rendering, handling of headers, and setting up caching. The code uses the withTRPC higher-order component to wrap the main App component.

LANGUAGE: tsx
CODE:
import { withTRPC } from '@trpc/next';
import { AppType } from 'next/dist/shared/lib/utils';
import React from 'react';
import superjson from 'superjson';
import type { AppRouter } from './api/trpc/[trpc]';

const MyApp: AppType = ({ Component, pageProps }) => {
  return <Component {...pageProps} />;
};

export default withTRPC<AppRouter>({
  config({ ctx }) {
    if (typeof window !== 'undefined') {
      // during client requests
      return {
        transformer: superjson, // optional - adds superjson serialization
        url: '/api/trpc',
      };
    }
    // during SSR below

    // optional: use SSG-caching for each rendered page (see caching section for more details)
    const ONE_DAY_SECONDS = 60 * 60 * 24;
    ctx?.res?.setHeader(
      'Cache-Control',
      `s-maxage=1, stale-while-revalidate=${ONE_DAY_SECONDS}`,
    );

    // The server needs to know your app's full url
    // On render.com you can use `http://${process.env.RENDER_INTERNAL_HOSTNAME}:${process.env.PORT}/api/trpc`
    const url = process.env.VERCEL_URL
      ? `https://${process.env.VERCEL_URL}/api/trpc`
      : 'http://localhost:3000/api/trpc';

    return {
      transformer: superjson, // optional - adds superjson serialization
      url,
      /**
       * Set custom request headers on every request from tRPC
       * @see http://localhost:3000/docs/v9/header
       * @see http://localhost:3000/docs/v9/ssr
       */
      headers() {
        if (ctx?.req) {
          // To use SSR properly, you need to forward the client's headers to the server
          // This is so you can pass through things like cookies when we're server-side rendering

          // If you're using Node 18, omit the "connection" header
          const {
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            connection: _connection,
            ...headers
          } = ctx.req.headers;
          return {
            ...headers,
            // Optional: inform server that it's an SSR request
            'x-ssr': '1',
          };
        }
        return {};
      },
    };
  },
  ssr: true,
})(MyApp);

----------------------------------------

TITLE: Using Custom Error Formatting in React Component
DESCRIPTION: This example demonstrates how to use the custom error formatting in a React component. It shows how to access and display Zod validation errors from a tRPC mutation.

LANGUAGE: tsx
CODE:
export function MyComponent() {
  const mutation = trpc.useMutation('addPost');

  useEffect(() => {
    mutation.mutate({ title: 'example' });
  }, []);

  if (mutation.error?.data?.zodError) {
    // zodError will be inferred
    return (
      <pre>Error: {JSON.stringify(mutation.error.data.zodError, null, 2)}</pre>
    );
  }
  return <>[...]</>;
}

----------------------------------------

TITLE: Running tRPC Tests in Watch Mode with Bash
DESCRIPTION: These commands demonstrate how to run tests in watch mode, including options for testing specific files or regression tests. It requires the development watcher to be running in another terminal.

LANGUAGE: bash
CODE:
pnpm test-watch

# example if you want to test a specific test file:
pnpm test-watch react

# run only a regression test while fixing a bug
pnpm test-watch 3085

----------------------------------------

TITLE: Implementing Custom Type Inference Helpers for tRPC in TypeScript
DESCRIPTION: This code snippet demonstrates how to create custom type inference helpers for tRPC applications. It includes type definitions for queries, mutations, and subscriptions, as well as helper types for inferring input and output types of procedures.

LANGUAGE: typescript
CODE:
// trpc-helper.ts
// Import AppRouter from your main server router
import type {
  inferProcedureInput,
  inferProcedureOutput,
  inferSubscriptionOutput,
} from '@trpc/server';
import type { AppRouter } from 'api/src/routers/_app';

/**
 * Enum containing all api query paths
 */
export type TQuery = keyof AppRouter['_def']['queries'];

/**
 * Enum containing all api mutation paths
 */
export type TMutation = keyof AppRouter['_def']['mutations'];

/**
 * Enum containing all api subscription paths
 */
export type TSubscription = keyof AppRouter['_def']['subscriptions'];

/**
 * This is a helper method to infer the output of a query resolver
 * @example type HelloOutput = InferQueryOutput<'hello'>
 */
export type InferQueryOutput<TRouteKey extends TQuery> = inferProcedureOutput<
  AppRouter['_def']['queries'][TRouteKey]
>;

/**
 * This is a helper method to infer the input of a query resolver
 * @example type HelloInput = InferQueryInput<'hello'>
 */
export type InferQueryInput<TRouteKey extends TQuery> = inferProcedureInput<
  AppRouter['_def']['queries'][TRouteKey]
>;

/**
 * This is a helper method to infer the output of a mutation resolver
 * @example type HelloOutput = InferMutationOutput<'hello'>
 */
export type InferMutationOutput<TRouteKey extends TMutation> =
  inferProcedureOutput<AppRouter['_def']['mutations'][TRouteKey]>;

/**
 * This is a helper method to infer the input of a mutation resolver
 * @example type HelloInput = InferMutationInput<'hello'>
 */
export type InferMutationInput<TRouteKey extends TMutation> =
  inferProcedureInput<AppRouter['_def']['mutations'][TRouteKey]>;

/**
 * This is a helper method to infer the output of a subscription resolver
 * @example type HelloOutput = InferSubscriptionOutput<'hello'>
 */
export type InferSubscriptionOutput<TRouteKey extends TSubscription> =
  inferProcedureOutput<AppRouter['_def']['subscriptions'][TRouteKey]>;

/**
 * This is a helper method to infer the asynchronous output of a subscription resolver
 * @example type HelloAsyncOutput = InferAsyncSubscriptionOutput<'hello'>
 */
export type InferAsyncSubscriptionOutput<TRouteKey extends TSubscription> =
  inferSubscriptionOutput<AppRouter, TRouteKey>;

/**
 * This is a helper method to infer the input of a subscription resolver
 * @example type HelloInput = InferSubscriptionInput<'hello'>
 */
export type InferSubscriptionInput<TRouteKey extends TSubscription> =
  inferProcedureInput<AppRouter['_def']['subscriptions'][TRouteKey]>;

----------------------------------------

TITLE: HTTPLinkOptions Interface Definition in TypeScript
DESCRIPTION: This code snippet defines the HTTPLinkOptions interface used for configuring the httpLink. It includes options for URL, fetch ponyfill, AbortController ponyfill, data transformer, headers, and method override.

LANGUAGE: typescript
CODE:
export interface HTTPLinkOptions {
  url: string;
  /**
   * Add ponyfill for fetch
   */
  fetch?: typeof fetch;
  /**
   * Add ponyfill for AbortController
   */
  AbortController?: typeof AbortController | null;
  /**
   * Data transformer
   * @see https://trpc.io/docs/v11/data-transformers
   **/
  transformer?: DataTransformerOptions;
  /**
   * Headers to be set on outgoing requests or a callback that of said headers
   * @see http://trpc.io/docs/v10/header
   */
  headers?:
    | HTTPHeaders
    | ((opts: { op: Operation }) => HTTPHeaders | Promise<HTTPHeaders>);
  /**
   * Send all requests as POSTS requests regardless of the procedure type
   * The server must separately allow overriding the method. See:
   * @see https://trpc.io/docs/rpc
   */
  methodOverride?: 'POST';
}

----------------------------------------

TITLE: Setting Up tRPC Client in TypeScript
DESCRIPTION: Configures the tRPC client with the AppRouter type for end-to-end typesafety.

LANGUAGE: typescript
CODE:
import { createTRPCClient, httpBatchLink } from '@trpc/client';
import type { AppRouter } from './server';

const trpc = createTRPCClient<AppRouter>({
  links: [
    httpBatchLink({
      url: 'http://localhost:3000',
    }),
  ],
});

----------------------------------------

TITLE: Implementing SSG with tRPC in Next.js Post Page
DESCRIPTION: Complete example of a Next.js page component implementing Static Site Generation with tRPC. Shows how to fetch data using createSSGHelpers, implement getStaticProps and getStaticPaths, and render a blog post page. Uses Prisma for database access and includes support for superjson serialization.

LANGUAGE: tsx
CODE:
import { createSSGHelpers } from '@trpc/react/ssg';
import {
  GetStaticPaths,
  GetStaticPropsContext,
  InferGetStaticPropsType,
} from 'next';
import { prisma } from 'server/context';
import { appRouter } from 'server/routers/_app';
import superjson from 'superjson';
import { trpc } from 'utils/trpc';

export async function getStaticProps(
  context: GetStaticPropsContext<{ id: string }>,
) {
  const ssg = await createSSGHelpers({
    router: appRouter,
    ctx: {},
    transformer: superjson, // optional - adds superjson serialization
  });
  const id = context.params?.id as string;

  // prefetch `post.byId`
  await ssg.fetchQuery('post.byId', {
    id,
  });

  return {
    props: {
      trpcState: ssg.dehydrate(),
      id,
    },
    revalidate: 1,
  };
}

export const getStaticPaths: GetStaticPaths = async () => {
  const posts = await prisma.post.findMany({
    select: {
      id: true,
    },
  });

  return {
    paths: posts.map((post) => ({
      params: {
        id: post.id,
      },
    })),
    // https://nextjs.org/docs/basic-features/data-fetching#fallback-blocking
    fallback: 'blocking',
  };
};

export default function PostViewPage(
  props: InferGetStaticPropsType<typeof getStaticProps>,
) {
  const { id } = props;
  const postQuery = trpc.useQuery(['post.byId', { id }]);

  if (postQuery.status !== 'success') {
    // won't happen since we're using `fallback: "blocking"`
    return <>Loading...</>;
  }
  const { data } = postQuery;
  return (
    <>
      <h1>{data.title}</h1>
      <em>Created {data.createdAt.toLocaleDateString('en-us')}</em>

      <p>{data.text}</p>

      <h2>Raw data:</h2>
      <pre>{JSON.stringify(data, null, 4)}</pre>
    </>
  );
}

----------------------------------------

TITLE: tRPC Default Error Shape Type Definition
DESCRIPTION: Defines the TypeScript types for the default error data structure and shape used by tRPC's error handling system.

LANGUAGE: typescript
CODE:
type DefaultErrorData = {
  code: TRPC_ERROR_CODE_KEY;
  httpStatus: number;
  /**
   * Path to the procedure that threw the error
   */
  path?: string;
  /**
   * Stack trace of the error (only in development)
   */
  stack?: string;
};

interface DefaultErrorShape {
  message: string;
  code: TRPC_ERROR_CODE_NUMBER;
  data: DefaultErrorData;
}

----------------------------------------

TITLE: Extending Middlewares with Pipe in tRPC
DESCRIPTION: This snippet shows how to extend middlewares using the .pipe() method in tRPC, allowing for chaining and modifying context in a type-safe manner.

LANGUAGE: typescript
CODE:
const fooMiddleware = t.middleware((opts) => {
  return opts.next({
    ctx: {
      foo: 'foo' as const,
    },
  });
});

const barMiddleware = fooMiddleware.unstable_pipe((opts) => {
  const { ctx } = opts;
  ctx.foo;
  return opts.next({
    ctx: {
      bar: 'bar' as const,
    },
  });
});

const barProcedure = publicProcedure.use(barMiddleware);
barProcedure.query(({ ctx }) => ctx.bar);

----------------------------------------

TITLE: Installing WebSocket Dependency for tRPC Subscriptions
DESCRIPTION: Command to install the @fastify/websocket package for enabling WebSocket support in Fastify.

LANGUAGE: bash
CODE:
yarn add @fastify/websocket

----------------------------------------

TITLE: LoggerLinkOptions Interface Definition (TypeScript)
DESCRIPTION: This snippet defines the LoggerLinkOptions interface used for configuring the loggerLink. It includes options for custom logging functions, enabling conditions, console object, and color mode.

LANGUAGE: typescript
CODE:
type LoggerLinkOptions<TRouter extends AnyRouter> = {
  logger?: LogFn<TRouter>;
  /**
   * It is a function that returns a condition that determines whether to enable the logger.
   * It is true by default.
   */
  enabled?: EnabledFn<TRouter>;
  /**
   * Used in the built-in defaultLogger
   */
  console?: ConsoleEsque;
  /**
   * Color mode used in the default logger.
   * @default typeof window === 'undefined' ? 'ansi' : 'css'
   */
  colorMode?: 'ansi' | 'css';
};

----------------------------------------

TITLE: Using getQueryKey in React Components
DESCRIPTION: Practical example showing how to use getQueryKey with React Query hooks to check fetching status and set query defaults. Demonstrates integration with useIsFetching and queryClient.

LANGUAGE: tsx
CODE:
import { useIsFetching, useQueryClient } from '@tanstack/react-query';
import { getQueryKey } from '@trpc/react-query';
import { trpc } from '~/utils/trpc';

function MyComponent() {
  const queryClient = useQueryClient();

  const posts = trpc.post.list.useQuery();

  // See if a query is fetching
  const postListKey = getQueryKey(trpc.post.list, undefined, 'query');
  const isFetching = useIsFetching(postListKey);

  // Set some query defaults for an entire router
  const postKey = getQueryKey(trpc.post);
  queryClient.setQueryDefaults(postKey, { staleTime: 30 * 60 * 1000 });

  // ...
}

----------------------------------------

TITLE: Initializing and Starting tRPC HTTP Server in TypeScript
DESCRIPTION: This code creates an HTTP server using tRPC's createHTTPServer function, configures it with an appRouter, and starts the server to listen on port 3000. The createHTTPServer function returns a listen method, which is then called to start the server.

LANGUAGE: typescript
CODE:
const { listen } = createHTTPServer({
  router: appRouter,
});

// The API will now be listening on port 3000!
listen(3000);

----------------------------------------

TITLE: Creating Typed tRPC Hooks for React Components
DESCRIPTION: Defines a set of strongly-typed hooks using the tRPC API's type signature. This allows for type-safe API calls in React components.

LANGUAGE: typescript
CODE:
import { createReactQueryHooks } from '@trpc/react';
import type { AppRouter } from '../pages/api/trpc/[trpc]';

export const trpc = createReactQueryHooks<AppRouter>();
// => { useQuery: ..., useMutation: ...}

----------------------------------------

TITLE: Adding a Query Endpoint to tRPC Router in TypeScript
DESCRIPTION: Demonstrates how to add a query endpoint 'getUser' to the tRPC router. It includes input validation and resolver implementation.

LANGUAGE: typescript
CODE:
import * as trpc from '@trpc/server';

const appRouter = trpc.router().query('getUser', {
  input: (val: unknown) => {
    if (typeof val === 'string') return val;
    throw new Error(`Invalid input: ${typeof val}`);
  },
  async resolve(req) {
    req.input; // string
    return { id: req.input, name: 'Bilbo' };
  },
});

export type AppRouter = typeof appRouter;

----------------------------------------

TITLE: Creating Standalone Middlewares in tRPC
DESCRIPTION: This snippet demonstrates how to create standalone middlewares using experimental_standaloneMiddleware in tRPC, allowing for reusable middlewares across different tRPC instances.

LANGUAGE: typescript
CODE:
const projectAccessMiddleware = experimental_standaloneMiddleware<{
  ctx: { allowedProjects: string[] }; // defaults to 'object' if not defined
  input: { projectId: string }; // defaults to 'unknown' if not defined
  // 'meta', not defined here, defaults to 'object | undefined'
}>().create((opts) => {
  if (!opts.ctx.allowedProjects.includes(opts.input.projectId)) {
    throw new TRPCError({
      code: 'FORBIDDEN',
      message: 'Not allowed',
    });
  }

  return opts.next();
});

const t1 = initTRPC
  .context<{
    allowedProjects: string[];
  }>()
  .create();

// ✅ `ctx.allowedProjects` satisfies "string[]" and `input.projectId` satisfies "string"
const accessControlledProcedure = t1.procedure
  .input(z.object({ projectId: z.string() }))
  .use(projectAccessMiddleware);

----------------------------------------

TITLE: Creating tRPC Router in TypeScript
DESCRIPTION: Sample code for creating a tRPC router with query and mutation endpoints using Zod for input validation.

LANGUAGE: typescript
CODE:
import * as trpc from '@trpc/server';
import { z } from 'zod';

type User = {
  id: string;
  name: string;
  bio?: string;
};

const users: Record<string, User> = {};

export const appRouter = trpc
  .router()
  .query('getUserById', {
    input: z.string(),
    async resolve({ input }) {
      return users[input]; // input type is string
    },
  })
  .mutation('createUser', {
    // validate input with Zod
    input: z.object({
      name: z.string().min(3),
      bio: z.string().max(142).optional(),
    }),
    async resolve({ input }) {
      const id = Date.now().toString();
      const user: User = { id, ...input };
      users[user.id] = user;
      return user;
    },
  });

// export type definition of API
export type AppRouter = typeof appRouter;

----------------------------------------

TITLE: Batching Multiple Queries in TypeScript with tRPC
DESCRIPTION: Demonstrates how to batch multiple queries into a single HTTP request using tRPC's automatic request batching feature.

LANGUAGE: typescript
CODE:
const somePosts = await Promise.all([
  client.query('post.byId', 1),
  client.query('post.byId', 2),
  client.query('post.byId', 3),
]);

----------------------------------------

TITLE: Configuring TypeScript Strict Mode
DESCRIPTION: TypeScript configuration to enable strict mode for better type safety when using Zod validation.

LANGUAGE: json
CODE:
{
  // ...
  "compilerOptions": {
    // ...
    "strict": true
  }
}

----------------------------------------

TITLE: Recommended File Structure for tRPC with Next.js
DESCRIPTION: Displays the recommended file structure for a Next.js project using tRPC. This structure includes directories for Prisma (if used), pages, server-side code, and utility files.

LANGUAGE: graphql
CODE:
.
├── prisma # <-- if prisma is added
│   └── [..]
├── src
│   ├── pages
│   │   ├── _app.tsx # <-- add `withTRPC()`-HOC here
│   │   ├── api
│   │   │   └── trpc
│   │   │       └── [trpc].ts # <-- tRPC HTTP handler
│   │   └── [..]
│   ├── server
│   │   ├── routers
│   │   │   ├── app.ts   # <-- main app router
│   │   │   ├── post.ts  # <-- sub routers
│   │   │   └── [..]
│   │   ├── context.ts      # <-- create app context
│   │   └── createRouter.ts # <-- router helper
│   └── utils
│       └── trpc.ts  # <-- your typesafe tRPC hooks
└── [..]

----------------------------------------

TITLE: Installing Next.js Prisma TodoMVC Example
DESCRIPTION: Command to create a new Next.js TodoMVC application with tRPC and Prisma using create-next-app.

LANGUAGE: bash
CODE:
yarn create next-app --example https://github.com/trpc/trpc --example-path examples/next-prisma-todomvc trpc-todo

----------------------------------------

TITLE: Implementing Error Handler in tRPC
DESCRIPTION: Shows how to implement an error handler using the onError method to process and handle errors before they are sent to the client.

LANGUAGE: typescript
CODE:
export default trpcNext.createNextApiHandler({
  // ...
  onError(opts) {
    const { error, type, path, input, ctx, req } = opts;
    console.error('Error:', error);
    if (error.code === 'INTERNAL_SERVER_ERROR') {
      // send to bug reporting
    }
  },
});

----------------------------------------

TITLE: Installing tRPC and Fastify Dependencies
DESCRIPTION: Command to install the required dependencies for using tRPC with Fastify.

LANGUAGE: bash
CODE:
yarn add @trpc/server fastify zod

----------------------------------------

TITLE: Defining useSubscription Hook Signature and Options in TypeScript
DESCRIPTION: This snippet defines the TypeScript signature for the useSubscription hook and its options interface. It includes callbacks for subscription lifecycle events and supports pausing with skipToken.

LANGUAGE: typescript
CODE:
function useSubscription<TOutput, TError>(
  input: TInput | SkipToken,
  opts?: UseTRPCSubscriptionOptions<TOutput, TError>,
): TRPCSubscriptionResult<TOutput, TError>;

interface UseTRPCSubscriptionOptions<TOutput, TError> {
  /**
   * Callback invoked when the subscription starts.
   */
  onStarted?: () => void;
  /**
   * Callback invoked when new data is received from the subscription.
   * @param data - The data received.
   */
  onData?: (data: TOutput) => void;
  /**
   * Callback invoked when an **unrecoverable error** occurs and the subscription is stopped.
   */
  onError?: (error: TError) => void;
  /**
   * Callback invoked when the subscription is completed.
   */
  onComplete?: () => void;
  /**
   * @deprecated Use a `skipToken` from `@tanstack/react-query` instead.
   * This will be removed in a future version.
   */
  enabled?: boolean;
}

----------------------------------------

TITLE: Using tRPC API in Server Component
DESCRIPTION: Demonstrates prefetching a query in a server component and rendering a client component with the data.

LANGUAGE: tsx
CODE:
import { trpc } from '~/trpc/server';
import { ClientGreeting } from './client-greeting';

export default async function Home() {
  void trpc.hello.prefetch();

  return (
    <HydrateClient>
      <div>...</div>
      <ClientGreeting />
    </HydrateClient>
  );
}

----------------------------------------

TITLE: Creating Custom Post Retrieval Hook
DESCRIPTION: Implements a custom React hook for fetching posts by ID with proper type inference for inputs and options.

LANGUAGE: typescript
CODE:
import { ReactQueryOptions, RouterInputs, trpc } from './trpc';

type PostByIdOptions = ReactQueryOptions['post']['byId'];
type PostByIdInput = RouterInputs['post']['byId'];

function usePostById(input: PostByIdInput, options?: PostByIdOptions) {
  return trpc.post.byId.useQuery(input, options);
}

----------------------------------------

TITLE: Importing and Rendering MDX Content in Docusaurus
DESCRIPTION: Imports testimonial content from an unversioned _love.mdx file and renders it within the page component using JSX syntax.

LANGUAGE: jsx
CODE:
import Content from '@site/unversioned/_love.mdx';

<Content />

----------------------------------------

TITLE: Installing Next.js Starter with tRPC, Prisma, and E2E Testing (yarn)
DESCRIPTION: Command to create a new Next.js application using tRPC, Prisma, and E2E testing with yarn. This starter includes ESLint configuration.

LANGUAGE: sh
CODE:
yarn create next-app --example https://github.com/trpc/trpc --example-path examples/next-prisma-starter trpc-prisma-starter

----------------------------------------

TITLE: Default Error Shape Interface
DESCRIPTION: Defines the default error shape interfaces used in tRPC error handling, including error data structure and shape definition.

LANGUAGE: typescript
CODE:
interface DefaultErrorData {
  code: TRPC_ERROR_CODE_KEY;
  httpStatus: number;
  path?: string;
  stack?: string;
}

interface DefaultErrorShape
  extends TRPCErrorShape<TRPC_ERROR_CODE_NUMBER, DefaultErrorData> {
  message: string;
  code: TRPC_ERROR_CODE_NUMBER;
}

----------------------------------------

TITLE: Error Handling in Next.js API Handler
DESCRIPTION: Shows how to implement custom error handling using the onError handler in a Next.js API route. Includes error logging and conditional error processing.

LANGUAGE: typescript
CODE:
export default trpcNext.createNextApiHandler({
  // ...
  onError({ error, type, path, input, ctx, req }) {
    console.error('Error:', error);
    if (error.code === 'INTERNAL_SERVER_ERROR') {
      // send to bug reporting
    }
  },
});

----------------------------------------

TITLE: Query Invalidation Examples in React Component
DESCRIPTION: This snippet demonstrates various ways to invalidate queries using the useUtils hook, including invalidating single queries, whole routers, or all queries.

LANGUAGE: tsx
CODE:
import { trpc } from '../utils/trpc';

function MyComponent() {
  const utils = trpc.useUtils();

  const invalidateAllQueriesAcrossAllRouters = () => {
    // 1️⃣
    // All queries on all routers will be invalidated 🔥
    utils.invalidate();
  };

  const invalidateAllPostQueries = () => {
    // 2️⃣
    // All post queries will be invalidated 📭
    utils.post.invalidate();
  };

  const invalidatePostById = () => {
    // 3️⃣
    // All queries in the post router with input {id:1} invalidated 📭
    utils.post.byId.invalidate({ id: 1 });
  };

  // Example queries
  trpc.user.all.useQuery(); // Would only be validated by 1️⃣ only.
  trpc.post.all.useQuery(); // Would be invalidated by 1️⃣ & 2️⃣
  trpc.post.byId.useQuery({ id: 1 }); // Would be invalidated by 1️⃣, 2️⃣ and 3️⃣
  trpc.post.byId.useQuery({ id: 2 }); // would be invalidated by 1️⃣ and 2️⃣ but NOT 3️⃣!

  // [...]
}

----------------------------------------

TITLE: Initializing tRPC Client with HTTP Batch Link in TypeScript
DESCRIPTION: Creates a tRPC client using createTRPCProxyClient and sets up an HTTP batch link. It includes type import for AppRouter and a custom header function for authentication.

LANGUAGE: typescript
CODE:
import { createTRPCProxyClient, httpBatchLink } from '@trpc/client';
import type { AppRouter } from '../path/to/server/trpc';

const client = createTRPCProxyClient<AppRouter>({
  links: [
    httpBatchLink({
      url: 'http://localhost:3000/trpc',

      // You can pass any HTTP headers you wish here
      async headers() {
        return {
          authorization: getAuthCookie(),
        };
      },
    }),
  ],
});

----------------------------------------

TITLE: Batching Request Input Encoding
DESCRIPTION: Example showing how input parameters are encoded for batched requests in tRPC.

LANGUAGE: typescript
CODE:
encodeURIComponent(
  JSON.stringify({
    0: '1', // <-- input for `postById`
    1: '1', // <-- input for `relatedPosts`
  }),
);

----------------------------------------

TITLE: Initializing HTTP Subscription Link with Split Link in TypeScript
DESCRIPTION: Basic setup of HTTP subscription link using splitLink to handle subscription operations separately from regular HTTP requests. Includes logger link for development debugging.

LANGUAGE: typescript
CODE:
import type { TRPCLink } from '@trpc/client';
import {
  httpBatchLink,
  loggerLink,
  splitLink,
  unstable_httpSubscriptionLink,
} from '@trpc/client';

const trpcClient = createTRPCClient<AppRouter>({
  links: [
    loggerLink(),
    splitLink({
      condition: (op) => op.type === 'subscription',
      true: unstable_httpSubscriptionLink({
        url: `/api/trpc`,
      }),
      false: httpBatchLink({
        url: `/api/trpc`,
      }),
    }),
  ],
});

----------------------------------------

TITLE: HTTP Link Options Interface Definition
DESCRIPTION: TypeScript interface defining the available configuration options for httpLink, including URL, fetch ponyfill, AbortController, and custom headers configuration.

LANGUAGE: typescript
CODE:
export interface HTTPLinkOptions {
  url: string;
  /**
   * Add ponyfill for fetch
   */
  fetch?: typeof fetch;
  /**
   * Add ponyfill for AbortController
   */
  AbortController?: typeof AbortController | null;
  /**
   * Headers to be set on outgoing requests or a callback that of said headers
   * @see http://trpc.io/docs/v10/header
   */
  headers?:
    | HTTPHeaders
    | ((opts: { op: Operation }) => HTTPHeaders | Promise<HTTPHeaders>);
}

----------------------------------------

TITLE: Throwing tRPC Errors in Server Procedures
DESCRIPTION: Demonstrates how to throw a custom TRPCError in a server procedure with a specific error code, message, and optional cause. Shows implementation in a router query.

LANGUAGE: typescript
CODE:
import * as trpc from '@trpc/server';

const appRouter = trpc.router().query('hello', {
  resolve: () => {
    throw new trpc.TRPCError({
      code: 'INTERNAL_SERVER_ERROR',
      message: 'An unexpected error occurred, please try again later.',
      // optional: pass the original error to retain stack trace
      cause: theError,
    });
  },
});

// [...]

----------------------------------------

TITLE: Using Proxy Client with useUtils
DESCRIPTION: Example of using the proxy client exposed by useUtils for async procedure calls.

LANGUAGE: tsx
CODE:
import { trpc } from '../utils/trpc';

function MyComponent() {
  const [apiKey, setApiKey] = useState();
  const utils = trpc.useUtils();

  return (
    <Form
      handleSubmit={async (event) => {
        const apiKey = await utils.client.apiKey.create.mutate(event);
        setApiKey(apiKey);
      }}
    >
      ...
    </Form>
  );
}

----------------------------------------

TITLE: Inferring Input and Output Types from tRPC Router in TypeScript
DESCRIPTION: This snippet demonstrates how to use the inferRouterInputs and inferRouterOutputs helper types from @trpc/server to infer the types of router inputs and outputs, specifically for the post.create procedure.

LANGUAGE: typescript
CODE:
import type { inferRouterInputs, inferRouterOutputs } from '@trpc/server';
import type { AppRouter } from './server';

type RouterInput = inferRouterInputs<AppRouter>;
type RouterOutput = inferRouterOutputs<AppRouter>;

type PostCreateInput = RouterInput['post']['create'];
type PostCreateOutput = RouterOutput['post']['create'];

----------------------------------------

TITLE: Inferring TRPCClientError Types in TypeScript
DESCRIPTION: This snippet shows how to infer and use the TRPCClientError type for error handling in tRPC client code. It includes a type guard function and demonstrates error handling in an async function.

LANGUAGE: typescript
CODE:
import { TRPCClientError } from '@trpc/client';
import type { AppRouter } from './server';
import { trpc } from './trpc';

export function isTRPCClientError(
  cause: unknown,
): cause is TRPCClientError<AppRouter> {
  return cause instanceof TRPCClientError;
}

async function main() {
  try {
    await trpc.post.byId.query('1');
  } catch (cause) {
    if (isTRPCClientError(cause)) {
      // `cause` is now typed as your router's `TRPCClientError`
      console.log('data', cause.data);
    } else {
      // [...]
    }
  }
}

main();

----------------------------------------

TITLE: React Component with tRPC Queries
DESCRIPTION: React component demonstrating how to use tRPC queries with the useQuery hook. Shows parallel query execution that will be automatically batched.

LANGUAGE: tsx
CODE:
export function MyComponent() {
  const post1 = trpc.useQuery(['postById', '1']);
  const relatedPosts = trpc.useQuery(['relatedPosts', '1']);

  return (
    <pre>
      {JSON.stringify(
        {
          post1: post1.data ?? null,
          relatedPosts: relatedPosts.data ?? null,
        },
        null,
        4,
      )}
    </pre>
  );
}

----------------------------------------

TITLE: Implementing Custom Headers with EventSource Polyfill in TypeScript
DESCRIPTION: Setup for custom headers and authentication using EventSource polyfill in non-web environments.

LANGUAGE: typescript
CODE:
import {
  createTRPCClient,
  httpBatchLink,
  splitLink,
  unstable_httpSubscriptionLink,
} from '@trpc/client';
import { EventSourcePolyfill } from 'event-source-polyfill';
import type { AppRouter } from '../server/index.js';

const trpc = createTRPCClient<AppRouter>({
  links: [
    splitLink({
      condition: (op) => op.type === 'subscription',
      true: unstable_httpSubscriptionLink({
        url: 'http://localhost:3000',
        EventSource: EventSourcePolyfill,
        eventSourceOptions: async ({ op }) => {
          const signature = await getSignature(op);
          return {
            headers: {
              authorization: 'Bearer supersecret',
              'x-signature': signature,
            },
          };
        },
      }),
      false: httpBatchLink({
        url: 'http://localhost:3000',
      }),
    }),
  ],
});

----------------------------------------

TITLE: Initializing tRPC Client with HTTP Batch Stream Link
DESCRIPTION: Basic setup of a tRPC client using httpBatchStreamLink to enable batched request streaming. This allows multiple requests to be combined into a single HTTP request while streaming responses as they become available.

LANGUAGE: typescript
CODE:
import { createTRPCProxyClient, httpBatchStreamLink } from '@trpc/client';
import type { AppRouter } from '../server';

const client = createTRPCProxyClient<AppRouter>({
  links: [
    httpBatchStreamLink({
      url: 'http://localhost:3000',
    }),
  ],
});

----------------------------------------

TITLE: Example tRPC Error Response Structure
DESCRIPTION: Shows the JSON structure of a typical tRPC error response when a bad request is made. Includes error message, code, and additional metadata.

LANGUAGE: json
CODE:
{
  "id": null,
  "error": {
    "message": "\"password\" must be at least 4 characters",
    "code": -32600,
    "data": {
      "code": "BAD_REQUEST",
      "httpStatus": 400,
      "stack": "...",
      "path": "user.changepassword"
    }
  }
}

----------------------------------------

TITLE: Query Invalidation Example
DESCRIPTION: Shows how to invalidate specific queries using the useUtils hook's invalidate helper.

LANGUAGE: tsx
CODE:
import { trpc } from '../utils/trpc';

function MyComponent() {
  const utils = trpc.useUtils();

  const mutation = trpc.post.edit.useMutation({
    onSuccess(input) {
      utils.post.all.invalidate();
      utils.post.byId.invalidate({ id: input.id });
    },
  });

  // [...]
}

----------------------------------------

TITLE: Configuring tRPC Client with Method Override (TypeScript)
DESCRIPTION: Example of configuring a tRPC client to use a specific HTTP method (POST) for all queries and mutations, overriding the default behavior.

LANGUAGE: typescript
CODE:
const client = createTRPCClient<AppRouter>({
  links: [
    httpLink({
      url: `http://localhost:3000`,
      methodOverride: 'POST', // all queries and mutations will be sent to the tRPC Server as POST requests.
    }),
  ],
});

----------------------------------------

TITLE: Using tRPC in Server and Client Components
DESCRIPTION: Demonstrates prefetching queries in a server component and consuming the data in a client component using React Query hooks.

LANGUAGE: tsx
CODE:
// app/page.tsx
import { dehydrate, HydrationBoundary } from '@tanstack/react-query';
import { getQueryClient, trpc } from '~/trpc/server';
import { ClientGreeting } from './client-greeting';

export default async function Home() {
  const queryClient = getQueryClient();
  void queryClient.prefetchQuery(
    trpc.hello.queryOptions({
      /** input */
    }),
  );

  return (
    <HydrationBoundary state={dehydrate(queryClient)}>
      <div>...</div>
      <ClientGreeting />
    </HydrationBoundary>
  );
}

// app/client-greeting.tsx
'use client';

import { useQuery } from '@tanstack/react-query';
import { useTRPC } from '~/trpc/client';

export function ClientGreeting() {
  const trpc = useTRPC();
  const greeting = useQuery(trpc.hello.queryOptions({ text: 'world' }));
  if (!greeting.data) return <div>Loading...</div>;
  return <div>{greeting.data.greeting}</div>;
}

----------------------------------------

TITLE: Using useInfiniteQuery Hook in React Component with tRPC
DESCRIPTION: This example shows how to use the useInfiniteQuery hook in a React component with tRPC. It demonstrates setting up the query with a limit and a function to get the next page parameter.

LANGUAGE: tsx
CODE:
import { trpc } from '../utils/trpc';

export function MyComponent() {
  const myQuery = trpc.infinitePosts.useInfiniteQuery(
    {
      limit: 10,
    },
    {
      getNextPageParam: (lastPage) => lastPage.nextCursor,
      // initialCursor: 1, // <-- optional you can pass an initialCursor
    },
  );
  // [...]
}

----------------------------------------

TITLE: Optimized tRPC Router Types in TypeScript
DESCRIPTION: Improved TypeScript types for tRPC v10 routers with better performance characteristics.

LANGUAGE: ts
CODE:
export type V10Router<TProcedureRecord> = {
  record: TProcedureRecord;
  // by default, no legacy procedures
  legacy: {};
};

export type MigrateV9Router<TV9Router extends V9Router> = {
  // v9 routers inject their procedures into a `legacy` field
  legacy: {
    // v9 clients require that we filter queries, mutations, subscriptions at the top-level
    queries: MigrateProcedureRecord<TV9Router['queries']>;
    mutations: MigrateProcedureRecord<TV9Router['mutations']>;
    subscriptions: MigrateProcedureRecord<TV9Router['subscriptions']>;
  };
} & V10Router</* empty object, v9 routers have no v10 procedures to pass */ {}>;

----------------------------------------

TITLE: Creating a tRPC Router in TypeScript
DESCRIPTION: Example of implementing a basic tRPC router with a 'getUser' query. It demonstrates input validation using Zod and defines the router's type.

LANGUAGE: typescript
CODE:
import * as trpc from '@trpc/server';
import { z } from 'zod';

const appRouter = trpc.router().query('getUser', {
  input: z.string(),
  async resolve(req) {
    req.input; // string
    return { id: req.input, name: 'Bilbo' };
  },
});

// export type definition of API
export type AppRouter = typeof appRouter;

----------------------------------------

TITLE: Using useSuspenseQuery with tRPC React
DESCRIPTION: Demonstrates how to use the useSuspenseQuery hook to fetch a post by ID with React Suspense support. Returns a tuple containing the data and query object.

LANGUAGE: tsx
CODE:
import React from 'react';
import { trpc } from '../utils/trpc';

function PostView() {
  const [post, postQuery] = trpc.post.byId.useSuspenseQuery({ id: '1' });

  return <>{/* ... */}</>;
}

----------------------------------------

TITLE: Setting up tRPC without React Context
DESCRIPTION: Shows how to set up tRPC and React Query without using React context. This approach is suitable for single-page applications using client-side rendering.

LANGUAGE: typescript
CODE:
import { QueryClient } from '@tanstack/react-query';
import { createTRPCClient, httpBatchLink } from '@trpc/client';
import { createTRPCOptionsProxy } from '@trpc/tanstack-react-query';
import type { AppRouter } from '../server/router';

export const queryClient = new QueryClient();

const trpcClient = createTRPCClient<AppRouter>({
  links: [httpBatchLink({ url: 'http://localhost:2022' })],
});

export const trpc = createTRPCOptionsProxy<AppRouter>({
  client: trpcClient,
  queryClient,
});

LANGUAGE: tsx
CODE:
import { QueryClientProvider } from '@tanstack/react-query';
import React from 'react';
import { queryClient } from './utils/trpc';

export function App() {
  return (
    <QueryClientProvider client={queryClient}>
      {/* Your app here */}
    </QueryClientProvider>
  );
}

----------------------------------------

TITLE: Making Typesafe API Calls with tRPC Client in TypeScript
DESCRIPTION: Demonstrates how to use the initialized tRPC client to make strongly typed API calls. It shows examples of both query and mutation operations with full type inference.

LANGUAGE: typescript
CODE:
const bilbo = await client.query('getUser', 'id_bilbo');
// => { id: 'id_bilbo', name: 'Bilbo' };

const frodo = await client.mutation('createUser', { name: 'Frodo' });
// => { id: 'id_frodo', name: 'Frodo' };

----------------------------------------

TITLE: Using getInfiniteData Helper with tRPC in React
DESCRIPTION: This snippet demonstrates how to use the getInfiniteData helper function to retrieve cached data from an existing infinite query in a React component using tRPC.

LANGUAGE: tsx
CODE:
import { trpc } from '../utils/trpc';

export function MyComponent() {
  const utils = trpc.useUtils();

  const myMutation = trpc.infinitePosts.add.useMutation({
    async onMutate(opts) {
      await utils.infinitePosts.cancel();
      const allPosts = utils.infinitePosts.getInfiniteData({ limit: 10 });
      // [...]
    },
  });
}

----------------------------------------

TITLE: Running tRPC Client with Bun
DESCRIPTION: Command to start the tRPC client using Bun runtime. This should be executed in a separate terminal after starting the server.

LANGUAGE: sh
CODE:
bun dev:client

----------------------------------------

TITLE: Using tRPC useQuery() Hook in a React Component
DESCRIPTION: Shows how to use the tRPC useQuery() hook in a React component. It demonstrates queries both with and without arguments, and renders the results.

LANGUAGE: tsx
CODE:
import { trpc } from '../utils/trpc';

export function MyComponent() {
  // input is optional, so we don't have to pass second argument
  const helloNoArgs = trpc.useQuery(['hello']);
  const helloWithArgs = trpc.useQuery(['hello', { text: 'client' }]);

  return (
    <div>
      <h1>Hello World Example</h1>
      <ul>
        <li>
          helloNoArgs ({helloNoArgs.status}):{' '}
          <pre>{JSON.stringify(helloNoArgs.data, null, 2)}</pre>
        </li>
        <li>
          helloWithArgs ({helloWithArgs.status}):{' '}
          <pre>{JSON.stringify(helloWithArgs.data, null, 2)}</pre>
        </li>
      </ul>
    </div>
  );
}

----------------------------------------

TITLE: Using useSuspenseInfiniteQuery with tRPC React
DESCRIPTION: Shows implementation of infinite query pagination using useSuspenseInfiniteQuery hook. Includes cursor-based pagination and handling of loading states.

LANGUAGE: tsx
CODE:
import React from 'react';
import { trpc } from '../utils/trpc';

function PostView() {
  const [pages, allPostsQuery] = trpc.post.all.useSuspenseInfiniteQuery(
    {},
    {
      getNextPageParam(lastPage) {
        return lastPage.nextCursor;
      },
    },
  );

  const { isFetching, isFetchingNextPage, fetchNextPage, hasNextPage } =
    allPostsQuery;

  return <>{/* ... */}</>;
}

----------------------------------------

TITLE: Migrating tRPC Query Invalidations in TypeScript React
DESCRIPTION: Example of migrating query invalidations from the classic tRPC client to the new client. This shows how to use the QueryClient directly for invalidations instead of tRPC's useUtils.

LANGUAGE: typescript
CODE:
import { trpc } from './trpc';

function Users() {
  const utils = trpc.useUtils();

  async function invalidateGreeting() {
    await utils.greeting.invalidate({ name: 'Jerry' });
  }
}

LANGUAGE: typescript
CODE:
import { useQuery, useQueryClient } from '@tanstack/react-query';
import { useTRPC } from './trpc';

function Users() {
  const trpc = useTRPC();
  const queryClient = useQueryClient();

  async function invalidateGreeting() {
    await queryClient.invalidateQueries(
      trpc.greeting.queryFilter({ name: 'Jerry' }),
    );
  }
}

----------------------------------------

TITLE: Creating a Custom tRPC Link in Next.js
DESCRIPTION: Demonstrates how to create and use a custom tRPC link in a Next.js application. The custom link can be used for logging, error handling, or modifying requests/responses.

LANGUAGE: typescript
CODE:
import { TRPCLink } from '@trpc/client';
import type { AppRouter } from 'pages/api/trpc/[trpc]';

const customLink: TRPCLink<AppRouter> = (runtime) => {
  // here we just got initialized in the app - this happens once per app
  // useful for storing cache for instance
  return ({ prev, next, op }) => {
    // this is when passing the result to the next link
    next(op, (result) => {
      // this is when we've gotten result from the server
      if (result instanceof Error) {
        // maybe send to bugsnag?
      }
      prev(result);
    });
  };
};

export default withTRPC<AppRouter>({
  config() {
    return {
      links: [
        customLink,
        // [..]
        // ❗ Make sure to end with a `httpBatchLink` or `httpLink`
      ],
    };
  },
  // ssr: false
})(MyApp);

----------------------------------------

TITLE: Using setInfiniteData Helper with tRPC in React
DESCRIPTION: This example illustrates how to use the setInfiniteData helper function to update a query's cached data in a React component using tRPC. It includes filtering items based on a condition.

LANGUAGE: tsx
CODE:
import { trpc } from '../utils/trpc';

export function MyComponent() {
  const utils = trpc.useUtils();

  const myMutation = trpc.infinitePosts.delete.useMutation({
    async onMutate(opts) {
      await utils.infinitePosts.cancel();

      utils.infinitePosts.setInfiniteData({ limit: 10 }, (data) => {
        if (!data) {
          return {
            pages: [],
            pageParams: [],
          };
        }

        return {
          ...data,
          pages: data.pages.map((page) => ({
            ...page,
            items: page.items.filter((item) => item.status === 'published'),
          })),
        };
      });
    },
  });

  // [...]
}

----------------------------------------

TITLE: Configuring Fastify Server with tRPC Plugin
DESCRIPTION: Setup for a Fastify server with the tRPC plugin, including error handling and context creation. This configuration exposes tRPC routes under the '/trpc' prefix.

LANGUAGE: typescript
CODE:
import {
  fastifyTRPCPlugin,
  FastifyTRPCPluginOptions,
} from '@trpc/server/adapters/fastify';
import fastify from 'fastify';
import { createContext } from './context';
import { appRouter, type AppRouter } from './router';

const server = fastify({
  maxParamLength: 5000,
});

server.register(fastifyTRPCPlugin, {
  prefix: '/trpc',
  trpcOptions: {
    router: appRouter,
    createContext,
    onError({ path, error }) {
      // report to error monitoring
      console.error(`Error in tRPC handler on path '${path}':`, error);
    },
  } satisfies FastifyTRPCPluginOptions<AppRouter>['trpcOptions'],
});

(async () => {
  try {
    await server.listen({ port: 3000 });
  } catch (err) {
    server.log.error(err);
    process.exit(1);
  }
})();

----------------------------------------

TITLE: Creating tRPC React Hooks
DESCRIPTION: Setting up strongly-typed React hooks using createReactQueryHooks from tRPC.

LANGUAGE: tsx
CODE:
// utils/trpc.ts
import { createReactQueryHooks } from '@trpc/react';
import type { AppRouter } from '../path/to/router.ts';

export const trpc = createReactQueryHooks<AppRouter>();
// => { useQuery: ..., useMutation: ...}

----------------------------------------

TITLE: Creating tRPC Client for React Components
DESCRIPTION: Sets up a tRPC client for use in client components, including a provider and query client configuration.

LANGUAGE: tsx
CODE:
'use client';

import type { QueryClient } from '@tanstack/react-query';
import { QueryClientProvider } from '@tanstack/react-query';
import { httpBatchLink } from '@trpc/client';
import { createTRPCReact } from '@trpc/react-query';
import { useState } from 'react';
import { makeQueryClient } from './query-client';
import type { AppRouter } from './routers/_app';

export const trpc = createTRPCReact<AppRouter>();

let clientQueryClientSingleton: QueryClient;
function getQueryClient() {
  if (typeof window === 'undefined') {
    return makeQueryClient();
  }
  return (clientQueryClientSingleton ??= makeQueryClient());
}

function getUrl() {
  const base = (() => {
    if (typeof window !== 'undefined') return '';
    if (process.env.VERCEL_URL) return `https://${process.env.VERCEL_URL}`;
    return 'http://localhost:3000';
  })();
  return `${base}/api/trpc`;
}

export function TRPCProvider(
  props: Readonly<{
    children: React.ReactNode;
  }>,
) {
  const queryClient = getQueryClient();

  const [trpcClient] = useState(() =>
    trpc.createClient({
      links: [
        httpBatchLink({
          url: getUrl(),
        }),
      ],
    }),
  );

  return (
    <trpc.Provider client={trpcClient} queryClient={queryClient}>
      <QueryClientProvider client={queryClient}>
        {props.children}
      </QueryClientProvider>
    </trpc.Provider>
  );
}

----------------------------------------

TITLE: Comparing HTTP/REST and RPC API Calls in TypeScript
DESCRIPTION: This snippet demonstrates the difference between making an API call using traditional HTTP/REST approach and using RPC. It shows how RPC simplifies the process by directly calling a function instead of constructing a URL request.

LANGUAGE: typescript
CODE:
// HTTP/REST
const res = await fetch('/api/users/1');
const user = await res.json();

// RPC
const user = await api.users.getById({ id: 1 });

----------------------------------------

TITLE: React Component with Non-Batched tRPC Query
DESCRIPTION: Illustrates how to use splitLink configuration within a React component to make non-batched queries using the useQuery hook with proper context configuration.

LANGUAGE: tsx
CODE:
export function MyComponent() {
  const postsQuery = proxy.posts.useQuery(undefined, {
    trpc: {
      context: {
        skipBatch: true,
      },
    }
  });
  return (
    <pre>{JSON.stringify(postsQuery.data ?? null, null, 4)}</pre>
  )
})

----------------------------------------

TITLE: Creating a tRPC Router with a Query Procedure in TypeScript
DESCRIPTION: Demonstrates how to create a tRPC router with a 'hello' query procedure. It uses Zod for input validation and defines a resolver function.

LANGUAGE: tsx
CODE:
import * as trpc from '@trpc/server';
import { z } from 'zod';

export const appRouter = trpc
  .router()
  // Create procedure at path 'hello'
  .query('hello', {
    // using zod schema to validate and infer input values
    input: z
      .object({
        text: z.string().nullish(),
      })
      .nullish(),
    resolve({ input }) {
      return {
        greeting: `hello ${input?.text ?? 'world'}`,
      };
    },
  });

----------------------------------------

TITLE: Using setInfiniteData Helper in tRPC (TypeScript)
DESCRIPTION: This snippet shows how to use the setInfiniteData helper function to update the cached data of an infinite query in tRPC. It's used within a mutation to modify the query data based on the mutation result.

LANGUAGE: tsx
CODE:
import { trpc } from '../utils/trpc';

export function MyComponent() {
  const utils = trpc.useUtils();

  const myMutation = trpc.infinitePosts.delete.useMutation({
    async onMutate(opts) {
      await utils.infinitePosts.cancel();

      utils.infinitePosts.setInfiniteData({ limit: 10 }, (data) => {
        if (!data) {
          return {
            pages: [],
            pageParams: [],
          };
        }

        return {
          ...data,
          pages: data.pages.map((page) => ({
            ...page,
            items: page.items.filter((item) => item.status === 'published'),
          })),
        };
      });
    },
  });

  // [...]
}

----------------------------------------

TITLE: Installing WebSocket Dependencies
DESCRIPTION: Command to install the required ws package for WebSocket functionality

LANGUAGE: bash
CODE:
yarn add ws

----------------------------------------

TITLE: Installing Client Dependencies for tRPC
DESCRIPTION: Installation of required client-side dependencies including tRPC packages and react-query.

LANGUAGE: bash
CODE:
yarn add @trpc/client @trpc/server @trpc/react react-query@3

----------------------------------------

TITLE: Creating tRPC Caller for Server Components
DESCRIPTION: Sets up a tRPC caller for use in server components, including hydration helpers and a query client getter.

LANGUAGE: tsx
CODE:
import 'server-only';

import { createHydrationHelpers } from '@trpc/react-query/rsc';
import { cache } from 'react';
import { createCallerFactory, createTRPCContext } from './init';
import { makeQueryClient } from './query-client';
import { appRouter } from './routers/_app';

export const getQueryClient = cache(makeQueryClient);
const caller = createCallerFactory(appRouter)(createTRPCContext);

export const { trpc, HydrateClient } = createHydrationHelpers<typeof appRouter>(
  caller,
  getQueryClient,
);

----------------------------------------

TITLE: Configuring TRPC Client with Retry Link
DESCRIPTION: Example showing how to set up a TRPC client with retry link functionality. The retry logic is customized to retry queries up to 3 times for internal server errors.

LANGUAGE: typescript
CODE:
import { createTRPCClient, retryLink } from '@trpc/client';

const client = createTRPCClient<AppRouter>({
  links: [
    retryLink({
      retry(opts) {
        if (
          opts.error.data &&
          opts.error.data.code !== 'INTERNAL_SERVER_ERROR'
        ) {
          // Don't retry on non-500s
          return false;
        }
        if (opts.op.type !== 'query') {
          // Only retry queries
          return false;
        }

        // Retry up to 3 times
        return opts.attempts <= 3;
      },
    }),
    httpBatchLink({
      url: 'http://localhost:3000',
    }),
  ],
});

----------------------------------------

TITLE: Defining useQuery() Hook Signature in TypeScript
DESCRIPTION: Defines the TypeScript signature for the useQuery() hook in tRPC. It accepts a path and input tuple, along with optional configuration options.

LANGUAGE: tsx
CODE:
function useQuery(
  pathAndInput: [string, TInput?],
  opts?: UseTRPCQueryOptions;
)

----------------------------------------

TITLE: Using useInfiniteQuery in React Component (TypeScript)
DESCRIPTION: This snippet shows how to use the useInfiniteQuery hook in a React component to fetch paginated data from a tRPC procedure. It includes setting up the query with a limit and defining how to get the next page parameter.

LANGUAGE: tsx
CODE:
import { trpc } from '../utils/trpc';

export function MyComponent() {
  const myQuery = trpc.infinitePosts.useInfiniteQuery(
    {
      limit: 10,
    },
    {
      getNextPageParam: (lastPage) => lastPage.nextCursor,
      // initialCursor: 1, // <-- optional you can pass an initialCursor
    },
  );
  // [...]
}

----------------------------------------

TITLE: Defining a tRPC Mutation for Updating Todos
DESCRIPTION: This code defines a tRPC mutation endpoint for updating todo items. It uses zod for input validation and interacts with a database context to perform the update operation.

LANGUAGE: tsx
CODE:
const todoRouter = createRouter().mutation('add', {
  input: z.object({
    id: z.string().uuid(),
    data: z.object({
      completed: z.boolean().optional(),
      text: z.string().min(1).optional(),
    }),
  }),
  async resolve({ ctx, input }) {
    const { id, data } = input;
    const todo = await ctx.task.update({
      where: { id },
      data,
    });
    return todo;
  },
});

----------------------------------------

TITLE: Configuring Next.js _app.tsx with tRPC
DESCRIPTION: Sets up the Next.js _app.tsx file with tRPC integration using the withTRPC higher-order component. This configuration includes setting up the tRPC client and enabling server-side rendering.

LANGUAGE: tsx
CODE:
import { withTRPC } from '@trpc/next';
import { AppType } from 'next/dist/shared/lib/utils';
import type { AppRouter } from './api/trpc/[trpc]';

const MyApp: AppType = ({ Component, pageProps }) => {
  return <Component {...pageProps} />;
};

export default withTRPC<AppRouter>({
  config({ ctx }) {
    /**
     * If you want to use SSR, you need to use the server's full URL
     * @see https://trpc.io/docs/ssr
     */
    const url = process.env.VERCEL_URL
      ? `https://${process.env.VERCEL_URL}/api/trpc`
      : 'http://localhost:3000/api/trpc';

    return {
      url,
      /**
       * @see https://tanstack.com/query/v3/docs/react/reference/QueryClient
       */
      // queryClientConfig: { defaultOptions: { queries: { staleTime: 60 } } },
    };
  },
  /**
   * @see https://trpc.io/docs/ssr
   */
  ssr: true,
})(MyApp);

----------------------------------------

TITLE: Using tRPC API in Client Component
DESCRIPTION: Shows how to use the tRPC query hook in a client component to fetch and display data.

LANGUAGE: tsx
CODE:
'use client';

import { trpc } from '~/trpc/client';

export function ClientGreeting() {
  const greeting = trpc.hello.useQuery();
  if (!greeting.data) return <div>Loading...</div>;
  return <div>{greeting.data.greeting}</div>;
}

----------------------------------------

TITLE: Serving tRPC API with Standalone Adapter in TypeScript
DESCRIPTION: Sets up an HTTP server to serve the tRPC API using the standalone adapter.

LANGUAGE: typescript
CODE:
import { createHTTPServer } from '@trpc/server/adapters/standalone';

const appRouter = router({
  // ...
});

const server = createHTTPServer({
  router: appRouter,
});

server.listen(3000);

----------------------------------------

TITLE: Implementing Async Generator Example with tRPC
DESCRIPTION: Complete example demonstrating async generator implementation with tRPC server and client setup for streaming responses.

LANGUAGE: typescript
CODE:
// @filename: server.ts
import { publicProcedure, router } from './trpc';

const appRouter = router({
  examples: {
    iterable: publicProcedure.query(async function* () {
      for (let i = 0; i < 3; i++) {
        await new Promise((resolve) => setTimeout(resolve, 500));
        yield i;
      }
    }),
  },
});

export type AppRouter = typeof appRouter;

// @filename: client.ts
import { createTRPCClient, unstable_httpBatchStreamLink } from '@trpc/client';
import type { AppRouter } from './server';

const trpc = createTRPCClient<AppRouter>({
  links: [
    unstable_httpBatchStreamLink({
      url: 'http://localhost:3000',
    }),
  ],
});
const iterable = await trpc.examples.iterable.query();

for await (const value of iterable) {
  console.log('Iterable:', value);
}

----------------------------------------

TITLE: Invalidating tRPC Queries with TypeScript
DESCRIPTION: Example showing how to invalidate tRPC queries within a mutation's onSuccess handler. Demonstrates invalidating both a collection query ('post.all') and a specific item query ('post.byId') after a successful post edit operation.

LANGUAGE: tsx
CODE:
import { trpc } from '../utils/trpc';

// In component:
const utils = trpc.useUtils();

const mutation = trpc.useMutation('post.edit', {
  onSuccess(input) {
    utils.invalidateQueries(['post.all']);
    utils.invalidateQueries(['post.byId', input.id]);
  },
});

----------------------------------------

TITLE: Leveraging Suspense with tRPC and React Server Components
DESCRIPTION: Demonstrates using Suspense and Error Boundaries with tRPC queries in a server component setup.

LANGUAGE: tsx
CODE:
import { trpc } from '~/trpc/server';
import { Suspense } from 'react';
import { ErrorBoundary } from 'react-error-boundary';
import { ClientGreeting } from './client-greeting';

export default async function Home() {
  void trpc.hello.prefetch();

  return (
    <HydrateClient>
      <div>...</div>
      <ErrorBoundary fallback={<div>Something went wrong</div>}>
        <Suspense fallback={<div>Loading...</div>}>
          <ClientGreeting />
        </Suspense>
      </ErrorBoundary>
    </HydrateClient>
  );
}

----------------------------------------

TITLE: Installing tRPC dependencies for Express
DESCRIPTION: Command to install the required dependencies for using tRPC with Express. Zod is included as an optional dependency for input validation.

LANGUAGE: bash
CODE:
yarn add @trpc/server zod

----------------------------------------

TITLE: Adding Subscription Procedure in tRPC Router
DESCRIPTION: Demonstrates how to add a subscription procedure to a tRPC router. It uses an EventEmitter to handle real-time updates and includes a mutation to trigger events.

LANGUAGE: typescript
CODE:
import { EventEmitter } from 'events';
import * as trpc from '@trpc/server';

// create a global event emitter (could be replaced by redis, etc)
const ee = new EventEmitter();

export const appRouter = trpc
  .router()
  .subscription('onAdd', {
    resolve({ ctx }) {
      // `resolve()` is triggered for each client when they start subscribing `onAdd`

      // return a `Subscription` with a callback which is triggered immediately
      return new trpc.Subscription<Post>((emit) => {
        const onAdd = (data: Post) => {
          // emit data to client
          emit.data(data);
        };

        // trigger `onAdd()` when `add` is triggered in our event emitter
        ee.on('add', onAdd);

        // unsubscribe function when client disconnects or stops subscribing
        return () => {
          ee.off('add', onAdd);
        };
      });
    },
  })
  .mutation('add', {
    input: z.object({
      id: z.string().uuid().optional(),
      text: z.string().min(1),
    }),
    async resolve({ ctx, input }) {
      const post = { ...input }; /* [..] add to db */

      ee.emit('add', post);
      return post;
    },
  });

----------------------------------------

TITLE: Creating tRPC Router with Typed Metadata in JSX
DESCRIPTION: This snippet shows how to create a tRPC router with typed metadata. It defines an interface for the metadata and creates a router instance with the specified Context and Meta types.

LANGUAGE: jsx
CODE:
import * as trpc from '@trpc/server';

// [...]

interface Meta {
  hasAuth: boolean
}

export const appRouter = trpc.router<Context, Meta>();

----------------------------------------

TITLE: Initializing tRPC Client with HTTP Batch Stream Link
DESCRIPTION: Basic setup for creating a tRPC client using httpBatchStreamLink for handling batched HTTP requests with streaming responses.

LANGUAGE: typescript
CODE:
import { createTRPCClient, httpBatchStreamLink } from '@trpc/client';
import type { AppRouter } from '../server';

const client = createTRPCClient<AppRouter>({
  links: [
    httpBatchStreamLink({
      url: 'http://localhost:3000',
    }),
  ],
});

----------------------------------------

TITLE: Installing tRPC Packages with yarn
DESCRIPTION: Command to install tRPC packages and dependencies using yarn. This includes server, client, React integration, and Next.js utilities.

LANGUAGE: bash
CODE:
yarn add @trpc/server @trpc/client @trpc/react react-query@3 @trpc/next

----------------------------------------

TITLE: Using tRPC with Suspense in Client Component
DESCRIPTION: Shows how to use the tRPC suspense query hook in a client component for data fetching.

LANGUAGE: tsx
CODE:
'use client';

import { trpc } from '~/trpc/client';

export function ClientGreeting() {
  const [data] = trpc.hello.useSuspenseQuery();
  return <div>{data.greeting}</div>;
}

----------------------------------------

TITLE: Running tRPC Linter with Automatic Fixes using Bash
DESCRIPTION: This command runs the project's linter and automatically applies fixes to code style issues where possible.

LANGUAGE: bash
CODE:
pnpm lint-fix

----------------------------------------

TITLE: tRPC Error Code Mappings
DESCRIPTION: Definition of tRPC error codes and their mapping to JSON-RPC 2.0 error codes. Includes implementation-specific server errors.

LANGUAGE: typescript
CODE:
export const TRPC_ERROR_CODES_BY_KEY = {
  PARSE_ERROR: -32700,
  BAD_REQUEST: -32600,
  INTERNAL_SERVER_ERROR: -32603,
  UNAUTHORIZED: -32001,
  FORBIDDEN: -32003,
  NOT_FOUND: -32004,
  METHOD_NOT_SUPPORTED: -32005,
  TIMEOUT: -32008,
  CONFLICT: -32009,
  PRECONDITION_FAILED: -32012,
  PAYLOAD_TOO_LARGE: -32013,
  CLIENT_CLOSED_REQUEST: -32099,
} as const;

----------------------------------------

TITLE: Implementing Per-Route Authentication with tRPC Metadata in TSX
DESCRIPTION: This example demonstrates how to use route metadata for per-route authentication settings in tRPC. It creates a router with middleware that checks for authentication based on the metadata, and defines two routes with different authentication requirements.

LANGUAGE: tsx
CODE:
import * as trpc from '@trpc/server';

// [...]

interface Meta {
  hasAuth: boolean;
}

export const appRouter = trpc
  .router<Context, Meta>()
  .middleware(async ({ meta, next, ctx }) => {
    // only check authorization if enabled
    if (meta?.hasAuth && !ctx.user) {
      throw new TRPCError({ code: 'UNAUTHORIZED' });
    }
    return next();
  })
  .query('hello', {
    meta: {
      hasAuth: false,
    },
    resolve({ ctx }) {
      return {
        greeting: `hello world`,
      };
    },
  })
  .query('protected-hello', {
    meta: {
      hasAuth: true,
    },
    resolve({ ctx }) {
      return {
        greeting: `hello world`,
      };
    },
  });

----------------------------------------

TITLE: Configuring Per-Request Abort Behavior in tRPC React Query
DESCRIPTION: This snippet shows how to enable request abortion for a specific query in a React component. It uses the 'trpc' option in the query configuration to set 'abortOnUnmount' to true for that particular query.

LANGUAGE: typescript
CODE:
// @filename: pages/posts.tsx
declare const useRouter: any;
// ---cut---
import { trpc } from '../utils/trpc';

function PostViewPage() {
  const { query } = useRouter();
  const postQuery = trpc.post.byId.useQuery(
    { id: query.id },
    { trpc: { abortOnUnmount: true } }
  );

  // ...
}

----------------------------------------

TITLE: Configuring Per-Request Abort Behavior in tRPC React Query
DESCRIPTION: This snippet shows how to enable request abortion for a specific query in a React component. It uses the 'trpc' option in the query configuration to set 'abortOnUnmount' to true for that particular query.

LANGUAGE: typescript
CODE:
// @filename: pages/posts.tsx
declare const useRouter: any;
// ---cut---
import { trpc } from '../utils/trpc';

function PostViewPage() {
  const { query } = useRouter();
  const postQuery = trpc.post.byId.useQuery(
    { id: query.id },
    { trpc: { abortOnUnmount: true } }
  );

  // ...
}

----------------------------------------

TITLE: Installing Next.js Prisma Starter with tRPC
DESCRIPTION: Command to create a new Next.js application with tRPC and Prisma using create-next-app.

LANGUAGE: bash
CODE:
yarn create next-app --example https://github.com/trpc/trpc --example-path examples/next-prisma-starter trpc-prisma-starter

----------------------------------------

TITLE: Component-Level Query Prefetching
DESCRIPTION: Shows how to implement component-level prefetching using usePrefetchQuery hook for optimal performance.

LANGUAGE: tsx
CODE:
import { trpc } from '../utils/trpc';

function PostViewPage(props: { postId: string }) {
  trpc.post.byId.usePrefetchQuery({ id: props.postId });

  return (
    <Suspense>
      <PostView postId={props.postId} />
    </Suspense>
  );
}

----------------------------------------

TITLE: Installing and Running tRPC Development Server
DESCRIPTION: Commands for installing project dependencies and starting the development server. Uses pnpm as the package manager for faster and more efficient dependency management.

LANGUAGE: bash
CODE:
pnpm install
pnpm dev

----------------------------------------

TITLE: Importing AppRouter Type for tRPC Client in TypeScript
DESCRIPTION: Demonstrates how to import the AppRouter type from the server-side tRPC file into the client. This enables type-safe API calls without code generation.

LANGUAGE: typescript
CODE:
import type { AppRouter } from '../path/to/server/trpc';

----------------------------------------

TITLE: Configuring Global Abort Behavior in tRPC React Client
DESCRIPTION: This snippet demonstrates how to configure the tRPC React client to abort all requests on component unmount. It sets the 'abortOnUnmount' option to true when creating the tRPC client.

LANGUAGE: typescript
CODE:
// @filename: utils.ts
// @noErrors
import { createTRPCReact } from '@trpc/react-query';

export const trpc = createTRPCReact<AppRouter>({
  abortOnUnmount: true,
});

trpc.createClient({
  // ...
});

----------------------------------------

TITLE: Creating Context from Request Headers in tRPC (TypeScript)
DESCRIPTION: This snippet shows how to create a context function that extracts user information from request headers. It decodes and verifies a JWT token to authenticate the user.

LANGUAGE: typescript
CODE:
import * as trpc from '@trpc/server';
import { inferAsyncReturnType } from '@trpc/server';
import * as trpcNext from '@trpc/server/adapters/next';
import { decodeAndVerifyJwtToken } from './somewhere/in/your/app/utils';

export async function createContext({
  req,
  res,
}: trpcNext.CreateNextContextOptions) {
  // Create your context based on the request object
  // Will be available as `ctx` in all your resolvers

  // This is just an example of something you'd might want to do in your ctx fn
  async function getUserFromHeader() {
    if (req.headers.authorization) {
      const user = await decodeAndVerifyJwtToken(
        req.headers.authorization.split(' ')[1],
      );
      return user;
    }
    return null;
  }
  const user = await getUserFromHeader();

  return {
    user,
  };
}
type Context = inferAsyncReturnType<typeof createContext>;

// [..] Define API handler and app router

----------------------------------------

TITLE: Defining a tRPC Router with a Query Endpoint in TypeScript
DESCRIPTION: This snippet demonstrates how to create a tRPC router with a 'hello' query endpoint that takes an optional string input and returns a greeting. It uses zod for input validation.

LANGUAGE: tsx
CODE:
const appRouter = trpc.router().query('hello', {
  input: z.string().optional(),
  resolve: ({ input }) => {
    return {
      text: `hello ${input ?? 'world'}`,
    };
  },
});

export type AppRouter = typeof appRouter;

----------------------------------------

TITLE: Configuring Global Abort Behavior in tRPC React Client
DESCRIPTION: This snippet demonstrates how to configure the tRPC React client to abort all requests on component unmount. It sets the 'abortOnUnmount' option to true when creating the tRPC client.

LANGUAGE: typescript
CODE:
// @filename: utils.ts
// @noErrors
import { createTRPCReact } from '@trpc/react-query';

export const trpc = createTRPCReact<AppRouter>({
  abortOnUnmount: true,
});

trpc.createClient({
  // ...
});

----------------------------------------

TITLE: Authenticated WebSocket Client Configuration
DESCRIPTION: Client-side setup with authentication token in connection parameters

LANGUAGE: typescript
CODE:
import { createTRPCClient, createWSClient, wsLink } from '@trpc/client';
import type { AppRouter } from '~/server/routers/_app';

const wsClient = createWSClient({
  url: `ws://localhost:3000`,

  connectionParams: async () => {
    return {
      token: 'supersecret',
    };
  },
});
export const trpc = createTRPCClient<AppRouter>({
  links: [wsLink({ client: wsClient, transformer: superjson })],
});

----------------------------------------

TITLE: Using tRPC Suspense Query Hook
DESCRIPTION: Demonstrates the usage of useSuspenseQuery hook to fetch a post by ID with React Suspense integration.

LANGUAGE: tsx
CODE:
import React from 'react';
import { trpc } from '../utils/trpc';

function PostView() {
  const [post, postQuery] = trpc.post.byId.useSuspenseQuery({ id: '1' });

  return <>{/* ... */}</>;
}

----------------------------------------

TITLE: Installing SuperJSON for tRPC Data Transformation
DESCRIPTION: Command to install SuperJSON package as a dependency for data transformation in tRPC.

LANGUAGE: bash
CODE:
yarn add superjson

----------------------------------------

TITLE: Handling Authentication Token in tRPC Mutation
DESCRIPTION: This snippet shows how to update an authentication token after a successful login mutation. It demonstrates setting the token variable which can be used in the custom headers configuration.

LANGUAGE: typescript
CODE:
const loginMut = trpc.useMutation(['auth.login'], {
  onSuccess({ accessToken }) {
    token = accessToken;
  },
});

----------------------------------------

TITLE: Creating tRPC Router in Next.js API Route
DESCRIPTION: Implements a basic tRPC router in a Next.js API route file. This router defines a 'hello' query with input validation using Zod and exports the router type and API handler.

LANGUAGE: typescript
CODE:
import * as trpc from '@trpc/server';
import * as trpcNext from '@trpc/server/adapters/next';
import { z } from 'zod';

export const appRouter = trpc.router().query('hello', {
  input: z
    .object({
      text: z.string().nullish(),
    })
    .nullish(),
  resolve({ input }) {
    return {
      greeting: `hello ${input?.text ?? 'world'}`,
    };
  },
});

// export type definition of API
export type AppRouter = typeof appRouter;

// export API handler
export default trpcNext.createNextApiHandler({
  router: appRouter,
  createContext: () => null,
});

----------------------------------------

TITLE: Implementing onError Handler in Next.js API Route
DESCRIPTION: Shows how to implement the onError handler in a Next.js API route to handle or modify errors before sending them to the client.

LANGUAGE: typescript
CODE:
export default trpcNext.createNextApiHandler({
  // ...
  onError(opts) {
    const { error, type, path, input, ctx, req } = opts;
    console.error('Error:', error);
    if (error.code === 'INTERNAL_SERVER_ERROR') {
      // send to bug reporting
    }
  },
});

----------------------------------------

TITLE: Creating tRPC Router with Hello World Procedure
DESCRIPTION: Defines an app router with a 'hello' procedure that takes a text input and returns a greeting.

LANGUAGE: typescript
CODE:
import { z } from 'zod';
import { baseProcedure, createTRPCRouter } from '../init';

export const appRouter = createTRPCRouter({
  hello: baseProcedure
    .input(
      z.object({
        text: z.string(),
      }),
    )
    .query((opts) => {
      return {
        greeting: `hello ${opts.input.text}`,
      };
    }),
});

export type AppRouter = typeof appRouter;

----------------------------------------

TITLE: Configuring tRPC for Vercel Edge Runtime in TypeScript
DESCRIPTION: Sets up a tRPC endpoint for Vercel Edge Runtime using the fetch adapter. This configuration allows a Vercel Edge Function to handle tRPC requests using the defined router and context.

LANGUAGE: typescript
CODE:
import { fetchRequestHandler } from '@trpc/server/adapters/fetch';
import { createContext } from './context';
import { appRouter } from './router';

addEventListener('fetch', (event) => {
  return event.respondWith(
    fetchRequestHandler({
      endpoint: '/trpc',
      req: event.request,
      router: appRouter,
      createContext,
    }),
  );
});

----------------------------------------

TITLE: Implementing Infinite Query with Suspense
DESCRIPTION: Shows how to use useSuspenseInfiniteQuery for paginated post fetching with cursor-based pagination.

LANGUAGE: tsx
CODE:
import React from 'react';
import { trpc } from '../utils/trpc';

function PostView() {
  const [{ pages }, allPostsQuery] = trpc.post.all.useSuspenseInfiniteQuery(
    {},
    {
      getNextPageParam(lastPage) {
        return lastPage.nextCursor;
      },
    },
  );

  const { isFetching, isFetchingNextPage, fetchNextPage, hasNextPage } =
    allPostsQuery;

  return <>{/* ... */}</>;
}

----------------------------------------

TITLE: Using tRPC Queries in React Component (TypeScript)
DESCRIPTION: Example of using tRPC queries in a React component. Two queries are defined: 'postById' and 'relatedPosts', both using the input '1'.

LANGUAGE: typescript
CODE:
export function MyComponent() {
  const post1 = trpc.postById.useQuery('1');
  const relatedPosts = trpc.relatedPosts.useQuery('1');

  return (
    <pre>
      {JSON.stringify(
        {
          post1: post1.data ?? null,
          relatedPosts: relatedPosts.data ?? null,
        },
        null,
        4,
      )}
    </pre>
  );
}

----------------------------------------

TITLE: Using tRPC Hooks in Next.js Page Component
DESCRIPTION: Demonstrates how to use tRPC hooks in a Next.js page component to make API requests. This example queries the 'hello' endpoint and displays the result.

LANGUAGE: tsx
CODE:
import { trpc } from '../utils/trpc';

export default function IndexPage() {
  const hello = trpc.useQuery(['hello', { text: 'client' }]);
  if (!hello.data) {
    return <div>Loading...</div>;
  }
  return (
    <div>
      <p>{hello.data.greeting}</p>
    </div>
  );
}

----------------------------------------

TITLE: Implementing Output Validation for tRPC Subscriptions using Zod
DESCRIPTION: This complex example shows how to implement output validation for tRPC subscriptions using Zod. It defines a custom zAsyncIterable helper to validate the yielded values and return value of the subscription.

LANGUAGE: typescript
CODE:
import type { TrackedEnvelope } from '@trpc/server';
import { isTrackedEnvelope, tracked } from '@trpc/server';
import { z } from 'zod';

function isAsyncIterable<TValue, TReturn = unknown>(
  value: unknown,
): value is AsyncIterable<TValue, TReturn> {
  return !!value && typeof value === 'object' && Symbol.asyncIterator in value;
}
const trackedEnvelopeSchema =
  z.custom<TrackedEnvelope<unknown>>(isTrackedEnvelope);

export function zAsyncIterable<
  TYieldIn,
  TYieldOut,
  TReturnIn = void,
  TReturnOut = void,
  Tracked extends boolean = false,
>(opts: {
  yield: z.ZodType<TYieldIn, any, TYieldOut>;
  return?: z.ZodType<TReturnIn, any, TReturnOut>;
  tracked?: Tracked;
}) {
  return z
    .custom<
      AsyncIterable<
        Tracked extends true ? TrackedEnvelope<TYieldIn> : TYieldIn,
        TReturnIn
      >
    >((val) => isAsyncIterable(val))
    .transform(async function* (iter) {
      const iterator = iter[Symbol.asyncIterator]();

      try {
        let next;
        while ((next = await iterator.next()) && !next.done) {
          if (opts.tracked) {
            const [id, data] = trackedEnvelopeSchema.parse(next.value);
            yield tracked(id, await opts.yield.parseAsync(data));
            continue;
          }
          yield opts.yield.parseAsync(next.value);
        }
        if (opts.return) {
          return await opts.return.parseAsync(next.value);
        }
        return;
      } finally {
        await iterator.return?.();
      }
    }) as z.ZodType<
    AsyncIterable<
      Tracked extends true ? TrackedEnvelope<TYieldIn> : TYieldIn,
      TReturnIn,
      unknown
    >,
    any,
    AsyncIterable<
      Tracked extends true ? TrackedEnvelope<TYieldOut> : TYieldOut,
      TReturnOut,
      unknown
    >
  >;
}

----------------------------------------

TITLE: Configuring tRPC for Deno Oak in TypeScript
DESCRIPTION: Sets up a tRPC endpoint for Deno Oak using the fetch adapter. This configuration allows a Deno Oak server to handle tRPC requests using the defined router and context.

LANGUAGE: typescript
CODE:
import { Application, Router } from 'https://deno.land/x/oak/mod.ts';
import { fetchRequestHandler } from 'npm:@trpc/server/adapters/fetch';
import { createContext } from './context.ts';
import { appRouter } from './router.ts';

const app = new Application();
const router = new Router();

router.all('/trpc/(.*)', async (ctx) => {
  const res = await fetchRequestHandler({
    endpoint: '/trpc',
    req: new Request(ctx.request.url, {
      headers: ctx.request.headers,
      body:
        ctx.request.method !== 'GET' && ctx.request.method !== 'HEAD'
          ? ctx.request.body({ type: 'stream' }).value
          : void 0,
      method: ctx.request.method,
    }),
    router: appRouter,
    createContext,
  });

  ctx.response.status = res.status;
  ctx.response.headers = res.headers;
  ctx.response.body = res.body;
});

app.use(router.routes());
app.use(router.allowedMethods());

await app.listen({ port: 3000 });

----------------------------------------

TITLE: Next.js Integration with tRPC SSG Helpers
DESCRIPTION: Shows a complete example of using SSG helpers in a Next.js page component with getServerSideProps. Demonstrates prefetching data and hydrating the client-side state with server-fetched data.

LANGUAGE: typescript
CODE:
import { createSSGHelpers } from '@trpc/react/ssg';
import { GetServerSidePropsContext, InferGetServerSidePropsType } from 'next';
import { createContext, prisma } from 'server/context';
import { appRouter } from 'server/routers/_app';
import superjson from 'superjson';
import { trpc } from 'utils/trpc';

export async function getServerSideProps(
  context: GetServerSidePropsContext<{ id: string }>,
) {
  const ssg = createSSGHelpers({
    router: appRouter,
    ctx: await createContext(),
    transformer: superjson,
  });
  const id = context.params?.id as string;

  /*
   * Prefetching the `post.byId` query here.
   * `prefetchQuery` does not return the result - if you need that, use `fetchQuery` instead.
   */
  await ssg.prefetchQuery('post.byId', {
    id,
  });

  // Make sure to return { props: { trpcState: ssg.dehydrate() } }
  return {
    props: {
      trpcState: ssg.dehydrate(),
      id,
    },
  };
}

export default function PostViewPage(
  props: InferGetServerSidePropsType<typeof getServerSideProps>,
) {
  const { id } = props;

  // This query will be immediately available as it's prefetched.
  const postQuery = trpc.useQuery(['post.byId', { id }]);

  const { data } = postQuery;

  return (
    <>
      <h1>{data.title}</h1>
      <em>Created {data.createdAt.toLocaleDateString()}</em>

      <p>{data.text}</p>

      <h2>Raw data:</h2>
      <pre>{JSON.stringify(data, null, 4)}</pre>
    </>
  );
}

----------------------------------------

TITLE: Installing Next.js Starter with tRPC, Prisma, WebSockets, and Subscriptions (pnpm)
DESCRIPTION: Command to create a new Next.js application using tRPC, Prisma, WebSockets, and subscriptions with pnpm. This starter includes ESLint and next-auth.

LANGUAGE: sh
CODE:
pnpx create-next-app --example https://github.com/trpc/trpc --example-path examples/next-prisma-websockets-starter trpc-prisma-websockets-starter

----------------------------------------

TITLE: Defining tRPC Router with Multiple Procedures (TypeScript)
DESCRIPTION: Example of a tRPC router with two procedures: 'postById' and 'relatedPosts'. Both are queries that take a string input and return post data.

LANGUAGE: typescript
CODE:
export const appRouter = t.router({
  postById: t.procedure.input(String).query(async (opts) => {
    const post = await opts.ctx.post.findUnique({
      where: { id: opts.input },
    });
    return post;
  }),
  relatedPosts: t.procedure.input(String).query(async (opts) => {
    const posts = await opts.ctx.findRelatedPostsById(opts.input);
    return posts;
  }),
});

----------------------------------------

TITLE: Adding Context and User Authentication to tRPC Server Actions
DESCRIPTION: Extends the base setup by adding user context and authentication through middleware. Includes user injection and protected action creation.

LANGUAGE: typescript
CODE:
export const serverActionProcedure = t.procedure
  .experimental_caller(
    experimental_nextAppDirCaller({
      pathExtractor: ({ meta }) => (meta as Meta).span,
    }),
  )
  .use(async (opts) => {
    // Inject user into context
    const user = await currentUser();
    return opts.next({ ctx: { user } });
  });

export const protectedAction = serverActionProcedure.use((opts) => {
  if (!opts.ctx.user) {
    throw new TRPCError({
      code: 'UNAUTHORIZED',
    });
  }

  return opts.next({
    ctx: {
      ...opts.ctx,
      user: opts.ctx.user,
    },
  });
});

----------------------------------------

TITLE: Installing tRPC Server Dependencies
DESCRIPTION: Commands for installing the @trpc/server package using different package managers including npm, yarn, pnpm, and bun.

LANGUAGE: bash
CODE:
# npm
npm install @trpc/server@next

# Yarn
yarn add @trpc/server@next

# pnpm
pnpm add @trpc/server@next

# Bun
bun add @trpc/server@next

----------------------------------------

TITLE: Implementing Server-Side Subscription Termination in tRPC
DESCRIPTION: This example shows how to stop a subscription from the server side by returning from the generator function when a certain condition is met.

LANGUAGE: typescript
CODE:
import { publicProcedure, router } from '../trpc';

export const subRouter = router({
  onPostAdd: publicProcedure
    .input(
      z.object({
        lastEventId: z.string().coerce.number().min(0).optional(),
      }),
    )
    .subscription(async function* (opts) {
      let index = opts.input.lastEventId ?? 0;
      while (true) {
        const idx = index++;
        if (idx > 100) {
          // With this, the subscription will stop and the client will disconnect
          return;
        }
        await new Promise((resolve) => setTimeout(resolve, 10));
      }
    }
  ),
});

----------------------------------------

TITLE: Configuring tRPC for Astro in TypeScript
DESCRIPTION: Sets up a tRPC endpoint for Astro using the fetch adapter. This configuration allows Astro to handle tRPC requests using the defined router and context.

LANGUAGE: typescript
CODE:
import { fetchRequestHandler } from '@trpc/server/adapters/fetch';
import type { APIRoute } from 'astro';
import { createContext } from '../../server/context';
import { appRouter } from '../../server/router';

export const ALL: APIRoute = (opts) => {
  return fetchRequestHandler({
    endpoint: '/trpc',
    req: opts.request,
    router: appRouter,
    createContext,
  });
};

----------------------------------------

TITLE: Initializing SSG Helpers in tRPC
DESCRIPTION: Demonstrates how to initialize the createSSGHelpers utility with a tRPC router, context, and optional transformer. Returns functions for prefetching queries and managing server-side state.

LANGUAGE: typescript
CODE:
import { createSSGHelpers } from '@trpc/react/ssg';

const {
  prefetchQuery,
  prefetchInfiniteQuery,
  fetchQuery,
  fetchInfiniteQuery,
  dehydrate,
  queryClient,
} = await createSSGHelpers({
  router: appRouter,
  ctx: createContext,
  transformer: superjson, // optional - adds superjson serialization
});

----------------------------------------

TITLE: Using Non-Batched Query in React Component with tRPC
DESCRIPTION: This example demonstrates how to use a non-batched tRPC query within a React component by setting the skipBatch context property.

LANGUAGE: tsx
CODE:
export function MyComponent() {
  const postsQuery = proxy.posts.useQuery(undefined, {
    trpc: {
      context: {
        skipBatch: true,
      },
    }
  });
  return (
    <pre>{JSON.stringify(postsQuery.data ?? null, null, 4)}</pre>
  )
})

----------------------------------------

TITLE: Defining Nested Procedures in tRPC Router (TypeScript)
DESCRIPTION: Example of defining nested procedures in a tRPC router. The 'post.byId' procedure is defined as a public query that takes a string input.

LANGUAGE: typescript
CODE:
export const appRouter = router({
  post: router({
    byId: publicProcedure.input(String).query(async (opts) => {
      // [...]
    }),
  }),
});

----------------------------------------

TITLE: Complex TypeScript Types for tRPC Procedure Decoration
DESCRIPTION: TypeScript types used for decorating tRPC procedures with React Query utilities.

LANGUAGE: ts
CODE:
type DecorateProcedure<
  TRouter extends AnyRouter,
  TProcedure extends Procedure<any>,
  TProcedure extends AnyQueryProcedure,
> = {
  /**
   * @see https://tanstack.com/query/v4/docs/framework/react/guides/query-invalidation
   */
  invalidate(
    input?: inferProcedureInput<TProcedure>,
    filters?: InvalidateQueryFilters,
    options?: InvalidateOptions,
  ): Promise<void>;
  // ... and so on for all the other React Query utilities
};

export type DecoratedProcedureUtilsRecord<TRouter extends AnyRouter> =
  OmitNeverKeys<{
    [TKey in keyof TRouter['_def']['record']]: TRouter['_def']['record'][TKey] extends LegacyV9ProcedureTag
      ? never
      : TRouter['_def']['record'][TKey] extends AnyRouter
        ? DecoratedProcedureUtilsRecord<TRouter['_def']['record'][TKey]>
        : TRouter['_def']['record'][TKey] extends AnyQueryProcedure
          ? DecorateProcedure<TRouter, TRouter['_def']['record'][TKey]>
          : never;
  }>;

----------------------------------------

TITLE: Installing tRPC Server Dependencies
DESCRIPTION: Command to install the required tRPC server package using yarn package manager.

LANGUAGE: bash
CODE:
yarn add @trpc/server

----------------------------------------

TITLE: Installing tRPC Server Dependencies
DESCRIPTION: Command to install the required tRPC server package using yarn package manager.

LANGUAGE: bash
CODE:
yarn add @trpc/server

----------------------------------------

TITLE: Handling tRPC Errors in React Component
DESCRIPTION: Shows how to handle custom formatted errors in a React component using tRPC's useMutation hook. Demonstrates accessing and displaying Zod validation errors.

LANGUAGE: tsx
CODE:
export function MyComponent() {
  const mutation = trpc.addPost.useMutation();

  useEffect(() => {
    mutation.mutate({ title: 'example' });
  }, []);

  if (mutation.error?.data?.zodError) {
    // zodError will be inferred
    return (
      <pre>Error: {JSON.stringify(mutation.error.data.zodError, null, 2)}</pre>
    );
  }
  return <>[...]</>;
}

----------------------------------------

TITLE: Configuring VSCode Settings for tRPC TypeScript Integration
DESCRIPTION: VSCode configuration settings to ensure proper TypeScript version alignment between the editor and project dependencies. These settings should be added to the project's .vscode/settings.json file.

LANGUAGE: json
CODE:
{
  "typescript.tsdk": "node_modules/typescript/lib",
  "typescript.enablePromptUseWorkspaceTsdk": true
}

----------------------------------------

TITLE: Implementing SSG with tRPC in Next.js Page Component
DESCRIPTION: Example of a Next.js page component implementing Static Site Generation with tRPC. Shows how to fetch data using getStaticProps and getStaticPaths, with server-side helpers for data prefetching and dehydration.

LANGUAGE: tsx
CODE:
import { createServerSideHelpers } from '@trpc/react-query/server';
import { prisma } from '~/server/context';
import { appRouter } from '~/server/routers/_app';
import { trpc } from '~/utils/trpc';
import {
  GetStaticPaths,
  GetStaticPropsContext,
  InferGetStaticPropsType,
} from 'next';
import superjson from 'superjson';

export async function getStaticProps(
  context: GetStaticPropsContext<{ id: string }>,
) {
  const helpers = createServerSideHelpers({
    router: appRouter,
    ctx: {},
    transformer: superjson, // optional - adds superjson serialization
  });
  const id = context.params?.id as string;

  // prefetch `post.byId`
  await helpers.post.byId.prefetch({ id });

  return {
    props: {
      trpcState: helpers.dehydrate(),
      id,
    },
    revalidate: 1,
  };
}

export const getStaticPaths: GetStaticPaths = async () => {
  const posts = await prisma.post.findMany({
    select: {
      id: true,
    },
  });

  return {
    paths: posts.map((post) => ({
      params: {
        id: post.id,
      },
    })),
    fallback: 'blocking',
  };
};

export default function PostViewPage(
  props: InferGetStaticPropsType<typeof getStaticProps>,
) {
  const { id } = props;
  const postQuery = trpc.post.byId.useQuery({ id });

  if (postQuery.status !== 'success') {
    return <>Loading...</>;
  }
  const { data } = postQuery;
  return (
    <>
      <h1>{data.title}</h1>
      <em>Created {data.createdAt.toLocaleDateString('en-us')}</em>

      <p>{data.text}</p>

      <h2>Raw data:</h2>
      <pre>{JSON.stringify(data, null, 4)}</pre>
    </>
  );
}

----------------------------------------

TITLE: Creating Flat Namespace User Router in tRPC
DESCRIPTION: This snippet demonstrates the creation of a user router with a flat namespace in tRPC. It includes a procedure for listing users, prefixed with 'user'.

LANGUAGE: typescript
CODE:
import { router, publicProcedure } from '../trpc';
import { z } from 'zod';
export const userRouter = router({
  userList: publicProcedure.query(() => {
    // [..]
    return [];
  }),
});

----------------------------------------

TITLE: Handling tRPC Client Errors with Type Safety
DESCRIPTION: Shows how to create a type guard for tRPC client errors and properly handle them with full type inference in try-catch blocks.

LANGUAGE: typescript
CODE:
import { TRPCClientError } from '@trpc/client';
import type { AppRouter } from './server';
import { trpc } from './trpc';

export function isTRPCClientError(
  cause: unknown,
): cause is TRPCClientError<AppRouter> {
  return cause instanceof TRPCClientError;
}

async function main() {
  try {
    await trpc.post.byId.query('1');
  } catch (cause) {
    if (isTRPCClientError(cause)) {
      console.log('data', cause.data);
    } else {
      // [...]
    }
  }
}

main();

----------------------------------------

TITLE: Old tRPC Router Types in TypeScript
DESCRIPTION: Previous TypeScript types for tRPC v10 routers and v9 to v10 migration.

LANGUAGE: ts
CODE:
export type V10Router<TProcedureRecord> = {
  record: TProcedureRecord;
};

// convert a v9 interop router to a v10 router
export type MigrateV9Router<TV9Router extends V9Router> = V10Router<{
  [TKey in keyof TV9Router['procedures']]: MigrateProcedure<
    TV9Router['procedures'][TKey]
  > &
    LegacyV9ProcedureTag;
}>;

----------------------------------------

TITLE: HTTP Handler Context Integration
DESCRIPTION: Shows how to integrate context with an HTTP handler for tRPC server setup.

LANGUAGE: typescript
CODE:
import { createHTTPHandler } from '@trpc/server/adapters/standalone';
import { createContext } from './context';
import { appRouter } from './router';

const handler = createHTTPHandler({
  router: appRouter,
  createContext,
});

----------------------------------------

TITLE: Initializing tRPC Client with HTTP Batch Link in TypeScript
DESCRIPTION: This snippet demonstrates how to create a tRPC client using createTRPCClient method and configure it with an HTTP batch link. It includes setting the API URL and adding custom headers for authorization.

LANGUAGE: typescript
CODE:
import { createTRPCClient, httpBatchLink } from '@trpc/client';
import type { AppRouter } from '../path/to/server/trpc';

const client = createTRPCClient<AppRouter>({
  links: [
    httpBatchLink({
      url: 'http://localhost:3000/trpc',

      // You can pass any HTTP headers you wish here
      async headers() {
        return {
          authorization: getAuthCookie(),
        };
      },
    }),
  ],
});

----------------------------------------

TITLE: Adding tRPC Subscription to Router in TypeScript
DESCRIPTION: Example of adding a subscription endpoint to the tRPC router for real-time updates.

LANGUAGE: typescript
CODE:
export const appRouter = trpc
  .router()
  // .query(...)
  // .mutation(...)
  .subscription('randomNumber', {
    resolve() {
      return new Subscription<{ randomNumber: number }>((emit) => {
        const timer = setInterval(() => {
          emit.data({ randomNumber: Math.random() });
        }, 1000);
        return () => {
          clearInterval(timer);
        };
      });
    },
  });

----------------------------------------

TITLE: Setting Up Fastify Example in Development Mode
DESCRIPTION: Commands to navigate to the Fastify example directory, install its dependencies, and run in development mode

LANGUAGE: bash
CODE:
cd ./examples/fastify-server
yarn
yarn dev

----------------------------------------

TITLE: Configuring tRPC HTTP Handler with Method Override (TypeScript)
DESCRIPTION: Example of configuring a tRPC HTTP handler to allow method override. This enables clients to specify custom HTTP methods for queries and mutations.

LANGUAGE: typescript
CODE:
const handler = createHTTPHandler({
  router: router,
  allowMethodOverride: true,
});

----------------------------------------

TITLE: Creating tRPC hooks and providers in TypeScript
DESCRIPTION: Sets up a utility file that exports tRPC hooks and providers for use in a React application. Requires importing the AppRouter type from the server.

LANGUAGE: typescript
CODE:
import { createTRPCReact } from '@trpc/react-query';
import type { AppRouter } from './server';

export const trpc = createTRPCReact<AppRouter>();

----------------------------------------

TITLE: Setting up Standalone tRPC Server in TypeScript
DESCRIPTION: This code sets up a standalone tRPC HTTP server using the createHTTPServer function. It listens on port 2022 and uses the previously defined appRouter.

LANGUAGE: typescript
CODE:
import { initTRPC } from '@trpc/server';
import { createHTTPServer } from '@trpc/server/adapters/standalone';
import { appRouter } from './appRouter.ts';

createHTTPServer({
  router: appRouter,
  createContext() {
    console.log('context 3');
    return {};
  },
  // basePath: '/trpc/', // optional, defaults to '/'
}).listen(2022);

----------------------------------------

TITLE: Initializing tRPC Router with Procedures
DESCRIPTION: Sets up a basic tRPC router with procedures for listing posts, getting posts by ID, and creating new posts. Uses Zod for input validation and defines procedure handlers with mock database calls.

LANGUAGE: typescript
CODE:
import { initTRPC } from '@trpc/server';
import { z } from "zod";

const t = initTRPC.create();

const appRouter = t.router({
  post: t.router({
    list: t.procedure
      .query(() => {
        // imaginary db call
        return [{ id: 1, title: 'tRPC is the best!' }];
    }),
    byId: t.procedure
      .input(z.string())
      .query((opts) => {
        // imaginary db call
        return { id: 1, title: 'tRPC is the best!' };
    }),
    create: t.procedure
      .input(z.object({ title: z.string(), text: z.string(), }))
      .mutation((opts) => {
        // imaginary db call
        return { id: 1, ...opts.input };
    }),
  }),
});

export type AppRouter = typeof appRouter;

----------------------------------------

TITLE: Setting up Fastify Server with tRPC in TypeScript
DESCRIPTION: Code to create a Fastify server and integrate it with tRPC using the fastifyTRPCPlugin.

LANGUAGE: typescript
CODE:
import { fastifyTRPCPlugin } from '@trpc/server/adapters/fastify';
import fastify from 'fastify';
import { createContext } from './context';
import { appRouter } from './router';

const server = fastify({
  maxParamLength: 5000,
});

server.register(fastifyTRPCPlugin, {
  prefix: '/trpc',
  trpcOptions: { router: appRouter, createContext },
});

(async () => {
  try {
    await server.listen({ port: 3000 });
  } catch (err) {
    server.log.error(err);
    process.exit(1);
  }
})();

----------------------------------------

TITLE: Installing tRPC Dependencies for Next.js
DESCRIPTION: Command line instructions for installing required tRPC packages and dependencies using different package managers (npm, yarn, pnpm, bun).

LANGUAGE: bash
CODE:
# npm
npm install @trpc/next@next @trpc/react-query@next @tanstack/react-query

# Yarn
yarn add @trpc/next@next @trpc/react-query@next @tanstack/react-query

# pnpm
pnpm add @trpc/next@next @trpc/react-query@next @tanstack/react-query

# Bun
bun add @trpc/next@next @trpc/react-query@next @tanstack/react-query

----------------------------------------

TITLE: Implementing Request Abortion in tRPC Client
DESCRIPTION: Demonstrates how to set up and use AbortController with tRPC client procedures. Shows the creation of a tRPC client, initializing an AbortController, passing the abort signal to a query, and aborting the request. Uses the standard browser AbortController API for request cancellation.

LANGUAGE: typescript
CODE:
// @filename: server.ts
import { createTRPCClient, httpBatchLink } from '@trpc/client';
// @noErrors
import type { AppRouter } from './server.ts';

const proxy = createTRPCClient<AppRouter>({
  links: [
    httpBatchLink({
      url: 'http://localhost:3000/trpc',
    }),
  ],
});

// 1. Create an AbortController instance - this is a standard javascript API
const ac = new AbortController();

// 2. Pass the signal to a query or mutation
const query = proxy.userById.query('id_bilbo', { signal: ac.signal });

// 3. Cancel the request if needed
ac.abort();

----------------------------------------

TITLE: Defining tRPC Router in TypeScript
DESCRIPTION: This snippet demonstrates how to define a tRPC router with a post router containing an 'all' query procedure.

LANGUAGE: typescript
CODE:
import { initTRPC } from '@trpc/server';
import { z } from 'zod';

const t = initTRPC.create();

const appRouter = t.router({
  post: t.router({
    all: t.procedure.query(() => {
      return {
        posts: [
          { id: 1, title: 'everlong' },
          { id: 2, title: 'After Dark' },
        ],
      };
    }),
  }),
});

export type AppRouter = typeof appRouter;

----------------------------------------

TITLE: Defining tRPC Router with Queries
DESCRIPTION: Example of defining a tRPC router with two query procedures: 'postById' and 'relatedPosts'. Shows how to set up query handlers with input validation and database interactions.

LANGUAGE: tsx
CODE:
export const appRouter = trpc
  .router<Context>()
  .query('postById', {
    input: String,
    async resolve({ input, ctx }) {
      const post = await ctx.post.findUnique({
        where: { id: input },
      });
      return post;
    },
  })
  .query('relatedPosts', {
    input: String,
    async resolve({ ctx, input }) {
      const posts = await ctx.findRelatedPostsById(input);
      return posts;
    },
  });

----------------------------------------

TITLE: Example Error Response in JSON
DESCRIPTION: Demonstrates the structure of an error response in tRPC, including message, code, and additional data.

LANGUAGE: json
CODE:
{
  "id": null,
  "error": {
    "message": "\"password\" must be at least 4 characters",
    "code": -32600,
    "data": {
      "code": "BAD_REQUEST",
      "httpStatus": 400,
      "stack": "...",
      "path": "user.changepassword"
    }
  }
}

----------------------------------------

TITLE: Example Error Response in JSON
DESCRIPTION: Demonstrates the structure of an error response in tRPC, including message, code, and additional data.

LANGUAGE: json
CODE:
{
  "id": null,
  "error": {
    "message": "\"password\" must be at least 4 characters",
    "code": -32600,
    "data": {
      "code": "BAD_REQUEST",
      "httpStatus": 400,
      "stack": "...",
      "path": "user.changepassword"
    }
  }
}

----------------------------------------

TITLE: Creating tRPC Context
DESCRIPTION: Implementation of request context creation for tRPC with Fastify, including user information from headers.

LANGUAGE: typescript
CODE:
import { CreateFastifyContextOptions } from '@trpc/server/adapters/fastify';

export function createContext({ req, res }: CreateFastifyContextOptions) {
  const user = { name: req.headers.username ?? 'anonymous' };

  return { req, res, user };
}

export type Context = Awaited<ReturnType<typeof createContext>>;

----------------------------------------

TITLE: Implementing Request Abortion in tRPC Client
DESCRIPTION: Demonstrates how to set up and use AbortController with tRPC client procedures. Shows the creation of a tRPC client, initializing an AbortController, passing the abort signal to a query, and aborting the request. Uses the standard browser AbortController API for request cancellation.

LANGUAGE: typescript
CODE:
// @filename: server.ts
import { createTRPCClient, httpBatchLink } from '@trpc/client';
// @noErrors
import type { AppRouter } from './server.ts';

const proxy = createTRPCClient<AppRouter>({
  links: [
    httpBatchLink({
      url: 'http://localhost:3000/trpc',
    }),
  ],
});

// 1. Create an AbortController instance - this is a standard javascript API
const ac = new AbortController();

// 2. Pass the signal to a query or mutation
const query = proxy.userById.query('id_bilbo', { signal: ac.signal });

// 3. Cancel the request if needed
ac.abort();

----------------------------------------

TITLE: Implementing Output Validation with Zod in tRPC
DESCRIPTION: Example of using Zod schema validation to validate query output in a tRPC router. The output validator ensures the response contains a greeting string property.

LANGUAGE: tsx
CODE:
import * as trpc from '@trpc/server';
import { z } from 'zod';

// [...]

export const appRouter = trpc.router<Context>().query('hello', {
  output: z.object({
    greeting: z.string(),
  }),
  // expects return type of { greeting: string }
  resolve() {
    return {
      greeting: 'hello!',
    };
  },
});

export type AppRouter = typeof appRouter;

----------------------------------------

TITLE: Running Development Tools for TodoMVC Project
DESCRIPTION: Command to run Prisma Studio and Next.js development server simultaneously using the dx script defined in package.json.

LANGUAGE: bash
CODE:
pnpm dx # runs prisma studio + next

----------------------------------------

TITLE: Implementing tRPC Data Fetching in React Component
DESCRIPTION: Demonstrates using tRPC hooks for querying and mutating data in a React component with type safety.

LANGUAGE: tsx
CODE:
import React from "react";
import { trpc } from '../utils/trpc';

export default function IndexPage() {
  const userQuery = trpc.getUser.useQuery({ id: 'id_bilbo' });
  const userCreator = trpc.createUser.useMutation();

  return (
    <div>
      <p>{userQuery.data?.name}</p>

      <button onClick={() => userCreator.mutate({ name: 'Frodo' })}>
        Create Frodo
      </button>
    </div>
  );
}

----------------------------------------

TITLE: Adding Mutation Procedure to tRPC Router in TypeScript
DESCRIPTION: Adds a 'userCreate' mutation procedure to create a new user, with input validation using Zod.

LANGUAGE: typescript
CODE:
const appRouter = router({
  // ...
  userCreate: publicProcedure
    .input(z.object({ name: z.string() }))
    .mutation(async (opts) => {
      const { input } = opts;
      const user = await db.user.create(input);
      return user;
    }),
});

----------------------------------------

TITLE: Configuring HTTP Link Without Batching
DESCRIPTION: Examples of replacing httpBatchLink with httpLink to disable batching in both standard tRPC client and Next.js configurations.

LANGUAGE: typescript
CODE:
import { createTRPCClient, httpLink } from '@trpc/client';
import type { AppRouter } from '../server';

const client = createTRPCClient<AppRouter>({
  links: [
    httpLink({
      url: 'http://localhost:3000',
    }),
  ],
});

----------------------------------------

TITLE: Creating Subscription Options with tRPC in TypeScript/React
DESCRIPTION: Demonstrates how to create subscription options using tRPC's subscriptionOptions method. It shows how to handle subscription events like onStarted, onData, and onError, and manage subscription state.

LANGUAGE: tsx
CODE:
function SubscriptionExample() {
  const trpc = useTRPC();
  const subscription = useSubscription(
    trpc.path.to.subscription.subscriptionOptions(
      {
        /** input */
      },
      {
        enabled: true,
        onStarted: () => {
          // do something when the subscription is started
        },
        onData: (data) => {
          // you can handle the data here
        },
        onError: (error) => {
          // you can handle the error here
        },
        onConnectionStateChange: (state) => {
          // you can handle the connection state here
        },
      },
    ),
  );

  // Or you can handle the state here
  subscription.data; // The lastly received data
  subscription.error; // The lastly received error

  /**
   * The current status of the subscription.
   * Will be one of: `'idle'`, `'connecting'`, `'pending'`, or `'error'`.
   *
   * - `idle`: subscription is disabled or ended
   * - `connecting`: trying to establish a connection
   * - `pending`: connected to the server, receiving data
   * - `error`: an error occurred and the subscription is stopped
   */
  subscription.status;

  // Reset the subscription (if you have an error etc)
  subscription.reset();

  return <>{/* ... */}</>;
}

----------------------------------------

TITLE: Implementing Logging Middleware in tRPC Router
DESCRIPTION: This example shows how to add a logging middleware to a tRPC router. It logs the timing for each query, including the path, type, and duration.

LANGUAGE: typescript
CODE:
trpc
  .router<Context>()
  .middleware(async ({ path, type, next }) => {
    const start = Date.now();
    const result = await next();
    const durationMs = Date.now() - start;
    result.ok
      ? logMock('OK request timing:', { path, type, durationMs })
      : logMock('Non-OK request timing', { path, type, durationMs });

    return result;
  })
  .query('foo', {
    resolve() {
      return 'bar';
    },
  })
  .query('abc', {
    resolve() {
      return 'def';
    },
  });

----------------------------------------

TITLE: Building and Starting React tRPC Example in Production Mode
DESCRIPTION: These commands build the React tRPC project for production and start the application in production mode. This process optimizes the code for performance.

LANGUAGE: bash
CODE:
npm run build
npm run start

----------------------------------------

TITLE: Defining tRPC Server Router in TypeScript
DESCRIPTION: Sets up a basic tRPC server router with procedures for listing, retrieving, and creating posts. This serves as the foundation for type inference examples.

LANGUAGE: typescript
CODE:
import { initTRPC } from '@trpc/server';
import { z } from "zod";

const t = initTRPC.create();

const appRouter = t.router({
  post: t.router({
    list: t.procedure
      .query(() => {
        // imaginary db call
        return [{ id: 1, title: 'tRPC is the best!' }];
    }),
    byId: t.procedure
      .input(z.string())
      .query(({ input }) => {
        // imaginary db call
        return { id: 1, title: 'tRPC is the best!' };
    }),
    create: t.procedure
      .input(z.object({ title: z.string(), text: z.string(), }))
      .mutation(({ input }) => {
        // imaginary db call
        return { id: 1, ...input };
    }),
  }),
});

export type AppRouter = typeof appRouter;

----------------------------------------

TITLE: Adding Query and Mutation Endpoints to tRPC Router in TypeScript
DESCRIPTION: Extends the router with both a query ('getUser') and a mutation ('createUser') endpoint. Uses Zod for input validation in the mutation.

LANGUAGE: typescript
CODE:
import * as trpc from '@trpc/server';
import { z } from 'zod';

const appRouter = trpc
  .router()
  .query('getUser', {
    input: (val: unknown) => {
      if (typeof val === 'string') return val;
      throw new Error(`Invalid input: ${typeof val}`);
    },
    async resolve(req) {
      req.input; // string
      return { id: req.input, name: 'Bilbo' };
    },
  })
  .mutation('createUser', {
    // validate input with Zod
    input: z.object({ name: z.string().min(5) }),
    async resolve(req) {
      // use your ORM of choice
      return await UserModel.create({
        data: req.input,
      });
    },
  });

export type AppRouter = typeof appRouter;

----------------------------------------

TITLE: Comparing HTTP/REST and RPC API Calls in TypeScript
DESCRIPTION: This snippet demonstrates the difference between making an API call using traditional HTTP/REST approach versus using RPC. It shows how RPC simplifies the process by directly calling a function instead of constructing a URL and parsing the response.

LANGUAGE: typescript
CODE:
// HTTP/REST
const res = await fetch('/api/users/1');
const user = await res.json();

// RPC
const user = await api.users.getById({ id: 1 });

----------------------------------------

TITLE: Installing @trpc/react-query and dependencies
DESCRIPTION: Commands for installing @trpc/react-query and @tanstack/react-query using various package managers.

LANGUAGE: bash
CODE:
# npm
npm install @trpc/react-query@next @tanstack/react-query

# Yarn
yarn add @trpc/react-query@next @tanstack/react-query

# pnpm
pnpm add @trpc/react-query@next @tanstack/react-query

# Bun
bun add @trpc/react-query@next @tanstack/react-query

----------------------------------------

TITLE: Creating Infinite Query Options with tRPC in TypeScript
DESCRIPTION: Shows how to create infinite query options using tRPC's infiniteQueryOptions method. It demonstrates providing input parameters and configuring the getNextPageParam function.

LANGUAGE: typescript
CODE:
const infiniteQueryOptions = trpc.path.to.query.infiniteQueryOptions(
  {
    /** input */
  },
  {
    // Any Tanstack React Query options
    getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
  },
);

----------------------------------------

TITLE: tRPC Router with Superstruct Input Validation
DESCRIPTION: Implementation using Superstruct for input validation with default values and inline documentation support.

LANGUAGE: tsx
CODE:
import * as trpc from '@trpc/server';
import * as t from 'superstruct';

// [...]

export const appRouter = trpc.router<Context>().query('hello', {
  input: t.object({
    /**
     * Also supports inline doc strings when referencing the type.
     */
    text: t.defaulted(t.string(), 'world'),
  }),
  resolve({ input }) {
    return {
      greeting: `hello ${input.text}`,
    };
  },
});

export type AppRouter = typeof appRouter;

----------------------------------------

TITLE: Configuring trpc Client for Cross-Origin Requests with Credentials in TypeScript
DESCRIPTION: This code snippet shows how to create a trpc client that includes credentials in cross-origin requests. It modifies the fetch function used by trpc to add the 'credentials: include' option, enabling cookie sending across different origins.

LANGUAGE: typescript
CODE:
import { createTRPCClient } from '@trpc/client';

const client = createTRPCClient<AppRouter>({
  url: 'YOUR_SERVER_URL',
  fetch(url, options) {
    return fetch(url, {
      ...options,
      credentials: 'include',
    });
  },
});

----------------------------------------

TITLE: Initializing Database Types and Mock Data Store
DESCRIPTION: Sets up type definitions and mock database implementation with basic CRUD operations for a User entity

LANGUAGE: typescript
CODE:
type User = { id: string; name: string };

// Imaginary database
const users: User[] = [];
export const db = {
  user: {
    findMany: async () => users,
    findById: async (id: string) => users.find((user) => user.id === id),
    create: async (data: { name: string }) => {
      const user = { id: String(users.length + 1), ...data };
      users.push(user);
      return user;
    },
  },
};

----------------------------------------

TITLE: Running TRPC Client with Deno
DESCRIPTION: Command to start the TRPC client in a separate terminal using Deno task runner.

LANGUAGE: sh
CODE:
deno task client

----------------------------------------

TITLE: Using tRPC Queries in React Components
DESCRIPTION: Example of using tRPC queries in a React component, including handling loading states and errors, and displaying query results.

LANGUAGE: typescript
CODE:
import { trpc } from '~/utils/trpc';

export function Hello() {
  const { data, error, status } = trpc.greeting.useQuery({
    name: 'tRPC',
  });

  if (error) {
    return <p>{error.message}</p>;
  }

  if (status !== 'success') {
    return <p>Loading...</p>;
  }

  return <div>{data && <p>{data.greeting}</p>}</div>;
}

----------------------------------------

TITLE: Creating tRPC Client without Integration
DESCRIPTION: Demonstrates how to create a vanilla tRPC client without using the React Query integration. This approach requires manual management of query keys.

LANGUAGE: typescript
CODE:
export const trpc = createTRPCClient<AppRouter>({
  links: [httpBatchLink({ url: 'YOUR_API_URL' })],
});

LANGUAGE: tsx
CODE:
function PostList() {
  const { data } = useQuery({
    queryKey: ['posts'],
    queryFn: () => trpc.post.list.query(),
  });
  data; // Post[]

  // ...
}

----------------------------------------

TITLE: Configuring tRPC Mutation Router - TypeScript Server
DESCRIPTION: Demonstrates setting up a tRPC router with a login mutation endpoint. Uses Zod for input validation and defines a mutation that processes user login data.

LANGUAGE: tsx
CODE:
import * as trpc from '@trpc/server';
import { z } from 'zod';

export const appRouter = trpc.router()
  // Create procedure at path 'login'
  // The syntax is identical to creating queries
  .mutation('login', {
    // using zod schema to validate and infer input values
    input: z
      .object({
        name: z.string(),
      })
    async resolve({ input }) {
      // Here some login stuff would happen

      return {
        user: {
          name: input.name,
          role: 'ADMIN'
        },
      };
    },
  })

----------------------------------------

TITLE: tRPC Client Hooks Setup
DESCRIPTION: Configures tRPC client hooks with HTTP batch link and base URL handling for different environments.

LANGUAGE: typescript
CODE:
import { httpBatchLink } from '@trpc/client';
import { createTRPCNext } from '@trpc/next';
import type { AppRouter } from '../server/routers/_app';

function getBaseUrl() {
  if (typeof window !== 'undefined')
    return '';

  if (process.env.VERCEL_URL)
    return `https://${process.env.VERCEL_URL}`;

  if (process.env.RENDER_INTERNAL_HOSTNAME)
    return `http://${process.env.RENDER_INTERNAL_HOSTNAME}:${process.env.PORT}`;

  return `http://localhost:${process.env.PORT ?? 3000}`;
}

export const trpc = createTRPCNext<AppRouter>({
  config(opts) {
    return {
      links: [
        httpBatchLink({
          url: `${getBaseUrl()}/api/trpc`,
          async headers() {
            return {};
          },
        }),
      ],
    };
  },
  ssr: false,
});

----------------------------------------

TITLE: Initializing Server-Side Helpers with Internal Router in TypeScript
DESCRIPTION: This snippet demonstrates how to create server-side helpers using the internal router method in tRPC. It requires direct access to the tRPC router and is suitable for monolithic Next.js applications.

LANGUAGE: typescript
CODE:
import { createServerSideHelpers } from '@trpc/react-query/server';
import { createContext } from '~/server/context';
import superjson from 'superjson';

const helpers = createServerSideHelpers({
  router: appRouter,
  ctx: await createContext(),
  transformer: superjson, // optional - adds superjson serialization
});

----------------------------------------

TITLE: Setting up tRPC Context Provider
DESCRIPTION: Shows how to create a tRPC context provider using createTRPCContext. This is useful for server-side rendering scenarios to ensure each request has its own QueryClient.

LANGUAGE: typescript
CODE:
import { createTRPCContext } from '@trpc/tanstack-react-query';
import type { AppRouter } from '../server/router';

export const { TRPCProvider, useTRPC, useTRPCClient } = createTRPCContext<AppRouter>();

----------------------------------------

TITLE: Installing Next.js Prisma WebSockets Starter
DESCRIPTION: Command to create a new Next.js application with tRPC, Prisma, and WebSocket support using create-next-app.

LANGUAGE: bash
CODE:
yarn create next-app --example https://github.com/trpc/trpc --example-path examples/next-prisma-websockets-starter trpc-prisma-websockets-starter

----------------------------------------

TITLE: Adding SuperJSON to withTRPC Configuration
DESCRIPTION: Configuration of SuperJSON transformer in withTRPC wrapper for Next.js applications

LANGUAGE: typescript
CODE:
import superjson from 'superjson';

// [...]

export default withTRPC<AppRouter>({
  config({ ctx }) {
    return {
      // [...]
      transformer: superjson,
    };
  },
})(MyApp);

----------------------------------------

TITLE: Migrating tRPC Mutations in TypeScript React
DESCRIPTION: Example of migrating a tRPC mutation from the classic client to the new client. This demonstrates the changes in import statements, hook usage, and mutation execution.

LANGUAGE: typescript
CODE:
import { trpc } from './trpc';

function Users() {
  const createUserMutation = trpc.createUser.useMutation();

  createUserMutation.mutate({ name: 'Jerry' });
}

LANGUAGE: typescript
CODE:
import { useMutation } from '@tanstack/react-query';
import { useTRPC } from './trpc';

function Users() {
  const trpc = useTRPC();

  const createUserMutation = useMutation(trpc.createUser.mutationOptions());

  createUserMutation.mutate({ name: 'Jerry' });
}

----------------------------------------

TITLE: Running Project Commands for Prisma + tRPC + WebSockets
DESCRIPTION: Various commands for building, resetting the database, starting development servers, and running tests in the project.

LANGUAGE: bash
CODE:
pnpm build      # runs `prisma generate` + `prisma migrate` + `next build`
pnpm db-nuke    # resets local db
pnpm dev        # starts next.js + WebSocket server
pnpm dx         # starts postgres db + runs migrations + seeds + starts next.js
pnpm test-dev   # runs e2e tests on dev
pnpm test-start # runs e2e tests on `next start` - build required before
pnpm test:unit  # runs normal Vitest unit tests
pnpm test:e2e   # runs e2e tests

----------------------------------------

TITLE: Importing GitHub Sponsor Button Component in React
DESCRIPTION: This JavaScript import statement brings in a custom React component for displaying a GitHub Sponsor button. It's likely used to render a sponsorship call-to-action on the page.

LANGUAGE: JavaScript
CODE:
import { GithubSponsorButton } from '@site/src/components/GithubSponsorButton';

----------------------------------------

TITLE: Example API Usage
DESCRIPTION: Demonstrates how to use tRPC hooks in a Next.js page component.

LANGUAGE: typescript
CODE:
import { trpc } from '../utils/trpc';

export default function IndexPage() {
  const hello = trpc.hello.useQuery({ text: 'client' });
  if (!hello.data) {
    return <div>Loading...</div>;
  }
  return (
    <div>
      <p>{hello.data.greeting}</p>
    </div>
  );
}

----------------------------------------

TITLE: Initializing tRPC React Hooks
DESCRIPTION: Creating strongly-typed React hooks using createTRPCReact with the AppRouter type.

LANGUAGE: typescript
CODE:
import { createTRPCReact } from '@trpc/react-query';
import type { AppRouter } from '../server/router';

export const trpc = createTRPCReact<AppRouter>();

----------------------------------------

TITLE: Running Development Commands for Prisma + tRPC Project
DESCRIPTION: A list of development commands for building, resetting the database, starting the development server, running tests, and more in the Prisma + tRPC project.

LANGUAGE: bash
CODE:
pnpm build      # runs `prisma generate` + `prisma migrate` + `next build`
pnpm db-reset   # resets local db
pnpm dev        # starts next.js
pnpm dx         # starts postgres db + runs migrations + seeds + starts next.js
pnpm test-dev   # runs e2e tests on dev
pnpm test-start # runs e2e + unit tests
pnpm test-unit  # runs normal Vitest unit tests
pnpm test-e2e   # runs e2e tests

----------------------------------------

TITLE: Migrating tRPC Queries in TypeScript React
DESCRIPTION: Example of migrating a classic tRPC query to the new client using TanStack Query. This demonstrates the changes in import statements, hook usage, and query execution.

LANGUAGE: typescript
CODE:
import { trpc } from './trpc';

function Users() {
  const greetingQuery = trpc.greeting.useQuery({ name: 'Jerry' });

  // greetingQuery.data === 'Hello Jerry'
}

LANGUAGE: typescript
CODE:
import { useQuery } from '@tanstack/react-query';
import { useTRPC } from './trpc';

function Users() {
  const trpc = useTRPC();

  const greetingQuery = useQuery(trpc.greeting.queryOptions({ name: 'Jerry' }));

  // greetingQuery.data === 'Hello Jerry'
}

----------------------------------------

TITLE: Handling Auth Login with tRPC Mutation in TypeScript
DESCRIPTION: This snippet shows how to use a tRPC mutation for authentication login. It updates the token variable on successful login, which can then be used in subsequent requests.

LANGUAGE: typescript
CODE:
const loginMut = trpc.auth.login.useMutation({
  onSuccess(opts) {
    token = opts.accessToken;
  },
});

----------------------------------------

TITLE: Creating tRPC Hooks for Next.js
DESCRIPTION: TypeScript code for creating strongly-typed tRPC hooks using createTRPCNext. It sets up the client configuration including the base URL and HTTP batch link.

LANGUAGE: typescript
CODE:
import { httpBatchLink } from '@trpc/client';
import { createTRPCNext } from '@trpc/next';
import type { AppRouter } from '../server/routers/_app';

function getBaseUrl() {
  if (typeof window !== 'undefined')
    // browser should use relative path
    return '';

  if (process.env.VERCEL_URL)
    // reference for vercel.com
    return `https://${process.env.VERCEL_URL}`;

  if (process.env.RENDER_INTERNAL_HOSTNAME)
    // reference for render.com
    return `http://${process.env.RENDER_INTERNAL_HOSTNAME}:${process.env.PORT}`;

  // assume localhost
  return `http://localhost:${process.env.PORT ?? 3000}`;
}

export const trpc = createTRPCNext<AppRouter>({
  config(opts) {
    return {
      links: [
        httpBatchLink({
          /**
           * If you want to use SSR, you need to use the server's full URL
           * @see https://trpc.io/docs/ssr
           **/
          url: `${getBaseUrl()}/api/trpc`,

          // You can pass any HTTP headers you wish here
          async headers() {
            return {
              // authorization: getAuthCookie(),
            };
          },
        }),
      ],
    };
  },
  /**
   * @see https://trpc.io/docs/ssr
   **/
  ssr: false,
});

----------------------------------------

TITLE: Installing and Running tRPC Serverless Project
DESCRIPTION: Commands for installing dependencies, building the project, and starting both server and client components. The server uses serverless-offline to mock AWS API Gateway locally.

LANGUAGE: bash
CODE:
$ yarn install

LANGUAGE: bash
CODE:
$ yarn build

LANGUAGE: bash
CODE:
$ yarn start-server

LANGUAGE: bash
CODE:
$ yarn start-client

----------------------------------------

TITLE: Running tRPC upgrade CLI in Bash
DESCRIPTION: Command to run the tRPC upgrade CLI for automated migration assistance. This codemod helps migrate hooks to the new xxxOptions API and update context provider setup.

LANGUAGE: bash
CODE:
npx @trpc/upgrade@next

----------------------------------------

TITLE: Starting Development Server with PNPM
DESCRIPTION: Command to start the local development server using PNPM package manager.

LANGUAGE: bash
CODE:
pnpm dev

----------------------------------------

TITLE: Server-side tRPC Configuration
DESCRIPTION: Initializes tRPC backend configuration with router and procedure helpers.

LANGUAGE: typescript
CODE:
import { initTRPC } from '@trpc/server';

const t = initTRPC.create();

export const router = t.router;
export const procedure = t.procedure;

----------------------------------------

TITLE: Building and Starting tRPC Production Server
DESCRIPTION: Commands to build the tRPC project for production and start the server. This process compiles the TypeScript files and prepares the application for deployment.

LANGUAGE: bash
CODE:
npm run build
npm run start

----------------------------------------

TITLE: Configuring tRPC Client with Automatic Cache Invalidation
DESCRIPTION: This snippet shows how to configure the tRPC client to automatically invalidate the full cache on every successful mutation.

LANGUAGE: typescript
CODE:
export const trpc = createTRPCReact<AppRouter, SSRContext>({
  overrides: {
    useMutation: {
      /**
       * This function is called whenever a `.useMutation` succeeds
       **/
      async onSuccess(opts) {
        /**
         * @note that order here matters:
         * The order here allows route changes in `onSuccess` without
         * having a flash of content change whilst redirecting.
         **/

        // Calls the `onSuccess` defined in the `useQuery()`-options:
        await opts.originalFn();

        // Invalidate all queries in the react-query cache:
        await opts.queryClient.invalidateQueries();
      },
    },
  },
});

----------------------------------------

TITLE: Implementing Middleware-based Authorization in tRPC (TypeScript)
DESCRIPTION: This snippet shows how to implement authorization using middleware in tRPC. It includes an open query and a protected router with an admin-only query.

LANGUAGE: typescript
CODE:
import * as trpc from '@trpc/server';
import { TRPCError } from '@trpc/server';
import { createRouter } from '../createRouter';

export const appRouter = createRouter()
  // this is accessible for everyone
  .query('hello', {
    input: z.string().nullish(),
    resolve: ({ input, ctx }) => {
      return `hello ${input ?? ctx.user?.name ?? 'world'}`;
    },
  })
  .merge(
    'admin.',
    createRouter()
      // this protects all procedures defined next in this router
      .middleware(async ({ ctx, next }) => {
        if (!ctx.user?.isAdmin) {
          throw new TRPCError({ code: 'UNAUTHORIZED' });
        }
        return next();
      })
      .query('secret', {
        resolve: ({ ctx }) => {
          return {
            secret: 'sauce',
          };
        },
      }),
  );

----------------------------------------

TITLE: Client-Side Form Implementation with Server Actions
DESCRIPTION: React component showing how to use tRPC server actions in a form, demonstrating both progressive enhancement and JavaScript-enabled interactions.

LANGUAGE: tsx
CODE:
'use client';

import { createPost } from '~/_actions';

export function PostForm() {
  return (
    <form
      action={createPost}
      onSubmit={async (e) => {
        e.preventDefault();
        const title = new FormData(e.target).get('title');
        await createPost({ title });
      }}
    >
      <input type="text" name="title" />
      <button type="submit">Create Post</button>
    </form>
  );
}

----------------------------------------

TITLE: Global tRPC Configuration for Static Queries
DESCRIPTION: Implementation of global tRPC configuration to disable automatic refetching for all queries. Shows how to set up the tRPC client with custom query options that apply across the entire application.

LANGUAGE: tsx
CODE:
import { httpBatchLink } from '@trpc/client';
import { createTRPCNext } from '@trpc/next';
import superjson from 'superjson';
import type { AppRouter } from './api/trpc/[trpc]';
export const trpc = createTRPCNext<AppRouter>({
  config(opts) {
    return {
      transformer: superjson,
      links: [
        httpBatchLink({
          url: `${getBaseUrl()}/api/trpc`,
        }),
      ],
      queryClientConfig: {
        defaultOptions: {
          queries: {
            refetchOnMount: false,
            refetchOnWindowFocus: false,
          },
        },
      },
    };
  },
});

----------------------------------------

TITLE: Implementing Context Swapping Middleware in tRPC Router
DESCRIPTION: This snippet demonstrates how to use a middleware to modify the context in a tRPC router. It ensures the user is authenticated and updates the context with the non-null user object.

LANGUAGE: typescript
CODE:
interface Context {
  // user is nullable
  user?: {
    id: string;
  };
}

trpc
  .router<Context>()
  .middleware(({ ctx, next }) => {
    if (!ctx.user) {
      throw new TRPCError({ code: 'UNAUTHORIZED' });
    }

    return next({
      ctx: {
        ...ctx,
        user: ctx.user, // user value is known to be non-null now
      },
    });
  })
  .query('userId', {
    async resolve({ ctx }) {
      return ctx.user.id;
    },
  });

----------------------------------------

TITLE: tRPC useQueries with Custom Context
DESCRIPTION: Demonstrates how to use useQueries with a custom React Query context to override the default context settings.

LANGUAGE: tsx
CODE:
const [post, greeting] = trpc.useQueries(
  (t) => [t.post.byId({ id: '1' }), t.greeting({ text: 'world' })],
  myCustomContext,
);

----------------------------------------

TITLE: Rendering GitHub Sponsor Button in JSX
DESCRIPTION: This JSX code renders the imported GithubSponsorButton component. It's used to display a button that allows visitors to sponsor the tRPC project on GitHub.

LANGUAGE: JSX
CODE:
<GithubSponsorButton />

----------------------------------------

TITLE: Running tRPC Upgrade from Compiled Code
DESCRIPTION: Steps to build, link and run the tRPC upgrade tool from compiled code. Shows how to link the package locally and run it in an application.

LANGUAGE: sh
CODE:
cd packages/upgrade
pnpm build && pnpm link .

# in an app somewhere
pnpm link @trpc/upgrade && pnpm trpc-upgrade

----------------------------------------

TITLE: Using tRPC Infinite Query in React Component
DESCRIPTION: React component implementation showing how to use the infinite query hook with pagination parameters.

LANGUAGE: tsx
CODE:
import { trpc } from '../utils/trpc';

export function MyComponent() {
  const myQuery = trpc.useInfiniteQuery(
    [
      'infinitePosts',
      {
        limit: 10,
      },
    ],
    {
      getNextPageParam: (lastPage) => lastPage.nextCursor,
    },
  );
  // [...]
}

----------------------------------------

TITLE: Installing Next.js Starter with WebSockets using npm
DESCRIPTION: Command to create a new Next.js application with tRPC, Prisma, WebSockets, and subscriptions using npm. This example also includes E2E testing, ESLint, and next-auth.

LANGUAGE: bash
CODE:
npx create-next-app --example https://github.com/trpc/trpc --example-path examples/next-prisma-websockets-starter trpc-prisma-websockets-starter

----------------------------------------

TITLE: Creating Next.js TodoMVC Example with tRPC
DESCRIPTION: Command to create a new Next.js TodoMVC project with tRPC and Prisma integration using create-next-app.

LANGUAGE: bash
CODE:
yarn create next-app --example https://github.com/trpc/trpc --example-path examples/next-prisma-todomvc trpc-todo

----------------------------------------

TITLE: Integrating tRPC with Next.js App Component
DESCRIPTION: Implementation of tRPC wrapper in the Next.js _app.tsx file to enable tRPC functionality throughout the application.

LANGUAGE: typescript
CODE:
import { trpc } from '~/utils/trpc';

const App = ({ Component, pageProps }) => {
  return <Component {...pageProps} />;
};

export default trpc.withTRPC(App);

----------------------------------------

TITLE: Installing Server Dependencies for tRPC
DESCRIPTION: Installation of required server-side dependencies including @trpc/server and zod for input validation.

LANGUAGE: bash
CODE:
yarn add @trpc/server zod

----------------------------------------

TITLE: Setting up tRPC SSE Example Project
DESCRIPTION: Shell commands to clone the repository, install dependencies, set up environment variables, and start the development server for the tRPC SSE example project.

LANGUAGE: Shell
CODE:
git clone git@github.com:trpc/examples-next-sse-chat.git
pnpm i
cp .env.example .env
pnpm dev

----------------------------------------

TITLE: Cloning T3 Stack with Expo and Turborepo
DESCRIPTION: Command to clone the create-t3-turbo repository, which includes T3 Stack with Expo and Turborepo integration.

LANGUAGE: bash
CODE:
git clone git@github.com:t3-oss/create-t3-turbo.git

----------------------------------------

TITLE: Implementing Conditional Queries with skipToken in tRPC React
DESCRIPTION: This snippet demonstrates how to use skipToken to create typesafe conditional queries in a React component using tRPC. It prevents the query from executing when the name state is undefined.

LANGUAGE: tsx
CODE:
import { skipToken } from '@tanstack/react-query';


export function MyComponent() {

const [name, setName] = useState<string | undefined>();

const result = trpc.getUserByName.useQuery(name ? { name: name } : skipToken);

  return (
    ...
  )
}

----------------------------------------

TITLE: Installing Combined Transformer Dependencies
DESCRIPTION: Command to install both SuperJSON and Devalue packages for combined transformer setup

LANGUAGE: bash
CODE:
yarn add superjson devalue

----------------------------------------

TITLE: Installing @trpc/client Package
DESCRIPTION: Commands for installing the @trpc/client package using various package managers. The @next tag is used to install the latest version.

LANGUAGE: bash
CODE:
# npm
npm install @trpc/client@next

# Yarn
yarn add @trpc/client@next

# pnpm
pnpm add @trpc/client@next

# Bun
bun add @trpc/client@next

----------------------------------------

TITLE: Configuring tRPC Client in Next.js
DESCRIPTION: Setup of tRPC client configuration in a Next.js application, including creating the client instance and setting up HTTP batch link for API communication.

LANGUAGE: typescript
CODE:
import { createTRPCNext, httpBatchLink } from '@trpc/next';
// Import the router type from your server file
import type { AppRouter } from '../pages/api/[trpc].ts';

export const trpc = createTRPCNext<AppRouter>({
  config() {
    return {
      links: [
        httpBatchLink({
          url: 'http://localhost:3000/trpc',
        }),
      ],
    };
  },
  ssr: false,
});

----------------------------------------

TITLE: Configuring SuperJSON in tRPC Server
DESCRIPTION: Implementation of SuperJSON transformer in the tRPC server initialization.

LANGUAGE: typescript
CODE:
import { initTRPC } from '@trpc/server';
import superjson from 'superjson';

export const t = initTRPC.create({
  transformer: superjson,
});

----------------------------------------

TITLE: Installing Next.js Todo MVC Example with tRPC, SSG, and Prisma (pnpm)
DESCRIPTION: Command to create a new Next.js Todo MVC application using tRPC, Static Site Generation (SSG), and Prisma with pnpm.

LANGUAGE: sh
CODE:
pnpx create-next-app --example https://github.com/trpc/trpc --example-path examples/next-prisma-todomvc trpc-todo

----------------------------------------

TITLE: WebSocket Link and Client Configuration Interfaces
DESCRIPTION: Defines the TypeScript interfaces for WebSocket link and client configuration options, including URL settings, connection parameters, retry logic, lifecycle hooks, and keepalive settings.

LANGUAGE: typescript
CODE:
export interface WebSocketLinkOptions {
  client: TRPCWebSocketClient;
  /**
   * Data transformer
   * @see https://trpc.io/docs/v11/data-transformers
   **/
  transformer?: DataTransformerOptions;
}

function createWSClient(opts: WebSocketClientOptions) => TRPCWebSocketClient


export interface WebSocketClientOptions {
  /**
   * The URL to connect to (can be a function that returns a URL)
   */
  url: string | (() => MaybePromise<string>);
  /**
   * Connection params that are available in `createContext()`
   * These are sent as the first message
   */
  connectionParams: string | (() => MaybePromise<string>);
  /**
   * Ponyfill which WebSocket implementation to use
   */
  WebSocket?: typeof WebSocket;
  /**
   * The number of milliseconds before a reconnect is attempted.
   * @default {@link exponentialBackoff}
   */
  retryDelayMs?: typeof exponentialBackoff;
  /**
   * Triggered when a WebSocket connection is established
   */
  onOpen?: () => void;
  /**
   * Triggered when a WebSocket connection encounters an error
   */
  onError?: (evt?: Event) => void;
  /**
   * Triggered when a WebSocket connection is closed
   */
  onClose?: (cause?: { code?: number }) => void;
  /**
   * Lazy mode will close the WebSocket automatically after a period of inactivity (no messages sent or received and no pending requests)
   */
  lazy?: {
    /**
     * Enable lazy mode
     * @default false
     */
    enabled: boolean;
    /**
     * Close the WebSocket after this many milliseconds
     * @default 0
     */
    closeMs: number;
  };
  /**
   * Send ping messages to the server and kill the connection if no pong message is returned
   */
  keepAlive?: {
    /**
     * @default false
     */
    enabled: boolean;
    /**
     * Send a ping message every this many milliseconds
     * @default 5_000
     */
    intervalMs?: number;
    /**
     * Close the WebSocket after this many milliseconds if the server does not respond
     * @default 1_000
     */
    pongTimeoutMs?: number;
  };
}

----------------------------------------

TITLE: WebSocket Link and Client Configuration Interfaces
DESCRIPTION: Defines the TypeScript interfaces for WebSocket link and client configuration options, including URL settings, connection parameters, retry logic, lifecycle hooks, and keepalive settings.

LANGUAGE: typescript
CODE:
export interface WebSocketLinkOptions {
  client: TRPCWebSocketClient;
  /**
   * Data transformer
   * @see https://trpc.io/docs/v11/data-transformers
   **/
  transformer?: DataTransformerOptions;
}

function createWSClient(opts: WebSocketClientOptions) => TRPCWebSocketClient


export interface WebSocketClientOptions {
  /**
   * The URL to connect to (can be a function that returns a URL)
   */
  url: string | (() => MaybePromise<string>);
  /**
   * Connection params that are available in `createContext()`
   * These are sent as the first message
   */
  connectionParams: string | (() => MaybePromise<string>);
  /**
   * Ponyfill which WebSocket implementation to use
   */
  WebSocket?: typeof WebSocket;
  /**
   * The number of milliseconds before a reconnect is attempted.
   * @default {@link exponentialBackoff}
   */
  retryDelayMs?: typeof exponentialBackoff;
  /**
   * Triggered when a WebSocket connection is established
   */
  onOpen?: () => void;
  /**
   * Triggered when a WebSocket connection encounters an error
   */
  onError?: (evt?: Event) => void;
  /**
   * Triggered when a WebSocket connection is closed
   */
  onClose?: (cause?: { code?: number }) => void;
  /**
   * Lazy mode will close the WebSocket automatically after a period of inactivity (no messages sent or received and no pending requests)
   */
  lazy?: {
    /**
     * Enable lazy mode
     * @default false
     */
    enabled: boolean;
    /**
     * Close the WebSocket after this many milliseconds
     * @default 0
     */
    closeMs: number;
  };
  /**
   * Send ping messages to the server and kill the connection if no pong message is returned
   */
  keepAlive?: {
    /**
     * @default false
     */
    enabled: boolean;
    /**
     * Send a ping message every this many milliseconds
     * @default 5_000
     */
    intervalMs?: number;
    /**
     * Close the WebSocket after this many milliseconds if the server does not respond
     * @default 1_000
     */
    pongTimeoutMs?: number;
  };
}

----------------------------------------

TITLE: Using TanStack React Query with tRPC in TypeScript React
DESCRIPTION: This snippet demonstrates how to use the new TanStack React Query integration with tRPC in a React component. It shows the usage of useQuery hook with tRPC's queryOptions to fetch a greeting.

LANGUAGE: tsx
CODE:
import { useQuery } from '@tanstack/react-query';
import { useTRPC } from './trpc';

export function Greeting() {
  const trpc = useTRPC();

  const greetingQuery = useQuery(trpc.greeting.queryOptions({ name: 'Jerry' }));

  // greetingQuery.data === 'Hello Jerry'

  // [...]
}

----------------------------------------

TITLE: Installing SuperJSON Dependencies
DESCRIPTION: Command to install SuperJSON package using yarn package manager

LANGUAGE: bash
CODE:
yarn add superjson

----------------------------------------

TITLE: Installing Next.js Edge Runtime with tRPC Template
DESCRIPTION: Commands to create a new Next.js project with tRPC integration using the Edge Runtime template. This sets up the initial project structure and installs required dependencies.

LANGUAGE: bash
CODE:
npx create-next-app --example https://github.com/trpc/trpc --example-path examples/next-edge-runtime trpc-next-edge-runtime
cd trpc-next-edge-runtime
npm i
npm run dev

----------------------------------------

TITLE: Installing Required Dependencies
DESCRIPTION: Command to install SuperJSON package as a project dependency.

LANGUAGE: bash
CODE:
yarn add superjson

----------------------------------------

TITLE: Installing SuperJSON Dependencies
DESCRIPTION: Command to install SuperJSON package using yarn package manager

LANGUAGE: bash
CODE:
yarn add superjson

----------------------------------------

TITLE: Using Raw Input in tRPC Middleware
DESCRIPTION: This example demonstrates how to access and validate raw input in a tRPC middleware. It uses Zod for input validation and updates the context with the validated userId.

LANGUAGE: typescript
CODE:
const inputSchema = z.object({ userId: z.string() });

trpc
  .router<Context>()
  .middleware(async ({ next, rawInput, ctx }) => {
    const result = inputSchema.safeParse(rawInput);
    if (!result.success) throw new TRPCError({ code: 'BAD_REQUEST' });
    const { userId } = result.data;
    // Check user id auth
    return next({ ctx: { ...ctx, userId } });
  })
  .query('userId', {
    input: inputSchema,
    resolve({ ctx }) {
      return ctx.userId;
    },
  });

----------------------------------------

TITLE: splitLink Function Type Definition
DESCRIPTION: Type definition for the splitLink function showing its parameters and return type. The function accepts condition, true, and false options to determine the execution path.

LANGUAGE: typescript
CODE:
function splitLink<TRouter extends AnyRouter = AnyRouter>(opts: {
  condition: (op: Operation) => boolean;
  /**
   * The link to execute next if the test function returns `true`.
   */
  true: TRPCLink<TRouter> | TRPCLink<TRouter>[];
  /**
   * The link to execute next if the test function returns `false`.
   */
  false: TRPCLink<TRouter> | TRPCLink<TRouter>[];
}) => TRPCLink<TRouter>

----------------------------------------

TITLE: Creating tRPC Context in TypeScript
DESCRIPTION: Example of creating a context for tRPC requests in a Fastify server environment.

LANGUAGE: typescript
CODE:
import { inferAsyncReturnType } from '@trpc/server';
import { CreateFastifyContextOptions } from '@trpc/server/adapters/fastify';

export function createContext({ req, res }: CreateFastifyContextOptions) {
  const user = { name: req.headers.username ?? 'anonymous' };

  return { req, res, user };
}

export type Context = inferAsyncReturnType<typeof createContext>;

----------------------------------------

TITLE: Installing and Running tRPC Development Server
DESCRIPTION: Commands to install dependencies and start the tRPC development server. This allows for real-time type checking as you edit TypeScript files.

LANGUAGE: bash
CODE:
npm i
npm run dev

----------------------------------------

TITLE: Configuring SuperJSON in tRPC Client
DESCRIPTION: Implementation of SuperJSON transformer in tRPC client configuration

LANGUAGE: typescript
CODE:
import superjson from 'superjson';

// [...]

export const client = createTRPCClient<AppRouter>({
  // [...]
  transformer: superjson,
});

----------------------------------------

TITLE: Installing tRPC Dependencies
DESCRIPTION: Commands to install required tRPC packages and React Query using different package managers.

LANGUAGE: bash
CODE:
npm install @trpc/client @trpc/server @trpc/react-query @tanstack/react-query@4

LANGUAGE: bash
CODE:
yarn add @trpc/client @trpc/server @trpc/react-query @tanstack/react-query@4

LANGUAGE: bash
CODE:
pnpm add @trpc/client @trpc/server @trpc/react-query @tanstack/react-query@4

LANGUAGE: bash
CODE:
bun add @trpc/client @trpc/server @trpc/react-query @tanstack/react-query@4

----------------------------------------

TITLE: Using setInfiniteQueryData Helper in tRPC
DESCRIPTION: Example of using the setInfiniteQueryData helper to update cached infinite query data during mutations.

LANGUAGE: tsx
CODE:
import { trpc } from '../utils/trpc';

export function MyComponent() {
  const utils = trpc.useContext();

  const myMutation = trpc.useMutation('infinitePosts.delete', {
    onMutate({ post }) {
      await utils.cancelQuery(['infinitePosts']);

      utils.setInfiniteQueryData(['infinitePosts', { limit: 10 }], (data) => {
        if (!data) {
          return {
            pages: [],
            pageParams: []
          }
        }

        return {
          ...data,
          pages: data.pages.map((page) => {
            ...page,
            items: page.items.filter((item) => item.status === 'published')
          })
        }
      });
    }
  });

  // [...]
}

----------------------------------------

TITLE: Using Batch Queries in tRPC
DESCRIPTION: Example of batching multiple queries into a single HTTP request using Promise.all. This approach optimizes network requests by combining multiple operations.

LANGUAGE: typescript
CODE:
const somePosts = await Promise.all([
  trpc.post.byId.query(1),
  trpc.post.byId.query(2),
  trpc.post.byId.query(3),
]);

----------------------------------------

TITLE: Using Batch Queries in tRPC
DESCRIPTION: Example of batching multiple queries into a single HTTP request using Promise.all. This approach optimizes network requests by combining multiple operations.

LANGUAGE: typescript
CODE:
const somePosts = await Promise.all([
  trpc.post.byId.query(1),
  trpc.post.byId.query(2),
  trpc.post.byId.query(3),
]);

----------------------------------------

TITLE: Installing Next.js Todo MVC Example with tRPC, SSG, and Prisma (bun)
DESCRIPTION: Command to create a new Next.js Todo MVC application using tRPC, Static Site Generation (SSG), and Prisma with bun.

LANGUAGE: sh
CODE:
bunx create-next-app --example https://github.com/trpc/trpc --example-path examples/next-prisma-todomvc trpc-todo

----------------------------------------

TITLE: Building and Running Production Build
DESCRIPTION: Commands to create a production build of the Fastify example and run it

LANGUAGE: bash
CODE:
yarn build
yarn start

----------------------------------------

TITLE: Creating tRPC Router with Typed Metadata in TypeScript
DESCRIPTION: This snippet demonstrates how to create a tRPC router with typed metadata. It defines a Meta interface with an authRequired property and initializes the tRPC instance with this metadata type.

LANGUAGE: typescript
CODE:
import { initTRPC } from '@trpc/server';

// [...]

interface Meta {
  authRequired: boolean;
}

export const t = initTRPC.context<Context>().meta<Meta>().create();

export const appRouter = t.router({
  // [...]
});

----------------------------------------

TITLE: Running TRPC Server with Deno
DESCRIPTION: Command to start the TRPC server using Deno task runner.

LANGUAGE: sh
CODE:
deno task server

----------------------------------------

TITLE: Setting up tRPC Server Router Configuration
DESCRIPTION: Example of server-side tRPC router configuration defining a post router with an 'all' query procedure.

LANGUAGE: typescript
CODE:
import { initTRPC } from '@trpc/server';
import { z } from 'zod';

const t = initTRPC.create();

const appRouter = t.router({
  post: t.router({
    all: t.procedure.query(() => {
      return {
        posts: [
          { id: 1, title: 'everlong' },
          { id: 2, title: 'After Dark' },
        ],
      };
    }),
  }),
});

export type AppRouter = typeof appRouter;

----------------------------------------

TITLE: Configuring tRPC Server Router with TypeScript
DESCRIPTION: Sets up a tRPC router with post-related procedures including fetching all posts and getting posts by ID. Includes type definitions and error handling.

LANGUAGE: typescript
CODE:
import { initTRPC, TRPCError } from '@trpc/server';
import { z } from 'zod';

const t = initTRPC.create();

const posts = [
  { id: '1', title: 'everlong' },
  { id: '2', title: 'After Dark' },
];

const appRouter = t.router({
  post: t.router({
    all: t.procedure
      .input(
        z.object({
          cursor: z.string().optional(),
        })
      )
      .query(({ input }) => {
        return {
          posts,
          nextCursor: '123' as string | undefined,
        };
      }),
    byId: t.procedure
      .input(
        z.object({
          id: z.string(),
        })
      )
      .query(({ input }) => {
        const post = posts.find(p => p.id === input.id);
        if (!post) {
          throw new TRPCError({
            code: 'NOT_FOUND',
          })
        }
        return post;
     }),
  }),
});

export type AppRouter = typeof appRouter;

----------------------------------------

TITLE: React Component with tRPC Usage in TypeScript
DESCRIPTION: Example of a React component using tRPC hooks and utilities.

LANGUAGE: tsx
CODE:
import type { AppRouter } from '~/server/trpc';

const trpc = createTRPCReact<AppRouter>();
const Home: NextPage = () => {
  const { data } = trpc.r0.greeting.useQuery({ who: 'from tRPC' });

  const utils = trpc.useContext();

  utils.r49.greeting.invalidate();
};

export default Home;

----------------------------------------

TITLE: Setting up tRPC API Routes with Fetch Adapter
DESCRIPTION: Configures API routes for tRPC using the fetch adapter in Next.js, handling both GET and POST requests.

LANGUAGE: typescript
CODE:
import { fetchRequestHandler } from '@trpc/server/adapters/fetch';
import { createTRPCContext } from '~/trpc/init';
import { appRouter } from '~/trpc/routers/_app';

const handler = (req: Request) =>
  fetchRequestHandler({
    endpoint: '/api/trpc',
    req,
    router: appRouter,
    createContext: createTRPCContext,
  });

export { handler as GET, handler as POST };

----------------------------------------

TITLE: Canonical Link and Head Setup for tRPC Docs
DESCRIPTION: HTML head section defining the canonical URL for the tRPC contribution documentation page.

LANGUAGE: html
CODE:
<head>
  <link rel="canonical" href="https://trpc.io/docs/contributing" />
</head>

----------------------------------------

TITLE: Creating a Vanilla tRPC Client in TypeScript
DESCRIPTION: This snippet demonstrates how to create a vanilla tRPC client without using the React Query integration. It sets up a client with a batch HTTP link.

LANGUAGE: typescript
CODE:
export const trpc = createTRPCClient<AppRouter>({
  links: [httpBatchLink({ url: 'YOUR_API_URL' })],
});

----------------------------------------

TITLE: Installing Next.js Starter with Prisma using deno
DESCRIPTION: Command to create a new Next.js application with tRPC and Prisma integration using deno. This example includes E2E testing and ESLint configuration.

LANGUAGE: sh
CODE:
deno init --npm next-app --example https://github.com/trpc/trpc --example-path examples/next-prisma-starter trpc-prisma-starter

----------------------------------------

TITLE: Activating WebSocket Support in Fastify tRPC Plugin
DESCRIPTION: Configuration to enable WebSocket support in the Fastify tRPC plugin for subscriptions.

LANGUAGE: typescript
CODE:
server.register(fastifyTRPCPlugin, {
  useWSS: true,
  // ...
});

----------------------------------------

TITLE: Activating WebSocket Support in Fastify tRPC Plugin
DESCRIPTION: Configuration to enable WebSocket support in the Fastify tRPC plugin for subscriptions.

LANGUAGE: typescript
CODE:
server.register(fastifyTRPCPlugin, {
  useWSS: true,
  // ...
});

----------------------------------------

TITLE: Running TypeScript Tracing in Shell
DESCRIPTION: Command to generate a trace file for TypeScript performance analysis.

LANGUAGE: sh
CODE:
tsc --generateTrace ./trace --incremental false

----------------------------------------

TITLE: Importing React Components for tRPC Documentation
DESCRIPTION: Imports required React components including Button and GithubSponsorButton for the contribution documentation page.

LANGUAGE: jsx
CODE:
import { Button } from '@site/src/components/Button';
import { GithubSponsorButton } from '@site/src/components/GithubSponsorButton';

----------------------------------------

TITLE: Installing Dependencies with PNPM
DESCRIPTION: Command to install project dependencies using PNPM package manager.

LANGUAGE: console
CODE:
pnpm install

----------------------------------------

TITLE: Running tRPC Upgrade from Source
DESCRIPTION: Instructions for running tRPC upgrade tool directly from source files using tsx. Includes an example command for upgrading a minimal React client with specific flags.

LANGUAGE: sh
CODE:
DEV=1 pnpx tsx path/to/cli.ts

# example
cd examples/minimal-react/client && DEV=1 pnpx tsx ../../../packages/upgrade/src/bin/cli.ts --force --skipTanstackQuery --verbose

----------------------------------------

TITLE: Rendering GitHub Sponsor Button Component
DESCRIPTION: Renders the GithubSponsorButton component for accepting sponsorships.

LANGUAGE: jsx
CODE:
<GithubSponsorButton />

----------------------------------------

TITLE: Using tRPC Mutation in a React Component
DESCRIPTION: This snippet shows how to use a tRPC mutation in a React component. It demonstrates adding a new todo item when the user presses Enter in an input field, showcasing the integration of tRPC mutations with React components.

LANGUAGE: tsx
CODE:
const addTask = trpc.useMutation('todos.add');

return (
  <>
    <input
      placeholder="What needs to be done?"
      onKeyDown={(e) => {
        const text = e.currentTarget.value.trim();
        if (e.key === 'Enter' && text) {
          addTask.mutate({ text });
          e.currentTarget.value = '';
        }
      }}
    />
  </>
)

----------------------------------------

TITLE: Implementing Server-Side Subscription Control in TypeScript
DESCRIPTION: Example showing how to stop subscriptions from the server side using tRPC's subscription handler.

LANGUAGE: typescript
CODE:
const myRouter = router({
  sub: publicProcedure.subscription(async function* (opts) {
    for await (const data of on(ee, 'data', {
      signal: opts.signal,
    })) {
      const num = data[0] as number | undefined;
      if (num === undefined) {
        // This will now stop the subscription on the client and trigger the `onComplete` callback
        return;
      }
      yield num;
    }
  }),
});

----------------------------------------

TITLE: Installing tRPC Fastify Dependencies
DESCRIPTION: Commands for installing the required dependencies for tRPC with Fastify implementation.

LANGUAGE: bash
CODE:
yarn add @trpc/server fastify zod

----------------------------------------

TITLE: Cloning zART Stack Example Repository
DESCRIPTION: Command to clone the zART-stack example repository containing a monorepo setup with React Native, Next.js, and Prisma integration.

LANGUAGE: bash
CODE:
git clone git@github.com:KATT/zart.git

----------------------------------------

TITLE: Running Development Environment
DESCRIPTION: Command to initiate the development environment for the OG image generation project.

LANGUAGE: bash
CODE:
pnpm dev dev

----------------------------------------

TITLE: Creating a Type-Safe tRPC Client in TypeScript
DESCRIPTION: This code snippet shows how to create a type-safe tRPC client that connects to a server and makes a query to the 'hello' endpoint. It demonstrates the end-to-end type safety provided by tRPC.

LANGUAGE: tsx
CODE:
import type { AppRouter } from './server';

async function main() {
  const client = createTRPCClient<AppRouter>({
    url: `http://localhost:2022`,
  });

  const result = await client.query('hello', '@alexdotjs');
  console.log(result); // --> { text: "hello @alexdotjs" }
}

main();

----------------------------------------

TITLE: Creating Tiny tRPC Client Implementation
DESCRIPTION: Final implementation of a minimal tRPC client that handles HTTP requests and response parsing. Includes error handling and proper request formatting for both query and mutation procedures.

LANGUAGE: typescript
CODE:
export const createTinyRPCClient = <TRouter extends AnyTRPCRouter>(
  baseUrl: string,
) =>
  createRecursiveProxy(async (opts) => {
    const path = [...opts.path];
    const method = path.pop()! as 'query' | 'mutate';
    const dotPath = path.join('.');
    let uri = `${baseUrl}/${dotPath}`;

    const [input] = opts.args;
    const stringifiedInput = input !== undefined && JSON.stringify(input);
    let body: undefined | string = undefined;
    if (stringifiedInput !== false) {
      if (method === 'query') {
        uri += `?input=${encodeURIComponent(stringifiedInput)}`;
      } else {
        body = stringifiedInput;
      }
    }

    const json: TRPCResponse = await fetch(uri, {
      method: method === 'query' ? 'GET' : 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body,
    }).then((res) => res.json());

    if ('error' in json) {
      throw new Error(`Error: ${json.error.message}`);
    }
    return json.result.data;
  }, []) as DecorateRouterRecord<TRouter['_def']['record']>;

----------------------------------------

TITLE: Defining tRPC Router Procedures
DESCRIPTION: Shows the difference between v9 and v10 router and procedure definitions, demonstrating the new chained method approach.

LANGUAGE: typescript
CODE:
// v9:
const appRouter = trpc.router()
  .query('greeting', {
    input: z.string(),
    resolve(opts) {
      return `hello ${opts.input}!`;
    },
  });

// v10:
const appRouter = router({
  greeting: publicProcedure
    .input(z.string())
    .query((opts) => `hello ${opts.input}!`),
});

----------------------------------------

TITLE: Initializing Basic tRPC Server Router
DESCRIPTION: Demonstrates setting up a basic tRPC server with a post router containing an 'all' query procedure.

LANGUAGE: typescript
CODE:
import { initTRPC } from '@trpc/server';
import { z } from 'zod';

const t = initTRPC.create();

const appRouter = t.router({
  post: t.router({
    all: t.procedure.query(() => {
      return {
        posts: [
          { id: 1, title: 'everlong' },
          { id: 2, title: 'After Dark' },
        ],
      };
    }),
  }),
});

export type AppRouter = typeof appRouter;

----------------------------------------

TITLE: Installing tRPC Server Dependencies
DESCRIPTION: Command to install the required tRPC server package using Yarn package manager.

LANGUAGE: bash
CODE:
yarn add @trpc/server

----------------------------------------

TITLE: Installing tRPC Tanstack React Query Package
DESCRIPTION: Commands for installing the @trpc/tanstack-react-query package and its dependency @tanstack/react-query using different package managers. Requires @tanstack/react-query v5.62.8 or higher.

LANGUAGE: bash
CODE:
# npm
npm install @trpc/tanstack-react-query@next @tanstack/react-query

# Yarn
yarn add @trpc/tanstack-react-query@next @tanstack/react-query

# pnpm
pnpm add @trpc/tanstack-react-query@next @tanstack/react-query

# Bun
bun add @trpc/tanstack-react-query@next @tanstack/react-query

----------------------------------------

TITLE: Using useUtils Hook in React Component
DESCRIPTION: This snippet shows how to use the useUtils hook in a React component to access query helpers for the 'post.all' procedure.

LANGUAGE: tsx
CODE:
import { createTRPCReact } from '@trpc/react-query';
import type { AppRouter } from './server';

const trpc = createTRPCReact<AppRouter>();

function MyComponent() {
  const utils = trpc.useUtils();
  utils.post.all.f;
  //              ^|
  // [...]
}

----------------------------------------

TITLE: Configuring tRPC with Ping Options
DESCRIPTION: Example showing how to configure ping options in tRPC root config to maintain connection alive during streaming.

LANGUAGE: typescript
CODE:
import { initTRPC } from '@trpc/server';

const t = initTRPC.create({
  jsonl: {
    pingMs: 1000,
  },
});

----------------------------------------

TITLE: Cloning Sign-In With Ethereum Authentication Example with tRPC and Express
DESCRIPTION: Command to clone a repository demonstrating Sign-In With Ethereum (SIWE) authentication using tRPC and Express.

LANGUAGE: bash
CODE:
git clone git@github.com:codingwithmanny/trpc-siwe-monorepo.git

----------------------------------------

TITLE: Using useUtils Hook in React Component
DESCRIPTION: This snippet shows how to use the useUtils hook in a React component to access query helpers for the 'post.all' procedure.

LANGUAGE: tsx
CODE:
import { createTRPCReact } from '@trpc/react-query';
import type { AppRouter } from './server';

const trpc = createTRPCReact<AppRouter>();

function MyComponent() {
  const utils = trpc.useUtils();
  utils.post.all.f;
  //              ^|
  // [...]
}

----------------------------------------

TITLE: Enabling Strict Mode in TypeScript Configuration
DESCRIPTION: JSON configuration to enable strict mode in tsconfig.json for better type checking when using Zod with tRPC.

LANGUAGE: json
CODE:
{
  // ...
  "compilerOptions": {
    // ...
    "strict": true
  }
}

----------------------------------------

TITLE: Creating tRPC Router in TypeScript
DESCRIPTION: Defines a sample tRPC router with user-related procedures using Zod for input validation. It includes a query to get a user by ID and a mutation to create a new user.

LANGUAGE: typescript
CODE:
import { initTRPC } from '@trpc/server';
import { z } from 'zod';
import { Context } from './context';

type User = {
  id: string;
  name: string;
  bio?: string;
};

const users: Record<string, User> = {};

export const t = initTRPC.context<Context>().create();

export const appRouter = t.router({
  getUserById: t.procedure.input(z.string()).query((opts) => {
    return users[opts.input]; // input type is string
  }),
  createUser: t.procedure
    // validate input with Zod
    .input(
      z.object({
        name: z.string().min(3),
        bio: z.string().max(142).optional(),
      }),
    )
    .mutation((opts) => {
      const id = Date.now().toString();
      const user: User = { id, ...opts.input };
      users[user.id] = user;
      return user;
    }),
});

// export type definition of API
export type AppRouter = typeof appRouter;

----------------------------------------

TITLE: Setting up tRPC v10 Large Router Example Project
DESCRIPTION: Commands to clone the example repository, install dependencies, open the project in Visual Studio Code, and start the development server.

LANGUAGE: bash
CODE:
git clone git@github.com:trpc/examples-v10-next-big-router.git
cd examples-v10-next-big-router
yarn && code . && yarn dev

----------------------------------------

TITLE: Creating tRPC Client for React Components
DESCRIPTION: Sets up a tRPC client for use in client components, including a provider and hooks for consuming the API.

LANGUAGE: tsx
CODE:
'use client';

import type { QueryClient } from '@tanstack/react-query';
import { QueryClientProvider } from '@tanstack/react-query';
import { createTRPCClient, httpBatchLink } from '@trpc/client';
import { createTRPCContext } from '@trpc/tanstack-react-query';
import { useState } from 'react';
import { makeQueryClient } from './query-client';
import type { AppRouter } from './routers/_app';

export const { TRPCProvider, useTRPC } = createTRPCContext<AppRouter>();

let browserQueryClient: QueryClient;
function getQueryClient() {
  if (typeof window === 'undefined') {
    return makeQueryClient();
  }
  if (!browserQueryClient) browserQueryClient = makeQueryClient();
  return browserQueryClient;
}

function getUrl() {
  const base = (() => {
    if (typeof window !== 'undefined') return '';
    if (process.env.VERCEL_URL) return `https://${process.env.VERCEL_URL}`;
    return 'http://localhost:3000';
  })();
  return `${base}/api/trpc`;
}

export function TRPCReactProvider(
  props: Readonly<{
    children: React.ReactNode;
  }>,
) {
  const queryClient = getQueryClient();

  const [trpcClient] = useState(() =>
    createTRPCClient<AppRouter>({
      links: [
        httpBatchLink({
          url: getUrl(),
        }),
      ],
    }),
  );

  return (
    <QueryClientProvider client={queryClient}>
      <TRPCProvider trpcClient={trpcClient} queryClient={queryClient}>
        {props.children}
      </TRPCProvider>
    </QueryClientProvider>
  );
}

----------------------------------------

TITLE: Installing Next.js Starter with tRPC, Prisma, WebSockets, and Subscriptions (yarn)
DESCRIPTION: Command to create a new Next.js application using tRPC, Prisma, WebSockets, and subscriptions with yarn. This starter includes ESLint and next-auth.

LANGUAGE: sh
CODE:
yarn create next-app --example https://github.com/trpc/trpc --example-path examples/next-prisma-websockets-starter trpc-prisma-websockets-starter

----------------------------------------

TITLE: Using useUtils Hook in React Component
DESCRIPTION: Shows how to use the useUtils hook to access query helpers in a React component.

LANGUAGE: tsx
CODE:
function MyComponent() {
  const utils = trpc.useUtils();
  utils.post.all.f;
  //              ^|
  // [...]
}

----------------------------------------

TITLE: Installing tRPC Dependencies for Next.js
DESCRIPTION: Command to install necessary tRPC dependencies for a Next.js project, including client, server, React integration, Next.js integration, Zod for validation, and React Query.

LANGUAGE: bash
CODE:
yarn add @trpc/client @trpc/server @trpc/react @trpc/next zod react-query@3

----------------------------------------

TITLE: Installing Next.js Starter with tRPC, Prisma, WebSockets, and Subscriptions (bun)
DESCRIPTION: Command to create a new Next.js application using tRPC, Prisma, WebSockets, and subscriptions with bun. This starter includes ESLint and next-auth.

LANGUAGE: sh
CODE:
bunx create-next-app --example https://github.com/trpc/trpc --example-path examples/next-prisma-websockets-starter trpc-prisma-websockets-starter

----------------------------------------

TITLE: Full tRPC Configuration Example
DESCRIPTION: Complete example showing initialization with data transformer, OpenAPI metadata, and error formatter configuration in v10.

LANGUAGE: typescript
CODE:
import { initTRPC } from '@trpc/server';
import superjson from 'superjson';

interface Context {
  user?: {
    id: string;
    name: string;
  };
}

interface Meta {
  openapi: {
    enabled: boolean;
    method: string;
    path: string;
  };
}

export const t = initTRPC
  .context<Context>()
  .meta<Meta>()
  .create({
    errorFormatter({ shape, error }) {
      return {
        ...shape,
        data: {
          ...shape.data,
          zodError:
            error.code === 'BAD_REQUEST' && error.cause instanceof ZodError
              ? error.cause.flatten()
              : null,
        },
      };
    },
    transformer: superjson,
  });

----------------------------------------

TITLE: Installing Next.js Starter with tRPC, Prisma, and E2E Testing (bun)
DESCRIPTION: Command to create a new Next.js application using tRPC, Prisma, and E2E testing with bun. This starter includes ESLint configuration.

LANGUAGE: sh
CODE:
bunx create-next-app --example https://github.com/trpc/trpc --example-path examples/next-prisma-starter trpc-prisma-starter

----------------------------------------

TITLE: Installing Next.js Starter with tRPC, Prisma, and E2E Testing (pnpm)
DESCRIPTION: Command to create a new Next.js application using tRPC, Prisma, and E2E testing with pnpm. This starter includes ESLint configuration.

LANGUAGE: sh
CODE:
pnpx create-next-app --example https://github.com/trpc/trpc --example-path examples/next-prisma-starter trpc-prisma-starter

----------------------------------------

TITLE: Importing TRPC Router Types in Client
DESCRIPTION: Shows how to properly import the AppRouter type from the server using TypeScript's type-only imports to prevent server code from being bundled with the client.

LANGUAGE: typescript
CODE:
import type { AppRouter } from '../server/router';

----------------------------------------

TITLE: Building and Starting React tRPC Example Application
DESCRIPTION: These commands build the React tRPC example project and start the production server. This process creates optimized production-ready files and runs the application in a production environment.

LANGUAGE: bash
CODE:
npm run build
npm run start

----------------------------------------

TITLE: Installing Next.js Starter with tRPC, Prisma, WebSockets, and Subscriptions (npm)
DESCRIPTION: Command to create a new Next.js application using tRPC, Prisma, WebSockets, and subscriptions with npm. This starter includes ESLint and next-auth.

LANGUAGE: bash
CODE:
npx create-next-app --example https://github.com/trpc/trpc --example-path examples/next-prisma-websockets-starter trpc-prisma-websockets-starter

----------------------------------------

TITLE: Configuring TypeScript Strict Null Checks
DESCRIPTION: Alternative TypeScript configuration enabling only strictNullChecks if full strict mode is too restrictive.

LANGUAGE: json
CODE:
{
  // ...
  "compilerOptions": {
    // ...
    "strictNullChecks": true
  }
}

----------------------------------------

TITLE: Importing and Rendering Testimonial Content in JSX
DESCRIPTION: This snippet imports a Content component from an external MDX file and renders it within the current page. It's used to display testimonials and love for the tRPC project.

LANGUAGE: jsx
CODE:
import Content from '@site/unversioned/_love.mdx';

<Content />

----------------------------------------

TITLE: Installing Next.js Starter with Prisma using bun
DESCRIPTION: Command to create a new Next.js application with tRPC and Prisma integration using bun. This example includes E2E testing and ESLint configuration.

LANGUAGE: sh
CODE:
bunx create-next-app --example https://github.com/trpc/trpc --example-path examples/next-prisma-starter trpc-prisma-starter

----------------------------------------

TITLE: Setting up tRPC with Deno Deploy
DESCRIPTION: Code for creating a Deno Deploy function that uses tRPC. This setup handles incoming requests and routes them through the tRPC handler.

LANGUAGE: typescript
CODE:
import { fetchRequestHandler } from 'npm:@trpc/server/adapters/fetch';
import { createContext } from './context.ts';
import { appRouter } from './router.ts';

function handler(request) {
  return fetchRequestHandler({
    endpoint: '/trpc',
    req: request,
    router: appRouter,
    createContext,
  });
}

Deno.serve(handler);

----------------------------------------

TITLE: Installing and Running Development Server for React tRPC Example
DESCRIPTION: These commands install the necessary dependencies and start the development server for the React tRPC example project. It requires Node.js version 18 or higher due to the need for global fetch support.

LANGUAGE: bash
CODE:
npm i
npm run dev

----------------------------------------

TITLE: tRPC Error Response JSON Structure
DESCRIPTION: Demonstrates the JSON structure of an error response in tRPC. The example includes error details such as message, code, and additional metadata.

LANGUAGE: json
CODE:
[
  {
    "error": {
      "json": {
        "message": "Something went wrong",
        "code": -32600,
        "data": {
          "code": "INTERNAL_SERVER_ERROR",
          "httpStatus": 500,
          "stack": "...",
          "path": "post.add"
        }
      }
    }
  }
]

----------------------------------------

TITLE: Performing Non-Batched Query with tRPC in TypeScript
DESCRIPTION: This snippet shows how to perform a tRPC query without batching by setting the skipBatch context property.

LANGUAGE: typescript
CODE:
const postResult = proxy.posts.query(null, {
  context: {
    skipBatch: true,
  },
});

----------------------------------------

TITLE: Importing Contributing Content in MDX
DESCRIPTION: MDX code that imports and renders contribution guidelines content from an unversioned directory.

LANGUAGE: mdx
CODE:
import Content from '@site/unversioned/_contributing.mdx';

<Content />

----------------------------------------

TITLE: Cloning create-t3-turbo Repository
DESCRIPTION: Command to clone the create-t3-turbo repository, which demonstrates T3 Stack integration with Expo and Turborepo.

LANGUAGE: bash
CODE:
git clone git@github.com:t3-oss/create-t3-turbo.git

----------------------------------------

TITLE: Implementing Per-Route Authentication with tRPC Metadata in TypeScript
DESCRIPTION: This example shows how to use tRPC metadata for per-route authentication settings. It defines a Meta interface, creates an authenticated procedure, and implements a router with both public and protected routes.

LANGUAGE: typescript
CODE:
import { initTRPC } from '@trpc/server';

// [...]

interface Meta {
  authRequired: boolean;
}

export const t = initTRPC.context<Context>().meta<Meta>().create();

export const authedProcedure = t.procedure.use(async (opts) => {
  const { meta, next, ctx } = opts;
  // only check authorization if enabled
  if (meta?.authRequired && !ctx.user) {
    throw new TRPCError({ code: 'UNAUTHORIZED' });
  }
  return next();
});

export const appRouter = t.router({
  hello: authedProcedure.meta({ authRequired: false }).query(() => {
    return {
      greeting: 'hello world',
    };
  }),
  protectedHello: authedProcedure.meta({ authRequired: true }).query(() => {
    return {
      greeting: 'hello-world',
    };
  }),
});

----------------------------------------

TITLE: Implementing Per-Route Authentication with tRPC Metadata in TypeScript
DESCRIPTION: This example shows how to use tRPC metadata for per-route authentication settings. It defines a Meta interface, creates an authenticated procedure, and implements a router with both public and protected routes.

LANGUAGE: typescript
CODE:
import { initTRPC } from '@trpc/server';

// [...]

interface Meta {
  authRequired: boolean;
}

export const t = initTRPC.context<Context>().meta<Meta>().create();

export const authedProcedure = t.procedure.use(async (opts) => {
  const { meta, next, ctx } = opts;
  // only check authorization if enabled
  if (meta?.authRequired && !ctx.user) {
    throw new TRPCError({ code: 'UNAUTHORIZED' });
  }
  return next();
});

export const appRouter = t.router({
  hello: authedProcedure.meta({ authRequired: false }).query(() => {
    return {
      greeting: 'hello world',
    };
  }),
  protectedHello: authedProcedure.meta({ authRequired: true }).query(() => {
    return {
      greeting: 'hello-world',
    };
  }),
});

----------------------------------------

TITLE: Building and Starting tRPC Project
DESCRIPTION: Commands to build the tRPC project and start the production server. This should be run after development and testing are complete.

LANGUAGE: bash
CODE:
npm run build
npm run start

----------------------------------------

TITLE: tRPC Server Response JSON Structure
DESCRIPTION: Illustrates the JSON structure of a successful tRPC server response. The example shows a response containing a post object with id, title, and body properties.

LANGUAGE: json
CODE:
{
  "result": {
    "data": {
      "id": "1",
      "title": "Hello tRPC",
      "body": "..."
    }
  }
}

----------------------------------------

TITLE: Querying User Data with tRPC Vanilla Client in TypeScript
DESCRIPTION: Demonstrates how to use the tRPC Vanilla Client to query user data from an API. It imports the AppRouter type and uses the client's query method to fetch user information.

LANGUAGE: typescript
CODE:
import type { AppRouter } from '../path/to/server/trpc';

const bilbo = await client.getUser.query('id_bilbo');
// => { id: 'id_bilbo', name: 'Bilbo' };

----------------------------------------

TITLE: Installing Next.js Todo MVC Example with tRPC, SSG, and Prisma (npm)
DESCRIPTION: Command to create a new Next.js Todo MVC application using tRPC, Static Site Generation (SSG), and Prisma with npm.

LANGUAGE: bash
CODE:
npx create-next-app --example https://github.com/trpc/trpc --example-path examples/next-prisma-todomvc trpc-todo

----------------------------------------

TITLE: Initializing tRPC Client with TypeScript
DESCRIPTION: Shows how to create a typesafe tRPC client using the createTRPCClient method from @trpc/client. It uses the AppRouter type to ensure type safety for API calls.

LANGUAGE: typescript
CODE:
// pages/index.tsx
import { createTRPCClient } from '@trpc/client';
import type { AppRouter } from '../path/to/server/trpc';

const client = createTRPCClient<AppRouter>({
  url: 'http://localhost:5000/trpc',
});

----------------------------------------

TITLE: Installing and Building tRPC Main Project
DESCRIPTION: Commands to clone the tRPC repository, install dependencies, and start the development environment

LANGUAGE: bash
CODE:
git clone git@github.com:trpc/trpc.git
cd ./trpc
yarn
yarn dev

----------------------------------------

TITLE: Defining Nested Procedures in tRPC Router (TypeScript)
DESCRIPTION: Demonstrates how to define nested procedures in a tRPC router. The example shows a 'post' router with a 'byId' query procedure that takes a string input.

LANGUAGE: typescript
CODE:
export const appRouter = router({
  post: router({
    byId: publicProcedure.input(String).query(async (opts) => {
      // [...]
    }),
  }),
});

----------------------------------------

TITLE: Defining tRPC Router with Post Endpoint
DESCRIPTION: Creates a tRPC router with a nested post router containing a byId query procedure. The procedure accepts an ID parameter and returns a post object with id and title.

LANGUAGE: typescript
CODE:
import { initTRPC } from '@trpc/server';
import { z } from "zod";
const t = initTRPC.create();

const appRouter = t.router({
  post: t.router({
    byId: t.procedure
      .input(z.object({ id: z.string() }))
      .query(async ({input}) => {
        return { id: input.id, title: 'Hello' };
      }),
  })
});
export type AppRouter = typeof appRouter;

----------------------------------------

TITLE: Installing Express Server with tRPC Shield
DESCRIPTION: Command to create a new Express server with tRPC Shield and Prisma using create-trpc-appx.

LANGUAGE: bash
CODE:
npx create-trpc-appx --example https://github.com/omar-dulaimi/trpc-shield/tree/master/example

----------------------------------------

TITLE: Creating tRPC Router
DESCRIPTION: Example of creating a basic tRPC router with query and mutation procedures.

LANGUAGE: typescript
CODE:
import { initTRPC } from '@trpc/server';
import { z } from "zod";
const t = initTRPC.create();

const appRouter = t.router({
  getUser: t.procedure.input(z.object({ id: z.string() })).query(() => ({ name: 'foo' })),
  createUser: t.procedure.input(z.object({ name: z.string() })).mutation(() => 'bar'),
});
export type AppRouter = typeof appRouter;

----------------------------------------

TITLE: Running tRPC Server with Bun
DESCRIPTION: Command to start the tRPC server using Bun runtime. This should be executed in a terminal after installing Bun.

LANGUAGE: sh
CODE:
bun dev:server

----------------------------------------

TITLE: Using Custom Context with useQueries in tRPC React
DESCRIPTION: Demonstrates how to use a custom React Query context with the useQueries hook in tRPC. This allows overriding the default context for specific queries.

LANGUAGE: tsx
CODE:
const [post, greeting] = trpc.useQueries(
  (t) => [t.post.byId({ id: '1' }), t.greeting({ text: 'world' })],
  myCustomContext,
);

----------------------------------------

TITLE: Protected Procedures with Authentication Context
DESCRIPTION: Example implementation of protected and public procedures using tRPC context with authentication checks.

LANGUAGE: typescript
CODE:
import { initTRPC, TRPCError } from '@trpc/server';
import { Context } from './context';

const t = initTRPC.context<Context>().create();

export const router = t.router;

export const publicProcedure = t.procedure;

export const protectedProcedure = t.procedure.use(function isAuthed(opts) {
  if (!opts.ctx.session?.user?.email) {
    throw new TRPCError({
      code: 'UNAUTHORIZED',
    });
  }
  return opts.next({
    ctx: {
      session: opts.ctx.session,
    },
  });
});

----------------------------------------

TITLE: Initializing TodoMVC Project with Next.js and tRPC
DESCRIPTION: Commands to create a new Next.js project using the tRPC TodoMVC example template and start the development server. Creates a new project directory and installs all dependencies.

LANGUAGE: bash
CODE:
pnpm create next-app --example https://github.com/trpc/trpc --example-path examples/next-prisma-todomvc trpc-todo
cd trpc-todo
pnpm
pnpm dev

----------------------------------------

TITLE: Route-Level Query Prefetching
DESCRIPTION: Demonstrates how to implement route-level prefetching for tRPC queries using tanstack/react router.

LANGUAGE: tsx
CODE:
const utils = createTRPCQueryUtils({ queryClient, client: trpcClient });

// tanstack router/ react router loader
const loader = async (params: { id: string }) =>
  utils.post.byId.ensureQueryData({ id: params.id });

----------------------------------------

TITLE: Setting up tRPC Development Environment with Bash
DESCRIPTION: This snippet shows how to clone the tRPC repository, install dependencies, and build the project using pnpm. It's the initial setup process for contributors.

LANGUAGE: bash
CODE:
git clone git@github.com:trpc/trpc.git
cd trpc
pnpm install
pnpm build

----------------------------------------

TITLE: Providing Options to Individual Queries in useQueries
DESCRIPTION: Shows how to pass query options to individual queries within the useQueries hook. This example demonstrates setting 'enabled' option for one query and refetching it on button click.

LANGUAGE: tsx
CODE:
const Component = () => {
  const [post, greeting] = trpc.useQueries((t) => [
    t.post.byId({ id: '1' }, { enabled: false }),
    t.greeting({ text: 'world' }),
  ]);

  const onButtonClick = () => {
    post.refetch();
  };

  return (
    <div>
      <h1>{post.data && post.data.title}</h1>
      <p>{greeting.data.message}</p>
      <button onClick={onButtonClick}>Click to fetch</button>
    </div>
  );
};

----------------------------------------

TITLE: Making Non-Batched tRPC Query
DESCRIPTION: Shows how to make a tRPC query with batching disabled by setting the skipBatch context property. This example demonstrates direct client usage without React integration.

LANGUAGE: typescript
CODE:
const postResult = proxy.posts.query(null, {
  context: {
    skipBatch: true,
  },
});

----------------------------------------

TITLE: Setting up Next.js project with tRPC using create-next-app
DESCRIPTION: This snippet shows how to create a new Next.js project with tRPC integration using the create-next-app command. It clones a minimal starter template and installs dependencies.

LANGUAGE: bash
CODE:
npx create-next-app --example https://github.com/trpc/trpc --example-path examples/next-minimal-starter trpc-minimal-starter
cd trpc-minimal-starter
npm i
npm run dev

----------------------------------------

TITLE: Running tRPC Development Watcher with Bash
DESCRIPTION: This command starts a watcher that rebuilds all packages in the 'packages/*' directory whenever a file changes, facilitating continuous development.

LANGUAGE: bash
CODE:
# in project root directory
pnpm dev

----------------------------------------

TITLE: Implementing Infinite Query Procedure in tRPC (TypeScript)
DESCRIPTION: This snippet demonstrates how to set up a tRPC procedure for infinite queries using Prisma. It includes input validation with Zod and implements cursor-based pagination.

LANGUAGE: tsx
CODE:
import { initTRPC } from '@trpc/server';
import { z } from 'zod';
import { Context } from './[trpc]';

export const t = initTRPC.create();

export const appRouter = t.router({
  infinitePosts: t.procedure
    .input(
      z.object({
        limit: z.number().min(1).max(100).nullish(),
        cursor: z.number().nullish(), // <-- "cursor" needs to exist, but can be any type
      }),
    )
    .query(async (opts) => {
      const { input } = opts;
      const limit = input.limit ?? 50;
      const { cursor } = input;
      const items = await prisma.post.findMany({
        take: limit + 1, // get an extra item at the end which we'll use as next cursor
        where: {
          title: {
            contains: 'Prisma' /* Optional filter */,
          },
        },
        cursor: cursor ? { myCursor: cursor } : undefined,
        orderBy: {
          myCursor: 'asc',
        },
      });
      let nextCursor: typeof cursor | undefined = undefined;
      if (items.length > limit) {
        const nextItem = items.pop();
        nextCursor = nextItem!.myCursor;
      }

      return {
        items,
        nextCursor,
      };
    }),
});

----------------------------------------

TITLE: Setting up tRPC Providers
DESCRIPTION: Configuration of tRPC client and providers with React Query integration, including HTTP batch link setup.

LANGUAGE: tsx
CODE:
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { httpBatchLink } from '@trpc/client';
import React, { useState } from 'react';
import { trpc } from './utils/trpc';

export function App() {
  const [queryClient] = useState(() => new QueryClient());
  const [trpcClient] = useState(() =>
    trpc.createClient({
      links: [
        httpBatchLink({
          url: 'http://localhost:3000/trpc',

          // You can pass any HTTP headers you wish here
          async headers() {
            return {
              authorization: getAuthCookie(),
            };
          },
        }),
      ],
    }),
  );

  return (
    <trpc.Provider client={trpcClient} queryClient={queryClient}>
      <QueryClientProvider client={queryClient}>
        {/* Your app here */}
      </QueryClientProvider>
    </trpc.Provider>
  );
}

----------------------------------------

TITLE: Starting Next.js Development Server
DESCRIPTION: Command to start the Next.js development server for local development and testing.

LANGUAGE: bash
CODE:
npm run dev        # starts next.js

----------------------------------------

TITLE: Initializing tRPC Server Router with Post Endpoints
DESCRIPTION: Sets up a tRPC router with post-related procedures including fetching all posts and getting posts by ID. Includes error handling and type definitions.

LANGUAGE: typescript
CODE:
import { initTRPC, TRPCError } from '@trpc/server';
import { z } from 'zod';

const t = initTRPC.create();

const posts = [
  { id: '1', title: 'everlong' },
  { id: '2', title: 'After Dark' },
];

const appRouter = t.router({
  post: t.router({
    all: t.procedure
      .input(
        z.object({
          cursor: z.string().optional(),
        })
      )
      .query(({ input }) => {
        return {
          posts,
          nextCursor: '123' as string | undefined,
        };
      }),
    byId: t.procedure
      .input(
        z.object({
          id: z.string(),
        })
      )
      .query(({ input }) => {
        const post = posts.find(p => p.id === input.id);
        if (!post) {
          throw new TRPCError({
            code: 'NOT_FOUND',
          })
        }
        return post;
     }),
  }),
});

export type AppRouter = typeof appRouter;

----------------------------------------

TITLE: Initializing Server-Side Helpers with Internal Router in TypeScript
DESCRIPTION: This snippet demonstrates how to create server-side helpers using the internal router method in a monolithic Next.js application. It requires direct access to the tRPC router and uses the createServerSideHelpers function.

LANGUAGE: typescript
CODE:
import { createServerSideHelpers } from '@trpc/react-query/server';
import { createContext } from '~/server/context';
import superjson from 'superjson';

const helpers = createServerSideHelpers({
  router: appRouter,
  ctx: await createContext(),
  transformer: superjson, // optional - adds superjson serialization
});

----------------------------------------

TITLE: Using tRPC React Query Integration in a React Component
DESCRIPTION: This snippet demonstrates how to use the tRPC React Query integration in a React component. It shows both querying and mutation examples using tRPC hooks.

LANGUAGE: tsx
CODE:
import { trpc } from '../utils/trpc';

export default function IndexPage() {
  const helloQuery = trpc.hello.useQuery({ name: 'Bob' });
  const goodbyeMutation = trpc.goodbye.useMutation();

  return (
    <div>
      <p>{helloQuery.data?.greeting}</p>

      <button onClick={() => goodbyeMutation.mutate()}>Say Goodbye</button>
    </div>
  );
}

----------------------------------------

TITLE: Building and Starting tRPC Production Server
DESCRIPTION: Commands for building the production version of the tRPC application and starting the production server. The build process optimizes the code for production deployment.

LANGUAGE: bash
CODE:
pnpm build
pnpm start

----------------------------------------

TITLE: Configuring tRPC Client without Batching in Next.js
DESCRIPTION: Shows how to configure the tRPC client in a Next.js application to use a batch-free link (httpLink) instead of the default batching link.

LANGUAGE: typescript
CODE:
import { httpLink } from '@trpc/client/links/httpLink';
import { withTRPC } from '@trpc/next';
import { AppType } from 'next/dist/shared/lib/utils';
import type { AppRouter } from 'pages/api/trpc/[trpc]';

const MyApp: AppType = ({ Component, pageProps }) => {
  return <Component {...pageProps} />;
};

export default withTRPC<AppRouter>({
  config() {
    return {
      links: [
        httpLink({
          url: '/api/trpc',
        }),
      ],
    };
  },
  // ssr: false,
})(MyApp);

----------------------------------------

TITLE: Configuring tRPC Client without Batching in Next.js
DESCRIPTION: Shows how to configure the tRPC client in a Next.js application to use a batch-free link (httpLink) instead of the default batching link.

LANGUAGE: typescript
CODE:
import { httpLink } from '@trpc/client/links/httpLink';
import { withTRPC } from '@trpc/next';
import { AppType } from 'next/dist/shared/lib/utils';
import type { AppRouter } from 'pages/api/trpc/[trpc]';

const MyApp: AppType = ({ Component, pageProps }) => {
  return <Component {...pageProps} />;
};

export default withTRPC<AppRouter>({
  config() {
    return {
      links: [
        httpLink({
          url: '/api/trpc',
        }),
      ],
    };
  },
  // ssr: false,
})(MyApp);

----------------------------------------

TITLE: Recommended File Structure for tRPC with Next.js
DESCRIPTION: A graphql representation of the recommended file structure for a tRPC project with Next.js. It shows the organization of directories and files for prisma, pages, server, and utils.

LANGUAGE: graphql
CODE:
.
├── prisma  # <-- if prisma is added
│   └── [..]
├── src
│   ├── pages
│   │   ├── _app.tsx  # <-- add `withTRPC()`-HOC here
│   │   ├── api
│   │   │   └── trpc
│   │   │       └── [trpc].ts  # <-- tRPC HTTP handler
│   │   └── [..]
│   ├── server
│   │   ├── routers
│   │   │   ├── _app.ts  # <-- main app router
│   │   │   ├── post.ts  # <-- sub routers
│   │   │   └── [..]
│   │   ├── context.ts   # <-- create app context
│   │   └── trpc.ts      # <-- procedure helpers
│   └── utils
│       └── trpc.ts  # <-- your typesafe tRPC hooks
└── [..]

----------------------------------------

TITLE: Creating WebSocket Server for tRPC
DESCRIPTION: Shows how to create a WebSocket server using the 'ws' package and apply the tRPC WebSocket handler. It includes error handling and graceful shutdown.

LANGUAGE: bash
CODE:
yarn add ws

LANGUAGE: typescript
CODE:
import { applyWSSHandler } from '@trpc/server/adapters/ws';
import ws from 'ws';
import { appRouter } from './routers/app';
import { createContext } from './trpc';

const wss = new ws.Server({
  port: 3001,
});
const handler = applyWSSHandler({ wss, router: appRouter, createContext });

wss.on('connection', (ws) => {
  console.log(`➕➕ Connection (${wss.clients.size})`);
  ws.once('close', () => {
    console.log(`➖➖ Connection (${wss.clients.size})`);
  });
});
console.log('✅ WebSocket Server listening on ws://localhost:3001');

process.on('SIGTERM', () => {
  console.log('SIGTERM');
  handler.broadcastReconnectNotification();
  wss.close();
});

----------------------------------------

TITLE: Configuring VSCode TypeScript Settings
DESCRIPTION: JSON configuration for VSCode to use the correct TypeScript version from node_modules.

LANGUAGE: json
CODE:
{
  "typescript.tsdk": "node_modules/typescript/lib",
  "typescript.enablePromptUseWorkspaceTsdk": true
}

----------------------------------------

TITLE: Adding Query Procedure to tRPC Router in TypeScript
DESCRIPTION: Adds a 'userList' query procedure to the router that retrieves users from a database.

LANGUAGE: typescript
CODE:
import { db } from './db';
import { publicProcedure, router } from './trpc';

const appRouter = router({
  userList: publicProcedure
    .query(async () => {
      const users = await db.user.findMany();
      return users;
    }),
});

----------------------------------------

TITLE: Starting Local Development Server
DESCRIPTION: Command to start the local development server with TypeDoc generation disabled. Opens a browser window and includes hot reloading functionality.

LANGUAGE: console
CODE:
TYPEDOC=0 pnpm dev

----------------------------------------

TITLE: Configuring tRPC Client with SSR Caching
DESCRIPTION: Implementation of tRPC client configuration with SSR support and response caching using Vercel's edge caching. Includes conditional URL handling for development and production environments, and cache control headers configuration.

LANGUAGE: typescript
CODE:
import { httpBatchLink } from '@trpc/client';
import { createTRPCNext } from '@trpc/next';
import type { AppRouter } from '../server/routers/_app';

export const trpc = createTRPCNext<AppRouter>({
  config(opts) {
    if (typeof window !== 'undefined') {
      return {
        links: [
          httpBatchLink({
            url: '/api/trpc',
          }),
        ],
      };
    }

    const url = process.env.VERCEL_URL
      ? `https://${process.env.VERCEL_URL}/api/trpc`
      : 'http://localhost:3000/api/trpc';

    return {
      links: {
        http: httpBatchLink({
          url,
        }),
      },
    };
  },
  ssr: true,
  responseMeta(opts) {
    const { clientErrors } = opts;

    if (clientErrors.length) {
      return {
        status: clientErrors[0].data?.httpStatus ?? 500,
      };
    }

    const ONE_DAY_IN_SECONDS = 60 * 60 * 24;
    return {
      headers: new Headers([
        [
          'cache-control',
          `s-maxage=1, stale-while-revalidate=${ONE_DAY_IN_SECONDS}`,
        ],
      ]),
    };
  },
});

----------------------------------------

TITLE: Replacing httpBatchLink with httpLink in tRPC Client (TypeScript)
DESCRIPTION: This code shows how to replace the httpBatchLink with httpLink in the tRPC client configuration when disabling request batching.

LANGUAGE: typescript
CODE:
import { createTRPCProxyClient, httpLink } from '@trpc/client';
import type { AppRouter } from '../server';

const client = createTRPCProxyClient<AppRouter>({
  links: [
    httpLink({
      url: 'http://localhost:3000',
    }),
  ],
});

----------------------------------------

TITLE: Setting Default Metadata and Chaining in tRPC with TypeScript
DESCRIPTION: This snippet illustrates how to set default values for metadata in tRPC, and how metadata is shallow merged when chaining procedures. It defines a Meta interface with authRequired and role properties, and demonstrates creating public, authenticated, and admin procedures.

LANGUAGE: typescript
CODE:
import { initTRPC } from '@trpc/server';

interface Meta {
  authRequired: boolean;
  role?: 'user' | 'admin'
}

export const t = initTRPC
  .context<Context>()
  .meta<Meta>()
  .create({
    // Set a default value
    defaultMeta: { authRequired: false }
  });

const publicProcedure = t.procedure
// ^ Default Meta: { authRequired: false }

const authProcedure = publicProcedure
  .use(authMiddleware)
  .meta({
    authRequired: true;
    role: 'user'
  });
// ^ Meta: { authRequired: true, role: 'user' }

const adminProcedure = authProcedure
  .meta({
    role: 'admin'
  });
// ^ Meta: { authRequired: true, role: 'admin' }

----------------------------------------

TITLE: Installing and Setting Up Prisma + tRPC Project with Next.js
DESCRIPTION: Commands to create a new Next.js project using the tRPC and Prisma starter template, navigate to the project directory, install dependencies, and start the development environment.

LANGUAGE: bash
CODE:
pnpm create next-app --example https://github.com/trpc/trpc --example-path examples/next-prisma-starter trpc-prisma-starter
cd trpc-prisma-starter
pnpm
pnpm dx

----------------------------------------

TITLE: Importing and Rendering Contributing Guidelines in JSX
DESCRIPTION: This code snippet imports content from an external Markdown file and renders it within the current page. It uses JSX syntax to include the content dynamically.

LANGUAGE: jsx
CODE:
import Content from '@site/unversioned/_contributing.mdx';

<Content />

----------------------------------------

TITLE: Setting Default Metadata and Chaining in tRPC with TypeScript
DESCRIPTION: This snippet illustrates how to set default values for metadata in tRPC, and how metadata is shallow merged when chaining procedures. It defines a Meta interface with authRequired and role properties, and demonstrates creating public, authenticated, and admin procedures.

LANGUAGE: typescript
CODE:
import { initTRPC } from '@trpc/server';

interface Meta {
  authRequired: boolean;
  role?: 'user' | 'admin'
}

export const t = initTRPC
  .context<Context>()
  .meta<Meta>()
  .create({
    // Set a default value
    defaultMeta: { authRequired: false }
  });

const publicProcedure = t.procedure
// ^ Default Meta: { authRequired: false }

const authProcedure = publicProcedure
  .use(authMiddleware)
  .meta({
    authRequired: true;
    role: 'user'
  });
// ^ Meta: { authRequired: true, role: 'user' }

const adminProcedure = authProcedure
  .meta({
    role: 'admin'
  });
// ^ Meta: { authRequired: true, role: 'admin' }

----------------------------------------

TITLE: Setting Default Metadata and Chaining in tRPC with TypeScript
DESCRIPTION: This snippet illustrates how to set default values for metadata in tRPC, and how metadata is shallow merged when chaining procedures. It defines a Meta interface with authRequired and role properties, and demonstrates creating public, authenticated, and admin procedures.

LANGUAGE: typescript
CODE:
import { initTRPC } from '@trpc/server';

interface Meta {
  authRequired: boolean;
  role?: 'user' | 'admin'
}

export const t = initTRPC
  .context<Context>()
  .meta<Meta>()
  .create({
    // Set a default value
    defaultMeta: { authRequired: false }
  });

const publicProcedure = t.procedure
// ^ Default Meta: { authRequired: false }

const authProcedure = publicProcedure
  .use(authMiddleware)
  .meta({
    authRequired: true;
    role: 'user'
  });
// ^ Meta: { authRequired: true, role: 'user' }

const adminProcedure = authProcedure
  .meta({
    role: 'admin'
  });
// ^ Meta: { authRequired: true, role: 'admin' }

----------------------------------------

TITLE: Installing tRPC Client Libraries using Package Managers
DESCRIPTION: Commands for installing @trpc/client and @trpc/server using different package managers (npm, yarn, pnpm, bun).

LANGUAGE: bash
CODE:
npm install @trpc/client @trpc/server

LANGUAGE: bash
CODE:
yarn add @trpc/client @trpc/server

LANGUAGE: bash
CODE:
pnpm add @trpc/client @trpc/server

LANGUAGE: bash
CODE:
bun add @trpc/client @trpc/server

----------------------------------------

TITLE: Rendering Sponsors Content in MDX
DESCRIPTION: Imports and renders sponsor content from an external MDX file located at '@site/unversioned/_sponsors.mdx' using React components in an MDX documentation page.

LANGUAGE: jsx
CODE:
import Content from '@site/unversioned/_sponsors.mdx';

<Content />

----------------------------------------

TITLE: Merging Routers with t.mergeRouters in tRPC
DESCRIPTION: Demonstrates how to merge multiple routers into a single flat namespace using t.mergeRouters. This approach avoids nested namespaces and keeps all procedures at the root level.

LANGUAGE: typescript
CODE:
import { router, publicProcedure, mergeRouters } from '../trpc';
import { z } from 'zod';

import { userRouter } from './user';
import { postRouter } from './post';

const appRouter = mergeRouters(userRouter, postRouter)

export type AppRouter = typeof appRouter;

----------------------------------------

TITLE: Defining tRPC Router in TypeScript
DESCRIPTION: This snippet defines a tRPC router with procedures for listing, retrieving by ID, and creating posts. It uses Zod for input validation and demonstrates query and mutation handlers.

LANGUAGE: typescript
CODE:
import { initTRPC } from '@trpc/server';
import { z } from "zod";

const t = initTRPC.create();

const appRouter = t.router({
  post: t.router({
    list: t.procedure
      .query(() => {
        // imaginary db call
        return [{ id: 1, title: 'tRPC is the best!' }];
    }),
    byId: t.procedure
      .input(z.string())
      .query((opts) => {
        // imaginary db call
        return { id: 1, title: 'tRPC is the best!' };
    }),
    create: t.procedure
      .input(z.object({ title: z.string(), text: z.string(), }))
      .mutation((opts) => {
        // imaginary db call
        return { id: 1, ...opts.input };
    }),
  }),
});

export type AppRouter = typeof appRouter;

----------------------------------------

TITLE: Setting Canonical URL for tRPC Sponsors Page
DESCRIPTION: This HTML snippet sets the canonical URL for the tRPC sponsors documentation page. It ensures search engines understand the preferred version of the page.

LANGUAGE: HTML
CODE:
<head>
  <link rel="canonical" href="https://trpc.io/docs/sponsors" />
</head>

----------------------------------------

TITLE: Creating Next.js Prisma Starter with tRPC
DESCRIPTION: Command to create a new Next.js project with tRPC, Prisma, E2E testing, and ESLint configuration using create-next-app.

LANGUAGE: bash
CODE:
yarn create next-app --example https://github.com/trpc/trpc --example-path examples/next-prisma-starter trpc-prisma-starter

----------------------------------------

TITLE: Importing Contributing Content in MDX
DESCRIPTION: MDX code that imports and displays contributing documentation content from an external file located at '@site/unversioned/_contributing.mdx'.

LANGUAGE: mdx
CODE:
import Content from '@site/unversioned/_contributing.mdx';

<Content />

----------------------------------------

TITLE: Throwing Custom tRPC Errors
DESCRIPTION: Demonstrates how to throw custom errors in tRPC procedures using the TRPCError class with custom error codes and messages.

LANGUAGE: typescript
CODE:
import { initTRPC, TRPCError } from '@trpc/server';

const t = initTRPC.create();

const appRouter = t.router({
  hello: t.procedure.query(() => {
    throw new TRPCError({
      code: 'INTERNAL_SERVER_ERROR',
      message: 'An unexpected error occurred, please try again later.',
      // optional: pass the original error to retain stack trace
      cause: theError,
    });
  }),
});

----------------------------------------

TITLE: Throwing Custom tRPC Errors
DESCRIPTION: Demonstrates how to throw custom errors in tRPC procedures using the TRPCError class with custom error codes and messages.

LANGUAGE: typescript
CODE:
import { initTRPC, TRPCError } from '@trpc/server';

const t = initTRPC.create();

const appRouter = t.router({
  hello: t.procedure.query(() => {
    throw new TRPCError({
      code: 'INTERNAL_SERVER_ERROR',
      message: 'An unexpected error occurred, please try again later.',
      // optional: pass the original error to retain stack trace
      cause: theError,
    });
  }),
});

----------------------------------------

TITLE: DataTransformer Interface Definition in TypeScript
DESCRIPTION: TypeScript interface definitions for data transformers in tRPC, including separate interfaces for input and output transformers. These interfaces define the structure for serialization and deserialization functions.

LANGUAGE: typescript
CODE:
export interface DataTransformer {
  serialize(object: any): any;
  deserialize(object: any): any;
}

interface InputDataTransformer extends DataTransformer {
  /**
   * This function runs **on the client** before sending the data to the server.
   */
  serialize(object: any): any;
  /**
   * This function runs **on the server** to transform the data before it is passed to the resolver
   */
  deserialize(object: any): any;
}

interface OutputDataTransformer extends DataTransformer {
  /**
   * This function runs **on the server** before sending the data to the client.
   */
  serialize(object: any): any;
  /**
   * This function runs **only on the client** to transform the data sent from the server.
   */
  deserialize(object: any): any;
}

export interface CombinedDataTransformer {
  /**
   * Specify how the data sent from the client to the server should be transformed.
   */
  input: InputDataTransformer;
  /**
   * Specify how the data sent from the server to the client should be transformed.
   */
  output: OutputDataTransformer;
}

----------------------------------------

TITLE: Importing and Rendering Sponsors Content in JSX
DESCRIPTION: This code snippet imports a Content component from an external file and renders it within the current page. It's likely used to display a list of sponsors for the trpc project.

LANGUAGE: jsx
CODE:
import Content from '@site/unversioned/_sponsors.mdx';

<Content />

----------------------------------------

TITLE: Creating a Basic tRPC Router in TypeScript
DESCRIPTION: Defines a basic tRPC router instance. This is the foundation for adding query and mutation endpoints to your API.

LANGUAGE: typescript
CODE:
import * as trpc from '@trpc/server';

const appRouter = trpc.router();

// only export *type signature* of router!
// to avoid accidentally importing your API
// into client-side code
export type AppRouter = typeof appRouter;

----------------------------------------

TITLE: Implementing tRPC Backend Router
DESCRIPTION: Backend implementation showing how to create a tRPC router with a 'hello' procedure that accepts optional text input and returns a greeting message. Uses Zod for input validation.

LANGUAGE: tsx
CODE:
import { initTRPC } from '@trpc/server';
import { z } from 'zod';

export const t = initTRPC.create();

export const appRouter = t.router({
  // Create procedure at path 'hello'
  hello: t.procedure
    // using zod schema to validate and infer input values
    .input(
      z
        .object({
          text: z.string().nullish(),
        })
        .nullish(),
    )
    .query((opts) => {
      return {
        greeting: `hello ${opts.input?.text ?? 'world'}`,
      };
    }),
});

----------------------------------------

TITLE: Implementing tRPC Backend Router
DESCRIPTION: Backend implementation showing how to create a tRPC router with a 'hello' procedure that accepts optional text input and returns a greeting message. Uses Zod for input validation.

LANGUAGE: tsx
CODE:
import { initTRPC } from '@trpc/server';
import { z } from 'zod';

export const t = initTRPC.create();

export const appRouter = t.router({
  // Create procedure at path 'hello'
  hello: t.procedure
    // using zod schema to validate and infer input values
    .input(
      z
        .object({
          text: z.string().nullish(),
        })
        .nullish(),
    )
    .query((opts) => {
      return {
        greeting: `hello ${opts.input?.text ?? 'world'}`,
      };
    }),
});

----------------------------------------

TITLE: Implementing Backend Router with tRPC in TypeScript
DESCRIPTION: Demonstrates how to set up a tRPC router on the backend, defining a 'hello' procedure with input validation using Zod schema.

LANGUAGE: tsx
CODE:
import { initTRPC } from '@trpc/server';
import { z } from 'zod';

export const t = initTRPC.create();

export const appRouter = t.router({
  // Create procedure at path 'hello'
  hello: t.procedure
    // using zod schema to validate and infer input values
    .input(
      z
        .object({
          text: z.string().nullish(),
        })
        .nullish(),
    )
    .query((opts) => {
      return {
        greeting: `hello ${opts.input?.text ?? 'world'}`,
      };
    }),
});

----------------------------------------

TITLE: Using router.createCaller() for Input Query in TypeScript
DESCRIPTION: This example shows how to create a router with an input query procedure and use router.createCaller() to make a server-side call to the greeting procedure.

LANGUAGE: typescript
CODE:
import { initTRPC } from '@trpc/server';
import { z } from 'zod';

const t = initTRPC.create();

const router = t.router({
  // Create procedure at path 'greeting'
  greeting: t.procedure
    .input(z.object({ name: z.string() }))
    .query((opts) => `Hello ${opts.input.name}`),
});

const caller = router.createCaller({});
const result = await caller.greeting({ name: 'tRPC' });

----------------------------------------

TITLE: Implementing tRPC Server Router
DESCRIPTION: Creates HTTP server with router implementation including userList, userById, and userCreate procedures

LANGUAGE: typescript
CODE:
import { createHTTPServer } from "@trpc/server/adapters/standalone";
import { z } from "zod";
import { db } from "./db";
import { publicProcedure, router } from "./trpc";

const appRouter = router({
  userList: publicProcedure
    .query(async () => {
      const users = await db.user.findMany();
      return users;
    }),
  userById: publicProcedure
    .input(z.string())
    .query(async (opts) => {
      const { input } = opts;
      const user = await db.user.findById(input);
      return user;
    }),
  userCreate: publicProcedure
    .input(z.object({ name: z.string() }))
    .mutation(async (opts) => {
      const { input } = opts;
      const user = await db.user.create(input);
      return user;
    }),
});

export type AppRouter = typeof appRouter;

const server = createHTTPServer({
  router: appRouter,
});

server.listen(3000);

----------------------------------------

TITLE: Implementing tRPC Server Router
DESCRIPTION: Creates HTTP server with router implementation including userList, userById, and userCreate procedures

LANGUAGE: typescript
CODE:
import { createHTTPServer } from "@trpc/server/adapters/standalone";
import { z } from "zod";
import { db } from "./db";
import { publicProcedure, router } from "./trpc";

const appRouter = router({
  userList: publicProcedure
    .query(async () => {
      const users = await db.user.findMany();
      return users;
    }),
  userById: publicProcedure
    .input(z.string())
    .query(async (opts) => {
      const { input } = opts;
      const user = await db.user.findById(input);
      return user;
    }),
  userCreate: publicProcedure
    .input(z.object({ name: z.string() }))
    .mutation(async (opts) => {
      const { input } = opts;
      const user = await db.user.create(input);
      return user;
    }),
});

export type AppRouter = typeof appRouter;

const server = createHTTPServer({
  router: appRouter,
});

server.listen(3000);

----------------------------------------

TITLE: Implementing tRPC Server Router
DESCRIPTION: Creates HTTP server with router implementation including userList, userById, and userCreate procedures

LANGUAGE: typescript
CODE:
import { createHTTPServer } from "@trpc/server/adapters/standalone";
import { z } from "zod";
import { db } from "./db";
import { publicProcedure, router } from "./trpc";

const appRouter = router({
  userList: publicProcedure
    .query(async () => {
      const users = await db.user.findMany();
      return users;
    }),
  userById: publicProcedure
    .input(z.string())
    .query(async (opts) => {
      const { input } = opts;
      const user = await db.user.findById(input);
      return user;
    }),
  userCreate: publicProcedure
    .input(z.object({ name: z.string() }))
    .mutation(async (opts) => {
      const { input } = opts;
      const user = await db.user.create(input);
      return user;
    }),
});

export type AppRouter = typeof appRouter;

const server = createHTTPServer({
  router: appRouter,
});

server.listen(3000);

----------------------------------------

TITLE: Extracting HTTP Status Code from tRPC Error
DESCRIPTION: Shows how to use the getHTTPStatusCodeFromError helper function to extract HTTP status codes from tRPC errors.

LANGUAGE: typescript
CODE:
import { getHTTPStatusCodeFromError } from '@trpc/server/http';

// Example error you might get if your input validation fails
const error: TRPCError = {
  name: 'TRPCError',
  code: 'BAD_REQUEST',
  message: '\"password\" must be at least 4 characters',
};

if (error instanceof TRPCError) {
  const httpCode = getHTTPStatusCodeFromError(error);
  console.log(httpCode); // 400
}

----------------------------------------

TITLE: Extracting HTTP Status Code from tRPC Error
DESCRIPTION: Shows how to use the getHTTPStatusCodeFromError helper function to extract HTTP status codes from tRPC errors.

LANGUAGE: typescript
CODE:
import { getHTTPStatusCodeFromError } from '@trpc/server/http';

// Example error you might get if your input validation fails
const error: TRPCError = {
  name: 'TRPCError',
  code: 'BAD_REQUEST',
  message: '\"password\" must be at least 4 characters',
};

if (error instanceof TRPCError) {
  const httpCode = getHTTPStatusCodeFromError(error);
  console.log(httpCode); // 400
}

----------------------------------------

TITLE: Extracting HTTP Status Code from tRPC Error
DESCRIPTION: Shows how to use the getHTTPStatusCodeFromError helper function to extract HTTP status codes from tRPC errors.

LANGUAGE: typescript
CODE:
import { getHTTPStatusCodeFromError } from '@trpc/server/http';

// Example error you might get if your input validation fails
const error: TRPCError = {
  name: 'TRPCError',
  code: 'BAD_REQUEST',
  message: '\"password\" must be at least 4 characters',
};

if (error instanceof TRPCError) {
  const httpCode = getHTTPStatusCodeFromError(error);
  console.log(httpCode); // 400
}

----------------------------------------

TITLE: Configuring httpBatchLink in tRPC Client (TypeScript)
DESCRIPTION: This snippet demonstrates how to import and configure the httpBatchLink in a tRPC client. It shows the basic setup for creating a client proxy with the httpBatchLink.

LANGUAGE: typescript
CODE:
import { createTRPCProxyClient, httpBatchLink } from '@trpc/client';
import type { AppRouter } from '../server';

const client = createTRPCProxyClient<AppRouter>({
  links: [
    httpBatchLink({
      url: 'http://localhost:3000',
    }),
  ],
});

----------------------------------------

TITLE: Configuring httpBatchLink in tRPC Client (TypeScript)
DESCRIPTION: This snippet demonstrates how to import and configure the httpBatchLink in a tRPC client. It shows the basic setup for creating a client proxy with the httpBatchLink.

LANGUAGE: typescript
CODE:
import { createTRPCProxyClient, httpBatchLink } from '@trpc/client';
import type { AppRouter } from '../server';

const client = createTRPCProxyClient<AppRouter>({
  links: [
    httpBatchLink({
      url: 'http://localhost:3000',
    }),
  ],
});

----------------------------------------

TITLE: Configuring httpBatchLink in tRPC Client (TypeScript)
DESCRIPTION: This snippet demonstrates how to import and configure the httpBatchLink in a tRPC client. It shows the basic setup for creating a client proxy with the httpBatchLink.

LANGUAGE: typescript
CODE:
import { createTRPCProxyClient, httpBatchLink } from '@trpc/client';
import type { AppRouter } from '../server';

const client = createTRPCProxyClient<AppRouter>({
  links: [
    httpBatchLink({
      url: 'http://localhost:3000',
    }),
  ],
});

----------------------------------------

TITLE: Disabling Request Batching on tRPC Server
DESCRIPTION: Demonstrates how to disable request batching on the tRPC server side in a Next.js API route.

LANGUAGE: typescript
CODE:
export default trpcNext.createNextApiHandler({
  // [...]
  // 👇 disable batching
  batching: {
    enabled: false,
  },
});

----------------------------------------

TITLE: Disabling Request Batching on tRPC Server
DESCRIPTION: Demonstrates how to disable request batching on the tRPC server side in a Next.js API route.

LANGUAGE: typescript
CODE:
export default trpcNext.createNextApiHandler({
  // [...]
  // 👇 disable batching
  batching: {
    enabled: false,
  },
});

----------------------------------------

TITLE: Implementing Admin Authorization Middleware in tRPC
DESCRIPTION: Creates an admin authorization middleware that checks if the user has admin privileges before allowing access to protected procedures. Throws UNAUTHORIZED error if user is not an admin.

LANGUAGE: typescript
CODE:
const adminProcedure = publicProcedure.use(async (opts) => {
  const { ctx } = opts;
  if (!ctx.user?.isAdmin) {
    throw new TRPCError({ code: 'UNAUTHORIZED' });
  }
  return opts.next({
    ctx: {
      user: ctx.user,
    },
  });
});

----------------------------------------

TITLE: Implementing Protected Server Action with Input Validation
DESCRIPTION: Example of creating a protected server action with Zod input validation for creating posts. Shows how to use the protectedAction builder with input validation.

LANGUAGE: typescript
CODE:
'use server';

import { z } from 'zod';
import { protectedAction } from '../server/trpc';

export const createPost = protectedAction
  .input(
    z.object({
      title: z.string(),
    }),
  )
  .mutation(async ({ ctx, input }) => {
    // Do something with the input
  });

----------------------------------------

TITLE: Implementing Protected Server Action with Input Validation
DESCRIPTION: Example of creating a protected server action with Zod input validation for creating posts. Shows how to use the protectedAction builder with input validation.

LANGUAGE: typescript
CODE:
'use server';

import { z } from 'zod';
import { protectedAction } from '../server/trpc';

export const createPost = protectedAction
  .input(
    z.object({
      title: z.string(),
    }),
  )
  .mutation(async ({ ctx, input }) => {
    // Do something with the input
  });

----------------------------------------

TITLE: Configuring Global Request Abortion in tRPC Client
DESCRIPTION: Demonstrates how to set up global request abortion behavior by configuring the tRPC React client with abortOnUnmount option.

LANGUAGE: typescript
CODE:
import { createTRPCReact } from '@trpc/react-query';

export const trpc = createTRPCReact<AppRouter>({
  abortOnUnmount: true,
});

trpc.createClient({
  // ...
});

----------------------------------------

TITLE: Installing Next.js Starter with Prisma using pnpm
DESCRIPTION: Command to create a new Next.js application with tRPC and Prisma integration using pnpm. This example includes E2E testing and ESLint configuration.

LANGUAGE: sh
CODE:
pnpx create-next-app --example https://github.com/trpc/trpc --example-path examples/next-prisma-starter trpc-prisma-starter

----------------------------------------

TITLE: Installing Next.js Starter with Prisma using pnpm
DESCRIPTION: Command to create a new Next.js application with tRPC and Prisma integration using pnpm. This example includes E2E testing and ESLint configuration.

LANGUAGE: sh
CODE:
pnpx create-next-app --example https://github.com/trpc/trpc --example-path examples/next-prisma-starter trpc-prisma-starter

----------------------------------------

TITLE: Setting Maximum URL Length for httpBatchLink (TypeScript)
DESCRIPTION: This snippet shows how to set a maximum URL length for the httpBatchLink to prevent HTTP errors related to large payloads or long URIs.

LANGUAGE: typescript
CODE:
import { createTRPCProxyClient, httpBatchLink } from '@trpc/client';
import type { AppRouter } from '../server';

const client = createTRPCProxyClient<AppRouter>({
  links: [
    httpBatchLink({
      url: 'http://localhost:3000',
      maxURLLength: 2083, // a suitable size
    }),
  ],
});

----------------------------------------

TITLE: Setting Maximum URL Length for httpBatchLink (TypeScript)
DESCRIPTION: This snippet shows how to set a maximum URL length for the httpBatchLink to prevent HTTP errors related to large payloads or long URIs.

LANGUAGE: typescript
CODE:
import { createTRPCProxyClient, httpBatchLink } from '@trpc/client';
import type { AppRouter } from '../server';

const client = createTRPCProxyClient<AppRouter>({
  links: [
    httpBatchLink({
      url: 'http://localhost:3000',
      maxURLLength: 2083, // a suitable size
    }),
  ],
});

----------------------------------------

TITLE: Implementing Conditional SSR with tRPC
DESCRIPTION: Example of conditional SSR implementation that enables server-side rendering based on specific conditions (e.g., user agent). Shows how to use the ssr callback for dynamic SSR decisions.

LANGUAGE: typescript
CODE:
import { httpBatchLink } from '@trpc/client';
import { createTRPCNext } from '@trpc/next';
import superjson from 'superjson';
import type { AppRouter } from './api/trpc/[trpc]';

export const trpc = createTRPCNext<AppRouter>({
  config(opts) {
    const { ctx } = opts;
    if (typeof window !== 'undefined') {
      // during client requests
      return {
        links: [
          httpBatchLink({
            url: '/api/trpc',
          }),
        ],
      };
    }

    return {
      links: [
        httpBatchLink({
          // The server needs to know your app's full url
          url: `${getBaseUrl()}/api/trpc`,
          /**
           * Set custom request headers on every request from tRPC
           * @see https://trpc.io/docs/v10/header
           */
          headers() {
            if (!ctx?.req?.headers) {
              return {};
            }
            // To use SSR properly, you need to forward client headers to the server
            // This is so you can pass through things like cookies when we're server-side rendering
            return {
              cookie: ctx.req.headers.cookie,
            };
          },
        }),
      ],
    };
  },
  ssr(opts) {
    // only SSR if the request is coming from a bot
    return opts.ctx?.req?.headers['user-agent']?.includes('bot');
  },
});

----------------------------------------

TITLE: Implementing Conditional SSR with tRPC
DESCRIPTION: Example of conditional SSR implementation that enables server-side rendering based on specific conditions (e.g., user agent). Shows how to use the ssr callback for dynamic SSR decisions.

LANGUAGE: typescript
CODE:
import { httpBatchLink } from '@trpc/client';
import { createTRPCNext } from '@trpc/next';
import superjson from 'superjson';
import type { AppRouter } from './api/trpc/[trpc]';

export const trpc = createTRPCNext<AppRouter>({
  config(opts) {
    const { ctx } = opts;
    if (typeof window !== 'undefined') {
      // during client requests
      return {
        links: [
          httpBatchLink({
            url: '/api/trpc',
          }),
        ],
      };
    }

    return {
      links: [
        httpBatchLink({
          // The server needs to know your app's full url
          url: `${getBaseUrl()}/api/trpc`,
          /**
           * Set custom request headers on every request from tRPC
           * @see https://trpc.io/docs/v10/header
           */
          headers() {
            if (!ctx?.req?.headers) {
              return {};
            }
            // To use SSR properly, you need to forward client headers to the server
            // This is so you can pass through things like cookies when we're server-side rendering
            return {
              cookie: ctx.req.headers.cookie,
            };
          },
        }),
      ],
    };
  },
  ssr(opts) {
    // only SSR if the request is coming from a bot
    return opts.ctx?.req?.headers['user-agent']?.includes('bot');
  },
});

----------------------------------------

TITLE: Creating Mutation Options with tRPC in TypeScript
DESCRIPTION: Shows how to create mutation options using tRPC's mutationOptions method. It demonstrates defining an onSuccess callback for handling mutation results.

LANGUAGE: typescript
CODE:
const mutationOptions = trpc.path.to.mutation.mutationOptions({
  // Any Tanstack React Query options
  onSuccess: (data) => {
    // do something with the data
  },
});

----------------------------------------

TITLE: Creating Mutation Options with tRPC in TypeScript
DESCRIPTION: Shows how to create mutation options using tRPC's mutationOptions method. It demonstrates defining an onSuccess callback for handling mutation results.

LANGUAGE: typescript
CODE:
const mutationOptions = trpc.path.to.mutation.mutationOptions({
  // Any Tanstack React Query options
  onSuccess: (data) => {
    // do something with the data
  },
});

----------------------------------------

TITLE: Implementing Per-Request Abortion in React Component
DESCRIPTION: Shows how to configure request abortion for individual queries using the trpc.abortOnUnmount option in a React component.

LANGUAGE: typescript
CODE:
import { trpc } from '../utils/trpc';

function PostViewPage() {
  const { query } = useRouter();
  const postQuery = trpc.post.byId.useQuery(
    { id: query.id },
    { trpc: { abortOnUnmount: true } }
  );

  // ...
}

----------------------------------------

TITLE: Implementing Per-Request Abortion in React Component
DESCRIPTION: Shows how to configure request abortion for individual queries using the trpc.abortOnUnmount option in a React component.

LANGUAGE: typescript
CODE:
import { trpc } from '../utils/trpc';

function PostViewPage() {
  const { query } = useRouter();
  const postQuery = trpc.post.byId.useQuery(
    { id: query.id },
    { trpc: { abortOnUnmount: true } }
  );

  // ...
}

----------------------------------------

TITLE: Implementing Batch Queries with Promise.all
DESCRIPTION: Example showing how to batch multiple queries into a single HTTP request using Promise.all with tRPC client.

LANGUAGE: typescript
CODE:
const somePosts = await Promise.all([
  trpc.post.byId.query(1),
  trpc.post.byId.query(2),
  trpc.post.byId.query(3),
]);

----------------------------------------

TITLE: Implementing Batch Queries with Promise.all
DESCRIPTION: Example showing how to batch multiple queries into a single HTTP request using Promise.all with tRPC client.

LANGUAGE: typescript
CODE:
const somePosts = await Promise.all([
  trpc.post.byId.query(1),
  trpc.post.byId.query(2),
  trpc.post.byId.query(3),
]);

----------------------------------------

TITLE: Initializing WebSocket Client and Link in tRPC
DESCRIPTION: Demonstrates how to create a WebSocket client and configure a tRPC client with wsLink. Uses createWSClient to establish the WebSocket connection and createTRPCClient to set up the tRPC client with the WebSocket link.

LANGUAGE: typescript
CODE:
import { createTRPCClient, createWSClient, wsLink } from '@trpc/client';
import type { AppRouter } from '../server';

const wsClient = createWSClient({
  url: 'ws://localhost:3000',
});

const trpcClient = createTRPCClient<AppRouter>({
  links: [wsLink<AppRouter>({ client: wsClient })],
});

----------------------------------------

TITLE: Initializing WebSocket Client and Link in tRPC
DESCRIPTION: Demonstrates how to create a WebSocket client and configure a tRPC client with wsLink. Uses createWSClient to establish the WebSocket connection and createTRPCClient to set up the tRPC client with the WebSocket link.

LANGUAGE: typescript
CODE:
import { createTRPCClient, createWSClient, wsLink } from '@trpc/client';
import type { AppRouter } from '../server';

const wsClient = createWSClient({
  url: 'ws://localhost:3000',
});

const trpcClient = createTRPCClient<AppRouter>({
  links: [wsLink<AppRouter>({ client: wsClient })],
});

----------------------------------------

TITLE: Implementing Server-Side Helpers in Next.js Page with TypeScript
DESCRIPTION: This example demonstrates how to use server-side helpers in a Next.js page component. It shows prefetching a query, dehydrating the state, and using the prefetched data in the component.

LANGUAGE: typescript
CODE:
import { createServerSideHelpers } from '@trpc/react-query/server';
import { appRouter } from '~/server/routers/_app';
import { trpc } from '~/utils/trpc';
import { GetServerSidePropsContext, InferGetServerSidePropsType } from 'next';
import superjson from 'superjson';

export async function getServerSideProps(
  context: GetServerSidePropsContext<{ id: string }>,
) {
  const helpers = createServerSideHelpers({
    router: appRouter,
    ctx: {},
    transformer: superjson,
  });
  const id = context.params?.id as string;

  /*
   * Prefetching the `post.byId` query.
   * `prefetch` does not return the result and never throws - if you need that behavior, use `fetch` instead.
   */
  await helpers.post.byId.prefetch({ id });

  // Make sure to return { props: { trpcState: helpers.dehydrate() } }
  return {
    props: {
      trpcState: helpers.dehydrate(),
      id,
    },
  };
}

export default function PostViewPage(
  props: InferGetServerSidePropsType<typeof getServerSideProps>,
) {
  const { id } = props;
  const postQuery = trpc.post.byId.useQuery({ id });
  if (postQuery.status !== 'success') {
    // won't happen since the query has been prefetched
    return <>Loading...</>;
  }
  const { data } = postQuery;
  return (
    <>
      <h1>{data.title}</h1>
      <em>Created {data.createdAt.toLocaleDateString()}</em>
      <p>{data.text}</p>
      <h2>Raw data:</h2>
      <pre>{JSON.stringify(data, null, 4)}</pre>
    </>
  );
}

----------------------------------------

TITLE: Next.js tRPC API Handler with CORS Support
DESCRIPTION: Advanced implementation of tRPC API handler that includes CORS configuration options. Demonstrates how to handle OPTIONS requests and set various CORS headers for both authenticated and unauthenticated requests.

LANGUAGE: typescript
CODE:
import { createNextApiHandler } from '@trpc/server/adapters/next';
import { createContext } from '../../../server/trpc/context';
import { appRouter } from '../../../server/trpc/router/_app';

const nextApiHandler = createNextApiHandler({
  router: appRouter,
  createContext,
});

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse,
) {
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Request-Method', '*');
  res.setHeader('Access-Control-Allow-Methods', 'OPTIONS, GET');
  res.setHeader('Access-Control-Allow-Headers', '*');

  if (req.method === 'OPTIONS') {
    res.writeHead(200);
    return res.end();
  }

  return nextApiHandler(req, res);
}

----------------------------------------

TITLE: Next.js tRPC API Handler with CORS Support
DESCRIPTION: Advanced implementation of tRPC API handler that includes CORS configuration options. Demonstrates how to handle OPTIONS requests and set various CORS headers for both authenticated and unauthenticated requests.

LANGUAGE: typescript
CODE:
import { createNextApiHandler } from '@trpc/server/adapters/next';
import { createContext } from '../../../server/trpc/context';
import { appRouter } from '../../../server/trpc/router/_app';

const nextApiHandler = createNextApiHandler({
  router: appRouter,
  createContext,
});

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse,
) {
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Request-Method', '*');
  res.setHeader('Access-Control-Allow-Methods', 'OPTIONS, GET');
  res.setHeader('Access-Control-Allow-Headers', '*');

  if (req.method === 'OPTIONS') {
    res.writeHead(200);
    return res.end();
  }

  return nextApiHandler(req, res);
}

----------------------------------------

TITLE: Applying Separate Upload/Download Transformers in tRPC Server
DESCRIPTION: Adding the configured separate transformers to the tRPC server initialization. This enables different data transformation strategies for input and output.

LANGUAGE: typescript
CODE:
import { initTRPC } from '@trpc/server';
import { transformer } from '../../utils/trpc';

export const t = initTRPC.create({
  transformer,
});

export const appRouter = t.router({
  // [...]
});

----------------------------------------

TITLE: Applying Separate Upload/Download Transformers in tRPC Server
DESCRIPTION: Adding the configured separate transformers to the tRPC server initialization. This enables different data transformation strategies for input and output.

LANGUAGE: typescript
CODE:
import { initTRPC } from '@trpc/server';
import { transformer } from '../../utils/trpc';

export const t = initTRPC.create({
  transformer,
});

export const appRouter = t.router({
  // [...]
});

----------------------------------------

TITLE: Using tRPC Query in a React Component
DESCRIPTION: This snippet demonstrates how to use a tRPC query in a React component using the `useQuery` hook provided by the `@trpc/react` library. It shows the simplicity of fetching type-safe data in React applications.

LANGUAGE: tsx
CODE:
const { data } = trpc.useQuery(['hello', '@alexdotjs']);

----------------------------------------

TITLE: Using tRPC Query in a React Component
DESCRIPTION: This snippet demonstrates how to use a tRPC query in a React component using the `useQuery` hook provided by the `@trpc/react` library. It shows the simplicity of fetching type-safe data in React applications.

LANGUAGE: tsx
CODE:
const { data } = trpc.useQuery(['hello', '@alexdotjs']);