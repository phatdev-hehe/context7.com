TITLE: Defining One-to-Many Relations in Drizzle ORM with TypeScript
DESCRIPTION: Demonstrates how to set up one-to-many relations between users and posts tables using Drizzle ORM's schema definition and relations API.

LANGUAGE: typescript
CODE:
import { integer, serial, text, pgTable } from 'drizzle-orm/pg-core';
import { relations } from 'drizzle-orm';

export const users = pgTable('users', {
	id: serial('id').primaryKey(),
	name: text('name').notNull(),
});

export const usersConfig = relations(users, ({ many }) => ({
	posts: many(posts),
}));

export const posts = pgTable('posts', {
	id: serial('id').primaryKey(),
	content: text('content').notNull(),
	authorId: integer('author_id').notNull(),
});

export const postsConfig = relations(posts, ({ one }) => ({
	author: one(users, { fields: [posts.authorId], references: [users.id] }),
}));

----------------------------------------

TITLE: Defining Database Schema in TypeScript with Drizzle ORM
DESCRIPTION: Example of defining database tables for users and authentication OTP using Drizzle ORM's PostgreSQL table definitions. Demonstrates creation of tables with primary keys, foreign keys, and indexes.

LANGUAGE: typescript
CODE:
import { integer, pgTable, serial, text, varchar } from "drizzle-orm/pg-core";

const users = pgTable("users", {
    id: serial("id").primaryKey(),
    fullName: varchar("full_name", { length: 256 }),
  }, (table) => ({
    nameIdx: index("name_idx", table.fullName),
  })
);

export const authOtp = pgTable("auth_otp", {
  id: serial("id").primaryKey(),
  phone: varchar("phone", { length: 256 }),
  userId: integer("user_id").references(() => users.id),
});

----------------------------------------

TITLE: Generating and Using Valibot Schemas with Drizzle ORM in TypeScript
DESCRIPTION: This snippet demonstrates how to define a Drizzle ORM table, create valibot schemas for insert, update, and select operations, and customize these schemas. It also shows how to use the generated schema for data validation.

LANGUAGE: typescript
CODE:
import { pgEnum, pgTable, serial, text, timestamp } from 'drizzle-orm/pg-core';
import { createInsertSchema, createSelectSchema } from 'drizzle-valibot';
import { string, parse, number, pipe } from 'valibot';

const users = pgTable('users', {
	id: serial('id').primaryKey(),
	name: text('name').notNull(),
	email: text('email').notNull(),
	role: text('role', { enum: ['admin', 'user'] }).notNull(),
	createdAt: timestamp('created_at').notNull().defaultNow(),
});

// Schema for inserting a user - can be used to validate API requests
const insertUserSchema = createInsertSchema(users);

// Schema for updating a user - can be used to validate API requests
const updateUserSchema = createUpdateSchema(users);

// Schema for selecting a user - can be used to validate API responses
const selectUserSchema = createSelectSchema(users);

// Overriding the fields
const insertUserSchema = createInsertSchema(users, {
	role: string(),
});

// Refining the fields - useful if you want to change the fields before they become nullable/optional in the final schema
const insertUserSchema = createInsertSchema(users, {
	id: (schema) => pipe([schema, minValue(0)]),
	role: string(),
});

// Usage

const isUserValid = parse(insertUserSchema, {
	name: 'John Doe',
	email: 'johndoe@test.com',
	role: 'admin',
});

----------------------------------------

TITLE: Establishing PostgreSQL Connection with Drizzle ORM
DESCRIPTION: Basic setup for connecting to PostgreSQL using Drizzle ORM with the postgres.js driver. Creates a database client instance and initializes the Drizzle ORM.

LANGUAGE: typescript
CODE:
import { drizzle } from 'drizzle-orm/postgres-js';
import postgres from 'postgres';

const client = postgres(connectionString);
const db = drizzle(client);

----------------------------------------

TITLE: Advanced SQL Query with Field References in TypeScript using Drizzle
DESCRIPTION: Demonstrates a complex SQL query using Drizzle's query builder with the new field reference callback syntax. The query performs a left join between cities and users tables, applies string manipulation, counting, filtering, grouping, and ordering using referenced fields.

LANGUAGE: typescript
CODE:
await db
    .select({
      id: citiesTable.id,
      name: sql<string>`upper(${citiesTable.name})`.as('upper_name'),
      usersCount: sql<number>`count(${users2Table.id})::int`.as('users_count'),
    })
    .from(citiesTable)
    .leftJoin(users2Table, eq(users2Table.cityId, citiesTable.id))
    .where(({ name }) => sql`length(${name}) >= 3`)
    .groupBy(citiesTable.id)
    .having(({ usersCount }) => sql`${usersCount} > 0`)
    .orderBy(({ name }) => name);

----------------------------------------

TITLE: Implementing SQLite Durable Objects with Drizzle ORM in Cloudflare Workers
DESCRIPTION: This code snippet illustrates how to use Drizzle ORM with SQLite Durable Objects in a Cloudflare Worker environment. It includes setting up a DurableObject class, initializing the database, performing migrations, and executing insert and select operations. The snippet also demonstrates how to interact with the DurableObject from a Worker's fetch handler.

LANGUAGE: typescript
CODE:
/// <reference types="@cloudflare/workers-types" />
import { drizzle, DrizzleSqliteDODatabase } from 'drizzle-orm/durable-sqlite';
import { DurableObject } from 'cloudflare:workers'
import { migrate } from 'drizzle-orm/durable-sqlite/migrator';
import migrations from '../drizzle/migrations';
import { usersTable } from './db/schema';

export class MyDurableObject1 extends DurableObject {
  storage: DurableObjectStorage;
  db: DrizzleSqliteDODatabase<any>;

  constructor(ctx: DurableObjectState, env: Env) {
    super(ctx, env);
    this.storage = ctx.storage;
    this.db = drizzle(this.storage, { logger: false });
  }

    async migrate() {
        migrate(this.db, migrations);
    }

  async insert(user: typeof usersTable.$inferInsert) {
        await this.db.insert(usersTable).values(user);
    }

  async select() {
        return this.db.select().from(usersTable);
    }
}

export default {
  /**
   * This is the standard fetch handler for a Cloudflare Worker
   *
   * @param request - The request submitted to the Worker from the client
   * @param env - The interface to reference bindings declared in wrangler.toml
   * @param ctx - The execution context of the Worker
   * @returns The response to be sent back to the client
   */
  async fetch(request: Request, env: Env): Promise<Response> {
    const id: DurableObjectId = env.MY_DURABLE_OBJECT1.idFromName('durable-object');
    const stub = env.MY_DURABLE_OBJECT1.get(id);
    await stub.migrate();

    await stub.insert({
      name: 'John',
      age: 30,
      email: 'john@example.com',
      })
    console.log('New user created!')
  
    const users = await stub.select();
    console.log('Getting all users from the database: ', users)

        return new Response();
    }
}

----------------------------------------

TITLE: Configuring Drizzle-Zod Schema Generation in TypeScript
DESCRIPTION: Demonstrates how to create and customize Zod schemas from Drizzle ORM table definitions. Shows schema generation for insert, update, and select operations with field overriding and refinement capabilities.

LANGUAGE: typescript
CODE:
import { pgEnum, pgTable, serial, text, timestamp } from 'drizzle-orm/pg-core';
import { createInsertSchema, createSelectSchema } from 'drizzle-zod';
import { z } from 'zod';

const users = pgTable('users', {
  id: serial('id').primaryKey(),
  name: text('name').notNull(),
  email: text('email').notNull(),
  role: text('role', { enum: ['admin', 'user'] }).notNull(),
  createdAt: timestamp('created_at').notNull().defaultNow(),
});

// Schema for inserting a user - can be used to validate API requests
const insertUserSchema = createInsertSchema(users);

// Schema for updating a user - can be used to validate API requests
const updateUserSchema = createUpdateSchema(users);

// Schema for selecting a user - can be used to validate API responses
const selectUserSchema = createSelectSchema(users);

// Overriding the fields
const insertUserSchema = createInsertSchema(users, {
  role: z.string(),
});

// Refining the fields - useful if you want to change the fields before they become nullable/optional in the final schema
const insertUserSchema = createInsertSchema(users, {
  id: (schema) => schema.positive(),
  email: (schema) => schema.email(),
  role: z.string(),
});

// Usage
const user = insertUserSchema.parse({
  name: 'John Doe',
  email: 'johndoe@test.com',
  role: 'admin',
});

// Zod schema type is also inferred from the table schema, so you have full type safety
const requestSchema = insertUserSchema.pick({ name: true, email: true });

----------------------------------------

TITLE: Initializing Drizzle Database Connection with New API
DESCRIPTION: Shows various ways to initialize Drizzle database connection using the new API introduced after 0.34.0. Demonstrates connection using URL string or configuration object with additional options for logger and schema.

LANGUAGE: typescript
CODE:
import { drizzle } from "drizzle-orm/node-postgres";

const db = drizzle(process.env.DATABASE_URL);
// or
const db = drizzle({
  connection: process.env.DATABASE_URL
});
const db = drizzle({
  connection: {
    user: "...",
    password: "...",
    host: "...",
    port: 4321,
    db: "...",
  },
});

// if you need to pass logger or schema
const db = drizzle({
  connection: process.env.DATABASE_URL,
  logger: true,
  schema: schema,
});

----------------------------------------

TITLE: Creating Subqueries with Drizzle ORM in TypeScript
DESCRIPTION: Demonstrates how to create a subquery using Drizzle ORM, including selecting specific fields, grouping, and aliasing. The example shows aggregation with count and multiple field selection from a course categories table.

LANGUAGE: typescript
CODE:
const sq = db
    .select({
      categoryId: courseCategoriesTable.id,
      category: courseCategoriesTable.name,
      total: sql`count(${courseCategoriesTable.id})`.as<number>(),
    })
    .from(courseCategoriesTable)
    .groupBy(courseCategoriesTable.id, courseCategoriesTable.name)
    .subquery('sq');

----------------------------------------

TITLE: Implementing Neon HTTP Batch Operations in TypeScript
DESCRIPTION: Demonstrates how to perform multiple database operations in a single batch request using Neon HTTP Batch feature. The example shows inserting records, querying data, and handling typed responses.

LANGUAGE: typescript
CODE:
const batchResponse: BatchType = await db.batch([
	db.insert(usersTable).values({ id: 1, name: 'John' }).returning({
		id: usersTable.id,
	}),
	db.insert(usersTable).values({ id: 2, name: 'Dan' }),
	db.query.usersTable.findMany({}),
	db.query.usersTable.findFirst({}),
]);

LANGUAGE: typescript
CODE:
type BatchType = [
	{
		id: number;
	}[],
	NeonHttpQueryResult<never>,
	{
		id: number;
		name: string;
		verified: number;
		invitedBy: number | null;
	}[],
	{
		id: number;
		name: string;
		verified: number;
		invitedBy: number | null;
	} | undefined,
];

----------------------------------------

TITLE: Implementing Live Queries with Drizzle ORM and Expo SQLite in React Native
DESCRIPTION: This code snippet demonstrates how to use the new useLiveQuery React Hook from Drizzle ORM to implement live queries in a React Native application using Expo SQLite. The hook automatically re-runs database queries when data changes, supporting both SQL-like and Drizzle Queries.

LANGUAGE: tsx
CODE:
import { useLiveQuery, drizzle } from 'drizzle-orm/expo-sqlite';
import { openDatabaseSync } from 'expo-sqlite/next';
import { users } from './schema';
import { Text } from 'react-native';

const expo = openDatabaseSync('db.db');
const db = drizzle(expo);

const App = () => {
  // Re-renders automatically when data changes
  const { data } = useLiveQuery(db.select().from(users));

  // const { data, error, updatedAt } = useLiveQuery(db.query.users.findFirst());
  // const { data, error, updatedAt } = useLiveQuery(db.query.users.findMany());


  return <Text>{JSON.stringify(data)}</Text>;
};

export default App;

----------------------------------------

TITLE: Generating and Using TypeBox Schemas with Drizzle ORM
DESCRIPTION: Demonstrates how to create and use TypeBox schemas from Drizzle ORM table definitions. Shows table definition, schema generation for insert/update/select operations, field overriding, and schema validation. Includes integration with @sinclair/typebox for type checking.

LANGUAGE: typescript
CODE:
import { pgEnum, pgTable, serial, text, timestamp } from 'drizzle-orm/pg-core';
import { createInsertSchema, createSelectSchema } from 'drizzle-typebox';
import { Type } from '@sinclair/typebox';
import { Value } from '@sinclair/typebox/value';

const users = pgTable('users', {
	id: serial('id').primaryKey(),
	name: text('name').notNull(),
	email: text('email').notNull(),
	role: text('role', { enum: ['admin', 'user'] }).notNull(),
	createdAt: timestamp('created_at').notNull().defaultNow(),
});

// Schema for inserting a user - can be used to validate API requests
const insertUserSchema = createInsertSchema(users);

// Schema for updating a user - can be used to validate API requests
const updateUserSchema = createUpdateSchema(users);

// Schema for selecting a user - can be used to validate API responses
const selectUserSchema = createSelectSchema(users);

// Overriding the fields
const insertUserSchema = createInsertSchema(users, {
	role: Type.String(),
});

// Refining the fields - useful if you want to change the fields before they become nullable/optional in the final schema
const insertUserSchema = createInsertSchema(users, {
	id: (schema) => Type.Number({ ...schema, minimum: 0 }),
	role: Type.String(),
});

// Usage

const isUserValid: boolean = Value.Check(insertUserSchema, {
	name: 'John Doe',
	email: 'johndoe@test.com',
	role: 'admin',
});

----------------------------------------

TITLE: Using Aggregate Functions in Drizzle ORM with TypeScript
DESCRIPTION: Demonstrates the usage of new aggregate function helpers in Drizzle ORM, including count, countDistinct, avg, avgDistinct, sum, sumDistinct, max, and min. Each function is shown with its equivalent SQL template usage.

LANGUAGE: typescript
CODE:
await db.select({ value: count() }).from(users);
await db.select({ value: count(users.id) }).from(users);

// It's equivalent to writing
await db.select({ 
  value: sql`count('*'))`.mapWith(Number) 
}).from(users);
await db.select({ 
  value: sql`count(${users.id})`.mapWith(Number) 
}).from(users);

LANGUAGE: typescript
CODE:
await db.select({ value: countDistinct(users.id) }).from(users);

// It's equivalent to writing
await db.select({ 
  value: sql`count(${users.id})`.mapWith(Number) 
}).from(users);

LANGUAGE: typescript
CODE:
await db.select({ value: avg(users.id) }).from(users);

// It's equivalent to writing
await db.select({ 
  value: sql`avg(${users.id})`.mapWith(String) 
}).from(users);

LANGUAGE: typescript
CODE:
await db.select({ value: avgDistinct(users.id) }).from(users);

// It's equivalent to writing
await db.select({ 
  value: sql`avg(distinct ${users.id})`.mapWith(String) 
}).from(users);

LANGUAGE: typescript
CODE:
await db.select({ value: sum(users.id) }).from(users);

// It's equivalent to writing
await db.select({ 
  value: sql`sum(${users.id})`.mapWith(String) 
}).from(users);

LANGUAGE: typescript
CODE:
await db.select({ value: sumDistinct(users.id) }).from(users);

// It's equivalent to writing
await db.select({ 
  value: sql`sum(distinct ${users.id})`.mapWith(String) 
}).from(users);

LANGUAGE: typescript
CODE:
await db.select({ value: max(users.id) }).from(users);

// It's equivalent to writing
await db.select({ 
  value: sql`max(${expression})`.mapWith(users.id) 
}).from(users);

LANGUAGE: typescript
CODE:
await db.select({ value: min(users.id) }).from(users);

// It's equivalent to writing
await db.select({ 
  value: sql`min(${users.id})`.mapWith(users.id) 
}).from(users);

----------------------------------------

TITLE: Defining Table Relationships in Drizzle ORM (TypeScript)
DESCRIPTION: This snippet demonstrates how to define a one-to-many relationship between users and cities tables using Drizzle ORM. It shows the table structure and foreign key references.

LANGUAGE: typescript
CODE:
const users = pgTable('users', {
  id: serial('id').primaryKey(),
  firstName: text('first_name').notNull(),
  lastName: text('last_name'),
  cityId: int('city_id').references(() => cities.id),
});

const cities = pgTable('cities', {
  id: serial('id').primaryKey(),
  name: text('name').notNull(),
});

----------------------------------------

TITLE: Type Inference for PostgreSQL Table Models
DESCRIPTION: Shows the new type inference syntax using $inferSelect and $inferInsert, along with the legacy InferSelectModel and InferInsertModel types. Demonstrates type inference for a complex table schema including various column types and constraints.

LANGUAGE: typescript
CODE:
import { InferSelectModel, InferInsertModel } from 'drizzle-orm'

const usersTable = pgTable('users', {
  id: serial('id').primaryKey(),
  name: text('name').notNull(),
  verified: boolean('verified').notNull().default(false),
  jsonb: jsonb('jsonb').$type<string[]>(),
  createdAt: timestamp('created_at', { withTimezone: true }).notNull().defaultNow(),
});

type SelectUser = typeof usersTable.$inferSelect;
type InsertUser = typeof usersTable.$inferInsert;

type SelectUser2 = InferSelectModel<typeof usersTable>;
type InsertUser2 = InferInsertModel<typeof usersTable>;

----------------------------------------

TITLE: Implementing $onUpdate Column Functionality in TypeScript with Drizzle ORM
DESCRIPTION: Demonstrates how to define a table schema with various $onUpdate implementations including counter increments, timestamp updates, and null assignments. The example shows different column types and their update behaviors using the new $onUpdate and $onUpdateFn methods.

LANGUAGE: typescript
CODE:
const usersOnUpdate = pgTable('users_on_update', {
  id: serial('id').primaryKey(),
  name: text('name').notNull(),
  updateCounter: integer('update_counter').default(sql`1`).$onUpdateFn(() => sql`update_counter + 1`),
  updatedAt: timestamp('updated_at', { mode: 'date', precision: 3 }).$onUpdate(() => new Date()),
  alwaysNull: text('always_null').$type<string | null>().$onUpdate(() => null),
});

----------------------------------------

TITLE: Aggregating Join Results in Drizzle ORM (TypeScript)
DESCRIPTION: This snippet shows how to transform the result of a join operation into a more structured format, grouping users by city using Array.reduce().

LANGUAGE: typescript
CODE:
import { InferModel } from 'drizzle-orm';

type User = InferModel<typeof users>;
type City = InferModel<typeof cities>;

const rows = await db
  .select({
    city: cities,
    user: users,
  })
  .from(cities)
  .leftJoin(users, eq(users.cityId, cities.id));

const result = rows.reduce<Record<number, { city: City; users: User[] }>>(
  (acc, row) => {
    const city = row.city;
    const user = row.user;

    if (!acc[city.id]) {
      acc[city.id] = { city, users: [] };
    }

    if (user) {
      acc[city.id].users.push(user);
    }

    return acc;
  },
  {},
);

----------------------------------------

TITLE: Updating Users with City Data using UPDATE ... FROM in Drizzle ORM
DESCRIPTION: Demonstrates how to use the UPDATE ... FROM feature in Drizzle ORM to update users' city IDs based on city names. This example joins the users and cities tables to perform the update.

LANGUAGE: typescript
CODE:
await db
  .update(users)
  .set({ cityId: cities.id })
  .from(cities)
  .where(and(eq(cities.name, 'Seattle'), eq(users.name, 'John')))

LANGUAGE: sql
CODE:
update "users" set "city_id" = "cities"."id" 
from "cities" 
where ("cities"."name" = $1 and "users"."name" = $2)

-- params: [ 'Seattle', 'John' ]

----------------------------------------

TITLE: INSERT INTO ... SELECT with Query Builder in Drizzle ORM
DESCRIPTION: Shows how to use INSERT INTO ... SELECT with a query builder in Drizzle ORM. This example inserts employee data from the users table into the employees table based on a condition.

LANGUAGE: typescript
CODE:
const insertedEmployees = await db
  .insert(employees)
  .select(
    db.select({ name: users.name }).from(users).where(eq(users.role, 'employee'))
  )
  .returning({
    id: employees.id,
    name: employees.name
  });

----------------------------------------

TITLE: Installing Drizzle ORM and PostgreSQL Dependencies
DESCRIPTION: Package installation commands for npm, yarn, and pnpm to set up Drizzle ORM with PostgreSQL dependencies. Includes both runtime dependencies (drizzle-orm, postgres) and development dependencies (drizzle-kit).

LANGUAGE: bash
CODE:
# npm
npm i drizzle-orm postgres
npm i -D drizzle-kit

# yarn
yarn add drizzle-orm postgres
yarn add -D drizzle-kit

# pnpm
pnpm add drizzle-orm postgres
pnpm add -D drizzle-kit

----------------------------------------

TITLE: Implementing Locking Clauses in SELECT Queries for PostgreSQL using Drizzle ORM
DESCRIPTION: Demonstrates the usage of various locking clauses in SELECT statements for PostgreSQL using Drizzle ORM. Includes examples of FOR UPDATE, FOR NO KEY UPDATE, and FOR SHARE with options like skipLocked and noWait.

LANGUAGE: typescript
CODE:
await db
  .select()
  .from(users)
  .for('update')
  .for('no key update', { of: users })
  .for('no key update', { of: users, skipLocked: true })
  .for('share', { of: users, noWait: true });

----------------------------------------

TITLE: Basic Database Seeding with Drizzle ORM in TypeScript
DESCRIPTION: Demonstrates how to create a basic database seeding setup that generates 10 users with random names and IDs using drizzle-seed. Includes table definition and seeding execution.

LANGUAGE: typescript
CODE:
import { pgTable, integer, text } from "drizzle-orm/pg-core";
import { drizzle } from "drizzle-orm/node-postgres";
import { seed } from "drizzle-seed";

const users = pgTable("users", {
  id: integer().primaryKey(),
  name: text().notNull(),
});

async function main() {
  const db = drizzle(process.env.DATABASE_URL!);
  await seed(db, { users });
}

main();

----------------------------------------

TITLE: Implementing Check Constraints in Drizzle ORM
DESCRIPTION: Demonstrates how to define check constraints in a Drizzle ORM schema using PostgreSQL. The example shows a users table with an age check constraint that ensures age is greater than 21.

LANGUAGE: typescript
CODE:
import { sql } from "drizzle-orm";
import { check, pgTable } from "drizzle-orm/pg-core";

export const users = pgTable(
  "users",
  (c) => ({
    id: c.uuid().defaultRandom().primaryKey(),
    username: c.text().notNull(),
    age: c.integer(),
  }),
  (table) => ({
    checkConstraint: check("age_check", sql`${table.age} > 21`),
  })
);

LANGUAGE: sql
CODE:
CREATE TABLE IF NOT EXISTS "users" (
  "id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
  "username" text NOT NULL,
  "age" integer,
  CONSTRAINT "age_check" CHECK ("users"."age" > 21)
);

----------------------------------------

TITLE: Initializing Expo SQLite Database Connection
DESCRIPTION: Example showing how to initialize and use Drizzle with Expo SQLite, including different query patterns

LANGUAGE: typescript
CODE:
import { drizzle } from "drizzle-orm/expo-sqlite";
import { openDatabaseSync } from "expo-sqlite/next";

const expoDb = openDatabaseSync("db.db");

const db = drizzle(expoDb);

await db.select().from(...)...

// or

db.select().from(...).then(...);

// or

db.select().from(...).all();

----------------------------------------

TITLE: Defining Schema with Foreign Key and One-to-Many Relation in Drizzle ORM (TypeScript)
DESCRIPTION: This code snippet demonstrates how to define a schema in Drizzle ORM using TypeScript. It creates two tables, 'users' and 'posts', with a foreign key constraint in the 'posts' table referencing the 'users' table. Additionally, it defines a one-to-many relation between these tables.

LANGUAGE: typescript
CODE:
// schema.ts
import { integer, pgTable, text } from "drizzle-orm/pg-core";
import { relations } from "drizzle-orm/relations";

export const users = pgTable("users", {
  id: integer().primaryKey(),
  name: text(),
  email: text(),
});

export const posts = pgTable("posts", {
  id: integer().primaryKey(),
  content: text(),
  userId: integer().references(() => users.id),
});

export const postsRelation = relations(posts, ({ one }) => ({
  user: one(users, {
    fields: [posts.userId],
    references: [users.id],
  }),
}));

----------------------------------------

TITLE: Defining Composite Primary Keys in PostgreSQL with Drizzle ORM
DESCRIPTION: Demonstrates how to define a table with a composite primary key in PostgreSQL using Drizzle ORM. It uses the primaryKey function to create a composite key from multiple columns.

LANGUAGE: typescript
CODE:
import { primaryKey } from 'drizzle-orm/pg-core';

export const cpkTable = pgTable('table', {
  column1: integer('column1').default(10).notNull(),
  column2: integer('column2'),
  column3: integer('column3'),
}, (table) => ({
  cpk: primaryKey(table.column1, table.column2),
}));

----------------------------------------

TITLE: Defining SQLite Schema
DESCRIPTION: Demonstrates how to define a SQLite schema using Drizzle ORM

LANGUAGE: typescript
CODE:
import { sqliteTable, text, integer, uniqueIndex } from 'drizzle-orm/sqlite-core';

export const countries = sqliteTable('countries', {
    id: integer('id').primaryKey(),
    name: text('name'),
  }, (countries) => ({
    nameIdx: uniqueIndex('nameIdx').on(countries.name),
  })
);

export const cities = sqliteTable('cities', {
  id: integer('id').primaryKey(),
  name: text('name'),
  countryId: integer('country_id').references(() => countries.id),
})

----------------------------------------

TITLE: Complete PostgreSQL Text Column Implementation
DESCRIPTION: Full implementation example of a PostgreSQL text column type including builder, column class, and helper function.

LANGUAGE: typescript
CODE:
import { ColumnConfig, ColumnBuilderConfig } from 'drizzle-orm';
import { AnyPgTable } from 'drizzle-orm/pg-core';

import { PgColumn, PgColumnBuilder } from './common';

export class PgTextBuilder<TData extends string = string>
  extends PgColumnBuilder<
    ColumnBuilderConfig<{ data: TData; driverParam: string }>
  >
{
  

  build<TTableName extends string>(
    table: AnyPgTable<{ name: TTableName }>,
  ): PgText<TTableName, TData> {
    return new PgText(table, this.config);
  }
}

export class PgText<TTableName extends string, TData extends string>
  extends PgColumn<
    ColumnConfig<{ tableName: TTableName; data: TData; driverParam: string }>
  >
{
  

  constructor(
    table: AnyPgTable<{ name: TTableName }>,
    builder: PgTextBuilder<TData>['config'],
  ) {
    super(table, builder);
  }

  getSQLType(): string {
    return 'text';
  }
}

export function text<T extends string = string>(
  name: string,
): PgTextBuilder<T> {
  return new PgTextBuilder(name);
}

----------------------------------------

TITLE: Using OrderBy and Limit in Update/Delete Queries
DESCRIPTION: Demonstrates the new orderBy() and limit() functions in update and delete statements for SQLite and MySQL. Shows how to combine these operations with existing query builders.

LANGUAGE: typescript
CODE:
await db.update(usersTable).set({ verified: true }).limit(2).orderBy(asc(usersTable.name));

await db.delete(usersTable).where(eq(usersTable.verified, false)).limit(1).orderBy(asc(usersTable.name));

----------------------------------------

TITLE: Executing Database Transactions with node-postgres in Drizzle ORM
DESCRIPTION: Demonstrates how to perform multiple database operations within a single transaction using node-postgres driver. The example shows insert, update, and delete operations executed atomically.

LANGUAGE: typescript
CODE:
await db.transaction(async (tx) => {
  await tx.insert(users).values(newUser);
  await tx.update(users).set({ name: 'Mr. Dan' }).where(eq(users.name, 'Dan'));
  await tx.delete(users).where(eq(users.name, 'Dan'));
});

----------------------------------------

TITLE: Column Type Override with $type() in Drizzle ORM
DESCRIPTION: Shows the new syntax for overriding column data types using the $type() method, replacing generic type parameters.

LANGUAGE: typescript
CODE:
// Before
const test = mysqlTable('test', {
  jsonField: json<Data>('json_field'),
});

// After
const test = mysqlTable('test', {
  jsonField: json('json_field').$type<Data>(),
});

----------------------------------------

TITLE: Connecting to Gel Database using Drizzle ORM and gel-js
DESCRIPTION: This snippet demonstrates how to establish a connection to a Gel database using Drizzle ORM with the gel-js client. It imports necessary modules, creates a Gel client, initializes a Drizzle instance, and executes a simple query.

LANGUAGE: typescript
CODE:
// Make sure to install the 'gel' package 
import { drizzle } from "drizzle-orm/gel";
import { createClient } from "gel";

const gelClient = createClient();
const db = drizzle({ client: gelClient });

const result = await db.execute('select 1');

----------------------------------------

TITLE: Initializing Drizzle ORM with Schema in TypeScript
DESCRIPTION: Shows how to initialize the Drizzle ORM instance with a schema, including examples for single and multiple schema files.

LANGUAGE: typescript
CODE:
import * as schema from './schema';
import { drizzle } from 'drizzle-orm/...';

const db = drizzle(client, { schema });

await db.query.users.findMany(...);

LANGUAGE: typescript
CODE:
import * as schema1 from './schema1';
import * as schema2 from './schema2';
import { drizzle } from 'drizzle-orm/...';

const db = drizzle(client, { schema: { ...schema1, ...schema2 } });

await db.query.users.findMany(...);

----------------------------------------

TITLE: Improved Relational Query in TypeScript
DESCRIPTION: Example of a complex relational query using the new optimized query generation strategy in Drizzle ORM 0.28.0, which improves performance and reduces row reads.

LANGUAGE: typescript
CODE:
const items = await db.query.comments.findMany({
  limit,
  orderBy: comments.id,
  with: {
    user: {
      columns: { name: true },
    },
    post: {
      columns: { title: true },
      with: {
        user: {
          columns: { name: true },
        },
      },
    },
  },
});

----------------------------------------

TITLE: Updated Enum Column Syntax in Drizzle ORM
DESCRIPTION: Illustrates the new syntax for defining text-based enum columns using an explicit enum option object.

LANGUAGE: typescript
CODE:
// Before
const test = mysqlTable('test', {
  role: text<'admin' | 'user'>('role'),
});

// After
const test = mysqlTable('test', {
  role: text('role', { enum: ['admin', 'user'] }),
});

----------------------------------------

TITLE: Initializing Drizzle Database Instance with HTTP Client
DESCRIPTION: Sets up a Drizzle database instance using axios for HTTP communication. Handles database queries by sending SQL, parameters, and method type to a proxy server. Returns results in the required {rows: []} format.

LANGUAGE: typescript
CODE:
import axios from 'axios';
import { drizzle } from 'drizzle-orm/pg-proxy';

const db = drizzle(async (sql, params, method) => {
  try {
    const rows = await axios.post('http://localhost:3000/query', {
      sql,
      params,
      method,
    });

    return { rows: rows.data };
  } catch (e: any) {
    console.error('Error from pg proxy server: ', e.response.data);
    return { rows: [] };
  }
});

----------------------------------------

TITLE: Implementing Read Replicas Support in Drizzle ORM
DESCRIPTION: Demonstrates how to use the 'withReplica' function to specify different database connections for read replicas and the main instance for write operations.

LANGUAGE: typescript
CODE:
const primaryDb = drizzle(client);
const read1 = drizzle(client);
const read2 = drizzle(client);

const db = withReplicas(primaryDb, [read1, read2]);

// read from primary
db.$primary.select().from(usersTable);

// read from either read1 connection or read2 connection
db.select().from(usersTable)

// use primary database for delete operation
db.delete(usersTable).where(eq(usersTable.id, 1))

----------------------------------------

TITLE: Bulk Insert Values in Drizzle ORM
DESCRIPTION: Demonstrates the new array-based syntax for bulk inserting multiple records using insert().values().

LANGUAGE: typescript
CODE:
const users = mysqlTable('users', {
  id: int('id').primaryKey(),
  name: text('name').notNull(),
});

await users.insert().values([
  { name: 'John' },
  { name: 'Jane' },
]);

----------------------------------------

TITLE: Connecting to TiDB Cloud Serverless with Drizzle ORM in TypeScript
DESCRIPTION: Demonstrates how to establish a connection to TiDB Cloud Serverless database using Drizzle ORM. The code shows the basic setup process including client initialization and database connection configuration.

LANGUAGE: typescript
CODE:
import { connect } from '@tidbcloud/serverless';
import { drizzle } from 'drizzle-orm/tidb-serverless';

const client = connect({ url: '...' });
const db = drizzle(client);
await db.select().from(...);

----------------------------------------

TITLE: Defining Custom JSONB Type in PostgreSQL
DESCRIPTION: Creates a custom JSONB type for PostgreSQL using the customType function from Drizzle ORM. Includes a toDriver method to stringify the data.

LANGUAGE: typescript
CODE:
const customJsonb = <TData>(name: string) =>
  customType<{ data: TData; driverData: string }>({
    dataType() {
      return 'jsonb';
    },
    toDriver(value: TData): string {
      return JSON.stringify(value);
    },
  })(name);

----------------------------------------

TITLE: Generated SQL Migration from Drizzle Kit
DESCRIPTION: Auto-generated SQL migration that creates tables with proper constraints and indexes based on the TypeScript schema definition.

LANGUAGE: sql
CODE:
CREATE TABLE IF NOT EXISTS auth_otp (
 "id" SERIAL PRIMARY KEY,
 "phone" character varying(256),
 "user_id" INT
);

CREATE TABLE IF NOT EXISTS users (
 "id" SERIAL PRIMARY KEY,
 "full_name" character varying(256)
);

DO $$ BEGIN
 ALTER TABLE auth_otp ADD CONSTRAINT auth_otp_user_id_fkey FOREIGN KEY ("user_id") REFERENCES users(id);
EXCEPTION
 WHEN duplicate_object THEN null;
END $$;

CREATE INDEX IF NOT EXISTS users_full_name_index ON users (full_name);

----------------------------------------

TITLE: Table Name Customization with Table Creators in Drizzle ORM
DESCRIPTION: Shows how to use table creators to customize table names with prefixes or other modifications.

LANGUAGE: typescript
CODE:
import { mysqlTableCreator } from 'drizzle-orm/mysql-core';

const mysqlTable = mysqlTableCreator((name) => `myprefix_${name}`);

const users = mysqlTable('users', {
  id: int('id').primaryKey(),
  name: text('name').notNull(),
});

----------------------------------------

TITLE: Querying Database with Relational Query Builder in TypeScript
DESCRIPTION: Demonstrates various ways to query the database using Drizzle ORM's Relational Query Builder, including selecting all users, first user, and posts with specific columns and relations.

LANGUAGE: typescript
CODE:
const users = await db.query.users.findMany();

LANGUAGE: typescript
CODE:
const user = await db.query.users.findFirst();

LANGUAGE: typescript
CODE:
const posts = await db.query.posts.findMany({
	columns: {
		id: true,
		content: true,
	},
	with: {
		comments: true,
	}
});

LANGUAGE: typescript
CODE:
const posts = await db.query.posts.findMany({
	columns: {
		content: false,
	},
});

----------------------------------------

TITLE: Implementing Migrations with SQLite Proxy in Drizzle ORM
DESCRIPTION: Demonstrates how to handle migrations using the SQLite Proxy in Drizzle ORM. It sends migration queries to the proxy server and handles potential errors during the migration process.

LANGUAGE: typescript
CODE:
import axios from 'axios';
import { migrate } from 'drizzle-orm/sqlite-proxy/migrator';

await migrate(db, async (queries) => {
  try {
    await axios.post('http://localhost:3000/migrate', { queries });
  } catch (e) {
    console.log(e);
    throw Error('Proxy server cannot run migrations');
  }
}, { migrationsFolder: 'drizzle' });

----------------------------------------

TITLE: Configuring RLS with Neon Integration
DESCRIPTION: Shows how to use Neon-specific RLS features with Drizzle ORM including CRUD policies.

LANGUAGE: typescript
CODE:
import { crudPolicy } from 'drizzle-orm/neon';
import { integer, pgRole, pgTable } from 'drizzle-orm/pg-core';

export const admin = pgRole('admin');

export const users = pgTable('users', {
	id: integer(),
}, (t) => [
	crudPolicy({ role: admin, read: true, modify: false }),
]);

----------------------------------------

TITLE: Deprecated vs New Client Initialization in Drizzle
DESCRIPTION: Compares the deprecated and new methods of initializing Drizzle with a database client. Shows both the old way using direct client initialization and the new recommended approach.

LANGUAGE: typescript
CODE:
import { drizzle } from "drizzle-orm/node-postgres";
import { Pool } from "pg";

const client = new Pool({ connectionString: process.env.DATABASE_URL });
const db = drizzle(client); // deprecated but available

// new version
const db = drizzle({
  client: client,
});

----------------------------------------

TITLE: Defining PostgreSQL Sequences in TypeScript
DESCRIPTION: Shows how to specify sequences in PostgreSQL within any schema and define available properties using the new pgSequence function.

LANGUAGE: typescript
CODE:
import { pgSchema, pgSequence } from "drizzle-orm/pg-core";

// No params specified
export const customSequence = pgSequence("name");

// Sequence with params
export const customSequence = pgSequence("name", {
      startWith: 100,
      maxValue: 10000,
      minValue: 100,
      cycle: true,
      cache: 10,
      increment: 2
});

// Sequence in custom schema
export const customSchema = pgSchema('custom_schema');

export const customSequence = customSchema.sequence("name");

----------------------------------------

TITLE: New Column Definition Syntax
DESCRIPTION: Updated syntax for defining table columns using callback approach and optional column naming

LANGUAGE: typescript
CODE:
import { pgTable } from "drizzle-orm/pg-core";

export const ingredients = pgTable("ingredients", (t) => ({
  id: t.uuid().defaultRandom().primaryKey(),
  name: t.text().notNull(),
  description: t.text(),
  inStock: t.boolean().default(true),
}));

----------------------------------------

TITLE: Introspecting MySQL Database with Drizzle Kit
DESCRIPTION: Demonstrates how to use the new 'introspect:mysql' command in Drizzle Kit to introspect an existing MySQL database and generate schema files.

LANGUAGE: bash
CODE:
drizzle-kit introspect:mysql --out ./migrations --connectionString mysql://user:password@127.0.0.1:3306/database

----------------------------------------

TITLE: Creating Simple Generated Columns in PostgreSQL with TypeScript
DESCRIPTION: Shows how to create simple generated columns in PostgreSQL using Drizzle ORM, demonstrating the use of SQL templates and string literals.

LANGUAGE: typescript
CODE:
export const users = pgTable("users", {
  id: integer("id"),
  name: text("name"),
  generatedName: text("gen_name").generatedAlwaysAs(sql`hello world!`),
  generatedName1: text("gen_name1").generatedAlwaysAs("hello world!"),
}),

----------------------------------------

TITLE: Vector Operation Helper Functions in TypeScript
DESCRIPTION: Helper functions for vector operations including distance calculations and comparisons.

LANGUAGE: typescript
CODE:
import { l2Distance, l1Distance, innerProduct, 
          cosineDistance, hammingDistance, jaccardDistance } from 'drizzle-orm'

l2Distance(table.column, [3, 1, 2]) // table.column <-> '[3, 1, 2]'
l1Distance(table.column, [3, 1, 2]) // table.column <+> '[3, 1, 2]'

innerProduct(table.column, [3, 1, 2]) // table.column <#> '[3, 1, 2]'
cosineDistance(table.column, [3, 1, 2]) // table.column <=> '[3, 1, 2]'

hammingDistance(table.column, '101') // table.column <~> '101'
jaccardDistance(table.column, '101') // table.column <%> '101'

----------------------------------------

TITLE: Defining Roles in Drizzle ORM
DESCRIPTION: This example shows how to define roles in Drizzle ORM. It creates an 'admin' role with specific permissions and demonstrates how to mark a role as existing in the database.

LANGUAGE: typescript
CODE:
import { pgRole } from 'drizzle-orm/pg-core';

export const admin = pgRole('admin', { createRole: true, createDb: true, inherit: true });

// Marking a role as existing
export const admin = pgRole('admin').existing();

----------------------------------------

TITLE: Creating MySQL Tables with Schema Support
DESCRIPTION: Demonstrates how to create tables in both default and custom MySQL schemas using drizzle-orm. Shows table definition with various column types including serial, text, boolean, json, and timestamp.

LANGUAGE: typescript
CODE:
// Table in default schema
const publicUsersTable = mysqlTable('users', {
	id: serial('id').primaryKey(),
	name: text('name').notNull(),
	verified: boolean('verified').notNull().default(false),
	jsonb: json<string[]>('jsonb'),
	createdAt: timestamp('created_at', { fsp: 2 }).notNull().defaultNow(),
});


// Table in custom schema
const mySchema = mysqlSchema('mySchema');

const mySchemaUsersTable = mySchema('users', {
	id: serial('id').primaryKey(),
	name: text('name').notNull(),
	verified: boolean('verified').notNull().default(false),
	jsonb: json<string[]>('jsonb'),
	createdAt: timestamp('created_at', { fsp: 2 }).notNull().defaultNow(),
});

----------------------------------------

TITLE: INSERT INTO ... SELECT with Callback in Drizzle ORM
DESCRIPTION: Demonstrates how to use INSERT INTO ... SELECT with a callback function in Drizzle ORM. This approach allows for more flexible query construction within the insert statement.

LANGUAGE: typescript
CODE:
await db.insert(employees).select(
    (qb) => qb.select({ name: users.name }).from(users).where(eq(users.role, 'employee'))
);

----------------------------------------

TITLE: Selecting All Fields in Drizzle ORM (TypeScript)
DESCRIPTION: This snippet demonstrates how to select all fields from joined tables without explicitly listing them, using an empty select() method.

LANGUAGE: typescript
CODE:
const rows = await db.select().from(cities).leftJoin(users, eq(users.cityId, cities.id));

----------------------------------------

TITLE: Configuring Role Management in Drizzle Config
DESCRIPTION: This snippet demonstrates how to configure role management in the drizzle.config.ts file. It shows various options for including or excluding specific roles and how to handle roles for different database providers.

LANGUAGE: typescript
CODE:
// drizzle.config.ts
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  dialect: 'postgresql',
  schema: "./drizzle/schema.ts",
  dbCredentials: {
    url: process.env.DATABASE_URL!
  },
  verbose: true,
  strict: true,
  entities: {
    roles: true
  }
});

----------------------------------------

TITLE: Setting up PlanetScale Client Connection in TypeScript
DESCRIPTION: Shows the recommended way to establish a connection to PlanetScale using the Client instance instead of the deprecated connect() method. This approach will become mandatory from version 0.30.0.

LANGUAGE: typescript
CODE:
import { Client } from '@planetscale/database';
import { drizzle } from 'drizzle-orm/planetscale-serverless';

// create the connection
const client = new Client({
	host: process.env['DATABASE_HOST'],
	username: process.env['DATABASE_USERNAME'],
	password: process.env['DATABASE_PASSWORD'],
});

const db = drizzle(client);

----------------------------------------

TITLE: Defining UNIQUE Constraints in SQLite with Drizzle ORM
DESCRIPTION: This snippet illustrates how to define single-column and multi-column UNIQUE constraints in SQLite using Drizzle ORM. In SQLite, unique constraints are treated as unique indexes.

LANGUAGE: typescript
CODE:
// single column
const table = sqliteTable('table', {
    id: int('id').primaryKey(),
    name: text('name').notNull().unique(),
    state: text('state').unique('custom'),
    field: text('field').unique(),
});
// multiple columns
const table = sqliteTable('table', {
    id: int('id').primaryKey(),
    name: text('name').notNull(),
    state: text('state'),
}, (t) => ({
    first: unique().on(t.name, t.state),
    second: unique('custom').on(t.name, t.state),
}));

----------------------------------------

TITLE: Implementing SQLite Proxy Batch Operations - TypeScript
DESCRIPTION: Shows how to set up SQLite Proxy with batch query support, including handling batch requests and responses through a proxy server.

LANGUAGE: typescript
CODE:
import { drizzle } from 'drizzle-orm/sqlite-proxy';

type ResponseType = { rows: any[][] | any[] }[];

const db = drizzle(
	async (sql, params, method) => {
		// single query logic
	},
	// new batch callback
	async (
		queries: {
			sql: string;
			params: any[];
			method: 'all' | 'run' | 'get' | 'values';
		}[],
	) => {
		try {
			const result: ResponseType = await axios.post(
				'http://localhost:3000/batch',
				{ queries },
			);

			return result;
		} catch (e: any) {
			console.error('Error from sqlite proxy server:', e);
			throw e;
		}
	},
);

----------------------------------------

TITLE: Implementing Dynamic Query Building in Drizzle ORM
DESCRIPTION: Shows how to use the new dynamic mode for query builders in Drizzle ORM, allowing multiple invocations of methods like 'where()' for flexible query construction.

LANGUAGE: typescript
CODE:
function withPagination<T extends PgSelect>(
  qb: T,
  page: number,
  pageSize: number = 10,
) {
  return qb.limit(pageSize).offset(page * pageSize);
}

const query = db.select().from(users).where(eq(users.id, 1));
withPagination(query, 1); // ❌ Type error - the query builder is not in dynamic mode

const dynamicQuery = query.$dynamic();
withPagination(dynamicQuery, 1); // ✅ OK

----------------------------------------

TITLE: Previous PostgreSQL Index API Implementation in TypeScript
DESCRIPTION: Shows the deprecated index API structure that was not aligned with PostgreSQL documentation.

LANGUAGE: typescript
CODE:
index('name')
  .on(table.column1, table.column2, ...) or .onOnly(table.column1, table.column2, ...)
  .concurrently()
  .using(sql``) // sql expression
  .asc() or .desc()
  .nullsFirst() or .nullsLast()
  .where(sql``) // sql expression

----------------------------------------

TITLE: Creating and Using Arktype Schemas with Drizzle ORM
DESCRIPTION: Demonstrates how to create and use arktype schemas for database operations using drizzle-arktype plugin. Shows table definition, schema generation for insert/update/select operations, field overriding, and schema validation.

LANGUAGE: typescript
CODE:
import { pgEnum, pgTable, serial, text, timestamp } from 'drizzle-orm/pg-core';
import { createInsertSchema, createSelectSchema } from 'drizzle-arktype';
import { type } from 'arktype';

const users = pgTable('users', {
	id: serial('id').primaryKey(),
	name: text('name').notNull(),
	email: text('email').notNull(),
	role: text('role', { enum: ['admin', 'user'] }).notNull(),
	createdAt: timestamp('created_at').notNull().defaultNow(),
});

// Schema for inserting a user - can be used to validate API requests
const insertUserSchema = createInsertSchema(users);

// Schema for updating a user - can be used to validate API requests
const updateUserSchema = createUpdateSchema(users);

// Schema for selecting a user - can be used to validate API responses
const selectUserSchema = createSelectSchema(users);

// Overriding the fields
const insertUserSchema = createInsertSchema(users, {
	role: type('string'),
});

// Refining the fields - useful if you want to change the fields before they become nullable/optional in the final schema
const insertUserSchema = createInsertSchema(users, {
	id: (schema) => schema.atLeast(1),
	role: type('string'),
});

// Usage

const isUserValid = parse(insertUserSchema, {
	name: 'John Doe',
	email: 'johndoe@test.com',
	role: 'admin',
});

----------------------------------------

TITLE: Creating Schema Factory with Custom Options
DESCRIPTION: Demonstrates the use of createSchemaFactory for advanced schema creation with custom type box instances and extended configuration options.

LANGUAGE: typescript
CODE:
import { pgTable, text, integer } from 'drizzle-orm/pg-core';
import { createSchemaFactory } from 'drizzle-typebox';
import { t } from 'elysia';

const users = pgTable('users', {
  id: integer().generatedAlwaysAsIdentity().primaryKey(),
  name: text().notNull(),
  age: integer().notNull()
});

const { createInsertSchema } = createSchemaFactory({ typeboxInstance: t });

const userInsertSchema = createInsertSchema(users, {
  name: (schema) => t.Number({ ...schema }, { error: '`name` must be a string' })
});

----------------------------------------

TITLE: Custom CITEXT Data Type Implementation
DESCRIPTION: Implementation of a custom PostgreSQL CITEXT data type with builder pattern and usage example.

LANGUAGE: typescript
CODE:
export class PgCITextBuilder<TData extends string = string> extends PgColumnBuilder<
  PgColumnBuilderHKT,
  ColumnBuilderConfig<{ data: TData; driverParam: string }>
> {
  protected $pgColumnBuilderBrand: string = 'PgCITextBuilder';
  
  build<TTableName extends string>(table: AnyPgTable<{ name: TTableName }>): PgCIText<TTableName, TData> {
    return new PgCIText(table, this.config);
  }
}

export class PgCIText<TTableName extends string, TData extends string>
  extends PgColumn<PgColumnHKT, ColumnConfig<{ tableName: TTableName; data: TData; driverParam: string }>>
{
  

  constructor(table: AnyPgTable<{ name: TTableName }>, builder: PgCITextBuilder<TData>['config']) {
    super(table, builder);
  }

  getSQLType(): string {
    return 'citext';
  }
}

export function citext<T extends string = string>(name: string): PgCITextBuilder<T> {
  return new PgCITextBuilder(name);
}

LANGUAGE: typescript
CODE:
const table = pgTable('table', {
  id: integer('id').primaryKey(),
  ciname: citext('ciname')
})

----------------------------------------

TITLE: Generating SQL from Relational Query API in TypeScript
DESCRIPTION: Shows how to use the new .toSQL() method to generate SQL from a Relational Query API call without executing the query.

LANGUAGE: typescript
CODE:
const query = db.query.usersTable.findFirst().toSQL();

----------------------------------------

TITLE: Creating Update Schema for Tables in TypeScript
DESCRIPTION: Shows how to use the new createUpdateSchema function to create a schema for updating queries, including handling of generated columns and parsing update data.

LANGUAGE: typescript
CODE:
import { pgTable, text, integer } from 'drizzle-orm/pg-core';
import { createUpdateSchema } from 'drizzle-valibot';
import { parse } from 'valibot';

const users = pgTable('users', {
  id: integer().generatedAlwaysAsIdentity().primaryKey(),
  name: text().notNull(),
  age: integer().notNull()
});

const userUpdateSchema = createUpdateSchema(users);

const user = { id: 5, name: 'John' };
const parsed: { name?: string | undefined, age?: number | undefined } = parse(userUpdateSchema, user); // Error: `id` is a generated column, it can't be updated

const user = { age: 35 };
const parsed: { name?: string | undefined, age?: number | undefined } = parse(userUpdateSchema, user); // Will parse successfully
await db.update(users).set(parsed).where(eq(users.name, 'Jane'));

----------------------------------------

TITLE: Defining Custom Serial Type in PostgreSQL
DESCRIPTION: Creates a custom Serial type for PostgreSQL using the customType function from Drizzle ORM.

LANGUAGE: typescript
CODE:
const customSerial = customType<{ data: number; notNull: true; default: true }>(
  {
    dataType() {
      return 'serial';
    },
  },
);

----------------------------------------

TITLE: Using OVERRIDING SYSTEM VALUE in Drizzle ORM Insert
DESCRIPTION: Shows how to use the OVERRIDING SYSTEM VALUE API to force custom values for GENERATED ALWAYS AS IDENTITY columns in a PostgreSQL database insert operation.

LANGUAGE: typescript
CODE:
await db.insert(identityColumnsTable).overridingSystemValue().values([
  { alwaysAsIdentity: 2 },
]);

----------------------------------------

TITLE: Defining UNIQUE Constraints in PostgreSQL with Drizzle ORM
DESCRIPTION: This snippet demonstrates how to define single-column and multi-column UNIQUE constraints in PostgreSQL using Drizzle ORM. It includes examples of custom constraint names and the 'NULLS NOT DISTINCT' option.

LANGUAGE: typescript
CODE:
// single column
const table = pgTable('table', {
  id: serial('id').primaryKey(),
  name: text('name').notNull().unique(),
  state: char('state', { length: 2 }).unique('custom'),
  field: char('field', { length: 2 }).unique('custom_field', { nulls: 'not distinct' }),
});
// multiple columns
const table = pgTable('table', {
  id: serial('id').primaryKey(),
  name: text('name').notNull(),
  state: char('state', { length: 2 }),
}, (t) => ({
  first: unique('custom_name').on(t.name, t.state).nullsNotDistinct(),
  second: unique('custom_name1').on(t.name, t.state),
}));

----------------------------------------

TITLE: Implementing RLS on Views in Drizzle ORM
DESCRIPTION: This example shows how to specify RLS policies on views in Drizzle ORM. It demonstrates the use of 'security_invoker' in the view's WITH options to enable RLS on a view.

LANGUAGE: typescript
CODE:
export const roomsUsersProfiles = pgView("rooms_users_profiles")
  .with({
    securityInvoker: true,
  })
  .as((qb) =>
    qb
      .select({
        ...getTableColumns(roomsUsers),
        email: profiles.email,
      })
      .from(roomsUsers)
      .innerJoin(profiles, eq(roomsUsers.userId, profiles.id))
  );

----------------------------------------

TITLE: Defining Custom Text Type in PostgreSQL
DESCRIPTION: Creates a custom Text type for PostgreSQL using the customType function from Drizzle ORM.

LANGUAGE: typescript
CODE:
const customText = customType<{ data: string }>({
  dataType() {
    return 'text';
  },
});

----------------------------------------

TITLE: Using SQL Operators in Relational Queries' Where Clause in TypeScript
DESCRIPTION: Compares the old and new ways of using SQL operators like inArray in the where clause of relational queries. The new approach provides the operators as part of the where function parameters.

LANGUAGE: typescript
CODE:
// Before
import { inArray } from "drizzle-orm/pg-core";

await db.users.findFirst({
  where: (table, _) => inArray(table.id, [ ... ])
})

// After
await db.users.findFirst({
  where: (table, { inArray }) => inArray(table.id, [ ... ])
})

----------------------------------------

TITLE: Configuring Custom Migrations Table - TypeScript
DESCRIPTION: Shows how to configure a custom table name for storing migration information in the database instead of using the default '__drizzle_migrations' table.

LANGUAGE: typescript
CODE:
await migrate(db, {
	migrationsFolder: './drizzle',
	migrationsTable: 'my_migrations',
});

----------------------------------------

TITLE: Defining Custom Timestamp Type in MySQL
DESCRIPTION: Creates a custom Timestamp type for MySQL using the customType function from Drizzle ORM. Includes configuration options for fractional seconds precision.

LANGUAGE: typescript
CODE:
const customTimestamp = customType<
  { data: Date; driverData: string; config: { fsp: number } }
>({
  dataType(config) {
    const precision = typeof config.fsp !== 'undefined'
      ? ` (${config.fsp})`
      : '';
    return `timestamp${precision}`;
  },
  fromDriver(value: string): Date {
    return new Date(value);
  },
});

----------------------------------------

TITLE: PostgreSQL Distinct ON Clause Implementation
DESCRIPTION: Demonstrates PostgreSQL-specific distinct ON clause usage in Drizzle ORM for advanced unique record filtering.

LANGUAGE: typescript
CODE:
await db.selectDistinctOn([usersDistinctTable.id]).from(usersDistinctTable).orderBy(
  usersDistinctTable.id,
);

await db.selectDistinctOn([usersDistinctTable.name], { name: usersDistinctTable.name }).from(
  usersDistinctTable,
).orderBy(usersDistinctTable.name);

----------------------------------------

TITLE: Implementing WITH Clause Query in Drizzle ORM - TypeScript
DESCRIPTION: Demonstrates how to use the new WITH clause functionality in Drizzle ORM. Shows subquery preparation and subsequent usage in a SELECT statement with grouping. The example includes type casting and aggregate functions.

LANGUAGE: typescript
CODE:
const sq = db
    .select()
    .from(users)
    .prepareWithSubquery('sq');

const result = await db
    .with(sq)
    .select({
      id: sq.id,
      name: sq.name,
      total: sql<number>`count(${sq.id})::int`(),
    })
    .from(sq)
    .groupBy(sq.id, sq.name);

----------------------------------------

TITLE: Converting Complex JSON Strings with Type Checking
DESCRIPTION: SQL query to convert stringified JSON values to JSON objects while handling both objects/arrays and primitive values.

LANGUAGE: sql
CODE:
UPDATE table_name
SET json_column = CASE
    -- Convert to JSON if it is a valid JSON object or array
    WHEN json_column #>> '{}' LIKE '{%' OR json_column #>> '{}' LIKE '[%' THEN
        (json_column #>> '{}')::json
    ELSE
        json_column
END
WHERE json_column IS NOT NULL;

----------------------------------------

TITLE: Using WITH Clause with INSERT Operations
DESCRIPTION: Shows how to use the WITH clause with INSERT operations in Drizzle ORM.

LANGUAGE: typescript
CODE:
const users = pgTable('users', {
  id: serial('id').primaryKey(),
  name: text('name').notNull(),
});

const sq = db.$with('sq').as(
    db.insert(users).values({ name: 'John' }).returning(),
);

const result = await db.with(sq).select().from(sq);

----------------------------------------

TITLE: Type Checking with is() Function in Drizzle
DESCRIPTION: Demonstrates the new is() function for type checking Drizzle objects, replacing instanceof to handle multiple Drizzle package instances in monorepos.

LANGUAGE: typescript
CODE:
import { is, Column } from 'drizzle-orm'

if (is(value, Column)) {
  // value's type is narrowed to Column
}

----------------------------------------

TITLE: Using Updated Interval Generator in TypeScript
DESCRIPTION: Demonstrates the usage of the updated interval generator, which now handles intervals more accurately for PostgreSQL compatibility.

LANGUAGE: typescript
CODE:
await seed(db, { table }).refine((f) => ({
  table: {
    columns: {
      // this function usage will output different values with the same `seed` number from previous version
      column1: f.interval({ isUnique: true }),
    }
  }
}))

----------------------------------------

TITLE: Using WITH Clause with UPDATE Operations
DESCRIPTION: Demonstrates using the WITH clause with UPDATE operations in Drizzle ORM.

LANGUAGE: typescript
CODE:
const users = pgTable('users', {
  id: serial('id').primaryKey(),
  name: text('name').notNull(),
});

const sq = db.$with('sq').as(
    db.update(users).set({ age: 25 }).where(eq(users.name, 'John')).returning(),
);
const result = await db.with(sq).select().from(sq);

----------------------------------------

TITLE: Implementing WITH Clause in DELETE Operation - TypeScript
DESCRIPTION: Demonstrates how to use WITH statements in DELETE operations using Drizzle ORM. The example shows creating a CTE (Common Table Expression) to calculate average order amount and using it in a delete operation.

LANGUAGE: typescript
CODE:
const averageAmount = db.$with('average_amount').as(
	db.select({ value: sql`avg(${orders.amount})`.as('value') }).from(orders),
);
const result = await db
	.with(averageAmount)
	.delete(orders)
	.where(gt(orders.amount, sql`(select * from ${averageAmount})`))
	.returning({
		id: orders.id,
	});

LANGUAGE: sql
CODE:
with "average_amount" as (select avg("amount") as "value" from "orders") 
delete from "orders" 
where "orders"."amount" > (select * from "average_amount") 
returning "id"

----------------------------------------

TITLE: Express.js Proxy Server Implementation
DESCRIPTION: Complete implementation of an Express.js server that handles proxied MySQL database operations. Includes endpoints for query execution and migration handling with proper error handling and type casting.

LANGUAGE: typescript
CODE:
import * as mysql from 'mysql2/promise';
import express from 'express';

const app = express();
app.use(express.json());
const port = 3000;

const main = async () => {
const connection = await mysql.createConnection('mysql://root:mysql@127.0.0.1:5432/drizzle');

app.post('/query', async (req, res) => {
	const { sql: sqlBody, params, method } = req.body;

	if (method === 'all') {
		try {
            const result = await connection.query({
                sql: sqlBody,
                values: params,
                rowsAsArray: true,
                typeCast: function(field: any, next: any) {
                    if (field.type === 'TIMESTAMP' || field.type === 'DATETIME' || field.type === 'DATE') {
                        return field.string();
                    }
                    return next();
                },
            });
			res.send(result[0]);
		} catch (e: any) {
			res.status(500).json({ error: e });
		}
	} else if (method === 'execute') {
		try {
            const result = await connection.query({
                sql: sqlBody,
                values: params,
                typeCast: function(field: any, next: any) {
                    if (field.type === 'TIMESTAMP' || field.type === 'DATETIME' || field.type === 'DATE') {
                        return field.string();
                    }
                    return next();
                },
            });

			res.send(result);
		} catch (e: any) {
			res.status(500).json({ error: e });
		}
	} else {
		res.status(500).json({ error: 'Unknown method value' });
	}
});

app.post('/migrate', async (req, res) => {
	const { queries } = req.body;

    await connection.query('BEGIN');
    try {
        for (const query of queries) {
            await connection.query(query);
        }
        await connection.query('COMMIT');
    } catch {
        await connection.query('ROLLBACK');
    }

	res.send({});
});

app.listen(port, () => {
	console.log(`Example app listening on port ${port}`);
});
}

main();

----------------------------------------

TITLE: Implementing Custom Schema for Postgres Enums in Drizzle ORM
DESCRIPTION: This snippet demonstrates how to create a custom schema and define an enum within that schema using Drizzle ORM with Postgres. It allows for more flexible enum definitions within specific database schemas.

LANGUAGE: typescript
CODE:
import { pgSchema } from 'drizzle-orm/pg-core';

const mySchema = pgSchema('mySchema');
const colors = mySchema.enum('colors', ['red', 'green', 'blue']);

----------------------------------------

TITLE: Using WITH Clause with Raw SQL
DESCRIPTION: Demonstrates using the WITH clause with raw SQL templates in Drizzle ORM.

LANGUAGE: typescript
CODE:
const users = pgTable('users', {
  id: serial('id').primaryKey(),
  name: text('name').notNull(),
});

const sq = db.$with('sq', {
  userId: users.id,
  data: {
    name: users.name,
  },
}).as(sql`select * from ${users} where ${users.name} = 'John'`);

const result = await db.with(sq).select().from(sq);

----------------------------------------

TITLE: Defining Custom JSON Type in MySQL
DESCRIPTION: Creates a custom JSON type for MySQL using the customType function from Drizzle ORM. Includes a toDriver method to stringify the data.

LANGUAGE: typescript
CODE:
const customJson = <TData>(name: string) =>
  customType<{ data: TData; driverData: string }>({
    dataType() {
      return 'json';
    },
    toDriver(value: TData): string {
      return JSON.stringify(value);
    },
  })(name);

----------------------------------------

TITLE: MySQL Iterator Support Enhancement
DESCRIPTION: Adds iterator support functionality to the mysql2 driver, allowing for more efficient data iteration operations. This feature was sponsored by @rizen.



----------------------------------------

TITLE: Using USE INDEX Hint in MySQL with Drizzle ORM
DESCRIPTION: Demonstrates how to suggest specific indexes to the MySQL query optimizer using the USE INDEX hint. Creates a users table with a name index and shows how to prioritize that index in a select query.

LANGUAGE: typescript
CODE:
export const users = mysqlTable('users', {
  id: int('id').primaryKey(),
  name: varchar('name', { length: 100 }).notNull(),
}, () => [usersTableNameIndex]);

const usersTableNameIndex = index('users_name_index').on(users.name);

await db.select()
  .from(users, { useIndex: usersTableNameIndex })
  .where(eq(users.name, 'David'));

----------------------------------------

TITLE: Aliasing Tables in UPDATE ... FROM with Drizzle ORM
DESCRIPTION: Shows how to alias tables in an UPDATE ... FROM query using Drizzle ORM. This is particularly useful for more complex queries or when working with multiple instances of the same table.

LANGUAGE: typescript
CODE:
const c = alias(cities, 'c');
await db
  .update(users)
  .set({ cityId: c.id })
  .from(c);

LANGUAGE: sql
CODE:
update "users" set "city_id" = "c"."id" 
from "cities" "c"

----------------------------------------

TITLE: Defining Custom Text Type in MySQL
DESCRIPTION: Creates a custom Text type for MySQL using the customType function from Drizzle ORM.

LANGUAGE: typescript
CODE:
const customText = customType<{ data: string }>({
  dataType() {
    return 'text';
  },
});

----------------------------------------

TITLE: Defining Custom Text Type in Drizzle ORM with TypeScript
DESCRIPTION: Shows how to create a custom text data type and use it in a table definition. The example demonstrates creating a typed text field using customType helper and applying it to a users table schema.

LANGUAGE: typescript
CODE:
const customText = customType<{ data: string }>({\n\tdataType() {\n\t\treturn 'text';\n\t},\n});\n\nconst usersTable = pgTable('users', {\n\tname: customText('name').notNull(),\n});

----------------------------------------

TITLE: Using IGNORE INDEX Hint in MySQL with Drizzle ORM
DESCRIPTION: Shows how to tell the MySQL optimizer to avoid using specific indexes using the IGNORE INDEX hint. Creates a users table and demonstrates how to exclude a particular index from consideration in query optimization.

LANGUAGE: typescript
CODE:
export const users = mysqlTable('users', {
  id: int('id').primaryKey(),
  name: varchar('name', { length: 100 }).notNull(),
}, () => [usersTableNameIndex]);

const usersTableNameIndex = index('users_name_index').on(users.name);

await db.select()
  .from(users, { ignoreIndex: usersTableNameIndex })
  .where(eq(users.name, 'David'));

----------------------------------------

TITLE: Configuring Drizzle Database Instance with HTTP Proxy
DESCRIPTION: Sets up a Drizzle database instance that proxies SQL queries through HTTP calls to a remote server. Handles query execution with proper error handling and response formatting.

LANGUAGE: typescript
CODE:
import axios from 'axios';
import { drizzle } from 'drizzle-orm/mysql-proxy';

const db = drizzle(async (sql, params, method) => {
  try {
    const rows = await axios.post('http://localhost:3000/query', {
      sql,
      params,
      method,
    });

    return { rows: rows.data };
  } catch (e: any) {
    console.error('Error from mysql proxy server: ', e.response.data);
    return { rows: [] };
  }
});

----------------------------------------

TITLE: Updating Drizzle Config for Turso Dialect in TypeScript
DESCRIPTION: Example of how to update the drizzle.config file to use the new Turso dialect instead of the previous SQLite dialect for Turso users.

LANGUAGE: typescript
CODE:
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  dialect: "turso",
  schema: "./schema.ts",
  out: "./drizzle",
  dbCredentials: {
    url: "database.db",
  },
  breakpoints: true,
  verbose: true,
  strict: true,
});

----------------------------------------

TITLE: Using FORCE INDEX Hint in MySQL with Drizzle ORM
DESCRIPTION: Illustrates how to force the MySQL optimizer to use specific indexes with the FORCE INDEX hint. Creates a users table and shows how to mandate the use of a particular index in query execution.

LANGUAGE: typescript
CODE:
export const users = mysqlTable('users', {
  id: int('id').primaryKey(),
  name: varchar('name', { length: 100 }).notNull(),
}, () => [usersTableNameIndex]);

const usersTableNameIndex = index('users_name_index').on(users.name);

await db.select()
  .from(users, { forceIndex: usersTableNameIndex })
  .where(eq(users.name, 'David'));

----------------------------------------

TITLE: Initializing Drizzle Database Instance with HTTP Call Implementation
DESCRIPTION: Sets up a Drizzle database instance using the SQLite Proxy driver. It implements HTTP calls to communicate with the database server, handling errors and returning results in the expected format.

LANGUAGE: typescript
CODE:
import axios from 'axios';
import { drizzle } from 'drizzle-orm/sqlite-proxy';

const db = drizzle(async (sql, params, method) => {
  try {
    const rows = await axios.post('http://localhost:3000/query', {
      sql,
      params,
      method,
    });

    return { rows: rows.data };
  } catch (e: any) {
    console.error('Error from sqlite proxy server: ', e.response.data);
    return { rows: [] };
  }
});

----------------------------------------

TITLE: Defining Policies in Drizzle ORM
DESCRIPTION: This snippet demonstrates how to define policies within a Drizzle table. It shows a full example of a pgPolicy with all available properties, including the policy name, role, actions, and conditions.

LANGUAGE: typescript
CODE:
import { sql } from 'drizzle-orm';
import { integer, pgPolicy, pgRole, pgTable } from 'drizzle-orm/pg-core';

export const admin = pgRole('admin');

export const users = pgTable('users', {
	id: integer(),
}, (t) => [
	pgPolicy('policy', {
		as: 'permissive',
		to: admin,
		for: 'delete',
		using: sql``,
		withCheck: sql``,
	}),
]);

----------------------------------------

TITLE: Seeding PostgreSQL Table with UUID Columns in TypeScript
DESCRIPTION: Demonstrates how to set up a PostgreSQL table with a UUID column and seed it using Drizzle ORM. The example shows both automatic seeding and manual specification of the UUID generator.

LANGUAGE: typescript
CODE:
import { pgTable, uuid } from "drizzle-orm/pg-core";
import { drizzle } from "drizzle-orm/node-postgres";
import { seed } from "drizzle-seed";

const users = pgTable("users", {
  uuid: uuid("uuid"),
});

async function main() {
  const db = drizzle(process.env.DATABASE_URL!);
  //  You can let it seed automatically
  //  await seed(db, { users });

  // Alternatively, you can manually specify the generator in refine.
  await seed(db, { users }, { count: 1000 }).refine((funcs) => ({
    users: {
      columns: {
        uuid: funcs.uuid(),
      },
    },
  }));
}

main();

----------------------------------------

TITLE: Seeding Database with drizzle-seed in TypeScript
DESCRIPTION: Demonstrates how to use the drizzle-seed package to create 10 users with random names and ids in a PostgreSQL database. It shows the setup of a users table and the basic usage of the seed function.

LANGUAGE: typescript
CODE:
import { pgTable, integer, text } from "drizzle-orm/pg-core";
import { drizzle } from "drizzle-orm/node-postgres";
import { seed } from "drizzle-seed";

const users = pgTable("users", {
  id: integer().primaryKey(),
  name: text().notNull(),
});

async function main() {
  const db = drizzle(process.env.DATABASE_URL!);
  await seed(db, { users });
}

main();

----------------------------------------

TITLE: Implementing Locking Clauses in SELECT Queries for MySQL using Drizzle ORM
DESCRIPTION: Shows how to use locking clauses in SELECT statements for MySQL using Drizzle ORM. Includes examples of FOR UPDATE and FOR SHARE with options like skipLocked and noWait.

LANGUAGE: typescript
CODE:
await db.select().from(users).for('update');
await db.select().from(users).for('share', { skipLocked: true });
await db.select().from(users).for('update', { noWait: true });

----------------------------------------

TITLE: Configuring Drizzle for Expo SQLite
DESCRIPTION: Configuration file setup for Drizzle with Expo SQLite driver

LANGUAGE: typescript
CODE:
import type { Config } from 'drizzle-kit';

export default {
	schema: './db/schema.ts',
	out: './drizzle',
	driver: 'expo',
} satisfies Config;

----------------------------------------

TITLE: Setting Seed Value in drizzle-seed
DESCRIPTION: Demonstrates how to set a specific seed value to generate a unique set of values for all subsequent runs of the seed function.

LANGUAGE: typescript
CODE:
await seed(db, schema, { seed: 12345 });

----------------------------------------

TITLE: Vector Query Examples in TypeScript
DESCRIPTION: Practical examples of vector queries using the pg_vector extension.

LANGUAGE: typescript
CODE:
import { l2Distance } from 'drizzle-orm';

// SELECT * FROM items ORDER BY embedding <-> '[3,1,2]' LIMIT 5;
db.select().from(items).orderBy(l2Distance(items.embedding, [3,1,2]))

// SELECT embedding <-> '[3,1,2]' AS distance FROM items;
db.select({ distance: l2Distance(items.embedding, [3,1,2]) })

// SELECT * FROM items ORDER BY embedding <-> (SELECT embedding FROM items WHERE id = 1) LIMIT 5;
const subquery = db.select({ embedding: items.embedding }).from(items).where(eq(items.id, 1));
db.select().from(items).orderBy(l2Distance(items.embedding, subquery)).limit(5)

// SELECT (embedding <#> '[3,1,2]') * -1 AS inner_product FROM items;
db.select({ innerProduct: sql`(${maxInnerProduct(items.embedding, [3,1,2])}) * -1` }).from(items)

----------------------------------------

TITLE: Running Drizzle Kit Migration Generation
DESCRIPTION: Command to execute the configured migration generation script using NPM.

LANGUAGE: shell
CODE:
npm run generate

----------------------------------------

TITLE: Converting Simple JSON String to JSON Type
DESCRIPTION: SQL query to convert stringified JSON values to actual JSON objects in PostgreSQL tables.

LANGUAGE: sql
CODE:
update table_name
set json_column = (json_column #>> '{}')::json;

----------------------------------------

TITLE: Using $withAuth() API for Neon HTTP Driver in Drizzle ORM
DESCRIPTION: Demonstrates the usage of the $withAuth() API for the Neon HTTP driver in Drizzle ORM. It shows how to send an auth token to authorize queries for select and update operations.

LANGUAGE: typescript
CODE:
const token = 'HdncFj1Nm'

await db.$withAuth(token).select().from(usersTable);
await db.$withAuth(token).update(usersTable).set({ name: 'CHANGED' }).where(eq(usersTable.name, 'TARGET'))

----------------------------------------

TITLE: Creating PostgreSQL Generated Columns in TypeScript
DESCRIPTION: Shows how to specify generated columns in PostgreSQL, including an example with a tsvector column type and referencing other columns or using SQL templates.

LANGUAGE: typescript
CODE:
import { SQL, sql } from "drizzle-orm";
import { customType, index, integer, pgTable, text } from "drizzle-orm/pg-core";

const tsVector = customType<{ data: string }>({
  dataType() {
    return "tsvector";
  },
});

export const test = pgTable(
  "test",
  {
    id: integer("id").primaryKey().generatedAlwaysAsIdentity(),
    content: text("content"),
    contentSearch: tsVector("content_search", {
      dimensions: 3,
    }).generatedAlwaysAs(
      (): SQL => sql`to_tsvector('english', ${test.content})`
    ),
  },
  (t) => ({
    idx: index("idx_content_search").using("gin", t.contentSearch),
  })
);

LANGUAGE: typescript
CODE:
export const users = pgTable("users", {
  id: integer("id"),
  name: text("name"),
  generatedName: text("gen_name").generatedAlwaysAs(sql`hello world!`),
  generatedName1: text("gen_name1").generatedAlwaysAs("hello world!"),
}),

----------------------------------------

TITLE: Updating Drizzle ORM MySQL Package Version
DESCRIPTION: This snippet documents the version update of the drizzle-orm-mysql package to 0.14.2. It indicates that all components within the package have been updated to this new version.

LANGUAGE: Markdown
CODE:
# drizzle-orm-mysql 0.14.2

- Bumped everything to 0.14.2

----------------------------------------

TITLE: Initializing Default LibSQL Client with Drizzle
DESCRIPTION: Default LibSQL client implementation that automatically adapts between Node and web environments based on the bundler target.

LANGUAGE: typescript
CODE:
import { drizzle } from 'drizzle-orm/libsql';

const db = drizzle({ connection: {
  url: process.env.DATABASE_URL, 
  authToken: process.env.DATABASE_AUTH_TOKEN 
}});

----------------------------------------

TITLE: Performing a Left Join in Drizzle ORM (TypeScript)
DESCRIPTION: This TypeScript snippet demonstrates how to perform the equivalent left join operation using Drizzle ORM, including column selection and join condition.

LANGUAGE: typescript
CODE:
const rows = await db
  .select({
      cityId: cities.id,
      cityName: cities.name,
      userId: users.id,
      firstName: users.firstName,
      lastName: users.lastName,
    })
  .from(cities)
  .leftJoin(users, eq(users.cityId, cities.id));

----------------------------------------

TITLE: Configuring Drizzle Kit in package.json
DESCRIPTION: NPM script configuration for generating migrations using Drizzle Kit with specified output folder and schema location.

LANGUAGE: jsonc
CODE:
{
 "scripts": {
  "generate": "drizzle-kit generate --out migrations-folder --schema src/db/schema.ts"
 }
}

----------------------------------------

TITLE: Implementing Type Coercion with Drizzle and Zod
DESCRIPTION: Demonstrates how to use type coercion in Drizzle ORM with Zod schema validation. The example shows configuration of selective coercion for date fields when creating insert schemas for database tables.

LANGUAGE: typescript
CODE:
import { pgTable, timestamp } from 'drizzle-orm/pg-core';
import { createSchemaFactory } from 'drizzle-zod';
import { z } from 'zod';

const users = pgTable('users', {
  ...,
  createdAt: timestamp().notNull()
});

const { createInsertSchema } = createSchemaFactory({
  // This configuration will only coerce dates. Set `coerce` to `true` to coerce all data types or specify others
  coerce: {
    date: true
  }
});

const userInsertSchema = createInsertSchema(users);
// The above is the same as this:
const userInsertSchema = z.object({
  ...,
  createdAt: z.coerce.date()
});

----------------------------------------

TITLE: Initializing Web Framework LibSQL Client
DESCRIPTION: Web-specific implementation for fullstack frameworks like Next.js, Nuxt, and Astro.

LANGUAGE: typescript
CODE:
import { drizzle } from 'drizzle-orm/libsql/web';

const db = drizzle({ connection: {
  url: process.env.DATABASE_URL, 
  authToken: process.env.DATABASE_AUTH_TOKEN 
}});

----------------------------------------

TITLE: Defining UNIQUE Constraints in MySQL with Drizzle ORM
DESCRIPTION: This snippet shows how to define single-column and multi-column UNIQUE constraints in MySQL using Drizzle ORM. It's similar to PostgreSQL but without the 'NULLS NOT DISTINCT' option.

LANGUAGE: typescript
CODE:
// single column
const table = mysqlTable('table', {
    id: serial('id').primaryKey(),
    name: text('name').notNull().unique(),
    state: text('state').unique('custom'),
    field: text('field').unique('custom_field'),
});
// multiple columns
const table = mysqlTable('cities1', {
    id: serial('id').primaryKey(),
    name: text('name').notNull(),
    state: text('state'),
}, (t) => ({
    first: unique().on(t.name, t.state),
    second: unique('custom_name1').on(t.name, t.state),
}));

----------------------------------------

TITLE: MySQL Enum Definition - New Syntax
DESCRIPTION: Shows the new recommended way of defining MySQL enums directly in the column definition.

LANGUAGE: typescript
CODE:
const tableWithEnums = mysqlTable('enums_test_case', {
	id: serial('id').primaryKey(),
	enum1: mysqlEnum('enum1', ['a', 'b', 'c']).notNull(),
	enum2: mysqlEnum('enum2', ['a', 'b', 'c']).default('a'),
	enum3: mysqlEnum('enum3', ['a', 'b', 'c']).notNull().default('b'),
});

----------------------------------------

TITLE: Initializing HTTP-specific LibSQL Client
DESCRIPTION: Implementation specifically for HTTP and HTTPS connection protocols.

LANGUAGE: typescript
CODE:
import { drizzle } from 'drizzle-orm/libsql/http';

const db = drizzle({ connection: {
  url: process.env.DATABASE_URL, 
  authToken: process.env.DATABASE_AUTH_TOKEN 
}});

----------------------------------------

TITLE: MySQL Prepare Statement Simplification
DESCRIPTION: Modification to the .prepare() method in MySQL to remove the requirement for a name argument, simplifying the prepare statement syntax.



----------------------------------------

TITLE: Performing SQLite Queries
DESCRIPTION: Shows how to perform various types of queries using Drizzle ORM with SQLite

LANGUAGE: typescript
CODE:
db.select().from(users).all();
db.select().from(users).where(eq(users.id, 42)).get();

// you can combine filters with and(...) or or(...)
db.select().from(users).where(and(eq(users.id, 42), eq(users.name, 'Dan'))).all();

db.select().from(users).where(or(eq(users.id, 42), eq(users.id, 1))).all();

// partial select
const result = db
  .select({
    field1: users.id,
    field2: users.name,
  })
  .from(users)
  .all();
const { field1, field2 } = result[0];

----------------------------------------

TITLE: Supporting PostgreSQL Arrays in TypeScript
DESCRIPTION: Shows how PostgreSQL arrays are now fully supported in the drizzle-zod integration. It demonstrates the schema creation for array data types with length constraints.

LANGUAGE: typescript
CODE:
pg.dataType().array(...);

// Schema
z.array(baseDataTypeSchema).length(size);

----------------------------------------

TITLE: Updating Drizzle Configuration for Turso
DESCRIPTION: Example showing the migration from SQLite to Turso dialect configuration in drizzle-kit

LANGUAGE: typescript
CODE:
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  dialect: "turso",
  schema: "./schema.ts",
  out: "./drizzle",
  dbCredentials: {
    url: "database.db",
  },
  breakpoints: true,
  verbose: true,
  strict: true,
});

----------------------------------------

TITLE: Configuring Wrangler for Cloudflare Worker with Drizzle ORM
DESCRIPTION: This snippet shows the Wrangler configuration for a Cloudflare Worker project using Drizzle ORM. It specifies the project name, main file, compatibility date, and other settings.

LANGUAGE: toml
CODE:
name = "neon-cf-demo"
main = "src/index.ts"
compatibility_date = "2022-12-09"
usage_model = "unbound"
node_compat = true

----------------------------------------

TITLE: PlanetScale Client Migration Warning Message
DESCRIPTION: Warning message displayed when using the deprecated connect() method, providing guidance on migrating to the new Client instance approach.

LANGUAGE: mdx
CODE:
Warning: You need to pass an instance of Client:

import { Client } from "@planetscale/database";

const client = new Client({
  host: process.env["DATABASE_HOST"],
  username: process.env["DATABASE_USERNAME"],
  password: process.env["DATABASE_PASSWORD"],
});

const db = drizzle(client);

Starting from version 0.30.0, you will encounter an error if you attempt to use anything other than a Client instance.

Please make the necessary changes now to prevent any runtime errors in the future

----------------------------------------

TITLE: New Count API Implementation
DESCRIPTION: Examples of the new count API for simple counting and subqueries

LANGUAGE: typescript
CODE:
const count: number = await db.$count(users);

const count: number = await db.$count(users, eq(name, "Dan"));

const users = await db.select({
    ...users,
    postsCount: db.$count(posts, eq(posts.authorId, users.id))
});

const users = await db.query.users.findMany({
    extras: {
        postsCount: db.$count(posts, eq(posts.authorId, users.id))
    }
})

----------------------------------------

TITLE: Optimized SQL Query Generation for Relational Queries
DESCRIPTION: The SQL query generated by Drizzle ORM 0.28.0 for the improved relational query, showcasing the use of lateral joins and more efficient data retrieval.

LANGUAGE: sql
CODE:
select "comments"."id",
       "comments"."user_id",
       "comments"."post_id",
       "comments"."content",
       "comments_user"."data" as "user",
       "comments_post"."data" as "post"
from "comments"
         left join lateral (select json_build_array("comments_user"."name") as "data"
                            from (select *
                                  from "users" "comments_user"
                                  where "comments_user"."id" = "comments"."user_id"
                                  limit 1) "comments_user") "comments_user" on true
         left join lateral (select json_build_array("comments_post"."title", "comments_post_user"."data") as "data"
                            from (select *
                                  from "posts" "comments_post"
                                  where "comments_post"."id" = "comments"."post_id"
                                  limit 1) "comments_post"
                                     left join lateral (select json_build_array("comments_post_user"."name") as "data"
                                                        from (select *
                                                              from "users" "comments_post_user"
                                                              where "comments_post_user"."id" = "comments_post"."user_id"
                                                              limit 1) "comments_post_user") "comments_post_user"
                                               on true) "comments_post" on true
order by "comments"."id"
limit 1

----------------------------------------

TITLE: Implementing MySQL $returningId() Function in TypeScript
DESCRIPTION: Demonstrates how to use the new $returningId() function in MySQL to automatically receive inserted IDs as separate objects. It works with both auto-increment and custom primary keys.

LANGUAGE: typescript
CODE:
import { boolean, int, text, mysqlTable } from 'drizzle-orm/mysql-core';

const usersTable = mysqlTable('users', {
  id: int('id').primaryKey(),
  name: text('name').notNull(),
  verified: boolean('verified').notNull().default(false),
});


const result = await db.insert(usersTable).values([{ name: 'John' }, { name: 'John1' }]).$returningId();
//    ^? { id: number }[]

LANGUAGE: typescript
CODE:
import { varchar, text, mysqlTable } from 'drizzle-orm/mysql-core';
import { createId } from '@paralleldrive/cuid2';

const usersTableDefFn = mysqlTable('users_default_fn', {
  customId: varchar('id', { length: 256 }).primaryKey().$defaultFn(createId),
  name: text('name').notNull(),
});


const result = await db.insert(usersTableDefFn).values([{ name: 'John' }, { name: 'John1' }]).$returningId();
//  ^? { customId: string }[]

----------------------------------------

TITLE: Defining PostgreSQL Schema with Updated Generators in TypeScript
DESCRIPTION: Illustrates the definition of a PostgreSQL schema using updated generators for text, varchar, and char columns.

LANGUAGE: typescript
CODE:
// schema.ts
import * as p from 'drizzle-orm/pg-core'

export const table = p.pgTable('table', {
  column1: p.text(),
  column2: p.varchar(),
  column3: p.char()
});

----------------------------------------

TITLE: Defining Database Schema with Drizzle Relations in TypeScript
DESCRIPTION: Demonstrates how to define database tables and their relationships using Drizzle ORM. Creates users and posts tables with one-to-many relationship using relations helper functions.

LANGUAGE: typescript
CODE:
// schema.ts
import { integer, serial, text, pgTable } from 'drizzle-orm/pg-core';
import { relations } from 'drizzle-orm';
export const users = pgTable('users', {
  id: serial('id').primaryKey(),
  name: text('name').notNull(),
});
export const usersRelations = relations(users, ({ many }) => ({
  posts: many(posts),
}));
export const posts = pgTable('posts', {
  id: serial('id').primaryKey(),
  content: text('content').notNull(),
  authorId: integer('author_id').notNull(),
});
export const postsRelations = relations(posts, ({ one }) => ({
  author: one(users, { fields: [posts.authorId], references: [users.id] }),
}));

----------------------------------------

TITLE: Configuring Seed Count in drizzle-seed
DESCRIPTION: Shows how to specify the number of entities to be created when using the seed function from drizzle-seed. This example sets the count to 1000.

LANGUAGE: typescript
CODE:
await seed(db, schema, { count: 1000 });

----------------------------------------

TITLE: Returning Joined Table Columns in PostgreSQL UPDATE ... FROM with Drizzle ORM
DESCRIPTION: Demonstrates how to return columns from joined tables in a PostgreSQL UPDATE ... FROM query using Drizzle ORM. This feature allows for retrieving updated data along with related information in a single query.

LANGUAGE: typescript
CODE:
const updatedUsers = await db
  .update(users)
  .set({ cityId: cities.id })
  .from(cities)
  .returning({ id: users.id, cityName: cities.name });

LANGUAGE: sql
CODE:
update "users" set "city_id" = "cities"."id" 
from "cities" 
returning "users"."id", "cities"."name"

----------------------------------------

TITLE: Returning Joined Table Columns in PostgreSQL UPDATE ... FROM with Drizzle ORM
DESCRIPTION: Demonstrates how to return columns from joined tables in a PostgreSQL UPDATE ... FROM query using Drizzle ORM. This feature allows for retrieving updated data along with related information in a single query.

LANGUAGE: typescript
CODE:
const updatedUsers = await db
  .update(users)
  .set({ cityId: cities.id })
  .from(cities)
  .returning({ id: users.id, cityName: cities.name });

LANGUAGE: sql
CODE:
update "users" set "city_id" = "cities"."id" 
from "cities" 
returning "users"."id", "cities"."name"

----------------------------------------

TITLE: Seeding with Specific Generator Versions in TypeScript
DESCRIPTION: Illustrates how to use specific versions of generators by specifying the version parameter.

LANGUAGE: typescript
CODE:
await seed(db, schema, { version: '2' });

LANGUAGE: typescript
CODE:
await seed(db, schema, { version: '1' });

----------------------------------------

TITLE: Implementing SQLite Proxy Server with Express.js
DESCRIPTION: Provides an example of a proxy server implementation using Express.js. It handles database queries and migrations, executing them on a SQLite database using better-sqlite3.

LANGUAGE: typescript
CODE:
import Database from 'better-sqlite3';
import express from 'express';

const app = express();
app.use(express.json());
const port = 3000;

const db = new Database('./test.db');

app.post('/query', (req, res) => {
  const { sql: sqlBody, params, method } = req.body;

  if (method === 'run') {
    try {
      const result = db.prepare(sqlBody).run(params);
      res.send(result);
    } catch (e: any) {
      res.status(500).json({ error: e.message });
    }
  } else if (method === 'all' || method === 'values') {
    try {
      const rows = db.prepare(sqlBody).raw().all(params);
      res.send(rows);
    } catch (e: any) {
      res.status(500).json({ error: e.message });
    }
  } else if (method === 'get') {
    try {
      const row = db.prepare(sqlBody).raw().get(params);
      res.send(row);
    } catch (e: any) {
      res.status(500).json({ error: e.message });
    }
  } else {
    res.status(500).json({ error: 'Unkown method value' });
  }
});

app.post('/migrate', (req, res) => {
  const { queries } = req.body;

  db.exec('BEGIN');
  try {
    for (const query of queries) {
      db.exec(query);
    }

    db.exec('COMMIT');
  } catch (e: any) {
    db.exec('ROLLBACK');
  }

  res.send({});
});

app.listen(port, () => {
  console.log(`Example app listening on port ${port}`);
});

----------------------------------------

TITLE: Implementing MySQL Generated Columns in TypeScript
DESCRIPTION: Demonstrates how to specify generated columns in MySQL, including both stored and virtual options, and referencing other columns or using SQL templates.

LANGUAGE: typescript
CODE:
export const users = mysqlTable("users", {
  id: int("id"),
  id2: int("id2"),
  name: text("name"),
  generatedName: text("gen_name").generatedAlwaysAs(
    (): SQL => sql`${schema2.users.name} || 'hello'`,
    { mode: "stored" }
  ),
  generatedName1: text("gen_name1").generatedAlwaysAs(
    (): SQL => sql`${schema2.users.name} || 'hello'`,
    { mode: "virtual" }
  ),
}),

----------------------------------------

TITLE: Drizzle ORM Warning Message for Duplicate Relations
DESCRIPTION: This snippet shows the warning message that Drizzle ORM now displays when a one-to-many relation is defined between two tables that already have a foreign key constraint in the schema. This warning helps prevent the duplication of relations and potential infinite loops during seeding.

LANGUAGE: plaintext
CODE:
You are providing a one-to-many relation between the 'users' and 'posts' tables,
while the 'posts' table object already has foreign key constraint in the schema referencing 'users' table.
In this case, the foreign key constraint will be used.

----------------------------------------

TITLE: Using Updated String Generators in TypeScript
DESCRIPTION: Shows the usage of updated string generators, which now support generating unique strings based on column length.

LANGUAGE: typescript
CODE:
await seed(db, { table }).refine((f) => ({
  table: {
    columns: {
      // this function will output different values with the same `seed` number from previous version
      column1: f.string(),
    }
  }
}))

----------------------------------------

TITLE: Defining Custom Timestamp Type in PostgreSQL
DESCRIPTION: Creates a custom Timestamp type for PostgreSQL using the customType function from Drizzle ORM. Includes configuration options for timezone and precision.

LANGUAGE: typescript
CODE:
const customTimestamp = customType<
  {
    data: Date;
    driverData: string;
    config: { withTimezone: boolean; precision?: number };
  }
>({
  dataType(config) {
    const precision = typeof config.precision !== 'undefined'
      ? ` (${config.precision})`
      : '';
    return `timestamp${precision}${
      config.withTimezone ? ' with time zone' : ''
    }`;
  },
  fromDriver(value: string): Date {
    return new Date(value);
  },
});

----------------------------------------

TITLE: Type Mapping Examples for Column Classes
DESCRIPTION: Examples showing how to implement type mapping interceptors for JSON and integer values in custom column types.

LANGUAGE: typescript
CODE:
override mapToDriverValue(value: TData): string {
  return JSON.stringify(value);
}

LANGUAGE: typescript
CODE:
override mapFromDriverValue(value: number | string): number {
  if (typeof value === 'string') {
    return parseInt(value);
  }
  return value;
}

----------------------------------------

TITLE: Defining MySQL Schema with Updated Generators in TypeScript
DESCRIPTION: Shows the definition of a MySQL schema using updated generators for various column types.

LANGUAGE: typescript
CODE:
// schema.ts
import * as p from 'drizzle-orm/mysql-core'

export const table = p.mysqlTable('table', {
  column1: p.text(),
  column2: p.char(),
  column3: p.varchar({ length: 256 }),
  column4: p.binary(),
  column5: p.varbinary({ length: 256 }),
});

----------------------------------------

TITLE: Configuring PostgreSQL Migrations with Drizzle ORM
DESCRIPTION: Setup for running database migrations using Drizzle ORM. Creates a dedicated connection for migrations with max:1 setting as required by postgres.js for safe transactions.

LANGUAGE: typescript
CODE:
import postgres from 'postgres';
import { migrate } from 'drizzle-orm/postgres-js/migrator';

const migrationsClient = postgres(connectionString, {
  max: 1,
});
const db = drizzle(migrationsClient);
await migrate(db, { migrationsFolder: '...' });

----------------------------------------

TITLE: Implementing MySQL Proxy Migrations
DESCRIPTION: Handles database migrations through the MySQL Proxy driver. Executes migration queries in batches and provides transaction handling on the server side.

LANGUAGE: typescript
CODE:
import axios from 'axios';
import { migrate } from 'drizzle-orm/mysql-proxy/migrator';

await migrate(db, async (queries) => {
  try {
    await axios.post('http://localhost:3000/migrate', { queries });
  } catch (e) {
    console.log(e);
    throw Error('Proxy server cannot run migrations');
  }
}, { migrationsFolder: 'drizzle' });

----------------------------------------

TITLE: Initializing SingleStore Database and Defining Table Schema in TypeScript
DESCRIPTION: This snippet demonstrates how to import SingleStore-specific modules from Drizzle ORM, define a table schema, and initialize a database connection for SingleStore. It shows the basic setup for working with SingleStore in a Drizzle ORM project.

LANGUAGE: typescript
CODE:
import { int, singlestoreTable, varchar } from 'drizzle-orm/singlestore-core';
import { drizzle } from 'drizzle-orm/singlestore';

export const usersTable = singlestoreTable('users_table', {
  id: int().primaryKey(),
  name: varchar({ length: 255 }).notNull(),
  age: int().notNull(),
  email: varchar({ length: 255 }).notNull().unique(),
});

...

const db = drizzle(process.env.DATABASE_URL!);

db.select()...

----------------------------------------

TITLE: Defining SQLite Schema with Updated Generators in TypeScript
DESCRIPTION: Demonstrates the definition of an SQLite schema using updated generators for various column types.

LANGUAGE: typescript
CODE:
// schema.ts
import * as p from 'drizzle-orm/sqlite-core'

export const table = p.sqliteTable('table', {
  column1: p.text(),
  column2: p.numeric(),
  column3: p.blob({ mode:'buffer' }),
  column4: p.blob(),
});

----------------------------------------

TITLE: Improved WITH ... SELECT Subquery Creation in Drizzle ORM
DESCRIPTION: This snippet shows the before and after syntax for creating WITH ... SELECT subqueries in Drizzle ORM. The new syntax more closely resembles SQL, making it easier to read and understand. It uses the .$with() method to define a named subquery that can be used in subsequent queries.

LANGUAGE: typescript
CODE:
const regionalSales = db
  .select({
    region: orders.region,
    totalSales: sql`sum(${orders.amount})`.as<number>('total_sales'),
})
.from(orders)
.groupBy(orders.region)
.prepareWithSubquery('regional_sales');

await db.with(regionalSales).select(...).from(...);

LANGUAGE: typescript
CODE:
const regionalSales = db
  .$with('regional_sales')
  .as(
    db
      .select({
        region: orders.region,
        totalSales: sql<number>`sum(${orders.amount})`.as('total_sales'),
      })
      .from(orders)
      .groupBy(orders.region),
  );

await db.with(regionalSales).select(...).from(...);

----------------------------------------

TITLE: Overriding Postgres.js Date Parsers in TypeScript
DESCRIPTION: This code snippet demonstrates how to override the default date parsers in postgres.js to return transparent values. It modifies both parsers and serializers for specific PostgreSQL data types.

LANGUAGE: typescript
CODE:
const transparentParser = (val: any) => val;

// Override postgres.js default date parsers: https://github.com/porsager/postgres/discussions/761
for (const type of ['1184', '1082', '1083', '1114']) {
	client.options.parsers[type as any] = transparentParser;
	client.options.serializers[type as any] = transparentParser;
}

----------------------------------------

TITLE: Defining PostgreSQL Table with Array Columns in TypeScript
DESCRIPTION: Shows how to define a PostgreSQL table with array columns using Drizzle ORM. The example includes a 'users' table with a 'phone_numbers' column of type varchar array.

LANGUAGE: typescript
CODE:
import { pgTable, integer, text, varchar } from "drizzle-orm/pg-core";
import { drizzle } from "drizzle-orm/node-postgres";
import { seed } from "drizzle-seed";

const users = pgTable("users", {
  id: integer().primaryKey(),
  name: text().notNull(),
  phone_numbers: varchar({ length: 256 }).array(),
});

----------------------------------------

TITLE: Implementing Views in PostgreSQL with Drizzle ORM
DESCRIPTION: Shows how to create both regular and materialized views in PostgreSQL using Drizzle ORM. The example demonstrates creating views based on a users table with both simple and materialized view implementations.

LANGUAGE: typescript
CODE:
import { sql } from "drizzle-orm";
import {
  check,
  pgMaterializedView,
  pgTable,
  pgView,
} from "drizzle-orm/pg-core";

export const users = pgTable(
  "users",
  (c) => ({
    id: c.uuid().defaultRandom().primaryKey(),
    username: c.text().notNull(),
    age: c.integer(),
  }),
  (table) => ({
    checkConstraint: check("age_check", sql`${table.age} > 21`),
  })
);

export const simpleView = pgView("simple_users_view").as((qb) =>
  qb.select().from(users)
);

export const materializedView = pgMaterializedView(
  "materialized_users_view"
).as((qb) => qb.select().from(users));

LANGUAGE: sql
CODE:
CREATE TABLE IF NOT EXISTS "users" (
  "id" uuid PRIMARY KEY DEFAULT gen_random_uuid() NOT NULL,
  "username" text NOT NULL,
  "age" integer,
  CONSTRAINT "age_check" CHECK ("users"."age" > 21)
);

CREATE VIEW "public"."simple_users_view" AS (select "id", "username", "age" from "users");

CREATE MATERIALIZED VIEW "public"."materialized_users_view" AS (select "id", "username", "age" from "users");

----------------------------------------

TITLE: Database Reset and Reseeding in Drizzle ORM
DESCRIPTION: Shows how to reset a database and reseed it with new values, typically used in test suites.

LANGUAGE: typescript
CODE:
import * as schema from "./schema.ts";
import { reset } from "drizzle-seed";

async function main() {
  const db = drizzle(process.env.DATABASE_URL!);
  await reset(db, schema);
}

main();

----------------------------------------

TITLE: Generated SQL Output
DESCRIPTION: The resulting SQL DDL statement generated from the Drizzle schema, showing the CREATE TABLE syntax with all defined columns and constraints.

LANGUAGE: sql
CODE:
CREATE TABLE "users" (
        "id" serial PRIMARY KEY NOT NULL,
        "email" text NOT NULL,
        "name" text
);

----------------------------------------

TITLE: Seeding PostgreSQL Table with Array Columns in TypeScript
DESCRIPTION: Demonstrates how to seed a PostgreSQL table with array columns using Drizzle ORM. The example shows both manual specification of array size and automatic handling of arrays of any dimension.

LANGUAGE: typescript
CODE:
async function main() {
  const db = drizzle(process.env.DATABASE_URL!);
  await seed(db, { users }, { count: 1000 }).refine((funcs) => ({
    users: {
      columns: {
        phone_numbers: funcs.phoneNumber({ arraySize: 3 }),
      },
    },
  }));
}

main();

LANGUAGE: typescript
CODE:
async function main() {
  const db = drizzle(process.env.DATABASE_URL!);
  await seed(db, { users });
}

main();

----------------------------------------

TITLE: Creating Select Schema for Enums and Views in TypeScript
DESCRIPTION: Demonstrates how to use the createSelectSchema function with PostgreSQL enums and views. It shows the creation of schemas for both a roles enum and a users view.

LANGUAGE: typescript
CODE:
import { pgEnum } from 'drizzle-orm/pg-core';
import { createSelectSchema } from 'drizzle-zod';

const roles = pgEnum('roles', ['admin', 'basic']);
const rolesSchema = createSelectSchema(roles);
const parsed: 'admin' | 'basic' = rolesSchema.parse(...);

const usersView = pgView('users_view').as((qb) => qb.select().from(users).where(gt(users.age, 18)));
const usersViewSchema = createSelectSchema(usersView);
const parsed: { id: number; name: string; age: number } = usersViewSchema.parse(...);

----------------------------------------

TITLE: New Drizzle Client Initialization
DESCRIPTION: Examples of the new simplified API for initializing Drizzle with various database clients

LANGUAGE: typescript
CODE:
import { drizzle } from 'drizzle-orm'

const db1 = await drizzle("node-postgres", process.env.POSTGRES_URL);

const db2 = await drizzle("node-postgres", {
  connection: process.env.POSTGRES_URL,
  logger: true
});

const db3 = await drizzle("node-postgres", {
  connection: {
    connectionString: process.env.POSTGRES_URL,
  },
});

const db4 = await drizzle("node-postgres", {
  connection: {
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    host: process.env.DB_HOST,
    port: process.env.DB_PORT,
    database: process.env.DB_NAME,
    ssl: true,
  },
});

----------------------------------------

TITLE: Seeding Users Table with Drizzle ORM in TypeScript
DESCRIPTION: This snippet demonstrates how to use drizzle-seed to create 10 users with random names and ids in a PostgreSQL database. It defines a users table schema and uses the seed function to populate it.

LANGUAGE: typescript
CODE:
import { pgTable, integer, text } from "drizzle-orm/pg-core";
import { drizzle } from "drizzle-orm/node-postgres";
import { seed } from "drizzle-seed";

const users = pgTable("users", {
  id: integer().primaryKey(),
  name: text().notNull(),
});

async function main() {
  const db = drizzle(process.env.DATABASE_URL!);
  await seed(db, { users });
}

main();

----------------------------------------

TITLE: Implementing Prisma-Drizzle Extension in TypeScript
DESCRIPTION: This code snippet demonstrates how to use the new Prisma-Drizzle extension. It shows the process of importing necessary modules, extending a PrismaClient instance with Drizzle, and using the extended client to perform a select operation on a User table.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client';
import { drizzle } from 'drizzle-orm/prisma/pg';
import { User } from './drizzle';

const prisma = new PrismaClient().$extends(drizzle());
const users = await prisma.$drizzle.select().from(User);

----------------------------------------

TITLE: Configuring Drizzle Connection with Casing Option in TypeScript
DESCRIPTION: Example of how to configure the Drizzle connection with the new casing option, which automatically maps column names to snake_case in the database.

LANGUAGE: typescript
CODE:
const db = await drizzle('node-postgres', { connection: '', casing: 'snake_case' })

----------------------------------------

TITLE: Generated SQL for PostgreSQL Array Types
DESCRIPTION: Shows the SQL generated by Drizzle Kit for the PostgreSQL array type definitions. It creates tables with array columns, including multi-dimensional arrays.

LANGUAGE: sql
CODE:
CREATE TABLE sal_emp (
  name            text,
  pay_by_quarter  integer[],
  schedule        text[][]
);

CREATE TABLE tictactoe (
  squares   integer[3][3]
);

----------------------------------------

TITLE: Configuring Seed Count in Drizzle ORM
DESCRIPTION: This snippet shows how to specify the number of entities to be created during seeding. It uses the count option to generate 1000 entities instead of the default 10.

LANGUAGE: typescript
CODE:
await seed(db, schema, { count: 1000 });

----------------------------------------

TITLE: Configuring API Gateway for Lambda Function in Serverless Framework
DESCRIPTION: This YAML snippet shows how to expose a Lambda function through API Gateway using the Serverless Framework. It defines the 'getUsers' function with an HTTP event and sets up CORS-related gateway responses for both 4XX and 5XX errors.

LANGUAGE: yaml
CODE:
functions:
  getUsers:
    handler: ./src/api/user.getAll
    events:
      - http:
          path: "users"
          method: GET

resources:
  Resources:
    GatewayResponse:
      Type: "AWS::ApiGateway::GatewayResponse"
      Properties:
        ResponseParameters:
          gatewayresponse.header.Access-Control-Allow-Origin: "'*'"
          gatewayresponse.header.Access-Control-Allow-Headers: "'*'"
          gatewayresponse.header.Access-Control-Allow-Methods: "'*'"
        ResponseType: DEFAULT_4XX
        RestApiId:
          Ref: "ApiGatewayRestApi"
    GatewayResponse5xx:
      Type: "AWS::ApiGateway::GatewayResponse"
      Properties:
        ResponseParameters:
          gatewayresponse.header.Access-Control-Allow-Origin: "'*'"
          gatewayresponse.header.Access-Control-Allow-Headers: "'*'"
          gatewayresponse.header.Access-Control-Allow-Methods: "'*'"
        ResponseType: DEFAULT_5XX
        RestApiId:
          Ref: "ApiGatewayRestApi"

----------------------------------------

TITLE: Initializing Drizzle ORM with Bun SQL Driver
DESCRIPTION: Demonstrates how to initialize Drizzle ORM using the new Bun SQL driver with both URL and SQL instance approaches.

LANGUAGE: typescript
CODE:
import { drizzle } from 'drizzle-orm/bun-sql';

const db = drizzle(process.env.PG_DB_URL!);

const result = await db.select().from(...);

LANGUAGE: typescript
CODE:
import { drizzle } from 'drizzle-orm/bun-sqlite';
import { SQL } from 'bun';

const client = new SQL(process.env.PG_DB_URL!);
const db = drizzle({ client });

const result = await db.select().from(...);

----------------------------------------

TITLE: Defining PostgreSQL Table with Foreign Key (Previous Syntax)
DESCRIPTION: Example showing the previous syntax for creating a PostgreSQL table with a foreign key relationship using a callback function in the foreignKey() method.

LANGUAGE: typescript
CODE:
export const usersTable = pgTable(
	'users_table',
	{
		id: serial('id').primaryKey(),
		uuid: uuid('uuid').defaultRandom().notNull(),
		homeCity: integer('home_city').notNull()
	},
	(users) => ({
		// foreignKey had a callback as param
		usersCityFK: foreignKey(() => ({ columns: [users.homeCity], foreignColumns: [cities.id] })),
	}),
);

----------------------------------------

TITLE: Initializing WASM LibSQL Client
DESCRIPTION: Experimental WASM implementation using a separate package.

LANGUAGE: typescript
CODE:
import { drizzle } from 'drizzle-orm/libsql';

const db = drizzle({ connection: {
  url: process.env.DATABASE_URL, 
  authToken: process.env.DATABASE_AUTH_TOKEN 
}});

----------------------------------------

TITLE: Performing a Left Join in SQL
DESCRIPTION: This SQL snippet shows how to perform a left join between cities and users tables, selecting specific columns from both tables.

LANGUAGE: sql
CODE:
select
  cities.id as city_id,
  cities.name as city_name,
  users.id as user_id,
  users.first_name,
  users.last_name
from cities
left join users on users.city_id = cities.id

----------------------------------------

TITLE: Defining PostgreSQL Tables with Default and Custom Schemas in TypeScript
DESCRIPTION: Demonstrates how to create table definitions in both the default public schema and a custom schema using Drizzle ORM. Shows table configuration with various column types including serial, text, boolean, jsonb, and timestamp with timezone.

LANGUAGE: typescript
CODE:
// Table in default schema
const publicUsersTable = pgTable('users', {
	id: serial('id').primaryKey(),
	name: text('name').notNull(),
	verified: boolean('verified').notNull().default(false),
	jsonb: jsonb<string[]>('jsonb'),
	createdAt: timestamp('created_at', { withTimezone: true }).notNull().defaultNow(),
});


// Table in custom schema
const mySchema = pgSchema('mySchema');

const usersTable = mySchema('users', {
	id: serial('id').primaryKey(),
	name: text('name').notNull(),
	verified: boolean('verified').notNull().default(false),
	jsonb: jsonb<string[]>('jsonb'),
	createdAt: timestamp('created_at', { withTimezone: true }).notNull().defaultNow(),
});

----------------------------------------

TITLE: Defining PostgreSQL Table with Foreign Key (New Syntax)
DESCRIPTION: Example demonstrating the new syntax for creating a PostgreSQL table with a foreign key relationship using a direct object parameter instead of a callback function.

LANGUAGE: typescript
CODE:
export const usersTable = pgTable(
	'users_table',
	{
		id: serial('id').primaryKey(),
		uuid: uuid('uuid').defaultRandom().notNull(),
		homeCity: integer('home_city').notNull()
	},
	(users) => ({
		// foreignKey doesn't have a callback as param
		usersCityFK: foreignKey({ columns: [users.homeCity], foreignColumns: [cities.id] }),
	}),
);

----------------------------------------

TITLE: Initializing WebSocket-specific LibSQL Client
DESCRIPTION: Implementation specifically for WS and WSS connection protocols.

LANGUAGE: typescript
CODE:
import { drizzle } from 'drizzle-orm/libsql/ws';

const db = drizzle({ connection: {
  url: process.env.DATABASE_URL, 
  authToken: process.env.DATABASE_AUTH_TOKEN 
}});

----------------------------------------

TITLE: Generating Default Value for SQLite Timestamp (Previous)
DESCRIPTION: Shows the previous SQL query generation for defaultNow() method, which was causing issues due to missing parentheses.

LANGUAGE: sql
CODE:
cast((julianday('now') - 2440587.5)*86400000 as integer)

----------------------------------------

TITLE: Foreign Key Definition - Previous Syntax
DESCRIPTION: Shows the deprecated method of defining foreign keys using a callback function approach.

LANGUAGE: typescript
CODE:
export const usersTable = mysqlTable('userstest', {
	id: serial('id').primaryKey(),
	homeCity: text('name').notNull(),
	createdAt: timestamp('created_at', { fsp: 2 }).notNull().defaultNow(),
}, (users) => ({
	// foreignKey has a callback as param
	usersCityFK: foreignKey(() => { columns: [users.homeCity], foreignColumns: [cities.id] }),
}));

----------------------------------------

TITLE: Converting Simple JSONB String to JSONB Type
DESCRIPTION: SQL query to convert stringified JSONB values to actual JSONB objects in PostgreSQL tables.

LANGUAGE: sql
CODE:
update table_name
set jsonb_column = (jsonb_column #>> '{}')::jsonb;

----------------------------------------

TITLE: Creating Custom Schema Enum in PostgreSQL with Drizzle ORM
DESCRIPTION: Demonstrates how to create a custom schema enum in PostgreSQL using Drizzle ORM. This feature allows for more flexible schema organization and enum definition within specific schemas.

LANGUAGE: typescript
CODE:
import { pgSchema } from 'drizzle-orm/pg-core';

const mySchema = pgSchema('mySchema');
const colors = mySchema.enum('colors', ['red', 'green', 'blue']);

----------------------------------------

TITLE: Defining and Seeding Cyclic Tables in PostgreSQL with TypeScript
DESCRIPTION: Illustrates how to define and seed tables with cyclic relations in PostgreSQL using Drizzle ORM. The example includes 'model' and 'model_image' tables with a circular foreign key relationship.

LANGUAGE: typescript
CODE:
import type { AnyPgColumn } from "drizzle-orm/pg-core";
import {
  foreignKey,
  integer,
  pgTable,
  serial,
  varchar,
} from "drizzle-orm/pg-core";

export const modelTable = pgTable(
  "model",
  {
    id: serial().primaryKey(),
    name: varchar().notNull(),
    defaultImageId: integer(),
  },
  (t) => [
    foreignKey({
      columns: [t.defaultImageId],
      foreignColumns: [modelImageTable.id],
    }),
  ]
);

export const modelImageTable = pgTable("model_image", {
  id: serial().primaryKey(),
  url: varchar().notNull(),
  caption: varchar(),
  modelId: integer()
    .notNull()
    .references((): AnyPgColumn => modelTable.id),
});

async function main() {
  const db = drizzle(process.env.DATABASE_URL!);
  await seed(db, { modelTable, modelImageTable });
}

main();

----------------------------------------

TITLE: Implementing PostgreSQL Identity Columns in TypeScript
DESCRIPTION: Demonstrates how to use identity columns, the recommended way to specify sequences in PostgreSQL schemas, using the generatedAlwaysAsIdentity() function.

LANGUAGE: typescript
CODE:
import { pgTable, integer, text } from 'drizzle-orm/pg-core' 

export const ingredients = pgTable("ingredients", {
  id: integer("id").primaryKey().generatedAlwaysAsIdentity({ startWith: 1000 }),
  name: text("name").notNull(),
  description: text("description"),
});

----------------------------------------

TITLE: Defining PostgreSQL Sequences in TypeScript
DESCRIPTION: Demonstrates how to create PostgreSQL sequences with various parameters and in custom schemas using Drizzle ORM.

LANGUAGE: typescript
CODE:
import { pgSchema, pgSequence } from "drizzle-orm/pg-core";

// No params specified
export const customSequence = pgSequence("name");

// Sequence with params
export const customSequence = pgSequence("name", {
      startWith: 100,
      maxValue: 10000,
      minValue: 100,
      cycle: true,
      cache: 10,
      increment: 2
});

// Sequence in custom schema
export const customSchema = pgSchema('custom_schema');

export const customSequence = customSchema.sequence("name");

----------------------------------------

TITLE: Implementing Placeholders for Limit and Offset in Drizzle ORM Queries
DESCRIPTION: This code snippet showcases how to use placeholders in the .limit() and .offset() methods of a Drizzle ORM query. It prepares a statement with placeholders and then executes it with specific values, enabling dynamic query parameter assignment.

LANGUAGE: typescript
CODE:
const stmt = db
  .select({
    id: usersTable.id,
    name: usersTable.name,
  })
  .from(usersTable)
  .limit(placeholder('limit'))
  .offset(placeholder('offset'))
  .prepare('stmt');

const result = await stmt.execute({ limit: 1, offset: 1 });

----------------------------------------

TITLE: Configuring Drizzle Kit Migrations in TypeScript
DESCRIPTION: Shows how to customize migration file prefixes using the new migrations flag 'prefix' in the Drizzle Kit configuration file.

LANGUAGE: typescript
CODE:
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  dialect: "postgresql",
  migrations: {
    prefix: 'supabase'
  }
});

----------------------------------------

TITLE: Querying Turso database using CLI
DESCRIPTION: Demonstrates how to use the Turso CLI to query the remote database and verify data.

LANGUAGE: bash
CODE:
turso db shell drizzle-example "select * from users"

----------------------------------------

TITLE: Inserting Rows with Default Values in TypeScript
DESCRIPTION: Examples of how to insert rows with default values for all columns using the new feature in Drizzle ORM 0.28.0, allowing for empty object insertions.

LANGUAGE: typescript
CODE:
// Insert 1 row with all defaults
await db.insert(usersTable).values({});

// Insert 2 rows with all defaults
await db.insert(usersTable).values([{}, {}]);

----------------------------------------

TITLE: Foreign Key Definition - New Syntax
DESCRIPTION: Demonstrates the new method of defining foreign keys using a direct object parameter instead of a callback function.

LANGUAGE: typescript
CODE:
export const usersTable = mysqlTable('userstest', {
	id: serial('id').primaryKey(),
	homeCity: text('name').notNull(),
	createdAt: timestamp('created_at', { fsp: 2 }).notNull().defaultNow(),
}, (users) => ({
	// foreignKey has a callback as param
	usersCityFK: foreignKey({ columns: [users.homeCity], foreignColumns: [cities.id] }),
}));

----------------------------------------

TITLE: Initializing PGlite with Drizzle ORM in TypeScript
DESCRIPTION: Demonstrates how to set up an in-memory Postgres database using PGlite and initialize it with Drizzle ORM. The example shows basic configuration and a simple query execution.

LANGUAGE: typescript
CODE:
import { PGlite } from '@electric-sql/pglite';
import { drizzle } from 'drizzle-orm/pglite';

// In-memory Postgres
const client = new PGlite();
const db = drizzle(client);

await db.select().from(users);

----------------------------------------

TITLE: Creating Update Schema for Database Tables in TypeScript
DESCRIPTION: Shows the usage of the new createUpdateSchema function for creating schemas to be used in update queries. It demonstrates how the schema handles generated columns and optional updates.

LANGUAGE: typescript
CODE:
import { pgTable, text, integer } from 'drizzle-orm/pg-core';
import { createUpdateSchema } from 'drizzle-zod';

const users = pgTable('users', {
  id: integer().generatedAlwaysAsIdentity().primaryKey(),
  name: text().notNull(),
  age: integer().notNull()
});

const userUpdateSchema = createUpdateSchema(users);

const user = { id: 5, name: 'John' };
const parsed: { name?: string | undefined, age?: number | undefined } = userUpdateSchema.parse(user); // Error: `id` is a generated column, it can't be updated

const user = { age: 35 };
const parsed: { name?: string | undefined, age?: number | undefined } = userUpdateSchema.parse(user); // Will parse successfully
await db.update(users).set(parsed).where(eq(users.name, 'Jane'));

----------------------------------------

TITLE: Using getViewName Utility Function
DESCRIPTION: Demonstrates how to use the getViewName utility function to retrieve view names in Drizzle ORM.

LANGUAGE: typescript
CODE:
import { getViewName } from 'drizzle-orm/sql'

export const user = pgTable("user", {
  id: serial(),
  name: text(),
  email: text(),
});

export const userView = pgView("user_view").as((qb) => qb.select().from(user));

const viewName = getViewName(userView)

----------------------------------------

TITLE: Installing Drizzle ORM and Xata Client with pnpm
DESCRIPTION: Command to install the required dependencies for using Drizzle ORM with Xata.

LANGUAGE: bash
CODE:
pnpm add drizzle-orm @xata.io/client

----------------------------------------

TITLE: Defining Drizzle Schema in TypeScript
DESCRIPTION: Example of defining a users table schema using Drizzle's TypeScript API with pgTable. Demonstrates table creation with serial, text columns and primary key constraints.

LANGUAGE: typescript
CODE:
import { pgTable, serial, text } from 'drizzle-orm/pg-core'

export const users = pgTable('users', {
	id: serial('id').primaryKey(),
	email: text('email').notNull(),
	name: text('name')
});

----------------------------------------

TITLE: Initializing Neon HTTP Driver with Drizzle ORM in TypeScript
DESCRIPTION: This snippet demonstrates how to import and configure the Neon HTTP driver for use with Drizzle ORM. It sets up connection caching, initializes the SQL client, and creates a Drizzle database instance.

LANGUAGE: typescript
CODE:
import { neon, neonConfig } from '@neondatabase/serverless';
import { drizzle } from 'drizzle-orm/neon-http';

neonConfig.fetchConnectionCache = true;

const sql = neon(process.env.DRIZZLE_DATABASE_URL!);
const db = drizzle(sql);

db.select(...)

----------------------------------------

TITLE: Executing Batch Operations with LibSQL in TypeScript
DESCRIPTION: Demonstrates how to use the new LibSQL batch API support in Drizzle ORM. It shows executing multiple database operations in a single batch, including insert, update, and select queries.

LANGUAGE: typescript
CODE:
const batchResponse = await db.batch([
	db.insert(usersTable).values({ id: 1, name: 'John' }).returning({
		id: usersTable.id,
	}),
	db.update(usersTable).set({ name: 'Dan' }).where(eq(usersTable.id, 1)),
	db.query.usersTable.findMany({}),
	db.select().from(usersTable).where(eq(usersTable.id, 1)),
	db.select({ id: usersTable.id, invitedBy: usersTable.invitedBy }).from(
		usersTable,
	),
]);

----------------------------------------

TITLE: SQLite Proxy Driver Run Method
DESCRIPTION: Reference to the .run() method in the SQLite proxy driver that received bug fixes

LANGUAGE: typescript
CODE:
.run()

----------------------------------------

TITLE: Using Supabase Predefined Roles in Drizzle ORM
DESCRIPTION: This example shows how to use Supabase's predefined roles in Drizzle ORM. It demonstrates creating a policy for the 'serviceRole' on a 'users' table.

LANGUAGE: typescript
CODE:
import { sql } from 'drizzle-orm';
import { serviceRole } from 'drizzle-orm/supabase';
import { integer, pgPolicy, pgRole, pgTable } from 'drizzle-orm/pg-core';

export const admin = pgRole('admin');

export const users = pgTable('users', {
	id: integer(),
}, (t) => [
	pgPolicy(`policy-insert`, {
		for: 'insert',
		to: serviceRole,
		withCheck: sql`false`,
	}),
]);

----------------------------------------

TITLE: Updating Neon Auth Schema Reference
DESCRIPTION: Schema name change from 'neon_identity' to 'neon_auth' to align with Neon's latest authentication feature requirements.

LANGUAGE: sql
CODE:
neon_auth

----------------------------------------

TITLE: Installing Expo SQLite Dependencies
DESCRIPTION: Command to install required packages for using Expo SQLite with Drizzle ORM

LANGUAGE: bash
CODE:
npm install drizzle-orm expo-sqlite@next

----------------------------------------

TITLE: Using Neon's CRUD Policy in Drizzle ORM
DESCRIPTION: This snippet demonstrates how to use Neon's crudPolicy function in Drizzle ORM. It shows a simplified way to create CRUD policies for a specific role on a table.

LANGUAGE: typescript
CODE:
import { crudPolicy } from 'drizzle-orm/neon';
import { integer, pgRole, pgTable } from 'drizzle-orm/pg-core';

export const admin = pgRole('admin');

export const users = pgTable('users', {
	id: integer(),
}, (t) => [
	crudPolicy({ role: admin, read: true, modify: false }),
]);

----------------------------------------

TITLE: Defining Drizzle Config File in TypeScript
DESCRIPTION: Shows how to create a Drizzle configuration file using TypeScript, specifying schema, connection string, output directory, and other options.

LANGUAGE: typescript
CODE:
import { Config } from "drizzle-kit";

export default {
  schema: "",
  connectionString: process.env.DB_URL,
  out: "",
  breakpoints: true
} satisfies Config;

----------------------------------------

TITLE: Defining PostgreSQL Roles in Drizzle
DESCRIPTION: Demonstrates creation of PostgreSQL roles with various permissions using Drizzle ORM.

LANGUAGE: typescript
CODE:
import { pgRole } from 'drizzle-orm/pg-core';

export const admin = pgRole('admin', { createRole: true, createDb: true, inherit: true });

----------------------------------------

TITLE: Updating Babel Configuration for SQLite Migrations
DESCRIPTION: Diff showing required changes to babel.config.js for supporting SQL file imports

LANGUAGE: diff
CODE:
module.exports = function(api) {
  api.cache(true);

  return {
    presets: ['babel-preset-expo'],
+   plugins: [["inline-import", { "extensions": [".sql"] }]]
  };
};

----------------------------------------

TITLE: Configuring MySQL2 Driver Mode in TypeScript
DESCRIPTION: Example of how to configure the MySQL2 driver with the new 'mode' option, which is necessary for compatibility with different MySQL implementations like PlanetScale.

LANGUAGE: typescript
CODE:
import { drizzle } from 'drizzle-orm/mysql2';
import mysql from 'mysql2/promise';
import * as schema from './schema';

const connection = await mysql.createConnection({
  uri: process.env.PLANETSCALE_DATABASE_URL,
});

const db = drizzle(connection, { schema, mode: 'planetscale' });

----------------------------------------

TITLE: Documenting Version Update for Drizzle ORM SQLite Package in Markdown
DESCRIPTION: This markdown snippet documents the version update of the drizzle-orm-sqlite package to 0.16.0. It also mentions that all related packages have been bumped to this version.

LANGUAGE: markdown
CODE:
# drizzle-orm-sqlite 0.16.0

- Bump all packages to 0.16.0

----------------------------------------

TITLE: Updating Metro Configuration for SQLite
DESCRIPTION: Diff showing required changes to metro.config.js for supporting SQL file extensions

LANGUAGE: diff
CODE:
const { getDefaultConfig } = require('expo/metro-config');

/** @type {import('expo/metro-config').MetroConfig} */
const config = getDefaultConfig(__dirname);

+config.resolver.sourceExts.push('sql');

module.exports = config;

----------------------------------------

TITLE: Removed Nested Relation Filtering in TypeScript
DESCRIPTION: Example of a query that will no longer work in Drizzle ORM 0.28.0 due to the removal of nested relation filtering in the 'where' callback.

LANGUAGE: typescript
CODE:
const usersWithPosts = await db.query.users.findMany({
  where: (table, { sql }) => (sql`json_array_length(${table.posts}) > 0`),
  with: {
    posts: true,
  },
});

----------------------------------------

TITLE: Converting Complex JSONB Strings with Type Checking
DESCRIPTION: SQL query to convert stringified JSONB values to JSONB objects while handling both objects/arrays and primitive values.

LANGUAGE: sql
CODE:
UPDATE table_name
SET jsonb_column = CASE
    -- Convert to JSONB if it is a valid JSON object or array
    WHEN jsonb_column #>> '{}' LIKE '{%' OR jsonb_column #>> '{}' LIKE '[%' THEN
        (jsonb_column #>> '{}')::jsonb
    ELSE
        jsonb_column
END
WHERE
    jsonb_column IS NOT NULL;

----------------------------------------

TITLE: Querying Users with Conditional Cursor in TypeScript using Drizzle ORM
DESCRIPTION: This snippet demonstrates how to use the new .if() function in Drizzle ORM to conditionally apply a WHERE clause based on the presence of a cursor value. It selects all users with an ID greater than the provided cursor, if a cursor is specified.

LANGUAGE: typescript
CODE:
function getUsersAfter(cursor?: number) {
    return db.select().from(users).where(
        gt(users.id, cursor).if(cursor)
    );
}

----------------------------------------

TITLE: Implementing Migrations in Expo React Native App
DESCRIPTION: Example showing how to implement database migrations in an Expo React Native application using Drizzle

LANGUAGE: tsx
CODE:
import { drizzle } from "drizzle-orm/expo-sqlite";
import { openDatabaseSync } from "expo-sqlite/next";
import { useMigrations } from 'drizzle-orm/expo-sqlite/migrator';
import migrations from './drizzle/migrations';

const expoDb = openDatabaseSync("db.db");

const db = drizzle(expoDb);

export default function App() {
    const { success, error } = useMigrations(db, migrations);

    if (error) {
        return (
            <View>
                <Text>Migration error: {error.message}</Text>
            </View>
        );
    }

    if (!success) {
        return (
            <View>
                <Text>Migration is in progress...</Text>
            </View>
        );
    }

    return ...your application component;
}

----------------------------------------

TITLE: Updating SQLite Import Paths in JavaScript
DESCRIPTION: Examples of how to update import statements for SQLite-related modules in Drizzle ORM after the package consolidation.

LANGUAGE: javascript
CODE:
import { ... } from 'drizzle-orm/sqlite-core'

LANGUAGE: javascript
CODE:
import { ... } from 'drizzle-orm/better-sqlite3'

LANGUAGE: javascript
CODE:
import { ... } from 'drizzle-orm/d1'

LANGUAGE: javascript
CODE:
import { ... } from 'drizzle-orm/bun-sqlite'

LANGUAGE: javascript
CODE:
import { ... } from 'drizzle-orm/sql.js'

----------------------------------------

TITLE: Linking Policy to Existing Table in Drizzle ORM
DESCRIPTION: This example shows how to link a policy to an existing table in the database using Drizzle ORM. It's useful for database providers like Neon or Supabase where you need to add policies to their existing tables.

LANGUAGE: typescript
CODE:
import { sql } from "drizzle-orm";
import { pgPolicy } from "drizzle-orm/pg-core";
import { authenticatedRole, realtimeMessages } from "drizzle-orm/supabase";

export const policy = pgPolicy("authenticated role insert policy", {
  for: "insert",
  to: authenticatedRole,
  using: sql``,
}).link(realtimeMessages);

----------------------------------------

TITLE: Accessing Type Maps in TypeScript with Drizzle ORM
DESCRIPTION: Demonstrates how to access type information from table definitions using the new _ property for type mapping.

LANGUAGE: typescript
CODE:
const users = mysqlTable('users', {
  id: int('id').primaryKey(),
  name: text('name').notNull(),
});

type UserFields = typeof users['_']['columns'];
type InsertUser = typeof users['_']['model']['insert'];

----------------------------------------

TITLE: Defining MySQL Unsigned Bigint in Drizzle ORM
DESCRIPTION: Demonstrates how to specify a 'bigint unsigned' type in a MySQL table definition using Drizzle ORM.

LANGUAGE: typescript
CODE:
const table = mysqlTable('table', {
  id: bigint('id', { mode: 'number', unsigned: true }),
});

----------------------------------------

TITLE: Defining PostgreSQL Array Types in Drizzle ORM
DESCRIPTION: Demonstrates how to define tables with array types in PostgreSQL using Drizzle ORM. It shows examples of single-dimensional and multi-dimensional arrays.

LANGUAGE: typescript
CODE:
export const salEmp = pgTable('sal_emp', {
  name: text('name').notNull(),
  payByQuarter: integer('pay_by_quarter').array(),
  schedule: text('schedule').array().array(),
});

export const tictactoe = pgTable('tictactoe', {
  squares: integer('squares').array(3).array(3),
});

----------------------------------------

TITLE: Accessing Type Maps in TypeScript with Drizzle ORM
DESCRIPTION: Demonstrates how to access type information from table definitions using the new _ property for type mapping.

LANGUAGE: typescript
CODE:
const users = mysqlTable('users', {
  id: int('id').primaryKey(),
  name: text('name').notNull(),
});

type UserFields = typeof users['_']['columns'];
type InsertUser = typeof users['_']['model']['insert'];

----------------------------------------

TITLE: Initializing Drizzle ORM with Xata HTTP Client in TypeScript
DESCRIPTION: Example of how to initialize Drizzle ORM using the Xata HTTP client. It demonstrates importing the necessary modules, creating a Xata client instance, and initializing the Drizzle database object.

LANGUAGE: typescript
CODE:
import { drizzle } from 'drizzle-orm/xata-http';
import { getXataClient } from './xata'; // Generated client

const xata = getXataClient();
const db = drizzle(xata);

const result = await db.select().from(...);

----------------------------------------

TITLE: Implementing MySQL Proxy Driver in Drizzle ORM
DESCRIPTION: Demonstrates how to create a custom HTTP driver for MySQL database using the new MySQL Proxy Driver in Drizzle ORM.

LANGUAGE: typescript
CODE:
import axios from 'axios';
import { eq } from 'drizzle-orm/expressions';
import { drizzle } from 'drizzle-orm/mysql-proxy';
import { migrate } from 'drizzle-orm/mysql-proxy/migrator';
import { cities, users } from './schema';

async function main() {
  const db = drizzle(async (sql, params, method) => {
    try {
      const rows = await axios.post(`${process.env.REMOTE_DRIVER}/query`, {
        sql,
        params,
        method,
      });

      return { rows: rows.data };
    } catch (e: any) {
      console.error('Error from pg proxy server:', e.response.data);
      return { rows: [] };
    }
  });

  await migrate(db, async (queries) => {
    try {
      await axios.post(`${process.env.REMOTE_DRIVER}/migrate`, { queries });
    } catch (e) {
      console.log(e);
      throw new Error('Proxy server cannot run migrations');
    }
  }, { migrationsFolder: 'drizzle' });

  await db.insert(cities).values({ id: 1, name: 'name' });

  await db.insert(users).values({
    id: 1,
    name: 'name',
    email: 'email',
    cityId: 1,
  });

  const usersToCityResponse = await db.select().from(users).leftJoin(
    cities,
    eq(users.cityId, cities.id),
  );
}

----------------------------------------

TITLE: CustomTypeParams Interface Definition
DESCRIPTION: Defines the CustomTypeParams interface used for specifying custom type parameters in Drizzle ORM.

LANGUAGE: typescript
CODE:
export interface CustomTypeParams<T extends Partial<CustomTypeValues>> {
  dataType: (config: T['config'] | (Equal<T['configRequired'], true> extends true ? never : undefined)) => string;
  toDriver?: (value: T['data']) => T['driverData'] | SQL;
  fromDriver?: (value: T['driverData']) => T['data'];
}

----------------------------------------

TITLE: Custom Vector Operation Implementation in TypeScript
DESCRIPTION: Example of implementing custom vector operations using SQL templates.

LANGUAGE: typescript
CODE:
export function l2Distance(
  column: SQLWrapper | AnyColumn,
  value: number[] | string[] | TypedQueryBuilder<any> | string,
): SQL {
  if (is(value, TypedQueryBuilder<any>) || typeof value === 'string') {
    return sql`${column} <-> ${value}`;
  }
  return sql`${column} <-> ${JSON.stringify(value)}`;
}

----------------------------------------

TITLE: Using D1 Batch API in Drizzle ORM
DESCRIPTION: Demonstrates how to use the D1 Batch API support in Drizzle ORM for executing multiple database operations in a single batch.

LANGUAGE: typescript
CODE:
const batchResponse = await db.batch([
  db.insert(usersTable).values({ id: 1, name: 'John' }).returning({
    id: usersTable.id,
  }),
  db.update(usersTable).set({ name: 'Dan' }).where(eq(usersTable.id, 1)),
  db.query.usersTable.findMany({}),
  db.select().from(usersTable).where(eq(usersTable.id, 1)),
  db.select({ id: usersTable.id, invitedBy: usersTable.invitedBy }).from(
    usersTable,
  ),
]);

----------------------------------------

TITLE: Defining Custom Boolean Type in MySQL
DESCRIPTION: Creates a custom Boolean type for MySQL using the customType function from Drizzle ORM. Includes a fromDriver method to handle conversion from numeric values.

LANGUAGE: typescript
CODE:
const customBoolean = customType<{ data: boolean }>({
  dataType() {
    return 'boolean';
  },
  fromDriver(value) {
    if (typeof value === 'boolean') {
      return value;
    }
    return value === 1;
  },
});

----------------------------------------

TITLE: Initializing SQLite3-specific LibSQL Client
DESCRIPTION: Implementation for memory and file connection protocols using SQLite3.

LANGUAGE: typescript
CODE:
import { drizzle } from 'drizzle-orm/libsql/wasm';

const db = drizzle({ connection: {
  url: process.env.DATABASE_URL, 
  authToken: process.env.DATABASE_AUTH_TOKEN 
}});

----------------------------------------

TITLE: Updating drizzle-orm-mysql to version 0.16.2
DESCRIPTION: This update fixes a peer dependency error for drizzle packages version 0.16 and above. It ensures compatibility with the latest drizzle ecosystem.

LANGUAGE: markdown
CODE:
# drizzle-orm-mysql 0.16.2

- Fix peer dependency error for >=0.16 drizzle packages

----------------------------------------

TITLE: Defining BatchResponse Type for LibSQL Batch Operations in TypeScript
DESCRIPTION: Shows the type definition for the response of a LibSQL batch operation. It includes the expected return types for various queries executed in the batch.

LANGUAGE: typescript
CODE:
type BatchResponse = [
	{
		id: number;
	}[],
	ResultSet,
	{
		id: number;
		name: string;
		verified: number;
		invitedBy: number | null;
	}[],
	{
		id: number;
		name: string;
		verified: number;
		invitedBy: number | null;
	}[],
	{
		id: number;
		invitedBy: number | null;
	}[],
];

----------------------------------------

TITLE: Making HTTP requests to add and fetch users
DESCRIPTION: Demonstrates how to use curl to add a new user and fetch all users from the local server.

LANGUAGE: bash
CODE:
curl --request POST \
  --url http://localhost:3000/users \
  --header 'Content-Type: application/json' \
  --data '{
  "name": "John Doe",
  "email": "john@test.com"
}'

LANGUAGE: bash
CODE:
curl --url http://localhost:3000/users

----------------------------------------

TITLE: Connecting to Planetscale Serverless Database with Drizzle ORM in TypeScript
DESCRIPTION: This code snippet shows how to create a connection to a Planetscale Serverless database using Drizzle ORM. It imports necessary modules, sets up the connection using environment variables, and initializes the Drizzle instance.

LANGUAGE: typescript
CODE:
import { drizzle } from 'drizzle-orm/planetscale-serverless';
import { connect } from '@planetscale/database';

// create the connection
const connection = connect({
  host: process.env['DATABASE_HOST'],
  username: process.env['DATABASE_USERNAME'],
  password: process.env['DATABASE_PASSWORD'],
});

const db = drizzle(connection);

----------------------------------------

TITLE: Using JSON Mode for SQLite Text Column in TypeScript
DESCRIPTION: Demonstrates how to define a SQLite table with a text column in JSON mode, including type annotation for the JSON structure.

LANGUAGE: typescript
CODE:
const test = sqliteTable('test', {
	dataTyped: text('data_typed', { mode: 'json' }).$type<{ a: 1 }>().notNull(),
});

----------------------------------------

TITLE: Generating SQL with Breakpoints in Drizzle Kit
DESCRIPTION: Shows how to use the new '--breakpoints' option in Drizzle Kit to generate SQL with statement breakpoints. This is useful for drivers that don't support running multiple queries in one execution.

LANGUAGE: sql
CODE:
CREATE TABLE `users` (
  `id` int PRIMARY KEY NOT NULL,
  `full_name` text NOT NULL,
);
--> statement-breakpoint
CREATE TABLE `table` (
  `id` int PRIMARY KEY NOT NULL,
  `phone` int,
);

----------------------------------------

TITLE: Using Custom Types in PostgreSQL Table Definition
DESCRIPTION: Demonstrates how to use the custom types defined earlier in a PostgreSQL table definition using Drizzle ORM.

LANGUAGE: typescript
CODE:
const usersTable = pgTable('users', {
  id: customSerial('id').primaryKey(),
  name: customText('name').notNull(),
  verified: customBoolean('verified').notNull().default(false),
  jsonb: customJsonb<string[]>('jsonb'),
  createdAt: customTimestamp('created_at', { withTimezone: true }).notNull()
    .default(sql`now()`),
});

----------------------------------------

TITLE: Creating Select Schema for Enums and Views in TypeScript
DESCRIPTION: Demonstrates how to create select schemas for PostgreSQL enums and views using the createSelectSchema function. Shows type inference and parsing for both enum and view schemas.

LANGUAGE: typescript
CODE:
import { pgEnum } from 'drizzle-orm/pg-core';
import { createSelectSchema } from 'drizzle-typebox';
import { Value } from '@sinclair/typebox/value';

const roles = pgEnum('roles', ['admin', 'basic']);
const rolesSchema = createSelectSchema(roles);
const parsed: 'admin' | 'basic' = Value.Parse(rolesSchema, ...);

const usersView = pgView('users_view').as((qb) => qb.select().from(users).where(gt(users.age, 18)));
const usersViewSchema = createSelectSchema(usersView);
const parsed: { id: number; name: string; age: number } = Value.Parse(usersViewSchema, ...);

----------------------------------------

TITLE: Distinct Query Support in Drizzle
DESCRIPTION: Shows how to use the distinct clause in Drizzle ORM queries for filtering unique records.

LANGUAGE: typescript
CODE:
await db.selectDistinct().from(usersDistinctTable).orderBy(
  usersDistinctTable.id,
  usersDistinctTable.name,
);

----------------------------------------

TITLE: Nested Object Selection in Drizzle ORM (TypeScript)
DESCRIPTION: This snippet shows how to group fields from a joined table into a nested object in the select statement, improving type safety and null checking.

LANGUAGE: typescript
CODE:
const rows = await db
  .select({
    cityId: cities.id,
    cityName: cities.name,
    user: {
      id: users.id,
      firstName: users.firstName,
      lastName: users.lastName,
    },
  })
  .from(cities)
  .leftJoin(users, eq(users.cityId, cities.id));

----------------------------------------

TITLE: Creating Update Schema for Database Tables
DESCRIPTION: Shows usage of createUpdateSchema function for generating validation schemas for update operations. Includes handling of generated columns and partial updates.

LANGUAGE: typescript
CODE:
import { pgTable, text, integer } from 'drizzle-orm/pg-core';
import { createUpdateSchema } from 'drizzle-typebox';
import { Value } from '@sinclair/typebox/value';

const users = pgTable('users', {
  id: integer().generatedAlwaysAsIdentity().primaryKey(),
  name: text().notNull(),
  age: integer().notNull()
});

const userUpdateSchema = createUpdateSchema(users);

const user = { id: 5, name: 'John' };
const parsed: { name?: string | undefined, age?: number | undefined } = Value.Parse(userUpdateSchema, user);

const user = { age: 35 };
const parsed: { name?: string | undefined, age?: number | undefined } = Value.Parse(userUpdateSchema, user);
await db.update(users).set(parsed).where(eq(users.name, 'Jane'));

----------------------------------------

TITLE: Defining Drizzle Config File in JavaScript
DESCRIPTION: Demonstrates how to create a Drizzle configuration file using JavaScript, including type annotations for better IDE support.

LANGUAGE: javascript
CODE:
/** @type { import("drizzle-kit").Config } */
export default {
    schema: "",
  connectionString: "",
  out: "",
  breakpoints: true
};

----------------------------------------

TITLE: Demonstrating enforce-delete-with-where Rule Usage
DESCRIPTION: TypeScript code examples showing how the 'enforce-delete-with-where' rule behaves with different configurations.

LANGUAGE: typescript
CODE:
class MyClass {
  public delete() {
    return {}
  }
}

const myClassObj = new MyClass();

// ---> Will be triggered by ESLint Rule
myClassObj.delete()

const db = drizzle(...)
// ---> Will be triggered by ESLint Rule
db.delete()

LANGUAGE: typescript
CODE:
class MyClass {
  public delete() {
    return {}
  }
}

const myClassObj = new MyClass();

// ---> Will NOT be triggered by ESLint Rule
myClassObj.delete()

const db = drizzle(...)
// ---> Will be triggered by ESLint Rule
db.delete()

----------------------------------------

TITLE: Configuring Drizzle for SQLite Durable Objects Driver in TypeScript
DESCRIPTION: This snippet shows the configuration for using the SQLite Durable Objects driver with Drizzle. It imports the required modules and uses defineConfig to set up the dialect as SQLite and the driver as durable-sqlite.

LANGUAGE: typescript
CODE:
import 'dotenv/config';
import { defineConfig } from 'drizzle-kit';
export default defineConfig({
  out: './drizzle',
  schema: './src/db/schema.ts',
  dialect: 'sqlite',
  driver: 'durable-sqlite',
});

----------------------------------------

TITLE: Adding PostgreSQL Network Data Types
DESCRIPTION: Implementation of PostgreSQL network-related data types. Includes support for inet (IP addresses), cidr (IP network blocks), macaddr (MAC addresses), and macaddr8 (EUI-64 MAC addresses).

LANGUAGE: postgresql
CODE:
inet
cidr
macaddr
macaddr8

----------------------------------------

TITLE: Configuring Drizzle Kit Push for MySQL in TypeScript
DESCRIPTION: Shows how to set up the configuration file for the new 'drizzle-kit push:mysql' command, specifying the schema and connection string.

LANGUAGE: typescript
CODE:
import { Config } from "src";

export default {
  schema: "./schema.ts",
  connectionString: process.env.DB_URL,
} satisfies Config;

----------------------------------------

TITLE: Getting Table Columns Map in Drizzle ORM with TypeScript
DESCRIPTION: Shows how to use getTableColumns to retrieve a typed map of column definitions from a PostgreSQL table, including example of defining a table with primary key and text columns.

LANGUAGE: typescript
CODE:
import { pgTable, getTableColumns } from 'drizzle-orm/pg-core';

const table = pgTable('table', {
  id: integer('id').primaryKey(),
  name: text('name'),
});

const columns/*: { id: ..., name: ... } */ = getTableColumns(table);

----------------------------------------

TITLE: Initializing Node-specific LibSQL Client
DESCRIPTION: Node.js specific implementation supporting memory, file, WSS, HTTP, and Turso connection protocols.

LANGUAGE: typescript
CODE:
import { drizzle } from 'drizzle-orm/libsql/node';

const db = drizzle({ connection: {
  url: process.env.DATABASE_URL, 
  authToken: process.env.DATABASE_AUTH_TOKEN 
}});

----------------------------------------

TITLE: Initializing Drizzle ORM with Vercel Postgres
DESCRIPTION: Shows how to set up a database connection using Drizzle ORM with Vercel Postgres. The code imports necessary dependencies and creates a database instance that can be used for queries.

LANGUAGE: typescript
CODE:
import { drizzle } from 'drizzle-orm/vercel-postgres';
import { sql } from "@vercel/postgres";

const db = drizzle(sql);

db.select(...)

----------------------------------------

TITLE: Retrieving Table Configuration in Drizzle ORM with TypeScript
DESCRIPTION: Demonstrates how to use getTableConfig to extract detailed table configuration including columns, indexes, foreign keys, checks, primary keys, name, and schema information from a PostgreSQL table definition.

LANGUAGE: typescript
CODE:
import { pgTable, getTableConfig } from 'drizzle-orm/pg-core';

const table = pgTable(...);

const {
  columns,
  indexes,
  foreignKeys,
  checks,
  primaryKeys,
  name,
  schema,
} = getTableConfig(table);

----------------------------------------

TITLE: Defining Drizzle Schema and Using Knex Query Builder in TypeScript
DESCRIPTION: This snippet demonstrates how to define a database schema using Drizzle ORM and use Knex.js as a query builder. It includes importing necessary modules, defining a table schema, extending Knex types, and executing a simple query. This approach combines Drizzle's schema definition capabilities with Knex's query building functionality.

LANGUAGE: typescript
CODE:
import Knex from 'knex';
import { pgTable, serial, text } from 'drizzle-orm/pg-core';
// This line is important - it allows you to use the Knexify type
import 'drizzle-orm/knex';

const test = pgTable('test', {
  id: serial('id').primaryKey(),
  name: text('name').notNull(),
});

declare module 'knex/types/tables' {
  interface Tables {
    test: Knexify<typeof test>;
  }
}

const db = Knex({});

const result/*: { id: number, name: string }[] */ = db('test').select();

----------------------------------------

TITLE: Raw Query Execution in Neon HTTP Driver
DESCRIPTION: Demonstrates the new raw query execution capability via db.execute() in the Neon HTTP driver's batch API

LANGUAGE: typescript
CODE:
db.execute(...)

----------------------------------------

TITLE: Updating Package Exports Configuration - JSON
DESCRIPTION: Configuration changes to package.json to include 'types' and 'default' fields in the exports entries for better module resolution and TypeScript support.

LANGUAGE: json
CODE:
{
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "default": "./dist/index.js"
    }
  }
}

----------------------------------------

TITLE: Defining Custom Serial Type in MySQL
DESCRIPTION: Creates a custom Serial type for MySQL using the customType function from Drizzle ORM.

LANGUAGE: typescript
CODE:
const customSerial = customType<{ data: number; notNull: true; default: true }>(
  {
    dataType() {
      return 'serial';
    },
  },
);

----------------------------------------

TITLE: Enabling RLS on PostgreSQL Table in Drizzle
DESCRIPTION: Shows how to enable Row-Level Security on a PostgreSQL table using Drizzle ORM's enableRLS() method.

LANGUAGE: typescript
CODE:
import { integer, pgTable } from 'drizzle-orm/pg-core';

export const users = pgTable('users', {
	id: integer(),
}).enableRLS();

----------------------------------------

TITLE: Defining Composite Primary Keys in MySQL with Drizzle ORM
DESCRIPTION: Shows how to define a table with a composite primary key in MySQL using Drizzle ORM. It uses the primaryKey function to create a composite key from multiple columns.

LANGUAGE: typescript
CODE:
import { primaryKey } from 'drizzle-orm/mysql-core';

export const cpkTable = mysqlTable('table', {
  simple: int('simple'),
  columnNotNull: int('column_not_null').notNull(),
  columnDefault: int('column_default').default(100),
}, (table) => ({
  cpk: primaryKey(table.simple, table.columnDefault),
}));

----------------------------------------

TITLE: Defining Custom Boolean Type in PostgreSQL
DESCRIPTION: Creates a custom Boolean type for PostgreSQL using the customType function from Drizzle ORM.

LANGUAGE: typescript
CODE:
const customBoolean = customType<{ data: boolean }>({
  dataType() {
    return 'boolean';
  },
});

----------------------------------------

TITLE: Configuring VPC for AWS Lambda Function in Serverless Framework
DESCRIPTION: This YAML snippet demonstrates how to configure a Lambda function to be in the same VPC as an Aurora RDS Instance using the Serverless Framework. It defines custom VPC settings and applies them to a 'getUsers' function.

LANGUAGE: yaml
CODE:
custom:
  vpc_config: &vpc_config
    vpc:
      securityGroupIds:
        - sg-samplegroupId
      subnetIds:
        - subnet-sample1
        - subnet-sample2
        - subnet-sample3

functions:
  getUsers:
    handler: ./src/api/user.getAll
    <<: *vpc_config

----------------------------------------

TITLE: Implementing Database Seeding with Drizzle Relations in TypeScript
DESCRIPTION: Shows how to use the seed function with Drizzle Relations objects to populate the database while respecting foreign key constraints.

LANGUAGE: typescript
CODE:
// index.ts
import { seed } from "drizzle-seed";
import * as schema from './schema.ts'

async function main() {
  const db = drizzle(process.env.DATABASE_URL!);
  await seed(db, schema);
}

main();

----------------------------------------

TITLE: Using Drizzle Kit Drop Command
DESCRIPTION: Demonstrates how to use the new 'drop' command in Drizzle Kit to rollback migrations. This command allows users to select and drop specific migrations.

LANGUAGE: bash
CODE:
drizzle-kit drop

----------------------------------------

TITLE: SQLite BigInt and Boolean Column Definition
DESCRIPTION: Shows how to define bigint and boolean columns in SQLite tables using Drizzle ORM's new type support.

LANGUAGE: typescript
CODE:
const users = sqliteTable('users', {
  bigintCol: blob('bigint', { mode: 'bigint' }).notNull(),
  boolCol: integer('bool', { mode: 'boolean' }).notNull(),
});

----------------------------------------

TITLE: Configuring Drizzle for SingleStore Dialect in TypeScript
DESCRIPTION: This snippet demonstrates how to configure Drizzle to use the SingleStore dialect. It imports the necessary modules, defines the configuration using defineConfig, and sets up the database credentials using an environment variable.

LANGUAGE: typescript
CODE:
import 'dotenv/config';
import { defineConfig } from 'drizzle-kit';

export default defineConfig({
  dialect: 'singlestore',
  out: './drizzle',
  schema: './src/db/schema.ts',
  dbCredentials: {
    url: process.env.DATABASE_URL!,
  },
});

----------------------------------------

TITLE: Configuring Query Logging in Drizzle ORM
DESCRIPTION: Demonstrates how to enable query logging in Drizzle ORM using the simplified logger shorthand configuration. The { logger: true } option can be passed to the drizzle() function to enable default query logging behavior.

LANGUAGE: typescript
CODE:
drizzle({ logger: true })

----------------------------------------

TITLE: Basic Drizzle ORM Usage with SQLite
DESCRIPTION: Demonstrates how to define a table schema and perform a basic query using Drizzle ORM with SQLite

LANGUAGE: typescript
CODE:
import { sqliteTable, text, integer } from 'drizzle-orm/sqlite-core';
import { drizzle } from 'drizzle-orm/better-sqlite3';
import Database from 'better-sqlite3';

const users = sqliteTable('users', {
  id: integer('id').primaryKey(),
  fullName: text('full_name'),
})

const sqlite = new Database('sqlite.db');
const db = drizzle(sqlite);

const allUsers = db.select().from(users).all();

----------------------------------------

TITLE: Implementing PostgreSQL Text Column Builder Pattern
DESCRIPTION: Example implementation of a PostgreSQL text column builder class extending PgColumnBuilder with type definitions and build method.

LANGUAGE: typescript
CODE:
export class PgTextBuilder<TData extends string = string>
  extends PgColumnBuilder<
    ColumnBuilderConfig<{ data: TData; driverParam: string }>
  >
{
  

  build<TTableName extends string>(
    table: AnyPgTable<{ name: TTableName }>,
  ): PgText<TTableName, TData> {
    return new PgText(table, this.config);
  }
}

----------------------------------------

TITLE: Defining Custom Text Type in Drizzle ORM MySQL
DESCRIPTION: Example showing how to create a custom text data type and use it in a MySQL table definition. The custom type includes TypeScript type safety with a generic type parameter for the data structure.

LANGUAGE: typescript
CODE:
const customText = customType<{ data: string }>({\n\tdataType() {\n\t\treturn 'text';\n\t},\n});\n\nconst usersTable = mysqlTable('users', {\n\tname: customText('name').notNull(),\n});

----------------------------------------

TITLE: Implementing Custom HTTP Proxy Driver in TypeScript with Drizzle
DESCRIPTION: Example of creating a custom proxy driver that forwards database queries through HTTP requests. The driver uses axios to make POST requests to a proxy server endpoint, handling both successful queries and error cases.

LANGUAGE: typescript
CODE:
// Custom Proxy HTTP driver
  const db = drizzle(async (sql, params, method) => {
    try {
      const rows = await axios.post('http://localhost:3000/query', { sql, params, method });

      return { rows: rows.data };
    } catch (e: any) {
      console.error('Error from sqlite proxy server: ', e.response.data)
      return { rows: [] };
    }
  });

----------------------------------------

TITLE: Configuring Wrangler for Cloudflare D1
DESCRIPTION: Wrangler configuration file setup for Cloudflare D1 database integration, specifying project settings and database bindings.

LANGUAGE: toml
CODE:
name = "YOUR PROJECT NAME"
main = "src/index.ts"
compatibility_date = "2022-11-07"
node_compat = true

[[ d1_databases ]]
binding = "DB"
database_name = "YOUR DB NAME"
database_id = "YOUR DB ID"

----------------------------------------

TITLE: Specifying Custom Names for Primary and Foreign Keys in Drizzle ORM
DESCRIPTION: Illustrates how to specify custom names for primary keys and foreign keys in table definitions to avoid database name truncation issues.

LANGUAGE: typescript
CODE:
const table = pgTable('table', {
  id: integer('id'),
  name: text('name'),
}, (table) => ({
  cpk: primaryKey({ name: 'composite_key', columns: [table.id, table.name] }),
  cfk: foreignKey({
    name: 'fkName',
    columns: [table.id],
    foreignColumns: [table.name],
  }),
}));

----------------------------------------

TITLE: Initializing Drizzle ORM with AWS Data API for PostgreSQL
DESCRIPTION: Shows how to set up a database connection using AWS Data API client with Drizzle ORM for PostgreSQL. Includes configuration of database credentials through AWS secret and resource ARNs, and demonstrates how to run migrations. Note that the interval data type is not fully supported.

LANGUAGE: typescript
CODE:
import { drizzle, migrate } from 'drizzle-orm/aws-data-api/pg';

const rdsClient = new RDSDataClient({});

const db = drizzle(rdsClient, {
  database: '',
  secretArn: '',
  resourceArn: '',
});

await migrate(db, { migrationsFolder: '' });

----------------------------------------

TITLE: Running and managing the Drizzle ORM project with npm commands
DESCRIPTION: This snippet provides npm commands for running the project locally, generating SQL migrations from the schema, and applying migrations to the remote database. These commands are essential for development and database management.

LANGUAGE: bash
CODE:
npm i

## run locally
npm start

## generate SQL migrations for schema.ts
npm run generate

## apply migrations to remote database
npm run migrate

----------------------------------------

TITLE: Updating Import Paths for Postgres.js and SQL.js Drivers in Drizzle ORM
DESCRIPTION: This snippet shows the changes made to import paths for Postgres.js and SQL.js drivers in Drizzle ORM to avoid bundling errors. The old import paths are replaced with new, more specific paths.

LANGUAGE: markdown
CODE:
- `drizzle-orm/postgres.js` -> `drizzle-orm/postgres-js`
- `drizzle-orm/sql.js` -> `drizzle-orm/sql-js`

----------------------------------------

TITLE: Creating PostgreSQL Identity Columns in TypeScript
DESCRIPTION: Shows how to define identity columns in PostgreSQL using Drizzle ORM, which is the recommended way to specify sequences in a schema.

LANGUAGE: typescript
CODE:
import { pgTable, integer, text } from 'drizzle-orm/pg-core' 

export const ingredients = pgTable("ingredients", {
  id: integer("id").primaryKey().generatedAlwaysAsIdentity({ startWith: 1000 }),
  name: text("name").notNull(),
  description: text("description"),
});

----------------------------------------

TITLE: Updating PostgreSQL Import Paths in JavaScript
DESCRIPTION: Examples of how to update import statements for PostgreSQL-related modules in Drizzle ORM after the package consolidation.

LANGUAGE: javascript
CODE:
import { ... } from 'drizzle-orm/pg-core'

LANGUAGE: javascript
CODE:
import { ... } from 'drizzle-orm/node-postgres'

LANGUAGE: javascript
CODE:
import { ... } from 'drizzle-orm/neon'

LANGUAGE: javascript
CODE:
import { ... } from 'drizzle-orm/postgres.js'

----------------------------------------

TITLE: Using Custom Types in MySQL Table Definition
DESCRIPTION: Demonstrates how to use the custom types defined earlier in a MySQL table definition using Drizzle ORM.

LANGUAGE: typescript
CODE:
const usersTable = mysqlTable('userstest', {
  id: customSerial('id').primaryKey(),
  name: customText('name').notNull(),
  verified: customBoolean('verified').notNull().default(false),
  jsonb: customJson<string[]>('jsonb'),
  createdAt: customTimestamp('created_at', { fsp: 2 }).notNull().default(
    sql`now()`,
  ),
});

----------------------------------------

TITLE: Defining MySQL Generated Columns in TypeScript
DESCRIPTION: Demonstrates how to create generated columns in MySQL using Drizzle ORM, including both stored and virtual options with SQL expressions.

LANGUAGE: typescript
CODE:
export const users = mysqlTable("users", {
  id: int("id"),
  id2: int("id2"),
  name: text("name"),
  generatedName: text("gen_name").generatedAlwaysAs(
    (): SQL => sql`${schema2.users.name} || 'hello'`,
    { mode: "stored" }
  ),
  generatedName1: text("gen_name1").generatedAlwaysAs(
    (): SQL => sql`${schema2.users.name} || 'hello'`,
    { mode: "virtual" }
  ),
}),

----------------------------------------

TITLE: Updating MySQL Import Paths in JavaScript
DESCRIPTION: Examples of how to update import statements for MySQL-related modules in Drizzle ORM after the package consolidation.

LANGUAGE: javascript
CODE:
import { ... } from 'drizzle-orm/mysql-core'

LANGUAGE: javascript
CODE:
import { ... } from 'drizzle-orm/mysql2'

----------------------------------------

TITLE: Setting up environment variables for Neon Serverless database
DESCRIPTION: This snippet demonstrates how to set up environment variables for connecting to a Neon Serverless database. It includes the database URL and project name, which are necessary for the postgres.js driver to run migrations.

LANGUAGE: env
CODE:
DATABASE_URL=postgres://user:password@localhost:5432/dbname
PROJECT_NAME=shiny-fire-338756

----------------------------------------

TITLE: Launching Drizzle Studio UI
DESCRIPTION: Command to start the Drizzle web-based database management interface.

LANGUAGE: bash
CODE:
npm run studio

----------------------------------------

TITLE: Configuring Drizzle Kit for Supabase Migrations Format
DESCRIPTION: Shows how to configure Drizzle Kit to use Supabase-compatible migration file naming format using the 'prefix' option in the configuration file.

LANGUAGE: typescript
CODE:
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  dialect: "postgresql",
  migrations: {
    prefix: 'supabase'
  }
});

----------------------------------------

TITLE: Implementing Database Migrations with Postgres Proxy
DESCRIPTION: Handles database migrations by executing an array of SQL queries through the proxy server. Includes transaction management responsibility on the server side.

LANGUAGE: typescript
CODE:
import axios from 'axios';
import { migrate } from 'drizzle-orm/pg-proxy/migrator';

await migrate(db, async (queries) => {
  try {
    await axios.post('http://localhost:3000/migrate', { queries });
  } catch (e) {
    console.log(e);
    throw Error('Proxy server cannot run migrations');
  }
}, { migrationsFolder: 'drizzle' });

----------------------------------------

TITLE: Updated SQLite Migration SQL Statements
DESCRIPTION: Example of the new SQL migration statements generated for SQLite, which no longer include comments about manual migration and instead provide a set of SQL commands for schema changes.

LANGUAGE: sql
CODE:
PRAGMA foreign_keys=OFF;
--> statement-breakpoint
CREATE TABLE `__new_worker` (
  `id` integer PRIMARY KEY NOT NULL,
  `name` text NOT NULL,
  `salary` text NOT NULL,
  `job_id` integer,
  FOREIGN KEY (`job_id`) REFERENCES `job`(`id`) ON UPDATE no action ON DELETE no action
);
--> statement-breakpoint
INSERT INTO `__new_worker`("id", "name", "salary", "job_id") SELECT "id", "name", "salary", "job_id" FROM `worker`;
--> statement-breakpoint
DROP TABLE `worker`;
--> statement-breakpoint
ALTER TABLE `__new_worker` RENAME TO `worker`;
--> statement-breakpoint
PRAGMA foreign_keys=ON;

----------------------------------------

TITLE: Seeding with Version Parameter in TypeScript
DESCRIPTION: Demonstrates how to use the new 'version' parameter in the seed function to control generator versioning.

LANGUAGE: typescript
CODE:
await seed(db, schema, { version: '2' });

----------------------------------------

TITLE: Installing dependencies and starting local server
DESCRIPTION: Installs required modules and starts a local HTTP server on port 3000, which creates the database and performs a migration.

LANGUAGE: bash
CODE:
pnpm i

LANGUAGE: bash
CODE:
pnpm start

----------------------------------------

TITLE: Updating Drizzle Config with Casing Parameter in TypeScript
DESCRIPTION: Example of how to update the drizzle.config file to include the new casing parameter, ensuring consistent casing strategy across drizzle-orm and drizzle-kit.

LANGUAGE: typescript
CODE:
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  dialect: "postgresql",
  schema: "./schema.ts",
  dbCredentials: {
    url: "postgresql://postgres:password@localhost:5432/db",
  },
  casing: "snake_case",
});

----------------------------------------

TITLE: Demonstrating enforce-update-with-where Rule Usage
DESCRIPTION: TypeScript code examples showing how the 'enforce-update-with-where' rule behaves with different configurations.

LANGUAGE: typescript
CODE:
class MyClass {
  public update() {
    return {}
  }
}

const myClassObj = new MyClass();

// ---> Will be triggered by ESLint Rule
myClassObj.update()

const db = drizzle(...)
// ---> Will be triggered by ESLint Rule
db.update()

LANGUAGE: typescript
CODE:
class MyClass {
  public update() {
    return {}
  }
}

const myClassObj = new MyClass();

// ---> Will NOT be triggered by ESLint Rule
myClassObj.update()

const db = drizzle(...)
// ---> Will be triggered by ESLint Rule
db.update()

----------------------------------------

TITLE: Generating and Using arktype Schemas with Drizzle ORM in TypeScript
DESCRIPTION: This snippet demonstrates how to create a Drizzle ORM table definition and generate corresponding arktype schemas for insert, update, and select operations. It also shows how to override and refine schema fields, as well as validate data using the generated schemas.

LANGUAGE: typescript
CODE:
import { pgEnum, pgTable, serial, text, timestamp } from 'drizzle-orm/pg-core';
import { createInsertSchema, createSelectSchema } from 'drizzle-arktype';
import { type } from 'arktype';

const users = pgTable('users', {
	id: serial('id').primaryKey(),
	name: text('name').notNull(),
	email: text('email').notNull(),
	role: text('role', { enum: ['admin', 'user'] }).notNull(),
	createdAt: timestamp('created_at').notNull().defaultNow(),
});

// Schema for inserting a user - can be used to validate API requests
const insertUserSchema = createInsertSchema(users);

// Schema for updating a user - can be used to validate API requests
const updateUserSchema = createUpdateSchema(users);

// Schema for selecting a user - can be used to validate API responses
const selectUserSchema = createSelectSchema(users);

// Overriding the fields
const insertUserSchema = createInsertSchema(users, {
	role: type('string'),
});

// Refining the fields - useful if you want to change the fields before they become nullable/optional in the final schema
const insertUserSchema = createInsertSchema(users, {
	id: (schema) => schema.atLeast(1),
	role: type('string'),
});

// Usage

const isUserValid = parse(insertUserSchema, {
	name: 'John Doe',
	email: 'johndoe@test.com',
	role: 'admin',
});

----------------------------------------

TITLE: Configuring environment for Turso database connection
DESCRIPTION: Updates the .env file with the Turso database URL and authentication token for remote connection.

LANGUAGE: plain
CODE:
DATABASE_URL=libsql://[your-database]-[your-github].turso.io

LANGUAGE: plain
CODE:
DATABASE_AUTH_TOKEN=[your-auth-token]

----------------------------------------

TITLE: Installing Latest @libsql/client Package in Bash
DESCRIPTION: Command to install the latest version of @libsql/client package, which is required for the new version of drizzle-orm when using the 'migrate' function.

LANGUAGE: bash
CODE:
npm i @libsql/client@latest

----------------------------------------

TITLE: Using Standalone Query Builder in Drizzle ORM for PostgreSQL
DESCRIPTION: This snippet demonstrates how to use the new standalone query builder in Drizzle ORM for PostgreSQL. It allows creating queries without an active database connection, which can be useful for query composition or testing.

LANGUAGE: typescript
CODE:
import { queryBuilder as qb } from 'drizzle-orm/pg-core';

const query = qb.select().from(users).where(eq(users.name, 'Dan'));
const { sql, params } = query.toSQL();

----------------------------------------

TITLE: Generating new database migrations
DESCRIPTION: Command to generate a new migration based on schema changes using Drizzle Kit.

LANGUAGE: bash
CODE:
pnpm generate

----------------------------------------

TITLE: Configuring ESLint for Drizzle in YAML
DESCRIPTION: YAML configuration for setting up ESLint with the Drizzle plugin, including parser options and rule specifications.

LANGUAGE: yaml
CODE:
root: true
parser: '@typescript-eslint/parser'
parserOptions:
  project: './tsconfig.json'
plugins:
  - drizzle
rules:
  'drizzle/enforce-delete-with-where': "error"
  'drizzle/enforce-update-with-where': "error"

LANGUAGE: yaml
CODE:
root: true
extends:
  - "plugin:drizzle/all"
parser: '@typescript-eslint/parser'
parserOptions:
  project: './tsconfig.json'
plugins:
  - drizzle

LANGUAGE: yaml
CODE:
root: true
extends:
  - "plugin:drizzle/recommended"
parser: '@typescript-eslint/parser'
parserOptions:
  project: './tsconfig.json'
plugins:
  - drizzle

----------------------------------------

TITLE: Configuring enforce-delete-with-where Rule
DESCRIPTION: JSON configuration for the 'enforce-delete-with-where' rule, which enforces using .where() clause with delete operations.

LANGUAGE: json
CODE:
"rules": {
  "drizzle/enforce-delete-with-where": ["error"]
}

LANGUAGE: json
CODE:
"rules": {
  "drizzle/enforce-delete-with-where": ["error", { "drizzleObjectName": ["db"] }]
}

----------------------------------------

TITLE: Vector Distance Index Implementations in TypeScript
DESCRIPTION: Examples of creating L2, Inner product, and Cosine distance indexes using pg_vector extension.

LANGUAGE: typescript
CODE:
const table = pgTable('items', {
    embedding: vector('embedding', { dimensions: 3 })
}, (table) => ({
    l2: index('l2_index').using('hnsw', table.embedding.op('vector_l2_ops'))
    ip: index('ip_index').using('hnsw', table.embedding.op('vector_ip_ops'))
    cosine: index('cosine_index').using('hnsw', table.embedding.op('vector_cosine_ops'))
}))

----------------------------------------

TITLE: Connecting to SQLite Database
DESCRIPTION: Shows different ways to connect to SQLite databases using Drizzle ORM

LANGUAGE: typescript
CODE:
// better-sqlite3 or fly.io LiteFS
import { drizzle, BetterSQLite3Database } from 'drizzle-orm/better-sqlite3';
import Database from 'better-sqlite3';

const sqlite = new Database('sqlite.db');
const db/*: BetterSQLite3Database*/ = drizzle(sqlite);
const result = db.select().from(users).all()

// bun js embedded sqlite connector
import { drizzle, BunSQLiteDatabase } from 'drizzle-orm/bun-sqlite';
import { Database } from 'bun:sqlite';

const sqlite = new Database('nw.sqlite');
const db/*: BunSQLiteDatabase*/ = drizzle(sqlite);
const result = db.select().from(users).all()

----------------------------------------

TITLE: Installing ESLint Drizzle Plugin
DESCRIPTION: Instructions for installing the ESLint Drizzle Plugin and its dependencies using various package managers.

LANGUAGE: shell
CODE:
[ npm | yarn | pnpm | bun ] install eslint eslint-plugin-drizzle

LANGUAGE: shell
CODE:
[ npm | yarn | pnpm | bun ] install @typescript-eslint/eslint-plugin @typescript-eslint/parser

----------------------------------------

TITLE: Additional Vector Distance Implementations in TypeScript
DESCRIPTION: Implementation of L1, Hamming, and Jaccard distance indexes for pg_vector 0.7.0.

LANGUAGE: typescript
CODE:
const table = pgTable('table', {
    embedding: vector('embedding', { dimensions: 3 })
}, (table) => ({
    l1: index('l1_index').using('hnsw', table.embedding.op('vector_l1_ops'))
    hamming: index('hamming_index').using('hnsw', table.embedding.op('bit_hamming_ops'))
    bit: index('bit_jaccard_index').using('hnsw', table.embedding.op('bit_jaccard_ops'))
}))

----------------------------------------

TITLE: SQLite Migrations with Drizzle Kit
DESCRIPTION: Explains how to use Drizzle Kit for generating and running SQLite migrations

LANGUAGE: typescript
CODE:
import { drizzle } from 'drizzle-orm/better-sqlite3';
import { migrate } from 'drizzle-orm/better-sqlite3/migrator';
import Database from 'better-sqlite3';

const sqlite = new Database('sqlite.db');
const db = drizzle(sqlite);

// this will automatically run needed migrations on the database
migrate(db, { migrationsFolder: './drizzle' });

----------------------------------------

TITLE: Using 'all' Configuration for eslint-plugin-drizzle
DESCRIPTION: YAML configuration for using the 'all' preset of eslint-plugin-drizzle, which includes all available rules.

LANGUAGE: yaml
CODE:
root: true
extends:
  - "plugin:drizzle/all"
parser: '@typescript-eslint/parser'
parserOptions:
  project: './tsconfig.json'
plugins:
  - drizzle

----------------------------------------

TITLE: Setting up Turso database and retrieving connection details
DESCRIPTION: Creates a new Turso database, retrieves its URL, and generates an authentication token for remote connection.

LANGUAGE: bash
CODE:
turso db create drizzle-example

LANGUAGE: bash
CODE:
turso db show drizzle-example --url

LANGUAGE: bash
CODE:
turso db tokens create drizzle-example

----------------------------------------

TITLE: Using New PostgreSQL Array Operators in TypeScript
DESCRIPTION: Demonstrates the usage of new PostgreSQL array operators: arrayContains, arrayContained, and arrayOverlaps. It includes examples with direct array comparisons and subqueries.

LANGUAGE: typescript
CODE:
const contains = await db.select({ id: posts.id }).from(posts)
	.where(arrayContains(posts.tags, ['Typescript', 'ORM']));

const contained = await db.select({ id: posts.id }).from(posts)
	.where(arrayContained(posts.tags, ['Typescript', 'ORM']));

const overlaps = await db.select({ id: posts.id }).from(posts)
	.where(arrayOverlaps(posts.tags, ['Typescript', 'ORM']));

const withSubQuery = await db.select({ id: posts.id }).from(posts)
	.where(arrayContains(
		posts.tags,
		db.select({ tags: posts.tags }).from(posts).where(eq(posts.id, 1)),
	));

----------------------------------------

TITLE: Setting Custom Seed Value in Drizzle ORM
DESCRIPTION: Demonstrates how to set a custom seed value to generate different but deterministic sets of data.

LANGUAGE: typescript
CODE:
await seed(db, schema, { seed: 12345 });

----------------------------------------

TITLE: Configuring eslint-plugin-drizzle in .eslintrc.yml
DESCRIPTION: YAML configuration for setting up eslint-plugin-drizzle with specific rules in a .eslintrc.yml file.

LANGUAGE: yaml
CODE:
root: true
parser: '@typescript-eslint/parser'
parserOptions:
  project: './tsconfig.json'
plugins:
  - drizzle
rules:
  'drizzle/enforce-delete-with-where': "error"
  'drizzle/enforce-update-with-where': "error"

----------------------------------------

TITLE: Documenting Initial Release of drizzle-typebox in Markdown
DESCRIPTION: This snippet documents the initial release of drizzle-typebox version 0.1.0 using Markdown formatting. It simply states that this is the initial release of the package.

LANGUAGE: Markdown
CODE:
# drizzle-typebox 0.1.0

- Initial release

----------------------------------------

TITLE: CustomTypeValues Interface Definition
DESCRIPTION: Defines the CustomTypeValues interface used for specifying custom type properties in Drizzle ORM.

LANGUAGE: typescript
CODE:
export type CustomTypeValues = {
  data: unknown;
  driverData?: unknown;
  config?: unknown;
  configRequired?: boolean;
  notNull?: boolean;
  default?: boolean;
};

----------------------------------------

TITLE: Installing eslint-plugin-drizzle and Dependencies
DESCRIPTION: Commands for installing eslint-plugin-drizzle and optional TypeScript support packages using various package managers.

LANGUAGE: sh
CODE:
[ npm | yarn | pnpm | bun ] install eslint eslint-plugin-drizzle

LANGUAGE: sh
CODE:
[ npm | yarn | pnpm | bun ] install @typescript-eslint/eslint-plugin @typescript-eslint/parser

----------------------------------------

TITLE: Upgrading Drizzle Kit Migration Folder Structure
DESCRIPTION: Explains how to upgrade the migration folder structure to the new format in Drizzle Kit 0.17.0. It uses the 'up' command to migrate from the previous structure to the new one.

LANGUAGE: bash
CODE:
drizzle-kit up:<dialect> # dialects: `pg`, `mysql`, `sqlite`

# example for pg
drizzle-kit up:pg

----------------------------------------

TITLE: Implementing SingleStore Dialect Support in Drizzle ORM with TypeScript
DESCRIPTION: This code snippet demonstrates how to use the newly added SingleStore dialect in Drizzle ORM. It shows table definition, schema creation, and query execution with type validation using drizzle-zod.

LANGUAGE: typescript
CODE:
import { singlestoreTable, text, int } from 'drizzle-orm/singlestore-core';
import { createSelectSchema } from 'drizzle-zod';

const users = singlestoreTable('users', {
  id: int().primaryKey(),
  name: text().notNull(),
  age: int().notNull()
});

const userSelectSchema = createSelectSchema(users);
const rows = await db.select({ id: users.id, name: users.name }).from(users).limit(1);
const parsed: { id: number; name: string; age: number } = userSelectSchema.parse(rows[0]); // Error: `age` is not returned in the above query

const rows = await db.select().from(users).limit(1);
const parsed: { id: number; name: string; age: number } = userSelectSchema.parse(rows[0]); // Will parse successfully

----------------------------------------

TITLE: Creating Schema Factory with Extended Zod Instance in TypeScript
DESCRIPTION: Demonstrates the use of the new createSchemaFactory function, which allows for more advanced options and the use of extended Zod instances. It shows how to create an insert schema with OpenAPI examples.

LANGUAGE: typescript
CODE:
import { pgTable, text, integer } from 'drizzle-orm/pg-core';
import { createSchemaFactory } from 'drizzle-zod';
import { z } from '@hono/zod-openapi'; // Extended Zod instance

const users = pgTable('users', {
  id: integer().generatedAlwaysAsIdentity().primaryKey(),
  name: text().notNull(),
  age: integer().notNull()
});

const { createInsertSchema } = createSchemaFactory({ zodInstance: z });

const userInsertSchema = createInsertSchema(users, {
  // We can now use the extended instance
  name: (schema) => schema.openapi({ example: 'John' })
});

----------------------------------------

TITLE: Initializing Local D1 Database
DESCRIPTION: Commands to execute local database initialization and run the development server with persistence.

LANGUAGE: bash
CODE:
wrangler d1 execute <DATABASE_NAME> --local --file=./drizzle/0000_short_lockheed.sql
wrangler dev --local --persist

----------------------------------------

TITLE: Defining Composite Primary Keys in SQLite Table Schema with Drizzle ORM
DESCRIPTION: This code snippet demonstrates how to define a table schema with a composite primary key using drizzle-orm-sqlite. It creates a table named 'pk_example' with three columns (id, name, email) and sets a composite primary key using the 'id' and 'name' columns.

LANGUAGE: typescript
CODE:
const pkExample = sqliteTable('pk_example', {
	id: integer('id'),
	name: text('name').notNull(),
	email: text('email').notNull(),
}, (table) => ({
	compositePk: primaryKey(table.id, table.name)
}));

----------------------------------------

TITLE: Creating Select Schema for Enums and Views in TypeScript
DESCRIPTION: Demonstrates how to use the createSelectSchema function with pgEnum and pgView, showcasing the new ability to create schemas for enums and views.

LANGUAGE: typescript
CODE:
import { pgEnum } from 'drizzle-orm/pg-core';
import { createSelectSchema } from 'drizzle-valibot';
import { parse } from 'valibot';

const roles = pgEnum('roles', ['admin', 'basic']);
const rolesSchema = createSelectSchema(roles);
const parsed: 'admin' | 'basic' = parse(rolesSchema, ...);

const usersView = pgView('users_view').as((qb) => qb.select().from(users).where(gt(users.age, 18)));
const usersViewSchema = createSelectSchema(usersView);
const parsed: { id: number; name: string; age: number } = parse(usersViewSchema, ...);

----------------------------------------

TITLE: Configuring Migration Scripts
DESCRIPTION: Package.json configuration for Drizzle migration management, including scripts for generating and applying SQLite migrations.

LANGUAGE: bash
CODE:
npm install drizzle-kit

LANGUAGE: json
CODE:
{
  "scripts": {
    "generate": "drizzle-kit generate:sqlite --schema=src/schema.ts",
    "up": "drizzle-kit up:sqlite --schema=src/schema.ts"
  }
}

LANGUAGE: bash
CODE:
npm run generate

----------------------------------------

TITLE: Setting up environment for local SQLite database
DESCRIPTION: Copies the example environment file and sets the DATABASE_URL to a local SQLite file.

LANGUAGE: bash
CODE:
cp .env.example .env

LANGUAGE: plain
CODE:
DATABASE_URL=file:local.db

----------------------------------------

TITLE: Installing Drizzle ESLint Plugin
DESCRIPTION: Command to install the ESLint plugin for Drizzle version 0.2.3

LANGUAGE: bash
CODE:
npm i eslint-plugin-drizzle@0.2.3

----------------------------------------

TITLE: Support for PostgreSQL Arrays in TypeScript
DESCRIPTION: Illustrates the full support for PostgreSQL arrays in the updated integration, showing how to define array data types and their corresponding schema.

LANGUAGE: typescript
CODE:
pg.dataType().array(...);

// Schema
z.array(baseDataTypeSchema).length(size);

----------------------------------------

TITLE: Installing and Running Drizzle ORM with Bun
DESCRIPTION: Commands for installing required dependencies (mitata and drizzle-orm) and running the TypeScript application using Bun runtime.

LANGUAGE: shell
CODE:
bun install mitata drizzle-orm
bun run src/index.ts

----------------------------------------

TITLE: Initializing SingleStore Table with Valibot Schema Validation in TypeScript
DESCRIPTION: Creates a SingleStore table definition with typed columns and demonstrates schema validation using Valibot. Shows both partial and full select query validation scenarios with type checking.

LANGUAGE: typescript
CODE:
import { singlestoreTable, text, int } from 'drizzle-orm/singlestore-core';
import { createSelectSchema } from 'drizzle-valibot';
import { parse } from 'valibot';

const users = singlestoreTable('users', {
  id: int().primaryKey(),
  name: text().notNull(),
  age: int().notNull()
});

const userSelectSchema = createSelectSchema(users);
const rows = await db.select({ id: users.id, name: users.name }).from(users).limit(1);
const parsed: { id: number; name: string; age: number } = parse(userSelectSchema, rows[0]); // Error: `age` is not returned in the above query
const rows = await db.select().from(users).limit(1);
const parsed: { id: number; name: string; age: number } = parse(userSelectSchema, rows[0]); // Will parse successfully

----------------------------------------

TITLE: Initializing SingleStore Table with TypeBox Schema Validation
DESCRIPTION: Demonstrates how to define a SingleStore table schema with Drizzle ORM and validate query results using TypeBox. Shows both successful and failing validation scenarios based on selected columns.

LANGUAGE: typescript
CODE:
import { singlestoreTable, text, int } from 'drizzle-orm/singlestore-core';
import { createSelectSchema } from 'drizzle-typebox';
import { Value } from '@sinclair/typebox/value';

const users = singlestoreTable('users', {
  id: int().primaryKey(),
  name: text().notNull(),
  age: int().notNull()
});

const userSelectSchema = createSelectSchema(users);

const rows = await db.select({ id: users.id, name: users.name }).from(users).limit(1);
const parsed: { id: number; name: string; age: number } = Value.Parse(userSelectSchema, rows[0]);  // Error: `age` is not returned in the above query

const rows = await db.select().from(users).limit(1);
const parsed: { id: number; name: string; age: number } = Value.Parse(userSelectSchema, rows[0]);  // Will parse successfully

----------------------------------------

TITLE: Configuring Seed Count in Drizzle ORM
DESCRIPTION: Shows how to customize the number of entities created during seeding by setting the count option.

LANGUAGE: typescript
CODE:
await seed(db, schema, { count: 1000 });

----------------------------------------

TITLE: Installing Drizzle ORM for SQLite
DESCRIPTION: Installation command for Drizzle ORM core and SQLite driver

LANGUAGE: bash
CODE:
npm install drizzle-orm better-sqlite3
npm install -D drizzle-kit

----------------------------------------

TITLE: Importing SQLite Migrations in TypeScript
DESCRIPTION: New migration import syntax for better-sqlite3 adapter in drizzle-orm. This change separates the migration functionality into a dedicated import.

LANGUAGE: typescript
CODE:
import { migrate } from 'drizzle-orm-sqlite/better-sqlite3/migrate';

----------------------------------------

TITLE: PostgreSQL Array Type Support
DESCRIPTION: Shows the syntax for PostgreSQL array type support with schema validation including size constraints.

LANGUAGE: typescript
CODE:
pg.dataType().array(...);

// Schema
Type.Array(baseDataTypeSchema, { minItems: size, maxItems: size });

----------------------------------------

TITLE: Seeding with Latest Generator Versions in TypeScript
DESCRIPTION: Shows how to use the latest versions of generators without specifying a version parameter.

LANGUAGE: typescript
CODE:
await seed(db, schema);

----------------------------------------

TITLE: Generating Default Value for SQLite Timestamp (Fixed)
DESCRIPTION: Displays the corrected SQL query generation for defaultNow() method, with added parentheses to fix the issue.

LANGUAGE: sql
CODE:
(cast((julianday('now') - 2440587.5)*86400000 as integer))

----------------------------------------

TITLE: Cloning Drizzle ORM Repository
DESCRIPTION: Git commands to clone the Drizzle ORM repository and navigate to its directory

LANGUAGE: bash
CODE:
git clone https://github.com/drizzle-team/drizzle-orm.git
cd drizzle-orm

----------------------------------------

TITLE: Installing Drizzle ORM
DESCRIPTION: Command to install the Drizzle ORM package via npm.

LANGUAGE: bash
CODE:
npm install drizzle-orm

----------------------------------------

TITLE: Configuring ESLint Rules for Drizzle in JSON
DESCRIPTION: JSON configuration examples for ESLint rules specific to Drizzle, including options for customizing rule behavior.

LANGUAGE: json
CODE:
"rules": {
  "drizzle/enforce-delete-with-where": ["error"]
}

LANGUAGE: json
CODE:
"rules": {
  "drizzle/enforce-delete-with-where": ["error", { "drizzleObjectName": ["db"] }],
}

LANGUAGE: json
CODE:
"rules": {
  "drizzle/enforce-update-with-where": ["error"]
}

LANGUAGE: json
CODE:
"rules": {
  "drizzle/enforce-update-with-where": ["error", { "drizzleObjectName": ["db"] }],
}

----------------------------------------

TITLE: SQLite Schema Migration Error Fix
DESCRIPTION: Fix for a syntax error that occurred when running migrations with async driver that produced 'Error: SqliteError: near "SCHEMA": syntax error'

LANGUAGE: sql
CODE:
SCHEMA

----------------------------------------

TITLE: Installing PNPM Package Manager
DESCRIPTION: Command to install PNPM globally using NPM

LANGUAGE: bash
CODE:
npm install -g pnpm

----------------------------------------

TITLE: MySQL INSERT IGNORE Statement
DESCRIPTION: Demonstrates the syntax for using INSERT IGNORE in MySQL queries via Drizzle ORM. This feature allows insert operations to continue even when duplicate key conflicts occur, silently skipping the conflicting rows instead of throwing an error.

LANGUAGE: sql
CODE:
INSERT IGNORE INTO table_name VALUES (value1, value2, ...)

----------------------------------------

TITLE: SQLite Prepared Statement Error Fix
DESCRIPTION: Resolution for the error 'Statement does not return any data - use run()' that occurred when no fields were provided to prepared statement

LANGUAGE: sql
CODE:
Statement does not return any data - use run()

----------------------------------------

TITLE: Adding Side Effects Configuration in Package.json
DESCRIPTION: Configuration update to package.json to specify the package has no side effects, enabling better tree-shaking in modern bundlers.

LANGUAGE: json
CODE:
{
  "sideEffects": false
}

----------------------------------------

TITLE: Installing Node.js Using NVM
DESCRIPTION: Commands to install Node Version Manager (NVM) and set up Node.js version 18.13.0

LANGUAGE: bash
CODE:
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.40.1/install.sh | bash
nvm install 18.13.0
nvm use 18.13.0

----------------------------------------

TITLE: INSERT INTO ... SELECT with SQL Template Tag in Drizzle ORM
DESCRIPTION: Shows how to use INSERT INTO ... SELECT with an SQL template tag in Drizzle ORM. This method allows for writing raw SQL queries within the insert statement, providing maximum flexibility.

LANGUAGE: typescript
CODE:
await db.insert(employees).select(
    sql`select "users"."name" as "name" from "users" where "users"."role" = 'employee'`
);

----------------------------------------

TITLE: SQLite Schema Error Fix
DESCRIPTION: Fix for a bug that was causing a syntax error when running migrations near the 'SCHEMA' keyword.

LANGUAGE: sql
CODE:
Error: SqliteError: near "SCHEMA": syntax error

----------------------------------------

TITLE: Installing Latest LibSQL Client
DESCRIPTION: Command to install the latest version of @libsql/client package

LANGUAGE: bash
CODE:
npm i @libsql/client@latest

----------------------------------------

TITLE: Configuring Drizzle-Kit with pglite Driver in TypeScript
DESCRIPTION: This code snippet demonstrates how to configure Drizzle-Kit to use the new pglite driver. It sets up the dialect, driver, schema location, database credentials, and other options using the defineConfig function.

LANGUAGE: typescript
CODE:
import { defineConfig } from "drizzle-kit";

export default defineConfig({
  dialect: "postgresql",
  driver: "pglite",
  schema: "./schema.ts",
  dbCredentials: {
    url: "local-pg.db",
  },
  verbose: true,
  strict: true,
});

----------------------------------------

TITLE: Configuring Drizzle for Gel Dialect
DESCRIPTION: Configuration setup for using the Gel dialect in a Drizzle project. This code shows how to specify the Gel dialect in the drizzle.config.ts file using defineConfig.

LANGUAGE: typescript
CODE:
// drizzle.config.ts
import { defineConfig } from 'drizzle-kit';

export default defineConfig({
  dialect: 'gel',
});

----------------------------------------

TITLE: Using Drizzle Mock Function
DESCRIPTION: Shows how to use the new drizzle.mock() function for testing and type checking scenarios where a real database connection isn't needed.

LANGUAGE: typescript
CODE:
const db = drizzle.mock()

----------------------------------------

TITLE: Updated PostgreSQL Index API Implementation in TypeScript
DESCRIPTION: Demonstrates the new, correct index API structure with proper column-level sort and null ordering.

LANGUAGE: typescript
CODE:
// First example, with `.on()`
index('name')
  .on(table.column1.asc(), table.column2.nullsFirst(), ...) or .onOnly(table.column1.desc().nullsLast(), table.column2, ...)
  .concurrently()
  .where(sql``)
  .with({ fillfactor: '70' })

// Second Example, with `.using()`
index('name')
  .using('btree', table.column1.asc(), sql`lower(${table.column2})`, table.column1.op('text_ops'))
  .where(sql``) // sql expression
  .with({ fillfactor: '70' })

----------------------------------------

TITLE: Running Drizzle-Kit Export Command
DESCRIPTION: Command line instruction to execute the drizzle-kit export functionality which converts schema to SQL.

LANGUAGE: bash
CODE:
npx drizzle-kit export

----------------------------------------

TITLE: Installing Drizzle Kit via NPM
DESCRIPTION: Command to install Drizzle Kit as a development dependency using NPM.

LANGUAGE: shell
CODE:
npm install -D drizzle-kit

----------------------------------------

TITLE: Defining Neon Identity Schema
DESCRIPTION: Shows the structure of the Neon Identity schema and users_sync table in Drizzle ORM.

LANGUAGE: typescript
CODE:
const neonIdentitySchema = pgSchema('neon_identity');

export const usersSync = neonIdentitySchema.table('users_sync', {
  rawJson: jsonb('raw_json').notNull(),
  id: text().primaryKey().notNull(),
  name: text(),
  email: text(),
  createdAt: timestamp('created_at', { withTimezone: true, mode: 'string' }),
  deletedAt: timestamp('deleted_at', { withTimezone: true, mode: 'string' }),
});

----------------------------------------

TITLE: Defining Table Schema with New Casing API in TypeScript
DESCRIPTION: Example of how to define a table schema using the new casing API in Drizzle, which allows for automatic mapping between snake_case in the database and camelCase in TypeScript code.

LANGUAGE: typescript
CODE:
import { pgTable } from "drizzle-orm/pg-core";

export const ingredients = pgTable("ingredients", (t) => ({
  id: t.uuid().defaultRandom().primaryKey(),
  name: t.text().notNull(),
  description: t.text(),
  inStock: t.boolean().default(true),
}));

----------------------------------------

TITLE: Export Command with SQL Flag
DESCRIPTION: Command to explicitly specify SQL as the output format using the --sql flag.

LANGUAGE: bash
CODE:
npx drizzle-kit export --sql

----------------------------------------

TITLE: Importing Migration Functionality in drizzle-orm-pg
DESCRIPTION: Demonstrates the new import statement for migration functionality, which has been separated into its own module.

LANGUAGE: typescript
CODE:
import { migrate } from 'drizzle-orm-pg/node/migrate';

----------------------------------------

TITLE: Building Drizzle ORM Project
DESCRIPTION: Commands to install dependencies and build the entire monorepo

LANGUAGE: bash
CODE:
pnpm install && pnpm build

----------------------------------------

TITLE: Running Core Project Commands
DESCRIPTION: Essential npm commands for generating schemas, running migrations, and starting the development server.

LANGUAGE: bash
CODE:
npm run generate
npm run migrate
npm run dev

----------------------------------------

TITLE: Configuring drizzle-kit for Gel Dialect
DESCRIPTION: This code snippet shows how to configure drizzle-kit to use the Gel dialect. It defines a configuration file that specifies 'gel' as the dialect for Drizzle ORM operations.

LANGUAGE: typescript
CODE:
// drizzle.config.ts
import { defineConfig } from 'drizzle-kit';

export default defineConfig({
  dialect: 'gel',
});

----------------------------------------

TITLE: Using 'recommended' Configuration for eslint-plugin-drizzle
DESCRIPTION: YAML configuration for using the 'recommended' preset of eslint-plugin-drizzle, which is currently equivalent to 'all'.

LANGUAGE: yaml
CODE:
root: true
extends:
  - "plugin:drizzle/recommended"
parser: '@typescript-eslint/parser'
parserOptions:
  project: './tsconfig.json'
plugins:
  - drizzle

----------------------------------------

TITLE: Creating RLS Policies in Drizzle
DESCRIPTION: Example of creating comprehensive RLS policies with all available options in Drizzle ORM.

LANGUAGE: typescript
CODE:
import { sql } from 'drizzle-orm';
import { integer, pgPolicy, pgRole, pgTable } from 'drizzle-orm/pg-core';

export const admin = pgRole('admin');

export const users = pgTable('users', {
	id: integer(),
}, (t) => [
	pgPolicy('policy', {
		as: 'permissive',
		to: admin,
		for: 'delete',
		using: sql``,
		withCheck: sql``,
	}),
]);

----------------------------------------

TITLE: Configuring enforce-update-with-where Rule
DESCRIPTION: JSON configuration for the 'enforce-update-with-where' rule, which enforces using .where() clause with update operations.

LANGUAGE: json
CODE:
"rules": {
  "drizzle/enforce-update-with-where": ["error"]
}

LANGUAGE: json
CODE:
"rules": {
  "drizzle/enforce-update-with-where": ["error", { "drizzleObjectName": ["db"] }]
}

----------------------------------------

TITLE: Demonstrating ESLint Rule Behavior in TypeScript
DESCRIPTION: TypeScript code examples showing how the ESLint rules for Drizzle behave with different configurations, including cases where rules are triggered or not triggered.

LANGUAGE: typescript
CODE:
class MyClass {
  public delete() {
    return {}
  }
}

const myClassObj = new MyClass();

// ---> Will be triggered by ESLint Rule
myClassObj.delete()

const db = drizzle(...)
// ---> Will be triggered by ESLint Rule
db.delete()

LANGUAGE: typescript
CODE:
class MyClass {
  public delete() {
    return {}
  }
}

const myClassObj = new MyClass();

// ---> Will NOT be triggered by ESLint Rule
myClassObj.delete()

const db = drizzle(...)
// ---> Will be triggered by ESLint Rule
db.delete()

LANGUAGE: typescript
CODE:
class MyClass {
  public update() {
    return {}
  }
}

const myClassObj = new MyClass();

// ---> Will be triggered by ESLint Rule
myClassObj.update()

const db = drizzle(...)
// ---> Will be triggered by ESLint Rule
db.update()

LANGUAGE: typescript
CODE:
class MyClass {
  public update() {
    return {}
  }
}

const myClassObj = new MyClass();

// ---> Will NOT be triggered by ESLint Rule
myClassObj.update()

const db = drizzle(...)
// ---> Will be triggered by ESLint Rule
db.update()