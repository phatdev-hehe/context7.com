TITLE: Installing Vite with Package Managers
DESCRIPTION: Commands for installing Vite using different package managers including npm, Yarn, pnpm, and Bun.

LANGUAGE: bash
CODE:
$ npm create vite@latest
$ yarn create vite
$ pnpm create vite
$ bun create vite

----------------------------------------

TITLE: Creating Vue Project with Vite
DESCRIPTION: Commands to scaffold a Vue.js project using Vite with different package managers.

LANGUAGE: bash
CODE:
# npm 7+, extra double-dash is needed:
$ npm create vite@latest my-vue-app -- --template vue
$ yarn create vite my-vue-app --template vue
$ pnpm create vite my-vue-app --template vue
$ bun create vite my-vue-app --template vue

----------------------------------------

TITLE: Basic Vite Configuration Structure
DESCRIPTION: The most basic Vite configuration file structure using ES modules syntax.

LANGUAGE: javascript
CODE:
export default {
  // config options
}

----------------------------------------

TITLE: Glob Importing in Vite
DESCRIPTION: Vite provides a special import.meta.glob function for importing multiple modules from the file system.

LANGUAGE: javascript
CODE:
const modules = import.meta.glob('./dir/*.js')

----------------------------------------

TITLE: Configuring Vite Plugins in JavaScript
DESCRIPTION: Example showing how to configure Vite and Rollup plugins in a vite.config.js file, including support for plugin presets.

LANGUAGE: javascript
CODE:
import vitePlugin from 'vite-plugin-feature'
import rollupPlugin from 'rollup-plugin-feature'

export default defineConfig({
  plugins: [vitePlugin(), rollupPlugin()],
})

----------------------------------------

TITLE: Virtual Modules Plugin Example
DESCRIPTION: Plugin implementation showing how to create virtual modules in Vite for passing build time information through ESM imports.

LANGUAGE: javascript
CODE:
export default function myPlugin() {
  const virtualModuleId = 'virtual:my-module'
  const resolvedVirtualModuleId = '\0' + virtualModuleId

  return {
    name: 'my-plugin',
    resolveId(id) {
      if (id === virtualModuleId) {
        return resolvedVirtualModuleId
      }
    },
    load(id) {
      if (id === resolvedVirtualModuleId) {
        return `export const msg = "from virtual module"`
      }
    },
  }
}

----------------------------------------

TITLE: Vite NPM Scripts Configuration
DESCRIPTION: Standard npm scripts configuration for a Vite project including development, build, and preview commands.

LANGUAGE: json
CODE:
{
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  }
}

----------------------------------------

TITLE: Setting up SSR dev server with Express and Vite
DESCRIPTION: This snippet demonstrates how to set up a development server for SSR using Express and Vite in middleware mode. It creates a Vite server instance and uses it as middleware in an Express application.

LANGUAGE: javascript
CODE:
import fs from 'node:fs'
import path from 'node:path'
import { fileURLToPath } from 'node:url'
import express from 'express'
import { createServer as createViteServer } from 'vite'

const __dirname = path.dirname(fileURLToPath(import.meta.url))

async function createServer() {
  const app = express()

  // Create Vite server in middleware mode and configure the app type as
  // 'custom', disabling Vite's own HTML serving logic so parent server
  // can take control
  const vite = await createViteServer({
    server: { middlewareMode: true },
    appType: 'custom'
  })

  // Use vite's connect instance as middleware. If you use your own
  // express router (express.Router()), you should use router.use
  // When the server restarts (for example after the user modifies
  // vite.config.js), `vite.middlewares` is still going to be the same
  // reference (with a new internal stack of Vite and plugin-injected
  // middlewares). The following is valid even after restarts.
  app.use(vite.middlewares)

  app.use('*', async (req, res) => {
    // serve index.html - we will tackle this next
  })

  app.listen(5173)
}

createServer()

----------------------------------------

TITLE: Accessing Environment Variables in JavaScript
DESCRIPTION: Demonstrates how Vite exposes environment variables with VITE_ prefix to client code while protecting sensitive variables.

LANGUAGE: javascript
CODE:
console.log(import.meta.env.VITE_SOME_KEY) // "123"
console.log(import.meta.env.DB_PASSWORD) // undefined

----------------------------------------

TITLE: Creating Vite Dev Server in TypeScript
DESCRIPTION: Example of creating and configuring a Vite dev server programmatically with TypeScript. Shows basic server setup with port configuration and CLI shortcuts.

LANGUAGE: typescript
CODE:
import { fileURLToPath } from 'node:url'
import { createServer } from 'vite'

const __dirname = fileURLToPath(new URL('.', import.meta.url))

const server = await createServer({
  configFile: false,
  root: __dirname,
  server: {
    port: 1337,
  },
})
await server.listen()

server.printUrls()
server.bindCLIShortcuts({ print: true })

----------------------------------------

TITLE: Configuring Rollup Build Options in Vite
DESCRIPTION: Example of customizing Vite's build configuration by adjusting Rollup options in the vite.config.js file.

LANGUAGE: javascript
CODE:
export default defineConfig({
  build: {
    rollupOptions: {
      // https://rollupjs.org/configuration-options/
    },
  },
})

----------------------------------------

TITLE: Multi-Page App Configuration in Vite
DESCRIPTION: Configuration for building a multi-page application with multiple HTML entry points using Vite.

LANGUAGE: javascript
CODE:
import { dirname, resolve } from 'node:path'
import { fileURLToPath } from 'node:url'
import { defineConfig } from 'vite'

const __dirname = dirname(fileURLToPath(import.meta.url))

export default defineConfig({
  build: {
    rollupOptions: {
      input: {
        main: resolve(__dirname, 'index.html'),
        nested: resolve(__dirname, 'nested/index.html'),
      },
    },
  },
})

----------------------------------------

TITLE: Configuring SPA/MPA Environment in Vite
DESCRIPTION: Example configuration for a single-page or multi-page application in Vite. This configuration applies to the default 'client' environment.

LANGUAGE: javascript
CODE:
export default defineConfig({
  build: {
    sourcemap: false,
  },
  optimizeDeps: {
    include: ['lib'],
  },
})

----------------------------------------

TITLE: Configuring npm scripts for Vite build and preview
DESCRIPTION: Defines npm scripts for building and previewing a Vite project. The 'build' script runs the Vite build process, while 'preview' starts a local server to preview the built files.

LANGUAGE: json
CODE:
{
  "scripts": {
    "build": "vite build",
    "preview": "vite preview"
  }
}

----------------------------------------

TITLE: Self-accepting Module with HMR in JavaScript
DESCRIPTION: Demonstrates how to create a self-accepting module using `import.meta.hot.accept()`. The callback receives the updated module, allowing for handling of the hot update.

LANGUAGE: javascript
CODE:
export const count = 1

if (import.meta.hot) {
  import.meta.hot.accept((newModule) => {
    if (newModule) {
      // newModule is undefined when SyntaxError happened
      console.log('updated: count is now ', newModule.count)
    }
  })
}

----------------------------------------

TITLE: Resolving Bare Module Imports in JavaScript
DESCRIPTION: Vite detects and resolves bare module imports in source files, converting them to valid URLs that the browser can import.

LANGUAGE: javascript
CODE:
import { someMethod } from 'my-dep'

----------------------------------------

TITLE: Configuring Vite Warmup for Performance
DESCRIPTION: Shows how to configure Vite's server warmup feature to pre-transform frequently used files and improve loading performance.

LANGUAGE: javascript
CODE:
export default defineConfig({
  server: {
    warmup: {
      clientFiles: [
        './src/components/BigComponent.vue',
        './src/utils/big-utils.js',
      ],
    },
  },
})

----------------------------------------

TITLE: Creating a Workerd Environment Factory in TypeScript
DESCRIPTION: Demonstrates how to create an environment factory for Workerd, setting up default options and merging with user configurations. This factory can be used to create environments for both development and build phases.

LANGUAGE: typescript
CODE:
function createWorkerdEnvironment(
  userConfig: EnvironmentOptions,
): EnvironmentOptions {
  return mergeConfig(
    {
      resolve: {
        conditions: [
          /*...*/
        ],
      },
      dev: {
        createEnvironment(name, config) {
          return createWorkerdDevEnvironment(name, config, {
            hot: true,
            transport: customHotChannel(),
          })
        },
      },
      build: {
        createEnvironment(name, config) {
          return createWorkerdBuildEnvironment(name, config)
        },
      },
    },
    userConfig,
  )
}

----------------------------------------

TITLE: Importing CSS Modules in Vite
DESCRIPTION: Vite supports CSS Modules for files ending with .module.css, allowing import of CSS classes as objects.

LANGUAGE: javascript
CODE:
import classes from './example.module.css'
document.getElementById('foo').className = classes.red

----------------------------------------

TITLE: Configuring Global Constants in Vite
DESCRIPTION: Example of using defineConfig to set global constants that will be defined during dev and statically replaced during build using esbuild defines.

LANGUAGE: javascript
CODE:
export default defineConfig({
  define: {
    __APP_VERSION__: JSON.stringify('v1.0.0'),
    __API_URL__: 'window.__backend_api_url',
  },
})

----------------------------------------

TITLE: Dev Server Configuration Plugin
DESCRIPTION: Example showing how to configure the Vite dev server using the configureServer hook to add custom middleware.

LANGUAGE: javascript
CODE:
const myPlugin = () => ({
  name: 'configure-server',
  configureServer(server) {
    server.middlewares.use((req, res, next) => {
      // custom handle request...
    })
  },
})

----------------------------------------

TITLE: Importing Asset as URL in JavaScript
DESCRIPTION: Demonstrates how to import a static asset as a URL in JavaScript using Vite. The resolved public URL is returned when the asset is served.

LANGUAGE: javascript
CODE:
import imgUrl from './img.png'
document.getElementById('hero-img').src = imgUrl

----------------------------------------

TITLE: Configuring Legacy Browser Support Plugin in Vite
DESCRIPTION: This code demonstrates how to configure the @vitejs/plugin-legacy plugin in the vite.config.js file. It sets up legacy browser support targeting default browsers except IE 11.

LANGUAGE: javascript
CODE:
import legacy from '@vitejs/plugin-legacy'
import { defineConfig } from 'vite'

export default defineConfig({
  plugins: [
    legacy({
      targets: ['defaults', 'not IE 11'],
    }),
  ],
})

----------------------------------------

TITLE: Implementing server-rendered HTML handler
DESCRIPTION: This code snippet shows how to implement a catch-all route handler that serves server-rendered HTML. It reads the index.html template, applies Vite transformations, loads the server entry module, renders the app, and sends the final HTML to the client.

LANGUAGE: javascript
CODE:
app.use('*', async (req, res, next) => {
  const url = req.originalUrl

  try {
    // 1. Read index.html
    let template = fs.readFileSync(
      path.resolve(__dirname, 'index.html'),
      'utf-8',
    )

    // 2. Apply Vite HTML transforms. This injects the Vite HMR client,
    //    and also applies HTML transforms from Vite plugins, e.g. global
    //    preambles from @vitejs/plugin-react
    template = await vite.transformIndexHtml(url, template)

    // 3. Load the server entry. ssrLoadModule automatically transforms
    //    ESM source code to be usable in Node.js! There is no bundling
    //    required, and provides efficient invalidation similar to HMR.
    const { render } = await vite.ssrLoadModule('/src/entry-server.js')

    // 4. render the app HTML. This assumes entry-server.js's exported
    //     `render` function calls appropriate framework SSR APIs,
    //    e.g. ReactDOMServer.renderToString()
    const appHtml = await render(url)

    // 5. Inject the app-rendered HTML into the template.
    const html = template.replace(`<!--ssr-outlet-->`, () => appHtml)

    // 6. Send the rendered HTML back.
    res.status(200).set({ 'Content-Type': 'text/html' }).end(html)
  } catch (e) {
    // If an error is caught, let Vite fix the stack trace so it maps back
    // to your actual source code.
    vite.ssrFixStacktrace(e)
    next(e)
  }
})

----------------------------------------

TITLE: Library Build Configuration in Vite
DESCRIPTION: Configuration for building a library with single or multiple entry points and external dependencies.

LANGUAGE: javascript
CODE:
import { dirname, resolve } from 'node:path'
import { fileURLToPath } from 'node:url'
import { defineConfig } from 'vite'

const __dirname = dirname(fileURLToPath(import.meta.url))

export default defineConfig({
  build: {
    lib: {
      entry: resolve(__dirname, 'lib/main.js'),
      name: 'MyLib',
      fileName: 'my-lib',
    },
    rollupOptions: {
      external: ['vue'],
      output: {
        globals: {
          vue: 'Vue',
        },
      },
    },
  },
})

----------------------------------------

TITLE: Accessing Vite Server Environments in JavaScript
DESCRIPTION: Demonstrates how to access and interact with environments in a Vite dev server, including transforming requests and accessing the module graph.

LANGUAGE: javascript
CODE:
// create the server, or get it from the configureServer hook
const server = await createServer(/* options */)

const environment = server.environments.client
environment.transformRequest(url)
console.log(server.environments.ssr.moduleGraph)

----------------------------------------

TITLE: Building Vite Project Programmatically
DESCRIPTION: Example of using Vite's build API to programmatically build a project with custom configuration.

LANGUAGE: typescript
CODE:
import path from 'node:path'
import { fileURLToPath } from 'node:url'
import { build } from 'vite'

const __dirname = fileURLToPath(new URL('.', import.meta.url))

await build({
  root: path.resolve(__dirname, './project'),
  base: '/foo/',
  build: {
    rollupOptions: {
      // ...
    },
  },
})

----------------------------------------

TITLE: Configuring Multiple Environments in Vite
DESCRIPTION: Example configuration for an application with multiple environments (client, server, and edge) in Vite. This demonstrates how to use the new 'environments' config option.

LANGUAGE: javascript
CODE:
export default {
  build: {
    sourcemap: false,
  },
  optimizeDeps: {
    include: ['lib'],
  },
  environments: {
    server: {},
    edge: {
      resolve: {
        noExternal: true,
      },
    },
  },
}

----------------------------------------

TITLE: Configuring Library Build Settings in Vite
DESCRIPTION: Demonstrates how to configure library build settings, including entry points, file naming, and CSS output in the Vite configuration.

LANGUAGE: javascript
CODE:
import { defineConfig } from 'vite'

export default defineConfig({
  build: {
    lib: {
      entry: ['src/main.js'],
      fileName: (format, entryName) => `my-lib-${entryName}.${format}.js`,
      cssFileName: 'my-lib-style',
    },
  },
})

----------------------------------------

TITLE: Using Environment Factory in Vite Configuration
DESCRIPTION: Shows how to use a custom environment factory in a Vite configuration file. This example sets up two environments (SSR and RSC) using the Workerd environment factory.

LANGUAGE: javascript
CODE:
import { createWorkerdEnvironment } from 'vite-environment-workerd'

export default {
  environments: {
    ssr: createWorkerdEnvironment({
      build: {
        outDir: '/dist/ssr',
      },
    }),
    rsc: createWorkerdEnvironment({
      build: {
        outDir: '/dist/rsc',
      },
    }),
  },
}

----------------------------------------

TITLE: Starting Vite Dev Server
DESCRIPTION: Command to start the Vite development server in the current directory. Supports various options for configuration including host, port, CORS, and other development settings.

LANGUAGE: bash
CODE:
vite [root]

----------------------------------------

TITLE: Configuring preview port for Vite app
DESCRIPTION: Shows how to set a custom port for the Vite preview server by modifying the npm script. This allows you to specify the port on which the preview server will run.

LANGUAGE: json
CODE:
{
  "scripts": {
    "preview": "vite preview --port 8080"
  }
}

----------------------------------------

TITLE: Configuring Server Proxy in Vite (JavaScript)
DESCRIPTION: Shows various examples of configuring proxy rules for the Vite development server, including string shortcuts, options with rewrite rules, RegExp patterns, and websocket proxying.

LANGUAGE: javascript
CODE:
export default defineConfig({
  server: {
    proxy: {
      // string shorthand:
      '/foo': 'http://localhost:4567',
      // with options:
      '/api': {
        target: 'http://jsonplaceholder.typicode.com',
        changeOrigin: true,
        rewrite: (path) => path.replace(/^\/api/, ''),
      },
      // with RegExp:
      '^/fallback/.*': {
        target: 'http://jsonplaceholder.typicode.com',
        changeOrigin: true,
        rewrite: (path) => path.replace(/^\/fallback/, ''),
      },
      // Using the proxy instance
      '/api': {
        target: 'http://jsonplaceholder.typicode.com',
        changeOrigin: true,
        configure: (proxy, options) => {
          // proxy will be an instance of 'http-proxy'
        },
      },
      // Proxying websockets or socket.io:
      '/socket.io': {
        target: 'ws://localhost:5174',
        ws: true,
        rewriteWsOrigin: true,
      },
    },
  },
})

----------------------------------------

TITLE: Advanced Base URL Configuration in Vite
DESCRIPTION: Implementation of advanced base URL handling for assets and public files during build.

LANGUAGE: typescript
CODE:
experimental: {
  renderBuiltUrl(filename, { hostType }) {
    if (hostType === 'js') {
      return { runtime: `window.__toCdnUrl(${JSON.stringify(filename)})` }
    } else {
      return { relative: true }
    }
  },
}

----------------------------------------

TITLE: Importing Script as Web Worker in JavaScript
DESCRIPTION: Shows various ways to import scripts as web workers using ?worker, ?sharedworker, and ?worker&inline suffixes in Vite.

LANGUAGE: javascript
CODE:
// Separate chunk in the production build
import Worker from './shader.js?worker'
const worker = new Worker()

// sharedworker
import SharedWorker from './shader.js?sharedworker'
const sharedWorker = new SharedWorker()

// Inlined as base64 strings
import InlineWorker from './shader.js?worker&inline'

----------------------------------------

TITLE: Conditional Guard for HMR API Usage in JavaScript
DESCRIPTION: Example of using a conditional guard to ensure HMR API code is only executed in development and can be tree-shaken in production.

LANGUAGE: javascript
CODE:
if (import.meta.hot) {
  // HMR code
}

----------------------------------------

TITLE: Implementing a Virtual Module Plugin for Runtime-Agnostic SSR in TypeScript
DESCRIPTION: This plugin creates a virtual module to handle index.html transformation in a runtime-agnostic manner. It demonstrates how to use Vite's plugin API to create and load virtual modules for SSR scenarios.

LANGUAGE: typescript
CODE:
function vitePluginVirtualIndexHtml(): Plugin {
  let server: ViteDevServer | undefined
  return {
    name: vitePluginVirtualIndexHtml.name,
    configureServer(server_) {
      server = server_
    },
    resolveId(source) {
      return source === 'virtual:index-html' ? '\0' + source : undefined
    },
    async load(id) {
      if (id === '\0' + 'virtual:index-html') {
        let html: string
        if (server) {
          this.addWatchFile('index.html')
          html = fs.readFileSync('index.html', 'utf-8')
          html = await server.transformIndexHtml('/', html)
        } else {
          html = fs.readFileSync('dist/client/index.html', 'utf-8')
        }
        return `export default ${JSON.stringify(html)}`
      }
      return
    },
  }
}

----------------------------------------

TITLE: Configuring Vite for Linked Dependencies
DESCRIPTION: Configuration example showing how to handle linked dependencies in a monorepo setup by including them in optimization and CommonJS options.

LANGUAGE: javascript
CODE:
export default defineConfig({
  optimizeDeps: {
    include: ['linked-dep'],
  },
  build: {
    commonjsOptions: {
      include: [/linked-dep/, /node_modules/],
    },
  },
})

----------------------------------------

TITLE: ModuleRunnerTransport Interface Definition in TypeScript
DESCRIPTION: Defines the interface for transport mechanisms used by ModuleRunner to communicate with the Vite server. It includes methods for connecting, disconnecting, sending data, and invoking remote procedures.

LANGUAGE: typescript
CODE:
interface ModuleRunnerTransport {
  connect?(handlers: ModuleRunnerTransportHandlers): Promise<void> | void
  disconnect?(): Promise<void> | void
  send?(data: HotPayload): Promise<void> | void
  invoke?(data: HotPayload): Promise<{ result: any } | { error: any }>
  timeout?: number
}

----------------------------------------

TITLE: Using hot.data for Persistent Data in HMR
DESCRIPTION: Demonstrates how to use `import.meta.hot.data` to persist data across different instances of the same updated module during hot module replacement.

LANGUAGE: javascript
CODE:
// ok
import.meta.hot.data.someValue = 'hello'

// not supported
import.meta.hot.data = { someValue: 'hello' }

----------------------------------------

TITLE: Applying Plugins Conditionally in Vite
DESCRIPTION: This code shows how to conditionally apply a plugin only during the build process in Vite. It uses the rollup-plugin-typescript2 as an example and sets it to apply only during 'build' using the 'apply' property.

LANGUAGE: javascript
CODE:
import typescript2 from 'rollup-plugin-typescript2'
import { defineConfig } from 'vite'

export default defineConfig({
  plugins: [
    {
      ...typescript2(),
      apply: 'build',
    },
  ],
})

----------------------------------------

TITLE: Creating a Custom Dev Environment for Workerd in TypeScript
DESCRIPTION: Illustrates how to create a custom development environment for Workerd. This example sets up a connection and transport mechanism for hot module replacement (HMR).

LANGUAGE: typescript
CODE:
import { DevEnvironment, HotChannel } from 'vite'

function createWorkerdDevEnvironment(
  name: string,
  config: ResolvedConfig,
  context: DevEnvironmentContext
) {
  const connection = /* ... */
  const transport: HotChannel = {
    on: (listener) => { connection.on('message', listener) },
    send: (data) => connection.send(data),
  }

  const workerdDevEnvironment = new DevEnvironment(name, config, {
    options: {
      resolve: { conditions: ['custom'] },
      ...context.options,
    },
    hot: true,
    transport,
  })
  return workerdDevEnvironment
}

----------------------------------------

TITLE: Accepting Updates from Dependencies in JavaScript
DESCRIPTION: Shows how a module can accept updates from its direct dependencies without reloading itself, using `import.meta.hot.accept()` with specified dependency paths.

LANGUAGE: javascript
CODE:
import { foo } from './foo.js'

foo()

if (import.meta.hot) {
  import.meta.hot.accept('./foo.js', (newFoo) => {
    // the callback receives the updated './foo.js' module
    newFoo?.foo()
  })

  // Can also accept an array of dep modules:
  import.meta.hot.accept(
    ['./foo.js', './bar.js'],
    ([newFooModule, newBarModule]) => {
      // The callback receives an array where only the updated module is
      // non null. If the update was not successful (syntax error for ex.),
      // the array is empty
    },
  )
}

----------------------------------------

TITLE: Defining RunnableDevEnvironment and ModuleRunner in TypeScript
DESCRIPTION: This snippet defines the RunnableDevEnvironment class and ModuleRunner interface, which are used for running modules in the same runtime as the Vite server. It includes methods for importing modules and checking environment compatibility.

LANGUAGE: typescript
CODE:
export class RunnableDevEnvironment extends DevEnvironment {
  public readonly runner: ModuleRunner
}

class ModuleRunner {
  /**
   * URL to execute.
   * Accepts file path, server path, or id relative to the root.
   * Returns an instantiated module (same as in ssrLoadModule)
   */
  public async import(url: string): Promise<Record<string, any>>
  /**
   * Other ModuleRunner methods...
   */
}

if (isRunnableDevEnvironment(server.environments.ssr)) {
  await server.environments.ssr.runner.import('/entry-point.js')
}

----------------------------------------

TITLE: Importing WebAssembly in Vite
DESCRIPTION: Vite allows importing pre-compiled .wasm files with the ?init suffix, returning an initialization function.

LANGUAGE: javascript
CODE:
import init from './example.wasm?init'

init().then((instance) => {
  instance.exports.test()
})

----------------------------------------

TITLE: HotUpdate Hook Interface Definition
DESCRIPTION: Type definition for the hotUpdate hook options interface showing available properties for HMR handling.

LANGUAGE: typescript
CODE:
interface HotUpdateOptions {
  type: 'create' | 'update' | 'delete'
  file: string
  timestamp: number
  modules: Array<EnvironmentModuleNode>
  read: () => string | Promise<string>
  server: ViteDevServer
}

----------------------------------------

TITLE: ModuleRunnerOptions Interface Definition in TypeScript
DESCRIPTION: Defines the options interface for ModuleRunner, including transport configuration, sourcemap handling, HMR settings, and module caching options.

LANGUAGE: typescript
CODE:
interface ModuleRunnerOptions {
  /**
   * A set of methods to communicate with the server.
   */
  transport: ModuleRunnerTransport
  /**
   * Configure how source maps are resolved.
   * Prefers `node` if `process.setSourceMapsEnabled` is available.
   * Otherwise it will use `prepareStackTrace` by default which overrides
   * `Error.prepareStackTrace` method.
   * You can provide an object to configure how file contents and
   * source maps are resolved for files that were not processed by Vite.
   */
  sourcemapInterceptor?:
    | false
    | 'node'
    | 'prepareStackTrace'
    | InterceptorOptions
  /**
   * Disable HMR or configure HMR options.
   *
   * @default true
   */
  hmr?: boolean | ModuleRunnerHmr
  /**
   * Custom module cache. If not provided, it creates a separate module
   * cache for each module runner instance.
   */
  evaluatedModules?: EvaluatedModules
}

----------------------------------------

TITLE: Configuring Environment Options
DESCRIPTION: Shows how to configure specific environment options using the configEnvironment hook.

LANGUAGE: typescript
CODE:
  configEnvironment(name: string, options: EnvironmentOptions) {
    if (name === 'rsc') {
      options.resolve.conditions = // ...


----------------------------------------

TITLE: Transform Result Interface in TypeScript
DESCRIPTION: TypeScript interface definition for TransformResult, detailing the structure of transformation output including code, source maps, and dependencies.

LANGUAGE: typescript
CODE:
interface TransformResult {
  code: string
  map: SourceMap | { mappings: '' } | null
  etag?: string
  deps?: string[]
  dynamicDeps?: string[]
}

----------------------------------------

TITLE: Building Vite Project for Production
DESCRIPTION: Command to build a Vite project for production deployment. Includes options for output configuration, minification, source maps, and SSR support.

LANGUAGE: bash
CODE:
vite build [root]

----------------------------------------

TITLE: Running Vite Dev Server with Performance Profiling
DESCRIPTION: Command to start the Vite dev server with performance profiling enabled.

LANGUAGE: bash
CODE:
vite --profile --open

----------------------------------------

TITLE: Full Reload HMR Implementation
DESCRIPTION: Example of implementing a full page reload in the hotUpdate hook for client environment.

LANGUAGE: javascript
CODE:
  hotUpdate({ modules, timestamp }) {
    if (this.environment.name !== 'client')
      return

    // Invalidate modules manually
    const invalidatedModules = new Set()
    for (const mod of modules) {
      this.environment.moduleGraph.invalidateModule(
        mod,
        invalidatedModules,
        timestamp,
        true
      )
    }
    this.environment.hot.send({ type: 'full-reload' })
    return []
  }

----------------------------------------

TITLE: Importing Web Workers in Vite
DESCRIPTION: Vite supports importing Web Workers using the ?worker suffix, returning a custom worker constructor.

LANGUAGE: javascript
CODE:
import MyWorker from './worker?worker'

const worker = new MyWorker()

----------------------------------------

TITLE: Defining HmrContext Interface in TypeScript
DESCRIPTION: TypeScript interface definition for the HmrContext object used in the handleHotUpdate hook. It includes properties for file information, timestamp, affected modules, and server instance.

LANGUAGE: typescript
CODE:
interface HmrContext {
  file: string
  timestamp: number
  modules: Array<ModuleNode>
  read: () => string | Promise<string>
  server: ViteDevServer
}

----------------------------------------

TITLE: Previewing Production Build
DESCRIPTION: Command to locally preview the production build. Not intended for use as a production server, but useful for testing the built application.

LANGUAGE: bash
CODE:
vite preview [root]

----------------------------------------

TITLE: Defining ViteHotContext Interface in TypeScript
DESCRIPTION: TypeScript interface definition for the ViteHotContext object, which represents the `import.meta.hot` API in Vite. It includes methods for accepting updates, disposing modules, and handling custom events.

LANGUAGE: typescript
CODE:
interface ImportMeta {
  readonly hot?: ViteHotContext
}

interface ViteHotContext {
  readonly data: any

  accept(): void
  accept(cb: (mod: ModuleNamespace | undefined) => void): void
  accept(dep: string, cb: (mod: ModuleNamespace | undefined) => void): void
  accept(
    deps: readonly string[],
    cb: (mods: Array<ModuleNamespace | undefined>) => void,
  ): void

  dispose(cb: (data: any) => void): void
  prune(cb: (data: any) => void): void
  invalidate(message?: string): void

  on<T extends string>(
    event: T,
    cb: (payload: InferCustomEventPayload<T>) => void,
  ): void
  off<T extends string>(
    event: T,
    cb: (payload: InferCustomEventPayload<T>) => void,
  ): void
  send<T extends string>(event: T, data?: InferCustomEventPayload<T>): void
}

----------------------------------------

TITLE: Configuring JSX in Vite
DESCRIPTION: Vite allows configuration of JSX settings using the esbuild option in the config file.

LANGUAGE: javascript
CODE:
import { defineConfig } from 'vite'

export default defineConfig({
  esbuild: {
    jsxFactory: 'h',
    jsxFragment: 'Fragment',
  },
})

----------------------------------------

TITLE: ModuleEvaluator Interface Definition in TypeScript
DESCRIPTION: Specifies the interface for module evaluators, which are responsible for executing transformed code in the runtime environment. It includes methods for running inlined and external modules.

LANGUAGE: typescript
CODE:
export interface ModuleEvaluator {
  /**
   * Number of prefixed lines in the transformed code.
   */
  startOffset?: number
  /**
   * Evaluate code that was transformed by Vite.
   * @param context Function context
   * @param code Transformed code
   * @param id ID that was used to fetch the module
   */
  runInlinedModule(
    context: ModuleRunnerContext,
    code: string,
    id: string,
  ): Promise<any>
  /**
   * evaluate externalized module.
   * @param file File URL to the external module
   */
  runExternalModule(file: string): Promise<any>
}

----------------------------------------

TITLE: Custom HMR Event Handler
DESCRIPTION: Implementation of custom HMR event handling with specialized update logic.

LANGUAGE: javascript
CODE:
  hotUpdate() {
    if (this.environment.name !== 'client')
      return

    this.environment.hot.send({
      type: 'custom',
      event: 'special-update',
      data: {}
    })
    return []
  }

LANGUAGE: javascript
CODE:
if (import.meta.hot) {
  import.meta.hot.on('special-update', (data) => {
    // perform custom update
  })
}

----------------------------------------

TITLE: Importing TypeScript Files in Vite
DESCRIPTION: Vite supports importing .ts files directly, performing transpilation but not type checking.

LANGUAGE: typescript
CODE:
import type { T } from 'only/types'
export type { T }

----------------------------------------

TITLE: Implementing ModuleRunnerTransport in Worker Thread
DESCRIPTION: Shows how to implement the ModuleRunnerTransport interface for a worker thread scenario. This example sets up communication between a worker and the main thread using Node.js worker_threads.

LANGUAGE: javascript
CODE:
import { parentPort } from 'node:worker_threads'
import { fileURLToPath } from 'node:url'
import { ESModulesEvaluator, ModuleRunner } from 'vite/module-runner'

/** @type {import('vite/module-runner').ModuleRunnerTransport} */
const transport = {
  connect({ onMessage, onDisconnection }) {
    parentPort.on('message', onMessage)
    parentPort.on('close', onDisconnection)
  },
  send(data) {
    parentPort.postMessage(data)
  },
}

const runner = new ModuleRunner(
  {
    transport,
  },
  new ESModulesEvaluator(),
)

----------------------------------------

TITLE: Per-Environment Plugin Implementation
DESCRIPTION: Shows how to implement a plugin that can be configured differently for each environment using applyToEnvironment.

LANGUAGE: javascript
CODE:
const UnoCssPlugin = () => {
  // shared global state
  return {
    buildStart() {
      // init per-environment state with WeakMap<Environment,Data>
      // using this.environment
    },
    configureServer() {
      // use global hooks normally
    },
    applyToEnvironment(environment) {
      // return true if this plugin should be active in this environment,
      // or return a new plugin to replace it.
      // if the hook is not used, the plugin is active in all environments
    },
    resolveId(id, importer) {
      // only called for environments this plugin apply to
    },
  }
}

----------------------------------------

TITLE: Creating Worker Environment in Vite Server
DESCRIPTION: Demonstrates how to create a worker environment in a Vite server. This example sets up a worker thread and establishes communication channels between the worker and the Vite server for hot module replacement (HMR).

LANGUAGE: javascript
CODE:
import { BroadcastChannel } from 'node:worker_threads'
import { createServer, RemoteEnvironmentTransport, DevEnvironment } from 'vite'

function createWorkerEnvironment(name, config, context) {
  const worker = new Worker('./worker.js')
  const handlerToWorkerListener = new WeakMap()

  const workerHotChannel = {
    send: (data) => worker.postMessage(data),
    on: (event, handler) => {
      if (event === 'connection') return

      const listener = (value) => {
        if (value.type === 'custom' && value.event === event) {
          const client = {
            send(payload) {
              worker.postMessage(payload)
            },
          }
          handler(value.data, client)
        }
      }
      handlerToWorkerListener.set(handler, listener)
      worker.on('message', listener)
    },
    off: (event, handler) => {
      if (event === 'connection') return
      const listener = handlerToWorkerListener.get(handler)
      if (listener) {
        worker.off('message', listener)
        handlerToWorkerListener.delete(handler)
      }
    },
  }

  return new DevEnvironment(name, config, {
    transport: workerHotChannel,
  })
}

await createServer({
  environments: {
    worker: {
      dev: {
        createEnvironment: createWorkerEnvironment,
      },
    },
  },
})

----------------------------------------

TITLE: Explicit Inline Handling of Assets in JavaScript
DESCRIPTION: Shows how to explicitly import assets with inlining or no inlining using the ?inline or ?no-inline suffixes respectively.

LANGUAGE: javascript
CODE:
import imgUrl1 from './img.svg?no-inline'
import imgUrl2 from './img.png?inline'

----------------------------------------

TITLE: Importing Asset as String in JavaScript
DESCRIPTION: Demonstrates how to import assets as strings using the ?raw suffix in Vite projects.

LANGUAGE: javascript
CODE:
import shaderString from './shader.glsl?raw'

----------------------------------------

TITLE: HTTP-based ModuleRunner Transport Implementation
DESCRIPTION: Illustrates how to implement a ModuleRunner transport using HTTP requests for communication between the runner and the Vite server. This example disables HMR as it requires a connect method.

LANGUAGE: typescript
CODE:
import { ESModulesEvaluator, ModuleRunner } from 'vite/module-runner'

export const runner = new ModuleRunner(
  {
    transport: {
      async invoke(data) {
        const response = await fetch(`http://my-vite-server/invoke`, {
          method: 'POST',
          body: JSON.stringify(data),
        })
        return response.json()
      },
    },
    hmr: false, // disable HMR as HMR requires transport.connect
  },
  new ESModulesEvaluator(),
)

await runner.import('/entry.js')

----------------------------------------

TITLE: Using new URL() with import.meta.url in JavaScript
DESCRIPTION: Demonstrates how to use the new URL() constructor with import.meta.url to obtain the full, resolved URL of a static asset using a relative path from a JavaScript module.

LANGUAGE: javascript
CODE:
const imgUrl = new URL('./img.png', import.meta.url).href

document.getElementById('hero-img').src = imgUrl

----------------------------------------

TITLE: Handling Invocations in Custom Vite Environment
DESCRIPTION: Shows how to handle invocations from a ModuleRunner in a custom Vite environment. This example sets up a request handler to process invocations and return results.

LANGUAGE: typescript
CODE:
const customEnvironment = new DevEnvironment(name, config, context)

server.onRequest((request: Request) => {
  const url = new URL(request.url)
  if (url.pathname === '/invoke') {
    const payload = (await request.json()) as HotPayload
    const result = customEnvironment.hot.handleInvoke(payload)
    return new Response(JSON.stringify(result))
  }
  return Response.error()
})

----------------------------------------

TITLE: Injecting React Refresh Runtime for Development
DESCRIPTION: Injects the React Refresh Runtime script for development when using @vitejs/plugin-react with Vite.

LANGUAGE: html
CODE:
<script type="module">
  import RefreshRuntime from 'http://localhost:5173/@react-refresh'
  RefreshRuntime.injectIntoGlobalHook(window)
  window.$RefreshReg$ = () => {}
  window.$RefreshSig$ = () => (type) => type
  window.__vite_plugin_react_preamble_installed__ = true
</script>

----------------------------------------

TITLE: Configuring CSS Preprocessor Options in Vite
DESCRIPTION: Example showing how to configure options for various CSS preprocessors like Less, Stylus and SCSS.

LANGUAGE: javascript
CODE:
export default defineConfig({
  css: {
    preprocessorOptions: {
      less: {
        math: 'parens-division',
      },
      styl: {
        define: {
          $specialColor: new stylus.nodes.RGBA(51, 197, 255, 1),
        },
      },
      scss: {
        api: 'modern-compiler', // or "modern", "legacy"
        importers: [
          // ...
        ],
      },
    },
  },
})

----------------------------------------

TITLE: Inlining SVGs through url() in JavaScript
DESCRIPTION: Shows how to properly inline SVG URLs in JavaScript when manually constructing a url() function. The variable should be wrapped in double quotes.

LANGUAGE: javascript
CODE:
import imgUrl from './img.svg'
document.getElementById('hero-img').style.background = `url("${imgUrl}")`

----------------------------------------

TITLE: Load Error Handling in Vite
DESCRIPTION: Implementation of error handling for dynamic import failures in Vite using the vite:preloadError event.

LANGUAGE: javascript
CODE:
window.addEventListener('vite:preloadError', (event) => {
  window.location.reload() // for example, refresh the page
})

----------------------------------------

TITLE: Explicit URL Import for Houdini Paint Worklets
DESCRIPTION: Demonstrates how to explicitly import assets as URLs using the ?url suffix, which is useful for importing Houdini Paint Worklets.

LANGUAGE: javascript
CODE:
import workletURL from 'extra-scalloped-border/worklet.js?url'
CSS.paintWorklet.addModule(workletURL)

----------------------------------------

TITLE: Registering New Environment in Config Hook
DESCRIPTION: Demonstrates how to register a new environment (RSC) using the config hook with default values.

LANGUAGE: typescript
CODE:
  config(config: UserConfig) {
    config.environments.rsc ??= {}
  }

----------------------------------------

TITLE: Configuring Server Warmup in Vite (JavaScript)
DESCRIPTION: Demonstrates how to configure the server.warmup option to pre-transform and cache frequently used files, improving initial page load times during server starts.

LANGUAGE: javascript
CODE:
export default defineConfig({
  server: {
    warmup: {
      clientFiles: ['./src/components/*.vue', './src/utils/big-utils.js'],
      ssrFiles: ['./src/server/modules/*.js'],
    },
  },
})

----------------------------------------

TITLE: Dynamic URL Generation with Template Literals in JavaScript
DESCRIPTION: Shows how to generate dynamic URLs using template literals with the new URL() constructor and import.meta.url in Vite projects.

LANGUAGE: javascript
CODE:
function getImageUrl(name) {
  // note that this does not include files in subdirectories
  return new URL(`./dir/${name}.png`, import.meta.url).href
}

----------------------------------------

TITLE: Rendering Asset Links in Production HTML Template
DESCRIPTION: Demonstrates how to render links or preload directives with hashed filenames in a production HTML template using the Vite manifest.

LANGUAGE: html
CODE:
<!-- if production -->

<!-- for cssFile of manifest[name].css -->
<link rel="stylesheet" href="/{{ cssFile }}" />

<!-- for chunk of importedChunks(manifest, name) -->
<!-- for cssFile of chunk.css -->
<link rel="stylesheet" href="/{{ cssFile }}" />

<script type="module" src="/{{ manifest[name].file }}"></script>

<!-- for chunk of importedChunks(manifest, name) -->
<link rel="modulepreload" href="/{{ chunk.file }}" />

----------------------------------------

TITLE: Configuring Vite for Backend Integration
DESCRIPTION: Sets up Vite configuration for backend integration, including CORS settings, manifest generation, and entry point specification.

LANGUAGE: javascript
CODE:
export default defineConfig({
  server: {
    cors: {
      // the origin you will be accessing via browser
      origin: 'http://my-backend.example.com',
    },
  },
  build: {
    // generate .vite/manifest.json in outDir
    manifest: true,
    rollupOptions: {
      // overwrite default .html entry
      input: '/path/to/main.js',
    },
  },
})

----------------------------------------

TITLE: Migrating Full Reload Logic in Vite HMR Hooks
DESCRIPTION: Example of migrating from handleHotUpdate to hotUpdate hook while implementing a full reload. This snippet shows how to invalidate modules and trigger a full reload in both hooks.

LANGUAGE: javascript
CODE:
handleHotUpdate({ server, modules, timestamp }) {
  // Invalidate modules manually
  const invalidatedModules = new Set()
  for (const mod of modules) {
    server.moduleGraph.invalidateModule(
      mod,
      invalidatedModules,
      timestamp,
      true
    )
  }
  server.ws.send({ type: 'full-reload' })
  return []
}

// Migrate to:

hotUpdate({ modules, timestamp }) {
  // Invalidate modules manually
  const invalidatedModules = new Set()
  for (const mod of modules) {
    this.environment.moduleGraph.invalidateModule(
      mod,
      invalidatedModules,
      timestamp,
      true
    )
  }
  this.environment.hot.send({ type: 'full-reload' })
  return []
}

----------------------------------------

TITLE: ModuleRunner Class Definition in TypeScript
DESCRIPTION: Defines the ModuleRunner class, which is responsible for executing modules in the target runtime. It includes methods for importing modules, clearing caches, and managing the runner's lifecycle.

LANGUAGE: typescript
CODE:
export class ModuleRunner {
  constructor(
    public options: ModuleRunnerOptions,
    public evaluator: ModuleEvaluator = new ESModulesEvaluator(),
    private debug?: ModuleRunnerDebugger,
  ) {}
  /**
   * URL to execute.
   * Accepts file path, server path, or id relative to the root.
   */
  public async import<T = any>(url: string): Promise<T>
  /**
   * Clear all caches including HMR listeners.
   */
  public clearCache(): void
  /**
   * Clear all caches, remove all HMR listeners, reset sourcemap support.
   * This method doesn't stop the HMR connection.
   */
  public async close(): Promise<void>
  /**
   * Returns `true` if the runner has been closed by calling `close()`.
   */
  public isClosed(): boolean
}

----------------------------------------

TITLE: Example Vite Manifest JSON
DESCRIPTION: Demonstrates the structure of a .vite/manifest.json file generated after running vite build, showing chunk information and dependencies.

LANGUAGE: json
CODE:
{
  "_shared-B7PI925R.js": {
    "file": "assets/shared-B7PI925R.js",
    "name": "shared",
    "css": ["assets/shared-ChJ_j-JJ.css"]
  },
  "_shared-ChJ_j-JJ.css": {
    "file": "assets/shared-ChJ_j-JJ.css",
    "src": "_shared-ChJ_j-JJ.css"
  },
  "baz.js": {
    "file": "assets/baz-B2H3sXNv.js",
    "name": "baz",
    "src": "baz.js",
    "isDynamicEntry": true
  },
  "views/bar.js": {
    "file": "assets/bar-gkvgaI9m.js",
    "name": "bar",
    "src": "views/bar.js",
    "isEntry": true,
    "imports": ["_shared-B7PI925R.js"],
    "dynamicImports": ["baz.js"]
  },
  "views/foo.js": {
    "file": "assets/foo-BRBmoGS9.js",
    "name": "foo",
    "src": "views/foo.js",
    "isEntry": true,
    "imports": ["_shared-B7PI925R.js"],
    "css": ["assets/foo-5UjPuW-k.css"]
  }
}

----------------------------------------

TITLE: Implementing SSR Middleware with Default RunnableDevEnvironment in JavaScript
DESCRIPTION: This code demonstrates how to set up an SSR middleware using Vite's Environment API. It includes steps for reading and transforming HTML, loading the server entry, rendering the app, and sending the response.

LANGUAGE: javascript
CODE:
import fs from 'node:fs'
import path from 'node:path'
import { fileURLToPath } from 'node:url'
import { createServer } from 'vite'

const __dirname = path.dirname(fileURLToPath(import.meta.url))

const server = await createServer({
  server: { middlewareMode: true },
  appType: 'custom',
  environments: {
    server: {
      // by default, modules are run in the same process as the vite server
    },
  },
})

// You might need to cast this to RunnableDevEnvironment in TypeScript or
// use isRunnableDevEnvironment to guard the access to the runner
const environment = server.environments.node

app.use('*', async (req, res, next) => {
  const url = req.originalUrl

  // 1. Read index.html
  const indexHtmlPath = path.resolve(__dirname, 'index.html')
  let template = fs.readFileSync(indexHtmlPath, 'utf-8')

  // 2. Apply Vite HTML transforms. This injects the Vite HMR client,
  //    and also applies HTML transforms from Vite plugins, e.g. global
  //    preambles from @vitejs/plugin-react
  template = await server.transformIndexHtml(url, template)

  // 3. Load the server entry. import(url) automatically transforms
  //    ESM source code to be usable in Node.js! There is no bundling
  //    required, and provides full HMR support.
  const { render } = await environment.runner.import('/src/entry-server.js')

  // 4. render the app HTML. This assumes entry-server.js's exported
  //     `render` function calls appropriate framework SSR APIs,
  //    e.g. ReactDOMServer.renderToString()
  const appHtml = await render(url)

  // 5. Inject the app-rendered HTML into the template.
  const html = template.replace(`<!--ssr-outlet-->`, appHtml)

  // 6. Send the rendered HTML back.
  res.status(200).set({ 'Content-Type': 'text/html' }).end(html)
})

----------------------------------------

TITLE: Pre-bundling Dependencies (Deprecated)
DESCRIPTION: Deprecated command for pre-bundling dependencies. This process now runs automatically and doesn't need to be called manually.

LANGUAGE: bash
CODE:
vite optimize [root]

----------------------------------------

TITLE: DevEnvironment Class Definition in TypeScript
DESCRIPTION: TypeScript class definition for DevEnvironment, including methods for transforming requests and managing module graphs with environment-specific configurations.

LANGUAGE: typescript
CODE:
class DevEnvironment {
  /**
   * Unique identifier for the environment in a Vite server.
   * By default Vite exposes 'client' and 'ssr' environments.
   */
  name: string
  /**
   * Communication channel to send and receive messages from the
   * associated module runner in the target runtime.
   */
  hot: NormalizedHotChannel
  /**
   * Graph of module nodes, with the imported relationship between
   * processed modules and the cached result of the processed code.
   */
  moduleGraph: EnvironmentModuleGraph
  /**
   * Resolved plugins for this environment, including the ones
   * created using the per-environment `create` hook
   */
  plugins: Plugin[]
  /**
   * Allows to resolve, load, and transform code through the
   * environment plugins pipeline
   */
  pluginContainer: EnvironmentPluginContainer
  /**
   * Resolved config options for this environment. Options at the server
   * global scope are taken as defaults for all environments, and can
   * be overridden (resolve conditions, external, optimizedDeps)
   */
  config: ResolvedConfig & ResolvedDevEnvironmentOptions

  constructor(
    name: string,
    config: ResolvedConfig,
    context: DevEnvironmentContext,
  )

  /**
   * Resolve the URL to an id, load it, and process the code using the
   * plugins pipeline. The module graph is also updated.
   */
  async transformRequest(url: string): Promise<TransformResult | null>

  /**
   * Register a request to be processed with low priority. This is useful
   * to avoid waterfalls. The Vite server has information about the
   * imported modules by other requests, so it can warmup the module graph
   * so the modules are already processed when they are requested.
   */
  async warmupRequest(url: string): Promise<void>
}

----------------------------------------

TITLE: Installing Legacy Browser Support Plugin in Vite
DESCRIPTION: This snippet shows how to install the @vitejs/plugin-legacy package using npm to provide support for legacy browsers in a Vite project.

LANGUAGE: bash
CODE:
$ npm add -D @vitejs/plugin-legacy

----------------------------------------

TITLE: Basic React Import Example with Vite ESM Conversion
DESCRIPTION: Demonstrates how Vite handles CommonJS module imports by converting them to ESM format, allowing named imports to work as expected.

LANGUAGE: javascript
CODE:
// works as expected
import React, { useState } from 'react'

----------------------------------------

TITLE: Migrating Custom HMR Handling in Vite HMR Hooks
DESCRIPTION: Example of migrating from handleHotUpdate to hotUpdate hook while implementing custom HMR handling. This snippet demonstrates how to send custom events to the client in both hooks.

LANGUAGE: javascript
CODE:
handleHotUpdate({ server }) {
  server.ws.send({
    type: 'custom',
    event: 'special-update',
    data: {}
  })
  return []
}

// Migrate to...

hotUpdate() {
  this.environment.hot.send({
    type: 'custom',
    event: 'special-update',
    data: {}
  })
  return []
}

----------------------------------------

TITLE: TypeScript Environment Variable Type Definitions
DESCRIPTION: Shows how to add TypeScript type definitions for custom environment variables in Vite applications.

LANGUAGE: typescript
CODE:
/// <reference types="vite/client" />

interface ImportMetaEnv {
  readonly VITE_APP_TITLE: string
  // more env variables...
}

interface ImportMeta {
  readonly env: ImportMetaEnv
}

----------------------------------------

TITLE: TypeScript Configuration for Browser Types
DESCRIPTION: Configuration example for including browser environment types in TypeScript projects.

LANGUAGE: json
CODE:
{
  "lib": ["WebWorker"]
}

----------------------------------------

TITLE: Creating Vite Server in Middleware Mode (JavaScript)
DESCRIPTION: Illustrates how to create a Vite server in middleware mode and integrate it with an Express application for custom server setups.

LANGUAGE: javascript
CODE:
import express from 'express'
import { createServer as createViteServer } from 'vite'

async function createServer() {
  const app = express()

  // Create Vite server in middleware mode
  const vite = await createViteServer({
    server: { middlewareMode: true },
    // don't include Vite's default HTML handling middlewares
    appType: 'custom',
  })
  // Use vite's connect instance as middleware
  app.use(vite.middlewares)

  app.use('*', async (req, res) => {
    // Since `appType` is `'custom'`, should serve response here.
    // Note: if `appType` is `'spa'` or `'mpa'`, Vite includes middlewares
    // to handle HTML requests and 404s so user middlewares should be added
    // before Vite's middlewares to take effect instead
  })
}

createServer()

----------------------------------------

TITLE: HTML Environment Variable Usage
DESCRIPTION: Example of using environment variables in HTML files using Vite's constant replacement syntax.

LANGUAGE: html
CODE:
<h1>Vite is running in %MODE%</h1>
<p>Using data from %VITE_API_URL%</p>

----------------------------------------

TITLE: Importing Module Preload Polyfill in Vite Entry
DESCRIPTION: Imports the module preload polyfill at the beginning of the app entry if it hasn't been disabled in the Vite configuration.

LANGUAGE: javascript
CODE:
// add the beginning of your app entry
import 'vite/modulepreload-polyfill'

----------------------------------------

TITLE: HTML Asset Processing in Vite
DESCRIPTION: Vite processes assets referenced in HTML files, including scripts, stylesheets, and images.

LANGUAGE: html
CODE:
<!doctype html>
<html>
  <head>
    <link rel="icon" href="/favicon.ico" />
    <link rel="stylesheet" href="/src/styles.css" />
  </head>
  <body>
    <img src="/src/images/logo.svg" alt="logo" />
    <script type="module" src="/src/main.js"></script>
  </body>
</html>

----------------------------------------

TITLE: Injecting Vite Scripts for Development
DESCRIPTION: Injects necessary Vite scripts into the HTML template for development, including the Vite client and main entry point.

LANGUAGE: html
CODE:
<!-- if development -->
<script type="module" src="http://localhost:5173/@vite/client"></script>
<script type="module" src="http://localhost:5173/main.js"></script>

----------------------------------------

TITLE: Configuring Server Origin in Vite (JavaScript)
DESCRIPTION: Demonstrates how to set the server.origin option to define the origin of generated asset URLs during development.

LANGUAGE: javascript
CODE:
export default defineConfig({
  server: {
    origin: 'http://127.0.0.1:8080',
  },
})

----------------------------------------

TITLE: GitHub Actions workflow for deploying to GitHub Pages
DESCRIPTION: Defines a GitHub Actions workflow for deploying a static site to GitHub Pages. It includes steps for checking out the code, setting up Node.js, installing dependencies, building the project, and deploying to GitHub Pages.

LANGUAGE: yaml
CODE:
name: Deploy static content to Pages

on:
  push:
    branches: ['main']
  workflow_dispatch:

permissions:
  contents: read
  pages: write
  id-token: write

concurrency:
  group: 'pages'
  cancel-in-progress: true

jobs:
  deploy:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Set up Node
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'
      - name: Install dependencies
        run: npm ci
      - name: Build
        run: npm run build
      - name: Setup Pages
        uses: actions/configure-pages@v4
      - name: Upload artifact
        uses: actions/upload-pages-artifact@v3
        with:
          path: './dist'
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4

----------------------------------------

TITLE: Creating Custom Environment Instances in Vite
DESCRIPTION: Example of using a custom environment provider to create a specific environment configuration, in this case for an SSR environment.

LANGUAGE: javascript
CODE:
import { customEnvironment } from 'vite-environment-provider'

export default {
  build: {
    outDir: '/dist/client',
  },
  environments: {
    ssr: customEnvironment({
      build: {
        outDir: '/dist/ssr',
      },
    }),
  },
}

----------------------------------------

TITLE: GitLab CI configuration for deploying to GitLab Pages
DESCRIPTION: Configures GitLab CI to deploy a static site to GitLab Pages. It defines a job that installs dependencies, builds the project, and copies the build output to the public directory for deployment.

LANGUAGE: yaml
CODE:
image: node:16.5.0
pages:
  stage: deploy
  cache:
    key:
      files:
        - package-lock.json
      prefix: npm
    paths:
      - node_modules/
  script:
    - npm install
    - npm run build
    - cp -a dist/. public/
  artifacts:
    paths:
      - public
  rules:
    - if: $CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH

----------------------------------------

TITLE: Configuring Custom Logger in Vite
DESCRIPTION: Example of creating and customizing a logger to filter specific warning messages.

LANGUAGE: typescript
CODE:
import { createLogger, defineConfig } from 'vite'

const logger = createLogger()
const loggerWarn = logger.warn

logger.warn = (msg, options) => {
  // Ignore empty CSS files warning
  if (msg.includes('vite:css') && msg.includes(' is empty')) return
  loggerWarn(msg, options)
}

export default defineConfig({
  customLogger: logger,
})

----------------------------------------

TITLE: Configuring Server Sourcemap Ignore List in Vite (JavaScript)
DESCRIPTION: Shows how to configure the server.sourcemapIgnoreList option to control which source files are ignored in the server sourcemap.

LANGUAGE: javascript
CODE:
export default defineConfig({
  server: {
    // This is the default value, and will add all files with node_modules
    // in their paths to the ignore list.
    sourcemapIgnoreList(sourcePath, sourcemapPath) {
      return sourcePath.includes('node_modules')
    },
  },
})

----------------------------------------

TITLE: Firebase configuration for hosting a Vite app
DESCRIPTION: Defines the Firebase configuration for hosting a Vite app. It specifies the public directory, ignore patterns, and URL rewrite rules for single-page applications.

LANGUAGE: json
CODE:
{
  "hosting": {
    "public": "dist",
    "ignore": [],
    "rewrites": [
      {
        "source": "**",
        "destination": "/index.html"
      }
    ]
  }
}

----------------------------------------

TITLE: Using ModuleRunner in JavaScript
DESCRIPTION: Demonstrates how to create and use a ModuleRunner instance. This example sets up a module runner with custom transport and evaluator, then imports a module.

LANGUAGE: javascript
CODE:
import { ModuleRunner, ESModulesEvaluator } from 'vite/module-runner'
import { transport } from './rpc-implementation.js'

const moduleRunner = new ModuleRunner(
  {
    transport,
  },
  new ESModulesEvaluator(),
)

await moduleRunner.import('/src/entry-point.js')

----------------------------------------

TITLE: Firebase project configuration
DESCRIPTION: Specifies the Firebase project configuration, including the default project ID. This file is used to associate the local project with a specific Firebase project.

LANGUAGE: json
CODE:
{
  "projects": {
    "default": "<YOUR_FIREBASE_ID>"
  }
}

----------------------------------------

TITLE: Disposing Side Effects in HMR with JavaScript
DESCRIPTION: Demonstrates using `hot.dispose()` to clean up side effects when a module is about to be replaced during hot module replacement.

LANGUAGE: javascript
CODE:
function setupSideEffect() {}

setupSideEffect()

if (import.meta.hot) {
  import.meta.hot.dispose((data) => {
    // cleanup side effect
  })
}

----------------------------------------

TITLE: Implementing importedChunks Function in TypeScript
DESCRIPTION: Provides a TypeScript implementation of the importedChunks function to recursively gather imported chunks from the Vite manifest.

LANGUAGE: typescript
CODE:
import type { Manifest, ManifestChunk } from 'vite'

export default function importedChunks(
  manifest: Manifest,
  name: string,
): ManifestChunk[] {
  const seen = new Set<string>()

  function getImportedChunks(chunk: ManifestChunk): ManifestChunk[] {
    const chunks: ManifestChunk[] = []
    for (const file of chunk.imports ?? []) {
      const importee = manifest[file]
      if (seen.has(file)) {
        continue
      }
      seen.add(file)

      chunks.push(...getImportedChunks(importee))
      chunks.push(importee)
    }

    return chunks
  }

  return getImportedChunks(manifest[name])
}

----------------------------------------

TITLE: Running Vite with CJS Trace Flag
DESCRIPTION: Command to run Vite with a flag that logs the stack trace for CJS deprecation warnings.

LANGUAGE: bash
CODE:
VITE_CJS_TRACE=true vite dev

----------------------------------------

TITLE: Environment Variables in Vite Config
DESCRIPTION: Loading and using environment variables in Vite configuration

LANGUAGE: javascript
CODE:
import { defineConfig, loadEnv } from 'vite'

export default defineConfig(({ mode }) => {
  const env = loadEnv(mode, process.cwd(), '')
  return {
    // vite config
    define: {
      __APP_ENV__: JSON.stringify(env.APP_ENV),
    },
  }
})

----------------------------------------

TITLE: Ignoring CJS Deprecation Warning in Vite
DESCRIPTION: Command to run Vite while ignoring the CJS deprecation warning.

LANGUAGE: bash
CODE:
VITE_CJS_IGNORE_WARNING=true vite dev

----------------------------------------

TITLE: Async Vite Configuration
DESCRIPTION: Asynchronous configuration setup with defineConfig

LANGUAGE: javascript
CODE:
export default defineConfig(async ({ command, mode }) => {
  const data = await asyncFunction()
  return {
    // vite config
  }
})

----------------------------------------

TITLE: TypeScript Config with Satisfies Operator
DESCRIPTION: Vite configuration using TypeScript with type checking

LANGUAGE: typescript
CODE:
import type { UserConfig } from 'vite'

export default {
  // ...
} satisfies UserConfig

----------------------------------------

TITLE: Incorrect Case-Sensitive Import in JavaScript
DESCRIPTION: Example of an incorrect import statement that may cause HMR issues due to case sensitivity.

LANGUAGE: javascript
CODE:
import './Foo.js' // should be './foo.js'

----------------------------------------

TITLE: Advanced Legacy Plugin Configuration
DESCRIPTION: Example showing how to configure the legacy plugin with specific polyfill settings for both modern and legacy builds.

LANGUAGE: javascript
CODE:
import legacy from '@vitejs/plugin-legacy'

export default {
  plugins: [
    legacy({
      polyfills: ['es.promise.finally', 'es/map', 'es/set'],
      modernPolyfills: ['es.promise.finally'],
    }),
  ],
}

----------------------------------------

TITLE: Building Vite Project with Performance Profiling
DESCRIPTION: Command to build a Vite project with performance profiling enabled.

LANGUAGE: bash
CODE:
vite build --profile

----------------------------------------

TITLE: Importing SVG Images in Vue Component
DESCRIPTION: This code snippet demonstrates how to import and use SVG images in a Vue component using Vite's raw import feature. It sets up two SVG images to be used in the component.

LANGUAGE: javascript
CODE:
<script setup>
import bundlerSvg from '../images/bundler.svg?raw'
import esmSvg from '../images/esm.svg?raw'
</script>

----------------------------------------

TITLE: Configuring Package.json CSS File Path Migration
DESCRIPTION: Example showing how to update package.json exports configuration to handle the new CSS file naming convention in Vite 6 library mode.

LANGUAGE: json
CODE:
{
  "name": "my-lib",
  "exports": {
    "./style.css": "./dist/my-lib.css"
  }
}

----------------------------------------

TITLE: CLI Interface Styling
DESCRIPTION: Custom CSS styling for the Vite CLI interface elements.

LANGUAGE: css
CODE:
.stackblitz-links {
  display: flex;
  width: 100%;
  justify-content: space-around;
  align-items: center;
}
@media screen and (max-width: 550px) {
  .stackblitz-links {
    display: grid;
    grid-template-columns: 1fr 1fr 1fr;
    width: 100%;
    gap: 2rem;
    padding-left: 3rem;
    padding-right: 3rem;
  }
}
.stackblitz-links > a {
  width: 70px;
  height: 70px;
  display: grid;
  align-items: center;
  justify-items: center;
}
.stackblitz-links > a:hover {
  filter: drop-shadow(0 0 0.5em #646cffaa);
}

----------------------------------------

TITLE: Glob Import Patterns in JavaScript
DESCRIPTION: Examples of using import.meta.glob with various patterns including multiple patterns, negative patterns, named imports and custom queries.

LANGUAGE: javascript
CODE:
import.meta.glob(['./dir/*.js', './another/*.js'])
import.meta.glob(['./dir/*.js', '!**/bar.js'])
import.meta.glob('./dir/*.js', { import: 'setup' })
import.meta.glob('./dir/*.js', { query: { custom: 'data' } })
import.meta.glob('./dir/*.js', { eager: true })

----------------------------------------

TITLE: Importing CSS as a String in Vite 4
DESCRIPTION: Demonstrates the new way to import CSS as a string in Vite 4 using the ?inline query suffix modifier. This change prevents double loading of CSS files.

LANGUAGE: typescript
CODE:
import cssString from './global.css?inline'

----------------------------------------

TITLE: Using perEnvironmentState Helper for Plugin State Management in JavaScript
DESCRIPTION: This snippet demonstrates the use of Vite's perEnvironmentState helper to simplify the creation of environment-aware plugins. It provides a cleaner way to manage state for different environments.

LANGUAGE: javascript
CODE:
function PerEnvironmentCountTransformedModulesPlugin() {
  const state = perEnvironmentState<{ count: number }>(() => ({ count: 0 }))
  return {
    name: 'count-transformed-modules',
    perEnvironmentStartEndDuringDev: true,
    buildStart() {
      state(this).count = 0
    }
    transform(id) {
      state(this).count++
    },
    buildEnd() {
      console.log(this.environment.name, state(this).count)
    }
  }
}

----------------------------------------

TITLE: Configuring VitePress Page with Vue Script
DESCRIPTION: Vue template that configures a VitePress markdown page and imports a BlogIndex component. The frontmatter disables common VitePress features like sidebar and edit links, while the script imports and renders a BlogIndex component.

LANGUAGE: markdown
CODE:
---
sidebar: false
editLink: false
outline: false
---

LANGUAGE: vue
CODE:
<script setup>
import BlogIndex from './.vitepress/theme/components/BlogIndex.vue'
</script>

# Latest From the Vite Blog

<BlogIndex/>

----------------------------------------

TITLE: Migrating Module Filtering in Vite HMR Hooks
DESCRIPTION: Example of migrating from handleHotUpdate to hotUpdate hook while maintaining module filtering logic. This snippet demonstrates how to filter and return affected modules in both hooks.

LANGUAGE: javascript
CODE:
handleHotUpdate({ modules }) {
  return modules.filter(condition)
}

// Migrate to:

hotUpdate({ modules }) {
  return modules.filter(condition)
}

----------------------------------------

TITLE: Updating Environment Variables in Vite 4
DESCRIPTION: Shows the required change in environment variable formatting for Vite 4, which uses dotenv 16 and dotenv-expand 9. Values containing # or ` now need to be wrapped in quotes.

LANGUAGE: diff
CODE:
-VITE_APP=ab#cd`ef
+VITE_APP="ab#cd`ef"

----------------------------------------

TITLE: Configuring Future Deprecation Warnings in Vite
DESCRIPTION: Configuration options to enable warning messages for deprecated server methods that will be removed in Vite v7.0. These settings help identify usage of server.moduleGraph and server.transformRequest that should be migrated to environment-based APIs.

LANGUAGE: typescript
CODE:
future: {
  removeServerModuleGraph: 'warn',
  removeServerTransformRequest: 'warn',
}

----------------------------------------

TITLE: Configuring Vite with Qwik CSR Mode
DESCRIPTION: Vite configuration for enabling Client Side Rendering mode in Qwik. Sets up the Qwik plugin with CSR enabled through the configuration object.

LANGUAGE: typescript
CODE:
export default defineConfig({
  plugins: [
    qwikVite({
      csr: true,
    }),
  ],
})

----------------------------------------

TITLE: Project Setup Commands
DESCRIPTION: Basic package installation command for setting up project dependencies using various package managers.

LANGUAGE: bash
CODE:
$ npm install # or pnpm install or yarn install

----------------------------------------

TITLE: Implementing a Basic Plugin Counter in JavaScript
DESCRIPTION: This snippet demonstrates a basic Vite plugin that counts the number of transformed modules across all environments. It uses a shared state, which may not be ideal for multi-environment setups.

LANGUAGE: javascript
CODE:
function CountTransformedModulesPlugin() {
  let transformedModules
  return {
    name: 'count-transformed-modules',
    buildStart() {
      transformedModules = 0
    },
    transform(id) {
      transformedModules++
    },
    buildEnd() {
      console.log(transformedModules)
    },
  }
}

----------------------------------------

TITLE: Building Vite Project for Production
DESCRIPTION: This script builds the app for production, bundling Solid.js in production mode and optimizing for best performance. The output is placed in the 'dist' folder.

LANGUAGE: bash
CODE:
npm run build

----------------------------------------

TITLE: Creating an Environment-Aware Plugin Counter in JavaScript
DESCRIPTION: This snippet shows how to create a Vite plugin that counts transformed modules separately for each environment. It uses a Map to store state for different environments.

LANGUAGE: javascript
CODE:
function PerEnvironmentCountTransformedModulesPlugin() {
  const state = new Map<Environment, { count: number }>()
  return {
    name: 'count-transformed-modules',
    perEnvironmentStartEndDuringDev: true,
    buildStart() {
      state.set(this.environment, { count: 0 })
    }
    transform(id) {
      state.get(this.environment).count++
    },
    buildEnd() {
      console.log(this.environment.name, state.get(this.environment).count)
    }
  }
}

----------------------------------------

TITLE: Running Vite Development Server
DESCRIPTION: This script runs the app in development mode, starting a local server at http://localhost:5173 for viewing in the browser.

LANGUAGE: bash
CODE:
npm run dev

----------------------------------------

TITLE: Installing Dependencies for Vite Project
DESCRIPTION: This command installs the necessary dependencies for the Vite project using npm, pnpm, or yarn package managers.

LANGUAGE: bash
CODE:
$ npm install # or pnpm install or yarn install

----------------------------------------

TITLE: Migrating Plugin Environment Check in TypeScript
DESCRIPTION: Demonstrates how to migrate a Vite plugin from using the legacy `options.ssr` argument to the new `this.environment.name` check in plugin hooks. This change is part of Vite 6's transition to supporting multiple named environments.

LANGUAGE: typescript
CODE:
import { Plugin } from 'vite'

export function myPlugin(): Plugin {
  return {
    name: 'my-plugin',
    resolveId(id, importer, options) {
      const isSSR = options.ssr // [!code --]
      const isSSR = this.environment.name !== 'client' // [!code ++]

      if (isSSR) {
        // SSR specific logic
      } else {
        // Client specific logic
      }
    },
  }
}

----------------------------------------

TITLE: Building Vite Project for Production
DESCRIPTION: Script to build the application for production, bundling and optimizing Solid.js components into the 'dist' folder with minification and hashed filenames.

LANGUAGE: bash
CODE:
npm run build

----------------------------------------

TITLE: Importing Module Preload Polyfill in JavaScript
DESCRIPTION: Demonstrates how to manually import the module preload polyfill in a custom entry file when not using HTML entries.

LANGUAGE: javascript
CODE:
import 'vite/modulepreload-polyfill'

----------------------------------------

TITLE: Accessing Experimental Proposals in GitHub Discussions
DESCRIPTION: This snippet provides a link to the GitHub Discussions page for Vite, filtered to show experimental proposals. It allows users to view and provide feedback on potential future changes.

LANGUAGE: markdown
CODE:
[Experimental Label in Vite GitHub Discussions](https://github.com/vitejs/vite/discussions/categories/feedback?discussions_q=label%3Aexperimental+category%3AFeedback)

----------------------------------------

TITLE: Accessing Future Options in Vite Configuration
DESCRIPTION: This snippet demonstrates how to access the 'future' option in the Vite configuration file. The 'future' option allows users to opt-in to upcoming breaking changes.

LANGUAGE: markdown
CODE:
[`future` option](/config/shared-options.html#future)

----------------------------------------

TITLE: Configuring Module Preload Resolution in Vite
DESCRIPTION: Shows how to customize module preload dependency resolution using the resolveDependencies function in the Vite configuration.

LANGUAGE: javascript
CODE:
/** @type {import('vite').UserConfig} */
const config = {
  // prettier-ignore
  build: {
modulePreload: {
  resolveDependencies: (filename, deps, { hostId, hostType }) => {
    return deps.filter(condition)
  },
},
  },
}

----------------------------------------

TITLE: Building and previewing a Vite app using npm scripts
DESCRIPTION: Demonstrates how to use npm scripts to build a Vite app and preview it locally. The 'npm run build' command creates a production build, while 'npm run preview' starts a local server to test the built files.

LANGUAGE: bash
CODE:
$ npm run build
$ npm run preview

----------------------------------------

TITLE: Configuring Custom Optimization Entries in Vite
DESCRIPTION: Demonstrates how to specify custom entries for Vite's dependency optimizer using the optimizeDeps.entries option. This overrides the default entry inference and allows for more granular control over which files are scanned for dependencies.

LANGUAGE: javascript
CODE:
export default defineConfig({
  optimizeDeps: {
    include: ['esm-dep > cjs-dep'],
  },
})

----------------------------------------

TITLE: Setting Environment Variable in Vite
DESCRIPTION: Defines a basic environment variable named 'KEY' with value 'safe' for use in a Vite project configuration.

LANGUAGE: env
CODE:
KEY=safe

----------------------------------------

TITLE: Setting Environment Variable in Vite Project
DESCRIPTION: Defines a single environment variable 'KEY' with the value 'safe' for use in a Vite application. This configuration can be accessed within the application using import.meta.env.KEY.

LANGUAGE: env
CODE:
KEY=safe

----------------------------------------

TITLE: Including Deep Imports for Pre-bundling in Vite
DESCRIPTION: Shows how to use a glob pattern with optimizeDeps.include to pre-bundle all deep imports from a library at once. This can improve performance by avoiding constant pre-bundling when new deep imports are used.

LANGUAGE: javascript
CODE:
export default defineConfig({
  optimizeDeps: {
    include: ['my-lib/components/**/*.vue'],
  },
})

----------------------------------------

TITLE: Configuring Type-Aware ESLint Rules for Vite TypeScript
DESCRIPTION: Demonstrates how to enable type-aware lint rules in the ESLint configuration for production applications. Includes configuration for recommended type checking, strict type checking, and stylistic rules with TypeScript project references.

LANGUAGE: javascript
CODE:
export default tseslint.config({
  extends: [
    // Remove ...tseslint.configs.recommended and replace with this
    ...tseslint.configs.recommendedTypeChecked,
    // Alternatively, use this for stricter rules
    ...tseslint.configs.strictTypeChecked,
    // Optionally, add this for stylistic rules
    ...tseslint.configs.stylisticTypeChecked,
  ],
  languageOptions: {
    // other options...
    parserOptions: {
      project: ['./tsconfig.node.json', './tsconfig.app.json'],
      tsconfigRootDir: import.meta.dirname,
    },
  },
})

----------------------------------------

TITLE: Vite CLI Config Specification
DESCRIPTION: Command to specify a custom config file using the CLI

LANGUAGE: bash
CODE:
vite --config my-config.js

----------------------------------------

TITLE: Legacy Modern Polyfill Detection (JavaScript)
DESCRIPTION: Fix for modern polyfill autodetection to avoid extra polyfills

LANGUAGE: javascript
CODE:
modern polyfill autodetection was injecting more polyfills than needed

----------------------------------------

TITLE: Legacy Build File Name Pattern (JavaScript)
DESCRIPTION: Fix for legacy build file naming pattern with hash separator

LANGUAGE: javascript
CODE:
x.[hash].js -> x-legacy.[hash].js

----------------------------------------

TITLE: Vite Config with TypeScript Intellisense
DESCRIPTION: Configuration with JSDoc type hints for TypeScript support

LANGUAGE: javascript
CODE:
/** @type {import('vite').UserConfig} */
export default {
  // ...
}

----------------------------------------

TITLE: Installing Terser Dependency
DESCRIPTION: Command to install Terser as a required dependency for the legacy plugin's minification functionality.

LANGUAGE: shell
CODE:
npm add -D terser

----------------------------------------

TITLE: Vite Config with defineConfig Helper
DESCRIPTION: Using defineConfig helper for built-in intellisense support

LANGUAGE: javascript
CODE:
import { defineConfig } from 'vite'

export default defineConfig({
  // ...
})

----------------------------------------

TITLE: Basic Vite HTML Template
DESCRIPTION: Minimal HTML template for starting a Vite project.

LANGUAGE: html
CODE:
<p>Hello Vite!</p>

----------------------------------------

TITLE: WebAssembly Import in JavaScript
DESCRIPTION: Example of the revised WebAssembly import API using the new ?init syntax.

LANGUAGE: javascript
CODE:
import init from './example.wasm?init'

init().then((instance) => {
  instance.exports.test()
})

----------------------------------------

TITLE: Conditional Vite Configuration
DESCRIPTION: Config that conditionally determines options based on command and mode

LANGUAGE: javascript
CODE:
export default defineConfig(({ command, mode, isSsrBuild, isPreview }) => {
  if (command === 'serve') {
    return {
      // dev specific config
    }
  } else {
    // command === 'build'
    return {
      // build specific config
    }
  }
})

----------------------------------------

TITLE: Initializing a Vite Project with NPM
DESCRIPTION: This command initializes a new Vite-powered project using NPM. It requires Node.js version 12 or higher to be installed on the system.

LANGUAGE: bash
CODE:
npm init @vitejs/app

----------------------------------------

TITLE: Configuring Preview and Server Ports in Vite
DESCRIPTION: This snippet demonstrates how to set different ports for the development server and preview server in Vite. It uses the defineConfig function to export the configuration object.

LANGUAGE: javascript
CODE:
export default defineConfig({
  server: {
    port: 3030,
  },
  preview: {
    port: 8080,
  },
})

----------------------------------------

TITLE: Module Stack Contents
DESCRIPTION: Shows the import stack contents for each module involved in the circular dependency, demonstrating how module H acts as a common ancestor creating forked import paths.

LANGUAGE: plaintext
CODE:
[X] stack:
	[H]

LANGUAGE: plaintext
CODE:
[Y] stack:
	[X]
	[H]

LANGUAGE: plaintext
CODE:
[A] stack:
	[H]

LANGUAGE: plaintext
CODE:
[B] stack:
	[A]
	[H]

----------------------------------------

TITLE: Dependency Chain Visualization
DESCRIPTION: Demonstrates the import relationships between modules using arrow notation. Shows how module H imports various other modules creating potential circular dependencies.

LANGUAGE: plaintext
CODE:
H -> X ... Y
H -> X -> Y ... B
H -> A ... B
H -> A -> B ... X

----------------------------------------

TITLE: Setting DNS Result Order in Vite Config (JavaScript)
DESCRIPTION: Configures DNS result order to 'verbatim' in a Vite configuration file. This is useful when using 'localhost' as the server host to ensure consistent address resolution.

LANGUAGE: javascript
CODE:
import { defineConfig } from 'vite'
import dns from 'node:dns'

dns.setDefaultResultOrder('verbatim')

export default defineConfig({
  // omit
})

----------------------------------------

TITLE: Defining HotUpdateOptions Interface in TypeScript
DESCRIPTION: TypeScript interface definition for the HotUpdateOptions object used in the new hotUpdate hook. It extends HmrContext with an additional type property for different update events.

LANGUAGE: typescript
CODE:
interface HotUpdateOptions {
  type: 'create' | 'update' | 'delete'
  file: string
  timestamp: number
  modules: Array<EnvironmentModuleNode>
  read: () => string | Promise<string>
  server: ViteDevServer
}

----------------------------------------

TITLE: Configuring Server Open Option in Vite (JavaScript)
DESCRIPTION: Demonstrates how to configure the server.open option in a Vite configuration file to automatically open a specific URL path when the server starts.

LANGUAGE: javascript
CODE:
export default defineConfig({
  server: {
    open: '/docs/index.html',
  },
})

----------------------------------------

TITLE: Configuring Package Overrides in package.json
DESCRIPTION: JSON configuration for testing local Vite modifications against external packages using pnpm overrides

LANGUAGE: json
CODE:
{
  "dependencies": {
    "vite": "^6.0.0"
  },
  "pnpm": {
    "overrides": {
      "vite": "link:../path/to/vite/packages/vite"
    }
  }
}

----------------------------------------

TITLE: Configuring Git Blame Ignore File
DESCRIPTION: Command to configure git to use the blame ignore file for excluding formatting changes from blame history

LANGUAGE: sh
CODE:
git config --local blame.ignoreRevsFile .git-blame-ignore-revs

----------------------------------------

TITLE: Configuring Server File System Allow in Vite (JavaScript)
DESCRIPTION: Shows how to configure the server.fs.allow option to restrict file serving and extend the workspace root detection in Vite.

LANGUAGE: javascript
CODE:
import { defineConfig, searchForWorkspaceRoot } from 'vite'

export default defineConfig({
  server: {
    fs: {
      allow: [
        // search up for workspace root
        searchForWorkspaceRoot(process.cwd()),
        // your custom rules
        '/path/to/custom/allow_directory',
        '/path/to/custom/allow_file.demo',
      ],
    },
  },
})

----------------------------------------

TITLE: TypeScript Global Constants Declaration
DESCRIPTION: Example of declaring types for global constants in TypeScript environment definition file.

LANGUAGE: typescript
CODE:
// vite-env.d.ts
declare const __APP_VERSION__: string

----------------------------------------

TITLE: DevEnvironment Context Interface in TypeScript
DESCRIPTION: TypeScript interface definition for DevEnvironmentContext, specifying the context options for environment initialization.

LANGUAGE: typescript
CODE:
interface DevEnvironmentContext {
  hot: boolean
  transport?: HotChannel | WebSocketServer
  options?: EnvironmentOptions
  remoteRunner?: {
    inlineSourceMap?: boolean
  }
  depsOptimizer?: DepsOptimizer
}

----------------------------------------

TITLE: Accessing Environment Config in Transform Hook
DESCRIPTION: Example showing how to access environment configuration within a plugin transform hook using the environment instance.

LANGUAGE: typescript
CODE:
  transform(code, id) {
    console.log(this.environment.config.resolve.conditions)
  }

----------------------------------------

TITLE: Pruning Modules in HMR with JavaScript
DESCRIPTION: Shows how to use `hot.prune()` to register a callback that will be called when the module is no longer imported on the page, useful for cleaning up side effects.

LANGUAGE: javascript
CODE:
function setupOrReuseSideEffect() {}

setupOrReuseSideEffect()

if (import.meta.hot) {
  import.meta.hot.prune((data) => {
    // cleanup side effect
  })
}

----------------------------------------

TITLE: Invalidating Modules in HMR with JavaScript
DESCRIPTION: Shows how to use `import.meta.hot.invalidate()` within an accept callback to forcefully propagate updates to importers when a module can't handle a hot update.

LANGUAGE: javascript
CODE:
import.meta.hot.accept((module) => {
  // You may use the new module instance to decide whether to invalidate.
  if (cannotHandleUpdate(module)) {
    import.meta.hot.invalidate()
  }
})

----------------------------------------

TITLE: Vite WebSocket Proxy Configuration
DESCRIPTION: Example showing how to configure Vite with WebSocket proxy support in middleware mode using a parent HTTP server.

LANGUAGE: typescript
CODE:
import http from 'http'
import { createServer } from 'vite'

const parentServer = http.createServer()

const vite = await createServer({
  server: {
    middlewareMode: {
      server: parentServer,
    },
    proxy: {
      '/ws': {
        target: 'ws://localhost:3000',
        ws: true,
      },
    },
  },
})

parentServer.use(vite.middlewares)

----------------------------------------

TITLE: Transforming Custom File Types Plugin
DESCRIPTION: Example plugin that demonstrates how to transform custom file types in Vite using the transform hook.

LANGUAGE: javascript
CODE:
const fileRegex = /\.(my-file-ext)$/

export default function myPlugin() {
  return {
    name: 'transform-file',

    transform(src, id) {
      if (fileRegex.test(id)) {
        return {
          code: compileFileToJS(src),
          map: null, // provide source map if available
        }
      }
    },
  }
}

----------------------------------------

TITLE: Configuring package.json scripts for SSR
DESCRIPTION: This JSON snippet shows how to configure the scripts in package.json for an SSR project. It includes commands for development, client-side build, and server-side build.

LANGUAGE: json
CODE:
{
  "scripts": {
    "dev": "node server",
    "build:client": "vite build --outDir dist/client",
    "build:server": "vite build --outDir dist/server --ssr src/entry-server.js"
  }
}

----------------------------------------

TITLE: Implementing SSR-specific plugin logic
DESCRIPTION: This JavaScript snippet demonstrates how to create a Vite plugin with SSR-specific logic. It uses the 'ssr' property in the options object of the transform hook to conditionally apply SSR-specific transformations.

LANGUAGE: javascript
CODE:
export function mySSRPlugin() {
  return {
    name: 'my-ssr',
    transform(code, id, options) {
      if (options?.ssr) {
        // perform ssr-specific transform...
      }
    },
  }
}

----------------------------------------

TITLE: Structuring Vite Landing Page with Vue Components
DESCRIPTION: This snippet defines the structure of the Vite landing page using imported Vue components. It includes sections for hero, features, frameworks, community, sponsors, and getting started, with feature sections divided into two parts.

LANGUAGE: vue
CODE:
<div class="VPHome">
  <Hero/>
  <FeatureSection title="Redefining developer experience" description="Vite makes web development simple again" type="blue">
    <FeatureInstantServerStart />
    <FeatureHMR />
    <FeatureRichFeatures />
    <FeatureOptimizedBuild />
  </FeatureSection>
  <FeatureSection title="A shared foundation to build upon" type="pink" class="feature-section--flip">
    <FeatureFlexiblePlugins />
    <FeatureTypedAPI />
    <FeatureSSRSupport />
    <FeatureCI />
  </FeatureSection>
  <FrameworksSection />
  <CommunitySection />
  <SponsorSection />
  <GetStartedSection />
</div>

----------------------------------------

TITLE: Importing VitePress Team Components in Vue
DESCRIPTION: Imports necessary components from VitePress theme to create a team page layout. Also imports team member data from a local file.

LANGUAGE: javascript
CODE:
import {
  VPTeamPage,
  VPTeamPageTitle,
  VPTeamPageSection,
  VPTeamMembers
} from 'vitepress/theme'
import { core, emeriti } from './_data/team'

----------------------------------------

TITLE: Structuring Vite Team Page with Vue Components
DESCRIPTION: Creates a team page layout using VitePress components. Displays core team members and emeriti contributors with titles and descriptions.

LANGUAGE: vue
CODE:
<VPTeamPage>
  <VPTeamPageTitle>
    <template #title>Meet the Team</template>
    <template #lead>
      The development of Vite is guided by an international team, some of whom
      have chosen to be featured below.
    </template>
  </VPTeamPageTitle>
  <VPTeamMembers :members="core" />
  <VPTeamPageSection>
    <template #title>Team Emeriti</template>
    <template #lead>
      Here we honor some no-longer-active team members who have made valuable
      contributions in the past.
    </template>
    <template #members>
      <VPTeamMembers size="small" :members="emeriti" />
    </template>
  </VPTeamPageSection>
</VPTeamPage>

----------------------------------------

TITLE: Configuring ESLint in React Template
DESCRIPTION: Example of ESLint configuration in React template with properly configured rules and plugins

LANGUAGE: json
CODE:
{
  "eslintConfig": {
    "ignores": [".config/*"],
    "rules": {
      "react/jsx-no-target-blank": "off"
    }
  }
}

----------------------------------------

TITLE: TypeScript Project Configuration
DESCRIPTION: Updated TypeScript configuration for stricter type checking and module resolution

LANGUAGE: json
CODE:
{
  "compilerOptions": {
    "strict": true,
    "tsBuildInfoFile": ".tsbuildinfo",
    "useDefineForClassFields": true,
    "resolveJsonModule": true,
    "moduleResolution": "node"
  }
}

----------------------------------------

TITLE: Package Initialization Command
DESCRIPTION: Example of creating a new Vite project using package managers

LANGUAGE: bash
CODE:
# npm
npm init vite@latest

# yarn
yarn create vite

# pnpm 
pnpm dlx create-vite

----------------------------------------

TITLE: Basic Vite Project Creation Commands
DESCRIPTION: Basic commands to create a new Vite project using different package managers. Requires Node.js version 18+ or 20+.

LANGUAGE: bash
CODE:
npm create vite@latest

LANGUAGE: bash
CODE:
yarn create vite

LANGUAGE: bash
CODE:
pnpm create vite

LANGUAGE: bash
CODE:
bun create vite

----------------------------------------

TITLE: Template-Specific Vite Project Creation
DESCRIPTION: Commands to create a Vite project with a specific template and project name. Example shows Vue template usage across different package managers.

LANGUAGE: bash
CODE:
npm create vite@latest my-vue-app -- --template vue

LANGUAGE: bash
CODE:
yarn create vite my-vue-app --template vue

LANGUAGE: bash
CODE:
pnpm create vite my-vue-app --template vue

LANGUAGE: bash
CODE:
bun create vite my-vue-app --template vue

----------------------------------------

TITLE: Community Template Installation with Degit
DESCRIPTION: Commands to scaffold a project using community-maintained templates via degit, including installation and development server startup.

LANGUAGE: bash
CODE:
npx degit user/project my-project
cd my-project

npm install
npm run dev

LANGUAGE: bash
CODE:
npx degit user/project#main my-project

----------------------------------------

TITLE: Installing Project Dependencies
DESCRIPTION: Command for installing project dependencies using various package managers including npm, pnpm, or yarn.

LANGUAGE: bash
CODE:
$ npm install # or pnpm install or yarn install

----------------------------------------

TITLE: Configuring Vite for Qwik CSR Mode
DESCRIPTION: Vite configuration setup for Qwik in Client Side Rendering mode. Enables full browser-side bootstrapping of the application using the qwikVite plugin.

LANGUAGE: typescript
CODE:
export default defineConfig({
  plugins: [
    qwikVite({
      csr: true,
    }),
  ],
})

----------------------------------------

TITLE: Adding React-Specific ESLint Plugins
DESCRIPTION: Shows how to integrate React-specific lint rules using eslint-plugin-react-x and eslint-plugin-react-dom plugins. Includes configuration for TypeScript-specific React rules and DOM-specific rules.

LANGUAGE: javascript
CODE:
// eslint.config.js
import reactX from 'eslint-plugin-react-x'
import reactDom from 'eslint-plugin-react-dom'

export default tseslint.config({
  plugins: {
    // Add the react-x and react-dom plugins
    'react-x': reactX,
    'react-dom': reactDom,
  },
  rules: {
    // other rules...
    // Enable its recommended typescript rules
    ...reactX.configs['recommended-typescript'].rules,
    ...reactDom.configs.recommended.rules,
  },
})

----------------------------------------

TITLE: Installing Dependencies for Vite Project
DESCRIPTION: Command to install project dependencies using npm, pnpm, or yarn package managers.

LANGUAGE: bash
CODE:
$ npm install # or pnpm install or yarn install

----------------------------------------

TITLE: Running Vite Development Server
DESCRIPTION: Script to run the application in development mode, which starts a local server at http://localhost:5173 for viewing in the browser.

LANGUAGE: bash
CODE:
npm run dev

----------------------------------------

TITLE: Creating an External Store in Svelte with TypeScript
DESCRIPTION: This snippet demonstrates how to create a simple external store in Svelte using TypeScript. External stores are useful for retaining component state during Hot Module Replacement (HMR).

LANGUAGE: typescript
CODE:
// store.ts
// An extremely simple external store
import { writable } from 'svelte/store'
export default writable(0)

----------------------------------------

TITLE: Creating an External Store in Svelte
DESCRIPTION: This snippet demonstrates how to create a simple external store in Svelte using the writable function. External stores are useful for retaining state that should not be replaced during Hot Module Replacement (HMR).

LANGUAGE: javascript
CODE:
// store.js
// An extremely simple external store
import { writable } from 'svelte/store'
export default writable(0)

----------------------------------------

TITLE: Legacy Plugin Warning Configuration (JavaScript)
DESCRIPTION: Example showing configuration for disabling legacy polyfill warning

LANGUAGE: javascript
CODE:
plugin-legacy: warn if plugin-legacy is passed to `worker.plugins` (#19079)

----------------------------------------

TITLE: Configuring Vite Legacy Plugin
DESCRIPTION: Basic configuration example for setting up the legacy plugin in vite.config.js with browser target specifications.

LANGUAGE: javascript
CODE:
// vite.config.js
import legacy from '@vitejs/plugin-legacy'

export default {
  plugins: [
    legacy({
      targets: ['defaults', 'not IE 11'],
    }),
  ],
}

----------------------------------------

TITLE: Setting Environment Variable in .env File
DESCRIPTION: Defines a single environment variable named KEY with value 'safe'. This can be accessed within the Vite application through import.meta.env.KEY.

LANGUAGE: env
CODE:
KEY=safe

----------------------------------------

TITLE: Setting Environment Variable for Vite Project
DESCRIPTION: This snippet sets an environment variable named 'KEY' with the value 'unsafe'. It's likely used for configuration or security settings in a Vite project.

LANGUAGE: Environment Variables
CODE:
KEY=unsafe