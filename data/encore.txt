TITLE: Using HTTP Headers in API Request Parameters
DESCRIPTION: Demonstrates how to use the Header type to extract values from HTTP headers in request parameters. The 'language' field will be parsed from the 'Accept-Language' header.

LANGUAGE: typescript
CODE:
import { Header } from "encore.dev/api";

interface Params {
  language: Header<"Accept-Language">; // parsed from header
  author: string; // not a header
}

----------------------------------------

TITLE: Creating a Hello World API in Encore.go
DESCRIPTION: A Go implementation of a Hello World API using Encore.go. This example shows how to define a public API endpoint with a path parameter using Encore's comment-based annotations.

LANGUAGE: go
CODE:
package hello

//encore:api public path=/hello/:name
func World(ctx context.Context, name string) (*Response, error) {
	msg := fmt.Sprintf("Hello, %s!", name)
	return &Response{Message: msg}, nil
}

type Response struct {
	Message string
}

----------------------------------------

TITLE: Encore.ts Validation Error Response Format
DESCRIPTION: Shows the format of a 400 Bad Request response returned by Encore.ts when request validation fails. The response includes a code, message, and internal_message to help with debugging.

LANGUAGE: output
CODE:
HTTP/1.1 400 Bad Request

{
  "code": "invalid_argument",
  "message": "unable to decode request body",
  "internal_message": "Error(\"missing field name\", line: 1, column: 18)"
}

----------------------------------------

TITLE: Making Service-to-Service API Calls in Encore.ts
DESCRIPTION: Demonstrates how to call other services within an Encore.ts application using the clients module. Shows the simple function call syntax with full type safety.

LANGUAGE: typescript
CODE:
import { hello } from "~encore/clients";
export const myOtherAPI = api({}, async (): Promise<void> => {
const resp = await hello.ping({ name: "World" });
console.log(resp.message); // "Hello World!"
});

----------------------------------------

TITLE: Defining API Request and Response Schemas in Encore.go
DESCRIPTION: Demonstrates how to define the request and response data structures for an API endpoint. PingParams defines the request structure with a Name field, while PingResponse specifies the response with a Message field. The implementation formats a greeting using the provided name.

LANGUAGE: go
CODE:
package hello // service name

// PingParams is the request data for the Ping endpoint.
type PingParams struct {
    Name string
}

// PingResponse is the response data for the Ping endpoint.
type PingResponse struct {
    Message string
}

// Ping is an API endpoint that responds with a simple response.
// This is exposed as "hello.Ping".
//encore:api public
func Ping(ctx context.Context, params *PingParams) (*PingResponse, error) {
    msg := fmt.Sprintf("Hello, %s!", params.Name)
    return &PingResponse{Message: msg}, nil
}

----------------------------------------

TITLE: Implementing GetBookableSlots API endpoint in Go
DESCRIPTION: Complete implementation of a public API endpoint that retrieves available booking slots for a given date. The code handles date parsing, fetches slots for a week, and formats the response with start and end times.

LANGUAGE: go
CODE:
// Service booking keeps track of bookable slots in the calendar.
package booking

import (
	"context"
	"github.com/jackc/pgx/v5/pgtype"
	"time"
)

const DefaultBookingDuration = 1 * time.Hour

type BookableSlot struct {
	Start time.Time `json:"start"`
	End   time.Time `json:"end"`
}

type SlotsParams struct{}

type SlotsResponse struct{ Slots []BookableSlot }

//encore:api public method=GET path=/slots/:from
func GetBookableSlots(ctx context.Context, from string) (*SlotsResponse, error) {
	fromDate, err := time.Parse("2006-01-02", from)
	if err != nil {
		return nil, err
	}

	const numDays = 7

	var slots []BookableSlot
	for i := 0; i < numDays; i++ {
		date := fromDate.AddDate(0, 0, i)
		daySlots, err := bookableSlotsForDay(date)
		if err != nil {
			return nil, err
		}
		slots = append(slots, daySlots...)
	}

	return &SlotsResponse{Slots: slots}, nil
}

func bookableSlotsForDay(date time.Time) ([]BookableSlot, error) {
	// 09:00
	availStartTime := pgtype.Time{
		Valid:        true,
		Microseconds: int64(9*3600) * 1e6,
	}
	// 17:00
	availEndTime := pgtype.Time{
		Valid:        true,
		Microseconds: int64(17*3600) * 1e6,
	}

	availStart := date.Add(time.Duration(availStartTime.Microseconds) * time.Microsecond)
	availEnd := date.Add(time.Duration(availEndTime.Microseconds) * time.Microsecond)

	// Compute the bookable slots in this day, based on availability.
	var slots []BookableSlot
	start := availStart
	for {
		end := start.Add(DefaultBookingDuration)
		if end.After(availEnd) {
			break
		}
		slots = append(slots, BookableSlot{
			Start: start,
			End:   end,
		})
		start = end
	}

	return slots, nil
}

----------------------------------------

TITLE: Inserting Data with Raw SQL and Parameters in TypeScript
DESCRIPTION: This snippet shows how to insert data into a PostgreSQL database using raw SQL with parameters in Encore. It adds a new todo item with the given title and a default done status.

LANGUAGE: typescript
CODE:
await db.rawExec(
  "INSERT INTO todo_item (title, done) VALUES ($1, $2)",
  title,
  false
);

----------------------------------------

TITLE: Implementing Pagination with Query Parameters in Encore
DESCRIPTION: Example of a ListBlogPosts endpoint that accepts pagination parameters (limit and offset) as query parameters. This endpoint demonstrates how to handle optional behavior like filtering and pagination.

LANGUAGE: go
CODE:
type ListParams struct {
    Limit uint // number of blog posts to return
    Offset uint // number of blog posts to skip, for pagination
}

type ListResponse struct {
    Posts []*BlogPost
}

//encore:api public method=GET path=/blog
func ListBlogPosts(ctx context.Context, opts *ListParams) (*ListResponse, error) {
    // Use limit and offset to query database...
}

----------------------------------------

TITLE: Creating an Encore Service in TypeScript
DESCRIPTION: This snippet demonstrates how to define an Encore service by creating an encore.service.ts file that exports a service instance. The Service class is imported from encore.dev/service and initialized with a service name.

LANGUAGE: typescript
CODE:
import { Service } from "encore.dev/service";

export default new Service("my-service");

----------------------------------------

TITLE: Hello World API Definition in Go
DESCRIPTION: A simple Go REST API service that responds with a personalized greeting. It demonstrates Encore's API annotation syntax for defining public endpoints.

LANGUAGE: go
CODE:
// Service hello implements a simple hello world REST API.
package hello

import (
	"context"
)

// This is a simple REST API that responds with a personalized greeting.
//
//encore:api public path=/hello/:name
func World(ctx context.Context, name string) (*Response, error) {
	msg := "Hello, " + name + "!"
	return &Response{Message: msg}, nil
}

type Response struct {
	Message string
}

----------------------------------------

TITLE: Reusing Request Type as Response Type in Encore.ts
DESCRIPTION: Demonstrates how to reuse the same data type for both request and response in an Encore.ts API endpoint. The example shows a simple echo endpoint that returns the same data it receives.

LANGUAGE: typescript
CODE:
import { api, Header, Query } from "encore.dev/api";

interface Data {
  header: Header<"X-Header">; // this field will be read from the http header
  query: Query<string>; // this will be parsed from the '?query=...' parameter in the request url
  body: string; // this will be sent as part of the JSON body
}
// A simple API endpoint that echoes the data back.
export const echo = api(
  { method: "POST", path: "/echo" },
  async (params: Data): Promise<Data> => {
    return params; // echo the data back
  },
);

----------------------------------------

TITLE: Defining a Basic Public API Endpoint in Encore.go
DESCRIPTION: Creates a public API endpoint named 'Ping' in the 'hello' service. It takes a name parameter and returns a formatted greeting message. The endpoint is exposed as 'hello.Ping' and can be accessed by anyone on the internet.

LANGUAGE: go
CODE:
package hello // service name

//encore:api public
func Ping(ctx context.Context, params *PingParams) (*PingResponse, error) {
    msg := fmt.Sprintf("Hello, %s!", params.Name)
    return &PingResponse{Message: msg}, nil
}

----------------------------------------

TITLE: Defining Public API Endpoints in Go with Encore
DESCRIPTION: Shows how to define a public API endpoint in a Go service using Encore's API annotation. This example creates a simple Ping endpoint that accepts a name parameter and returns a greeting message.

LANGUAGE: go
CODE:
package hello // service name

//encore:api public
func Ping(ctx context.Context, params *PingParams) (*PingResponse, error) {
    msg := fmt.Sprintf("Hello, %s!", params.Name)
    return &PingResponse{Message: msg}, nil
}

----------------------------------------

TITLE: Complete API Definition with Request and Response Schemas
DESCRIPTION: Defines a complete API endpoint with interface definitions for request and response types. The 'hello' endpoint accepts a name parameter and returns a greeting message.

LANGUAGE: typescript
CODE:
-- hello.ts --
import { api } from "encore.dev/api";

// PingParams is the request data for the Ping endpoint.
interface PingParams {
  name: string;
}

// PingResponse is the response data for the Ping endpoint.
interface PingResponse {
  message: string;
}

// hello is an API endpoint that responds with a simple response.
export const hello = api(
  { method: "POST", path: "/hello" },
  async (p: PingParams): Promise<PingResponse> => {
    return { message: `Hello ${p.name}!` };
  },
);

----------------------------------------

TITLE: Hello World API Endpoint in TypeScript
DESCRIPTION: Example of defining a REST API endpoint using Encore.ts. This snippet shows how to create a GET endpoint with a path parameter that returns a simple greeting message.

LANGUAGE: typescript
CODE:
-- hello/hello.ts --
import { api } from "encore.dev/api";

export const world = api(
  { method: "GET", path: "/hello/:name", expose: true },
  async ({ name }: { name: string }): Promise<Response> => {
    return { message: `Hello ${name}!` };
  },
);

interface Response {
  message: string;
}

----------------------------------------

TITLE: Querying Data with Tagged Template Literals in TypeScript
DESCRIPTION: This example demonstrates how to query a PostgreSQL database in Encore using tagged template literals for SQL. It shows iterating through query results asynchronously.

LANGUAGE: typescript
CODE:
const allTodos = await db.query`SELECT * FROM todo_item`;
for await (const todo of allTodos) {
  // Process each todo
}

----------------------------------------

TITLE: Handling Sensitive Data with Encore Struct Tags
DESCRIPTION: Example of an API endpoint with various parameter types (header, query, body) and a sensitive field marked with encore:"sensitive". This demonstrates how to handle sensitive data that should be redacted in traces.

LANGUAGE: go
CODE:
package blog // service name
import (
	"time"
	"encore.dev/types/uuid"
)

type Updates struct {
	Author      string `json:"author,omitempty"`
	PublishTime time.Time `json:"publish_time,omitempty"`
}

// BatchUpdateParams is the request data for the BatchUpdate endpoint.
type BatchUpdateParams struct {
	Requester     string    `header:"X-Requester"`
	RequestTime   time.Time `header:"X-Request-Time"`
	CurrentAuthor string    `query:"author"`
	Updates       *Updates  `json:"updates"`
	MySecretKey   string    `encore:"sensitive"`
}

// BatchUpdateResponse is the response data for the BatchUpdate endpoint.
type BatchUpdateResponse struct {
	ServedBy   string       `header:"X-Served-By"`
	UpdatedIDs []uuid.UUID  `json:"updated_ids"`
}

//encore:api public method=POST path=/section/:sectionID/posts
func BatchUpdate(ctx context.Context, sectionID string, params *BatchUpdateParams) (*BatchUpdateResponse, error) {
	// Update blog posts for section
	return &BatchUpdateResponse{ServedBy: hostname, UpdatedIDs: ids}, nil
}

----------------------------------------

TITLE: Handling API Errors in Encore.ts
DESCRIPTION: Demonstrates how to create and throw standardized API errors using Encore.ts's APIError class. Shows both the constructor approach and shorthand methods for common error types.

LANGUAGE: typescript
CODE:
import { APIError, ErrCode } from "encore.dev/api";
throw new APIError(ErrCode.NotFound, "sprocket not found");
// shorthand version:
throw APIError.notFound("sprocket not found");

----------------------------------------

TITLE: Defining a Basic Encore Service in TypeScript
DESCRIPTION: This snippet shows how to create an Encore service by adding an encore.service.ts file that exports a service instance. The service is created by importing the Service class from encore.dev/service and calling the constructor with a service name.

LANGUAGE: typescript
CODE:
import { Service } from "encore.dev/service";

export default new Service("my-service");

----------------------------------------

TITLE: Defining a Service Struct with API Methods in Encore
DESCRIPTION: This snippet demonstrates how to define a service struct with the //encore:service annotation, implement an initialization function, and create an API endpoint as a method on the struct.

LANGUAGE: go
CODE:
//encore:service
type Service struct {
	// Add your dependencies here
}

func initService() (*Service, error) {
	// Write your service initialization code here.
}

//encore:api public
func (s *Service) MyAPI(ctx context.Context) error {
	// ...
}

----------------------------------------

TITLE: Setting Up SQL Database Connection in Encore.ts
DESCRIPTION: Demonstrates how to set up a named SQL database connection using Encore.ts's SQLDatabase class. This example creates a database instance with a migration path and provides access to the connection string.

LANGUAGE: typescript
CODE:
import { SQLDatabase } from "encore.dev/storage/sqldb";

const SiteDB = new SQLDatabase("siteDB", {
  migrations: "./migrations",
});

const connStr = SiteDB.connectionString;

----------------------------------------

TITLE: Working with HTTP Headers in Encore.go API Requests
DESCRIPTION: Shows how to map HTTP headers to struct fields using the header tag. In this example, the Language field will be populated from the Accept-Language HTTP header, while the Author field will be treated as a regular body parameter.

LANGUAGE: go
CODE:
type ListBlogPost struct {
    Language string `header:"Accept-Language"`
    Author      string // Not a header
}

----------------------------------------

TITLE: Defining a Basic API Endpoint in Encore.ts
DESCRIPTION: Creates a basic API endpoint named 'ping' that accepts POST requests. The endpoint takes a PingParams object as input and returns a PingResponse object with a greeting message.

LANGUAGE: typescript
CODE:
// inside the hello.ts file
import { api } from "encore.dev/api";

export const ping = api(
  { method: "POST" },
  async (p: PingParams): Promise<PingResponse> => {
    return { message: `Hello ${p.name}!` };
  },
);

----------------------------------------

TITLE: Defining Nested Request and Response Structs in Encore
DESCRIPTION: This example demonstrates how to define a struct with nested fields and various tags like header, query, and json. It shows how these fields are unmarshalled from HTTP requests and marshalled to responses.

LANGUAGE: go
CODE:
type NestedRequestResponse struct {
	Header string `header:"X-Header"`// this field will be read from the http header
	Query  string `query:"query"`// this field will be read from the query string
	Body1  string `json:"body1"`
	Nested struct {
	    Header2 string `header:"X-Header2"`// this field will be read from the body
		Query2  string `query:"query2"`// this field will be read from the body
		Body2   string `json:"body2"`
    } `json:"nested"`
}

----------------------------------------

TITLE: Directory Structure for Encore.go Microservices
DESCRIPTION: The directory structure for an Encore.go application with two services (hello and world). Each service is represented by a Go package with its own files.

LANGUAGE: plaintext
CODE:
/my-app
├── encore.app          // ... and other top-level project files
│
├── hello               // hello service (a Go package)
│   ├── hello.go        // hello service code
│   └── hello_test.go   // tests for hello service
│
└── world               // world service (a Go package)
    └── world.go        // world service code

----------------------------------------

TITLE: Defining Query Parameters in Encore API Endpoints
DESCRIPTION: Example of defining a struct with query parameters in an Encore API. The PageLimit field is explicitly marked as a query parameter, while the Author field follows default behavior for HTTP methods.

LANGUAGE: go
CODE:
type ListBlogPost struct {
    PageLimit  int `query:"limit"` // always a query parameter
    Author     string              // query if GET, HEAD or DELETE, otherwise body parameter
}

----------------------------------------

TITLE: Creating a Fallback Route
DESCRIPTION: Shows how to define a fallback route that handles requests when no other endpoint matches. This is useful for gradually migrating existing services to Encore.

LANGUAGE: typescript
CODE:
// Route all requests to the existing HTTP router if no other endpoint matches.
export const fallback = api.raw(
    { expose: true, method: "*", path: "/!path" },
    async (req, resp) {
        // Call old router
    }
)

----------------------------------------

TITLE: Using Nested Request and Response Types with Field Tags in Encore.go
DESCRIPTION: Demonstrates how to define complex request/response structures with field tags. Shows usage of header, query, and json tags for HTTP parameter binding. Note that header and query tags only work at the root level, while nested fields are always parsed from the request body.

LANGUAGE: go
CODE:
type NestedRequestResponse struct {
	Header string `header:"X-Header"`// this field will be read from the http header
	Query  string `query:"query"`// this field will be read from the query string
	Body1  string `json:"body1"`
	Nested struct {
	    Header2 string `header:"X-Header2"`// this field will be read from the body
		Query2  string `query:"query2"`// this field will be read from the body
		Body2   string `json:"body2"`
    } `json:"nested"`
}

----------------------------------------

TITLE: Directory Structure for Large Encore Application with Multiple Systems
DESCRIPTION: Shows how to organize a large Encore application with several systems, each containing multiple services. This example is for a Trello clone with trello, premium, and user systems.

LANGUAGE: plaintext
CODE:
/my-trello-clone
├── encore.app                  // ... and other top-level project files
│
├── trello                      // trello system (a directory)
│   ├── board                   // board service (a Go package)
│   │   └── board.go            // board service code
│   └── card                    // card service (a Go package)
│       └── card.go             // card service code
│
├── premium                     // premium system (a directory)
│   ├── payment                 // payment service (a Go package)
│   │   └── payment.go          // payment service code
│   └── subscription            // subscription service (a Go package)
│       └── subscription.go     // subscription service code
│
└── usr                         // usr system (a directory)
    ├── org                     // org service (a Go package)
    │   └── org.go              // org service code
    └── user                    // user service (a Go package)
        └── user.go             // user service code

----------------------------------------

TITLE: Defining Secrets Structure in Go
DESCRIPTION: Shows how to define a secrets struct in Go where all fields are of type string. This structure is used by Encore to validate that all required secrets are set before running or deploying the application.

LANGUAGE: go
CODE:
var secrets struct {
    SSHPrivateKey string    // ed25519 private key for SSH server
    GitHubAPIToken string   // personal access token for deployments
    // ...
}

----------------------------------------

TITLE: Creating Fallback Routes for Unmatched Requests in Encore.go
DESCRIPTION: Shows how to implement fallback routes that capture requests not matched by other endpoints. This is useful when migrating existing services to Encore, allowing gradual migration while routing remaining endpoints to the existing HTTP router.

LANGUAGE: go
CODE:
//encore:service
type Service struct {
	oldRouter *gin.Engine // existing HTTP router
}

// Route all requests to the existing HTTP router if no other endpoint matches.
//encore:api public raw path=/!fallback
func (s *Service) Fallback(w http.ResponseWriter, req *http.Request) {
    s.oldRouter.ServeHTTP(w, req)
}

----------------------------------------

TITLE: Creating SQL Database with Migrations in Encore.ts
DESCRIPTION: Demonstrates how to create and configure a SQL database in Encore.ts, including setting up the initial schema migration. This requires importing SQLDatabase from encore.dev/storage/sqldb and defining a migration file with SQL commands.

LANGUAGE: TypeScript
CODE:
import { SQLDatabase } from "encore.dev/storage/sqldb";

const db = new SQLDatabase("todo", {
  migrations: "./migrations",
});

-- todo/migrations/1_create_table.up.sql --
CREATE TABLE todo_item (
  id BIGSERIAL PRIMARY KEY,
  title TEXT NOT NULL,
  done BOOLEAN NOT NULL DEFAULT false
);

----------------------------------------

TITLE: Defining Path Parameters in Encore.go API Endpoints
DESCRIPTION: Demonstrates how to define path parameters in API routes using the path field in the encore:api annotation. Shows both named parameters (:id) and wildcard parameters (*path) which are bound to function parameters of matching names.

LANGUAGE: go
CODE:
// GetBlogPost retrieves a blog post by id.
//encore:api public method=GET path=/blog/:id/*path
func GetBlogPost(ctx context.Context, id int, path string) (*BlogPost, error) {
    // Use id to query database...
}

----------------------------------------

TITLE: Testing URL Shortening and Retrieval in TypeScript with Vitest
DESCRIPTION: A unit test for the URL shortener API that verifies the complete flow: shortening a URL, storing it in the database, and then retrieving the original URL with the short ID. It uses Vitest as the testing framework and ensures the returned URL matches the original.

LANGUAGE: typescript
CODE:
import { describe, expect, test } from "vitest";
import { get, shorten } from "./url";

describe("shorten", () => {
  test("getting a shortened url should give back the original", async () => {
    const resp = await shorten({ url: "https://example.com" });
    const url = await get({ id: resp.id });
    expect(url.url).toBe("https://example.com");
  });
});

----------------------------------------

TITLE: Implementing Caching Middleware in Encore
DESCRIPTION: Defines a middleware function that implements caching for API endpoints tagged with 'cache'. The middleware checks if a response is cached for the given path and returns it if available, otherwise passes the request to the next middleware.

LANGUAGE: go
CODE:
//encore:middleware target=tag:cache
func CachingMiddleware(req middleware.Request, next middleware.Next) middleware.Response {
    data := req.Data()
    cacheKey := data.Path
    if cached, err := loadFromCache(cacheKey, data.API.ResponseType); err == nil && cached != nil {
        return middleware.Response{Payload: cached}
    }
    return next(req)
}

----------------------------------------

TITLE: Validating Optional Fields in Encore.ts
DESCRIPTION: This example shows how to define and validate optional fields in request schemas, which can be either the specified type or undefined.

LANGUAGE: typescript
CODE:
interface Request {
  name?: string;
}

export const myEndpoint = api(
  { expose: true, method: "POST", path: "/body" },
  async (req: Request) => {
    // req.name is a string or undefined
  },
);

----------------------------------------

TITLE: Consuming a Streaming Endpoint from Another Service in Encore
DESCRIPTION: This example demonstrates how to import a client for another service ('chat'), call a streaming endpoint from that service, send messages to the stream, and handle incoming messages using async iterators. The code shows a typical pattern for bidirectional communication between services.

LANGUAGE: typescript
CODE:
import { chat } from "~encore/clients"; // import 'chat' service

export const myOtherAPI = api({}, async (): Promise<void> => {
  const stream = await chat.myStreamingEndpoint();

  // send a message to the chat service over the stream
  await stream.send({ msg: "data" });

  for await (const msg of stream) {
    // handle incoming message
  }
});

----------------------------------------

TITLE: Making Service-to-Service API Calls in Encore.ts
DESCRIPTION: This code demonstrates how to import a service and call its API endpoint as a function in Encore.ts. The example imports the 'hello' service and calls its 'ping' endpoint, showing how service-to-service calls maintain type safety and simplicity.

LANGUAGE: typescript
CODE:
import { hello } from "~encore/clients"; // import 'hello' service

export const myOtherAPI = api({}, async (): Promise<void> => {
  const resp = await hello.ping({ name: "World" });
  console.log(resp.message); // "Hello World!"
});

----------------------------------------

TITLE: Defining Basic API Endpoint with Encore.ts
DESCRIPTION: Creates a simple POST API endpoint with typed request parameters and response. Uses the api function from Encore.ts with method configuration and strong TypeScript typing.

LANGUAGE: typescript
CODE:
import { api } from "encore.dev/api";
interface PingParams {
name: string;
}
interface PingResponse {
message: string;
}
export const ping = api(
{ method: "POST" },
async (p: PingParams): Promise<PingResponse> => {
return { message: Hello ${p.name}! };
}
);

----------------------------------------

TITLE: Defining Body Parameters in Encore API Endpoints
DESCRIPTION: Example of defining body parameters in an Encore API. The Subject field uses a custom JSON field name, and both fields are treated as body parameters for HTTP methods other than GET, HEAD, or DELETE.

LANGUAGE: go
CODE:
type CreateBlogPost struct {
    Subject    string `json:"limit"` // query if GET, HEAD or DELETE, otherwise body parameter
    Author     string                // query if GET, HEAD or DELETE, otherwise body parameter
}

----------------------------------------

TITLE: Implementing Clerk Authentication Handler in Go
DESCRIPTION: Complete implementation of an Encore auth handler using Clerk. This code verifies tokens from Clerk, retrieves user data, and provides authenticated user information to the Encore application.

LANGUAGE: go
CODE:
package auth

import (
	"context"
	"encore.dev/beta/auth"
	"encore.dev/beta/errs"
	"github.com/clerkinc/clerk-sdk-go/clerk"
)

var secrets struct {
	ClientSecretKey string
}

// Service struct definition.
// Learn more: encore.dev/docs/primitives/services-and-apis/service-structs
//
//encore:service
type Service struct {
	client clerk.Client
}

// initService is automatically called by Encore when the service starts up.
func initService() (*Service, error) {
	client, err := clerk.NewClient(secrets.ClientSecretKey)
	if err != nil {
		return nil, err
	}
	return &Service{client: client}, nil
}

type UserData struct {
	ID                    string               `json:"id"`
	Username              *string              `json:"username"`
	FirstName             *string              `json:"first_name"`
	LastName              *string              `json:"last_name"`
	ProfileImageURL       string               `json:"profile_image_url"`
	PrimaryEmailAddressID *string              `json:"primary_email_address_id"`
	EmailAddresses        []clerk.EmailAddress `json:"email_addresses"`
}

// The `encore:authhandler` annotation tells Encore to run this function for all
// incoming API call that requires authentication.
// Learn more: encore.dev/docs/develop/auth#the-auth-handler
//
//encore:authhandler
func (s *Service) AuthHandler(ctx context.Context, token string) (auth.UID, *UserData, error) {
	// verify the session
	sessClaims, err := s.client.VerifyToken(token)
	if err != nil {
		return "", nil, &errs.Error{
			Code:    errs.Unauthenticated,
			Message: "invalid token",
		}
	}

	user, err := s.client.Users().Read(sessClaims.Claims.Subject)
	if err != nil {
		return "", nil, &errs.Error{
			Code:    errs.Internal,
			Message: err.Error(),
		}
	}

	userData := &UserData{
		ID:                    user.ID,
		Username:              user.Username,
		FirstName:             user.FirstName,
		LastName:              user.LastName,
		ProfileImageURL:       user.ProfileImageURL,
		PrimaryEmailAddressID: user.PrimaryEmailAddressID,
		EmailAddresses:        user.EmailAddresses,
	}

	return auth.UID(user.ID), userData, nil
}

----------------------------------------

TITLE: Defining API Endpoints with Path Parameters in Encore.go
DESCRIPTION: Example showing how to define an API endpoint with path parameters using the //encore:api annotation. It demonstrates both named parameters (:id) and wildcard paths (*path).

LANGUAGE: go
CODE:
//encore:api public method=GET path=/blog/:id/*path
func GetBlogPost(ctx context.Context, id int, path string)

----------------------------------------

TITLE: Combining Multiple Data Sources in Encore.ts Request Schema
DESCRIPTION: Shows how to combine data from different sources (path parameters, query parameters, HTTP headers, and request body) in the same request schema for an Encore.ts API endpoint.

LANGUAGE: typescript
CODE:
import { Header, Query, api } from "encore.dev/api";

interface Request {
  // Required path parameter. Parsed from the request URL.
  id: number;

  // Optional query parameter. Parsed from the request URL.
  limit?: Query<number>;

  // Custom header that must be set. Parsed from the HTTP headers.
  myHeader: Header<"X-My-Header">;

  // Required enum. Parsed from the request body.
  type: "sprocket" | "widget";
}

export const myEndpoint = api(
  { expose: true, method: "POST", path: "/user/:id" },
  async ({ id, limit, myHeader, type }: Request) => {
    // ...
  },
);

----------------------------------------

TITLE: Implementing Logto JWT Authentication Handler in Encore
DESCRIPTION: A complete implementation of an Encore authentication handler that validates Logto JWT tokens. It includes configuration loading, JWT claims validation, and user ID extraction from tokens.

LANGUAGE: go
CODE:
package auth

import (
	"context"
	"time"

	"encore.dev/beta/auth"
	"encore.dev/beta/errs"
	"encore.dev/config"
	"github.com/MicahParks/keyfunc/v3"
	"github.com/golang-jwt/jwt/v5"
)

// Configuration variables for authentication
type LogtoAuthConfig struct {
	// The issuer URL
	Issuer config.String
	// URL to fetch JSON Web Key Set (JWKS)
	JwksUri config.String
	// Expected audience for the JWT
	ApiResourceIndicator config.String
	// Expected client ID in the token claims
	ClientId config.String
}

var authConfig *LogtoAuthConfig = config.Load[*LogtoAuthConfig]()

// RequiredClaims defines the expected structure of JWT claims
// Extends the standard JWT claims with a custom ClientID field
type RequiredClaims struct {
	ClientID string `json:"client_id"`
	jwt.RegisteredClaims
}

// AuthHandler validates JWT tokens and extracts the user ID
// Implements Encore's authentication handler interface
//
//encore:authhandler
func AuthHandler(ctx context.Context, token string) (auth.UID, error) {
	// Fetch and parse the JWKS (JSON Web Key Set) from the identity provider
	jwks, err := keyfunc.NewDefaultCtx(ctx, []string{authConfig.JwksUri()})
	if err != nil {
		return "", &errs.Error{
			Code:    errs.Internal,
			Message: "failed to fetch JWKS",
		}
	}

	// Parse and validate the JWT token with required claims and validation options
	parsedToken, err := jwt.ParseWithClaims(
		token,
		&RequiredClaims{},
		jwks.Keyfunc,
		// Expect the token to be intended for this API resource
		jwt.WithAudience(authConfig.ApiResourceIndicator()),
		// Expect the token to be issued by this issuer
		jwt.WithIssuer(authConfig.Issuer()),
		// Allow some leeway for clock skew
		jwt.WithLeeway(time.Minute*10),
	)

	// Check if there were any errors during token parsing
	if err != nil {
		return "", &errs.Error{
			Code:    errs.Unauthenticated,
			Message: "invalid token",
		}
	}

	// Verify that the client ID in the token matches the expected client ID
	if parsedToken.Claims.(*RequiredClaims).ClientID != authConfig.ClientId() {
		return "", &errs.Error{
			Code:    errs.Unauthenticated,
			Message: "invalid token",
		}
	}

	// Extract the user ID (subject) from the token claims
	userId, err := parsedToken.Claims.GetSubject()
	if err != nil {
		return "", &errs.Error{
			Code:    errs.Unauthenticated,
			Message: "invalid token",
		}
	}

	// Return the user ID as an Encore auth.UID
	return auth.UID(userId), nil
}

----------------------------------------

TITLE: Creating Middleware in Encore.ts
DESCRIPTION: Demonstrates how to create middleware for API endpoints in Encore.ts using the middleware helper. The example shows a middleware function that executes logic before and after the request handler, with specific targeting for authenticated endpoints.

LANGUAGE: typescript
CODE:
import { middleware } from "encore.dev/api";

export default new Service("myService", {
    middlewares: [
        middleware({ target: { auth: true } }, async (req, next) => {
            // Pre-handler logic
            const resp = await next(req);
            // Post-handler logic
            return resp
        })
    ]
});

----------------------------------------

TITLE: Initializing Knex.js with Encore SQLDatabase Connection
DESCRIPTION: Demonstrates how to set up a database connection using Encore's SQLDatabase and configure Knex.js to use it. The example includes defining a Site interface, creating a query builder for the 'site' table, and implementing basic database operations like select, where, and insert.

LANGUAGE: typescript
CODE:
// site.ts
import { SQLDatabase } from "encore.dev/storage/sqldb";
import knex from "knex";

// Create SQLDatabase instance with migrations configuration
const SiteDB = new SQLDatabase("siteDB", {
  migrations: "./migrations",
});

// Initialize Knex with the database connection string
const orm = knex({
  client: "pg",
  connection: SiteDB.connectionString,
});

// Define the Site interface
export interface Site {
  id: number;
  url: string;
}

// Query builder for the "site" table
const Sites = () => orm<Site>("site");

// Example queries

// Query all sites
await Sites().select();

// Query a site by id
await Sites().where("id", id).first();

// Insert a new site
await Sites().insert({ url: params.url });

----------------------------------------

TITLE: Defining a Public API Endpoint with Encore
DESCRIPTION: Defines a basic public API endpoint function 'Foo' using Encore's annotation system. The function takes a context and returns an error, serving as a minimal API endpoint implementation.

LANGUAGE: go
CODE:
package basic

import "context"

//encore:api public
func Foo(ctx context.Context) error { return nil }

----------------------------------------

TITLE: Implementing Basic Middleware in an Encore.ts Service
DESCRIPTION: Example of creating a middleware that runs for endpoints requiring authentication. This middleware demonstrates the pattern of processing a request before and after the API handler executes.

LANGUAGE: typescript
CODE:
import { middleware } from "encore.dev/api";

export default new Service("myService", {
    middlewares: [
        middleware({ target: { auth: true } }, async (req, next) => {
            // do something before the api handler
            const resp = await next(req);
            // do something after the api handler
            return resp
        })
    ]
});

----------------------------------------

TITLE: Implementing Service Methods with Injected Dependencies in Go
DESCRIPTION: This snippet shows how to define API endpoints as methods on a service struct, utilizing the injected dependencies. The Send method uses the sendgridClient field to send emails.

LANGUAGE: go
CODE:
//encore:api private
func (s *Service) Send(ctx context.Context, p *SendParams) error {
	// ... use s.sendgridClient to send emails ...
}

----------------------------------------

TITLE: Mocking Dependencies in Go Tests with Encore Service Structs
DESCRIPTION: This snippet shows how to create test instances of a service with mocked dependencies. This approach allows for isolated testing of service logic without relying on external services.

LANGUAGE: go
CODE:
func TestFoo(t *testing.T) {
    svc := &Service{sendgridClient: &myMockClient{}}
    // ...
}

----------------------------------------

TITLE: Implementing Middleware as Service Methods in Encore
DESCRIPTION: This example demonstrates how to define middleware as a method on a Dependency Injection struct declared with '//encore:service'. It shows the integration between Encore's service architecture and middleware functionality.

LANGUAGE: go
CODE:
//encore:service
type Service struct{}

//encore:middleware target=all
func (s *Service) MyMiddleware(req middleware.Request, next middleware.Next) middleware.Response {
	// ...
}

----------------------------------------

TITLE: Implementing Incident Management Service in Go with Encore
DESCRIPTION: Main implementation of the incidents service that provides endpoints for listing, creating, and acknowledging incidents. It connects to the PostgreSQL database and integrates with the schedules and slack services for automated notifications and incident assignment.

LANGUAGE: go
CODE:
// Service incidents reports, assigns and acknowledges incidents.
package incidents

import (
	"context"
	"encore.app/schedules"
	"encore.app/slack"
	"encore.app/users"
	"encore.dev/beta/errs"
	"encore.dev/storage/sqldb"
	"fmt"
	"time"
)

// Define a database named 'incidents', using the database migrations
// in the "./migrations" folder. Encore automatically provisions,
// migrates, and connects to the database.
var db = sqldb.NewDatabase("incidents", sqldb.DatabaseConfig{
	Migrations: "./migrations",
})

// This struct holds multiple Incidents structs
type Incidents struct {
	Items []Incident
}

// This is a Go struct representing our PostgreSQL schema for `incidents`
type Incident struct {
	Id             int32
	Body           string
	CreatedAt      time.Time
	Acknowledged   bool
	AcknowledgedAt *time.Time
	Assignee       *users.User
}

//encore:api public method=GET path=/incidents
func List(ctx context.Context) (*Incidents, error) {
	rows, err := db.Query(ctx, `
		SELECT id, assigned_user_id, body, created_at, acknowledged_at
		FROM incidents
		WHERE acknowledged_at IS NULL
	`)
	if err != nil {
		return nil, err
	}
	return RowsToIncidents(ctx, rows)
}

//encore:api public method=PUT path=/incidents/:id/acknowledge
func Acknowledge(ctx context.Context, id int32) (*Incident, error) {
	eb := errs.B().Meta("incidentId", id)
	rows, err := db.Query(ctx, `
		UPDATE incidents
		SET acknowledged_at = NOW()
		WHERE acknowledged_at IS NULL
		  AND id = $1
		RETURNING id, assigned_user_id, body, created_at, acknowledged_at
	`, id)
	if err != nil {
		return nil, err
	}

	incidents, err := RowsToIncidents(ctx, rows)
	if err != nil {
		return nil, err
	}
	if incidents.Items == nil {
		return nil, eb.Code(errs.NotFound).Msg("no incident found").Err()
	}

	incident := &incidents.Items[0]
	_ = slack.Notify(ctx, &slack.NotifyParams{
		Text: fmt.Sprintf("Incident #%d assigned to %s %s <@%s> has been acknowledged:\n%s", incident.Id, incident.Assignee.FirstName, incident.Assignee.LastName, incident.Assignee.SlackHandle, incident.Body),
	})

	return incident, err
}

//encore:api public method=POST path=/incidents
func Create(ctx context.Context, params *CreateParams) (*Incident, error) {
	// check who is on-call
	schedule, err := schedules.ScheduledNow(ctx)

	incident := Incident{}
	if schedule != nil {
		incident.Assignee = &schedule.User
	}

	var row *db.Row
	if schedule != nil {
		// Someone is on-call
		row = db.QueryRow(ctx, `
			INSERT INTO incidents (assigned_user_id, body)
			VALUES ($1, $2)
			RETURNING id, body, created_at
		`, &schedule.User.Id, params.Body)
	} else {
		// Nobody is on-call
		row = db.QueryRow(ctx, `
			INSERT INTO incidents (body)
			VALUES ($1)
			RETURNING id, body, created_at
		`, params.Body)
	}

	if err = row.Scan(&incident.Id, &incident.Body, &incident.CreatedAt); err != nil {
		return nil, err
	}

	var text string
	if incident.Assignee != nil {
		text = fmt.Sprintf("Incident #%d created and assigned to %s %s <@%s>\n%s", incident.Id, incident.Assignee.FirstName, incident.Assignee.LastName, incident.Assignee.SlackHandle, incident.Body)
	} else {
		text = fmt.Sprintf("Incident #%d created and unassigned\n%s", incident.Id, incident.Body)
	}
	_ = slack.Notify(ctx, &slack.NotifyParams{Text: text})

	return &incident, nil
}

type CreateParams struct {
	Body string
}

// Helper to take a db.Rows instance and convert it into a list of Incidents
func RowsToIncidents(ctx context.Context, rows *db.Rows) (*Incidents, error) {
	eb := errs.B()

	defer rows.Close()

	var incidents []Incident
	for rows.Next() {
		var incident = Incident{}
		var assignedUserId *int32
		if err := rows.Scan(&incident.Id, &assignedUserId, &incident.Body, &incident.CreatedAt, &incident.AcknowledgedAt); err != nil {
			return nil, eb.Code(errs.Unknown).Msgf("could not scan: %v", err).Err()
		}
		if assignedUserId != nil {
			user, err := users.Get(ctx, *assignedUserId)
			if err != nil {
				return nil, eb.Code(errs.NotFound).Msgf("could not retrieve user for incident %v", assignedUserId).Err()
			}
			incident.Assignee = user
		}
		incident.Acknowledged = incident.AcknowledgedAt != nil
		incidents = append(incidents, incident)
	}

	return &Incidents{Items: incidents}, nil
}

----------------------------------------

TITLE: Handling Authentication Errors in Go
DESCRIPTION: This snippet shows how to properly handle and return authentication errors using Encore's built-in error package. It returns a standardized Unauthenticated error that will be properly communicated to API clients.

LANGUAGE: go
CODE:
import "encore.dev/beta/errs"

//encore:authhandler
func AuthHandler(ctx context.Context, token string) (auth.UID, error) {
    return "", &errs.Error{
        Code: errs.Unauthenticated,
        Message: "invalid token",
    }
}

----------------------------------------

TITLE: Defining a POST API Endpoint in Encore.ts
DESCRIPTION: Creates a POST HTTP endpoint at the '/api' path. This endpoint is configured to be publicly accessible and accepts a Request object containing limit, myHeader, and type parameters. The implementation section is a placeholder for business logic.

LANGUAGE: typescript
CODE:
export const myEndpoint = api<Request, Response>(
  { expose: true, method: "POST", path: "/api" },
  async ({ limit, myHeader, type }) => {
    // Implementation
  }
);

----------------------------------------

TITLE: Creating a Hello World API Endpoint in Encore.ts
DESCRIPTION: This code snippet demonstrates how to define a simple GET API endpoint using Encore.ts. It creates a '/hello/:name' route that accepts a name parameter and returns a greeting message. The snippet shows Encore's declarative approach for API definition with automatic request validation.

LANGUAGE: TypeScript
CODE:
import { api } from "encore.dev/api";

export const get = api(
  { expose: true, method: "GET", path: "/hello/:name" },
  async ({ name }: { name: string }): Promise<Response> => {
    const msg = `Hello ${name}!`;
    return { message: msg };
  }
);

interface Response {
  message: string;
}

----------------------------------------

TITLE: Using Cloud-Specific Services with Encore Metadata API
DESCRIPTION: This snippet demonstrates how to use the appMeta() function to determine the current cloud environment and choose an appropriate backend service accordingly. The example shows writing audit events to different data warehouses based on the cloud provider.

LANGUAGE: typescript
CODE:
import { appMeta } from "encore.dev";

// Emit an audit event.
async function audit(userID: string, event: Record<string, any>) {
  const cloud = appMeta().environment.cloud;
  switch (cloud) {
    case "aws":
      return writeIntoRedshift(userID, event);
    case "gcp":
      return writeIntoBigQuery(userID, event);
    case "local":
      return writeIntoFile(userID, event);
    default:
      throw new Error(`unknown cloud: ${cloud}`);
  }
}

----------------------------------------

TITLE: Implementing Dependency Injection in Encore Services
DESCRIPTION: Shows how to structure an Encore service using dependency injection. The service initializer creates and injects dependencies, making the code more testable and modular.

LANGUAGE: go
CODE:
package email

//encore:service
type Service struct {
    sendgridClient *sendgrid.Client
}

func initService() (*Service, error) {
    client, err := sendgrid.NewClient()
    if err != nil {
        return nil, err
    }
    return &Service{sendgridClient: client}, nil
}

----------------------------------------

TITLE: Defining a Raw Endpoint in Encore.ts with TypeScript
DESCRIPTION: This snippet shows how to define a raw endpoint using the api.raw function in Encore.ts. Unlike standard api endpoints, raw endpoints provide direct access to the HTTP request and response objects, similar to Node.js http module and Express.js.

LANGUAGE: typescript
CODE:
import { api } from "encore.dev/api";

export const myRawEndpoint = api.raw(
  { expose: true, path: "/raw", method: "GET" },
  async (req, resp) => {
    resp.writeHead(200, { "Content-Type": "text/plain" });
    resp.end("Hello, raw world!");
  },
);

----------------------------------------

TITLE: Integrating Drizzle ORM with Encore.ts
DESCRIPTION: Shows how to set up and use Drizzle ORM with an Encore.ts SQL database. This example initializes a database connection with Drizzle ORM and performs a sample query against a users table.

LANGUAGE: typescript
CODE:
import { api } from "encore.dev/api";
import { SQLDatabase } from "encore.dev/storage/sqldb";
import { drizzle } from "drizzle-orm/node-postgres";
import { users } from "./schema";

const db = new SQLDatabase("test", {
  migrations: {
    path: "migrations",
    source: "drizzle",
  },
});

const orm = drizzle(db.connectionString);
await orm.select().from(users);

----------------------------------------

TITLE: Implementing URL Shortening Service in Go with Encore
DESCRIPTION: The main service file that defines the URL shortening functionality, including a REST endpoint to shorten URLs and generate random IDs. The initial implementation creates short IDs but doesn't persist them.

LANGUAGE: go
CODE:
// Service url takes URLs, generates random short IDs, and stores the URLs in a database.
package url

import (
	"context"
	"crypto/rand"
	"encoding/base64"
)

type URL struct {
	ID  string // short-form URL id
	URL string // complete URL, in long form
}

type ShortenParams struct {
	URL string // the URL to shorten
}

// Shorten shortens a URL.
//encore:api public method=POST path=/url
func Shorten(ctx context.Context, p *ShortenParams) (*URL, error) {
	id, err := generateID()
	if err != nil {
		return nil, err
	}
	return &URL{ID: id, URL: p.URL}, nil
}

// generateID generates a random short ID.
func generateID() (string, error) {
	var data [6]byte // 6 bytes of entropy
	if _, err := rand.Read(data[:]); err != nil {
		return "", err
	}
	return base64.RawURLEncoding.EncodeToString(data[:]), nil
}

----------------------------------------

TITLE: Integrating Drizzle ORM with Encore.ts
DESCRIPTION: Shows how to set up and use Drizzle ORM with an Encore.ts SQL database. This example initializes a database connection with Drizzle ORM and performs a sample query against a users table.

LANGUAGE: typescript
CODE:
import { api } from "encore.dev/api";
import { SQLDatabase } from "encore.dev/storage/sqldb";
import { drizzle } from "drizzle-orm/node-postgres";
import { users } from "./schema";

const db = new SQLDatabase("test", {
  migrations: {
    path: "migrations",
    source: "drizzle",
  },
});

const orm = drizzle(db.connectionString);
await orm.select().from(users);

----------------------------------------

TITLE: Sample GraphQL Schema for Books API
DESCRIPTION: This GraphQL schema defines a Query type with a books field that returns an array of Book objects. Each Book has title and author fields, both of which are required strings.

LANGUAGE: graphql
CODE:
type Query {
  books: [Book]
}

type Book {
  title: String!
  author: String!
}

----------------------------------------

TITLE: Implementing CRUD Operations for Site Service
DESCRIPTION: TypeScript implementation of the site service with CRUD endpoints to manage monitored websites using Knex.js for database interactions.

LANGUAGE: typescript
CODE:
import { api } from "encore.dev/api";
import { SQLDatabase } from "encore.dev/storage/sqldb";
import knex from "knex";

// Site describes a monitored site.
export interface Site {
  id: number; // ID is a unique ID for the site.
  url: string; // URL is the site's URL.
}

// AddParams are the parameters for adding a site to be monitored.
export interface AddParams {
  // URL is the URL of the site. If it doesn't contain a scheme
  // (like "http:" or "https:") it defaults to "https:".
  url: string;
}

// Add a new site to the list of monitored websites.
export const add = api(
  { expose: true, method: "POST", path: "/site" },
  async (params: AddParams): Promise<Site> => {
    const site = (await Sites().insert({ url: params.url }, "*"))[0];
    return site;
  },
);

// Get a site by id.
export const get = api(
  { expose: true, method: "GET", path: "/site/:id", auth: false },
  async ({ id }: { id: number }): Promise<Site> => {
    const site = await Sites().where("id", id).first();
    return site ?? Promise.reject(new Error("site not found"));
  },
);

// Delete a site by id.
export const del = api(
  { expose: true, method: "DELETE", path: "/site/:id" },
  async ({ id }: { id: number }): Promise<void> => {
    await Sites().where("id", id).delete();
  },
);

export interface ListResponse {
  sites: Site[]; // Sites is the list of monitored sites
}

// Lists the monitored websites.
export const list = api(
  { expose: true, method: "GET", path: "/site" },
  async (): Promise<ListResponse> => {
    const sites = await Sites().select();
    return { sites };
  },
);

// Define a database named 'site', using the database migrations
// in the "./migrations" folder. Encore automatically provisions,
// migrates, and connects to the database.
const SiteDB = new SQLDatabase("site", {
  migrations: "./migrations",
});

const orm = knex({
  client: "pg",
  connection: SiteDB.connectionString,
});

const Sites = () => orm<Site>("site");

----------------------------------------

TITLE: Using Encore Client for API Requests in TypeScript
DESCRIPTION: TypeScript example showing how to initialize an Encore client and make type-safe API requests. It demonstrates calling a GetNote endpoint and handling the strongly-typed response.

LANGUAGE: typescript
CODE:
import Client, { Environment, Local } from "src/client.ts";

// Making request to locally running backend...
const client = new Client(Local);
// or to a specific deployed environment
// const client = new Client(Environment("staging"));

// Calling APIs as typesafe functions 🌟
const response = await client.note.GetNote("note-uuid");
console.log(response.id);
console.log(response.cover_url);
console.log(response.text);

----------------------------------------

TITLE: Implementing an Auth Handler with Custom User Data in Go
DESCRIPTION: This snippet demonstrates how to create an authentication handler that returns both a user ID and custom user data. The auth handler validates a token and returns structured user information that can be accessed throughout the application.

LANGUAGE: go
CODE:
import "encore.dev/beta/auth"

// Data can be named whatever you prefer (but must be exported).
type Data struct {
    Username string
    // ...
}

// AuthHandler can be named whatever you prefer (but must be exported).
//encore:authhandler
func AuthHandler(ctx context.Context, token string) (auth.UID, *Data, error) {
    // Validate the token and look up the user id and user data,
    // for example by calling Firebase Auth.
}

----------------------------------------

TITLE: Throwing API Errors in Encore with TypeScript
DESCRIPTION: Shows how to throw an APIError in TypeScript with Encore, demonstrating both the standard constructor approach and the shorthand method for common error types.

LANGUAGE: typescript
CODE:
import { APIError, ErrCode } from "encore.dev/api";

throw new APIError(ErrCode.NotFound, "sprocket not found");

// or as a shorthand you can also write:
throw APIError.notFound("sprocket not found");

----------------------------------------

TITLE: Creating a Topic with At-Least-Once Delivery in Go
DESCRIPTION: This snippet demonstrates how to create a Pub/Sub topic for user signup events with at-least-once delivery guarantee. It defines a SignupEvent struct and creates a topic that can be published to from any service in the application.

LANGUAGE: go
CODE:
package user

import "encore.dev/pubsub"

type SignupEvent struct{ UserID int }

var Signups = pubsub.NewTopic[*SignupEvent]("signups", pubsub.TopicConfig{
    DeliveryGuarantee: pubsub.AtLeastOnce,
})

----------------------------------------

TITLE: Creating an Ordered PubSub Topic in TypeScript
DESCRIPTION: Shows how to create a PubSub topic with ordered delivery using the orderingAttribute property. This example creates a CartEvent topic where messages are ordered by shoppingCartID.

LANGUAGE: typescript
CODE:
import { Topic, Attribute } from "encore.dev/pubsub";

export interface CartEvent {
    shoppingCartID: Attribute<number>;
    event: string;
}

export const cartEvents = new Topic<CartEvent>("cart-events", {
    deliveryGuarantee: "at-least-once",
    orderingAttribute: "shoppingCartID",
})

----------------------------------------

TITLE: Inserting Data with Tagged Template Literals in TypeScript
DESCRIPTION: This example demonstrates how to insert data into a PostgreSQL database using tagged template literals. It inserts a new todo item with a title and sets the done status to false.

LANGUAGE: typescript
CODE:
await db.exec`
  INSERT INTO todo_item (title, done)
  VALUES (${title}, false)
`;

----------------------------------------

TITLE: Connecting to External PostgreSQL Database in Go with Encore
DESCRIPTION: This snippet demonstrates how to create a dedicated package for lazily initializing a connection pool to an external PostgreSQL database. It uses Encore's secrets manager to store the database password securely and implements a thread-safe lazy initialization pattern using the syncutil package.

LANGUAGE: plaintext
CODE:
postgresql://user:password@externaldb-do-user-1234567-0.db.ondigitalocean.com:25010/externaldb?sslmode=require

LANGUAGE: go
CODE:
package externaldb

import (
    "context"
    "fmt"

    "github.com/jackc/pgx/v4/pgxpool"
    "go4.org/syncutil"
)

// Get returns a database connection pool to the external database.
// It is lazily created on first use.
func Get(ctx context.Context) (*pgxpool.Pool, error) {
    // Attempt to setup the database connection pool if it hasn't
    // already been successfully setup.
    err := once.Do(func() error {
        var err error
        pool, err = setup(ctx)
        return err
    })
    return pool, err
}

var (
    // once is like sync.Once except it re-arms itself on failure
    once syncutil.Once
    // pool is the successfully created database connection pool,
    // or nil when no such pool has been setup yet.
    pool *pgxpool.Pool
)

var secrets struct {
    // ExternalDBPassword is the database password for authenticating
    // with the external database hosted on DigitalOcean.
    ExternalDBPassword string
}

// setup attempts to set up a database connection pool.
func setup(ctx context.Context) (*pgxpool.Pool, error) {
    connString := fmt.Sprintf("postgresql://%s:%s@externaldb-do-user-1234567-0.db.ondigitalocean.com:25010/externaldb?sslmode=require",
        "user", secrets.ExternalDBPassword)
    return pgxpool.Connect(ctx, connString)
}

----------------------------------------

TITLE: Creating an Ordered Topic in Go with Encore PubSub
DESCRIPTION: This example shows how to create an ordered topic for cart events where messages with the same shopping cart ID are delivered in order. It demonstrates setting an ordering attribute and publishing multiple events that maintain ordering based on the cart_id field.

LANGUAGE: go
CODE:
package example

import (
	"context"
	"encore.dev/pubsub"
)

type CartEvent struct {
	ShoppingCartID int `pubsub-attr:"cart_id"`
	Event          string
}

var CartEvents = pubsub.NewTopic[*CartEvent]("cart-events", pubsub.TopicConfig{
	DeliveryGuarantee: pubsub.AtLeastOnce,
	OrderingAttribute: "cart_id",
})

func Example(ctx context.Context) error {
	// These are delivered in order as they all have the same shopping cart ID
	CartEvents.Publish(ctx, &CartEvent{ShoppingCartID: 1, Event: "item_added"})
	CartEvents.Publish(ctx, &CartEvent{ShoppingCartID: 1, Event: "checkout_started"})
	CartEvents.Publish(ctx, &CartEvent{ShoppingCartID: 1, Event: "checkout_completed"})

	// This event may be delivered at any point as it has a different shopping cart ID
	CartEvents.Publish(ctx, &CartEvent{ShoppingCartID: 2, Event: "item_added"})
}

----------------------------------------

TITLE: Implementing Concurrent Site Checking with errgroup in Go
DESCRIPTION: Creates a CheckAll endpoint that retrieves all tracked sites and checks them concurrently using errgroup with a limit of 8 concurrent operations. This function is designed to be called by a cron job to regularly monitor all sites.

LANGUAGE: go
CODE:
import "golang.org/x/sync/errgroup"

// CheckAll checks all sites.
//
//encore:api public method=POST path=/checkall
func CheckAll(ctx context.Context) error {
	// Get all the tracked sites.
	resp, err := site.List(ctx)
	if err != nil {
		return err
	}

	// Check up to 8 sites concurrently.
	g, ctx := errgroup.WithContext(ctx)
	g.SetLimit(8)
	for _, site := range resp.Sites {
		site := site // capture for closure
		g.Go(func() error {
			return check(ctx, site)
		})
	}
	return g.Wait()
}

----------------------------------------

TITLE: Creating a StreamIn API for Data Upload
DESCRIPTION: Example of implementing a StreamIn API endpoint that receives data streams from clients. It includes handling connection handshakes, processing incoming messages, and returning a response when the stream is complete.

LANGUAGE: typescript
CODE:
import { api } from "encore.dev/api";
import log from "encore.dev/log";

// Used to pass initial data, optional.
interface Handshake {
  user: string;
}

// What the clients sends over the stream.
interface Message {
  data: string;
  done: boolean;
}

// Returned when the stream is done, optional.
interface Response {
  success: boolean;
}

export const uploadStream = api.streamIn<Handshake, Message, Response>(
  { path: "/upload", expose: true },
  async (handshake, stream) => {
    const chunks: string[] = [];
    try {
      // The stream object is an AsyncIterator that yields incoming messages.
      for await (const data of stream) {
        chunks.push(data.data);
        // Stop the stream if the client sends a "done" message
        if (data.done) break;
      }
    } catch (err) {
      log.error(`Upload error by ${handshake.user}:`, err);
      return { success: false };
    }
    log.info(`Upload complete by ${handshake.user}`);
    return { success: true };
  },
);

----------------------------------------

TITLE: Validating Union Fields in Encore.ts
DESCRIPTION: This example shows how to define and validate union fields in request schemas, which can be one of several specified types.

LANGUAGE: typescript
CODE:
interface Request {
  value: string | number | boolean;
}

export const myEndpoint = api(
  { expose: true, method: "POST", path: "/body" },
  async (req: Request) => {
    // req.value is a string, number, or boolean
  },
);

----------------------------------------

TITLE: Defining SQL Database Schema with Migrations
DESCRIPTION: Shows how to create the initial database schema using SQL migration files. This example creates a todo_item table with fields for id, title, and completion status.

LANGUAGE: sql
CODE:
CREATE TABLE todo_item (
    id BIGSERIAL PRIMARY KEY,
    title TEXT NOT NULL,
    done BOOLEAN NOT NULL DEFAULT false
);

----------------------------------------

TITLE: Setting Up the Site Service with GORM and Dependency Injection
DESCRIPTION: Core service file implementing Encore's dependency injection to create a site monitoring service. It initializes a GORM database connection and defines the service structure.

LANGUAGE: go
CODE:
-- site/service.go --
// Service site keeps track of which sites to monitor.
package site

import (
	"encore.dev/storage/sqldb"
	"gorm.io/driver/postgres"
	"gorm.io/gorm"
)

//encore:service
type Service struct {
	db *gorm.DB
}

// Define a database named 'site', using the database migrations
// in the "./migrations" folder. Encore automatically provisions,
// migrates, and connects to the database.
var db = sqldb.NewDatabase("site", sqldb.DatabaseConfig{
	Migrations: "./migrations",
})

// initService initializes the site service.
// It is automatically called by Encore on service startup.
func initService() (*Service, error) {
	db, err := gorm.Open(postgres.New(postgres.Config{
		Conn: db.Stdlib(),
	}))
	if err != nil {
		return nil, err
	}
	return &Service{db: db}, nil
}

----------------------------------------

TITLE: Returning Error Example in Go
DESCRIPTION: Example of returning an errs.Error from an Encore API endpoint with a NotFound error code and a descriptive message. This will result in a HTTP 404 response with the JSON-serialized error.

LANGUAGE: go
CODE:
return &errs.Error{
	Code: errs.NotFound,
	Message: "sprocket not found",
}

----------------------------------------

TITLE: Implementing a Slack Notification Service in Go
DESCRIPTION: Creates a service to send notifications to Slack using incoming webhooks. The service accepts message text as a parameter and sends it to a pre-configured Slack channel. It uses HTTP POST requests and handles potential errors.

LANGUAGE: go
CODE:
package slack

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
)

type NotifyParams struct {
	// Text is the Slack message text to send.
	Text string `json:"text"`
}

// Notify sends a Slack message to a pre-configured channel using a
// Slack Incoming Webhook (see https://api.slack.com/messaging/webhooks).
//
//encore:api private
func Notify(ctx context.Context, p *NotifyParams) error {
	reqBody, err := json.Marshal(p)
	if err != nil {
		return err
	}
	req, err := http.NewRequestWithContext(ctx, "POST", secrets.SlackWebhookURL, bytes.NewReader(reqBody))
	if err != nil {
		return err
	}
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode >= 400 {
		body, _ := io.ReadAll(resp.Body)
		return fmt.Errorf("notify slack: %s: %s", resp.Status, body)
	}
	return nil
}

var secrets struct {
	// SlackWebhookURL defines the Slack webhook URL to send
	// uptime notifications to.
	SlackWebhookURL string
}

----------------------------------------

TITLE: Defining Encore API with Invalid Header Parameter Type in Go
DESCRIPTION: This code snippet defines an Encore API endpoint with a nested struct type used in a header parameter, which is not supported. The API function accepts a context and a pointer to a Params struct that contains an unsupported nested struct type marked with a header tag.

LANGUAGE: go
CODE:
package svc

import (
	"context"
	"encore.dev/types/uuid"
)

type Nested struct {
    Baz string
}

type Params struct {
    Foo uuid.UUID
    Bar *Nested `header:"X-Bar"`
}

//encore:api public method=POST
func Str(ctx context.Context, p *Params) error { return nil }

----------------------------------------

TITLE: Initializing SQLDatabase and Drizzle ORM Connection in TypeScript
DESCRIPTION: Sets up a SQLDatabase instance and initializes Drizzle ORM with the connection string. This snippet shows how to configure database migrations and perform a basic query to retrieve all users.

LANGUAGE: typescript
CODE:
// database.ts
import { api } from "encore.dev/api";
import { SQLDatabase } from "encore.dev/storage/sqldb";
import { drizzle } from "drizzle-orm/node-postgres";
import { users } from "./schema";

// Create SQLDatabase instance with migrations configuration
const db = new SQLDatabase("test", {
  migrations: {
    path: "migrations",
    source: "drizzle",
  },
});

// Initialize Drizzle ORM with the connection string
const orm = drizzle(db.connectionString);

// Query all users
await orm.select().from(users);

----------------------------------------

TITLE: Defining Secrets in TypeScript with Encore
DESCRIPTION: Shows how to define a secret in Encore TypeScript applications using the secret function from encore.dev/config. This creates a top-level variable that can be used to securely access sensitive data like API tokens.

LANGUAGE: ts
CODE:
import { secret } from "encore.dev/config";

// Personal access token for deployments
const githubToken = secret("GitHubAPIToken");

// Then, resolve the secret value by calling `githubToken()`.

----------------------------------------

TITLE: Integrating PostgreSQL Database with URL Shortener API
DESCRIPTION: Updates the URL shortener API to store shortened URLs in a PostgreSQL database. This implementation creates a database connection, generates random IDs, and inserts the URL mapping into the database.

LANGUAGE: typescript
CODE:
import { api } from "encore.dev/api";
import { SQLDatabase } from "encore.dev/storage/sqldb";
import { randomBytes } from "node:crypto";

// 'url' database is used to store the URLs that are being shortened.
const db = new SQLDatabase("url", { migrations: "./migrations" });

interface URL {
    id: string; // short-form URL id
    url: string; // complete URL, in long form
}

interface ShortenParams {
    url: string; // the URL to shorten
}

// Shortens a URL.
export const shorten = api(
    { method: "POST", path: "/url", expose: true },
    async ({ url }: ShortenParams): Promise<URL> => {
      const id = randomBytes(6).toString("base64url");
      await db.exec`
        INSERT INTO url (id, original_url)
        VALUES (${id}, ${url})
      `;
      return { id, url };
    },
  );

----------------------------------------

TITLE: Railway Deployment Automation Script
DESCRIPTION: JavaScript script that uses Railway's GraphQL API to trigger a new deployment of the service. This script is executed by GitHub Actions when a new Docker image is pushed.

LANGUAGE: javascript
CODE:
const TOKEN = process.argv.slice(2)[0];
const ENVIRONMENT_ID = "<your environment id>"
const SERVICE_ID = "<your service id>"

const resp = await fetch('https://backboard.railway.com/graphql/v2', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'authorization': `Bearer ${TOKEN}`,
  },
  body: JSON.stringify({
    query: `
      mutation ServiceInstanceRedeploy {
          serviceInstanceRedeploy(
              environmentId: "${ENVIRONMENT_ID}"
              serviceId: "${SERVICE_ID}"
          )
      }`
  }),
})

const data = await resp.json()

if (data.errors) {
  console.error(data.errors)
  throw new Error('Failed to redeploy service')
}

console.log(data)

----------------------------------------

TITLE: Defining GraphQL Schema for Book Service
DESCRIPTION: GraphQL schema that defines the API structure including Query and Mutation types. It includes a Book type, queries to fetch books, and a mutation to add new books with appropriate response types.

LANGUAGE: graphql
CODE:
type Query {
  books: [Book]
}

type Book {
  title: String!
  author: String!
}

type AddBookMutationResponse {
  code: String!
  success: Boolean!
  message: String!
  book: Book
}

type Mutation {
  addBook(title: String!, author: String!): AddBookMutationResponse
}

----------------------------------------

TITLE: Querying PostgreSQL Databases in Encore
DESCRIPTION: Shows how to query data from a PostgreSQL database using sqldb.QueryRow in an Encore application. The example demonstrates reading a single todo item and scanning the result into a struct.

LANGUAGE: go
CODE:
var item struct {
    ID int64
    Title string
    Done bool
}
err := tododb.QueryRow(ctx, `
    SELECT id, title, done
    FROM todo_item
    LIMIT 1
`).Scan(&item.ID, &item.Title, &item.Done)

----------------------------------------

TITLE: Implementing Website Check Functionality
DESCRIPTION: TypeScript implementation of the check endpoint for the monitor service. It retrieves site information, pings the URL, and records the check result in the database.

LANGUAGE: typescript
CODE:
import { api } from "encore.dev/api";
import { SQLDatabase } from "encore.dev/storage/sqldb";
import { ping } from "./ping";
import { site } from "~encore/clients";

// Check checks a single site.
export const check = api(
  { expose: true, method: "POST", path: "/check/:siteID" },
  async (p: { siteID: number }): Promise<{ up: boolean }> => {
    const s = await site.get({ id: p.siteID });
    const { up } = await ping({ url: s.url });
    await MonitorDB.exec`
        INSERT INTO checks (site_id, up, checked_at)
        VALUES (${s.id}, ${up}, NOW())
    `;
    return { up };
  },
);

// Define a database named 'monitor', using the database migrations
// in the "./migrations" folder. Encore automatically provisions,
// migrates, and connects to the database.
export const MonitorDB = new SQLDatabase("monitor", {
  migrations: "./migrations",
});

----------------------------------------

TITLE: Uploading Files to Object Storage in Go
DESCRIPTION: Implements an HTTP endpoint for uploading profile pictures to an Object Storage bucket. The function receives the file via a POST request and stores it with the user's ID as the key.

LANGUAGE: go
CODE:
package user

import (
		"context"
		"io"
		"net/http"

		"encore.dev/beta/auth"
		"encore.dev/beta/errs"
		"encore.dev/storage/objects"
)

var ProfilePictures = objects.NewBucket("profile-pictures", objects.BucketConfig{})

//encore:api auth raw method=POST path=/upload-profile-picture
func UploadProfilePicture(w http.ResponseWriter, req *http.Request) {
	// Store the user's profile picture with their user id as the key.
	userID, _ := auth.UserID()
	key := string(userID) // We store the profile

	writer := ProfilePictures.Upload(req.Context(), key)
	_, err := io.Copy(writer, req.Body)
	if err != nil {
		// If something went wrong with copying data, abort the upload and return an error.
		writer.Abort()
		errs.HTTPError(w, err)
		return
	}

	if err := writer.Close(); err != nil {
		errs.HTTPError(w, err)
		return
	}

	// All good! Return a 200 OK.
	w.WriteHeader(http.StatusOK)
}

----------------------------------------

TITLE: Multi-Service Application Directory Structure
DESCRIPTION: This example shows how to organize a distributed system with multiple services in Encore, where each service has its own directory with an encore.service.ts file and related components like migrations and API definitions.

LANGUAGE: plaintext
CODE:
/my-app
├── encore.app                       // ... and other top-level project files
│
├── hello                            // hello service (directory)
│   ├── migrations                   // hello service db migrations (directory)
│   │   └── 1_create_table.up.sql    // hello service db migration
│   ├── encore.service.ts            // hello service definition
│   ├── hello.ts                     // hello service APIs
│   └── hello_test.ts                // tests for hello service
│
└── world                            // world service (directory)
│   ├── encore.service.ts            // world service definition
    └── world.ts                     // world service APIs

----------------------------------------

TITLE: Validating Enum Fields with TypeScript Enums in Encore.ts
DESCRIPTION: This example demonstrates how to validate enum fields using TypeScript's enum type in request schemas.

LANGUAGE: typescript
CODE:
enum PostType {
  BlogPost = "BLOG_POST",
  Comment = "COMMENT"
}

interface Schema {
  type: PostType,
}

----------------------------------------

TITLE: Configuring Prisma Client with Encore.ts Database Connection
DESCRIPTION: This snippet demonstrates how to define an SQL database in Encore.ts and integrate it with Prisma. It shows how to create a database instance, configure Prisma migrations, and set up the Prisma client using Encore's connection string.

LANGUAGE: typescript
CODE:
import { SQLDatabase } from "encore.dev/storage/sqldb";
import { PrismaClient } from "@prisma/client";

// Define a database named 'encore_prisma_test', using the database migrations
// in the "./prisma/migrations" folder (where prisma will generate their migrations).
// Set `source` to `prisma` to let Encore know that the migrations are generated by Prisma.
const DB = new SQLDatabase('encore_prisma_test', {
  migrations: {
    path: './prisma/migrations',
    source: 'prisma',
  },
});

// Setup prisma client with connection string
const prisma = new PrismaClient({
  datasources: {
    db: {
      url: DB.connectionString,
    },
  },
});

// Select all users
const allUsers = prisma.user.findMany();

----------------------------------------

TITLE: Creating a Hello World API in Encore.ts
DESCRIPTION: A simple TypeScript example showing how to create an HTTP GET endpoint that takes a name parameter and returns a greeting message. This demonstrates Encore.ts's declarative API definition pattern.

LANGUAGE: typescript
CODE:
import { api } from "encore.dev/api";

export const get = api(
  { expose: true, method: "GET", path: "/hello/:name" },
  async ({ name }: { name: string }): Promise<Response> => {
    const msg = `Hello ${name}!`;
    return { message: msg };
  }
);

interface Response {
  message: string;
}

----------------------------------------

TITLE: Creating a StreamInOut API for Bidirectional Communication
DESCRIPTION: Example of implementing a StreamInOut API endpoint that enables bidirectional communication between client and server, suitable for chat applications or other interactive features.

LANGUAGE: typescript
CODE:
import { api } from "encore.dev/api";

interface InMessage {
  // ...
}

interface OutMessage {
  // ...
}

export const ChatStream = api.streamInOut<InMessage, OutMessage>(
  { path: "/chat", expose: true },
  async (stream) => {
    for await (const chatMessage of stream) {
      // Respond to the message by sending something back
      await stream.send({ /* ... */ })
    }
  }
);

----------------------------------------

TITLE: Implementing Auth Handler and Authentication Endpoints in Go
DESCRIPTION: Defines an Encore service with endpoints for login, callback, logout, and profile retrieval, as well as an auth handler for token validation.

LANGUAGE: go
CODE:
package auth

import (
	"context"
	"net/url"

	"encore.dev/beta/auth"
	"encore.dev/beta/errs"
	"github.com/coreos/go-oidc/v3/oidc"
)

// Service struct definition.
// Learn more: encore.dev/docs/primitives/services-and-apis/service-structs
//
//encore:service
type Service struct {
	auth *Authenticator
}

// initService is automatically called by Encore when the service starts up.
func initService() (*Service, error) {
	authenticator, err := New()
	if err != nil {
		return nil, err
	}
	return &Service{auth: authenticator}, nil
}

type LoginResponse struct {
	State       string `json:"state"`
	AuthCodeURL string `json:"auth_code_url"`
}

//encore:api public method=POST path=/auth/login
func (s *Service) Login(ctx context.Context) (*LoginResponse, error) {
	state, err := generateRandomState()
	if err != nil {
		return nil, &errs.Error{
			Code:    errs.Internal,
			Message: err.Error(),
		}
	}

	return &LoginResponse{
		State: state,
		// add the audience to the auth code url
		AuthCodeURL: s.auth.AuthCodeURL(state),
	}, nil
}

type CallbackRequest struct {
	Code string `json:"code"`
}

type CallbackResponse struct {
	Token string `json:"token"`
}

//encore:api public method=POST path=/auth/callback
func (s *Service) Callback(
	ctx context.Context,
	req *CallbackRequest,
) (*CallbackResponse, error) {

	// Exchange an authorization code for a token.
	token, err := s.auth.Exchange(ctx, req.Code)
	if err != nil {
		return nil, &errs.Error{
			Code:    errs.PermissionDenied,
			Message: "Failed to convert an authorization code into a token.",
		}
	}

	idToken, err := s.auth.VerifyIDToken(ctx, token)
	if err != nil {
		return nil, &errs.Error{
			Code:    errs.Internal,
			Message: "Failed to verify ID Token.",
		}
	}

	var profile map[string]interface{}
	if err := idToken.Claims(&profile); err != nil {
		return nil, &errs.Error{
			Code:    errs.Internal,
			Message: err.Error(),
		}
	}

	return &CallbackResponse{
		Token: token.Extra("id_token").(string),
	}, nil
}

type LogoutResponse struct {
	RedirectURL string `json:"redirect_url"`
}

//encore:api public method=GET path=/auth/logout
func (s *Service) Logout(ctx context.Context) (*LogoutResponse, error) {
	logoutUrl, err := url.Parse("https://" + cfg.Domain() + "/v2/logout")
	if err != nil {
		return nil, &errs.Error{
			Code:    errs.Internal,
			Message: err.Error(),
		}
	}

	returnTo, err := url.Parse(cfg.LogoutURL())
	if err != nil {
		return nil, &errs.Error{
			Code:    errs.Internal,
			Message: err.Error(),
		}
	}

	parameters := url.Values{}
	parameters.Add("returnTo", returnTo.String())
	parameters.Add("client_id", cfg.ClientID())
	logoutUrl.RawQuery = parameters.Encode()

	return &LogoutResponse{
		RedirectURL: logoutUrl.String(),
	}, nil
}

type ProfileData struct {
	Email   string `json:"email"`
	Picture string `json:"picture"`
}

// The `encore:authhandler` annotation tells Encore to run this function for all 
// incoming API call that requires authentication.
// Learn more: encore.dev/docs/develop/auth#the-auth-handler
//
//encore:authhandler
func (s *Service) AuthHandler(
	ctx context.Context,
	token string,
) (auth.UID, *ProfileData, error) {
	oidcConfig := &oidc.Config{
		ClientID: s.auth.ClientID,
	}

	t, err := s.auth.Verifier(oidcConfig).Verify(ctx, token)
	if err != nil {
		return "", nil, &errs.Error{
			Code:    errs.Unauthenticated,
			Message: "invalid token",
		}
	}

	var profile map[string]interface{}
	if err := t.Claims(&profile); err != nil {
		return "", nil, &errs.Error{
			Code:    errs.Internal,
			Message: err.Error(),
		}
	}

	// Extract profile data returned from the identity provider.
	// auth0.com/docs/manage-users/user-accounts/user-profiles/user-profile-structure
	profileData := &ProfileData{
		Email:   profile["email"].(string),
		Picture: profile["picture"].(string),
	}

	return auth.UID(profile["sub"].(string)), profileData, nil
}

// Endpoints annotated with `auth` are public and requires authentication
// Learn more: encore.dev/docs/primitives/apis#access-controls
//
//encore:api auth method=GET path=/profile
func GetProfile(ctx context.Context) (*ProfileData, error) {
	return auth.Data().(*ProfileData), nil
}

----------------------------------------

TITLE: Calling Service APIs Between Encore Services
DESCRIPTION: Demonstrates how to call APIs between services in an Encore application. Services can be imported and their endpoints called directly as Go functions, with automatic type safety and serialization.

LANGUAGE: go
CODE:
import "encore.app/hello" // import service

//encore:api public
func MyOtherAPI(ctx context.Context) error {
    resp, err := hello.Ping(ctx, &hello.PingParams{Name: "World"})
    if err == nil {
        log.Println(resp.Message) // "Hello, World!"
    }
    return err
}

----------------------------------------

TITLE: Implementing URL Retrieval Endpoint in TypeScript with Encore
DESCRIPTION: This code adds a GET endpoint to retrieve original URLs by their short IDs. It extends the URL shortener API by defining the 'get' function, which queries the database for a stored URL based on the provided ID and returns it or throws a 'not found' error.

LANGUAGE: typescript
CODE:
import { api, APIError } from "encore.dev/api";
import { SQLDatabase } from "encore.dev/storage/sqldb";
import { randomBytes } from "node:crypto";

// 'url' database is used to store the URLs that are being shortened.
const db = new SQLDatabase("url", { migrations: "./migrations" });

interface URL {
    id: string; // short-form URL id
    url: string; // complete URL, in long form
}

interface ShortenParams {
    url: string; // the URL to shorten
}

// Shortens a URL.
export const shorten = api(
    { method: "POST", path: "/url", expose: true },
    async ({ url }: ShortenParams): Promise<URL> => {
      const id = randomBytes(6).toString("base64url");
      await db.exec`
        INSERT INTO url (id, original_url)
        VALUES (${id}, ${url})
      `;
      return { id, url };
    },
  );

  // Get retrieves the original URL for the id.
export const get = api(
    { expose: true, auth: false, method: "GET", path: "/url/:id" },
    async ({ id }: { id: string }): Promise<URL> => {
      const row = await db.queryRow`
          SELECT original_url FROM url WHERE id = ${id}
      `;
      if (!row) throw APIError.notFound("url not found");
      return { id, url: row.original_url };
    }
  );

----------------------------------------

TITLE: Serving Templates from Dynamic Paths in Encore.ts
DESCRIPTION: This example demonstrates how to serve template files based on the request path using EJS in Encore.ts. It retrieves the path parameter from the current request, renders the corresponding template file, and serves the HTML response with the appropriate content type.

LANGUAGE: typescript
CODE:
import { api } from "encore.dev/api";
import { APICallMeta, currentRequest } from "encore.dev";
import ejs, { Options } from "ejs";

const BASE_PATH = "./template/views";
const ejsOptions: Options = { views: [BASE_PATH] };

export const servePathTemplate = api.raw(
  { expose: true, path: "/!path", method: "GET" },
  async (req, resp) => {
    const { path } = (currentRequest() as APICallMeta).pathParams;
    const viewPath = `${BASE_PATH}/${path ?? "index"}.html`;
    const html = await ejs.renderFile(viewPath, ejsOptions);
    resp.setHeader("content-type", "text/html");
    resp.end(html);
  },
);

----------------------------------------

TITLE: Inserting Data into SQL Database with Encore
DESCRIPTION: Example function for inserting data into a PostgreSQL database using Encore's database abstraction. This demonstrates parameterized query execution with the tododb reference.

LANGUAGE: go
CODE:
func insert(ctx context.Context, id, title string, done bool) error {
    _, err := tododb.Exec(ctx, `
        INSERT INTO todo_item (id, title, done)
        VALUES ($1, $2, $3)
    `, id, title, done)
    return err
}

----------------------------------------

TITLE: Implementing Apollo GraphQL Server with Encore.ts Raw Endpoint
DESCRIPTION: This snippet shows how to create a GraphQL API using Apollo Server and Encore.ts raw endpoints. It initializes an Apollo server, handles HTTP requests, and processes GraphQL operations through a custom endpoint exposed at /graphql.

LANGUAGE: typescript
CODE:
import { HeaderMap } from "@apollo/server";
import { api } from "encore.dev/api";
const { ApolloServer, gql } = require("apollo-server");
import { json } from "node:stream/consumers";

// Type definition schema
const typeDefs = gql`
  ...
`;

// Resolver functions
const resolvers = {
  // ...
};

const server = new ApolloServer({ typeDefs, resolvers });

await server.start();

export const graphqlAPI = api.raw(
  { expose: true, path: "/graphql", method: "*" },
  async (req, res) => {
    // Make sure the Apollo server is started
    server.assertStarted("/graphql");

    // Extract headers in a format that Apollo understands
    const headers = new HeaderMap();
    for (const [key, value] of Object.entries(req.headers)) {
      if (value !== undefined) {
        headers.set(key, Array.isArray(value) ? value.join(", ") : value);
      }
    }

    // Get response from Apollo server
    const httpGraphQLResponse = await server.executeHTTPGraphQLRequest({
      httpGraphQLRequest: {
        headers,
        method: req.method!.toUpperCase(),
        body: await json(req),
        search: new URLSearchParams(req.url ?? "").toString(),
      },
      context: async () => {
        return { req, res };
      },
    });

    // Set headers
    for (const [key, value] of httpGraphQLResponse.headers) {
      res.setHeader(key, value);
    }

    // Set status code
    res.statusCode = httpGraphQLResponse.status || 200;

    // Write response if it's complete
    if (httpGraphQLResponse.body.kind === "complete") {
      res.end(httpGraphQLResponse.body.string);
      return;
    }

    // Write response in chunks if it's async
    for await (const chunk of httpGraphQLResponse.body.asyncIterator) {
      res.write(chunk);
    }
    res.end();
  },
);

----------------------------------------

TITLE: Inserting Data into PostgreSQL with Encore
DESCRIPTION: Demonstrates how to insert data into a PostgreSQL database using sqldb.Exec in an Encore application. The example shows a helper function for inserting todo items into the previously defined schema.

LANGUAGE: go
CODE:
-- todo/insert.go --
// insert inserts a todo item into the database.
func insert(ctx context.Context, id, title string, done bool) error {
	_, err := tododb.Exec(ctx, `
		INSERT INTO todo_item (id, title, done)
		VALUES ($1, $2, $3)
	`, id, title, done)
	return err
}

LANGUAGE: go
CODE:
-- todo/db.go --
package todo

// Create the todo database and assign it to the "tododb" variable
var tododb = sqldb.NewDatabase("todo", sqldb.DatabaseConfig{
  Migrations: "./migrations",
})

// Then, query the database using db.QueryRow, db.Exec, etc.

LANGUAGE: sql
CODE:
-- todo/migrations/1_create_table.up.sql --
CREATE TABLE todo_item (
  id BIGSERIAL PRIMARY KEY,
  title TEXT NOT NULL,
  done BOOLEAN NOT NULL DEFAULT false
  -- etc...
);

----------------------------------------

TITLE: Setting Cookies in API Responses with Encore.go
DESCRIPTION: Demonstrates how to set cookies in API responses by using the header tag with the Set-Cookie header name. This example shows a login endpoint that returns a session cookie which can later be read using structured auth data.

LANGUAGE: go
CODE:
type LoginResponse struct {
    SessionID string `header:"Set-Cookie"`
}

//encore:api public method=POST path=/login
func Login(ctx context.Context) (*LoginResponse, error) {
    return &LoginResponse{SessionID: "session=123"}, nil
}

----------------------------------------

TITLE: Checking Environment Type in Encore Applications
DESCRIPTION: This example shows how to use appMeta() to check the current environment type and adjust application behavior accordingly. The sample code demonstrates skipping email verification in test and development environments while sending verification emails in production.

LANGUAGE: typescript
CODE:
import { appMeta } from "encore.dev";

export const signup = api(
  { expose: true },
  async (params: SignupParams): Promise<SignupResponse> => {
    // more code...

    // If this is a testing environment, skip sending the verification email.
    switch (appMeta().environment.type) {
      case "test":
      case "development":
        await markEmailVerified(userID);
        break;
      default:
        await sendVerificationEmail(userID);
        break;
    }

    // more code...
  },
);

----------------------------------------

TITLE: Defining a Raw HTTP Webhook Endpoint in Encore.go
DESCRIPTION: This code demonstrates how to define a raw endpoint in Encore.go that provides direct access to the HTTP request and response objects. It uses the `//encore:api public raw` annotation to indicate this is a raw endpoint, and follows Go's standard HTTP handler signature. This pattern is particularly useful for implementing webhook receivers.

LANGUAGE: go
CODE:
package service

import "net/http"

// Webhook receives incoming webhooks from Some Service That Sends Webhooks.
//encore:api public raw
func Webhook(w http.ResponseWriter, req *http.Request) {
    // ... operate on the raw HTTP request ...
}

----------------------------------------

TITLE: Validating Boolean Fields in Encore.ts
DESCRIPTION: This example shows how to validate boolean fields in request schemas using Encore.ts.

LANGUAGE: typescript
CODE:
interface Schema {
  isHuman:  boolean;
}

----------------------------------------

TITLE: Implementing Schedules Service in Go
DESCRIPTION: Implementation of a schedules service with HTTP endpoints for creating, listing, and retrieving schedules. The code includes database operations, validation, and error handling for managing user schedules within the incident management system.

LANGUAGE: go
CODE:
// Service schedules implements schedules to answer who should be assigned to an incident.
package schedules

import (
	"context"
	"errors"
	"time"

	"encore.app/users"
	"encore.dev/beta/errs"
	"encore.dev/storage/sqldb"
)

// Define a database named 'schedules', using the database migrations
// in the "./migrations" folder. Encore automatically provisions,
// migrates, and connects to the database.
var db = sqldb.NewDatabase("schedules", sqldb.DatabaseConfig{
	Migrations: "./migrations",
})

// This struct holds multiple Schedule structs
type Schedules struct {
	Items []Schedule
}

// This is a Go struct representing our PostgreSQL schema for `schedules`
type Schedule struct {
	Id   int32
	User users.User
	Time TimeRange
}

// As we use time ranges in our schedule, we created a generic TimeRange struct
type TimeRange struct {
	Start time.Time
	End   time.Time
}

//encore:api public method=POST path=/users/:userId/schedules
func Create(ctx context.Context, userId int32, timeRange TimeRange) (*Schedule, error) {
	eb := errs.B().Meta("userId", userId, "timeRange", timeRange)
	// check for existing overlapping schedules
	if schedule, err := ScheduledAt(ctx, timeRange.Start.String()); schedule != nil && err == nil {
		return nil, eb.Code(errs.InvalidArgument).Cause(err).Msg("schedule already exists within this start timestamp").Err()
	}
	if schedule, err := ScheduledAt(ctx, timeRange.End.String()); schedule != nil && err == nil {
		return nil, eb.Code(errs.InvalidArgument).Cause(err).Msg("schedule already exists within this end timestamp").Err()
	}

	// check user exists
	user, err := users.Get(ctx, userId)
	if err != nil {
		return nil, eb.Code(errs.Unavailable).Cause(err).Msg("failed to get user").Err()
	}

	schedule := Schedule{User: *user, Time: TimeRange{}}
	err = db.QueryRow(
		ctx,
		`INSERT INTO schedules (user_id, start_time, end_time) VALUES ($1, $2, $3) RETURNING id, start_time, end_time`,
		userId, timeRange.Start, timeRange.End,
	).Scan(&schedule.Id, &schedule.Time.Start, &schedule.Time.End)
	if err != nil {
		return nil, eb.Code(errs.Unavailable).Cause(err).Msg("failed to insert schedule").Err()
	}

	return &schedule, nil
}

//encore:api public method=GET path=/scheduled
func ScheduledNow(ctx context.Context) (*Schedule, error) {
	return scheduled(ctx, time.Now())
}

//encore:api public method=GET path=/scheduled/:timestamp
func ScheduledAt(ctx context.Context, timestamp string) (*Schedule, error) {
	eb := errs.B().Meta("timestamp", timestamp)
	parsedtime, err := time.Parse(time.RFC3339, timestamp)
	if err != nil {
		return nil, eb.Code(errs.InvalidArgument).Msg("timestamp is not in a valid format").Err()
	}

	return scheduled(ctx, parsedtime)
}

func scheduled(ctx context.Context, timestamp time.Time) (*Schedule, error) {
	eb := errs.B().Meta("timestamp", timestamp)
	schedule, err := RowToSchedule(ctx, db.QueryRow(ctx, `
		SELECT id, user_id, start_time, end_time
		FROM schedules
		WHERE start_time <= $1
		  AND end_time >= $1
	`, timestamp.UTC()))
	if errors.Is(err, db.ErrNoRows) {
		return nil, eb.Code(errs.NotFound).Msg("no schedule found").Err()
	}
	if err != nil {
		return nil, err
	}
	return schedule, nil
}

//encore:api public method=GET path=/schedules
func ListByTimeRange(ctx context.Context, timeRange TimeRange) (*Schedules, error) {
	rows, err := db.Query(ctx, `
		SELECT id, user_id, start_time, end_time
		FROM schedules
		WHERE start_time >= $1
		AND end_time <= $2
		ORDER BY start_time ASC
	`, timeRange.Start, timeRange.End)
	if err != nil {
		return nil, err
	}

	defer rows.Close()

	var schedules []Schedule
	for rows.Next() {
		schedule, err := RowToSchedule(ctx, rows)
		if err != nil {
			return nil, err
		}
		schedules = append(schedules, *schedule)
	}

	return &Schedules{Items: schedules}, nil
}

//encore:api public method=DELETE path=/schedules
func DeleteByTimeRange(ctx context.Context, timeRange TimeRange) (*Schedules, error) {
	schedules, err := ListByTimeRange(ctx, timeRange)
	if err != nil {
		return nil, err
	}
	_, err = db.Exec(ctx, `DELETE FROM schedules WHERE start_time >= $1 AND end_time <= $2`, timeRange.Start, timeRange.End)
	if err != nil {
		return nil, err
	}

	return schedules, err
}

// Helper function to convert a Row object to to Schedule
func RowToSchedule(ctx context.Context, row interface {
	Scan(dest ...interface{}) error
}) (*Schedule, error) {
	var schedule = &Schedule{Time: TimeRange{}}
	var userId int32

	err := row.Scan(&schedule.Id, &userId, &schedule.Time.Start, &schedule.Time.End)
	if err != nil {
		return nil, err
	}

	user, err := users.Get(ctx, userId)
	if err != nil {
		return nil, err
	}

	schedule.User = *user
	return schedule, nil
}

----------------------------------------

TITLE: Implementing API Endpoint with Sub-Package in Encore
DESCRIPTION: Demonstrates how to structure an API endpoint that leverages logic from a sub-package. The hello service defines a public API that calls a function from the foo sub-package.

LANGUAGE: go
CODE:
package hello

import (
	"context"
	
	"encore.app/hello/foo"
)

//encore:api public path=/hello/:name
func World(ctx context.Context, name string) (*Response, error) {
	msg := foo.GenerateMessage(name)
	return &Response{Message: msg}, nil
}

type Response struct {
    Message string
}

----------------------------------------

TITLE: Defining Application Secrets in Encore
DESCRIPTION: Demonstrates how to define application secrets in Encore. This example defines a struct with fields for different secrets that can be accessed in the code but are not stored in the repository.

LANGUAGE: go
CODE:
var secrets struct {
    GitHubAPIToken string   // personal access token for deployments
    SomeOtherSecret string  // some other secret
}

----------------------------------------

TITLE: Structured Logging in Encore.ts
DESCRIPTION: Implementation of structured logging in Encore.ts using the built-in logging module. Shows how to log errors and information with type-safe key-value pairs, which integrates with Encore's distributed tracing system.

LANGUAGE: typescript
CODE:
import log from "encore.dev/log";

log.error(err, "something went terribly wrong!");
log.info("log message", {is_subscriber: true});

----------------------------------------

TITLE: Setting Up Pub/Sub Outbox Pattern in Encore
DESCRIPTION: Configures the Pub/Sub outbox pattern by binding a topic reference to a transaction persister. This ensures consistency between database operations and Pub/Sub notifications.

LANGUAGE: go
CODE:
var SignupsTopic = pubsub.NewTopic[*SignupEvent](/* ... */)
ref := pubsub.TopicRef[pubsub.Publisher[*SignupEvent]](SignupsTopic)
ref = outbox.Bind(ref, outbox.TxPersister(tx))

----------------------------------------

TITLE: Implementing Single File Upload Handling in Encore.ts
DESCRIPTION: This code creates a database schema for storing files and implements a raw API endpoint for handling single file uploads. It uses the busboy library to process multipart form data, saves files as binary data in PostgreSQL, and redirects upon completion.

LANGUAGE: typescript
CODE:
import { api } from "encore.dev/api";
import log from "encore.dev/log";
import busboy from "busboy";
import { SQLDatabase } from "encore.dev/storage/sqldb";

// Define a database named 'files', using the database migrations
// in the "./migrations" folder. Encore automatically provisions,
// migrates, and connects to the database.
export const DB = new SQLDatabase("files", {
  migrations: "./migrations",
});

type FileEntry = { data: any[]; filename: string };

/**
 * Raw endpoint for storing a single file to the database.
 * Setting bodyLimit to null allows for unlimited file size.
 */
export const save = api.raw(
  { expose: true, method: "POST", path: "/upload", bodyLimit: null },
  async (req, res) => {
    const bb = busboy({
      headers: req.headers,
      limits: { files: 1 },
    });
    const entry: FileEntry = { filename: "", data: [] };

    bb.on("file", (_, file, info) => {
      entry.filename = info.filename;
      file
        .on("data", (data) => {
          entry.data.push(data);
        })
        .on("close", () => {
          log.info(`File ${entry.filename} uploaded`);
        })
        .on("error", (err) => {
          bb.emit("error", err);
        });
    });

    bb.on("close", async () => {
      try {
        const buf = Buffer.concat(entry.data);
        await DB.exec`
            INSERT INTO files (name, data)
            VALUES (${entry.filename}, ${buf})
            ON CONFLICT (name) DO UPDATE
                SET data = ${buf}
        `;
        log.info(`File ${entry.filename} saved`);

        // Redirect to the root page
        res.writeHead(303, { Connection: "close", Location: "/" });
        res.end();
      } catch (err) {
        bb.emit("error", err);
      }
    });

    bb.on("error", async (err) => {
      res.writeHead(500, { Connection: "close" });
      res.end(`Error: ${(err as Error).message}`);
    });

    req.pipe(bb);
    return;
  },
);

LANGUAGE: sql
CODE:
CREATE TABLE files (
    name TEXT PRIMARY KEY,
    data BYTEA NOT NULL
);

----------------------------------------

TITLE: Configuring CORS Settings in Encore Application
DESCRIPTION: This snippet shows the structure of the global_cors configuration object in the encore.app file. It includes options for debug logging, allowed headers, exposed headers, and origin permissions both with and without credentials.

LANGUAGE: cue
CODE:
{
    // debug enables CORS debug logging.
    "debug": true | false,

    // allow_headers allows an app to specify additional headers that should be
    // accepted by the app.
    //
    // If the list contains "*", then all headers are allowed.
    "allow_headers": [...string],

    // expose_headers allows an app to specify additional headers that should be
    // exposed from the app, beyond the default set always recognized by Encore.
    //
    // If the list contains "*", then all headers are exposed.
    "expose_headers": [...string],

    // allow_origins_without_credentials specifies the allowed origins for requests
    // that don't include credentials. If nil it defaults to allowing all domains
    // (equivalent to ["*"]).
    "allow_origins_without_credentials": [...string],

    // allow_origins_with_credentials specifies the allowed origins for requests
    // that include credentials. If a request is made from an Origin in this list
    // Encore responds with Access-Control-Allow-Origin: <Origin>.
    //
    // The URLs in this list may include wildcards (e.g. "https://*.example.com"
    // or "https://*-myapp.example.com").
    "allow_origins_with_credentials": [...string],
}

----------------------------------------

TITLE: Creating a NestJS Standalone Application Context
DESCRIPTION: Creates a standalone NestJS application context to expose services like CatsService that can be used by Encore APIs. This approach replaces the traditional NestJS bootstrapping.

LANGUAGE: typescript
CODE:
const applicationContext: Promise<{ catsService: CatsService }> =
  NestFactory.createApplicationContext(AppModule).then((app) => {
    return {
      catsService: app.select(CatsModule).get(CatsService, {strict: true}),
      // other services...
    };
  });

export default applicationContext;

----------------------------------------

TITLE: Creating a slots.go file for the booking service
DESCRIPTION: Shell command to create a new file for implementing the booking service API endpoints, specifically for managing bookable time slots.

LANGUAGE: shell
CODE:
$ touch booking/slots.go

----------------------------------------

TITLE: Defining Query Parameters in API Request Structs in Encore.go
DESCRIPTION: Example of how to define query parameters in request structs. It shows explicit query tag usage and implicit query parameter behavior for specific HTTP methods.

LANGUAGE: go
CODE:
struct {
    PageLimit int `query:"limit"`
    Author string // query for GET/HEAD/DELETE, body otherwise
}

----------------------------------------

TITLE: Implementing Rate Limiting with Encore Cache
DESCRIPTION: Creates a rate limiting middleware using a cache-based counter. This example tracks requests per user with a 10-second expiry and limits to 10 requests per time window.

LANGUAGE: go
CODE:
import (
    "encore.dev/beta/auth"
    "encore.dev/beta/errs"
    "encore.dev/middleware"
)

// RequestsPerUser tracks the number of requests per user.
// The cache items expire after 10 seconds without activity.
var RequestsPerUser = cache.NewIntKeyspace[auth.UID](cluster, cache.KeyspaceConfig{
	KeyPattern:    "requests/:key",
	DefaultExpiry: cache.ExpireIn(10 * time.Second),
})

// RateLimitMiddleware is a global middleware that limits the number of authenticated requests
// to 10 requests per 10 seconds.
//encore:middleware target=all
func RateLimitMiddleware(req middleware.Request, next middleware.Next) middleware.Response {
	if userID, ok := auth.UserID(); ok {
		val, err := RequestsPerUser.Increment(req.Context(), userID, 1)

		// NOTE: this "fails open", meaning if we can't communicate with the cache
		// we default to allowing the requests.
		//
		// Consider whether that's the correct behavior for your application,
		// or if you want to return an error to the user in that case.
		if err == nil && val > 10 {
			return middleware.Response{
				Err: &errs.Error{Code: errs.ResourceExhausted, Message: "rate limit exceeded"},
			}
		}
	}
	return next(req)
}

----------------------------------------

TITLE: Creating a PostgreSQL Database with Encore
DESCRIPTION: Demonstrates how to create a PostgreSQL database in an Encore application by using sqldb.NewDatabase and specifying migration files. The example shows basic database setup for a todo application.

LANGUAGE: go
CODE:
-- todo/db.go --
package todo

// Create the todo database and assign it to the "tododb" variable
var tododb = sqldb.NewDatabase("todo", sqldb.DatabaseConfig{
	Migrations: "./migrations",
})

// Then, query the database using db.QueryRow, db.Exec, etc.

LANGUAGE: sql
CODE:
-- todo/migrations/1_create_table.up.sql --
CREATE TABLE todo_item (
  id BIGSERIAL PRIMARY KEY,
  title TEXT NOT NULL,
  done BOOLEAN NOT NULL DEFAULT false
  -- etc...
);

----------------------------------------

TITLE: Using Cloud-Specific Services Based on Environment in Go
DESCRIPTION: This example demonstrates how to use Encore's Metadata API to determine the cloud provider of the current environment and conditionally select different services based on the provider (AWS, GCP, or local development).

LANGUAGE: go
CODE:
package audit

import (
    "encore.dev"
    "encore.dev/beta/auth"
)

func Audit(ctx context.Context, action message, user auth.UID) error {
    switch encore.Meta().Environment.Cloud {
    case encore.CloudAWS:
        return writeIntoRedshift(ctx, action, user)
    case encore.CloudGCP:
        return writeIntoBigQuery(ctx, action, user)
    case encore.CloudLocal:
        return writeIntoFile(ctx, action, user)
    default:
        return fmt.Errorf("unknown cloud: %s", encore.Meta().Environment.Cloud)
    }
}

----------------------------------------

TITLE: Combining Path Parameters with Body Payloads in Encore REST APIs
DESCRIPTION: Example of an UpdateBlogPost endpoint that combines a path parameter (id) with a body payload (post). This demonstrates the pattern for updating a resource in a RESTful API.

LANGUAGE: go
CODE:
// UpdateBlogPost updates an existing blog post by id.
//encore:api public method=PUT path=/blog/:id
func UpdateBlogPost(ctx context.Context, id int, post *BlogPost) error {
    // Use `post` to update the blog post with the given id.
}

----------------------------------------

TITLE: Implementing SaveNote API Endpoint in Go
DESCRIPTION: API endpoint function that saves a note to the database. It handles both inserts and updates using SQL's ON CONFLICT clause when there's an ID collision.

LANGUAGE: go
CODE:
//encore:api public method=POST path=/note
func SaveNote(ctx context.Context, note *Note) (*Note, error) {
	// Save the note to the database.
	// If the note already exists (i.e. CONFLICT), we update the notes text and the cover URL.
	_, err := sqldb.Exec(ctx, `
		INSERT INTO note (id, text, cover_url) VALUES ($1, $2, $3)
		ON CONFLICT (id) DO UPDATE SET text=$2, cover_url=$3
	`, note.ID, note.Text, note.CoverURL)

	// If there was an error saving to the database, then we return that error.
	if err != nil {
		return nil, err
	}

	// Otherwise, we return the note to indicate that the save was successful.
	return note, nil
}

----------------------------------------

TITLE: Microservices Communication in Express.js vs Encore.ts
DESCRIPTION: Demonstrates how to handle service-to-service communication in Express.js using fetch compared to Encore.ts's built-in type-safe function calls. Encore's approach simplifies cross-service communication by making remote calls look like local function calls.

LANGUAGE: typescript
CODE:
import express, {Request, Response} from "express";

const app: Express = express();

app.get("/save-post", async (req: Request, res: Response) => {
  try {
    // Calling another service using fetch
    const resp = await fetch("https://another-service/posts", {
      method: "POST",
      headers: {"Content-Type": "application/json"},
      body: JSON.stringify({
        title: req.query.title,
        content: req.query.content,
      }),
    });
    res.json(await resp.json());
  } catch (e) {
    res.status(500).json({error: "Could not save post"});
  }
});

LANGUAGE: typescript
CODE:
import {api} from "encore.dev/api";
import {anotherService} from "~encore/clients";

export const microserviceCommunication = api(
  {expose: true, method: "GET", path: "/call"},
  async (): Promise<{ message: string }> => {
    // Calling the foo endpoint in anotherService
    const fooResponse = await anotherService.foo();

    const msg = `Data from another service ${fooResponse.data}!`;
    return {message: msg};
  },
);

----------------------------------------

TITLE: Implementing Site Status Retrieval API in Go
DESCRIPTION: Creates a Status endpoint that fetches the most recent status for each monitored site from the database. It uses a query with DISTINCT ON to get only the latest check for each site, returning a map of site IDs to their current status.

LANGUAGE: go
CODE:
package monitor

import (
	"context"
	"time"
)

// SiteStatus describes the current status of a site
// and when it was last checked.
type SiteStatus struct {
	Up        bool      `json:"up"`
	CheckedAt time.Time `json:"checked_at"`
}

// StatusResponse is the response type from the Status endpoint.
type StatusResponse struct {
	// Sites contains the current status of all sites,
	// keyed by the site ID.
	Sites map[int]SiteStatus `json:"sites"`
}

// Status checks the current up/down status of all monitored sites.
//
//encore:api public method=GET path=/status
func Status(ctx context.Context) (*StatusResponse, error) {
	rows, err := db.Query(ctx, `
		SELECT DISTINCT ON (site_id) site_id, up, checked_at
		FROM checks
		ORDER BY site_id, checked_at DESC
	`)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	result := make(map[int]SiteStatus)
	for rows.Next() {
		var siteID int
		var status SiteStatus
		if err := rows.Scan(&siteID, &status.Up, &status.CheckedAt); err != nil {
			return nil, err
		}
		result[siteID] = status
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return &StatusResponse{Sites: result}, nil
}

----------------------------------------

TITLE: Using Query Parameters in API Requests
DESCRIPTION: Shows how to configure fields to be parsed from query string parameters. The 'limit' field will always be read from the query string, while 'author' may be read from either query string or request body depending on HTTP method.

LANGUAGE: typescript
CODE:
interface Params {
  limit: Query<number>; // always a query parameter
  author: string; // query if GET, HEAD or DELETE, otherwise body parameter
}

----------------------------------------

TITLE: Defining an Encore Service
DESCRIPTION: Example of defining a service in Encore.ts. This code creates a service named 'hello' which groups related functionality together in the application architecture.

LANGUAGE: typescript
CODE:
-- hello/encore.service.ts --
import { Service } from "encore.dev/service";

export default new Service("hello");

----------------------------------------

TITLE: Exploring the schema_migrations Table Structure in SQL
DESCRIPTION: This SQL snippet shows the structure of the schema_migrations table that Encore uses to track which migrations have been applied to the database. The table contains a version column to track the last applied migration and a dirty flag.

LANGUAGE: sql
CODE:
database=# \d schema_migrations
          Table "public.schema_migrations"
 Column  |  Type   | Collation | Nullable | Default
---------+---------+-----------+----------+---------
 version | bigint  |           | not null |
 dirty   | boolean |           | not null |
Indexes:
    "schema_migrations_pkey" PRIMARY KEY, btree (version)

----------------------------------------

TITLE: Serving Static Files in Express.js
DESCRIPTION: This snippet shows how to serve static files in Express.js using the built-in express.static middleware function to serve files from a specific directory.

LANGUAGE: typescript
CODE:
import express from "express";

const app: Express = express();

app.use("/assets", express.static("assets"));

----------------------------------------

TITLE: Binding a Pub/Sub Topic to a Transactional Outbox in Go
DESCRIPTION: This code demonstrates how to bind a Pub/Sub topic to a transactional outbox using Encore. It shows the process of creating a topic reference with publisher permissions and binding it to a SQL transaction, ensuring database consistency with message publishing.

LANGUAGE: go
CODE:
// Create a SignupsTopic somehow.
var SignupsTopic = pubsub.NewTopic[*SignupEvent](/* ... */)

// Create a topic ref with publisher permissions.
ref := pubsub.TopicRef[pubsub.Publisher[*SignupEvent]](SignupsTopic)

// Bind it to the transactional outbox
import "x.encore.dev/infra/pubsub/outbox"
var tx *sqldb.Tx // somehow get a transaction
ref = outbox.Bind(ref, outbox.TxPersister(tx))

// Calls to ref.Publish() will now insert a row in the outbox table.

----------------------------------------

TITLE: Implementing Outbox Relay for Pub/Sub Messages
DESCRIPTION: Sets up a relay that polls the outbox table and publishes messages to actual Pub/Sub topics. The relay runs in a separate goroutine and supports various storage backends.

LANGUAGE: go
CODE:
type Service struct {
    signupsRef pubsub.Publisher[*SignupEvent]
}

func initService() (*Service, error) {
    relay := outbox.NewRelay(outbox.SQLDBStore(db))
    signupsRef := pubsub.TopicRef[pubsub.Publisher[*SignupEvent]](SignupsTopic)
    outbox.RegisterTopic(relay, signupsRef)
    go relay.PollForMessage(context.Background(), -1)
    return &Service{signupsRef: signupsRef}, nil
}

----------------------------------------

TITLE: Rejecting Authentication with APIError in Encore
DESCRIPTION: Demonstrates how to reject authentication by throwing an Unauthenticated APIError. This approach signals that the provided credentials are invalid and prevents access to protected endpoints.

LANGUAGE: typescript
CODE:
import { APIError } from "encore.dev/api";

export const auth = authHandler<AuthParams, AuthData>(
    async (params) => {
        throw APIError.unauthenticated("bad credentials");
    }
)

----------------------------------------

TITLE: Defining a Redis Cache Cluster in Encore
DESCRIPTION: Creates a new Redis-backed cache cluster in an Encore application. The cluster uses LRU (Least Recently Used) eviction policy to manage memory constraints.

LANGUAGE: go
CODE:
import "encore.dev/storage/cache"

var MyCacheCluster = cache.NewCluster("my-cache-cluster", cache.ClusterConfig{
    // EvictionPolicy tells Redis how to evict keys when the cache reaches
    // its memory limit. For typical cache use cases, cache.AllKeysLRU is a good default.
    EvictionPolicy: cache.AllKeysLRU,
})

----------------------------------------

TITLE: Creating a PostgreSQL Database with Encore in TypeScript
DESCRIPTION: This snippet demonstrates how to create a PostgreSQL database in an Encore application using TypeScript. It shows the database initialization with migration path configuration, and includes a sample migration file for creating a table.

LANGUAGE: typescript
CODE:
-- todo/todo.ts --
import { SQLDatabase } from "encore.dev/storage/sqldb";

// Create the todo database and assign it to the "db" variable
const db = new SQLDatabase("todo", {
  migrations: "./migrations",
});

// Then, query the database using db.query, db.exec, etc.

LANGUAGE: sql
CODE:
-- todo/migrations/1_create_table.up.sql --
CREATE TABLE todo_item (
  id BIGSERIAL PRIMARY KEY,
  title TEXT NOT NULL,
  done BOOLEAN NOT NULL DEFAULT false
  -- etc...
);

----------------------------------------

TITLE: URL Retrieval Endpoint Implementation
DESCRIPTION: Implements the GET endpoint to retrieve the original URL by its short ID. Uses a SQL query to fetch the URL from the database based on the provided ID parameter.

LANGUAGE: go
CODE:
// Get retrieves the original URL for the id.
//encore:api public method=GET path=/url/:id
func Get(ctx context.Context, id string) (*URL, error) {
	u := &URL{ID: id}
	err := db.QueryRow(ctx, `
        SELECT original_url FROM url
        WHERE id = $1
    `, id).Scan(&u.URL)
	return u, err
}

----------------------------------------

TITLE: Initializing Sequelize with Encore's SQLDatabase
DESCRIPTION: This snippet shows how to set up a SQLDatabase instance in Encore and initialize Sequelize with the connection string. It also includes defining a User model using Sequelize's Model class.

LANGUAGE: typescript
CODE:
// database.ts
import {
  Model,
  InferAttributes,
  InferCreationAttributes,
  CreationOptional,
  DataTypes,
  Sequelize,
} from "sequelize";
import { SQLDatabase } from "encore.dev/storage/sqldb";

// Create SQLDatabase instance with migrations configuration
const DB = new SQLDatabase("encore_sequelize_test", {
  migrations: "./migrations",
});

// Initialize Sequelize with the connection string
const sequelize = new Sequelize(DB.connectionString);

// Define the User model
class User extends Model<InferAttributes<User>, InferCreationAttributes<User>> {
  declare id: CreationOptional<number>;
  declare name: string;
  declare surname: string;
}

// Example usage: Count all users
const count = await User.count();

----------------------------------------

TITLE: Type-Safe Service Mocking with Interfaces in Encore
DESCRIPTION: Shows how to use Encore's automatically generated interfaces for type-safe service mocking. This approach provides compile-time safety by ensuring the mock object implements all required APIs.

LANGUAGE: go
CODE:
type myMockObject struct{}

func (m *myMockObject) GetPrice(ctx context.Context, p *products.PriceParams) (*products.PriceResponse, error) {
    return &products.PriceResponse{Price: 100}, nil
}

func Test_Something(t *testing.T) {
    t.Parallel() // Run this test in parallel with other tests without the mock implementation interfering
    
    // This will cause a compile time error if myMockObject does not implement all the APIs defined in the products service
    et.MockService[products.Interface]("products", &myMockObject{})
}

----------------------------------------

TITLE: Serving Static Files with api.static in Encore.ts
DESCRIPTION: Basic implementation of serving static files from a directory using Encore.ts. This code serves all files from the ./assets directory under the /frontend path prefix, and automatically serves index.html files as root files for directories.

LANGUAGE: typescript
CODE:
import { api } from "encore.dev/api";

export const assets = api.static(
  { expose: true, path: "/frontend/*path", dir: "./assets" },
);

----------------------------------------

TITLE: Defining a Service Struct with Dependency Injection in Go
DESCRIPTION: This snippet demonstrates how to create an email service with a dependency-injected SendGrid client. It uses Encore's //encore:service directive to define a service struct and an initialization function that creates the SendGrid client.

LANGUAGE: go
CODE:
package email

//encore:service
type Service struct {
	sendgridClient *sendgrid.Client
}

func initService() (*Service, error) {
    client, err := sendgrid.NewClient()
    if err != nil {
        return nil, err
    }
    return &Service{sendgridClient: client}, nil
}

----------------------------------------

TITLE: Implementing Multiple File Upload Handling in Encore.ts
DESCRIPTION: This endpoint handles multiple file uploads simultaneously. It processes each file with busboy, collects them in an array, and stores each one in the database. It follows the same pattern as the single upload handler but accommodates multiple files.

LANGUAGE: typescript
CODE:
export const saveMultiple = api.raw(
  { expose: true, method: "POST", path: "/upload-multiple", bodyLimit: null },
  async (req, res) => {
    const bb = busboy({ headers: req.headers });
    const entries: FileEntry[] = [];

    bb.on("file", (_, file, info) => {
      const entry: FileEntry = { filename: info.filename, data: [] };

      file
        .on("data", (data) => {
          entry.data.push(data);
        })
        .on("close", () => {
          entries.push(entry);
        })
        .on("error", (err) => {
          bb.emit("error", err);
        });
    });

    bb.on("close", async () => {
      try {
        for (const entry of entries) {
          const buf = Buffer.concat(entry.data);
          await DB.exec`
              INSERT INTO files (name, data)
              VALUES (${entry.filename}, ${buf})
              ON CONFLICT (name) DO UPDATE
                  SET data = ${buf}
          `;
          log.info(`File ${entry.filename} saved`);
        }

        // Redirect to the root page
        res.writeHead(303, { Connection: "close", Location: "/" });
        res.end();
      } catch (err) {
        bb.emit("error", err);
      }
    });

    bb.on("error", async (err) => {
      res.writeHead(500, { Connection: "close" });
      res.end(`Error: ${(err as Error).message}`);
    });

    req.pipe(bb);
    return;
  },
);

----------------------------------------

TITLE: Subscribing to PubSub Events in Encore
DESCRIPTION: Demonstrates how to subscribe to PubSub topics in Encore. This example creates a subscription to the Signups topic that triggers a SendWelcomeEmail function for each event received.

LANGUAGE: go
CODE:
var _ = pubsub.NewSubscription(
    user.Signups, "send-welcome-email",
    pubsub.SubscriptionConfig[*SignupEvent] {
        Handler: SendWelcomeEmail,
    },
)
func SendWelcomeEmail(ctx context.Context, event *SignupEvent) error {
    ... send email ...
    return nil
}

----------------------------------------

TITLE: Defining Redis Cache Clusters in Encore
DESCRIPTION: Shows how to define Redis cache clusters in Encore applications. This example creates a cache cluster with a least-recently-used eviction policy for typical caching use cases.

LANGUAGE: go
CODE:
import "encore.dev/storage/cache"

var MyCacheCluster = cache.NewCluster("my-cache-cluster", cache.ClusterConfig{
    // EvictionPolicy tells Redis how to evict keys when the cache reaches
    // its memory limit. For typical cache use cases, cache.AllKeysLRU is a good default.
    EvictionPolicy: cache.AllKeysLRU,
})

----------------------------------------

TITLE: Creating a PostgreSQL Database with Encore in TypeScript
DESCRIPTION: This snippet demonstrates how to create a PostgreSQL database in an Encore application using TypeScript. It shows the database initialization with migration path configuration, and includes a sample migration file for creating a table.

LANGUAGE: typescript
CODE:
-- todo/todo.ts --
import { SQLDatabase } from "encore.dev/storage/sqldb";

// Create the todo database and assign it to the "db" variable
const db = new SQLDatabase("todo", {
  migrations: "./migrations",
});

// Then, query the database using db.query, db.exec, etc.

LANGUAGE: sql
CODE:
-- todo/migrations/1_create_table.up.sql --
CREATE TABLE todo_item (
  id BIGSERIAL PRIMARY KEY,
  title TEXT NOT NULL,
  done BOOLEAN NOT NULL DEFAULT false
  -- etc...
);

----------------------------------------

TITLE: Serving Static Assets with Encore.ts
DESCRIPTION: This code creates an API endpoint to serve static frontend assets including HTML files from a specified directory. It demonstrates how to set up a fallback route for serving static files with a custom 404 response.

LANGUAGE: typescript
CODE:
import { api } from "encore.dev/api";

// Using fallback route to serve all files in the ./assets directory under the root path.
export const rootAssets = api.static({
  expose: true,
  path: "/!path",
  dir: "./assets",
  // When a file matching the request isn't found, Encore automatically serves a 404 Not Found response.
  // You can customize the response by setting the notFound option to specify a file that should be served instead:
  notFound: "./assets/not_found.html",
});


----------------------------------------

TITLE: Using Raw SQL Queries with Parameters in TypeScript
DESCRIPTION: This function shows how to use raw SQL queries with parameterized input in an Encore PostgreSQL database. It uses rawQueryRow to safely retrieve a todo's title by ID.

LANGUAGE: typescript
CODE:
async function getTodoTitle(id: number): string | undefined {
  const row = await db.rawQueryRow("SELECT title FROM todo_item WHERE id = $1", id);
  return row?.title;
}

----------------------------------------

TITLE: Listing Objects in a Bucket with Encore.ts
DESCRIPTION: Shows how to list objects in a bucket using an async iterator. This allows you to iterate over all objects in the bucket using a 'for await' loop, with options to limit or filter the results.

LANGUAGE: typescript
CODE:
for await (const entry of profilePictures.list({})) {
  // Do something with entry
}

----------------------------------------

TITLE: Directory Structure for a Multi-Service Encore Application
DESCRIPTION: A representation of the file structure after breaking the monolith into separate services. Shows how Encore organizes services as Go packages at the top level of the project.

LANGUAGE: text
CODE:
/my-app
├── encore.app        // ... and other top-level project files
│
├── hello             // hello service (a Go package)
│   └── hello.go      // hello service code
│
└── yo                // yo service (a Go package)
    └── yo.go         // yo service code

----------------------------------------

TITLE: Running Ruleguard Rules in Go
DESCRIPTION: Command to run all ruleguard rules against a Go codebase. This specifies the rules file and disables coloring (-c=0) while analyzing all packages in and below the current directory.

LANGUAGE: bash
CODE:
$ ruleguard -c=0 -rules path/to/semgrep-go/ruleguard.rules.go ./...

----------------------------------------

TITLE: Large Multi-System Application Directory Structure
DESCRIPTION: This demonstrates the recommended directory structure for large applications divided into multiple systems (logical domains), each containing several related services. The example shows a Trello-like application with separate systems for core functionality, user management, and premium features.

LANGUAGE: plaintext
CODE:
/my-trello-clone
├── encore.app
├── package.json                // ... and other top-level project files
│
├── trello                      // trello system (a directory)
│   ├── board                   // board service (a directory)
│   │   ├── encore.service.ts   // service definition
│   │   └── board.ts            // service code
│   │
│   └── card                    // card service (a directory)
│       ├── encore.service.ts   // service definition
│       └── card.ts             // service code
│
├── premium                     // premium system (a directory)
│   ├── payment                 // payment service (a directory)
│   │   ├── encore.service.ts   // service definition
│   │   └── payment.ts          // service code
│   │
│   └── subscription            // subscription service (a directory)
│       ├── encore.service.ts   // service definition
│       └── subscription.ts     // service code
│
└── usr                         // usr system (a directory)
    ├── org                     // org service (a directory)
    │   ├── encore.service.ts   // service definition
    │   └── org.ts              // service code
    │
    └── user                    // user service (a directory)
        ├── encore.service.ts   // service definition
        └── user.ts             // service code

----------------------------------------

TITLE: Creating Signed Download URLs with Encore in Go
DESCRIPTION: Generates a time-limited signed URL for direct file downloads from a cloud storage bucket. The example creates a URL for downloading a specific document with a 2-hour expiration time.

LANGUAGE: go
CODE:
url, err := Documents.SignedDownloadURL(ctx, "letter-1234", objects.WithTTL(time.Duration(7200)*time.Second))
// Pass url to client

----------------------------------------

TITLE: Client-Side Stream Connection and Usage
DESCRIPTION: Client-side examples showing how to connect to streaming endpoints, receive messages using async iterators, send messages, and handle network events with the Encore generated client.

LANGUAGE: typescript
CODE:
const stream = client.serviceName.endpointName();
for await (const msg of stream) {
  // Do something with each message
}

LANGUAGE: typescript
CODE:
const stream = client.serviceName.endpointName();
await stream.send({ ... });

LANGUAGE: typescript
CODE:
const stream = client.serviceName.endpointName();

stream.socket.on("error", (event) => {
  // An error occurred
});

stream.socket.on("close", (event) => {
  // Connection was closed
});


----------------------------------------

TITLE: Basic Encore Application Directory Structure
DESCRIPTION: Shows the folder structure of a simple Encore application with two services (hello and world). The structure includes service packages, database migrations, and test files.

LANGUAGE: plaintext
CODE:
/my-app
├── encore.app                       // ... and other top-level project files
│
├── hello                            // hello service (a Go package)
│   ├── migrations                   // hello service db migration (directory)
│   │   └── 1_create_table.up.sql    // hello service db migration
│   ├── hello.go                     // hello service code
│   └── hello_test.go                // tests for hello service
│
└── world                            // world service (a Go package)
    └── world.go                     // world service code

----------------------------------------

TITLE: Using Interfaces for Testable Dependency Injection in Go
DESCRIPTION: This snippet demonstrates how to use interfaces for dependencies to enable easier testing. By defining an interface for the SendGrid client, it becomes possible to substitute a mock implementation during tests.

LANGUAGE: go
CODE:
type sendgridClient interface {
	SendEmail(...) // a hypothetical signature, for illustration purposes
}

//encore:service
type Service struct {
    sendgridClient sendgridClient
}

----------------------------------------

TITLE: Publishing Events to a PubSub Topic in Go
DESCRIPTION: This snippet shows how to publish an event to a PubSub topic. It demonstrates error handling and explains that the messageID returned can be used to track the unique ID of the published message.

LANGUAGE: go
CODE:
messageID, err := Signups.Publish(ctx, &SignupEvent{UserID: id})
if err != nil {
    return err
}

// If we get here the event has been successfully published,
// and all registered subscribers will receive the event.

// The messageID variable contains the unique id of the message,
// which is also provided to the subscribers when processing the event.

----------------------------------------

TITLE: Using Error Builder Pattern in Go
DESCRIPTION: Example of using the errs.Builder pattern for gradually constructing errors with metadata in complex business logic. The builder uses a chaining API design for setting error properties before returning the final error.

LANGUAGE: go
CODE:
func getBoard(ctx context.Context, boardID int64) (*Board, error) {
    // Construct a new error builder with errs.B()
	eb := errs.B().Meta("board_id", params.ID)

	b := &Board{ID: params.ID}
	err := sqldb.QueryRow(ctx, `
		SELECT name, created
		FROM board
		WHERE id = $1
	`, params.ID).Scan(&b.Name, &b.Created)
	if errors.Is(err, sqldb.ErrNoRows) {
        // Return a "board not found" error with code == NotFound
		return nil, eb.Code(errs.NotFound).Msg("board not found").Err()
	} else if err != nil {
        // Return a general error
		return nil, eb.Cause(err).Msg("could not get board").Err()
	}
    // ...
}

----------------------------------------

TITLE: Updating Book Function to Check for Available Slots in Go
DESCRIPTION: Updated Book function that checks if a requested time slot is available based on existing bookings and current time.

LANGUAGE: go
CODE:
-- booking/booking.go --
//encore:api public method=POST path=/booking
func Book(ctx context.Context, p *BookParams) error {
	eb := errs.B()

	now := time.Now()
	if p.Start.Before(now) {
		return eb.Code(errs.InvalidArgument).Msg("start time must be in the future").Err()
	}

	tx, err := pgxdb.Begin(ctx)
	if err != nil {
		return eb.Cause(err).Code(errs.Unavailable).Msg("failed to start transaction").Err()
	}
	defer tx.Rollback(context.Background()) // committed explicitly on success

	// Get the bookings for this day.
	startOfDay := time.Date(p.Start.Year(), p.Start.Month(), p.Start.Day(), 0, 0, 0, 0, p.Start.Location())
	bookings, err := listBookingsBetween(ctx, startOfDay, startOfDay.AddDate(0, 0, 1))
	if err != nil {
		return eb.Cause(err).Code(errs.Unavailable).Msg("failed to list bookings").Err()
	}

	// Is this slot bookable?
	slot := BookableSlot{Start: p.Start, End: p.Start.Add(DefaultBookingDuration)}
	if len(filterBookableSlots([]BookableSlot{slot}, now, bookings)) == 0 {
		return eb.Code(errs.InvalidArgument).Msg("slot is unavailable").Err()
	}

	_, err = query.InsertBooking(ctx, db.InsertBookingParams{
		StartTime: pgtype.Timestamp{Time: p.Start, Valid: true},
		EndTime:   pgtype.Timestamp{Time: p.Start.Add(DefaultBookingDuration), Valid: true},
		Email:     p.Email,
	})
	if err != nil {
		return eb.Cause(err).Code(errs.Unavailable).Msg("failed to insert booking").Err()
	}

	if err := tx.Commit(ctx); err != nil {
		return eb.Cause(err).Code(errs.Unavailable).Msg("failed to commit transaction").Err()
	}
	return nil
}

----------------------------------------

TITLE: Defining Body Parameters in Encore API Schemas
DESCRIPTION: This example demonstrates how to define body parameters in Encore API schemas. It shows how the json tag is used to control field names in the serialized JSON body.

LANGUAGE: go
CODE:
type CreateBlogPost struct {
    Subject    string `json:"limit"` // query if GET, HEAD or DELETE, otherwise body parameter
    Author     string                // query if GET, HEAD or DELETE, otherwise body parameter
}

----------------------------------------

TITLE: Example CUE Environment Conditionals
DESCRIPTION: Useful conditional expressions in CUE for detecting different environments and adjusting configuration accordingly.

LANGUAGE: cue
CODE:
// An application running due to `encore run`
if #Meta.Environment.Type == "development" && #Meta.Environment.Cloud == "local" {}

// An application running in a development environment in the Cloud
if #Meta.Environment.Type == "development" && #Meta.Environment.Cloud != "local" {}

// An application running in a production environment
if #Meta.Environment.Type == "production" {}

// An application running in an environment that Encore has created
// for an open Pull Request on Github
if #Meta.Environment.Type == "ephemeral" {}

----------------------------------------

TITLE: Using CUE Tags in Go Structs for Configuration Constraints
DESCRIPTION: Example of using CUE tags in Go structs to specify additional constraints on configuration values. This allows for value inference and validation in the generated CUE definitions.

LANGUAGE: go
CODE:
type FooBar {
    A int `cue:">100"`
    B int `cue:"A-50"` // If A is set, B can be inferred by CUE
    C int `cue:"A+B"`  // Which then allows CUE to infer this too
}

var _ = config.Load[*FooBar]()

----------------------------------------

TITLE: Implementing Ordered PubSub Topics in Encore
DESCRIPTION: This code example shows how to create an ordered topic where messages with the same ordering key are delivered in the order they were published. This ensures sequential processing for events related to the same entity.

LANGUAGE: typescript
CODE:
import { Topic, Attribute } from "encore.dev/pubsub";

export interface CartEvent {
	shoppingCartID: Attribute<number>;
	event: string;
}

export const cartEvents = new Topic<CartEvent>("cart-events", {
	deliveryGuarantee: "at-least-once",
	orderingAttribute: "shoppingCartID",
})

async function example() {
	// These are delivered in order as they all have the same shopping cart ID
	await cartEvents.publish({shoppingCartID: 1, event: "item_added"});
	await cartEvents.publish({shoppingCartID: 1, event: "checkout_started"});
	await cartEvents.publish({shoppingCartID: 1, event: "checkout_completed"});

	// This may be delivered at any point as it has a different shopping cart ID.
	await cartEvents.publish({shoppingCartID: 2, event: "item_added"});
}

----------------------------------------

TITLE: Configuring Multiple Middleware in Order of Execution
DESCRIPTION: Example showing how to define multiple middleware functions that will be executed in sequence. The order of execution follows the order in which they are defined in the service configuration.

LANGUAGE: typescript
CODE:
export default new Service("myService", {
    middlewares: [
        first,
        second,
        third
    ],
});

----------------------------------------

TITLE: Implementing a Pub/Sub Topic for Site Status Transitions
DESCRIPTION: This code defines a Pub/Sub topic that will publish notifications when a site transitions from up to down or vice versa. It includes the definition of the TransitionEvent interface.

LANGUAGE: typescript
CODE:
import { Subscription, Topic } from "encore.dev/pubsub";

// TransitionEvent describes a transition of a monitored site
// from up->down or from down->up.
export interface TransitionEvent {
  site: Site; // Site is the monitored site in question.
  up: boolean; // Up specifies whether the site is now up or down (the new value).
}

// TransitionTopic is a pubsub topic with transition events for when a monitored site
// transitions from up->down or from down->up.
export const TransitionTopic = new Topic<TransitionEvent>("uptime-transition", {
  deliveryGuarantee: "at-least-once",
});

----------------------------------------

TITLE: Deleting Objects from Object Storage in Go
DESCRIPTION: Shows how to remove an object from a bucket using the Remove method. The example includes error handling for when the object doesn't exist.

LANGUAGE: go
CODE:
err := ProfilePictures.Remove(ctx, "my-user-id")
if err != nil && !errors.Is(err, objects.ErrObjectNotFound) {
	// Handle error
}

----------------------------------------

TITLE: Implementing a Bidirectional Streaming API Endpoint
DESCRIPTION: Shows how to create a bidirectional streaming API endpoint. This example defines a chat endpoint that receives messages from clients and sends responses back in real-time.

LANGUAGE: typescript
CODE:
export const chatStream = api.streamInOut<InMessage, OutMessage>(
  { path: "/chat", expose: true },
  async (stream) => {
    for await (const msg of stream) {
      await stream.send(/* response */);
    }
  }
);

----------------------------------------

TITLE: Serving a Specific Template File with EJS in Encore.ts
DESCRIPTION: This example shows how to serve a specific template file using EJS in an Encore.ts application. It imports the EJS package, sets up a Raw Endpoint to handle template rendering, provides data to the template, and serves the generated HTML with the appropriate content-type header.

LANGUAGE: typescript
CODE:
-- template/template.ts --
import { api } from "encore.dev/api";
import ejs, { Options } from "ejs";

const BASE_PATH = "./template/views";
const ejsOptions: Options = { views: [BASE_PATH] };

export const serveSpecificTemplate = api.raw(
  { expose: true, path: "/person", method: "GET" },
  async (req, resp) => {
    const viewPath = `${BASE_PATH}/person.html`;
    const html = await ejs.renderFile(
      viewPath,
      // Supplying data to the view
      { name: "Simon" },
      ejsOptions,
    );
    resp.setHeader("content-type", "text/html");
    resp.end(html);
  },
);
-- template/views/person.html --
<h1>Person Page</h1>
<p>Name: <%= name %></p>

----------------------------------------

TITLE: Implementing a Periodic Cron Job in Encore
DESCRIPTION: Example of creating a basic cron job in Encore that runs every 2 hours. The job is defined with a unique identifier, title, schedule, and endpoint function that will be executed automatically.

LANGUAGE: go
CODE:
var _ = cron.NewJob("welcome-email", cron.JobConfig{
    Title:    "Send welcome emails",
    Every:    2 * cron.Hour,
    Endpoint: SendWelcomeEmail,
})

//encore:api private
func SendWelcomeEmail(ctx context.Context) error {
    return nil
}

----------------------------------------

TITLE: Using Signed Upload URLs with cURL
DESCRIPTION: Demonstrates how to use a signed upload URL from the client side to upload a file directly to cloud storage using cURL. The example shows uploading a JPEG file to a Google Cloud Storage bucket.

LANGUAGE: bash
CODE:
curl -X PUT --data-binary @/home/me/dog-wizard.jpeg "https://storage.googleapis.com/profile-pictures/my-user-id/?x-goog-signature=b7a1<...>"

----------------------------------------

TITLE: Querying Data from SQL Databases with Encore
DESCRIPTION: Demonstrates how to query data from SQL databases using Encore's database functionality. This example retrieves a single todo item and scans the results into a struct.

LANGUAGE: go
CODE:
import "encore.dev/storage/sqldb"

var item struct {
    ID int64
    Title string
    Done bool
}
err := tododb.QueryRow(ctx, `
    SELECT id, title, done
    FROM todo_item
    LIMIT 1
`).Scan(&item.ID, &item.Title, &item.Done)

----------------------------------------

TITLE: Example GraphQL AddBook Mutation
DESCRIPTION: Example query for adding a new book to the system. This GraphQL mutation demonstrates how to create a book with an author and title, returning success information.

LANGUAGE: graphql
CODE:
mutation AddBook {
  addBook(author: "J.R.R. Tolkien", title: "The Hobbit") {
    success
    message
    code
  }
}

----------------------------------------

TITLE: Implementing Availability API Endpoints in Go
DESCRIPTION: Go code implementing two API endpoints - GetAvailability (public) and SetAvailability (authenticated) to manage business hours for each day of the week.

LANGUAGE: go
CODE:
-- booking/availability.go --
package booking

import (
	"context"
	"errors"
	"fmt"

	"encore.app/booking/db"
	"github.com/jackc/pgx/v5/pgtype"

	"encore.dev/beta/errs"
	"encore.dev/rlog"
)

type Availability struct {
	Start *string `json:"start" encore:"optional"`
	End   *string `json:"end" encore:"optional"`
}

type GetAvailabilityResponse struct {
	Availability []Availability
}

//encore:api public method=GET path=/availability
func GetAvailability(ctx context.Context) (*GetAvailabilityResponse, error) {
	rows, err := query.GetAvailability(ctx)
	if err != nil {
		return nil, err
	}

	availability := make([]Availability, 7)
	for _, row := range rows {
		day := row.Weekday
		if day < 0 || day > 6 {
			rlog.Error("invalid week day in availability table", "row", row)
			continue
		}

		// These never fail
		start, _ := row.StartTime.TimeValue()
		end, _ := row.EndTime.TimeValue()
		availability[day] = Availability{
			Start: timeToStr(start),
			End:   timeToStr(end),
		}
	}

	return &GetAvailabilityResponse{Availability: availability}, nil
}

type SetAvailabilityParams struct {
	Availability []Availability
}

//encore:api auth method=POST path=/availability
func SetAvailability(ctx context.Context, params SetAvailabilityParams) error {
	eb := errs.B()
	tx, err := pgxdb.Begin(ctx)
	if err != nil {
		return err
	}
	defer tx.Rollback(context.Background()) // committed explicitly on success

	qry := query.WithTx(tx)
	for weekday, a := range params.Availability {
		if weekday > 6 {
			return eb.Code(errs.InvalidArgument).Msgf("invalid weekday %d", weekday).Err()
		}

		start, err1 := strToTime(a.Start)
		end, err2 := strToTime(a.End)
		if err := errors.Join(err1, err2); err != nil {
			return eb.Cause(err).Code(errs.InvalidArgument).Msg("invalid start/end time").Err()
		} else if start.Valid != end.Valid {
			return eb.Code(errs.InvalidArgument).Msg("both start/stop must be set, or both null").Err()
		} else if start.Valid && start.Microseconds > end.Microseconds {
			return eb.Code(errs.InvalidArgument).Msg("start must be before end").Err()
		}

		err = qry.UpdateAvailability(ctx, db.UpdateAvailabilityParams{
			Weekday:   int16(weekday),
			StartTime: start,
			EndTime:   end,
		})
		if err != nil {
			return eb.Cause(err).Code(errs.Unavailable).Msg("failed to update availability").Err()
		}
	}

	err = tx.Commit(ctx)
	return errs.WrapCode(err, errs.Unavailable, "failed to commit transaction")
}

----------------------------------------

TITLE: Mocking an Individual Endpoint in Encore Tests
DESCRIPTION: Demonstrates how to mock a specific API endpoint using et.MockEndpoint within a test. This approach ensures the mock only affects the current test and any sub-tests, allowing parallel test execution.

LANGUAGE: go
CODE:
package shoppingcart

import (
	"context"
	"testing"
	
	"encore.dev/et" // Encore's test support package
	
	"your_app/products"
)


func Test_Something(t *testing.T) {
	t.Parallel() // Run this test in parallel with other tests without the mock implementation interfering
	
	// Create a mock implementation of pricing API which will only impact this test and any sub-tests
	et.MockEndpoint(products.GetPrice, func(ctx context.Context, p *products.PriceParams) (*products.PriceResponse, error) {
		return &products.PriceResponse{Price: 100}, nil
	})
	
	// ... the rest of your test code here ...
}

----------------------------------------

TITLE: Using Default Values in CUE Configuration
DESCRIPTION: Demonstrates how to specify default values in CUE using the asterisk (*) prefix. The example shows setting a ReadOnlyMode with a default value of false, which can be overridden in specific environments.

LANGUAGE: cue
CODE:
// ReadOnlyMode is a boolean and if we don't provide a value, it
// will default to false.
ReadOnlyMode: bool | *false

if #Meta.Environment.Name == "old-prod" {
    // On this environment, we want to set ReadOnlyMode to true
    ReadOnlyMode: true
}

----------------------------------------

TITLE: Conditional Logic Based on Environment Type in Go
DESCRIPTION: This snippet demonstrates how to use Encore's Metadata API to check the environment type and implement different behavior based on whether the application is running in a test, development, or production environment. The example skips email verification in non-production environments.

LANGUAGE: go
CODE:
package user

import "encore.dev"

//encore:api public
func Signup(ctx context.Context, params *SignupParams) (*SignupResponse, error) {
    // ...

    // If this is a testing environment, skip sending the verification email
    switch encore.Meta().Environment.Type {
    case encore.EnvTest, encore.EnvDevelopment:
        if err := MarkEmailVerified(ctx, userID); err != nil {
            return nil, err
        }
    default:
        if err := SendVerificationEmail(ctx, userID); err != nil {
            return nil, err
        }
    }

    // ...
}

----------------------------------------

TITLE: Publishing Events to a PubSub Topic in Encore
DESCRIPTION: This snippet shows how to publish an event to a previously defined Pub/Sub topic. When successful, it returns a unique message ID that can be used to track the event.

LANGUAGE: typescript
CODE:
const messageID = await signups.publish({userID: id});

// If we get here the event has been successfully published,
// and all registered subscribers will receive the event.

// The messageID variable contains the unique id of the message,
// which is also provided to the subscribers when processing the event.

----------------------------------------

TITLE: Checking Encore VPN Status
DESCRIPTION: Determines the current status of the VPN connection.

LANGUAGE: shell
CODE:
$ encore vpn status

----------------------------------------

TITLE: Configuring kubectl for Encore Kubernetes cluster access
DESCRIPTION: This command configures kubectl to authenticate through Encore and connect to a specific environment's Kubernetes cluster. The -e flag specifies which environment to target.

LANGUAGE: shell
CODE:
encore kubernetes configure -e <environment>

----------------------------------------

TITLE: Implementing an Authentication Handler with Authorization Header in TypeScript
DESCRIPTION: Creates a basic authentication handler that processes the Authorization header to identify users. This handler is attached to a Gateway and will be executed for all incoming requests containing the specified header.

LANGUAGE: typescript
CODE:
import { Header, Gateway } from "encore.dev/api";
import { authHandler } from "encore.dev/auth";

// AuthParams specifies the incoming request information
// the auth handler is interested in. In this case it only
// cares about requests that contain the `Authorization` header.
interface AuthParams {
    authorization: Header<"Authorization">;
}

// The AuthData specifies the information about the authenticated user
// that the auth handler makes available.
interface AuthData {
    userID: string;
}

// The auth handler itself.
export const auth = authHandler<AuthParams, AuthData>(
    async (params) => {
        // TODO: Look up information about the user based on the authorization header.
        return {userID: "my-user-id"};
    }
)

// Define the API Gateway that will execute the auth handler:
export const gateway = new Gateway({
    authHandler: auth,
})

----------------------------------------

TITLE: Downloading Files from Object Storage in Go
DESCRIPTION: Implements an HTTP endpoint for serving a user's profile picture from Object Storage. The function retrieves the user ID from the URL path, downloads the corresponding file, and streams it to the client.

LANGUAGE: go
CODE:
package user

import (
		"context"
		"io"
		"net/http"

		"encore.dev"
		"encore.dev/beta/auth"
		"encore.dev/beta/errs"
		"encore.dev/storage/objects"
)

var ProfilePictures = objects.NewBucket("profile-pictures", objects.BucketConfig{})

//encore:api public raw method=GET path=/profile-picture/:userID
func ServeProfilePicture(w http.ResponseWriter, req *http.Request) {
	userID := encore.CurrentRequest().PathParams.Get("userID")
	reader := ProfilePictures.Download(req.Context(), userID)

	// Did we encounter an error?
	if err := reader.Err(); err != nil {
		errs.HTTPError(w, err)
		return
	}

	// Assuming all images are JPEGs.
	w.Header().Set("Content-Type", "image/jpeg")
	io.Copy(w, reader)
}

----------------------------------------

TITLE: Setting Up Apollo Server and GraphQL API Endpoint
DESCRIPTION: Configures and initializes an Apollo Server instance with the schema and resolvers, then exposes it through an Encore raw API endpoint. This handles all incoming GraphQL requests, processes them through Apollo Server, and returns appropriate responses.

LANGUAGE: typescript
CODE:
import { api } from "encore.dev/api";
import { ApolloServer, HeaderMap } from "@apollo/server";
import { readFileSync } from "node:fs";
import resolvers from "./resolvers";
import { json } from "node:stream/consumers";

const typeDefs = readFileSync("./schema.graphql", { encoding: "utf-8" });

const server = new ApolloServer({
  typeDefs,
  resolvers,
});

await server.start();

export const graphqlAPI = api.raw(
  { expose: true, path: "/graphql", method: "*" },
  async (req, res) => {
    server.assertStarted("/graphql");

    const headers = new HeaderMap();
    for (const [key, value] of Object.entries(req.headers)) {
      if (value !== undefined) {
        headers.set(key, Array.isArray(value) ? value.join(", ") : value);
      }
    }

    // More on how to use executeHTTPGraphQLRequest: https://www.apollographql.com/docs/apollo-server/integrations/building-integrations/
    const httpGraphQLResponse = await server.executeHTTPGraphQLRequest({
      httpGraphQLRequest: {
        headers,
        method: req.method!.toUpperCase(),
        body: await json(req),
        search: new URLSearchParams(req.url ?? "").toString(),
      },
      context: async () => {
        return { req, res };
      },
    });

    for (const [key, value] of httpGraphQLResponse.headers) {
      res.setHeader(key, value);
    }
    res.statusCode = httpGraphQLResponse.status || 200;

    if (httpGraphQLResponse.body.kind === "complete") {
      res.end(httpGraphQLResponse.body.string);
      return;
    }

    for await (const chunk of httpGraphQLResponse.body.asyncIterator) {
      res.write(chunk);
    }
    res.end();
  },
);

----------------------------------------

TITLE: Query Parameter Validation in Encore.ts
DESCRIPTION: This example shows how to validate query parameters using the Query type for HTTP methods that support request bodies, specifying that a field should be parsed from the query string.

LANGUAGE: typescript
CODE:
import { api, Query } from "encore.dev/api";

interface Schema {
  query: Query<string>; // this will be parsed from the '?query=...' parameter in the request url
}
// A simple API endpoint that echoes the data back.
export const echo = api(
  { method: "POST", path: "/example" },
  async (params: Schema) => {
    // params.query is a string
  },
);

----------------------------------------

TITLE: Implementing Reminder Cron Job for Unacknowledged Incidents
DESCRIPTION: A cron job implementation that runs every 10 minutes to check for unacknowledged incidents and sends reminder notifications to Slack. This ensures teams are regularly notified of pending incidents until they are addressed.

LANGUAGE: go
CODE:
// Track unacknowledged incidents
var _ = cron.NewJob("unacknowledged-incidents-reminder", cron.JobConfig{
	Title:    "Notify on Slack about incidents which are not acknowledged",
	Every:    10 * cron.Minute,
	Endpoint: RemindUnacknowledgedIncidents,
})

//encore:api private
func RemindUnacknowledgedIncidents(ctx context.Context) error {
	incidents, err := List(ctx) // we never query for acknowledged incidents
	if err != nil {
		return err
	}
	if incidents == nil {
		return nil
	}

	var items = []string{"These incidents have not been acknowledged yet. Please acknowledge them otherwise you will be reminded every 10 minutes:"}
	for _, incident := range incidents.Items {
		var assignee string
		if incident.Assignee != nil {
			assignee = fmt.Sprintf("%s %s (<@%s>)", incident.Assignee.FirstName, incident.Assignee.LastName, incident.Assignee.SlackHandle)
		} else {
			assignee = "Unassigned"
		}

		items = append(items, fmt.Sprintf("[%s] [#%d] %s", assignee, incident.Id, incident.Body))
	}

	if len(incidents.Items) > 0 {
		_ = slack.Notify(ctx, &slack.NotifyParams{Text: strings.Join(items, "\n")})
	}

	return nil
}

----------------------------------------

TITLE: Creating Public Buckets in Object Storage in Go
DESCRIPTION: Shows how to create a public bucket where objects can be accessed directly via HTTP/HTTPS without authentication, useful for serving static assets.

LANGUAGE: go
CODE:
var PublicAssets = objects.NewBucket("public-assets", objects.BucketConfig{
    Public: true,
})

----------------------------------------

TITLE: Implementing Pub/Sub subscription for site monitoring events
DESCRIPTION: Adds a Pub/Sub subscription to automatically notify Slack when a monitored site changes status (goes up or down).

LANGUAGE: typescript
CODE:
import { Subscription } from "encore.dev/pubsub";
import { TransitionTopic } from "../monitor/check";

const _ = new Subscription(TransitionTopic, "slack-notification", {
  handler: async (event) => {
    const text = `*${event.site.url} is ${event.up ? "back up." : "down!"}*`;
    await notify({ text });
  },
});

----------------------------------------

TITLE: Creating Signed Upload URLs in Encore.ts
DESCRIPTION: Demonstrates how to create signed URLs for direct client uploads to a bucket. The URL is restricted to one filename, has an expiration time, and allows uploads without additional authentication.

LANGUAGE: typescript
CODE:
const uploadUrl = await profilePictures.signedUploadUrl("my-user-id", {ttl: 7200})
// Pass url to client

----------------------------------------

TITLE: Encore API Annotation Syntax
DESCRIPTION: The specific annotation syntax used by Encore to define public API endpoints. This annotation indicates that the function is a public endpoint with a parameterized URL path.

LANGUAGE: go
CODE:
//encore:api public path=/hello/:name

----------------------------------------

TITLE: Creating SQL Databases in Encore
DESCRIPTION: Example of creating a new PostgreSQL database in an Encore service using sqldb.NewDatabase. This defines a logical database resource that can be used throughout the service with built-in migration support.

LANGUAGE: go
CODE:
package todo

var tododb = sqldb.NewDatabase("todo", sqldb.DatabaseConfig{
    Migrations: "./migrations",
})

----------------------------------------

TITLE: Implementing a Booking Endpoint with Encore and PostgreSQL
DESCRIPTION: Go code for a booking service that handles appointment creation. This implementation includes database setup, transaction handling, input validation, and uses the sqlc-generated code for type-safe database operations.

LANGUAGE: go
CODE:
-- booking/booking.go --
package booking

import (
	"context"
	"time"

	"encore.app/booking/db"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/jackc/pgx/v5/pgxpool"

	"encore.dev/beta/errs"
	"encore.dev/storage/sqldb"
)

var (
	bookingDB = sqldb.NewDatabase("booking", sqldb.DatabaseConfig{
		Migrations: "./db/migrations",
	})

	pgxdb = sqldb.Driver[*pgxpool.Pool](bookingDB)
	query = db.New(pgxdb)
)

type Booking struct {
	ID    int64     `json:"id"`
	Start time.Time `json:"start"`
	End   time.Time `json:"end"`
	Email string    `encore:"sensitive"`
}

type BookParams struct {
	Start time.Time `json:"start"`
	Email string    `encore:"sensitive"`
}

//encore:api public method=POST path=/booking
func Book(ctx context.Context, p *BookParams) error {
	eb := errs.B()

	now := time.Now()
	if p.Start.Before(now) {
		return eb.Code(errs.InvalidArgument).Msg("start time must be in the future").Err()
	}

	tx, err := pgxdb.Begin(ctx)
	if err != nil {
		return eb.Cause(err).Code(errs.Unavailable).Msg("failed to start transaction").Err()
	}
	defer tx.Rollback(context.Background()) // committed explicitly on success

	_, err = query.InsertBooking(ctx, db.InsertBookingParams{
		StartTime: pgtype.Timestamp{Time: p.Start, Valid: true},
		EndTime:   pgtype.Timestamp{Time: p.Start.Add(DefaultBookingDuration), Valid: true},
		Email:     p.Email,
	})
	if err != nil {
		return eb.Cause(err).Code(errs.Unavailable).Msg("failed to insert booking").Err()
	}

	if err := tx.Commit(ctx); err != nil {
		return eb.Cause(err).Code(errs.Unavailable).Msg("failed to commit transaction").Err()
	}
	return nil
}

----------------------------------------

TITLE: Checking Encore CLI Version
DESCRIPTION: Reports the current version of the Encore CLI.

LANGUAGE: shell
CODE:
$ encore version

----------------------------------------

TITLE: Running and Comparing Test Output with Encore
DESCRIPTION: Commands to run the application at example.com and compare stderr with expected output.

LANGUAGE: bash
CODE:
run example.com
cmp stderr expected_output

----------------------------------------

TITLE: Clerk Authentication Handler Implementation in Encore
DESCRIPTION: Defines an authentication handler that verifies tokens and retrieves user data from Clerk. This function is marked as an authhandler which Encore uses to authenticate API requests.

LANGUAGE: go
CODE:
//encore:authhandler
func (s *Service) AuthHandler(ctx context.Context, token string) (auth.UID, *UserData, error) {
    // Token verification and user data retrieval
}

----------------------------------------

TITLE: Implementing Site Status Check Functionality in TypeScript
DESCRIPTION: This code defines a 'check' endpoint for a single site, with the core functionality extracted into a 'doCheck' function. It makes a ping request to the site URL and records the result in a database.

LANGUAGE: typescript
CODE:
import {Site} from "../site/site";

// Check checks a single site.
export const check = api(
  { expose: true, method: "POST", path: "/check/:siteID" },
  async (p: { siteID: number }): Promise<{ up: boolean }> => {
    const s = await site.get({ id: p.siteID });
    return doCheck(s);
  },
);

async function doCheck(site: Site): Promise<{ up: boolean }> {
  const { up } = await ping({ url: site.url });
  await MonitorDB.exec`
      INSERT INTO checks (site_id, up, checked_at)
      VALUES (${site.id}, ${up}, NOW())
  `;
  return { up };
}

----------------------------------------

TITLE: Using Bucket References with Multiple Permissions in Object Storage in Go
DESCRIPTION: Demonstrates how to create a bucket reference with multiple permissions by combining permission interfaces. This allows for more fine-grained control over access to bucket operations.

LANGUAGE: go
CODE:
type myPerms interface {
  objects.Downloader
  objects.Uploader
}
ref := objects.BucketRef[myPerms](ProfilePictures)

----------------------------------------

TITLE: Using the errs.Error Structure in Go
DESCRIPTION: The errs.Error type represents structured errors in Encore applications, containing a code, message, user-defined details, and internal metadata. When returned from an API endpoint, it's serialized to JSON with an appropriate HTTP status code.

LANGUAGE: go
CODE:
type Error struct {
	// Code is the error code to return.
	Code ErrCode `json:"code"`
	// Message is a descriptive message of the error.
	Message string `json:"message"`
	// Details are user-defined additional details.
	Details ErrDetails `json:"details"`
	// Meta are arbitrary key-value pairs for use within
	// the Encore application. They are not exposed to external clients.
	Meta Metadata `json:"-"`
}

----------------------------------------

TITLE: Request Body Validation in Encore.ts
DESCRIPTION: This example demonstrates how to validate request body data by default for POST requests, requiring specific fields to be present in the JSON body.

LANGUAGE: typescript
CODE:
interface Request {
  name: string; // Parsed from the JSON body
}

export const myEndpoint = api<Request, Response>(
  { expose: true, method: "POST", path: "/body" },
  async (req) => {
    // req.name is a string
  },
);

----------------------------------------

TITLE: Defining a Pub/Sub Topic for Site Status Transitions in Go
DESCRIPTION: Creates a Pub/Sub topic that will publish events when a monitored site transitions between up and down states. The code defines both the event structure and the topic configuration with an at-least-once delivery guarantee.

LANGUAGE: go
CODE:
package monitor

import "encore.dev/pubsub"

// TransitionEvent describes a transition of a monitored site
// from up->down or from down->up.
type TransitionEvent struct {
	// Site is the monitored site in question.
	Site *site.Site `json:"site"`
	// Up specifies whether the site is now up or down (the new value).
	Up bool `json:"up"`
}

// TransitionTopic is a pubsub topic with transition events for when a monitored site
// transitions from up->down or from down->up.
var TransitionTopic = pubsub.NewTopic[*TransitionEvent]("uptime-transition", pubsub.TopicConfig{
	DeliveryGuarantee: pubsub.AtLeastOnce,
})

----------------------------------------

TITLE: Using rlog.With for Grouped Context Logging in Go
DESCRIPTION: Shows how to use rlog.With to create a context object that includes common key-value pairs for multiple log entries. This approach reduces repetition when logging many messages with the same contextual data.

LANGUAGE: go
CODE:
ctx := rlog.With("is_subscriber", true)
ctx.Info("user logged in", "login_method", "oauth") // includes is_subscriber=true

----------------------------------------

TITLE: Implementing Caching Middleware in Encore
DESCRIPTION: This middleware implements a caching mechanism that checks if a response is cached before forwarding the request to the handler. It targets only APIs with the 'cache' tag as specified in the 'target=tag:cache' directive.

LANGUAGE: go
CODE:
//encore:middleware target=tag:cache
func CachingMiddleware(req middleware.Request, next middleware.Next) middleware.Response {
    data := req.Data()
    // Check if we have the response cached. Use the request path as the cache key.
    cacheKey := data.Path
	if cached, err := loadFromCache(cacheKey, data.API.ResponseType); err == nil && cached != nil {
	    return middleware.Response{Payload: cached}
    }
	// Otherwise forward the request to the handler
	return next(req)
}

----------------------------------------

TITLE: Building and Deploying Encore Docker Images with GitHub Actions
DESCRIPTION: This GitHub Actions workflow demonstrates automating the build, push, and deployment of an Encore Docker image to DigitalOcean. It installs the Encore CLI, builds a Docker image, tags it, and pushes it to DigitalOcean's container registry.

LANGUAGE: yaml
CODE:
name: Build, Push and Deploy a Encore Docker Image to DigitalOcean

on:
  push:
    branches: [ main ]

permissions:
  contents: read
  packages: write

jobs:
  build-push-deploy-image:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download Encore CLI script
        uses: sozo-design/curl@v1.0.2
        with:
          args: --output install.sh -L https://encore.dev/install.sh

      - name: Install Encore CLI
        run: bash install.sh

      - name: Log in to DigitalOcean container registry
        run: docker login registry.digitalocean.com -u my-email@gmail.com -p ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}

      - name: Build Docker image
        run: /home/runner/.encore/bin/encore build docker myapp

      - name: Tag Docker image
        run: docker tag myapp registry.digitalocean.com/<YOUR_CONTAINER_REGISTRY_NAME>/<YOUR_IMAGE_REPOSITORY_NAME>:latest

      - name: Push Docker image
        run: docker push registry.digitalocean.com/<YOUR_CONTAINER_REGISTRY_NAME>/<YOUR_IMAGE_REPOSITORY_NAME>:latest

----------------------------------------

TITLE: Publishing an Event to a Pub/Sub Topic in Encore
DESCRIPTION: Shows how to publish an event to a Pub/Sub topic. This basic usage example publishes a SignupEvent with a user ID and returns the message ID.

LANGUAGE: go
CODE:
messageID, err := Signups.Publish(ctx, &SignupEvent{UserID: id})

----------------------------------------

TITLE: Auto-generated Config Unmarshalers for Encore in Go
DESCRIPTION: Provides automatically generated unmarshalers for configuration types. These functions convert JSON data into the proper Go structs for the Config and ServerOptions types.

LANGUAGE: go
CODE:
var (
	encoreInternalConfigUnmarshaler_ptr_svc_Config = func(itr *jsoniter.Iterator, path []string) *Config {
		return func() *Config {
			// If the value is null, we return nil
			if itr.ReadNil() {
				return nil
			}

			// Otherwise we unmarshal the value and return a pointer to it
			obj := encoreInternalTypeConfigUnmarshaler_svc_Config(itr, append(path))
			return &obj
		}()
	}
)

----------------------------------------

TITLE: Defining Database Schema with Drizzle in Encore.ts
DESCRIPTION: Demonstrates how to define a database schema using Drizzle's pg-core for use with Encore.ts. This example creates a users table with id, name, and email fields.

LANGUAGE: typescript
CODE:
import * as p from "drizzle-orm/pg-core";

export const users = p.pgTable("users", {
  id: p.serial().primaryKey(),
  name: p.text(),
  email: p.text().unique(),
});

----------------------------------------

TITLE: Accessing Another Service's Database in Go with Encore
DESCRIPTION: Go implementation of a report service that connects to and queries the todo service's database. It demonstrates how to establish a cross-service database connection using sqldb.Named() and execute SQL queries against the shared database.

LANGUAGE: go
CODE:
package report

import (
	"context"

	"encore.dev/storage/sqldb"
)

// todoDB connects to the "todo" service's database.
var todoDB = sqldb.Named("todo")

type ReportResponse struct {
    Total int
}

// CountCompletedTodos generates a report with the number of completed todo items.
//encore:api method=GET path=/report/todo
func CountCompletedTodos(ctx context.Context) (*ReportResponse, error) {
    var report ReportResponse
    err := todoDB.QueryRow(ctx,`
        SELECT COUNT(*)
        FROM todo_item
        WHERE completed = TRUE
    `).Scan(&report.Total)
    return &report, err
}

----------------------------------------

TITLE: Template Rendering in Encore.ts with Handlebars
DESCRIPTION: This snippet demonstrates how to render HTML templates in Encore.ts using the api.raw function with Handlebars.js as the templating engine, allowing for dynamic template rendering.

LANGUAGE: typescript
CODE:
import {api} from "encore.dev/api";
import Handlebars from "handlebars";

const html = `
<!doctype html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <link rel="stylesheet" href="/assets/styles.css">
</head>
<body>
<h1>Hello {{name}}!</h1>
</body>
</html>
`;

// Making use of raw endpoints to serve dynamic templates.
// https://encore.dev/docs/ts/primitives/raw-endpoints
export const serveHTML = api.raw(
  {expose: true, path: "/html", method: "GET"},
  async (req, resp) => {
    const template = Handlebars.compile(html);

    resp.setHeader("Content-Type", "text/html");
    resp.end(template({name: "Simon"}));
  },
);

----------------------------------------

TITLE: Querying Data from SQL Database with Encore
DESCRIPTION: Example of querying data from a PostgreSQL database and scanning results into a struct. This demonstrates the standard pattern for database queries in Encore applications.

LANGUAGE: go
CODE:
var item struct {
    ID int64
    Title string
    Done bool
}
err := tododb.QueryRow(ctx, `
    SELECT id, title, done
    FROM todo_item
    LIMIT 1
`).Scan(&item.ID, &item.Title, &item.Done)

----------------------------------------

TITLE: Implementing a Message Handler Function
DESCRIPTION: Defines a handler function for processing PubSub messages. This function is marked as an Encore API endpoint and takes a context and message parameter, returning an error if processing fails.

LANGUAGE: go
CODE:
// encore:api
func Subscriber1(ctx context.Context, msg *shared.MessageType) error {
    return nil
}

----------------------------------------

TITLE: Defining Service Dependencies with Interfaces in Encore
DESCRIPTION: Creates an interface for the SendGrid client to allow for dependency injection and easier testing. The service is marked with the encore:service annotation.

LANGUAGE: go
CODE:
type sendgridClient interface {
    SendEmail(...) // hypothetical signature
}

//encore:service
type Service struct {
    sendgridClient sendgridClient
}

----------------------------------------

TITLE: Defining a Basic Cron Job in TypeScript with Encore
DESCRIPTION: Example of defining a Cron Job that runs every two hours to send welcome emails to new users. The job is registered with a unique ID and configured to call a specific API endpoint.

LANGUAGE: typescript
CODE:
import { CronJob } from "encore.dev/cron";
import { api } from "encore.dev/api";

// Send a welcome email to everyone who signed up in the last two hours.
const _ = new CronJob("welcome-email", {
	title: "Send welcome emails",
	every: "2h",
	endpoint: sendWelcomeEmail,
})

// Emails everyone who signed up recently.
// It's idempotent: it only sends a welcome email to each person once.
export const sendWelcomeEmail = api({}, async () => {
	// Send welcome emails...
});

----------------------------------------

TITLE: Database Connection and API in Encore.ts
DESCRIPTION: Defines a SQLDatabase in Encore.ts with automatic provisioning and migration handling. Implements two API endpoints for retrieving and adding users to the database, showcasing Encore's streamlined database interaction.

LANGUAGE: typescript
CODE:
import {api} from "encore.dev/api";
import {SQLDatabase} from "encore.dev/storage/sqldb";

// Define a database named 'users', using the database migrations in the "./migrations" folder.
// Encore automatically provisions, migrates, and connects to the database.
export const DB = new SQLDatabase("users", {
  migrations: "./migrations",
});

interface User {
  name: string;
  id: number;
}

// Get one User from DB
export const getUser = api(
  {expose: true, method: "GET", path: "/user/:id"},
  async ({id}: { id: number }): Promise<{ user: User | null }> => {
    const user = await DB.queryRow<User>`
        SELECT name
        FROM users
        WHERE id = ${id}
    `;

    return {user};
  },
);

// Add User from DB
export const addUser = api(
  { expose: true, method: "POST", path: "/user" },
  async ({ name }: { name: string }): Promise<void> => {
    await DB.exec`
        INSERT INTO users (name)
        VALUES (${name})
    `;
    return;
  },
);

----------------------------------------

TITLE: Implementing a Simple Auth Handler in Go
DESCRIPTION: This snippet shows a minimal authentication handler implementation that only returns a user ID without custom data. It's useful for simpler authentication scenarios where additional user data isn't needed.

LANGUAGE: go
CODE:
import "encore.dev/beta/auth"

// AuthHandler can be named whatever you prefer (but must be exported).
//encore:authhandler
func AuthHandler(ctx context.Context, token string) (auth.UID, error) {
    // Validate the token and look up the user id,
    // for example by calling Firebase Auth.
}

----------------------------------------

TITLE: Creating a Public Bucket in Encore.ts
DESCRIPTION: Shows how to create a publicly accessible bucket by setting the 'public' property to true. Public buckets allow objects to be accessed via public URLs without authentication.

LANGUAGE: typescript
CODE:
export const publicProfilePictures = new Bucket("public-profile-pictures", {
  public: true,
  versioned: false
});

----------------------------------------

TITLE: Creating Logger Objects with Shared Context in Encore
DESCRIPTION: Shows how to create a logger object with common key-value pairs that will be included in all subsequent log messages. This is useful for adding consistent context to multiple log entries.

LANGUAGE: typescript
CODE:
const logger = log.with({is_subscriber: true})
logger.info("user logged in", {login_method: "oauth"}) // includes is_subscriber=true

----------------------------------------

TITLE: Getting Public URLs for Objects in Encore.ts
DESCRIPTION: Demonstrates how to get the public URL for an object in a public bucket using the 'publicUrl' method. This URL can be used to access the object without authentication.

LANGUAGE: typescript
CODE:
const url = publicProfilePictures.publicUrl("my-image.jpeg");
console.log(`Public URL: ${url}`);

----------------------------------------

TITLE: Defining a Basic Cron Job in Encore
DESCRIPTION: Creates a scheduled job that sends welcome emails every 2 hours by calling the SendWelcomeEmail endpoint. The job uses a unique ID for tracking and includes configuration for title and schedule.

LANGUAGE: go
CODE:
import "encore.dev/cron"

// Send a welcome email to everyone who signed up in the last two hours.
var _ = cron.NewJob("welcome-email", cron.JobConfig{
	Title:    "Send welcome emails",
	Every:    2 * cron.Hour,
	Endpoint: SendWelcomeEmail,
})

// SendWelcomeEmail emails everyone who signed up recently.
// It's idempotent: it only sends a welcome email to each person once.
//encore:api private
func SendWelcomeEmail(ctx context.Context) error {
	// ...
	return nil
}

----------------------------------------

TITLE: Defining a Private API Endpoint in Encore
DESCRIPTION: Defines a private API endpoint for sending emails using a SendGrid client. The endpoint is marked as private with the encore:api annotation.

LANGUAGE: go
CODE:
//encore:api private
func (s *Service) Send(ctx context.Context, p *SendParams) error {
    // Use s.sendgridClient to send emails
}

----------------------------------------

TITLE: Defining API Endpoints with Combined Data Sources in Encore.ts
DESCRIPTION: This example demonstrates how to define an API endpoint that combines data from different sources: query parameters, HTTP headers, and the request body. It shows how Encore.ts uses TypeScript types for validation.

LANGUAGE: typescript
CODE:
import { Header, Query, api } from "encore.dev/api";

interface Request {
  // Optional query parameter. Parsed from the request URL.
  limit?: Query<number>;

  // Custom header that must be set. Parsed from the HTTP headers.
  myHeader: Header<"X-My-Header">;

  // Required enum. Parsed from the request body.
  type: "sprocket" | "widget";
}

export const myEndpoint = api<Request, Response>(
  { expose: true, method: "POST", path: "/api" },
  async ({ limit, myHeader, type }) => {
    // ...
  },
);

----------------------------------------

TITLE: Implementing Webhook Receivers with Raw HTTP Handling
DESCRIPTION: Shows how to implement webhook receivers in Encore using raw HTTP handling. This allows processing of webhooks from external services with direct access to the HTTP request and response objects.

LANGUAGE: go
CODE:
import "net/http"

// Webhook receives incoming webhooks from Some Service That Sends Webhooks.
//encore:api public raw
func Webhook(w http.ResponseWriter, req *http.Request) {
    // ... operate on the raw HTTP request ...
}

----------------------------------------

TITLE: Testing Express.js Apps with Vitest and Supertest
DESCRIPTION: This snippet shows how to test Express.js applications using Vitest and Supertest. It demonstrates making fake HTTP requests to test API endpoints without starting the server.

LANGUAGE: typescript
CODE:
import {describe, expect, test} from "vitest";
import request from "supertest";
import express from "express";
import getRequestExample from "../get-request-example";

/**
 * We need to add the supertest library to make fake HTTP requests to the Express.js app without having to
 * start the server. We also use the vitest library to write tests.
 */
describe("Express App", () => {
  const app = express();
  app.use("/", getRequestExample);

  test("should respond with a greeting message", async () => {
    const response = await request(app).get("/hello/John");
    expect(response.status).to.equal(200);
    expect(response.body).to.have.property("message");
    expect(response.body.message).to.equal("Hello John!");
  });
});

----------------------------------------

TITLE: Downloading Files from a Storage Bucket
DESCRIPTION: Demonstrates how to download files from a storage bucket using the download method. This simple example retrieves a specific file by name.

LANGUAGE: typescript
CODE:
const data = await profilePictures.download("my-image.jpeg");

----------------------------------------

TITLE: Setting Up PubSub Topics in Encore
DESCRIPTION: Defines two PubSub topics with different delivery guarantees in a shared package. BasicTopic uses at-least-once delivery while AnotherTopic uses exactly-once delivery. Both topics accept MessageType pointer as the message format.

LANGUAGE: go
CODE:
package shared

import (
    "encore.dev/pubsub"
)

type MessageType struct {
    Name string
}

var (
    BasicTopic = pubsub.NewTopic[*MessageType]("basic-topic", pubsub.TopicConfig{ DeliveryGuarantee: pubsub.AtLeastOnce })
    AnotherTopic = pubsub.NewTopic[*MessageType]("another-topic", pubsub.TopicConfig{ DeliveryGuarantee: pubsub.ExactlyOnce })
)

----------------------------------------

TITLE: Creating Directory Structure for Book Service
DESCRIPTION: Shell commands to create the directory and file structure needed for the Book service in an Encore application.

LANGUAGE: shell
CODE:
$ mkdir book
$ touch book/encore.service.ts

----------------------------------------

TITLE: Creating a Subscription to a PubSub Topic in Encore
DESCRIPTION: This code shows how to create a subscription to a Pub/Sub topic. The subscription includes a handler function that processes each event as it arrives, and can be placed in the same service as the topic or in any other service.

LANGUAGE: typescript
CODE:
import { Subscription } from "encore.dev/pubsub";

const _ = new Subscription(signups, "send-welcome-email", {
    handler: async (event) => {
        // Send a welcome email using the event.
    },
});

----------------------------------------

TITLE: Authentication Implementation in Express.js vs Encore.ts
DESCRIPTION: Shows how authentication is handled in Express.js using middleware functions compared to Encore.ts's dedicated authentication handlers. Encore provides a more structured approach with built-in integration between auth handlers and API endpoints.

LANGUAGE: typescript
CODE:
import express, {NextFunction, Request, Response} from "express";

const app: Express = express();

// Auth middleware
function authMiddleware(req: Request, res: Response, next: NextFunction) {
  // TODO: Validate up auth token and verify that this is an authenticated user
  const isInvalidUser = req.headers["authorization"] === undefined;

  if (isInvalidUser) {
    res.status(401).json({error: "invalid request"});
  } else {
    next();
  }
}

// Endpoint that requires auth
app.get("/dashboard", authMiddleware, (_, res: Response) => {
  res.json({message: "Secret dashboard message"});
});

LANGUAGE: typescript
CODE:
import { api, APIError, Gateway, Header } from "encore.dev/api";
import { authHandler } from "encore.dev/auth";
import { getAuthData } from "~encore/auth";

interface AuthParams {
  authorization: Header<"Authorization">;
}

// The function passed to authHandler will be called for all incoming API call that requires authentication.
export const myAuthHandler = authHandler(
  async (params: AuthParams): Promise<{ userID: string }> => {
    // TODO: Validate up auth token and verify that this is an authenticated user
    const isInvalidUser = params.authorization === undefined;

    if (isInvalidUser) {
      throw APIError.unauthenticated("Invalid user ID");
    }

    return { userID: "user123" };
  },
);

export const gateway = new Gateway({ authHandler: myAuthHandler });

// Auth endpoint example
export const dashboardEndpoint = api(
  // Setting auth to true will require the user to be authenticated
  { auth: true, method: "GET", path: "/dashboard" },
  async (): Promise<{ message: string; userID: string }> => {
    return {
      message: "Secret dashboard message",
      userID: getAuthData()!.userID,
    };
  },
);

----------------------------------------

TITLE: SQL Database Configuration
DESCRIPTION: Configuration for SQL databases used by the application. Specifies connection details, TLS settings, and credentials for each database server and database.

LANGUAGE: json
CODE:
{
  "sql_servers": [
    {
      "host": "db.myencoreapp.com:5432",
      "tls_config": {
        "disabled": false,
        "ca": "---BEGIN CERTIFICATE---\n...",
        "disable_tls_hostname_verification": false,
        "disable_ca_verification": false
      },
      "databases": {
        "my-database": {
          "name": "my-postgres-db-name",
          "max_connections": 100,
          "min_connections": 10,
          "username": "db_user",
          "password": {
            "$env": "DB_PASSWORD"
          }
        }
      }
    }
  ]
}

----------------------------------------

TITLE: Running Encore Applications with Run Command
DESCRIPTION: Runs your Encore application locally with optional debug mode and file watching capabilities.

LANGUAGE: shell
CODE:
$ encore run [--debug] [--watch=true] [flags]

----------------------------------------

TITLE: Creating PostgreSQL Database Schema for URL Shortener
DESCRIPTION: SQL migration file to create the database schema for storing shortened URLs. Defines a table with columns for the URL ID and the original URL.

LANGUAGE: sql
CODE:
CREATE TABLE url (
	id TEXT PRIMARY KEY,
	original_url TEXT NOT NULL
);

----------------------------------------

TITLE: Encore Request Client Configuration
DESCRIPTION: Utility function that creates and configures an Encore API client for the appropriate environment. It automatically adds authentication tokens to requests and sets the correct API environment based on development mode.

LANGUAGE: ts
CODE:
import Client, { Environment, Local } from "./client.ts";
import Cookies from "js-cookie";

/**
 * Returns the generated Encore request client for either the local or staging environment.
 * If we are running the frontend locally (development) we assume that our Encore
 * backend is also running locally.
 */
const getRequestClient = () => {
  const token = Cookies.get("auth-token");
  const env = import.meta.env.DEV ? Local : Environment("staging");

  return new Client(env, {
    auth: token,
  });
};

export default getRequestClient;

----------------------------------------

TITLE: Defining a raw HTTP endpoint for webhooks in Encore Go
DESCRIPTION: This snippet demonstrates how to define a raw endpoint for receiving webhooks in an Encore Go application. It uses the //encore:api annotation with the 'raw' modifier and the standard Go HTTP handler signature.

LANGUAGE: go
CODE:
package service

import "net/http"

// Webhook receives incoming webhooks from Some Service That Sends Webhooks.
//encore:api public raw method=POST path=/webhook
func Webhook(w http.ResponseWriter, req *http.Request) {
    // ... operate on the raw HTTP request ...
}

----------------------------------------

TITLE: GraphQL Mutation for Shortening URLs
DESCRIPTION: Example GraphQL mutation query for shortening a URL that can be used in the GraphQL playground to test the API.

LANGUAGE: graphql
CODE:
mutation {
    shorten(input: "https://encore.dev") {
        id
    }
}

----------------------------------------

TITLE: Running an Encore Project with Test Comparison
DESCRIPTION: Commands to run the Encore application at example.com and compare stderr with expected output.

LANGUAGE: bash
CODE:
run example.com
cmp stderr expected_output

----------------------------------------

TITLE: Implementing ping functionality to check website status
DESCRIPTION: TypeScript implementation of the ping endpoint that checks if a website is up or down by making an HTTP request and determining the status based on the response code.

LANGUAGE: typescript
CODE:
// Service monitor checks if a website is up or down.
import { api } from "encore.dev/api";

export interface PingParams {
  url: string;
}

export interface PingResponse {
  up: boolean;
}

// Ping pings a specific site and determines whether it's up or down right now.
export const ping = api<PingParams, PingResponse>(
  { expose: true, path: "/ping/:url", method: "GET" },
  async ({ url }) => {
    // If the url does not start with "http:" or "https:", default to "https:".
    if (!url.startsWith("http:") && !url.startsWith("https:")) {
      url = "https://" + url;
    }

    try {
      // Make an HTTP request to check if it's up.
      const resp = await fetch(url, { method: "GET" });
      // 2xx and 3xx status codes are considered up
      const up = resp.status >= 200 && resp.status < 300;
      return { up };
    } catch (err) {
      return { up: false };
    }
  }
);

----------------------------------------

TITLE: Checking if an Object Exists in Storage with Encore.ts
DESCRIPTION: Demonstrates how to check if an object exists in a bucket using the 'exists' method, which returns a boolean indicating whether the specified object exists.

LANGUAGE: typescript
CODE:
const exists = await profilePictures.exists("my-image.jpeg");

----------------------------------------

TITLE: Generated Service Registration (encore_internal__svcstruct.go)
DESCRIPTION: Auto-generated code that registers the service with Encore's runtime system. It creates a service declaration that can be used to instantiate the service.

LANGUAGE: go
CODE:
package svca

import __service "encore.dev/appruntime/apisdk/service"

func init() {
	__service.Register(EncoreInternal_svcstruct_Service)
}

var EncoreInternal_svcstruct_Service = &__service.Decl[Service]{
	Name:        "Service",
	Service:     "svca",
	Setup:       nil,
	SetupDefLoc: uint32(0x0),
}

----------------------------------------

TITLE: Implementing Website Status Checking in Go
DESCRIPTION: Implementation of the Ping API endpoint that checks if a website is up by making an HTTP request and determining status based on HTTP response codes. The function takes a URL as input and returns a response with the site status.

LANGUAGE: go
CODE:
// Service monitor checks if a website is up or down.
package monitor

import (
	"context"
	"net/http"
	"strings"
)

// PingResponse is the response from the Ping endpoint.
type PingResponse struct {
	Up bool `json:"up"`
}

// Ping pings a specific site and determines whether it's up or down right now.
//
//encore:api public path=/ping/*url
func Ping(ctx context.Context, url string) (*PingResponse, error) {
    // If the url does not start with "http:" or "https:", default to "https:".
	if !strings.HasPrefix(url, "http:") && !strings.HasPrefix(url, "https:") {
		url = "https://" + url
	}

    // Make an HTTP request to check if it's up.
	req, err := http.NewRequestWithContext(ctx, "GET", url, nil)
	if err != nil {
		return nil, err
	}
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return &PingResponse{Up: false}, nil
	}
	resp.Body.Close()

    // 2xx and 3xx status codes are considered up
    up := resp.StatusCode < 400
    return &PingResponse{Up: up}, nil
}

----------------------------------------

TITLE: Configuring Middleware Order in Encore.ts
DESCRIPTION: Shows how to specify the execution order of middleware in an Encore.ts service. Middleware functions will be executed in the order they are defined in the middlewares array.

LANGUAGE: typescript
CODE:
export default new Service("myService", {
    middlewares: [
        first,
        second,
        third
    ],
});

----------------------------------------

TITLE: Making a Request to a Raw Endpoint with cURL
DESCRIPTION: This example demonstrates how to call a raw endpoint using cURL. The endpoint returns a plain text response with the message 'Hello, raw world!'.

LANGUAGE: shell
CODE:
$ curl http://localhost:4000/raw
Hello, raw world!

----------------------------------------

TITLE: Basic Structured Logging with rlog in Go
DESCRIPTION: Demonstrates how to use rlog.Info and rlog.Error to create structured logs with contextual key-value pairs. The first parameter is the log message, followed by pairs of keys and values that provide additional context to the log entry.

LANGUAGE: go
CODE:
rlog.Info("log message",
	"user_id", 12345,
	"is_subscriber", true)
rlog.Error("something went terribly wrong!",
	"err", err)

----------------------------------------

TITLE: Mounting Connect Service in Encore with Raw Endpoints
DESCRIPTION: Code to integrate the Connect service with Encore using service structs and raw endpoints. This creates an HTTP handler that forwards requests to the Connect service implementation, allowing it to be exposed through Encore's API gateway.

LANGUAGE: go
CODE:
package greet

import (
	"net/http"

	"encore.app/gen/greet/v1/greetv1connect"
	"golang.org/x/net/http2"
	"golang.org/x/net/http2/h2c"
)

//encore:service
type Service struct {
	routes http.Handler
}

//encore:api public raw path=/greet.v1.GreetService/*endpoint
func (s *Service) GreetService(w http.ResponseWriter, req *http.Request) {
	s.routes.ServeHTTP(w, req)
}

func initService() (*Service, error) {
	greeter := &GreetServer{}
	mux := http.NewServeMux()
	path, handler := greetv1connect.NewGreetServiceHandler(greeter)
	mux.Handle(path, handler)
	return &Service{routes: mux}, nil
}

----------------------------------------

TITLE: Configuring AWS S3 in Encore
DESCRIPTION: JSON configuration for AWS S3 storage buckets in an Encore application. Specifies region, bucket name, optional key prefixes, and public access URLs. Essential for applications requiring file storage, backups, or content distribution.

LANGUAGE: json
CODE:
{
  "object_storage": [
    {
      "type": "s3",
      "region": "us-east-1",
      "buckets": {
        "my-s3-bucket": {
          "name": "my-s3-bucket",
          "key_prefix": "my-optional-prefix/",
          "public_base_url": "https://my-gcs-bucket-cdn.example.com/my-optional-prefix"
        }
      }
    }
  ]
}

----------------------------------------

TITLE: Configuring Kubernetes for Encore
DESCRIPTION: Updates kubectl configuration to point to the Kubernetes clusters for the specified Encore environment.

LANGUAGE: shell
CODE:
$ encore k8s configure --env=ENV_NAME

----------------------------------------

TITLE: Protected Resource Component Using Logto Authentication
DESCRIPTION: This React component demonstrates how to create a protected resource that requires authentication. It uses the useLogto hook to check authentication status, fetch access tokens, and make authenticated API requests to the Encore API endpoint.

LANGUAGE: tsx
CODE:
import { useLogto } from "@logto/react";
import { useState } from "react";
import { Navigate } from "react-router-dom";
import { appConfig, encoreApiEndpoint } from "../config/logto";

export function ProtectedResource() {
  const { isAuthenticated, getAccessToken } = useLogto();
  const [message, setMessage] = useState("");
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState("");

  const fetchProtectedResource = async () => {
    setIsLoading(true);
    setError("");
    try {
      const accessToken = await getAccessToken(appConfig.apiResourceIndicator);
      const response = await fetch(`${encoreApiEndpoint}/api/hello`, {
        headers: {
          Authorization: `Bearer ${accessToken}`,
        },
      });
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      setMessage(JSON.stringify(data));
    } catch (error) {
      console.error("Error fetching protected resource:", error);
      setError("Failed to fetch protected resource. Please try again.");
    } finally {
      setIsLoading(false);
    }
  };

  if (!isAuthenticated) {
    return <Navigate to="/" replace />;
  }

  return (
    <div>
      <h2>Protected Resource</h2>

      {message && !error && (
        <div>
          <h3>Response from Protected API</h3>
          <pre>{message}</pre>
        </div>
      )}

      <button
        onClick={fetchProtectedResource}
        disabled={isLoading}
      >
        {isLoading ? "Loading..." : "Fetch protected resource"}
      </button>

      {error && <div>{error}</div>}
    </div>
  );
}

----------------------------------------

TITLE: Service Filtering for API Client Generation
DESCRIPTION: Example of generating a TypeScript client for specific services using the '--services' flag to narrow down the output.

LANGUAGE: shell
CODE:
encore gen client --services=email,users -o client.ts

----------------------------------------

TITLE: Retrieving Files from Database in Encore.ts
DESCRIPTION: This endpoint retrieves files from the database by name and serves them back to clients. It extracts the file name from the path parameter, queries the database for the file's binary data, and returns it with appropriate headers.

LANGUAGE: typescript
CODE:
import { api } from "encore.dev/api";
import { APICallMeta, currentRequest } from "encore.dev"; 

export const DB = new SQLDatabase("files", {
  migrations: "./migrations",
});

export const get = api.raw(
  { expose: true, method: "GET", path: "/files/:name" },
  async (req, resp) => {
    try {
      const { name } = (currentRequest() as APICallMeta).pathParams;
      const row = await DB.queryRow`
          SELECT data
          FROM files
          WHERE name = ${name}`;
      if (!row) {
        resp.writeHead(404);
        resp.end("File not found");
        return;
      }

      const chunk = Buffer.from(row.data);
      resp.writeHead(200, { Connection: "close" });
      resp.end(chunk);
    } catch (err) {
      resp.writeHead(500);
      resp.end((err as Error).message);
    }
  },
);

----------------------------------------

TITLE: Implementing an Encore API for Cron Job Execution
DESCRIPTION: This code defines an Encore API endpoint that serves as the target function for cron job execution. It returns a simple response with a message. The function is marked as a public API accessible at the '/cron' path.

LANGUAGE: go
CODE:
//encore:api public path=/cron
func Cron(ctx context.Context) (*Response, error) {
	msg := "Hello, Cron!"
	return &Response{Message: msg}, nil
}

type Response struct {
	Message string
}

----------------------------------------

TITLE: Implementing Image Search API with Pexels Integration
DESCRIPTION: API endpoint that proxies image search requests to the Pexels API. It requires a Pexels API key stored as an Encore secret and returns formatted image search results.

LANGUAGE: go
CODE:
//encore:api public method=GET path=/images/:query
func SearchPhoto(ctx context.Context, query string) (*SearchResponse, error) {
	// Create a new http client to proxy the request to the Pexels API.
	URL := "https://api.pexels.com/v1/search?query=" + query
	client := &http.Client{}
	req, _ := http.NewRequest("GET", URL, nil)

	// Add authorization header to the req with the API key.
	req.Header.Set("Authorization", secrets.PexelsApiKey)

	// Make the request, and close the response body when we're done.
	res, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()

	if res.StatusCode >= 400 {
		return nil, fmt.Errorf("Pexels API error: %s", res.Status)
	}

	// Decode the data into the searchResponse struct.
	var searchResponse *SearchResponse
	err = json.NewDecoder(res.Body).Decode(&searchResponse)
	if err != nil {
		return nil, err
	}

	return searchResponse, nil
}

----------------------------------------

TITLE: Unarchiving an Encore Secret
DESCRIPTION: Restores a previously archived secret value by its ID.

LANGUAGE: shell
CODE:
$  encore secret unarchive <id>

----------------------------------------

TITLE: Defining a Simple Encore API Endpoint in Go
DESCRIPTION: Declares a simple API endpoint using Encore's API directive. The function accepts a context parameter and returns only an error, implementing the minimal interface required for an Encore API endpoint.

LANGUAGE: go
CODE:
package svc

import (
	"context"
)

//encore:api
func MyAPI(ctx context.Context) (error) {
	return nil
}

----------------------------------------

TITLE: Creating a PubSub Topic in TypeScript with Encore
DESCRIPTION: This code snippet demonstrates how to create a Pub/Sub topic in Encore's Backend Framework. The topic is configured for 'at-least-once' delivery and uses a custom event type to define the structure of the messages.

LANGUAGE: typescript
CODE:
import { Topic } from "encore.dev/pubsub"

export interface SignupEvent {
    userID: string;
}

export const signups = new Topic<SignupEvent>("signups", {
    deliveryGuarantee: "at-least-once",
});

----------------------------------------

TITLE: Calling Streaming APIs Between Services
DESCRIPTION: Shows how to use streaming endpoints for service-to-service communication. This example demonstrates importing a service client and establishing a stream connection.

LANGUAGE: typescript
CODE:
import { service } from "~encore/clients";
const stream = await service.streamEndpoint();

----------------------------------------

TITLE: Stopping Encore VPN Connection
DESCRIPTION: Terminates the active VPN connection.

LANGUAGE: shell
CODE:
$ encore vpn stop

----------------------------------------

TITLE: Complete Infrastructure Configuration Example
DESCRIPTION: Comprehensive example of an Encore infrastructure configuration file. It demonstrates configuration for application metadata, SQL databases, service discovery, Redis, metrics, graceful shutdown, authentication, secrets, Pub/Sub, and object storage.

LANGUAGE: json
CODE:
{
  "$schema": "https://encore.dev/schemas/infra.schema.json",
  "metadata": {
    "app_id": "my-app",
    "env_name": "my-env",
    "env_type": "production",
    "cloud": "gcp",
    "base_url": "https://my-app.com"
  },
  "sql_servers": [
    {
      "host": "my-db-host:5432",
      "databases": {
        "my-db": {
          "username": "my-db-owner",
          "password": {"$env": "DB_PASSWORD"}
        }
      }
    }
  ],
  "service_discovery": {
    "myservice": {
      "base_url": "https://myservice:8044"
    }
  },
  "redis": {
    "my-redis": {
      "database_index": 0,
      "auth": {
        "type": "acl",
        "username": "encoreredis",
        "password": {"$env": "REDIS_PASSWORD"}
      },
      "host": "my-redis-host",
    }
  },
  "metrics": {
    "type": "prometheus",
    "remote_write_url": "https://my-remote-write-url"
  },
  "graceful_shutdown": {
    "total": 30
  },
  "auth": [
    {
      "type": "key",
      "id": 1,
      "key": {"$env": "SVC_TO_SVC_KEY"}
    }
  ],
  "secrets": {
    "AppSecret": {"$env": "APP_SECRET"}
  },
  "pubsub": [
    {
      "type": "gcp_pubsub",
      "project_id": "my-project",
      "topics": {
        "my-topic": {
          "name": "gcp-topic-name",
          "subscriptions": {
            "encore-subscription": {
              "name": "gcp-subscription-name"
            }
          }
        }
      }
    }
  ],
  "object_storage": [
    {
      "type": "gcs",
      "buckets": {
          "my-gcs-bucket": {
            "name": "my-gcs-bucket",
          }
        }
    }
  ]
}

----------------------------------------

TITLE: Validating String Fields in Encore.ts
DESCRIPTION: This example shows how to validate string fields in request schemas using Encore.ts's type system.

LANGUAGE: typescript
CODE:
interface Schema {
  name:  string;
}

----------------------------------------

TITLE: Complete Infrastructure Configuration Example
DESCRIPTION: Comprehensive example of an Encore infrastructure configuration file. It demonstrates configuration for application metadata, SQL databases, service discovery, Redis, metrics, graceful shutdown, authentication, secrets, Pub/Sub, and object storage.

LANGUAGE: json
CODE:
{
  "$schema": "https://encore.dev/schemas/infra.schema.json",
  "metadata": {
    "app_id": "my-app",
    "env_name": "my-env",
    "env_type": "production",
    "cloud": "gcp",
    "base_url": "https://my-app.com"
  },
  "sql_servers": [
    {
      "host": "my-db-host:5432",
      "databases": {
        "my-db": {
          "username": "my-db-owner",
          "password": {"$env": "DB_PASSWORD"}
        }
      }
    }
  ],
  "service_discovery": {
    "myservice": {
      "base_url": "https://myservice:8044"
    }
  },
  "redis": {
    "my-redis": {
      "database_index": 0,
      "auth": {
        "type": "acl",
        "username": "encoreredis",
        "password": {"$env": "REDIS_PASSWORD"}
      },
      "host": "my-redis-host",
    }
  },
  "metrics": {
    "type": "prometheus",
    "remote_write_url": "https://my-remote-write-url"
  },
  "graceful_shutdown": {
    "total": 30
  },
  "auth": [
    {
      "type": "key",
      "id": 1,
      "key": {"$env": "SVC_TO_SVC_KEY"}
    }
  ],
  "secrets": {
    "AppSecret": {"$env": "APP_SECRET"}
  },
  "pubsub": [
    {
      "type": "gcp_pubsub",
      "project_id": "my-project",
      "topics": {
        "my-topic": {
          "name": "gcp-topic-name",
          "subscriptions": {
            "encore-subscription": {
              "name": "gcp-subscription-name"
            }
          }
        }
      }
    }
  ],
  "object_storage": [
    {
      "type": "gcs",
      "buckets": {
          "my-gcs-bucket": {
            "name": "my-gcs-bucket",
          }
        }
    }
  ]
}

----------------------------------------

TITLE: Generating API Clients with Encore CLI
DESCRIPTION: Examples of using the 'encore gen client' command to generate type-safe clients in different languages, targeting different environments.

LANGUAGE: shell
CODE:
# Generate a TypeScript client for calling the hello-a8bc application based on the primary environment
encore gen client hello-a8bc --output=./client.ts

# Generate a Go client for the hello-a8bc application based on the locally running code
encore gen client hello-a8bc --output=./client.go --env=local

# Generate an OpenAPI client for the hello-a8bc application based on the primary environment
encore gen client hello-a8bc --lang=openapi --output=./openapi.json

----------------------------------------

TITLE: Customizing Encore Docker Builds with CLI Options
DESCRIPTION: Examples of using the 'encore build docker' command with various options to customize Docker builds. Shows how to build specific services and gateways, and how to specify a custom base image for the Docker container.

LANGUAGE: bash
CODE:
# Build specific services and gateways
encore build docker --services=service1,service2 --gateways=api-gateway MY-IMAGE:TAG

# Customize the base image
encore build docker --base=node:18-alpine MY-IMAGE:TAG

----------------------------------------

TITLE: Configuring NSQ in Encore
DESCRIPTION: JSON configuration for setting up NSQ messaging system in an Encore application. The example defines an order-events topic with a subscription for order processing, specifying the NSQ host, topic name, and subscription name.

LANGUAGE: json
CODE:
{
  "pubsub": [
    {
      "type": "nsq",
      "hosts": "nsq.myencoreapp.com:4150",
      "topics": {
        "order-events": {
          "name": "order-events-topic",
          "subscriptions": {
            "order-processor": {
              "name": "order-processor-subscription"
            }
          }
        }
      }
    }
  ]
}

----------------------------------------

TITLE: Setting Encore Secrets
DESCRIPTION: Sets a secret value for specified environment types including production, development, preview, and local environments.

LANGUAGE: shell
CODE:
$ encore secret set --type <types> <secret-name>

----------------------------------------

TITLE: Implementing Advanced Cron Job with Cron Expression
DESCRIPTION: Demonstrates how to use cron expressions for more advanced scheduling needs. This example schedules an accounting sync job to run at 4am UTC on the 15th day of each month.

LANGUAGE: go
CODE:
// Run the monthly accounting sync job at 4am (UTC) on the 15th day of each month.
var _ = cron.NewJob("accounting-sync", cron.JobConfig{
	Title:    "Cron Job Example",
	Schedule: "0 4 15 * *",
	Endpoint: AccountingSync,
})

----------------------------------------

TITLE: Fetching and Using Access Token with Logto React SDK
DESCRIPTION: This snippet demonstrates how to obtain an access token using the getAccessToken method from the Logto React SDK and use it in subsequent API requests to the Encore API by adding it to the Authorization header.

LANGUAGE: typescript
CODE:
const { getAccessToken } = useLogto();
const accessToken = await getAccessToken('<your-api-resource-indicator>');

// Add this access token to the request headers as the 'Authorization' field in subsequent requests
fetch('<your-encore-api-endpoint>/hello', {
  headers: {
    Authorization: `Bearer ${accessToken}`,
  },
});

----------------------------------------

TITLE: Generating API Clients with Encore CLI
DESCRIPTION: Examples of using the 'encore gen client' command to generate type-safe clients in different languages, targeting different environments.

LANGUAGE: shell
CODE:
# Generate a TypeScript client for calling the hello-a8bc application based on the primary environment
encore gen client hello-a8bc --output=./client.ts

# Generate a Go client for the hello-a8bc application based on the locally running code
encore gen client hello-a8bc --output=./client.go --env=local

# Generate an OpenAPI client for the hello-a8bc application based on the primary environment
encore gen client hello-a8bc --lang=openapi --output=./openapi.json

----------------------------------------

TITLE: Configuring CORS Settings in Encore Application CUE File
DESCRIPTION: CUE configuration structure for overriding default CORS settings in an Encore application through the global_cors key in the encore.app file. It defines fields for debug logging, allowed headers, exposed headers, and origin permissions both with and without credentials.

LANGUAGE: cue
CODE:
{
    // debug enables CORS debug logging.
    "debug": true | false,

    // allow_headers allows an app to specify additional headers that should be
    // accepted by the app.
    //
    // If the list contains "*", then all headers are allowed.
    "allow_headers": [...string],

    // expose_headers allows an app to specify additional headers that should be
    // exposed from the app, beyond the default set always recognized by Encore.
    //
    // If the list contains "*", then all headers are exposed.
    "expose_headers": [...string],

    // allow_origins_without_credentials specifies the allowed origins for requests
    // that don't include credentials. If nil it defaults to allowing all domains
    // (equivalent to ["*"]).
    "allow_origins_without_credentials": [...string],

    // allow_origins_with_credentials specifies the allowed origins for requests
    // that include credentials. If a request is made from an Origin in this list
    // Encore responds with Access-Control-Allow-Origin: <Origin>.
    //
    // The URLs in this list may include wildcards (e.g. "https://*.example.com"
    // or "https://*-myapp.example.com").
    "allow_origins_with_credentials": [...string],
}

----------------------------------------

TITLE: Displaying Current Logged In User
DESCRIPTION: Shows information about the currently authenticated Encore user.

LANGUAGE: shell
CODE:
$ encore auth whoami

----------------------------------------

TITLE: Implementing Booking Helper Functions in Go
DESCRIPTION: Go functions to list bookings between time periods and filter bookable slots based on existing bookings and current time.

LANGUAGE: go
CODE:
func listBookingsBetween(
	ctx context.Context,
	start, end time.Time,
) ([]*Booking, error) {
	rows, err := query.ListBookingsBetween(ctx, db.ListBookingsBetweenParams{
		StartTime: pgtype.Timestamp{Time: start, Valid: true},
		EndTime:   pgtype.Timestamp{Time: end, Valid: true},
	})
	if err != nil {
		return nil, err
	}
	var bookings []*Booking
	for _, row := range rows {
		bookings = append(bookings, &Booking{
			ID:    row.ID,
			Start: row.StartTime.Time,
			End:   row.EndTime.Time,
			Email: row.Email,
		})
	}
	return bookings, nil
}

func filterBookableSlots(
	slots []BookableSlot,
	now time.Time,
	bookings []*Booking,
) []BookableSlot {
	// Remove slots for which the start time has already passed.
	slots = slices.DeleteFunc(slots, func(s BookableSlot) bool {
		// Has the slot already passed?
		if s.Start.Before(now) {
			return true
		}

		// Is there a booking that overlaps with this slot?
		for _, b := range bookings {
			if b.Start.Before(s.End) && b.End.After(s.Start) {
				return true
			}
		}

		return false
	})
	return slots
}

----------------------------------------

TITLE: Disabling Telemetry Using Environment Variable
DESCRIPTION: Shows how to disable Encore telemetry by setting the DISABLE_ENCORE_TELEMETRY environment variable to 1, providing an alternative method to the CLI command.

LANGUAGE: sh
CODE:
export DISABLE_ENCORE_TELEMETRY=1

----------------------------------------

TITLE: Generating TypeScript API Client for Preview Environment
DESCRIPTION: Command to generate a new TypeScript API client for a specific preview environment. This is useful when your pull request makes changes to the API and you need to update your frontend client accordingly.

LANGUAGE: bash
CODE:
encore gen client --env=pr:72 --lang=typescript my-app

----------------------------------------

TITLE: Using Secret Values in API Calls
DESCRIPTION: Demonstrates how to use a secret value in an HTTP request by calling the secret function to retrieve the stored value. This example shows integrating with the GitHub API using a stored token.

LANGUAGE: ts
CODE:
async function callGitHub() {
  const resp = await fetch("https:///api.github.com/user", {
    credentials: "include",
    headers: {
      Authorization: `token ${githubToken()}`,
    },
  });
  // ... handle resp
}

----------------------------------------

TITLE: Overriding Local Secrets in CUE Format
DESCRIPTION: Shows how to create local secret overrides by defining a .secrets.local.cue file. This allows developers to use different secret values on their local machine without affecting other environments or team members.

LANGUAGE: cue
CODE:
GitHubAPIToken: "my-local-override-token"
SSHPrivateKey: "custom-ssh-private-key"

----------------------------------------

TITLE: Defining Request and Response Schemas for Encore APIs
DESCRIPTION: Shows how to define structured request parameters and response types for Encore API endpoints. These types will be automatically serialized/deserialized when the API is called.

LANGUAGE: go
CODE:
// PingParams is the request data for the Ping endpoint.
type PingParams struct {
    Name string
}

// PingResponse is the response data for the Ping endpoint.
type PingResponse struct {
    Message string
}

----------------------------------------

TITLE: Registering Temporal Workflow and Activity in Encore Service
DESCRIPTION: Updates the Encore service to register the Greeting workflow and ComposeGreeting activity with the Temporal worker. This is required for Temporal to recognize and execute the workflow and activity.

LANGUAGE: go
CODE:
// Import the package at the top:
import "encore.app/greeting/workflow"

// Add these lines to `initService`, below the call to `worker.New`:
w.RegisterWorkflow(workflow.Greeting)
w.RegisterActivity(workflow.ComposeGreeting)

----------------------------------------

TITLE: Redis Configuration for Encore
DESCRIPTION: JSON configuration for setting up Redis connections in Encore applications, including host, authentication, and connection pooling settings.

LANGUAGE: json
CODE:
{
  "redis": {
    "cache": {
      "host": "redis.myencoreapp.com:6379",
      "database_index": 0,
      "auth": {
        "type": "auth",
        "auth_string": {
          "$env": "REDIS_AUTH_STRING"
        }
      },
      "max_connections": 50,
      "min_connections": 5
    }
  }
}

----------------------------------------

TITLE: Setting Up Database Proxy
DESCRIPTION: Creates a local proxy that forwards connections to databases in the specified environment.

LANGUAGE: shell
CODE:
$ encore db proxy [--env=<name>] [flags]

----------------------------------------

TITLE: Implementing React Router with Auth0 Authentication
DESCRIPTION: Main application component that sets up routes, authentication flow, and protected routes using React Router. It defines login, callback, and logout routes to handle the Auth0 authentication process.

LANGUAGE: tsx
CODE:
import { PropsWithChildren } from "react";
import {
  createBrowserRouter,
  Link,
  Outlet,
  redirect,
  RouterProvider,
  useRouteError,
} from "react-router-dom";
import { Auth0Provider } from "./lib/auth";
import AdminDashboard from "./components/AdminDashboard.tsx";

import IndexPage from "./components/IndexPage.tsx";
import "./App.css";
import LoginStatus from "./components/LoginStatus.tsx";

// Application routes
const router = createBrowserRouter([
  {
    id: "root",
    path: "/",
    Component: Layout,
    errorElement: (
      <Layout>
        <ErrorBoundary />
      </Layout>
    ),
    children: [
      {
        Component: Outlet,
        children: [
          {
            index: true,
            Component: IndexPage,
          },
          {
            // Login route
            path: "login",
            loader: async ({ request }) => {
              const url = new URL(request.url);
              const searchParams = new URLSearchParams(url.search);
              const returnToURL = searchParams.get("returnTo") ?? "/";

              if (Auth0Provider.isAuthenticated()) return redirect(returnToURL);

              try {
                const returnURL = await Auth0Provider.login(returnToURL);
                return redirect(returnURL);
              } catch (error) {
                throw new Error("Login failed");
              }
            },
          },
          {
            // Callback route, redirected to from Auth0 after login
            path: "callback",
            loader: async ({ request }) => {
              const url = new URL(request.url);
              const searchParams = new URLSearchParams(url.search);
              const state = searchParams.get("state");
              const code = searchParams.get("code");

              if (!state || !code) throw new Error("Login failed");

              try {
                const redirectURL = await Auth0Provider.validate(state, code);
                return redirect(redirectURL);
              } catch (error) {
                throw new Error("Login failed");
              }
            },
          },
          {
            // Logout route
            path: "logout",
            loader: async () => {
              try {
                const redirectURL = await Auth0Provider.logout();
                return redirect(redirectURL);
              } catch (error) {
                throw new Error("Logout failed");
              }
            },
          },
          {
            element: <Outlet />,
            // Redirect to /login if not authenticated
            loader: async ({ request }) => {
              if (!Auth0Provider.isAuthenticated()) {
                const params = new URLSearchParams();
                params.set("returnTo", new URL(request.url).pathname);
                return redirect("/login?" + params.toString());
              }
              return null;
            },
            // Protected routes
            children: [
              {
                path: "admin-dashboard",
                Component: AdminDashboard,
              },
            ],
          },
        ],
      },
    ],
  },
]);

export default function App() {
  return <RouterProvider router={router} fallbackElement={<p>Loading...</p>} />;
}

function Layout({ children }: PropsWithChildren) {
  return (
    <div>
      <header>
        <nav className="nav">
          <div className="navLinks">
            <Link to="/">Home</Link>
            <Link to="/admin-dashboard">Admin Dashboard</Link>
          </div>

          <LoginStatus />
        </nav>
      </header>

      <main className="main">{children ?? <Outlet />}</main>
    </div>
  );
}

function ErrorBoundary() {
  const error = useRouteError() as Error;
  return (
    <div>
      <h1>Something went wrong</h1>
      <p>{error.message || JSON.stringify(error)}</p>
    </div>
  );
}

----------------------------------------

TITLE: Implementing Validation Middleware in Encore
DESCRIPTION: This middleware validates request payloads by checking if they implement a Validate method. If validation fails, it returns an InvalidArgument error. It targets all API endpoints using the 'target=all' directive.

LANGUAGE: go
CODE:
import (
    "encore.dev/beta/errs"
    "encore.dev/middleware"
)

//encore:middleware global target=all
func ValidationMiddleware(req middleware.Request, next middleware.Next) middleware.Response {
    // If the payload has a Validate method, use it to validate the request.
    payload := req.Data().Payload
    if validator, ok := payload.(interface { Validate() error }); ok {
        if err := validator.Validate(); err != nil {
            // If the validation fails, return an InvalidArgument error.
            err = errs.WrapCode(err, errs.InvalidArgument, "validation failed")
            return middleware.Response{Err: err}
        }
    }
    return next(req)
}

----------------------------------------

TITLE: Reading path parameters from raw HTTP endpoints in Encore Go
DESCRIPTION: This snippet shows how to access path parameters in a raw endpoint using encore.CurrentRequest(). It defines a webhook endpoint with a path parameter named 'id' and demonstrates how to retrieve this parameter from the request.

LANGUAGE: go
CODE:
package service  
  
import (  
   "net/http"  
   
   "encore.dev"
 )

//encore:api public raw method=POST path=/webhook/:id
func Webhook(w http.ResponseWriter, req *http.Request) {  
    id := encore.CurrentRequest().PathParams.Get("id")
	// ... Do something with id
 }

----------------------------------------

TITLE: Restarting the Encore CLI Daemon
DESCRIPTION: Restarts the Encore CLI daemon process, which can help resolve unexpected behavior issues.

LANGUAGE: shell
CODE:
$ encore daemon

----------------------------------------

TITLE: Overriding Local Secrets with CUE Configuration
DESCRIPTION: Shows how to create a local override file for secrets that applies only to your local development environment. This is useful when developers need different secret values than what's shared across the team.

LANGUAGE: cue
CODE:
GitHubAPIToken: "my-local-override-token"
SSHPrivateKey: "custom-ssh-private-key"

----------------------------------------

TITLE: Single-Service Application Directory Structure
DESCRIPTION: This illustrates the recommended directory structure for a simple single-service Encore application, showing the placement of the encore.service.ts file at the root along with other key files like API definitions and database configuration.

LANGUAGE: plaintext
CODE:
/my-app
├── package.json
├── encore.app
├──  // ... other project files
│
├── encore.service.ts    // defines your service root
├── api.ts               // API endpoints
├── db.ts                // Database definition

----------------------------------------

TITLE: Implementing Request Validation in Express.js with Zod
DESCRIPTION: This snippet demonstrates how to implement request validation middleware in Express.js using Zod to validate headers, query parameters, and request body data. It includes a validation middleware function and schema definitions.

LANGUAGE: typescript
CODE:
import express, {NextFunction, Request, Response} from "express";
import {z, ZodError} from "zod";

const app: Express = express();

// Request validation middleware
function validateData(schemas: {
  body: z.ZodObject<any, any>;
  query: z.ZodObject<any, any>;
  headers: z.ZodObject<any, any>;
}) {
  return (req: Request, res: Response, next: NextFunction) => {
    try {
      // Validate headers
      schemas.headers.parse(req.headers);

      // Validate request body
      schemas.body.parse(req.body);

      // Validate query params
      schemas.query.parse(req.query);

      next();
    } catch (error) {
      if (error instanceof ZodError) {
        const errorMessages = error.errors.map((issue: any) => ({
          message: `${issue.path.join(".")} is ${issue.message}`,
        }));
        res.status(400).json({error: "Invalid data", details: errorMessages});
      } else {
        res.status(500).json({error: "Internal Server Error"});
      }
    }
  };
}

// Request body validation schemas
const bodySchema = z.object({
  someKey: z.string().optional(),
  someOtherKey: z.number().optional(),
  requiredKey: z.array(z.number()),
  nullableKey: z.number().nullable().optional(),
  multipleTypesKey: z.union([z.boolean(), z.number()]).optional(),
  enumKey: z.enum(["John", "Foo"]).optional(),
});

// Query string validation schemas
const queryStringSchema = z.object({
  name: z.string().optional(),
});

// Headers validation schemas
const headersSchema = z.object({
  "x-foo": z.string().optional(),
});

// Request validation example using Zod
app.post(
  "/validate",
  validateData({
    headers: headersSchema,
    body: bodySchema,
    query: queryStringSchema,
  }),
  (_: Request, res: Response) => {
    res.json({message: "Validation succeeded"});
  },
);

----------------------------------------

TITLE: Implementing Slack Signature Verification
DESCRIPTION: TypeScript function to verify the authenticity of incoming Slack webhook requests using HMAC. The function checks for request staleness and signature validity based on Slack's verification protocol.

LANGUAGE: typescript
CODE:
// Verifies the signature of an incoming request from Slack.
const verifySignature = async function (
  body: string,
  headers: IncomingHttpHeaders,
) {
  const requestTimestampSec = parseInt(
    headers["x-slack-request-timestamp"] as string,
  );
  const signature = headers["x-slack-signature"] as string;
  if (Number.isNaN(requestTimestampSec)) {
    throw new Error(
      `Failed to verify authenticity: header x-slack-request-timestamp did not have the expected type (${requestTimestampSec})`,
    );
  }

  // Calculate time-dependent values
  const nowMs = Date.now();
  const requestTimestampMaxDeltaMin = 5;
  const fiveMinutesAgoSec =
    Math.floor(nowMs / 1000) - 60 * requestTimestampMaxDeltaMin;

  // Enforce verification rules

  // Rule 1: Check staleness
  if (requestTimestampSec < fiveMinutesAgoSec) {
    throw new Error(
      `Failed to verify authenticity: x-slack-request-timestamp must differ from system time by no more than ${requestTimestampMaxDeltaMin} minutes or request is stale`,
    );
  }

  // Rule 2: Check signature
  // Separate parts of signature
  const [signatureVersion, signatureHash] = signature.split("=");
  // Only handle known versions
  if (signatureVersion !== "v0") {
    throw new Error(`Failed to verify authenticity: unknown signature version`);
  }
  // Compute our own signature hash
  const hmac = createHmac("sha256", slackSigningSecret());
  hmac.update(`${signatureVersion}:${requestTimestampSec}:${body}`);
  const ourSignatureHash = hmac.digest("hex");
  if (
    !signatureHash ||
    !timingSafeEqual(
      Buffer.from(signatureHash, "utf8"),
      Buffer.from(ourSignatureHash, "utf8"),
    )
  ) {
    throw new Error(`Failed to verify authenticity: signature mismatch`);
  }
};

----------------------------------------

TITLE: Running an Encore Application with Shell Command
DESCRIPTION: Demonstrates the shell command for starting an Encore application locally, which will run both Encore and the NestJS application together.

LANGUAGE: shell
CODE:
$ encore run

----------------------------------------

TITLE: Running an Encore Application Locally with Development Dashboard
DESCRIPTION: This command starts an Encore application locally using 'encore run' and displays URLs for accessing the API and development dashboard. The dashboard opens automatically and provides access to the service catalog, API explorer, distributed tracing, and architecture visualization tools.

LANGUAGE: bash
CODE:
$ encore run
API Base URL:      http://localhost:4000
Dev Dashboard URL: http://localhost:9400/hello-world-cgu2

----------------------------------------

TITLE: Using the Generated Client to Make API Requests in TypeScript
DESCRIPTION: Example of how to import and use the generated Encore client to make typesafe API requests to a backend service.

LANGUAGE: typescript
CODE:
import Client, { Environment, Local } from "src/client.ts";

// Making request to locally running backend...
const client = new Client(Local);
// or to a specific deployed environment
const client = new Client(Environment("staging"));

// Calling APIs as typesafe functions 🌟
const response = await client.note.GetNote("note-uuid");
console.log(response.id);
console.log(response.cover_url);
console.log(response.text);

----------------------------------------

TITLE: Running an Encore Application Locally
DESCRIPTION: Command to start an Encore application in the local development environment. This launches the application and the local development dashboard.

LANGUAGE: shell
CODE:
$ cd your-app-name # replace with the app name you picked
$ encore run

----------------------------------------

TITLE: Implementing Validation Logic in CUE
DESCRIPTION: Shows how to create complex validation logic in CUE using field unification and the list package. The example validates port numbers to ensure they meet specific criteria including containing port 8080.

LANGUAGE: cue
CODE:
import (
    "list" // import CUE's list package
)

// Set some port numbers defaulting just to 8080
// but in development including 8443
portNumbers: [...int] | *[8080]
if #Meta.Environment.Type == "development" {
    portNumbers: [8080, 8443]
}

// Port numbers must be an array and all values
// are integers 1024 or above.
portNumbers: [...int & >= 1024]

// The ports are considered valid if they contain the port number 8080.
_portsAreValid: list.Contains(portNumbers, 8080)

// Ensure that the ports are valid by constraining the value to be true.
// CUE will report an error if the value is false (that is if the portNumbers list
// does not contain the value 8080).
_portsAreValid: true

----------------------------------------

TITLE: Listing Encore Secrets
DESCRIPTION: Lists all secrets or filters by specific keys.

LANGUAGE: shell
CODE:
$ encore secret list [keys...]

----------------------------------------

TITLE: Testing Slack Notification Endpoint with cURL
DESCRIPTION: A curl command to test the Slack notification endpoint by sending a test message. This allows verifying that the webhook integration works correctly before setting up the Pub/Sub subscription.

LANGUAGE: shell
CODE:
$ curl 'http://localhost:4000/slack.Notify' -d '{"Text": "Testing Slack webhook"}'

----------------------------------------

TITLE: Updating Temporal Client to Use Environment-Specific Configuration
DESCRIPTION: Modifies the Temporal client initialization to use the configured server address from the environment-specific configuration. This ensures the application connects to the appropriate Temporal cluster based on the environment.

LANGUAGE: go
CODE:
client.Dial(client.Options{HostPort: cfg.TemporalServer})

----------------------------------------

TITLE: Deploying Using Encore Cloud's Managed Git
DESCRIPTION: Git commands for deploying an application using Encore Cloud's built-in managed git repository.

LANGUAGE: shell
CODE:
$ git add -A .
$ git commit -m 'Commit message'
$ git push encore

----------------------------------------

TITLE: Testing Site Service API with cURL
DESCRIPTION: Shell command to test the site.add endpoint using cURL, showing how to add a website to be monitored.

LANGUAGE: shell
CODE:
$ curl -X POST 'http://localhost:4000/site' -d '{"url": "https://encore.dev"}'
{
  "id": 1,
  "url": "https://encore.dev"
}

----------------------------------------

TITLE: Setting Firebase Secret for Production Environment
DESCRIPTION: Shell command to set the Firebase private key as a production secret in Encore.

LANGUAGE: shell
CODE:
$ encore secret set --type prod FirebasePrivateKey < /path/to/firebase-private-key.json
Successfully updated production secret FirebasePrivateKey

----------------------------------------

TITLE: Checking Encore Version
DESCRIPTION: Reports the current version of the Encore application.

LANGUAGE: shell
CODE:
$ encore version

----------------------------------------

TITLE: Implementing GraphQL Resolvers for URL Service
DESCRIPTION: Implementation of the GraphQL resolvers that connect to the underlying Encore URL service, bridging GraphQL queries and mutations with Encore API endpoints.

LANGUAGE: go
CODE:
// Shorten is the resolver for the shorten field.
func (r *mutationResolver) Shorten(ctx context.Context, input string) (*url.URL, error) {
	return url.Shorten(ctx, &url.ShortenParams{URL: input})
}

// Urls is the resolver for the urls field.
func (r *queryResolver) Urls(ctx context.Context) ([]*url.URL, error) {
	resp, err := url.List(ctx)
	if err != nil {
		return nil, err
	}
	return resp.URLs, nil
}

// Get is the resolver for the get field.
func (r *queryResolver) Get(ctx context.Context, id string) (*url.URL, error) {
	return url.Get(ctx, id)
}

----------------------------------------

TITLE: Implementing GraphQL Query Resolvers
DESCRIPTION: Defines query resolvers that fetch data from the book service. This file uses the generated QueryResolvers type for type checking and implements the books query to return a list of books.

LANGUAGE: typescript
CODE:
import { book } from "~encore/clients";
import { QueryResolvers } from "../__generated__/resolvers-types";

// Use the generated `QueryResolvers` type to type check our queries!
const queries: QueryResolvers = {
  books: async () => {
    const { books } = await book.list();
    return books;
  },
};

export default queries;

----------------------------------------

TITLE: Creating APIs in Express.js vs Encore.ts
DESCRIPTION: Compares how to create RESTful APIs in Express.js using app.get/post methods versus Encore.ts's type-safe api function. Shows examples of handling path parameters, query strings, and JSON body requests in both frameworks.

LANGUAGE: typescript
CODE:
import express, {Request, Response} from "express";

const app: Express = express();

// GET request with dynamic path parameter
app.get("/hello/:name", (req: Request, res: Response) => {
  const msg = `Hello ${req.params.name}!`;
  res.json({message: msg});
})

// GET request with query string parameter
app.get("/hello", (req: Request, res: Response) => {
  const msg = `Hello ${req.query.name}!`;
  res.json({message: msg});
});

// POST request example with JSON body
app.post("/order", (req: Request, res: Response) => {
  const price = req.body.price;
  const orderId = req.body.orderId;
  // Handle order logic
  res.json({message: "Order has been placed"});
});

LANGUAGE: typescript
CODE:
import {api, Query} from "encore.dev/api";

// Dynamic path parameter :name
export const dynamicPathParamExample = api(
  {expose: true, method: "GET", path: "/hello/:name"},
  async ({name}: { name: string }): Promise<{ message: string }> => {
    const msg = `Hello ${name}!`;
    return {message: msg};
  },
);

interface RequestParams {
  // Encore will now automatically parse the query string parameter
  name?: Query<string>;
}

// Query string parameter ?name
export const queryStringExample = api(
  {expose: true, method: "GET", path: "/hello"},
  async ({name}: RequestParams): Promise<{ message: string }> => {
    const msg = `Hello ${name}!`;
    return {message: msg};
  },
);

interface OrderRequest {
  price: string;
  orderId: number;
}

// POST request example with JSON body
export const order = api(
  {expose: true, method: "POST", path: "/order"},
  async ({price, orderId}: OrderRequest): Promise<{ message: string }> => {
    // Handle order logic
    console.log(price, orderId)

    return {message: "Order has been placed"};
  },
);

// Raw endpoint
export const myRawEndpoint = api.raw(
  {expose: true, path: "/raw", method: "GET"},
  async (req, resp) => {
    resp.writeHead(200, {"Content-Type": "text/plain"});
    resp.end("Hello, raw world!");
  },
);

----------------------------------------

TITLE: Defining Cron Job with Schedule and Documentation in Go
DESCRIPTION: Creates a cron job named 'cronfoo' with a descriptive comment indicating it's for sending emails to newsletter subscribers. The job runs every Friday and calls the CronAPI endpoint.

LANGUAGE: go
CODE:
// A cron job to send out emails to newsletter subscribers.
// On two lines.
var _ = cron.NewJob("cronfoo", cron.JobConfig{
	Title:     "Cron Foo Bar",
	Schedule: "* * * * 5",
	Endpoint: CronAPI,
})

----------------------------------------

TITLE: Updated Shorten Function with Database Storage
DESCRIPTION: Enhanced version of the Shorten function that not only generates a short ID but also persists the URL mapping in the database using the insert helper function.

LANGUAGE: go
CODE:
func Shorten(ctx context.Context, p *ShortenParams) (*URL, error) {
	id, err := generateID()
	if err != nil {
		return nil, err
	} else if err := insert(ctx, id, p.URL); err != nil {
		return nil, err
	}
	return &URL{ID: id, URL: p.URL}, nil
}

----------------------------------------

TITLE: Implementing Incident Assignment and Auto-Assignment Cron Job
DESCRIPTION: Implementation of an endpoint to assign incidents to users and a cron job that automatically assigns unassigned incidents to on-call personnel. The cron job runs every minute to ensure quick assignment when someone begins their on-call rotation.

LANGUAGE: go
CODE:
//encore:api public method=PUT path=/incidents/:id/assign
func Assign(ctx context.Context, id int32, params *AssignParams) (*Incident, error) {
	eb := errs.B().Meta("params", params)
	rows, err := db.Query(ctx, `
		UPDATE incidents
		SET assigned_user_id = $1
		WHERE acknowledged_at IS NULL
		  AND id = $2
		RETURNING id, assigned_user_id, body, created_at, acknowledged_at
	`, params.UserId, id)
	if err != nil {
		return nil, err
	}

	incidents, err := RowsToIncidents(ctx, rows)
	if err != nil {
		return nil, err
	}
	if incidents.Items == nil {
		return nil, eb.Code(errs.NotFound).Msg("no incident found").Err()
	}

	incident := &incidents.Items[0]
	_ = slack.Notify(ctx, &slack.NotifyParams{
		Text: fmt.Sprintf("Incident #%d is re-assigned to %s %s <@%s>\n%s", incident.Id, incident.Assignee.FirstName, incident.Assignee.LastName, incident.Assignee.SlackHandle, incident.Body),
	})

	return incident, err
}

type AssignParams struct {
	UserId int32
}

var _ = cron.NewJob("assign-unassigned-incidents", cron.JobConfig{
	Title:    "Assign unassigned incidents to user on-call",
	Every:    1 * cron.Minute,
	Endpoint: AssignUnassignedIncidents,
})

----------------------------------------

TITLE: Building Encore Docker Images
DESCRIPTION: Builds a portable Docker image of your Encore application, with options to specify a base image and push to a remote repository.

LANGUAGE: shell
CODE:
$ encore build docker

----------------------------------------

TITLE: Implementing Switch-like Statements in CUE
DESCRIPTION: Demonstrates how to emulate switch statements in CUE using arrays with conditional values. This pattern allows selecting different values based on environment conditions without needing else branches.

LANGUAGE: cue
CODE:
SendEmailsFrom: [
	// These act as individual case statements
    if #Meta.Environment.Type == "production" { "noreply@example.com" },
    if #Meta.Environment.Name == "staging"    { "staging@example.com" },

    // This last value without a condition acts as the default case
    "dev-system@example.dev",
][0] // Return the first value which matches the condition

----------------------------------------

TITLE: Archiving an Encore Secret
DESCRIPTION: Archives a secret value by its ID.

LANGUAGE: shell
CODE:
$ encore secret archive <id>

----------------------------------------

TITLE: Creating a GORM Schema Loader for Atlas
DESCRIPTION: Go script that loads GORM models and generates schema statements for Atlas to use when creating migrations.

LANGUAGE: go
CODE:
-- blog/scripts/atlas-gorm-loader.go --
package main

import (
    "fmt"
    "io"
    "os"

    _ "ariga.io/atlas-go-sdk/recordriver"
    "ariga.io/atlas-provider-gorm/gormschema"
    "encore.app/blog"
)

// Define the models to generate migrations for.
var models = []any{
    &blog.Post{},
    &blog.Comment{},
}

func main() {
    stmts, err := gormschema.New("postgres").Load(models...)
    if err != nil {
        fmt.Fprintf(os.Stderr, "failed to load gorm schema: %v\n", err)
        os.Exit(1)
    }
    io.WriteString(os.Stdout, stmts)
}

----------------------------------------

TITLE: Computing Bookable Time Slots in Go
DESCRIPTION: This function computes bookable time slots based on availability windows. It takes a date and availability time windows as input and returns a list of BookableSlot objects that represent time periods available for booking.

LANGUAGE: go
CODE:
availStart := date.Add(time.Duration(availStartTime.Microseconds) * time.Microsecond)
availEnd := date.Add(time.Duration(availEndTime.Microseconds) * time.Microsecond)

// Compute the bookable slots in this day, based on availability.
var slots []BookableSlot
start := availStart
for {
	end := start.Add(DefaultBookingDuration)
	if end.After(availEnd) {
		break
	}
	slots = append(slots, BookableSlot{
		Start: start,
		End:   end,
	})
	start = end
}

return slots, nil
}

----------------------------------------

TITLE: Creating a Pub/Sub Subscription for Slack Notifications in Go
DESCRIPTION: Sets up a Pub/Sub subscription that listens for site status transition events and sends appropriate notifications to Slack. This connects the monitoring system to Slack without direct coupling between the services.

LANGUAGE: go
CODE:
import (
	"encore.dev/pubsub"
	"encore.app/monitor"
)

var _ = pubsub.NewSubscription(monitor.TransitionTopic, "slack-notification", pubsub.SubscriptionConfig[*monitor.TransitionEvent]{
	Handler: func(ctx context.Context, event *monitor.TransitionEvent) error {
		// Compose our message.
		msg := fmt.Sprintf("*%s is down!*", event.Site.URL)
		if event.Up {
			msg = fmt.Sprintf("*%s is back up.*", event.Site.URL)
		}

		// Send the Slack notification.
		return Notify(ctx, &NotifyParams{Text: msg})
	},
})

----------------------------------------

TITLE: Checking Encore VPN Status
DESCRIPTION: Determines the current status of the Encore VPN connection.

LANGUAGE: shell
CODE:
$ encore vpn status

----------------------------------------

TITLE: Configuring package.json for GraphQL and Encore.ts
DESCRIPTION: Package configuration for an Encore GraphQL project, including dependencies for Apollo Server, GraphQL, and codegen tools. This sets up the necessary development and runtime dependencies along with a script to generate TypeScript types from GraphQL schema.

LANGUAGE: json
CODE:
{
  "name": "encore-graphql",
  "private": true,
  "version": "0.0.1",
  "license": "MPL-2.0",
  "type": "module",
  "scripts": {
    "generate": "graphql-codegen --config codegen.yml"
  },
  "devDependencies": {
    "@types/node": "^20.5.7",
    "typescript": "^5.2.2",
    "@graphql-codegen/cli": "2.16.5",
    "@graphql-codegen/typescript": "2.8.8",
    "@graphql-codegen/typescript-resolvers": "2.7.13"
  },
  "dependencies": {
    "@apollo/server": "^4.11.0",
    "encore.dev": "^1.35.3",
    "graphql": "^16.9.0",
    "graphql-tag": "^2.12.6"
  }
}

----------------------------------------

TITLE: Uploading Files to Object Storage in Encore.ts
DESCRIPTION: Shows how to upload data to a bucket using the 'upload' method. This example uploads image data with a specified content type and returns the object attributes.

LANGUAGE: typescript
CODE:
const data = Buffer.from(...); // image data
const attributes = await profilePictures.upload("my-image.jpeg", data, {
  contentType: "image/jpeg",
});

----------------------------------------

TITLE: SQL Migration for Users Table in Encore.ts
DESCRIPTION: SQL migration file for creating the users table in an Encore.ts application. This file is automatically executed by Encore when provisioning the database, demonstrating Encore's migration system.

LANGUAGE: sql
CODE:
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL UNIQUE
);

----------------------------------------

TITLE: Setting Up a Cron Job for Automated Site Monitoring
DESCRIPTION: This code configures a cron job using Encore's cron module to automatically call the checkAll endpoint every hour, providing regular monitoring of all tracked sites.

LANGUAGE: typescript
CODE:
import { CronJob } from "encore.dev/cron";

// Check all tracked sites every 1 hour.
const cronJob = new CronJob("check-all", {
  title: "Check all sites",
  every: "1h",
  endpoint: checkAll,
});

----------------------------------------

TITLE: Implementing Automatic Request Validation in Encore.ts
DESCRIPTION: This snippet shows how Encore.ts handles request validation automatically using TypeScript types. It defines a RequestSchema interface that describes the expected structure of the request, including headers, query parameters, and body.

LANGUAGE: typescript
CODE:
import {api, Header, Query} from "encore.dev/api";

enum EnumType {
  FOO = "foo",
  BAR = "bar",
}

// Encore.ts automatically validates the request schema and returns and error
// if the request does not match the schema.
interface RequestSchema {
  foo: Header<"x-foo">;
  name?: Query<string>;

  someKey?: string;
  someOtherKey?: number;
  requiredKey: number[];
  nullableKey?: number | null;
  multipleTypesKey?: boolean | number;
  enumKey?: EnumType;
}

// Validate a request
export const schema = api(
  {expose: true, method: "POST", path: "/validate"},
  (data: RequestSchema): { message: string } => {
    console.log(data);
    return {message: "Validation succeeded"};
  },
);

----------------------------------------

TITLE: Database Insert Function for URL Shortener
DESCRIPTION: Helper function that inserts a URL and its generated ID into the PostgreSQL database using a parameterized SQL query.

LANGUAGE: go
CODE:
// insert inserts a URL into the database.
func insert(ctx context.Context, id, url string) error {
	_, err := db.Exec(ctx, `
        INSERT INTO url (id, original_url)
        VALUES ($1, $2)
    `, id, url)
	return err
}

----------------------------------------

TITLE: Deploying to Encore Cloud with Git
DESCRIPTION: Git commands to commit changes and push to Encore Cloud, which automatically builds, tests, and deploys the application.

LANGUAGE: shell
CODE:
$ git add -A .
$ git commit -m 'Initial commit'
$ git push encore

----------------------------------------

TITLE: Using HTTP Headers in Encore API Schema
DESCRIPTION: This example shows how to define HTTP headers in Encore API schemas using the header tag. The tag name translates between struct fields and HTTP headers.

LANGUAGE: go
CODE:
type ListBlogPost struct {
    Language string `header:"Accept-Language"`
    Author      string // Not a header
}

----------------------------------------

TITLE: Configuring Database Connection for Self-Hosted Encore Application in JSON
DESCRIPTION: Infrastructure configuration JSON file for an Encore application that defines PostgreSQL database connection details. This file allows the self-hosted application to connect to the database, with database credentials specified directly or through environment variables.

LANGUAGE: json
CODE:
{
   "$schema": "https://encore.dev/schemas/infra.schema.json",
   "sql_servers": [
      {
         "host": "my-db-host:5432",
         "databases": {
            "url": {
               "username": "my-db-owner",
                "password": {"$env": "DB_PASSWORD"}
            }
         }
      }
   ]
}

----------------------------------------

TITLE: Displaying Current Encore User
DESCRIPTION: Shows information about the currently logged in Encore user.

LANGUAGE: shell
CODE:
$ encore auth whoami

----------------------------------------

TITLE: Creating an Object Storage Bucket in Go
DESCRIPTION: Creates a bucket for storing profile pictures using Encore's Object Storage API. Buckets must be declared as package-level variables and can be configured with additional properties like versioning.

LANGUAGE: go
CODE:
package user

import "encore.dev/storage/objects"

var ProfilePictures = objects.NewBucket("profile-pictures", objects.BucketConfig{
	Versioned: false,
})

----------------------------------------

TITLE: Configuring a Cron Job in Encore
DESCRIPTION: Sets up a scheduled cron job using Encore's cron package to automatically call the CheckAll endpoint every hour. This ensures regular monitoring of all tracked sites even without manual intervention.

LANGUAGE: go
CODE:
import "encore.dev/cron"

// Check all tracked sites every 1 hour.
var _ = cron.NewJob("check-all", cron.JobConfig{
	Title:    "Check all sites",
	Endpoint: CheckAll,
	Every:    1 * cron.Hour,
})

----------------------------------------

TITLE: Combining Validation Rules in Encore.ts
DESCRIPTION: This example shows how to combine multiple validation rules using & (and) to require all rules to pass or | (or) to require at least one rule to pass.

LANGUAGE: typescript
CODE:
interface Schema {
  // Must be both >= 3 and <= 1000
  count: number & (Min<3> & Max<1000>);

  // Must be either a URL or an email
  contact: string & (IsURL | IsEmail);
}

----------------------------------------

TITLE: Defining TypeScript Interface
DESCRIPTION: Defines a TypeScript interface named 'foo' with a string property 'bar'. This interface can be used for type checking in TypeScript applications.

LANGUAGE: typescript
CODE:
export interface foo {
  bar: string;
}

----------------------------------------

TITLE: Generated Generic Configuration Type Unmarshalers for CfgType
DESCRIPTION: This automatically generated function creates unmarshalers for the generic CfgType struct. It handles the JSON deserialization of all fields within the structure, including nested configuration values and collections.

LANGUAGE: go
CODE:
func encoreInternalTypeConfigUnmarshaler_generics_CfgType[T any](_T_unmarshaler config.Unmarshaler[T]) (concreteUnmarshaler config.Unmarshaler[CfgType[T]]) {
	return func(itr *jsoniter.Iterator, path []string) (obj CfgType[T]) {
		itr.ReadObjectCB(func(itr *jsoniter.Iterator, field string) bool {
			switch field {
			case "ReadOnlyMode":
				obj.ReadOnlyMode = config.CreateValue[bool](itr.ReadBool(), append(path, "ReadOnlyMode"))
			case "PublicKey":
				obj.PublicKey = config.CreateValue[[]byte](func() (rtn []byte) {
					decoder := new(__etype.Unmarshaller)
					rtn = __etype.UnmarshalOne(decoder, __etype.UnmarshalBytes, "value", itr.ReadString(), true)
					if err := decoder.Error; err != nil {
						panic(fmt.Sprintf("unable to decode the config: %v", err))
					}
					return
				}(), append(path, "PublicKey"))
			case "AdminUsers":
				obj.AdminUsers = config.CreateValueList(config.ReadArray[string](itr, func(itr *jsoniter.Iterator, idx int) string {
					return itr.ReadString()
				}), append(path, "AdminUsers"))
			case "SubConfig":
				obj.SubConfig = config.CreateValue[struct {
					SubKey *SubCfgType[T]
				}](func() (obj struct {
					SubKey *SubCfgType[T]
				}) {
					itr.ReadObjectCB(func(itr *jsoniter.Iterator, field string) bool {
						switch field {
						case "SubKey":
							obj.SubKey = func() *SubCfgType[T] {
								// If the value is null, we return nil
								if itr.ReadNil() {
									return nil
								}

								// Otherwise we unmarshal the value and return a pointer to it
								obj := encoreInternalTypeConfigUnmarshaler_generics_SubCfgType[T](func(itr *jsoniter.Iterator, path []string) T {
									return _T_unmarshaler(itr, append(path))
								})(itr, append(path, "SubKey"))
								return &obj
							}()
						default:
							itr.Skip()
						}
						return true
					})
					return
				}(), append(path, "SubConfig"))
			case "Currencies":
				obj.Currencies = config.ReadMap[string, struct {
					Name    config.Value[string]
					Code    config.Value[string]
					Aliases config.Values[string]
				}](itr, func(itr *jsoniter.Iterator, keyAsString string) (string, struct {
					Name    config.Value[string]
					Code    config.Value[string]
					Aliases config.Values[string]
				}) {
					// Decode the map key from the JSON string to the underlying type it needs to be
					keyDecoder := new(__etype.Unmarshaller)
					key := __etype.UnmarshalOne(keyDecoder, __etype.UnmarshalString, "keyAsString", keyAsString, true)
					if err := keyDecoder.Error; err != nil {
						panic(fmt.Sprintf("unable to decode the config: %v", err))
					}
					return key, func() (obj struct {
						Name    config.Value[string]
						Code    config.Value[string]
						Aliases config.Values[string]
					}) {
						itr.ReadObjectCB(func(itr *jsoniter.Iterator, field string) bool {
							switch field {
							case "Name":
								obj.Name = config.CreateValue[string](itr.ReadString(), append(path, "Name"))
							case "Code":
								obj.Code = config.CreateValue[string](itr.ReadString(), append(path, "Code"))
							case "Aliases":
								obj.Aliases = config.CreateValueList(config.ReadArray[string](itr, func(itr *jsoniter.Iterator, idx int) string {
									return itr.ReadString()
								}), append(path, "Aliases"))
							default:
								itr.Skip()
							}
							return true
						})
						return
					}()
				})
			case "AnotherList":
				obj.AnotherList = config.CreateValueList(config.ReadArray[struct {
					Name config.Value[string]
				}](itr, func(itr *jsoniter.Iterator, idx int) struct {
					Name config.Value[string]
				} {
					return func() (obj struct {
						Name config.Value[string]
					}) {
						itr.ReadObjectCB(func(itr *jsoniter.Iterator, field string) bool {
							switch field {
							case "Name":
								obj.Name = config.CreateValue[string](itr.ReadString(), append(path, "Name"))
							default:
								itr.Skip()
							}
							return true
						})
						return
					}()
				}), append(path, "AnotherList"))
			default:
				itr.Skip()
			}
			return true
		})
		return
	}
}

----------------------------------------

TITLE: Running Encore in Debug Mode with Break
DESCRIPTION: Command to start an Encore application in debug mode with the break flag, which pauses execution until a debugger is attached. The output shows the local server URLs and debugger port.

LANGUAGE: shell
CODE:
$ encore run --debug=break
API Base URL:      http://localhost:4000
Dev Dashboard URL: http://localhost:9400/hello-world-cgu2

API server listening at: 127.0.0.1:2345

----------------------------------------

TITLE: Installing Prisma Development Dependencies
DESCRIPTION: Command to install Prisma as a development dependency in your project. This is the first step in setting up Prisma with your Encore.ts application.

LANGUAGE: bash
CODE:
npm install prisma --save-dev

----------------------------------------

TITLE: Writing tests for the ping functionality
DESCRIPTION: TypeScript test suite using Vitest to test the ping functionality with various URLs, including valid and invalid cases, ensuring the endpoint correctly identifies site status.

LANGUAGE: typescript
CODE:
import { describe, expect, test } from "vitest";
import { ping } from "./ping";

describe("ping", () => {
  test.each([
    // Test both with and without "https://"
    { site: "google.com", expected: true },
    { site: "https://encore.dev", expected: true },

    // 4xx and 5xx should considered down.
    { site: "https://not-a-real-site.xyz", expected: false },
    // Invalid URLs should be considered down.
    { site: "invalid://scheme", expected: false },
  ])(
    `should verify that $site is ${"$expected" ? "up" : "down"}`,
    async ({ site, expected }) => {
      const resp = await ping({ url: site });
      expect(resp.up).toBe(expected);
    },
  );
});

----------------------------------------

TITLE: Deploying Using Connected GitHub Repository
DESCRIPTION: Git commands for deploying an application when using a connected GitHub repository instead of Encore's managed git.

LANGUAGE: shell
CODE:
$ git add -A .
$ git commit -m 'Commit message'
$ git push origin

----------------------------------------

TITLE: Creating directory and file structure for the monitor service
DESCRIPTION: Shell commands to create the directory and required file for the monitor service that will check website availability.

LANGUAGE: shell
CODE:
$ mkdir monitor
$ touch monitor/encore.service.ts

----------------------------------------

TITLE: Database Configuration for URL Shortener
DESCRIPTION: Defines a PostgreSQL database configuration for the URL shortener service using Encore's sqldb package, specifying the database name and migration path.

LANGUAGE: go
CODE:
// Define a database named 'url', using the database
// migrations in the "./migrations" folder.

var db = sqldb.NewDatabase("url", sqldb.DatabaseConfig{
	Migrations: "./migrations",
})

----------------------------------------

TITLE: Generating TypeScript Client for Encore Endpoints
DESCRIPTION: Command to generate a TypeScript client from the Encore API definitions, enabling type-safe API calls from the frontend without manual synchronization.

LANGUAGE: shell
CODE:
$ encore gen client <APP_NAME> --output=./src/client.ts --env=<ENV_NAME>

----------------------------------------

TITLE: Creating an OAuth Client with Go to Access Encore Cloud API
DESCRIPTION: This Go example demonstrates how to set up an OAuth client using the clientcredentials package to generate API access tokens. It uses environment variables for the client ID and secret, then creates an HTTP client that automatically handles token generation and renewal for API calls.

LANGUAGE: go
CODE:
package main

import (
    "context"
    "os"

    "golang.org/x/oauth2/clientcredentials"
)

func main() {
    oauthConfig := &clientcredentials.Config{
        ClientID:     os.Getenv("OAUTH_CLIENT_ID"),
        ClientSecret: os.Getenv("OAUTH_CLIENT_SECRET"),
        TokenURL:     "https://api.encore.cloud/api/oauth/token",
    }

    client := oauthConfig.Client(context.Background())

    // Make API calls using `client.Get` etc.
    resp, err := client.Get("https://api.encore.cloud.com/api/...")
    // ...
}

----------------------------------------

TITLE: Creating an Availability File with Shell Command
DESCRIPTION: Shell command to create a new file for implementing availability functionality in the booking service.

LANGUAGE: shell
CODE:
$ touch booking/availability.go

----------------------------------------

TITLE: Checking an Encore Application for Errors
DESCRIPTION: Performs compile-time error checking on your application using Encore's compiler.

LANGUAGE: shell
CODE:
$ encore check

----------------------------------------

TITLE: Creating a Redis Cache Cluster in Encore
DESCRIPTION: Shows how to define a Redis-based cache cluster in Encore. The cluster is configured with a specific eviction policy and can be used for high-speed caching across services.

LANGUAGE: go
CODE:
import "encore.dev/storage/cache"

var MyCacheCluster = cache.NewCluster("my-cache-cluster", cache.ClusterConfig{
    EvictionPolicy: cache.AllKeysLRU,
})

----------------------------------------

TITLE: Implementing a Temporal Activity in Go
DESCRIPTION: Creates a simple ComposeGreeting activity function that formats a greeting message. This activity is called by the Greeting workflow and demonstrates the activity pattern in Temporal.

LANGUAGE: go
CODE:
package workflow

import (
	"context"
	"fmt"
)

func ComposeGreeting(ctx context.Context, name string) (string, error) {
    greeting := fmt.Sprintf("Hello %s!", name)
    return greeting, nil
}

----------------------------------------

TITLE: Generating Encore API Clients
DESCRIPTION: Generates API clients for your Encore app in various languages including Go, TypeScript, JavaScript, or OpenAPI specifications. Can be customized to specific services and environments.

LANGUAGE: shell
CODE:
$ encore gen client [<app-id>] [--env=<name>] [--services=foo,bar] [--excluded-services=baz,qux] [--lang=<lang>] [flags]

----------------------------------------

TITLE: Checking Encore Version Using CLI
DESCRIPTION: Shows how to check the currently installed version of Encore by using the 'encore version' command in the terminal. The output displays the version number in the format 'encore version vX.Y.Z'.

LANGUAGE: shell
CODE:
encore version v1.28.0

----------------------------------------

TITLE: Configuring Package.json for Prisma Deployment
DESCRIPTION: This shows the required postinstall hook in package.json for Encore Cloud deployments. It ensures that the Prisma client is generated during the build process, making it available for your application.

LANGUAGE: json
CODE:
{
  "scripts": {
    "postinstall": "npx prisma generate --schema=users/prisma/schema.prisma"
  }
}

----------------------------------------

TITLE: Creating an Encore Application for Uptime Monitoring
DESCRIPTION: Command to create a new Encore application using a starting-point template that provides a ready-to-use frontend for the uptime monitoring project.

LANGUAGE: shell
CODE:
$ encore app create uptime --example=github.com/encoredev/example-app-uptime/tree/starting-point

----------------------------------------

TITLE: Auto-Generated Middleware Registration in Encore
DESCRIPTION: Auto-generated code that registers the global middleware with Encore's runtime system. This file creates a middleware object with metadata about the middleware function and registers it during initialization.

LANGUAGE: go
CODE:
package global

import __api "encore.dev/appruntime/apisdk/api"

func init() {
	__api.RegisterGlobalMiddleware(EncoreInternal_middleware_middleware_Middleware)
}

var EncoreInternal_middleware_middleware_Middleware = &__api.Middleware{
	DefLoc:  uint32(0x0),
	Global:  true,
	ID:      "example.com.Middleware",
	Invoke:  Middleware,
	Name:    "Middleware",
	PkgName: "global",
}

----------------------------------------

TITLE: Defining the monitor service with Encore
DESCRIPTION: TypeScript code that creates a new Encore service named 'monitor', establishing the service boundary for the uptime monitoring functionality.

LANGUAGE: typescript
CODE:
import { Service } from "encore.dev/service";

export default new Service("monitor");

----------------------------------------

TITLE: Installing JWT Dependencies for Go Authentication
DESCRIPTION: Commands to install the required Go modules for JWT token validation, including golang-jwt for parsing and validating JWTs and keyfunc for handling JSON Web Keys.

LANGUAGE: shell
CODE:
$ go get github.com/golang-jwt/jwt/v5
$ go get github.com/MicahParks/keyfunc/v3

----------------------------------------

TITLE: Creating a URL Shortener REST API Endpoint
DESCRIPTION: Implements a POST endpoint to shorten URLs by generating a random base64 ID. This initial implementation only generates IDs without storing them in a database.

LANGUAGE: typescript
CODE:
import { api } from "encore.dev/api";
import { randomBytes } from "node:crypto";

interface URL {
  id: string; // short-form URL id
  url: string; // complete URL, in long form
}

interface ShortenParams {
  url: string; // the URL to shorten
}

// Shortens a URL.
export const shorten = api(
  { method: "POST", path: "/url", expose: true },
  async ({ url }: ShortenParams): Promise<URL> => {
    const id = randomBytes(6).toString("base64url");
    return { id, url };
  },
);

----------------------------------------

TITLE: Setting Secrets in Encore CLI
DESCRIPTION: Shell commands for setting the Slack signing secret in Encore's secrets management system for different environments.

LANGUAGE: shell
CODE:
$ encore secret set --type prod SlackSigningSecret
$ encore secret set --type dev,local,pr SlackSigningSecret

----------------------------------------

TITLE: Using Secret Values in API Calls
DESCRIPTION: Demonstrates how to access secret values in your application code to make authenticated API calls. The example shows using a GitHub API token for authorization.

LANGUAGE: go
CODE:
func callGitHub(ctx context.Context) {
    req, _ := http.NewRequestWithContext(ctx, "GET", "https:///api.github.com/user", nil)
    req.Header.Add("Authorization", "token " + secrets.GitHubAPIToken)
    resp, err := http.DefaultClient.Do(req)
    // ... handle err and resp
}

----------------------------------------

TITLE: Extracting a Microservice from a Monolith in Go
DESCRIPTION: Code for the new 'yo' microservice after extracting the H2 endpoint from the monolith. This demonstrates how to split functionality into separate services in Encore.

LANGUAGE: go
CODE:
package yo

import (
	"context"
)

//encore:api public path=/yo/:name
func H2(ctx context.Context, name string) (*Response, error) {
	msg := "Yo, " + name + "!"
	return &Response{Message: msg}, nil
}

type Response struct {
	Message string
}

----------------------------------------

TITLE: ASCII Cow Art Template in Go
DESCRIPTION: Constant string definition containing the ASCII art template for the cowsay output, with proper formatting for the user's input message.

LANGUAGE: go
CODE:
const cowart = `
 ________________________________________
< %- 38s >
 ----------------------------------------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||
`

----------------------------------------

TITLE: Enabling Debug Mode in Encore Applications via CLI
DESCRIPTION: Command to run an Encore application in debug mode with the --debug=break flag, which pauses execution until a debugger is attached. The output shows the local API endpoint, dashboard URL, process ID, and debugger listening address.

LANGUAGE: shell
CODE:
$ encore run --debug=break
  Your API is running at:     http://127.0.0.1:4000
  Development Dashboard URL:  http://localhost:9400/ai-chat-ts-qhwi
  Process ID:                 38965

Debugger listening on ws://127.0.0.1:9229/473dd95f-e71e-4bf2-9eda-6132dd0d6ae3

----------------------------------------

TITLE: Converting NestJS Controller to Encore APIs
DESCRIPTION: Transforms a NestJS controller into Encore API endpoints using the api function. This example defines three endpoints (findAll, get, create) that use the applicationContext to access NestJS services.

LANGUAGE: typescript
CODE:
export const findAll = api(
  {expose: true, method: 'GET', path: '/cats'},
  async (): Promise<{ cats: Cat[] }> => {
    const {catsService} = await applicationContext;
    return {cats: await catsService.findAll()};
  },
);

export const get = api(
  {expose: true, method: 'GET', path: '/cats/:id'},
  async ({id}: { id: number }): Promise<{ cat: Cat }> => {
    const {catsService} = await applicationContext;
    return {cat: await catsService.get(id)};
  },
);

export const create = api(
  {expose: true, auth: true, method: 'POST', path: '/cats'},
  async (dto: CreateCatDto): Promise<void> => {
    const {catsService} = await applicationContext;
    catsService.create(dto);
  },
);

----------------------------------------

TITLE: Using the Error Builder Pattern in Encore
DESCRIPTION: Shows how to use the builder pattern for creating structured errors with metadata and specific error codes.

LANGUAGE: go
CODE:
eb := errs.B().Meta("board_id", params.ID)
return eb.Code(errs.NotFound).Msg("board not found").Err()

----------------------------------------

TITLE: Implementing a Temporal Workflow in Go
DESCRIPTION: Defines a Greeting workflow that uses a Temporal context to execute an activity with timeout settings. The workflow orchestrates the execution of the ComposeGreeting activity and returns its result.

LANGUAGE: go
CODE:
package workflow

import (
	"time"

	"go.temporal.io/sdk/workflow"
)

func Greeting(ctx workflow.Context, name string) (string, error) {
    options := workflow.ActivityOptions{
        StartToCloseTimeout: time.Second * 5,
    }

    ctx = workflow.WithActivityOptions(ctx, options)

    var result string
    err := workflow.ExecuteActivity(ctx, ComposeGreeting, name).Get(ctx, &result)

    return result, err
}

----------------------------------------

TITLE: Creating a Counter with Labels in Go using Encore
DESCRIPTION: This snippet shows how to define and use a counter with labels. It creates a labeled counter for processed orders that tracks whether processing was successful or not, providing more detailed metrics.

LANGUAGE: go
CODE:
type Labels struct {
    Success bool
}

var OrdersProcessed = metrics.NewCounterGroup[Labels, uint64]("orders_processed", metrics.CounterConfig{})

func process(order *Order) {
    var success bool
    // ... populate success with true/false ...
    OrdersProcessed.With(Labels{Success: success}).Increment()
}

----------------------------------------

TITLE: Setting up a Temporal Service in Encore
DESCRIPTION: Creates an Encore service for Temporal integration with environment-specific task queues, client initialization, and worker setup. The service handles connection to Temporal and proper lifecycle management.

LANGUAGE: go
CODE:
package greeting

import (
	"context"
	"fmt"

	"go.temporal.io/sdk/client"
	"go.temporal.io/sdk/worker"
	"encore.dev"
)

// Use an environment-specific task queue so we can use the same
// Temporal Cluster for all cloud environments.
var (
    envName = encore.Meta().Environment.Name
    greetingTaskQueue = envName + "-greeting"
)

//encore:service
type Service struct {
	client client.Client
	worker worker.Worker
}

func initService() (*Service, error) {
	c, err := client.Dial(client.Options{})
	if err != nil {
		return nil, fmt.Errorf("create temporal client: %v", err)
	}

	w := worker.New(c, greetingTaskQueue, worker.Options{})

	err = w.Start()
	if err != nil {
		c.Close()
		return nil, fmt.Errorf("start temporal worker: %v", err)
	}
	return &Service{client: c, worker: w}, nil
}

func (s *Service) Shutdown(force context.Context) {
	s.client.Close()
	s.worker.Stop()
}

----------------------------------------

TITLE: Creating a Multi-Field Cache Key with Encore
DESCRIPTION: Demonstrates how to create a complex cache key using a struct to track requests per user and resource path. The KeyPattern uses multiple struct fields for more granular caching.

LANGUAGE: go
CODE:
type MyKey struct {
    UserID auth.UID
    ResourcePath string // the resource being accessed
}

// ResourceRequestsPerUser tracks the number of requests per user and resource.
// The cache items expire after 10 seconds without activity.
var ResourceRequestsPerUser = cache.NewIntKeyspace[MyKey](cluster, cache.KeyspaceConfig{
	KeyPattern:    "requests/:UserID/:ResourcePath",
	DefaultExpiry: cache.ExpireIn(10 * time.Second),
})

// ... then:
key := MyKey{UserID: "some-user-id", ResourcePath: "/foo"}
ResourceRequestsPerUser.Increment(ctx, key, 1)

----------------------------------------

TITLE: Using Attributes in PubSub Messages with Encore
DESCRIPTION: This snippet demonstrates how to define message attributes in a Pub/Sub topic. Attributes are key-value pairs that can be used for filtering messages or ensuring message ordering.

LANGUAGE: typescript
CODE:
import { Topic, Attribute } from "encore.dev/pubsub";

export interface SignupEvent {
    userID: string;
    source: Attribute<string>;
}

export const signups = new Topic<SignupEvent>("signups", {
    deliveryGuarantee: "at-least-once",
});

----------------------------------------

TITLE: Implementing CRUD Endpoints for Site Service
DESCRIPTION: Implementation of Get, Add, List, and Delete endpoints for the site service. These files define the API endpoints and their handlers using GORM for database operations.

LANGUAGE: go
CODE:
-- site/get.go --
package site

import "context"

// Site describes a monitored site.
type Site struct {
	// ID is a unique ID for the site.
	ID int `json:"id"`
	// URL is the site's URL.
	URL string `json:"url"`
}

// Get gets a site by id.
//
//encore:api public method=GET path=/site/:siteID
func (s *Service) Get(ctx context.Context, siteID int) (*Site, error) {
	var site Site
	if err := s.db.Where("id = $1", siteID).First(&site).Error; err != nil {
		return nil, err
	}
	return &site, nil
}

LANGUAGE: go
CODE:
-- site/add.go --
package site

import "context"

// AddParams are the parameters for adding a site to be monitored.
type AddParams struct {
	// URL is the URL of the site. If it doesn't contain a scheme
	// (like "http:" or "https:") it defaults to "https:".
	URL string `json:"url"`
}

// Add adds a new site to the list of monitored websites.
//
//encore:api public method=POST path=/site
func (s *Service) Add(ctx context.Context, p *AddParams) (*Site, error) {
	site := &Site{URL: p.URL}
	if err := s.db.Create(site).Error; err != nil {
		return nil, err
	}
	return site, nil
}

LANGUAGE: go
CODE:
-- site/list.go --
package site

import "context"

type ListResponse struct {
	// Sites is the list of monitored sites.
	Sites []*Site `json:"sites"`
}

// List lists the monitored websites.
//
//encore:api public method=GET path=/site
func (s *Service) List(ctx context.Context) (*ListResponse, error) {
	var sites []*Site
	if err := s.db.Find(&sites).Error; err != nil {
		return nil, err
	}
	return &ListResponse{Sites: sites}, nil
}

LANGUAGE: go
CODE:
-- site/delete.go --
package site

import "context"

// Delete deletes a site by id.
//
//encore:api public method=DELETE path=/site/:siteID
func (s *Service) Delete(ctx context.Context, siteID int) error {
	return s.db.Delete(&Site{ID: siteID}).Error
}

----------------------------------------

TITLE: Auto-generated Encore Service Registration
DESCRIPTION: Auto-generated code that registers the service with Encore's runtime. This handles service initialization and makes the service available to the Encore platform.

LANGUAGE: go
CODE:
package basic

import __service "encore.dev/appruntime/apisdk/service"

func init() {
	__service.Register(EncoreInternal_svcstruct_Service)
}

var EncoreInternal_svcstruct_Service = &__service.Decl[Service]{
	Name:        "Service",
	Service:     "basic",
	Setup:       nil,
	SetupDefLoc: uint32(0x0),
}

----------------------------------------

TITLE: Creating Advanced Cron Jobs with Cron Expressions in Encore
DESCRIPTION: Example of using a cron expression for more complex scheduling needs. This example runs a job at 4am on the 15th day of each month using standard cron syntax instead of the 'every' field.

LANGUAGE: typescript
CODE:
// Run the monthly accounting sync job at 4am (UTC) on the 15th day of each month.
const _ = new CronJob("accounting-sync", {
	title:    "Cron Job Example",
	schedule: "0 4 15 * *",
	endpoint: accountingSync,
})

----------------------------------------

TITLE: Adding Test Script to package.json for Vitest Integration
DESCRIPTION: Configuration update for package.json to add a test script that runs Vitest. This enables running tests using 'npm test' or 'encore test' commands.

LANGUAGE: json
CODE:
"scripts": {
  "test": "vitest"
},

----------------------------------------

TITLE: Creating a New Encore Application
DESCRIPTION: Creates a new Encore application with the specified name.

LANGUAGE: shell
CODE:
$ encore app create [name]

----------------------------------------

TITLE: Using Number Type for Path Parameters in Encore.ts
DESCRIPTION: Demonstrates how to use the number type for path parameters in Encore.ts. The framework will attempt to parse the path parameter as a number and return a 400 Bad Request if parsing fails.

LANGUAGE: typescript
CODE:
interface Request {
  id: number;
}

----------------------------------------

TITLE: Setting Cookies in Encore API Responses
DESCRIPTION: This snippet demonstrates how to set cookies in API responses using the header tag with Set-Cookie. The example shows a login endpoint that returns a session cookie.

LANGUAGE: go
CODE:
type LoginResponse struct {
    SessionID string `header:"Set-Cookie"`
}

//encore:api public method=POST path=/login
func Login(ctx context.Context) (*LoginResponse, error) {
    return &LoginResponse{SessionID: "session=123"}, nil
}

----------------------------------------

TITLE: Connecting to Delve Server from Terminal
DESCRIPTION: Command to connect to a running Delve debug server from the terminal, and the expected output showing the Delve command prompt.

LANGUAGE: shell
CODE:
$ dlv connect :2345
Type 'help' for list of commands.
(dlv)

----------------------------------------

TITLE: Configuring PubSub Subscription in Encore
DESCRIPTION: Demonstrates how to create a subscription to a topic in Encore's pubsub system. This includes specifying the topic, subscription name, and handler function.

LANGUAGE: go
CODE:
var _ = pubsub.NewSubscription(
    user.Signups, "send-welcome-email",
    pubsub.SubscriptionConfig[*SignupEvent]{
        Handler: SendWelcomeEmail,
    },
)

----------------------------------------

TITLE: Configuring NSQ in Encore
DESCRIPTION: JSON configuration for NSQ message queue system in an Encore application. Defines hosts, topics, and subscriptions for this lightweight message platform. Allows simple naming conventions for topic and subscription identifiers.

LANGUAGE: json
CODE:
{
  "pubsub": [
    {
      "type": "nsq",
      "hosts": "nsq.myencoreapp.com:4150",
      "topics": {
        "my-topic": {
          "name": "my-topic",
          "subscriptions": {
            "my-subscription": {
                "name": "my-subscription"
            }
          }
        }
      }
    }
  ]
}

----------------------------------------

TITLE: Defining a gRPC Service with Protobuf
DESCRIPTION: Protobuf definition for a simple greeting service that accepts a name and returns a greeting. The file defines the message structures and service interface using Protocol Buffers version 3 syntax.

LANGUAGE: protobuf
CODE:
syntax = "proto3";

package greet.v1;

option go_package = "encore.app/gen/greet/v1;greetv1";

message GreetRequest {
  string name = 1;
}

message GreetResponse {
  string greeting = 1;
}

service GreetService {
  rpc Greet(GreetRequest) returns (GreetResponse) {}
}

----------------------------------------

TITLE: Retrieving Object Attributes in Object Storage in Go
DESCRIPTION: Demonstrates how to get metadata about an object using the Attrs method, which returns information like size, content type, and ETag.

LANGUAGE: go
CODE:
attrs, err := ProfilePictures.Attrs(ctx, "my-user-id")
if errors.Is(err, objects.ErrObjectNotFound) {
	// Object not found
} else if err != nil {
	// Some other error
}
// Do something with attrs

----------------------------------------

TITLE: Implementing Method-based Handlers in Encore Pub/Sub
DESCRIPTION: Example demonstrating how to use pubsub.MethodHandler to define subscription handlers as methods on a service struct, allowing access to injected dependencies.

LANGUAGE: go
CODE:
//encore:service
type Service struct { /* ... */ }

func (s *Service) SendWelcomeEmail(ctx context.Context, event *SignupEvent) error {
	// ...
}

var _ = pubsub.NewSubscription(
  user.Signups, "send-welcome-email",
  pubsub.SubscriptionConfig[*SignupEvent]{
    Handler: pubsub.MethodHandler((*Service).SendWelcomeEmail),
  },
)

----------------------------------------

TITLE: Refactoring Site Check Logic in Go with Encore
DESCRIPTION: Restructures the Check endpoint to extract the site checking logic into a separate function for reuse. The Check endpoint remains public while the check function becomes internal, handling the actual site pinging and recording of results.

LANGUAGE: go
CODE:
// Check checks a single site.
//
//encore:api public method=POST path=/check/:siteID
func Check(ctx context.Context, siteID int) error {
	site, err := site.Get(ctx, siteID)
	if err != nil {
		return err
	}
	return check(ctx, site)
}

func check(ctx context.Context, site *site.Site) error {
	result, err := Ping(ctx, site.URL)
	if err != nil {
		return err
	}
	_, err = db.Exec(ctx, `
		INSERT INTO checks (site_id, up, checked_at)
		VALUES ($1, $2, NOW())
	`, site.ID, result.Up)
	return err
}

----------------------------------------

TITLE: Defining an Authentication Handler with Encore
DESCRIPTION: This snippet defines an auth handler structure and function for the Encore framework. It demonstrates how to extract authentication data from HTTP headers, query parameters, and cookies using struct tags.

LANGUAGE: go
CODE:
package code

import ("context"; "net/http"; "encore.dev/beta/auth")

type MyAuthParams struct {
	ClientID string `header:"X-Client-ID"`
	APIKey   string `query:"key"`
	SessionToken string `cookie:"session_token"`
	OtherCookie *http.Cookie `cookie:"other_cookie"`
	IntCookie int `cookie:"int_cookie"`
}

//encore:authhandler
func AuthHandler(ctx context.Context, p *MyAuthParams) (auth.UID, error) {
    return "", nil
}

----------------------------------------

TITLE: Mocking Authentication Data in Vitest for Encore API Testing
DESCRIPTION: Shows how to mock the getAuthData function in unit tests using Vitest. This technique allows testing endpoints that require authentication without setting up actual authentication infrastructure.

LANGUAGE: typescript
CODE:
import { describe, expect, test, vi } from "vitest";
import * as auth from "~encore/auth"; 
import { get } from "./hello";


describe("get", () => {
  test("should combine string with parameter value", async () => {
    const spy = vi.spyOn(auth, 'getAuthData');
    spy.mockImplementation(() => ({ userEmail: "user@email.com" }))

    const resp = await get({ name: "world" });
    expect(resp.message).toBe("Hello world! You are authenticated with user@email.com");
  });
});

----------------------------------------

TITLE: Creating Database Migration for Sites Table in SQL
DESCRIPTION: SQL migration script to create the 'sites' table with an ID and URL field. This establishes the database schema for storing website information to monitor.

LANGUAGE: sql
CODE:
-- site/migrations/1_create_tables.up.sql --
CREATE TABLE sites (
    id BIGSERIAL PRIMARY KEY,
    url TEXT NOT NULL
);

----------------------------------------

TITLE: Building Docker Image with Encore for Self-Hosting
DESCRIPTION: Shell command to build a Docker image of the URL shortener application using Encore's build system. The image is tagged as 'url-shortener:v1.0'.

LANGUAGE: shell
CODE:
$ encore build docker url-shortener:v1.0

----------------------------------------

TITLE: Generating API Client for Encore App
DESCRIPTION: Creates API clients in various languages (Go, TypeScript, JavaScript, OpenAPI) based on your app, with options to specify environment and services.

LANGUAGE: shell
CODE:
$ encore gen client [<app-id>] [--env=<name>] [--services=foo,bar] [--excluded-services=baz,qux] [--lang=<lang>] [flags]

----------------------------------------

TITLE: VS Code Debug Configuration for Delve Server Connection
DESCRIPTION: JSON configuration for Visual Studio Code to connect to a Delve debug server. Specifies connection details including host and port.

LANGUAGE: json
CODE:
{
    "version": "0.2.0",
    "configurations": [
        {
            "name": "Connect to server",
            "type": "go",
            "request": "attach",
            "mode": "remote",
            "remotePath": "${workspaceFolder}",
            "port": 2345,
            "host": "127.0.0.1"
        }
    ]
}

----------------------------------------

TITLE: Connecting to Encore Database via Shell
DESCRIPTION: Connects to a specified Encore database using psql shell with configurable permission levels. Defaults to local environment with read-only permissions.

LANGUAGE: shell
CODE:
$ encore db shell <database-name> [--env=<name>]

----------------------------------------

TITLE: Configuring Client Generation in package.json
DESCRIPTION: Example of integrating Encore client generation into a package.json script for a TypeScript frontend project, targeting a staging environment.

LANGUAGE: json
CODE:
{
  "scripts": {
    // ...
    "gen": "encore gen client hello-a8bc --output=./client.ts --env=staging"
    // ...
  }
}

----------------------------------------

TITLE: Setting Up a Relay to Consume Messages from the Outbox in Go
DESCRIPTION: Implementation of an outbox relay that polls the outbox table and publishes messages to actual Pub/Sub topics. The code initializes the relay with a SQL database store, registers topics to be monitored, and starts a background polling process.

LANGUAGE: go
CODE:
package user

import (
	"context"
	
    "encore.dev/pubsub"
    "encore.dev/storage/sqldb"
    "x.encore.dev/infra/pubsub/outbox"
)

type Service struct {
	signupsRef pubsub.Publisher[*SignupEvent]
}

// db is the database the outbox table is stored in
var db = sqldb.NewDatabase(...)

// Create the SignupsTopic somehow.
var SignupsTopic = pubsub.NewTopic[*SignupEvent](/* ... */)

func initService() (*Service, error) {
    // Initialize the relay to poll from our database.
	relay := outbox.NewRelay(outbox.SQLDBStore(db))
	
	// Register the SignupsTopic to be polled.
    signupsRef := pubsub.TopicRef[pubsub.Publisher[*SignupEvent]](SignupsTopic)
	outbox.RegisterTopic(relay, signupsRef)
	
	// Start polling.
	go relay.PollForMessage(context.Background(), -1)
	
	return &Service{signupsRef: signupsRef}, nil
}

----------------------------------------

TITLE: Validating Number Fields in Encore.ts
DESCRIPTION: This example demonstrates how to validate number fields in request schemas, which accept both integer and float values.

LANGUAGE: typescript
CODE:
interface Schema {
  age:  number;
}

----------------------------------------

TITLE: Configuring Redis Connections in Encore
DESCRIPTION: JSON configuration for Redis resources in an Encore application. Includes settings for host, authentication, database index, and connection pool settings. Uses environment variables for sensitive information like authentication strings.

LANGUAGE: json
CODE:
{
  "redis": {
    "my-redis": {
      "host": "redis.myencoreapp.com:6379",
      "database_index": 0,
      "auth": {
        "type": "auth",
        "auth_string": {
          "$env": "REDIS_AUTH_STRING"
        }
      },
      "max_connections": 50,
      "min_connections": 5
    }
  }
}

----------------------------------------

TITLE: Encore Generated Service Interface for Go
DESCRIPTION: Auto-generated code by Encore that defines a service interface. This provides a consistent API surface area for mocking and service-to-service communication, reflecting the exposed endpoints.

LANGUAGE: go
CODE:
// Code generated by encore. DO NOT EDIT.

package basic

import "context"

// These functions are automatically generated and maintained by Encore
// to simplify calling them from other services, as they were implemented as methods.
// They are automatically updated by Encore whenever your API endpoints change.

// Interface defines the service's API surface area, primarily for mocking purposes.
//
// Raw endpoints are currently excluded from this interface, as Encore does not yet
// support service-to-service API calls to raw endpoints.
type Interface interface {
	Foo(ctx context.Context) (*Params, error)
}

----------------------------------------

TITLE: SQL Database Configuration for Encore
DESCRIPTION: JSON configuration for setting up SQL database connections in Encore applications, including host, TLS settings, and connection parameters.

LANGUAGE: json
CODE:
{
  "sql_servers": [
    {
      "host": "db.myencoreapp.com:5432",
      "tls_config": {
        "disabled": false,
        "ca": "---BEGIN CERTIFICATE---\n..."
      },
      "databases": {
        "main_db": {
          "max_connections": 100,
          "min_connections": 10,
          "username": "db_user",
          "password": {
            "$env": "DB_PASSWORD"
          }
        }
      }
    }
  ]
}

----------------------------------------

TITLE: Testing the API with cURL
DESCRIPTION: Command to test the API endpoint by making an HTTP request to the locally running Encore application using cURL. Returns a JSON response with a greeting message.

LANGUAGE: shell
CODE:
$ curl http://localhost:4000/hello/world
{"Message": "Hello, world!"}

----------------------------------------

TITLE: Creating Topic References for Flexible Usage in Go
DESCRIPTION: This example demonstrates how to create a topic reference that can be passed around freely in code, unlike topic variables which have static analysis restrictions. It shows creating a reference with publisher permissions.

LANGUAGE: go
CODE:
signupRef := pubsub.TopicRef[pubsub.Publisher[*SignupEvent]](Signups)

// signupRef is of type pubsub.Publisher[*SignupEvent], which allows publishing.

----------------------------------------

TITLE: Updating Slack Webhook to Include Signature Verification
DESCRIPTION: Updated TypeScript implementation of the cowsay webhook endpoint that incorporates signature verification. The code now verifies the authenticity of incoming requests from Slack before processing them.

LANGUAGE: typescript
CODE:
export const cowsay = api.raw(
  { expose: true, path: "/cowsay", method: "*" },
  async (req, resp) => {
    const body = await getBody(req);

    try {
      await verifySignature(body, req.headers);
    } catch (err) {
      const e = err as Error;
      resp.statusCode = 500;
      resp.end(e.message);
      return;
    }

    const text = new URLSearchParams(body).get("text");
    const msg = cowart(text || "Moo!");
    resp.setHeader("Content-Type", "application/json");
    resp.end(JSON.stringify({ response_type: "in_channel", text: msg }));
  },
);

----------------------------------------

TITLE: Publishing Site Status Transition Events in Go
DESCRIPTION: Implements a function to check if a site's status has changed and publish an event to the Pub/Sub topic if it has. This allows decoupled notification of status changes without direct integration to notification services.

LANGUAGE: go
CODE:
import "encore.app/site"

func publishOnTransition(ctx context.Context, site *site.Site, isUp bool) error {
	wasUp, err := getPreviousMeasurement(ctx, site.ID)
	if err != nil {
		return err
	}
	if isUp == wasUp {
		// Nothing to do
		return nil
	}
	_, err = TransitionTopic.Publish(ctx, &TransitionEvent{
		Site: site,
		Up:   isUp,
	})
	return err
}

----------------------------------------

TITLE: Implementing Token Validation against Firebase in Go
DESCRIPTION: Implementation of the ValidateToken function that verifies Firebase ID tokens and extracts user information from token claims.

LANGUAGE: go
CODE:
func ValidateToken(ctx context.Context, token string) (auth.UID, *Data, error) {
    if err := setupFB(); err != nil {
		return "", nil, err
	}
	tok, err := fbAuth.VerifyIDToken(ctx, token)
	if err != nil {
		return "", nil, err
	}

	email, _ := tok.Claims["email"].(string)
	name, _ := tok.Claims["name"].(string)
	picture, _ := tok.Claims["picture"].(string)
	uid := auth.UID(tok.UID)

	usr := &Data{
		Email:   email,
		Name:    name,
		Picture: picture,
	}
	return uid, usr, nil
}

----------------------------------------

TITLE: Defining Basic Cron Job with Schedule in Go
DESCRIPTION: Creates a cron job named 'cronfooboo' that runs every Friday with a specific title. The job is configured to call the CronAPI endpoint when triggered.

LANGUAGE: go
CODE:
var _ = cron.NewJob("cronfooboo", cron.JobConfig{
	Title:     "Cron Foo Boo",
	Schedule: "* * * * 5",
	Endpoint: CronAPI,
})

----------------------------------------

TITLE: Generating GraphQL Resolver Stubs
DESCRIPTION: Command to generate resolver stubs based on the GraphQL schema, creating placeholders for implementation.

LANGUAGE: shell
CODE:
$ go generate ./graphql

----------------------------------------

TITLE: Testing Encore Applications
DESCRIPTION: Tests your Encore application using all the standard Go test flags and functionality.

LANGUAGE: shell
CODE:
$ encore test ./... [go test flags]

----------------------------------------

TITLE: Restarting the Encore CLI Daemon
DESCRIPTION: Restarts the Encore CLI daemon to resolve unexpected behavior issues.

LANGUAGE: shell
CODE:
$ encore daemon

----------------------------------------

TITLE: Retrieving Database Connection URI
DESCRIPTION: Outputs a connection string for a specified database, with options to select environment.

LANGUAGE: shell
CODE:
$ encore db conn-uri <database-name> [--env=<name>] [flags]

----------------------------------------

TITLE: CLI Tool Using Generated Go Client
DESCRIPTION: Example of building a command-line tool that uses a generated Go client for a URL shortener API. Demonstrates client initialization, authentication, API calls, and structured error handling.

LANGUAGE: go
CODE:
package main

import (
    "context"
    "fmt"
    "os"
    "time"

    "shorten_cli/client"
)

func main() {
    // Create a new client with the default BaseURL
    client, err := client.New(
        client.Environment("production"),
        client.WithAuth(os.Getenv("SHORTEN_API_KEY")),
    )
    if err != nil {
        panic(err)
    }

    // Timeout if the request takes more than 5 seconds
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()

    // Call the Shorten function in the URL service
    resp, err := client.Url.Shorten(
        ctx,
        client.UrlShortenParams{ URL: os.Args[1] },
    )
    if err != nil {
        // Check the error returned
        if err, ok := err.(*client.APIError); ok {
            switch err.Code {
            case client.ErrUnauthenticated:
                fmt.Println("SHORTEN_API_KEY was invalid, please check your environment")
                os.Exit(1)
            case client.ErrAlreadyExists:
                fmt.Println("The URL you provided was already shortened")
                os.Exit(0)
            }
        }
        panic(err) // if here then something has gone wrong in an unexpected way
    }
    fmt.Printf("https://short.encr.app/%s", resp.ID)
}

----------------------------------------

TITLE: Defining Query Parameters in Encore API Schemas
DESCRIPTION: This example shows how to define query parameters using the query tag. It demonstrates how to override the default parameter name and explains when fields are read from the query string versus the request body.

LANGUAGE: go
CODE:
type ListBlogPost struct {
    PageLimit  int `query:"limit"` // always a query parameter
    Author     string              // query if GET, HEAD or DELETE, otherwise body parameter
}

----------------------------------------

TITLE: Implementing REST API Endpoints with Path Parameters in Encore
DESCRIPTION: Example of defining a REST API endpoint that retrieves a blog post by ID. The function demonstrates how to use path parameters with the :id syntax in the path definition.

LANGUAGE: go
CODE:
// GetBlogPost retrieves a blog post by id.
//encore:api public method=GET path=/blog/:id
func GetBlogPost(ctx context.Context, id int) (*BlogPost, error) {
    // Use id to query database...
}

----------------------------------------

TITLE: Implementing REST API Endpoints with Path Parameters in Encore
DESCRIPTION: Example of defining a REST API endpoint that retrieves a blog post by ID. The function demonstrates how to use path parameters with the :id syntax in the path definition.

LANGUAGE: go
CODE:
// GetBlogPost retrieves a blog post by id.
//encore:api public method=GET path=/blog/:id
func GetBlogPost(ctx context.Context, id int) (*BlogPost, error) {
    // Use id to query database...
}

----------------------------------------

TITLE: Live-Streaming Logs from Encore Environments
DESCRIPTION: Command-line instruction for streaming logs directly to the terminal from any Encore environment. This example shows how to access production logs using the encore CLI.

LANGUAGE: bash
CODE:
$ encore logs --env=prod

----------------------------------------

TITLE: Configuring Drizzle ORM with TypeScript
DESCRIPTION: Creates a Drizzle configuration file that specifies settings like migration output directory, schema file location, and database dialect (PostgreSQL in this case).

LANGUAGE: typescript
CODE:
// drizzle.config.ts
import 'dotenv/config';
import { defineConfig } from 'drizzle-kit';

export default defineConfig({
  out: 'migrations',
  schema: 'schema.ts',
  dialect: 'postgresql',
});

----------------------------------------

TITLE: Configuring Google Cloud Storage (GCS) in Encore
DESCRIPTION: JSON configuration for setting up Google Cloud Storage in an Encore application. This example defines a GCS bucket with an optional key prefix and public base URL for CDN access. The configuration specifies the bucket name and access parameters.

LANGUAGE: json
CODE:
{
  "object_storage": [
    {
      "type": "gcs",
      "buckets": {
        "my-gcs-bucket": {
          "name": "my-gcs-bucket",
          "key_prefix": "my-optional-prefix/",
          "public_base_url": "https://my-gcs-bucket-cdn.example.com/my-optional-prefix"
        }
      }
    }
  ]
}

----------------------------------------

TITLE: Implementing Site Check Functionality with Direct SQL Queries
DESCRIPTION: Implementation of the Check endpoint for monitoring site status, using Encore's sqldb package for direct SQL queries rather than GORM. Records check results in the database.

LANGUAGE: go
CODE:
-- monitor/check.go --
package monitor

import (
	"context"

	"encore.app/site"
	"encore.dev/storage/sqldb"
)

// Check checks a single site.
//
//encore:api public method=POST path=/check/:siteID
func Check(ctx context.Context, siteID int) error {
	site, err := site.Get(ctx, siteID)
	if err != nil {
		return err
	}
	result, err := Ping(ctx, site.URL)
	if err != nil {
		return err
	}
	_, err = db.Exec(ctx, `
		INSERT INTO checks (site_id, up, checked_at)
		VALUES ($1, $2, NOW())
	`, site.ID, result.Up)
	return err
}

// Define a database named 'monitor', using the database migrations
// in the "./migrations" folder. Encore automatically provisions,
// migrates, and connects to the database.
var db = sqldb.NewDatabase("monitor", sqldb.DatabaseConfig{
	Migrations: "./migrations",
})

----------------------------------------

TITLE: Defining Config Structure with Unexported Field in Encore Application
DESCRIPTION: A Go service definition that shows an invalid configuration setup where a nested struct contains an unexported field 'subField'. This causes an error as Encore cannot initialize unexported fields when loading configuration with config.Load[T]().

LANGUAGE: go
CODE:
package svc

import (
    "context"

    "encore.dev/config"
)

type SubType struct {
    subField string
}

type Config struct {
    FooEnabled bool
    Sub        SubType
}

var Cfg = config.Load[Config]()


//encore:api
func Subscriber1(ctx context.Context) error {
    return nil
}

----------------------------------------

TITLE: Main Service Implementation with SQL Database Connection
DESCRIPTION: Main Go code for the myservice package that defines a named SQL database connection and an Encore API endpoint. It imports Encore's sqldb package for database connectivity.

LANGUAGE: go
CODE:
package myservice

import (
    "context"

    "encore.dev/storage/sqldb"
)

var Moo = sqldb.Named("myservice")

//encore:api public
func Foo(ctx context.Context) error {
    return nil
}

----------------------------------------

TITLE: Creating SQL Migration for Users Table
DESCRIPTION: SQL migration script to create the users table in PostgreSQL with columns for ID, first name, last name, and Slack handle.

LANGUAGE: sql
CODE:
CREATE TABLE users (
    id           BIGSERIAL PRIMARY KEY,
    first_name   VARCHAR(255) NOT NULL,
    last_name    VARCHAR(255) NOT NULL,
    slack_handle VARCHAR(255) NOT NULL
);

----------------------------------------

TITLE: Defining GraphQL Schema for URL Shortener
DESCRIPTION: GraphQL schema definition for a URL shortener service, including Query and Mutation types for retrieving and creating shortened URLs.

LANGUAGE: graphql
CODE:
type Query {
  urls: [URL!]!
  get(id: ID!): URL!
}

type Mutation {
  shorten(input: String!): URL!
}

type URL {
  id:  ID!     # shortened id
  url: String! # full URL
}

----------------------------------------

TITLE: Writing Automated Tests for the Ping Endpoint
DESCRIPTION: Implementation of automated tests for the Ping endpoint to verify it correctly identifies websites as up or down based on different scenarios, including valid and invalid URLs and different HTTP status codes.

LANGUAGE: go
CODE:
package monitor

import (
	"context"
	"testing"
)

func TestPing(t *testing.T) {
	ctx := context.Background()
	tests := []struct {
		URL string
		Up  bool
	}{
		{"encore.dev", true},
		{"google.com", true},
        // Test both with and without "https://"
		{"httpbin.org/status/200", true},
		{"https://httpbin.org/status/200", true},

        // 4xx and 5xx should considered down.
		{"httpbin.org/status/400", false},
		{"https://httpbin.org/status/500", false},
        // Invalid URLs should be considered down.
		{"invalid://scheme", false},
	}

	for _, test := range tests {
		resp, err := Ping(ctx, test.URL)
		if err != nil {
			t.Errorf("url %s: unexpected error: %v", test.URL, err)
		} else if resp.Up != test.Up {
			t.Errorf("url %s: got up=%v, want %v", test.URL, resp.Up, test.Up)
		}
	}
}

----------------------------------------

TITLE: Connecting to an Encore Database via Shell
DESCRIPTION: Connects to a specified database using psql shell, with options to set environment and permission levels.

LANGUAGE: shell
CODE:
$ encore db shell <database-name> [--env=<name>]

----------------------------------------

TITLE: Getting Encore Shadow Database Connection URL
DESCRIPTION: Command to retrieve the connection URL for Encore's shadow database. This is needed for Prisma's schema migrations and operations that require a shadow database.

LANGUAGE: bash
CODE:
encore db conn-uri <database name> --shadow

----------------------------------------

TITLE: Disabling Telemetry via Environment Variable
DESCRIPTION: Shows how to disable Encore's telemetry by setting an environment variable, offering an alternative method to the CLI command.

LANGUAGE: sh
CODE:
export DISABLE_ENCORE_TELEMETRY=1

----------------------------------------

TITLE: Reference Schema for Request Validation in Encore.ts
DESCRIPTION: This example provides a reference schema demonstrating various validation types including strings, numbers, arrays, nullable fields, optional fields, union types, and enums.

LANGUAGE: typescript
CODE:
interface Schema {
  str: string; // String
  int: number; // Number
  list: number[]; // Array of numbers
  listOfTypes: (number | string )[]; // Array multiple types
  nullable: number | null; // Nullable
  maybe?: string; // Optional
  multiple: boolean | number | string | { name: string }; // Union
  enum: "John" | "Foo"; // Enum
}

----------------------------------------

TITLE: Committing and Deploying an Encore Application to Encore Cloud
DESCRIPTION: Git commands to commit changes to your Encore project repository and deploy it to Encore's development cloud. This sequence adds all changes, commits them with a message, and pushes to the Encore remote to trigger a deployment.

LANGUAGE: shell
CODE:
$ git add -A .
$ git commit -m 'Initial commit'
$ git push encore

----------------------------------------

TITLE: Parsing Webhook Events in Go with Encore
DESCRIPTION: Example of how to process webhook events in a Go application using the go.encore.dev/webhooks library. This snippet demonstrates parsing the webhook payload, verifying the signature, and handling different event types.

LANGUAGE: go
CODE:
package service

import (
    "net/http"

    "go.encore.dev/webhooks"
)

var secrets struct {
	EncoreWebhookSecret string
}

//encore:api public raw
func Webhook(w http.ResponseWriter, req *http.Request) {
	payload, err := io.ReadAll(req.Body)
	if err != nil {
		// ... handle error
    }
    event, err := webhooks.ParseEvent(payload, req.Header.Get("X-Encore-Signature"), secrets.EncoreWebhookSecret)
    if err != nil {
        // ... handle error
    }

    switch data := event.Data.(type) {
    case *webhooks.RolloutCreatedEvent:
        // ... handle rollout created event
    case *webhooks.RolloutCompletedEvent:
        // ... handle rollout completed event
    }
}

----------------------------------------

TITLE: Resetting Encore Databases
DESCRIPTION: Resets databases for specified services or all databases with the --all flag.

LANGUAGE: shell
CODE:
$ encore db reset [service-names...] [flags]

----------------------------------------

TITLE: Configuring Custom S3-Compatible Provider in Encore
DESCRIPTION: JSON configuration for setting up a custom S3-compatible storage provider (like Cloudflare R2) in an Encore application. This example defines a bucket with custom endpoint, access credentials (with environment variable for secret), and optional parameters for key prefix and public access.

LANGUAGE: json
CODE:
{
  "object_storage": [
    {
      "type": "s3",
      "region": "auto",
      "endpoint": "https://...",
      "access_key_id": "...",
      "secret_access_key": {
          "$env": "BUCKET_SECRET_ACCESS_KEY"
      },
      "buckets": {
        "my-s3-bucket": {
          "name": "my-s3-bucket",
          "key_prefix": "my-optional-prefix/",
          "public_base_url": "https://my-gcs-bucket-cdn.example.com/my-optional-prefix"          
        }
      }
    }
  ]
}

----------------------------------------

TITLE: Defining Encore Service with API Endpoints in Go
DESCRIPTION: Defines a basic Encore service with various API endpoint patterns including simple calls, raw HTTP handlers, requests with parameters, path parameters, and standalone functions. Each endpoint is annotated with encore:api directives specifying visibility and path options.

LANGUAGE: go
CODE:
package basic

import ("context"; "net/http")

//encore:service
type Service struct{}

// Foo is an amazing API which does
// x, y and z - it's really cool!
//encore:api public
func (s *Service) Foo(ctx context.Context) error { return nil }

//encore:api public raw
func (s *Service) Raw(w http.ResponseWriter, req *http.Request) {}

type Data struct{}

//encore:api public
func (s *Service) WithReq(context.Context, *Data) error { return nil }

//encore:api public
func (s *Service) WithResp(context.Context) (*Data, error) { return nil, nil }

//encore:api public
func (s *Service) WithReqResp(context.Context, *Data) (*Data, error) { return nil, nil }

//encore:api public path=/pathing/:name/:age/*other
func (s *Service) WithPathParams(ctx context.Context, name string, age int, other string) error { return nil }

//encore:api public path=/fallback/!url
func (s *Service) WithFallback(ctx context.Context, url string) error { return nil }

// This API doesn't
// exist on the service struct, but should still
// appear
//
// on the service Interface
//encore:api public
func NoServiceStruct(context.Context) error { return nil }

----------------------------------------

TITLE: Generating Drizzle Migrations with Command Line
DESCRIPTION: Demonstrates the command to generate database migrations using Drizzle Kit. This command should be run in the directory containing the drizzle.config.ts file.

LANGUAGE: bash
CODE:
drizzle-kit generate

----------------------------------------

TITLE: Configuring Custom S3-Compatible Provider in Encore
DESCRIPTION: JSON configuration for setting up a custom S3-compatible storage provider (like Cloudflare R2) in an Encore application. This example defines a bucket with custom endpoint, access credentials (with environment variable for secret), and optional parameters for key prefix and public access.

LANGUAGE: json
CODE:
{
  "object_storage": [
    {
      "type": "s3",
      "region": "auto",
      "endpoint": "https://...",
      "access_key_id": "...",
      "secret_access_key": {
          "$env": "BUCKET_SECRET_ACCESS_KEY"
      },
      "buckets": {
        "my-s3-bucket": {
          "name": "my-s3-bucket",
          "key_prefix": "my-optional-prefix/",
          "public_base_url": "https://my-gcs-bucket-cdn.example.com/my-optional-prefix"          
        }
      }
    }
  ]
}

----------------------------------------

TITLE: Implementing GetNote API Endpoint in Go
DESCRIPTION: API endpoint function that retrieves a note from the database by its ID. It returns the found note or an error if the note doesn't exist.

LANGUAGE: go
CODE:
//encore:api public method=GET path=/note/:id
func GetNote(ctx context.Context, id string) (*Note, error) {
	note := &Note{ID: id}

	// We use the note ID to query the database for the note's text and cover URL.
	err := sqldb.QueryRow(ctx, `
		SELECT text, cover_url FROM note
		WHERE id = $1
	`, id).Scan(&note.Text, &note.CoverURL)

	// If the note doesn't exist, we return an error.
	if err != nil {
		return nil, err
	}

	// Otherwise, we return the note.
	return note, nil
}

----------------------------------------

TITLE: Implementing REST Endpoint for Books API
DESCRIPTION: This TypeScript code implements a REST endpoint for listing books that aligns with the GraphQL schema. It defines a sample database of books and exposes a GET /books endpoint that returns the book data in a format compatible with the GraphQL types.

LANGUAGE: typescript
CODE:
import { api } from "encore.dev/api";
// Import Book type the generated schema types
import { Book } from "../generated/resolvers-types";

const db: Book[] = [
  {
    title: "To Kill a Mockingbird",
    author: "Harper Lee",
  },
  // ...
];

// REST endpoint to get the list of books
export const list = api(
  { expose: true, method: "GET", path: "/books" },
  async (): Promise<{ books: Book[] }> => {
    return { books: db };
  },
);

----------------------------------------

TITLE: Creating Go Tools File for gqlgen Integration
DESCRIPTION: Defines a tools.go file that imports gqlgen packages for code generation, making them available as build tools within the project.

LANGUAGE: go
CODE:
//go:build tools

package tools

import (
    _ "github.com/99designs/gqlgen"
    _ "github.com/99designs/gqlgen/graphql/introspection"
)

----------------------------------------

TITLE: Deploying Backend to Encore Cloud using Git
DESCRIPTION: Commands to commit and push your code to the Encore remote, which triggers deployment of your backend to the Encore Cloud platform.

LANGUAGE: shell
CODE:
$ git add -A .
$ git commit -m 'Initial commit'
$ git push encore

----------------------------------------

TITLE: Validating Arrays with Multiple Types in Encore.ts
DESCRIPTION: This example demonstrates how to validate arrays that can contain multiple types of values in request schemas.

LANGUAGE: typescript
CODE:
interface Schema {
  values:  (string | number)[];
}

----------------------------------------

TITLE: Creating a New Encore Account
DESCRIPTION: Signs up for a new Encore account.

LANGUAGE: shell
CODE:
$ encore auth signup

----------------------------------------

TITLE: Enabling Telemetry Debug Mode
DESCRIPTION: Shows how to enable debug mode for telemetry by setting an environment variable, which helps users see what data is being sent.

LANGUAGE: sh
CODE:
export ENCORE_TELEMETRY_DEBUG=1

----------------------------------------

TITLE: Building Docker Image for Encore App
DESCRIPTION: Creates a portable Docker image of your Encore application that can be used for self-hosting. Includes options to specify base image and push to repository.

LANGUAGE: shell
CODE:
$ encore build docker

----------------------------------------

TITLE: Creating Tag-Targeted Middleware in Service Package
DESCRIPTION: Defines a middleware function that targets only API endpoints tagged with 'foo'. The middleware is defined within a service package, making it service-specific.

LANGUAGE: go
CODE:
//encore:middleware target=tag:foo
func TaggedInSvc(req middleware.Request, next middleware.Next) middleware.Response {
    return next(req)
}

----------------------------------------

TITLE: Displaying Encore Environment Information
DESCRIPTION: Outputs information about the current Encore environment configuration.

LANGUAGE: shell
CODE:
$ encore daemon env

----------------------------------------

TITLE: Generating Encore Client with CLI Command
DESCRIPTION: Command to generate a TypeScript client for your Encore application. It creates a client file with type definitions that match your backend API endpoints.

LANGUAGE: bash
CODE:
$ encore gen client <ENCORE-APP-ID> --output=./src/client.ts --env=<ENV_NAME>

----------------------------------------

TITLE: Example Application Using Config Wrappers
DESCRIPTION: Sample application showing how to use config wrappers for future-proofing configuration values. Config wrappers allow real-time updates and value overrides in tests.

LANGUAGE: go
CODE:
-- svc/svc.go --
type mysvc

import (
    "encore.dev/config"
)

type Server struct {
    // The config wrappers do not have to be in the top level struct
    Enabled config.Bool
    Port    config.Int
}

type SvcConfig struct {
    GameServerPorts config.Values[Server]
}

var cfg = config.Load[*SvcConfig]()

func startServers() {
    for _, server := range cfg.GameServerPorts() {
        if server.Enabled() {
            go startServer(server.Port())
        }
    }
}

func startServer(port int) {
  // ...
}

LANGUAGE: cue
CODE:
-- svc/servers.cue --
GameServerPorts: [
    {
        Enabled: false
        Port:    12345
    },
    {
        Enabled: true
        Port:    1337
    },
]

----------------------------------------

TITLE: Implementing User Management Service in Go
DESCRIPTION: Implementation of a service to manage users with endpoints for creating and retrieving users. The service interacts with a PostgreSQL database to store user data.

LANGUAGE: go
CODE:
// Service users manages users and assigns incidents.
package users

import (
	"context"
	"encore.dev/storage/sqldb"
)

// This is a Go struct representing our PostgreSQL schema for `users`
type User struct {
	Id          int32
	FirstName   string
	LastName    string
	SlackHandle string
}

// Define a database named 'users', using the database migrations
// in the "./migrations" folder. Encore automatically provisions,
// migrates, and connects to the database.
var db = sqldb.NewDatabase("users", sqldb.DatabaseConfig{
	Migrations: "./migrations",
})

//encore:api public method=POST path=/users
func Create(ctx context.Context, params CreateParams) (*User, error) {
	user := User{}
	err := db.QueryRow(ctx, `
		INSERT INTO users (first_name, last_name, slack_handle)
		VALUES ($1, $2, $3)
		RETURNING id, first_name, last_name, slack_handle
	`, params.FirstName, params.LastName, params.SlackHandle).Scan(&user.Id, &user.FirstName, &user.LastName, &user.SlackHandle)
	if err != nil {
		return nil, err
	}
	return &user, nil
}

// This is what JSON params our POST /users endpoint will accept
type CreateParams struct {
	FirstName   string
	LastName    string
	SlackHandle string
}

//encore:api public method=GET path=/users/:id
func Get(ctx context.Context, id int32) (*User, error) {
	user := User{}
	err := db.QueryRow(ctx, `
	  SELECT id, first_name, last_name, slack_handle
		FROM users
		WHERE id = $1
	`, id).Scan(&user.Id, &user.FirstName, &user.LastName, &user.SlackHandle)
	if err != nil {
		return nil, err
	}
	return &user, nil
}

----------------------------------------

TITLE: Using Bucket References with Single Permission in Object Storage in Go
DESCRIPTION: Shows how to create a bucket reference with a specific permission using BucketRef. This approach allows bucket references to be passed around while maintaining static analysis for permissions.

LANGUAGE: go
CODE:
ref := objects.BucketRef[objects.Downloader](ProfilePictures)

// ref is of type objects.Downloader, which allows downloading.

----------------------------------------

TITLE: Using Secrets in API Calls
DESCRIPTION: Demonstrates how to access and use secrets in API calls, specifically adding a GitHub API token to request headers.

LANGUAGE: go
CODE:
func callGitHub(ctx context.Context) {
    req.Header.Add("Authorization", "token " + secrets.GitHubAPIToken)
}

----------------------------------------

TITLE: Creating PostgreSQL Schema for Schedules
DESCRIPTION: SQL migration script that creates a schedules table with associated columns and an index for optimizing time range lookups. The schema includes fields for user ID and schedule time ranges.

LANGUAGE: sql
CODE:
CREATE TABLE schedules
(
    id         BIGSERIAL PRIMARY KEY,
    user_id    INTEGER   NOT NULL,
    start_time TIMESTAMP NOT NULL,
    end_time   TIMESTAMP NOT NULL
);

CREATE INDEX schedules_range_index ON schedules (start_time, end_time);

----------------------------------------

TITLE: Creating an Encore Service Definition for GraphQL
DESCRIPTION: Defines a new Encore service named 'graphql' which will provide the GraphQL API functionality. This service definition allows Encore to recognize and manage this component within the application.

LANGUAGE: typescript
CODE:
import { Service } from "encore.dev/service";

export default new Service("graphql");

----------------------------------------

TITLE: Subscribing to PubSub Events in Go
DESCRIPTION: This snippet shows how to create a subscription to a PubSub topic. It demonstrates subscribing to the 'Signups' topic from another service to send welcome emails when new users sign up, including the handler function that processes each event.

LANGUAGE: go
CODE:
package email

import (
    "encore.dev/pubsub"
    "user"
)

var _ = pubsub.NewSubscription(
    user.Signups, "send-welcome-email",
    pubsub.SubscriptionConfig[*SignupEvent]{
        Handler: SendWelcomeEmail,
    },
)
func SendWelcomeEmail(ctx context.Context, event *SignupEvent) error {
    // send email...
    return nil
}

----------------------------------------

TITLE: Creating a Todo Items Table in SQL for Encore Application
DESCRIPTION: SQL migration script that creates a todo_item table with fields for id, title, and done status. This represents the database schema for the todo service that will be accessed by multiple services.

LANGUAGE: sql
CODE:
CREATE TABLE todo_item (
    id BIGSERIAL PRIMARY KEY,
    title TEXT NOT NULL,
    done BOOLEAN NOT NULL DEFAULT FALSE
);

----------------------------------------

TITLE: Directory Structure for Monorepo with Separate Frontend and Backend
DESCRIPTION: Recommended directory structure for a monorepo setup that separates frontend and backend code into distinct folders, allowing for separate dependency management while keeping the codebases in the same repository.

LANGUAGE: plaintext
CODE:
/my-app
├── backend
│   ├── encore.app
│   ├── package.json // Backend dependencies
│   └── ...
└── frontend
    ├── package.json // Frontend dependencies
    └── ...

----------------------------------------

TITLE: Implementing Auth0 Authenticator in Go
DESCRIPTION: Creates an Authenticator struct that handles communication with Auth0, including provider configuration, OAuth2 setup, and token verification.

LANGUAGE: go
CODE:
package auth

import (
	"context"
	"crypto/rand"
	"encoding/base64"
	"encore.dev/config"
	"errors"
	"github.com/coreos/go-oidc/v3/oidc"
	"golang.org/x/oauth2"
)

type Auth0Config struct {
	ClientID    config.String
	Domain      config.String
	CallbackURL config.String
	LogoutURL   config.String
}

var cfg = config.Load[*Auth0Config]()

var secrets struct {
	Auth0ClientSecret string
}

// Authenticator is used to authenticate our users.
type Authenticator struct {
	*oidc.Provider
	oauth2.Config
}

// New instantiates the *Authenticator.
func New() (*Authenticator, error) {
	provider, err := oidc.NewProvider(
		context.Background(),
		"https://"+cfg.Domain()+"/",
	)
	if err != nil {
		return nil, err
	}

	conf := oauth2.Config{
		ClientID:     cfg.ClientID(),
		ClientSecret: secrets.Auth0ClientSecret,
		RedirectURL:  cfg.CallbackURL(),
		Endpoint:     provider.Endpoint(),
		Scopes:       []string{oidc.ScopeOpenID, "profile", "email"},
	}

	return &Authenticator{
		Provider: provider,
		Config:   conf,
	}, nil
}

// VerifyIDToken verifies that an *oauth2.Token is a valid *oidc.IDToken.
func (a *Authenticator) VerifyIDToken(ctx context.Context, token *oauth2.Token) (*oidc.IDToken, error) {
	rawIDToken, ok := token.Extra("id_token").(string)
	if !ok {
		return nil, errors.New("no id_token field in oauth2 token")
	}

	oidcConfig := &oidc.Config{
		ClientID: a.ClientID,
	}

	return a.Verifier(oidcConfig).Verify(ctx, rawIDToken)
}

func generateRandomState() (string, error) {
	b := make([]byte, 32)
	_, err := rand.Read(b)
	if err != nil {
		return "", err
	}

	state := base64.StdEncoding.EncodeToString(b)

	return state, nil
}

----------------------------------------

TITLE: Connecting ent Client to Encore Database
DESCRIPTION: Complete implementation of a service struct that initializes an ent client connected to the Encore database.

LANGUAGE: go
CODE:
-- user/user.go --
package user

import (
    "encore.dev/storage/sqldb"
	"entgo.io/ent/dialect"
	entsql "entgo.io/ent/dialect/sql"
	
	"encore.app/user/ent"
)

var userDB = sqldb.NewDatabase("user", sqldb.DatabaseConfig{
	Migrations: "./migrations",
})

//encore:service
type Service struct{
    ent *ent.Client
}

func initService() (*Service, error) {
    driver := entsql.OpenDB(dialect.Postgres, userDB.Stdlib())
    entClient := ent.NewClient(ent.Driver(driver))
    return &Service{ent: entClient}, nil
}

----------------------------------------

TITLE: Running an Encore App Locally
DESCRIPTION: Command to start an Encore application in the local development environment, which provides automatic infrastructure setup and hot reloading.

LANGUAGE: shell
CODE:
$ cd your-app-name # replace with the app name you picked
$ encore run

----------------------------------------

TITLE: Creating Service-Wide Middleware in Service Package
DESCRIPTION: Defines a middleware function that targets all API endpoints within the service. The middleware is defined within a service package.

LANGUAGE: go
CODE:
//encore:middleware target=all
func AllInSvc(req middleware.Request, next middleware.Next) middleware.Response {
    return next(req)
}

----------------------------------------

TITLE: Checking Encore CLI Version
DESCRIPTION: Command to report the current version of the Encore CLI.

LANGUAGE: bash
CODE:
encore version

----------------------------------------

TITLE: Creating a PostgreSQL Database
DESCRIPTION: SQL command to create a new database in PostgreSQL on DigitalOcean.

LANGUAGE: sql
CODE:
CREATE DATABASE mydb;

----------------------------------------

TITLE: Testing Components with Mocked Encore Client
DESCRIPTION: Unit testing example showing how to mock Encore client methods for testing React components. It demonstrates mocking GET requests with predetermined data and spying on POST requests to verify they are called correctly.

LANGUAGE: typescript
CODE:
import { render, waitForElementToBeRemoved } from "@testing-library/react";
import App from "./App";
import { site } from "./client";
import { userEvent } from "@testing-library/user-event";

describe("App", () => {
  beforeEach(() => {
    // Return mocked data from the List (GET) endpoint
    jest
      .spyOn(site.ServiceClient.prototype, "List")
      .mockReturnValue(Promise.resolve({
        sites: [{
          id: 1,
          url: "test.dev"
        }]
      }));

    // Spy on the Add (POST) endpoint
    jest.spyOn(site.ServiceClient.prototype, "Add");
  });

  it("render sites", async () => {
    render(<App />);
    await waitForElementToBeRemoved(() => screen.queryByText("Loading..."));

    // Verify that the List endpoint has been called
    expect(site.ServiceClient.prototype.List).toBeCalledTimes(1);

    // Verify that the sites are rendered with our mocked data
    screen.getAllByText("test.dev");
  });

  it("add site", async () => {
    render(<App />);
    await waitForElementToBeRemoved(() => screen.queryByText("Loading..."));

    // Interact with the page and add 'another.com'
    await userEvent.click(screen.getByText("Add website"));
    await userEvent.type(
      screen.getByPlaceholderText("google.com"),
      "another.com",
    );
    await userEvent.click(screen.getByText("Save"));

    // Verify that the Add endpoint has been called with the correct parameters
    expect(site.ServiceClient.prototype.Add).toHaveBeenCalledWith({
      url: "another.com",
    });
  });
})

----------------------------------------

TITLE: Example CUE Configuration Files
DESCRIPTION: Example of generated and user-defined CUE configuration files showing how to set default values and conditionally override them based on environment.

LANGUAGE: cue
CODE:
-- mysvc/encore.gen.cue --
// Code generated by encore. DO NOT EDIT.
package mysvc

#Meta: {
	APIBaseURL: string
	Environment: {
		Name:  string
		Type:  "production" | "development" | "ephemeral" | "test"
		Cloud: "aws" | "gcp" | "encore" | "local"
	}
}

#Config: {
	ReadOnly: bool   // Put the system into read-only mode
    Example:  string
}
#Config

LANGUAGE: cue
CODE:
-- mysvc/myconfig.cue --
// Set example to "hello world"
Example: "hello world"

// By default we're not in read only mode
ReadOnly: bool | *false

// But on the old production environment, we're in read only mode
if #Meta.Environment.Name == "old-prod" {
    ReadOnly: true
}

----------------------------------------

TITLE: Encore Application Structure with Sub-Packages
DESCRIPTION: Illustrates the directory structure for an Encore application that uses sub-packages within services. It shows how to organize service code, sub-packages, migrations, and tests.

LANGUAGE: plaintext
CODE:
/my-app
├── encore.app                       // ... and other top-level project files
│
├── hello                            // hello service (a Go package)
│   ├── migrations                   // hello service db migrations (directory)
│   │   └── 1_create_table.up.sql    // hello service db migration
│   ├── foo                          // sub-package foo (directory)
│   │   └── foo.go                   // foo code (cannot define APIs)
│   ├── hello.go                     // hello service code
│   └── hello_test.go                // tests for hello service
│
└── world                            // world service (a Go package)
    └── world.go                     // world service code

----------------------------------------

TITLE: Generated Static Configuration for Encore Application
DESCRIPTION: A synthetic file containing JSON configuration for the Encore application with service mappings, CORS settings, and application metadata. This is used by the Encore runtime to understand the application structure.

LANGUAGE: go
CODE:
package synthetic

/*

This is a synthetic file describing the generated static config:

{
	"EncoreCompiler": "",
	"AppCommit": {
		"revision": "",
		"uncommitted": false
	},
	"CORSAllowHeaders": null,
	"CORSExposeHeaders": null,
	"PubsubTopics": {},
	"Testing": false,
	"TestServiceMap": {
		"code": "testing_path:code"
	},
	"TestAppRootPath": "testing_path:main",
	"PrettyPrintLogs": false,
	"BundledServices": [
		"code"
	],
	"EmbeddedEnvs": {}
}
*/

----------------------------------------

TITLE: Implementing GraphQL Mutation Resolvers
DESCRIPTION: Defines mutation resolvers that modify data in the book service. This implements the addBook mutation with error handling to provide appropriate responses for both success and failure cases.

LANGUAGE: typescript
CODE:
import { book } from "~encore/clients";
import { MutationResolvers } from "../__generated__/resolvers-types";
import { APIError } from "encore.dev/api";

// Use the generated `MutationResolvers` type to type check our mutations
const mutations: MutationResolvers = {
  addBook: async (_, { title, author }) => {
    try {
      const resp = await book.add({ title, author });
      return {
        book: resp.book,
        success: true,
        code: "ok",
        message: "New book added",
      };
    } catch (err) {
      const apiError = err as APIError;

      return {
        book: null,
        success: false,
        code: apiError.code,
        message: apiError.message,
      };
    }
  },
};

export default mutations;

----------------------------------------

TITLE: Implementing Book Service API Endpoints
DESCRIPTION: Implementation of the Book service with two API endpoints: one for listing books and another for adding new books. It includes a simple in-memory database and uses the generated GraphQL types for type safety.

LANGUAGE: typescript
CODE:
import { api, APIError } from "encore.dev/api";
import { Book } from "../graphql/__generated__/resolvers-types";

const db: Book[] = [
  {
    title: "To Kill a Mockingbird",
    author: "Harper Lee",
  },
  {
    title: "1984",
    author: "George Orwell",
  },
  {
    title: "The Great Gatsby",
    author: "F. Scott Fitzgerald",
  },
  {
    title: "Moby-Dick",
    author: "Herman Melville",
  },
  {
    title: "Pride and Prejudice",
    author: "Jane Austen",
  },
];

export const list = api(
  { expose: true, method: "GET", path: "/books" },
  async (): Promise<{ books: Book[] }> => {
    return { books: db };
  },
);

// Omit the "__typename" field from the request
type AddRequest = Omit<Required<Book>, "__typename">;

export const add = api(
  { expose: true, method: "POST", path: "/book" },
  async (book: AddRequest): Promise<{ book: Book }> => {
    if (db.some((b) => b.title === book.title)) {
      throw APIError.alreadyExists(
        `Book "${book.title}" is already in database`,
      );
    }
    db.push(book);
    return { book };
  },
);

----------------------------------------

TITLE: Starting Encore VPN Connection
DESCRIPTION: Sets up a secure VPN connection to private Encore environments.

LANGUAGE: shell
CODE:
$ encore vpn start

----------------------------------------

TITLE: Testing with Configuration Overrides
DESCRIPTION: Example of testing Encore applications with different configuration values using et.SetCfg helper. This allows testing specific behaviors based on different configurations at a per-test level.

LANGUAGE: cue
CODE:
-- config.cue --
// By default we want to send emails
SendEmails: bool | *true

// But in all tests we want to disable emails
if #Meta.Environment.Type == "test" {
    SendEmails: false
}

LANGUAGE: go
CODE:
-- signup.go --
import (
    "context"

    "encore.dev/config"
)

type Config struct {
    SendEmails config.Bool
}

var cfg = config.Load[Config]()

//encore:api public
func Signup(ctx context.Context, p *SignupParams) error {
    user := createUser(p)

    if cfg.SendEmails() {
        SendWelcomeEmail(user)
    }

    return nil
}

LANGUAGE: go
CODE:
-- signup_test.go --
import (
    "errors"
    "testing"

    "encore.dev/et"
)

func TestSignup(t *testing.T) {
    err := Signup(context.Background(), &SignupParams { ... })
    if err != nil {
        // We don't expect an error here
        t.Fatal(err)
    }

    if emailWasSent() {
        // We don't expect an email to be sent
        // as it's disabled for all tests
        t.Fatal("email was sent")
    }
}

func TestSignup_TestEmails(t *testing.T) {
    // For this test, we want to enable the welcome
    // emails so we can test that they are sent
    et.SetCfg(cfg.SendEmails, true)

    err := Signup(context.Background(), &SignupParams { ... })
    if err != nil {
        // We don't expect an error here
        t.Fatal(err)
    }

    // Check the email was sent
    if !emailWasSent() {
        t.Fatal("email was not sent")
    }
}

----------------------------------------

TITLE: Connecting to Encore Cloud Databases Using Shell Command
DESCRIPTION: Command for connecting to Encore Cloud-hosted databases. It defaults to read-only permissions, with flags available for different permission levels.

LANGUAGE: bash
CODE:
encore db shell

----------------------------------------

TITLE: Creating Migration Generation Script
DESCRIPTION: Bash script that uses Atlas and Encore's shadow database feature to generate migration files based on changes to the ent schema.

LANGUAGE: shell
CODE:
-- user/scripts/generate-migration --
#!/bin/bash
set -eu
DB_NAME=user
MIGRATION_NAME=${1:-}

# Reset the shadow database
encore db reset --shadow $DB_NAME

# ent executes Go code without initializing Encore when generating migrations,
# so configure the Encore runtime to be aware that this is expected.
export ENCORERUNTIME_NOPANIC=1

# Generate the migration
atlas migrate diff $MIGRATION_NAME --env local --dev-url "$(encore db conn-uri --shadow $DB_NAME)&search_path=public"

----------------------------------------

TITLE: Setting Firebase Secret for Development Environments
DESCRIPTION: Shell command to set the Firebase private key for development, local, and PR environments in Encore.

LANGUAGE: shell
CODE:
$ encore secret set --type dev,local,pr FirebasePrivateKey < /path/to/firebase-private-key.json
Successfully updated development secret FirebasePrivateKey

----------------------------------------

TITLE: Global Middleware with All Target in Encore
DESCRIPTION: Defines a global middleware in Encore that targets all APIs across all services. The middleware passes the request to the next handler without modification.

LANGUAGE: go
CODE:
//encore:middleware global target=all
func AllInSvc(req middleware.Request, next middleware.Next) middleware.Response {
    return next(req)
}

----------------------------------------

TITLE: Creating a SQL Database Schema for Todo Service in Encore
DESCRIPTION: SQL schema definition for a todo_item table in the todo service. The schema creates a table with ID, title, and done status columns that will be accessible by other services.

LANGUAGE: sql
CODE:
CREATE TABLE todo_item (
    id BIGSERIAL PRIMARY KEY,
    title TEXT NOT NULL,
    done BOOLEAN NOT NULL DEFAULT FALSE
);

----------------------------------------

TITLE: HTML Form for Multiple File Upload
DESCRIPTION: An HTML form that allows users to upload multiple files simultaneously. The form uses the multipart/form-data encoding type and includes the 'multiple' attribute on the file input to enable selecting multiple files.

LANGUAGE: html
CODE:
<form method="POST" enctype="multipart/form-data" action="/upload-multiple">
    <label for="filefield">Multiple files upload:</label><br>
    <input type="file" name="filefield" multiple>
    <input type="submit">
</form>

----------------------------------------

TITLE: Loading Configuration in Encore Services
DESCRIPTION: Basic implementation of configuration loading in Encore services using CUE files. Defines a configuration struct with Boolean and String types and loads it using config.Load.

LANGUAGE: go
CODE:
package mysvc

import "encore.dev/config"

type SomeConfigType struct {
    ReadOnly config.Bool
    Example  config.String
}

var cfg *SomeConfigType = config.Load[*SomeConfigType]()

----------------------------------------

TITLE: Implementing the GraphQL Encore Service
DESCRIPTION: Creates an Encore service that exposes GraphQL endpoints, configures the gqlgen server, and handles playground routing with production environment restrictions.

LANGUAGE: go
CODE:
// Service graphql exposes a GraphQL API.
package graphql

import (
    "net/http"

    "encore.app/graphql/generated"
    "encore.dev"
    "github.com/99designs/gqlgen/graphql/handler"
    "github.com/99designs/gqlgen/graphql/playground"
)

//go:generate go run github.com/99designs/gqlgen generate

//encore:service
type Service struct {
    srv        *handler.Server
    playground http.Handler
}

func initService() (*Service, error) {
    srv := handler.NewDefaultServer(generated.NewExecutableSchema(generated.Config{Resolvers: &Resolver{}}))
    pg := playground.Handler("GraphQL Playground", "/graphql")
    return &Service{srv: srv, playground: pg}, nil
}

//encore:api public raw path=/graphql
func (s *Service) Query(w http.ResponseWriter, req *http.Request) {
    s.srv.ServeHTTP(w, req)
}

//encore:api public raw path=/graphql/playground
func (s *Service) Playground(w http.ResponseWriter, req *http.Request) {
	// Disable playground in production
	if encore.Meta().Environment.Type == encore.EnvProduction {
        http.Error(w, "Playground disabled", http.StatusNotFound)
		return
    }

    s.playground.ServeHTTP(w, req)
}

----------------------------------------

TITLE: Creating a User Authentication Service in Encore
DESCRIPTION: Shell commands to create a new user service directory and authentication file. This sets up the structure for implementing authentication.

LANGUAGE: shell
CODE:
$ mkdir user
$ touch user/auth.go

----------------------------------------

TITLE: Adding Slack Signing Secret Management
DESCRIPTION: TypeScript code for importing and defining Encore's secret management for the Slack signing secret. This secret is used to verify webhook requests from Slack.

LANGUAGE: typescript
CODE:
import { secret } from "encore.dev/config";

const slackSigningSecret = secret("SlackSigningSecret");

----------------------------------------

TITLE: Testing the Monitor API with cURL
DESCRIPTION: Example of how to test the Ping API endpoint using cURL to check if a website is up.

LANGUAGE: shell
CODE:
curl http://localhost:4000/ping/google.com

----------------------------------------

TITLE: Example GraphQL GetBooks Query
DESCRIPTION: Example query for retrieving all books from the system. This GraphQL query returns a list of books with their author and title information.

LANGUAGE: graphql
CODE:
query GetBooks {
  books {
    author
    title
  }
}

----------------------------------------

TITLE: Getting Encore Database Connection URI
DESCRIPTION: Outputs a connection string for the specified database, with options to select different environments.

LANGUAGE: shell
CODE:
$ encore db conn-uri <database-name> [--env=<name>] [flags]

----------------------------------------

TITLE: Generating ent Schema in Encore Service
DESCRIPTION: Command to generate a new ent User schema in the user service directory.

LANGUAGE: shell
CODE:
$ go run entgo.io/ent/cmd/ent@latest new --target user/ent/schema User

----------------------------------------

TITLE: Creating an Encore App from Command Line
DESCRIPTION: Command to create a new Encore application and account if needed. This is a prerequisite before deploying.

LANGUAGE: shell
CODE:
$ encore app create

----------------------------------------

TITLE: Service Discovery Configuration
DESCRIPTION: Configuration for service discovery to access other services over the network. This example shows how to specify the base URL and authentication methods for a service named 'myservice'.

LANGUAGE: json
CODE:
{
  "service_discovery": {
    "myservice": {
      "base_url": "https://myservice.myencoreapp.com",
      "auth": [
        {
          "type": "key",
          "id": 1,
          "key": {
            "$env": "MY_SERVICE_API_KEY"
          }
        }
      ]
    }
  }
}

----------------------------------------

TITLE: Implementing a Monolithic Service with Multiple API Endpoints in Go
DESCRIPTION: A simple monolithic service example with two API endpoints (H1 and H2) in a single package. Both endpoints generate greeting messages based on the provided name parameter.

LANGUAGE: go
CODE:
package hello

import (
	"context"
)

//encore:api public path=/hello/:name
func H1(ctx context.Context, name string) (*Response, error) {
	msg := "Hello, " + name + "!"
	return &Response{Message: msg}, nil
}

//encore:api public path=/yo/:name
func H2(ctx context.Context, name string) (*Response, error) {
	msg := "Yo, " + name + "!"
	return &Response{Message: msg}, nil
}

type Response struct {
	Message string
}

----------------------------------------

TITLE: Implementing Structured Authentication Handler
DESCRIPTION: Advanced authentication handler that uses a structured parameter object to process multiple authentication methods (cookies, query parameters, and headers) in a single handler.

LANGUAGE: go
CODE:
type MyAuthParams struct {
    SessionCookie *http.Cookie `cookie:"session"`
    ClientID string `query:"client_id"`
    Authorization string `header:"Authorization"`
}

//encore:authhandler
func AuthHandler(ctx context.Context, p *MyAuthParams) (auth.UID, error) {
    // Process structured auth params
}

----------------------------------------

TITLE: Generated API Wrapper Function in encore.gen.go
DESCRIPTION: This snippet shows an automatically generated wrapper function in encore.gen.go that allows other services to call APIs defined as methods on a service struct using package-level functions.

LANGUAGE: go
CODE:
// Code generated by encore. DO NOT EDIT.

package email

import "context"

// These functions are automatically generated and maintained by Encore
// to simplify calling them from other services, as they were implemented as methods.
// They are automatically updated by Encore whenever your API endpoints change.

func Send(ctx context.Context, p *SendParams) error {
	// The implementation is elided here, and generated at compile-time by Encore.
	return nil
}

----------------------------------------

TITLE: Generated API Wrapper Function in encore.gen.go
DESCRIPTION: This snippet shows an automatically generated wrapper function in encore.gen.go that allows other services to call APIs defined as methods on a service struct using package-level functions.

LANGUAGE: go
CODE:
// Code generated by encore. DO NOT EDIT.

package email

import "context"

// These functions are automatically generated and maintained by Encore
// to simplify calling them from other services, as they were implemented as methods.
// They are automatically updated by Encore whenever your API endpoints change.

func Send(ctx context.Context, p *SendParams) error {
	// The implementation is elided here, and generated at compile-time by Encore.
	return nil
}

----------------------------------------

TITLE: Initializing Firebase SDK in Go
DESCRIPTION: Code for setting up the Firebase Authentication client using syncutil.Once for lazy initialization. Includes secret definition for Firebase credentials.

LANGUAGE: go
CODE:
var (
	fbAuth    *fbauth.Client
	setupOnce syncutil.Once
)

// setupFB ensures Firebase Auth is setup.
func setupFB() error {
    return setupOnce.Do(func() error {
        opt := option.WithCredentialsJSON([]byte(secrets.FirebasePrivateKey))
        app, err := firebase.NewApp(context.Background(), nil, opt)
        if err == nil {
            fbAuth, err = app.Auth(context.Background())
        }
        return err
    })
}

var secrets struct {
	// FirebasePrivateKey is the JSON credentials for calling Firebase.
	FirebasePrivateKey string
}

----------------------------------------

TITLE: Auth0 Provider Service for Backend Communication
DESCRIPTION: Service that handles authentication operations by communicating with the backend. It manages login, logout, and token validation while storing authentication state in cookies and session storage.

LANGUAGE: ts
CODE:
import Cookies from "js-cookie";
import getRequestClient from "./getRequestClient.ts";

type RedirectURL = string;

/**
 * Handles the backend communication for the authentication flow.
 */
export const Auth0Provider = {
  client: getRequestClient(),
  isAuthenticated: () => !!Cookies.get("auth-token"),

  async login(returnTo: RedirectURL): Promise<RedirectURL> {
    const response = await this.client.auth.Login();
    Cookies.set("state", response.state);
    sessionStorage.setItem(response.state, returnTo);
    return response.auth_code_url;
  },

  async logout(): Promise<RedirectURL> {
    const response = await this.client.auth.Logout();

    Cookies.remove("auth-token");
    Cookies.remove("state");

    return response.redirect_url;
  },

  async validate(state: string, authCode: string): Promise<RedirectURL> {
    if (state != Cookies.get("state")) throw new Error("Invalid state");

    const response = await this.client.auth.Callback({ code: authCode });
    Cookies.set("auth-token", response.token);
    const returnURL = sessionStorage.getItem(state) ?? "/";
    sessionStorage.removeItem(state);
    return returnURL;
  },
};

----------------------------------------

TITLE: Testing Encore.ts Apps with Direct Function Calls
DESCRIPTION: This snippet demonstrates how to test Encore.ts applications by calling API endpoints directly as functions. Tests can be run using the 'encore test' command, simplifying the testing process.

LANGUAGE: typescript
CODE:
import {describe, expect, test} from "vitest";
import {dynamicPathParamExample} from "../get-request-example";

// This test suite demonstrates how to test an Encore route.
// Run tests using the `encore test` command.
describe("Encore app", () => {
  test("should respond with a greeting message", async () => {
    // You can call the Encore.ts endpoint directly in your tests,
    // just like any other function.
    const resp = await dynamicPathParamExample({name: "world"});
    expect(resp.message).toBe("Hello world!");
  });
});


----------------------------------------

TITLE: Handling Authentication Errors
DESCRIPTION: Recommended pattern for returning authentication errors using Encore's error system. Uses the Unauthenticated error code with a message that helps users understand the issue.

LANGUAGE: go
CODE:
return "", &errs.Error{
    Code: errs.Unauthenticated,
    Message: "invalid token",
}

----------------------------------------

TITLE: Implementing Email Confirmation with SendGrid in Go
DESCRIPTION: This code enhances the Book endpoint to send a confirmation email using SendGrid when a booking is successfully created. It formats the booking time and sends an email to the user's provided email address with the booking details.

LANGUAGE: go
CODE:
//encore:api public method=POST path=/booking
func Book(ctx context.Context, p *BookParams) error {
	eb := errs.B()

	now := time.Now()
	if p.Start.Before(now) {
		return eb.Code(errs.InvalidArgument).Msg("start time must be in the future").Err()
	}

	tx, err := pgxdb.Begin(ctx)
	if err != nil {
		return eb.Cause(err).Code(errs.Unavailable).Msg("failed to start transaction").Err()
	}
	defer tx.Rollback(context.Background()) // committed explicitly on success

	// Get the bookings for this day.
	startOfDay := time.Date(p.Start.Year(), p.Start.Month(), p.Start.Day(), 0, 0, 0, 0, p.Start.Location())
	bookings, err := listBookingsBetween(ctx, startOfDay, startOfDay.AddDate(0, 0, 1))
	if err != nil {
		return eb.Cause(err).Code(errs.Unavailable).Msg("failed to list bookings").Err()
	}

	// Is this slot bookable?
	slot := BookableSlot{Start: p.Start, End: p.Start.Add(DefaultBookingDuration)}
	if len(filterBookableSlots([]BookableSlot{slot}, now, bookings)) == 0 {
		return eb.Code(errs.InvalidArgument).Msg("slot is unavailable").Err()
	}

	_, err = query.InsertBooking(ctx, db.InsertBookingParams{
		StartTime: pgtype.Timestamp{Time: p.Start, Valid: true},
		EndTime:   pgtype.Timestamp{Time: p.Start.Add(DefaultBookingDuration), Valid: true},
		Email:     p.Email,
	})
	if err != nil {
		return eb.Cause(err).Code(errs.Unavailable).Msg("failed to insert booking").Err()
	}

	if err := tx.Commit(ctx); err != nil {
		return eb.Cause(err).Code(errs.Unavailable).Msg("failed to commit transaction").Err()
	}

	// Send confirmation email using SendGrid
	formattedTime := pgtype.Timestamp{Time: p.Start, Valid: true}.Time.Format("2006-01-02 15:04")
	_, err = sendgrid.Send(ctx, &sendgrid.SendParams{
		From: sendgrid.Address{
			Name:  "<your name>",
			Email: "<your email>",
		},
		To: sendgrid.Address{
			Email: p.Email,
		},
		Subject: "Booking Confirmation",
		Text:    "Thank you for your booking!\nWe look forward to seeing you soon at " + formattedTime,
		Html:    "",
	})

	if err != nil {
		return err
	}

	return nil
}

----------------------------------------

TITLE: Listing Objects in an Object Storage Bucket in Encore
DESCRIPTION: Example of how to list objects within a storage bucket. This code iterates through bucket contents and handles any errors that may occur during the listing operation.

LANGUAGE: go
CODE:
for err, entry := range bucket.List(ctx, &objects.Query{}) {
    if err != nil {
        // Handle error
    }
    // Process entry
}

----------------------------------------

TITLE: Package Importing and Using myservice Database
DESCRIPTION: A supporting package that imports and uses the main myservice package. It demonstrates how to reference the named database instance from another package.

LANGUAGE: go
CODE:
package pkg

import (
    "context"
    "test/myservice"
)

func Foo() {
    _ = myservice.Moo.Baz()
}

----------------------------------------

TITLE: Adding SQL Queries for Availability Management
DESCRIPTION: SQL queries to retrieve all availability records and to update availability for a specific day of the week.

LANGUAGE: sql
CODE:
-- booking/db/query.sql --
-- name: GetAvailability :many
SELECT * FROM availability
ORDER BY weekday;

-- name: UpdateAvailability :exec
INSERT INTO availability (weekday, start_time, end_time)
VALUES (@weekday, @start_time, @end_time)
ON CONFLICT (weekday) DO UPDATE
SET start_time = @start_time, end_time = @end_time;

----------------------------------------

TITLE: Outputting Encore Environment Information
DESCRIPTION: Displays information about the current Encore environment.

LANGUAGE: shell
CODE:
$ encore daemon env

----------------------------------------

TITLE: Configuring cgo in encore.app JSON Configuration
DESCRIPTION: This snippet shows how to enable cgo support in an Encore application by modifying the encore.app configuration file. The 'build.cgo_enabled' property must be set to true to allow the application to use C bindings.

LANGUAGE: json
CODE:
{
  "id": "my-app-id",
  "build": {
    "cgo_enabled": true
  }
}

----------------------------------------

TITLE: Installing Txtar with Cargo
DESCRIPTION: Command to add the txtar package to your Rust project using Cargo.

LANGUAGE: sh
CODE:
cargo add txtar

----------------------------------------

TITLE: Configuring Google Cloud PubSub in Encore
DESCRIPTION: JSON configuration for Google Cloud PubSub in an Encore application. Includes topic and subscription configuration with push delivery settings. Defines project IDs, service accounts, and push endpoint paths.

LANGUAGE: json
CODE:
{
  "pubsub": [
    {
      "type": "gcp_pubsub",
      "project_id": "my-gcp-project",
      "topics": {
        "my-topic": {
          "name": "my-topic",
          "project_id": "my-gcp-project",
          "subscriptions": {
            "my-subscription": {
              "name": "my-subscription",
              "push_config": {
                "id": "my-push",
                "service_account": "service-account@my-gcp-project.iam.gserviceaccount.com"
              }
            }
          }
        }
      }
    }
  ]
}

----------------------------------------

TITLE: Making an API Request to the Hello World Endpoint
DESCRIPTION: Example of using curl to make an HTTP request to the hello world API endpoint running locally.

LANGUAGE: shell
CODE:
$ curl http://localhost:4000/hello/world
{"Message": "Hello, world!"}

----------------------------------------

TITLE: Creating a Database Schema Migration for Bookings in PostgreSQL
DESCRIPTION: SQL migration file that creates a booking table with fields for id, start_time, end_time, email, and created_at. This schema supports the core functionality of storing appointment information.

LANGUAGE: sql
CODE:
-- booking/db/migrations/1_create_tables.up.sql --
CREATE TABLE booking (
    id BIGSERIAL PRIMARY KEY,
    start_time TIMESTAMP NOT NULL,
    end_time TIMESTAMP NOT NULL,
    email TEXT NOT NULL,
    created_at TIMESTAMP NOT NULL DEFAULT NOW()
);

----------------------------------------

TITLE: Defining Server Configuration Structures in Go
DESCRIPTION: Defines two structures: ServerOptions for server configuration parameters (enabled status and port) and Config which contains server options for different protocols (HTTP, TCP, GRPC).

LANGUAGE: go
CODE:
// ServerOptions represent options for a server
type ServerOptions struct {
    Enabled bool // Is this option enabled?
    Port    uint32 // What port should we run on?
}

type Config struct {
    HTTP ServerOptions // The options for the HTTP server
    TCP  ServerOptions // The options for the TCP server
    GRPC ServerOptions // The options for the GRPC server
}

----------------------------------------

TITLE: Implementing Database Connection and Query in Express.js
DESCRIPTION: Sets up a PostgreSQL connection in Express.js using pg-promise with hardcoded credentials and implements a route to fetch a user by ID from the database. This demonstrates the manual connection management required in Express.

LANGUAGE: typescript
CODE:
import express, {Request, Response} from "express";
import pgPromise from "pg-promise";

const app: Express = express();

// Connect to the DB with the credentials from docker-compose.yml
const db = pgPromise()({
  host: "localhost",
  port: 5432,
  database: "database",
  user: "user1",
  password: "user1@123",
});

interface User {
  name: string;
  id: number;
}

// Get one User from DB
app.get("/user/:id", async (req: Request, res: Response) => {
  const user = await db.oneOrNone<User>(
    `
        SELECT *
        FROM users
        WHERE id = $1
    `,
    req.params.id,
  );

  res.json({user});
});

----------------------------------------

TITLE: Creating a New Encore App from Template
DESCRIPTION: Command to create a new Encore application using the meeting-notes example as a template. This sets up the initial project structure with all the necessary files.

LANGUAGE: shell
CODE:
$ encore app create my-app --example=meeting-notes

----------------------------------------

TITLE: Starting the Frontend Development Server
DESCRIPTION: Commands to navigate to the frontend directory, install dependencies, and start the development server for the React frontend.

LANGUAGE: shell
CODE:
$ cd you-app-name/frontend
$ npm install
$ npm run dev

----------------------------------------

TITLE: Configuring TypeScript Path Mappings for Encore
DESCRIPTION: Updates the tsconfig.json file to add path mappings for Encore generated files, allowing imports from the encore.gen directory using the ~encore/* alias.

LANGUAGE: json
CODE:
{
   "compilerOptions": {
      "paths": {
         "~encore/*": [
            "./encore.gen/*"
         ]
      }
   }
}

----------------------------------------

TITLE: Listing Encore Secrets
DESCRIPTION: Command to list configured secrets in Encore applications, optionally filtering by specific keys.

LANGUAGE: bash
CODE:
encore secret list [keys...]

----------------------------------------

TITLE: Using Encore PubSub Topic with AWS IoT Core
DESCRIPTION: Demonstrates how to integrate an Encore-managed PubSub topic with AWS IoT Core by retrieving the topic's AWS SNS ARN through the encore_pubsub_topic data source and using it in an AWS IoT topic rule.

LANGUAGE: terraform
CODE:
data "encore_pubsub_topic" "topic" {
  name = "my-topic"
  env  = "my-env"
}

resource "aws_iot_topic_rule" "rule" {
  name = "my-rule"
  sql  = "SELECT * FROM 'my-topic'"
  sns {
    message_format = "RAW"
    role_arn       = aws_iam_role.role.arn
    target_arn     = data.encore_pubsub_topic.topic.aws_sns.arn
  }
}

----------------------------------------

TITLE: Creating Availability Table Migration in SQL
DESCRIPTION: SQL migration script that creates an availability table to store working hours for each day of the week, with initial placeholder data.

LANGUAGE: sql
CODE:
-- booking/db/migrations/2_add_availability.up.sql --
CREATE TABLE availability (
    weekday SMALLINT NOT NULL PRIMARY KEY, -- Sunday=0, Monday=1, etc.
    start_time TIME NULL, -- null indicates not available
    end_time TIME NULL -- null indicates not available
);

-- Add some placeholder availability to get started
INSERT INTO availability (weekday, start_time, end_time) VALUES
    (0, '09:30', '17:00'),
    (1, '09:00', '17:00'),
    (2, '09:00', '18:00'),
    (3, '08:30', '18:00'),
    (4, '09:00', '17:00'),
    (5, '09:00', '17:00'),
    (6, '09:30', '16:30');

----------------------------------------

TITLE: Unarchiving Encore Secrets
DESCRIPTION: Unarchives a previously archived secret value with the specified ID.

LANGUAGE: shell
CODE:
$ encore secret unarchive <id>

----------------------------------------

TITLE: Testing an Encore Application
DESCRIPTION: Tests your application using the same flags as 'go test'.

LANGUAGE: shell
CODE:
$ encore test ./... [go test flags]

----------------------------------------

TITLE: Authentication Methods Configuration for Encore
DESCRIPTION: JSON configuration for setting up authentication methods in Encore applications to secure private endpoints when services communicate over the public internet.

LANGUAGE: json
CODE:
{
  "auth": [
    {
      "type": "key",
      "id": 1,
      "key": {
        "$env": "SERVICE_API_KEY"
      }
    }
  ]
}

----------------------------------------

TITLE: Overriding Auth Information in Context for Testing in Go
DESCRIPTION: This example demonstrates how to override authentication information in a context for testing purposes. It creates a new context with specified user ID and custom auth data that can be used for API testing.

LANGUAGE: go
CODE:
ctx := auth.WithContext(context.Background(), auth.UID("my-user-id"), &MyAuthData{Email: "hello@example.com"})
// ... Make an API call using `ctx` to override the auth information for that API call.

----------------------------------------

TITLE: Cloning an Encore Application
DESCRIPTION: Clones an existing Encore application to your local machine using its app ID.

LANGUAGE: shell
CODE:
$ encore app clone [app-id] [directory]

----------------------------------------

TITLE: Inserting Test Data on Startup Using go:embed in Go with Encore
DESCRIPTION: This code demonstrates how to embed SQL fixtures and conditionally execute them during application startup, but only in local development environments. It uses go:embed to include the SQL file and Encore's metadata API to check the current environment.

LANGUAGE: go
CODE:
import (
    _ "embed"
    "log"

    "encore.dev"
)

//go:embed fixtures.sql
var fixtures string

func init() {
    if encore.Meta().Environment.Cloud == encore.CloudLocal {
        if _, err := sqldb.Exec(context.Background(), fixtures); err != nil {
            log.Fatalln("unable to add fixtures:", err)
        }
    }
}

----------------------------------------

TITLE: Value-Based Validation Rules in Encore.ts
DESCRIPTION: This example demonstrates how to use value-based validation rules to add constraints like min/max values, string lengths, and format validation for emails and URLs.

LANGUAGE: typescript
CODE:
import { Min, Max, MinLen, MaxLen, IsEmail, IsURL } from "encore.dev/validate";

interface Schema {
  // Number between 3 and 1000 (inclusive)
  count: number & (Min<3> & Max<1000>);

  // String between 5 and 20 characters
  username: string & (MinLen<5> & MaxLen<20>);

  // Must be either a valid URL or email address
  contact: string & (IsURL | IsEmail);

  // Array of up to 10 email addresses
  recipients: Array<string & IsEmail> & MaxLen<10>;
}

----------------------------------------

TITLE: Defining Encore Service Configuration Structure
DESCRIPTION: This snippet defines a service package with a Config structure that includes a time.Time field, and loads it using Encore's config system.

LANGUAGE: go
CODE:
package svc

import (
	"context"
    "time"

	"encore.dev/config"
)

type Config struct {
    SomeTime time.Time
}

var _ = config.Load[*Config]()

----------------------------------------

TITLE: Live-Streaming Logs from Encore Environments
DESCRIPTION: Demonstrates the command-line syntax for streaming logs from any Encore environment directly to the terminal. This example shows how to stream logs from the production environment.

LANGUAGE: bash
CODE:
$ encore logs --env=prod

----------------------------------------

TITLE: Using Signed Upload URLs from Client with curl
DESCRIPTION: Shows how clients can use a signed upload URL to directly upload content to a bucket using a simple HTTP PUT request with curl, bypassing your API service.

LANGUAGE: bash
CODE:
curl -X PUT --data-binary @/home/me/dog-wizard.jpeg "https://storage.googleapis.com/profile-pictures/my-user-id/?x-goog-signature=b7a1<...>"

----------------------------------------

TITLE: Creating Discord Logo SVG in HTML
DESCRIPTION: SVG code for rendering the Discord logo within an HTML container. The SVG uses a path element with specific coordinates to draw the Discord icon in dark color (#111111).

LANGUAGE: SVG
CODE:
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 -28.5 256 256">
    <path fill="#111111"
        d="M216.856339,16.5966031 C200.285002,8.84328665 182.566144,3.2084988 164.041564,0 C161.766523,4.11318106 159.108624,9.64549908 157.276099,14.0464379 C137.583995,11.0849896 118.072967,11.0849896 98.7430163,14.0464379 C96.9108417,9.64549908 94.1925838,4.11318106 91.8971895,0 C73.3526068,3.2084988 55.6133949,8.86399117 39.0420583,16.6376612 C5.61752293,67.146514 -3.4433191,116.400813 1.08711069,164.955721 C23.2560196,181.510915 44.7403634,191.567697 65.8621325,198.148576 C71.0772151,190.971126 75.7283628,183.341335 79.7352139,175.300261 C72.104019,172.400575 64.7949724,168.822202 57.8887866,164.667963 C59.7209612,163.310589 61.5131304,161.891452 63.2445898,160.431257 C105.36741,180.133187 151.134928,180.133187 192.754523,160.431257 C194.506336,161.891452 196.298154,163.310589 198.110326,164.667963 C191.183787,168.842556 183.854737,172.420929 176.223542,175.320965 C180.230393,183.341335 184.861538,190.991831 190.096624,198.16893 C211.238746,191.588051 232.743023,181.531619 254.911949,164.955721 C260.227747,108.668201 245.831087,59.8662432 216.856339,16.5966031 Z M85.4738752,135.09489 C72.8290281,135.09489 62.4592217,123.290155 62.4592217,108.914901 C62.4592217,94.5396472 72.607595,82.7145587 85.4738752,82.7145587 C98.3405064,82.7145587 108.709962,94.5189427 108.488529,108.914901 C108.508531,123.290155 98.3405064,135.09489 85.4738752,135.09489 Z M170.525237,135.09489 C157.88039,135.09489 147.510584,123.290155 147.510584,108.914901 C147.510584,94.5396472 157.658606,82.7145587 170.525237,82.7145587 C183.391518,82.7145587 193.761324,94.5189427 193.539891,108.914901 C193.539891,123.290155 183.391518,135.09489 170.525237,135.09489 Z" />
</svg>

----------------------------------------

TITLE: Defining Basic API Endpoint in Foo Service
DESCRIPTION: Defines a simple API endpoint called Foo in the foo service package using the Encore framework annotation //encore:api.

LANGUAGE: go
CODE:
package foo

import "context"

//encore:api
func Foo(ctx context.Context) error { return nil }

----------------------------------------

TITLE: Initializing Encore in Existing Repository
DESCRIPTION: Command to initialize a new Encore application from an existing repository with the specified name.

LANGUAGE: bash
CODE:
encore app init [name]

----------------------------------------

TITLE: Implementing a Basic Authentication Handler in Encore
DESCRIPTION: Go code that implements a basic authentication handler for the Encore application. This handler validates requests with an Authorization header and returns user information for authenticated requests.

LANGUAGE: go
CODE:
-- user/auth.go --
// Service user authenticates users.
package user

import (
	"context"
	"encore.dev/beta/auth"
	"encore.dev/beta/errs"
)

type Data struct {
	Email string
}

type AuthParams struct {
	Authorization string `header:"Authorization"`
}

//encore:authhandler
func AuthHandler(ctx context.Context, p *AuthParams) (auth.UID, *Data, error) {
	if p.Authorization != "" {
		return "test", &Data{}, nil
	}
	return "", nil, errs.B().Code(errs.Unauthenticated).Msg("no auth header").Err()
}

----------------------------------------

TITLE: Logging into Encore
DESCRIPTION: Authenticates the user with their Encore account credentials.

LANGUAGE: shell
CODE:
$ encore auth login

----------------------------------------

TITLE: Running Encore Docker Images with Custom Port Configuration
DESCRIPTION: Command to run an Encore Docker image with a custom port configuration. The example shows how to set the PORT environment variable to override the default port 8080.

LANGUAGE: bash
CODE:
docker run -e PORT=8081 -p 8081:8081 MY-IMAGE:TAG

----------------------------------------

TITLE: Installing Encore CLI across different operating systems
DESCRIPTION: Commands for installing the Encore CLI on macOS, Linux, and Windows operating systems, which is needed to run the local development environment.

LANGUAGE: bash
CODE:
npm i encore.dev

----------------------------------------

TITLE: GCP Cloud Monitoring Configuration for Encore
DESCRIPTION: JSON configuration for setting up GCP Cloud Monitoring metrics export in Encore applications, including project ID, resource type, and metric names.

LANGUAGE: json
CODE:
{
  "metrics": {
    "type": "gcp_cloud_monitoring",
    "collection_interval": 60,
    "project_id": "my-gcp-project",
    "monitored_resource_type": "gce_instance",
    "monitored_resource_labels": {
      "instance_id": "1234567890",
      "zone": "us-central1-a"
    },
    "metric_names": {
      "cpu_usage": "compute.googleapis.com/instance/cpu/usage_time"
    }
  }
}

----------------------------------------

TITLE: Deploying to Encore Cloud with Git
DESCRIPTION: Git commands to commit and push changes to Encore Cloud for automated deployment. Encore Cloud handles building, testing, and provisioning the necessary infrastructure.

LANGUAGE: shell
CODE:
$ git add -A .
$ git commit -m 'Initial commit'
$ git push encore

----------------------------------------

TITLE: Defining Encore Metrics in Go
DESCRIPTION: Defines two metrics types in an Encore application: a simple counter and a counter with labels. The metrics package from Encore is used to register these counters for monitoring purposes.

LANGUAGE: go
CODE:
package svc

import (
	"context"

	"encore.dev/metrics"
)

var Counter = metrics.NewCounter[uint64]("counter", metrics.CounterConfig{})

type Labels struct {
	Label string // Label doc string.
}

var CounterWithLabels = metrics.NewCounterGroup[Labels, uint64]("counter_with_labels", metrics.CounterConfig{})

//encore:api public
func Foo(context.Context) error {
	return nil
}

----------------------------------------

TITLE: Building Docker Image with Infrastructure Configuration
DESCRIPTION: Command to build a Docker image with infrastructure configuration for an Encore app. The --config flag specifies the path to the infrastructure configuration JSON file.

LANGUAGE: bash
CODE:
encore build docker --config path/to/infra-config.json MY-IMAGE:TAG

----------------------------------------

TITLE: Creating Signed Download URLs in Encore.ts
DESCRIPTION: Demonstrates how to create signed URLs for direct client downloads from a bucket. These URLs allow downloading private files without authentication for a limited time.

LANGUAGE: typescript
CODE:
const url = await documents.signedDownloadUrl("letter-1234", {ttl: 7200})
// Pass url to client

----------------------------------------

TITLE: Creating Incidents Table Schema in PostgreSQL
DESCRIPTION: SQL migration that creates the 'incidents' table structure in PostgreSQL. The schema includes fields for tracking incident IDs, assigned users, incident details, creation time, and acknowledgment status.

LANGUAGE: sql
CODE:
CREATE TABLE incidents
(
    id               BIGSERIAL PRIMARY KEY,
    assigned_user_id INTEGER,
    body             TEXT      NOT NULL,
    created_at       TIMESTAMP NOT NULL DEFAULT NOW(),
    acknowledged_at  TIMESTAMP
);

----------------------------------------

TITLE: Adding Client Generation Scripts to package.json
DESCRIPTION: Package.json configuration that includes scripts to generate Encore clients for different environments. This makes it easy to regenerate the client when the API changes.

LANGUAGE: json
CODE:
{
...
"scripts": {
    ...
    "generate-client:staging": "encore gen client <ENCORE-APP-ID> --output=./src/client.ts --env=staging",
    "generate-client:local": "encore gen client <ENCORE-APP-ID> --output=./src/client.ts --env=local"
  }
}

----------------------------------------

TITLE: Creating Service Directories for Encore Application
DESCRIPTION: Shell commands to create the site service directory structure in an Encore application.

LANGUAGE: shell
CODE:
$ mkdir site # Create a new directory in the application root
$ touch site/encore.service.ts

----------------------------------------

TITLE: Creating Encore Service with Unknown Database Reference in Go
DESCRIPTION: This code demonstrates an Encore service that attempts to reference a non-existent database named 'unknown-db' using sqldb.Named() and defines a simple API endpoint function. This will cause an E9999 error since the referenced database hasn't been created with sqldb.NewDatabase.

LANGUAGE: go
CODE:
package svc

import (
    "context"

    "encore.dev/storage/sqldb"
)

var Moo = sqldb.Named("unknown-db")

//encore:api public
func Foo(ctx context.Context) error {
    return nil
}

----------------------------------------

TITLE: Configuring sqlc for PostgreSQL Code Generation
DESCRIPTION: YAML configuration for sqlc that specifies the database engine, query file location, schema migration directory, and Go code generation settings. This enables sqlc to generate type-safe database access code.

LANGUAGE: yaml
CODE:
version: "2"
sql:
  - engine: "postgresql"
    queries: "db/query.sql"
    schema: "./db/migrations"
    gen:
      go:
        package: "db"
        out: "db"
        sql_package: "pgx/v5"

----------------------------------------

TITLE: Initializing an Encore Application from Existing Repository
DESCRIPTION: Creates a new Encore application from an existing repository.

LANGUAGE: shell
CODE:
$ encore app init [name]

----------------------------------------

TITLE: Implementing Fallback Routes for API Migration
DESCRIPTION: This example demonstrates how to define fallback routes in Encore using path=/!fallback. This pattern is useful when migrating existing backends to Encore, allowing gradual migration while maintaining compatibility.

LANGUAGE: go
CODE:
//encore:service
type Service struct {
	oldRouter *gin.Engine // existing HTTP router
}

// Route all requests to the existing HTTP router if no other endpoint matches.
//encore:api public raw path=/!fallback
func (s *Service) Fallback(w http.ResponseWriter, req *http.Request) {
    s.oldRouter.ServeHTTP(w, req)
}

----------------------------------------

TITLE: Configuring Slack App Manifest in YAML
DESCRIPTION: YAML manifest for creating a Slack app with a /cowsay slash command. The manifest defines display information, features, bot user settings, and required OAuth scopes for the bot to function properly.

LANGUAGE: yaml
CODE:
_metadata:
  major_version: 1
display_information:
  name: Encore Bot
  description: Cowsay for the cloud age.
features:
  slash_commands:
    - command: /cowsay
      # Replace $APP_ID below
      url: https://staging-$APP_ID.encr.app/cowsay
      description: Say things with a flair!
      usage_hint: your message here
      should_escape: false
  bot_user:
    display_name: encore-bot
    always_online: true
oauth_config:
  scopes:
    bot:
      - commands
      - chat:write
      - chat:write.public
settings:
  org_deploy_enabled: false
  socket_mode_enabled: false
  token_rotation_enabled: false

----------------------------------------

TITLE: Defining an Encore.ts Service
DESCRIPTION: Creates a service definition file using the Service class from Encore.ts. This file marks a directory as an Encore service and provides a service name.

LANGUAGE: typescript
CODE:
import { Service } from "encore.dev/service";
export default new Service("my-service");

----------------------------------------

TITLE: Implementing Booking Management Endpoints in Go
DESCRIPTION: This code adds two endpoints to list all bookings and delete a booking by ID. The ListBookings endpoint retrieves all bookings from the database and formats them for the frontend, while DeleteBooking removes a specific booking from the system.

LANGUAGE: go
CODE:
-- booking/booking.go --
type ListBookingsResponse struct {
	Booking []*Booking `json:"bookings"`
}

//encore:api auth method=GET path=/booking
func ListBookings(ctx context.Context) (*ListBookingsResponse, error) {
	rows, err := query.ListBookings(ctx)
	if err != nil {
		return nil, err
	}

	var bookings []*Booking
	for _, row := range rows {
		bookings = append(bookings, &Booking{
			ID:    row.ID,
			Start: row.StartTime.Time,
			End:   row.EndTime.Time,
			Email: row.Email,
		})
	}
	return &ListBookingsResponse{Booking: bookings}, nil
}

//encore:api auth method=DELETE path=/booking/:id
func DeleteBooking(ctx context.Context, id int64) error {
	return query.DeleteBooking(ctx, id)
}

----------------------------------------

TITLE: Example Telemetry Data Format in JSON
DESCRIPTION: Shows the structure of telemetry data sent by Encore, including the event type, an anonymous identifier, and event properties such as language and template used.

LANGUAGE: json
CODE:
{
    "event": "app.create",
    "anonymousId": "a-uuid-unique-for-the-installation",
    "properties": {
        "error": false,
        "lang": "go",
        "template": "graphql"
    }
}

----------------------------------------

TITLE: Building Docker Image with Specific Services in Encore
DESCRIPTION: This command builds a Docker image for an Encore application with specific services and gateways. The `--services` flag specifies which services to include, and the `--gateways` flag specifies which gateways to include.

LANGUAGE: bash
CODE:
encore build docker --services=service1,service2 --gateways=api-gateway MY-IMAGE:TAG

----------------------------------------

TITLE: Configuring Environment-Specific Temporal Server Addresses using CUE
DESCRIPTION: Defines a CUE configuration file that provides different Temporal server addresses based on the environment. Uses conditional logic to select the appropriate server address for local versus cloud environments.

LANGUAGE: go
CODE:
package greeting

TemporalServer: [
	// These act as individual case statements
    if #Meta.Environment.Cloud == "local" { "localhost:7233" },

    // TODO: configure this to match your own cluster address
    "my.cluster.address:7233",
][0] // Return the first value which matches the condition

----------------------------------------

TITLE: Defining Subscription Handler in Separate Package in Go
DESCRIPTION: This snippet shows a PubSub subscription handler function defined in a separate package. This causes an error in Encore since subscription handlers must be defined in the same service as where pubsub.NewSubscription is called.

LANGUAGE: go
CODE:
package shared

func Subscriber(ctx context.Context, msg *shared.MessageType) error {
    return nil
}

----------------------------------------

TITLE: Customizing 404 Response for Static Files in Encore.ts
DESCRIPTION: Configuration for customizing the 404 Not Found response when serving static files. This example specifies a custom not_found.html file to be served instead of the default 404 response.

LANGUAGE: typescript
CODE:
import { api } from "encore.dev/api";

export const assets = api.static(
  { expose: true, path: "/!path", dir: "./assets", notFound: "./not_found.html" },
);

----------------------------------------

TITLE: Setting Availability with JSON Request Example
DESCRIPTION: JSON example for setting availability for each day of the week through the SetAvailability API endpoint.

LANGUAGE: json
CODE:
{
    "Availability": [{
        "start": "09:30",
        "end": "17:00"
    },{
        "start": "09:00",
        "end": "17:00"
    },{
        "start": "09:00",
        "end": "18:00"
    },{
        "start": "08:30",
        "end": "18:00"
    },{
        "start": "09:00",
        "end": "17:00"
    },{
        "start": "09:00",
        "end": "17:00"
    },{
        "start": "09:30",
        "end": "16:30"
    }]
}

----------------------------------------

TITLE: Service Implementation with Database Integration
DESCRIPTION: Main service implementation that defines a named SQL database and exposes a public API endpoint that uses it. The service imports functionality from a supporting package.

LANGUAGE: go
CODE:
package svc

import (
    "context"
    "test/pkg"

    "encore.dev/storage/sqldb"
)

var Moo = sqldb.Named("svc")

//encore:api public
func Foo(ctx context.Context) error {
    pkg.Foo(Moo)
    return nil
}

----------------------------------------

TITLE: Creating a Bucket Reference with Specific Permissions
DESCRIPTION: Demonstrates how to create a reference to a bucket with specific permissions. This example creates a reference with upload-only permissions, limiting operations that can be performed with this reference.

LANGUAGE: typescript
CODE:
import { Uploader } from "encore.dev/storage/objects";
const ref = profilePictures.ref<Uploader>();

----------------------------------------

TITLE: Validating Arrays of Objects in Encore.ts
DESCRIPTION: This example shows how to validate arrays of objects with specific field requirements in request schemas.

LANGUAGE: typescript
CODE:
interface Schema {
  users:  { name: string; age: number }[];
}

----------------------------------------

TITLE: Git Commands for Deploying to Encore Cloud
DESCRIPTION: Shell commands for committing changes to the project repository and deploying to Encore's free development cloud. The process involves adding all files, committing with a message, and pushing to the Encore remote.

LANGUAGE: shell
CODE:
$ git add -A .
$ git commit -m 'Initial commit'
$ git push encore

----------------------------------------

TITLE: Installing the sqlc Library for Database Integration
DESCRIPTION: Shell command to install the sqlc library, which generates type-safe Go code from SQL queries. This tool bridges the gap between SQL and Go code.

LANGUAGE: shell
CODE:
$ go install github.com/sqlc-dev/sqlc/cmd/sqlc@latest

----------------------------------------

TITLE: Linking an Encore Application with the Server
DESCRIPTION: Links a local Encore application with the server using the app ID.

LANGUAGE: shell
CODE:
$ encore app link [app-id]

----------------------------------------

TITLE: Creating an Encore application with a template
DESCRIPTION: Command to create a new Encore application named 'uptime' using a starting-point template from GitHub that provides a ready-to-use frontend.

LANGUAGE: shell
CODE:
$ encore app create uptime --example=github.com/encoredev/example-app-uptime/tree/starting-point-ts

----------------------------------------

TITLE: Defining Rollout Object Structure in TypeScript
DESCRIPTION: Defines the Rollout object and related types that represent the state of a rollout in Encore Cloud. A rollout is a coordinated process for deploying versions of an Encore application, consisting of build, infrastructure provisioning, and deployment phases.

LANGUAGE: typescript
CODE:
// The representation of a rollout.
type Rollout = {
  // Unique id of the rollout.
  id: string;

  // The current status of the rollout.
  status: "pending" | "queued" | "running" | "completed";

  // What the conclusion was of the rollout (when status is "completed").
  // If the status is not "completed" the conclusion is "pending".
  conclusion: "pending" | "canceled" | "failure" | "success";

  // When the rollout was queued, started, and completed.
  queued_at: Date | null;
  started_at: Date | null;
  completed_at: Date | null;

  // Information about the various rollout phases.
  // See type definitions below.
  build: RolloutPhase<BuildStatus, BuildConclusion>;
  infra: RolloutPhase<InfraStatus, InfraConclusion>;
  deploy: RolloutPhase<DeployStatus, DeployConclusion>;
}

// Common structure of the various rollout phases.
type RolloutPhase<Status, Conclusion> = {
  // Unique id of the phase.
  id: string;

  // The current status of the rollout phase.
  status: Status;

  // What the conclusion was of the phase.
  conclusion: Conclusion;

  // When the phase was queued, started, and completed.
  queued_at: Date | null;
  started_at: Date | null;
  completed_at: Date | null;
}

// The current status and conclusion of a build.
// If the status is not "completed" the conclusion is "unknown".
type BuildStatus = "queued" | "running" | "completed";
type BuildConclusion = "unknown" | "canceled" | "failure" | "success";

// The current status and conclusion of an infra change.
// The "proposed" status means the change is awaiting human approval.
// The "rejected" conclusion means a human rejected the proposed infra change.
type InfraStatus = "pending" | "proposed" | "queued" | "running" | "completed";
type InfraConclusion = "unknown" | "canceled" | "failure" | "rejected" | "success";

// The current status and conclusion of a deploy.
// If the status is not "completed" the conclusion is "unknown".
type DeployStatus = "queued" | "running" | "completed";
type DeployConclusion = "unknown" | "canceled" | "failure" | "success";

----------------------------------------

TITLE: Creating Pub/Sub Topics in Encore.ts
DESCRIPTION: Shows how to create a Pub/Sub topic for asynchronous messaging between services. Topics must be package-level variables and cannot be created inside functions.

LANGUAGE: TypeScript
CODE:
import { Topic } from "encore.dev/pubsub"

export interface SignupEvent {
    userID: string;
}

export const signups = new Topic<SignupEvent>("signups", {
    deliveryGuarantee: "at-least-once",
});

----------------------------------------

TITLE: Computing Webhook Signature in Go
DESCRIPTION: Code snippet showing how to compute the expected signature for webhook verification using HMAC-SHA256 in Go. This is used to manually verify the authenticity of webhook requests.

LANGUAGE: go
CODE:
h := hmac.New(sha256.New, []byte(webhookSecret))
h.Write([]byte(payloadToSign))
digest := h.Sum(nil)
expectedSignature := base64.RawURLEncoding.EncodeToString(digest)

----------------------------------------

TITLE: Mocking an Entire Service in Encore Tests
DESCRIPTION: Demonstrates how to mock an entire service using et.MockService. This approach allows injecting a different implementation of a service for testing purposes.

LANGUAGE: go
CODE:
package shoppingcart

import (
    "context"
    "testing"
    
    "encore.dev/et" // Encore's test support package
    
    "your_app/products"
)

func Test_Something(t *testing.T) {
    t.Parallel() // Run this test in parallel with other tests without the mock implementation interfering
    
    // Create a instance of the products service which will only impact this test and any sub-tests
    et.MockService("products", &products.Service{
		SomeField: "a testing value",
	})
    
    // ... the rest of your test code here ...
}

----------------------------------------

TITLE: Updated Config Loading with Generated Unmarshaler in Go
DESCRIPTION: Enhanced version of the config.Load call that includes a service name and references the generated unmarshaler function. This demonstrates how Encore links the configuration system with the custom unmarshalers.

LANGUAGE: go
CODE:
var _ = config.Load[*Config]("svc", encoreInternalConfigUnmarshaler_ptr_svc_Config/*line :21:30*/)

----------------------------------------

TITLE: StreamIn API Type Signatures
DESCRIPTION: Different type signature options for the StreamIn API function, showing variations with and without handshake types and response types.

LANGUAGE: typescript
CODE:
api.streamIn<Handshake, Incoming, Outgoing>(
  {...}, async (handshake, stream): Promise<Outgoing> => {...})

LANGUAGE: typescript
CODE:
api.streamIn<Handshake, Incoming>(
  {...}, async (handshake, stream) => {...})

LANGUAGE: typescript
CODE:
api.streamIn<Incoming, Outgoing>(
  {...}, async (stream): Promise<Outgoing> => {...})

LANGUAGE: typescript
CODE:
api.streamIn<Incoming>(
  {...}, async (stream) => {...})

----------------------------------------

TITLE: Setting Secret Values Using Encore CLI
DESCRIPTION: Shows the CLI command to set secret values for Encore applications. This example demonstrates setting a secret for specific environment types using the Encore CLI.

LANGUAGE: shell
CODE:
$ encore secret set --type <types...> <secret-name>

----------------------------------------

TITLE: Metric Schema Definition for Encore
DESCRIPTION: Defines the schema for metrics to be used with Encore. Specifies a simple counter metric and a counter with labels metric, including their types and documentation.

LANGUAGE: text
CODE:
output 'metric counter UINT64 COUNTER []'
output 'metric counter_with_labels UINT64 COUNTER [label STRING Label doc string.\n]'

----------------------------------------

TITLE: Encore Internal API Registration and Handlers
DESCRIPTION: Generated internal code that registers the API endpoint with Encore's runtime. It defines request/response types, serialization, HTTP handling, and routing for the 'Foo' endpoint.

LANGUAGE: go
CODE:
package basic

import (
	"context"
	__api "encore.dev/appruntime/apisdk/api"
	jsoniter "github.com/json-iterator/go"
	"net/http"
	"net/url"
)

func init() {
	__api.RegisterEndpoint(EncoreInternal_api_APIDesc_Foo, Foo)
}

type EncoreInternal_FooReq struct{}

type EncoreInternal_FooResp = __api.Void

var EncoreInternal_api_APIDesc_Foo = &__api.Desc[*EncoreInternal_FooReq, EncoreInternal_FooResp]{
	Access: __api.Public,
	AppHandler: func(ctx context.Context, reqData *EncoreInternal_FooReq) (EncoreInternal_FooResp, error) {
		err := Foo(ctx)
		if err != nil {
			return __api.Void{}, err
		}
		return __api.Void{}, nil
	},
	CloneReq: func(r *EncoreInternal_FooReq) (*EncoreInternal_FooReq, error) {
		var clone *EncoreInternal_FooReq
		bytes, err := jsoniter.ConfigDefault.Marshal(r)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return clone, err
	},
	CloneResp: func(r EncoreInternal_FooResp) (EncoreInternal_FooResp, error) {
		var clone EncoreInternal_FooResp
		bytes, err := jsoniter.ConfigDefault.Marshal(r)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return clone, err
	},
	DecodeExternalResp: func(httpResp *http.Response, json jsoniter.API) (resp EncoreInternal_FooResp, err error) {
		return __api.Void{}, nil
	},
	DecodeReq: func(httpReq *http.Request, ps __api.UnnamedParams, json jsoniter.API) (reqData *EncoreInternal_FooReq, pathParams __api.UnnamedParams, err error) {
		reqData = new(EncoreInternal_FooReq)
		return reqData, nil, nil
	},
	DefLoc: uint32(0x0),
	EncodeExternalReq: func(reqData *EncoreInternal_FooReq, stream *jsoniter.Stream) (httpHeader http.Header, queryString url.Values, err error) {
		return nil, nil, nil
	},
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, resp EncoreInternal_FooResp) (err error) {
		return nil
	},
	Endpoint:            "Foo",
	Fallback:            false,
	GlobalMiddlewareIDs: []string{},
	Methods:             []string{"GET", "POST"},
	Path:                "/basic.Foo",
	PathParamNames:      nil,
	Raw:                 false,
	RawHandler:          nil,
	RawPath:             "/basic.Foo",
	ReqPath: func(reqData *EncoreInternal_FooReq) (string, __api.UnnamedParams, error) {
		return "/basic.Foo", nil, nil
	},
	ReqUserPayload: func(reqData *EncoreInternal_FooReq) any {
		return nil
	},
	Service:           "basic",
	ServiceMiddleware: []*__api.Middleware{},
	SvcNum:            1,
	Tags:              nil,
}

----------------------------------------

TITLE: Running GraphQL Code Generation
DESCRIPTION: Shell command to execute the code generation script defined in package.json, which generates TypeScript types based on the GraphQL schema.

LANGUAGE: shell
CODE:
$ npm run generate

----------------------------------------

TITLE: Defining Raw and Standard API Endpoints in Encore
DESCRIPTION: This code defines two Encore API endpoints - a raw API that uses http.ResponseWriter and a standard API that incorrectly attempts to call the raw API directly, which is not supported in Encore.

LANGUAGE: go
CODE:
package svc

import (
    "context"
    "net/http"
)

//encore:api public raw
func API(w http.ResponseWriter, req *http.Request) { }

//encore:api public
func NonRaw(ctx context.Context) error {
    API(nil, nil)
    return nil
}

----------------------------------------

TITLE: Running the Encore Service Locally
DESCRIPTION: Command to run the Encore application locally for testing the monitor service.

LANGUAGE: shell
CODE:
$ encore run

----------------------------------------

TITLE: Setting Secret Values in Encore
DESCRIPTION: Sets a secret value for specified environment types, accepting input directly or from a file.

LANGUAGE: shell
CODE:
$ encore secret set --type <types> <secret-name>

----------------------------------------

TITLE: Listing Encore Secrets
DESCRIPTION: Lists all secrets or specific keys if provided as arguments.

LANGUAGE: shell
CODE:
$ encore secret list [keys...]

----------------------------------------

TITLE: Example Telemetry Data Structure in JSON
DESCRIPTION: An example of the telemetry data that Encore sends, showing the structure with an event type, anonymousId, and associated properties. This demonstrates what kind of information is collected during app creation events.

LANGUAGE: json
CODE:
{
    "event": "app.create",
    "anonymousId": "a-uuid-unique-for-the-installation",
    "properties": {
        "error": false,
        "lang": "go",
        "template": "graphql"
    }
}

----------------------------------------

TITLE: Defining PubSub Topic Attributes in TypeScript
DESCRIPTION: Demonstrates how to define a PubSub topic with message attributes for filtering or ordering. This example shows how to create a SignupEvent interface with a userID and source attribute.

LANGUAGE: typescript
CODE:
import { Topic, Attribute } from "encore.dev/pubsub";

export interface SignupEvent {
    userID: string;
    source: Attribute<string>;
}

----------------------------------------

TITLE: Creating Signed Upload URLs with Encore in Go
DESCRIPTION: Creates a time-limited signed URL for direct file uploads to a cloud storage bucket. The example shows how to generate a URL for a specific user ID with a 2-hour expiration time.

LANGUAGE: go
CODE:
url, err := ProfilePictures.SignedUploadURL(ctx, "my-user-id", objects.WithTTL(time.Duration(7200)*time.Second))
// Pass url to client

----------------------------------------

TITLE: Setting Slack webhook URL as an Encore secret
DESCRIPTION: Shell command to set the Slack webhook URL as a secret in Encore for different environments.

LANGUAGE: shell
CODE:
$ encore secret set --type dev,local,pr SlackWebhookURL
Enter secret value: *****
Successfully updated development secret SlackWebhookURL.

----------------------------------------

TITLE: Setting up Cache Cluster and Keyspace in Encore
DESCRIPTION: Creates a cache cluster and configures a string keyspace with a specific key pattern and default expiry time. The cache is designed to store string values with keys following the 'foo/:key' pattern and items automatically expire after 10 seconds.

LANGUAGE: go
CODE:
package svc

import (
    "context"

    "encore.dev/storage/cache"
)

var cluster = cache.NewCluster("cluster", cache.ClusterConfig{})

var keyspace = cache.NewStringKeyspace[string](cluster, cache.KeyspaceConfig{
    KeyPattern: "foo/:key",
    DefaultExpiry: cache.ExpireIn(10 * time.Second),
})

//encore:api public
func Foo(context.Context) error {
    return nil
}

----------------------------------------

TITLE: Integrating Encore Client with TanStack Query for State Management
DESCRIPTION: Implementation of TanStack Query with an Encore client to handle caching, refetching, and managing stale data in a React application.

LANGUAGE: typescript
CODE:
import {
  useQuery,
  useMutation,
  useQueryClient,
  QueryClient,
  QueryClientProvider,
} from '@tanstack/react-query'
import Client, { todo } from '../encore-client'

// Create a Encore client
const encoreClient = new Client(window.location.origin);

// Create a react-query client
const queryClient = new QueryClient()

function App() {
  return (
    // Provide the client to your App
    <QueryClientProvider client={queryClient}>
      <Todos />
    </QueryClientProvider>
  )
}

function Todos() {
  // Access the client
  const queryClient = useQueryClient()

  // Queries
  const query = useQuery({
    queryKey: ['todos'],
    queryFn: () => encoreClient.todo.List()
  })

  // Mutations
  const mutation = useMutation({
    mutationFn: (params: todo.AddParams) => encoreClient.todo.Add(params),
    onSuccess: () => {
      // Invalidate and refetch
      queryClient.invalidateQueries({ queryKey: ['todos'] })
    },
  })

  return (
    <div>
      <ul>
        {query.data?.map((todo) => (
          <li key={todo.id}>{todo.title}</li>
        ))}
      </ul>

      <button
        onClick={() => {
          mutation.mutate({
            id: Date.now(),
            title: 'Do Laundry',
          })
        }}
      >
        Add Todo
      </button>
    </div>
  )
}

render(<App />, document.getElementById('root'))

----------------------------------------

TITLE: Cross-Service API Call in Encore (svcb)
DESCRIPTION: This snippet shows how to call an API endpoint from another service within an Encore application. It imports the svca package and calls its Foo endpoint from the Baz function.

LANGUAGE: go
CODE:
package svcb

import ("context"; "example.com/svca")

//encore:api public
func Baz(ctx context.Context) error { return svca.Foo(ctx) }

----------------------------------------

TITLE: Direct Secrets Configuration for Encore
DESCRIPTION: JSON configuration for setting up application secrets in Encore applications with direct value embedding or environment variable references.

LANGUAGE: json
CODE:
{
  "secrets": {
    "API_TOKEN": "embedded-secret-value",
    "DB_PASSWORD": {
      "$env": "DB_PASSWORD"
    }
  }
}

----------------------------------------

TITLE: Implementing Config Type Unmarshaler in Go
DESCRIPTION: Implementation of a type-specific config unmarshaler that handles JSON to Go struct conversion. This function reads JSON fields and converts them to corresponding Go types, with special handling for complex types like UUID and byte arrays.

LANGUAGE: go
CODE:
func encoreInternalTypeConfigUnmarshaler_svc_Config(itr *jsoniter.Iterator, path []string) (obj Config) {
	itr.ReadObjectCB(func(itr *jsoniter.Iterator, field string) bool {
		switch field {
		case "Name":
			obj.Name = itr.ReadString()
		case "Port":
			obj.Port = itr.ReadUint16()
		case "ReadOnly":
			obj.ReadOnly = itr.ReadBool()
		case "MagicNumber":
			obj.MagicNumber = itr.ReadInt()
		case "ID":
			obj.ID = func() (rtn uuid.UUID) {
				decoder := new(__etype.Unmarshaller)
				rtn = __etype.UnmarshalOne(decoder, __etype.UnmarshalUUID, "value", itr.ReadString(), true)
				if err := decoder.Error; err != nil {
					panic(fmt.Sprintf("unable to decode the config: %v", err))
				}
				return
			}()
		case "PublicKey":
			obj.PublicKey = func() (rtn []byte) {
				decoder := new(__etype.Unmarshaller)
				rtn = __etype.UnmarshalOne(decoder, __etype.UnmarshalBytes, "value", itr.ReadString(), true)
				if err := decoder.Error; err != nil {
					panic(fmt.Sprintf("unable to decode the config: %v", err))
				}
				return
			}()
		default:
			itr.Skip()
		}
		return true
	})
	return
}

----------------------------------------

TITLE: Encore Error Message for Invalid Raw API Call
DESCRIPTION: This shows the error message produced by Encore when a raw API endpoint is called from within the application. The error explains that raw APIs cannot be called from within an Encore application and provides hints on valid API signatures.

LANGUAGE: text
CODE:
! parse
err 'calling raw API endpoint svc.API from another endpoint is not yet supported'

----------------------------------------

TITLE: Using Secrets in Encore Applications
DESCRIPTION: Demonstrates how to use secrets in Encore applications. This example shows accessing the GitHub API token secret to make authenticated API calls to GitHub's API.

LANGUAGE: go
CODE:
func callGitHub(ctx context.Context) {
    req, _ := http.NewRequestWithContext(ctx, "GET", "https:///api.github.com/user", nil)
    req.Header.Add("Authorization", "token " + secrets.GitHubAPIToken)
    resp, err := http.DefaultClient.Do(req)
    // ... handle err and resp
}

----------------------------------------

TITLE: Datadog Metrics Configuration for Encore
DESCRIPTION: JSON configuration for setting up Datadog metrics export in Encore applications, including collection interval, site, and API key.

LANGUAGE: json
CODE:
{
  "metrics": {
    "type": "datadog",
    "collection_interval": 30,
    "site": "datadoghq.com",
    "api_key": {
      "$env": "DATADOG_API_KEY"
    }
  }
}

----------------------------------------

TITLE: Defining an Encore Service Struct (Go)
DESCRIPTION: Declares a service struct in the 'svc' package with the //encore:service annotation and exposes a public API method. Service structs are meant to be used only within their own service boundary.

LANGUAGE: go
CODE:
package svc

import (
	"context"
)

//encore:service
type Service struct {}

//encore:api public
func (*Service) Foo(ctx context.Context) error { return nil }

----------------------------------------

TITLE: Defining a Slack service in Encore
DESCRIPTION: Creates an Encore service definition for the Slack integration. This establishes the service within the Encore ecosystem.

LANGUAGE: typescript
CODE:
import { Service } from "encore.dev/service";

export default new Service("slack");

----------------------------------------

TITLE: Testing Deployed Application with cURL
DESCRIPTION: Command to test if the deployed Encore application is responding correctly on DigitalOcean's App Platform.

LANGUAGE: bash
CODE:
curl https://myapp.ondigitalocean.app/hello/world

----------------------------------------

TITLE: Running Encore in Standard Debug Mode
DESCRIPTION: Command to start an Encore application in debug mode, which prints the process ID to be used for attaching a debugger to the running process.

LANGUAGE: shell
CODE:
$ encore run --debug
API Base URL:      http://localhost:4000
Dev Dashboard URL: http://localhost:9400/hello-world-cgu2
Process ID:        51894
1:48PM INF registered endpoint path=/hello/:name service=hello endpoint=Hello

----------------------------------------

TITLE: Configuring Logto Resources in React Application
DESCRIPTION: This snippet shows how to update the LogtoConfig to include the API resource used in the Encore app. This configuration tells Logto that access tokens will be requested for the Encore API resource.

LANGUAGE: typescript
CODE:
import { LogtoConfig } from '@logto/react';

const config: LogtoConfig = {
  // ...other configs
  resources: ['<your-api-resource-indicator>'],
};

----------------------------------------

TITLE: Logging into Encore
DESCRIPTION: Command to authenticate and log in to the Encore platform.

LANGUAGE: bash
CODE:
encore auth login

----------------------------------------

TITLE: Running Encore Tests for the Monitor Service
DESCRIPTION: Command to run automated tests for the Encore application to verify the Ping endpoint works correctly.

LANGUAGE: shell
CODE:
$ encore test ./...

----------------------------------------

TITLE: Configuring gqlgen with YAML Configuration
DESCRIPTION: Configuration file for gqlgen that defines schema location, code generation paths, resolver layout, and type mappings between GraphQL and Go types.

LANGUAGE: yaml
CODE:
# Where are all the schema files located? globs are supported eg  src/**/*.graphqls
schema:
  - graphql/*.graphqls

# Where should the generated server code go?
exec:
  filename: graphql/generated/generated.go
  package: generated

# Where should any generated models go?
model:
  filename: graphql/model/models_gen.go
  package: model

# Where should the resolver implementations go?
resolver:
  layout: follow-schema
  dir: graphql
  package: graphql

# gqlgen will search for any type names in the schema in these go packages
# if they match it will use them, otherwise it will generate them.
autobind:
 - "encore.app/url"

# This section declares type mapping between the GraphQL and go type systems
#
# The first line in each type will be used as defaults for resolver arguments and
# modelgen, the others will be allowed when binding to fields. Configure them to
# your liking
models:
  ID:
    model:
      - github.com/99designs/gqlgen/graphql.ID
      - github.com/99designs/gqlgen/graphql.Int
      - github.com/99designs/gqlgen/graphql.Int64
      - github.com/99designs/gqlgen/graphql.Int32
  Int:
    model:
      - github.com/99designs/gqlgen/graphql.Int
      - github.com/99designs/gqlgen/graphql.Int64
      - github.com/99designs/gqlgen/graphql.Int32

----------------------------------------

TITLE: Login Status Component with User Profile Display
DESCRIPTION: React component that displays the current authentication status, showing login/logout buttons and user profile information when authenticated. It fetches user profile data from the backend when the user is logged in.

LANGUAGE: tsx
CODE:
import getRequestClient from "../lib/getRequestClient.ts";
import { useFetcher } from "react-router-dom";
import { useEffect, useState } from "react";
import { auth } from "../lib/client.ts";
import { Auth0Provider } from "../lib/auth.ts";

/**
 * Component displaying login/logout button and basic user information if logged in.
 */
function LoginStatus() {
  const client = getRequestClient();
  const fetcher = useFetcher();
  const [profile, setProfile] = useState<auth.ProfileData>();
  const [loading, setLoading] = useState(true);

  // Fetch profile data if user is authenticated
  useEffect(() => {
    const getProfile = async () => {
      setProfile(await client.auth.GetProfile());
      setLoading(false);
    };
    if (Auth0Provider.isAuthenticated()) getProfile();
    else setLoading(false);
  }, []);

  if (loading) return null;

  if (profile) {
    return (
      <div className="authStatus">
        <img src={profile.picture} />
        <fetcher.Form method="GET" action="/logout">
          <button type="submit">Sign out {profile.email}</button>
        </fetcher.Form>
      </div>
    );
  }

  const params = new URLSearchParams();
  params.set("returnTo", window.location.pathname);
  return (
    <div className="authStatus">
      <fetcher.Form method="GET" action={"/login?" + params.toString()}>
        <button type="submit">
          {fetcher.state !== "idle" ? "Signing in..." : "Sign in"}
        </button>
      </fetcher.Form>
    </div>
  );
}

export default LoginStatus;

----------------------------------------

TITLE: Configuring AWS SNS/SQS in Encore
DESCRIPTION: JSON configuration for setting up AWS SNS (Simple Notification Service) with SQS (Simple Queue Service) in an Encore application. The example defines a user-notifications topic with an SQS subscription, specifying the ARNs for both resources.

LANGUAGE: json
CODE:
{
  "pubsub": [
    {
      "type": "aws_sns_sqs",
      "topics": {
        "user-notifications": {
          "arn": "arn:aws:sns:us-east-1:123456789012:user-notifications",
          "subscriptions": {
            "user-queue": {
              "arn": "arn:aws:sqs:us-east-1:123456789012:user-queue"
            }
          }
        }
      }
    }
  ]
}

----------------------------------------

TITLE: Enhanced Config Loading with Unmarshaler in Go
DESCRIPTION: Enhanced version of the config loading with an explicit service name and reference to the auto-generated unmarshaler function. This shows how the auto-generated code integrates with the config loading mechanism.

LANGUAGE: go
CODE:
var _ = config.Load[*Config]("svc", encoreInternalConfigUnmarshaler_ptr_svc_Config/*line :24:30*/)

----------------------------------------

TITLE: Implementing a Public API Endpoint in Encore
DESCRIPTION: Defines a service package with a public API endpoint called Foo. The function takes a context.Context parameter and always returns nil. The //encore:api public directive exposes this function as a public API endpoint.

LANGUAGE: Go
CODE:
package svc

import (
    "context"
)

//encore:api public
func Foo(context.Context) error { return nil }

----------------------------------------

TITLE: Implementing PubSub Topic and Subscription in Go with Encore.dev
DESCRIPTION: Creates a pubsub topic with at-least-once delivery guarantee and registers a subscription that processes events through a handler function. The subscription handler currently has an empty implementation that simply returns nil.

LANGUAGE: go
CODE:
package svc

import (
	"context"
	"encore.dev/pubsub"
)

type Event struct {}

var Topic = pubsub.NewTopic[*Event]("topic", pubsub.TopicConfig{
    DeliveryGuarantee: pubsub.AtLeastOnce,
})

var _ = pubsub.NewSubscription(Topic, "subscription",
    pubsub.SubscriptionConfig[*Event]{
        Handler: func(ctx context.Context, event *Event) error {
            return nil
        },
    },
)

----------------------------------------

TITLE: Installing Vitest as Development Dependency
DESCRIPTION: Shell command to install Vitest, a testing framework for TypeScript, as a development dependency in the project using npm.

LANGUAGE: shell
CODE:
$ npm i --save-dev vitest

----------------------------------------

TITLE: Implementing an Authentication Handler in Go with Encore
DESCRIPTION: This code snippet defines a basic authentication handler function using Encore's beta auth package. The function is marked with the '//encore:authhandler' directive to register it as an authentication handler with the Encore framework. It takes a context and token string as input and returns an auth.UID and error.

LANGUAGE: Go
CODE:
package svc

import (
    "context"
    "encore.dev/beta/auth"
)

//encore:authhandler
func MyAuth(ctx context.Context, token string) (auth.UID, error) { return "", nil }

----------------------------------------

TITLE: Updated Cowsay Endpoint with Security Verification in Go
DESCRIPTION: Enhanced version of the Cowsay endpoint that includes Slack request verification and proper form data parsing from the request body.

LANGUAGE: go
CODE:
//encore:api public raw path=/cowsay
func Cowsay(w http.ResponseWriter, req *http.Request) {
	body, err := verifyRequest(req)
	if err != nil {
		errs.HTTPError(w, err)
		return
	}
	q, _ := url.ParseQuery(string(body))
	text := q.Get("text")
	data, _ := json.Marshal(map[string]string{
		"response_type": "in_channel",
		"text":          fmt.Sprintf(cowart, text),
	})
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	w.Write(data)
}

----------------------------------------

TITLE: Importing Libraries for HMAC Verification in Go
DESCRIPTION: Importing necessary Go packages for implementing HMAC-based Slack request verification, including cryptography, HTTP handling, and Encore error utilities.

LANGUAGE: go
CODE:
import (
	"crypto/hmac"
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"time"

	"encore.dev/beta/errs"
	"encore.dev/rlog"
)

----------------------------------------

TITLE: Deleting Objects from Object Storage in Encore.ts
DESCRIPTION: Demonstrates how to delete an object from a bucket using the 'remove' method. This permanently removes the specified file from storage.

LANGUAGE: typescript
CODE:
await profilePictures.remove("my-image.jpeg");

----------------------------------------

TITLE: Example Logto Authentication Configuration Values
DESCRIPTION: A sample CUE configuration with placeholder values replaced with realistic Logto authentication parameters.

LANGUAGE: cue
CODE:
Issuer: "https://your-tenant.logto.app"
JwksUri: "https://your-tenant.logto.app/jwks"
ApiResourceIndicator: "https://api.encoreapp.com"
ClientId: "2gadf3mp0zotlq8j1k5x"

----------------------------------------

TITLE: Configuring Kubernetes for Encore Environments
DESCRIPTION: Command to update kubectl configuration for a specific Encore environment.

LANGUAGE: bash
CODE:
encore k8s configure --env=ENV_NAME

----------------------------------------

TITLE: Listing Objects in Object Storage in Go
DESCRIPTION: Demonstrates how to list objects in a bucket using the List method. The method returns an iterator that can be used with a range loop to process each object entry.

LANGUAGE: go
CODE:
for err, entry := range ProfilePictures.List(ctx, &objects.Query{}) {
	if err != nil {
		// Handle error
	}
	// Do something with entry
}

----------------------------------------

TITLE: Checking Encore Version in Terminal
DESCRIPTION: Command to check which version of Encore is currently installed on your system. The output displays the version number in the format 'encore version vX.Y.Z'.

LANGUAGE: shell
CODE:
encore version v1.28.0

----------------------------------------

TITLE: Defining Go Package with Encore Imports
DESCRIPTION: Defines the svc package and imports the necessary Encore authentication package.

LANGUAGE: go
CODE:
package svc

import (
    "context"
    
    "encore.dev/beta/auth"
)

----------------------------------------

TITLE: Auto-Generated Encore Config Unmarshalers for Temporal Client
DESCRIPTION: Shows the auto-generated unmarshalers that Encore creates to handle JSON deserialization into strongly-typed configuration objects. These functions use jsoniter to parse the JSON configuration data into the appropriate types.

LANGUAGE: go
CODE:
package helloworld

import (
	config "encore.dev/config"
	temporal "example.com/pkg/temporal"
	jsoniter "github.com/json-iterator/go"
)

/*
These functions are automatically generated and maintained by Encore to allow config values
to be unmarshalled into the correct types. They are not intended to be used directly. They
are automatically updated by Encore whenever you change the data types used within your
calls to config.Load[T]().
*/

// Concrete unmarshalers for all config.Load calls, including those using generic types.
// These instances are used directly by calls to `config.Load[T]()`.
var (
	encoreInternalConfigUnmarshaler_examplecom_Config = encoreInternalTypeConfigUnmarshaler_helloworld_Config
)

// encoreInternalTypeConfigUnmarshaler_helloworld_Config will unmarshal the JSON representation into the given type, taking account for
// the `config.Value` dynamic functions.
func encoreInternalTypeConfigUnmarshaler_helloworld_Config(itr *jsoniter.Iterator, path []string) (obj Config) {
	itr.ReadObjectCB(func(itr *jsoniter.Iterator, field string) bool {
		switch field {
		case "Temporal":
			obj.Temporal = config.CreateValue[temporal.ClientOptions](encoreInternalTypeConfigUnmarshaler_temporal_ClientOptions(itr, append(path, "Temporal")), append(path, "Temporal"))
		default:
			itr.Skip()
		}
		return true
	})
	return
}

// encoreInternalTypeConfigUnmarshaler_temporal_ClientOptions will unmarshal the JSON representation into the given type, taking account for
// the `config.Value` dynamic functions.
func encoreInternalTypeConfigUnmarshaler_temporal_ClientOptions(itr *jsoniter.Iterator, path []string) (obj temporal.ClientOptions) {
	itr.ReadObjectCB(func(itr *jsoniter.Iterator, field string) bool {
		switch field {
		case "HostPort":
			obj.HostPort = itr.ReadString()
		case "Namespace":
			obj.Namespace = itr.ReadString()
		default:
			itr.Skip()
		}
		return true
	})
	return
}

----------------------------------------

TITLE: Implementing Basic API Endpoint with Encore Annotation in Go
DESCRIPTION: Implements a minimal API endpoint using Encore's annotation system. The function takes a context parameter and returns an error, with the //encore:api annotation marking it as an externally accessible API endpoint.

LANGUAGE: go
CODE:
//encore:api
func MyAPI(ctx context.Context) (error) {
	return nil
}

----------------------------------------

TITLE: AWS CloudWatch Metrics Configuration for Encore
DESCRIPTION: JSON configuration for setting up AWS CloudWatch metrics export in Encore applications, including collection interval and namespace.

LANGUAGE: json
CODE:
{
  "metrics": {
    "type": "aws_cloudwatch",
    "collection_interval": 60,
    "namespace": "MyAppMetrics"
  }
}

----------------------------------------

TITLE: Defining a Library Configuration Structure in Go
DESCRIPTION: Defines a shared configuration structure for a library with various config types including String, Bool, and generic Value types for handling int slices.

LANGUAGE: go
CODE:
package shared

import (
    "encore.dev/config"
)

type LibraryConfig struct {
    Name    config.String
    Enabled config.Bool
    ValueList config.Value[[]int]
    List []int
}

----------------------------------------

TITLE: Global Middleware with Tag Target in Encore
DESCRIPTION: Defines a global middleware in Encore that targets APIs with the 'foo' tag across all services. The middleware passes the request to the next handler without modification.

LANGUAGE: go
CODE:
//encore:middleware global target=tag:foo
func TaggedInSvc(req middleware.Request, next middleware.Next) middleware.Response {
    return next(req)
}

----------------------------------------

TITLE: Configuring Google Cloud Storage in Encore
DESCRIPTION: JSON configuration for Google Cloud Storage buckets in an Encore application. Includes bucket naming, key prefixes for organizing objects, and optional public CDN URLs for serving content. Useful for static asset hosting and file storage.

LANGUAGE: json
CODE:
{
  "object_storage": [
    {
      "type": "gcs",
      "buckets": {
        "my-gcs-bucket": {
          "name": "my-gcs-bucket",
          "key_prefix": "my-optional-prefix/",
          "public_base_url": "https://my-gcs-bucket-cdn.example.com/my-optional-prefix"
        }
      }
    }
  ]
}

----------------------------------------

TITLE: Defining Initial Database Schema with SQL Migration
DESCRIPTION: This snippet shows how to define the initial database schema for a todo application using an SQL migration file. It creates a todo_item table with id, title, and done fields.

LANGUAGE: sql
CODE:
CREATE TABLE todo_item (
    id BIGSERIAL PRIMARY KEY,
    title TEXT NOT NULL,
    done BOOLEAN NOT NULL DEFAULT false
);

----------------------------------------

TITLE: Defining an Encore Service
DESCRIPTION: Creates an Encore service definition by exporting a Service instance. This marks the directory and its subdirectories as part of the specified service.

LANGUAGE: typescript
CODE:
import {Service} from "encore.dev/service";

export default new Service("my-service");

----------------------------------------

TITLE: Testing the Slack Webhook with cURL
DESCRIPTION: Shell command to test the Slack webhook endpoint locally using cURL. Sends a POST request with form data to the local Encore development server.

LANGUAGE: shell
CODE:
$ curl http://localhost:4000/cowsay -d 'text=Eat your greens!'
{"response_type":"in_channel","text":"Moo! Eat your greens!"}

----------------------------------------

TITLE: Deploying to Encore Cloud with Git
DESCRIPTION: Git commands to commit changes and deploy the application to Encore Cloud, which provides automated infrastructure and DevOps.

LANGUAGE: shell
CODE:
$ git add -A .
$ git commit -m 'Initial commit'
$ git push encore

----------------------------------------

TITLE: Installing GORM and PostgreSQL Driver Dependencies
DESCRIPTION: Shell command to install the GORM library and PostgreSQL driver required for database operations in the site service.

LANGUAGE: shell
CODE:
$ go get -u gorm.io/gorm gorm.io/driver/postgres

----------------------------------------

TITLE: Integrating Clerk Authentication in React Frontend
DESCRIPTION: Example React component using Clerk's React SDK to handle authentication state and retrieve the token to send to the Encore backend. This demonstrates how to use the useAuth hook to get tokens for authenticated API calls.

LANGUAGE: tsx
CODE:
import { useAuth } from '@clerk/clerk-react';
 
export default function ExternalDataPage() {
  const { getToken, isLoaded, isSignedIn } = useAuth();
 
  if (!isLoaded) {
    // Handle loading state however you like
    return <div>Loading...</div>;
  }
 
  if (!isSignedIn) {
    // Handle signed out state however you like
    return <div>Sign in to view this page</div>;
  }
 
  const fetchDataFromExternalResource = async () => {
    const token = await getToken();
    // Use token to send to Encore backend when fetching data
    return data;
  }
 
  return <div>...</div>;
}

----------------------------------------

TITLE: Creating a Private Object Storage Bucket in Encore
DESCRIPTION: Example of defining a private object storage bucket for profile pictures. This creates a cloud-agnostic storage bucket without versioning that can be used from any service.

LANGUAGE: go
CODE:
var ProfilePictures = objects.NewBucket("profile-pictures", objects.BucketConfig{
    Versioned: false,
})

----------------------------------------

TITLE: Checking Object Existence in Object Storage in Go
DESCRIPTION: Shows how to check if an object exists in a bucket using the Exists method, which returns a boolean indicating whether the object exists.

LANGUAGE: go
CODE:
exists, err := ProfilePictures.Exists(ctx, "my-user-id")
if err != nil {
	// Handle error
} else if !exists {
	// Object does not exist
}

----------------------------------------

TITLE: Defining a Data Structure with JSON Field Tags
DESCRIPTION: Creates a struct called SomeStruct with two string fields that are excluded from JSON serialization.

LANGUAGE: go
CODE:
type SomeStruct struct {
    A string `json:"-"`
    B string `json:"-"`
}

----------------------------------------

TITLE: Defining Generic Configuration Types in Go with Encore
DESCRIPTION: Defines a generic configuration structure that can handle various data types. The CfgType struct uses a generic type parameter T and includes various configuration field types including booleans, bytes, string lists, nested configurations, and maps.

LANGUAGE: go
CODE:
type CfgType[T any] struct {
	ReadOnlyMode config.Bool
	PublicKey    config.Bytes
	AdminUsers   config.Values[string]

	SubConfig config.Value[struct {
		SubKey *SubCfgType[T]
	}]

	Currencies map[string]struct {
		Name    config.String
		Code    config.String
		Aliases config.Values[string]
	}

	AnotherList config.Values[struct {
		Name config.String
	}]
}

----------------------------------------

TITLE: Defining Secrets Structure in Encore
DESCRIPTION: Shows how to define a secrets structure in Encore for secure storage of sensitive values like API keys and private keys.

LANGUAGE: go
CODE:
var secrets struct {
    SSHPrivateKey string
    GitHubAPIToken string
}

----------------------------------------

TITLE: Setting Up Configuration with Encore in Go
DESCRIPTION: Demonstrates how to set up a configuration structure using Encore's config system, including importing the temporal package and defining a Config struct with a Temporal field of type config.Value.

LANGUAGE: go
CODE:
package helloworld

import (
    "context"
    "encore.dev/config"

    "example.com/pkg/temporal"
)

type Config struct {
	Temporal config.Value[temporal.ClientOptions]
}

var cfg = config.Load[Config]()

// There must be an API endpoint to use config.Load.
//encore:api
func Dummy(context.Context) error { return nil }

----------------------------------------

TITLE: Defining an Auth Handler in Encore (Go)
DESCRIPTION: Defines a service package with an auth handler function 'MyAuth' using the encore:authhandler annotation. The handler accepts a context and token string, returning an auth.UID, custom data, and an error.

LANGUAGE: go
CODE:
package svc

import (
    "context"
    "encore.dev/beta/auth"
)

type MyData struct {
    Name string
}

//encore:authhandler
func MyAuth(ctx context.Context, token string) (auth.UID, *MyData, error) { return "", nil, nil }

----------------------------------------

TITLE: Creating a URL-shortener Application with Encore CLI
DESCRIPTION: Command to create a new Encore application using the url-shortener template as a starting point for the GraphQL API tutorial.

LANGUAGE: shell
CODE:
$ encore app create --example=url-shortener

----------------------------------------

TITLE: Resetting Encore Databases
DESCRIPTION: Resets databases for specified services or all databases using the --all flag.

LANGUAGE: shell
CODE:
$ encore db reset [service-names...] [flags]

----------------------------------------

TITLE: Creating Application-Level Tagged Middleware in Go
DESCRIPTION: Implements a global middleware that targets all API endpoints with the 'foo' tag across the entire application. This uses the 'global' modifier to ensure it applies to all services.

LANGUAGE: go
CODE:
//encore:middleware global target=tag:foo
func TaggedInSvc(req middleware.Request, next middleware.Next) middleware.Response {
    return next(req)
}

----------------------------------------

TITLE: Setting Slack Webhook URL as Encore Secrets
DESCRIPTION: Command for setting the Slack Webhook URL as secrets in Encore for different environments (development, local, PR, and production).

LANGUAGE: shell
CODE:
$ encore secret set --type dev,local,pr SlackWebhookURL
$ encore secret set --type prod SlackWebhookURL

----------------------------------------

TITLE: Basic Environment Metadata Configuration
DESCRIPTION: Configuration for basic environment metadata including app ID, environment name and type, cloud provider, and base URL. This information is used by Encore to properly identify and operate the application.

LANGUAGE: json
CODE:
{
  "metadata": {
    "app_id": "my-encore-app",
    "env_name": "production",
    "env_type": "production",
    "cloud": "aws",
    "base_url": "https://api.myencoreapp.com"
  }
}

----------------------------------------

TITLE: Defining Encore Service for Slack Integration
DESCRIPTION: TypeScript code that defines a new Encore service named 'slack'. This is the service definition file that tells Encore to treat the files in this directory as part of the slack service.

LANGUAGE: typescript
CODE:
import { Service } from "encore.dev/service";

export default new Service("slack");

----------------------------------------

TITLE: Setting Clerk Development Secret in Encore
DESCRIPTION: Command to set the Clerk client secret key as an Encore secret for development environment. This enables testing with a separate key for local development.

LANGUAGE: shell
CODE:
$ encore secret set --dev ClientSecretKey

----------------------------------------

TITLE: Creating Initial Database Schema with SQL Migration
DESCRIPTION: Example of an initial migration script that creates a table for todo items with basic fields.

LANGUAGE: sql
CODE:
CREATE TABLE todo_item (
    id BIGSERIAL PRIMARY KEY,
    title TEXT NOT NULL,
    done BOOLEAN NOT NULL
);

----------------------------------------

TITLE: Creating a Typed Pub/Sub Topic Reference in Encore
DESCRIPTION: Example of creating a typed reference to a Pub/Sub topic with specific permissions. This enables static analysis for infrastructure and enforces proper permission usage.

LANGUAGE: go
CODE:
signupRef := pubsub.TopicRef[pubsub.Publisher[*SignupEvent]](Signups)

----------------------------------------

TITLE: Running an Encore Docker Image with Custom Port
DESCRIPTION: This command demonstrates how to run a Docker image built with Encore while specifying a custom port. The PORT environment variable is used to configure the application to run on port 8081 instead of the default 8080.

LANGUAGE: bash
CODE:
docker run -e PORT=8081 -p 8081:8081 MY-IMAGE:TAG

----------------------------------------

TITLE: Generating an Encore API Client with Bash Command
DESCRIPTION: Command to generate a TypeScript client for an Encore backend application. This creates typesafe API clients that can be imported into frontend code.

LANGUAGE: bash
CODE:
$ encore gen client <ENCORE-APP-ID> --output=./src/client.ts --env=<ENV_NAME>

----------------------------------------

TITLE: Installing Delve Debugger for Go
DESCRIPTION: Command to install the Delve debugger tool using Go's package manager. This is a prerequisite for debugging Encore applications.

LANGUAGE: shell
CODE:
$ go install github.com/go-delve/delve/cmd/dlv@latest

----------------------------------------

TITLE: Creating SQL Migration for Knex.js in Encore
DESCRIPTION: Example of an SQL migration file that creates the 'site' table with an auto-incrementing id and a unique URL field. This SQL format is used since Encore does not support JavaScript migration files generated by knex migrate:make.

LANGUAGE: sql
CODE:
-- migrations/1_create_table.up.sql --
CREATE TABLE site (
    id SERIAL PRIMARY KEY,
    url TEXT NOT NULL UNIQUE
);

----------------------------------------

TITLE: Implementing Cloud-Specific Behavior with Metadata
DESCRIPTION: Example of using Encore metadata to implement different behaviors based on the cloud provider environment, directing audit logs to different storage systems depending on whether the application is running in AWS, GCP, or locally.

LANGUAGE: go
CODE:
func Audit(ctx context.Context, action message, user auth.UID) error {
    switch encore.Meta().Environment.Cloud {
    case encore.CloudAWS:
        return writeIntoRedshift(ctx, action, user)
    case encore.CloudGCP:
        return writeIntoBigQuery(ctx, action, user)
    case encore.CloudLocal:
        return writeIntoFile(ctx, action, user)
    }
}

----------------------------------------

TITLE: Implementing Authentication Handler in Encore
DESCRIPTION: Defines an authentication handler that processes requests with an Authorization header. The function is annotated with encore:authhandler directive to register it as an authentication handler for the service.

LANGUAGE: go
CODE:
type Params struct {
    Authorization string `header:"Authorization"`
}

//encore:authhandler
func MyAuth(ctx context.Context, p *Params) (auth.UID, error) { return "", nil }

----------------------------------------

TITLE: Implementing Cron API Endpoint in Go
DESCRIPTION: Defines the CronAPI function that serves as an endpoint for multiple cron jobs. This public API returns a response with a simple message and is exposed at the /cron path.

LANGUAGE: go
CODE:
//encore:api public path=/cron
func CronAPI(ctx context.Context) (*Response, error) {
	msg := "Hello, Cron!"
	return &Response{Message: msg}, nil
}

type Response struct {
	Message string
}

----------------------------------------

TITLE: Retrieving Previous Site Status Measurements
DESCRIPTION: This function queries the database to retrieve the most recent status check for a given site, defaulting to 'true' (up) if no previous measurements are found.

LANGUAGE: typescript
CODE:
// getPreviousMeasurement reports whether the given site was
// up or down in the previous measurement.
async function getPreviousMeasurement(siteID: number): Promise<boolean> {
  const row = await MonitorDB.queryRow`
      SELECT up
      FROM checks
      WHERE site_id = ${siteID}
      ORDER BY checked_at DESC
      LIMIT 1
  `;
  return row?.up ?? true;
}

----------------------------------------

TITLE: Implementing GraphQL Resolver with REST API Calls
DESCRIPTION: This TypeScript resolver implementation shows how to call an Encore REST API from a GraphQL resolver. It imports the book service client and implements the books query by calling the book.list() endpoint.

LANGUAGE: typescript
CODE:
// Import the book service from the generated service clients
import { book } from "~encore/clients";
import { QueryResolvers } from "../generated/resolvers-types";

const queries: QueryResolvers = {
  books: async () => {
    // Call book.list to get the list of books
    const { books } = await book.list();
    return books;
  },
};

export default queries;

----------------------------------------

TITLE: Initializing an Encore application
DESCRIPTION: Command to create an Encore app by generating the necessary encore.app file in the project root.

LANGUAGE: bash
CODE:
encore app init

----------------------------------------

TITLE: GitHub Actions Workflow for Frontend Deployment
DESCRIPTION: A GitHub Actions workflow configuration that builds and deploys the frontend to GitHub Pages. It runs on push events, installing dependencies and using the github-pages-deploy-action to deploy to the gh-pages branch.

LANGUAGE: yaml
CODE:
name: Build and Deploy

on: [push]

permissions:
  contents: write

jobs:
  build-and-deploy:
    concurrency: ci-${{ github.ref }}
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: frontend

    steps:
      - name: Checkout 🛎️
        uses: actions/checkout@v3

      - name: Use Node.js
        uses: actions/setup-node@v3
        with:
          node-version: "16.15.1"

      - name: Install and Build 🔧
        run: |
          npm install
          npm run build

      - name: Deploy 🚀
        uses: JamesIves/github-pages-deploy-action@v4.3.3
        with:
          branch: gh-pages
          folder: frontend/dist

----------------------------------------

TITLE: Creating Encore Infrastructure Configuration
DESCRIPTION: JSON configuration file that defines the SQL server connection details for the Encore application, including host, TLS configuration, and database credentials.

LANGUAGE: json
CODE:
{
   "$schema": "https://encore.dev/schemas/infra.schema.json",
   "sql_servers": [
   {
      "host": "mydb.db.ondigitalocean.com:25060",
      "tls_config": {
         "ca": "-----BEGIN CERTIFICATE-----\n..."
      },
      "databases": {
         "mydb": {
            "name": "mydb",
            "username": "doadmin",
            "password": {"$env": "DB_PASSWORD"}
          }
      }
   }]   
}

----------------------------------------

TITLE: Defining Note Data Structure in Go
DESCRIPTION: Go struct definition for the Note type, representing a meeting note with an ID, text content, and cover image URL.

LANGUAGE: go
CODE:
type Note struct {
	ID       string `json:"id"`
	Text     string `json:"text"`
	CoverURL string `json:"cover_url"`
}

----------------------------------------

TITLE: Installing Encore on Windows using PowerShell
DESCRIPTION: PowerShell command to download and execute the Encore installation script on Windows systems.

LANGUAGE: powershell
CODE:
iwr https://encore.dev/install.ps1 | iex

----------------------------------------

TITLE: Creating Service Directory Structure with Shell Commands
DESCRIPTION: Commands to create the directory structure for the site service, including a migrations folder for database schema files.

LANGUAGE: shell
CODE:
$ mkdir site
$ mkdir site/migrations

----------------------------------------

TITLE: Creating SQL Migration for Site Database
DESCRIPTION: SQL migration script that creates a table to store website information with id and url fields.

LANGUAGE: sql
CODE:
CREATE TABLE site (
    id SERIAL PRIMARY KEY,
    url TEXT NOT NULL UNIQUE
);

----------------------------------------

TITLE: Checking Current Encore User
DESCRIPTION: Command to display information about the currently authenticated Encore user.

LANGUAGE: bash
CODE:
encore auth whoami

----------------------------------------

TITLE: Setting Slack Webhook URL as Encore Secret via CLI
DESCRIPTION: Command to set the Slack webhook URL as an Encore secret for different environment types. This securely stores the URL for use in the application without hard-coding it in the source code.

LANGUAGE: shell
CODE:
$ encore secret set --type dev,local,pr SlackWebhookURL
Enter secret value: *****
Successfully updated development secret SlackWebhookURL.

----------------------------------------

TITLE: Environment-Based Behavior with Encore Metadata
DESCRIPTION: Example of modifying application behavior based on the environment type using Encore metadata. In test and development environments, automatically marks emails as verified, while in production sends verification emails.

LANGUAGE: go
CODE:
switch encore.Meta().Environment.Type {
case encore.EnvTest, encore.EnvDevelopment:
    return MarkEmailVerified(ctx, userID)
default:
    return SendVerificationEmail(ctx, userID)
}

----------------------------------------

TITLE: Building Encore Docker Images
DESCRIPTION: Command to build portable Docker images for Encore applications with options to define base image and push to remote repository.

LANGUAGE: bash
CODE:
encore build docker

----------------------------------------

TITLE: Defining Encore API Service
DESCRIPTION: A basic Encore service with an API endpoint 'Foo' that accepts a context and returns an error.

LANGUAGE: go
CODE:
package svc

import "context"

//encore:api
func Foo(ctx context.Context) error { return nil }

----------------------------------------

TITLE: Defining a PubSub Topic with Invalid Attribute Prefix in Go
DESCRIPTION: This code defines a MessageType struct with an attribute that incorrectly uses the 'encore' prefix, which is reserved. It then creates a PubSub topic using this message type with the Encore framework, triggering a validation error.

LANGUAGE: go
CODE:
package shared

import (
    "encore.dev/pubsub"
)

type MessageType struct {
    Name string `pubsub-attr:"encorename"`
}

var BasicTopic = pubsub.NewTopic[*MessageType]("same-name", pubsub.TopicConfig{ DeliveryGuarantee: pubsub.AtLeastOnce })

----------------------------------------

TITLE: SQL Migration File Structure for myservice
DESCRIPTION: File path for SQL migration files in the myservice directory.

LANGUAGE: plain
CODE:
-- myservice/migrations/1_foo.up.sql --

----------------------------------------

TITLE: Database Migration File
DESCRIPTION: Empty SQL migration file for the service database. This would typically contain SQL statements for schema changes.

LANGUAGE: sql
CODE:
-- 1_dummy.up.sql --

----------------------------------------

TITLE: Using Namespaces with Encore Commands
DESCRIPTION: Examples showing how to use the --namespace flag with other Encore commands to override the current namespace. The snippet demonstrates running an app, opening a database shell, and resetting databases with a specific namespace context.

LANGUAGE: shell
CODE:
# Run the app using the "my-ns" namespace
$ encore run --namespace my-ns

# Open a database shell to the "my-ns" namespace
$ encore db shell DATABASE_NAME --namespace my-ns

# Reset all databases within the "my-ns" namespace
$ encore db reset --all --namespace my-ns

----------------------------------------

TITLE: Creating a Users Table and Adding Data in PostgreSQL
DESCRIPTION: SQL commands to create a users table with id and name columns, and insert a sample user record.

LANGUAGE: sql
CODE:
CREATE TABLE users (
   id SERIAL PRIMARY KEY,
   name VARCHAR(50)
);
INSERT INTO users (name) VALUES ('Alice');

----------------------------------------

TITLE: Constructing Webhook Payload for Signature Verification
DESCRIPTION: Shows how to prepare the payload string that needs to be signed when manually verifying webhook signatures. The payload combines the timestamp and request body.

LANGUAGE: go
CODE:
payloadToSign := timestamp + "." + string(payload)

----------------------------------------

TITLE: Inserting Data into SQL Database in Encore.ts
DESCRIPTION: Shows how to insert data into a SQL database using the exec method, which is designed for operations that don't return rows.

LANGUAGE: TypeScript
CODE:
await db.exec`
  INSERT INTO todo_item (title, done)
  VALUES (${title}, false)
`;

----------------------------------------

TITLE: Defining an Encore Service for Site Management
DESCRIPTION: Typescript code that defines a new Encore service named 'site' for managing monitored websites.

LANGUAGE: typescript
CODE:
import { Service } from "encore.dev/service";

export default new Service("site");

----------------------------------------

TITLE: Defining Path Parameters in API Routes
DESCRIPTION: Demonstrates how to define API endpoints with path parameters. The example includes both a segment parameter ':id' and a wildcard parameter '*path' in the URL path.

LANGUAGE: typescript
CODE:
// Retrieves a blog post by its id.
export const getBlogPost = api(
    { method: "GET", path: "/blog/:id/*path" },
    async (params: {id: number; path: string}): Promise<BlogPost> {
        // Use id and path to query database...
    }
)

----------------------------------------

TITLE: Installing Required Firebase Modules with Go
DESCRIPTION: Commands to install the required Go modules for Firebase Authentication integration.

LANGUAGE: shell
CODE:
$ go get firebase.google.com/go/v4 go4.org/syncutil

----------------------------------------

TITLE: Linking Local App to Encore Platform
DESCRIPTION: Command to link a local Encore application with the server by specifying the app ID.

LANGUAGE: bash
CODE:
encore app link [app-id]

----------------------------------------

TITLE: Displaying Encore Environment Information
DESCRIPTION: Command to output environment information for the Encore daemon.

LANGUAGE: bash
CODE:
encore daemon env

----------------------------------------

TITLE: Loading Configuration with Encore's config.Load in Go
DESCRIPTION: Loads configuration using Encore's config.Load generic function with a Config pointer. This allows the service to access configuration values at runtime.

LANGUAGE: go
CODE:
var _ = config.Load[*Config]()

----------------------------------------

TITLE: Creating a Raw HTTP Endpoint in Encore
DESCRIPTION: Defines a raw HTTP endpoint using the encore:api annotation with the raw modifier. This approach gives direct access to the underlying HTTP request for webhook handling.

LANGUAGE: go
CODE:
package service

import "net/http"

//encore:api public raw method=POST path=/webhook
func Webhook(w http.ResponseWriter, req *http.Request) {
    // Handle raw HTTP request
}

----------------------------------------

TITLE: Creating New Encore Applications
DESCRIPTION: Command to create a new Encore application with the specified name.

LANGUAGE: bash
CODE:
encore app create [name]

----------------------------------------

TITLE: StreamOut API Type Signatures
DESCRIPTION: Type signature options for the StreamOut API function, showing variations with and without handshake types.

LANGUAGE: typescript
CODE:
api.streamOut<Handshake, Outgoing>(
  {...}, async (handshake, stream) => {...})

LANGUAGE: typescript
CODE:
api.streamOut<Outgoing>(
  {...}, async (stream) => {...})

----------------------------------------

TITLE: Defining a Public API Endpoint with Encore Framework in Go
DESCRIPTION: A simple Go code file defining a public API endpoint using Encore's annotation syntax. The code defines a structure for parameters and a function that serves as an API endpoint at path /foo/:id/*baz.

LANGUAGE: go
CODE:
package code

import "context"

type Params struct {
    String string
    Int int
}

//encore:api public path=/foo/:id/*baz
func Foo(ctx context.Context, id int, baz string, p *Params) error { return nil }

----------------------------------------

TITLE: Running All Semgrep Rules in Go
DESCRIPTION: Command to run all semgrep rules from the semgrep-go repository against the codebase. This targets the current directory for analysis using all available rules.

LANGUAGE: bash
CODE:
$ semgrep -f path/to/semgrep-go/ .

----------------------------------------

TITLE: Creating Service Directory Structure in Shell
DESCRIPTION: Shell commands to create the directory structure for the Slack service in an Encore application. Creates a 'slack' directory and an empty service definition file.

LANGUAGE: shell
CODE:
$ mkdir slack
$ touch slack/encore.service.ts

----------------------------------------

TITLE: Streaming Application Logs
DESCRIPTION: Streams logs from your application with options to specify environment and output format.

LANGUAGE: shell
CODE:
$ encore logs [--env=prod] [--json]

----------------------------------------

TITLE: Logging into DigitalOcean Container Registry
DESCRIPTION: Command to log into DigitalOcean's container registry using the DigitalOcean CLI.

LANGUAGE: bash
CODE:
doctl registry login

----------------------------------------

TITLE: Implementing a Connect Service in Go
DESCRIPTION: Implementation of the gRPC GreetService in Go using the connect-go library. This code defines a server that responds to greeting requests by returning a formatted greeting message with the provided name.

LANGUAGE: go
CODE:
package greet

import (
	"context"
	"fmt"
	"log"

	"connectrpc.com/connect"

	greetv1 "encore.app/gen/greet/v1" // generated by protoc-gen-go
)

type GreetServer struct{}

func (s *GreetServer) Greet(
	ctx context.Context,
	req *connect.Request[greetv1.GreetRequest],
) (*connect.Response[greetv1.GreetResponse], error) {
	log.Println("Request headers: ", req.Header())
	res := connect.NewResponse(&greetv1.GreetResponse{
		Greeting: fmt.Sprintf("Hello, %s!", req.Msg.Name),
	})
	res.Header().Set("Greet-Version", "v1")
	return res, nil
}

----------------------------------------

TITLE: Getting Object Attributes from a Storage Bucket
DESCRIPTION: Shows how to retrieve object information and check for existence using the attrs and exists methods. These are useful for validating files before processing them.

LANGUAGE: typescript
CODE:
const attrs = await profilePictures.attrs("my-image.jpeg");
const exists = await profilePictures.exists("my-image.jpeg");

----------------------------------------

TITLE: Creating SQL Migration for Monitor Database
DESCRIPTION: SQL migration script that creates a checks table to store the results of website uptime checks with timestamp information.

LANGUAGE: sql
CODE:
CREATE TABLE checks (
    id BIGSERIAL PRIMARY KEY,
    site_id BIGINT NOT NULL,
    up BOOLEAN NOT NULL,
    checked_at TIMESTAMP WITH TIME ZONE NOT NULL
);

----------------------------------------

TITLE: Installing Google's Process Snooper for GoLand Debugging
DESCRIPTION: Command to install the gops package, which is required for GoLand to attach to a running Go process for debugging.

LANGUAGE: shell
CODE:
go get -t github.com/google/gops/

----------------------------------------

TITLE: Disabling Telemetry Using CLI Command
DESCRIPTION: Demonstrates how to disable Encore telemetry using the CLI command, which is one of two methods available to users who wish to opt out of telemetry collection.

LANGUAGE: sh
CODE:
encore telemetry disable

----------------------------------------

TITLE: Example OAuth Token Response Format
DESCRIPTION: This JSON response example shows the structure of a successful token request response from the Encore Cloud OAuth endpoint. It includes the access_token (truncated for brevity), token_type (Bearer), expiration time in seconds (3600), and the actor identifier.

LANGUAGE: json
CODE:
{"access_token":"MTcyODQ3NTg3NXww...GDxfmxnuq9zDEAmHmP5D44=","token_type":"Bearer","expires_in":3600, "actor": "o2c_my_key_id"}

----------------------------------------

TITLE: Deleting Objects from a Storage Bucket
DESCRIPTION: Demonstrates how to delete objects from a storage bucket using the remove method. This example removes a specific file by name.

LANGUAGE: typescript
CODE:
await profilePictures.remove("my-image.jpeg");

----------------------------------------

TITLE: Cloning Encore Applications
DESCRIPTION: Command to clone an existing Encore application to your local machine by specifying the app ID and target directory.

LANGUAGE: bash
CODE:
encore app clone [app-id] [directory]

----------------------------------------

TITLE: Generated API Implementation and Request Handling in Go
DESCRIPTION: Comprehensive API implementation code generated by Encore that handles HTTP routing, parameter parsing, request/response encoding, and endpoint registration. This file connects the user-defined API function to the Encore runtime.

LANGUAGE: go
CODE:
package code

import (
	"context"
	__api "encore.dev/appruntime/apisdk/api"
	__etype "encore.dev/appruntime/shared/etype"
	jsoniter "github.com/json-iterator/go"
	"net/http"
	"net/url"
	"strings"
)

func init() {
	__api.RegisterEndpoint(EncoreInternal_api_APIDesc_Foo, Foo)
}

type EncoreInternal_FooReq struct {
	Payload *Params
	P0      int
	P1      string
}

type EncoreInternal_FooResp = __api.Void

var EncoreInternal_api_APIDesc_Foo = &__api.Desc[*EncoreInternal_FooReq, EncoreInternal_FooResp]{
	Access: __api.Public,
	AppHandler: func(ctx context.Context, reqData *EncoreInternal_FooReq) (EncoreInternal_FooResp, error) {
		err := Foo(ctx, reqData.P0, reqData.P1, reqData.Payload)
		if err != nil {
			return __api.Void{}, err
		}
		return __api.Void{}, nil
	},
	CloneReq: func(r *EncoreInternal_FooReq) (*EncoreInternal_FooReq, error) {
		var clone *EncoreInternal_FooReq
		bytes, err := jsoniter.ConfigDefault.Marshal(r)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return clone, err
	},
	CloneResp: func(r EncoreInternal_FooResp) (EncoreInternal_FooResp, error) {
		var clone EncoreInternal_FooResp
		bytes, err := jsoniter.ConfigDefault.Marshal(r)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return clone, err
	},
	DecodeExternalResp: func(httpResp *http.Response, json jsoniter.API) (resp EncoreInternal_FooResp, err error) {
		return __api.Void{}, nil
	},
	DecodeReq: func(httpReq *http.Request, ps __api.UnnamedParams, json jsoniter.API) (reqData *EncoreInternal_FooReq, pathParams __api.UnnamedParams, err error) {
		reqData = new(EncoreInternal_FooReq)
		dec := new(__etype.Unmarshaller)
		// Trim the leading slash from wildcard parameter, as Encore's semantics excludes it,
		// while the httprouter implementation includes it.
		ps[1] = strings.TrimPrefix(ps[1], "/")

		reqData.P0 = __etype.UnmarshalOne(dec, __etype.UnmarshalInt, "id", ps[0], true)
		if value, err := url.PathUnescape(ps[1]); err == nil {
			ps[1] = value
		}
		reqData.P1 = __etype.UnmarshalOne(dec, __etype.UnmarshalString, "baz", ps[1], true)
		params := new(Params)
		reqData.Payload = params
		switch m := httpReq.Method; m {
		case "POST":
			// Decode request body
			payload := dec.ReadBody(httpReq.Body)
			iter := jsoniter.ParseBytes(json, payload)

			for iter.ReadObjectCB(func(_ *jsoniter.Iterator, key string) bool {
				switch strings.ToLower(key) {
				case "string":
					dec.ParseJSON("String", iter, &params.String)
				case "int":
					dec.ParseJSON("Int", iter, &params.Int)
				default:
					_ = iter.SkipAndReturnBytes()
				}
				return true
			}) {
			}

		default:
			panic("HTTP method is not supported")
		}
		if err := dec.Error; err != nil {
			return nil, nil, err
		}
		return reqData, ps, nil
	},
	DefLoc: uint32(0x0),
	EncodeExternalReq: func(reqData *EncoreInternal_FooReq, stream *jsoniter.Stream) (httpHeader http.Header, queryString url.Values, err error) {
		params := reqData.Payload
		if params == nil {
			// If the payload is nil, we need to return an empty request body.
			return httpHeader, queryString, err
		}

		// Encode request body
		stream.WriteObjectStart()
		stream.WriteObjectField("String")
		stream.WriteVal(params.String)
		stream.WriteMore()
		stream.WriteObjectField("Int")
		stream.WriteVal(params.Int)
		stream.WriteObjectEnd()

		return httpHeader, queryString, err
	},
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, resp EncoreInternal_FooResp) (err error) {
		return nil
	},
	Endpoint:            "Foo",
	Fallback:            false,
	GlobalMiddlewareIDs: []string{},
	Methods:             []string{"POST"},
	Path:                "/foo/:id/*baz",
	PathParamNames:      []string{"id", "baz"},
	Raw:                 false,
	RawHandler:          nil,
	RawPath:             "/foo/:0/*1",
	ReqPath: func(reqData *EncoreInternal_FooReq) (string, __api.UnnamedParams, error) {
		params := __api.UnnamedParams{__etype.MarshalOne(__etype.MarshalInt, reqData.P0), __etype.MarshalOne(__etype.MarshalString, reqData.P1)}
		return "/foo" + "/" + url.PathEscape(params[0]) + "/" + url.PathEscape(params[1]), params, nil
	},
	ReqUserPayload: func(reqData *EncoreInternal_FooReq) any {
		return reqData.Payload
	},
	Service:           "code",
	ServiceMiddleware: []*__api.Middleware{},
	SvcNum:            1,
	Tags:              nil,
}

----------------------------------------

TITLE: Configuring Logto Authentication Settings in CUE
DESCRIPTION: A CUE configuration file for storing Logto authentication parameters including issuer URL, JWKS URI, API resource indicator, and client ID.

LANGUAGE: cue
CODE:
Issuer: "<your-logto-issuer-url>"
JwksUri: "<your-logto-issuer-url>/jwks"
ApiResourceIndicator: "<your-api-resource-indicator>"
ClientId: "<your-client-id>"

----------------------------------------

TITLE: TypeScript Configuration for Path Mapping
DESCRIPTION: Configures TypeScript path aliases for improved module imports. Maps the '~encore/*' path to './encore.gen/*' and '@bar/*' to './bar/*'.

LANGUAGE: json
CODE:
{
  "compilerOptions": {
    "paths": {
      "~encore/*": ["./encore.gen/*"],
      "@bar/*": ["./bar/*"]
    }
  }
}

----------------------------------------

TITLE: Defining Encore API Endpoint with Query Parameters in Go
DESCRIPTION: This code defines an Encore API endpoint named 'Foo' with parameter handling. It demonstrates the use of struct tags to configure query parameters, including how to ignore fields and handle arrays.

LANGUAGE: go
CODE:
package code

import "context"

type Params struct {
    Foo   string `query:"foo"`
    Ignore string `query:"-"`
    Ints []int `query:"ints"`
}

//encore:api public
func Foo(ctx context.Context, p *Params) error { return nil }

----------------------------------------

TITLE: Creating a New Encore Application
DESCRIPTION: Creates a new Encore application with the specified name.

LANGUAGE: shell
CODE:
$ encore app create [name]

----------------------------------------

TITLE: Logto Configuration File for Encore Integration
DESCRIPTION: This file defines the Logto configuration settings including endpoint, appId, and resources. It also includes appConfig with API resource indicator and redirect URIs, plus the Encore API endpoint for use throughout the application.

LANGUAGE: typescript
CODE:
import { LogtoConfig } from '@logto/react'

export const config: LogtoConfig = {
  endpoint: '<your-logto-endpoint>',
  appId: '<your-app-id>',
  resources: ['<your-api-resource-indicator>'],
}

export const appConfig = {
  apiResourceIndicator: '<your-api-resource-indicator>',
  signInRedirectUri: '<your-sign-in-redirect-uri>',
  signOutRedirectUri: '<your-sign-out-redirect-uri>',
}

export const encoreApiEndpoint = '<your-encore-api-endpoint>'

----------------------------------------

TITLE: Querying the Monitor Database with psql
DESCRIPTION: Example of using the Encore DB shell to connect to the monitor database and query the checks table to verify stored uptime check results.

LANGUAGE: shell
CODE:
$ encore db shell monitor
psql (14.4, server 14.2)
Type "help" for help.

monitor=> SELECT * FROM checks;
 id | site_id | up |          checked_at
----+---------+----+-------------------------------
  1 |       1 | t  | 2022-10-21 09:58:30.674265+00

----------------------------------------

TITLE: Restarting Encore Daemon
DESCRIPTION: Command to restart the Encore daemon, useful for resolving unexpected behavior.

LANGUAGE: bash
CODE:
encore daemon

----------------------------------------

TITLE: Basic Slack Cowsay Endpoint Implementation in Go
DESCRIPTION: A simple implementation of a public Encore API endpoint that handles Slack slash commands. It extracts the text from the form data and returns a formatted response with the cowsay output.

LANGUAGE: go
CODE:
// Service slack implements a cowsaw Slack bot.
package slack

import (
	"encoding/json"
	"fmt"
	"net/http"
)

// cowart is the formatting string for printing the cow art.
const cowart = "Moo! %s"

//encore:api public raw path=/cowsay
func Cowsay(w http.ResponseWriter, req *http.Request) {
	text := req.FormValue("text")
	data, _ := json.Marshal(map[string]string{
		"response_type": "in_channel",
		"text":          fmt.Sprintf(cowart, text),
	})
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)
	w.Write(data)
}

----------------------------------------

TITLE: Defining Recursive Data Structures in Go
DESCRIPTION: Defines three Go types (Recursive, MutualOne, and MutualTwo) that demonstrate various forms of recursive data structures, including self-recursion and mutual recursion between types.

LANGUAGE: go
CODE:
type Recursive struct {
    Basic []Recursive
    Pointer []*Recursive
    Mutual []MutualTwo
}

type MutualOne struct {
    Basic []MutualTwo
    Pointer []*MutualTwo
    Self []Recursive
    SelfPointer []*Recursive
}

type MutualTwo struct {
    Basic []MutualOne
    Pointer []*MutualOne
}

----------------------------------------

TITLE: Creating Migrations Directory
DESCRIPTION: Shell command to create a directory for database migrations.

LANGUAGE: shell
CODE:
$ mkdir user/migrations

----------------------------------------

TITLE: Configuring Vite for TypeScript Testing with Encore
DESCRIPTION: Setup configuration for Vite to work with Encore generated code. This configuration creates an alias for the Encore generated code and enables Vitest functionality for testing.

LANGUAGE: typescript
CODE:
/// <reference types="vitest" />
import { defineConfig } from "vite";
import path from "path";

export default defineConfig({
  resolve: {
    alias: {
      "~encore": path.resolve(__dirname, "./encore.gen"),
    },
  },
});

----------------------------------------

TITLE: Example Request Format for Encore.ts API Endpoint
DESCRIPTION: Shows the expected format of an HTTP request for an Encore.ts API endpoint that uses headers, query parameters, and a request body.

LANGUAGE: output
CODE:
POST /echo?query=hello HTTP/1.1
Content-Type: application/json
X-Header: this is a header
{
   "body": "a body",
}

----------------------------------------

TITLE: Implementing GitHub Actions Workflow for Encore Deployment to DigitalOcean
DESCRIPTION: A GitHub Actions workflow configuration that builds an Encore application into a Docker image and deploys it to DigitalOcean. The workflow installs the Encore CLI, builds the Docker image, and pushes it to DigitalOcean's container registry with the 'latest' tag.

LANGUAGE: yaml
CODE:
name: Build, Push and Deploy a Encore Docker Image to DigitalOcean

on:
  push:
    branches: [ main ]

permissions:
  contents: read
  packages: write

jobs:
  build-push-deploy-image:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download Encore CLI script
        uses: sozo-design/curl@v1.0.2
        with:
          args: --output install.sh -L https://encore.dev/install.sh

      - name: Install Encore CLI
        run: bash install.sh

      - name: Log in to DigitalOcean container registry
        run: docker login registry.digitalocean.com -u my-email@gmail.com -p ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}

      - name: Build Docker image
        run: /home/runner/.encore/bin/encore build docker myapp

      - name: Tag Docker image
        run: docker tag myapp registry.digitalocean.com/<YOUR_CONTAINER_REGISTRY_NAME>/<YOUR_IMAGE_REPOSITORY_NAME>:latest

      - name: Push Docker image
        run: docker push registry.digitalocean.com/<YOUR_CONTAINER_REGISTRY_NAME>/<YOUR_IMAGE_REPOSITORY_NAME>:latest

----------------------------------------

TITLE: Creating a Public Storage Bucket in Encore
DESCRIPTION: Demonstrates how to create a publicly accessible storage bucket. This example creates a non-versioned bucket with public access enabled, suitable for storing content that should be directly accessible.

LANGUAGE: typescript
CODE:
export const publicProfilePictures = new Bucket("public-profile-pictures", {
  public: true,
  versioned: false
});

----------------------------------------

TITLE: Building Docker Image for Deployment
DESCRIPTION: Command to build a Docker image from an Encore application for self-hosting and deployment to any environment.

LANGUAGE: shell
CODE:
$ encore build docker MY-IMAGE:TAG

----------------------------------------

TITLE: Generated Encore Service Interface for API Endpoint
DESCRIPTION: Encore auto-generated code that defines a service interface for the API endpoint. This code helps with mocking and provides type safety when making service-to-service calls within an Encore application.

LANGUAGE: go
CODE:
// Code generated by encore. DO NOT EDIT.

package code

import "context"

// These functions are automatically generated and maintained by Encore
// to simplify calling them from other services, as they were implemented as methods.
// They are automatically updated by Encore whenever your API endpoints change.

// Interface defines the service's API surface area, primarily for mocking purposes.
//
// Raw endpoints are currently excluded from this interface, as Encore does not yet
// support service-to-service API calls to raw endpoints.
type Interface interface {
	Foo(ctx context.Context, p *Params) error
}

----------------------------------------

TITLE: Defining an Encore API Endpoint
DESCRIPTION: Declares a public API endpoint using the encore:api directive. The function takes a context parameter and returns an error, with a simple implementation that returns nil.

LANGUAGE: Go
CODE:
//encore:api
func MyAPI(ctx context.Context) (error) {
	return nil
}

----------------------------------------

TITLE: Streaming Encore Application Logs
DESCRIPTION: Streams logs from your Encore application with options to specify environment and output format.

LANGUAGE: shell
CODE:
$ encore logs [--env=prod] [--json]

----------------------------------------

TITLE: Defining Service B with Dependency on Service A in Go
DESCRIPTION: Defines a service 'svcb' with a public API endpoint Bar() that imports and uses the database connection from service A.

LANGUAGE: go
CODE:
package svcb

import (
    "context"

    "test/svca"
)

//encore:api public
func Bar(ctx context.Context) error {
    _ = svca.Moo.Query()
    return nil
}

----------------------------------------

TITLE: Running an Encore Application
DESCRIPTION: Runs your application in the local development environment. Supports debug mode and file watching.

LANGUAGE: shell
CODE:
$ encore run [--debug] [--watch=true] [flags]

----------------------------------------

TITLE: Creating an Authenticated API Endpoint in Encore
DESCRIPTION: An example of a protected API endpoint that uses the Logto authentication handler to verify the user's identity and return a personalized greeting.

LANGUAGE: go
CODE:
package api

import (
	"context"
	"fmt"

	"encore.dev/beta/auth"
	"encore.dev/beta/errs"
)

//encore:api auth path=/api/hello
func Api(ctx context.Context) (*Response, error) {
	userId, hasUserId := auth.UserID()

	if !hasUserId {
		return nil, &errs.Error{
			Code:    errs.Internal,
			Message: "User ID not found",
		}
	}

	msg := fmt.Sprintf("Hello, %s!", userId)

	return &Response{Message: msg}, nil
}

type Response struct {
	Message string
}

----------------------------------------

TITLE: Final Deployment Commands for the Slack Bot
DESCRIPTION: Git commands to commit the improved application with security verification and enhanced cow art, then deploy it to Encore's cloud hosting.

LANGUAGE: shell
CODE:
$ git add -A .
$ git commit -m 'Verify webhook requests and improve art'
$ git push encore

----------------------------------------

TITLE: Configuring Drizzle ORM for Encore.ts
DESCRIPTION: Shows how to create a Drizzle configuration file for use with Encore.ts. This configuration specifies the output directory for migrations, the schema file, and the PostgreSQL dialect.

LANGUAGE: typescript
CODE:
import 'dotenv/config';
import { defineConfig } from 'drizzle-kit';

export default defineConfig({
  out: 'migrations',
  schema: 'schema.ts',
  dialect: 'postgresql',
});

----------------------------------------

TITLE: Resetting Encore Service Databases
DESCRIPTION: Command to reset databases for specified services in your Encore application.

LANGUAGE: bash
CODE:
encore db reset [service-names...]

----------------------------------------

TITLE: Implementing HMAC Verification for Slack Webhooks in Go
DESCRIPTION: Function that verifies incoming Slack webhook requests by checking timestamps to prevent replay attacks and validating signatures using HMAC-SHA256.

LANGUAGE: go
CODE:
// verifyRequest verifies that a request is coming from Slack.
func verifyRequest(req *http.Request) (body []byte, err error) {
	eb := errs.B().Code(errs.InvalidArgument)
	body, err = ioutil.ReadAll(req.Body)
	if err != nil {
		return nil, eb.Cause(err).Err()
	}

	// Compare timestamps to prevent replay attack
	ts := req.Header.Get("X-Slack-Request-Timestamp")
	threshold := int64(5 * 60)
	n, _ := strconv.ParseInt(ts, 10, 64)
	if diff := time.Now().Unix() - n; diff > threshold || diff < -threshold {
		return body, eb.Msg("message not recent").Err()
	}

	// Compare HMAC signature
	sig := req.Header.Get("X-Slack-Signature")
	prefix := "v0="
	if !strings.HasPrefix(sig, prefix) {
		return body, eb.Msg("invalid signature").Err()
	}
	gotMac, _ := hex.DecodeString(sig[len(prefix):])

	mac := hmac.New(sha256.New, []byte(secrets.SlackSigningSecret))
	fmt.Fprintf(mac, "v0:%s:", ts)
	mac.Write(body)
	expectedMac := mac.Sum(nil)
	if !hmac.Equal(gotMac, expectedMac) {
		return body, eb.Msg("bad mac").Err()
	}
	return body, nil
}

----------------------------------------

TITLE: Configuring GCP Pub/Sub in Encore
DESCRIPTION: JSON configuration for setting up Google Cloud Pub/Sub messaging in an Encore application. This example defines a user-events topic with a push subscription for user notifications, specifying the project ID, topic name, subscription name, and service account details.

LANGUAGE: json
CODE:
{
  "pubsub": [
    {
      "type": "gcp_pubsub",
      "project_id": "my-gcp-project",
      "topics": {
        "user-events": {
          "name": "user-events-topic",
          "project_id": "my-gcp-project",
          "subscriptions": {
            "user-notification": {
              "name": "user-notification-subscription",
              "push_config": {
                "id": "user-push",
                "service_account": "service-account@my-gcp-project.iam.gserviceaccount.com"
              }
            }
          }
        }
      }
    }
  ]
}

----------------------------------------

TITLE: Adding Test Script to Package.json for Encore
DESCRIPTION: Configuration for package.json to set up the test command using Vitest. This allows running tests with the 'encore test' command.

LANGUAGE: json
CODE:
{
  "scripts": {
    "test": "vitest"
  }
}

----------------------------------------

TITLE: Creating a Migration Generation Script
DESCRIPTION: Shell script that automates the process of generating new migrations by resetting the shadow database and running Atlas's migrate diff command.

LANGUAGE: shell
CODE:
-- blog/scripts/generate-migration --
#!/bin/bash
set -eu
DB_NAME=blog
MIGRATION_NAME=${1:-}

SCRIPT_DIR=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )

# Reset the shadow database
encore db reset --shadow $DB_NAME

# GORM executes Go code without initializing Encore when generating migrations,
# so configure the Encore runtime to be aware that this is expected.
export ENCORERUNTIME_NOPANIC=1

# Generate the migration
atlas migrate diff $MIGRATION_NAME --env local --dev-url "$(encore db conn-uri --shadow $DB_NAME)&search_path=public"

----------------------------------------

TITLE: Configuring Drizzle ORM for Encore.ts
DESCRIPTION: Shows how to create a Drizzle configuration file for use with Encore.ts. This configuration specifies the output directory for migrations, the schema file, and the PostgreSQL dialect.

LANGUAGE: typescript
CODE:
import 'dotenv/config';
import { defineConfig } from 'drizzle-kit';

export default defineConfig({
  out: 'migrations',
  schema: 'schema.ts',
  dialect: 'postgresql',
});

----------------------------------------

TITLE: Building Docker Image with Infrastructure Configuration
DESCRIPTION: Command to build a Docker image with a specific infrastructure configuration file for deployment.

LANGUAGE: bash
CODE:
encore build docker --config infra.config.json myapp

----------------------------------------

TITLE: Generated Service Interface for Mocking
DESCRIPTION: Auto-generated code by Encore that defines a service interface for mocking purposes. It includes the API surface of the service, making it easier to mock the service in tests.

LANGUAGE: go
CODE:
// Code generated by encore. DO NOT EDIT.

package basic

import "context"

// These functions are automatically generated and maintained by Encore
// to simplify calling them from other services, as they were implemented as methods.
// They are automatically updated by Encore whenever your API endpoints change.

// Interface defines the service's API surface area, primarily for mocking purposes.
//
// Raw endpoints are currently excluded from this interface, as Encore does not yet
// support service-to-service API calls to raw endpoints.
type Interface interface {
	Foo(ctx context.Context) error
}

----------------------------------------

TITLE: Defining an Encore API Endpoint in Go
DESCRIPTION: Declares a simple API endpoint using Encore's annotation system. The function takes a context parameter and returns an error, following standard Go API patterns.

LANGUAGE: go
CODE:
//encore:api
func MyAPI(ctx context.Context) (error) {
	return nil
}

----------------------------------------

TITLE: Setting Up Named SQL Database Reference
DESCRIPTION: A package that provides a named SQL database reference for use in the Encore application, using the sqldb package.

LANGUAGE: go
CODE:
package pkg

import (
    "context"

    "encore.dev/storage/sqldb"
)

var Moo = sqldb.Named("svc")

----------------------------------------

TITLE: Defining Global Middleware in Encore
DESCRIPTION: Defines a global middleware function that intercepts all API requests in an Encore application. This middleware currently passes the request through to the next handler without modification, serving as a template for custom middleware implementation.

LANGUAGE: go
CODE:
package global

import "encore.dev/middleware"

//encore:middleware global target=all
func Middleware(req middleware.Request, next middleware.Next) middleware.Response {
    return next(req)
}

----------------------------------------

TITLE: Testing the Modified API with cURL
DESCRIPTION: Command to test the API after making code changes, demonstrating Encore's hot-reload capability. The response now shows the updated greeting message.

LANGUAGE: shell
CODE:
$ curl http://localhost:4000/hello/world
{"Message": "Howdy, world!"}

----------------------------------------

TITLE: Creating a Go Encore Application
DESCRIPTION: Command to create a new Encore application using the Go hello-world example template.

LANGUAGE: bash
CODE:
encore app create --example=hello-world

----------------------------------------

TITLE: Defining Slack Signing Secret in Go
DESCRIPTION: Adding a structured secret variable in Go to store the Slack signing secret that will be used for webhook verification.

LANGUAGE: go
CODE:
var secrets struct {
	SlackSigningSecret string
}

----------------------------------------

TITLE: Generating Encore API Clients
DESCRIPTION: Command to generate API clients for Encore applications with support for multiple languages including Go, TypeScript, JavaScript, and OpenAPI specification.

LANGUAGE: bash
CODE:
encore gen client [app-id] [--env=name] [--lang=lang]

----------------------------------------

TITLE: Implementing Basic Slack Webhook Endpoint
DESCRIPTION: Initial implementation of the Slack webhook endpoint that handles /cowsay commands. Uses Encore's raw API handler to process the incoming webhook request and respond with formatted text for Slack.

LANGUAGE: typescript
CODE:
import { api } from "encore.dev/api";
import type { IncomingMessage } from "node:http";

// cowart is the formatting string for printing the cow art.
const cowart = (msg: string) => `Moo! ${msg}
`;

export const cowsay = api.raw(
  { expose: true, path: "/cowsay", method: "*" },
  async (req, resp) => {
    const body = await getBody(req);

    const text = new URLSearchParams(body).get("text");
    const msg = cowart(text || "Moo!");
    resp.setHeader("Content-Type", "application/json");
    resp.end(JSON.stringify({ response_type: "in_channel", text: msg }));
  },
);

// Extract the body from an incoming request.
function getBody(req: IncomingMessage): Promise<string> {
  return new Promise((resolve) => {
    const bodyParts: any[] = [];
    req
      .on("data", (chunk) => {
        bodyParts.push(chunk);
      })
      .on("end", () => {
        resolve(Buffer.concat(bodyParts).toString());
      });
  });
}

----------------------------------------

TITLE: Publishing Events to PubSub Topics in Encore
DESCRIPTION: Shows how to publish events to PubSub topics in Encore. This example publishes a signup event to a topic and then commits a transaction, demonstrating the pattern for reliable event publishing.

LANGUAGE: go
CODE:
if _, err := Signups.Publish(ctx, &SignupEvent{UserID: id}); err != nil {
    return err
}

if err := tx.Commit(); err != nil {
    return err
}

----------------------------------------

TITLE: Configuring AWS SNS/SQS in Encore
DESCRIPTION: JSON configuration for AWS SNS (Simple Notification Service) and SQS (Simple Queue Service) in an Encore application. References topics and queues by their Amazon Resource Names (ARNs) for integration with AWS resources.

LANGUAGE: json
CODE:
{
  "pubsub": [
    {
      "type": "aws_sns_sqs",
      "topics": {
        "my-topic": {
          "arn": "arn:aws:sns:us-east-1:123456789012:my-topic",
          "subscriptions": {
            "my-queue": {
              "arn": "arn:aws:sqs:us-east-1:123456789012:my-queue"
            }
          }
        }
      }
    }
  ]
}

----------------------------------------

TITLE: Starting Encore VPN Connection
DESCRIPTION: Sets up a secure VPN connection to access private environments.

LANGUAGE: shell
CODE:
$ encore vpn start

----------------------------------------

TITLE: Testing Slack notification API with cURL
DESCRIPTION: Command to test the Slack notification API using cURL by sending a test message to the configured webhook.

LANGUAGE: shell
CODE:
$ curl 'http://localhost:4000/slack.notify' -d '{"text": "Testing Slack webhook"}'

----------------------------------------

TITLE: Installing GORM and PostgreSQL Driver
DESCRIPTION: Command to install the required GORM packages and PostgreSQL driver for an Encore application.

LANGUAGE: shell
CODE:
go get -u gorm.io/gorm gorm.io/driver/postgres

----------------------------------------

TITLE: Checking Encore VPN Status
DESCRIPTION: Command to check the status of the Encore VPN connection.

LANGUAGE: bash
CODE:
encore vpn status

----------------------------------------

TITLE: Building Docker Image for Self-hosting
DESCRIPTION: Command to build a Docker image of the GraphQL application for self-hosting on custom infrastructure.

LANGUAGE: shell
CODE:
encore build docker graphql:v1.0

----------------------------------------

TITLE: Defining Scheduled Cron Jobs in Encore
DESCRIPTION: Shows how to define scheduled cron jobs in Encore applications. This example creates a job that runs every 2 hours to send welcome emails, with the job targeting a specific API endpoint.

LANGUAGE: go
CODE:
import "encore.dev/cron"

var _ = cron.NewJob("welcome-email", cron.JobConfig{
	Title:    "Send welcome emails",
	Every:    2 * cron.Hour,
	Endpoint: SendWelcomeEmail,
})

//encore:api private
func SendWelcomeEmail(ctx context.Context) error {
	// ...
	return nil
}

----------------------------------------

TITLE: Auto-Generated Middleware Registration Code
DESCRIPTION: Encore's internal code for registering the middleware. This generated code creates a middleware descriptor with metadata like the middleware's name, location, and invocation function.

LANGUAGE: go
CODE:
var EncoreInternal_middleware_middleware_Middleware = &__api.Middleware{
	DefLoc:  uint32(0x0),
	Global:  false,
	ID:      "example.com.Middleware",
	Invoke:  Middleware,
	Name:    "Middleware",
	PkgName: "basic",
}

----------------------------------------

TITLE: Type-specific Config Unmarshaler for Encore Config Struct
DESCRIPTION: Function that handles field-by-field unmarshaling of JSON data into the Config struct. Each field is processed according to its type, with special handling for complex types like time.Time, UUID, and byte arrays.

LANGUAGE: go
CODE:
func encoreInternalTypeConfigUnmarshaler_svc_Config(itr *jsoniter.Iterator, path []string) (obj Config) {
	itr.ReadObjectCB(func(itr *jsoniter.Iterator, field string) bool {
		switch field {
		case "Name":
			obj.Name = config.CreateValue[string](itr.ReadString(), append(path, "Name"))
		case "Port":
			obj.Port = config.CreateValue[uint16](itr.ReadUint16(), append(path, "Port"))
		case "ReadOnly":
			obj.ReadOnly = config.CreateValue[bool](itr.ReadBool(), append(path, "ReadOnly"))
		case "MagicNumber":
			obj.MagicNumber = config.CreateValue[int](itr.ReadInt(), append(path, "MagicNumber"))
		case "Start":
			obj.Start = config.CreateValue[time.Time](func() (rtn time.Time) {
				decoder := new(__etype.Unmarshaller)
				rtn = __etype.UnmarshalOne(decoder, __etype.UnmarshalTime, "value", itr.ReadString(), true)
				if err := decoder.Error; err != nil {
					panic(fmt.Sprintf("unable to decode the config: %v", err))
				}
				return
			}(), append(path, "Start"))
		case "ID":
			obj.ID = config.CreateValue[uuid.UUID](func() (rtn uuid.UUID) {
				decoder := new(__etype.Unmarshaller)
				rtn = __etype.UnmarshalOne(decoder, __etype.UnmarshalUUID, "value", itr.ReadString(), true)
				if err := decoder.Error; err != nil {
					panic(fmt.Sprintf("unable to decode the config: %v", err))
				}
				return
			}(), append(path, "ID"))
		case "PublicKey":
			obj.PublicKey = config.CreateValue[[]byte](func() (rtn []byte) {
				decoder := new(__etype.Unmarshaller)
				rtn = __etype.UnmarshalOne(decoder, __etype.UnmarshalBytes, "value", itr.ReadString(), true)
				if err := decoder.Error; err != nil {
					panic(fmt.Sprintf("unable to decode the config: %v", err))
				}
				return
			}(), append(path, "PublicKey"))
		case "AdminUsers":
			obj.AdminUsers = config.CreateValueList(config.ReadArray[string](itr, func(itr *jsoniter.Iterator, idx int) string {
				return itr.ReadString()
			}), append(path, "AdminUsers"))
		default:
			itr.Skip()
		}
		return true
	})
	return
}

----------------------------------------

TITLE: Creating SQL Migration in Encore Project
DESCRIPTION: An empty SQL migration file for database setup, marked as '1_dummy.up.sql'.

LANGUAGE: sql
CODE:


----------------------------------------

TITLE: Installing the Encore CLI
DESCRIPTION: Command to install the Encore CLI, which is required for developing with Encore. The specific installation command varies by operating system.

LANGUAGE: shell
CODE:
$ encore app create

----------------------------------------

TITLE: Implementing Pub/Sub with Encore.go
DESCRIPTION: A Go example showing how to create and use a Pub/Sub topic in Encore.go. This demonstrates topic definition with type parameters and publishing messages to the topic.

LANGUAGE: go
CODE:
import "encore.dev/pubsub"

type User struct { /* fields... */ }

var Signup = pubsub.NewTopic[*User]("signup", pubsub.TopicConfig{
  DeliveryGuarantee: pubsub.AtLeastOnce,
})

// Publish messages by calling a method
Signup.Publish(ctx, &User{...})

----------------------------------------

TITLE: Testing the Cowsay Endpoint with cURL
DESCRIPTION: A shell command to test the locally running Encore application's cowsay endpoint using cURL, demonstrating how to pass the 'text' parameter in the request.

LANGUAGE: shell
CODE:
$ curl http://localhost:4000/cowsay -d 'text=Eat your greens!'
{"response_type":"in_channel","text":"Moo! Eat your greens!"}

----------------------------------------

TITLE: Mocking Entire Service for Testing in Encore
DESCRIPTION: Shows how to mock an entire service for testing by providing a mock implementation of the service. The mock only needs to implement the methods that will be called during the test.

LANGUAGE: go
CODE:
func Test_Something(t *testing.T) {
    t.Parallel()
    
    et.MockService("products", &products.Service{
        SomeField: "a testing value",
    })
}

----------------------------------------

TITLE: Defining Pexels API Response Structure in Go
DESCRIPTION: Go struct that defines the expected response format from the Pexels API. It selects only the necessary fields needed for the frontend such as image IDs, URLs, and descriptions.

LANGUAGE: go
CODE:
type SearchResponse struct {
	Photos []struct {
		Id  int `json:"id"`
		Src struct {
			Medium    string `json:"medium"`
			Landscape string `json:"landscape"`
		} `json:"src"`
		Alt string `json:"alt"`
	} `json:"photos"`
}

----------------------------------------

TITLE: Updating Golden Tests with go test Command
DESCRIPTION: This command runs the tests in the clientgen package with the golden-update flag to update all expected output files after verifying the output is correct.

LANGUAGE: bash
CODE:
go test ./internal/clientgen -golden-update

----------------------------------------

TITLE: Updating Encore CLI
DESCRIPTION: Checks for updates to the Encore CLI and runs the appropriate command to update if available.

LANGUAGE: shell
CODE:
$ encore version update

----------------------------------------

TITLE: Defining Utility Configuration Types in Go
DESCRIPTION: Implements utility configuration types including ExtraConfig with String and Int configuration fields. These types are used by the main service configuration.

LANGUAGE: go
CODE:
package utils

import (
	"encore.dev/config"
)

type ExtraConfig struct{
    Foo config.String
    Bar config.Int
}

----------------------------------------

TITLE: Invalid Auth Handler Reference (Go)
DESCRIPTION: Attempts to directly call an auth handler from another package, which is not allowed in Encore. This code demonstrates the error case where svc2 package tries to call the MyAuth handler defined in the svc package.

LANGUAGE: go
CODE:
package svc2

import (
    "context"
    "test/svc"
)

func Foo() {
    svc.MyAuth(context.Background(), "foo")
}

----------------------------------------

TITLE: Connecting to Railway PostgreSQL Database
DESCRIPTION: Command to connect to a PostgreSQL database on Railway using the psql client, providing necessary authentication parameters.

LANGUAGE: bash
CODE:
PGPASSWORD=<password> psql -h <hostname>.rlwy.net -U postgres -p 39684 -d railway

----------------------------------------

TITLE: Creating Required API Endpoint for Service-Specific Middleware
DESCRIPTION: Defines a minimal API endpoint required to enable service-specific middleware. The encore:api directive marks this function as an API endpoint accessible to clients.

LANGUAGE: go
CODE:
//encore:api
func API(context.Context) error { return nil }

----------------------------------------

TITLE: Publishing Messages to PubSub Topic in Go with Encore
DESCRIPTION: Implements a service endpoint that publishes messages to the previously defined PubSub topic. This function is marked as an API endpoint using Encore's annotation.

LANGUAGE: go
CODE:
package svc

import (
    "context"

    "test/shared"
)

// encore:api
func DoStuff(ctx context.Context, msg *shared.MessageType) error {
    shared.BasicTopic.Publish(ctx, msg)
}

----------------------------------------

TITLE: Service-Local Middleware with Tag Target in Encore
DESCRIPTION: Defines a service-local middleware in Encore that targets APIs with the 'foo' tag. The middleware passes the request to the next handler without modification.

LANGUAGE: go
CODE:
//encore:middleware target=tag:foo
func TaggedInSvc(req middleware.Request, next middleware.Next) middleware.Response {
    return next(req)
}

----------------------------------------

TITLE: Generated Encore Service Registration
DESCRIPTION: Generated internal code for service registration in Encore. Defines how the service is registered with the Encore framework during initialization.

LANGUAGE: go
CODE:
package code

import __service "encore.dev/appruntime/apisdk/service"

func init() {
	__service.Register(EncoreInternal_svcstruct_Service)
}

var EncoreInternal_svcstruct_Service = &__service.Decl[Service]{
	Name:        "Service",
	Service:     "code",
	Setup:       nil,
	SetupDefLoc: uint32(0x0),
}

----------------------------------------

TITLE: Template Rendering in Express.js
DESCRIPTION: This snippet shows how to use Express.js's built-in template rendering capabilities with Pug as the view engine to render HTML templates.

LANGUAGE: typescript
CODE:
import express, {Request, Response} from "express";

const app: Express = express();

app.set("view engine", "pug"); // Set view engine to Pug

// Template engine example. This will render the index.pug file in the views directory
app.get("/html", (_, res) => {
  res.render("index", {title: "Hey", message: "Hello there!"});
});

----------------------------------------

TITLE: Implementing Pub/Sub with Encore.ts
DESCRIPTION: A TypeScript example demonstrating how to define a Pub/Sub topic in Encore.ts. This shows how to create a typed topic for signup events with an at-least-once delivery guarantee.

LANGUAGE: typescript
CODE:
import { Topic } "encore.dev/pubsub"

export interface SignupEvent {
    userID: string;
}

export const signups = new Topic<SignupEvent>("signups", {
    deliveryGuarantee: "at-least-once",
});

----------------------------------------

TITLE: Making the Script Executable and Generating Initial Migration
DESCRIPTION: Commands to make the migration generation script executable and run it to create the initial migration.

LANGUAGE: shell
CODE:
$ chmod +x blog/scripts/generate-migration
$ cd blog && ./scripts/generate-migration init

----------------------------------------

TITLE: Accessing Published Messages in Tests
DESCRIPTION: Example of how to access and assert on published messages during testing using the et.Topic helper.

LANGUAGE: go
CODE:
msgs := et.Topic(Signups).PublishedMessages()
assert.Len(t, msgs, 1)

----------------------------------------

TITLE: Using Generated TypeScript Client for API Calls
DESCRIPTION: Example of using the generated TypeScript client to make type-safe API calls to the Encore backend, either locally or to a deployed environment.

LANGUAGE: tsx
CODE:
import Client, { Environment, Local } from "src/client.ts";

// Making request to locally running backend...
const client = new Client(Local);
// or to a specific deployed environment
const client = new Client(Environment("staging"));

// Calling APIs as typesafe functions 🌟
const response = await client.note.GetNote("note-uuid");
console.log(response.id);
console.log(response.cover_url);
console.log(response.text);

----------------------------------------

TITLE: Prometheus Metrics Configuration
DESCRIPTION: Configuration for exporting metrics to Prometheus. Specifies the collection interval and remote write URL for sending metrics data to a Prometheus server.

LANGUAGE: json
CODE:
{
  "metrics": {
    "type": "prometheus",
    "collection_interval": 15,
    "remote_write_url": {
      "$env": "PROMETHEUS_REMOTE_WRITE_URL"
    }
  }
}

----------------------------------------

TITLE: Updating Encore CLI
DESCRIPTION: Command to check for and apply updates to the Encore CLI.

LANGUAGE: bash
CODE:
encore version update

----------------------------------------

TITLE: Enabling Telemetry Debug Mode via Environment Variable
DESCRIPTION: A shell command showing how to enable debug mode for Encore telemetry using an environment variable. This helps users see what data is being sent by displaying log statements when telemetry data is transmitted.

LANGUAGE: sh
CODE:
export ENCORE_TELEMETRY_DEBUG=1

----------------------------------------

TITLE: Tagging and Pushing Updated Docker Image
DESCRIPTION: Commands to tag and push the updated Docker image with database configuration to DigitalOcean's container registry.

LANGUAGE: bash
CODE:
docker tag myapp registry.digitalocean.com/YOUR_REGISTRY_NAME/myapp:latest
docker push registry.digitalocean.com/YOUR_REGISTRY_NAME/myapp:latest

----------------------------------------

TITLE: Service Package Definition with Imports in Go
DESCRIPTION: Defines the package and imports required for the service. It imports the context package from the standard library and the auth package from Encore's beta functionality.

LANGUAGE: go
CODE:
package svc

import (
    "context"
    "encore.dev/beta/auth"
)

----------------------------------------

TITLE: Creating a PostgreSQL Database on DigitalOcean
DESCRIPTION: SQL command to create a new database on the DigitalOcean PostgreSQL instance.

LANGUAGE: sql
CODE:
CREATE DATABASE mydb;

----------------------------------------

TITLE: Defining Basic Encore Service and API
DESCRIPTION: Defines a minimal Encore service structure with a simple API endpoint that returns nil. The service is marked with the encore:service annotation, and the API function is marked with encore:api annotation.

LANGUAGE: go
CODE:
package basic

import "context"

//encore:service
type Service struct {
}

//encore:api
func API(context.Context) error { return nil }

----------------------------------------

TITLE: Infrastructure Configuration for Self-Hosting with Encore
DESCRIPTION: JSON configuration for self-hosting an Encore application with PostgreSQL database connection details. The file defines SQL server connection parameters including host, database name, username, and a reference to an environment variable for the password.

LANGUAGE: json
CODE:
{
   "$schema": "https://encore.dev/schemas/infra.schema.json",
   "sql_servers": [
      {
         "host": "my-db-host:5432",
         "databases": {
            "url": {
               "username": "my-db-owner",
                "password": {"$env": "DB_PASSWORD"}
            }
         }
      }
   ]
}

----------------------------------------

TITLE: Example Response Format from Encore.ts API Endpoint
DESCRIPTION: Shows the format of an HTTP response from an Encore.ts API endpoint. Note that query parameters from the request are included in the response body since query strings only make sense for incoming requests.

LANGUAGE: output
CODE:
HTTP/1.1 200 OK
Content-Type: application/json
X-Header: this is a header
{
   "query": "hello",
   "body": "a body",
}

----------------------------------------

TITLE: Creating PostgreSQL Schema Migration for URL Storage
DESCRIPTION: Defines a SQL migration that creates a table for storing shortened URLs. The table includes an ID field as the primary key and the original URL.

LANGUAGE: sql
CODE:
CREATE TABLE url (
	id TEXT PRIMARY KEY,
	original_url TEXT NOT NULL
);

----------------------------------------

TITLE: Handling Errors in Encore.ts with APIError
DESCRIPTION: This snippet shows error handling in Encore.ts, where you can throw regular errors for 500 responses or use the APIError class to return specific error codes with appropriate messages.

LANGUAGE: typescript
CODE:
import {api, APIError} from "encore.dev/api"; // Default error handler

// Default error handler
export const broken = api(
  {expose: true, method: "GET", path: "/broken"},
  async (): Promise<void> => {
    throw new Error("This is a broken endpoint"); // This will result in a 500 error
  },
);

// Returning specific error code
export const brokenWithErrorCode = api(
  {expose: true, method: "GET", path: "/broken/:id"},
  async ({id}: { id: string }): Promise<{ user: string }> => {
    if (id.length !== 3) {
      throw APIError.invalidArgument("invalid id format");
    }
    // TODO: Fetch something from the DB
    return {user: "Simon"};
  },
);

----------------------------------------

TITLE: Configuring CORS Settings in encore.app JSON Configuration
DESCRIPTION: This JSON snippet shows how to configure CORS settings in the encore.app file. It demonstrates setting allowed origins for requests with and without credentials, including support for wildcard domains.

LANGUAGE: json
CODE:
global_cors: {
  // allow_origins_without_credentials specifies the allowed origins for requests
  // that don't include credentials. If nil it defaults to allowing all domains
  // (equivalent to ["*"]).
  "allow_origins_without_credentials": [
    "<ORIGIN-GOES-HERE>"
  ],

  // allow_origins_with_credentials specifies the allowed origins for requests
  // that include credentials. If a request is made from an Origin in this list
  // Encore responds with Access-Control-Allow-Origin: <Origin>.
  //
  // The URLs in this list may include wildcards (e.g. "https://*.example.com"
  // or "https://*-myapp.example.com").
  "allow_origins_with_credentials": [
    "<DOMAIN-GOES-HERE>"
  ]
}

----------------------------------------

TITLE: Setting Encore Secrets
DESCRIPTION: Command to set secret values in Encore applications with different environment types (production, development, preview, local).

LANGUAGE: bash
CODE:
encore secret set --type types secret-name

----------------------------------------

TITLE: Working with Path Parameters in Raw HTTP Endpoints
DESCRIPTION: Demonstrates how to access URL path parameters in raw HTTP endpoints using encore.CurrentRequest. This example extracts an ID parameter from the URL path.

LANGUAGE: go
CODE:
//encore:api public raw method=POST path=/webhook/:id
func Webhook(w http.ResponseWriter, req *http.Request) {
    id := encore.CurrentRequest().PathParams.Get("id")
    // Process with id
}

----------------------------------------

TITLE: Creating PostgreSQL Schema Migration for URL Storage
DESCRIPTION: Defines a SQL migration that creates a table for storing shortened URLs. The table includes an ID field as the primary key and the original URL.

LANGUAGE: sql
CODE:
CREATE TABLE url (
	id TEXT PRIMARY KEY,
	original_url TEXT NOT NULL
);

----------------------------------------

TITLE: Adding Client Generation Scripts to package.json
DESCRIPTION: NPM scripts for generating TypeScript clients for both local development and staging environments, making it easier to keep frontend API calls in sync with backend changes.

LANGUAGE: json
CODE:
{
...
"scripts": {
    ...
    "generate-client:staging": "encore gen client <Encore app id here> --output=./src/client.ts --env=staging",
    "generate-client:local": "encore gen client <Encore app id here> --output=./src/client.ts --env=local"
  },
}

----------------------------------------

TITLE: Querying Monitor Database with Encore CLI
DESCRIPTION: Shell command using the Encore CLI to connect to the monitor database and query the checks table to verify recorded uptime checks.

LANGUAGE: shell
CODE:
$ encore db shell monitor
psql (14.4, server 14.2)
Type "help" for help.

monitor=> SELECT * FROM checks;
 id | site_id | up |          checked_at
----+---------+----+-------------------------------
  1 |       1 | t  | 2022-10-21 09:58:30.674265+00

----------------------------------------

TITLE: Connecting to DigitalOcean PostgreSQL Database
DESCRIPTION: Command to connect to a PostgreSQL database hosted on DigitalOcean using the psql client.

LANGUAGE: bash
CODE:
psql -h mydb.db.ondigitalocean.com -U doadmin -d mydb -p 25060

----------------------------------------

TITLE: Configuring Cache Keyspace with Unused Field Error in Go
DESCRIPTION: This snippet demonstrates a cache keyspace configuration where the 'Bar' field in the Key struct is not referenced in the KeyPattern, causing a validation error. The error shows Encore's type safety for cache key patterns.

LANGUAGE: go
CODE:
package svc

import (
    "context"

    "encore.dev/storage/cache"
)

var cluster = cache.NewCluster("cluster", cache.ClusterConfig{})

type Key struct {
    ID int
    Bar string
}

var keyspace = cache.NewStringKeyspace[Key](cluster, cache.KeyspaceConfig{
    KeyPattern: "foo/:ID",
})

//encore:api public
func Foo(context.Context) error {
    return nil
}

----------------------------------------

TITLE: PostgreSQL with PostGIS Dockerfile for Express.js
DESCRIPTION: Custom Dockerfile that extends the base PostgreSQL image to include PostGIS extension support. This file is referenced in the Docker Compose configuration for creating a specialized database container.

LANGUAGE: dockerfile
CODE:
FROM postgres:latest

# Install PostGIS extension
RUN apt-get update \
    && apt-get install -y postgis postgresql-12-postgis-3 \
    && apt-get clean \
    && rm -rf /var/lib/apt/lists/*

# To execute some initial queries, we can write queries in init.sql
COPY init.sql /docker-entrypoint-initdb.d/

# Enable PostGIS extension
RUN echo "CREATE EXTENSION IF NOT EXISTS postgis;" >> /docker-entrypoint-initdb.d/init.sqld

----------------------------------------

TITLE: Generated Application Main Entry Point
DESCRIPTION: Encore generates a standard main function that initializes and runs the application using the Encore runtime. This connects user-defined services to the Encore runtime.

LANGUAGE: go
CODE:
package main

import (
	appinit "encore.dev/appruntime/apisdk/app/appinit"
	_ "example.com"
)

func main() {
	appinit.AppMain()
}

----------------------------------------

TITLE: Demonstrating Type Inference Examples in TypeScript
DESCRIPTION: Shows practical examples of the Iface type in use. Demonstrates successful type extraction (resulting in 'string'), failing extraction (resulting in 'never'), and a direct inline implementation of the conditional type logic.

LANGUAGE: typescript
CODE:
export type Infer1 = Iface<{ X: string }>; // string
export type Infer2 = Iface<{ Y: string }>; // never
export type Infer3 = { X: string } extends { X: infer A } ? A : never; // string

----------------------------------------

TITLE: Encore Static Configuration Documentation
DESCRIPTION: A synthetic file documenting the generated static configuration for the Encore application. It includes PubSub topic information, service mapping for testing, and other configuration details.

LANGUAGE: go
CODE:
package synthetic

/*

This is a synthetic file describing the generated static config:

{
	"EncoreCompiler": "",
	"AppCommit": {
		"revision": "",
		"uncommitted": false
	},
	"CORSAllowHeaders": null,
	"CORSExposeHeaders": null,
	"PubsubTopics": {
		"topic": {
			"Subscriptions": {
				"subscription": {
					"Service": "code",
					"SvcNum": 1,
					"TraceIdx": 0
				}
			}
		}
	},
	"Testing": false,
	"TestServiceMap": {
		"code": "testing_path:code"
	},
	"TestAppRootPath": "testing_path:main",
	"PrettyPrintLogs": false,
	"BundledServices": [
		"code"
	],
	"EmbeddedEnvs": {}
}
*/

----------------------------------------

TITLE: Configuring TypeScript paths for Encore
DESCRIPTION: TSConfig configuration to set up path aliases for Encore's generated files, allowing the use of ~encore/* imports.

LANGUAGE: json
CODE:
{
  "compilerOptions": {
    "paths": {
      "~encore/*": [
        "./encore.gen/*"
      ]
    }
  }
}

----------------------------------------

TITLE: Configuring Atlas for GORM Integration
DESCRIPTION: Atlas configuration file that sets up external schema integration with GORM and defines migration settings for the Encore application.

LANGUAGE: hcl
CODE:
-- blog/atlas.hcl --
data "external_schema" "gorm" {
  program = ["env", "ENCORERUNTIME_NOPANIC=1", "go", "run", "./scripts/atlas-gorm-loader.go"]
}

env "local" {
  src = data.external_schema.gorm.url

  migration {
    dir = "file://migrations"
    format = golang-migrate
  }

  format {
    migrate {
      diff = "{{ sql . \"  \" }}"
    }
  }
}

----------------------------------------

TITLE: Unarchiving Encore Secrets
DESCRIPTION: Command to unarchive a previously archived secret value in Encore by specifying its ID.

LANGUAGE: bash
CODE:
encore secret unarchive id

----------------------------------------

TITLE: Setting Up Named SQL Database Connection
DESCRIPTION: A test file that imports the sqldb package from Encore and creates a named database connection. The database is named 'svc', indicating it's likely used by the service defined in the previous snippet.

LANGUAGE: go
CODE:
package pkg

import (
    "context"

    "encore.dev/storage/sqldb"
)

var Moo = sqldb.Named("svc")

----------------------------------------

TITLE: CLI Commands for Service Setup and Testing
DESCRIPTION: Shell commands for creating directories, files, starting the Encore application, testing the API endpoint with curl, and verifying database storage.

LANGUAGE: shell
CODE:
$ mkdir url
$ touch url/encore.service.ts

LANGUAGE: shell
CODE:
$ touch url/url.ts

LANGUAGE: shell
CODE:
$ encore run

LANGUAGE: shell
CODE:
$ curl http://localhost:4000/url -d '{"url": "https://encore.dev"}'

LANGUAGE: shell
CODE:
$ mkdir url/migrations
$ touch url/migrations/001_create_tables.up.sql

LANGUAGE: shell
CODE:
$ encore db shell url
psql (13.1, server 11.12)
Type "help" for help.

url=# select * from url;
    id    |    original_url
----------+--------------------
 zr6RmZc4 | https://encore.dev
(1 row)

----------------------------------------

TITLE: Configuring Vite Base Path for GitHub Pages
DESCRIPTION: Configuration setting for the Vite build tool to specify the base path for assets when deploying to GitHub Pages. The base property should match your repository name.

LANGUAGE: yaml
CODE:
base: "/my-repo-name/",

----------------------------------------

TITLE: Running an Encore Backend Locally
DESCRIPTION: Commands to navigate to the application directory and run the Encore backend locally. This starts up the development server with all required infrastructure.

LANGUAGE: shell
CODE:
$ cd you-app-name # replace with the app name you picked
$ encore run

----------------------------------------

TITLE: Stopping Encore VPN Connection
DESCRIPTION: Stops the active Encore VPN connection.

LANGUAGE: shell
CODE:
$ encore vpn stop

----------------------------------------

TITLE: Pushing Docker Image to DigitalOcean Registry
DESCRIPTION: Command to push the tagged Docker image to DigitalOcean's container registry for deployment.

LANGUAGE: bash
CODE:
docker push registry.digitalocean.com/YOUR_REGISTRY_NAME/myapp:latest

----------------------------------------

TITLE: Defining Metrics Output Format
DESCRIPTION: Shows the expected output format for metrics defined in the application. Includes both a simple gauge metric and a gauge with labels.

LANGUAGE: plaintext
CODE:
parse
output 'metric gauge FLOAT64 GAUGE \[\]'
output 'metric gauge_with_labels FLOAT64 GAUGE \[label STRING Label doc string.\n\]'

----------------------------------------

TITLE: Example of Unimplemented Resolver Method
DESCRIPTION: Sample of an unimplemented resolver method that is generated by gqlgen and needs to be filled in with actual implementation.

LANGUAGE: go
CODE:
// Shorten is the resolver for the shorten field.
func (r *mutationResolver) Shorten(ctx context.Context, input string) (*url.URL, error) {
	panic(fmt.Errorf("not implemented: Shorten - shorten"))
}

----------------------------------------

TITLE: Service A Database Migration File
DESCRIPTION: Empty SQL migration file for service A's database, likely to be filled with schema definitions.

LANGUAGE: sql
CODE:
-- svca/migrations/1_foo.up.sql --

----------------------------------------

TITLE: Defining Encore Service with Public API Endpoints
DESCRIPTION: Declaration of a service module with public raw HTTP API endpoints using Encore annotations. Contains a standalone function and a method on a service struct that handle HTTP requests directly.

LANGUAGE: go
CODE:
package code
import "net/http"

//encore:api public raw
func Foo(w http.ResponseWriter, req *http.Request) {}

//encore:service
type Service struct{}

//encore:api public raw
func (s *Service) Bar(w http.ResponseWriter, req *http.Request) {}

----------------------------------------

TITLE: Creating Global Tag-Targeted Middleware
DESCRIPTION: Defines a global middleware function that targets only API endpoints tagged with 'foo'. This middleware is marked as global and defined outside of a service package.

LANGUAGE: go
CODE:
//encore:middleware global target=tag:foo
func TaggedInSvc(req middleware.Request, next middleware.Next) middleware.Response {
    return next(req)
}

----------------------------------------

TITLE: Creating a PostgreSQL Table and Inserting Data
DESCRIPTION: SQL commands to create a users table with id and name fields, and insert an initial record.

LANGUAGE: sql
CODE:
CREATE TABLE users (
   id SERIAL PRIMARY KEY,
   name VARCHAR(50)
);
INSERT INTO users (name) VALUES ('Alice');

----------------------------------------

TITLE: Generating Connect Service Code with Buf
DESCRIPTION: Commands to lint and generate Go code from Protobuf definitions using the buf tool. This generates the necessary client and server code for the Connect protocol.

LANGUAGE: shell
CODE:
$ buf lint
$ buf generate

----------------------------------------

TITLE: Creating New Encore Account
DESCRIPTION: Command to create a new user account on the Encore platform.

LANGUAGE: bash
CODE:
encore auth signup

----------------------------------------

TITLE: Defining a public API endpoint in Encore
DESCRIPTION: Defines a public API endpoint 'One' in package 'one' using the Encore framework. The function takes a context parameter and returns an error.

LANGUAGE: go
CODE:
//encore:api public
func One(ctx context.Context) error {
    return nil
}

----------------------------------------

TITLE: Testing URL Retrieval with curl
DESCRIPTION: Shell command to test the URL retrieval endpoint on the local development server using curl. It demonstrates how to make a GET request to the endpoint with a previously generated URL ID.

LANGUAGE: shell
CODE:
$ curl http://localhost:4000/url/your-id-from-the-previous-step

----------------------------------------

TITLE: Creating a Storage Bucket in Encore
DESCRIPTION: Demonstrates how to create a storage bucket for file storage. This example creates a non-versioned bucket named 'profile-pictures' that can be used to store user profile images.

LANGUAGE: typescript
CODE:
import { Bucket } from "encore.dev/storage/objects";

export const profilePictures = new Bucket("profile-pictures", {
  versioned: false
});

----------------------------------------

TITLE: Managing Namespaces with Encore CLI
DESCRIPTION: Examples of basic namespace management commands in Encore CLI, including listing, creating, switching between, and deleting namespaces. The snippet demonstrates the syntax for each operation and notes that 'encore ns' can be used as a shorthand for 'encore namespace'.

LANGUAGE: shell
CODE:
# List your namespaces (* indicates the current namespace)
$ encore namespace list

# Create a new namespace
$ encore namespace create my-ns

# Switch to a namespace
$ encore namespace switch my-ns

# Switch to a namespace, creating it if it doesn't exist
$ encore namespace switch --create my-ns

# Switch to the previous namespace
$ encore namespace switch -

# Delete a namespace (and all associated data)
$ encore namespace delete my-ns

----------------------------------------

TITLE: Disabling Telemetry via Environment Variable
DESCRIPTION: A shell command showing how to disable Encore telemetry by setting an environment variable. This provides an alternative method for users who prefer environment-based configuration.

LANGUAGE: sh
CODE:
export DISABLE_ENCORE_TELEMETRY=1

----------------------------------------

TITLE: Creating PubSub Topic and Subscription without Required DeliveryGuarantee Field in Go
DESCRIPTION: This code snippet shows an incorrect implementation of PubSub in Encore, where a topic is created without the required DeliveryGuarantee field in TopicConfig. This results in a compilation error as Encore requires this field to be explicitly set to either pubsub.AtLeastOnce or pubsub.ExactlyOnce.

LANGUAGE: go
CODE:
package svc

import (
    "context"

    "encore.dev/pubsub"
)

type MessageType struct {
    Name string
}

var (
    BasicTopic = pubsub.NewTopic[*MessageType]("basic-topic", pubsub.TopicConfig{})
    _ = pubsub.NewSubscription(BasicTopic, "basic-subscription", pubsub.SusbcriptionConfig { Handler: Subscriber })
)

// encore:api
func DoStuff(ctx context.Context) error {
    return BasicTopic.Publish(ctx, &MessageType{Name: "foo"})
}

func Subscriber(ctx context.Context, msg *MessageType) error {
    return nil
}

----------------------------------------

TITLE: Creating a Cache Cluster with Invalid Configuration in Go
DESCRIPTION: Attempts to initialize a cache cluster with an invalid eviction policy ('x'). This will result in an error during Encore processing as 'x' is not a valid eviction policy value.

LANGUAGE: go
CODE:
var b = cache.NewCluster( // ERR invalid "EvictionPolicy" value: "x"
    "foo", cache.ClusterConfig{
        EvictionPolicy: "x",
    },
)

----------------------------------------

TITLE: Generated Service-to-Service API Call Wrappers
DESCRIPTION: Auto-generated code that provides internal functions for cross-service API calls, replacing direct function calls with API calls through Encore's runtime.

LANGUAGE: go
CODE:
package svca

import (
	"context"
	__api "encore.dev/appruntime/apisdk/api"
)

func EncoreInternal_apicalls_Foo(ctx context.Context) error {
	_, err := EncoreInternal_api_APIDesc_Foo.Call(__api.NewCallContext(ctx), &EncoreInternal_FooReq{})
	if err != nil {
		return err
	}
	return nil
}

----------------------------------------

TITLE: Creating Migrations Directory for Site Service
DESCRIPTION: Shell command to create a migrations directory for the site service database.

LANGUAGE: shell
CODE:
$ mkdir site/migrations

----------------------------------------

TITLE: Defining a Public API Endpoint in Encore
DESCRIPTION: Defines a basic Encore service with a Params struct and a public API endpoint named Foo. The endpoint takes a context and Params pointer and returns an error.

LANGUAGE: go
CODE:
package basic

import "context"

type Params struct {
    String string   `json:",omitempty"`
    Array  [3]byte  `json:",omitempty"`
    Int int
}

//encore:api public
func Foo(ctx context.Context, p *Params) error { return nil }

----------------------------------------

TITLE: Building a Docker Image for an Encore App
DESCRIPTION: Command to build a Docker image from an Encore application for deployment to DigitalOcean.

LANGUAGE: bash
CODE:
encore build docker myapp

----------------------------------------

TITLE: Configuring AWS S3 in Encore
DESCRIPTION: JSON configuration for setting up AWS S3 object storage in an Encore application. This example defines an S3 bucket in the us-east-1 region with an optional key prefix and public base URL for CDN access. The configuration specifies the bucket name and region.

LANGUAGE: json
CODE:
{
  "object_storage": [
    {
      "type": "s3",
      "region": "us-east-1",
      "buckets": {
        "my-s3-bucket": {
          "name": "my-s3-bucket",
          "key_prefix": "my-optional-prefix/",
          "public_base_url": "https://my-gcs-bucket-cdn.example.com/my-optional-prefix"
        }
      }
    }
  ]
}

----------------------------------------

TITLE: Defining a Public API Endpoint using Encore in Go
DESCRIPTION: Implements a public API endpoint using Encore's annotation-based approach. The endpoint is defined at path '/foo/bar' and is marked as publicly accessible. The function simply returns nil to indicate success.

LANGUAGE: Go
CODE:
package svc

import "context"

//encore:api public path=/foo/bar
func API(ctx context.Context) error { return nil }

----------------------------------------

TITLE: Configuring GraphQL Resolvers Index
DESCRIPTION: Sets up the main resolvers configuration by importing and combining query and mutation resolvers. This file exports the combined resolvers object that will be used by Apollo Server.

LANGUAGE: typescript
CODE:
import { Resolvers } from "../__generated__/resolvers-types";
import Query from "./queries.js";
import Mutation from "./mutations.js";

const resolvers: Resolvers = { Query, Mutation };

export default resolvers;

----------------------------------------

TITLE: Broadcasting Messages to All Connected Clients
DESCRIPTION: Implementation of a chat service using StreamInOut that maintains a map of connected clients and broadcasts messages to all connected users. Includes handling of client disconnections and error scenarios.

LANGUAGE: typescript
CODE:
import { api, StreamInOut } from "encore.dev/api";

// Map to hold all connected streams
const connectedStreams: Map<
  string,
  StreamInOut<ChatMessage, ChatMessage>
> = new Map();

// Object sent from the client to the server when establishing a connection
interface HandshakeRequest {
  id: string;
}

// Object by both server and client
interface ChatMessage {
  username: string;
  msg: string;
}

export const chat = api.streamInOut<HandshakeRequest, ChatMessage, ChatMessage>(
  { expose: true, auth: false, path: "/chat" },
  async (handshake, stream) => {
    connectedStreams.set(handshake.id, stream);

    try {
      // The stream object is an AsyncIterator that yields incoming messages.
      // The loop will continue as long as the client keeps the connection open.
      for await (const chatMessage of stream) {
        for (const [key, val] of connectedStreams) {
          try {
            // Send the users message to all connected clients.
            await val.send(chatMessage);
          } catch (err) {
            // If there is an error sending the message, remove the client from the map.
            connectedStreams.delete(key);
          }
        }
      }
    } catch (err) {
      // If there is an error reading from the stream, remove the client from the map.
      connectedStreams.delete(handshake.id);
    }

    // When the client disconnects, remove them from the map.
    connectedStreams.delete(handshake.id);
  },
);

----------------------------------------

TITLE: Tagging API Endpoints in Encore
DESCRIPTION: Demonstrates how to tag an API endpoint with 'cache' to be targeted by specific middleware. This example defines a public GET endpoint for retrieving user information by ID.

LANGUAGE: go
CODE:
//encore:api public method=GET path=/user/:id tag:cache
func GetUser(ctx context.Context, id string) (*User, error) {
    // Implementation
}

----------------------------------------

TITLE: Creating Structured Errors in Encore
DESCRIPTION: Demonstrates how to create structured errors using the errs.Error type with proper error code and message.

LANGUAGE: go
CODE:
return &errs.Error{
    Code: errs.NotFound,
    Message: "sprocket not found",
}

----------------------------------------

TITLE: Disabling Telemetry via CLI Command
DESCRIPTION: Command to disable telemetry data collection using Encore's CLI, providing a simple way for users to opt out of data collection.

LANGUAGE: sh
CODE:
encore telemetry disable

----------------------------------------

TITLE: Invalid Reference of pubsub.NewTopic in Go
DESCRIPTION: This snippet shows an incorrect usage of the pubsub.NewTopic function in Encore. The error occurs because pubsub.NewTopic can only be called directly to create a new topic instance, not referenced or assigned to a variable. The proper pattern would be to directly call pubsub.NewTopic with the topic name.

LANGUAGE: go
CODE:
package svc

import (
    "context"

    "encore.dev/pubsub"
)

type MyMessage struct {}

var creator = pubsub.NewTopic[MyMessage]

var topic = creator("my-topic")

----------------------------------------

TITLE: Defining Service Configuration Structure in Go
DESCRIPTION: Defines a Config struct with various fields including strings, integers, booleans, UUIDs, and byte slices. Each field has descriptive comments explaining its purpose, with more detailed multi-line comments for complex fields.

LANGUAGE: go
CODE:
type Config struct {
    Name        string    // The users name
    Port        uint16
    ReadOnly    bool      // true if we're in read only mode

    // MagicNumber is complicated and requires
    // a multi-line comment to explain it.
    MagicNumber int

    ID          uuid.UUID // An ID

    PublicKey []byte
}

----------------------------------------

TITLE: Implementing Cloud Provider-Specific Behavior in Encore.ts
DESCRIPTION: Demonstrates how to use appMeta() to detect the current cloud provider and implement different behavior based on AWS, GCP, or local environments. This function provides a unified audit interface that routes data to the appropriate storage system.

LANGUAGE: typescript
CODE:
import { appMeta } from "encore.dev";

async function audit(userID: string, event: Record<string, any>) {
  const cloud = appMeta().environment.cloud;
  switch (cloud) {
    case "aws": return writeIntoRedshift(userID, event);
    case "gcp": return writeIntoBigQuery(userID, event);
    case "local": return writeIntoFile(userID, event);
    default: throw new Error(`unknown cloud: ${cloud}`);
  }
}

----------------------------------------

TITLE: Configuring Encore Terraform Provider
DESCRIPTION: Declares the Encore Terraform provider in the required_providers block, which is necessary for Terraform to download and use the provider when running terraform init.

LANGUAGE: terraform
CODE:
terraform {
  required_providers {
    encore = {
      source = "registry.terraform.io/encoredev/encore"
    }
  }
}

----------------------------------------

TITLE: Testing Database Connection API Endpoint
DESCRIPTION: cURL command to test the database connection by calling the getUser API endpoint with ID 1, verifying that the database integration is working correctly.

LANGUAGE: bash
CODE:
curl https://myapp.railway.app/names/1

----------------------------------------

TITLE: Express.js Docker Compose Configuration for PostgreSQL
DESCRIPTION: Docker Compose configuration for setting up a PostgreSQL database to use with Express.js. Defines database credentials, healthcheck settings, and volume persistence that must be manually created and maintained.

LANGUAGE: yaml
CODE:
version: '3.8'

services:
  db:
    build:
      context: .
      dockerfile: Dockerfile.postgis  # Use custom Dockerfile
    restart: always
    environment:
      POSTGRES_USER: user1
      POSTGRES_PASSWORD: user1@123
      POSTGRES_DB: database
    healthcheck:
      # This command checks if the database is ready, right on the source db server
      test: [ "CMD-SHELL", "pg_isready" ]
      interval: 5s
      timeout: 5s
      retries: 5
    ports:
      - "5432:5432"
    volumes:
      - postgres_data_v:/var/lib/postgresql/data
volumes:
  postgres_data_v:

----------------------------------------

TITLE: Defining API with Auth Directive in Go
DESCRIPTION: A simple Go service definition that incorrectly uses the 'auth' directive on an API endpoint without defining an auth handler, which will trigger an error in the Encore framework.

LANGUAGE: go
CODE:
package svc

import "context"

//encore:api auth
func API(ctx context.Context) error { return nil }

----------------------------------------

TITLE: Creating and Incrementing a Counter in Go with Encore
DESCRIPTION: This snippet demonstrates how to create a new counter metric and increment it within a function. The example creates a counter for tracking processed orders and increments it during order processing.

LANGUAGE: go
CODE:
import "encore.dev/metrics"

var OrdersProcessed = metrics.NewCounter[uint64]("orders_processed", metrics.CounterConfig{})

func process(order *Order) {
    // ...
    OrdersProcessed.Increment()
}

----------------------------------------

TITLE: Package-Level API Mocking in Encore
DESCRIPTION: Demonstrates how to mock an API endpoint for all tests in a package using TestMain. This approach applies the mock configuration to all tests in the package and can be modified at any time.

LANGUAGE: go
CODE:
func TestMain(m *testing.M) {
    et.MockEndpoint(products.GetPrice, func(ctx context.Context, p *products.PriceParams) (*products.PriceResponse, error) {
        return &products.PriceResponse{Price: 100}, nil
    })
    os.Exit(m.Run())
}

----------------------------------------

TITLE: Adding Column with SQL Migration
DESCRIPTION: Migration script showing how to modify an existing schema by adding a timestamp column with a default value.

LANGUAGE: sql
CODE:
ALTER TABLE todo_item ADD created TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW();

----------------------------------------

TITLE: Testing Token Generation with Curl
DESCRIPTION: This bash command verifies OAuth client setup by making a direct curl request to the Encore Cloud OAuth token endpoint. It demonstrates how to request an access token using the client_credentials grant type with your client ID and secret stored in environment variables.

LANGUAGE: bash
CODE:
curl -d "client_id=${OAUTH_CLIENT_ID}" -d "client_secret=${OAUTH_CLIENT_SECRET}" \
     -d "grant_type=client_credentials" "https://api.encore.cloud/api/oauth/token"

----------------------------------------

TITLE: Creating a PubSub Topic with Invalid Configuration in Go
DESCRIPTION: Defines a PubSub topic for MessageType with delivery guarantee and an invalid OrderingAttribute. The OrderingAttribute must be one of the export attributes on the message type (should use 'msg-id' instead of 'ID').

LANGUAGE: go
CODE:
var BasicTopic = pubsub.NewTopic[*MessageType]("same-name", pubsub.TopicConfig{
    DeliveryGuarantee: pubsub.AtLeastOnce,
    OrderingAttribute: "ID",
})

----------------------------------------

TITLE: Defining Encore API Endpoint
DESCRIPTION: Creates a basic API endpoint using Encore's annotation system. The function takes a context parameter and returns an error, with a minimal implementation that returns nil.

LANGUAGE: go
CODE:
//encore:api
func MyAPI(ctx context.Context) (error) {
	return nil
}

----------------------------------------

TITLE: Accessing Public Objects in a Storage Bucket
DESCRIPTION: Shows how to get the public URL for an object in a public bucket. This method returns a URL that can be used to access the object directly.

LANGUAGE: typescript
CODE:
const url = publicProfilePictures.publicUrl("my-image.jpeg");

----------------------------------------

TITLE: Generated Generic Configuration Type Unmarshalers for SubCfgType
DESCRIPTION: This automatically generated function creates unmarshalers for the generic SubCfgType struct. It handles the JSON deserialization of fields within the nested structure, maintaining the generic type parameter from the parent configuration.

LANGUAGE: go
CODE:
func encoreInternalTypeConfigUnmarshaler_generics_SubCfgType[T any](_T_unmarshaler config.Unmarshaler[T]) (concreteUnmarshaler config.Unmarshaler[SubCfgType[T]]) {
	return func(itr *jsoniter.Iterator, path []string) (obj SubCfgType[T]) {
		itr.ReadObjectCB(func(itr *jsoniter.Iterator, field string) bool {
			switch field {
			case "MaxCount":
				obj.MaxCount = _T_unmarshaler(itr, append(path, "MaxCount"))
			default:
				itr.Skip()
			}
			return true
		})
		return
	}
}

----------------------------------------

TITLE: Defining a Conditional Type Extractor in TypeScript
DESCRIPTION: Creates a utility type 'Iface' that extracts the type of property 'X' from an object type using conditional types and the 'infer' keyword. If the type parameter doesn't have property 'X', it returns 'never'.

LANGUAGE: typescript
CODE:
export type Iface<T> = T extends { X: infer A } ? A : never;

----------------------------------------

TITLE: Creating an Encore App with CLI
DESCRIPTION: Command to create a new Encore application using the Encore CLI, selecting the Hello World template.

LANGUAGE: bash
CODE:
encore app create

----------------------------------------

TITLE: Disabling Telemetry via CLI Command
DESCRIPTION: A shell command that disables telemetry data collection in Encore. This allows users to opt out of the telemetry program using the Encore CLI.

LANGUAGE: sh
CODE:
encore telemetry disable

----------------------------------------

TITLE: Accessing Public Objects in a Storage Bucket
DESCRIPTION: Shows how to get the public URL for an object in a public bucket. This method returns a URL that can be used to access the object directly.

LANGUAGE: typescript
CODE:
const url = publicProfilePictures.publicUrl("my-image.jpeg");

----------------------------------------

TITLE: Creating GitHub Logo SVG in HTML
DESCRIPTION: SVG code for rendering the GitHub logo within an HTML container. The SVG uses a path element with the fillRule="evenodd" to draw the GitHub icon with a consistent fill color (#111111).

LANGUAGE: SVG
CODE:
<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 16 16" fill="#111111"
    stroke="none">
    <path fillRule="evenodd"
        d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z" />
</svg>

----------------------------------------

TITLE: Creating Pub/Sub Subscriptions in Encore.ts
DESCRIPTION: Shows how to create a subscription to a Pub/Sub topic, which requires a topic to subscribe to, a unique name, a handler function, and configuration.

LANGUAGE: TypeScript
CODE:
import { Subscription } from "encore.dev/pubsub";

const _ = new Subscription(signups, "send-welcome-email", {
    handler: async (event) => {
        // Send a welcome email using the event.
    },
});

----------------------------------------

TITLE: Using Structured Logging in Encore.ts
DESCRIPTION: Demonstrates two approaches to structured logging in Encore.ts. The first example shows direct logging with structured data, while the second shows creating a logger with context that's shared across multiple log calls.

LANGUAGE: typescript
CODE:
log.info("log message", {is_subscriber: true})
log.error(err, "something went terribly wrong!")

LANGUAGE: typescript
CODE:
const logger = log.with({is_subscriber: true})
logger.info("user logged in", {login_method: "oauth"}) // includes is_subscriber=true

----------------------------------------

TITLE: Defining Service Structs with API Methods in Encore
DESCRIPTION: Implementation of Encore service structs with initialization logic and API endpoints as methods. This pattern enables dependency injection and supports graceful shutdown handling.

LANGUAGE: go
CODE:
type Service struct {
    // Dependencies here
}

func initService() (*Service, error) {
    // Initialization code
}

//encore:api public
func (s *Service) MyAPI(ctx context.Context) error {
    // API implementation
}

----------------------------------------

TITLE: Setting Clerk Production Secret in Encore
DESCRIPTION: Command to set the Clerk client secret key as an Encore secret for production environment. This securely stores the authentication credentials needed for the Clerk SDK.

LANGUAGE: shell
CODE:
$ encore secret set --prod ClientSecretKey

----------------------------------------

TITLE: Creating PubSub Subscription in Go with Encore
DESCRIPTION: Sets up a subscription to the PubSub topic with a handler function that processes incoming messages. The subscription is named 'foo-service-sub' and references the shared topic.

LANGUAGE: go
CODE:
package foo

import (
    "context"

    "encore.dev/pubsub"

    "test/shared"
)

var _ = pubsub.NewSubscription(
    shared.BasicTopic,
    "foo-service-sub",
    pubsub.SusbcriptionConfig { Handler: func(ctx context.Context, msg *shared.MessageType) error {
        return nil
    }},
)

----------------------------------------

TITLE: Implementing API Endpoints with Encore in Go
DESCRIPTION: Go implementation of an Encore service with two API endpoints: a public GET endpoint at /v1/regular that returns a greeting message, and a fallback handler that catches all unmatched routes.

LANGUAGE: go
CODE:
package svc

import (
    "context"
    "net/http"
)

//encore:api public raw path=/!fallback
func Fallback(w http.ResponseWriter, req *http.Request) {
    w.Write([]byte(`{"fallback": true}`))
}

type Response struct {
    Message string
}

//encore:api public method=GET path=/v1/regular
func Regular(ctx context.Context) (*Response, error) {
    return &Response{Message: "Hello, Encore world!"}, nil
}

----------------------------------------

TITLE: Authentication Methods Configuration
DESCRIPTION: Configuration for service-to-service authentication using a shared key method. This ensures private endpoints are only accessible to authorized backend services when exposed over public networks.

LANGUAGE: json
CODE:
{
  "auth": [
    {
      "type": "key",
      "id": 1,
      "key": {
        "$env": "SERVICE_API_KEY"
      }
    }
  ]
}

----------------------------------------

TITLE: Configuring PubSub Subscriptions in Main Service
DESCRIPTION: Creates two subscriptions to the BasicTopic in the main service. The first subscription includes detailed configuration with custom retry policy, while the second subscription uses a handler from another package.

LANGUAGE: go
CODE:
var (
    _ = pubsub.NewSubscription(shared.BasicTopic, "basic-subscription",
        pubsub.SubscriptionConfig {
            Handler: Subscriber1,
            MaxConcurrency: 25,
            AckDeadline: 45 * time.Second,
            MessageRetention: 5 * time.Hour * 24 + -10 * time.Hour,
            RetryPolicy: &pubsub.RetryPolicy{
                MaxRetries: 3,
                MinBackoff: 8 * time.Second,
                MaxBackoff: 32 * time.Minute,
            },
        },
    )

    _ = pubsub.NewSubscription(shared.BasicTopic, "another-subscription",
        pubsub.SubscriptionConfig { Handler: domain.SubscriptionCode },
    )
)

----------------------------------------

TITLE: Building Docker Image with Infrastructure Configuration in Encore
DESCRIPTION: Command to build a Docker image for an Encore application with infrastructure configuration using the encore build command and --config flag.

LANGUAGE: bash
CODE:
encore build docker --config path/to/infra-config.json MY-IMAGE:TAG

----------------------------------------

TITLE: Example Encore Webhook Signature Header Format
DESCRIPTION: Shows the format of the X-Encore-Signature header used in webhook requests. The header contains a timestamp and one or more signature schemes for verification.

LANGUAGE: text
CODE:
X-Encore-Signature: t=1623345600,v1=0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1b

----------------------------------------

TITLE: Implementing PubSub Topic with Invalid Name in Go using Encore
DESCRIPTION: This code demonstrates an incorrectly named PubSub topic in an Encore application. The topic name 'basic topic' violates the kebab-case naming convention required by Encore. The code also includes a function that publishes a message to this topic.

LANGUAGE: go
CODE:
package svc

import (
    "context"

    "encore.dev/pubsub"
)

type MessageType struct {
    Name string
}

var (
    BasicTopic = pubsub.NewTopic[*MessageType]("basic topic", pubsub.TopicConfig{ DeliveryGuarantee: pubsub.AtLeastOnce })
)

// encore:api
func DoStuff(ctx context.Context) error {
    return BasicTopic.Publish(ctx, &MessageType{Name: "foo"})
}

----------------------------------------

TITLE: Defining Request and Response Types for Internal API
DESCRIPTION: Internal type definitions used by Encore to handle the API request and response types for the Foo endpoint.

LANGUAGE: go
CODE:
type EncoreInternal_FooReq struct{}

type EncoreInternal_FooResp = *Params

----------------------------------------

TITLE: Auto-generated API Registration for Foo Service
DESCRIPTION: Encore-generated internal code that registers the Foo API endpoint with the Encore runtime. It handles request/response marshaling, path routing, HTTP methods, and other API-related functionality.

LANGUAGE: go
CODE:
package foo

import (
	"context"
	__api "encore.dev/appruntime/apisdk/api"
	jsoniter "github.com/json-iterator/go"
	"net/http"
	"net/url"
)

func init() {
	__api.RegisterEndpoint(EncoreInternal_api_APIDesc_Foo, Foo)
}

type EncoreInternal_FooReq struct{}

type EncoreInternal_FooResp = __api.Void

var EncoreInternal_api_APIDesc_Foo = &__api.Desc[*EncoreInternal_FooReq, EncoreInternal_FooResp]{
	Access: __api.Private,
	AppHandler: func(ctx context.Context, reqData *EncoreInternal_FooReq) (EncoreInternal_FooResp, error) {
		err := Foo(ctx)
		if err != nil {
			return __api.Void{}, err
		}
		return __api.Void{}, nil
	},
	CloneReq: func(r *EncoreInternal_FooReq) (*EncoreInternal_FooReq, error) {
		var clone *EncoreInternal_FooReq
		bytes, err := jsoniter.ConfigDefault.Marshal(r)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return clone, err
	},
	CloneResp: func(r EncoreInternal_FooResp) (EncoreInternal_FooResp, error) {
		var clone EncoreInternal_FooResp
		bytes, err := jsoniter.ConfigDefault.Marshal(r)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return clone, err
	},
	DecodeExternalResp: func(httpResp *http.Response, json jsoniter.API) (resp EncoreInternal_FooResp, err error) {
		return __api.Void{}, nil
	},
	DecodeReq: func(httpReq *http.Request, ps __api.UnnamedParams, json jsoniter.API) (reqData *EncoreInternal_FooReq, pathParams __api.UnnamedParams, err error) {
		reqData = new(EncoreInternal_FooReq)
		return reqData, nil, nil
	},
	DefLoc: uint32(0x0),
	EncodeExternalReq: func(reqData *EncoreInternal_FooReq, stream *jsoniter.Stream) (httpHeader http.Header, queryString url.Values, err error) {
		return nil, nil, nil
	},
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, resp EncoreInternal_FooResp) (err error) {
		return nil
	},
	Endpoint:            "Foo",
	Fallback:            false,
	GlobalMiddlewareIDs: []string{},
	Methods:             []string{"GET", "POST"},
	Path:                "/foo.Foo",
	PathParamNames:      nil,
	Raw:                 false,
	RawHandler:          nil,
	RawPath:             "/foo.Foo",
	ReqPath: func(reqData *EncoreInternal_FooReq) (string, __api.UnnamedParams, error) {
		return "/foo.Foo", nil, nil
	},
	ReqUserPayload: func(reqData *EncoreInternal_FooReq) any {
		return nil
	},
	Service:           "foo",
	ServiceMiddleware: []*__api.Middleware{},
	SvcNum:            2,
	Tags:              nil,
}

----------------------------------------

TITLE: React Frontend Integration with Clerk Authentication
DESCRIPTION: Shows how to use Clerk's React SDK to handle authentication in a frontend application. This code demonstrates accessing authentication state and retrieving tokens for backend API calls.

LANGUAGE: jsx
CODE:
import { useAuth } from '@clerk/clerk-react';

export default function ExternalDataPage() {
    const { getToken, isLoaded, isSignedIn } = useAuth();
    
    // Implementation using token for backend communication
}

----------------------------------------

TITLE: Creating Auth0 Configuration File in CUE
DESCRIPTION: Defines a CUE configuration file for Auth0 settings including ClientID, Domain, CallbackURL, and LogoutURL with environment-specific values.

LANGUAGE: cue
CODE:
ClientID: "<your client_id from above>"
Domain: "<your domain from above>"

// An application running locally
if #Meta.Environment.Type == "development" && #Meta.Environment.Cloud == "local" {
	CallbackURL: "http://localhost:3000/callback"
	LogoutURL: "http://localhost:3000/"
}

----------------------------------------

TITLE: Implementing Logging Function in Go using Encore's rlog
DESCRIPTION: Defines a package 'foo' with a Log function that logs an info message using Encore's rlog library. The function simply writes a 'test' message to the log at info level.

LANGUAGE: go
CODE:
package foo

import "encore.dev/rlog"

func Log() {
    rlog.Info("test")
}

----------------------------------------

TITLE: Configuring Kubernetes for Encore
DESCRIPTION: Updates kubectl configuration to point to Kubernetes clusters for the specified environment.

LANGUAGE: shell
CODE:
$ encore k8s configure --env=ENV_NAME

----------------------------------------

TITLE: Implementing a Domain-specific Message Handler
DESCRIPTION: Defines a subscription handler in a domain package that processes messages from a PubSub topic. The function accepts a context and message parameter, returning an error value.

LANGUAGE: go
CODE:
func SubscriptionCode(ctx context.Context, msg *shared.MessageType) error {
    return nil
}

----------------------------------------

TITLE: Logging out of Encore
DESCRIPTION: Logs out the currently authenticated user from Encore.

LANGUAGE: shell
CODE:
$ encore auth logout

----------------------------------------

TITLE: Environment Reference Secrets Configuration
DESCRIPTION: Configuration for application secrets using a JSON object from an environment variable. This approach allows loading all secrets from a single environment variable containing a JSON string.

LANGUAGE: json
CODE:
{
  "secrets": {
    "$env": "SECRET_JSON"
  }
}

----------------------------------------

TITLE: Retrieving Object Attributes from Storage in Encore.ts
DESCRIPTION: Shows how to retrieve metadata about an object using the 'attrs' method. This returns information like the object's size, content type, and ETag.

LANGUAGE: typescript
CODE:
const attrs = await profilePictures.attrs("my-image.jpeg");

----------------------------------------

TITLE: Defining Config Structure for Temporal Connection in Go
DESCRIPTION: Creates a configuration type in Go to store Temporal server connection details. Uses Encore's config functionality to load environment-specific configuration values.

LANGUAGE: go
CODE:
package greeting

import "encore.dev/config"

type Config struct {
    TemporalServer string
}

var cfg = config.Load[*Config]()

----------------------------------------

TITLE: Defining Duplicate PubSub Topic in Service Package
DESCRIPTION: Creates another PubSub topic with the same name 'same-name' in the svc package, which will cause a validation error since topic names must be unique within an Encore application.

LANGUAGE: go
CODE:
package svc

import (
    "context"

    "encore.dev/pubsub"
)

type MessageType struct {
    Name string
}

var AnotherTopic = pubsub.NewTopic[*MessageType]("same-name", pubsub.TopicConfig{ DeliveryGuarantee: pubsub.AtLeastOnce })

----------------------------------------

TITLE: Registering Endpoint with Encore Runtime
DESCRIPTION: Initializes and registers the API endpoint with Encore's runtime system. This ensures the endpoint is properly integrated with Encore's infrastructure.

LANGUAGE: go
CODE:
func init() {
	__api.RegisterEndpoint(EncoreInternal_api_APIDesc_Foo, Foo)
}

----------------------------------------

TITLE: Creating Database Migration for Uptime Checks
DESCRIPTION: SQL migration script to create the 'checks' table for storing uptime check results, including site ID, status, and timestamp information.

LANGUAGE: sql
CODE:
-- monitor/migrations/1_create_tables.up.sql --
CREATE TABLE checks (
    id BIGSERIAL PRIMARY KEY,
    site_id BIGINT NOT NULL,
    up BOOLEAN NOT NULL,
    checked_at TIMESTAMP WITH TIME ZONE NOT NULL
);

----------------------------------------

TITLE: Generated Encore Internal API Implementation
DESCRIPTION: This auto-generated code registers the API endpoint and implements its request/response handling. It includes functions for encoding/decoding parameters, handling HTTP methods, processing query parameters, and managing the endpoint's lifecycle.

LANGUAGE: go
CODE:
package code

import (
	"context"
	__api "encore.dev/appruntime/apisdk/api"
	__etype "encore.dev/appruntime/shared/etype"
	jsoniter "github.com/json-iterator/go"
	"net/http"
	"net/url"
)

func init() {
	__api.RegisterEndpoint(EncoreInternal_api_APIDesc_Foo, Foo)
}

type EncoreInternal_FooReq struct {
	Payload *Params
}

type EncoreInternal_FooResp = __api.Void

var EncoreInternal_api_APIDesc_Foo = &__api.Desc[*EncoreInternal_FooReq, EncoreInternal_FooResp]{
	Access: __api.Public,
	AppHandler: func(ctx context.Context, reqData *EncoreInternal_FooReq) (EncoreInternal_FooResp, error) {
		err := Foo(ctx, reqData.Payload)
		if err != nil {
			return __api.Void{}, err
		}
		return __api.Void{}, nil
	},
	CloneReq: func(r *EncoreInternal_FooReq) (*EncoreInternal_FooReq, error) {
		var clone *EncoreInternal_FooReq
		bytes, err := jsoniter.ConfigDefault.Marshal(r)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return clone, err
	},
	CloneResp: func(r EncoreInternal_FooResp) (EncoreInternal_FooResp, error) {
		var clone EncoreInternal_FooResp
		bytes, err := jsoniter.ConfigDefault.Marshal(r)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return clone, err
	},
	DecodeExternalResp: func(httpResp *http.Response, json jsoniter.API) (resp EncoreInternal_FooResp, err error) {
		return __api.Void{}, nil
	},
	DecodeReq: func(httpReq *http.Request, ps __api.UnnamedParams, json jsoniter.API) (reqData *EncoreInternal_FooReq, pathParams __api.UnnamedParams, err error) {
		reqData = new(EncoreInternal_FooReq)
		dec := new(__etype.Unmarshaller)
		params := new(Params)
		reqData.Payload = params
		switch m := httpReq.Method; m {
		case "POST":
			// Decode query string
			qs := httpReq.URL.Query()
			params.Foo = __etype.UnmarshalOne(dec, __etype.UnmarshalString, "foo", qs.Get("foo"), false)
			params.Ints = __etype.UnmarshalList(dec, __etype.UnmarshalInt, "ints", qs["ints"], false)

		default:
			panic("HTTP method is not supported")
		}
		if err := dec.Error; err != nil {
			return nil, nil, err
		}
		return reqData, ps, nil
	},
	DefLoc: uint32(0x0),
	EncodeExternalReq: func(reqData *EncoreInternal_FooReq, stream *jsoniter.Stream) (httpHeader http.Header, queryString url.Values, err error) {
		params := reqData.Payload
		if params == nil {
			// If the payload is nil, we need to return an empty request body.
			return httpHeader, queryString, err
		}

		// Encode query string
		queryString = make(url.Values, 2)
		queryString.Set("foo", __etype.MarshalOne(__etype.MarshalString, params.Foo))
		queryString["ints"] = __etype.MarshalList(__etype.MarshalInt, params.Ints)

		return httpHeader, queryString, err
	},
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, resp EncoreInternal_FooResp) (err error) {
		return nil
	},
	Endpoint:            "Foo",
	Fallback:            false,
	GlobalMiddlewareIDs: []string{},
	Methods:             []string{"POST"},
	Path:                "/code.Foo",
	PathParamNames:      nil,
	Raw:                 false,
	RawHandler:          nil,
	RawPath:             "/code.Foo",
	ReqPath: func(reqData *EncoreInternal_FooReq) (string, __api.UnnamedParams, error) {
		return "/code.Foo", nil, nil
	},
	ReqUserPayload: func(reqData *EncoreInternal_FooReq) any {
		return reqData.Payload
	},
	Service:           "code",
	ServiceMiddleware: []*__api.Middleware{},
	SvcNum:            1,
	Tags:              nil,
}

----------------------------------------

TITLE: Implementing a StreamIn API Endpoint
DESCRIPTION: Shows how to create an API endpoint that accepts streaming data from clients. This example defines an upload endpoint that processes incoming messages until it receives a completion signal.

LANGUAGE: typescript
CODE:
import { api } from "encore.dev/api";

interface Message {
  data: string;
  done: boolean;
}

export const uploadStream = api.streamIn<Message>(
  { path: "/upload", expose: true },
  async (stream) => {
    for await (const data of stream) {
      // Process incoming data
      if (data.done) break;
    }
  }
);

----------------------------------------

TITLE: Installing Connect Protocol Tools with Go
DESCRIPTION: Commands to install the necessary tools for working with Connect and Protobuf, including buf for Protobuf management, grpcurl for testing gRPC services, and protocol compiler plugins for Go.

LANGUAGE: shell
CODE:
$ go install github.com/bufbuild/buf/cmd/buf@latest
$ go install github.com/fullstorydev/grpcurl/cmd/grpcurl@latest
$ go install google.golang.org/protobuf/cmd/protoc-gen-go@latest
$ go install connectrpc.com/connect/cmd/protoc-gen-connect-go@latest

----------------------------------------

TITLE: Implementing Encore API Function with Method Call in Go
DESCRIPTION: Defines a public Encore API endpoint 'Foo' that creates an instance of a local type and calls a method with the same name. This tests that the parser correctly distinguishes between method calls and function calls.

LANGUAGE: go
CODE:
package svc

import (
    "context"
)

//encore:api public
func Foo(ctx context.Context) error {
    var t typ
    t.Foo()
    return nil
}

type typ struct{}
func (typ) Foo() { }

----------------------------------------

TITLE: Creating a catch-all handler for Express router in Encore
DESCRIPTION: TypeScript implementation that wraps an existing Express.js router in an Encore Raw API endpoint, allowing it to handle all incoming HTTP requests as a migration strategy.

LANGUAGE: typescript
CODE:
import { api, RawRequest, RawResponse } from "encore.dev/api";
import express, { request, response } from "express";

Object.setPrototypeOf(request, RawRequest.prototype);
Object.setPrototypeOf(response, RawResponse.prototype);

const app = express();

app.get('/foo', (req: any, res) => {
  res.send('Hello World!')
})

export const expressApp = api.raw(
  { expose: true, method: "*", path: "/!rest" },
  app,
);

----------------------------------------

TITLE: Testing Pub/Sub in Encore with TopicRef and Message Verification
DESCRIPTION: Demonstrates how to test pub/sub functionality in Encore using the testing package. It shows how to create a topic reference, publish messages, verify published messages, and check topic metadata in test assertions.

LANGUAGE: go
CODE:
package svc

import (
    "context"
    "testing"
    "encore.dev/et"
    "encore.dev/pubsub"
)

func TestRefPublish(t *testing.T) {
    ref := pubsub.TopicRef[pubsub.Publisher[Msg]](Topic)
    ref.Publish(context.Background(), Msg{Message: "test"})

    msgs := et.Topic(Topic).PublishedMessages()
    if len(msgs) != 1 || msgs[0].Message != "test" {
        t.Fatalf("got %v, want %v", msgs, []Msg{{Message: "test"}})
    }

    meta := ref.Meta()
    want := pubsub.TopicMeta{
        Name: "topic",
        Config: pubsub.TopicConfig{
            DeliveryGuarantee: pubsub.AtLeastOnce,
        },
    }
    if meta != want {
        t.Fatalf("got meta %v, want %v", meta, want)
    }
}

----------------------------------------

TITLE: Defining a Public API Endpoint in Encore
DESCRIPTION: Defines a public API endpoint named 'One' in the 'one' package that takes a context parameter and returns an error.

LANGUAGE: go
CODE:
package one

import (
    "context"
)

//encore:api public
func One(ctx context.Context) error {
    return nil
}

----------------------------------------

TITLE: AWS CloudWatch Metrics Configuration
DESCRIPTION: Configuration for exporting metrics to AWS CloudWatch. Specifies the collection interval and namespace for organizing metrics in CloudWatch.

LANGUAGE: json
CODE:
{
  "metrics": {
    "type": "aws_cloudwatch",
    "collection_interval": 60,
    "namespace": "MyAppMetrics"
  }
}

----------------------------------------

TITLE: Inserting Data into SQL Databases with Encore
DESCRIPTION: Shows how to insert data into SQL databases using Encore's database functionality. This example creates a helper function that executes an INSERT query with parameterized values.

LANGUAGE: go
CODE:
import "encore.dev/storage/sqldb"

// insert inserts a todo item into the database.
func insert(ctx context.Context, id, title string, done bool) error {
	_, err := tododb.Exec(ctx, `
		INSERT INTO todo_item (id, title, done)
		VALUES ($1, $2, $3)
	`, id, title, done)
	return err
}

----------------------------------------

TITLE: Implementing PubSub in Encore with Topic and Subscription
DESCRIPTION: Creates a PubSub Topic and Subscription in an Encore application. The example demonstrates how to define a message type, create a topic with 'at-least-once' delivery guarantee, and define a subscription. Note that the subscription name 'basic subscription' causes an error since it doesn't follow kebab-case convention.

LANGUAGE: go
CODE:
package svc

import (
    "context"

    "encore.dev/pubsub"
)

type MessageType struct {
    Name string
}

var (
    BasicTopic = pubsub.NewTopic[*MessageType]("basic-topic", pubsub.TopicConfig{ DeliveryGuarantee: pubsub.AtLeastOnce })
    _ = pubsub.NewSubscription(BasicTopic, "basic subscription", pubsub.SusbcriptionConfig { Handler: Subscriber })
)

// encore:api
func DoStuff(ctx context.Context) error {
    return BasicTopic.Publish(ctx, &MessageType{Name: "foo"})
}

func Subscriber(ctx context.Context, msg *MessageType) error {
    return nil
}

----------------------------------------

TITLE: Generated API Registration and Request Handling in Go
DESCRIPTION: Auto-generated code that handles API registration, request processing, and response generation for the 'Foo' endpoint. Includes functions for encoding/decoding requests and responses, along with HTTP path and method definitions.

LANGUAGE: go
CODE:
package basic

import (
	"context"
	__api "encore.dev/appruntime/apisdk/api"
	jsoniter "github.com/json-iterator/go"
	"net/http"
	"net/url"
)

func init() {
	__api.RegisterEndpoint(EncoreInternal_api_APIDesc_Foo, Foo)
}

type EncoreInternal_FooReq struct{}

type EncoreInternal_FooResp = __api.Void

var EncoreInternal_api_APIDesc_Foo = &__api.Desc[*EncoreInternal_FooReq, EncoreInternal_FooResp]{
	Access: __api.Public,
	AppHandler: func(ctx context.Context, reqData *EncoreInternal_FooReq) (EncoreInternal_FooResp, error) {
		svc, initErr := EncoreInternal_svcstruct_Service.Get()
		if initErr != nil {
			return __api.Void{}, initErr
		}
		err := svc.Foo(ctx)
		if err != nil {
			return __api.Void{}, err
		}
		return __api.Void{}, nil
	},
	CloneReq: func(r *EncoreInternal_FooReq) (*EncoreInternal_FooReq, error) {
		var clone *EncoreInternal_FooReq
		bytes, err := jsoniter.ConfigDefault.Marshal(r)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return clone, err
	},
	CloneResp: func(r EncoreInternal_FooResp) (EncoreInternal_FooResp, error) {
		var clone EncoreInternal_FooResp
		bytes, err := jsoniter.ConfigDefault.Marshal(r)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return clone, err
	},
	DecodeExternalResp: func(httpResp *http.Response, json jsoniter.API) (resp EncoreInternal_FooResp, err error) {
		return __api.Void{}, nil
	},
	DecodeReq: func(httpReq *http.Request, ps __api.UnnamedParams, json jsoniter.API) (reqData *EncoreInternal_FooReq, pathParams __api.UnnamedParams, err error) {
		reqData = new(EncoreInternal_FooReq)
		return reqData, nil, nil
	},
	DefLoc: uint32(0x0),
	EncodeExternalReq: func(reqData *EncoreInternal_FooReq, stream *jsoniter.Stream) (httpHeader http.Header, queryString url.Values, err error) {
		return nil, nil, nil
	},
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, resp EncoreInternal_FooResp) (err error) {
		return nil
	},
	Endpoint:            "Foo",
	Fallback:            false,
	GlobalMiddlewareIDs: []string{},
	Methods:             []string{"GET", "POST"},
	Path:                "/basic.Foo",
	PathParamNames:      nil,
	Raw:                 false,
	RawHandler:          nil,
	RawPath:             "/basic.Foo",
	ReqPath: func(reqData *EncoreInternal_FooReq) (string, __api.UnnamedParams, error) {
		return "/basic.Foo", nil, nil
	},
	ReqUserPayload: func(reqData *EncoreInternal_FooReq) any {
		return nil
	},
	Service:           "basic",
	ServiceMiddleware: []*__api.Middleware{},
	SvcNum:            1,
	Tags:              nil,
}

----------------------------------------

TITLE: Generated Service Interface for Encore API
DESCRIPTION: Encore-generated code that creates an interface definition for the service API, making it easier to mock the service for testing purposes. This interface includes all public API endpoints.

LANGUAGE: go
CODE:
// Code generated by encore. DO NOT EDIT.

package code

import "context"

// These functions are automatically generated and maintained by Encore
// to simplify calling them from other services, as they were implemented as methods.
// They are automatically updated by Encore whenever your API endpoints change.

// Interface defines the service's API surface area, primarily for mocking purposes.
//
// Raw endpoints are currently excluded from this interface, as Encore does not yet
// support service-to-service API calls to raw endpoints.
type Interface interface {
	Foo(ctx context.Context, p *Params) error
}

----------------------------------------

TITLE: Getting Encore Database Connection String
DESCRIPTION: Command to output a connection string for a specific Encore database with optional environment specification.

LANGUAGE: bash
CODE:
encore db conn-uri database-name [--env=name]

----------------------------------------

TITLE: Generating gqlgen Boilerplate with Shell Commands
DESCRIPTION: Shell commands to create necessary directories and generate the initial gqlgen boilerplate code for the GraphQL service.

LANGUAGE: shell
CODE:
$ mkdir -p graphql/generated graphql/model
$ echo "package model" > graphql/model/model.go
$ go run github.com/99designs/gqlgen generate

----------------------------------------

TITLE: Defining an Invalid Encore API with 'any' Type
DESCRIPTION: This code defines an Encore API endpoint that uses the 'any' type in its parameter struct, which is not supported in Encore API schemas. The code will generate an error as interfaces are not allowed in API schemas.

LANGUAGE: go
CODE:
package svc

import (
	"context"
)

type Params struct {
    Foo any
}

//encore:api public
func Any(ctx context.Context, p *Params) error { return nil }

----------------------------------------

TITLE: Implementing User API with Authentication in Encore
DESCRIPTION: Implements a public API endpoint for retrieving user information using Encore's authentication system. It extracts the user ID and authentication data from the current context.

LANGUAGE: go
CODE:
type Response struct {
    UserID auth.UID
    Data *AuthData
}

//encore:api public
func GetUser(ctx context.Context) (*Response, error) {
    uid, _ := auth.UserID()
    data, _ := auth.Data().(*AuthData)
    return &Response{UserID: uid, Data: data}, nil
}

----------------------------------------

TITLE: GCP Cloud Monitoring Metrics Configuration
DESCRIPTION: Configuration for exporting metrics to Google Cloud Monitoring. Specifies project ID, resource type, labels, and custom metric mappings for Google Cloud's monitoring system.

LANGUAGE: json
CODE:
{
  "metrics": {
    "type": "gcp_cloud_monitoring",
    "collection_interval": 60,
    "project_id": "my-gcp-project",
    "monitored_resource_type": "gce_instance",
    "monitored_resource_labels": {
      "instance_id": "1234567890",
      "zone": "us-central1-a"
    },
    "metric_names": {
      "cpu_usage": "compute.googleapis.com/instance/cpu/usage_time"
    }
  }
}

----------------------------------------

TITLE: Testing React Components with Mocked Encore API Clients
DESCRIPTION: Example of unit testing React components that use Encore clients by mocking API methods and verifying interactions with endpoints.

LANGUAGE: typescript
CODE:
import { render, waitForElementToBeRemoved } from "@testing-library/react";
import App from "./App";
import { site } from "./client";
import { userEvent } from "@testing-library/user-event";

describe("App", () => {
  beforeEach(() => {
    // Return mocked data from the List (GET) endpoint
    jest
      .spyOn(site.ServiceClient.prototype, "List")
      .mockReturnValue(Promise.resolve({
        sites: [{
          id: 1,
          url: "test.dev"
        }]
      }));

    // Spy on the Add (POST) endpoint
    jest.spyOn(site.ServiceClient.prototype, "Add");
  });

  it("render sites", async () => {
    render(<App />);
    await waitForElementToBeRemoved(() => screen.queryByText("Loading..."));

    // Verify that the List endpoint has been called
    expect(site.ServiceClient.prototype.List).toBeCalledTimes(1);

    // Verify that the sites are rendered with our mocked data
    screen.getAllByText("test.dev");
  });

  it("add site", async () => {
    render(<App />);
    await waitForElementToBeRemoved(() => screen.queryByText("Loading..."));

    // Interact with the page and add 'another.com'
    await userEvent.click(screen.getByText("Add website"));
    await userEvent.type(
      screen.getByPlaceholderText("google.com"),
      "another.com",
    );
    await userEvent.click(screen.getByText("Save"));

    // Verify that the Add endpoint has been called with the correct parameters
    expect(site.ServiceClient.prototype.Add).toHaveBeenCalledWith({
      url: "another.com",
    });
  });
})

----------------------------------------

TITLE: Defining a Shared Message Type Structure in Go
DESCRIPTION: Definition of a shared message type structure that will be used across services for PubSub messaging.

LANGUAGE: go
CODE:
package shared

type MessageType struct {
    Name string
}

----------------------------------------

TITLE: Auto-generated Service Interface for Bar
DESCRIPTION: Encore-generated code that defines an interface for the Bar service, which is useful for mocking in tests. This code is automatically maintained by Encore whenever API endpoints change.

LANGUAGE: go
CODE:
// Code generated by encore. DO NOT EDIT.

package bar

import "context"

// These functions are automatically generated and maintained by Encore
// to simplify calling them from other services, as they were implemented as methods.
// They are automatically updated by Encore whenever your API endpoints change.

// Interface defines the service's API surface area, primarily for mocking purposes.
//
// Raw endpoints are currently excluded from this interface, as Encore does not yet
// support service-to-service API calls to raw endpoints.
type Interface interface {
	Bar(ctx context.Context) error
}

----------------------------------------

TITLE: Retrieving Previous Site Measurements from Database in Go
DESCRIPTION: Implements a function to query the database for the previous up/down state of a monitored site. If no previous measurement exists, it defaults to treating the site as previously up.

LANGUAGE: go
CODE:
import (
	"encore.dev/storage/sqldb"
	"errors"
	"context"
)
// getPreviousMeasurement reports whether the given site was
// up or down in the previous measurement.
func getPreviousMeasurement(ctx context.Context, siteID int) (up bool, err error) {
	err = db.QueryRow(ctx, `
		SELECT up FROM checks
		WHERE site_id = $1
		ORDER BY checked_at DESC
		LIMIT 1
	`, siteID).Scan(&up)

	if errors.Is(err, sqldb.ErrNoRows) {
		// There was no previous ping; treat this as if the site was up before
		return true, nil
	} else if err != nil {
		return false, err
	}
	return up, nil
}

----------------------------------------

TITLE: Using the Service and Database Connection in a Package
DESCRIPTION: Demonstrates how to import and use the service package and its database connection in another package. It references both the database connection and its Query method.

LANGUAGE: go
CODE:
package pkg

import (
    "context"
    "test/svc"
)

func Foo() {
    _ = svc.Moo
    _ = svc.Moo.Query
}

----------------------------------------

TITLE: Testing Database Connection in Deployed App
DESCRIPTION: Command to test the database connection in the deployed application by calling the API endpoint that retrieves user data.

LANGUAGE: bash
CODE:
curl https://myapp.ondigitalocean.app/names/1

----------------------------------------

TITLE: Modified Config Loading with Explicit Unmarshaler Reference
DESCRIPTION: Updated version of the service code with explicit configuration unmarshaler reference in the config.Load call. This modification is likely applied by Encore's build process to wire up the generated unmarshaling functions.

LANGUAGE: go
CODE:
package svc

import (
	"context"

	"encore.dev/config"
)

type Config struct {
    Ages      []int32
    OtherBits []string
}

var _ = config.Load[*Config]("svc", encoreInternalConfigUnmarshaler_ptr_svc_Config/*line :14:30*/)

//encore:api
func MyAPI(ctx context.Context) (error) {
	return nil
}

----------------------------------------

TITLE: Database Utility Package Implementation
DESCRIPTION: Supporting package that provides database interaction functionality. It defines a function that accepts a database instance and can use its query capability.

LANGUAGE: go
CODE:
package pkg

import (
    "context"
    
    "encore.dev/storage/sqldb"
)

func Foo(db *sqldb.Database) {
    _ = db.Query
}

----------------------------------------

TITLE: Mocking Individual Endpoint for Testing in Encore
DESCRIPTION: Shows how to mock a specific API endpoint for a single test using Encore's testing framework. The mock function replaces the actual implementation for the duration of the test and returns predefined response values.

LANGUAGE: go
CODE:
func Test_Something(t *testing.T) {
    t.Parallel()
    
    et.MockEndpoint(products.GetPrice, func(ctx context.Context, p *products.PriceParams) (*products.PriceResponse, error) {
        return &products.PriceResponse{Price: 100}, nil
    })
}

----------------------------------------

TITLE: Defining an Encore API Endpoint
DESCRIPTION: Creates a simple API endpoint using Encore's //encore:api annotation. The function accepts a context and returns an error. This makes the function accessible as a public API endpoint in the Encore framework.

LANGUAGE: go
CODE:
//encore:api
func MyAPI(ctx context.Context) (error) {
	return nil
}

----------------------------------------

TITLE: Incorrect Usage of Cache Keyspace Outside of Service
DESCRIPTION: Demonstrates an invalid attempt to create a cache keyspace in a library package that is outside of an Encore service. This will trigger an error as cache keyspaces must be defined within services.

LANGUAGE: go
CODE:
package lib

import (
    "context"

    "encore.dev/storage/cache"
    "test/svc"
)

type Key[T any] struct {
    Foo T
}

var keyspace = cache.NewStringKeyspace[Key[string]](svc.Cluster, cache.KeyspaceConfig{
    KeyPattern: "foo/:Foo",
})

----------------------------------------

TITLE: Implementing Utility Configuration Structures in Go
DESCRIPTION: Defines configuration structures in the utils package that can be imported by the main service. Contains an ExtraConfig struct with string and integer configuration fields using Encore's configuration system.

LANGUAGE: go
CODE:
package utils

import (
	"context"

	"encore.dev/config"
)

type ExtraConfig struct{
    Foo config.String
    Bar config.Int
}

----------------------------------------

TITLE: Defining a Service with Encore.ts
DESCRIPTION: Creates a new Encore service named 'url' which will contain the URL shortener functionality. This file defines the service configuration for Encore's framework.

LANGUAGE: typescript
CODE:
import { Service } from "encore.dev/service";

export default new Service("url");

----------------------------------------

TITLE: Defining a Message Type with PubSub Attributes in Go
DESCRIPTION: Defines a MessageType struct with fields annotated with pubsub-attr tags to specify which fields should be exported as PubSub message attributes.

LANGUAGE: go
CODE:
type MessageType struct {
    ID   int64  `pubsub-attr:"msg-id"`
    Name string `pubsub-attr:"name"`
}

----------------------------------------

TITLE: Generated Auth Handler Implementation by Encore
DESCRIPTION: Auto-generated authentication handler implementation by Encore framework. It registers the auth handler with the API system, defines token extraction from HTTP Authorization headers, and connects the handler to the service implementation.

LANGUAGE: go
CODE:
package code

import (
	"context"
	__api "encore.dev/appruntime/apisdk/api"
	__model "encore.dev/appruntime/exported/model"
	errs "encore.dev/beta/errs"
	"net/http"
	"strings"
)

var EncoreInternal_authhandler_AuthDesc_AuthHandler = &__api.AuthHandlerDesc[string]{
	AuthHandler: func(ctx context.Context, params string) (info __model.AuthInfo, err error) {
		svc, initErr := EncoreInternal_svcstruct_Service.Get()
		if initErr != nil {
			return info, initErr
		}
		info.UID, err = svc.AuthHandler(ctx, params)
		return info, err
	},
	DecodeAuth: func(httpReq *http.Request) (params string, err error) {
		if auth := httpReq.Header.Get("Authorization"); auth != "" {
			for _, prefix := range [...]string{"Bearer ", "Token "} {
				if strings.HasPrefix(auth, prefix) {
					if params = auth[len(prefix):]; params != "" {
						return params, nil
					}
				}
			}
		}
		return "", errs.B().Code(errs.Unauthenticated).Msg("invalid auth param").Err()
	},
	DefLoc:      uint32(0x0),
	Endpoint:    "AuthHandler",
	HasAuthData: false,
	Service:     "code",
	SvcNum:      1,
}

func init() {
	__api.RegisterAuthHandler(EncoreInternal_authhandler_AuthDesc_AuthHandler)
}

----------------------------------------

TITLE: Creating Application-Level Global Middleware in Go
DESCRIPTION: Implements a global middleware that targets all API endpoints across the entire application. This middleware is completely universal and will be applied to every API request.

LANGUAGE: go
CODE:
//encore:middleware global target=all
func AllInSvc(req middleware.Request, next middleware.Next) middleware.Response {
    return next(req)
}

----------------------------------------

TITLE: Pushing a Docker Image to DigitalOcean Registry
DESCRIPTION: Command to push the tagged Docker image to the DigitalOcean container registry.

LANGUAGE: bash
CODE:
docker push registry.digitalocean.com/YOUR_REGISTRY_NAME/myapp:latest

----------------------------------------

TITLE: Defining a Configuration Structure with Encore's Type System
DESCRIPTION: Defines a Config structure with typed configuration fields using Encore's config package. The structure includes various data types like strings, integers, booleans, time, UUID, byte arrays, and string arrays, with inline documentation.

LANGUAGE: go
CODE:
type Config struct {
    Name        config.String    // The users name
    Port        config.Uint16
    ReadOnly    config.Bool      // true if we're in read only mode

    // MagicNumber is complicated and requires
    // a multi-line comment to explain it.
    MagicNumber config.Int

    Start       config.Time // The time at which the service was first started
    ID          config.UUID // An ID

    PublicKey config.Value[[]byte]

    AdminUsers config.Values[string]
}

----------------------------------------

TITLE: Implementing a Public Encore API Endpoint for Data Output
DESCRIPTION: Defines the Bar API endpoint that returns a SomeStruct pointer. This function is marked as a public API using the encore:api directive.

LANGUAGE: go
CODE:
//encore:api public
func Bar(ctx context.Context) (*SomeStruct, error) {
    return nil, nil
}

----------------------------------------

TITLE: Implementing a Simple Keyspace for Rate Limiting in Encore
DESCRIPTION: Example of creating a type-safe cache keyspace for rate limiting user requests. This keyspace stores integer values with automatic expiration after 10 seconds.

LANGUAGE: go
CODE:
var RequestsPerUser = cache.NewIntKeyspace[auth.UID](cluster, cache.KeyspaceConfig{
    KeyPattern:    "requests/:key",
    DefaultExpiry: cache.ExpireIn(10 * time.Second),
})

----------------------------------------

TITLE: Creating Service-Level Tagged Middleware in Go
DESCRIPTION: Implements a service-level middleware that targets all API endpoints with the 'foo' tag. This middleware follows the Encore middleware pattern with request and next function parameters.

LANGUAGE: go
CODE:
//encore:middleware target=tag:foo
func TaggedInSvc(req middleware.Request, next middleware.Next) middleware.Response {
    return next(req)
}

----------------------------------------

TITLE: Original NestJS Controller Example
DESCRIPTION: Example of a traditional NestJS controller for a Cats resource with create, findAll, and findOne methods, showing the standard NestJS approach with decorators.

LANGUAGE: typescript
CODE:
@Controller('cats')
export class CatsController {
  constructor(private readonly catsService: CatsService) {
  }

  @Post()
  @Roles(['admin'])
  async create(@Body() createCatDto: CreateCatDto) {
    this.catsService.create(createCatDto);
  }

  @Get()
  async findAll(): Promise<Cat[]> {
    return this.catsService.findAll();
  }

  @Get(':id')
  findOne(
    @Param('id', new ParseIntPipe())
      id: number,
  ) {
    return this.catsService.get(id);
  }
}

----------------------------------------

TITLE: Defining Main Service with Configuration Structure and API Endpoint in Go
DESCRIPTION: The main service package that imports configuration utilities from helper packages and defines an API endpoint. It uses Encore's configuration system to load settings and exposes a simple API endpoint that returns nil.

LANGUAGE: go
CODE:
package svc

import (
	"context"

	"encore.dev/config"
	"encore.dev/types/uuid"

	"encore.app/svc/utils"
	"encore.app/svc/helpers"
)

type Config struct {
    A helpers.ExtraConfig
    B utils.ExtraConfig
    C helpers.ExtraConfig
    D utils.ExtraConfig
    E helpers.SingleUse
}

var _ = config.Load[*Config]()

//encore:api
func MyAPI(ctx context.Context) (error) {
	return nil
}

----------------------------------------

TITLE: Improving Cow ASCII Art Output
DESCRIPTION: Enhanced version of the cowart function that produces a more elaborate ASCII art cow with a speech bubble containing the user's message. This is the final visual output for the /cowsay command in Slack.

LANGUAGE: typescript
CODE:
const cowart = (msg: string) => `
\`\`\`
+-${"---".repeat(msg.length)}-+
| ${msg} |
+-${"---".repeat(msg.length)}-+
      \\  __n__n__
  .------\`-\\00/-'
 /  ##  ## (oo)
/ \\## __   ./
   |//YY \\|/
   |||   |||
\`\`\`
`;

----------------------------------------

TITLE: Incorrect PubSub Topic Declaration in Encore Service Implementation
DESCRIPTION: This code shows an invalid implementation where a PubSub topic is incorrectly declared inside a function instead of at package level. Encore requires topics to be declared as package level variables for proper initialization and management.

LANGUAGE: go
CODE:
package svc

import (
    "context"

    pb "encore.dev/pubsub"
)

type MyMessage struct {}

//encore:api
func SomeAPI(ctx context.Context) error {
    topic := pb.NewTopic[MyMessage]("basic-topic")
    topic.Publish(ctx, &MyMessage{})
}

----------------------------------------

TITLE: Auto-generated Encore Internal Authentication Handler Implementation
DESCRIPTION: Encore's automatically generated code that implements the authentication handler infrastructure. This code handles parameter decoding from HTTP headers and query parameters, validates the authentication parameters, and registers the handler with Encore's runtime system.

LANGUAGE: go
CODE:
package code

import (
	"context"
	__api "encore.dev/appruntime/apisdk/api"
	__model "encore.dev/appruntime/exported/model"
	__etype "encore.dev/appruntime/shared/etype"
	errs "encore.dev/beta/errs"
	"net/http"
)

var EncoreInternal_authhandler_AuthDesc_AuthHandler = &__api.AuthHandlerDesc[*MyAuthParams]{
	AuthHandler: func(ctx context.Context, params *MyAuthParams) (info __model.AuthInfo, err error) {
		info.UID, info.UserData, err = AuthHandler(ctx, params)
		return info, err
	},
	DecodeAuth: func(httpReq *http.Request) (params *MyAuthParams, err error) {
		params = new(MyAuthParams)
		dec := new(__etype.Unmarshaller)
		// Decode headers
		h := httpReq.Header
		params.ClientID = __etype.UnmarshalOne(dec, __etype.UnmarshalString, "x-client-id", h.Get("x-client-id"), false)

		// Decode query string
		qs := httpReq.URL.Query()
		params.APIKey = __etype.UnmarshalOne(dec, __etype.UnmarshalString, "key", qs.Get("key"), false)

		if dec.NonEmptyValues == 0 {
			return (*MyAuthParams)(nil), errs.B().Code(errs.Unauthenticated).Msg("missing auth param").Err()
		} else if err := dec.Error; err != nil {
			return (*MyAuthParams)(nil), errs.B().Code(errs.InvalidArgument).Msgf("invalid auth param: %v", err).Err()
		}
		return params, nil
	},
	DefLoc:      uint32(0x0),
	Endpoint:    "AuthHandler",
	HasAuthData: true,
	Service:     "code",
	SvcNum:      1,
}

func init() {
	__api.RegisterAuthHandler(EncoreInternal_authhandler_AuthDesc_AuthHandler)
}

func init() {
	__api.RegisterAuthDataType[*MyAuthData]()
}

----------------------------------------

TITLE: Setting Up Encore Database Proxy
DESCRIPTION: Creates a local proxy that forwards incoming connections to databases in the specified environment.

LANGUAGE: shell
CODE:
$ encore db proxy [--env=<name>] [flags]

----------------------------------------

TITLE: Defining an Encore API Endpoint in Go
DESCRIPTION: Implementation of a simple API endpoint using Encore's API annotation. This example shows how to create an API function with a context parameter that returns an error.

LANGUAGE: go
CODE:
//encore:api
func MyAPI(ctx context.Context) (error) {
	return nil
}

----------------------------------------

TITLE: Creating an Encore Infrastructure Configuration File
DESCRIPTION: JSON configuration for connecting an Encore app to an external PostgreSQL database hosted on DigitalOcean, including TLS settings.

LANGUAGE: json
CODE:
{
   "$schema": "https://encore.dev/schemas/infra.schema.json",
   "sql_servers": [
   {
      "host": "mydb.db.ondigitalocean.com:25060",
      "tls_config": {
         "ca": "-----BEGIN CERTIFICATE-----\n..."
      },
      "databases": {
         "mydb": {
            "username": "doadmin",
            "password": {"$env": "DB_PASSWORD"}
          }
      }
   }]   
}

----------------------------------------

TITLE: Installing Required Packages for Auth0 Integration in Go
DESCRIPTION: Shell commands to install the necessary Go packages for OIDC and OAuth2 authentication.

LANGUAGE: shell
CODE:
$ go get github.com/coreos/go-oidc/v3/oidc golang.org/x/oauth2

----------------------------------------

TITLE: Defining a Basic Auth Handler in Encore Service
DESCRIPTION: Implementation of a basic authentication handler service using Encore. The service structure is declared with the 'encore:service' annotation, and the AuthHandler function is marked with 'encore:authhandler' to handle token-based authentication.

LANGUAGE: go
CODE:
package code

import ("context"; "encore.dev/beta/auth")

//encore:service
type Service struct{}

//encore:authhandler
func (*Service) AuthHandler(ctx context.Context, token string) (auth.UID, error) {
    return "", nil
}

----------------------------------------

TITLE: Running Encore Applications
DESCRIPTION: Command to run your Encore application locally with optional debugging and watch mode flags.

LANGUAGE: bash
CODE:
encore run [--debug] [--watch=true] [flags]

----------------------------------------

TITLE: Creating a Slack service directory in Encore
DESCRIPTION: Shell commands to create a new service directory named 'slack' in the application root.

LANGUAGE: shell
CODE:
$ mkdir slack # Create a new directory in the application root
$ touch slack/encore.service.ts

----------------------------------------

TITLE: Defining Service C Configuration in Go
DESCRIPTION: Defines a service configuration struct with a string field and loads it using Encore's config package. The Foo field has a multiline comment.

LANGUAGE: go
CODE:
package svc

import (
	"context"

	"encore.dev/config"
)

type CsConfig struct{
    // Multiline test
    // comment to deduplicate.
    Foo config.String
}

var _ = config.Load[CsConfig]()

----------------------------------------

TITLE: Generated JSON Unmarshalers for Config Types in Go
DESCRIPTION: Automatically generated code by Encore that provides custom unmarshalers for configuration types. Uses the jsoniter library for efficient JSON parsing and handles field mapping according to the JSON tags defined in the original types.

LANGUAGE: go
CODE:
var (
	encoreInternalConfigUnmarshaler_ptr_svc_Config = func(itr *jsoniter.Iterator, path []string) *Config {
		return func() *Config {
			// If the value is null, we return nil
			if itr.ReadNil() {
				return nil
			}

			// Otherwise we unmarshal the value and return a pointer to it
			obj := encoreInternalTypeConfigUnmarshaler_svc_Config(itr, append(path))
			return &obj
		}()
	}
)

----------------------------------------

TITLE: Creating a PubSub Subscription in First Service
DESCRIPTION: Creates a PubSub subscription in the svc service with a handler function named Subscriber1. This subscription uses the name 'same-name' which will cause a conflict when the same name is used in another service.

LANGUAGE: go
CODE:
package svc

import (
    "context"

    "encore.dev/pubsub"

    "test/shared"
)


var (
    _ = pubsub.NewSubscription(shared.BasicTopic, "same-name", pubsub.SusbcriptionConfig { Handler: Subscriber1 })
)

// encore:api
func Subscriber1(ctx context.Context, msg *shared.MessageType) error {
    return nil
}

----------------------------------------

TITLE: Defining Configuration Structure in Service B
DESCRIPTION: Defines a BsConfig structure with a string configuration field. The structure includes an inline comment for the Foo field.

LANGUAGE: go
CODE:
package svc

import (
	"encore.dev/config"
)

type BsConfig struct{
    Foo config.String // Some extra comment
}

var _ = config.Load[BsConfig]()

----------------------------------------

TITLE: Loading Configuration using Encore's Config System
DESCRIPTION: Loads the configuration struct using Encore's config.Load generic function. This statement initializes the configuration system to use the Config struct as its schema.

LANGUAGE: go
CODE:
var _ = config.Load[*Config]()

----------------------------------------

TITLE: Go Module Definition
DESCRIPTION: A go.mod file that declares the module name as example.com.

LANGUAGE: go
CODE:
module example.com

----------------------------------------

TITLE: Defining Helper Configuration Types in Go
DESCRIPTION: Implements helper configuration types including ExtraConfig with String and Value fields, and a SingleUse type. These types are used by the main service configuration.

LANGUAGE: go
CODE:
package helpers

import (
	"encore.dev/config"
)

type ExtraConfig struct{
    Foo config.String
    Baz config.Value[[]byte]
}

type SingleUse struct {
    Lock bool
}

----------------------------------------

TITLE: Implementing Public API Endpoints in svca Service
DESCRIPTION: Defines two public API endpoints in the svca service: Foo which returns nil, and Bar which calls Foo.

LANGUAGE: go
CODE:
package svca

import "context"

//encore:api public
func Foo(ctx context.Context) error { return nil }

//encore:api public
func Bar(ctx context.Context) error { return Foo(ctx) }

----------------------------------------

TITLE: Environment-Based Behavior in Encore.ts
DESCRIPTION: Shows how to modify application behavior based on the current environment type using appMeta(). In test and development environments, it automatically marks emails as verified, while in other environments it sends verification emails.

LANGUAGE: typescript
CODE:
switch (appMeta().environment.type) {
  case "test":
  case "development":
    await markEmailVerified(userID);
    break;
  default:
    await sendVerificationEmail(userID);
    break;
}

----------------------------------------

TITLE: Building and deploying to Encore Cloud
DESCRIPTION: Git commands to commit changes and deploy the application to Encore Cloud.

LANGUAGE: shell
CODE:
$ git add -A .
$ git commit -m 'Add slack integration'
$ git push encore

----------------------------------------

TITLE: Defining a Secret in Encore
DESCRIPTION: Shows how to define a secret using the secret function from Encore's config module. This example creates a GitHub API token secret that can be used in the application.

LANGUAGE: typescript
CODE:
import { secret } from "encore.dev/config";

const githubToken = secret("GitHubAPIToken");

----------------------------------------

TITLE: Defining Service Configuration Structures in Go
DESCRIPTION: Defines configuration structures for an Encore service, including ServerOption for individual protocol settings and a Config struct that aggregates multiple server options. Uses JSON struct tags to control serialization behavior.

LANGUAGE: go
CODE:
type ServerOption struct {
    Option   int64
    Disabled bool `json:",omitempty"` // True if this is disabled
}

type Config struct {
    HTTP    ServerOption
    Another ServerOption `json:"a_n_o_t_h_e_r"`
    TCP     ServerOption `json:",omitempty"`
    GRPC    ServerOption `json:",omitempty"`
}

----------------------------------------

TITLE: Config Struct JSON Unmarshaler Implementation in Go
DESCRIPTION: Generated unmarshal function for the Config type that handles field-by-field JSON parsing. Maps JSON fields to struct fields according to defined tags and handles nested ServerOption objects.

LANGUAGE: go
CODE:
func encoreInternalTypeConfigUnmarshaler_svc_Config(itr *jsoniter.Iterator, path []string) (obj Config) {
	itr.ReadObjectCB(func(itr *jsoniter.Iterator, field string) bool {
		switch field {
		case "HTTP":
			obj.HTTP = encoreInternalTypeConfigUnmarshaler_svc_ServerOption(itr, append(path, "HTTP"))
		case "a_n_o_t_h_e_r":
			obj.Another = encoreInternalTypeConfigUnmarshaler_svc_ServerOption(itr, append(path, "a_n_o_t_h_e_r"))
		case "TCP":
			obj.TCP = encoreInternalTypeConfigUnmarshaler_svc_ServerOption(itr, append(path, "TCP"))
		case "GRPC":
			obj.GRPC = encoreInternalTypeConfigUnmarshaler_svc_ServerOption(itr, append(path, "GRPC"))
		default:
			itr.Skip()
		}
		return true
	})
	return
}

----------------------------------------

TITLE: Defining Public API Endpoint with Tag in Go
DESCRIPTION: Defines a public API endpoint with the 'foo' tag which can be used for middleware targeting. The function takes a context parameter and returns an error.

LANGUAGE: go
CODE:
//encore:api public tag:foo
func API(ctx context.Context) error { return nil }

----------------------------------------

TITLE: Generated Configuration Unmarshalers for Encore
DESCRIPTION: Automatically generated code providing unmarshalers for all config structures. This file includes functions for unmarshaling JSON to strongly typed config objects and handling nested configuration paths.

LANGUAGE: go
CODE:
package svc

import (
	config "encore.dev/config"
	jsoniter "github.com/json-iterator/go"
)

/*
These functions are automatically generated and maintained by Encore to allow config values
to be unmarshalled into the correct types. They are not intended to be used directly. They
are automatically updated by Encore whenever you change the data types used within your
calls to config.Load[T]().
*/

// Concrete unmarshalers for all config.Load calls, including those using generic types.
// These instances are used directly by calls to `config.Load[T]()`.
var (
	encoreInternalConfigUnmarshaler_ptr_svc_AsConfig = func(itr *jsoniter.Iterator, path []string) *AsConfig {
		return func() *AsConfig {
			// If the value is null, we return nil
			if itr.ReadNil() {
				return nil
			}

			// Otherwise we unmarshal the value and return a pointer to it
			obj := encoreInternalTypeConfigUnmarshaler_svc_AsConfig(itr, append(path))
			return &obj
		}()
	}
	encoreInternalConfigUnmarshaler_svc_BsConfig = encoreInternalTypeConfigUnmarshaler_svc_BsConfig
	encoreInternalConfigUnmarshaler_svc_CsConfig = encoreInternalTypeConfigUnmarshaler_svc_CsConfig
	encoreInternalConfigUnmarshaler_svc_DsConfig = encoreInternalTypeConfigUnmarshaler_svc_DsConfig
)

// encoreInternalTypeConfigUnmarshaler_svc_AsConfig will unmarshal the JSON representation into the given type, taking account for
// the `config.Value` dynamic functions.
func encoreInternalTypeConfigUnmarshaler_svc_AsConfig(itr *jsoniter.Iterator, path []string) (obj AsConfig) {
	itr.ReadObjectCB(func(itr *jsoniter.Iterator, field string) bool {
		switch field {
		case "Foo":
			obj.Foo = config.CreateValue[string](itr.ReadString(), append(path, "Foo"))
		default:
			itr.Skip()
		}
		return true
	})
	return
}

// encoreInternalTypeConfigUnmarshaler_svc_BsConfig will unmarshal the JSON representation into the given type, taking account for
// the `config.Value` dynamic functions.
func encoreInternalTypeConfigUnmarshaler_svc_BsConfig(itr *jsoniter.Iterator, path []string) (obj BsConfig) {
	itr.ReadObjectCB(func(itr *jsoniter.Iterator, field string) bool {
		switch field {
		case "Foo":
			obj.Foo = config.CreateValue[string](itr.ReadString(), append(path, "Foo"))
		default:
			itr.Skip()
		}
		return true
	})
	return
}

// encoreInternalTypeConfigUnmarshaler_svc_CsConfig will unmarshal the JSON representation into the given type, taking account for
// the `config.Value` dynamic functions.
func encoreInternalTypeConfigUnmarshaler_svc_CsConfig(itr *jsoniter.Iterator, path []string) (obj CsConfig) {
	itr.ReadObjectCB(func(itr *jsoniter.Iterator, field string) bool {
		switch field {
		case "Foo":
			obj.Foo = config.CreateValue[string](itr.ReadString(), append(path, "Foo"))
		default:
			itr.Skip()
		}
		return true
	})
	return
}

// encoreInternalTypeConfigUnmarshaler_svc_DsConfig will unmarshal the JSON representation into the given type, taking account for
// the `config.Value` dynamic functions.
func encoreInternalTypeConfigUnmarshaler_svc_DsConfig(itr *jsoniter.Iterator, path []string) (obj DsConfig) {
	itr.ReadObjectCB(func(itr *jsoniter.Iterator, field string) bool {
		switch field {
		case "Foo":
			obj.Foo = config.CreateValue[string](itr.ReadString(), append(path, "Foo"))
		default:
			itr.Skip()
		}
		return true
	})
	return
}

----------------------------------------

TITLE: Datadog Metrics Configuration
DESCRIPTION: Configuration for exporting metrics to Datadog. Specifies the collection interval, Datadog site, and API key for sending metrics data to a Datadog account.

LANGUAGE: json
CODE:
{
  "metrics": {
    "type": "datadog",
    "collection_interval": 30,
    "site": "datadoghq.com",
    "api_key": {
      "$env": "DATADOG_API_KEY"
    }
  }
}

----------------------------------------

TITLE: Type-Specific Config Unmarshaler Implementation for Encore
DESCRIPTION: Generated function that handles the specific unmarshaling for the Config type. Parses JSON objects field by field, mapping them to the appropriate struct fields including the nested HTTP struct with its Enabled and Port properties.

LANGUAGE: go
CODE:
func encoreInternalTypeConfigUnmarshaler_svc_Config(itr *jsoniter.Iterator, path []string) (obj Config) {
	itr.ReadObjectCB(func(itr *jsoniter.Iterator, field string) bool {
		switch field {
		case "HTTP":
			obj.HTTP = func() (obj struct {
				Enabled bool
				Port    uint32
			}) {
				itr.ReadObjectCB(func(itr *jsoniter.Iterator, field string) bool {
					switch field {
					case "Enabled":
						obj.Enabled = itr.ReadBool()
					case "Port":
						obj.Port = itr.ReadUint32()
					default:
						itr.Skip()
					}
					return true
				})
				return
			}()
		default:
			itr.Skip()
		}
		return true
	})
	return
}

----------------------------------------

TITLE: Expected Test Output
DESCRIPTION: A file containing the expected output from running the application, which should be "Hello, rewritten world!".

LANGUAGE: plaintext
CODE:
Hello, rewritten world!

----------------------------------------

TITLE: Running Encore Docker Images with Custom Port Configuration
DESCRIPTION: Example showing how to run an Encore Docker image with a custom port configuration using the PORT environment variable. By default, Encore images run on port 8080, but this can be overridden.

LANGUAGE: bash
CODE:
docker run -e PORT=8081 -p 8081:8081 MY-IMAGE:TAG

----------------------------------------

TITLE: Generated API Endpoint Registration and Handling (encore_internal__api.go)
DESCRIPTION: Auto-generated code that registers API endpoints with Encore's runtime. It defines request/response types, encoding/decoding functions, and HTTP routing details for the Foo endpoint.

LANGUAGE: go
CODE:
package svca

import (
	"context"
	__api "encore.dev/appruntime/apisdk/api"
	jsoniter "github.com/json-iterator/go"
	"net/http"
	"net/url"
)

func init() {
	__api.RegisterEndpoint(EncoreInternal_api_APIDesc_Foo, Foo)
}

type EncoreInternal_FooReq struct{}

type EncoreInternal_FooResp = __api.Void

var EncoreInternal_api_APIDesc_Foo = &__api.Desc[*EncoreInternal_FooReq, EncoreInternal_FooResp]{
	Access: __api.Public,
	AppHandler: func(ctx context.Context, reqData *EncoreInternal_FooReq) (EncoreInternal_FooResp, error) {
		svc, initErr := EncoreInternal_svcstruct_Service.Get()
		if initErr != nil {
			return __api.Void{}, initErr
		}
		err := svc.Foo(ctx)
		if err != nil {
			return __api.Void{}, err
		}
		return __api.Void{}, nil
	},
	CloneReq: func(r *EncoreInternal_FooReq) (*EncoreInternal_FooReq, error) {
		var clone *EncoreInternal_FooReq
		bytes, err := jsoniter.ConfigDefault.Marshal(r)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return clone, err
	},
	CloneResp: func(r EncoreInternal_FooResp) (EncoreInternal_FooResp, error) {
		var clone EncoreInternal_FooResp
		bytes, err := jsoniter.ConfigDefault.Marshal(r)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return clone, err
	},
	DecodeExternalResp: func(httpResp *http.Response, json jsoniter.API) (resp EncoreInternal_FooResp, err error) {
		return __api.Void{}, nil
	},
	DecodeReq: func(httpReq *http.Request, ps __api.UnnamedParams, json jsoniter.API) (reqData *EncoreInternal_FooReq, pathParams __api.UnnamedParams, err error) {
		reqData = new(EncoreInternal_FooReq)
		return reqData, nil, nil
	},
	DefLoc: uint32(0x0),
	EncodeExternalReq: func(reqData *EncoreInternal_FooReq, stream *jsoniter.Stream) (httpHeader http.Header, queryString url.Values, err error) {
		return nil, nil, nil
	},
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, resp EncoreInternal_FooResp) (err error) {
		return nil
	},
	Endpoint:            "Foo",
	Fallback:            false,
	GlobalMiddlewareIDs: []string{},
	Methods:             []string{"GET", "POST"},
	Path:                "/svca.Foo",
	PathParamNames:      nil,
	Raw:                 false,
	RawHandler:          nil,
	RawPath:             "/svca.Foo",
	ReqPath: func(reqData *EncoreInternal_FooReq) (string, __api.UnnamedParams, error) {
		return "/svca.Foo", nil, nil
	},
	ReqUserPayload: func(reqData *EncoreInternal_FooReq) any {
		return nil
	},
	Service:           "svca",
	ServiceMiddleware: []*__api.Middleware{},
	SvcNum:            1,
	Tags:              nil,
}

----------------------------------------

TITLE: Defining an Encore service
DESCRIPTION: TypeScript code for creating a basic Encore service, which is required for running an Encore.ts application. This defines the service structure that will contain your APIs.

LANGUAGE: typescript
CODE:
import {Service} from "encore.dev/service";

export default new Service("my-service");

----------------------------------------

TITLE: Multiple Service Structs Error in Encore
DESCRIPTION: This Go code shows the error case of defining multiple service structs in the same Encore service. The code defines two structs with the '//encore:service' directive, which violates Encore's rule of allowing only one service struct per service.

LANGUAGE: go
CODE:
package svc

import (
	"context"
	"encore.dev/types/uuid"
)

//encore:service
type Service struct {}

//encore:service
type Duplicate struct {}

type Params struct{}

//encore:api public
func (s *Service) Str(ctx context.Context, p *Params) error { return nil }

----------------------------------------

TITLE: Loading Configuration in Encore
DESCRIPTION: Uses Encore's configuration loading mechanism to load a Config instance parameterized with uint type. The result is assigned to a blank identifier to ensure it's executed.

LANGUAGE: Go
CODE:
var _ = config.Load[*Config[uint]]()

----------------------------------------

TITLE: Starting Encore Application with Local Development Dashboard
DESCRIPTION: Command to start an Encore application locally using 'encore run', which launches both the application and its development dashboard. The output shows the local API URL and dashboard URL.

LANGUAGE: bash
CODE:
$ encore run
API Base URL:      http://localhost:4000
Dev Dashboard URL: http://localhost:9400/hello-world-cgu2

----------------------------------------

TITLE: Generated Code: Loading OtherConfig with Automatic Unmarshaler
DESCRIPTION: Shows the generated code for loading OtherConfig with an automatically generated unmarshal function. This code is created by Encore to support the config loading system.

LANGUAGE: go
CODE:
package svc

import (
	"encore.dev/config"
)

type OtherConfig struct{
    Foo config.String // Foo is great in Otherconfig
    Bar config.Int
}

var _ = config.Load[OtherConfig]("svc", encoreInternalConfigUnmarshaler_svc_OtherConfig/*line :12:34*/)

----------------------------------------

TITLE: Defining Public Encore API with Invalid Import
DESCRIPTION: This Go code defines a simple Encore service with a public API endpoint called Foo. The code imports encore.dev/et which is only allowed in test files, causing a compilation error. The function itself is trivial and just returns nil.

LANGUAGE: go
CODE:
package svc

import (
    "context"

    "encore.dev/et"
)

//encore:api public
func Foo(context.Context) error { return nil }

----------------------------------------

TITLE: Re-exporting All from a Module in TypeScript
DESCRIPTION: Re-exports all exports from the './bar' module. This pattern is used to aggregate and forward all exports from one module through another without explicitly listing each one.

LANGUAGE: typescript
CODE:
export * from "./bar";

----------------------------------------

TITLE: Encore Auto-Generated Config Unmarshal Implementation
DESCRIPTION: Automatically generated code by Encore to handle config unmarshaling. It defines functions to convert JSON configuration data into the Config struct with proper type handling for the Ages map.

LANGUAGE: go
CODE:
package svc

import (
	__etype "encore.dev/appruntime/shared/etype"
	config "encore.dev/config"
	"fmt"
	jsoniter "github.com/json-iterator/go"
)

/*
These functions are automatically generated and maintained by Encore to allow config values
to be unmarshalled into the correct types. They are not intended to be used directly. They
are automatically updated by Encore whenever you change the data types used within your
calls to config.Load[T]().
*/

// Concrete unmarshalers for all config.Load calls, including those using generic types.
// These instances are used directly by calls to `config.Load[T]()`.
var (
	encoreInternalConfigUnmarshaler_ptr_svc_Config = func(itr *jsoniter.Iterator, path []string) *Config {
		return func() *Config {
			// If the value is null, we return nil
			if itr.ReadNil() {
				return nil
			}

			// Otherwise we unmarshal the value and return a pointer to it
			obj := encoreInternalTypeConfigUnmarshaler_svc_Config(itr, append(path))
			return &obj
		}()
	}
)

// encoreInternalTypeConfigUnmarshaler_svc_Config will unmarshal the JSON representation into the given type, taking account for
// the `config.Value` dynamic functions.
func encoreInternalTypeConfigUnmarshaler_svc_Config(itr *jsoniter.Iterator, path []string) (obj Config) {
	itr.ReadObjectCB(func(itr *jsoniter.Iterator, field string) bool {
		switch field {
		case "Ages":
			obj.Ages = config.ReadMap[string, int](itr, func(itr *jsoniter.Iterator, keyAsString string) (string, int) {
				// Decode the map key from the JSON string to the underlying type it needs to be
				keyDecoder := new(__etype.Unmarshaller)
				key := __etype.UnmarshalOne(keyDecoder, __etype.UnmarshalString, "keyAsString", keyAsString, true)
				if err := keyDecoder.Error; err != nil {
					panic(fmt.Sprintf("unable to decode the config: %v", err))
				}
				return key, itr.ReadInt()
			})
		default:
			itr.Skip()
		}
		return true
	})
	return
}

----------------------------------------

TITLE: Encore API Registration and Request Handling Implementation
DESCRIPTION: Auto-generated code that handles API registration, request/response processing, and HTTP routing for the 'Tagged' endpoint. It includes functions for encoding/decoding requests and responses, cloning objects, and API metadata.

LANGUAGE: go
CODE:
package code

import (
	"context"
	__api "encore.dev/appruntime/apisdk/api"
	jsoniter "github.com/json-iterator/go"
	"net/http"
	"net/url"
)

func init() {
	__api.RegisterEndpoint(EncoreInternal_api_APIDesc_Tagged, Tagged)
}

type EncoreInternal_TaggedReq struct{}

type EncoreInternal_TaggedResp = __api.Void

var EncoreInternal_api_APIDesc_Tagged = &__api.Desc[*EncoreInternal_TaggedReq, EncoreInternal_TaggedResp]{
	Access: __api.Public,
	AppHandler: func(ctx context.Context, reqData *EncoreInternal_TaggedReq) (EncoreInternal_TaggedResp, error) {
		err := Tagged(ctx)
		if err != nil {
			return __api.Void{}, err
		}
		return __api.Void{}, nil
	},
	CloneReq: func(r *EncoreInternal_TaggedReq) (*EncoreInternal_TaggedReq, error) {
		var clone *EncoreInternal_TaggedReq
		bytes, err := jsoniter.ConfigDefault.Marshal(r)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return clone, err
	},
	CloneResp: func(r EncoreInternal_TaggedResp) (EncoreInternal_TaggedResp, error) {
		var clone EncoreInternal_TaggedResp
		bytes, err := jsoniter.ConfigDefault.Marshal(r)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return clone, err
	},
	DecodeExternalResp: func(httpResp *http.Response, json jsoniter.API) (resp EncoreInternal_TaggedResp, err error) {
		return __api.Void{}, nil
	},
	DecodeReq: func(httpReq *http.Request, ps __api.UnnamedParams, json jsoniter.API) (reqData *EncoreInternal_TaggedReq, pathParams __api.UnnamedParams, err error) {
		reqData = new(EncoreInternal_TaggedReq)
		return reqData, nil, nil
	},
	DefLoc: uint32(0x0),
	EncodeExternalReq: func(reqData *EncoreInternal_TaggedReq, stream *jsoniter.Stream) (httpHeader http.Header, queryString url.Values, err error) {
		return nil, nil, nil
	},
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, resp EncoreInternal_TaggedResp) (err error) {
		return nil
	},
	Endpoint:            "Tagged",
	Fallback:            false,
	GlobalMiddlewareIDs: []string{},
	Methods:             []string{"GET", "POST"},
	Path:                "/code.Tagged",
	PathParamNames:      nil,
	Raw:                 false,
	RawHandler:          nil,
	RawPath:             "/code.Tagged",
	ReqPath: func(reqData *EncoreInternal_TaggedReq) (string, __api.UnnamedParams, error) {
		return "/code.Tagged", nil, nil
	},
	ReqUserPayload: func(reqData *EncoreInternal_TaggedReq) any {
		return nil
	},
	Service:           "code",
	ServiceMiddleware: []*__api.Middleware{},
	SvcNum:            1,
	Tags:              []string{"bar", "foo"},
}

----------------------------------------

TITLE: Defining Book Service with Encore
DESCRIPTION: Service definition file for the Book service using Encore's Service class. This establishes the book directory as a service within the Encore application.

LANGUAGE: typescript
CODE:
import { Service } from "encore.dev/service";

export default new Service("book");

----------------------------------------

TITLE: Implementing Shopping Cart Service in Go with Encore Framework
DESCRIPTION: Definition of a shopping cart service using Encore framework annotations. It manages cart items and provides public and private API endpoints for calculating totals and emptying the cart.

LANGUAGE: go
CODE:
package shoppingcart

import (
    "context"

    "test/products"
)

type CartItem struct {
    ProductID int
    Quantity int
}

//encore:service
type Service struct {
    Items []CartItem
}

func initService() (*Service, error) {
    return &Service{
        Items: []CartItem{
            { ProductID: 1, Quantity: 2 },
            { ProductID: 2, Quantity: 1 },
        },
    }, nil
}

type TotalResult struct {
    Total float64
}

//encore:api public method=GET path=/cart/total
func (s *Service) Total(ctx context.Context) (*TotalResult, error) {
    var total float64

    for _, item := range s.Items {
        price, err := products.GetPrice(ctx, item.ProductID, &products.PriceParams{ Quantity: item.Quantity })
        if err != nil {
            return nil, err
        }

        total += price.Total
    }

    return &TotalResult{ Total: total }, nil
}

//encore:api private
func (s *Service) Empty(ctx context.Context) error {
    s.Items = []CartItem{}
    return nil
}

----------------------------------------

TITLE: Parsing Shell Command for RPC Service Detection
DESCRIPTION: A shell command that parses and outputs RPC service definitions matching a specific pattern. The command looks for public RPC services with a receiver of type *Service.

LANGUAGE: Shell
CODE:
parse
output 'rpc svc.Str access=public .* recv=\*Service'

----------------------------------------

TITLE: Defining an Encore API Endpoint
DESCRIPTION: Creates a simple API endpoint called MyAPI using Encore's API annotation. This function takes a context parameter and returns an error, providing the foundation for an HTTP endpoint.

LANGUAGE: go
CODE:
//encore:api
func MyAPI(ctx context.Context) (error) {
	return nil
}

----------------------------------------

TITLE: Testing the Booking Endpoint with cURL
DESCRIPTION: Shell command to test the booking endpoint by sending a POST request with JSON data containing appointment details. This demonstrates how to interact with the API.

LANGUAGE: shell
CODE:
$ curl -X POST 'http://localhost:4000/booking' -d '{"start": "2024-12-11T09:00:00Z", "email": "test@example.com"}'

----------------------------------------

TITLE: Generated Code: Loading ThisConfig with Automatic Unmarshaler
DESCRIPTION: Shows the generated code for loading ThisConfig with an automatically generated unmarshal function. This code is created by Encore to support the config loading system.

LANGUAGE: go
CODE:
package svc

import (
	"encore.dev/config"
)

type ThisConfig struct{
    Foo config.String // And even better in ThisConfig
    Baz config.Bool
}

var _ = config.Load[ThisConfig]("svc", encoreInternalConfigUnmarshaler_svc_ThisConfig/*line :12:33*/)

----------------------------------------

TITLE: Invalid Nested Config Value Type in Encore Application
DESCRIPTION: This snippet demonstrates an incorrect configuration structure in an Encore application where a config.Value type is nested inside another config.Value, which is not allowed. The code also includes a simple API endpoint function.

LANGUAGE: go
CODE:
package svc

import (
    "context"

    "encore.dev/config"
)

type Config struct {
    Name config.Value[config.Value[string]]
}

var cfg = config.Load[Config]()


// encore:api
func Subscriber1(ctx context.Context) error {
    return nil
}

----------------------------------------

TITLE: Creating a Catch-All Handler for HTTP Router in Encore
DESCRIPTION: Example of creating a Raw endpoint in Encore that acts as a catch-all handler for an existing HTTP router, allowing you to migrate existing Go applications without significant refactoring.

LANGUAGE: go
CODE:
//encore:api public raw path=/api/*path
func MigrationHandler(w http.ResponseWriter, req *http.Request) {
// pass request to existing router
}

----------------------------------------

TITLE: Defining an Encore Service with SQL Database Integration
DESCRIPTION: Establishes a service package with SQL database connectivity using Encore's sqldb package. It defines a named database connection and exposes a public API endpoint.

LANGUAGE: go
CODE:
package svc

import (
    "context"

    "encore.dev/storage/sqldb"
)

var Moo = sqldb.Named("svc")

//encore:api public
func Foo(ctx context.Context) error {
    return nil
}

----------------------------------------

TITLE: Package Configuration for Encore Project
DESCRIPTION: The package.json configuration for an Encore project named 'foo'. It specifies the project is an ES module and includes the encore.dev dependency.

LANGUAGE: JSON
CODE:
{
  "name": "foo",
  "type": "module",
  "dependencies": {
    "encore.dev": "^1.35.0"
  }
}

----------------------------------------

TITLE: Enabling Worker Pooling in Encore.ts Configuration
DESCRIPTION: JSON configuration to enable Worker Pooling in Encore.ts by adding it to the encore.app file. This setting allows Encore.ts to start multiple NodeJS event loops and load-balance requests across them for better performance with CPU-intensive workloads.

LANGUAGE: json
CODE:
"build": {"worker_pooling": true}

----------------------------------------

TITLE: Creating a Public API Endpoint with Encore
DESCRIPTION: Implements a simple public API endpoint 'Foo' using Encore's annotation system. The function takes a Recursive type pointer and returns the same pointer without modifications.

LANGUAGE: go
CODE:
//encore:api public
func Foo(ctx context.Context, p *Recursive) (*Recursive, error) { return p, nil }

----------------------------------------

TITLE: Overriding Authentication Context
DESCRIPTION: Example of using auth.WithContext to override authentication information for testing or specific requests, by creating a new context with custom user ID and auth data.

LANGUAGE: go
CODE:
ctx := auth.WithContext(context.Background(), auth.UID("my-user-id"), &MyAuthData{})

----------------------------------------

TITLE: Defining Configuration Structure in Encore
DESCRIPTION: Defines a configuration hierarchy for server options in an Encore application. The structure includes options for HTTP, TCP, and gRPC servers, each with enabled status and port configuration.

LANGUAGE: go
CODE:
// ServerOptions represent options for a server
type ServerOptions struct {
    Enabled bool // Is this option enabled?
    Port    uint32 // What port should we run on?
}

type Config struct {
    HTTP ServerOptions // The options for the HTTP server
    TCP  ServerOptions // The options for the TCP server
    GRPC ServerOptions // The options for the GRPC server
}

----------------------------------------

TITLE: Running the Encore application locally
DESCRIPTION: Commands to navigate to the project directory and run the Encore application locally, allowing access to the frontend through localhost.

LANGUAGE: shell
CODE:
$ cd booking-system
$ encore run

----------------------------------------

TITLE: Defining Service Configuration Structure in Go
DESCRIPTION: Defines a Config struct that incorporates configuration types from helper and utility packages. Uses the config.Load function to load configuration values.

LANGUAGE: go
CODE:
package svc

import (
	"context"

	"encore.dev/config"

	"example.com/svc/utils"
	"example.com/svc/helpers"
)

type Config struct {
    A helpers.ExtraConfig
    B utils.ExtraConfig
    C helpers.ExtraConfig
    D utils.ExtraConfig
    E helpers.SingleUse
}

var _ = config.Load[*Config]()

//encore:api
func MyAPI(ctx context.Context) (error) {
	return nil
}

----------------------------------------

TITLE: Defining Cron Job with External Endpoint in Go
DESCRIPTION: Creates a cron job named 'cron-external' that runs every minute and calls an external endpoint instead of an internal API. This demonstrates connecting cron jobs to endpoints in different packages.

LANGUAGE: go
CODE:
// A cron job using an external endpoint
var _ = cron.NewJob("cron-external", cron.JobConfig{
	Every:    cron.Minute,
	Endpoint: external.Endpoint,
})

----------------------------------------

TITLE: Injecting Config Unmarshalers in Encore's Configuration System
DESCRIPTION: Shows how Encore's build system modifies the config.Load call to inject the auto-generated unmarshalers. The configuration is loaded for the "svc" service with a specific unmarshaler function.

LANGUAGE: go
CODE:
var _ = config.Load[*Config]("svc", encoreInternalConfigUnmarshaler_ptr_svc_Config/*line :15:30*/)

----------------------------------------

TITLE: Implementing External Endpoint for Cron Jobs in Go
DESCRIPTION: Defines an external endpoint function that can be called by cron jobs. This private API takes a context and returns a nil error, serving as a simple target for cron job execution.

LANGUAGE: go
CODE:
//encore:api private
func Endpoint(ctx context.Context) error {
	return nil
}

----------------------------------------

TITLE: Package Configuration for Encore Project
DESCRIPTION: Package.json configuration for an Encore project. Specifies the project name, module type, and includes the encore.dev dependency at version 1.35.0 or higher.

LANGUAGE: json
CODE:
{
  "name": "foo",
  "type": "module",
  "dependencies": {
    "encore.dev": "^1.35.0"
  }
}

----------------------------------------

TITLE: Defining Configuration with Dynamic String and Bool Values
DESCRIPTION: Creates a ThisConfig struct using config.String and config.Bool dynamic types. Loads the configuration using config.Load with the struct type.

LANGUAGE: go
CODE:
package svc

import (
	"encore.dev/config"
)

type ThisConfig struct{
    Foo config.String // And even better in ThisConfig
    Baz config.Bool
}

var _ = config.Load[ThisConfig]()

----------------------------------------

TITLE: Implementing Basic Middleware in Encore
DESCRIPTION: Defines a simple middleware function that accepts requests and passes them to the next handler without modification. The encore:middleware directive specifies that this middleware applies to all endpoints.

LANGUAGE: go
CODE:
//encore:middleware target=all
func Middleware(req middleware.Request, next middleware.Next) middleware.Response {
    return next(req)
}

----------------------------------------

TITLE: Auto-generated Main Entry Point for Encore Application
DESCRIPTION: Encore-generated main package that imports all service packages and initializes the application using the Encore runtime.

LANGUAGE: go
CODE:
package main

import (
	appinit "encore.dev/appruntime/apisdk/app/appinit"
	_ "example.com/bar"
	_ "example.com/foo"
)

func main() {
	appinit.AppMain()
}

----------------------------------------

TITLE: Defining Encore Service Structure and API in Go
DESCRIPTION: Defines a basic Encore service struct with an initialization function and a simple API endpoint. The service is annotated with the encore:service directive, and the API function is annotated with encore:api to expose it as an endpoint.

LANGUAGE: go
CODE:
package basic

import "context"

//encore:service
type Service struct {
}

func initService() (*Service, error) {
    return nil, nil
}

//encore:api
func API(context.Context) error { return nil }

----------------------------------------

TITLE: Defining Encore Service Structure and API in Go
DESCRIPTION: Defines a basic Encore service struct with an initialization function and a simple API endpoint. The service is annotated with the encore:service directive, and the API function is annotated with encore:api to expose it as an endpoint.

LANGUAGE: go
CODE:
package basic

import "context"

//encore:service
type Service struct {
}

func initService() (*Service, error) {
    return nil, nil
}

//encore:api
func API(context.Context) error { return nil }

----------------------------------------

TITLE: Testing Complete Incident Management Workflow with cURL
DESCRIPTION: A series of cURL commands that demonstrate the complete workflow of the incident management system, including creating a user, scheduling them for on-call duty, triggering an incident, and acknowledging the incident.

LANGUAGE: bash
CODE:
# Step 1: Create a User and copy the User ID to your clipboard
curl -d '{
  "FirstName":"Katy",
  "LastName":"Smith",
  "SlackHandle":"katy"
}' http://localhost:4000/users

# Step 2: Create a schedule for the user we just created
curl -d '{
  "Start":"2022-09-28T10:00:00Z",
  "End":"2022-09-29T10:00:00Z"
}' "http://localhost:4000/users/1/schedules"

# Step 3: Trigger an incident
curl -d '{
  "Body":"An unexpected error happened on example-website.com on line 38. It needs addressing now!"
}' http://localhost:4000/incidents

# Step 4: Acknowledge the Incident
curl -X PUT "http://localhost:4000/incidents/1/acknowledge"

----------------------------------------

TITLE: Creating a Nested Generic Configuration Type in Go
DESCRIPTION: Defines a nested configuration type that utilizes the same generic type parameter as its parent structure. This allows for type consistency between parent and child configuration elements.

LANGUAGE: go
CODE:
type SubCfgType[T any] struct {
	MaxCount T
}

----------------------------------------

TITLE: Defining Cron Job for Push Notifications in Go
DESCRIPTION: Creates a cron job named 'cronfoocious' for sending push notifications to new subscribers. The job runs every Thursday and calls the CronAPI endpoint.

LANGUAGE: go
CODE:
// A cron job to send out push notifications to new subscribers.
var _ = cron.NewJob("cronfoocious", cron.JobConfig{
	Title:     "Cron Foo Bar Bazz",
	Schedule: "* * * * 4",
	Endpoint: CronAPI,
})

----------------------------------------

TITLE: Automatically Generated Config Unmarshaler for Encore Service
DESCRIPTION: Generated code for unmarshaling JSON configuration into Go structures. This code is automatically created by Encore to handle the conversion of JSON configuration into the defined Config and ServerOption types, with special handling for null values and nested structures.

LANGUAGE: go
CODE:
package svc

import jsoniter "github.com/json-iterator/go"

/*
These functions are automatically generated and maintained by Encore to allow config values
to be unmarshalled into the correct types. They are not intended to be used directly. They
are automatically updated by Encore whenever you change the data types used within your
calls to config.Load[T]().
*/

// Concrete unmarshalers for all config.Load calls, including those using generic types.
// These instances are used directly by calls to `config.Load[T]()`.
var (
	encoreInternalConfigUnmarshaler_ptr_svc_Config = func(itr *jsoniter.Iterator, path []string) *Config {
		return func() *Config {
			// If the value is null, we return nil
			if itr.ReadNil() {
				return nil
			}

			// Otherwise we unmarshal the value and return a pointer to it
			obj := encoreInternalTypeConfigUnmarshaler_svc_Config(itr, append(path))
			return &obj
		}()
	}
)

// encoreInternalTypeConfigUnmarshaler_svc_Config will unmarshal the JSON representation into the given type, taking account for
// the `config.Value` dynamic functions.
func encoreInternalTypeConfigUnmarshaler_svc_Config(itr *jsoniter.Iterator, path []string) (obj Config) {
	itr.ReadObjectCB(func(itr *jsoniter.Iterator, field string) bool {
		switch field {
		case "HTTP":
			obj.HTTP = encoreInternalTypeConfigUnmarshaler_svc_ServerOption(itr, append(path, "HTTP"))
		case "Another":
			obj.Another = encoreInternalTypeConfigUnmarshaler_svc_ServerOption(itr, append(path, "Another"))
		case "TCP":
			obj.TCP = encoreInternalTypeConfigUnmarshaler_svc_ServerOption(itr, append(path, "TCP"))
		case "GRPC":
			obj.GRPC = encoreInternalTypeConfigUnmarshaler_svc_ServerOption(itr, append(path, "GRPC"))
		default:
			itr.Skip()
		}
		return true
	})
	return
}

// encoreInternalTypeConfigUnmarshaler_svc_ServerOption will unmarshal the JSON representation into the given type, taking account for
// the `config.Value` dynamic functions.
func encoreInternalTypeConfigUnmarshaler_svc_ServerOption(itr *jsoniter.Iterator, path []string) (obj ServerOption) {
	itr.ReadObjectCB(func(itr *jsoniter.Iterator, field string) bool {
		switch field {
		case "Option":
			obj.Option = itr.ReadInt64()
		case "Disabled":
			obj.Disabled = itr.ReadBool()
		default:
			itr.Skip()
		}
		return true
	})
	return
}

----------------------------------------

TITLE: Prometheus Metrics Configuration for Encore
DESCRIPTION: JSON configuration for setting up Prometheus metrics export in Encore applications, including collection interval and remote write URL.

LANGUAGE: json
CODE:
{
  "metrics": {
    "type": "prometheus",
    "collection_interval": 15,
    "remote_write_url": {
      "$env": "PROMETHEUS_REMOTE_WRITE_URL"
    }
  }
}

----------------------------------------

TITLE: Creating a Duplicate PubSub Subscription in Second Service
DESCRIPTION: Creates another PubSub subscription in the foo service with an inline handler function. This subscription also uses the name 'same-name', causing a naming conflict with the subscription in the svc service.

LANGUAGE: go
CODE:
package foo

import (
    "context"

    "encore.dev/pubsub"

    "test/shared"
)

var _ = pubsub.NewSubscription(
    shared.BasicTopic,
    "same-name",
    pubsub.SusbcriptionConfig { Handler: func(ctx context.Context, msg *shared.MessageType) error {
        return nil
    }},
)

// encore:api
func DoStuff(ctx context.Context) error {
    shared.BasicTopic.Publish(ctx, &shared.MessageType{Name: "foo"})
}

----------------------------------------

TITLE: Implementing Site Status Tracking and Reporting
DESCRIPTION: This code creates a status endpoint that returns the current up/down status of all monitored sites. It retrieves the most recent check for each site from the database and formats the response.

LANGUAGE: typescript
CODE:
import { api } from "encore.dev/api";
import { MonitorDB } from "./check";

interface SiteStatus {
  id: number;
  up: boolean;
  checkedAt: string;
}

// StatusResponse is the response type from the Status endpoint.
interface StatusResponse {
  // Sites contains the current status of all sites,
  // keyed by the site ID.
  sites: SiteStatus[];
}

// status checks the current up/down status of all monitored sites.
export const status = api(
  { expose: true, path: "/status", method: "GET" },
  async (): Promise<StatusResponse> => {
    const rows = await MonitorDB.query`
      SELECT DISTINCT ON (site_id) site_id, up, checked_at
      FROM checks
      ORDER BY site_id, checked_at DESC
    `;
    const results: SiteStatus[] = [];
    for await (const row of rows) {
      results.push({
        id: row.site_id,
        up: row.up,
        checkedAt: row.checked_at,
      });
    }
    return { sites: results };
  },
);

----------------------------------------

TITLE: Generated Internal PubSub Handler Functions
DESCRIPTION: Shows the internal functions generated by Encore to implement the PubSub subscription handlers. Each function gets the service instance and calls the appropriate method.

LANGUAGE: Go
CODE:
package svc

import (
	"context"
	__service "encore.dev/appruntime/apisdk/service"
)

func EncoreInternal_pubsub_handler_pointer(ctx context.Context, msg *Event) error {
	svc, err := __service.Get[*Service]("svc")
	if err != nil {
		return err
	}
	return svc.PointerMethod(ctx, msg)
}

func EncoreInternal_pubsub_handler_non_pointer(ctx context.Context, msg *Event) error {
	svc, err := __service.Get[*Service]("svc")
	if err != nil {
		return err
	}
	return svc.NonPointerMethod(ctx, msg)
}

----------------------------------------

TITLE: Defining Configuration Structure in Encore Service
DESCRIPTION: Defines a Config struct that contains HTTP server configuration options including enabled status and port number. Each field has explanatory comments.

LANGUAGE: go
CODE:
type Config struct {
    // The options for the HTTP server
    HTTP struct {
        Enabled bool // Is this option enabled?
        Port    uint32 // What port should we run on?
    }
}

----------------------------------------

TITLE: Serving Frontend Assets with Go for Development
DESCRIPTION: Implementation of a raw Encore endpoint that serves compiled frontend assets for development purposes. This utilizes Go's embed package to include static files.

LANGUAGE: go
CODE:
package frontend

import (
	"embed"
	"io/fs"
	"net/http"
)

var (
	//go:embed dist
	dist embed.FS

	assets, _ = fs.Sub(dist, "dist")
	handler   = http.StripPrefix("/frontend/", http.FileServer(http.FS(assets)))
)

 //encore:api public raw path=/frontend/*path
 func Serve(w http.ResponseWriter, req *http.Request) {
	 handler.ServeHTTP(w, req)
 }

----------------------------------------

TITLE: Registering API Endpoint in Encore Runtime
DESCRIPTION: Initialization code that registers the Foo endpoint with Encore's API system during application startup.

LANGUAGE: go
CODE:
func init() {
	__api.RegisterEndpoint(EncoreInternal_api_APIDesc_Foo, Foo)
}

----------------------------------------

TITLE: Generated Encore Main Function
DESCRIPTION: Auto-generated main function for Encore applications. It imports the application and initializes it using Encore's appinit.AppMain() function.

LANGUAGE: go
CODE:
package main

import (
	appinit "encore.dev/appruntime/apisdk/app/appinit"
	_ "example.com"
)

func main() {
	appinit.AppMain()
}

----------------------------------------

TITLE: Creating a Schedule with cURL Request
DESCRIPTION: Example cURL command for creating a new schedule by sending a POST request to the API endpoint. The request includes a JSON payload with start and end times for the schedule assigned to user ID 1.

LANGUAGE: bash
CODE:
curl -d '{
  "Start":"2023-11-28T10:00:00Z",
  "End":"2023-11-30T10:00:00Z"
}' "http://localhost:4000/users/1/schedules"

# Example JSON response
# {
#   "Id":1,
#   "User":{
#     "Id":1,
#     "FirstName":"Katy",
#     "LastName":"Smith",
#     "SlackHandle":"katy"
#   },
#   "Time":{
#     "Start":"2023-11-28T10:00:00Z",
#     "End":"2023-11-30T10:00:00Z"
#   }
# }

----------------------------------------

TITLE: Defining ThisConfig Structure with String and Boolean Fields
DESCRIPTION: Creates a ThisConfig structure with String and Bool configuration types from the Encore config package. Includes a comment explaining the Foo field's purpose.

LANGUAGE: go
CODE:
type ThisConfig struct{
    Foo config.String // And even better in ThisConfig
    Baz config.Bool
}

----------------------------------------

TITLE: Implementing a Service Package with Generic Cache Key in Go
DESCRIPTION: Defines a service package with a generic cache key type and a string keyspace configuration. The keyspace uses a pattern to format cache keys and references a cluster defined in another package.

LANGUAGE: go
CODE:
package svc

import (
    "context"

    "encore.dev/storage/cache"
    "test/lib"
)

type Key[T any] struct {
    Foo T
}

var keyspace = cache.NewStringKeyspace[Key[string]](lib.Cluster, cache.KeyspaceConfig{
    KeyPattern: "foo/:Foo",
})

//encore:api public
func Foo(ctx context.Context) error { return nil }

----------------------------------------

TITLE: Defining Service Config Structure in Go
DESCRIPTION: Definition of a Config struct that contains various configuration parameters including name, port, read-only flag, magic number, UUID, and public key. The struct includes field comments for documentation.

LANGUAGE: go
CODE:
type Config struct {
    Name        string    // The users name
    Port        uint16
    ReadOnly    bool      // true if we're in read only mode

    // MagicNumber is complicated and requires
    // a multi-line comment to explain it.
    MagicNumber int

    ID          uuid.UUID // An ID

    PublicKey []byte
}

----------------------------------------

TITLE: Defining a PubSub Topic in Encore
DESCRIPTION: Defines a shared PubSub topic with a MessageType structure that can be imported by other services. Creates a basic topic with at-least-once delivery guarantee.

LANGUAGE: go
CODE:
package shared

import (
    "encore.dev/pubsub"
)

type MessageType struct {
    Name string
}

var (
    BasicTopic = pubsub.NewTopic[*MessageType]("basic-topic", pubsub.TopicConfig{ DeliveryGuarantee: pubsub.AtLeastOnce })
)

----------------------------------------

TITLE: Creating Infrastructure Configuration for Self-Hosting
DESCRIPTION: This JSON configuration file defines the required SQL server setup for self-hosting the uptime monitor application, including database connections and credential management.

LANGUAGE: json
CODE:
{
   "$schema": "https://encore.dev/schemas/infra.schema.json",
   "sql_servers": [
      {
         "host": "my-db-host:5432",
         "databases": {
            "monitor": {
               "username": "my-db-owner",
                "password": {"$env": "DB_PASSWORD"}
            },
            "site": {
               "username": "my-db-owner",
                "password": {"$env": "DB_PASSWORD"}
            }
         }
      }
   ]
}

----------------------------------------

TITLE: Implementing Encore Service with PubSub Integration
DESCRIPTION: Defines an Encore service with PubSub topic and subscription handlers. The service includes both pointer and non-pointer receiver methods that handle PubSub events.

LANGUAGE: Go
CODE:
package svc

import (
	"context"
	"encore.dev/pubsub"
)

//encore:service
type Service struct{}

func (s *Service) PointerMethod(ctx context.Context, event *Event) error {
    return nil
}

func (s Service) NonPointerMethod(ctx context.Context, event *Event) error {
    return nil
}

type Event struct {}

var Topic = pubsub.NewTopic[*Event]("topic", pubsub.TopicConfig{
    DeliveryGuarantee: pubsub.AtLeastOnce,
})

var _ = pubsub.NewSubscription(Topic, "pointer",
    pubsub.SubscriptionConfig[*Event]{
        Handler: pubsub.MethodHandler((*Service).PointerMethod),
    },
)

var _ = pubsub.NewSubscription(Topic, "non-pointer",
    pubsub.SubscriptionConfig[*Event]{
        Handler: pubsub.MethodHandler(Service.NonPointerMethod),
    },
)

----------------------------------------

TITLE: Defining Simple API Endpoint with Encore
DESCRIPTION: Creates a basic API endpoint using Encore's annotation system (//encore:api). The function takes a context parameter and returns only an error, with a nil implementation indicating success.

LANGUAGE: go
CODE:
//encore:api
func MyAPI(ctx context.Context) (error) {
	return nil
}

----------------------------------------

TITLE: Incorrect Cron Job Declaration in Encore Service
DESCRIPTION: This snippet demonstrates an incorrect way to define a cron job in an Encore service by placing it inside the init() function instead of at package level. It also includes an API endpoint that would be used by the cron job.

LANGUAGE: go
CODE:
package svc

import (
	"context"

	"encore.dev/cron"
)

func init() {
    // A cron job to send out emails to newsletter subscribers.
    // On two lines.
    var _ = cron.NewJob("cronfoo", cron.JobConfig{
        Title:    "Cron Foo Bar",
        Schedule: "* * * * 5",
        Endpoint: Cron,
    })
}

//encore:api public path=/cron
func Cron(ctx context.Context) (*Response, error) {
	msg := "Hello, Cron!"
	return &Response{Message: msg}, nil
}

type Response struct {
	Message string
}

----------------------------------------

TITLE: Encore Static Configuration
DESCRIPTION: A synthetic file containing the static configuration for the Encore application. It includes information about bundled services, testing paths, and other configuration options.

LANGUAGE: go
CODE:
package synthetic

/*

This is a synthetic file describing the generated static config:

{
	"EncoreCompiler": "",
	"AppCommit": {
		"revision": "",
		"uncommitted": false
	},
	"CORSAllowHeaders": null,
	"CORSExposeHeaders": null,
	"PubsubTopics": {},
	"Testing": false,
	"TestServiceMap": {
		"code": "testing_path:code"
	},
	"TestAppRootPath": "testing_path:main",
	"PrettyPrintLogs": false,
	"BundledServices": [
		"code"
	],
	"EmbeddedEnvs": {}
}
*/

----------------------------------------

TITLE: Implementing Moo Service with Public API in Go
DESCRIPTION: Defines the moo service with a simple public API endpoint that returns nil. Uses the encore framework's annotation for exposing the API publicly.

LANGUAGE: go
CODE:
package moo
import "context"
//encore:api public
func Dummy(context.Context) error { return nil }

----------------------------------------

TITLE: Loading ThisConfig Configuration
DESCRIPTION: Loads the ThisConfig structure using Encore's config.Load function, making the configuration values available to the service.

LANGUAGE: go
CODE:
var _ = config.Load[ThisConfig]()

----------------------------------------

TITLE: Importing and Using Service Types in External Package
DESCRIPTION: This code shows how to import and use types from an Encore service package in a separate package. It references the FooParams struct from the 'svc' package in a Test function.

LANGUAGE: go
CODE:
package pkg

import (
    "context"
    "test/svc"
)

func Test() {
    _ = &svc.FooParams{}
}

----------------------------------------

TITLE: Auto-generated Config Unmarshaling in Go
DESCRIPTION: Automatically generated code by Encore to handle config unmarshaling. It includes functions that convert JSON configuration into strongly-typed Go structs with proper type handling for various field types including primitives, UUIDs, and byte arrays.

LANGUAGE: go
CODE:
var (
	encoreInternalConfigUnmarshaler_ptr_svc_Config = func(itr *jsoniter.Iterator, path []string) *Config {
		return func() *Config {
			// If the value is null, we return nil
			if itr.ReadNil() {
				return nil
			}

			// Otherwise we unmarshal the value and return a pointer to it
			obj := encoreInternalTypeConfigUnmarshaler_svc_Config(itr, append(path))
			return &obj
		}()
	}
)

----------------------------------------

TITLE: Service Discovery Configuration for Encore
DESCRIPTION: JSON configuration for setting up service discovery in Encore applications to access other services over the network, including base URL and authentication methods.

LANGUAGE: json
CODE:
{
  "service_discovery": {
    "user-service": {
      "base_url": "https://user.myencoreapp.com",
      "auth": [
        {
          "type": "key",
          "id": 1,
          "key": {
            "$env": "USER_SERVICE_API_KEY"
          }
        }
      ]
    }
  }
}

----------------------------------------

TITLE: Defining an Encore Service with Type Error in Go
DESCRIPTION: This code attempts to define an Encore service with a public API endpoint but has a type error. The service struct is defined as 'Service', but the API method references it as 'Serviice', causing an undefined type error.

LANGUAGE: go
CODE:
package svc

import (
	"context"
	"encore.dev/types/uuid"
)

//encore:service
type Service struct {}

type Params struct{}

//encore:api public
func (s *Serviice) Str(ctx context.Context, p *Params) error { return nil }

----------------------------------------

TITLE: Using kubectl with Encore-configured credentials
DESCRIPTION: Example kubectl command that can be run after configuring the connection to an Encore-managed Kubernetes cluster. This demonstrates that standard kubectl commands work normally once configured.

LANGUAGE: shell
CODE:
kubectl get pods

----------------------------------------

TITLE: Unmarshal ServerOptions Type in Generated Encore Code
DESCRIPTION: Auto-generated function to unmarshal JSON configuration into the ServerOptions type. Handles the parsing of Enabled and Port fields from JSON configuration.

LANGUAGE: go
CODE:
// encoreInternalTypeConfigUnmarshaler_svc_ServerOptions will unmarshal the JSON representation into the given type, taking account for
// the `config.Value` dynamic functions.
func encoreInternalTypeConfigUnmarshaler_svc_ServerOptions(itr *jsoniter.Iterator, path []string) (obj ServerOptions) {
	itr.ReadObjectCB(func(itr *jsoniter.Iterator, field string) bool {
		switch field {
		case "Enabled":
			obj.Enabled = itr.ReadBool()
		case "Port":
			obj.Port = itr.ReadUint32()
		default:
			itr.Skip()
		}
		return true
	})
	return
}

----------------------------------------

TITLE: Defining an Encore API Endpoint
DESCRIPTION: Defines a simple API endpoint using Encore's API annotation. This function will be exposed as an API endpoint by the Encore platform.

LANGUAGE: go
CODE:
//encore:api
func MyAPI(ctx context.Context) (error) {
	return nil
}

----------------------------------------

TITLE: Validating Nullable Fields in Encore.ts
DESCRIPTION: This example demonstrates how to define and validate nullable fields in request schemas, which can be either the specified type or null.

LANGUAGE: typescript
CODE:
interface Request {
  name: string | null;
}

export const myEndpoint = api(
  { expose: true, method: "POST", path: "/body" },
  async (req: Request) => {
    // req.name is a string or null
  },
);

----------------------------------------

TITLE: Generated Encore API Endpoint Registration
DESCRIPTION: Automatically generated code that registers and implements the API endpoint functionality including request/response handling, encoding/decoding, and middleware. This includes various helper functions for the Foo endpoint.

LANGUAGE: go
CODE:
package code

import (
	"context"
	__api "encore.dev/appruntime/apisdk/api"
	jsoniter "github.com/json-iterator/go"
	"net/http"
	"net/url"
)

func init() {
	__api.RegisterEndpoint(EncoreInternal_api_APIDesc_Foo, Foo)
}

type EncoreInternal_FooReq struct{}

type EncoreInternal_FooResp = __api.Void

var EncoreInternal_api_APIDesc_Foo = &__api.Desc[*EncoreInternal_FooReq, EncoreInternal_FooResp]{
	Access: __api.Private,
	AppHandler: func(ctx context.Context, reqData *EncoreInternal_FooReq) (EncoreInternal_FooResp, error) {
		err := Foo(ctx)
		if err != nil {
			return __api.Void{}, err
		}
		return __api.Void{}, nil
	},
	CloneReq: func(r *EncoreInternal_FooReq) (*EncoreInternal_FooReq, error) {
		var clone *EncoreInternal_FooReq
		bytes, err := jsoniter.ConfigDefault.Marshal(r)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return clone, err
	},
	CloneResp: func(r EncoreInternal_FooResp) (EncoreInternal_FooResp, error) {
		var clone EncoreInternal_FooResp
		bytes, err := jsoniter.ConfigDefault.Marshal(r)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return clone, err
	},
	DecodeExternalResp: func(httpResp *http.Response, json jsoniter.API) (resp EncoreInternal_FooResp, err error) {
		return __api.Void{}, nil
	},
	DecodeReq: func(httpReq *http.Request, ps __api.UnnamedParams, json jsoniter.API) (reqData *EncoreInternal_FooReq, pathParams __api.UnnamedParams, err error) {
		reqData = new(EncoreInternal_FooReq)
		return reqData, nil, nil
	},
	DefLoc: uint32(0x0),
	EncodeExternalReq: func(reqData *EncoreInternal_FooReq, stream *jsoniter.Stream) (httpHeader http.Header, queryString url.Values, err error) {
		return nil, nil, nil
	},
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, resp EncoreInternal_FooResp) (err error) {
		return nil
	},
	Endpoint:            "Foo",
	Fallback:            false,
	GlobalMiddlewareIDs: []string{},
	Methods:             []string{"GET", "POST"},
	Path:                "/code.Foo",
	PathParamNames:      nil,
	Raw:                 false,
	RawHandler:          nil,
	RawPath:             "/code.Foo",
	ReqPath: func(reqData *EncoreInternal_FooReq) (string, __api.UnnamedParams, error) {
		return "/code.Foo", nil, nil
	},
	ReqUserPayload: func(reqData *EncoreInternal_FooReq) any {
		return nil
	},
	Service:           "code",
	ServiceMiddleware: []*__api.Middleware{},
	SvcNum:            1,
	Tags:              nil,
}

----------------------------------------

TITLE: Encore Application Main Entry Point
DESCRIPTION: The generated main package that serves as the entry point for the Encore application. It imports the application code and calls the Encore runtime initialization.

LANGUAGE: go
CODE:
package main

import (
	appinit "encore.dev/appruntime/apisdk/app/appinit"
	_ "example.com"
)

func main() {
	appinit.AppMain()
}

----------------------------------------

TITLE: Defining Foo Service with Database Connections in Go
DESCRIPTION: Implements the foo service with connections to multiple named databases (moo and bar). Exposes a public API endpoint Foo() that demonstrates various sqldb operations.

LANGUAGE: go
CODE:
package foo

import (
    "context"

    "encore.dev/storage/sqldb"
)

var Moo = sqldb.Named("moo")
var Bar = sqldb.Named("bar")

//encore:api public
func Foo(ctx context.Context) error {
    sqldb.QueryRow(ctx, "")
    Moo.Exec(ctx, "")
    Bar.Stdlib()
    return nil
}

----------------------------------------

TITLE: Implementing a Basic Encore API Endpoint
DESCRIPTION: Defines a simple API endpoint using Encore's API annotation. This endpoint takes a context parameter and returns an error, currently always returning nil (no error).

LANGUAGE: go
CODE:
//encore:api
func MyAPI(ctx context.Context) (error) {
	return nil
}

----------------------------------------

TITLE: Implementing Encore Authentication Handler with Invalid Parameter Type in Go
DESCRIPTION: This code defines an authentication handler with an invalid signature. The handler uses a non-pointer struct type 'Params' as a parameter, which violates Encore's requirement that the second parameter must be a string or a pointer to a named struct.

LANGUAGE: go
CODE:
package svc

import (
    "context"
    "encore.dev/beta/auth"
)

type Params int

//encore:authhandler
func MyAuth(ctx context.Context, p Params) (auth.UID, error) { return "", nil }

----------------------------------------

TITLE: Defining Configuration Structure and API Endpoint in Encore Service
DESCRIPTION: Defines a Config struct with integer and string arrays, loads it using config.Load, and declares a simple API endpoint using Encore's annotation. This code forms the basic structure of an Encore service.

LANGUAGE: go
CODE:
package svc

import (
	"context"

	"encore.dev/config"
)

type Config struct {
    Ages      []int32
    OtherBits []string
}

var _ = config.Load[*Config]()

//encore:api
func MyAPI(ctx context.Context) (error) {
	return nil
}

----------------------------------------

TITLE: Defining an API Endpoint with Path Parameters in Encore
DESCRIPTION: This code snippet demonstrates an error case where an API endpoint is defined with path parameters (:foo and :bar) but the function signature doesn't include matching parameters. Encore requires function parameters to match path parameters in the route declaration.

LANGUAGE: go
CODE:
package svc

import (
	"context"
	"encore.dev/types/uuid"
)

//encore:api public path=/str/:foo/:bar
func Str(ctx context.Context) error { return nil }

----------------------------------------

TITLE: Generating ent Client Files
DESCRIPTION: Command to generate the ent client files based on the schema definition.

LANGUAGE: shell
CODE:
$ go run entgo.io/ent/cmd/ent@latest generate ./user/ent/schema

----------------------------------------

TITLE: Defining Configuration Struct with Basic Types
DESCRIPTION: Defines a Config struct containing name, port, and read-only flag configuration with basic Go types. Loads the config using the config.Load function with a pointer type parameter.

LANGUAGE: go
CODE:
package svc

import (
	"context"

	"encore.dev/config"
)

type Config struct {
    Name        string    // The users name
    Port        uint16
    ReadOnly    bool      // true if we're in read only mode
}

var _ = config.Load[*Config]()

----------------------------------------

TITLE: Defining Service Configuration Structures in Go with Encore
DESCRIPTION: Defines configuration structures for an Encore service, including ServerOption and Config types. The Config structure uses tagged fields to mark optional configuration elements. The configuration is loaded using Encore's config package.

LANGUAGE: go
CODE:
package svc

import (
	"context"

	"encore.dev/config"
)

type ServerOption struct {
    Option   int64
    Disabled bool `cue:",opt"` // True if this is disabled
}

type Config struct {
    HTTP    ServerOption
    Another ServerOption
    TCP     ServerOption `cue:",opt"`
    GRPC    ServerOption `cue:",opt"`
}

var _ = config.Load[*Config]()

//encore:api
func MyAPI(ctx context.Context) (error) {
	return nil
}

----------------------------------------

TITLE: Implementing Bar Service with Public API in Go
DESCRIPTION: Defines the bar service with a simple public API endpoint that returns nil. Uses the encore framework's annotation for exposing the API publicly.

LANGUAGE: go
CODE:
package bar
import "context"
//encore:api public
func Dummy(context.Context) error { return nil }

----------------------------------------

TITLE: Generated Service Registration Code in Go
DESCRIPTION: Auto-generated code that registers the service with the Encore framework. Creates a global service declaration object and registers it during package initialization.

LANGUAGE: go
CODE:
package basic

import __service "encore.dev/appruntime/apisdk/service"

func init() {
	__service.Register(EncoreInternal_svcstruct_Service)
}

var EncoreInternal_svcstruct_Service = &__service.Decl[Service]{
	Name:        "Service",
	Service:     "basic",
	Setup:       nil,
	SetupDefLoc: uint32(0x0),
}

----------------------------------------

TITLE: Empty SQL Migration File
DESCRIPTION: An empty SQL migration file for database setup. This is a placeholder for database schema changes that would be executed during deployment.

LANGUAGE: sql
CODE:


----------------------------------------

TITLE: Loading Configuration with Encore's Config System
DESCRIPTION: Uses Encore's configuration system to load the Config struct. The blank identifier assignment stores the result of the load operation without using the returned value.

LANGUAGE: go
CODE:
var _ = config.Load[*Config]()

----------------------------------------

TITLE: Defining OtherConfig Structure with Encore Config Types
DESCRIPTION: Creates an OtherConfig structure that uses Encore's typed configuration values (String and Int). Includes a comment describing the purpose of the Foo field.

LANGUAGE: go
CODE:
type OtherConfig struct{
    Foo config.String // Foo is great in Otherconfig
    Bar config.Int
}

----------------------------------------

TITLE: Defining Server Configuration Structures in Go
DESCRIPTION: Defines configuration structures for an HTTP server including ServerOptions with enabled flag and port, and a Config type that contains HTTP server options.

LANGUAGE: go
CODE:
type ServerOptions struct {
    Enabled bool // Is this option enabled?
    Port    uint32 // What port should we run on?
}

type Config struct {
    HTTP ServerOptions // The options for the HTTP server
}

----------------------------------------

TITLE: Basic Encore App Structure
DESCRIPTION: Shows the typical directory structure of an Encore application with a user service.

LANGUAGE: plaintext
CODE:
/my-app
├── encore.app
└── user        // user service

----------------------------------------

TITLE: Setting up a PubSub System with Encore in Go
DESCRIPTION: This code sets up a complete PubSub system using Encore's pubsub library. It defines a message type, creates a topic with at-least-once delivery guarantee, sets up a subscription with a handler function, and includes an API endpoint that publishes messages to the topic.

LANGUAGE: Go
CODE:
package svc

import (
    "context"

    "encore.dev/pubsub"
)

type MessageType struct {
    Name string
}

var (
    BasicTopic = pubsub.NewTopic[*MessageType]("basic-topic", pubsub.TopicConfig{ DeliveryGuarantee: pubsub.AtLeastOnce })
    _ = pubsub.NewSubscription(BasicTopic, "basic-subscription", pubsub.SusbcriptionConfig { Handler: Subscriber })
)

// encore:api
func DoStuff(ctx context.Context) error {
    return BasicTopic.Publish(ctx, &MessageType{Name: "foo"})
}

func Subscriber(ctx context.Context, msg *MessageType) error {
    return nil
}

----------------------------------------

TITLE: Creating a new Encore application from template
DESCRIPTION: Command to create a new Encore application based on the booking system starting point template, which provides a ready-to-use frontend.

LANGUAGE: shell
CODE:
$ encore app create booking-system --example=github.com/encoredev/example-booking-system/tree/starting-point

----------------------------------------

TITLE: Empty Initialization Function in Encore API
DESCRIPTION: An empty initialization function for Encore's API code that doesn't perform any operations.

LANGUAGE: go
CODE:
package code

func init() {}

----------------------------------------

TITLE: Defining Config Structure with CUE Expressions in Go
DESCRIPTION: Defines a Config structure with CUE expression tags for field validation where fields B and C have interdependent constraints. Uses config.Load to load configuration values into the defined structure.

LANGUAGE: go
CODE:
package svc

import (
	"context"

	"encore.dev/config"
)

type Config struct {
    A int
    B int `cue:"A+C"`
    C int `cue:"B-A"`
}

var _ = config.Load[*Config]()

----------------------------------------

TITLE: Implementing Slack Notification Service in Go
DESCRIPTION: Implementation of a service that calls a Slack webhook to post notifications. The service provides a simple API to send text messages to a configured Slack channel.

LANGUAGE: go
CODE:
// Service slack calls a webhook to post notifications to Slack.
package slack

import (
	"bytes"
	"context"
	"encoding/json"
	"encore.dev/beta/errs"
	"io"
	"net/http"
)

type NotifyParams struct {
	Text string `json:"text"`
}

//encore:api private
func Notify(ctx context.Context, p *NotifyParams) error {
	eb := errs.B()
	reqBody, err := json.Marshal(p)
	if err != nil {
		return err
	}
	req, err := http.NewRequestWithContext(ctx, "POST", secrets.SlackWebhookURL, bytes.NewReader(reqBody))
	if err != nil {
		return err
	}
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
		return err
	}

	defer resp.Body.Close()

	if resp.StatusCode >= 400 {
		body, _ := io.ReadAll(resp.Body)
		return eb.Code(errs.Unavailable).Msgf("notify slack: %s: %s", resp.Status, body).Err()
	}
	return nil
}

var secrets struct {
	SlackWebhookURL string
}

----------------------------------------

TITLE: Creating a Public API Endpoint with Encore
DESCRIPTION: Defines a public API endpoint using Encore's annotation comment. This function returns the Params structure and handles any potential errors.

LANGUAGE: go
CODE:
//encore:api public
func Foo(ctx context.Context) (*Params, error) { return nil, nil }

----------------------------------------

TITLE: Encore Generated API Implementation with HTTP Bindings
DESCRIPTION: Auto-generated internal implementation that registers the API endpoint and provides serialization/deserialization logic. Includes HTTP request/response handling, parameter parsing, and JSON conversion for the 'Foo' endpoint.

LANGUAGE: go
CODE:
package basic

import (
	"context"
	__api "encore.dev/appruntime/apisdk/api"
	__etype "encore.dev/appruntime/shared/etype"
	__serde "encore.dev/appruntime/shared/serde"
	jsoniter "github.com/json-iterator/go"
	"net/http"
	"net/url"
	"strings"
)

func init() {
	__api.RegisterEndpoint(EncoreInternal_api_APIDesc_Foo, Foo)
}

type EncoreInternal_FooReq struct{}

type EncoreInternal_FooResp = *Params

var EncoreInternal_api_APIDesc_Foo = &__api.Desc[*EncoreInternal_FooReq, EncoreInternal_FooResp]{
	Access: __api.Public,
	AppHandler: func(ctx context.Context, reqData *EncoreInternal_FooReq) (EncoreInternal_FooResp, error) {
		resp, err := Foo(ctx)
		if err != nil {
			return (*Params)(nil), err
		}
		return resp, nil
	},
	CloneReq: func(r *EncoreInternal_FooReq) (*EncoreInternal_FooReq, error) {
		var clone *EncoreInternal_FooReq
		bytes, err := jsoniter.ConfigDefault.Marshal(r)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return clone, err
	},
	CloneResp: func(r EncoreInternal_FooResp) (EncoreInternal_FooResp, error) {
		var clone EncoreInternal_FooResp
		bytes, err := jsoniter.ConfigDefault.Marshal(r)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return clone, err
	},
	DecodeExternalResp: func(httpResp *http.Response, json jsoniter.API) (resp EncoreInternal_FooResp, err error) {
		resp = new(Params)
		dec := new(__etype.Unmarshaller)
		// Decode request body
		payload := dec.ReadBody(httpResp.Body)
		iter := jsoniter.ParseBytes(json, payload)

		for iter.ReadObjectCB(func(_ *jsoniter.Iterator, key string) bool {
			switch strings.ToLower(key) {
			case "string":
				dec.ParseJSON("String", iter, &resp.String)
			case "int":
				dec.ParseJSON("Int", iter, &resp.Int)
			default:
				_ = iter.SkipAndReturnBytes()
			}
			return true
		}) {
		}

		if err := dec.Error; err != nil {
			return (*Params)(nil), err
		}
		return resp, nil
	},
	DecodeReq: func(httpReq *http.Request, ps __api.UnnamedParams, json jsoniter.API) (reqData *EncoreInternal_FooReq, pathParams __api.UnnamedParams, err error) {
		reqData = new(EncoreInternal_FooReq)
		return reqData, nil, nil
	},
	DefLoc: uint32(0x0),
	EncodeExternalReq: func(reqData *EncoreInternal_FooReq, stream *jsoniter.Stream) (httpHeader http.Header, queryString url.Values, err error) {
		return nil, nil, nil
	},
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, resp EncoreInternal_FooResp) (err error) {
		respData := []byte("null\n")
		if resp != nil {
			// Encode JSON body
			respData, err = __serde.SerializeJSONFunc(json, func(ser *__serde.JSONSerializer) {
				ser.WriteField("String", resp.String, false)
				ser.WriteField("Int", resp.Int, false)
			})
			if err != nil {
				return err
			}
			respData = append(respData, '\n')
		}

		// Write response
		w.Write(respData)
		return nil
	},
	Endpoint:            "Foo",
	Fallback:            false,
	GlobalMiddlewareIDs: []string{},
	Methods:             []string{"GET", "POST"},
	Path:                "/basic.Foo",
	PathParamNames:      nil,
	Raw:                 false,
	RawHandler:          nil,
	RawPath:             "/basic.Foo",
	ReqPath: func(reqData *EncoreInternal_FooReq) (string, __api.UnnamedParams, error) {
		return "/basic.Foo", nil, nil
	},
	ReqUserPayload: func(reqData *EncoreInternal_FooReq) any {
		return nil
	},
	Service:           "basic",
	ServiceMiddleware: []*__api.Middleware{},
	SvcNum:            1,
	Tags:              nil,
}

----------------------------------------

TITLE: Defining Raw Endpoint with Custom Path in Encore
DESCRIPTION: This snippet shows how to define a public raw endpoint with a custom path '/foo' in an Encore application. The function implements a simple HTTP handler that accepts a response writer and request object.

LANGUAGE: go
CODE:
package svc

import "net/http"

//encore:api public raw path=/foo
func API(w http.ResponseWriter, req *http.Request) { }

----------------------------------------

TITLE: Defining an API Endpoint with Encore
DESCRIPTION: Creates a simple API endpoint using Encore's annotation system. The //encore:api annotation exposes the function as a public API endpoint that can be called from clients. This function takes a context and returns an error.

LANGUAGE: go
CODE:
//encore:api
func MyAPI(ctx context.Context) (error) {
	return nil
}

----------------------------------------

TITLE: Service Package Declaration and Imports in Go
DESCRIPTION: Declares the package 'svc' and imports required dependencies including context, time, Encore's config package, and UUID type. Sets up the foundation for an Encore service.

LANGUAGE: go
CODE:
package svc

import (
	"context"
    "time"

	"encore.dev/config"
	"encore.dev/types/uuid"
)

----------------------------------------

TITLE: Loading Configuration in Encore
DESCRIPTION: Uses Encore's configuration system to load application settings into the Config structure. The blank identifier is used to ensure the config is loaded even if not directly referenced.

LANGUAGE: go
CODE:
var _ = config.Load[*Config]()

----------------------------------------

TITLE: Expected Error Message for Duplicate Cache Cluster Names
DESCRIPTION: The error message displayed when Encore detects duplicate cache cluster names. It shows the line numbers where the duplication occurs and provides guidance on how to properly reuse cache clusters.

LANGUAGE: text
CODE:
── Duplicate Cache Cluster ────────────────────────────────────────────────────────────────[E9999]──

Cache clusters must have unique names.

    ╭─[ svc/svc.go:9:33 ]
    │
  7 │ )
  8 │
  9 │ var cluster1 = cache.NewCluster("cluster", cache.ClusterConfig{})
    ⋮                                 ─────────
 10 │ var cluster2 = cache.NewCluster("cluster", cache.ClusterConfig{})
    ⋮                                 ─────────
 11 │
 12 │ //encore:api public
────╯

I you wish to reuse the same cluster, export the original cache.Cluster object and reuse it here.

For more information see https://encore.dev/docs/primitives/caching

----------------------------------------

TITLE: Defining Secret Structure and API Endpoint in Go
DESCRIPTION: This code defines a simple service with a secret structure containing a 'Foo' string field and a public API endpoint function. It serves as a test for secret parsing functionality in Encore.

LANGUAGE: Go
CODE:
package svc

import "context"

var secrets struct {
    Foo string
}

//encore:api public
func Foo(ctx context.Context) error {
    return nil
}

----------------------------------------

TITLE: Generated API Implementation
DESCRIPTION: Complex generated code that implements the API endpoint registration, request/response types, and HTTP handler functionality for the 'Foo' method. It handles request parsing, service initialization, method invocation, and response encoding.

LANGUAGE: go
CODE:
package code

import (
	"context"
	__api "encore.dev/appruntime/apisdk/api"
	jsoniter "github.com/json-iterator/go"
	"net/http"
	"net/url"
)

func init() {
	__api.RegisterEndpoint(EncoreInternal_api_APIDesc_Foo, Foo)
}

type EncoreInternal_FooReq struct{}

type EncoreInternal_FooResp = __api.Void

var EncoreInternal_api_APIDesc_Foo = &__api.Desc[*EncoreInternal_FooReq, EncoreInternal_FooResp]{
	Access: __api.Private,
	AppHandler: func(ctx context.Context, reqData *EncoreInternal_FooReq) (EncoreInternal_FooResp, error) {
		svc, initErr := EncoreInternal_svcstruct_Service.Get()
		if initErr != nil {
			return __api.Void{}, initErr
		}
		err := svc.Foo(ctx)
		if err != nil {
			return __api.Void{}, err
		}
		return __api.Void{}, nil
	},
	CloneReq: func(r *EncoreInternal_FooReq) (*EncoreInternal_FooReq, error) {
		var clone *EncoreInternal_FooReq
		bytes, err := jsoniter.ConfigDefault.Marshal(r)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return clone, err
	},
	CloneResp: func(r EncoreInternal_FooResp) (EncoreInternal_FooResp, error) {
		var clone EncoreInternal_FooResp
		bytes, err := jsoniter.ConfigDefault.Marshal(r)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return clone, err
	},
	DecodeExternalResp: func(httpResp *http.Response, json jsoniter.API) (resp EncoreInternal_FooResp, err error) {
		return __api.Void{}, nil
	},
	DecodeReq: func(httpReq *http.Request, ps __api.UnnamedParams, json jsoniter.API) (reqData *EncoreInternal_FooReq, pathParams __api.UnnamedParams, err error) {
		reqData = new(EncoreInternal_FooReq)
		return reqData, nil, nil
	},
	DefLoc: uint32(0x0),
	EncodeExternalReq: func(reqData *EncoreInternal_FooReq, stream *jsoniter.Stream) (httpHeader http.Header, queryString url.Values, err error) {
		return nil, nil, nil
	},
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, resp EncoreInternal_FooResp) (err error) {
		return nil
	},
	Endpoint:            "Foo",
	Fallback:            false,
	GlobalMiddlewareIDs: []string{},
	Methods:             []string{"GET", "POST"},
	Path:                "/code.Foo",
	PathParamNames:      nil,
	Raw:                 false,
	RawHandler:          nil,
	RawPath:             "/code.Foo",
	ReqPath: func(reqData *EncoreInternal_FooReq) (string, __api.UnnamedParams, error) {
		return "/code.Foo", nil, nil
	},
	ReqUserPayload: func(reqData *EncoreInternal_FooReq) any {
		return nil
	},
	Service:           "code",
	ServiceMiddleware: []*__api.Middleware{},
	SvcNum:            1,
	Tags:              nil,
}

----------------------------------------

TITLE: Generated Type-Safe Configuration Unmarshalers for Encore
DESCRIPTION: This code is automatically generated by Encore to provide type-safe unmarshalers for configuration values. It creates specialized unmarshalers for each generic type instance used in the application's configuration.

LANGUAGE: go
CODE:
var (
	encoreInternalConfigUnmarshaler_ptr_examplecom_CfgType_uint_ = func(itr *jsoniter.Iterator, path []string) *CfgType[uint] {
		return func() *CfgType[uint] {
			// If the value is null, we return nil
			if itr.ReadNil() {
				return nil
			}

			// Otherwise we unmarshal the value and return a pointer to it
			obj := encoreInternalTypeConfigUnmarshaler_generics_CfgType[uint](func(itr *jsoniter.Iterator, path []string) uint {
				return itr.ReadUint()
			})(itr, append(path))
			return &obj
		}()
	}
)

----------------------------------------

TITLE: Encore Generated Service Interface
DESCRIPTION: Auto-generated code that defines a service interface for the API endpoints. This interface is used for mocking in tests and for service-to-service calls.

LANGUAGE: go
CODE:
// Code generated by encore. DO NOT EDIT.

package code

import "context"

// These functions are automatically generated and maintained by Encore
// to simplify calling them from other services, as they were implemented as methods.
// They are automatically updated by Encore whenever your API endpoints change.

// Interface defines the service's API surface area, primarily for mocking purposes.
//
// Raw endpoints are currently excluded from this interface, as Encore does not yet
// support service-to-service API calls to raw endpoints.
type Interface interface {
	Foo(ctx context.Context) error
}

----------------------------------------

TITLE: Defining a Basic Encore API Endpoint in Go
DESCRIPTION: Declares a basic Encore service with a public API endpoint 'Foo' that returns a Params struct. The endpoint is marked with the 'encore:api public' annotation to expose it publicly.

LANGUAGE: go
CODE:
package basic

import "context"

type Params struct {
    String string
    Int int
}

//encore:api public
func Foo(ctx context.Context) (*Params, error) { return nil, nil }

----------------------------------------

TITLE: Invalid API call from outside a service context
DESCRIPTION: Attempts to call the API function 'One' from another package, which causes an error in Encore since APIs can only be called from within services. This demonstrates a common restriction in the Encore framework.

LANGUAGE: go
CODE:
func Foo(ctx context.Context) error {
    return one.One(ctx)
}

----------------------------------------

TITLE: Defining an Encore Service Package with Configuration
DESCRIPTION: Defines a Go package for an Encore service with necessary imports for context, time, config management, and UUID handling. The service includes a Config struct with a map of ages by string keys.

LANGUAGE: go
CODE:
package svc

import (
	"context"
    "time"

	"encore.dev/config"
	"encore.dev/types/uuid"
)

----------------------------------------

TITLE: Defining Generic Types and Configuration Structure in Go
DESCRIPTION: Defines a set of generic types including DisablableOption, List, and Map, and creates a Config struct that uses these generic types for various configuration options. The configuration is loaded with Encore's config system.

LANGUAGE: go
CODE:
package svc

import (
	"context"
    "time"

	"encore.dev/config"
	"encore.dev/types/uuid"
)

// Generic option which can be disbaled
type DisablableOption[T any] struct {
    Option   T
    Disabled bool // True if this is disabled
}

type List[T any] []T

// A nice generic map
type Map[K any, V any] map[K]V

type Config struct {
    HTTP    DisablableOption[uint16] // The options for the HTTP server
    Another DisablableOption[uint64]
    TCP     DisablableOption[uint16] // The options for the TCP server
    GRPC    DisablableOption[uint64] // The options for the GRPC server
    List1   List[string]             // A list of strings
    List2   List[string]
    List3   List[int]
    Map1    Map[string, string]
    Map2    Map[int, string]
    Map3    Map[string, string]
}

var _ = config.Load[*Config]()

----------------------------------------

TITLE: Declaring Encore Service and Database Resource
DESCRIPTION: Configuration for an Encore service named 'myservice' with a SQL database resource binding.

LANGUAGE: plain
CODE:
parse
output 'svc myservice dbs=myservice'
output 'resource SQLDBResource myservice.Moo db=myservice'

----------------------------------------

TITLE: Header Validation in Encore.ts
DESCRIPTION: This example demonstrates how to validate HTTP headers using the Header type, requiring specific headers to be present in the request.

LANGUAGE: typescript
CODE:
import { Header } from "encore.dev/api";

interface Params {
  language: Header<"Accept-Language">; // parsed from header
  author: string; // not a header
}

----------------------------------------

TITLE: Empty SQL Migration File (SQL)
DESCRIPTION: A placeholder SQL migration file for the service. Migration files are used to manage database schema changes in Encore applications.

LANGUAGE: sql
CODE:


----------------------------------------

TITLE: Defining Encore API Endpoints with Different Parameter Types in Go
DESCRIPTION: Implements three public API endpoints for an Encore service, each handling a different parameter type from the URL path. The endpoints handle string, integer, and UUID parameters respectively, all returning nil errors.

LANGUAGE: go
CODE:
package svc

import (
	"context"
	"encore.dev/types/uuid"
)

//encore:api public path=/str/:p
func Str(ctx context.Context, p string) error { return nil }

//encore:api public path=/int/:p
func Int(ctx context.Context, p int) error { return nil }

//encore:api public path=/uuid/:p
func UUID(ctx context.Context, p uuid.UUID) error { return nil }

----------------------------------------

TITLE: Generated Static Configuration for Encore App
DESCRIPTION: A synthetic file containing the application's static configuration in JSON format. This includes information about the compiler, services, CORS settings, PubSub topics, and test configurations.

LANGUAGE: go
CODE:
package synthetic

/*

This is a synthetic file describing the generated static config:

{
	"EncoreCompiler": "",
	"AppCommit": {
		"revision": "",
		"uncommitted": false
	},
	"CORSAllowHeaders": null,
	"CORSExposeHeaders": null,
	"PubsubTopics": {},
	"Testing": false,
	"TestServiceMap": {
		"code": "testing_path:code"
	},
	"TestAppRootPath": "testing_path:main",
	"PrettyPrintLogs": false,
	"BundledServices": [
		"code"
	],
	"EmbeddedEnvs": {}
}
*/

----------------------------------------

TITLE: Transformed Configuration Structure with API Endpoint in Service A
DESCRIPTION: The transformed version of AsConfig that includes the service name and an internal unmarshaler function in the config.Load call. The API function remains unchanged.

LANGUAGE: go
CODE:
package svc

import (
	"context"

	"encore.dev/config"
)

type AsConfig struct {
    // Multiline test
    // comment to deduplicate.
    Foo config.String
}

var _ = config.Load[*AsConfig]("svc", encoreInternalConfigUnmarshaler_ptr_svc_AsConfig/*line :15:32*/)

//encore:api
func MyAPI(ctx context.Context) (error) {
	return nil
}

----------------------------------------

TITLE: Auto-generated API Runtime Implementation for Encore
DESCRIPTION: This file contains the auto-generated implementation code for handling HTTP requests to the defined API endpoint. It includes request/response types, encoding/decoding logic, middleware configurations, URL path handling, and API registration code that connects the endpoint definition to its implementation.

LANGUAGE: go
CODE:
package code

import (
	"context"
	__api "encore.dev/appruntime/apisdk/api"
	__etype "encore.dev/appruntime/shared/etype"
	jsoniter "github.com/json-iterator/go"
	"net/http"
	"net/url"
	"strings"
)

func init() {
	__api.RegisterEndpoint(EncoreInternal_api_APIDesc_Foo, Foo)
}

type EncoreInternal_FooReq struct {
	P0 string
}

type EncoreInternal_FooResp = __api.Void

var EncoreInternal_api_APIDesc_Foo = &__api.Desc[*EncoreInternal_FooReq, EncoreInternal_FooResp]{
	Access: __api.Public,
	AppHandler: func(ctx context.Context, reqData *EncoreInternal_FooReq) (EncoreInternal_FooResp, error) {
		err := Foo(ctx, reqData.P0)
		if err != nil {
			return __api.Void{}, err
		}
		return __api.Void{}, nil
	},
	CloneReq: func(r *EncoreInternal_FooReq) (*EncoreInternal_FooReq, error) {
		var clone *EncoreInternal_FooReq
		bytes, err := jsoniter.ConfigDefault.Marshal(r)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return clone, err
	},
	CloneResp: func(r EncoreInternal_FooResp) (EncoreInternal_FooResp, error) {
		var clone EncoreInternal_FooResp
		bytes, err := jsoniter.ConfigDefault.Marshal(r)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return clone, err
	},
	DecodeExternalResp: func(httpResp *http.Response, json jsoniter.API) (resp EncoreInternal_FooResp, err error) {
		return __api.Void{}, nil
	},
	DecodeReq: func(httpReq *http.Request, ps __api.UnnamedParams, json jsoniter.API) (reqData *EncoreInternal_FooReq, pathParams __api.UnnamedParams, err error) {
		reqData = new(EncoreInternal_FooReq)
		dec := new(__etype.Unmarshaller)
		// Trim the leading slash from wildcard parameter, as Encore's semantics excludes it,
		// while the httprouter implementation includes it.
		ps[0] = strings.TrimPrefix(ps[0], "/")

		if value, err := url.PathUnescape(ps[0]); err == nil {
			ps[0] = value
		}
		reqData.P0 = __etype.UnmarshalOne(dec, __etype.UnmarshalString, "fallback", ps[0], true)
		if err := dec.Error; err != nil {
			return nil, nil, err
		}
		return reqData, ps, nil
	},
	DefLoc: uint32(0x0),
	EncodeExternalReq: func(reqData *EncoreInternal_FooReq, stream *jsoniter.Stream) (httpHeader http.Header, queryString url.Values, err error) {
		return nil, nil, nil
	},
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, resp EncoreInternal_FooResp) (err error) {
		return nil
	},
	Endpoint:            "Foo",
	Fallback:            true,
	GlobalMiddlewareIDs: []string{},
	Methods:             []string{"GET", "POST"},
	Path:                "/!fallback",
	PathParamNames:      []string{"fallback"},
	Raw:                 false,
	RawHandler:          nil,
	RawPath:             "/*0",
	ReqPath: func(reqData *EncoreInternal_FooReq) (string, __api.UnnamedParams, error) {
		params := __api.UnnamedParams{__etype.MarshalOne(__etype.MarshalString, reqData.P0)}
		return "/" + url.PathEscape(params[0]), params, nil
	},
	ReqUserPayload: func(reqData *EncoreInternal_FooReq) any {
		return nil
	},
	Service:           "code",
	ServiceMiddleware: []*__api.Middleware{},
	SvcNum:            1,
	Tags:              nil,
}

----------------------------------------

TITLE: Defining an Encore API Endpoint
DESCRIPTION: Simple definition of an API endpoint using Encore's conventions. The //encore:api annotation marks this function as an API endpoint.

LANGUAGE: go
CODE:
package code

import "context"

//encore:api
func Foo(ctx context.Context) error { return nil }

----------------------------------------

TITLE: Defining Header Parameters with Struct Tags in Go
DESCRIPTION: Defines a Params struct with header tags that specify how fields map to HTTP headers. The 'X-Foo' header is mapped to Foo field, while the Ignore field is excluded from header mapping with '-'.

LANGUAGE: go
CODE:
type Params struct {
    Foo   string `header:"X-Foo"`
    Ignore string `header:"-"`
}

----------------------------------------

TITLE: Creating a Public API Endpoint with Encore
DESCRIPTION: Defines a package 'bar' with a public API endpoint 'CallFoo' that calls the Log function from the foo package. The function is tagged with '//encore:api public' to expose it as a public API endpoint.

LANGUAGE: go
CODE:
package bar

import (
    "context"

    "test/foo"
)

//encore:api public
func CallFoo(ctx context.Context) error {
    foo.Log()
    return nil
}

----------------------------------------

TITLE: Loading Configuration in Encore
DESCRIPTION: Demonstrates how to load configuration in an Encore application using the config.Load function with a typed parameter.

LANGUAGE: go
CODE:
var _ = config.Load[*Config]()

----------------------------------------

TITLE: Importing Dependencies for Encore Service
DESCRIPTION: This import block includes the necessary packages for the Encore service. It imports context and time from the standard library, as well as config and uuid from the Encore framework.

LANGUAGE: go
CODE:
import (
	"context"
    "time"

	"encore.dev/config"
	"encore.dev/types/uuid"
)

----------------------------------------

TITLE: Configuring Encore Project Resources
DESCRIPTION: Configuration for Encore services and resources, defining a database service and a SQL database resource named 'Moo'.

LANGUAGE: plain
CODE:
parse
output 'svc svc dbs=svc'
output 'resource SQLDBResource svc.Moo db=svc'

----------------------------------------

TITLE: Defining Service Configuration Structs with JSON Tags in Go
DESCRIPTION: Defines data structures for service configuration with JSON tags to customize serialization behavior. ServerOption contains basic server settings, while Config aggregates multiple server options for different protocols.

LANGUAGE: go
CODE:
type ServerOption struct {
    Option   int64
    Disabled bool `json:",omitempty"` // True if this is disabled
}

type Config struct {
    HTTP    ServerOption
    Another ServerOption `json:"a_n_o_t_h_e_r"`
    TCP     ServerOption `json:",omitempty"`
    GRPC    ServerOption `json:",omitempty"`
}

----------------------------------------

TITLE: Incorrectly Structured Encore Service API Definition in Go
DESCRIPTION: This code shows an invalid Encore service structure where an API endpoint is incorrectly defined as a method on a non-service struct. The //encore:api annotation must be used with methods defined on the service struct that is marked with //encore:service.

LANGUAGE: go
CODE:
package svc

import (
	"context"
	"encore.dev/types/uuid"
)

//encore:service
type Service struct {}

type Params struct{}

type SomeOtherType struct {}

//encore:api public
func (s *SomeOtherType) Str(ctx context.Context, p *Params) error { return nil }

----------------------------------------

TITLE: Generated Encore Auth Handler Registration
DESCRIPTION: Automatically generated code for registering and implementing the authentication handler. This includes decoding the authentication token from the Authorization header and handling the auth flow.

LANGUAGE: go
CODE:
package code

import (
	"context"
	__api "encore.dev/appruntime/apisdk/api"
	__model "encore.dev/appruntime/exported/model"
	errs "encore.dev/beta/errs"
	"net/http"
	"strings"
)

var EncoreInternal_authhandler_AuthDesc_AuthHandler = &__api.AuthHandlerDesc[string]{
	AuthHandler: func(ctx context.Context, params string) (info __model.AuthInfo, err error) {
		info.UID, info.UserData, err = AuthHandler(ctx, params)
		return info, err
	},
	DecodeAuth: func(httpReq *http.Request) (params string, err error) {
		if auth := httpReq.Header.Get("Authorization"); auth != "" {
			for _, prefix := range [...]string{"Bearer ", "Token "} {
				if strings.HasPrefix(auth, prefix) {
					if params = auth[len(prefix):]; params != "" {
						return params, nil
					}
				}
			}
		}
		return "", errs.B().Code(errs.Unauthenticated).Msg("invalid auth param").Err()
	},
	DefLoc:      uint32(0x0),
	Endpoint:    "AuthHandler",
	HasAuthData: true,
	Service:     "code",
	SvcNum:      1,
}

func init() {
	__api.RegisterAuthHandler(EncoreInternal_authhandler_AuthDesc_AuthHandler)
}

func init() {
	__api.RegisterAuthDataType[*MyAuthData]()
}

----------------------------------------

TITLE: Defining Temporal Client Options in Go
DESCRIPTION: Defines a ClientOptions struct for the Temporal client configuration with HostPort and Namespace fields.

LANGUAGE: go
CODE:
package temporal
type ClientOptions struct {
	HostPort  string
	Namespace string
}

----------------------------------------

TITLE: Generated Service Helper Functions for Cross-Service Communication in Go
DESCRIPTION: Auto-generated code that provides standalone functions for calling service methods from other services. Includes a wrapper function for the 'Foo' method and an interface definition for mocking purposes.

LANGUAGE: go
CODE:
// Code generated by encore. DO NOT EDIT.

package basic

import "context"

// These functions are automatically generated and maintained by Encore
// to simplify calling them from other services, as they were implemented as methods.
// They are automatically updated by Encore whenever your API endpoints change.

func Foo(ctx context.Context) error {
	svc, err := EncoreInternal_svcstruct_Service.Get()
	if err != nil {
		return err
	}
	return svc.Foo(ctx)
}

// Interface defines the service's API surface area, primarily for mocking purposes.
//
// Raw endpoints are currently excluded from this interface, as Encore does not yet
// support service-to-service API calls to raw endpoints.
type Interface interface {
	Foo(ctx context.Context) error
}

----------------------------------------

TITLE: Defining a Public API Endpoint with Tags in Encore
DESCRIPTION: Defines a public API endpoint called 'Tagged' using Encore's annotation system with 'foo' and 'bar' tags. The function takes a context and returns an error, implementing minimal functionality.

LANGUAGE: go
CODE:
package code

import "context"

//encore:api public tag:foo tag:bar
func Tagged(ctx context.Context) error { return nil }

----------------------------------------

TITLE: Defining Pub/Sub Topic and Message Type in Go with Encore
DESCRIPTION: Defines a message type structure with attributes and creates a pub/sub topic with specific configuration options including delivery guarantee and ordering attribute. Includes an API endpoint that publishes a message to the topic.

LANGUAGE: go
CODE:
package svc

import (
    "context"

    "encore.dev/pubsub"
)

type MessageType struct {
    UserID int64 `pubsub-attr:"user_id"`
    Name string
}

var (
    BasicTopic = pubsub.NewTopic[*MessageType]("basic", pubsub.TopicConfig{
        DeliveryGuarantee: pubsub.AtLeastOnce,
        OrderingAttribute: "user_id",
    })
)

// encore:api
func DoStuff(ctx context.Context) error {
    return BasicTopic.Publish(ctx, &MessageType{UserID: 1, Name: "foo"})
}

----------------------------------------

TITLE: Defining Basic API Endpoint in Bar Service
DESCRIPTION: Defines a simple API endpoint called Bar in the bar service package using the Encore framework annotation //encore:api.

LANGUAGE: go
CODE:
package bar

import "context"

//encore:api
func Bar(ctx context.Context) error { return nil }

----------------------------------------

TITLE: Creating an API Endpoint with Encore
DESCRIPTION: This function defines a simple API endpoint using Encore's annotation system. The '//encore:api' annotation exposes the function as an API endpoint, which takes a context parameter and returns an error.

LANGUAGE: go
CODE:
//encore:api
func MyAPI(ctx context.Context) (error) {
	return nil
}

----------------------------------------

TITLE: Defining an Encore Service with Public API
DESCRIPTION: Go code that defines an Encore service with a public API endpoint. The service includes the encore:service annotation for the Service type and encore:api public annotation for the Str method, which makes it publicly accessible.

LANGUAGE: Go
CODE:
package svc

import (
	"context"
	"encore.dev/types/uuid"
)

//encore:service
type Service struct {}

type Params struct{}

//encore:api public
func (s *Service) Str(ctx context.Context, p *Params) error { return nil }

----------------------------------------

TITLE: Importing and Using Database Service from Another Package
DESCRIPTION: Demonstrates how to import and use the database service from another package. Includes examples of using QueryRow and Publish methods from the imported DB variable.

LANGUAGE: go
CODE:
package usage
import "example.com/svc"

var x = svc.DB.QueryRow() // use svc.DB call QueryRow
var y = DB.Publish(svc.Message{})

----------------------------------------

TITLE: Generated Config Unmarshaling for Encore
DESCRIPTION: Automatically generated code by Encore for unmarshaling configuration values into the correct types. It implements the JSON unmarshaling logic for the Config struct using jsoniter with support for nested structures and arrays.

LANGUAGE: go
CODE:
package svc

import (
	config "encore.dev/config"
	jsoniter "github.com/json-iterator/go"
)

/*
These functions are automatically generated and maintained by Encore to allow config values
to be unmarshalled into the correct types. They are not intended to be used directly. They
are automatically updated by Encore whenever you change the data types used within your
calls to config.Load[T]().
*/

// Concrete unmarshalers for all config.Load calls, including those using generic types.
// These instances are used directly by calls to `config.Load[T]()`.
var (
	encoreInternalConfigUnmarshaler_ptr_svc_Config = func(itr *jsoniter.Iterator, path []string) *Config {
		return func() *Config {
			// If the value is null, we return nil
			if itr.ReadNil() {
				return nil
			}

			// Otherwise we unmarshal the value and return a pointer to it
			obj := encoreInternalTypeConfigUnmarshaler_svc_Config(itr, append(path))
			return &obj
		}()
	}
)

// encoreInternalTypeConfigUnmarshaler_svc_Config will unmarshal the JSON representation into the given type, taking account for
// the `config.Value` dynamic functions.
func encoreInternalTypeConfigUnmarshaler_svc_Config(itr *jsoniter.Iterator, path []string) (obj Config) {
	itr.ReadObjectCB(func(itr *jsoniter.Iterator, field string) bool {
		switch field {
		case "Ages":
			obj.Ages = config.ReadArray[int32](itr, func(itr *jsoniter.Iterator, idx int) int32 {
				return itr.ReadInt32()
			})
		case "OtherBits":
			obj.OtherBits = config.ReadArray[string](itr, func(itr *jsoniter.Iterator, idx int) string {
				return itr.ReadString()
			})
		default:
			itr.Skip()
		}
		return true
	})
	return
}

----------------------------------------

TITLE: Service Package Definition with Authentication Imports
DESCRIPTION: Defines the service package with necessary imports for authentication functionality, including the auth package from Encore.

LANGUAGE: go
CODE:
package svc

import (
    "context"
    
    "encore.dev/beta/auth"
)

----------------------------------------

TITLE: Modified Cross-Service API Call with Internal Implementation (svcb)
DESCRIPTION: The transformed version of the svcb service that uses the internal API call mechanism generated by Encore. This shows how Encore replaces direct service calls with its internal communication layer.

LANGUAGE: go
CODE:
package svcb

import ("context"; "example.com/svca")

//encore:api public
func Baz(ctx context.Context) error { return svca.EncoreInternal_apicalls_Foo(ctx) }

----------------------------------------

TITLE: Modified Service Configuration with Unmarshaler Reference in Go
DESCRIPTION: Shows the result of Encore's code generation process where the config.Load call is extended with a service name parameter and reference to the automatically generated unmarshaler function.

LANGUAGE: go
CODE:
package svc

import (
	"context"

	"encore.dev/config"

	"example.com/svc/utils"
	"example.com/svc/helpers"
)

type Config struct {
    A helpers.ExtraConfig
    B utils.ExtraConfig
    C helpers.ExtraConfig
    D utils.ExtraConfig
    E helpers.SingleUse
}

var _ = config.Load[*Config]("svc", encoreInternalConfigUnmarshaler_ptr_svc_Config/*line :20:30*/)

//encore:api
func MyAPI(ctx context.Context) (error) {
	return nil
}

----------------------------------------

TITLE: Updating Site Check Function to Publish Status Transitions in Go
DESCRIPTION: Modifies the existing check function to publish a message to the Pub/Sub topic when a site's status changes. This connects the monitoring logic to the notification system through the Pub/Sub topic.

LANGUAGE: go
CODE:
func check(ctx context.Context, site *site.Site) error {
	result, err := Ping(ctx, site.URL)
	if err != nil {
		return err
	}

	// Publish a Pub/Sub message if the site transitions
	// from up->down or from down->up.
	if err := publishOnTransition(ctx, site, result.Up); err != nil {
		return err
	}

	_, err = db.Exec(ctx, `
		INSERT INTO checks (site_id, up, checked_at)
		VALUES ($1, $2, NOW())
	`, site.ID, result.Up)
	return err
}

----------------------------------------

TITLE: Final Deployment Commands for Slack Bot
DESCRIPTION: Shell commands to commit and deploy the final version of the Slack bot with all security enhancements and improved ASCII art. This pushes the changes to Encore's cloud environment.

LANGUAGE: shell
CODE:
$ git add -A .
$ git commit -m 'Verify webhook requests and improve art'
$ git push encore

----------------------------------------

TITLE: Modified Service Implementation with API Call Wrappers
DESCRIPTION: The modified implementation of svca showing how Encore replaces direct function calls between services with API call wrappers.

LANGUAGE: go
CODE:
package svca

import "context"

//encore:api public
func Foo(ctx context.Context) error { return nil }

//encore:api public
func Bar(ctx context.Context) error { return EncoreInternal_apicalls_Foo(ctx) }

----------------------------------------

TITLE: Missing Generic Type Parameter Test in Go
DESCRIPTION: Demonstrates how Encore handles an error case where a generic type (Generic[T]) is referenced without specifying the required type parameter. The code defines a struct 'Params' that uses '*Generic' without type arguments, which should trigger parsing errors.

LANGUAGE: go
CODE:
package foo

import "context"

type Params struct {
    C *Generic
}

type Generic[T any] struct {
    Val *T
}

//encore:api public
func Dummy(ctx context.Context, p *Params) error {
    return nil
}

----------------------------------------

TITLE: Generated Encore Application Main Entry Point
DESCRIPTION: Generated main entry point for the Encore application. This initializes the application runtime and imports the app package.

LANGUAGE: go
CODE:
package main

import (
	appinit "encore.dev/appruntime/apisdk/app/appinit"
	_ "example.com"
)

func main() {
	appinit.AppMain()
}

----------------------------------------

TITLE: Implementing a Basic Encore API Endpoint in Go
DESCRIPTION: Defines a simple API endpoint 'MyAPI' using Encore's API declaration syntax. The function takes a context.Context parameter and returns an error type. This implementation is minimal and simply returns nil.

LANGUAGE: Go
CODE:
package svc

import (
	"context"
)

//encore:api
func MyAPI(ctx context.Context) (error) {
	return nil
}

----------------------------------------

TITLE: Invalid Path Parameter Declaration in Encore API
DESCRIPTION: This code snippet demonstrates an invalid API declaration in Encore where a custom struct is used as a path parameter. Encore requires path parameters to be strings, booleans, integers, or UUID types, not structs.

LANGUAGE: go
CODE:
package svc

import (
	"context"
	"encore.dev/types/uuid"
)

type Struct struct{}

//encore:api public path=/str/:p
func Str(ctx context.Context, p *Struct) error { return nil }

----------------------------------------

TITLE: Updated Encore Service with Injected Unmarshaler
DESCRIPTION: The modified version of the service file where Encore has injected the config unmarshaler function as an argument to config.Load. This shows how Encore transforms the code at build time.

LANGUAGE: go
CODE:
package svc

import (
	"context"

	"encore.dev/config"
)

type Config struct {
    Ages map[string]int
}

var _ = config.Load[*Config]("svc", encoreInternalConfigUnmarshaler_ptr_svc_Config/*line :13:30*/)

//encore:api
func MyAPI(ctx context.Context) (error) {
	return nil
}

----------------------------------------

TITLE: Defining PubSub Topic in Shared Package
DESCRIPTION: Creates a PubSub topic named 'same-name' in the shared package using Encore's pubsub package. The topic is configured with 'AtLeastOnce' delivery guarantee and handles messages of MessageType.

LANGUAGE: go
CODE:
package shared

import (
    "encore.dev/pubsub"
)

type MessageType struct {
    Name string
}

var BasicTopic = pubsub.NewTopic[*MessageType]("same-name", pubsub.TopicConfig{ DeliveryGuarantee: pubsub.AtLeastOnce })

----------------------------------------

TITLE: Defining a Service with Cache Cluster in Encore
DESCRIPTION: Creates an Encore service with a cache cluster definition. This shows the correct way to initialize a cache cluster within an Encore service.

LANGUAGE: go
CODE:
package svc

import (
    "context"

    "encore.dev/storage/cache"
)

var Cluster = cache.NewCluster("cluster", cache.ClusterConfig{})

//encore:api public
func Foo(ctx context.Context) error { return nil }

----------------------------------------

TITLE: Transformed Encore Service with Generated Handler Functions
DESCRIPTION: Shows the transformed version of the service file where method handlers are replaced with the generated internal handler functions. This is how Encore processes the service definitions during compilation.

LANGUAGE: Go
CODE:
package svc

import (
	"context"
	"encore.dev/pubsub"
)

//encore:service
type Service struct{}

func (s *Service) PointerMethod(ctx context.Context, event *Event) error {
    return nil
}

func (s Service) NonPointerMethod(ctx context.Context, event *Event) error {
    return nil
}

type Event struct {}

var Topic = pubsub.NewTopic[*Event]("topic", pubsub.TopicConfig{
    DeliveryGuarantee: pubsub.AtLeastOnce,
})

var _ = pubsub.NewSubscription(Topic, "pointer",
    pubsub.SubscriptionConfig[*Event]{
        Handler: EncoreInternal_pubsub_handler_pointer,
    },
)

var _ = pubsub.NewSubscription(Topic, "non-pointer",
    pubsub.SubscriptionConfig[*Event]{
        Handler: EncoreInternal_pubsub_handler_non_pointer,
    },
)

----------------------------------------

TITLE: Implementing PubSub Service with Pointer and Non-Pointer Methods in Go
DESCRIPTION: Complete implementation of a service that handles pubsub events using both pointer receiver methods and non-pointer receiver methods. It defines an Event type, creates topics for each method type, and sets up subscriptions that route events to the appropriate handlers.

LANGUAGE: go
CODE:
package svc

import (
    "context"
    "encore.dev/rlog"
    "encore.dev/pubsub"
)

//encore:service
type Service struct{}

func (s *Service) PointerMethod(ctx context.Context, event *Event) error {
    rlog.Info("pointer method", "event", event)
    return nil
}

func (s Service) NonPointerMethod(ctx context.Context, event *Event) error {
    rlog.Info("non-pointer method", "event", event)
    return nil
}

type Event struct {
    Data string
}

var Pointer = pubsub.NewTopic[*Event]("pointer", pubsub.TopicConfig{
    DeliveryGuarantee: pubsub.AtLeastOnce,
})

var NonPointer = pubsub.NewTopic[*Event]("non-pointer", pubsub.TopicConfig{
    DeliveryGuarantee: pubsub.AtLeastOnce,
})

var _ = pubsub.NewSubscription(Pointer, "pointer",
    pubsub.SubscriptionConfig[*Event]{
        Handler: pubsub.MethodHandler((*Service).PointerMethod),
    },
)

var _ = pubsub.NewSubscription(NonPointer, "non-pointer",
    pubsub.SubscriptionConfig[*Event]{
        Handler: pubsub.MethodHandler(Service.NonPointerMethod),
    },
)

----------------------------------------

TITLE: Defining Service A with Database Connection in Go
DESCRIPTION: Defines a service 'svca' with a public API endpoint Foo() and a named SQL database connection that can be used by other services.

LANGUAGE: go
CODE:
package svca

import (
    "context"

    "encore.dev/storage/sqldb"
)

var Moo = sqldb.Named("svca")

//encore:api public
func Foo(ctx context.Context) error {
    return nil
}

----------------------------------------

TITLE: Incorrect Auth Handler Reference From Another Package
DESCRIPTION: Shows an invalid attempt to reference an auth handler from another package. In Encore, auth handlers can only be called, not referenced as values or passed around.

LANGUAGE: go
CODE:
package svc2

import (
    "context"
    "test/svc"
)

func Foo() {
    _ = svc.MyAuth
}

----------------------------------------

TITLE: Generated Encore Internal API Request Handling Implementation
DESCRIPTION: This auto-generated implementation file contains the detailed API handling code for the Foo endpoint. It includes request/response types, serialization, deserialization, HTTP routing, middleware integration, and the registration of the API with Encore's runtime system.

LANGUAGE: go
CODE:
package code

import (
	"context"
	__api "encore.dev/appruntime/apisdk/api"
	__etype "encore.dev/appruntime/shared/etype"
	__serde "encore.dev/appruntime/shared/serde"
	jsoniter "github.com/json-iterator/go"
	"net/http"
	"net/url"
	"strings"
)

func init() {
	__api.RegisterEndpoint(EncoreInternal_api_APIDesc_Foo, Foo)
}

type EncoreInternal_FooReq struct{}

type EncoreInternal_FooResp = *Response

var EncoreInternal_api_APIDesc_Foo = &__api.Desc[*EncoreInternal_FooReq, EncoreInternal_FooResp]{
	Access: __api.Public,
	AppHandler: func(ctx context.Context, reqData *EncoreInternal_FooReq) (EncoreInternal_FooResp, error) {
		resp, err := Foo(ctx)
		if err != nil {
			return (*Response)(nil), err
		}
		return resp, nil
	},
	CloneReq: func(r *EncoreInternal_FooReq) (*EncoreInternal_FooReq, error) {
		var clone *EncoreInternal_FooReq
		bytes, err := jsoniter.ConfigDefault.Marshal(r)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return clone, err
	},
	CloneResp: func(r EncoreInternal_FooResp) (EncoreInternal_FooResp, error) {
		var clone EncoreInternal_FooResp
		bytes, err := jsoniter.ConfigDefault.Marshal(r)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return clone, err
	},
	DecodeExternalResp: func(httpResp *http.Response, json jsoniter.API) (resp EncoreInternal_FooResp, err error) {
		resp = new(Response)
		dec := new(__etype.Unmarshaller)
		// Decode request body
		payload := dec.ReadBody(httpResp.Body)
		iter := jsoniter.ParseBytes(json, payload)

		for iter.ReadObjectCB(func(_ *jsoniter.Iterator, key string) bool {
			switch strings.ToLower(key) {
			case "exported":
				dec.ParseJSON("Exported", iter, &resp.Exported)
			default:
				_ = iter.SkipAndReturnBytes()
			}
			return true
		}) {
		}

		if err := dec.Error; err != nil {
			return (*Response)(nil), err
		}
		return resp, nil
	},
	DecodeReq: func(httpReq *http.Request, ps __api.UnnamedParams, json jsoniter.API) (reqData *EncoreInternal_FooReq, pathParams __api.UnnamedParams, err error) {
		reqData = new(EncoreInternal_FooReq)
		return reqData, nil, nil
	},
	DefLoc: uint32(0x0),
	EncodeExternalReq: func(reqData *EncoreInternal_FooReq, stream *jsoniter.Stream) (httpHeader http.Header, queryString url.Values, err error) {
		return nil, nil, nil
	},
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, resp EncoreInternal_FooResp) (err error) {
		respData := []byte("null\n")
		if resp != nil {
			// Encode JSON body
			respData, err = __serde.SerializeJSONFunc(json, func(ser *__serde.JSONSerializer) {
				ser.WriteField("Exported", resp.Exported, false)
			})
			if err != nil {
				return err
			}
			respData = append(respData, '\n')
		}

		// Write response
		w.Write(respData)
		return nil
	},
	Endpoint:            "Foo",
	Fallback:            false,
	GlobalMiddlewareIDs: []string{},
	Methods:             []string{"GET", "POST"},
	Path:                "/code.Foo",
	PathParamNames:      nil,
	Raw:                 false,
	RawHandler:          nil,
	RawPath:             "/code.Foo",
	ReqPath: func(reqData *EncoreInternal_FooReq) (string, __api.UnnamedParams, error) {
		return "/code.Foo", nil, nil
	},
	ReqUserPayload: func(reqData *EncoreInternal_FooReq) any {
		return nil
	},
	Service:           "code",
	ServiceMiddleware: []*__api.Middleware{},
	SvcNum:            1,
	Tags:              nil,
}

----------------------------------------

TITLE: Implementing API Endpoint with Encore Annotation
DESCRIPTION: Defines an API endpoint function using the encore:api annotation. This function doesn't perform any operations and simply returns nil.

LANGUAGE: go
CODE:
//encore:api
func MyAPI(ctx context.Context) (error) {
	return nil
}

----------------------------------------

TITLE: Encore RPC Configuration Declaration
DESCRIPTION: Defines RPC service configuration using Encore's special syntax. Specifies the service with authentication required and raw mode disabled.

LANGUAGE: text
CODE:
parse
output 'rpc svc.API access=auth raw=false'

----------------------------------------

TITLE: Checking Encore Applications for Errors
DESCRIPTION: Performs compile-time error checking on your Encore application using Encore's compiler.

LANGUAGE: shell
CODE:
$ encore check

----------------------------------------

TITLE: Implementing a Simple API Service with Config Loading in Encore
DESCRIPTION: Defines a service package with a Config struct containing a map of ages by name. It loads the configuration using Encore's config.Load function and implements a simple API endpoint.

LANGUAGE: go
CODE:
package svc

import (
	"context"

	"encore.dev/config"
)

type Config struct {
    Ages map[string]int
}

var _ = config.Load[*Config]()

//encore:api
func MyAPI(ctx context.Context) (error) {
	return nil
}

----------------------------------------

TITLE: Error Message for Invalid PubSub Topic Name in Encore
DESCRIPTION: This error message explains the naming requirements for PubSub topics in Encore. Topic names must be in kebab-case format, which means they must start with a letter, end with a letter or number, and only contain lowercase letters, numbers, and dashes.

LANGUAGE: text
CODE:
── Invalid resource name ──────────────────────────────────────────────────────────────────[E9999]──

The pubsub.NewTopic topic name must be defined in "kebab-case".

    ╭─[ svc/svc.go:14:48 ]
    │
 12 │
 13 │ var (
 14 │     BasicTopic = pubsub.NewTopic[*MessageType]("basic topic", pubsub.TopicConfig{ DeliveryGuarantee: pubsub.AtLeastOnce })
    ⋮                                                ──────┬──────
    ⋮                                                      ╰─ try basic-topic?
 15 │ )
 16 │
────╯

pubsub.NewTopic topic name's must be defined as string literals, be between 1 and 63 characters
long, and defined in "kebab-case", meaning it must start with a letter, end with a letter or number
and only contain lower case letters, numbers and dashes.

----------------------------------------

TITLE: Defining an Encore Service with SQL Database Reference in Go
DESCRIPTION: This code defines an Encore service package with a reference to a SQL database and a public API endpoint. It attempts to use sqldb.Named to reference a database that doesn't exist in the application, which causes an error.

LANGUAGE: go
CODE:
package svc

import (
    "context"

    "encore.dev/storage/sqldb"
)

var Moo = sqldb.Named("unknown-db").Stdlib()

//encore:api public
func Foo(ctx context.Context) error {
    return nil
}

----------------------------------------

TITLE: Basic Go Hello World Application
DESCRIPTION: A minimal Go application that prints 'Hello, world!' to the console.

LANGUAGE: go
CODE:
package main
func main() {
    println("Hello, world!")
}

----------------------------------------

TITLE: Defining Custom Authentication Parameters and Handler in Encore
DESCRIPTION: Defines a custom authentication handler with parameter structures for client ID and API key. The handler extracts credentials from HTTP headers and query parameters, allowing for flexible authentication mechanisms in Encore applications.

LANGUAGE: go
CODE:
package code

import ("context"; "encore.dev/beta/auth")

type MyAuthParams struct {
	ClientID string `header:"X-Client-ID"`
	APIKey   string `query:"key"`
}

type MyAuthData struct {
    Username string
}

//encore:authhandler
func AuthHandler(ctx context.Context, p *MyAuthParams) (auth.UID, *MyAuthData, error) {
    return "", nil, nil
}

----------------------------------------

TITLE: Implementing a Basic Encore Service with a Private API
DESCRIPTION: A minimal implementation of an Encore service package with a single API endpoint. The API function is marked with the encore:api directive to expose it as an endpoint.

LANGUAGE: Go
CODE:
package svc

import "context"

// encore:api
func API(ctx context.Context) error { return nil }

----------------------------------------

TITLE: API Descriptor Configuration for HTTP Endpoint
DESCRIPTION: Comprehensive descriptor that configures how the API endpoint behaves, including access level, request/response handling, HTTP methods, path, and middleware. This handles all the HTTP transport details so the developer can focus on business logic.

LANGUAGE: go
CODE:
var EncoreInternal_api_APIDesc_Foo = &__api.Desc[*EncoreInternal_FooReq, EncoreInternal_FooResp]{
	Access: __api.Public,
	AppHandler: func(ctx context.Context, reqData *EncoreInternal_FooReq) (EncoreInternal_FooResp, error) {
		resp, err := Foo(ctx)
		if err != nil {
			return (*Params)(nil), err
		}
		return resp, nil
	},
	CloneReq: func(r *EncoreInternal_FooReq) (*EncoreInternal_FooReq, error) {
		var clone *EncoreInternal_FooReq
		bytes, err := jsoniter.ConfigDefault.Marshal(r)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return clone, err
	},
	CloneResp: func(r EncoreInternal_FooResp) (EncoreInternal_FooResp, error) {
		var clone EncoreInternal_FooResp
		bytes, err := jsoniter.ConfigDefault.Marshal(r)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return clone, err
	},
	DecodeExternalResp: func(httpResp *http.Response, json jsoniter.API) (resp EncoreInternal_FooResp, err error) {
		resp = new(Params)
		dec := new(__etype.Unmarshaller)
		// Decode headers
		h := httpResp.Header
		resp.Foo = __etype.UnmarshalOne(dec, __etype.UnmarshalString, "x-foo", h.Get("x-foo"), false)

		if err := dec.Error; err != nil {
			return (*Params)(nil), err
		}
		return resp, nil
	},
	DecodeReq: func(httpReq *http.Request, ps __api.UnnamedParams, json jsoniter.API) (reqData *EncoreInternal_FooReq, pathParams __api.UnnamedParams, err error) {
		reqData = new(EncoreInternal_FooReq)
		return reqData, nil, nil
	},
	DefLoc: uint32(0x0),
	EncodeExternalReq: func(reqData *EncoreInternal_FooReq, stream *jsoniter.Stream) (httpHeader http.Header, queryString url.Values, err error) {
		return nil, nil, nil
	},
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, resp EncoreInternal_FooResp) (err error) {
		respData := []byte{'\n'}
		var headers map[string][]string
		if resp != nil {

			// Encode headers
			headers = map[string][]string{"x-foo": []string{__etype.MarshalOne(__etype.MarshalString, resp.Foo)}}
		}

		// Write response
		for k, vs := range headers {
			for _, v := range vs {
				w.Header().Add(k, v)
			}
		}
		w.Write(respData)
		return nil
	},
	Endpoint:            "Foo",
	Fallback:            false,
	GlobalMiddlewareIDs: []string{},
	Methods:             []string{"GET", "POST"},
	Path:                "/code.Foo",
	PathParamNames:      nil,
	Raw:                 false,
	RawHandler:          nil,
	RawPath:             "/code.Foo",
	ReqPath: func(reqData *EncoreInternal_FooReq) (string, __api.UnnamedParams, error) {
		return "/code.Foo", nil, nil
	},
	ReqUserPayload: func(reqData *EncoreInternal_FooReq) any {
		return nil
	},
	Service:           "code",
	ServiceMiddleware: []*__api.Middleware{},
	SvcNum:            1,
	Tags:              nil,
}

----------------------------------------

TITLE: Transformed Configuration Structure in Service C
DESCRIPTION: The transformed version of CsConfig with the service name and an internal unmarshaler function in the config.Load call.

LANGUAGE: go
CODE:
package svc

import (
	"encore.dev/config"
)

type CsConfig struct{
    // Multiline test
    // comment to deduplicate.
    Foo config.String
}

var _ = config.Load[CsConfig]("svc", encoreInternalConfigUnmarshaler_svc_CsConfig/*line :13:31*/)

----------------------------------------

TITLE: Defining Duplicate Cache Clusters in Go with Encore
DESCRIPTION: This code creates two cache clusters with the same name 'cluster', which violates Encore's requirement that cache cluster names must be unique. The duplicated name will trigger an error during application parsing or initialization.

LANGUAGE: go
CODE:
package svc

import (
    "context"

    "encore.dev/storage/cache"
)

var cluster1 = cache.NewCluster("cluster", cache.ClusterConfig{})
var cluster2 = cache.NewCluster("cluster", cache.ClusterConfig{})

//encore:api public
func Foo(ctx context.Context) error { return nil }

----------------------------------------

TITLE: Generated Service Registration Code for Encore
DESCRIPTION: Auto-generated code by Encore to register the service structure with the Encore runtime. This handles service initialization and registration with the service system of the Encore framework.

LANGUAGE: go
CODE:
package code

import __service "encore.dev/appruntime/apisdk/service"

func init() {
	__service.Register(EncoreInternal_svcstruct_Service)
}

var EncoreInternal_svcstruct_Service = &__service.Decl[Service]{
	Name:        "Service",
	Service:     "code",
	Setup:       nil,
	SetupDefLoc: uint32(0x0),
}

----------------------------------------

TITLE: Defining PubSub Topic and Invalid Usage in Encore
DESCRIPTION: This code defines a message type and a PubSub topic using Encore's pubsub package. It then demonstrates an invalid usage pattern by directly passing the topic to a function, which violates Encore's restriction that topics can only be referenced by calling methods on them or passing to specific functions like pubsub.NewSubscription.

LANGUAGE: go
CODE:
package svc

import (
    "encore.dev/pubsub"
)

type MessageType struct {
    Name string
}

var BasicTopic = pubsub.NewTopic[*MessageType]("same-name", pubsub.TopicConfig{ DeliveryGuarantee: pubsub.AtLeastOnce })

func SomeFunc(t *pubsub.Topic[*MessageType]) {}

func init() {
    SomeFunc(BasicTopic)
}

----------------------------------------

TITLE: Defining a Named SQL Database in a Service Package (Go)
DESCRIPTION: Creates a named SQL database resource within a service package using Encore's sqldb.Named function. This service also provides a public API endpoint.

LANGUAGE: go
CODE:
package svc

import (
    "context"

    "encore.dev/storage/sqldb"
)

var Moo = sqldb.Named("svc")

//encore:api public
func Foo(ctx context.Context) error {
    return nil
}

----------------------------------------

TITLE: Expected Output for Test
DESCRIPTION: The expected output from running the program, which should print to stderr.

LANGUAGE: text
CODE:
Hello, overlay world!

----------------------------------------

TITLE: Generated Service Interface for Mocking
DESCRIPTION: Encore-generated code defining a service interface for mocking purposes. This interface represents the API surface area of the service, excluding raw endpoints.

LANGUAGE: go
CODE:
// Interface defines the service's API surface area, primarily for mocking purposes.
//
// Raw endpoints are currently excluded from this interface, as Encore does not yet
// support service-to-service API calls to raw endpoints.
type Interface interface {
	Foo(ctx context.Context, p *Recursive) (*Recursive, error)
}

----------------------------------------

TITLE: Defining an Encore API Configuration Directive
DESCRIPTION: Configuration directive for an Encore service defining a private API that doesn't use raw responses.

LANGUAGE: text
CODE:
output 'svc.API access=private raw=false'

----------------------------------------

TITLE: Loading OtherConfig Configuration
DESCRIPTION: Loads the OtherConfig structure using Encore's config.Load function. Note that unlike the first config loading, this loads the value directly rather than a pointer.

LANGUAGE: go
CODE:
var _ = config.Load[OtherConfig]()

----------------------------------------

TITLE: API Endpoint Description and Handler Configuration
DESCRIPTION: Detailed configuration of the API endpoint including access controls, request/response handling, serialization, and HTTP routing information. This generated code handles the integration between the API function and Encore's infrastructure.

LANGUAGE: go
CODE:
var EncoreInternal_api_APIDesc_Foo = &__api.Desc[*EncoreInternal_FooReq, EncoreInternal_FooResp]{
	Access: __api.Public,
	AppHandler: func(ctx context.Context, reqData *EncoreInternal_FooReq) (EncoreInternal_FooResp, error) {
		resp, err := Foo(ctx, reqData.Payload)
		if err != nil {
			return (*Recursive)(nil), err
		}
		return resp, nil
	},
	CloneReq: func(r *EncoreInternal_FooReq) (*EncoreInternal_FooReq, error) {
		var clone *EncoreInternal_FooReq
		bytes, err := jsoniter.ConfigDefault.Marshal(r)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return clone, err
	},
	CloneResp: func(r EncoreInternal_FooResp) (EncoreInternal_FooResp, error) {
		var clone EncoreInternal_FooResp
		bytes, err := jsoniter.ConfigDefault.Marshal(r)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return clone, err
	},
	DecodeExternalResp: func(httpResp *http.Response, json jsoniter.API) (resp EncoreInternal_FooResp, err error) {
		resp = new(Recursive)
		dec := new(__etype.Unmarshaller)
		// Decode request body
		payload := dec.ReadBody(httpResp.Body)
		iter := jsoniter.ParseBytes(json, payload)

		for iter.ReadObjectCB(func(_ *jsoniter.Iterator, key string) bool {
			switch strings.ToLower(key) {
			case "basic":
				dec.ParseJSON("Basic", iter, &resp.Basic)
			case "pointer":
				dec.ParseJSON("Pointer", iter, &resp.Pointer)
			case "mutual":
				dec.ParseJSON("Mutual", iter, &resp.Mutual)
			default:
				_ = iter.SkipAndReturnBytes()
			}
			return true
		}) {
		}

		if err := dec.Error; err != nil {
			return (*Recursive)(nil), err
		}
		return resp, nil
	},
	DecodeReq: func(httpReq *http.Request, ps __api.UnnamedParams, json jsoniter.API) (reqData *EncoreInternal_FooReq, pathParams __api.UnnamedParams, err error) {
		reqData = new(EncoreInternal_FooReq)
		dec := new(__etype.Unmarshaller)
		params := new(Recursive)
		reqData.Payload = params
		switch m := httpReq.Method; m {
		case "POST":
			// Decode request body
			payload := dec.ReadBody(httpReq.Body)
			iter := jsoniter.ParseBytes(json, payload)

			for iter.ReadObjectCB(func(_ *jsoniter.Iterator, key string) bool {
				switch strings.ToLower(key) {
				case "basic":
					dec.ParseJSON("Basic", iter, &params.Basic)
				case "pointer":
					dec.ParseJSON("Pointer", iter, &params.Pointer)
				case "mutual":
					dec.ParseJSON("Mutual", iter, &params.Mutual)
				default:
					_ = iter.SkipAndReturnBytes()
				}
				return true
			}) {
			}

		default:
			panic("HTTP method is not supported")
		}
		if err := dec.Error; err != nil {
			return nil, nil, err
		}
		return reqData, ps, nil
	},
	DefLoc: uint32(0x0),
	EncodeExternalReq: func(reqData *EncoreInternal_FooReq, stream *jsoniter.Stream) (httpHeader http.Header, queryString url.Values, err error) {
		params := reqData.Payload
		if params == nil {
			// If the payload is nil, we need to return an empty request body.
			return httpHeader, queryString, err
		}

		// Encode request body
		stream.WriteObjectStart()
		stream.WriteObjectField("Basic")
		stream.WriteVal(params.Basic)
		stream.WriteMore()
		stream.WriteObjectField("Pointer")
		stream.WriteVal(params.Pointer)
		stream.WriteMore()
		stream.WriteObjectField("Mutual")
		stream.WriteVal(params.Mutual)
		stream.WriteObjectEnd()

		return httpHeader, queryString, err
	},
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, resp EncoreInternal_FooResp) (err error) {
		respData := []byte("null\n")
		if resp != nil {
			// Encode JSON body
			respData, err = __serde.SerializeJSONFunc(json, func(ser *__serde.JSONSerializer) {
				ser.WriteField("Basic", resp.Basic, false)
				ser.WriteField("Pointer", resp.Pointer, false)
				ser.WriteField("Mutual", resp.Mutual, false)
			})
			if err != nil {
				return err
			}
			respData = append(respData, '\n')
		}

		// Write response
		w.Write(respData)
		return nil
	},
	Endpoint:            "Foo",
	Fallback:            false,
	GlobalMiddlewareIDs: []string{},
	Methods:             []string{"POST"},
	Path:                "/basic.Foo",
	PathParamNames:      nil,
	Raw:                 false,
	RawHandler:          nil,
	RawPath:             "/basic.Foo",
	ReqPath: func(reqData *EncoreInternal_FooReq) (string, __api.UnnamedParams, error) {
		return "/basic.Foo", nil, nil
	},
	ReqUserPayload: func(reqData *EncoreInternal_FooReq) any {
		return reqData.Payload
	},
	Service:           "basic",
	ServiceMiddleware: []*__api.Middleware{},
	SvcNum:            1,
	Tags:              nil,
}

----------------------------------------

TITLE: Defining Configuration Structure in Service C
DESCRIPTION: Defines a CsConfig structure with a string configuration field. The structure includes a multiline comment for the Foo field.

LANGUAGE: go
CODE:
package svc

import (
	"encore.dev/config"
)

type CsConfig struct{
    // Multiline test
    // comment to deduplicate.
    Foo config.String
}

var _ = config.Load[CsConfig]()

----------------------------------------

TITLE: Defining an Auth Handler in Encore
DESCRIPTION: Defines an authentication handler in a service using the encore:authhandler directive. This function processes authentication tokens and returns a user ID or an error.

LANGUAGE: go
CODE:
package svc

import (
    "context"
    "encore.dev/beta/auth"
)

//encore:authhandler
func MyAuth(ctx context.Context, token string) (auth.UID, error) { return "", nil }

----------------------------------------

TITLE: Defining a Database and API Endpoint in Encore
DESCRIPTION: TypeScript code to define a PostgreSQL database connection in Encore and create an API endpoint to query user data.

LANGUAGE: typescript
CODE:
const mydb = new SQLDatabase("mydb", {
   migrations: "./migrations",
});

export const getUser = api(
  { expose: true, method: "GET", path: "/names/:id" },
  async ({id}: {id:number}): Promise<{ id: number; name: string }> => {
    return await mydb.queryRow`SELECT * FROM users WHERE id = ${id}` as { id: number; name: string };
  }
);

----------------------------------------

TITLE: Generated API Request and Response Types
DESCRIPTION: Encore-generated types for handling the API request and response for the Foo endpoint. The request type wraps the Recursive payload and the response type is defined as an alias to *Recursive.

LANGUAGE: go
CODE:
type EncoreInternal_FooReq struct {
	Payload *Recursive
}

type EncoreInternal_FooResp = *Recursive

----------------------------------------

TITLE: Configuring PubSub Topic and Invalid Subscription in Service 1
DESCRIPTION: Setup of a PubSub topic and an invalid subscription that references a handler function from another service, which violates Encore's requirements.

LANGUAGE: go
CODE:
package svc1

import (
    "context"

    "encore.dev/pubsub"

    "test/shared"
    "test/svc2"
)

var BasicTopic = pubsub.NewTopic[*shared.MessageType]("basic-topic", pubsub.TopicConfig{ DeliveryGuarantee: pubsub.AtLeastOnce })

var _ = pubsub.NewSubscription(BasicTopic, "basic-subscription", pubsub.SusbcriptionConfig { Handler: svc2.Subscriber })

// encore:api
func Stuff(ctx context.Context) error {
    return nil
}

----------------------------------------

TITLE: Invalid PubSub Topic Declaration in Function Scope in Go
DESCRIPTION: This example demonstrates an incorrect way to declare a PubSub topic in Encore by attempting to create it inside a function. The error occurs because Encore requires PubSub topics to be declared at package level variables, not within function scope.

LANGUAGE: go
CODE:
package svc

import (
    "context"

    "encore.dev/pubsub"
)

type MyMessage struct {}

//encore:api
func SomeAPI(ctx context.Context) error {
    topic := pubsub.NewTopic[MyMessage]("basic-topic")
    topic.Publish(ctx, &MyMessage{})
}

----------------------------------------

TITLE: Creating SQL Migration Script in Encore Application
DESCRIPTION: An empty SQL migration file for database schema changes. Migration files in Encore follow a naming convention with sequence numbers and up/down indicators.

LANGUAGE: sql
CODE:
-- svc/migrations/1_foo.up.sql --

----------------------------------------

TITLE: Re-exporting Module in TypeScript
DESCRIPTION: Re-exports the 'foo' module from a relative path './foo'. This pattern allows for organizing exports through barrel files.

LANGUAGE: typescript
CODE:
export { foo } from "./foo";

----------------------------------------

TITLE: Implementing Authentication Handler in Encore Application
DESCRIPTION: Defines a basic authentication handler function using Encore's auth system. The handler validates a token and returns a user ID or an error.

LANGUAGE: go
CODE:
//encore:authhandler
func MyAuthHandler(ctx context.Context, token string) (auth.UID, error) {
    return "", nil
}

----------------------------------------

TITLE: Defining Service D Configuration in Go
DESCRIPTION: Defines a service configuration struct with a string field and loads it using Encore's config package. The Foo field has an additional comment.

LANGUAGE: go
CODE:
package svc

import (
	"context"

	"encore.dev/config"
)

type DsConfig struct{
    Foo config.String // Some extra comment
}

var _ = config.Load[DsConfig]()

----------------------------------------

TITLE: Generated API Registration and Handler Setup
DESCRIPTION: Encore internal generated code for API registration and request handling. Includes endpoint descriptors, request/response types, and HTTP handling logic for the defined API endpoints.

LANGUAGE: go
CODE:
package code

import (
	__api "encore.dev/appruntime/apisdk/api"
	errs "encore.dev/beta/errs"
	jsoniter "github.com/json-iterator/go"
	"net/http"
	"net/url"
)

func init() {
	__api.RegisterEndpoint(EncoreInternal_api_APIDesc_Foo, Foo)
	__api.RegisterEndpoint(EncoreInternal_api_APIDesc_Bar, Bar)
}

type EncoreInternal_FooReq struct{}

type EncoreInternal_FooResp = __api.Void

var EncoreInternal_api_APIDesc_Foo = &__api.Desc[*EncoreInternal_FooReq, EncoreInternal_FooResp]{
	Access:     __api.Public,
	AppHandler: nil,
	CloneReq: func(r *EncoreInternal_FooReq) (*EncoreInternal_FooReq, error) {
		var clone *EncoreInternal_FooReq
		bytes, err := jsoniter.ConfigDefault.Marshal(r)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return clone, err
	},
	CloneResp: func(r EncoreInternal_FooResp) (EncoreInternal_FooResp, error) {
		var clone EncoreInternal_FooResp
		bytes, err := jsoniter.ConfigDefault.Marshal(r)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return clone, err
	},
	DecodeExternalResp: nil,
	DecodeReq: func(httpReq *http.Request, ps __api.UnnamedParams, json jsoniter.API) (reqData *EncoreInternal_FooReq, pathParams __api.UnnamedParams, err error) {
		reqData = new(EncoreInternal_FooReq)
		return reqData, nil, nil
	},
	DefLoc: uint32(0x0),
	EncodeExternalReq: func(reqData *EncoreInternal_FooReq, stream *jsoniter.Stream) (httpHeader http.Header, queryString url.Values, err error) {
		return nil, nil, nil
	},
	EncodeResp:          nil,
	Endpoint:            "Foo",
	Fallback:            false,
	GlobalMiddlewareIDs: []string{},
	Methods:             []string{"GET", "HEAD", "POST", "PUT", "DELETE", "CONNECT", "OPTIONS", "TRACE", "PATCH"},
	Path:                "/code.Foo",
	PathParamNames:      nil,
	Raw:                 true,
	RawHandler: func(w http.ResponseWriter, req *http.Request) {
		Foo(w, req)
	},
	RawPath: "/code.Foo",
	ReqPath: func(reqData *EncoreInternal_FooReq) (string, __api.UnnamedParams, error) {
		return "/code.Foo", nil, nil
	},
	ReqUserPayload: func(reqData *EncoreInternal_FooReq) any {
		return nil
	},
	Service:           "code",
	ServiceMiddleware: []*__api.Middleware{},
	SvcNum:            1,
	Tags:              nil,
}

type EncoreInternal_BarReq struct{}

type EncoreInternal_BarResp = __api.Void

var EncoreInternal_api_APIDesc_Bar = &__api.Desc[*EncoreInternal_BarReq, EncoreInternal_BarResp]{
	Access:     __api.Public,
	AppHandler: nil,
	CloneReq: func(r *EncoreInternal_BarReq) (*EncoreInternal_BarReq, error) {
		var clone *EncoreInternal_BarReq
		bytes, err := jsoniter.ConfigDefault.Marshal(r)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return clone, err
	},
	CloneResp: func(r EncoreInternal_BarResp) (EncoreInternal_BarResp, error) {
		var clone EncoreInternal_BarResp
		bytes, err := jsoniter.ConfigDefault.Marshal(r)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return clone, err
	},
	DecodeExternalResp: nil,
	DecodeReq: func(httpReq *http.Request, ps __api.UnnamedParams, json jsoniter.API) (reqData *EncoreInternal_BarReq, pathParams __api.UnnamedParams, err error) {
		reqData = new(EncoreInternal_BarReq)
		return reqData, nil, nil
	},
	DefLoc: uint32(0x0),
	EncodeExternalReq: func(reqData *EncoreInternal_BarReq, stream *jsoniter.Stream) (httpHeader http.Header, queryString url.Values, err error) {
		return nil, nil, nil
	},
	EncodeResp:          nil,
	Endpoint:            "Bar",
	Fallback:            false,
	GlobalMiddlewareIDs: []string{},
	Methods:             []string{"GET", "HEAD", "POST", "PUT", "DELETE", "CONNECT", "OPTIONS", "TRACE", "PATCH"},
	Path:                "/code.Bar",
	PathParamNames:      nil,
	Raw:                 true,
	RawHandler: func(w http.ResponseWriter, req *http.Request) {
		svc, initErr := EncoreInternal_svcstruct_Service.Get()
		if initErr != nil {
			errs.HTTPErrorWithCode(w, initErr, 0)
			return
		}
		svc.Bar(w, req)
	},
	RawPath: "/code.Bar",
	ReqPath: func(reqData *EncoreInternal_BarReq) (string, __api.UnnamedParams, error) {
		return "/code.Bar", nil, nil
	},
	ReqUserPayload: func(reqData *EncoreInternal_BarReq) any {
		return nil
	},
	Service:           "code",
	ServiceMiddleware: []*__api.Middleware{},
	SvcNum:            1,
	Tags:              nil,
}

----------------------------------------

TITLE: Defining Configuration Structure with API Endpoint in Service A
DESCRIPTION: Defines an AsConfig structure with a string configuration field and exposes an API endpoint through Encore. The API function takes a context and returns an error.

LANGUAGE: go
CODE:
package svc

import (
	"context"

	"encore.dev/config"
)

type AsConfig struct {
    // Multiline test
    // comment to deduplicate.
    Foo config.String
}

var _ = config.Load[*AsConfig]()

//encore:api
func MyAPI(ctx context.Context) (error) {
	return nil
}

----------------------------------------

TITLE: Defining an Invalid Auth Handler in Encore with Integer Parameter
DESCRIPTION: This code snippet shows an incorrect implementation of an Encore auth handler. The function is marked with the `//encore:authhandler` annotation but uses an integer as the second parameter, which violates the requirement for a string or pointer to a named struct.

LANGUAGE: go
CODE:
package svc

import (
    "context"
    "encore.dev/beta/auth"
)

//encore:authhandler
func MyAuth(ctx context.Context, p int) (auth.UID, error) { return "", nil }

----------------------------------------

TITLE: Defining Header Parameters with Go Struct Tags in Encore
DESCRIPTION: Defines a Params struct with fields that are extracted from HTTP headers using the `header` struct tag. The `-` value in the tag means the field should be ignored for header extraction.

LANGUAGE: go
CODE:
package code

import "context"

type Params struct {
    Foo   string `header:"X-Foo"`
    Ignore string `header:"-"`
    Strings []string `header:"X-Strings"`
}

//encore:api public
func Foo(ctx context.Context, p *Params) error { return nil }

----------------------------------------

TITLE: Defining a Public API Endpoint with a Tag in Encore
DESCRIPTION: Defines a public API endpoint with the 'foo' tag in Encore. This tag allows the endpoint to be targeted by middleware functions.

LANGUAGE: go
CODE:
//encore:api public tag:foo
func API(ctx context.Context) error { return nil }

----------------------------------------

TITLE: Defining Public API with Tag in Encore
DESCRIPTION: Defines a public API endpoint in an Encore service with the 'bar' tag. The endpoint doesn't perform any operations and simply returns nil.

LANGUAGE: go
CODE:
//encore:api public tag:bar
func API(ctx context.Context) error { return nil }

----------------------------------------

TITLE: Defining API Interfaces and Endpoints with Encore Framework in TypeScript
DESCRIPTION: Defines a TypeScript interface for API parameters with various Query and Header type configurations, then exports three API endpoints with different parameter arrangements. The interface demonstrates the use of generic types to specify parameter types and names.

LANGUAGE: typescript
CODE:
import { api, Query, Header } from "encore.dev/api";

interface Params {
    q1: Query;
    q2: Query<boolean>;
    q3: Query<"my-query">;
    q4: Query<boolean, "my-query">;

    h1: Header;
    h2: Header<boolean>;
    h3: Header<"my-header">;
    h4: Header<boolean, "my-header">;
};

export const t1 = api<Params, void>({}, () => {});
export const t2 = api<void, Params>({}, () => {});
export const t3 = api<Params, Params>({}, () => {});

----------------------------------------

TITLE: Defining Service Configuration Structure in Go using Encore Framework
DESCRIPTION: Defines a Config struct with HTTP server configuration options including enabled status and port. Uses the config.Load function to load configuration from environment or other sources.

LANGUAGE: go
CODE:
type Config struct {
    // The options for the HTTP server
    HTTP struct {
        Enabled bool // Is this option enabled?
        Port    uint32 // What port should we run on?
    }
}

var _ = config.Load[*Config]()

----------------------------------------

TITLE: Defining Recursive and Generic Types in Go with Encore
DESCRIPTION: This snippet defines various recursive and generic type structures in Go, including self-recursive, mutually recursive, and generic types. It also includes a simple Encore API endpoint that accepts these complex types as parameters.

LANGUAGE: go
CODE:
package foo

import "context"

// We must reference these types in an RPC parameter to actually validate them.
type Params struct {
    A *SelfRecursive
    B *MutuallyRecursive
    C *Generic[Generic[MutuallyRecursive]]
}

//encore:api public
func Dummy(ctx context.Context, p *Params) error {
    return nil
}

type SelfRecursive struct {
    A *SelfRecursive
}

type MutuallyRecursive struct {
    Other *Other
}

type Other struct {
    Original *MutuallyRecursive
}

type Generic[T any] struct {
    Val *T
}

----------------------------------------

TITLE: Defining Service B Configuration in Go
DESCRIPTION: Defines a service configuration struct with a string field and loads it using Encore's config package. The Foo field has an additional comment.

LANGUAGE: go
CODE:
package svc

import (
	"context"

	"encore.dev/config"
)

type BsConfig struct{
    Foo config.String // Some extra comment
}

var _ = config.Load[BsConfig]()

----------------------------------------

TITLE: Auto-generated Interface for Service API in Encore
DESCRIPTION: An auto-generated code by Encore that defines an interface for the service API. This interface is primarily used for mocking purposes during testing and is automatically updated when API endpoints change.

LANGUAGE: go
CODE:
// Code generated by encore. DO NOT EDIT.

package code

import "context"

// These functions are automatically generated and maintained by Encore
// to simplify calling them from other services, as they were implemented as methods.
// They are automatically updated by Encore whenever your API endpoints change.

// Interface defines the service's API surface area, primarily for mocking purposes.
//
// Raw endpoints are currently excluded from this interface, as Encore does not yet
// support service-to-service API calls to raw endpoints.
type Interface interface {
	Tagged(ctx context.Context) error
}

----------------------------------------

TITLE: Creating a Required API Endpoint for Encore Configuration
DESCRIPTION: Defines a simple API endpoint required by the Encore framework to use config.Load. The endpoint is marked with an encore annotation to make it publicly accessible.

LANGUAGE: go
CODE:
//encore:api public
func Dummy(context.Context) error { return nil }

----------------------------------------

TITLE: Auto-generated Config Unmarshalers for Encore
DESCRIPTION: Automatically generated functions for unmarshaling config values into the correct Go types. Includes functions to handle null values and JSON object parsing, created specifically for the Config struct defined in the service.

LANGUAGE: go
CODE:
package svc

import jsoniter "github.com/json-iterator/go"

/*
These functions are automatically generated and maintained by Encore to allow config values
to be unmarshalled into the correct types. They are not intended to be used directly. They
are automatically updated by Encore whenever you change the data types used within your
calls to config.Load[T]().
*/

// Concrete unmarshalers for all config.Load calls, including those using generic types.
// These instances are used directly by calls to `config.Load[T]()`.
var (
	encoreInternalConfigUnmarshaler_ptr_svc_Config = func(itr *jsoniter.Iterator, path []string) *Config {
		return func() *Config {
			// If the value is null, we return nil
			if itr.ReadNil() {
				return nil
			}

			// Otherwise we unmarshal the value and return a pointer to it
			obj := encoreInternalTypeConfigUnmarshaler_svc_Config(itr, append(path))
			return &obj
		}()
	}
)

// encoreInternalTypeConfigUnmarshaler_svc_Config will unmarshal the JSON representation into the given type, taking account for
// the `config.Value` dynamic functions.
func encoreInternalTypeConfigUnmarshaler_svc_Config(itr *jsoniter.Iterator, path []string) (obj Config) {
	itr.ReadObjectCB(func(itr *jsoniter.Iterator, field string) bool {
		switch field {
		case "A":
			obj.A = itr.ReadInt()
		case "B":
			obj.B = itr.ReadInt()
		case "C":
			obj.C = itr.ReadInt()
		default:
			itr.Skip()
		}
		return true
	})
	return
}

----------------------------------------

TITLE: Creating a Cache Cluster with Valid Configuration in Go
DESCRIPTION: Initializes a new cache cluster named 'foo' with the AllKeysLRU eviction policy. This is a valid configuration that will be properly resolved by Encore.

LANGUAGE: go
CODE:
var a = cache.NewCluster( // res CacheCluster: {"Name": "foo", "EvictionPolicy": "allkeys-lru"}
    "foo", cache.ClusterConfig{
        EvictionPolicy: cache.AllKeysLRU,
    },
)

----------------------------------------

TITLE: Encore Infrastructure Configuration for Railway Database
DESCRIPTION: JSON configuration file for Encore infrastructure that defines the SQL server connection details for the Railway PostgreSQL database, including host, TLS configuration, and credentials.

LANGUAGE: json
CODE:
{
   "$schema": "https://encore.dev/schemas/infra.schema.json",
   "sql_servers": [
   {
      "host": "<hostname>.rlwy.net:39684",
      "tls_config": {
         "disable_ca_validation": true
      },
      "databases": {
         "mydb": {
            "name": "railway",
            "username": "postgres",
            "password": {"$env": "DB_PASSWORD"}
          }
      }
   }]   
}

----------------------------------------

TITLE: Encore API Endpoint Registration and Implementation
DESCRIPTION: Auto-generated code that registers and implements the API endpoint. It includes request/response handling, parameter parsing, and JSON serialization/deserialization.

LANGUAGE: go
CODE:
package code

import (
	"context"
	__api "encore.dev/appruntime/apisdk/api"
	jsoniter "github.com/json-iterator/go"
	"net/http"
	"net/url"
)

func init() {
	__api.RegisterEndpoint(EncoreInternal_api_APIDesc_Foo, Foo)
}

type EncoreInternal_FooReq struct{}

type EncoreInternal_FooResp = __api.Void

var EncoreInternal_api_APIDesc_Foo = &__api.Desc[*EncoreInternal_FooReq, EncoreInternal_FooResp]{
	Access: __api.Private,
	AppHandler: func(ctx context.Context, reqData *EncoreInternal_FooReq) (EncoreInternal_FooResp, error) {
		err := Foo(ctx)
		if err != nil {
			return __api.Void{}, err
		}
		return __api.Void{}, nil
	},
	CloneReq: func(r *EncoreInternal_FooReq) (*EncoreInternal_FooReq, error) {
		var clone *EncoreInternal_FooReq
		bytes, err := jsoniter.ConfigDefault.Marshal(r)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return clone, err
	},
	CloneResp: func(r EncoreInternal_FooResp) (EncoreInternal_FooResp, error) {
		var clone EncoreInternal_FooResp
		bytes, err := jsoniter.ConfigDefault.Marshal(r)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return clone, err
	},
	DecodeExternalResp: func(httpResp *http.Response, json jsoniter.API) (resp EncoreInternal_FooResp, err error) {
		return __api.Void{}, nil
	},
	DecodeReq: func(httpReq *http.Request, ps __api.UnnamedParams, json jsoniter.API) (reqData *EncoreInternal_FooReq, pathParams __api.UnnamedParams, err error) {
		reqData = new(EncoreInternal_FooReq)
		return reqData, nil, nil
	},
	DefLoc: uint32(0x0),
	EncodeExternalReq: func(reqData *EncoreInternal_FooReq, stream *jsoniter.Stream) (httpHeader http.Header, queryString url.Values, err error) {
		return nil, nil, nil
	},
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, resp EncoreInternal_FooResp) (err error) {
		return nil
	},
	Endpoint:            "Foo",
	Fallback:            false,
	GlobalMiddlewareIDs: []string{},
	Methods:             []string{"GET", "POST"},
	Path:                "/code.Foo",
	PathParamNames:      nil,
	Raw:                 false,
	RawHandler:          nil,
	RawPath:             "/code.Foo",
	ReqPath: func(reqData *EncoreInternal_FooReq) (string, __api.UnnamedParams, error) {
		return "/code.Foo", nil, nil
	},
	ReqUserPayload: func(reqData *EncoreInternal_FooReq) any {
		return nil
	},
	Service:           "code",
	ServiceMiddleware: []*__api.Middleware{},
	SvcNum:            1,
	Tags:              nil,
}

----------------------------------------

TITLE: Auto-generated Config Unmarshalers for Encore
DESCRIPTION: Automatically generated functions for unmarshaling config values into the correct Go types. Includes functions to handle null values and JSON object parsing, created specifically for the Config struct defined in the service.

LANGUAGE: go
CODE:
package svc

import jsoniter "github.com/json-iterator/go"

/*
These functions are automatically generated and maintained by Encore to allow config values
to be unmarshalled into the correct types. They are not intended to be used directly. They
are automatically updated by Encore whenever you change the data types used within your
calls to config.Load[T]().
*/

// Concrete unmarshalers for all config.Load calls, including those using generic types.
// These instances are used directly by calls to `config.Load[T]()`.
var (
	encoreInternalConfigUnmarshaler_ptr_svc_Config = func(itr *jsoniter.Iterator, path []string) *Config {
		return func() *Config {
			// If the value is null, we return nil
			if itr.ReadNil() {
				return nil
			}

			// Otherwise we unmarshal the value and return a pointer to it
			obj := encoreInternalTypeConfigUnmarshaler_svc_Config(itr, append(path))
			return &obj
		}()
	}
)

// encoreInternalTypeConfigUnmarshaler_svc_Config will unmarshal the JSON representation into the given type, taking account for
// the `config.Value` dynamic functions.
func encoreInternalTypeConfigUnmarshaler_svc_Config(itr *jsoniter.Iterator, path []string) (obj Config) {
	itr.ReadObjectCB(func(itr *jsoniter.Iterator, field string) bool {
		switch field {
		case "A":
			obj.A = itr.ReadInt()
		case "B":
			obj.B = itr.ReadInt()
		case "C":
			obj.C = itr.ReadInt()
		default:
			itr.Skip()
		}
		return true
	})
	return
}

----------------------------------------

TITLE: Expected Validation Errors for Incorrect Cron Job Usage
DESCRIPTION: This snippet shows the expected error messages when validating the incorrectly placed cron job. It highlights two issues: the cron job must be defined at package level, and APIs cannot be referenced without being called unless used as endpoints.

LANGUAGE: text
CODE:
── Invalid call ───────────────────────────────────────────────────────────────────────────[E9999]──

cron.NewJob cannot be called here. It must be called from a package level variable.

    ╭─[ svc/svc.go:12:13 ]
    │
 10 │     // A cron job to send out emails to newsletter subscribers.
 11 │     // On two lines.
 12 │     var _ = cron.NewJob("cronfoo", cron.JobConfig{
    ⋮             ───────────
 13 │         Title:    "Cron Foo Bar",
 14 │         Schedule: "* * * * 5",
────╯




── Invalid API Usage ──────────────────────────────────────────────────────────────────────[E9999]──

APIs can not be referenced without being called, unless they are used as a cron job endpoint, or a
PubSub subscription handler.

    ╭─[ svc/svc.go:15:19 ]
    │
 13 │         Title:    "Cron Foo Bar",
 14 │         Schedule: "* * * * 5",
 15 │         Endpoint: Cron,
    ⋮                   ─┬──
    ⋮                    ╰─ used here
    ·
    ·
 18 │
 19 │ //encore:api public path=/cron
 20 │ func Cron(ctx context.Context) (*Response, error) {
    ⋮      ─┬──
    ⋮       ╰─ defined here
 21 │     msg := "Hello, Cron!"
 22 │     return &Response{Message: msg}, nil
────╯

For more information on how to use APIs see https://encore.dev/docs/primitives/apis

----------------------------------------

TITLE: Encore Project Package Configuration
DESCRIPTION: Configures an Encore project as an ES module with a dependency on the encore.dev framework. Specifies the package name as 'foo' and requires version 1.35.0 or higher of the encore.dev dependency.

LANGUAGE: json
CODE:
{
  "name": "foo",
  "type": "module",
  "dependencies": {
    "encore.dev": "^1.35.0"
  }
}

----------------------------------------

TITLE: Incorrectly Implementing Cron Job in Encore Go Service
DESCRIPTION: This snippet shows an API endpoint that incorrectly attempts to define a cron job within the function body instead of at package level. It creates a job named 'cronfoo' that's scheduled to run every Friday and calls the Cron endpoint.

LANGUAGE: go
CODE:
package svc

import (
	"context"

	"encore.dev/cron"
)

//encore:api public path=/cron
func Cron(ctx context.Context) (*Response, error) {
	msg := "Hello, Cron!"
    // A cron job to send out emails to newsletter subscribers.
    // On two lines.
    var _ = cron.NewJob("cronfoo", cron.JobConfig{
        Title:    "Cron Foo Bar",
        Schedule: "* * * * 5",
        Endpoint: Cron,
    })
	return &Response{Message: msg}, nil
}

type Response struct {
	Message string
}

----------------------------------------

TITLE: Implementing a PubSub Handler Function in a Separate Service
DESCRIPTION: Implements a PubSub message handler function in a separate service (svc2). This function is intended to process messages from the topic defined in svc1, but Encore requires handlers to be in the same service as the subscription.

LANGUAGE: go
CODE:
package svc2

import (
    "context"

    "test/shared"
)

//encore:api
func Subscriber(ctx context.Context, msg *shared.MessageType) error {
    return nil
}

----------------------------------------

TITLE: Defining Service A Configuration with API Endpoint in Go
DESCRIPTION: Defines a service configuration struct with a string field and loads it using Encore's config package. Also defines a simple API endpoint using the encore:api annotation.

LANGUAGE: go
CODE:
package svc

import (
	"context"

	"encore.dev/config"
	"encore.dev/types/uuid"
)

type AsConfig struct {
    // Multiline test
    // comment to deduplicate.
    Foo config.String
}

var _ = config.Load[*AsConfig]()

//encore:api
func MyAPI(ctx context.Context) (error) {
	return nil
}

----------------------------------------

TITLE: Implementing a basic Encore API endpoint with custom types in Go
DESCRIPTION: Defines custom types including non-comparable structs and a public API endpoint. The implementation uses encore annotations to define the API visibility, with a simple endpoint that accepts a context and parameters.

LANGUAGE: go
CODE:
package basic

import "context"

type NotComparable struct{
    Foo []string
}

type NamedNotComparable NotComparable

type Int int

type Params struct {
    X NotComparable `json:"x,omitempty"`
    Integer Int `json:"int,omitempty"`
}

//encore:api public
func Foo(ctx context.Context, p *Params) error { return nil }

----------------------------------------

TITLE: Loading Configuration in Encore with Type Safety
DESCRIPTION: Demonstrates loading a typed configuration using Encore's config.Load function. The configuration is loaded as a pointer to CfgType instantiated with uint as the type parameter, allowing for compile-time type checking.

LANGUAGE: go
CODE:
var cfg = config.Load[*CfgType[uint]]()

----------------------------------------

TITLE: Defining a Simple API Endpoint with Encore
DESCRIPTION: Creates a simple API endpoint using Encore's API directive. The function accepts a context parameter and returns an error type, with a nil return for successful execution.

LANGUAGE: go
CODE:
//encore:api
func MyAPI(ctx context.Context) (error) {
	return nil
}

----------------------------------------

TITLE: Basic Go Hello World Application
DESCRIPTION: A simple Go application that prints "Hello, world!" to the console.

LANGUAGE: go
CODE:
package main
func main() {
    println("Hello, world!")
}

----------------------------------------

TITLE: Modified Cross-Service Implementation with API Call Wrappers
DESCRIPTION: The modified implementation of svcb showing how Encore replaces direct cross-service function calls with API call wrappers.

LANGUAGE: go
CODE:
package svcb

import ("context"; "example.com/svca")

//encore:api public
func Baz(ctx context.Context) error { return svca.EncoreInternal_apicalls_Foo(ctx) }

----------------------------------------

TITLE: Defining a Simple API Endpoint with Encore
DESCRIPTION: Creates a simple API endpoint using Encore's API directive. The function accepts a context parameter and returns an error type, with a nil return for successful execution.

LANGUAGE: go
CODE:
//encore:api
func MyAPI(ctx context.Context) (error) {
	return nil
}

----------------------------------------

TITLE: Defining Conflicting Cache Keyspaces in Encore Application
DESCRIPTION: This snippet creates a cache cluster and attempts to define two keyspaces with conflicting patterns. The conflict occurs between 'foo/:Foo' and 'foo/bar/:Foo' patterns, which is not allowed in Encore because 'bar' conflicts with the parameterized ':Foo' segment.

LANGUAGE: go
CODE:
package svc

import (
    "context"

    "encore.dev/storage/cache"
)

type Key[T any] struct {
    Foo T
}

var cluster = cache.NewCluster("cluster", cache.ClusterConfig{})

var keyspace1 = cache.NewStringKeyspace[Key[string]](cluster, cache.KeyspaceConfig{
    KeyPattern: "foo/:Foo",
})

var keyspace2 = cache.NewStringKeyspace[Key[string]](cluster, cache.KeyspaceConfig{
    KeyPattern: "foo/bar/:Foo",
})

//encore:api public
func Foo(ctx context.Context) error { return nil }

----------------------------------------

TITLE: Using Dynamic Encore AppID Notation in Templates
DESCRIPTION: When creating templates, use the {{ENCORE_APP_ID}} notation instead of hardcoding an AppID. This placeholder will be dynamically replaced with the user's unique AppID when they create an app from the template.

LANGUAGE: go
CODE:
{{ENCORE_APP_ID}}

----------------------------------------

TITLE: Using Txtar in Rust to Create and Materialize Archives
DESCRIPTION: Example of parsing a txtar string into an archive and then materializing it to the filesystem. The example demonstrates creating an archive with comments and multiple files, including nested directories and empty files.

LANGUAGE: rust
CODE:
let txt = "\
comment1
comment2
-- file1 --
File 1 text.
-- foo/bar --
File 2 text.
-- empty --
-- noNL --
hello world";

let archive = txtar::from_str(txt);
archive.materialize("/tmp/somedir/").unwrap();

----------------------------------------

TITLE: Configuring a Subscription with Inline Handler
DESCRIPTION: Creates a subscription in the foo package with an inline handler function and complex time configurations for retry policies. The subscription is configured with specific ack deadline, message retention, and retry policy parameters.

LANGUAGE: go
CODE:
var _ = pubsub.NewSubscription(
    shared.BasicTopic,
    "a-third-subscription",
    pubsub.SubscriptionConfig {
        Handler: func(ctx context.Context, msg *shared.MessageType) error {
          return nil
      },
      AckDeadline: 1 * time.Second,
      MessageRetention: 2 * time.Minute + -1 * time.Microsecond,
      RetryPolicy: &pubsub.RetryPolicy{
          MaxRetries: -3 + 10 * 5,
          MinBackoff: 4 * time.Hour + -2 * time.Microsecond,
          MaxBackoff: 5 * time.Hour + -3 * time.Microsecond,
      },
    },
)

----------------------------------------

TITLE: Defining a Parameterized Configuration Struct in Go
DESCRIPTION: Creates a generic Config struct with a type parameter T constrained to int types. The struct contains a Value field tagged with JSON metadata for serialization.

LANGUAGE: Go
CODE:
type Config[T int] struct {
    Value T `json:"value,omitempty"` // Some config
}

----------------------------------------

TITLE: Defining a Public Raw API Endpoint in Go
DESCRIPTION: Defines a public API endpoint that uses raw HTTP handling in an Encore service. The function takes direct control of the HTTP request and response objects, allowing for manual HTTP processing instead of using Encore's standard request/response marshaling.

LANGUAGE: go
CODE:
package svc

import "net/http"

//encore:api public raw
func API(w http.ResponseWriter, req *http.Request) { }

----------------------------------------

TITLE: Generated Service Registration for Encore in Go
DESCRIPTION: Auto-generated code that registers the service with Encore's runtime system. Handles service initialization and provides access to the service instance through a global variable, ensuring proper service lifecycle management.

LANGUAGE: go
CODE:
package basic

import __service "encore.dev/appruntime/apisdk/service"

func init() {
	__service.Register(EncoreInternal_svcstruct_Service)
}

var EncoreInternal_svcstruct_Service = &__service.Decl[Service]{
	Name:        "Service",
	Service:     "basic",
	Setup:       nil,
	SetupDefLoc: uint32(0x0),
}

----------------------------------------

TITLE: Go Module Definition
DESCRIPTION: A go.mod file that defines the module name as 'example.com'.

LANGUAGE: go
CODE:
module example.com

----------------------------------------

TITLE: Initializing an Encore Application from Existing Repository
DESCRIPTION: Creates a new Encore application from an existing code repository with the specified name.

LANGUAGE: shell
CODE:
$ encore app init [name]

----------------------------------------

TITLE: Incorrectly Referencing an API Endpoint Without Calling It
DESCRIPTION: Shows an incorrect usage pattern where an API endpoint is assigned to a variable but not called directly, which violates Encore's API usage rules.

LANGUAGE: go
CODE:
package two

import (
    "context"

    "test/one"
)

//encore:api public
func Foo(ctx context.Context) error {
    f := one.One
    f()
    return nil
}

----------------------------------------

TITLE: Enhanced Configuration Loading with Unmarshalers
DESCRIPTION: Modified version of the config.Load call that includes service name and the reference to the generated unmarshaler function. This is the enhanced code that would be used at runtime.

LANGUAGE: go
CODE:
var _ = config.Load[*Config]("svc", encoreInternalConfigUnmarshaler_ptr_svc_Config/*line :26:30*/)

----------------------------------------

TITLE: Defining Invalid Cache Key Type with Nested Generics in Encore
DESCRIPTION: This code demonstrates an error case in Encore's cache system where a generic struct is used as a key type with a nested generic parameter. Encore requires cache key fields to be basic types, not complex structures or nested generics.

LANGUAGE: go
CODE:
package svc

import (
    "context"

    "encore.dev/storage/cache"
)

var cluster = cache.NewCluster("cluster", cache.ClusterConfig{})

type Key[T any] struct {
    Foo T
}

var keyspace = cache.NewStringKeyspace[Key[Key[string]]](cluster, cache.KeyspaceConfig{
    KeyPattern: "foo/:Foo",
})

//encore:api public
func Foo(context.Context) error {
    return nil
}

----------------------------------------

TITLE: Generating API Clients for Specific Services
DESCRIPTION: Example of generating a TypeScript client for specific services within an Encore application. Shows how to use the --services flag to filter which services to include in the generated client.

LANGUAGE: shell
CODE:
encore gen client --services=email,users -o client.ts

----------------------------------------

TITLE: Archiving Encore Secrets
DESCRIPTION: Archives a secret value with the specified ID.

LANGUAGE: shell
CODE:
$ encore secret archive <id>

----------------------------------------

TITLE: Defining Service Structure and API in Encore (svca)
DESCRIPTION: This snippet defines the basic structure of an Encore service with a public API endpoint. It uses service annotations to mark the struct as an Encore service and designate the method as a public API endpoint.

LANGUAGE: go
CODE:
package svca

import "context"

//encore:service
type Service struct{}

//encore:api public
func (s *Service) Foo(context.Context) error { return nil }

----------------------------------------

TITLE: Incorrectly Defined Non-Global Middleware Outside Service Package
DESCRIPTION: This middleware function causes an error because it's defined outside a service package but is not marked as global. Middleware must be either defined within a service package or explicitly marked as global.

LANGUAGE: go
CODE:
//encore:middleware target=all
func AllInSvc(req middleware.Request, next middleware.Next) middleware.Response {
    return next(req)
}

----------------------------------------

TITLE: Defining Encore Service Package with Imports
DESCRIPTION: Defines the package and imports necessary dependencies for an Encore service, including context, time, configuration, and UUID utilities.

LANGUAGE: go
CODE:
package svc

import (
	"context"
    "time"

	"encore.dev/config"
	"encore.dev/types/uuid"
)

----------------------------------------

TITLE: Defining Encore API with Path Parameter Mismatch
DESCRIPTION: This code demonstrates an error case where the parameter name in the function ('bar') doesn't match the path parameter name in the API path (':foo'). In Encore, path parameters in the URL must have matching function parameters.

LANGUAGE: go
CODE:
package svc

import (
	"context"
	"encore.dev/types/uuid"
)

//encore:api public path=/str/:foo
func Str(ctx context.Context, bar string) error { return nil }

----------------------------------------

TITLE: Generated Encore Service Registration in Go
DESCRIPTION: Auto-generated code that registers the Service with Encore's runtime. It uses the internal service package to register the service structure, providing the service name, initialization function, and other metadata.

LANGUAGE: go
CODE:
package basic

import __service "encore.dev/appruntime/apisdk/service"

func init() {
	__service.Register(EncoreInternal_svcstruct_Service)
}

var EncoreInternal_svcstruct_Service = &__service.Decl[Service]{
	Name:        "Service",
	Service:     "basic",
	Setup:       initService,
	SetupDefLoc: uint32(0x0),
}

----------------------------------------

TITLE: Package.json Configuration for Encore Project
DESCRIPTION: Defines the package configuration for an Encore project, specifying module type and dependencies. Includes encore.dev library as a dependency.

LANGUAGE: json
CODE:
{
  "type": "module",
  "dependencies": {
    "encore.dev": "^1.35.0"
  }
}

----------------------------------------

TITLE: Creating and Using PostgreSQL Database with Encore in Go
DESCRIPTION: This code demonstrates how to define a PostgreSQL database using Encore's Go SDK. It shows the creation of a 'todo' database with a reference to migration files, which define the database schema. Encore automatically provisions and configures the database in both local and cloud environments.

LANGUAGE: go
CODE:
package todo

// Create the todo database and assign it to the "tododb" variable
var tododb = sqldb.NewDatabase("todo", sqldb.DatabaseConfig{
	Migrations: "./migrations",
})

// Then, query the database using db.QueryRow, db.Exec, etc.

LANGUAGE: sql
CODE:
CREATE TABLE todo_item (
  id BIGSERIAL PRIMARY KEY,
  title TEXT NOT NULL,
  done BOOLEAN NOT NULL DEFAULT false
  -- etc...
);

----------------------------------------

TITLE: Defining an Encore API Endpoint
DESCRIPTION: Defines a basic API endpoint function using Encore's API annotation. This function will be exposed as an HTTP endpoint by the Encore framework.

LANGUAGE: go
CODE:
//encore:api
func MyAPI(ctx context.Context) (error) {
	return nil
}

----------------------------------------

TITLE: Generated Encore Wrapper Functions for Service Methods in Go
DESCRIPTION: Auto-generated code that provides standalone functions for each service method to enable easier cross-service calls. Each function retrieves the service instance and delegates to the appropriate method, preserving the original API signatures and documentation.

LANGUAGE: go
CODE:
// Code generated by encore. DO NOT EDIT.

package basic

import (
	"context"
	"errors"
	"net/http"
)

// These functions are automatically generated and maintained by Encore
// to simplify calling them from other services, as they were implemented as methods.
// They are automatically updated by Encore whenever your API endpoints change.

// Foo is an amazing API which does
// x, y and z - it's really cool!
func Foo(ctx context.Context) error {
	svc, err := EncoreInternal_svcstruct_Service.Get()
	if err != nil {
		return err
	}
	return svc.Foo(ctx)
}

func Raw(ctx context.Context, req *http.Request) (*http.Response, error) {
	return nil, errors.New("encore: calling raw endpoints is not yet supported")
}

func WithReq(ctx context.Context, p *Data) error {
	svc, err := EncoreInternal_svcstruct_Service.Get()
	if err != nil {
		return err
	}
	return svc.WithReq(ctx, p)
}

func WithResp(ctx context.Context) (*Data, error) {
	svc, err := EncoreInternal_svcstruct_Service.Get()
	if err != nil {
		return (*Data)(nil), err
	}
	return svc.WithResp(ctx)
}

func WithReqResp(ctx context.Context, p *Data) (*Data, error) {
	svc, err := EncoreInternal_svcstruct_Service.Get()
	if err != nil {
		return (*Data)(nil), err
	}
	return svc.WithReqResp(ctx, p)
}

func WithPathParams(ctx context.Context, name string, age int, other string) error {
	svc, err := EncoreInternal_svcstruct_Service.Get()
	if err != nil {
		return err
	}
	return svc.WithPathParams(ctx, name, age, other)
}

func WithFallback(ctx context.Context, url string) error {
	svc, err := EncoreInternal_svcstruct_Service.Get()
	if err != nil {
		return err
	}
	return svc.WithFallback(ctx, url)
}

// Interface defines the service's API surface area, primarily for mocking purposes.
//
// Raw endpoints are currently excluded from this interface, as Encore does not yet
// support service-to-service API calls to raw endpoints.
type Interface interface {
	// Foo is an amazing API which does
	// x, y and z - it's really cool!
	Foo(ctx context.Context) error

	WithReq(ctx context.Context, p *Data) error

	WithResp(ctx context.Context) (*Data, error)

	WithReqResp(ctx context.Context, p *Data) (*Data, error)

	WithPathParams(ctx context.Context, name string, age int, other string) error

	WithFallback(ctx context.Context, url string) error

	// This API doesn't
	// exist on the service struct, but should still
	// appear
	//
	// on the service Interface
	NoServiceStruct(ctx context.Context) error
}

----------------------------------------

TITLE: Configuring Client Generation in package.json
DESCRIPTION: Example of adding a script to package.json to automate client generation for a TypeScript frontend. Creates a 'gen' script that generates a client for a staging environment.

LANGUAGE: json
CODE:
{
  "scripts": {
    // ...
    "gen": "encore gen client hello-a8bc --output=./client.ts --env=staging"
    // ...
  }
}

----------------------------------------

TITLE: Incorrect Usage of Service Resource from External Package (Go)
DESCRIPTION: Demonstrates the incorrect attempt to reference a SQL database resource from outside its service package. This will result in an Encore compilation error as infrastructure resources can only be referenced within their own service.

LANGUAGE: go
CODE:
package pkg

import (
    "context"
    "test/svc"
)

func Foo() {
    _ = svc.Moo.Query
}

----------------------------------------

TITLE: Querying Multiple Rows from SQL Database in Encore.ts
DESCRIPTION: Examples of querying multiple rows from a SQL database using the query method. Demonstrates basic querying and type-safe querying with specific return types.

LANGUAGE: TypeScript
CODE:
const allTodos = await db.query`SELECT * FROM todo_item`;
for await (const todo of allTodos) {
  // Process each todo
}

LANGUAGE: TypeScript
CODE:
const rows = await db.query<{ email: string; source_url: string; scraped_at: Date }>`
    SELECT email, source_url, created_at as scraped_at
    FROM scraped_emails
    ORDER BY created_at DESC
`;

// Fetch all rows and return them as an array
const emails = [];
for await (const row of rows) {
    emails.push(row);
}

return { emails };

----------------------------------------

TITLE: Defining Service Configuration with Encore
DESCRIPTION: Defines the configuration structures for server options in an Encore service. Includes a ServerOption struct for basic server configuration and a Config struct that applies these options to different server types (HTTP, TCP, GRPC) with optional fields marked using the cue tag.

LANGUAGE: go
CODE:
type ServerOption struct {
    Option   int64
    Disabled bool `cue:",opt"` // True if this is disabled
}

type Config struct {
    HTTP    ServerOption
    Another ServerOption
    TCP     ServerOption `cue:",opt"`
    GRPC    ServerOption `cue:",opt"`
}

----------------------------------------

TITLE: Creating Authenticated API Endpoint in Encore
DESCRIPTION: Implements a simple API endpoint that requires authentication. This function is marked with the encore:api directive with auth access control.

LANGUAGE: go
CODE:
//encore:api auth
func API(ctx context.Context) error { return nil }

----------------------------------------

TITLE: Defining PubSub Topic and Subscription in Encore
DESCRIPTION: Creates a PubSub topic named 'topic' with AtLeastOnce delivery guarantee and a subscription named 'subscription' with a minimal handler function. The handler accepts a context and an event parameter but currently returns nil without processing the event.

LANGUAGE: go
CODE:
package code

import "context"
import "encore.dev/pubsub"

type Event struct {}

var Topic = pubsub.NewTopic[*Event]("topic", pubsub.TopicConfig{
    DeliveryGuarantee: pubsub.AtLeastOnce,
})


var _ = pubsub.NewSubscription(Topic, "subscription",
    pubsub.SubscriptionConfig[*Event]{
        Handler: func(ctx context.Context, event *Event) error {
            return nil
        },
    },
)

----------------------------------------

TITLE: Testing Auth Data Override in Encore
DESCRIPTION: Tests the et.OverrideAuthInfo function to ensure it correctly overrides authentication data during testing. It verifies the initial state is nil and that auth data is properly set after overriding.

LANGUAGE: go
CODE:
func TestOverrideAuthInfo(t *testing.T) {
    curr, _ := auth.Data().(*AuthData)
    if curr != nil {
        t.Fatalf("got data %+v, want nil", curr)
    }

    et.OverrideAuthInfo("foo", &AuthData{"email"})

    curr = auth.Data().(*AuthData)
    if curr == nil || curr.Email != "email" {
        t.Fatalf("got data %+v, want %q", curr, &AuthData{"email"})
    }
}

----------------------------------------

TITLE: Building a Docker Image for Encore Application
DESCRIPTION: Command to build a Docker image for an Encore application, which can then be deployed to any container hosting service. Compiles the application and packages it into a Docker image.

LANGUAGE: shell
CODE:
$ encore build docker MY-IMAGE:TAG

----------------------------------------

TITLE: Implementing a Basic Encore Service with Pub/Sub Topic
DESCRIPTION: Defines a simple Encore service with a pub/sub topic for message publishing. It includes a message structure and configures the topic with at-least-once delivery guarantee. A dummy API endpoint is included as a placeholder.

LANGUAGE: go
CODE:
package svc

import (
    "context"
    "encore.dev/pubsub"
)

type Msg struct{Message string}

var Topic = pubsub.NewTopic[Msg]("topic", pubsub.TopicConfig{DeliveryGuarantee: pubsub.AtLeastOnce})

//encore:api
func Dummy(context.Context) error { return nil }

----------------------------------------

TITLE: Defining an Encore API Endpoint
DESCRIPTION: A simple API endpoint defined with Encore's API annotation. The function takes a context parameter and returns an error.

LANGUAGE: go
CODE:
//encore:api
func MyAPI(ctx context.Context) (error) {
	return nil
}

----------------------------------------

TITLE: Implementing a Public Encore API Endpoint for Data Input
DESCRIPTION: Defines the Foo API endpoint that accepts a SomeStruct pointer as input. This function is marked as a public API using the encore:api directive.

LANGUAGE: go
CODE:
//encore:api public
func Foo(ctx context.Context, p *SomeStruct) error {
    return nil
}

----------------------------------------

TITLE: Accepting Structured Auth Information in Go
DESCRIPTION: This example demonstrates how to accept complex authentication information from various sources in an HTTP request, including cookies, query parameters, and headers. It allows for flexible authentication schemes beyond just Bearer tokens.

LANGUAGE: go
CODE:
type MyAuthParams struct {
	// SessionCookie is set to the value of the "session" cookie.
	// If the cookie is not set it's nil.
	SessionCookie *http.Cookie `cookie:"session"`
	
	// ClientID is the unique id of the client, sourced from the URL query string.
	ClientID string `query:"client_id"`
	
	// Authorization is the raw value of the "Authorization" header
	// without any parsing.
	Authorization string `header:"Authorization"`
}

//encore:authhandler
func AuthHandler(ctx context.Context, p *MyAuthParams) (auth.UID, error) {
    // ...
}

----------------------------------------

TITLE: Testing Site API Endpoint with cURL
DESCRIPTION: A cURL command example to test the site.Add endpoint, demonstrating how to create a new site for monitoring.

LANGUAGE: shell
CODE:
$ curl -X POST 'http://localhost:4000/site' -d '{"url": "https://encore.dev"}'
{
  "id": 1,
  "url": "https://encore.dev"
}

----------------------------------------

TITLE: Running a Single Semgrep Rule in Go
DESCRIPTION: Command to run a specific semgrep rule against the codebase. The command specifies a path to a single rule file and targets the current directory for analysis.

LANGUAGE: bash
CODE:
$ semgrep -f path/to/semgrep-go/rule.yml .

----------------------------------------

TITLE: Loading Configuration in Encore
DESCRIPTION: This line loads the configuration defined in the Config struct using Encore's configuration loading system. The blank identifier is used to ensure the configuration is loaded even if not explicitly referenced elsewhere.

LANGUAGE: go
CODE:
var _ = config.Load[*Config]()

----------------------------------------

TITLE: Implementing Global Middleware with Pub/Sub Integration in Encore
DESCRIPTION: Creates a global middleware function that publishes a message to a predefined pub/sub topic before passing the request to the next handler. The middleware is applied to all endpoints in the application.

LANGUAGE: go
CODE:
package middleware

import (
	"time"

	"encore.dev/middleware"
	"encore.dev/pubsub"

	"test/svc"
)

//encore:middleware global target=all
func MiddlewareFunc(req middleware.Request, next middleware.Next) middleware.Response {
    svc.BasicTopic.Publish(req.Context(), &svc.MessageType{UserID: 1, Name: "bar"})

	return next(req)
}

----------------------------------------

TITLE: Generated Encore Service Interface
DESCRIPTION: Automatically generated code that defines the service interface for mocking purposes. The interface includes all API endpoints from the service, excluding raw endpoints that don't support service-to-service calls.

LANGUAGE: go
CODE:
// Code generated by encore. DO NOT EDIT.

package code

import "context"

// These functions are automatically generated and maintained by Encore
// to simplify calling them from other services, as they were implemented as methods.
// They are automatically updated by Encore whenever your API endpoints change.

// Interface defines the service's API surface area, primarily for mocking purposes.
//
// Raw endpoints are currently excluded from this interface, as Encore does not yet
// support service-to-service API calls to raw endpoints.
type Interface interface {
	Foo(ctx context.Context) error
}

----------------------------------------

TITLE: Testing Auth Data Reset Between Tests in Encore
DESCRIPTION: Verifies that authentication data is reset between test functions, ensuring test isolation. This test confirms that no auth data persists from the previous test.

LANGUAGE: go
CODE:
func TestOverrideAuthInfo_ResetBetweenTests(t *testing.T) {
    curr  := auth.Data()
    if curr != nil {
        t.Fatalf("got data %+v, want nil", curr)
    }
}

----------------------------------------

TITLE: Implementing Auth Handler in Encore
DESCRIPTION: Implements an authentication handler for the Encore framework that processes authentication tokens. This handler validates tokens and returns the associated user ID and authentication data.

LANGUAGE: go
CODE:
//encore:authhandler
func AuthHandler(ctx context.Context, token string) (auth.UID, *AuthData, error) {
    return "hello", &AuthData{Email: "hello@example.org"}, nil
}

----------------------------------------

TITLE: Auto-Generated Configuration Unmarshalers for Encore
DESCRIPTION: Generated code by Encore to unmarshal JSON configuration into the correct types. These functions are automatically maintained by Encore and handle the deserialization of configuration values.

LANGUAGE: go
CODE:
/*
These functions are automatically generated and maintained by Encore to allow config values
to be unmarshalled into the correct types. They are not intended to be used directly. They
are automatically updated by Encore whenever you change the data types used within your
calls to config.Load[T]().
*/

// Concrete unmarshalers for all config.Load calls, including those using generic types.
// These instances are used directly by calls to `config.Load[T]()`.
var (
	encoreInternalConfigUnmarshaler_ptr_svc_Config = func(itr *jsoniter.Iterator, path []string) *Config {
		return func() *Config {
			// If the value is null, we return nil
			if itr.ReadNil() {
				return nil
			}

			// Otherwise we unmarshal the value and return a pointer to it
			obj := encoreInternalTypeConfigUnmarshaler_svc_Config(itr, append(path))
			return &obj
		}()
	}
)

----------------------------------------

TITLE: Implementing Basic Encore API Endpoint
DESCRIPTION: A simple Encore service implementation with a basic API endpoint. The function Foo is marked with the encore:api annotation to expose it as an API endpoint. It accepts a context parameter and returns an error.

LANGUAGE: go
CODE:
package svc

import "context"

//encore:api
func Foo(ctx context.Context) error { return nil }

----------------------------------------

TITLE: Setting Auth0 Client Secret in Encore
DESCRIPTION: Shell commands to set the Auth0 client secret as an Encore secret for both production and development environments.

LANGUAGE: shell
CODE:
$ encore secret set --prod Auth0ClientSecret

LANGUAGE: shell
CODE:
$ encore secret set --dev Auth0ClientSecret

----------------------------------------

TITLE: Creating Empty SQL Migration File
DESCRIPTION: An empty SQL migration file that appears to be used for database initialization. The file is named '1_dummy.up.sql' which suggests it's the first migration to be run when updating the database.

LANGUAGE: sql
CODE:


----------------------------------------

TITLE: Defining a Pub/Sub Topic for Signup Events in Encore
DESCRIPTION: Implementation of a Pub/Sub topic for signup events with at-least-once delivery guarantee. The topic can be used to broadcast events to multiple subscribers asynchronously.

LANGUAGE: go
CODE:
type SignupEvent struct{ UserID int }

var Signups = pubsub.NewTopic[*SignupEvent]("signups", pubsub.TopicConfig{
    DeliveryGuarantee: pubsub.AtLeastOnce,
})

----------------------------------------

TITLE: Defining Service Configuration Structure in Go using Encore
DESCRIPTION: This code snippet defines a Config struct for an Encore service with various typed configuration fields including string, integer, boolean, time, UUID, byte array, and string array types. Each field has associated comments explaining its purpose.

LANGUAGE: go
CODE:
type Config struct {
    Name        config.String    // The users name
    Port        config.Uint16
    ReadOnly    config.Bool      // true if we're in read only mode

    // MagicNumber is complicated and requires
    // a multi-line comment to explain it.
    MagicNumber config.Int

    Start       config.Time // The time at which the service was first started
    ID          config.UUID // An ID

    PublicKey config.Value[[]byte]

    AdminUsers config.Values[string]
}

----------------------------------------

TITLE: Defining PubSub Topic and Invalid Subscription in Go with Encore
DESCRIPTION: This snippet demonstrates creating a PubSub topic with Encore and an invalid subscription where the handler function is defined in a different package. The subscription fails because Encore requires the subscription handler to be defined in the same service.

LANGUAGE: go
CODE:
package svc

import (
    "context"

    "test/shared"

    "encore.dev/pubsub"
)

type MessageType struct {
    Name string
}

var (
    BasicTopic = pubsub.NewTopic[*MessageType]("basic-topic", pubsub.TopicConfig{ DeliveryGuarantee: pubsub.AtLeastOnce })
    _ = pubsub.NewSubscription(BasicTopic, "basic-subscription", pubsub.SusbcriptionConfig { Handler: shared.Subscriber })
)

// encore:api
func DoStuff(ctx context.Context) error {
    return BasicTopic.Publish(ctx, &MessageType{Name: "foo"})
}

----------------------------------------

TITLE: Defining an Encore Service with a Public API Endpoint in Go
DESCRIPTION: Defines a basic Encore service with a simple public API endpoint named 'Foo'. The service is annotated with Encore-specific comments that mark it as a service and the function as a public API.

LANGUAGE: go
CODE:
package basic

import "context"

//encore:service
type Service struct{}

//encore:api public
func (s *Service) Foo(ctx context.Context) error { return nil }

----------------------------------------

TITLE: Testing Authentication Overrides in Encore
DESCRIPTION: Tests authentication functionality using OverrideAuthInfo and verifies user ID retrieval. Checks that auth info is reset between tests, propagates to API calls, and can be overridden by context.

LANGUAGE: go
CODE:
package svc

import (
    "context"
    "testing"
    "encore.dev/beta/auth"
    "encore.dev/et"
)

func TestOverrideAuthInfo(t *testing.T) {
    curr, _ := auth.UserID()
    if curr != "" {
        t.Fatalf("got uid %q, want %q", curr, "")
    }

    et.OverrideAuthInfo("foo", nil)

    curr, _ = auth.UserID()
    if curr != "foo" {
        t.Fatalf("got uid %q, want %q", curr, "foo")
    }
}

func TestOverrideAuthInfo_ResetBetweenTests(t *testing.T) {
    curr, _ := auth.UserID()
    if curr != "" {
        t.Fatalf("got uid %q, want %q", curr, "")
    }
}

func TestOverrideAuthInfo_PropagatesToAPICalls(t *testing.T) {
    resp, err := GetUser(context.Background())
    if err != nil {
        t.Fatal(err)
    } else if resp.UserID != "" {
        t.Fatalf("got uid %q, want %q", resp.UserID, "")
    }

    et.OverrideAuthInfo("foo", nil)

    resp, err = GetUser(context.Background())
    if err != nil {
        t.Fatal(err)
    } else if resp.UserID != "foo" {
        t.Fatalf("got uid %q, want %q", resp.UserID, "foo")
    }
}

func TestOverrideAuthInfo_APICallOptsOverride(t *testing.T) {
    et.OverrideAuthInfo("foo", nil)

    ctx := auth.WithContext(context.Background(), "bar", nil)
    resp, err := GetUser(ctx)
    if err != nil {
        t.Fatal(err)
    } else if resp.UserID != "bar" {
        t.Fatalf("got uid %q, want %q", resp.UserID, "bar")
    }
}

----------------------------------------

TITLE: Serving Inline HTML with EJS in Encore.ts
DESCRIPTION: This example shows how to render and serve inline HTML using EJS in an Encore.ts application. It defines an HTML template directly in the code, renders it with dynamic data using the ejs.render function, and serves the result with the appropriate Content-Type header.

LANGUAGE: typescript
CODE:
import { api } from "encore.dev/api";
import ejs, { Options } from "ejs";

const inlineHTML = `
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="stylesheet" href="/public/styles.css" >
  </head>
  <body>
    <h1>Static Inline HTML Example</h1>
    <h1>Name: <%= name %>!</h1>
  </body>
</html>
`;

export const serveInlineHTML = api.raw(
  { expose: true, path: "/html", method: "GET" },
  async (req, resp) => {
    const html = ejs.render(inlineHTML, { name: "Simon" });
    resp.setHeader("Content-Type", "text/html");
    resp.end(html);
  },
);

----------------------------------------

TITLE: Testing Shopping Cart Service with Encore Testing Framework in Go
DESCRIPTION: Comprehensive test suite for the shopping cart service using Encore's testing framework. Demonstrates various mocking strategies, service isolation, and endpoint testing techniques.

LANGUAGE: go
CODE:
package shoppingcart

import (
    "context"
    "math"
    "testing"

    "encore.dev/et"

    "test/products"
)

func callAndExpect(t *testing.T, total float64) {
    resp, err := Total(context.Background())
    if err != nil {
        t.Fatal(err)
    }

    if math.Abs(resp.Total - total) > 0.001 {
        t.Fatalf("expected total to be %f, got %f", total, resp.Total)
    }
}

func TestTotal_NoMocking(t *testing.T) {
    t.Parallel()

    callAndExpect(t, 299.97)
}

func TestTotal_WithMockingOfProductsEndpoint(t *testing.T) {
    t.Parallel()

    et.MockEndpoint(products.GetPrice, func(ctx context.Context, productID int, p *products.PriceParams) (*products.PriceResult, error) {
       return &products.PriceResult{ Total: 20 * float64(p.Quantity) }, nil
    })

    callAndExpect(t, 60.0)
}

func TestTotal_WithMockingOfServiceMethod(t *testing.T) {
    t.Parallel()

    et.MockEndpoint(Total, func(ctx context.Context) (*TotalResult, error) {
        return &TotalResult{ Total: 100.0 }, nil
    })

    callAndExpect(t, 100.0)
}

func TestTotal_WithMockingOfServiceObjectWithDifferentInstance(t *testing.T) {
    t.Parallel()

    et.MockService("shoppingcart", &Service{
        Items: []CartItem{
            { ProductID: 1, Quantity: 5 },
        },
    })

    callAndExpect(t, 499.95)
}

func TestTotal_WithMockingOfServiceWithMockObject(t *testing.T) {
    t.Parallel()

    et.MockService[products.Interface]("products", &mockProducts{})

    callAndExpect(t, 303.0)
}

type mockProducts struct{}

func (m *mockProducts) GetPrice(ctx context.Context, productID int, p *products.PriceParams) (*products.PriceResult, error) {
    return &products.PriceResult{ Total: float64(productID) + float64(p.Quantity * 100) }, nil
}

func TestTotal_UsingServiceIsolation(t *testing.T) {
    t.Parallel()

    callAndExpect(t, 299.97)

    // These don't run with parallel so we can test the isolation
    t.Run("emptied in isolation", func(t *testing.T) {
        et.EnableServiceInstanceIsolation()
        Empty(context.Background())
        callAndExpect(t, 0.0)
    })

    t.Run("non isolated still has items", func(t *testing.T) {
        callAndExpect(t, 299.97)
    })
}

func TestTotal_RemovingMockServices(t *testing.T) {
    t.Parallel()

    et.MockService[products.Interface]("products", &mockProducts{})

    t.Run("remove mock", func(t *testing.T) {
        et.MockService[products.Interface]("products", nil)
        callAndExpect(t, 299.97)
    })

    callAndExpect(t, 303.0)
}

func TestTotal_RemovingMockEndpoints(t *testing.T) {
    t.Parallel()

    et.MockEndpoint(products.GetPrice, func(ctx context.Context, productID int, p *products.PriceParams) (*products.PriceResult, error) {
       return &products.PriceResult{ Total: 20 * float64(p.Quantity) }, nil
    })

    t.Run("remove mock", func(t *testing.T) {
        et.MockEndpoint(products.GetPrice, nil)
        callAndExpect(t, 299.97)
    })

    callAndExpect(t, 60.0)
}

----------------------------------------

TITLE: Loading Configuration with Encore in Go
DESCRIPTION: Loads the configuration using Encore's config.Load function with a generic type parameter for the Config structure. This enables type-safe configuration loading in the application.

LANGUAGE: go
CODE:
var _ = config.Load[*Config]()

----------------------------------------

TITLE: Setting Cookies in API Responses with Header Tags in Go
DESCRIPTION: Example showing how to set cookies in API responses using the `header` tag with the Set-Cookie header name in Encore.go.

LANGUAGE: go
CODE:
struct {
    SessionID string `header:"Set-Cookie"`
}

----------------------------------------

TITLE: Configuring Buf for Code Generation
DESCRIPTION: Configuration file for buf that specifies how to generate Go code from Protobuf definitions. It defines plugins for generating both standard Protocol Buffers code and Connect-specific code.

LANGUAGE: yaml
CODE:
version: v2
plugins:
  - local: protoc-gen-go
    out: gen
    opt: paths=source_relative
  - local: protoc-gen-connect-go
    out: gen
    opt: paths=source_relative

----------------------------------------

TITLE: Defining PubSub Components in Go
DESCRIPTION: Defines a Message struct, Topic, and Subscription using Encore's pubsub package. The Topic is configured with AtLeastOnce delivery guarantee, and the Subscription has a minimal handler function that returns nil.

LANGUAGE: go
CODE:
package svc

import "encore.dev/pubsub"

type Message struct{}

var Topic = pubsub.NewTopic[*Message]("foo", pubsub.TopicConfig{
    DeliveryGuarantee: pubsub.AtLeastOnce,
})

var Sub = pubsub.NewSubscription(Topic, "bar", // use svc.Topic fn pubsub.NewSubscription arg 0
    pubsub.SubscriptionConfig{
        Handler: func(m *Message) error {
            return nil
        },
    },
)

func init() {
    Topic.Foo() // use svc.Topic call Foo
}

----------------------------------------

TITLE: Implementing an Invalid Cron Job in Encore
DESCRIPTION: This code demonstrates an incorrect cron job implementation in Encore. It fails due to two errors: the endpoint references a regular function instead of an Encore API, and the cron job is defined outside of a service context. The correct implementation would require defining an API endpoint and placing the cron definition within a proper service structure.

LANGUAGE: go
CODE:
package svc

import (
	"context"
	"time"

	"encore.dev/cron"
)

var _ = cron.NewJob("my-job", cron.JobConfig{
	Schedule: "* * * * 5",
	Endpoint: CronFunc,
})


func CronFunc(ctx context.Context) error {
    return nil
}

----------------------------------------

TITLE: Nested Fields in API Request Structures
DESCRIPTION: Example showing how nested fields in Encore API schemas are handled. Only json tags are processed for nested fields, while header and query parameters only work at the root level.

LANGUAGE: go
CODE:
struct {
    Header string `header:"X-Header"`
    Nested struct {
        Header2 string `header:"X-Header2"` // Read from body instead
    } `json:"nested"`
}

----------------------------------------

TITLE: Defining Configuration Structures in Encore
DESCRIPTION: Defines structures for server configuration in an Encore application. Includes ServerOptions for controlling server behavior and a Config structure for organizing configuration categories.

LANGUAGE: go
CODE:
type ServerOptions struct {
    Enabled bool // Is this option enabled?
    Port    uint32 // What port should we run on?
}

type Config struct {
    HTTP ServerOptions // The options for the HTTP server
}

----------------------------------------

TITLE: Configuring PubSub Topics and Subscriptions in Encore Go Service
DESCRIPTION: This code snippet demonstrates how to create PubSub topics and subscriptions in Encore, with a validation error occurring due to the missing required Handler field in the subscription configuration. The code includes a message type structure, topic definition, subscription setup, and handler functions.

LANGUAGE: go
CODE:
package svc

import (
    "context"

    "encore.dev/pubsub"
)

type MessageType struct {
    Name string
}

var (
    BasicTopic = pubsub.NewTopic[*MessageType]("basic-topic", pubsub.TopicConfig{ DeliveryGuarantee: pubsub.AtLeastOnce })
    _ = pubsub.NewSubscription(BasicTopic, "basic-subscription", pubsub.SusbcriptionConfig{})
)

// encore:api
func DoStuff(ctx context.Context) error {
    return BasicTopic.Publish(ctx, &MessageType{Name: "foo"})
}

func Subscriber(ctx context.Context, msg *MessageType) error {
    return nil
}

----------------------------------------

TITLE: Creating a User with cURL in the Incident Management Tool
DESCRIPTION: Example cURL command to create a new user by sending a POST request to the /users endpoint with user details in JSON format.

LANGUAGE: bash
CODE:
curl -d '{
  "FirstName":"Katy",
  "LastName":"Smith",
  "SlackHandle":"katy"
}' http://localhost:4000/users

# Example JSON response
# {
#   "Id":1,
#   "FirstName":"Katy",
#   "LastName":"Smith",
#   "SlackHandle":"katy"
# }

----------------------------------------

TITLE: Defining Product Price API with Encore Framework in Go
DESCRIPTION: Implementation of a product pricing API endpoint using Encore framework annotations. The API calculates product prices based on quantity and returns the total price.

LANGUAGE: go
CODE:
package products

import (
    "context"
)

type PriceParams struct {
    Quantity int
}

type PriceResult struct {
    Total float64
}

//encore:api public method=GET path=/products/:productID/price
func GetPrice(ctx context.Context, productID int, p *PriceParams) (*PriceResult, error) {
    return &PriceResult{ Total: 99.99 * float64(p.Quantity) }, nil
}

----------------------------------------

TITLE: Implementing Request Handling and PubSub in Encore
DESCRIPTION: Go code implementing an Encore service with PubSub functionality and request context handling. Includes a public API endpoint that returns request path and idempotency key information, plus PubSub topic and subscription definitions.

LANGUAGE: go
CODE:
package svc

import (
    "context"
    "encore.dev"
    "encore.dev/rlog"
    "encore.dev/pubsub"
)

type MyData struct {
    Name string
}

type Event struct {
    Data string
}

type RequestData struct {
    Path string
    IdempotencyKey string
}

//encore:api public
func CurrentRequest(ctx context.Context) (*RequestData, error) {
    req := encore.CurrentRequest()
    return &RequestData{
        Path: req.Path,
        IdempotencyKey: req.CronIdempotencyKey,
    }, nil
}

var topic = pubsub.NewTopic[*Event]("topic", pubsub.TopicConfig{
    DeliveryGuarantee: pubsub.AtLeastOnce,
})

var _ = pubsub.NewSubscription(topic, "sub", pubsub.SubscriptionConfig[*Event]{
    Handler: func(ctx context.Context, event *Event) error {
        req := encore.CurrentRequest()
        rlog.Info("pubsub event",
            "type", req.Type,
            "msg", req.Message,
        )
        return nil
    },
})

----------------------------------------

TITLE: Enhanced Config Loading with Generated Unmarshaler
DESCRIPTION: Modified version of the config loading that includes the service name and references the generated unmarshaler function. This represents how Encore transforms the original code during build processing.

LANGUAGE: go
CODE:
var _ = config.Load[*Config]("svc", encoreInternalConfigUnmarshaler_ptr_svc_Config/*line :17:30*/)

----------------------------------------

TITLE: Creating a Database Table in PostgreSQL
DESCRIPTION: SQL commands to create a users table with id and name fields, and insert a sample record into the new table.

LANGUAGE: sql
CODE:
CREATE TABLE users (
   id SERIAL PRIMARY KEY,
   name TEXT
);
INSERT INTO users (name) VALUES ('Alice');

----------------------------------------

TITLE: Assigning Unassigned Incidents to On-Call Users in Go
DESCRIPTION: A private API endpoint function that assigns unassigned incidents to the user who is currently scheduled to be on-call. It retrieves the current schedule, lists all incidents, and assigns unassigned incidents to the on-call user, with appropriate logging for successes and failures.

LANGUAGE: go
CODE:
//encore:api private
func AssignUnassignedIncidents(ctx context.Context) error {
	// if this fails, we don't have anyone on call so let's skip this
	schedule, err := schedules.ScheduledNow(ctx)
	if err != nil {
		return err
	}

	incidents, err := List(ctx) // we never query for acknowledged incidents
	if err != nil {
		return err
	}

	for _, incident := range incidents.Items {
		if incident.Assignee != nil {
			continue // this incident has already been assigned
		}

		_, err := Assign(ctx, incident.Id, &AssignParams{UserId: schedule.User.Id})
		if err == nil {
			rlog.Info("OK assigned unassigned incident", "incident", incident, "user", schedule.User)
		} else {
			rlog.Error("FAIL to assign unassigned incident", "incident", incident, "user", schedule.User, "err", err)
			return err
		}
	}

	return nil
}

----------------------------------------

TITLE: Generated Service Interface for API Endpoints
DESCRIPTION: Auto-generated code that defines an interface for the service's API surface area, primarily used for mocking purposes during testing.

LANGUAGE: go
CODE:
// Code generated by encore. DO NOT EDIT.

package svca

import "context"

// These functions are automatically generated and maintained by Encore
// to simplify calling them from other services, as they were implemented as methods.
// They are automatically updated by Encore whenever your API endpoints change.

// Interface defines the service's API surface area, primarily for mocking purposes.
//
// Raw endpoints are currently excluded from this interface, as Encore does not yet
// support service-to-service API calls to raw endpoints.
type Interface interface {
	Foo(ctx context.Context) error

	Bar(ctx context.Context) error
}

----------------------------------------

TITLE: Defining API Request/Response Structs with Header Tags in Go
DESCRIPTION: Example of how to define structs with header tags for API request/response handling in Encore.go. The struct field uses the `header` tag to specify HTTP header fields like Accept-Language.

LANGUAGE: go
CODE:
struct {
    Language string `header:"Accept-Language"`
}

----------------------------------------

TITLE: Defining an API Endpoint in Encore
DESCRIPTION: Defines a simple API endpoint using Encore's API declaration syntax. The function takes a context parameter and returns an error, with the '//encore:api' directive marking it as an API endpoint.

LANGUAGE: go
CODE:
//encore:api
func MyAPI(ctx context.Context) (error) {
	return nil
}

----------------------------------------

TITLE: Defining a Shared Message Type in Go for Encore PubSub
DESCRIPTION: Defines a shared MessageType struct that can be used across services for PubSub messages. This type serves as the payload structure for the PubSub topic.

LANGUAGE: go
CODE:
package shared

type MessageType struct {
    Name string
}

----------------------------------------

TITLE: Configuring Self-Hosted Infrastructure for Encore Application
DESCRIPTION: Creates an infrastructure configuration JSON file for self-hosting the Encore application. The file defines SQL server connections with database credentials that will be used when running the Docker image.

LANGUAGE: json
CODE:
{
   "$schema": "https://encore.dev/schemas/infra.schema.json",
   "sql_servers": [
      {
         "host": "my-db-host:5432",
         "databases": {
            "monitor": {
               "username": "my-db-owner",
                "password": {"$env": "DB_PASSWORD"}
            },
            "site": {
               "username": "my-db-owner",
                "password": {"$env": "DB_PASSWORD"}
            }
         }
      }
   ]
}

----------------------------------------

TITLE: Nested Header Fields in Encore.ts
DESCRIPTION: This example shows that using the Header type in nested fields has no effect; nested header fields are sent as part of the JSON body instead.

LANGUAGE: typescript
CODE:
import { api, Header } from "encore.dev/api";

interface Data {
  header: Header<"X-Header">; // this field will be read from the http header
  nested: {
    header2: Header<"X-Other-Header">; // Header has no effect inside nested fields
  };
}

// A simple API endpoint that echoes the data back.
export const echo = api(
  { method: "POST", path: "/nested" },
  async (params: Data) => {
    // ...
  },
);

----------------------------------------

TITLE: Adding Crypto Import for HMAC Verification
DESCRIPTION: TypeScript import statements for the crypto modules needed to implement HMAC verification of Slack webhook requests. These functions will be used to validate that incoming requests are authentic.

LANGUAGE: typescript
CODE:
import { createHmac, timingSafeEqual } from "node:crypto";
import type { IncomingHttpHeaders } from "http";

----------------------------------------

TITLE: Serving Static Files in Encore.ts
DESCRIPTION: This snippet demonstrates how to serve static files in Encore.ts using the api.static method, which serves files directly from the Encore.ts Rust Runtime without executing JavaScript code.

LANGUAGE: typescript
CODE:
import { api } from "encore.dev/api";

export const assets = api.static(
  { expose: true, path: "/assets/*path", dir: "./assets" },
);

----------------------------------------

TITLE: Generated Configuration Unmarshaler for Encore
DESCRIPTION: Automatically generated code by Encore that provides JSON unmarshaling functionality for the Config struct. Uses jsoniter to parse JSON into the appropriate data structure, handling null values and nested structs.

LANGUAGE: go
CODE:
var (
	encoreInternalConfigUnmarshaler_ptr_svc_Config = func(itr *jsoniter.Iterator, path []string) *Config {
		return func() *Config {
			// If the value is null, we return nil
			if itr.ReadNil() {
				return nil
			}

			// Otherwise we unmarshal the value and return a pointer to it
			obj := encoreInternalTypeConfigUnmarshaler_svc_Config(itr, append(path))
			return &obj
		}()
	}
)

----------------------------------------

TITLE: Defining API Endpoint with Encore in TypeScript
DESCRIPTION: Creates an API endpoint named 'ping' using Encore's API framework. The endpoint takes void as input and returns void as output.

LANGUAGE: typescript
CODE:
import { api } from "encore.dev/api";
import { blah } from "@bar/bar";

export const ping = api<void, void>({}, () => {});

----------------------------------------

TITLE: VS Code Debug Configuration for Node.js Attach
DESCRIPTION: JSON configuration for VS Code to attach a debugger to a running Encore application. This setup connects to port 9229, skips Node.js internal files, and uses the Node.js debugger type.

LANGUAGE: json
CODE:
{
  "version": "0.2.0",
  "configurations": [
    {
      "name": "Attach",
      "port": 9229,
      "request": "attach",
      "skipFiles": [
        "<node_internals>/**"
      ],
      "type": "node"
    }
  ]
}

----------------------------------------

TITLE: Defining a Monthly Cron Job with Cron Expression in Encore
DESCRIPTION: Implementation of a cron job using a cron expression for more advanced scheduling patterns. This example schedules a job to run at 4am UTC on the 15th of each month.

LANGUAGE: go
CODE:
var _ = cron.NewJob("accounting-sync", cron.JobConfig{
    Title:    "Cron Job Example",
    Schedule: "0 4 15 * *", // 4am UTC on 15th of each month
    Endpoint: AccountingSync,
})

----------------------------------------

TITLE: Generated API Endpoint Registration and Descriptor Definitions
DESCRIPTION: Auto-generated code that registers the API endpoints with Encore's runtime, defining request/response types and handlers for HTTP interaction.

LANGUAGE: go
CODE:
package svca

import (
	"context"
	__api "encore.dev/appruntime/apisdk/api"
	jsoniter "github.com/json-iterator/go"
	"net/http"
	"net/url"
)

func init() {
	__api.RegisterEndpoint(EncoreInternal_api_APIDesc_Foo, Foo)
	__api.RegisterEndpoint(EncoreInternal_api_APIDesc_Bar, Bar)
}

type EncoreInternal_FooReq struct{}

type EncoreInternal_FooResp = __api.Void

var EncoreInternal_api_APIDesc_Foo = &__api.Desc[*EncoreInternal_FooReq, EncoreInternal_FooResp]{
	Access: __api.Public,
	AppHandler: func(ctx context.Context, reqData *EncoreInternal_FooReq) (EncoreInternal_FooResp, error) {
		err := Foo(ctx)
		if err != nil {
			return __api.Void{}, err
		}
		return __api.Void{}, nil
	},
	CloneReq: func(r *EncoreInternal_FooReq) (*EncoreInternal_FooReq, error) {
		var clone *EncoreInternal_FooReq
		bytes, err := jsoniter.ConfigDefault.Marshal(r)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return clone, err
	},
	CloneResp: func(r EncoreInternal_FooResp) (EncoreInternal_FooResp, error) {
		var clone EncoreInternal_FooResp
		bytes, err := jsoniter.ConfigDefault.Marshal(r)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return clone, err
	},
	DecodeExternalResp: func(httpResp *http.Response, json jsoniter.API) (resp EncoreInternal_FooResp, err error) {
		return __api.Void{}, nil
	},
	DecodeReq: func(httpReq *http.Request, ps __api.UnnamedParams, json jsoniter.API) (reqData *EncoreInternal_FooReq, pathParams __api.UnnamedParams, err error) {
		reqData = new(EncoreInternal_FooReq)
		return reqData, nil, nil
	},
	DefLoc: uint32(0x0),
	EncodeExternalReq: func(reqData *EncoreInternal_FooReq, stream *jsoniter.Stream) (httpHeader http.Header, queryString url.Values, err error) {
		return nil, nil, nil
	},
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, resp EncoreInternal_FooResp) (err error) {
		return nil
	},
	Endpoint:            "Foo",
	Fallback:            false,
	GlobalMiddlewareIDs: []string{},
	Methods:             []string{"GET", "POST"},
	Path:                "/svca.Foo",
	PathParamNames:      nil,
	Raw:                 false,
	RawHandler:          nil,
	RawPath:             "/svca.Foo",
	ReqPath: func(reqData *EncoreInternal_FooReq) (string, __api.UnnamedParams, error) {
		return "/svca.Foo", nil, nil
	},
	ReqUserPayload: func(reqData *EncoreInternal_FooReq) any {
		return nil
	},
	Service:           "svca",
	ServiceMiddleware: []*__api.Middleware{},
	SvcNum:            1,
	Tags:              nil,
}

type EncoreInternal_BarReq struct{}

type EncoreInternal_BarResp = __api.Void

var EncoreInternal_api_APIDesc_Bar = &__api.Desc[*EncoreInternal_BarReq, EncoreInternal_BarResp]{
	Access: __api.Public,
	AppHandler: func(ctx context.Context, reqData *EncoreInternal_BarReq) (EncoreInternal_BarResp, error) {
		err := Bar(ctx)
		if err != nil {
			return __api.Void{}, err
		}
		return __api.Void{}, nil
	},
	CloneReq: func(r *EncoreInternal_BarReq) (*EncoreInternal_BarReq, error) {
		var clone *EncoreInternal_BarReq
		bytes, err := jsoniter.ConfigDefault.Marshal(r)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return clone, err
	},
	CloneResp: func(r EncoreInternal_BarResp) (EncoreInternal_BarResp, error) {
		var clone EncoreInternal_BarResp
		bytes, err := jsoniter.ConfigDefault.Marshal(r)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return clone, err
	},
	DecodeExternalResp: func(httpResp *http.Response, json jsoniter.API) (resp EncoreInternal_BarResp, err error) {
		return __api.Void{}, nil
	},
	DecodeReq: func(httpReq *http.Request, ps __api.UnnamedParams, json jsoniter.API) (reqData *EncoreInternal_BarReq, pathParams __api.UnnamedParams, err error) {
		reqData = new(EncoreInternal_BarReq)
		return reqData, nil, nil
	},
	DefLoc: uint32(0x0),
	EncodeExternalReq: func(reqData *EncoreInternal_BarReq, stream *jsoniter.Stream) (httpHeader http.Header, queryString url.Values, err error) {
		return nil, nil, nil
	},
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, resp EncoreInternal_BarResp) (err error) {
		return nil
	},
	Endpoint:            "Bar",
	Fallback:            false,
	GlobalMiddlewareIDs: []string{},
	Methods:             []string{"GET", "POST"},
	Path:                "/svca.Bar",
	PathParamNames:      nil,
	Raw:                 false,
	RawHandler:          nil,
	RawPath:             "/svca.Bar",
	ReqPath: func(reqData *EncoreInternal_BarReq) (string, __api.UnnamedParams, error) {
		return "/svca.Bar", nil, nil
	},
	ReqUserPayload: func(reqData *EncoreInternal_BarReq) any {
		return nil
	},
	Service:           "svca",
	ServiceMiddleware: []*__api.Middleware{},
	SvcNum:            1,
	Tags:              nil,
}

----------------------------------------

TITLE: Implementing an Encore Service with Shutdown Handler
DESCRIPTION: Code for an Encore service with a Shutdown method implementation. The service defines a shutdown handler that logs a message when the service is being shut down, using Encore's rlog and shutdown packages.

LANGUAGE: go
CODE:
package svc

import (
    "encore.dev/shutdown"
    "encore.dev/rlog"
)

//encore:service
type Service struct{}

func (s *Service) Shutdown(p shutdown.Progress) error {
    rlog.Info("shutting down")
    return nil
}

----------------------------------------

TITLE: Implementing a Basic Encore API Endpoint
DESCRIPTION: Defines an API endpoint named MyAPI using Encore's //encore:api directive. This creates a publicly accessible API endpoint that takes a context parameter and returns an error.

LANGUAGE: Go
CODE:
//encore:api
func MyAPI(ctx context.Context) (error) {
	return nil
}

----------------------------------------

TITLE: Defining a PubSub Handler Function in Service 2
DESCRIPTION: Implementation of a PubSub message handler function in Service 2 that is incorrectly referenced by Service 1's subscription.

LANGUAGE: go
CODE:
package svc2

import (
    "context"

    "test/shared"
)

//encore:api
func Subscriber(ctx context.Context, msg *shared.MessageType) error {
    return nil
}

----------------------------------------

TITLE: Creating Directory Structure for Monitor Service
DESCRIPTION: Shell commands to create the necessary directory and file structure for the monitor service which will handle website status checks.

LANGUAGE: shell
CODE:
$ mkdir monitor
$ touch monitor/ping.go

----------------------------------------

TITLE: GraphQL Query for Retrieving Shortened URLs
DESCRIPTION: Example GraphQL query for retrieving the original URL by its shortened ID, demonstrating how to use the GraphQL API for URL lookup.

LANGUAGE: graphql
CODE:
query {
    get(id: "<your-id-here>") {
        url
    }
}

----------------------------------------

TITLE: Loading Configuration in Encore Service
DESCRIPTION: Uses the config.Load generic function to load configuration values of type *Config. The discarded return value pattern indicates the configuration is being loaded but not directly used in this file.

LANGUAGE: go
CODE:
var _ = config.Load[*Config]()

----------------------------------------

TITLE: Using Streaming APIs from a Client
DESCRIPTION: Demonstrates how to use streaming APIs from a client perspective. This example shows how to establish a connection, send messages, and process incoming stream data.

LANGUAGE: typescript
CODE:
const stream = client.serviceName.endpointName();
await stream.send({ /* message */ });
for await (const msg of stream) {
  // Handle incoming messages
}

----------------------------------------

TITLE: Defining an Encore Database and API Endpoint
DESCRIPTION: TypeScript code to declare a SQL database connection in Encore and create an API endpoint that fetches user data by ID.

LANGUAGE: typescript
CODE:
const mydb = new SQLDatabase("mydb", {
   migrations: "./migrations",
});

export const getUser = api(
  { expose: true, method: "GET", path: "/names/:id" },
  async ({id}: {id:number}): Promise<{ id: number; name: string }> => {
    return await mydb.queryRow`SELECT * FROM users WHERE id = ${id}` as { id: number; name: string };
  }
);

----------------------------------------

TITLE: Implementing Encore Cloud Provider for AWS EC2 Metadata Retrieval in Go
DESCRIPTION: This code defines a cloud provider client for the Encore platform that retrieves metadata from AWS EC2 instances. It implements the CloudProvider interface with methods to fetch the host cluster, availability zone, and whether the environment is running in cloud infrastructure.

LANGUAGE: go
CODE:
package cloud

import (
	"context"
	"strings"

	"github.com/aws/aws-sdk-go-v2/config"
	"github.com/aws/aws-sdk-go-v2/feature/ec2/imds"
)

type encoreCloudProvider struct{}

func NewEncoreProvider() CloudProvider {
	return &encoreCloudProvider{}
}

func (p *encoreCloudProvider) HostCluster(ctx context.Context) (string, error) {
	// For now we don't identify the host cluster in Encore Cloud;
	// it's only used to distinguish between different self-hosted environments.
	return "", nil
}

func (p *encoreCloudProvider) Zone(ctx context.Context) (string, error) {
	// Get the AWS EC2 IMDS client
	cfg, err := config.LoadDefaultConfig(ctx)
	if err != nil {
		return "", err
	}
	client := imds.NewFromConfig(cfg)
	
	// Fetch the availability zone
	resp, err := client.GetInstanceIdentityDocument(ctx, &imds.GetInstanceIdentityDocumentInput{})
	if err != nil {
		return "", err
	}
	
	return resp.AvailabilityZone, nil
}

func (p *encoreCloudProvider) IsCloud(ctx context.Context) (bool, error) {
	zone, err := p.Zone(ctx)
	if err != nil {
		// If we get an error assume we're not running in the cloud
		return false, nil
	}
	return strings.TrimSpace(zone) != "", nil
}

----------------------------------------

TITLE: Adding a Timestamp Column to Todo Item Table
DESCRIPTION: This second migration file alters the 'todo_item' table by adding a 'created' timestamp column. The column uses timezone information, has a NOT NULL constraint, and defaults to the current time using NOW().

LANGUAGE: sql
CODE:
ALTER TABLE todo_item ADD created TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW();

----------------------------------------

TITLE: Generated Encore Middleware Implementation
DESCRIPTION: Generated internal code for middleware implementation in Encore. Defines how middleware is registered and invoked within the Encore framework, including service instance retrieval and error handling.

LANGUAGE: go
CODE:
package code

import (
	__api "encore.dev/appruntime/apisdk/api"
	errs "encore.dev/beta/errs"
	middleware "encore.dev/middleware"
)

var EncoreInternal_middleware_middleware_Middleware = &__api.Middleware{
	DefLoc: uint32(0x0),
	Global: false,
	ID:     "example.com.Middleware",
	Invoke: func(req middleware.Request, next middleware.Next) middleware.Response {
		svc, err := EncoreInternal_svcstruct_Service.Get()
		if err != nil {
			return middleware.Response{
				Err:        err,
				HTTPStatus: errs.HTTPStatus(err),
			}
		}
		return svc.Middleware(req, next)
	},
	Name:    "Middleware",
	PkgName: "code",
}

----------------------------------------

TITLE: Testing an Encore Service with Custom Authentication
DESCRIPTION: Implements a test for the Foo service using Encore's testing framework. This test uses et.AuthHandler to set a custom authentication handler named MyAuth for the test.

LANGUAGE: Go
CODE:
package svc

import (
    "context"
    "testing"

    "encore.dev/et"
)

func TestFoo(t *testing.T) {
    et.AuthHandler(MyAuth)
}

----------------------------------------

TITLE: Creating a New Encore App with CLI
DESCRIPTION: Command to create a new Encore application using the Encore CLI, selecting the Hello World template.

LANGUAGE: bash
CODE:
encore app create myapp

----------------------------------------

TITLE: Accessing API Call and PubSub Message Metadata Types in TypeScript
DESCRIPTION: This example shows the interface definitions for APICallMeta and PubSubMessageMeta types returned by the currentRequest() function. The APICallMeta interface represents an API call being processed, while PubSubMessageMeta represents a Pub/Sub message being processed.

LANGUAGE: typescript
CODE:
/** Describes an API call being processed. */
export interface APICallMeta {
  /** Specifies that the request is an API call. */
  type: "api-call";

  /** Describes the API Endpoint being called. */
  api: APIDesc;

  /** The HTTP method used in the API call. */
  method: Method;

  /**
   * The request URL path used in the API call,
   * excluding any query string parameters.
   * For example "/path/to/endpoint".
   */
  path: string;

  /**
   * The request URL path used in the API call,
   * including any query string parameters.
   * For example "/path/to/endpoint?with=querystring".
   */
  pathAndQuery: string;

  /**
   * The parsed path parameters for the API endpoint.
   * The keys are the names of the path parameters,
   * from the API definition.
   *
   * For example {id: 5}.
   */
  pathParams: Record<string, any>;

  /**
   * The request headers from the HTTP request.
   * The values are arrays if the header contains multiple values,
   * either separated by ";" or when the header key appears more than once.
   */
  headers: Record<string, string | string[]>;

  /**
   * The parsed request payload, as expected by the application code.
   * Not provided for raw endpoints or when the API endpoint expects no
   * request data.
   */
  parsedPayload?: Record<string, any>;
}

/** Describes a Pub/Sub message being processed. */
export interface PubSubMessageMeta {
  /** Specifies that the request is a Pub/Sub message. */
  type: "pubsub-message";

  /** The service processing the message. */
  service: string;

  /** The name of the Pub/Sub topic. */
  topic: string;

  /** The name of the Pub/Sub subscription. */
  subscription: string;

  /**
   * The unique id of the Pub/Sub message.
   * It is the same id returned by `topic.publish()`.
   * The message id stays the same across delivery attempts.
   */
  messageId: string;

  /**
   * The delivery attempt. The first attempt starts at 1,
   * and increases by 1 for each retry.
   */
  deliveryAttempt: number;

  /**
   * The parsed request payload, as expected by the application code.
   */
  parsedPayload?: Record<string, any>;
}

----------------------------------------

TITLE: Downloading Files from Object Storage in Encore.ts
DESCRIPTION: Demonstrates how to download a file from a bucket using the 'download' method. The method can be configured with additional options like specifying a particular version of the object.

LANGUAGE: typescript
CODE:
const data = await profilePictures.download("my-image.jpeg");

----------------------------------------

TITLE: Basic Empty Go Program (Original)
DESCRIPTION: The original main.go file with an empty main function.

LANGUAGE: go
CODE:
package main
func main() {
}

----------------------------------------

TITLE: Auto-generated Service Interface for Foo
DESCRIPTION: Encore-generated code that defines an interface for the Foo service, which is useful for mocking in tests. This code is automatically maintained by Encore whenever API endpoints change.

LANGUAGE: go
CODE:
// Code generated by encore. DO NOT EDIT.

package foo

import "context"

// These functions are automatically generated and maintained by Encore
// to simplify calling them from other services, as they were implemented as methods.
// They are automatically updated by Encore whenever your API endpoints change.

// Interface defines the service's API surface area, primarily for mocking purposes.
//
// Raw endpoints are currently excluded from this interface, as Encore does not yet
// support service-to-service API calls to raw endpoints.
type Interface interface {
	Foo(ctx context.Context) error
}

----------------------------------------

TITLE: Publishing to PubSub Topic and Checking Logs in Encore
DESCRIPTION: Shell commands for running an Encore application, publishing a test message to a topic, and verifying the log output with expected payload structure.

LANGUAGE: shell
CODE:
run
publish topic '{"Data": "test"}'
checklog '{"topic": "topic", "subscription": "sub", "type": "pubsub-message", "msg": {"Service": "svc", "Topic": "topic", "Subscription": "sub", "ID": "1", "DeliveryAttempt": 1}, "message": "pubsub event"}'

----------------------------------------

TITLE: Node Setup and Railway Deployment Trigger in GitHub Actions
DESCRIPTION: Additional GitHub Actions workflow steps to set up Node.js and trigger a Railway deployment using the automation script.

LANGUAGE: yaml
CODE:
      - name: Set up Node
        uses: actions/setup-node@v4
        with:
          node-version: 22

      - name: Trigger Railway deployment
        run: node script.js ${{ secrets.RAILWAY_API_TOKEN }}

----------------------------------------

TITLE: Modified Configuration Loading with Encore
DESCRIPTION: This modified version of the configuration loading code shows how Encore transforms the original code to include the generated unmarshalers. It adds the package name and unmarshaler function as arguments to config.Load.

LANGUAGE: go
CODE:
var cfg = config.Load[*CfgType[uint]]("generics", encoreInternalConfigUnmarshaler_ptr_examplecom_CfgType_uint_/*line :32:39*/)

----------------------------------------

TITLE: Defining Duplicate Cron Jobs in Go with Encore
DESCRIPTION: This code demonstrates an error scenario where two cron jobs are defined with the same name ('cronfood'), which is not allowed in Encore. The first job runs every Friday while the second attempts to run every Thursday, causing a validation error.

LANGUAGE: go
CODE:
var _, bd = cron.NewJob("cronfood", cron.JobConfig{
	Title:    "Cron Food Bar",
	Schedule: "* * * * 5",
	Endpoint: Cron,
}), "barfoo"

// A cron job to send out push notiifications to new subscribers.
var _ = cron.NewJob("cronfood", cron.JobConfig{
	Title:    "Cron Foo Bar Bazz",
	Schedule: "* * * * 4",
	Endpoint: Cron,
})

----------------------------------------

TITLE: Creating a Todo Item Table in SQL
DESCRIPTION: This migration file creates the initial 'todo_item' table with columns for id, title, and done status. It uses BIGSERIAL for auto-incrementing primary keys and enforces NOT NULL constraints on the data columns.

LANGUAGE: sql
CODE:
CREATE TABLE todo_item (
    id BIGSERIAL PRIMARY KEY,
    title TEXT NOT NULL,
    done BOOLEAN NOT NULL
);

----------------------------------------

TITLE: Generated Service Method Wrappers
DESCRIPTION: Encore automatically generates standalone function wrappers for service methods to simplify service-to-service calls. This includes a generated Interface to support mocking in tests.

LANGUAGE: go
CODE:
// Code generated by encore. DO NOT EDIT.

package code

import "context"

// These functions are automatically generated and maintained by Encore
// to simplify calling them from other services, as they were implemented as methods.
// They are automatically updated by Encore whenever your API endpoints change.

func Foo(ctx context.Context) error {
	svc, err := EncoreInternal_svcstruct_Service.Get()
	if err != nil {
		return err
	}
	return svc.Foo(ctx)
}

// Interface defines the service's API surface area, primarily for mocking purposes.
//
// Raw endpoints are currently excluded from this interface, as Encore does not yet
// support service-to-service API calls to raw endpoints.
type Interface interface {
	Foo(ctx context.Context) error
}

----------------------------------------

TITLE: Implementing an Auth Handler with Parameter Validation in Encore
DESCRIPTION: This code snippet defines an authentication handler in Encore with validation requirements for parameter sources. The example shows validation errors because some struct fields (Foo and Bar) lack the required header, query, or cookie tags that specify where the parameter comes from in HTTP requests.

LANGUAGE: go
CODE:
package svc

import (
    "context"
    "encore.dev/beta/auth"
)

type Params struct {
    Authorization string `header:"Authorization"`
    Foo string
    ClientID string `query:"client_id"`
    Bar int
}

//encore:authhandler
func MyAuth(ctx context.Context, p *Params) (auth.UID, error) { return "", nil }

----------------------------------------

TITLE: Tagging API Endpoints for Middleware in Encore
DESCRIPTION: This snippet shows how to tag an API endpoint so it can be targeted by specific middleware. The 'tag:cache' identifier allows middleware with a matching target directive to process requests to this endpoint.

LANGUAGE: go
CODE:
//encore:api public method=GET path=/user/:id tag:cache
func GetUser(ctx context.Context, id string) (*User, error) {
	// ...
}

----------------------------------------

TITLE: Using Command Flags to Override Current Namespace
DESCRIPTION: Examples of using the --namespace flag (or -n shorthand) with Encore commands to override the current namespace. This allows for targeting specific namespaces for operations like running the app, accessing database shells, or resetting databases.

LANGUAGE: shell
CODE:
# Run the app using the "my-ns" namespace
$ encore run --namespace my-ns

# Open a database shell to the "my-ns" namespace
$ encore db shell DATABASE_NAME --namespace my-ns

# Reset all databases within the "my-ns" namespace
$ encore db reset --all --namespace my-ns

----------------------------------------

TITLE: Expected Output for Testing
DESCRIPTION: The expected output file containing 'Hello, world!' for test verification.

LANGUAGE: plaintext
CODE:
Hello, world!

----------------------------------------

TITLE: Generated Encore Interface Definition
DESCRIPTION: Auto-generated code that defines an interface for the service's API. This interface allows for easier service mocking and defines the API surface area of the service.

LANGUAGE: go
CODE:
// Code generated by encore. DO NOT EDIT.

package basic

import "context"

// These functions are automatically generated and maintained by Encore
// to simplify calling them from other services, as they were implemented as methods.
// They are automatically updated by Encore whenever your API endpoints change.

// Interface defines the service's API surface area, primarily for mocking purposes.
//
// Raw endpoints are currently excluded from this interface, as Encore does not yet
// support service-to-service API calls to raw endpoints.
type Interface interface {
	Foo(ctx context.Context, p *Params) error
}

----------------------------------------

TITLE: Implementing Service-Specific Middleware
DESCRIPTION: Example of middleware implementation within a service struct, allowing access to service-specific state and dependencies. This pattern enables middleware to leverage service resources.

LANGUAGE: go
CODE:
//encore:service
type Service struct{}

//encore:middleware target=all
func (s *Service) MyMiddleware(req middleware.Request, next middleware.Next) middleware.Response {
    // Implementation
}

----------------------------------------

TITLE: Encore Database and API Implementation
DESCRIPTION: TypeScript code defining a SQL database connection and an API endpoint in Encore. This creates a getUser endpoint that queries the users table by ID.

LANGUAGE: typescript
CODE:
const mydb = new SQLDatabase("mydb", {
   migrations: "./migrations",
});

export const getUser = api(
  { expose: true, method: "GET", path: "/names/:id" },
  async ({id}: {id:number}): Promise<{ id: number; name: string }> => {
    return await mydb.queryRow`SELECT * FROM users WHERE id = ${id}` as { id: number; name: string };
  }
);

----------------------------------------

TITLE: Defining Encore Service with API Method
DESCRIPTION: Original service definition with an API endpoint method. The code defines a 'Service' type and exposes a 'Foo' method as an API endpoint using Encore annotations.

LANGUAGE: go
CODE:
package code

import "context"

//encore:service
type Service struct{}

//encore:api
func (s *Service) Foo(ctx context.Context) error { return nil }

func initService() (*Service, error) { return nil, nil }

----------------------------------------

TITLE: Defining Constants and Interfaces in TypeScript
DESCRIPTION: Contains original exports: a string constant 'foo' and an interface 'bar' with a number property. This module defines the primary types and values that are re-exported through the module chain.

LANGUAGE: typescript
CODE:
export const foo = "foo";
export interface bar {
    num: number;
}

----------------------------------------

TITLE: Auto-generated API Registration for Bar Service
DESCRIPTION: Encore-generated internal code that registers the Bar API endpoint with the Encore runtime. It handles request/response marshaling, path routing, HTTP methods, and other API-related functionality.

LANGUAGE: go
CODE:
package bar

import (
	"context"
	__api "encore.dev/appruntime/apisdk/api"
	jsoniter "github.com/json-iterator/go"
	"net/http"
	"net/url"
)

func init() {
	__api.RegisterEndpoint(EncoreInternal_api_APIDesc_Bar, Bar)
}

type EncoreInternal_BarReq struct{}

type EncoreInternal_BarResp = __api.Void

var EncoreInternal_api_APIDesc_Bar = &__api.Desc[*EncoreInternal_BarReq, EncoreInternal_BarResp]{
	Access: __api.Private,
	AppHandler: func(ctx context.Context, reqData *EncoreInternal_BarReq) (EncoreInternal_BarResp, error) {
		err := Bar(ctx)
		if err != nil {
			return __api.Void{}, err
		}
		return __api.Void{}, nil
	},
	CloneReq: func(r *EncoreInternal_BarReq) (*EncoreInternal_BarReq, error) {
		var clone *EncoreInternal_BarReq
		bytes, err := jsoniter.ConfigDefault.Marshal(r)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return clone, err
	},
	CloneResp: func(r EncoreInternal_BarResp) (EncoreInternal_BarResp, error) {
		var clone EncoreInternal_BarResp
		bytes, err := jsoniter.ConfigDefault.Marshal(r)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return clone, err
	},
	DecodeExternalResp: func(httpResp *http.Response, json jsoniter.API) (resp EncoreInternal_BarResp, err error) {
		return __api.Void{}, nil
	},
	DecodeReq: func(httpReq *http.Request, ps __api.UnnamedParams, json jsoniter.API) (reqData *EncoreInternal_BarReq, pathParams __api.UnnamedParams, err error) {
		reqData = new(EncoreInternal_BarReq)
		return reqData, nil, nil
	},
	DefLoc: uint32(0x0),
	EncodeExternalReq: func(reqData *EncoreInternal_BarReq, stream *jsoniter.Stream) (httpHeader http.Header, queryString url.Values, err error) {
		return nil, nil, nil
	},
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, resp EncoreInternal_BarResp) (err error) {
		return nil
	},
	Endpoint:            "Bar",
	Fallback:            false,
	GlobalMiddlewareIDs: []string{},
	Methods:             []string{"GET", "POST"},
	Path:                "/bar.Bar",
	PathParamNames:      nil,
	Raw:                 false,
	RawHandler:          nil,
	RawPath:             "/bar.Bar",
	ReqPath: func(reqData *EncoreInternal_BarReq) (string, __api.UnnamedParams, error) {
		return "/bar.Bar", nil, nil
	},
	ReqUserPayload: func(reqData *EncoreInternal_BarReq) any {
		return nil
	},
	Service:           "bar",
	ServiceMiddleware: []*__api.Middleware{},
	SvcNum:            1,
	Tags:              nil,
}

----------------------------------------

TITLE: Defining an Authentication Handler in Encore
DESCRIPTION: This code defines an authentication handler for an Encore application. It includes a custom data structure 'MyData' to store authenticated user information, and a handler function 'MyAuth' annotated with the Encore-specific '//encore:authhandler' directive that processes authentication tokens.

LANGUAGE: go
CODE:
package svc

import (
    "context"
    "encore.dev/beta/auth"
)

type MyData struct {
    Name string
}

//encore:authhandler
func MyAuth(ctx context.Context, token string) (auth.UID, *MyData, error) { return "", nil, nil }

----------------------------------------

TITLE: Re-enabling Telemetry via CLI Command
DESCRIPTION: Command to re-enable telemetry data collection if a user wishes to resume sharing usage data with Encore.

LANGUAGE: sh
CODE:
encore telemetry enable

----------------------------------------

TITLE: Building Docker Image with Custom Infrastructure Config
DESCRIPTION: Command to build a Docker image for an Encore app using a custom infrastructure configuration file.

LANGUAGE: bash
CODE:
encore build docker --config infra.config.json myapp

----------------------------------------

TITLE: Connecting to PostgreSQL Database on DigitalOcean
DESCRIPTION: Command to connect to a PostgreSQL database hosted on DigitalOcean using the psql client.

LANGUAGE: bash
CODE:
psql -h mydb.db.ondigitalocean.com -U doadmin -d mydb -p 25060

----------------------------------------

TITLE: Transformed Configuration Structure in Service D
DESCRIPTION: The transformed version of DsConfig with the service name and an internal unmarshaler function in the config.Load call.

LANGUAGE: go
CODE:
package svc

import (
	"encore.dev/config"
)

type DsConfig struct{
    Foo config.String // Some extra comment
}

var _ = config.Load[DsConfig]("svc", encoreInternalConfigUnmarshaler_svc_DsConfig/*line :11:31*/)

----------------------------------------

TITLE: Generated HTTP Handler for Header Parameter Extraction in Encore
DESCRIPTION: Encore-generated implementation code that registers the API endpoint and handles the extraction of header parameters from HTTP requests. It demonstrates how headers are parsed, validated, and mapped to the appropriate struct fields.

LANGUAGE: go
CODE:
package code

import (
	"context"
	__api "encore.dev/appruntime/apisdk/api"
	__etype "encore.dev/appruntime/shared/etype"
	jsoniter "github.com/json-iterator/go"
	"net/http"
	"net/textproto"
	"net/url"
)

func init() {
	__api.RegisterEndpoint(EncoreInternal_api_APIDesc_Foo, Foo)
}

type EncoreInternal_FooReq struct {
	Payload *Params
}

type EncoreInternal_FooResp = __api.Void

var EncoreInternal_api_APIDesc_Foo = &__api.Desc[*EncoreInternal_FooReq, EncoreInternal_FooResp]{
	Access: __api.Public,
	AppHandler: func(ctx context.Context, reqData *EncoreInternal_FooReq) (EncoreInternal_FooResp, error) {
		err := Foo(ctx, reqData.Payload)
		if err != nil {
			return __api.Void{}, err
		}
		return __api.Void{}, nil
	},
	CloneReq: func(r *EncoreInternal_FooReq) (*EncoreInternal_FooReq, error) {
		var clone *EncoreInternal_FooReq
		bytes, err := jsoniter.ConfigDefault.Marshal(r)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return clone, err
	},
	CloneResp: func(r EncoreInternal_FooResp) (EncoreInternal_FooResp, error) {
		var clone EncoreInternal_FooResp
		bytes, err := jsoniter.ConfigDefault.Marshal(r)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return clone, err
	},
	DecodeExternalResp: func(httpResp *http.Response, json jsoniter.API) (resp EncoreInternal_FooResp, err error) {
		return __api.Void{}, nil
	},
	DecodeReq: func(httpReq *http.Request, ps __api.UnnamedParams, json jsoniter.API) (reqData *EncoreInternal_FooReq, pathParams __api.UnnamedParams, err error) {
		reqData = new(EncoreInternal_FooReq)
		dec := new(__etype.Unmarshaller)
		params := new(Params)
		reqData.Payload = params
		switch m := httpReq.Method; m {
		case "POST":
			// Decode headers
			h := httpReq.Header
			params.Foo = __etype.UnmarshalOne(dec, __etype.UnmarshalString, "x-foo", h.Get("x-foo"), false)
			params.Strings = __etype.UnmarshalList(dec, __etype.UnmarshalString, "x-strings", h.Values("x-strings"), false)

		default:
			panic("HTTP method is not supported")
		}
		if err := dec.Error; err != nil {
			return nil, nil, err
		}
		return reqData, ps, nil
	},
	DefLoc: uint32(0x0),
	EncodeExternalReq: func(reqData *EncoreInternal_FooReq, stream *jsoniter.Stream) (httpHeader http.Header, queryString url.Values, err error) {
		params := reqData.Payload
		if params == nil {
			// If the payload is nil, we need to return an empty request body.
			return httpHeader, queryString, err
		}

		// Encode headers
		httpHeader = make(http.Header, 2)
		httpHeader.Set("x-foo", __etype.MarshalOne(__etype.MarshalString, params.Foo))
		httpHeader[textproto.CanonicalMIMEHeaderKey("x-strings")] = __etype.MarshalList(__etype.MarshalString, params.Strings)

		return httpHeader, queryString, err
	},
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, resp EncoreInternal_FooResp) (err error) {
		return nil
	},
	Endpoint:            "Foo",
	Fallback:            false,
	GlobalMiddlewareIDs: []string{},
	Methods:             []string{"POST"},
	Path:                "/code.Foo",
	PathParamNames:      nil,
	Raw:                 false,
	RawHandler:          nil,
	RawPath:             "/code.Foo",
	ReqPath: func(reqData *EncoreInternal_FooReq) (string, __api.UnnamedParams, error) {
		return "/code.Foo", nil, nil
	},
	ReqUserPayload: func(reqData *EncoreInternal_FooReq) any {
		return reqData.Payload
	},
	Service:           "code",
	ServiceMiddleware: []*__api.Middleware{},
	SvcNum:            1,
	Tags:              nil,
}

----------------------------------------

TITLE: Defining an API Endpoint in Encore
DESCRIPTION: An example of a private API endpoint in Encore that calls an external API to get pricing information. This endpoint would be a candidate for mocking during tests.

LANGUAGE: go
CODE:
//encore:api private
func GetPrice(ctx context.Context, p *PriceParams) (*PriceResponse, error) {
    // Call external API to get the price
}

----------------------------------------

TITLE: Getting Public URLs for Object Storage in Go
DESCRIPTION: Demonstrates how to obtain a public URL for an object in a public bucket using the PublicURL method. The URL can be used directly or shared publicly.

LANGUAGE: go
CODE:
// Get the public URL for an object
url := PublicAssets.PublicURL("path/to/image.jpg")

// The URL can be used directly or shared publicly
fmt.Println(url) // e.g. https://assets.example.com/path/to/image.jpg

----------------------------------------

TITLE: Getting Public URLs for Object Storage in Go
DESCRIPTION: Demonstrates how to obtain a public URL for an object in a public bucket using the PublicURL method. The URL can be used directly or shared publicly.

LANGUAGE: go
CODE:
// Get the public URL for an object
url := PublicAssets.PublicURL("path/to/image.jpg")

// The URL can be used directly or shared publicly
fmt.Println(url) // e.g. https://assets.example.com/path/to/image.jpg

----------------------------------------

TITLE: Implementing Metrics with Encore
DESCRIPTION: Defines a package that implements metrics using Encore's metrics package. Includes definitions for a simple gauge metric and a gauge with custom labels, along with a public API endpoint.

LANGUAGE: go
CODE:
package svc

import (
	"context"

	"encore.dev/metrics"
)

var Gauge = metrics.NewGauge[float64]("gauge", metrics.CounterConfig{})

type Labels struct {
	Label string // Label doc string.
}

var GaugeWithLabels = metrics.NewGaugeGroup[Labels, float64]("gauge_with_labels", metrics.CounterConfig{})

//encore:api public
func Foo(context.Context) error {
	return nil
}

----------------------------------------

TITLE: Generated Service Structure Registration
DESCRIPTION: Code that registers the service structure with the Encore runtime and associates it with the initialization function. This connects the service implementation to Encore's service discovery system.

LANGUAGE: go
CODE:
package code

import __service "encore.dev/appruntime/apisdk/service"

func init() {
	__service.Register(EncoreInternal_svcstruct_Service)
}

var EncoreInternal_svcstruct_Service = &__service.Decl[Service]{
	Name:        "Service",
	Service:     "code",
	Setup:       initService,
	SetupDefLoc: uint32(0x0),
}

----------------------------------------

TITLE: Creating a TypeScript Encore Application
DESCRIPTION: Command to create a new Encore application using the TypeScript introduction example template.

LANGUAGE: bash
CODE:
encore app create --example=ts/introduction

----------------------------------------

TITLE: Implementing Encore API Endpoint and Auth Handler
DESCRIPTION: Defines an Encore API endpoint using the //encore:api annotation and an authentication handler using //encore:authhandler. The implementation includes a simple API function and an auth handler function that returns authentication data.

LANGUAGE: go
CODE:
package code

import ("context"; "encore.dev/beta/auth")

//encore:api
func Foo(ctx context.Context) error { return nil }

type MyAuthData struct { Username string }

//encore:authhandler
func AuthHandler(context.Context, string) (auth.UID, *MyAuthData, error) {
    return "", nil, nil
}

----------------------------------------

TITLE: Exporting Constant in Bar Module
DESCRIPTION: Exports a constant named 'blah' with a value of 5 from the bar module.

LANGUAGE: typescript
CODE:
export const blah = 5;

----------------------------------------

TITLE: Logging out of Encore
DESCRIPTION: Logs out the currently authenticated user from Encore.

LANGUAGE: shell
CODE:
$ encore auth logout

----------------------------------------

TITLE: Tagging and Pushing Updated Docker Image
DESCRIPTION: Commands to tag and push the updated Docker image with database configuration to DigitalOcean's registry.

LANGUAGE: bash
CODE:
docker tag myapp registry.digitalocean.com/YOUR_REGISTRY_NAME/myapp:latest
docker push registry.digitalocean.com/YOUR_REGISTRY_NAME/myapp:latest

----------------------------------------

TITLE: Generated Encore Internal Auth Handler Implementation
DESCRIPTION: Auto-generated code by Encore that handles the integration of the auth handler with the framework. It includes token extraction from HTTP headers and registration of the auth handler with the API system.

LANGUAGE: go
CODE:
package basic

import (
	"context"
	__api "encore.dev/appruntime/apisdk/api"
	__model "encore.dev/appruntime/exported/model"
	errs "encore.dev/beta/errs"
	"net/http"
	"strings"
)

var EncoreInternal_authhandler_AuthDesc_AuthHandler = &__api.AuthHandlerDesc[string]{
	AuthHandler: func(ctx context.Context, params string) (info __model.AuthInfo, err error) {
		info.UID, err = AuthHandler(ctx, params)
		return info, err
	},
	DecodeAuth: func(httpReq *http.Request) (params string, err error) {
		if auth := httpReq.Header.Get("Authorization"); auth != "" {
			for _, prefix := range [...]string{"Bearer ", "Token "} {
				if strings.HasPrefix(auth, prefix) {
					if params = auth[len(prefix):]; params != "" {
						return params, nil
					}
				}
			}
		}
		return "", errs.B().Code(errs.Unauthenticated).Msg("invalid auth param").Err()
	},
	DefLoc:      uint32(0x0),
	Endpoint:    "AuthHandler",
	HasAuthData: false,
	Service:     "basic",
	SvcNum:      1,
}

func init() {
	__api.RegisterAuthHandler(EncoreInternal_authhandler_AuthDesc_AuthHandler)
}

----------------------------------------

TITLE: Defining and Accessing Secrets Structure in Go
DESCRIPTION: Defines a package-level variable 'secrets' as an anonymous struct with a string field 'Foo'. The init function demonstrates how to access the 'Foo' field and how to use the entire secrets struct.

LANGUAGE: go
CODE:
package svc

var secrets struct {
    Foo string
}

func init() {
    secrets.Foo // use svc.secrets field Foo
    x := secrets // use svc.secrets other
}

----------------------------------------

TITLE: Generated Encore Service Interface for Mocking
DESCRIPTION: This auto-generated file defines an Interface for the service API to facilitate mocking in tests. It includes the Foo method signature that matches the original API function, excluding raw endpoints which are not supported for service-to-service calls.

LANGUAGE: go
CODE:
// Code generated by encore. DO NOT EDIT.

package code

import "context"

// These functions are automatically generated and maintained by Encore
// to simplify calling them from other services, as they were implemented as methods.
// They are automatically updated by Encore whenever your API endpoints change.

// Interface defines the service's API surface area, primarily for mocking purposes.
//
// Raw endpoints are currently excluded from this interface, as Encore does not yet
// support service-to-service API calls to raw endpoints.
type Interface interface {
	Foo(ctx context.Context) (*Response, error)
}

----------------------------------------

TITLE: Defining Public API Function with Encore Annotation in Go
DESCRIPTION: This snippet defines a public API endpoint using the encore:api directive. It includes a Response struct with both exported and unexported fields, and a function Foo that returns a Response pointer or an error.

LANGUAGE: go
CODE:
package code

import "context"

type Response struct {
    Exported bool
    unexported string
}

//encore:api public
func Foo(ctx context.Context) (*Response, error) { return nil, nil }

----------------------------------------

TITLE: Service Package Declaration with Imports
DESCRIPTION: Declares the svc package and imports necessary dependencies including context, time, Encore config package, and UUID type from Encore.

LANGUAGE: go
CODE:
package svc

import (
	"context"
    "time"

	"encore.dev/config"
	"encore.dev/types/uuid"
)

----------------------------------------

TITLE: Creating a New Encore App with CLI
DESCRIPTION: Command to create a new Encore application using the Encore CLI, selecting the Hello World template.

LANGUAGE: bash
CODE:
encore app create myapp

----------------------------------------

TITLE: Creating SQL Migrations for Sequelize Models
DESCRIPTION: This is an example SQL migration file for creating a 'user' table to be used with Sequelize. Since Encore doesn't support JavaScript migration files generated by sequelize-cli, migrations need to be created manually in SQL format.

LANGUAGE: sql
CODE:
-- migrations/1_create_user.up.sql --
CREATE TABLE "user" (
  id SERIAL PRIMARY KEY,
  name TEXT NOT NULL,
  surname TEXT NOT NULL
);

----------------------------------------

TITLE: Testing Auth Propagation to API Calls in Encore
DESCRIPTION: Tests that overridden authentication data properly propagates to API calls. It verifies behavior before and after setting auth data to ensure API calls reflect the correct authentication context.

LANGUAGE: go
CODE:
func TestOverrideAuthInfo_PropagatesToAPICalls(t *testing.T) {
    resp, err := GetUser(context.Background())
    if err != nil {
        t.Fatal(err)
    } else if resp.Data != nil {
        t.Fatalf("got data %+v, want nil", resp.Data)
    }

    et.OverrideAuthInfo("foo", &AuthData{"email"})

    resp, err = GetUser(context.Background())
    if err != nil {
        t.Fatal(err)
    } else if resp.Data == nil || resp.Data.Email != "email" {
        t.Fatalf("got data %+v, want %+v", resp.Data, &AuthData{"email"})
    }
}

----------------------------------------

TITLE: Configuring Atlas for ent Schema Migrations
DESCRIPTION: Atlas configuration file that defines how to generate migrations from the ent schema.

LANGUAGE: hcl
CODE:
-- user/atlas.hcl --
env "local" {
  src = "ent://ent/schema"

  migration {
    dir = "file://migrations"
    format = golang-migrate
  }

  format {
    migrate {
      diff = "{{ sql . \"  \" }}"
    }
  }
}

----------------------------------------

TITLE: Generated Encore internal API handling code
DESCRIPTION: Auto-generated internal code that implements HTTP handling, request/response marshaling, and API registration for the service. This file provides the complete runtime implementation for the API endpoint including request parsing, parameter mapping, and response encoding.

LANGUAGE: go
CODE:
package basic

import (
	"context"
	__api "encore.dev/appruntime/apisdk/api"
	__etype "encore.dev/appruntime/shared/etype"
	jsoniter "github.com/json-iterator/go"
	"net/http"
	"net/url"
	"strings"
)

func init() {
	__api.RegisterEndpoint(EncoreInternal_api_APIDesc_Foo, Foo)
}

type EncoreInternal_FooReq struct {
	Payload *Params
}

type EncoreInternal_FooResp = __api.Void

var EncoreInternal_api_APIDesc_Foo = &__api.Desc[*EncoreInternal_FooReq, EncoreInternal_FooResp]{
	Access: __api.Public,
	AppHandler: func(ctx context.Context, reqData *EncoreInternal_FooReq) (EncoreInternal_FooResp, error) {
		err := Foo(ctx, reqData.Payload)
		if err != nil {
			return __api.Void{}, err
		}
		return __api.Void{}, nil
	},
	CloneReq: func(r *EncoreInternal_FooReq) (*EncoreInternal_FooReq, error) {
		var clone *EncoreInternal_FooReq
		bytes, err := jsoniter.ConfigDefault.Marshal(r)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return clone, err
	},
	CloneResp: func(r EncoreInternal_FooResp) (EncoreInternal_FooResp, error) {
		var clone EncoreInternal_FooResp
		bytes, err := jsoniter.ConfigDefault.Marshal(r)
		if err == nil {
			err = jsoniter.ConfigDefault.Unmarshal(bytes, &clone)
		}
		return clone, err
	},
	DecodeExternalResp: func(httpResp *http.Response, json jsoniter.API) (resp EncoreInternal_FooResp, err error) {
		return __api.Void{}, nil
	},
	DecodeReq: func(httpReq *http.Request, ps __api.UnnamedParams, json jsoniter.API) (reqData *EncoreInternal_FooReq, pathParams __api.UnnamedParams, err error) {
		reqData = new(EncoreInternal_FooReq)
		dec := new(__etype.Unmarshaller)
		params := new(Params)
		reqData.Payload = params
		switch m := httpReq.Method; m {
		case "POST":
			// Decode request body
			payload := dec.ReadBody(httpReq.Body)
			iter := jsoniter.ParseBytes(json, payload)

			for iter.ReadObjectCB(func(_ *jsoniter.Iterator, key string) bool {
				switch strings.ToLower(key) {
				case "x":
					dec.ParseJSON("X", iter, &params.X)
				case "int":
					dec.ParseJSON("Integer", iter, &params.Integer)
				default:
					_ = iter.SkipAndReturnBytes()
				}
				return true
			}) {
			}

		default:
			panic("HTTP method is not supported")
		}
		if err := dec.Error; err != nil {
			return nil, nil, err
		}
		return reqData, ps, nil
	},
	DefLoc: uint32(0x0),
	EncodeExternalReq: func(reqData *EncoreInternal_FooReq, stream *jsoniter.Stream) (httpHeader http.Header, queryString url.Values, err error) {
		params := reqData.Payload
		if params == nil {
			// If the payload is nil, we need to return an empty request body.
			return httpHeader, queryString, err
		}

		// Encode request body
		stream.WriteObjectStart()
		if true {
			// X is set to omitempty, so we need to check if it's empty before writing it
			stream.WriteObjectField("x")
			stream.WriteVal(params.X)
			stream.WriteMore()
		}
		if params.Integer != 0 {
			// Integer is set to omitempty, so we need to check if it's empty before writing it
			stream.WriteObjectField("int")
			stream.WriteVal(params.Integer)
		}
		stream.WriteObjectEnd()

		return httpHeader, queryString, err
	},
	EncodeResp: func(w http.ResponseWriter, json jsoniter.API, resp EncoreInternal_FooResp) (err error) {
		return nil
	},
	Endpoint:            "Foo",
	Fallback:            false,
	GlobalMiddlewareIDs: []string{},
	Methods:             []string{"POST"},
	Path:                "/basic.Foo",
	PathParamNames:      nil,
	Raw:                 false,
	RawHandler:          nil,
	RawPath:             "/basic.Foo",
	ReqPath: func(reqData *EncoreInternal_FooReq) (string, __api.UnnamedParams, error) {
		return "/basic.Foo", nil, nil
	},
	ReqUserPayload: func(reqData *EncoreInternal_FooReq) any {
		return reqData.Payload
	},
	Service:           "basic",
	ServiceMiddleware: []*__api.Middleware{},
	SvcNum:            1,
	Tags:              nil,
}

----------------------------------------

TITLE: Building a Docker Image for Encore App
DESCRIPTION: Command to build a Docker image from an Encore application for deployment to DigitalOcean.

LANGUAGE: bash
CODE:
encore build docker myapp

----------------------------------------

TITLE: Implementing Authentication API in Encore
DESCRIPTION: Defines a GetUser API endpoint that returns the authenticated user ID. Uses Encore's auth package to access the current user ID from the context.

LANGUAGE: go
CODE:
package svc

import (
    "context"
    "encore.dev/beta/auth"
)

type Response struct {
    UserID auth.UID
}

//encore:api public
func GetUser(ctx context.Context) (*Response, error) {
    uid, _ := auth.UserID()
    return &Response{UserID: uid}, nil
}

----------------------------------------

TITLE: Selectively Re-exporting from a Module in TypeScript
DESCRIPTION: Demonstrates selective re-export of the 'foo' export from the './foo' module. This pattern allows for controlling which exports are publicly exposed from imported modules.

LANGUAGE: typescript
CODE:
export { foo } from "./foo";

----------------------------------------

TITLE: Tagging Docker Image for DigitalOcean Registry
DESCRIPTION: Command to tag a Docker image to match DigitalOcean's registry URL format for pushing.

LANGUAGE: bash
CODE:
docker tag myapp registry.digitalocean.com/YOUR_REGISTRY_NAME/myapp:latest

----------------------------------------

TITLE: Making Script Executable and Generating Initial Migration
DESCRIPTION: Shell commands to make the migration script executable and run it to generate the initial migration.

LANGUAGE: shell
CODE:
$ chmod +x user/scripts/generate-migration
$ cd user && ./scripts/generate-migration init

----------------------------------------

TITLE: Testing Authenticated and Unauthenticated Requests in Encore
DESCRIPTION: Shell commands demonstrating how to test API requests with and without platform authentication, showing the difference in idempotency key handling based on authentication status.

LANGUAGE: shell
CODE:
# Authenticated requests should return the execution id
call GET X-Encore-Cron-Execution=foo /svc.CurrentRequest ''
checkresp '{"Path": "/svc.CurrentRequest", "IdempotencyKey": "foo"}'

# Unauthenticated requests should return the empty string
call GET X-Encore-Cron-Execution=foo /svc.CurrentRequest '' no-platform-auth
checkresp '{"Path": "/svc.CurrentRequest", "IdempotencyKey": ""}'

----------------------------------------

TITLE: Defining an Encore Service Package with Configuration Structure
DESCRIPTION: Defines a Go package for an Encore service, including imports for context, time, and Encore-specific packages. The code also defines a Config structure for configuration management with support for different data types.

LANGUAGE: Go
CODE:
package svc

import (
	"context"
    "time"

	"encore.dev/config"
	"encore.dev/types/uuid"
)

type Config struct {
    Ages      []int32
    OtherBits []string
}

----------------------------------------

TITLE: Structuring an Encore Application Directory
DESCRIPTION: Example directory structure for an Encore application showing the required file placement, including the encore.app file, service folders, and database migrations.

LANGUAGE: plaintext
CODE:
/my-app
├── encore.app                       // ... and other top-level project files
│
└── hello                            // hello service (a Go package)
    ├── migrations                   // hello service db migrations (directory)
    │   └── 1_create_table.up.sql    // hello service db migration
    ├── hello.go                     // hello service code
    └── hello_test.go                // tests for hello service

----------------------------------------

TITLE: Enabling Telemetry Debug Mode
DESCRIPTION: Shows how to enable debug mode for telemetry by setting the ENCORE_TELEMETRY_DEBUG environment variable, which will print log statements whenever telemetry data is sent.

LANGUAGE: sh
CODE:
export ENCORE_TELEMETRY_DEBUG=1

----------------------------------------

TITLE: Creating a StreamOut API for Log Streaming
DESCRIPTION: Implementation of a StreamOut API endpoint that sends data streams to clients. This example demonstrates server-to-client streaming with mocked log data and includes a generator function that yields log entries.

LANGUAGE: typescript
CODE:
import { api, StreamOut } from "encore.dev/api";
import log from "encore.dev/log";

// Used to pass initial data, optional.
interface Handshake {
  rows: number;
}

// What the server sends over the stream.
interface Message {
  row: string;
}

export const logStream = api.streamOut<Handshake, Message>(
  { path: "/logs", expose: true },
  async (handshake, stream) => {
    try {
      for await (const row of mockedLogs(handshake.rows, stream)) {
        // Send the message to the client
        await stream.send({ row });
      }
    } catch (err) {
      log.error("Upload error:", err);
    }
  },
);

// This function generates an async iterator that yields mocked log rows
async function* mockedLogs(rows: number, stream: StreamOut<Message>) {
  for (let i = 0; i < rows; i++) {
    yield new Promise<string>((resolve) => {
      setTimeout(() => {
        resolve(`Log row ${i + 1}`);
      }, 500);
    });
  }

  // Close the stream when all logs have been sent
  await stream.close();
}

----------------------------------------

TITLE: Creating a StreamOut API for Log Streaming
DESCRIPTION: Implementation of a StreamOut API endpoint that sends data streams to clients. This example demonstrates server-to-client streaming with mocked log data and includes a generator function that yields log entries.

LANGUAGE: typescript
CODE:
import { api, StreamOut } from "encore.dev/api";
import log from "encore.dev/log";

// Used to pass initial data, optional.
interface Handshake {
  rows: number;
}

// What the server sends over the stream.
interface Message {
  row: string;
}

export const logStream = api.streamOut<Handshake, Message>(
  { path: "/logs", expose: true },
  async (handshake, stream) => {
    try {
      for await (const row of mockedLogs(handshake.rows, stream)) {
        // Send the message to the client
        await stream.send({ row });
      }
    } catch (err) {
      log.error("Upload error:", err);
    }
  },
);

// This function generates an async iterator that yields mocked log rows
async function* mockedLogs(rows: number, stream: StreamOut<Message>) {
  for (let i = 0; i < rows; i++) {
    yield new Promise<string>((resolve) => {
      setTimeout(() => {
        resolve(`Log row ${i + 1}`);
      }, 500);
    });
  }

  // Close the stream when all logs have been sent
  await stream.close();
}

----------------------------------------

TITLE: Customizing Encore Docker Image Builds with CLI Options
DESCRIPTION: Examples of using the 'encore build docker' command with various options to customize builds. Shows how to specify services and gateways to include, and how to use a custom base image.

LANGUAGE: bash
CODE:
# Build specific services and gateways
encore build docker --services=service1,service2 --gateways=api-gateway MY-IMAGE:TAG

# Customize the base image
encore build docker --base=node:18-alpine MY-IMAGE:TAG

----------------------------------------

TITLE: Implementing Public API Function in Encore
DESCRIPTION: Defines a simple public API endpoint called Foo that takes FooParams and returns no data. The function is annotated with the encore:api directive to expose it as a public endpoint.

LANGUAGE: go
CODE:
type FooParams struct{}

//encore:api public
func Foo(ctx context.Context, p *FooParams) error { return nil }

----------------------------------------

TITLE: Updating Encore CLI
DESCRIPTION: Checks for an update of the Encore CLI and, if available, runs the appropriate command to update it.

LANGUAGE: shell
CODE:
$ encore version update

----------------------------------------

TITLE: Generating API Clients with Encore CLI
DESCRIPTION: Examples of how to use the 'encore gen client' command to generate different types of API clients for an Encore application. Shows options for TypeScript, Go, and OpenAPI clients with various environment configurations.

LANGUAGE: shell
CODE:
# Generate a TypeScript client for calling the hello-a8bc application based on the primary environment
encore gen client hello-a8bc --output=./client.ts

# Generate a Go client for the hello-a8bc application based on the locally running code
encore gen client hello-a8bc --output=./client.go --env=local

# Generate an OpenAPI client for the hello-a8bc application based on the primary environment
encore gen client hello-a8bc --lang=openapi --output=./openapi.json

----------------------------------------

TITLE: Installing Knex.js and PostgreSQL Dependencies
DESCRIPTION: Shell command to install Knex.js ORM library and PostgreSQL client for database operations.

LANGUAGE: shell
CODE:
$ npm i knex pg

----------------------------------------

TITLE: Auto-generated Service Interface for Encore API
DESCRIPTION: This is automatically generated code that defines a service interface for the Encore API. It provides an interface that can be used for mocking and service-to-service calls. The code is generated based on the API endpoints defined in the service.

LANGUAGE: go
CODE:
// Code generated by encore. DO NOT EDIT.

package code

import "context"

// These functions are automatically generated and maintained by Encore
// to simplify calling them from other services, as they were implemented as methods.
// They are automatically updated by Encore whenever your API endpoints change.

// Interface defines the service's API surface area, primarily for mocking purposes.
//
// Raw endpoints are currently excluded from this interface, as Encore does not yet
// support service-to-service API calls to raw endpoints.
type Interface interface {
	Foo(ctx context.Context, fallback string) error
}

----------------------------------------

TITLE: Logging into DigitalOcean Container Registry
DESCRIPTION: Command to authenticate with the DigitalOcean container registry using the DigitalOcean CLI.

LANGUAGE: bash
CODE:
doctl registry login

----------------------------------------

TITLE: Creating a Fallback Route for Static Files at Root Path in Encore.ts
DESCRIPTION: Implementation of a fallback route for serving static files at the root of a domain. Using the !path syntax ensures this route only gets called when no other API endpoint matches the request path.

LANGUAGE: typescript
CODE:
import { api } from "encore.dev/api";

export const assets = api.static(
  { expose: true, path: "/!path", dir: "./assets" },
);

----------------------------------------

TITLE: Creating a Fallback Route for Static Files at Root Path in Encore.ts
DESCRIPTION: Implementation of a fallback route for serving static files at the root of a domain. Using the !path syntax ensures this route only gets called when no other API endpoint matches the request path.

LANGUAGE: typescript
CODE:
import { api } from "encore.dev/api";

export const assets = api.static(
  { expose: true, path: "/!path", dir: "./assets" },
);

----------------------------------------

TITLE: Defining OAuth Token Response Structure in TypeScript
DESCRIPTION: Describes the structure of the OAuth token response which includes the access token, expiration time, actor information, and token type. The access token expires after 3600 seconds (1 hour) and should be used as a Bearer token in the Authorization header.

LANGUAGE: typescript
CODE:
type Token = {
  // The access token itself.
  "access_token": string;

  // The access token expires after 1 hour (3600 seconds).
  "expires_in": 3600;

  // The actor the token belongs to, in this case the OAuth2 client id.
  actor: string;


  // Indicates the access token should be passed as a "Bearer" token in the Authorization header.
  "token_type": "Bearer";
}

----------------------------------------

TITLE: Implementing Raw HTTP Endpoints in Encore.ts
DESCRIPTION: Creates a lower-level HTTP endpoint using api.raw for direct access to request and response objects. Useful for custom HTTP handling like webhooks or specialized response formatting.

LANGUAGE: typescript
CODE:
import { api } from "encore.dev/api";
export const myRawEndpoint = api.raw(
{ expose: true, path: "/raw", method: "GET" },
async (req, resp) => {
resp.writeHead(200, { "Content-Type": "text/plain" });
resp.end("Hello, raw world!");
}
);

----------------------------------------

TITLE: Implementing Raw HTTP Endpoints in Encore.ts
DESCRIPTION: Creates a lower-level HTTP endpoint using api.raw for direct access to request and response objects. Useful for custom HTTP handling like webhooks or specialized response formatting.

LANGUAGE: typescript
CODE:
import { api } from "encore.dev/api";
export const myRawEndpoint = api.raw(
{ expose: true, path: "/raw", method: "GET" },
async (req, resp) => {
resp.writeHead(200, { "Content-Type": "text/plain" });
resp.end("Hello, raw world!");
}
);

----------------------------------------

TITLE: Defining Rollout Trigger Request Body in TypeScript
DESCRIPTION: Describes the JSON request body structure for triggering a rollout, which requires either a commit SHA or branch name. This schema is used when making a POST request to trigger a new rollout for an Encore application in a specific environment.

LANGUAGE: typescript
CODE:
{
  // The commit hash to trigger a deploy for.
  "sha": string;
} | {
  // Name of the branch to trigger a deploy from.
  "branch": string;
}

----------------------------------------

TITLE: Installing Encore on macOS using Homebrew
DESCRIPTION: Command to install Encore on macOS systems using Homebrew package manager.

LANGUAGE: bash
CODE:
brew install encoredev/tap/encore

----------------------------------------

TITLE: Local Secret Override Configuration in CUE
DESCRIPTION: Example of how to override secrets locally using a CUE configuration file with custom values.

LANGUAGE: cue
CODE:
GitHubAPIToken: "my-local-override-token"
SSHPrivateKey: "custom-ssh-private-key"

----------------------------------------

TITLE: Creating a Bucket in Encore.ts
DESCRIPTION: Demonstrates how to create a storage bucket for profile pictures with the Encore.ts Object Storage API. Buckets must be declared as package level variables and can be configured with additional properties like versioning.

LANGUAGE: typescript
CODE:
import { Bucket } from "encore.dev/storage/objects";

export const profilePictures = new Bucket("profile-pictures", {
  versioned: false
});

----------------------------------------

TITLE: Creating a Bucket in Encore.ts
DESCRIPTION: Demonstrates how to create a storage bucket for profile pictures with the Encore.ts Object Storage API. Buckets must be declared as package level variables and can be configured with additional properties like versioning.

LANGUAGE: typescript
CODE:
import { Bucket } from "encore.dev/storage/objects";

export const profilePictures = new Bucket("profile-pictures", {
  versioned: false
});

----------------------------------------

TITLE: Type-Safe Service Mocking in Encore
DESCRIPTION: Demonstrates a type-safe approach to service mocking by implementing the service interface. This ensures compile-time type safety when mocking services for testing.

LANGUAGE: go
CODE:
type myMockObject struct{}

func (m *myMockObject) GetPrice(ctx context.Context, p *products.PriceParams) (*products.PriceResponse, error) {
    return &products.PriceResponse{Price: 100}, nil
}

func Test_Something(t *testing.T) {
    t.Parallel()
    et.MockService[products.Interface]("products", &myMockObject{})
}

----------------------------------------

TITLE: Defining an API Endpoint with Encore Annotation
DESCRIPTION: Creates a simple API endpoint using Encore's annotation system. The function takes a context parameter and returns an error, providing a basic template for an API handler.

LANGUAGE: go
CODE:
//encore:api
func MyAPI(ctx context.Context) (error) {
	return nil
}

----------------------------------------

TITLE: Re-enabling Telemetry via CLI Command
DESCRIPTION: A shell command that re-enables telemetry collection in Encore after it has been disabled. This allows users to opt back into the telemetry program if they change their mind.

LANGUAGE: sh
CODE:
encore telemetry enable

----------------------------------------

TITLE: Creating Encore Database Definition
DESCRIPTION: Go code snippet for creating a new Encore database with a migration directory specified.

LANGUAGE: go
CODE:
-- user/user.go --
package user

import "encore.dev/storage/sqldb"

var userDB = sqldb.NewDatabase("user", sqldb.DatabaseConfig{
	Migrations: "./migrations",
})

----------------------------------------

TITLE: Implementing a Generic Config Structure with Encore in Go
DESCRIPTION: Defines a generic Config structure that can work with any type parameter T. It includes a nested LibraryConfig and various config field types including Value, Values, and standard Go slices.

LANGUAGE: go
CODE:
package svc

import (
    "context"

    "encore.dev/config"

    "test/libraries/shared"
)

type Config[T any] struct {
    Library    shared.LibraryConfig
    OtherValue config.Value[T]
    NameList   config.Values[string]
    ValueList config.Value[[]T]
    List []T
}

var cfg = config.Load[Config[int]]()


// encore:api
func Subscriber1(ctx context.Context) error {
    return nil
}

----------------------------------------

TITLE: ServerOption JSON Unmarshaler Implementation in Go
DESCRIPTION: Generated unmarshal function for the ServerOption type that handles field-by-field JSON parsing. Directly maps JSON fields to their corresponding struct fields with appropriate type conversions.

LANGUAGE: go
CODE:
func encoreInternalTypeConfigUnmarshaler_svc_ServerOption(itr *jsoniter.Iterator, path []string) (obj ServerOption) {
	itr.ReadObjectCB(func(itr *jsoniter.Iterator, field string) bool {
		switch field {
		case "Option":
			obj.Option = itr.ReadInt64()
		case "Disabled":
			obj.Disabled = itr.ReadBool()
		default:
			itr.Skip()
		}
		return true
	})
	return
}

----------------------------------------

TITLE: Overlay Version of Main Go Application
DESCRIPTION: An overlay version of the main.go file that changes the output message to "Hello, rewritten world!".

LANGUAGE: go
CODE:
package main
func main() {
    println("Hello, rewritten world!")
}

----------------------------------------

TITLE: Running Custom Docker Image with Port Configuration
DESCRIPTION: This command demonstrates how to run the built Docker image with a custom port. The PORT environment variable is used to specify which port the application should listen on inside the container, and the port is mapped from the host to the container.

LANGUAGE: bash
CODE:
docker run -e PORT=8081 -p 8081:8081 MY-IMAGE:TAG

----------------------------------------

TITLE: Defining a Public API Endpoint in Encore
DESCRIPTION: This code defines a public API endpoint 'Foo' in the 'svc' package. It uses the encore:api annotation to make the function publicly accessible. The function takes a context and a parameter struct as input parameters.

LANGUAGE: go
CODE:
package svc

import (
    "context"
    "encore.dev/beta/auth"
)

type FooParams struct {
    Name string
}

//encore:api public
func Foo(ctx context.Context, p *FooParams) error { return nil }

----------------------------------------

TITLE: Defining Configuration in a Service with Encore
DESCRIPTION: Creates a Config struct and loads it using Encore's config.Load function within a service package. This establishes a service-scoped configuration that should only be accessed within this service.

LANGUAGE: go
CODE:
package svc

import (
    "context"

    "encore.dev/config"
)

type Config struct {
    FooEnabled bool
}

var Cfg = config.Load[Config]()


//encore:api
func Subscriber1(ctx context.Context) error {
    return nil
}

----------------------------------------

TITLE: Starting Encore VPN Connection
DESCRIPTION: Command to set up a secure VPN connection to private Encore environments.

LANGUAGE: bash
CODE:
encore vpn start

----------------------------------------

TITLE: Implementing Cron Jobs in Encore.ts
DESCRIPTION: Demonstrates how to create a scheduled cron job in Encore.ts by defining a CronJob that triggers an API endpoint at regular intervals.

LANGUAGE: TypeScript
CODE:
import { CronJob } from "encore.dev/cron";
import { api } from "encore.dev/api";

const _ = new CronJob("welcome-email", {
    title: "Send welcome emails",
    every: "2h",
    endpoint: sendWelcomeEmail,
})

export const sendWelcomeEmail = api({}, async () => {
    // Send welcome emails...
});

----------------------------------------

TITLE: Generated Encore service interface for API endpoints
DESCRIPTION: Auto-generated code that creates an interface for the service's API surface area. This interface is primarily used for mocking purposes and is automatically updated when API endpoints change.

LANGUAGE: go
CODE:
// Code generated by encore. DO NOT EDIT.

package basic

import "context"

// These functions are automatically generated and maintained by Encore
// to simplify calling them from other services, as they were implemented as methods.
// They are automatically updated by Encore whenever your API endpoints change.

// Interface defines the service's API surface area, primarily for mocking purposes.
//
// Raw endpoints are currently excluded from this interface, as Encore does not yet
// support service-to-service API calls to raw endpoints.
type Interface interface {
	Foo(ctx context.Context, p *Params) error
}

----------------------------------------

TITLE: Incorrect Cross-Service Configuration Access in Encore
DESCRIPTION: Demonstrates an incorrect pattern where a library tries to access a configuration defined in another service. This violates Encore's service boundaries for configuration and triggers an error.

LANGUAGE: go
CODE:
package foo

import (
    "test/svc"
)

func init() {
    if svc.Cfg.FooEnabled {
        // do something
    }
}

----------------------------------------

TITLE: Defining Time-Interval Based Cron Job in Go
DESCRIPTION: Creates a cron job named 'cron-every' that runs every 3 minutes instead of using a crontab schedule format. The job calls the CronAPI endpoint when triggered.

LANGUAGE: go
CODE:
// A cron job using Every instead of Schedule
var _ = cron.NewJob("cron-every", cron.JobConfig{
	Title:     "Cron Foo Bar Bazz",
	Every:    3 * cron.Minute,
	Endpoint: CronAPI,
})

----------------------------------------

TITLE: Defining Raw HTTP Endpoints with Custom Paths in Encore
DESCRIPTION: This code demonstrates defining HTTP endpoints in Encore using the 'raw' mode with custom path specifications. The example shows two endpoints: 'Foo' with a parameterized path '/:foo' and 'Bar' without a custom path. This leads to a path conflict error as shown in the test output.

LANGUAGE: go
CODE:
package svc

import "net/http"

//encore:api public raw path=/:foo
func Foo(w http.ResponseWriter, req *http.Request) { }

//encore:api public raw
func Bar(w http.ResponseWriter, req *http.Request) { }

----------------------------------------

TITLE: Using PubSub Topics in Go
DESCRIPTION: Demonstrates how to import and use the svc package to publish messages to the defined Topic. Shows two approaches: one correctly referencing the imported Topic and another incorrectly attempting to use an undefined Topic reference.

LANGUAGE: go
CODE:
package usage
import "example.com/svc"

var x = svc.Topic.Publish(svc.Message{}) // use svc.Topic call Publish
var y = Topic.Publish(svc.Message{})

----------------------------------------

TITLE: Testing Database Connection in Deployed App
DESCRIPTION: Command to test the database connection in the deployed application by calling the API endpoint.

LANGUAGE: bash
CODE:
curl https://myapp.ondigitalocean.app/names/1

----------------------------------------

TITLE: Creating PubSub Topic and Subscription with Missing Handler in Go
DESCRIPTION: This snippet demonstrates creating a PubSub topic and subscription in Encore, with an intentional error where the subscription lacks a required handler function. The code shows topic creation, subscription configuration, and a simple publisher function.

LANGUAGE: go
CODE:
package svc

import (
    "context"

    "encore.dev/pubsub"
)

type MessageType struct {
    Name string
}

var (
    BasicTopic = pubsub.NewTopic[*MessageType]("basic-topic", pubsub.TopicConfig{ DeliveryGuarantee: pubsub.AtLeastOnce })
    _ = pubsub.NewSubscription(BasicTopic, "basic-subscription", pubsub.SusbcriptionConfig{ Handler: nil })
)

// encore:api
func DoStuff(ctx context.Context) error {
    return BasicTopic.Publish(ctx, &MessageType{Name: "foo"})
}

func Subscriber(ctx context.Context, msg *MessageType) error {
    return nil
}

----------------------------------------

TITLE: Installing Encore CLI
DESCRIPTION: Command to install the Encore CLI, which is required for local development and running the development dashboard.

LANGUAGE: shell
CODE:
$ encore app create

----------------------------------------

TITLE: Modified Service File with Unmarshaler Reference
DESCRIPTION: The updated version of the service file with a modified config.Load call that includes the service name and a reference to the unmarshaler function. This modification is automatically applied by Encore to connect the configuration with its unmarshaling implementation.

LANGUAGE: go
CODE:
package svc

import (
	"context"

	"encore.dev/config"
)

type ServerOption struct {
    Option   int64
    Disabled bool `cue:",opt"` // True if this is disabled
}

type Config struct {
    HTTP    ServerOption
    Another ServerOption
    TCP     ServerOption `cue:",opt"`
    GRPC    ServerOption `cue:",opt"`
}

var _ = config.Load[*Config]("svc", encoreInternalConfigUnmarshaler_ptr_svc_Config/*line :21:30*/)

//encore:api
func MyAPI(ctx context.Context) (error) {
	return nil
}

----------------------------------------

TITLE: JSON Response for NotFound Error
DESCRIPTION: The JSON response structure when Encore returns a NotFound error. Shows how the errs.Error structure is serialized with code, message, and details fields.

LANGUAGE: json
CODE:
{
    "code": "not_found",
    "message": "sprocket not found",
    "details": null
}

----------------------------------------

TITLE: JSON Response for NotFound Error
DESCRIPTION: The JSON response structure when Encore returns a NotFound error. Shows how the errs.Error structure is serialized with code, message, and details fields.

LANGUAGE: json
CODE:
{
    "code": "not_found",
    "message": "sprocket not found",
    "details": null
}

----------------------------------------

TITLE: Creating a Cache Cluster in Go with Encore
DESCRIPTION: Defines a library package that creates and exports a cache cluster using Encore's cache package. This cluster can be imported and used by other packages for keyspace creation.

LANGUAGE: go
CODE:
package lib

import (
    "context"

    "encore.dev/storage/cache"
)

var Cluster = cache.NewCluster("cluster", cache.ClusterConfig{})

----------------------------------------

TITLE: Generated Code: Loading Config with Pointer Type and Automatic Unmarshaler
DESCRIPTION: Shows the generated code for loading the Config struct with pointer type. The code includes an automatically added service name and unmarshaler function reference.

LANGUAGE: go
CODE:
package svc

import (
	"context"

	"encore.dev/config"
)

type Config struct {
    Name        string    // The users name
    Port        uint16
    ReadOnly    bool      // true if we're in read only mode
}

var _ = config.Load[*Config]("svc", encoreInternalConfigUnmarshaler_ptr_svc_Config/*line :15:30*/)

//encore:api
func MyAPI(ctx context.Context) (error) {
	return nil
}

----------------------------------------

TITLE: Enhanced Encore Service with Explicit Unmarshaler
DESCRIPTION: The Encore service with a more specific config.Load call that includes the service name and a reference to the generated unmarshaler function. This is likely the transformed version produced by Encore's build tooling.

LANGUAGE: go
CODE:
package svc

import (
	"context"
    "time"

	"encore.dev/config"
)

type Config struct {
    SomeTime time.Time
}

var _ = config.Load[*Config]("svc", encoreInternalConfigUnmarshaler_ptr_svc_Config/*line :14:30*/)

//encore:api
func MyAPI(ctx context.Context) (error) {
	return nil
}

----------------------------------------

TITLE: Example Telemetry Data Format in JSON
DESCRIPTION: Shows the structure of telemetry data sent from Encore, including event type, anonymous ID, and properties that track usage details without collecting sensitive information.

LANGUAGE: json
CODE:
{
    "event": "app.create",
    "anonymousId": "a-uuid-unique-for-the-installation",
    "properties": {
        "error": false,
        "lang": "go",
        "template": "graphql"
    }
}

----------------------------------------

TITLE: Generated Config Unmarshaler for Time Handling
DESCRIPTION: Automatically generated unmarshal functions for config handling with proper type conversion, specifically handling time.Time values. These functions are generated by Encore to enable type-safe configuration handling.

LANGUAGE: go
CODE:
package svc

import (
	__etype "encore.dev/appruntime/shared/etype"
	"fmt"
	jsoniter "github.com/json-iterator/go"
	"time"
)

/*
These functions are automatically generated and maintained by Encore to allow config values
to be unmarshalled into the correct types. They are not intended to be used directly. They
are automatically updated by Encore whenever you change the data types used within your
calls to config.Load[T]().
*/

// Concrete unmarshalers for all config.Load calls, including those using generic types.
// These instances are used directly by calls to `config.Load[T]()`.
var (
	encoreInternalConfigUnmarshaler_ptr_svc_Config = func(itr *jsoniter.Iterator, path []string) *Config {
		return func() *Config {
			// If the value is null, we return nil
			if itr.ReadNil() {
				return nil
			}

			// Otherwise we unmarshal the value and return a pointer to it
			obj := encoreInternalTypeConfigUnmarshaler_svc_Config(itr, append(path))
			return &obj
		}()
	}
)

// encoreInternalTypeConfigUnmarshaler_svc_Config will unmarshal the JSON representation into the given type, taking account for
// the `config.Value` dynamic functions.
func encoreInternalTypeConfigUnmarshaler_svc_Config(itr *jsoniter.Iterator, path []string) (obj Config) {
	itr.ReadObjectCB(func(itr *jsoniter.Iterator, field string) bool {
		switch field {
		case "SomeTime":
			obj.SomeTime = func() (rtn time.Time) {
				decoder := new(__etype.Unmarshaller)
				rtn = __etype.UnmarshalOne(decoder, __etype.UnmarshalTime, "value", itr.ReadString(), true)
				if err := decoder.Error; err != nil {
					panic(fmt.Sprintf("unable to decode the config: %v", err))
				}
				return
			}()
		default:
			itr.Skip()
		}
		return true
	})
	return
}

----------------------------------------

TITLE: Using Map Keys as Values in CUE Configuration
DESCRIPTION: Shows a technique for using map keys as field values to reduce duplication in configuration. This example defines server configurations where the map key is reused as the server name property.

LANGUAGE: cue
CODE:
// Define the type we want to use
#Server: {
	server: string
	port: int & > 1024
	enabled: bool | *true
}

// Specify that servers is a map of strings to #Server
// where they key we assign the variable Name
servers: [Name=string]: #Server & {
	// Then we union the key with the value of server
	server: Name
}

servers: {
	"Foo": {
        port: 8080
    },
    "Bar": {
        port:    8081
        enabled: false
    },
}

----------------------------------------

TITLE: Running Encore Application Commands
DESCRIPTION: Shell commands for running, shutting down, and checking logs in an Encore application. The commands run the app, shut it down, and verify that a specific log message appears.

LANGUAGE: bash
CODE:
run
shutdown
checklog '{"message": "shutting down"}'

----------------------------------------

TITLE: Adding Client Generation Scripts to package.json
DESCRIPTION: Configuration for package.json that adds scripts to easily generate Encore API clients for different environments.

LANGUAGE: json
CODE:
{
...
"scripts": {
    ...
    "generate-client:staging": "encore gen client <ENCORE-APP-ID> --output=./src/client.ts --env=staging",
    "generate-client:local": "encore gen client <ENCORE-APP-ID> --output=./src/client.ts --env=local"
  }
}

----------------------------------------

TITLE: Transformed Configuration Structure in Service B
DESCRIPTION: The transformed version of BsConfig with the service name and an internal unmarshaler function in the config.Load call.

LANGUAGE: go
CODE:
package svc

import (
	"encore.dev/config"
)

type BsConfig struct{
    Foo config.String // Some extra comment
}

var _ = config.Load[BsConfig]("svc", encoreInternalConfigUnmarshaler_svc_BsConfig/*line :11:31*/)

----------------------------------------

TITLE: Defining Database Schema with Drizzle in TypeScript
DESCRIPTION: Creates a database schema using Drizzle's pg-core module. This example defines a 'users' table with id, name, and unique email fields.

LANGUAGE: typescript
CODE:
// schema.ts
import * as p from "drizzle-orm/pg-core";

export const users = p.pgTable("users", {
  id: p.serial().primaryKey(),
  name: p.text(),
  email: p.text().unique(),
});

----------------------------------------

TITLE: Defining Database Schema with Drizzle in TypeScript
DESCRIPTION: Creates a database schema using Drizzle's pg-core module. This example defines a 'users' table with id, name, and unique email fields.

LANGUAGE: typescript
CODE:
// schema.ts
import * as p from "drizzle-orm/pg-core";

export const users = p.pgTable("users", {
  id: p.serial().primaryKey(),
  name: p.text(),
  email: p.text().unique(),
});

----------------------------------------

TITLE: Loading Configuration with Encore in Go
DESCRIPTION: Example of loading config using Encore's config.Load generic function. This demonstrates how to use generic types with the config loader to instantiate the configuration.

LANGUAGE: go
CODE:
var _ = config.Load[*Config]()

----------------------------------------

TITLE: Environment Reference Secrets Configuration for Encore
DESCRIPTION: JSON configuration for setting up application secrets in Encore applications using a single environment variable containing a JSON string of secret values.

LANGUAGE: json
CODE:
{
  "secrets": {
    "$env": "SECRET_JSON"
  }
}

----------------------------------------

TITLE: Environment Reference Secrets Configuration for Encore
DESCRIPTION: JSON configuration for setting up application secrets in Encore applications using a single environment variable containing a JSON string of secret values.

LANGUAGE: json
CODE:
{
  "secrets": {
    "$env": "SECRET_JSON"
  }
}

----------------------------------------

TITLE: Direct Secrets Configuration
DESCRIPTION: Configuration for application secrets with direct values or environment variable references. This approach allows defining individual secrets with their values or environment sources.

LANGUAGE: json
CODE:
{
  "secrets": {
    "API_TOKEN": "embedded-secret-value",
    "DB_PASSWORD": {
      "$env": "DB_PASSWORD"
    }
  }
}

----------------------------------------

TITLE: Creating the Outbox Database Table in SQL
DESCRIPTION: SQL migration script to create the outbox table required for the transactional outbox pattern. The table stores messages to be published, with columns for ID, topic, data payload (as JSONB), and insertion timestamp.

LANGUAGE: sql
CODE:
-- The database used must contain the below database table:
-- See https://pkg.go.dev/x.encore.dev/infra/pubsub/outbox#SQLDBStore
CREATE TABLE outbox (
    id BIGSERIAL PRIMARY KEY,
    topic TEXT NOT NULL,
    data JSONB NOT NULL,
    inserted_at TIMESTAMPTZ NOT NULL
);
CREATE INDEX outbox_topic_idx ON outbox (topic, id);

----------------------------------------

TITLE: Generated Service Interface for Encore API in Go
DESCRIPTION: Automatically generated code by Encore that defines a service interface for the API endpoint. This interface is primarily used for mocking purposes and is updated whenever API endpoints change.

LANGUAGE: go
CODE:
// Code generated by encore. DO NOT EDIT.

package code

import "context"

// These functions are automatically generated and maintained by Encore
// to simplify calling them from other services, as they were implemented as methods.
// They are automatically updated by Encore whenever your API endpoints change.

// Interface defines the service's API surface area, primarily for mocking purposes.
//
// Raw endpoints are currently excluded from this interface, as Encore does not yet
// support service-to-service API calls to raw endpoints.
type Interface interface {
	Foo(ctx context.Context, id int, baz string, p *Params) error
}

----------------------------------------

TITLE: Defining Configuration Structure in Service D
DESCRIPTION: Defines a DsConfig structure with a string configuration field. The structure includes an inline comment for the Foo field.

LANGUAGE: go
CODE:
package svc

import (
	"encore.dev/config"
)

type DsConfig struct{
    Foo config.String // Some extra comment
}

var _ = config.Load[DsConfig]()

----------------------------------------

TITLE: Basic Structured Logging in Encore with TypeScript
DESCRIPTION: Demonstrates how to use the basic logging functions to emit log messages with structured key-value pairs. The example shows info and error level logging with different parameter patterns.

LANGUAGE: typescript
CODE:
log.info("log message", {is_subscriber: true})
log.error(err, "something went terribly wrong!")

----------------------------------------

TITLE: SQL Migration for Creating Note Table
DESCRIPTION: SQL migration file that creates the note table with columns for ID (primary key), text content, and cover image URL.

LANGUAGE: sql
CODE:
CREATE TABLE note (
	id TEXT PRIMARY KEY,
	text TEXT,
	cover_url TEXT
);

----------------------------------------

TITLE: Service-Local Middleware with All Target in Encore
DESCRIPTION: Defines a service-local middleware in Encore that targets all APIs in the service. The middleware passes the request to the next handler without modification.

LANGUAGE: go
CODE:
//encore:middleware target=all
func AllInSvc(req middleware.Request, next middleware.Next) middleware.Response {
    return next(req)
}

----------------------------------------

TITLE: Defining Unsupported Query Parameter Types in Encore API
DESCRIPTION: This example defines an API endpoint that attempts to use a pointer to a struct as a parameter in a GET request, which is not supported in Encore. Complex types like pointers to structs can only be used in request bodies (POST/PUT methods) not in query parameters.

LANGUAGE: go
CODE:
package svc

import (
	"context"
	"encore.dev/types/uuid"
)

type Nested struct {
    Baz string
}

type Params struct {
    Foo uuid.UUID
    Bar *Nested
}

//encore:api public method=GET
func Str(ctx context.Context, p *Params) error { return nil }

----------------------------------------

TITLE: Updated Encore Configuration with Unmarshaler Reference
DESCRIPTION: Shows how Encore modifies the original code to inject the appropriate unmarshaler function into the config.Load call, creating a link between the configuration structure and its parsing logic.

LANGUAGE: go
CODE:
package helloworld

import (
    "context"
    "encore.dev/config"

    "example.com/pkg/temporal"
)

type Config struct {
	Temporal config.Value[temporal.ClientOptions]
}

var cfg = config.Load[Config]("helloworld", encoreInternalConfigUnmarshaler_examplecom_Config/*line :14:31*/)

// There must be an API endpoint to use config.Load.
//encore:api
func Dummy(context.Context) error { return nil }

----------------------------------------

TITLE: Creating a Configuration Structure for Encore Service
DESCRIPTION: Defines a Config struct for the service with a map field to store ages by string identifiers. This structure will be loaded through Encore's configuration system.

LANGUAGE: go
CODE:
type Config struct {
    Ages map[string]int
}

----------------------------------------

TITLE: Defining Configuration with Dynamic String and Int Values
DESCRIPTION: Creates an OtherConfig struct using the config package's dynamic types (String and Int). Loads the configuration using config.Load with the struct type.

LANGUAGE: go
CODE:
package svc

import (
	"encore.dev/config"
)

type OtherConfig struct{
    Foo config.String // Foo is great in Otherconfig
    Bar config.Int
}

var _ = config.Load[OtherConfig]()

----------------------------------------

TITLE: Creating Service-Level Global Middleware in Go
DESCRIPTION: Implements a service-level middleware that targets all API endpoints within the service. This middleware follows the standard Encore middleware pattern and passes the request through to the next handler.

LANGUAGE: go
CODE:
//encore:middleware target=all
func AllInSvc(req middleware.Request, next middleware.Next) middleware.Response {
    return next(req)
}

----------------------------------------

TITLE: Incorrect Multiple Auth Handler Definition in Go
DESCRIPTION: This snippet demonstrates the incorrect usage of defining multiple auth handlers in an Encore application. The code declares two auth handlers (MyAuth and MyAuth2) which violates Encore's constraint of allowing only one auth handler per application.

LANGUAGE: go
CODE:
package svc

import (
    "context"
    "encore.dev/beta/auth"
)

//encore:authhandler
func MyAuth(ctx context.Context, token string) (auth.UID, error) { return "", nil }

//encore:authhandler
func MyAuth2(ctx context.Context, token string) (auth.UID, error) { return "", nil }

----------------------------------------

TITLE: Linking an Encore Application with the Server
DESCRIPTION: Links an existing Encore application with the server using its app ID.

LANGUAGE: shell
CODE:
$ encore app link [app-id]

----------------------------------------

TITLE: Setting Up Encore Database Proxy
DESCRIPTION: Command to set up a local database connection proxy for Encore databases with optional environment specification.

LANGUAGE: bash
CODE:
encore db proxy [--env=name]

----------------------------------------

TITLE: Creating a CheckAll Endpoint for Multiple Site Monitoring
DESCRIPTION: This code defines a 'checkAll' endpoint that retrieves all tracked sites and checks their status in parallel using Promise.all and the previously defined doCheck function.

LANGUAGE: typescript
CODE:
// CheckAll checks all sites.
export const checkAll = api(
  { expose: true, method: "POST", path: "/check-all" },
  async (): Promise<void> => {
    const sites = await site.list();
    await Promise.all(sites.sites.map(doCheck));
  },
);

----------------------------------------

TITLE: Creating a CheckAll Endpoint for Multiple Site Monitoring
DESCRIPTION: This code defines a 'checkAll' endpoint that retrieves all tracked sites and checks their status in parallel using Promise.all and the previously defined doCheck function.

LANGUAGE: typescript
CODE:
// CheckAll checks all sites.
export const checkAll = api(
  { expose: true, method: "POST", path: "/check-all" },
  async (): Promise<void> => {
    const sites = await site.list();
    await Promise.all(sites.sites.map(doCheck));
  },
);

----------------------------------------

TITLE: Generated Service Interface for Testing
DESCRIPTION: Auto-generated interface that defines the service's API surface area, primarily used for mocking in tests. It captures the Foo endpoint's signature for service-to-service calls.

LANGUAGE: go
CODE:
// Interface defines the service's API surface area, primarily for mocking purposes.
//
// Raw endpoints are currently excluded from this interface, as Encore does not yet
// support service-to-service API calls to raw endpoints.
type Interface interface {
	Foo(ctx context.Context) (*Params, error)
}

----------------------------------------

TITLE: Installing Clerk SDK for Go
DESCRIPTION: Command to install the Clerk SDK for Go in your Encore application. This dependency is required to interact with Clerk's authentication services.

LANGUAGE: shell
CODE:
$ go get github.com/clerkinc/clerk-sdk-go/clerk

----------------------------------------

TITLE: Installing Clerk SDK for Go
DESCRIPTION: Command to install the Clerk SDK for Go in your Encore application. This dependency is required to interact with Clerk's authentication services.

LANGUAGE: shell
CODE:
$ go get github.com/clerkinc/clerk-sdk-go/clerk

----------------------------------------

TITLE: Defining a Public API Endpoint with Fallback Parameter in Encore
DESCRIPTION: This code defines a public API endpoint with a fallback route parameter. It uses Encore's comment-based API definition syntax to specify a public endpoint that captures anything after the '!' as a fallback parameter.

LANGUAGE: go
CODE:
package code

import "context"

//encore:api public path=/!fallback
func Foo(ctx context.Context, fallback string) error { return nil }

----------------------------------------

TITLE: Graceful Shutdown Configuration for Encore
DESCRIPTION: JSON configuration for controlling the graceful shutdown behavior of an Encore application, including specifying timeouts for different shutdown phases.

LANGUAGE: json
CODE:
{
  "graceful_shutdown": {
    "total": 30,
    "shutdown_hooks": 10,
    "handlers": 20
  }
}

----------------------------------------

TITLE: Graceful Shutdown Configuration for Encore
DESCRIPTION: JSON configuration for controlling the graceful shutdown behavior of an Encore application, including specifying timeouts for different shutdown phases.

LANGUAGE: json
CODE:
{
  "graceful_shutdown": {
    "total": 30,
    "shutdown_hooks": 10,
    "handlers": 20
  }
}

----------------------------------------

TITLE: Logging in to Encore
DESCRIPTION: Authenticates with Encore by logging in to your account.

LANGUAGE: shell
CODE:
$ encore auth login

----------------------------------------

TITLE: Listing Objects in a Storage Bucket
DESCRIPTION: Shows how to list objects in a storage bucket using the async iterator pattern. This allows for processing each entry as it's retrieved.

LANGUAGE: typescript
CODE:
for await (const entry of profilePictures.list({})) {
  // Process entry
}

----------------------------------------

TITLE: Listing Objects in a Storage Bucket
DESCRIPTION: Shows how to list objects in a storage bucket using the async iterator pattern. This allows for processing each entry as it's retrieved.

LANGUAGE: typescript
CODE:
for await (const entry of profilePictures.list({})) {
  // Process entry
}

----------------------------------------

TITLE: Auto-generated Config Unmarshaler for Encore
DESCRIPTION: Encore-generated code for unmarshaling JSON configuration into the Config struct. This complex code handles type conversion for all the config fields, including special types like time.Time, UUID, and byte arrays.

LANGUAGE: go
CODE:
var (
	encoreInternalConfigUnmarshaler_ptr_svc_Config = func(itr *jsoniter.Iterator, path []string) *Config {
		return func() *Config {
			// If the value is null, we return nil
			if itr.ReadNil() {
				return nil
			}

			// Otherwise we unmarshal the value and return a pointer to it
			obj := encoreInternalTypeConfigUnmarshaler_svc_Config(itr, append(path))
			return &obj
		}()
	}
)

----------------------------------------

TITLE: Defining Path Parameters in Encore.ts API Endpoints
DESCRIPTION: Shows how to define required path parameters in the request schema of an Encore.ts API endpoint. The parameter is parsed from the request URL and made available in the request object.

LANGUAGE: typescript
CODE:
import { api } from "encore.dev/api";

interface Request {
  // Required path parameter. Parsed from the request URL.
  id: string;
}

export const myEndpoint = api(
  { expose: true, method: "POST", path: "/user/:id" },
  async ({ id }: Request) => {
    // ...
  },
);

----------------------------------------

TITLE: Defining Path Parameters in Encore.ts API Endpoints
DESCRIPTION: Shows how to define required path parameters in the request schema of an Encore.ts API endpoint. The parameter is parsed from the request URL and made available in the request object.

LANGUAGE: typescript
CODE:
import { api } from "encore.dev/api";

interface Request {
  // Required path parameter. Parsed from the request URL.
  id: string;
}

export const myEndpoint = api(
  { expose: true, method: "POST", path: "/user/:id" },
  async ({ id }: Request) => {
    // ...
  },
);

----------------------------------------

TITLE: Overlaid Main Function
DESCRIPTION: Modified main.go file that calls a function defined in another overlay file.

LANGUAGE: go
CODE:
package main
func main() {
    OverlayPrint() // defined in overlay
}

----------------------------------------

TITLE: Helper Function in Sub-Package for Encore Service
DESCRIPTION: Shows implementation of a helper function in a sub-package that is used by the main service API. This demonstrates how to organize service logic across multiple files and packages.

LANGUAGE: go
CODE:
package foo

import (
	"fmt"
)

func GenerateMessage(name string) string {
	return fmt.Sprintf("Hello %s!", name)
}

----------------------------------------

TITLE: Helper Function in Sub-Package for Encore Service
DESCRIPTION: Shows implementation of a helper function in a sub-package that is used by the main service API. This demonstrates how to organize service logic across multiple files and packages.

LANGUAGE: go
CODE:
package foo

import (
	"fmt"
)

func GenerateMessage(name string) string {
	return fmt.Sprintf("Hello %s!", name)
}

----------------------------------------

TITLE: Implementing Cross-Service API Call in svcb Service
DESCRIPTION: Defines a public API endpoint in the svcb service that calls the Foo endpoint from the svca service.

LANGUAGE: go
CODE:
package svcb

import ("context"; "example.com/svca")

//encore:api public
func Baz(ctx context.Context) error { return svca.Foo(ctx) }

----------------------------------------

TITLE: Deploying Modified Code to API
DESCRIPTION: Example of calling the modified API endpoint after changing the greeting message.

LANGUAGE: shell
CODE:
$ curl http://localhost:4000/hello/world
{"Message": "Howdy, world!"}

----------------------------------------

TITLE: Auto-generated Encore Internal Authentication Implementation
DESCRIPTION: This auto-generated code implements the authentication handler integration with Encore's runtime. It includes functions for decoding authentication parameters from HTTP requests and registering the handler with the Encore framework.

LANGUAGE: go
CODE:
package code

import (
	"context"
	__api "encore.dev/appruntime/apisdk/api"
	__model "encore.dev/appruntime/exported/model"
	__etype "encore.dev/appruntime/shared/etype"
	errs "encore.dev/beta/errs"
	"net/http"
)

var EncoreInternal_authhandler_AuthDesc_AuthHandler = &__api.AuthHandlerDesc[*MyAuthParams]{
	AuthHandler: func(ctx context.Context, params *MyAuthParams) (info __model.AuthInfo, err error) {
		info.UID, err = AuthHandler(ctx, params)
		return info, err
	},
	DecodeAuth: func(httpReq *http.Request) (params *MyAuthParams, err error) {
		params = new(MyAuthParams)
		dec := new(__etype.Unmarshaller)
		// Decode headers
		h := httpReq.Header
		params.ClientID = __etype.UnmarshalOne(dec, __etype.UnmarshalString, "x-client-id", h.Get("x-client-id"), false)

		// Decode query string
		qs := httpReq.URL.Query()
		params.APIKey = __etype.UnmarshalOne(dec, __etype.UnmarshalString, "key", qs.Get("key"), false)

		// Decode cookies
		if c, _ := httpReq.Cookie("session_token"); c != nil {
			params.SessionToken = __etype.UnmarshalOne(dec, __etype.UnmarshalString, "session_token", c.Value, false)
		}
		if c, _ := httpReq.Cookie("other_cookie"); c != nil {
			params.OtherCookie = c
			dec.IncNonEmpty()
		}
		if c, _ := httpReq.Cookie("int_cookie"); c != nil {
			params.IntCookie = __etype.UnmarshalOne(dec, __etype.UnmarshalInt, "int_cookie", c.Value, false)
		}

		if dec.NonEmptyValues == 0 {
			return (*MyAuthParams)(nil), errs.B().Code(errs.Unauthenticated).Msg("missing auth param").Err()
		} else if err := dec.Error; err != nil {
			return (*MyAuthParams)(nil), errs.B().Code(errs.InvalidArgument).Msgf("invalid auth param: %v", err).Err()
		}
		return params, nil
	},
	DefLoc:      uint32(0x0),
	Endpoint:    "AuthHandler",
	HasAuthData: false,
	Service:     "code",
	SvcNum:      1,
}

func init() {
	__api.RegisterAuthHandler(EncoreInternal_authhandler_AuthDesc_AuthHandler)
}

----------------------------------------

TITLE: Auto-generated Configuration Unmarshaler for Encore in Go
DESCRIPTION: Implements type-safe JSON unmarshaling for configuration types. This file is automatically generated by Encore and contains functions to deserialize JSON into config structs from the main service and its dependencies.

LANGUAGE: go
CODE:
package svc

import (
	__etype "encore.dev/appruntime/shared/etype"
	config "encore.dev/config"
	helpers "example.com/svc/helpers"
	utils "example.com/svc/utils"
	"fmt"
	jsoniter "github.com/json-iterator/go"
)

/*
These functions are automatically generated and maintained by Encore to allow config values
to be unmarshalled into the correct types. They are not intended to be used directly. They
are automatically updated by Encore whenever you change the data types used within your
calls to config.Load[T]().
*/

// Concrete unmarshalers for all config.Load calls, including those using generic types.
// These instances are used directly by calls to `config.Load[T]()`.
var (
	encoreInternalConfigUnmarshaler_ptr_svc_Config = func(itr *jsoniter.Iterator, path []string) *Config {
		return func() *Config {
			// If the value is null, we return nil
			if itr.ReadNil() {
				return nil
			}

			// Otherwise we unmarshal the value and return a pointer to it
			obj := encoreInternalTypeConfigUnmarshaler_svc_Config(itr, append(path))
			return &obj
		}()
	}
)

// encoreInternalTypeConfigUnmarshaler_svc_Config will unmarshal the JSON representation into the given type, taking account for
// the `config.Value` dynamic functions.
func encoreInternalTypeConfigUnmarshaler_svc_Config(itr *jsoniter.Iterator, path []string) (obj Config) {
	itr.ReadObjectCB(func(itr *jsoniter.Iterator, field string) bool {
		switch field {
		case "A":
			obj.A = encoreInternalTypeConfigUnmarshaler_helpers_ExtraConfig(itr, append(path, "A"))
		case "B":
			obj.B = encoreInternalTypeConfigUnmarshaler_utils_ExtraConfig(itr, append(path, "B"))
		case "C":
			obj.C = encoreInternalTypeConfigUnmarshaler_helpers_ExtraConfig(itr, append(path, "C"))
		case "D":
			obj.D = encoreInternalTypeConfigUnmarshaler_utils_ExtraConfig(itr, append(path, "D"))
		case "E":
			obj.E = encoreInternalTypeConfigUnmarshaler_helpers_SingleUse(itr, append(path, "E"))
		default:
			itr.Skip()
		}
		return true
	})
	return
}

// encoreInternalTypeConfigUnmarshaler_helpers_ExtraConfig will unmarshal the JSON representation into the given type, taking account for
// the `config.Value` dynamic functions.
func encoreInternalTypeConfigUnmarshaler_helpers_ExtraConfig(itr *jsoniter.Iterator, path []string) (obj helpers.ExtraConfig) {
	itr.ReadObjectCB(func(itr *jsoniter.Iterator, field string) bool {
		switch field {
		case "Foo":
			obj.Foo = config.CreateValue[string](itr.ReadString(), append(path, "Foo"))
		case "Baz":
			obj.Baz = config.CreateValue[[]byte](func() (rtn []byte) {
				decoder := new(__etype.Unmarshaller)
				rtn = __etype.UnmarshalOne(decoder, __etype.UnmarshalBytes, "value", itr.ReadString(), true)
				if err := decoder.Error; err != nil {
					panic(fmt.Sprintf("unable to decode the config: %v", err))
				}
				return
			}(), append(path, "Baz"))
		default:
			itr.Skip()
		}
		return true
	})
	return
}

// encoreInternalTypeConfigUnmarshaler_helpers_SingleUse will unmarshal the JSON representation into the given type, taking account for
// the `config.Value` dynamic functions.
func encoreInternalTypeConfigUnmarshaler_helpers_SingleUse(itr *jsoniter.Iterator, path []string) (obj helpers.SingleUse) {
	itr.ReadObjectCB(func(itr *jsoniter.Iterator, field string) bool {
		switch field {
		case "Lock":
			obj.Lock = itr.ReadBool()
		default:
			itr.Skip()
		}
		return true
	})
	return
}

// encoreInternalTypeConfigUnmarshaler_utils_ExtraConfig will unmarshal the JSON representation into the given type, taking account for
// the `config.Value` dynamic functions.
func encoreInternalTypeConfigUnmarshaler_utils_ExtraConfig(itr *jsoniter.Iterator, path []string) (obj utils.ExtraConfig) {
	itr.ReadObjectCB(func(itr *jsoniter.Iterator, field string) bool {
		switch field {
		case "Foo":
			obj.Foo = config.CreateValue[string](itr.ReadString(), append(path, "Foo"))
		case "Bar":
			obj.Bar = config.CreateValue[int](itr.ReadInt(), append(path, "Bar"))
		default:
			itr.Skip()
		}
		return true
	})
	return
}

----------------------------------------

TITLE: Querying a Single Row by ID in TypeScript
DESCRIPTION: This function demonstrates how to query for a single row from a PostgreSQL database in Encore. It uses queryRow with a template literal to retrieve a todo's title by its ID.

LANGUAGE: typescript
CODE:
async function getTodoTitle(id: number): string | undefined {
  const row = await db.queryRow`SELECT title FROM todo_item WHERE id = ${id}`;
  return row?.title;
}

----------------------------------------

TITLE: Validating Array Fields in Encore.ts
DESCRIPTION: This example demonstrates how to validate arrays of different types (strings, numbers, booleans, nulls) in request schemas.

LANGUAGE: typescript
CODE:
interface Schema {
  strings:  string[];
  numbers:  number[];
  booleans:  boolean[];
  nulls: null[];
}

----------------------------------------

TITLE: Defining Database Service with Encore
DESCRIPTION: Sets up a named database connection using Encore's sqldb package and demonstrates various ways to use the database variable. Includes a dummy API endpoint to satisfy Encore's service requirements.

LANGUAGE: go
CODE:
package svc

import "context"
import "encore.dev/storage/sqldb"

var DB = sqldb.Named("svc")

func init() {
    DB.Foo() // use svc.DB call Foo
    DB.Foo // use svc.DB field Foo
    DB // use svc.DB other

    1 + DB // use svc.DB other
    x = DB // use svc.DB other
}

//encore:api public
func Dummy(context.Context) error { return nil }

----------------------------------------

TITLE: Defining a Minimal Service Struct in Go
DESCRIPTION: This snippet defines a bare-minimum service struct marked with the encore:service annotation. It demonstrates that the encore:service annotation on a struct is sufficient to create a service, even without any API endpoints defined.

LANGUAGE: go
CODE:
package foobar

import (
	"context"
)

//encore:service
type Service struct {}

----------------------------------------

TITLE: Creating SQL Databases with Migration Support in Encore
DESCRIPTION: Demonstrates how to create a SQL database in Encore with migration support. This includes defining the database connection and specifying the directory containing migration files for schema management.

LANGUAGE: go
CODE:
-- todo/db.go --
package todo

// Create the todo database and assign it to the "tododb" variable
var tododb = sqldb.NewDatabase("todo", sqldb.DatabaseConfig{
	Migrations: "./migrations",
})

// Then, query the database using db.QueryRow, db.Exec, etc.
-- todo/migrations/1_create_table.up.sql --
CREATE TABLE todo_item (
  id BIGSERIAL PRIMARY KEY,
  title TEXT NOT NULL,
  done BOOLEAN NOT NULL DEFAULT false
  -- etc...
);

----------------------------------------

TITLE: Implementing Slack notification API in Encore
DESCRIPTION: Creates an API endpoint to send Slack notifications. The implementation uses webhook URLs stored as secrets and handles error responses from the Slack API.

LANGUAGE: typescript
CODE:
import { api } from "encore.dev/api";
import { secret } from "encore.dev/config";
import log from "encore.dev/log";

export interface NotifyParams {
  text: string; // the slack message to send
}

// Sends a Slack message to a pre-configured channel using a
// Slack Incoming Webhook (see https://api.slack.com/messaging/webhooks).
export const notify = api<NotifyParams>({}, async ({ text }) => {
  const url = webhookURL();
  if (!url) {
    log.info("no slack webhook url defined, skipping slack notification");
    return;
  }

  const resp = await fetch(url, {
    method: "POST",
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({ content: text }),
  });
  if (resp.status >= 400) {
    const body = await resp.text();
    throw new Error(`slack notification failed: ${resp.status}: ${body}`);
  }
});

// SlackWebhookURL defines the Slack webhook URL to send uptime notifications to.
const webhookURL = secret("SlackWebhookURL");

----------------------------------------

TITLE: GitHub Actions Workflow for Docker Image Build and Push
DESCRIPTION: GitHub Actions workflow configuration to build an Encore application Docker image and push it to GitHub Container Registry. The workflow installs Encore CLI, builds the Docker image, and pushes it to the registry.

LANGUAGE: yaml
CODE:
name: Build, Push and Deploy a Docker Image to Railway

on:
  push:
    branches: [ main ]

permissions:
  contents: read
  packages: write

jobs:
  build-push-deploy-image:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Log in to the Container registry
        uses: docker/login-action@v3.3.0
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Download Encore CLI script
        uses: sozo-design/curl@v1.0.2
        with:
          args: --output install.sh -L https://encore.dev/install.sh

      - name: Install Encore CLI
        run: bash install.sh

      - name: Build Docker image
        run: /home/runner/.encore/bin/encore build --config railway-infra.config.json docker myapp

      - name: Tag Docker image
        run: docker tag myapp ghcr.io/${{ github.repository }}:latest

      - name: Push Docker image
        run: docker push ghcr.io/${{ github.repository }}:latest

----------------------------------------

TITLE: GitHub Actions Workflow for Docker Image Build and Push
DESCRIPTION: GitHub Actions workflow configuration to build an Encore application Docker image and push it to GitHub Container Registry. The workflow installs Encore CLI, builds the Docker image, and pushes it to the registry.

LANGUAGE: yaml
CODE:
name: Build, Push and Deploy a Docker Image to Railway

on:
  push:
    branches: [ main ]

permissions:
  contents: read
  packages: write

jobs:
  build-push-deploy-image:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Log in to the Container registry
        uses: docker/login-action@v3.3.0
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Download Encore CLI script
        uses: sozo-design/curl@v1.0.2
        with:
          args: --output install.sh -L https://encore.dev/install.sh

      - name: Install Encore CLI
        run: bash install.sh

      - name: Build Docker image
        run: /home/runner/.encore/bin/encore build --config railway-infra.config.json docker myapp

      - name: Tag Docker image
        run: docker tag myapp ghcr.io/${{ github.repository }}:latest

      - name: Push Docker image
        run: docker push ghcr.io/${{ github.repository }}:latest

----------------------------------------

TITLE: Defining Cron Job with Additional Variable Assignment in Go
DESCRIPTION: Creates a cron job named 'cronfood' that runs every Friday while also assigning a string value to another variable. This demonstrates how to combine cron job creation with other variable assignments.

LANGUAGE: go
CODE:
var _, bd = cron.NewJob("cronfood", cron.JobConfig{
	Title:     "Cron Food Bar",
	Schedule: "* * * * 5",
	Endpoint: CronAPI,
}), "barfoo"