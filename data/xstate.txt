TITLE: Implementing Guarded Transitions in XState
DESCRIPTION: This snippet demonstrates how to create a search machine with a guarded transition. It uses a condition function to determine if the transition to the 'searching' state should occur based on the context and event data.

LANGUAGE: javascript
CODE:
const searchValid = (context, event) => {
  return context.canSearch && event.query && event.query.length > 0;
};

const searchMachine = createMachine(
  {
    id: 'search',
    initial: 'idle',
    context: {
      canSearch: true
    },
    states: {
      idle: {
        on: {
          SEARCH: [
            {
              target: 'searching',
              // Only transition to 'searching' if the guard (cond) evaluates to true
              cond: searchValid // or { type: 'searchValid' }
            },
            { target: '.invalid' }
          ]
        },
        initial: 'normal',
        states: {
          normal: {},
          invalid: {}
        }
      },
      searching: {
        entry: 'executeSearch'
        // ...
      },
      searchError: {
        // ...
      }
    }
  },
  {
    guards: {
      searchValid // optional, if the implementation doesn't change
    }
  }
);

----------------------------------------

TITLE: Creating a Promise State Machine with XState
DESCRIPTION: Demonstrates how to create a state machine representing a Promise using XState's createMachine function. It defines states for pending, resolved, and rejected, with transitions between them.

LANGUAGE: javascript
CODE:
import { createMachine } from 'xstate';

const promiseMachine = createMachine({
  id: 'promise',
  initial: 'pending',
  states: {
    pending: {
      on: {
        RESOLVE: { target: 'resolved' },
        REJECT: { target: 'rejected' }
      }
    },
    resolved: {
      type: 'final'
    },
    rejected: {
      type: 'final'
    }
  }
});

----------------------------------------

TITLE: Interpreting and Running XState Machine in Node.js
DESCRIPTION: Shows how to interpret and run the XState machine in a Node.js or vanilla JavaScript environment using the interpret function. It demonstrates starting the service and sending events to it.

LANGUAGE: javascript
CODE:
import { createMachine, interpret } from 'xstate';

const promiseMachine = createMachine({
  /* ... */
});

const promiseService = interpret(promiseMachine).onTransition((state) =>
  console.log(state.value)
);

// Start the service
promiseService.start();
// => 'pending'

promiseService.send({ type: 'RESOLVE' });
// => 'resolved'

----------------------------------------

TITLE: Merging Contexts in XState JavaScript
DESCRIPTION: Demonstrates how to manually merge the original context with new values when using .withContext(), as the method doesn't perform a shallow merge by default.

LANGUAGE: javascript
CODE:
const testLightMachine = lightMachine.withContext({
  // merge with original context
  ...lightMachine.context,
  elapsed: 1000
});

----------------------------------------

TITLE: Using XState Machine in React Component
DESCRIPTION: Demonstrates how to use the XState machine within a React component using the useMachine hook from @xstate/react. It shows how to render different states and send events to the machine.

LANGUAGE: tsx
CODE:
import { useMachine } from '@xstate/react';

const Component = () => {
  const [state, send] = useMachine(promiseMachine);

  return (
    <div>
      {/** You can listen to what state the service is in */}
      {state.matches('pending') && <p>Loading...</p>}
      {state.matches('rejected') && <p>Promise Rejected</p>}
      {state.matches('resolved') && <p>Promise Resolved</p>}
      <div>
        {/** You can send events to the running service */}
        <button onClick={() => send('RESOLVE')}>Resolve</button>
        <button onClick={() => send('REJECT')}>Reject</button>
      </div>
    </div>
  );
};

----------------------------------------

TITLE: Persisting and Restoring State in XState
DESCRIPTION: Demonstrates how to persist a state object to JSON and restore it using State.create(). Also shows how to start an interpreted service from a restored state.

LANGUAGE: javascript
CODE:
const jsonState = JSON.stringify(currentState);

// Example: persisting to localStorage
try {
  localStorage.setItem('app-state', jsonState);
} catch (e) {
  // unable to save to localStorage
}

// Restoring state
import { State, interpret } from 'xstate';
import { myMachine } from '../path/to/myMachine';

const stateDefinition =
  JSON.parse(localStorage.getItem('app-state')) || myMachine.initialState;

const previousState = State.create(stateDefinition);

// Start service from restored state
const service = interpret(myMachine).start(previousState);

----------------------------------------

TITLE: Persisting and Restoring State in XState
DESCRIPTION: Demonstrates how to persist a state object to JSON and restore it using State.create(). Also shows how to start an interpreted service from a restored state.

LANGUAGE: javascript
CODE:
const jsonState = JSON.stringify(currentState);

// Example: persisting to localStorage
try {
  localStorage.setItem('app-state', jsonState);
} catch (e) {
  // unable to save to localStorage
}

// Restoring state
import { State, interpret } from 'xstate';
import { myMachine } from '../path/to/myMachine';

const stateDefinition =
  JSON.parse(localStorage.getItem('app-state')) || myMachine.initialState;

const previousState = State.create(stateDefinition);

// Start service from restored state
const service = interpret(myMachine).start(previousState);

----------------------------------------

TITLE: Using Multiple Guards in XState
DESCRIPTION: This example demonstrates how to use multiple guards in XState. It shows a door machine that transitions to different states based on multiple conditions, such as admin status and alert status.

LANGUAGE: javascript
CODE:
import { createMachine, actions, interpret, assign } from 'xstate';

const doorMachine = createMachine(
  {
    id: 'door',
    initial: 'closed',
    context: {
      level: 'user',
      alert: false // alert when intrusions happen
    },
    states: {
      closed: {
        initial: 'idle',
        states: {
          idle: {},
          error: {}
        },
        on: {
          SET_ADMIN: {
            actions: assign({ level: 'admin' })
          },
          SET_ALARM: {
            actions: assign({ alert: true })
          },
          OPEN: [
            // Transitions are tested one at a time.
            // The first valid transition will be taken.
            { target: 'opened', cond: 'isAdmin' },
            { target: '.error', cond: 'shouldAlert' },
            { target: '.idle' }
          ]
        }
      },
      opened: {
        on: {
          CLOSE: { target: 'closed' }
        }
      }
    }
  },
  {
    guards: {
      isAdmin: (context) => context.level === 'admin',
      shouldAlert: (context) => context.alert === true
    }
  }
);

const doorService = interpret(doorMachine)
  .onTransition((state) => console.log(state.value))
  .start();
// => { closed: 'idle' }

doorService.send({ type: 'OPEN' });
// => { closed: 'idle' }

doorService.send({ type: 'SET_ALARM' });
// => { closed: 'idle' }
// (state does not change, but context changes)

doorService.send({ type: 'OPEN' });
// => { closed: 'error' }

doorService.send({ type: 'SET_ADMIN' });
// => { closed: 'error' }
// (state does not change, but context changes)

doorService.send({ type: 'OPEN' });
// => 'opened'
// (since context.isAdmin === true)

----------------------------------------

TITLE: Defining Schema for XState Machine in TypeScript
DESCRIPTION: This snippet demonstrates how to define the schema for an XState machine, including context and events types. It shows the usage of the createMachine function with TypeScript types.

LANGUAGE: typescript
CODE:
import { createMachine } from 'xstate';

const lightMachine = createMachine({
  schema: {
    // The context (extended state) of the machine
    context: {} as { elapsed: number },
    // The events this machine handles
    events: {} as
      | { type: 'TIMER' }
      | { type: 'POWER_OUTAGE' }
      | { type: 'PED_COUNTDOWN'; duration: number }
  }
  /* Other config... */
});

----------------------------------------

TITLE: Creating a State Machine with XState in JavaScript
DESCRIPTION: This snippet demonstrates how to create a basic state machine using XState's createMachine() function. It includes machine identifier, initial state, context, and state definitions.

LANGUAGE: javascript
CODE:
import { createMachine } from 'xstate';

const lightMachine = createMachine({
  // Machine identifier
  id: 'light',

  // Initial state
  initial: 'green',

  // Local context for entire machine
  context: {
    elapsed: 0,
    direction: 'east'
  },

  // State definitions
  states: {
    green: {
      /* ... */
    },
    yellow: {
      /* ... */
    },
    red: {
      /* ... */
    }
  }
});

----------------------------------------

TITLE: Basic Context Modeling in XState
DESCRIPTION: Demonstrates how to create a basic user model with context and use it within a machine definition. Shows usage of model.initialContext and model.assign for type-safe context updates.

LANGUAGE: javascript
CODE:
import { createModel } from 'xstate/lib/model';

const userModel = createModel({
  name: 'Someone',
  age: 0
});

// ...

const machine = userModel.createMachine({
  context: userModel.initialContext,
  // ...
  entry: userModel.assign({ name: '' })
});

----------------------------------------

TITLE: Defining Initial Context in XState Machines
DESCRIPTION: This example demonstrates how to define initial context for an XState machine, including lazy initialization and dynamic context creation.

LANGUAGE: javascript
CODE:
const counterMachine = createMachine({
  id: 'counter',
  // initial context
  context: {
    count: 0,
    message: 'Currently empty',
    user: {
      name: 'David'
    },
    allowedToIncrement: true
    // ... etc.
  },
  states: {
    // ...
  }
});

// Lazy initialization
const lazyCounterMachine = createMachine({
  id: 'counter',
  // initial context
  context: () => ({
    count: 0,
    message: 'Currently empty',
    user: {
      name: 'David'
    },
    allowedToIncrement: true
    // ... etc.
  }),
  states: {
    // ...
  }
});

// Dynamic context
const createCounterMachine = (count, time) => {
  return createMachine({
    id: 'counter',
    // values provided from function arguments
    context: {
      count,
      time
    }
    // ...
  });
};

const counterMachine = createCounterMachine(42, Date.now());

----------------------------------------

TITLE: Basic Toggle State Machine Implementation
DESCRIPTION: Demonstrates creating a simple toggle state machine with context management and state transitions using XState v5

LANGUAGE: typescript
CODE:
import { createMachine, createActor, assign } from 'xstate';

// State machine
const toggleMachine = createMachine({
  id: 'toggle',
  initial: 'inactive',
  context: {
    count: 0
  },
  states: {
    inactive: {
      on: {
        TOGGLE: { target: 'active' }
      }
    },
    active: {
      entry: assign({ count: ({ context }) => context.count + 1 }),
      on: {
        TOGGLE: { target: 'inactive' }
      }
    }
  }
});

// Actor (instance of the machine logic, like a store)
const toggleActor = createActor(toggleMachine);
toggleActor.subscribe((state) => console.log(state.value, state.context));
toggleActor.start();
// => logs 'inactive', { count: 0 }

toggleActor.send({ type: 'TOGGLE' });
// => logs 'active', { count: 1 }

toggleActor.send({ type: 'TOGGLE' });
// => logs 'inactive', { count: 1 }

----------------------------------------

TITLE: Creating a Glass Machine with Context in XState
DESCRIPTION: This snippet demonstrates how to create a machine that simulates filling a glass of water using context to track the amount of water.

LANGUAGE: javascript
CODE:
import { createMachine, assign } from 'xstate';

// Action to increment the context amount
const addWater = assign({
  amount: (context, event) => context.amount + 1
});

// Guard to check if the glass is full
function glassIsFull(context, event) {
  return context.amount >= 10;
}

const glassMachine = createMachine(
  {
    id: 'glass',
    // the initial context (extended state) of the statechart
    context: {
      amount: 0
    },
    initial: 'empty',
    states: {
      empty: {
        on: {
          FILL: {
            target: 'filling',
            actions: 'addWater'
          }
        }
      },
      filling: {
        // Transient transition
        always: {
          target: 'full',
          cond: 'glassIsFull'
        },
        on: {
          FILL: {
            target: 'filling',
            actions: 'addWater'
          }
        }
      },
      full: {}
    }
  },
  {
    actions: { addWater },
    guards: { glassIsFull }
  }
);

----------------------------------------

TITLE: Extending Machines with withConfig in XState JavaScript
DESCRIPTION: Demonstrates how to extend an existing machine using the .withConfig() method, allowing for overriding or adding new implementations for actions, delays, guards, or services.

LANGUAGE: javascript
CODE:
const lightMachine = // (same as above example)

const noAlertLightMachine = lightMachine.withConfig({
  actions: {
    alertGreen: (context, event) => {
      console.log('green');
    }
  }
});

----------------------------------------

TITLE: Extending Machines with withConfig in XState JavaScript
DESCRIPTION: Demonstrates how to extend an existing machine using the .withConfig() method, allowing for overriding or adding new implementations for actions, delays, guards, or services.

LANGUAGE: javascript
CODE:
const lightMachine = // (same as above example)

const noAlertLightMachine = lightMachine.withConfig({
  actions: {
    alertGreen: (context, event) => {
      console.log('green');
    }
  }
});

----------------------------------------

TITLE: Using the Machine Transition Method in XState
DESCRIPTION: This snippet shows how to use the machine.transition() method to determine the next state based on the current state and an event.

LANGUAGE: javascript
CODE:
const lightMachine = createMachine({
  /* ... */
});

const greenState = lightMachine.initialState;

// determine next state based on current state and event
const yellowState = lightMachine.transition(greenState, { type: 'TIMER' });

console.log(yellowState.value);
// => 'yellow'

----------------------------------------

TITLE: Basic XState Interpreter Usage
DESCRIPTION: Demonstrates how to create and use an XState interpreter to run a state machine, including starting the service, handling transitions, and sending events.

LANGUAGE: javascript
CODE:
import { createMachine, interpret } from 'xstate';

const machine = createMachine(/* machine config */);

// Interpret the machine, and add a listener for whenever a transition occurs.
const service = interpret(machine).onTransition((state) => {
  console.log(state.value);
});

// Start the service
service.start();

// Send events
service.send({ type: 'SOME_EVENT' });

// Stop the service when you are no longer using it.
service.stop();

----------------------------------------

TITLE: Basic Toggle State Machine Implementation
DESCRIPTION: Demonstrates creation of a simple toggle state machine with context management and state transitions using XState v5.

LANGUAGE: typescript
CODE:
import { createMachine, createActor, assign } from 'xstate';

// State machine
const toggleMachine = createMachine({
  id: 'toggle',
  initial: 'inactive',
  context: {
    count: 0
  },
  states: {
    inactive: {
      on: {
        TOGGLE: { target: 'active' }
      }
    },
    active: {
      entry: assign({ count: ({ context }) => context.count + 1 }),
      on: {
        TOGGLE: { target: 'inactive' }
      }
    }
  }
});

// Actor (instance of the machine logic, like a store)
const toggleActor = createActor(toggleMachine);
toggleActor.subscribe((state) => console.log(state.value, state.context));
toggleActor.start();
// => logs 'inactive', { count: 0 }

toggleActor.send({ type: 'TOGGLE' });
// => logs 'active', { count: 1 }

toggleActor.send({ type: 'TOGGLE' });
// => logs 'inactive', { count: 1 }

----------------------------------------

TITLE: Initializing and Transitioning States in XState
DESCRIPTION: Demonstrates how to create a state machine, access its initial state, and perform a state transition. Shows the structure of the State object.

LANGUAGE: javascript
CODE:
const lightMachine = createMachine({
  id: 'light',
  initial: 'green',
  states: {
    green: {
      /* ... */
    }
    // ...
  }
});

console.log(lightMachine.initialState);
// State {
//   value: 'green',
//   actions: [],
//   context: undefined,
//   // ...
// }

console.log(lightMachine.transition('yellow', { type: 'TIMER' }));
// State {
//   value: { red: 'walk' },
//   actions: [],
//   context: undefined,
//   // ...
// }

----------------------------------------

TITLE: Initializing and Transitioning States in XState
DESCRIPTION: Demonstrates how to create a machine, access its initial state, and perform a state transition. Shows the structure of the State object returned.

LANGUAGE: javascript
CODE:
const lightMachine = createMachine({
  id: 'light',
  initial: 'green',
  states: {
    green: {
      /* ... */
    }
    // ...
  }
});

console.log(lightMachine.initialState);
// State {
//   value: 'green',
//   actions: [],
//   context: undefined,
//   // ...
// }

console.log(lightMachine.transition('yellow', { type: 'TIMER' }));
// State {
//   value: { red: 'walk' },
//   actions: [],
//   context: undefined,
//   // ...
// }

----------------------------------------

TITLE: Creating a Basic State Machine with XState in JavaScript
DESCRIPTION: This snippet demonstrates how to create a basic state machine for a traffic light using XState's createMachine() function. It shows the structure for defining states, initial state, and context.

LANGUAGE: javascript
CODE:
import { createMachine } from 'xstate';

const lightMachine = createMachine({
  // 状态机标识
  id: 'light',

  // 初始状态
  initial: 'green',

  // 整个状态机的本地 context
  context: {
    elapsed: 0,
    direction: 'east'
  },

  // 状态定义
  states: {
    green: {
      /* ... */
    },
    yellow: {
      /* ... */
    },
    red: {
      /* ... */
    }
  }
});

----------------------------------------

TITLE: Traffic Light Finite State Machine
DESCRIPTION: Implementation of a traffic light system using finite state machines, showing simple state transitions between green, yellow, and red states.

LANGUAGE: javascript
CODE:
import { createMachine, createActor } from 'xstate';

const lightMachine = createMachine({
  id: 'light',
  initial: 'green',
  states: {
    green: {
      on: {
        TIMER: 'yellow'
      }
    },
    yellow: {
      on: {
        TIMER: 'red'
      }
    },
    red: {
      on: {
        TIMER: 'green'
      }
    }
  }
});

const actor = createActor(lightMachine);

actor.subscribe((state) => {
  console.log(state.value);
});

actor.start();
// logs 'green'

actor.send({ type: 'TIMER' });
// logs 'yellow'

----------------------------------------

TITLE: Implementing Actions in XState State Machine
DESCRIPTION: Demonstrates different ways to add entry, exit and transition actions to state nodes, along with their implementations in the machine options.

LANGUAGE: javascript
CODE:
const triggerMachine = createMachine(
  {
    id: 'trigger',
    initial: 'inactive',
    states: {
      inactive: {
        on: {
          TRIGGER: {
            target: 'active',
            // transition actions
            actions: ['activate', 'sendTelemetry']
          }
        }
      },
      active: {
        // entry actions
        entry: ['notifyActive', 'sendTelemetry'],
        // exit actions
        exit: ['notifyInactive', 'sendTelemetry'],
        on: {
          STOP: { target: 'inactive' }
        }
      }
    }
  },
  {
    actions: {
      // action implementations
      activate: (context, event) => {
        console.log('activating...');
      },
      notifyActive: (context, event) => {
        console.log('active!');
      },
      notifyInactive: (context, event) => {
        console.log('inactive!');
      },
      sendTelemetry: (context, event) => {
        console.log('time:', Date.now());
      }
    }
  }
);

----------------------------------------

TITLE: Using state.matches() in XState
DESCRIPTION: Shows how to use the state.matches() method to check if the current state matches a given state value. Demonstrates various matching patterns.

LANGUAGE: javascript
CODE:
console.log(state.value);
// => { red: 'stop' }

console.log(state.matches('red'));
// => true

console.log(state.matches('red.stop'));
// => true

console.log(state.matches({ red: 'stop' }));
// => true

console.log(state.matches('green'));
// => false

----------------------------------------

TITLE: Defining Typestates for XState Machine in TypeScript
DESCRIPTION: This snippet demonstrates how to define typestates for an XState machine. Typestates narrow down the shape of the overall state context based on the state value, preventing impossible states.

LANGUAGE: typescript
CODE:
import { createMachine, interpret } from 'xstate';

interface User {
  name: string;
}

interface UserContext {
  user?: User;
  error?: string;
}

type UserEvent =
  | { type: 'FETCH'; id: string }
  | { type: 'RESOLVE'; user: User }
  | { type: 'REJECT'; error: string };

type UserTypestate =
  | {
      value: 'idle';
      context: UserContext & {
        user: undefined;
        error: undefined;
      };
    }
  | {
      value: 'loading';
      context: UserContext;
    }
  | {
      value: 'success';
      context: UserContext & { user: User; error: undefined };
    }
  | {
      value: 'failure';
      context: UserContext & { user: undefined; error: string };
    };

const userMachine = createMachine<UserContext, UserEvent, UserTypestate>({
  id: 'user',
  initial: 'idle',
  states: {
    idle: {
      /* ... */
    },
    loading: {
      /* ... */
    },
    success: {
      /* ... */
    },
    failure: {
      /* ... */
    }
  }
});

const userService = interpret(userMachine);

userService.subscribe((state) => {
  if (state.matches('success')) {
    // from the UserState typestate, `user` will be defined
    state.context.user.name;
  }
});

----------------------------------------

TITLE: Using Multiple Guards in XState
DESCRIPTION: This snippet illustrates how to use multiple conditional transitions for a single event. The transitions are tested in order, and the first one with a true condition is taken. It models a door with different outcomes based on admin status and alert conditions.

LANGUAGE: javascript
CODE:
import { createMachine, actions, interpret, assign } from 'xstate';

const doorMachine = createMachine(
  {
    id: 'door',
    initial: 'closed',
    context: {
      level: 'user',
      alert: false // alert when intrusions happen
    },
    states: {
      closed: {
        initial: 'idle',
        states: {
          idle: {},
          error: {}
        },
        on: {
          SET_ADMIN: {
            actions: assign({ level: 'admin' })
          },
          SET_ALARM: {
            actions: assign({ alert: true })
          },
          OPEN: [
            // Transitions are tested one at a time.
            // The first valid transition will be taken.
            { target: 'opened', cond: 'isAdmin' },
            { target: '.error', cond: 'shouldAlert' },
            { target: '.idle' }
          ]
        }
      },
      opened: {
        on: {
          CLOSE: { target: 'closed' }
        }
      }
    }
  },
  {
    guards: {
      isAdmin: (context) => context.level === 'admin',
      shouldAlert: (context) => context.alert === true
    }
  }
);

const doorService = interpret(doorMachine)
  .onTransition((state) => console.log(state.value))
  .start();
// => { closed: 'idle' }

doorService.send({ type: 'OPEN' });
// => { closed: 'idle' }

doorService.send({ type: 'SET_ALARM' });
// => { closed: 'idle' }
// (state does not change, but context changes)

doorService.send({ type: 'OPEN' });
// => { closed: 'error' }

doorService.send({ type: 'SET_ADMIN' });
// => { closed: 'error' }
// (state does not change, but context changes)

doorService.send({ type: 'OPEN' });
// => 'opened'
// (since context.isAdmin === true)

----------------------------------------

TITLE: Creating Hierarchical State Machine in JavaScript with XState
DESCRIPTION: Example of a traffic light state machine with nested pedestrian states. Demonstrates compound states, state transitions, and event handling between parent and child states.

LANGUAGE: javascript
CODE:
const pedestrianStates = {
  initial: 'walk',
  states: {
    walk: {
      on: {
        PED_COUNTDOWN: { target: 'wait' }
      }
    },
    wait: {
      on: {
        PED_COUNTDOWN: { target: 'stop' }
      }
    },
    stop: {},
    blinking: {}
  }
};

const lightMachine = createMachine({
  key: 'light',
  initial: 'green',
  states: {
    green: {
      on: {
        TIMER: { target: 'yellow' }
      }
    },
    yellow: {
      on: {
        TIMER: { target: 'red' }
      }
    },
    red: {
      on: {
        TIMER: { target: 'green' }
      },
      ...pedestrianStates
    }
  },
  on: {
    POWER_OUTAGE: { target: '.red.blinking' },
    POWER_RESTORED: { target: '.red' }
  }
});

----------------------------------------

TITLE: Event Propagation in Nested States with XState
DESCRIPTION: This example illustrates event propagation in nested states using XState. It shows that when a substate doesn't handle an event, it's propagated to the parent state for handling. In this case, the 'TIMER' event is handled by the 'red' parent state when the machine is in the 'red.stop' substate.

LANGUAGE: javascript
CODE:
console.log(lightMachine.transition({ red: 'stop' }, { type: 'TIMER' }).value);
// => 'green'

----------------------------------------

TITLE: Creating a State Machine with XState in JavaScript
DESCRIPTION: Demonstrates how to create a basic state machine using the createMachine() function from XState. The example includes machine identifier, initial state, context, and state definitions.

LANGUAGE: javascript
CODE:
import { createMachine } from 'xstate';

const lightMachine = createMachine({
  // Machine identifier
  id: 'light',

  // Initial state
  initial: 'green',

  // Local context for entire machine
  context: {
    elapsed: 0,
    direction: 'east'
  },

  // State definitions
  states: {
    green: {
      /* ... */
    },
    yellow: {
      /* ... */
    },
    red: {
      /* ... */
    }
  }
});

----------------------------------------

TITLE: Typing Context in XState with TypeScript
DESCRIPTION: This snippet shows how to properly type the context in an XState machine using TypeScript, including type inference for assign actions.

LANGUAGE: typescript
CODE:
import { createMachine } from 'xstate';

interface CounterContext {
  count: number;
  user?: {
    name: string;
  };
}

const machine = createMachine({
  schema: {
    context: {} as CounterContext
  },
  // ...
  context: {
    count: 0,
    user: undefined
  }
  // ...
});

// Using assign with TypeScript
const machine = createMachine({
  schema: {
    context: {} as CounterContext
  },
  // ...
  context: {
    count: 0
  },
  // ...
  {
    on: {
      INCREMENT: {
        // Generics guarantee proper inference
        actions: assign<CounterContext, CounterEvent>({
          count: (context) => {
            // context: { count: number }
            return context.count + 1;
          }
        });
      }
    }
  }
});

----------------------------------------

TITLE: Typing Context in XState with TypeScript
DESCRIPTION: This snippet shows how to properly type the context in an XState machine using TypeScript, including type inference for assign actions.

LANGUAGE: typescript
CODE:
import { createMachine } from 'xstate';

interface CounterContext {
  count: number;
  user?: {
    name: string;
  };
}

const machine = createMachine({
  schema: {
    context: {} as CounterContext
  },
  // ...
  context: {
    count: 0,
    user: undefined
  }
  // ...
});

// Using assign with TypeScript
const machine = createMachine({
  schema: {
    context: {} as CounterContext
  },
  // ...
  context: {
    count: 0
  },
  // ...
  {
    on: {
      INCREMENT: {
        // Generics guarantee proper inference
        actions: assign<CounterContext, CounterEvent>({
          count: (context) => {
            // context: { count: number }
            return context.count + 1;
          }
        });
      }
    }
  }
});

----------------------------------------

TITLE: Parent-Child Machine Communication
DESCRIPTION: Example showing communication between parent and child machines using spawn and message passing

LANGUAGE: javascript
CODE:
const remoteMachine = createMachine({
  id: 'remote',
  initial: 'offline',
  states: {
    offline: {
      on: {
        WAKE: 'online'
      }
    },
    online: {
      after: {
        1000: {
          actions: sendParent({ type: 'REMOTE.ONLINE' })
        }
      }
    }
  }
});

const parentMachine = createMachine({
  id: 'parent',
  initial: 'waiting',
  context: {
    localOne: null
  },
  states: {
    waiting: {
      entry: assign({
        localOne: () => spawn(remoteMachine)
      }),
      on: {
        'LOCAL.WAKE': {
          actions: send({ type: 'WAKE' }, { to: (context) => context.localOne })
        },
        'REMOTE.ONLINE': { target: 'connected' }
      }
    },
    connected: {}
  }
});

----------------------------------------

TITLE: Using Assign Action in XState
DESCRIPTION: This snippet demonstrates how to use the assign action to update the machine's context, including both object and function syntax.

LANGUAGE: javascript
CODE:
import { createMachine, assign } from 'xstate';
// example: property assigner

// ...
  actions: assign({
    // increment the current count by the event value
    count: (context, event) => context.count + event.value,

    // assign static value to the message (no function needed)
    message: 'Count changed'
  }),
// ...

// example: context assigner

// ...

  // return a partial (or full) updated context
  actions: assign((context, event) => {
    return {
      count: context.count + event.value,
      message: 'Count changed'
    }
  }),
// ...

----------------------------------------

TITLE: Sending Events to XState Service
DESCRIPTION: Shows different ways to send events to a running XState service, including sending an event object.

LANGUAGE: javascript
CODE:
service.start();

// As an object (preferred):
service.send({ type: 'CLICK', x: 40, y: 21 });

----------------------------------------

TITLE: Complex State Machine with Nested States
DESCRIPTION: Implementation of a fetch machine with multiple states including idle, pending, success, and failure states with nested child states.

LANGUAGE: javascript
CODE:
const fetchMachine = createMachine({
  id: 'fetch',

  // Initial state
  initial: 'idle',

  // States
  states: {
    idle: {
      on: {
        FETCH: { target: 'pending' }
      }
    },
    pending: {
      on: {
        FULFILL: { target: 'success' },
        REJECT: { target: 'failure' }
      }
    },
    success: {
      // Initial child state
      initial: 'items',

      // Child states
      states: {
        items: {
          on: {
            'ITEM.CLICK': { target: 'item' }
          }
        },
        item: {
          on: {
            BACK: { target: 'items' }
          }
        }
      }
    },
    failure: {
      on: {
        RETRY: { target: 'pending' }
      }
    }
  }
});

----------------------------------------

TITLE: Creating Basic Toggle State Machine
DESCRIPTION: Example of creating and using a simple toggle state machine with two states (active/inactive) and a transition between them.

LANGUAGE: javascript
CODE:
import { createMachine, interpret } from 'xstate';

// Stateless machine definition
// machine.transition(...) is a pure function used by the interpreter.
const toggleMachine = createMachine({
  id: 'toggle',
  initial: 'inactive',
  states: {
    inactive: { on: { TOGGLE: 'active' } },
    active: { on: { TOGGLE: 'inactive' } }
  }
});

// Machine instance with internal state
const toggleService = interpret(toggleMachine)
  .onTransition((state) => console.log(state.value))
  .start();
// => 'inactive'

toggleService.send({ type: 'TOGGLE' });
// => 'active'

toggleService.send({ type: 'TOGGLE' });
// => 'inactive'

----------------------------------------

TITLE: Implementing Flight Booking State Machine in XState
DESCRIPTION: Complete implementation of the flight booking state machine using XState, including state definitions, context management, transitions, and validation logic.

LANGUAGE: javascript
CODE:
import { createMachine, assign } from 'xstate';

export const flightMachine = createMachine({
  id: 'flight',
  initial: 'editing',
  context: {
    startDate: undefined,
    returnDate: undefined,
    trip: 'oneWay' // or 'roundTrip'
  },
  states: {
    editing: {
      on: {
        'startDate.UPDATE': {
          actions: assign({
            startDate: (_, event) => event.value
          })
        },
        'returnDate.UPDATE': {
          actions: assign({
            returnDate: (_, event) => event.value
          }),
          cond: (context) => context.trip === 'roundTrip'
        },
        SET_TRIP: {
          actions: assign({
            trip: (_, event) => event.value
          }),
          cond: (_, event) =>
            event.value === 'oneWay' || event.value === 'roundTrip'
        },
        SUBMIT: {
          target: 'submitted',
          cond: (context) => {
            if (context.trip === 'oneWay') {
              return !!context.startDate;
            } else {
              return (
                !!context.startDate &&
                !!context.returnDate &&
                context.returnDate > context.startDate
              );
            }
          }
        }
      }
    },
    submitted: {
      type: 'final'
    }
  }
});

----------------------------------------

TITLE: Mocking Effects with machine.withConfig() in XState
DESCRIPTION: This snippet demonstrates how to mock side-effects like actions and invoking/spawning actors using the machine.withConfig() option. It allows changing the implementation details of certain actions for testing purposes.

LANGUAGE: javascript
CODE:
import { fetchMachine } from '../path/to/fetchMachine';

it('should eventually reach "success"', (done) => {
  let userAlerted = false;

  const mockFetchMachine = fetchMachine.withConfig({
    services: {
      fetchFromAPI: (_, event) =>
        new Promise((resolve) => {
          setTimeout(() => {
            resolve({ id: event.id });
          }, 50);
        })
    },
    actions: {
      alertUser: () => {
        // set a flag instead of executing the original action
        userAlerted = true;
      }
    }
  });

  const fetchService = interpret(mockFetchMachine).onTransition((state) => {
    if (state.matches('success')) {
      // assert that effects were executed
      expect(userAlerted).toBeTruthy();
      done();
    }
  });

  fetchService.start();

  fetchService.send({ type: 'FETCH', id: 42 });
});

----------------------------------------

TITLE: Invoking a Promise in XState
DESCRIPTION: Example of invoking a promise to fetch user data in an XState machine. Shows how to handle successful resolution and error cases.

LANGUAGE: javascript
CODE:
const fetchUser = (userId) =>
  fetch(`url/to/user/${userId}`).then((response) => response.json());

const userMachine = createMachine({
  id: 'user',
  initial: 'idle',
  context: {
    userId: 42,
    user: undefined,
    error: undefined
  },
  states: {
    idle: {
      on: {
        FETCH: { target: 'loading' }
      }
    },
    loading: {
      invoke: {
        id: 'getUser',
        src: (context, event) => fetchUser(context.userId),
        onDone: {
          target: 'success',
          actions: assign({ user: (context, event) => event.data })
        },
        onError: {
          target: 'failure',
          actions: assign({ error: (context, event) => event.data })
        }
      }
    },
    success: {},
    failure: {
      on: {
        RETRY: { target: 'loading' }
      }
    }
  }
});

----------------------------------------

TITLE: Implementing Conditional Transitions with Null Events in XState
DESCRIPTION: Shows how to use null events with guards to create conditional transitions based on the machine's context.

LANGUAGE: javascript
CODE:
const isAdult = ({ age }) => age >= 18;
const isMinor = ({ age }) => age < 18;

const ageMachine = createMachine({
  id: 'age',
  context: { age: undefined }, // age unknown
  initial: 'unknown',
  states: {
    unknown: {
      on: {
        // immediately take transition that satisfies conditional guard.
        // otherwise, no transition occurs
        '': [
          { target: 'adult', cond: isAdult },
          { target: 'child', cond: isMinor }
        ]
      }
    },
    adult: { type: 'final' },
    child: { type: 'final' }
  }
});

console.log(ageMachine.initialState.value);
// => 'unknown'

const personData = { age: 28 };

const personMachine = ageMachine.withContext(personData);

console.log(personMachine.initialState.value);
// => 'adult'

----------------------------------------

TITLE: Basic Promise Invocation in XState
DESCRIPTION: Example of invoking a Promise-based service to fetch user data with success and error handling.

LANGUAGE: javascript
CODE:
const fetchUser = (userId) =>
  fetch(`url/to/user/${userId}`).then((response) => response.json());

const userMachine = createMachine({
  id: 'user',
  initial: 'idle',
  context: {
    userId: 42,
    user: undefined,
    error: undefined
  },
  states: {
    idle: {
      on: {
        FETCH: { target: 'loading' }
      }
    },
    loading: {
      invoke: {
        id: 'getUser',
        src: (context, event) => fetchUser(context.userId),
        onDone: {
          target: 'success',
          actions: assign({ user: (context, event) => event.data })
        },
        onError: {
          target: 'failure',
          actions: assign({ error: (context, event) => event.data })
        }
      }
    },
    success: {},
    failure: {
      on: {
        RETRY: { target: 'loading' }
      }
    }
  }
});

----------------------------------------

TITLE: Setting Initial Context in XState Machines with JavaScript
DESCRIPTION: This example shows how to set a custom initial context for an XState machine using the withContext() method. It replaces the original context with the provided one.

LANGUAGE: javascript
CODE:
const lightMachine = // (same as first example)

const testLightMachine = lightMachine.withContext({
  elapsed: 1000,
  direction: 'north'
});

----------------------------------------

TITLE: Implementing Guarded Transitions in XState
DESCRIPTION: This snippet demonstrates how to create a search machine with a guarded transition. The transition to the 'searching' state only occurs if the searchValid condition is met.

LANGUAGE: javascript
CODE:
const searchValid = (context, event) => {
  return context.canSearch && event.query && event.query.length > 0;
};

const searchMachine = createMachine(
  {
    id: 'search',
    initial: 'idle',
    context: {
      canSearch: true
    },
    states: {
      idle: {
        on: {
          SEARCH: [
            {
              target: 'searching',
              // Only transition to 'searching' if the guard (cond) evaluates to true
              cond: searchValid // or { type: 'searchValid' }
            },
            { target: '.invalid' }
          ]
        },
        initial: 'normal',
        states: {
          normal: {},
          invalid: {}
        }
      },
      searching: {
        entry: 'executeSearch'
        // ...
      },
      searchError: {
        // ...
      }
    }
  },
  {
    guards: {
      searchValid // optional, if the implementation doesn't change
    }
  }
);

----------------------------------------

TITLE: Creating Counter State Machine with XState
DESCRIPTION: Implementation of a counter state machine using XState. The machine has a single 'active' state and manages a count in its context. It handles INCREMENT events by incrementing the count value using an assign action.

LANGUAGE: javascript
CODE:
import { createMachine, assign } from 'xstate';

export const counterMachine = createMachine({
  initial: 'active',
  context: { count: 0 },
  states: {
    active: {
      on: {
        INCREMENT: {
          actions: assign({ count: (ctx) => ctx.count + 1 })
        }
      }
    }
  }
});

----------------------------------------

TITLE: Using State Machine in React Component
DESCRIPTION: Demonstration of using the Promise state machine within a React component using the useMachine hook from @xstate/react.

LANGUAGE: tsx
CODE:
import { useMachine } from '@xstate/react';

const Component = () => {
  const [state, send] = useMachine(promiseMachine);

  return (
    <div>
      {/** You can listen to what state the service is in */}
      {state.matches('pending') && <p>Loading...</p>}
      {state.matches('rejected') && <p>Promise Rejected</p>}
      {state.matches('resolved') && <p>Promise Resolved</p>}
      <div>
        {/** You can send events to the running service */}
        <button onClick={() => send('RESOLVE')}>Resolve</button>
        <button onClick={() => send('REJECT')}>Reject</button>
      </div>
    </div>
  );
};

----------------------------------------

TITLE: Event Modeling with TypeScript in XState
DESCRIPTION: Shows how to model events with payload types and use them in a machine definition. Includes event creators and type-safe action definitions.

LANGUAGE: typescript
CODE:
import { createModel } from 'xstate/lib/model';

const userModel = createModel(
  // Initial context
  {
    name: 'David',
    age: 30
  },
  {
    // Event creators
    events: {
      updateName: (value) => ({ value }),
      updateAge: (value) => ({ value }),
      anotherEvent: () => ({}) // no payload
    }
  }
);

const machine = userModel.createMachine(
  {
    context: userModel.initialContext,
    initial: 'active',
    states: {
      active: {
        on: {
          updateName: {
            actions: userModel.assign({
              name: (_, event) => event.value
            })
          },
          updateAge: {
            actions: 'assignAge'
          }
        }
      }
    }
  },
  {
    actions: {
      assignAge: userModel.assign({
        age: (_, event) => event.value
      })
    }
  }
);

const nextState = machine.transition(
  undefined,
  userModel.events.updateName('David')
);

----------------------------------------

TITLE: Implementing Parallel File Upload/Download States in XState
DESCRIPTION: Creates a state machine with parallel upload and download states that can operate simultaneously. Each state has idle, pending and success substates that can be transitioned independently.

LANGUAGE: javascript
CODE:
const fileMachine = createMachine({
  id: 'file',
  type: 'parallel',
  states: {
    upload: {
      initial: 'idle',
      states: {
        idle: {
          on: {
            INIT_UPLOAD: { target: 'pending' }
          }
        },
        pending: {
          on: {
            UPLOAD_COMPLETE: { target: 'success' }
          }
        },
        success: {}
      }
    },
    download: {
      initial: 'idle',
      states: {
        idle: {
          on: {
            INIT_DOWNLOAD: { target: 'pending' }
          }
        },
        pending: {
          on: {
            DOWNLOAD_COMPLETE: { target: 'success' }
          }
        },
        success: {}
      }
    }
  }
});

console.log(fileMachine.initialState.value);

----------------------------------------

TITLE: Eventless Transitions in XState
DESCRIPTION: Demonstrates the use of eventless transitions that are always taken when the machine is in a specific state and conditions are met.

LANGUAGE: javascript
CODE:
const gameMachine = createMachine(
  {
    id: 'game',
    initial: 'playing',
    context: {
      points: 0
    },
    states: {
      playing: {
        // Eventless transition
        // Will transition to either 'win' or 'lose' immediately upon
        // entering 'playing' state or receiving AWARD_POINTS event
        // if the condition is met.
        always: [
          { target: 'win', cond: 'didPlayerWin' },
          { target: 'lose', cond: 'didPlayerLose' }
        ],
        on: {
          // Self-transition
          AWARD_POINTS: {
            actions: assign({
              points: 100
            })
          }
        }
      },
      win: { type: 'final' },
      lose: { type: 'final' }
    }
  },
  {
    guards: {
      didPlayerWin: (context, event) => {
        // check if player won
        return context.points > 99;
      },
      didPlayerLose: (context, event) => {
        // check if player lost
        return context.points < 0;
      }
    }
  }
);

const gameService = interpret(gameMachine)
  .onTransition((state) => console.log(state.value))
  .start();

// Still in 'playing' state because no conditions of
// transient transition were met
// => 'playing'

// When 'AWARD_POINTS' is sent, a self-transition to 'PLAYING' occurs.
// The transient transition to 'win' is taken because the 'didPlayerWin'
// condition is satisfied.
gameService.send({ type: 'AWARD_POINTS' });
// => 'win'

----------------------------------------

TITLE: Testing Services with interpret() in XState
DESCRIPTION: This snippet shows how to test the behavior and output of services by asserting that it eventually reaches an expected state, given an initial state and a sequence of events.

LANGUAGE: javascript
CODE:
import { fetchMachine } from '../path/to/fetchMachine';

it('should eventually reach "success"', (done) => {
  const fetchService = interpret(fetchMachine).onTransition((state) => {
    // this is where you expect the state to eventually
    // be reached
    if (state.matches('success')) {
      done();
    }
  });

  fetchService.start();

  // send zero or more events to the service that should
  // cause it to eventually reach its expected state
  fetchService.send({ type: 'FETCH', id: 42 });
});

----------------------------------------

TITLE: Fetch Machine Implementation
DESCRIPTION: Complex example showing a configurable fetch machine with multiple states and service integration.

LANGUAGE: javascript
CODE:
const fetchMachine = createMachine({
  id: 'fetch',
  initial: 'idle',
  context: {
    data: undefined,
    error: undefined
  },
  states: {
    idle: {
      on: { FETCH: 'loading' }
    },
    loading: {
      invoke: {
        src: 'fetchData',
        onDone: {
          target: 'success',
          actions: assign({
            data: (_, event) => event.data
          })
        },
        onError: {
          target: 'failure',
          actions: assign({
            error: (_, event) => event.data
          })
        }
      }
    },
    success: {
      entry: 'notifySuccess',
      type: 'final'
    },
    failure: {
      on: {
        RETRY: 'loading'
      }
    }
  }
});

----------------------------------------

TITLE: Using XState Machine with Context
DESCRIPTION: This snippet shows how to use the search machine with context. It demonstrates sending events to the machine and observing state transitions based on the guarded conditions.

LANGUAGE: javascript
CODE:
import { interpret } from 'xstate';

const searchService = interpret(searchMachine)
  .onTransition((state) => console.log(state.value))
  .start();

searchService.send({ type: 'SEARCH', query: '' });
// => 'idle'

searchService.send({ type: 'SEARCH', query: 'something' });
// => 'searching'

----------------------------------------

TITLE: Defining Schema Types for XState Machine in TypeScript
DESCRIPTION: This snippet demonstrates how to define schema types for context and events in an XState machine using TypeScript. It provides type safety for the machine's context and events.

LANGUAGE: typescript
CODE:
import { createMachine } from 'xstate';

const lightMachine = createMachine({
  schema: {
    // The context (extended state) of the machine
    context: {} as { elapsed: number },
    // The events this machine handles
    events: {} as
      | { type: 'TIMER' }
      | { type: 'POWER_OUTAGE' }
      | { type: 'PED_COUNTDOWN'; duration: number }
  }
  /* Other config... */
});

----------------------------------------

TITLE: Creating a User Model with createModel in JavaScript
DESCRIPTION: Demonstrates creating a model for a user with initial context and event creators using createModel(). Shows how to use the model to create a machine with typed context and events.

LANGUAGE: javascript
CODE:
import { createModel } from 'xstate/lib/model';

const userModel = createModel({
  name: 'Someone',
  age: 0
});

// ...

const machine = userModel.createMachine({
  context: userModel.initialContext,
  // ...
  entry: userModel.assign({ name: '' })
});

----------------------------------------

TITLE: Batch Event Processing in XState
DESCRIPTION: Demonstrates how to send multiple events as a batch to an XState service for sequential processing.

LANGUAGE: javascript
CODE:
service.send([
  // String events
  'CLICK',
  'CLICK',
  'ANOTHER_EVENT',
  // Event objects
  { type: 'CLICK', x: 40, y: 21 },
  { type: 'KEYDOWN', key: 'Escape' }
]);

----------------------------------------

TITLE: Initializing Context in XState Machine
DESCRIPTION: This snippet shows how to set initial context for a counter machine, including both static and dynamic initialization methods.

LANGUAGE: javascript
CODE:
const counterMachine = createMachine({
  id: 'counter',
  // initial context
  context: {
    count: 0,
    message: 'Currently empty',
    user: {
      name: 'David'
    },
    allowedToIncrement: true
    // ... etc.
  },
  states: {
    // ...
  }
});

// Dynamic context initialization
const counterMachine = createMachine({
  id: 'counter',
  // initial context
  context: () => ({
    count: 0,
    message: 'Currently empty',
    user: {
      name: 'David'
    },
    allowedToIncrement: true
    // ... etc.
  }),
  states: {
    // ...
  }
});

----------------------------------------

TITLE: Serializing Guards in XState
DESCRIPTION: This example demonstrates how to serialize guards in XState. The guard implementation is specified in the machine options, allowing for easier debugging, serialization, testing, and visualization.

LANGUAGE: javascript
CODE:
const searchMachine = createMachine(
  {
    // ...
    states: {
      idle: {
        on: {
          SEARCH: {
            target: 'searching',
            // The 'searchValid' guard implementation details are
            // specified in the machine config
            cond: 'searchValid' // or { type: 'searchValid' }
          }
        }
      }
      // ...
    }
  },
  {
    guards: {
      searchValid: (context, event) => {
        return context.canSearch && event.query && event.query.length > 0;
      }
    }
  }
);

----------------------------------------

TITLE: Testing Pure Logic with machine.transition() in XState
DESCRIPTION: This snippet demonstrates how to test the pure logic of a state machine using the machine.transition() function. It asserts that a specific state is reached given an initial state and an event.

LANGUAGE: javascript
CODE:
import { lightMachine } from '../path/to/lightMachine';

it('should reach "yellow" given "green" when the "TIMER" event occurs', () => {
  const expectedValue = 'yellow'; // the expected state value

  const actualState = lightMachine.transition('green', { type: 'TIMER' });

  expect(actualState.matches(expectedValue)).toBeTruthy();
});

----------------------------------------

TITLE: Basic Context Modeling in XState
DESCRIPTION: Demonstrates how to create a basic user model with context and use it within a state machine definition

LANGUAGE: javascript
CODE:
import { createModel } from 'xstate/lib/model';

const userModel = createModel({
  name: 'Someone',
  age: 0
});

// ...

const machine = userModel.createMachine({
  context: userModel.initialContext,
  // ...
  entry: userModel.assign({ name: '' })
});

----------------------------------------

TITLE: Traffic Light State Machine Example in JavaScript
DESCRIPTION: Shows implementation of a traffic light system using finite state machines with simple state transitions triggered by timer events.

LANGUAGE: javascript
CODE:
import { createMachine, createActor } from 'xstate';

const lightMachine = createMachine({
  id: 'light',
  initial: 'green',
  states: {
    green: {
      on: {
        TIMER: 'yellow'
      }
    },
    yellow: {
      on: {
        TIMER: 'red'
      }
    },
    red: {
      on: {
        TIMER: 'green'
      }
    }
  }
});

const actor = createActor(lightMachine);

actor.subscribe((state) => {
  console.log(state.value);
});

actor.start();
// logs 'green'

actor.send({ type: 'TIMER' });
// logs 'yellow'

----------------------------------------

TITLE: Persisting and Restoring State in XState
DESCRIPTION: Shows how to serialize a state to JSON, save it, and then restore it using State.create(). Also demonstrates how to start a service from a restored state.

LANGUAGE: javascript
CODE:
const jsonState = JSON.stringify(currentState);

// Example: persisting to localStorage
try {
  localStorage.setItem('app-state', jsonState);
} catch (e) {
  // unable to save to localStorage
}

import { State, interpret } from 'xstate';
import { myMachine } from '../path/to/myMachine';

// Retrieving the state definition from localStorage, if localStorage is empty use machine initial state
const stateDefinition =
  JSON.parse(localStorage.getItem('app-state')) || myMachine.initialState;

// Use State.create() to restore state from a plain object
const previousState = State.create(stateDefinition);

// This will start the service at the specified State
const service = interpret(myMachine).start(previousState);

----------------------------------------

TITLE: Using Typegen with XState in TypeScript
DESCRIPTION: This example shows how to use XState's typegen feature to generate intelligent typings. It includes setting up the machine with schema and tsTypes, and implementing typed actions.

LANGUAGE: typescript
CODE:
import { createMachine } from 'xstate';

const machine = createMachine(
  {
    tsTypes: {} as import('./filename.typegen').Typegen0,
    schema: {
      context: {} as { value: string },
      events: {} as { type: 'FOO'; value: string } | { type: 'BAR' }
    },
    context: {
      value: ''
    },
    initial: 'a',
    states: {
      a: {
        on: {
          FOO: {
            actions: 'consoleLogValue',
            target: 'b'
          }
        }
      },
      b: {
        entry: 'consoleLogValueAgain'
      }
    }
  },
  {
    actions: {
      consoleLogValue: (context, event) => {
        // Wow! event is typed to { type: 'FOO' }
        console.log(event.value);
      },
      consoleLogValueAgain: (context, event) => {
        // Wow! event is typed to { type: 'FOO' }
        console.log(event.value);
      }
    }
  }
);

----------------------------------------

TITLE: Performance Optimized Context Consumer
DESCRIPTION: Optimized implementation using useSelector hook to prevent unnecessary re-renders by selecting specific state values.

LANGUAGE: javascript
CODE:
import React, { useContext } from 'react';
import { GlobalStateContext } from './globalState';
import { useSelector } from '@xstate/react';

const loggedInSelector = (state) => {
  return state.matches('loggedIn');
};

export const SomeComponent = (props) => {
  const globalServices = useContext(GlobalStateContext);
  const isLoggedIn = useSelector(globalServices.authService, loggedInSelector);
  return isLoggedIn ? 'Logged In' : 'Logged Out';
};

----------------------------------------

TITLE: Implementing Basic Counter with XState in JavaScript
DESCRIPTION: This snippet demonstrates creating a basic counter machine with XState. It includes an 'active' state with 'INC' and 'DEC' events to increment and decrement the count stored in context.

LANGUAGE: javascript
CODE:
import { createMachine, interpret, assign } from 'xstate';

const increment = (context) => context.count + 1;
const decrement = (context) => context.count - 1;

const counterMachine = createMachine({
  initial: 'active',
  context: {
    count: 0
  },
  states: {
    active: {
      on: {
        INC: { actions: assign({ count: increment }) },
        DEC: { actions: assign({ count: decrement }) }
      }
    }
  }
});

const counterService = interpret(counterMachine)
  .onTransition((state) => console.log(state.context.count))
  .start();
// => 0

counterService.send({ type: 'INC' });
// => 1

counterService.send({ type: 'INC' });
// => 2

counterService.send({ type: 'DEC' });
// => 1

----------------------------------------

TITLE: Configuring Actions in XState Machine with JavaScript
DESCRIPTION: This example shows how to define and implement actions in an XState machine. Actions are referenced as strings in the machine config and implemented in a separate options object.

LANGUAGE: javascript
CODE:
const lightMachine = createMachine(
  {
    id: 'light',
    initial: 'green',
    states: {
      green: {
        // action referenced via string
        entry: 'alertGreen'
      }
    }
  },
  {
    actions: {
      // action implementation
      alertGreen: (context, event) => {
        alert('Green!');
      }
    },
    delays: {
      /* ... */
    },
    guards: {
      /* ... */
    },
    services: {
      /* ... */
    }
  }
);

----------------------------------------

TITLE: Creating and Using an XState Interpreter Service
DESCRIPTION: Demonstrates how to create a machine, interpret it, add a transition listener, start the service, send events, and stop the service.

LANGUAGE: javascript
CODE:
import { createMachine, interpret } from 'xstate';

const machine = createMachine(/* machine config */);

// Interpret the machine, and add a listener for whenever a transition occurs.
const service = interpret(machine).onTransition((state) => {
  console.log(state.value);
});

// Start the service
service.start();

// Send events
service.send({ type: 'SOME_EVENT' });

// Stop the service when you are no longer using it.
service.stop();

----------------------------------------

TITLE: Configuring Actions in XState Machine with JavaScript
DESCRIPTION: This example shows how to define and implement actions in an XState machine. Actions are referenced as strings in the machine config and implemented in a separate options object.

LANGUAGE: javascript
CODE:
const lightMachine = createMachine(
  {
    id: 'light',
    initial: 'green',
    states: {
      green: {
        // action referenced via string
        entry: 'alertGreen'
      }
    }
  },
  {
    actions: {
      // action implementation
      alertGreen: (context, event) => {
        alert('Green!');
      }
    },
    delays: {
      /* ... */
    },
    guards: {
      /* ... */
    },
    services: {
      /* ... */
    }
  }
);

----------------------------------------

TITLE: Merging Contexts in XState Machines with JavaScript
DESCRIPTION: This snippet demonstrates how to merge the original context with a new context when extending an XState machine. It uses the spread operator to combine contexts.

LANGUAGE: javascript
CODE:
const testLightMachine = lightMachine.withContext({
  // merge with original context
  ...lightMachine.context,
  elapsed: 1000
});

----------------------------------------

TITLE: Using useMachine in Vue Component
DESCRIPTION: Example of using the useMachine composition function in a Vue component with a toggle machine.

LANGUAGE: vue
CODE:
<script setup>
import { useMachine } from '@xstate/vue';
import { createMachine } from 'xstate';

const toggleMachine = createMachine({
  id: 'toggle',
  initial: 'inactive',
  states: {
    inactive: {
      on: { TOGGLE: 'active' }
    },
    active: {
      on: { TOGGLE: 'inactive' }
    }
  }
});

const { state, send } = useMachine(toggleMachine);
</script>

<template>
  <button @click="send('TOGGLE')">
    {{
      state.value === 'inactive'
        ? 'Click to activate'
        : 'Active! Click to deactivate'
    }}
  </button>
</template>

----------------------------------------

TITLE: Creating a Test Model with XState and @xstate/test
DESCRIPTION: Demonstrates how to create a test model using the createModel function from @xstate/test. The model includes an event definition for the 'TOGGLE' event with an execution function.

LANGUAGE: javascript
CODE:
import { createMachine } from 'xstate';
import { createModel } from '@xstate/test';

const toggleMachine = createMachine(/* ... */);

const toggleModel = createModel(toggleMachine).withEvents({
  TOGGLE: {
    exec: async (page) => {
      await page.click('input');
    }
  }
});

----------------------------------------

TITLE: Defining State Transitions in XState
DESCRIPTION: This snippet demonstrates how to define state transitions in an XState machine, including shorthand and object notations for transitions.

LANGUAGE: javascript
CODE:
import { createMachine } from 'xstate';

const promiseMachine = createMachine({
  id: 'promise',
  initial: 'pending',
  states: {
    pending: {
      on: {
        // state transition (shorthand)
        // this is equivalent to { target: 'resolved' }
        RESOLVE: 'resolved',

        // state transition (object)
        REJECT: {
          target: 'rejected'
        }
      }
    },
    resolved: {
      type: 'final'
    },
    rejected: {
      type: 'final'
    }
  }
});

const { initialState } = promiseMachine;

console.log(initialState.value);
// => 'pending'

const nextState = promiseMachine.transition(initialState, { type: 'RESOLVE' });

console.log(nextState.value);
// => 'resolved'

----------------------------------------

TITLE: Custom XState Interpreter Implementation
DESCRIPTION: Shows how to create a minimal custom interpreter implementation for running state machines.

LANGUAGE: javascript
CODE:
const machine = createMachine(/* machine config */);

// Keep track of the current state, and start
// with the initial state
let currentState = machine.initialState;

// Keep track of the listeners
const listeners = new Set();

// Have a way of sending/dispatching events
function send(event) {
  // Remember: machine.transition() is a pure function
  currentState = machine.transition(currentState, event);

  // Get the side-effect actions to execute
  const { actions } = currentState;

  actions.forEach((action) => {
    // If the action is executable, execute it
    typeof action.exec === 'function' && action.exec();
  });

  // Notify the listeners
  listeners.forEach((listener) => listener(currentState));
}

function listen(listener) {
  listeners.add(listener);
}

function unlisten(listener) {
  listeners.delete(listener);
}

// Now you can listen and send events to update state
listen((state) => {
  console.log(state.value);
});

send('SOME_EVENT');

----------------------------------------

TITLE: Complex Fetch Machine with Configuration
DESCRIPTION: Implementation of a more complex state machine for handling API fetching with configurable actions and services.

LANGUAGE: javascript
CODE:
import { createMachine } from 'xstate';
import { fromPromise } from 'xstate/actors';

const fetchMachine = createMachine({
  id: 'fetch',
  initial: 'idle',
  context: {
    data: undefined,
    error: undefined
  },
  states: {
    idle: {
      on: { FETCH: 'loading' }
    },
    loading: {
      invoke: {
        src: 'fetchData',
        onDone: {
          target: 'success',
          actions: assign({
            data: (_, event) => event.data
          })
        },
        onError: {
          target: 'failure',
          actions: assign({
            error: (_, event) => event.data
          })
        }
      }
    },
    success: {
      entry: 'notifySuccess',
      type: 'final'
    },
    failure: {
      on: {
        RETRY: 'loading'
      }
    }
  }
});

----------------------------------------

TITLE: Defining Typestates for XState Machine in TypeScript
DESCRIPTION: This snippet demonstrates how to define typestates for an XState machine, which narrow down the shape of the overall state context based on the state value. It includes the machine definition with typestates.

LANGUAGE: typescript
CODE:
import { createMachine, interpret } from 'xstate';

interface User {
  name: string;
}

interface UserContext {
  user?: User;
  error?: string;
}

type UserEvent =
  | { type: 'FETCH'; id: string }
  | { type: 'RESOLVE'; user: User }
  | { type: 'REJECT'; error: string };

type UserTypestate =
  | {
      value: 'idle';
      context: UserContext & {
        user: undefined;
        error: undefined;
      };
    }
  | {
      value: 'loading';
      context: UserContext;
    }
  | {
      value: 'success';
      context: UserContext & { user: User; error: undefined };
    }
  | {
      value: 'failure';
      context: UserContext & { user: undefined; error: string };
    };

const userMachine = createMachine<UserContext, UserEvent, UserTypestate>({
  id: 'user',
  initial: 'idle',
  states: {
    idle: {
      /* ... */
    },
    loading: {
      /* ... */
    },
    success: {
      /* ... */
    },
    failure: {
      /* ... */
    }
  }
});

const userService = interpret(userMachine);

userService.subscribe((state) => {
  if (state.matches('success')) {
    // from the UserState typestate, `user` will be defined
    state.context.user.name;
  }
});

----------------------------------------

TITLE: Configuring Machines in Svelte Component
DESCRIPTION: Example of configuring an existing machine with custom actions and services when using useMachine in a Svelte component.

LANGUAGE: svelte
CODE:
<script>
  import { useMachine } from '@xstate/svelte';
  import { createMachine, assign } from 'xstate';

  const fetchMachine = createMachine({
    id: 'fetch',
    initial: 'idle',
    context: {
      data: undefined,
      error: undefined
    },
    states: {
      idle: {
        on: { FETCH: 'loading' }
      },
      loading: {
        invoke: {
          src: 'fetchData',
          onDone: {
            target: 'success',
            actions: assign({
              data: (_, event) => event.data
            })
          },
          onError: {
            target: 'failure',
            actions: assign({
              error: (_, event) => event.data
            })
          }
        }
      },
      success: {
        entry: 'notifySuccess',
        type: 'final'
      },
      failure: {
        on: {
          RETRY: 'loading'
        }
      }
    }
  });

  const onResolve = (data) => {
    // Do something with data
  };

  const { state, send } = useMachine(fetchMachine, {
    actions: {
      notifySuccess: (context) => onResolve(context.data)
    },
    services: {
      fetchData: (_, event) =>
        fetch(`some/api/${event.query}`).then((res) => res.json())
    }
  });
</script>

{#if $state.value === 'idle'}
  <button on:click={() => send({ type: 'FETCH', query: 'something' })}>
    Search for something
  </button>
{:else if $state.value === 'loading'}
  <div>Searching...</div>
{:else if $state.value === 'success'}
  <div>Success! Data: {$state.context.data}</div>
{:else if $state.value === 'failure'}
  <p>{$state.context.error.message}</p>
  <button on:click={() => send('RETRY')}>Retry</button>
{/if}

----------------------------------------

TITLE: Using XState Typegen with VS Code Extension
DESCRIPTION: This snippet shows how to use XState's typegen feature with the VS Code extension. It generates intelligent typings for the machine, providing type safety for actions, events, and state matching.

LANGUAGE: typescript
CODE:
import { createMachine } from 'xstate';

const machine = createMachine(
  {
    tsTypes: {} as import('./filename.typegen').Typegen0,
    schema: {
      context: {} as { value: string },
      events: {} as { type: 'FOO'; value: string } | { type: 'BAR' }
    },
    initial: 'a',
    states: {
      a: {
        on: {
          FOO: {
            actions: 'consoleLogValue',
            target: 'b'
          }
        }
      },
      b: {
        entry: 'consoleLogValueAgain'
      }
    }
  },
  {
    actions: {
      consoleLogValue: (context, event) => {
        // Wow! event is typed to { type: 'FOO' }
        console.log(event.value);
      },
      consoleLogValueAgain: (context, event) => {
        // Wow! event is typed to { type: 'FOO' }
        console.log(event.value);
      }
    }
  }
);

----------------------------------------

TITLE: Defining Actions in XState State Machine
DESCRIPTION: This snippet demonstrates how to define entry, exit, and transition actions in an XState state machine. It also shows how to implement action functions.

LANGUAGE: javascript
CODE:
const triggerMachine = createMachine(
  {
    id: 'trigger',
    initial: 'inactive',
    states: {
      inactive: {
        on: {
          TRIGGER: {
            target: 'active',
            // transition actions
            actions: ['activate', 'sendTelemetry']
          }
        }
      },
      active: {
        // entry actions
        entry: ['notifyActive', 'sendTelemetry'],
        // exit actions
        exit: ['notifyInactive', 'sendTelemetry'],
        on: {
          STOP: { target: 'inactive' }
        }
      }
    }
  },
  {
    actions: {
      // action implementations
      activate: (context, event) => {
        console.log('activating...');
      },
      notifyActive: (context, event) => {
        console.log('active!');
      },
      notifyInactive: (context, event) => {
        console.log('inactive!');
      },
      sendTelemetry: (context, event) => {
        console.log('time:', Date.now());
      }
    }
  }
);

----------------------------------------

TITLE: Spawning and Communicating with a Machine Actor in XState
DESCRIPTION: Demonstrates spawning a machine actor, sending events to it, and handling events sent from the child to the parent machine.

LANGUAGE: javascript
CODE:
const remoteMachine = createMachine({
  id: 'remote',
  initial: 'offline',
  states: {
    offline: {
      on: {
        WAKE: 'online'
      }
    },
    online: {
      after: {
        1000: {
          actions: sendParent({ type: 'REMOTE.ONLINE' })
        }
      }
    }
  }
});

const parentMachine = createMachine({
  id: 'parent',
  initial: 'waiting',
  context: {
    localOne: null
  },
  states: {
    waiting: {
      entry: assign({
        localOne: () => spawn(remoteMachine)
      }),
      on: {
        'LOCAL.WAKE': {
          actions: send({ type: 'WAKE' }, { to: (context) => context.localOne })
        },
        'REMOTE.ONLINE': { target: 'connected' }
      }
    },
    connected: {}
  }
});

const parentService = interpret(parentMachine)
  .onTransition((state) => console.log(state.value))
  .start();

parentService.send({ type: 'LOCAL.WAKE' });
// => 'waiting'
// ... after 1000ms
// => 'connected'

----------------------------------------

TITLE: Sending Events to XState Machines
DESCRIPTION: Shows how to send events to state machines using the transition method and handle state changes. Demonstrates integration with native DOM events.

LANGUAGE: javascript
CODE:
import { createMachine } from 'xstate';

const lightMachine = createMachine({
  /* ... */
});

const { initialState } = lightMachine;

nextState = lightMachine.transition(nextState, { type: 'TIMER' });
console.log(nextState.value);
// => 'red'

LANGUAGE: javascript
CODE:
import { createMachine, interpret } from 'xstate';

const mouseMachine = createMachine({
  on: {
    mousemove: {
      actions: [
        (context, event) => {
          const { offsetX, offsetY } = event;
          console.log({ offsetX, offsetY });
        }
      ]
    }
  }
});
const mouseService = interpret(mouseMachine).start();

window.addEventListener('mousemove', (event) => {
  // event can be sent directly to service
  mouseService.send(event);
});

----------------------------------------

TITLE: State Node Types Example
DESCRIPTION: Demonstration of different state node types including atomic, compound, parallel, final, and history states with explicit type definitions.

LANGUAGE: javascript
CODE:
const machine = createMachine({
  id: 'fetch',
  initial: 'idle',
  states: {
    idle: {
      type: 'atomic',
      on: {
        FETCH: { target: 'pending' }
      }
    },
    pending: {
      type: 'parallel',
      states: {
        resource1: {
          type: 'compound',
          initial: 'pending',
          states: {
            pending: {
              on: {
                'FULFILL.resource1': { target: 'success' }
              }
            },
            success: {
              type: 'final'
            }
          }
        },
        resource2: {
          type: 'compound',
          initial: 'pending',
          states: {
            pending: {
              on: {
                'FULFILL.resource2': { target: 'success' }
              }
            },
            success: {
              type: 'final'
            }
          }
        }
      },
      onDone: 'success'
    },
    success: {
      type: 'compound',
      initial: 'items',
      states: {
        items: {
          on: {
            'ITEM.CLICK': { target: 'item' }
          }
        },
        item: {
          on: {
            BACK: { target: 'items' }
          }
        },
        hist: {
          type: 'history',
          history: 'shallow'
        }
      }
    }
  }
});

----------------------------------------

TITLE: Adding Transitions to Promise State Machine
DESCRIPTION: Enhancing the Promise state machine with transitions between states.

LANGUAGE: javascript
CODE:
import { createMachine } from 'xstate';

const promiseMachine = createMachine({
  id: 'promise',
  initial: 'pending',
  states: {
    pending: {
      on: {
        RESOLVE: { target: 'resolved' },
        REJECT: { target: 'rejected' }
      }
    },
    resolved: {},
    rejected: {}
  }
});

----------------------------------------

TITLE: Transient Transitions in XState
DESCRIPTION: Shows how to use transient transitions that are taken immediately upon entering a state if conditions are met, without requiring an event trigger.

LANGUAGE: javascript
CODE:
const gameMachine = createMachine(
  {
    id: 'game',
    initial: 'playing',
    context: {
      points: 0
    },
    states: {
      playing: {
        on: {
          // Transient transition
          // Will transition to either 'win' or 'lose' immediately upon
          // (re)entering 'playing' state if the condition is met.
          '': [
            { target: 'win', cond: 'didPlayerWin' },
            { target: 'lose', cond: 'didPlayerLose' }
          ],
          // Self-transition
          AWARD_POINTS: {
            actions: assign({
              points: 100
            })
          }
        }
      },
      win: { type: 'final' },
      lose: { type: 'final' }
    }
  },
  {
    guards: {
      didPlayerWin: (context, event) => {
        // check if player won
        return context.points > 99;
      },
      didPlayerLose: (context, event) => {
        // check if player lost
        return context.points < 0;
      }
    }
  }
);

const gameService = interpret(gameMachine)
  .onTransition((state) => console.log(state.value))
  .start();

// Still in 'playing' state because no conditions of
// transient transition were met
// => 'playing'

// When 'AWARD_POINTS' is sent, a self-transition to 'PLAYING' occurs.
// The transient transition to 'win' is taken because the 'didPlayerWin'
// condition is satisfied.
gameService.send({ type: 'AWARD_POINTS' });
// => 'win'

----------------------------------------

TITLE: Basic Toggle State Machine Implementation in TypeScript
DESCRIPTION: Demonstrates creating a simple toggle state machine with context that tracks count. Shows basic machine creation, actor instantiation, and event handling.

LANGUAGE: typescript
CODE:
import { createMachine, createActor, assign } from 'xstate';

// State machine
const toggleMachine = createMachine({
  id: 'toggle',
  initial: 'inactive',
  context: {
    count: 0
  },
  states: {
    inactive: {
      on: {
        TOGGLE: { target: 'active' }
      }
    },
    active: {
      entry: assign({ count: ({ context }) => context.count + 1 }),
      on: {
        TOGGLE: { target: 'inactive' }
      }
    }
  }
});

// Actor (instance of the machine logic, like a store)
const toggleActor = createActor(toggleMachine);
toggleActor.subscribe((state) => console.log(state.value, state.context));
toggleActor.start();
// => logs 'inactive', { count: 0 }

toggleActor.send({ type: 'TOGGLE' });
// => logs 'active', { count: 1 }

toggleActor.send({ type: 'TOGGLE' });
// => logs 'inactive', { count: 1 }

----------------------------------------

TITLE: Defining State Nodes in XState JavaScript
DESCRIPTION: Example of defining state nodes in an XState machine, including idle, pending, success, and failure states with transitions.

LANGUAGE: javascript
CODE:
const fetchMachine = createMachine({
  id: 'fetch',

  // Initial state
  initial: 'idle',

  // States
  states: {
    idle: {
      on: {
        FETCH: { target: 'pending' }
      }
    },
    pending: {
      on: {
        FULFILL: { target: 'success' },
        REJECT: { target: 'failure' }
      }
    },
    success: {
      // Initial child state
      initial: 'items',

      // Child states
      states: {
        items: {
          on: {
            'ITEM.CLICK': { target: 'item' }
          }
        },
        item: {
          on: {
            BACK: { target: 'items' }
          }
        }
      }
    },
    failure: {
      on: {
        RETRY: { target: 'pending' }
      }
    }
  }
});

----------------------------------------

TITLE: Dynamic Delay Expressions in XState
DESCRIPTION: Shows how to use dynamic delays in transitions using context-based delay expressions and string delay references.

LANGUAGE: javascript
CODE:
const lightDelayMachine = createMachine(
  {
    id: 'lightDelay',
    initial: 'green',
    context: {
      trafficLevel: 'low'
    },
    states: {
      green: {
        after: {
          LIGHT_DELAY: { target: 'yellow' }
        }
      },
      yellow: {
        after: {
          YELLOW_LIGHT_DELAY: { target: 'red' }
        }
      }
    }
  },
  {
    delays: {
      LIGHT_DELAY: (context, event) => {
        return context.trafficLevel === 'low' ? 1000 : 3000;
      },
      YELLOW_LIGHT_DELAY: 500
    }
  }
);

----------------------------------------

TITLE: Internal Transitions in XState
DESCRIPTION: This snippet illustrates how to define internal transitions in XState, which do not exit the current state node.

LANGUAGE: javascript
CODE:
import { createMachine } from 'xstate';

const wordMachine = createMachine({
  id: 'word',
  initial: 'left',
  states: {
    left: {},
    right: {},
    center: {},
    justify: {}
  },
  on: {
    // internal transitions
    LEFT_CLICK: '.left',
    RIGHT_CLICK: { target: '.right' }, // same as '.right'
    CENTER_CLICK: { target: '.center', internal: true }, // same as '.center'
    JUSTIFY_CLICK: { target: '.justify', internal: true } // same as '.justify'
  }
});

----------------------------------------

TITLE: Custom State Node IDs in XState
DESCRIPTION: Shows how to assign and use custom IDs for state nodes, allowing for more flexible targeting in complex statecharts.

LANGUAGE: javascript
CODE:
const lightMachine = createMachine({
  id: 'light',
  initial: 'green',
  states: {
    green: {
      // custom identifier
      id: 'greenLight',
      on: {
        // target state node by its ID
        TIMER: { target: '#yellowLight' }
      }
    },
    yellow: {
      id: 'yellowLight',
      on: {
        TIMER: { target: '#redLight' }
      }
    },
    red: {
      id: 'redLight',
      on: {
        // relative targets will still work
        TIMER: { target: 'green' }
      }
    }
  }
});

----------------------------------------

TITLE: Transitioning Parallel States in XState
DESCRIPTION: Demonstrates how to transition between states in a parallel state machine using object state values. Shows how transitions affect only the relevant parallel state while maintaining the other state's value.

LANGUAGE: javascript
CODE:
console.log(
  fileMachine.transition(
    {
      upload: 'pending',
      download: 'idle'
    },
    { type: 'UPLOAD_COMPLETE' }
  ).value
);

----------------------------------------

TITLE: Implementing 'In State' Guards in XState
DESCRIPTION: This snippet demonstrates how to use 'in state' guards in XState. It shows a traffic light machine that uses an 'in' guard to ensure the transition to green only occurs when the red light is in the 'stop' state.

LANGUAGE: javascript
CODE:
const lightMachine = createMachine({
  id: 'light',
  initial: 'green',
  states: {
    green: {
      on: {
        TIMER: { target: 'yellow' }
      }
    },
    yellow: {
      on: {
        TIMER: { target: 'red' }
      }
    },
    red: {
      initial: 'walk',
      states: {
        walk: {
          /* ... */
        },
        wait: {
          /* ... */
        },
        stop: {
          /* ... */
        }
      },
      on: {
        TIMER: [
          {
            target: 'green',
            in: '#light.red.stop'
          }
        ]
      }
    }
  }
});

----------------------------------------

TITLE: Implementing Custom Guards in XState
DESCRIPTION: This snippet shows how to implement custom guards in XState using serialized objects. It allows for more complex guard logic to be serialized in JSON format.

LANGUAGE: javascript
CODE:
const searchMachine = createMachine(
  {
    // ...
    states: {
      idle: {
        on: {
          SEARCH: {
            target: 'searching',
            // Custom guard object
            cond: {
              type: 'searchValid',
              minQueryLength: 3
            }
          }
        }
      }
      // ...
    }
  },
  {
    guards: {
      searchValid: (context, event, { cond }) => {
        // cond === { type: 'searchValid', minQueryLength: 3 }
        return (
          context.canSearch &&
          event.query &&
          event.query.length > cond.minQueryLength
        );
      }
    }
  }
);

----------------------------------------

TITLE: Conditional Delayed Transitions in XState
DESCRIPTION: Demonstrates how to implement conditional delayed transitions based on traffic conditions with multiple possible delays.

LANGUAGE: javascript
CODE:
states: {
  green: {
    after: {
      1000: { target: 'yellow', cond: 'trafficIsLight' },
      2000: { target: 'yellow' } // always transition to 'yellow' after 2 seconds
    }
  }
}

----------------------------------------

TITLE: Delayed Events with Cancel Actions in XState
DESCRIPTION: Implements delayed event sending with the ability to cancel pending events using unique event IDs.

LANGUAGE: javascript
CODE:
const toggleMachine = createMachine({
  id: 'toggle',
  initial: 'inactive',
  states: {
    inactive: {
      entry: send({ type: 'TIMER' }, { delay: 1000, id: 'oneSecondTimer' }),
      on: {
        TIMER: { target: 'active' },
        CANCEL: { actions: cancel('oneSecondTimer') }
      }
    },
    active: {}
  }
});

----------------------------------------

TITLE: Conditional Delayed Transitions in XState
DESCRIPTION: Demonstrates how to implement conditional delayed transitions based on traffic conditions with multiple possible delays.

LANGUAGE: javascript
CODE:
states: {
  green: {
    after: {
      1000: { target: 'yellow', cond: 'trafficIsLight' },
      2000: { target: 'yellow' } // always transition to 'yellow' after 2 seconds
    }
  }
}

----------------------------------------

TITLE: Controlling Action Execution in XState Service
DESCRIPTION: Demonstrates how to control when actions are executed in an XState service by using the execute option and manually calling service.execute().

LANGUAGE: javascript
CODE:
const service = interpret(machine, {
  execute: false // do not execute actions on state transitions
});

service.onTransition((state) => {
  // execute actions on next animation frame
  // instead of immediately
  requestAnimationFrame(() => service.execute(state));
});

service.start();

----------------------------------------

TITLE: Creating a Traffic Light Machine with Nested States in JavaScript
DESCRIPTION: This snippet demonstrates how to create a traffic light state machine using XState, including nested pedestrian states within the 'red' state. It showcases the use of compound states and event transitions between different states and substates.

LANGUAGE: javascript
CODE:
const pedestrianStates = {
  initial: 'walk',
  states: {
    walk: {
      on: {
        PED_COUNTDOWN: { target: 'wait' }
      }
    },
    wait: {
      on: {
        PED_COUNTDOWN: { target: 'stop' }
      }
    },
    stop: {},
    blinking: {}
  }
};

const lightMachine = createMachine({
  key: 'light',
  initial: 'green',
  states: {
    green: {
      on: {
        TIMER: { target: 'yellow' }
      }
    },
    yellow: {
      on: {
        TIMER: { target: 'red' }
      }
    },
    red: {
      on: {
        TIMER: { target: 'green' }
      },
      ...pedestrianStates
    }
  },
  on: {
    POWER_OUTAGE: { target: '.red.blinking' },
    POWER_RESTORED: { target: '.red' }
  }
});

----------------------------------------

TITLE: Transitioning States with Events in XState
DESCRIPTION: Demonstrates how to use the transition method to move between states in an XState machine by sending events.

LANGUAGE: javascript
CODE:
import { createMachine } from 'xstate';

const lightMachine = createMachine({
  /* ... */
});

const { initialState } = lightMachine;

let nextState = lightMachine.transition(initialState, { type: 'TIMER' }); // string event
console.log(nextState.value);
// => 'yellow'

nextState = lightMachine.transition(nextState, { type: { type: 'TIMER' } }); // event object
console.log(nextState.value);
// => 'red'

----------------------------------------

TITLE: Using Send Action in XState
DESCRIPTION: This snippet shows how to use the send action creator to send events within a state machine.

LANGUAGE: javascript
CODE:
import { createMachine, send } from 'xstate';

const lazyStubbornMachine = createMachine({
  id: 'stubborn',
  initial: 'inactive',
  states: {
    inactive: {
      on: {
        TOGGLE: {
          target: 'active',
          // send the TOGGLE event again to the service
          actions: send('TOGGLE')
        }
      }
    },
    active: {
      on: {
        TOGGLE: { target: 'inactive' }
      }
    }
  }
});

----------------------------------------

TITLE: Implementing Final States in XState JavaScript
DESCRIPTION: This code snippet demonstrates how to declare final states in an XState machine, including examples of compound states, parallel states, and onDone transitions.

LANGUAGE: javascript
CODE:
const lightMachine = createMachine({
  id: 'light',
  initial: 'green',
  states: {
    green: {
      on: {
        TIMER: { target: 'yellow' }
      }
    },
    yellow: {
      on: {
        TIMER: { target: 'red' }
      }
    },
    red: {
      type: 'parallel',
      states: {
        crosswalkNorth: {
          initial: 'walk',
          states: {
            walk: {
              on: {
                PED_WAIT: { target: 'wait' }
              }
            },
            wait: {
              on: {
                PED_STOP: { target: 'stop' }
              }
            },
            stop: {
              // 'stop' is a final state node for 'crosswalkNorth'
              type: 'final'
            }
          },
          onDone: {
            actions: 'stopCrosswalkNorth'
          }
        },
        crosswalkEast: {
          initial: 'walk',
          states: {
            walk: {
              on: {
                PED_WAIT: { target: 'wait' }
              }
            },
            wait: {
              on: {
                PED_STOP: { target: 'stop' }
              }
            },
            stop: {
              // 'stop' is a final state node for 'crosswalkEast'
              type: 'final'
            }
          },
          onDone: {
            actions: 'stopCrosswalkEast'
          }
        }
      },
      onDone: 'green'
    }
  }
});

----------------------------------------

TITLE: Implementing Nested Parallel States in Traffic Light System
DESCRIPTION: Creates a complex state machine for a traffic light system with nested parallel states controlling walk signs and pedestrian signals within the red light state.

LANGUAGE: javascript
CODE:
const lightMachine = createMachine({
  id: 'light',
  initial: 'green',
  states: {
    green: {
      on: {
        TIMER: { target: 'yellow' }
      }
    },
    yellow: {
      on: {
        TIMER: { target: 'red' }
      }
    },
    red: {
      type: 'parallel',
      states: {
        walkSign: {
          initial: 'solid',
          states: {
            solid: {
              on: {
                COUNTDOWN: { target: 'flashing' }
              }
            },
            flashing: {
              on: {
                STOP_COUNTDOWN: { target: 'solid' }
              }
            }
          }
        },
        pedestrian: {
          initial: 'walk',
          states: {
            walk: {
              on: {
                COUNTDOWN: { target: 'wait' }
              }
            },
            wait: {
              on: {
                STOP_COUNTDOWN: { target: 'stop' }
              }
            },
            stop: {
              type: 'final'
            }
          }
        }
      }
    }
  }
});

console.log(lightMachine.transition('yellow', { type: 'TIMER' }).value);

----------------------------------------

TITLE: External Transitions with Relative Targets in XState
DESCRIPTION: Demonstrates how to make relative targets use external transitions by setting internal: false.

LANGUAGE: javascript
CODE:
on: {
  SELECT_FIRST: {
    target: { target: '.first' },
    internal: false // external transition, will exit/reenter parent state node
  }
}

----------------------------------------

TITLE: XState Invoke and SCXML Invoke Elements
DESCRIPTION: Demonstrates the correspondence between XState's invoke property and SCXML's invoke element for service invocation.

LANGUAGE: javascript
CODE:
{
  loading: {
    invoke: {
      src: 'someSource',
      id: 'someID',
      autoForward: true,
      onDone: 'success',
      onError: 'failure'
    }
  }
}

LANGUAGE: xml
CODE:
<state id="loading">
  <invoke id="someID" src="someSource" autoforward />
  <transition event="done.invoke.someID" target="success" />
  <transition event="error.platform" cond="_event.src === 'someID'" target="failure" />
</state>

----------------------------------------

TITLE: Implementing Basic Delayed Transitions in XState
DESCRIPTION: Creates a traffic light state machine with automatic transitions after specified delays. Each state transitions to the next state after a fixed time delay.

LANGUAGE: javascript
CODE:
const lightDelayMachine = createMachine({
  id: 'lightDelay',
  initial: 'green',
  states: {
    green: {
      after: {
        // after 1 second, transition to yellow
        1000: { target: 'yellow' }
      }
    },
    yellow: {
      after: {
        // after 0.5 seconds, transition to red
        500: { target: 'red' }
      }
    },
    red: {
      after: {
        // after 2 seconds, transition to green
        2000: { target: 'green' }
      }
    }
  }
});

----------------------------------------

TITLE: Dynamic Delay Expressions in XState
DESCRIPTION: Shows how to use dynamic delay expressions that can change based on context or events. Includes both string delay references and direct function implementations.

LANGUAGE: javascript
CODE:
const lightDelayMachine = createMachine(
  {
    id: 'lightDelay',
    initial: 'green',
    context: {
      trafficLevel: 'low'
    },
    states: {
      green: {
        after: {
          LIGHT_DELAY: { target: 'yellow' }
        }
      },
      yellow: {
        after: {
          YELLOW_LIGHT_DELAY: { target: 'red' }
        }
      }
    }
  },
  {
    delays: {
      LIGHT_DELAY: (context, event) => {
        return context.trafficLevel === 'low' ? 1000 : 3000;
      },
      YELLOW_LIGHT_DELAY: 500
    }
  }
);

----------------------------------------

TITLE: Creating a Fan State Machine with History States in JavaScript
DESCRIPTION: This code snippet demonstrates the creation of a state machine for a fan with history states. It includes shallow history states and shows how to configure them with default targets.

LANGUAGE: javascript
CODE:
const fanMachine = createMachine({
  id: 'fan',
  initial: 'fanOff',
  states: {
    fanOff: {
      on: {
        // transitions to history state
        POWER: { target: 'fanOn.hist' },
        HIGH_POWER: { target: 'fanOn.highPowerHist' }
      }
    },
    fanOn: {
      initial: 'first',
      states: {
        first: {
          on: {
            SWITCH: { target: 'second' }
          }
        },
        second: {
          on: {
            SWITCH: { target: 'third' }
          }
        },
        third: {},

        // shallow history state
        hist: {
          type: 'history',
          history: 'shallow' // optional; default is 'shallow'
        },

        // shallow history state with default
        highPowerHist: {
          type: 'history',
          target: 'third'
        }
      },
      on: {
        POWER: { target: 'fanOff' }
      }
    }
  }
});

----------------------------------------

TITLE: Hierarchical Transitions in XState
DESCRIPTION: Illustrates how transitions are prioritized in a hierarchical state machine, with deeper transitions having higher priority.

LANGUAGE: javascript
CODE:
const wizardMachine = createMachine({
  id: 'wizard',
  initial: 'open',
  states: {
    open: {
      initial: 'step1',
      states: {
        step1: {
          on: {
            NEXT: { target: 'step2' }
          }
        },
        step2: {
          /* ... */
        },
        step3: {
          /* ... */
        }
      },
      on: {
        NEXT: { target: 'goodbye' },
        CLOSE: { target: 'closed' }
      }
    },
    goodbye: {
      on: {
        CLOSE: { target: 'closed' }
      }
    },
    closed: {
      type: 'final'
    }
  }
});

// { open: 'step1' }
const { initialState } = wizardMachine;

// the NEXT transition defined on 'open.step1'
// supersedes the NEXT transition defined
// on the parent 'open' state
const nextStepState = wizardMachine.transition(initialState, { type: 'NEXT' });
console.log(nextStepState.value);
// => { open: 'step2' }

// there is no CLOSE transition on 'open.step1'
// so the event is passed up to the parent
// 'open' state, where it is defined
const closedState = wizardMachine.transition(initialState, { type: 'CLOSE' });
console.log(closedState.value);
// => 'closed'

----------------------------------------

TITLE: Converting Activities to Actors in XState
DESCRIPTION: Shows how to migrate from deprecated activities to the recommended actor-based approach in XState v5.

LANGUAGE: diff
CODE:
-activities: [(context, event) => {
-  // do something
-
-  return () => {/* cleanup */}
-}],
+invoke: {
+  src: (context, event) => (sendBack, receive) => {
+    // do something
+
+    return () => {/* cleanup */}
+  }
+}

----------------------------------------

TITLE: Invoke Implementation in XState and SCXML
DESCRIPTION: Demonstrates how service invocation is handled in both XState and SCXML, including success and error handling.

LANGUAGE: javascript
CODE:
{
  loading: {
    invoke: {
      src: 'someSource',
      id: 'someID',
      autoForward: true,
      onDone: 'success',
      onError: 'failure'
    }
  }
}

LANGUAGE: xml
CODE:
<state id="loading">
  <invoke id="someID" src="someSource" autoforward />
  <transition event="done.invoke.someID" target="success" />
  <transition event="error.platform" cond="_event.src === 'someID'" target="failure" />
</state>

----------------------------------------

TITLE: Implementing Parallel Tasks with Final States in XState JavaScript
DESCRIPTION: This code snippet shows how to use final states in parallel tasks within an XState machine, demonstrating the concept of a shopping cart with user and items as parallel states.

LANGUAGE: javascript
CODE:
const shoppingMachine = createMachine({
  id: 'shopping',
  initial: 'cart',
  states: {
    cart: {
      type: 'parallel',
      states: {
        user: {
          initial: 'pending',
          states: {
            pending: {
              entry: 'getUser',
              on: {
                RESOLVE_USER: { target: 'success' },
                REJECT_USER: { target: 'failure' }
              }
            },
            success: { type: 'final' },
            failure: {}
          }
        },
        items: {
          initial: 'pending',
          states: {
            pending: {
              entry: 'getItems',
              on: {
                RESOLVE_ITEMS: { target: 'success' },
                REJECT_ITEMS: { target: 'failure' }
              }
            },
            success: { type: 'final' },
            failure: {}
          }
        }
      },
      onDone: 'confirm'
    },
    confirm: {
      // ...
    }
  }
});

----------------------------------------

TITLE: Using Choose Action in XState
DESCRIPTION: This snippet shows how to use the choose action creator to conditionally execute actions based on certain conditions.

LANGUAGE: javascript
CODE:
import { actions } from 'xstate';

const { choose, log } = actions;

const maybeDoThese = choose([
  {
    cond: 'cond1',
    actions: [
      // selected when "cond1" is true
      log('cond1 chosen!')
    ]
  },
  {
    cond: 'cond2',
    actions: [
      // selected when "cond1" is false and "cond2" is true
      log((context, event) => {
        /* ... */
      }),
      log('another action')
    ]
  },
  {
    cond: (context, event) => {
      // some condition
      return false;
    },
    actions: [
      // selected when "cond1" and "cond2" are false and the inline `cond` is true
      (context, event) => {
        // some other action
      }
    ]
  },
  {
    actions: [
      log('fall-through action')
      // selected when "cond1", "cond2", and "cond3" are false
    ]
  }
]);

----------------------------------------

TITLE: Entry vs Transition Actions in XState
DESCRIPTION: Shows the difference between using entry actions versus transition actions, with examples of when to use each approach.

LANGUAGE: javascript
CODE:
// Entry action example
{
  idle: {
    on: {
      LOAD: 'loading'
    }
  },
  loading: {
    // this action is executed whenever the 'loading' state is entered
    entry: 'fetchData'
  }
}

// Transition action example
{
  idle: {
    on: {
      LOAD: {
        target: 'loading',
        // this action is executed only on this transition
        actions: 'fetchData'
    }
  },
  loading: {
    // ...
  }
}

----------------------------------------

TITLE: Invoking a Child Machine in XState
DESCRIPTION: Demonstrates invoking a child machine from a parent machine, including parent-to-child and child-to-parent communication.

LANGUAGE: javascript
CODE:
import { createMachine, interpret, send, sendParent } from 'xstate';

// Invoked child machine
const minuteMachine = createMachine({
  id: 'timer',
  initial: 'active',
  states: {
    active: {
      after: {
        60000: { target: 'finished' }
      }
    },
    finished: { type: 'final' }
  }
});

const parentMachine = createMachine({
  id: 'parent',
  initial: 'pending',
  states: {
    pending: {
      invoke: {
        src: minuteMachine,
        onDone: 'timesUp'
      }
    },
    timesUp: {
      type: 'final'
    }
  }
});

----------------------------------------

TITLE: Traffic Light State Machine Example
DESCRIPTION: Shows implementation of a traffic light system using finite state machines with simple transitions between green, yellow and red states.

LANGUAGE: javascript
CODE:
import { createMachine, createActor } from 'xstate';

const lightMachine = createMachine({
  id: 'light',
  initial: 'green',
  states: {
    green: {
      on: {
        TIMER: 'yellow'
      }
    },
    yellow: {
      on: {
        TIMER: 'red'
      }
    },
    red: {
      on: {
        TIMER: 'green'
      }
    }
  }
});

const actor = createActor(lightMachine);

actor.subscribe((state) => {
  console.log(state.value);
});

actor.start();
// logs 'green'

actor.send({ type: 'TIMER' });
// logs 'yellow'

----------------------------------------

TITLE: Using Raise Action in XState
DESCRIPTION: This snippet demonstrates how to use the raise action creator to immediately queue an event in the internal event queue.

LANGUAGE: javascript
CODE:
import { createMachine, raise } from 'xstate';

const raiseActionDemo = createMachine({
  id: 'raisedmo',
  initial: 'entry',
  states: {
    entry: {
      on: {
        STEP: {
          target: 'middle'
        },
        RAISE: {
          target: 'middle',
          // immediately invoke the NEXT event for 'middle'
          actions: raise({ type: 'NEXT' })
        }
      }
    },
    middle: {
      on: {
        NEXT: { target: 'last' }
      }
    },
    last: {
      on: {
        RESET: { target: 'entry' }
      }
    }
  }
});

----------------------------------------

TITLE: Implementing Parallel File Upload/Download State Machine in XState
DESCRIPTION: Creates a parallel state machine that handles file uploads and downloads simultaneously. Each operation has its own independent state flow (idle -> pending -> success) and can transition independently of the other.

LANGUAGE: javascript
CODE:
const fileMachine = createMachine({
  id: 'file',
  type: 'parallel',
  states: {
    upload: {
      initial: 'idle',
      states: {
        idle: {
          on: {
            INIT_UPLOAD: { target: 'pending' }
          }
        },
        pending: {
          on: {
            UPLOAD_COMPLETE: { target: 'success' }
          }
        },
        success: {}
      }
    },
    download: {
      initial: 'idle',
      states: {
        idle: {
          on: {
            INIT_DOWNLOAD: { target: 'pending' }
          }
        },
        pending: {
          on: {
            DOWNLOAD_COMPLETE: { target: 'success' }
          }
        },
        success: {}
      }
    }
  }
});

console.log(fileMachine.initialState.value);

----------------------------------------

TITLE: XState and SCXML Transition Comparison
DESCRIPTION: Shows equivalent transition definitions in XState JavaScript and SCXML XML formats, demonstrating conditional transitions and multiple event handling.

LANGUAGE: javascript
CODE:
{
  green: {
    on: {
      TIMER: {
        target: '#yellow',
        cond: context => context.timeElapsed > 5000
      },
      POWER_OUTAGE: { target: '#red.flashing' }
    }
  }
}

LANGUAGE: xml
CODE:
<state id="green">
  <transition
    event="TIMER"
    target="yellow"
    cond="timeElapsed > 5000"
  />
  <transition
    event="POWER_OUTAGE"
    target="red.flashing"
  />
</state>

----------------------------------------

TITLE: Targeting State Nodes by Default ID in XState
DESCRIPTION: This snippet demonstrates how to create a simple state machine for a traffic light, using default state node IDs to target transitions.

LANGUAGE: javascript
CODE:
const lightMachine = createMachine({
  id: 'light',
  initial: 'green',
  states: {
    green: {
      // default ID: 'light.green'
      on: {
        // You can target state nodes by their default ID.
        // This is the same as TIMER: 'yellow'
        TIMER: { target: '#light.yellow' }
      }
    },
    yellow: {
      on: {
        TIMER: { target: 'red' }
      }
    },
    red: {
      on: {
        TIMER: { target: 'green' }
      }
    }
  }
});

----------------------------------------

TITLE: Using Tags and Checking Possible Events in XState
DESCRIPTION: Demonstrates how to use state.hasTag() to check for tagged states and state.can() to determine if an event will cause a state change.

LANGUAGE: javascript
CODE:
const machine = createMachine({
  initial: 'green',
  states: {
    green: {
      tags: 'go' // single tag
    },
    yellow: {
      tags: 'go'
    },
    red: {
      tags: ['stop', 'other'] // multiple tags
    }
  }
});

const canGo = state.hasTag('go');
// => `true` if in 'green' or 'yellow' state

const machine = createMachine({
  initial: 'inactive',
  states: {
    inactive: {
      on: {
        TOGGLE: 'active'
      }
    },
    active: {
      on: {
        DO_SOMETHING: { actions: ['something'] }
      }
    }
  }
});

const inactiveState = machine.initialState;

inactiveState.can({ type: 'TOGGLE' }); // true
inactiveState.can({ type: 'DO_SOMETHING' }); // false

----------------------------------------

TITLE: Multiple Targets in XState Transitions
DESCRIPTION: This snippet shows how to define transitions with multiple target state nodes in XState.

LANGUAGE: javascript
CODE:
const settingsMachine = createMachine({
  id: 'settings',
  type: 'parallel',
  states: {
    mode: {
      initial: 'active',
      states: {
        inactive: {},
        pending: {},
        active: {}
      }
    },
    status: {
      initial: 'enabled',
      states: {
        disabled: {},
        enabled: {}
      }
    }
  },
  on: {
    // Multiple targets
    DEACTIVATE: {
      target: ['.mode.inactive', '.status.disabled']
    }
  }
});

----------------------------------------

TITLE: Actions Implementation in XState and SCXML
DESCRIPTION: Shows how entry, exit, and transition actions are defined in both XState and SCXML syntaxes.

LANGUAGE: javascript
CODE:
{
  start: {
    entry: 'showStartScreen',
    exit: 'logScreenChange',
    on: {
      STOP: {
        target: 'stop',
        actions: ['logStop', 'stopEverything']
      }
    }
  }
}

LANGUAGE: xml
CODE:
<state id="start">
  <onentry>
    <script>showStartScreen();</script>
  </onentry>
  <onexit>
    <script>logScreenChange();</script>
  </onexit>
  <transition event="STOP" target="stop">
    <script>logStop();</script>
    <script>stopEverything();</script>
  </transition>
</state>

----------------------------------------

TITLE: Implementing Asynchronous Sequences with XState and API Calls
DESCRIPTION: This example demonstrates how to model an asynchronous sequence using XState. It involves fetching user information and then fetching the user's friends, using Promise-based API calls and invoking services in sequence.

LANGUAGE: javascript
CODE:
function getUserInfo(context) {
  return fetch(`/api/users/${context.userId}`).then((response) =>
    response.json()
  );
}

function getUserFriends(context) {
  const { friends } = context.user;

  return Promise.all(
    friends.map((friendId) =>
      fetch(`/api/users/${friendId}/`).then((response) => response.json())
    )
  );
}

const friendsMachine = createMachine({
  id: 'friends',
  context: { userId: 42, user: undefined, friends: undefined },
  initial: 'gettingUser',
  states: {
    gettingUser: {
      invoke: {
        src: getUserInfo,
        onDone: {
          target: 'gettingFriends',
          actions: assign({
            user: (context, event) => event.data
          })
        }
      }
    },
    gettingFriends: {
      invoke: {
        src: getUserFriends,
        onDone: {
          target: 'success',
          actions: assign({
            friends: (context, event) => event.data
          })
        }
      }
    },
    success: {
      type: 'final'
    }
  }
});

----------------------------------------

TITLE: Sending Batched Events to XState Service
DESCRIPTION: Demonstrates how to send multiple events as a batch to a running XState service, including both string events and event objects.

LANGUAGE: javascript
CODE:
service.send([
  // String events
  'CLICK',
  'CLICK',
  'ANOTHER_EVENT',
  // Event objects
  { type: 'CLICK', x: 40, y: 21 },
  { type: 'KEYDOWN', key: 'Escape' }
]);

----------------------------------------

TITLE: Using Relative Targets in XState
DESCRIPTION: This example shows how to use relative targets in XState, allowing child state nodes to be targeted relative to their parent using dot notation.

LANGUAGE: javascript
CODE:
const optionsMachine = createMachine({
  id: 'options',
  initial: 'first',
  states: {
    first: {},
    second: {},
    third: {}
  },
  on: {
    SELECT_FIRST: { target: '.first' }, // resolves to 'options.first'
    SELECT_SECOND: { target: '.second' }, // 'options.second'
    SELECT_THIRD: { target: '.third' } // 'options.third'
  }
});

----------------------------------------

TITLE: Wildcard Descriptors in XState
DESCRIPTION: This example demonstrates the use of wildcard event descriptors in XState, which are activated by any event.

LANGUAGE: javascript
CODE:
const quietMachine = createMachine({
  id: 'quiet',
  initial: 'idle',
  states: {
    idle: {
      on: {
        WHISPER: undefined,
        // On any event besides a WHISPER, transition to the 'disturbed' state
        '*': 'disturbed'
      }
    },
    disturbed: {}
  }
});

quietMachine.transition(quietMachine.initialState, { type: 'WHISPER' });
// => State { value: 'idle' }

quietMachine.transition(quietMachine.initialState, { type: 'SOME_EVENT' });
// => State { value: 'disturbed' }

----------------------------------------

TITLE: Using XState Global Variable
DESCRIPTION: Example of accessing XState functionality through the global variable after loading via CDN. Shows basic machine creation and interpretation.

LANGUAGE: javascript
CODE:
const { createMachine, actions, interpret } = XState; // global variable: window.XState

const lightMachine = createMachine({
  // ...
});

const lightService = interpret(lightMachine);

----------------------------------------

TITLE: Interpreting and Running State Machine in Node/Vanilla JS
DESCRIPTION: Example of how to interpret and run the Promise state machine in a Node.js or vanilla JavaScript environment.

LANGUAGE: javascript
CODE:
import { createMachine, interpret } from 'xstate';

const promiseMachine = createMachine({
  /* ... */
});

const promiseService = interpret(promiseMachine).onTransition((state) =>
  console.log(state.value)
);

// Start the service
promiseService.start();
// => 'pending'

promiseService.send({ type: 'RESOLVE' });
// => 'resolved'

----------------------------------------

TITLE: Adding Transition Listener to XState Service
DESCRIPTION: Shows how to add a state transition listener to an XState service, which is called every time a state transition occurs.

LANGUAGE: javascript
CODE:
// Interpret the machine
const service = interpret(machine);

// Add a state listener, which is called whenever a state transition occurs.
service.onTransition((state) => {
  console.log(state.value);
});

service.start();

----------------------------------------

TITLE: Specifying External Transitions with Relative Targets in XState
DESCRIPTION: This snippet demonstrates how to make relative targets external transitions by setting 'internal: false', causing the parent state to exit and reenter.

LANGUAGE: javascript
CODE:
// ...
on: {
  SELECT_FIRST: {
    target: '.first',
    internal: false // external transition, will exit/reenter parent state node
  }
}

----------------------------------------

TITLE: Transient Transitions in XState
DESCRIPTION: This example demonstrates transient transitions in XState, which are immediately taken without a triggering event if conditions are met.

LANGUAGE: javascript
CODE:
const gameMachine = createMachine(
  {
    id: 'game',
    initial: 'playing',
    context: {
      points: 0
    },
    states: {
      playing: {
        on: {
          // Transient transition
          // Will transition to either 'win' or 'lose' immediately upon
          // (re)entering 'playing' state if the condition is met.
          '': [
            { target: 'win', cond: 'didPlayerWin' },
            { target: 'lose', cond: 'didPlayerLose' }
          ],
          // Self-transition
          AWARD_POINTS: {
            actions: assign({
              points: 100
            })
          }
        }
      },
      win: { type: 'final' },
      lose: { type: 'final' }
    }
  },
  {
    guards: {
      didPlayerWin: (context, event) => {
        // check if player won
        return context.points > 99;
      },
      didPlayerLose: (context, event) => {
        // check if player lost
        return context.points < 0;
      }
    }
  }
);

const gameService = interpret(gameMachine)
  .onTransition((state) => console.log(state.value))
  .start();

// Still in 'playing' state because no conditions of
// transient transition were met
// => 'playing'

// When 'AWARD_POINTS' is sent, a self-transition to 'PLAYING' occurs.
// The transient transition to 'win' is taken because the 'didPlayerWin'
// condition is satisfied.
gameService.send({ type: 'AWARD_POINTS' });
// => 'win'

----------------------------------------

TITLE: Spawning a Callback Actor in XState
DESCRIPTION: Illustrates how to spawn a callback-based actor that implements a counter-interval functionality.

LANGUAGE: javascript
CODE:
const counterInterval = (callback, receive) => {
  let count = 0;

  const intervalId = setInterval(() => {
    callback({ type: 'COUNT.UPDATE', count });
    count++;
  }, 1000);

  receive(event => {
    if (event.type === 'INC') {
      count++;
    }
  });

  return () => { clearInterval(intervalId); }
}

const machine = createMachine({
  // ...
  {
    actions: assign({
      counterRef: () => spawn(counterInterval)
    })
  }
  // ...
});

----------------------------------------

TITLE: Custom XState Integration in Ember Component
DESCRIPTION: Shows how to manually integrate XState into an Ember component without addons. Implements state tracking, event handling, and proper lifecycle management.

LANGUAGE: handlebars
CODE:
<button type='button' {{on 'click' (fn this.transition 'TOGGLE')}}>
  {{if this.isInactive 'Off' 'On'}}
</button>

LANGUAGE: javascript
CODE:
import Component from '@glimmer/component';
import { tracked } from '@glimmer/tracking';
import { action } from '@ember/object';
import { interpret } from 'xstate';
import { toggleMachine } from '../path/to/toggleMachine';

export default class ToggleButton extends Component {
  @tracked current;

  get context() {
    return this.current.context;
  }

  get isInactive() {
    return this.current.matches('inactive');
  }

  constructor() {
    super(...arguments);
    this.toggleInterpreter = interpret(toggleMachine);
    this.toggleInterpreter
      .onTransition((state) => (this.current = state))
      .start();
  }

  willDestroy() {
    super.willDestroy(...arguments);
    this.toggleInterpreter.stop();
  }

  @action
  transition(...args) {
    this.toggleInterpreter.send(...args);
  }
}

----------------------------------------

TITLE: Implementing Custom XState Interpreter
DESCRIPTION: Shows a minimal implementation of a custom interpreter for running XState machines, demonstrating how to manage current state, listeners, and event dispatching.

LANGUAGE: javascript
CODE:
const machine = createMachine(/* machine config */);

// Keep track of the current state, and start
// with the initial state
let currentState = machine.initialState;

// Keep track of the listeners
const listeners = new Set();

// Have a way of sending/dispatching events
function send(event) {
  // Remember: machine.transition() is a pure function
  currentState = machine.transition(currentState, event);

  // Get the side-effect actions to execute
  const { actions } = currentState;

  actions.forEach((action) => {
    // If the action is executable, execute it
    typeof action.exec === 'function' && action.exec();
  });

  // Notify the listeners
  listeners.forEach((listener) => listener(currentState));
}

function listen(listener) {
  listeners.add(listener);
}

function unlisten(listener) {
  listeners.delete(listener);
}

// Now you can listen and send events to update state
listen((state) => {
  console.log(state.value);
});

send('SOME_EVENT');

----------------------------------------

TITLE: Creating a Step Sequence Machine in JavaScript with XState
DESCRIPTION: This snippet demonstrates how to create a simple step sequence machine using XState. It defines three steps with transitions between them, including a final state. The machine allows moving forward with a 'NEXT' event and backwards with a 'PREV' event.

LANGUAGE: javascript
CODE:
const stepMachine = createMachine({
  id: 'step',
  initial: 'one',
  states: {
    one: {
      on: { NEXT: 'two' }
    },
    two: {
      on: { NEXT: 'three', PREV: 'one' }
    },
    three: {
      type: 'final'
    }
  }
});

console.log(stepMachine.transition('one', { type: 'NEXT' }).value);
// => 'two'

----------------------------------------

TITLE: Defining and Accessing State Metadata in XState
DESCRIPTION: Demonstrates how to define metadata for states in a machine and how to access this metadata from the current state.

LANGUAGE: javascript
CODE:
const fetchMachine = createMachine({
  id: 'fetch',
  initial: 'idle',
  states: {
    idle: {
      on: { FETCH: { target: 'loading' } }
    },
    loading: {
      after: {
        3000: 'failure.timeout'
      },
      on: {
        RESOLVE: { target: 'success' },
        REJECT: { target: 'failure' },
        TIMEOUT: { target: 'failure.timeout' } // manual timeout
      },
      meta: {
        message: 'Loading...'
      }
    },
    success: {
      meta: {
        message: 'The request succeeded!'
      }
    },
    failure: {
      initial: 'rejection',
      states: {
        rejection: {
          meta: {
            message: 'The request failed.'
          }
        },
        timeout: {
          meta: {
            message: 'The request timed out.'
          }
        }
      },
      meta: {
        alert: 'Uh oh.'
      }
    }
  }
});

const failureTimeoutState = fetchMachine.transition('loading', {
  type: 'TIMEOUT'
});

console.log(failureTimeoutState.meta);
// => {
//   failure: {
//     alert: 'Uh oh.'
//   },
//   'failure.timeout': {
//     message: 'The request timed out.'
//   }
// }

----------------------------------------

TITLE: Implementing Basic Delayed Transitions in XState
DESCRIPTION: Creates a traffic light state machine with automatic delayed transitions between states using millisecond delays in the 'after' property.

LANGUAGE: javascript
CODE:
const lightDelayMachine = createMachine({
  id: 'lightDelay',
  initial: 'green',
  states: {
    green: {
      after: {
        // after 1 second, transition to yellow
        1000: { target: 'yellow' }
      }
    },
    yellow: {
      after: {
        // after 0.5 seconds, transition to red
        500: { target: 'red' }
      }
    },
    red: {
      after: {
        // after 2 seconds, transition to green
        2000: { target: 'green' }
      }
    }
  }
});

----------------------------------------

TITLE: Using useActor in Vue Component
DESCRIPTION: Example of using the useActor composition function to subscribe to an actor in a Vue component.

LANGUAGE: javascript
CODE:
import { useActor } from '@xstate/vue';

const props = defineProps(['someSpawnedActor']);

const { state, send } = useActor(props.someSpawnedActor);

----------------------------------------

TITLE: Converting XState Service to RxJS Observable
DESCRIPTION: Shows how to convert an XState interpreted machine service into an RxJS observable stream using the 'from' operator. The service is started and then subscribed to for state updates.

LANGUAGE: javascript
CODE:
import { createMachine, interpret } from 'xstate';
import { from } from 'rxjs';

const machine = createMachine(/* ... */);
const service = interpret(machine).start();

const state$ = from(service);

state$.subscribe((state) => {
  // ...
});

----------------------------------------

TITLE: Creating a Glass Filling Machine with Context in XState
DESCRIPTION: This snippet demonstrates how to create a state machine that simulates filling a glass of water using context to track the amount of water.

LANGUAGE: javascript
CODE:
import { createMachine, assign } from 'xstate';

// Action to increment the context amount
const addWater = assign({
  amount: (context, event) => context.amount + 1
});

// Guard to check if the glass is full
function glassIsFull(context, event) {
  return context.amount >= 10;
}

const glassMachine = createMachine(
  {
    id: 'glass',
    // the initial context (extended state) of the statechart
    context: {
      amount: 0
    },
    initial: 'empty',
    states: {
      empty: {
        on: {
          FILL: {
            target: 'filling',
            actions: 'addWater'
          }
        }
      },
      filling: {
        // Transient transition
        always: {
          target: 'full',
          cond: 'glassIsFull'
        },
        on: {
          FILL: {
            target: 'filling',
            actions: 'addWater'
          }
        }
      },
      full: {}
    }
  },
  {
    actions: { addWater },
    guards: { glassIsFull }
  }
);

----------------------------------------

TITLE: Using getShortestPaths Function with Feedback Machine
DESCRIPTION: Example demonstrating the usage of getShortestPaths function with a feedback machine, including the machine definition and the resulting output structure.

LANGUAGE: javascript
CODE:
import { createMachine } from 'xstate';
import { getShortestPaths } from '@xstate/graph';

const feedbackMachine = createMachine({
  id: 'feedback',
  initial: 'question',
  states: {
    question: {
      on: {
        CLICK_GOOD: 'thanks',
        CLICK_BAD: 'form',
        CLOSE: 'closed',
        ESC: 'closed'
      }
    },
    form: {
      on: {
        SUBMIT: 'thanks',
        CLOSE: 'closed',
        ESC: 'closed'
      }
    },
    thanks: {
      on: {
        CLOSE: 'closed',
        ESC: 'closed'
      }
    },
    closed: {
      type: 'final'
    }
  }
});

const shortestPaths = getShortestPaths(feedbackMachine);

console.log(shortestPaths);

----------------------------------------

TITLE: SCXML Event Access in XState Actions and Guards
DESCRIPTION: Demonstrates how to access SCXML event data within XState action and guard functions through the _event property.

LANGUAGE: javascript
CODE:
{
  actions: {
    someAction: (context, event, { _event }) => {
      console.log(_event); // SCXML event
    };
  },
  guards: {
    someGuard: (context, event, { _event }) => {
      console.log(_event); // SCXML event
    }
  }
}

----------------------------------------

TITLE: Using useMachine in Vue Component
DESCRIPTION: Example of using the useMachine composition function in a Vue component to create a toggle button.

LANGUAGE: vue
CODE:
<script setup>
import { useMachine } from '@xstate/vue';
import { createMachine } from 'xstate';

const toggleMachine = createMachine({
  id: 'toggle',
  initial: 'inactive',
  states: {
    inactive: {
      on: { TOGGLE: 'active' }
    },
    active: {
      on: { TOGGLE: 'inactive' }
    }
  }
});

const { state, send } = useMachine(toggleMachine);
</script>

<template>
  <button @click="send('TOGGLE')">
    {{
      state.value === 'inactive'
        ? 'Click to activate'
        : 'Active! Click to deactivate'
    }}
  </button>
</template>

----------------------------------------

TITLE: Using useInterpret in Vue Component
DESCRIPTION: Example of using the useInterpret composition function to create and subscribe to a service in a Vue component.

LANGUAGE: javascript
CODE:
import { useInterpret } from '@xstate/vue';
import { someMachine } from '../path/to/someMachine';

const service = useInterpret(
  someMachine,
  {
    actions: {
      /* ... */
    }
  },
  (state) => {
    // subscribes to state changes
    console.log(state.value);
  }
);

----------------------------------------

TITLE: TypeScript Usage with XState Context and Assign
DESCRIPTION: This example demonstrates how to use TypeScript with XState for proper type inference of context and assign actions.

LANGUAGE: typescript
CODE:
import { createMachine } from 'xstate';

interface CounterContext {
  count: number;
  user?: {
    name: string;
  };
}

const machine = createMachine({
  schema: {
    context: {} as CounterContext
  },
  // ...
  context: {
    count: 0,
    user: undefined
  }
  // ...
});

// Using assign with TypeScript
const typedMachine = createMachine({
  schema: {
    context: {} as CounterContext
  },
  // ...
  context: {
    count: 0
  },
  // ...
  {
    on: {
      INCREMENT: {
        // Generics guarantee proper inference
        actions: assign<CounterContext, CounterEvent>({
          count: (context) => {
            // context: { count: number }
            return context.count + 1;
          }
        });
      }
    }
  }
});

----------------------------------------

TITLE: Using toDirectedGraph Function
DESCRIPTION: Example showing how to use the toDirectedGraph function to convert a machine to a directed graph structure.

LANGUAGE: javascript
CODE:
import { toDirectedGraph } from '@xstate/graph';

const machine = createMachine({/* ... */});

const digraph = toDirectedGraph(machine);

// returns an object with this structure:
{
  id: '...',
  stateNode: /* StateNode */,
  children: [
    { id: '...', children: [/* ... */], edges: [/* ... */] },
    { id: '...', /* ... */ },
    // ...
  ],
  edges: [
    { source: /* ... */, target: /* ... */, transition: /* ... */ }
    // ...
  ]
}

----------------------------------------

TITLE: XState State IDs and SCXML State Definition
DESCRIPTION: Shows how state IDs are defined in XState compared to SCXML state elements.

LANGUAGE: javascript
CODE:
{
  green: {
    id: 'lightGreen';
  }
}

LANGUAGE: xml
CODE:
<state id="lightGreen">
  <!-- ... -->
</state>

----------------------------------------

TITLE: Extracting Types from XState Models
DESCRIPTION: Demonstrates how to extract context and event types from an XState model using ContextFrom and EventFrom utility types.

LANGUAGE: typescript
CODE:
import { ContextFrom, EventFrom } from 'xstate';
import { createModel } from 'xstate/lib/model';

const someModel = createModel(
  {
    /* ... */
  },
  {
    events: {
      /* ... */
    }
  }
);

type SomeContext = ContextFrom<typeof someModel>;
type SomeEvent = EventFrom<typeof someModel>;

----------------------------------------

TITLE: Using XState Service in Svelte Component
DESCRIPTION: Example of using an exported XState service directly in a Svelte component, leveraging Svelte's store contract.

LANGUAGE: svelte
CODE:
// App.svelte

<script>
  import { toggleService } from './service';
</script>

<button on:click={() => toggleService.send({type:'TOGGLE'})}>
  {$toggleService.value === 'inactive'
    ? 'Click to activate'
    : 'Active! Click to deactivate'}
</button>

----------------------------------------

TITLE: Creating a Global State Provider with XState and SolidJS Context
DESCRIPTION: Shows how to create a global state provider using SolidJS context and XState. This setup allows for sharing state across components without prop drilling.

LANGUAGE: javascript
CODE:
import { createContext } from 'solid-js';
import { useMachine } from '@xstate/solid';
import { authMachine } from './auth.machine';

export const GlobalStateContext = createContext({});

export const GlobalStateProvider = (props) => {
  const authService = useMachine(authMachine);

  return (
    <GlobalStateContext.Provider value={{ authService }}>
      {props.children}
    </GlobalStateContext.Provider>
  );
};

----------------------------------------

TITLE: Implementing Custom Guards in XState
DESCRIPTION: This example demonstrates how to use custom guards with serialized objects containing relevant data. The guard logic can be serialized in JSON, allowing for more flexible and data-driven guard conditions.

LANGUAGE: javascript
CODE:
const searchMachine = createMachine(
  {
    // ...
    states: {
      idle: {
        on: {
          SEARCH: {
            target: 'searching',
            // Custom guard object
            cond: {
              type: 'searchValid',
              minQueryLength: 3
            }
          }
        }
      }
      // ...
    }
  },
  {
    guards: {
      searchValid: (context, event, { cond }) => {
        // cond === { type: 'searchValid', minQueryLength: 3 }
        return (
          context.canSearch &&
          event.query &&
          event.query.length > cond.minQueryLength
        );
      }
    }
  }
);

----------------------------------------

TITLE: Using Options with getShortestPaths Function
DESCRIPTION: Example demonstrating the usage of options to customize event expansion and state filtering in the getShortestPaths function.

LANGUAGE: javascript
CODE:
const counterMachine = createMachine({
  id: 'counter',
  initial: 'active',
  context: { count: 0 },
  states: {
    active: {
      on: {
        INC: {
          actions: assign({ count: (ctx, e) => ctx.count + e.value })
        }
      }
    }
  }
});

const shortestPaths = getShortestPaths(counterMachine, {
  events: {
    INC: [
      { type: 'INC', value: 1 },
      { type: 'INC', value: 2 }
    ]
  },
  filter: (state) => state.context.count <= 5
});

console.log(shortestPaths);

----------------------------------------

TITLE: Defining State Node Types in XState JavaScript
DESCRIPTION: Example of explicitly defining state node types in an XState machine, including atomic, parallel, compound, final, and history states.

LANGUAGE: javascript
CODE:
const machine = createMachine({
  id: 'fetch',
  initial: 'idle',
  states: {
    idle: {
      type: 'atomic',
      on: {
        FETCH: { target: 'pending' }
      }
    },
    pending: {
      type: 'parallel',
      states: {
        resource1: {
          type: 'compound',
          initial: 'pending',
          states: {
            pending: {
              on: {
                'FULFILL.resource1': { target: 'success' }
              }
            },
            success: {
              type: 'final'
            }
          }
        },
        resource2: {
          type: 'compound',
          initial: 'pending',
          states: {
            pending: {
              on: {
                'FULFILL.resource2': { target: 'success' }
              }
            },
            success: {
              type: 'final'
            }
          }
        }
      },
      onDone: 'success'
    },
    success: {
      type: 'compound',
      initial: 'items',
      states: {
        items: {
          on: {
            'ITEM.CLICK': { target: 'item' }
          }
        },
        item: {
          on: {
            BACK: { target: 'items' }
          }
        },
        hist: {
          type: 'history',
          history: 'shallow'
        }
      }
    }
  }
});

----------------------------------------

TITLE: Transitioning Parallel States in XState
DESCRIPTION: Demonstrates how to transition between states within a parallel state node using object state values.

LANGUAGE: javascript
CODE:
console.log(
  fileMachine.transition(
    {
      upload: 'pending',
      download: 'idle'
    },
    { type: 'UPLOAD_COMPLETE' }
  ).value
);

----------------------------------------

TITLE: Configuring XState Inspect Options
DESCRIPTION: Shows default and custom configurations for the inspect function, including iframe targeting and URL specification.

LANGUAGE: javascript
CODE:
// defaults
inspect({
  iframe: () => document.querySelector('iframe[data-xstate]'),
  url: 'https://stately.ai/viz?inspect'
});

// the above is the same as this:
inspect();

----------------------------------------

TITLE: Using useMachine Hook from xstate-vue2 in Vue 2.7+
DESCRIPTION: Demonstrates how to use the useMachine hook from the xstate-vue2 package in a Vue 2.7+ component. It imports the toggleMachine and uses it to create a simple toggle button.

LANGUAGE: html
CODE:
<!-- toggle.vue -->
<!-- Top level bindigs are pre-processed via "setup" -->
<script setup>
  import { useMachine } from 'xstate-vue2';
  import toggleMachine from '../path/to/toggleMachine';

  const { state, send } = useMachine(toggleMachine);
</script>

<template>
  <main>
    <button @click="send('TOGGLE')">
      {{ state.value === "inactive" ? "Click to activate" : "Active! Click to
      deactivate" }}
    </button>
  </main>
</template>

----------------------------------------

TITLE: Traffic Light Machine with Multiple Activities
DESCRIPTION: Implementation of a traffic light state machine demonstrating multiple concurrent activities for crosswalk management.

LANGUAGE: javascript
CODE:
const lightMachine = createMachine({
  key: 'light',
  initial: 'green',
  states: {
    green: {
      on: {
        TIMER: { target: 'yellow' }
      }
    },
    yellow: {
      on: {
        TIMER: { target: 'red' }
      }
    },
    red: {
      initial: 'walk',
      activities: ['activateCrosswalkLight'],
      on: {
        TIMER: { target: 'green' }
      },
      states: {
        walk: {
          on: {
            PED_WAIT: { target: 'wait' }
          }
        },
        wait: {
          activities: ['blinkCrosswalkLight'],
          on: {
            PED_STOP: { target: 'stop' }
          }
        },
        stop: {}
      }
    }
  }
});

----------------------------------------

TITLE: Eventless Transitions in XState
DESCRIPTION: This snippet shows how to use eventless transitions in XState, which are always taken when the machine is in the state where they are defined and their conditions are met.

LANGUAGE: javascript
CODE:
const gameMachine = createMachine(
  {
    id: 'game',
    initial: 'playing',
    context: {
      points: 0
    },
    states: {
      playing: {
        // Eventless transition
        // Will transition to either 'win' or 'lose' immediately upon
        // entering 'playing' state or receiving AWARD_POINTS event
        // if the condition is met.
        always: [
          { target: 'win', cond: 'didPlayerWin' },
          { target: 'lose', cond: 'didPlayerLose' }
        ],
        on: {
          // Self-transition
          AWARD_POINTS: {
            actions: assign({
              points: 100
            })
          }
        }
      },
      win: { type: 'final' },
      lose: { type: 'final' }
    }
  },
  {
    guards: {
      didPlayerWin: (context, event) => {
        // check if player won
        return context.points > 99;
      },
      didPlayerLose: (context, event) => {
        // check if player lost
        return context.points < 0;
      }
    }
  }
);

const gameService = interpret(gameMachine)
  .onTransition((state) => console.log(state.value))
  .start();

// Still in 'playing' state because no conditions of
// transient transition were met
// => 'playing'

// When 'AWARD_POINTS' is sent, a self-transition to 'PLAYING' occurs.
// The transient transition to 'win' is taken because the 'didPlayerWin'
// condition is satisfied.
gameService.send({ type: 'AWARD_POINTS' });
// => 'win'

----------------------------------------

TITLE: Invoking a Callback in XState
DESCRIPTION: Demonstrates how to invoke a callback service that sends events to the parent machine and listens for events from the parent.

LANGUAGE: javascript
CODE:
counting: {
  invoke: {
    id: 'incInterval',
    src: (context, event) => (callback, onReceive) => {
      // This will send the 'INC' event to the parent every second
      const id = setInterval(() => callback('INC'), 1000);

      // Perform cleanup
      return () => clearInterval(id);
    }
  },
  on: {
    INC: { actions: assign({ counter: context => context.counter + 1 }) }
  }
}

----------------------------------------

TITLE: Importing and Configuring XState Inspector
DESCRIPTION: Example of importing the inspect function from @xstate/inspect and configuring it with options at the beginning of a project.

LANGUAGE: javascript
CODE:
import { inspect } from '@xstate/inspect';

inspect({
  // options
  // url: 'https://stately.ai/viz?inspect', // (default)
  iframe: false // open in new window
});

----------------------------------------

TITLE: Using XState interpret in Vue 2
DESCRIPTION: Shows how to use XState's interpret function in a Vue 2 component. It creates a service from the toggleMachine, starts it in the created hook, and updates component data based on state transitions.

LANGUAGE: html
CODE:
<!-- Toggle.vue -->
<template>
  <button v-on:click="send('TOGGLE');">
    {{ current.matches("inactive") ? "Off" : "On" }}
  </button>
</template>

<script>
  import { interpret } from 'xstate';
  import { toggleMachine } from '../path/to/toggleMachine';

  export default {
    name: 'Toggle',
    created() {
      // Start service on component creation
      this.toggleService
        .onTransition((state) => {
          // Update the current state component data property with the next state
          this.current = state;
          // Update the context component data property with the updated context
          this.context = state.context;
        })
        .start();
    },
    data() {
      return {
        // Interpret the machine and store it in data
        toggleService: interpret(toggleMachine),

        // Start with the machine's initial state
        current: toggleMachine.initialState,

        // Start with the machine's initial context
        context: toggleMachine.context
      };
    },
    methods: {
      // Send events to the service
      send(event) {
        this.toggleService.send(event);
      }
    }
  };
</script>

----------------------------------------

TITLE: State Transitions Comparison between XState and SCXML
DESCRIPTION: Shows equivalent transition definitions in XState and SCXML formats, demonstrating conditional transitions and multiple event handlers.

LANGUAGE: javascript
CODE:
{
  green: {
    on: {
      TIMER: {
        target: '#yellow',
        cond: context => context.timeElapsed > 5000
      },
      POWER_OUTAGE: { target: '#red.flashing' }
    }
  }
}

LANGUAGE: xml
CODE:
<state id="green">
  <transition
    event="TIMER"
    target="yellow"
    cond="timeElapsed > 5000"
  />
  <transition
    event="POWER_OUTAGE"
    target="red.flashing"
  />
</state>

----------------------------------------

TITLE: Configurable Fetch Machine Example
DESCRIPTION: Advanced example demonstrating a configurable state machine for handling API requests with loading, success, and failure states.

LANGUAGE: svelte
CODE:
<script>
  import { useMachine } from '@xstate/svelte';
  import { createMachine, assign } from 'xstate';

  const fetchMachine = createMachine({
    id: 'fetch',
    initial: 'idle',
    context: {
      data: undefined,
      error: undefined
    },
    states: {
      idle: {
        on: { FETCH: 'loading' }
      },
      loading: {
        invoke: {
          src: 'fetchData',
          onDone: {
            target: 'success',
            actions: assign({
              data: (_, event) => event.data
            })
          },
          onError: {
            target: 'failure',
            actions: assign({
              error: (_, event) => event.data
            })
          }
        }
      },
      success: {
        entry: 'notifySuccess',
        type: 'final'
      },
      failure: {
        on: {
          RETRY: 'loading'
        }
      }
    }
  });

  const onResolve = (data) => {
    // Do something with data
  };

  const { state, send } = useMachine(fetchMachine, {
    actions: {
      notifySuccess: (context) => onResolve(context.data)
    },
    services: {
      fetchData: (_, event) =>
        fetch(`some/api/${event.query}`).then((res) => res.json())
    }
  });
</script>

{#if $state.value === 'idle'}
  <button on:click={() => send({ type: 'FETCH', query: 'something' })}>
    Search for something
  </button>
{:else if $state.value === 'loading'}
  <div>Searching...</div>
{:else if $state.value === 'success'}
  <div>Success! Data: {$state.context.data}</div>
{:else if $state.value === 'failure'}
  <p>{$state.context.error.message}</p>
  <button on:click={() => send('RETRY')}>Retry</button>
{/if}

----------------------------------------

TITLE: Forbidden Transitions in XState
DESCRIPTION: This example demonstrates how to define forbidden transitions in XState, which specify that no state transition should occur for a given event.

LANGUAGE: javascript
CODE:
const formMachine = createMachine({
  id: 'form',
  initial: 'firstPage',
  states: {
    firstPage: {
      /* ... */
    },
    secondPage: {
      /* ... */
    },
    userInfoPage: {
      on: {
        // explicitly forbid the LOG event from doing anything
        // or taking any transitions to any other state
        LOG: undefined
      }
    }
  },
  on: {
    LOG: {
      actions: 'logTelemetry'
    }
  }
});

----------------------------------------

TITLE: Configuring Predictable Action Arguments in XState
DESCRIPTION: Example showing how to enable predictable action arguments behavior that will be default in v5. This ensures actions are called with the direct triggering event.

LANGUAGE: javascript
CODE:
createMachine({
  predictableActionArguments: true
  // ...
});

----------------------------------------

TITLE: Configuring XState Inspector in Next.js
DESCRIPTION: Shows how to conditionally run the XState inspector code only on the client-side in a Next.js application.

LANGUAGE: javascript
CODE:
if (typeof window !== 'undefined') {
  inspect({
    /* options */
  });
}

----------------------------------------

TITLE: Creating Authenticated Toggle with ember-statechart-component
DESCRIPTION: Demonstrates using ember-statechart-component to create a statechart-based component with authentication checks and service integration.

LANGUAGE: javascript
CODE:
// app/components/authenticated-toggle.js
import { getService } from 'ember-statechart-component';
import { createMachine } from 'xstate';

export default createMachine(
  {
    initial: 'inactive',
    states: {
      inactive: {
        on: {
          TOGGLE: [
            {
              target: 'active',
              cond: 'isAuthenticated'
            },
            { actions: ['notify'] }
          ]
        }
      },
      active: { on: { TOGGLE: 'inactive' } }
    }
  },
  {
    actions: {
      notify: (ctx) => {
        getService(ctx, 'toasts').notify('You must be logged in');
      }
    },
    guards: {
      isAuthenticated: (ctx) => getService(ctx, 'session').isAuthenticated
    }
  }
);

LANGUAGE: handlebars
CODE:
<AuthenticatedToggle as |state send|>
  {{state.value}}

  <button {{on 'click' (fn send 'TOGGLE')}}>
    Toggle
  </button>
</AuthenticatedToggle>

----------------------------------------

TITLE: Creating Actor Context in React with XState
DESCRIPTION: Example of using createActorContext to create a React context for XState actors with provider options

LANGUAGE: tsx
CODE:
const { inspect } = createBrowserInspector();

const SomeContext = createActorContext(someMachine, { inspect });

// Options are merged: { inspect: inspect, input: 10 }
<SomeContext.Provider options={{ input: 10 }}>
  {/* ... */}
</SomeContext.Provider>

----------------------------------------

TITLE: Creating a Toggle Machine in XState
DESCRIPTION: Defines a simple toggle machine using XState's createMachine function. The machine has two states: 'inactive' and 'active', with a 'TOGGLE' event to switch between them.

LANGUAGE: javascript
CODE:
import { createMachine } from 'xstate';

const toggleMachine = createMachine({
  id: 'toggle',
  initial: 'inactive',
  states: {
    inactive: {
      on: {
        TOGGLE: 'active'
      }
    },
    active: {
      on: {
        TOGGLE: 'inactive'
      }
    }
  }
});

----------------------------------------

TITLE: Mocking Effects in XState Machine Testing
DESCRIPTION: This snippet illustrates how to mock side-effects (actions and services) when testing XState machines. It uses the machine.withConfig(...) option to change the implementation of certain actions and services for testing purposes.

LANGUAGE: javascript
CODE:
import { fetchMachine } from '../path/to/fetchMachine';

it('should eventually reach "success"', (done) => {
  let userAlerted = false;

  const mockFetchMachine = fetchMachine.withConfig({
    services: {
      fetchFromAPI: (_, event) =>
        new Promise((resolve) => {
          setTimeout(() => {
            resolve({ id: event.id });
          }, 50);
        })
    },
    actions: {
      alertUser: () => {
        // set a flag instead of executing the original action
        userAlerted = true;
      }
    }
  });

  const fetchService = interpret(mockFetchMachine).onTransition((state) => {
    if (state.matches('success')) {
      // assert that effects were executed
      expect(userAlerted).toBeTruthy();
      done();
    }
  });

  fetchService.start();

  fetchService.send({ type: 'FETCH', id: 42 });
});

----------------------------------------

TITLE: Defining History States in XState Fan Machine
DESCRIPTION: This snippet demonstrates how to define and use history states in an XState machine. It includes examples of shallow history states, history states with default targets, and transitions to history states.

LANGUAGE: javascript
CODE:
const fanMachine = createMachine({
  id: 'fan',
  initial: 'fanOff',
  states: {
    fanOff: {
      on: {
        // transitions to history state
        POWER: { target: 'fanOn.hist' },
        HIGH_POWER: { target: 'fanOn.highPowerHist' }
      }
    },
    fanOn: {
      initial: 'first',
      states: {
        first: {
          on: {
            SWITCH: { target: 'second' }
          }
        },
        second: {
          on: {
            SWITCH: { target: 'third' }
          }
        },
        third: {},

        // shallow history state
        hist: {
          type: 'history',
          history: 'shallow' // optional; default is 'shallow'
        },

        // shallow history state with default
        highPowerHist: {
          type: 'history',
          target: 'third'
        }
      },
      on: {
        POWER: { target: 'fanOff' }
      }
    }
  }
});

----------------------------------------

TITLE: XState Immer User Machine Example
DESCRIPTION: Shows how to use assign with Immer to update nested state objects in a user management machine.

LANGUAGE: javascript
CODE:
import { createMachine } from 'xstate';
import { assign } from '@xstate/immer';

const userMachine = createMachine({
  id: 'user',
  context: {
    name: null,
    address: {
      city: null,
      state: null,
      country: null
    }
  },
  initial: 'active',
  states: {
    active: {
      on: {
        CHANGE_COUNTRY: {
          actions: assign((context, event) => {
            context.address.country = event.value;
          })
        }
      }
    }
  }
});

----------------------------------------

TITLE: Callback Service Invocation in XState
DESCRIPTION: Example of invoking a callback service that increments a counter every second.

LANGUAGE: javascript
CODE:
counting: {
  invoke: {
    id: 'incInterval',
    src: (context, event) => (callback, onReceive) => {
      const id = setInterval(() => callback('INC'), 1000);
      return () => clearInterval(id);
    }
  },
  on: {
    INC: { actions: assign({ counter: context => context.counter + 1 }) }
  }
}

----------------------------------------

TITLE: Running Tests with Coverage using @xstate/test
DESCRIPTION: Shows how to create test plans, run tests, and check coverage using the @xstate/test model. It uses Jest-like syntax to describe test suites and individual test cases.

LANGUAGE: javascript
CODE:
// ...

describe('toggle', () => {
  const testPlans = toggleModel.getShortestPathPlans();

  testPlans.forEach((plan) => {
    describe(plan.description, () => {
      plan.paths.forEach((path) => {
        it(path.description, async () => {
          // do any setup, then...

          await path.test(page);
        });
      });
    });
  });

  it('should have full coverage', () => {
    return toggleModel.testCoverage();
  });
});

----------------------------------------

TITLE: Using ember-statecharts with XState in Ember.js Component
DESCRIPTION: This code snippet shows how to use the ember-statecharts addon to integrate an XState machine into an Ember.js component. It demonstrates the useMachine API and how to interact with the machine state.

LANGUAGE: javascript
CODE:
import Component from '@glimmmer/component';
import { action } from '@ember/object';

import { useMachine, matchesState } from 'ember-statecharts';

// @use (https://github.com/emberjs/rfcs/pull/567) is still WIP - polyfill it
import { use } from 'ember-usable';

import toggleMachine from './path/to/toggleMachine';

export default class ToggleComponent extends Component {
  @use statechart = useMachine(toggleMachine);

  @matchesState('active')
  isActive;

  @matchesState('inactive')
  isInactive;

  @action
  toggle() {
    this.statechart.send({ type: 'TOGGLE' });
  }
}

----------------------------------------

TITLE: Configuring a Basic Promise State Machine
DESCRIPTION: Initial configuration of a state machine representing a Promise with pending, resolved, and rejected states.

LANGUAGE: javascript
CODE:
import { createMachine } from 'xstate';

const promiseMachine = createMachine({
  id: 'promise',
  initial: 'pending',
  states: {
    pending: {},
    resolved: {},
    rejected: {}
  }
});

----------------------------------------

TITLE: React Component Implementation with XState
DESCRIPTION: Shows how to integrate the Reddit state machine with a React component using @xstate/react.

LANGUAGE: jsx
CODE:
import React from 'react';
import { useMachine } from '@xstate/react';
import { redditMachine } from '../path/to/redditMachine';

const subreddits = ['frontend', 'reactjs', 'vuejs'];

const App = () => {
  const [current, send] = useMachine(redditMachine);
  const { subreddit, posts } = current.context;

  return (
    <main>
      <header>
        <select
          onChange={(e) => {
            send({ type: 'SELECT', name: e.target.value });
          }}
        >
          {subreddits.map((subreddit) => {
            return <option key={subreddit}>{subreddit}</option>;
          })}
        </select>
      </header>
      <section>
        <h1>{current.matches('idle') ? 'Select a subreddit' : subreddit}</h1>
        {current.matches({ selected: 'loading' }) && <div>Loading...</div>}
        {current.matches({ selected: 'loaded' }) && (
          <ul>
            {posts.map((post) => (
              <li key={post.title}>{post.title}</li>
            ))}
          </ul>
        )}
      </section>
    </main>
  );
};

----------------------------------------

TITLE: Creating and Configuring Beeping Activity
DESCRIPTION: Example showing how to create and configure an activity with context-dependent behavior in XState.

LANGUAGE: javascript
CODE:
function createBeepingActivity(context, activity) {
  // Start the beeping activity
  const interval = setInterval(() => {
    console.log('BEEP!');
  }, context.interval);

  // Return a function that stops the beeping activity
  return () => clearInterval(interval);
}

----------------------------------------

TITLE: Observable Service Invocation in XState
DESCRIPTION: Example of invoking an RxJS Observable service that emits count events.

LANGUAGE: javascript
CODE:
const intervalMachine = createMachine({
  id: 'interval',
  initial: 'counting',
  context: { myInterval: 1000 },
  states: {
    counting: {
      invoke: {
        src: (context, event) =>
          interval(context.myInterval).pipe(
            map((value) => ({ type: 'COUNT', value })),
            take(5)
          ),
        onDone: 'finished'
      },
      on: {
        COUNT: { actions: 'notifyCount' },
        CANCEL: { target: 'finished' }
      }
    },
    finished: {
      type: 'final'
    }
  }
});

----------------------------------------

TITLE: Checking Final States and Converting to Strings in XState
DESCRIPTION: Shows how to use state.done to check if a state is final, and state.toStrings() to get an array of state value paths.

LANGUAGE: javascript
CODE:
const answeringMachine = createMachine({
  initial: 'unanswered',
  states: {
    unanswered: {
      on: {
        ANSWER: { target: 'answered' }
      }
    },
    answered: {
      type: 'final'
    }
  }
});

const { initialState } = answeringMachine;
initialState.done; // false

const answeredState = answeringMachine.transition(initialState, {
  type: 'ANSWER'
});
answeredState.done; // true

console.log(state.value);
// => { red: 'stop' }

console.log(state.toStrings());
// => ['red', 'red.stop']

----------------------------------------

TITLE: Global State Context Provider Implementation
DESCRIPTION: Setup for global state management using React Context with XState's useInterpret hook to provide authentication service.

LANGUAGE: javascript
CODE:
import React, { createContext } from 'react';
import { useInterpret } from '@xstate/react';
import { authMachine } from './authMachine';

export const GlobalStateContext = createContext({});

export const GlobalStateProvider = (props) => {
  const authService = useInterpret(authMachine);

  return (
    <GlobalStateContext.Provider value={{ authService }}>
      {props.children}
    </GlobalStateContext.Provider>
  );
};

----------------------------------------

TITLE: Using useActor in Vue Component
DESCRIPTION: Example of using the useActor composition function to interact with a spawned actor in a Vue component.

LANGUAGE: javascript
CODE:
import { useActor } from '@xstate/vue';

const props = defineProps(['someSpawnedActor']);

const { state, send } = useActor(props.someSpawnedActor);

----------------------------------------

TITLE: Implementing Null Events and Immediate Transitions
DESCRIPTION: Examples of using null events (empty string events) for immediate transitions and conditional routing in state machines.

LANGUAGE: javascript
CODE:
const skipMachine = createMachine({
  id: 'skip',
  initial: 'one',
  states: {
    one: {
      on: { CLICK: 'two' }
    },
    two: {
      // null event '' always occurs once state is entered
      // immediately take the transition to 'three'
      on: { '': 'three' }
    },
    three: {
      type: 'final'
    }
  }
});

const { initialState } = skipMachine;
const nextState = skipMachine.transition(initialState, { type: 'CLICK' });

console.log(nextState.value);
// => 'three'

LANGUAGE: javascript
CODE:
const isAdult = ({ age }) => age >= 18;
const isMinor = ({ age }) => age < 18;

const ageMachine = createMachine({
  id: 'age',
  context: { age: undefined }, // age unknown
  initial: 'unknown',
  states: {
    unknown: {
      on: {
        // immediately take transition that satisfies conditional guard.
        // otherwise, no transition occurs
        '': [
          { target: 'adult', cond: isAdult },
          { target: 'child', cond: isMinor }
        ]
      }
    },
    adult: { type: 'final' },
    child: { type: 'final' }
  }
});

console.log(ageMachine.initialState.value);
// => 'unknown'

const personData = { age: 28 };

const personMachine = ageMachine.withContext(personData);

console.log(personMachine.initialState.value);
// => 'adult'

----------------------------------------

TITLE: Implementing Named Actions in XState with SolidJS
DESCRIPTION: Illustrates how to implement named actions in an XState machine and utilize them within a SolidJS component, integrating with external libraries like solid-app-router.

LANGUAGE: javascript
CODE:
import { createMachine } from 'xstate';

export const machine = createMachine({
  initial: 'toggledOff',
  states: {
    toggledOff: {
      on: {
        TOGGLE: 'toggledOn'
      }
    },
    toggledOn: {
      entry: ['goToOtherPage']
    }
  }
});

LANGUAGE: javascript
CODE:
import { machine } from './machine';
import { useMachine } from '@xstate/solid';
import { useNavigate } from 'solid-app-router';

const Component = () => {
  const navigate = useNavigate();

  const [state, send] = useMachine(machine, {
    actions: {
      goToOtherPage: () => {
        navigate('/other-page');
      }
    }
  });

  return null;
};

----------------------------------------

TITLE: Initializing Basic Reddit State Machine
DESCRIPTION: Creates the initial state machine structure with idle and selected states for the Reddit viewer application.

LANGUAGE: javascript
CODE:
import { createMachine, assign } from 'xstate';

const redditMachine = createMachine({
  id: 'reddit',
  initial: 'idle',
  states: {
    idle: {},
    selected: {}
  }
});

----------------------------------------

TITLE: Class Component Implementation
DESCRIPTION: Traditional class component implementation of XState using interpret to manage state transitions.

LANGUAGE: jsx
CODE:
import React from 'react';
import { interpret } from 'xstate';
import { toggleMachine } from '../path/to/toggleMachine';

class Toggle extends React.Component {
  state = {
    current: toggleMachine.initialState
  };

  service = interpret(toggleMachine).onTransition((current) =>
    this.setState({ current })
  );

  componentDidMount() {
    this.service.start();
  }

  componentWillUnmount() {
    this.service.stop();
  }

  render() {
    const { current } = this.state;
    const { send } = this.service;

    return (
      <button onClick={() => send('TOGGLE')}>
        {current.matches('inactive') ? 'Off' : 'On'}
      </button>
    );
  }
}

----------------------------------------

TITLE: Optimized State Selection with useSelector
DESCRIPTION: Shows how to optimize performance using useSelector hook to prevent unnecessary re-renders.

LANGUAGE: javascript
CODE:
import React, { useContext } from 'react';
import { GlobalStateContext } from './globalState';
import { useSelector } from '@xstate/react';

const loggedInSelector = (state) => {
  return state.matches('loggedIn');
};

export const SomeComponent = (props) => {
  const globalServices = useContext(GlobalStateContext);
  const isLoggedIn = useSelector(globalServices.authService, loggedInSelector);

  return isLoggedIn ? 'Logged In' : 'Logged Out';
};

----------------------------------------

TITLE: Class Component Implementation
DESCRIPTION: Traditional class component implementation of XState using interpret to manage state transitions.

LANGUAGE: jsx
CODE:
import React from 'react';
import { interpret } from 'xstate';
import { toggleMachine } from '../path/to/toggleMachine';

class Toggle extends React.Component {
  state = {
    current: toggleMachine.initialState
  };

  service = interpret(toggleMachine).onTransition((current) =>
    this.setState({ current })
  );

  componentDidMount() {
    this.service.start();
  }

  componentWillUnmount() {
    this.service.stop();
  }

  render() {
    const { current } = this.state;
    const { send } = this.service;

    return (
      <button onClick={() => send('TOGGLE')}>
        {current.matches('inactive') ? 'Off' : 'On'}
      </button>
    );
  }
}

----------------------------------------

TITLE: Adding Assertions to Toggle Machine States
DESCRIPTION: Extends the toggle machine by adding test assertions for each state using Puppeteer. The 'meta.test' property is used to define asynchronous test functions for each state.

LANGUAGE: javascript
CODE:
// ...

const toggleMachine = createMachine({
  id: 'toggle',
  initial: 'inactive',
  states: {
    inactive: {
      on: {
        /* ... */
      },
      meta: {
        test: async (page) => {
          await page.waitFor('input:checked');
        }
      }
    },
    active: {
      on: {
        /* ... */
      },
      meta: {
        test: async (page) => {
          await page.waitFor('input:not(:checked)');
        }
      }
    }
  }
});

----------------------------------------

TITLE: Actor Reference Subscription in SolidJS
DESCRIPTION: Shows how to subscribe to actor reference state changes using createEffect hook

LANGUAGE: javascript
CODE:
createEffect(() => {
  const subscription = actorRef.subscribe((snapshot) => {
    // simple snapshot logging
    console.log(snapshot);
  });

  onCleanup(() => subscription.unsubscribe());
}); // note: service should never change

----------------------------------------

TITLE: Subscribing to XState Service with RxJS
DESCRIPTION: Example showing how to convert an XState service into an RxJS observable stream using the 'from' operator. This allows you to use RxJS operators and patterns with XState state updates.

LANGUAGE: javascript
CODE:
import { createMachine, interpret } from 'xstate';
import { from } from 'rxjs';

const machine = createMachine(/* ... */);
const service = interpret(machine).start();

const state$ = from(service);

state$.subscribe((state) => {
  // ...
});

----------------------------------------

TITLE: Traffic Light State Machine Example
DESCRIPTION: Implementation of a traffic light system using finite state machine patterns in XState

LANGUAGE: javascript
CODE:
import { createMachine, createActor } from 'xstate';

const lightMachine = createMachine({
  id: 'light',
  initial: 'green',
  states: {
    green: {
      on: {
        TIMER: 'yellow'
      }
    },
    yellow: {
      on: {
        TIMER: 'red'
      }
    },
    red: {
      on: {
        TIMER: 'green'
      }
    }
  }
});

const actor = createActor(lightMachine);

actor.subscribe((state) => {
  console.log(state.value);
});

actor.start();
// logs 'green'

actor.send({ type: 'TIMER' });
// logs 'yellow'

----------------------------------------

TITLE: Running XState Typegen Command
DESCRIPTION: Command to run typegen against TypeScript files using a glob pattern. The glob must be wrapped in quotes to ensure correct interpretation.

LANGUAGE: bash
CODE:
xstate typegen "src/**/*.ts?(x)"

----------------------------------------

TITLE: Quick Reference Examples for State Node IDs
DESCRIPTION: Quick reference examples showing both default and custom ID usage in XState state machines.

LANGUAGE: javascript
CODE:
const lightMachine = createMachine({
  id: 'light',
  initial: 'green',
  states: {
    // ID: "light.green"
    green: {
      /* ... */
    },
    // ID: "light.yellow"
    yellow: {
      /* ... */
    },
    // ID: "light.red"
    red: {
      /* ... */
    }
  }
});

LANGUAGE: javascript
CODE:
states: {
  active: {
    id: 'custom-active', // can be any unique string
    // ...
  }
}

LANGUAGE: javascript
CODE:
on: {
  EVENT: { target: '#light.yellow' }, // target default ID
  ANOTHER_EVENT: { target: '#custom-id' } // target custom ID
}

----------------------------------------

TITLE: Default Inspect Options Configuration
DESCRIPTION: Demonstrates default configuration options for the XState inspector including iframe selection and URL settings.

LANGUAGE: javascript
CODE:
// defaults
inspect({
  iframe: () => document.querySelector('iframe[data-xstate]'),
  url: 'https://stately.ai/viz?inspect'
});

// the above is the same as this:
inspect();

----------------------------------------

TITLE: Running XState Typegen Command
DESCRIPTION: Command to run typegen against TypeScript files using a glob pattern. The glob must be wrapped in quotes to ensure correct interpretation.

LANGUAGE: bash
CODE:
xstate typegen "src/**/*.ts?(x)"

----------------------------------------

TITLE: Dispatching Events to XState Machine in SolidJS
DESCRIPTION: Shows how to dispatch events to an XState machine from within a SolidJS component using the send function obtained from the global context.

LANGUAGE: javascript
CODE:
import { useContext } from 'solid-js';
import { GlobalStateContext } from './globalState';

export const SomeComponent = (props) => {
  const {
    authService: [, send]
  } = useContext(GlobalStateContext);
  return <button onClick={() => send({ type: 'LOG_OUT' })}>Log Out</button>;
};

----------------------------------------

TITLE: Defining a Toggle Machine in XState
DESCRIPTION: Creates a simple toggle machine using XState's createMachine function. The machine has two states (inactive and active) and a TOGGLE event to switch between them.

LANGUAGE: javascript
CODE:
import { createMachine } from 'xstate';

// This machine is completely decoupled from Vue
export const toggleMachine = createMachine({
  id: 'toggle',
  context: {
    /* some data */
  },
  initial: 'inactive',
  states: {
    inactive: {
      on: { TOGGLE: 'active' }
    },
    active: {
      on: { TOGGLE: 'inactive' }
    }
  }
});

----------------------------------------

TITLE: Implementing Toggle Machine with Beeping Activity
DESCRIPTION: Example of creating a toggle machine with a beeping activity that starts and stops based on state transitions.

LANGUAGE: javascript
CODE:
const toggleMachine = createMachine(
  {
    id: 'toggle',
    initial: 'inactive',
    states: {
      inactive: {
        on: {
          TOGGLE: { target: 'active' }
        }
      },
      active: {
        // The 'beeping' activity will take place as long as
        // the machine is in the 'active' state
        activities: ['beeping'],
        on: {
          TOGGLE: { target: 'inactive' }
        }
      }
    }
  },
  {
    activities: {
      beeping: () => {
        // Start the beeping activity
        const interval = setInterval(() => console.log('BEEP!'), 1000);

        // Return a function that stops the beeping activity
        return () => clearInterval(interval);
      }
    }
  }
);

----------------------------------------

TITLE: Type Inference with createModel in TypeScript
DESCRIPTION: Demonstrates how TypeScript infers types for context and events when using createModel(). Shows explicit type annotations and how the inferred types are structured.

LANGUAGE: typescript
CODE:
import { createModel } from 'xstate/lib/model';

const userModel = createModel(
  {
    name: 'David', // inferred as `string`
    age: 30, // inferred as `number`
    friends: [] as string[] // explicit type
  },
  {
    events: {
      updateName: (value: string) => ({ value }),
      updateAge: (value: number) => ({ value }),
      anotherEvent: () => ({}) // No payload
    }
  }
);

// Context inferred as:
// {
//   name: string;
//   age: number;
//   friends: string[];
// }

// Events inferred as:
// | { type: 'updateName'; value: string; }
// | { type: 'updateAge'; value: number; }
// | { type: 'anotherEvent'; }

----------------------------------------

TITLE: Defining a Toggle Machine in XState
DESCRIPTION: Creates a simple toggle machine using XState's createMachine function. The machine has two states (inactive and active) and a TOGGLE event to switch between them.

LANGUAGE: javascript
CODE:
import { createMachine } from 'xstate';

// This machine is completely decoupled from Vue
export const toggleMachine = createMachine({
  id: 'toggle',
  context: {
    /* some data */
  },
  initial: 'inactive',
  states: {
    inactive: {
      on: { TOGGLE: 'active' }
    },
    active: {
      on: { TOGGLE: 'inactive' }
    }
  }
});

----------------------------------------

TITLE: Using getSimplePaths Function with Feedback Machine
DESCRIPTION: Example showing the usage of getSimplePaths function with the same feedback machine, including the resulting output structure.

LANGUAGE: javascript
CODE:
import { createMachine } from 'xstate';
import { getSimplePaths } from '@xstate/graph';

const feedbackMachine = createMachine({
  id: 'feedback',
  initial: 'question',
  states: {
    question: {
      on: {
        CLICK_GOOD: 'thanks',
        CLICK_BAD: 'form',
        CLOSE: 'closed',
        ESC: 'closed'
      }
    },
    form: {
      on: {
        SUBMIT: 'thanks',
        CLOSE: 'closed',
        ESC: 'closed'
      }
    },
    thanks: {
      on: {
        CLOSE: 'closed',
        ESC: 'closed'
      }
    },
    closed: {
      type: 'final'
    }
  }
});

const simplePaths = getSimplePaths(feedbackMachine);

console.log(simplePaths);

----------------------------------------

TITLE: Sending Events to XState Actor in TypeScript
DESCRIPTION: Demonstrates how to send an event to the XState actor to start the scan process.

LANGUAGE: typescript
CODE:
mediaScannerActor.send({ type: 'START_SCAN' });

----------------------------------------

TITLE: Relative Targeting in XState
DESCRIPTION: Shows how to use relative targeting with dot notation to reference child state nodes relative to their parent state.

LANGUAGE: javascript
CODE:
const optionsMachine = createMachine({
  id: 'options',
  initial: 'first',
  states: {
    first: {},
    second: {},
    third: {}
  },
  on: {
    SELECT_FIRST: { target: '.first' }, // resolves to 'options.first'
    SELECT_SECOND: { target: '.second' }, // 'options.second'
    SELECT_THIRD: { target: '.third' } // 'options.third'
  }
});

----------------------------------------

TITLE: Traffic Light Machine with Multiple Activities
DESCRIPTION: Implementation of a traffic light state machine demonstrating multiple concurrent activities and their lifecycle management.

LANGUAGE: javascript
CODE:
const lightMachine = createMachine({
  key: 'light',
  initial: 'green',
  states: {
    green: {
      on: {
        TIMER: { target: 'yellow' }
      }
    },
    yellow: {
      on: {
        TIMER: { target: 'red' }
      }
    },
    red: {
      initial: 'walk',
      activities: ['activateCrosswalkLight'],
      on: {
        TIMER: { target: 'green' }
      },
      states: {
        walk: {
          on: {
            PED_WAIT: { target: 'wait' }
          }
        },
        wait: {
          activities: ['blinkCrosswalkLight'],
          on: {
            PED_STOP: { target: 'stop' }
          }
        },
        stop: {}
      }
    }
  }
});

----------------------------------------

TITLE: Extracting Types from Models in TypeScript
DESCRIPTION: Shows how to extract context and event types from a model using the ContextFrom<T> and EventFrom<T> utility types. This is useful for defining types based on the model outside of the machine definition.

LANGUAGE: typescript
CODE:
import { ContextFrom, EventFrom } from 'xstate';
import { createModel } from 'xstate/lib/model';

const someModel = createModel(
  {
    /* ... */
  },
  {
    events: {
      /* ... */
    }
  }
);

type SomeContext = ContextFrom<typeof someModel>;
type SomeEvent = EventFrom<typeof someModel>;

----------------------------------------

TITLE: Implementing Async Reddit API Fetching
DESCRIPTION: Adds asynchronous data fetching functionality using invoke and Promise handling.

LANGUAGE: javascript
CODE:
function invokeFetchSubreddit(context) {
  const { subreddit } = context;

  return fetch(`https://www.reddit.com/r/${subreddit}.json`)
    .then((response) => response.json())
    .then((json) => json.data.children.map((child) => child.data));
}

const redditMachine = createMachine({
  /* ... */
  states: {
    idle: {},
    selected: {
      invoke: {
        id: 'fetch-subreddit',
        src: invokeFetchSubreddit
      }
    }
  }
});

----------------------------------------

TITLE: Using getPathFromEvents Function
DESCRIPTION: Example demonstrating the usage of getPathFromEvents function to generate a path from a sequence of events in a feedback machine.

LANGUAGE: javascript
CODE:
import { createMachine } from 'xstate';
import { getSimplePaths } from '@xstate/graph';

const feedbackMachine = createMachine({
  id: 'feedback',
  initial: 'question',
  states: {
    question: {
      on: {
        CLICK_GOOD: 'thanks',
        CLICK_BAD: 'form',
        CLOSE: 'closed',
        ESC: 'closed'
      }
    },
    form: {
      on: {
        SUBMIT: 'thanks',
        CLOSE: 'closed',
        ESC: 'closed'
      }
    },
    thanks: {
      on: {
        CLOSE: 'closed',
        ESC: 'closed'
      }
    },
    closed: {
      type: 'final'
    }
  }
});

const path = getPathFromEvents(feedbackMachine, [
  { type: 'CLICK_GOOD' },
  { type: 'SUBMIT' },
  { type: 'CLOSE' }
]);

console.log(path);

----------------------------------------

TITLE: Installing XState with SolidJS
DESCRIPTION: Command to install XState and its SolidJS integration package via npm.

LANGUAGE: bash
CODE:
npm i xstate @xstate/solid

----------------------------------------

TITLE: Custom XState Integration in Ember.js Component
DESCRIPTION: This example demonstrates a custom integration of XState in an Ember.js component without using addons. It shows how to manage the machine interpreter, handle state transitions, and interact with the machine from component actions.

LANGUAGE: javascript
CODE:
import Component from '@glimmer/component';
import { tracked } from '@glimmer/tracking';
import { action } from '@ember/object';
import { interpret } from 'xstate';
import { toggleMachine } from '../path/to/toggleMachine';

export default class ToggleButton extends Component {
  @tracked current;

  get context() {
    return this.current.context;
  }

  get isInactive() {
    return this.current.matches('inactive');
  }

  constructor() {
    super(...arguments);
    this.toggleInterpreter = interpret(toggleMachine);
    this.toggleInterpreter
      .onTransition((state) => (this.current = state))
      .start();
  }

  willDestroy() {
    super.willDestroy(...arguments);
    this.toggleInterpreter.stop();
  }

  @action
  transition(...args) {
    this.toggleInterpreter.send(...args);
  }
}

----------------------------------------

TITLE: XState Guards and SCXML Conditions
DESCRIPTION: Demonstrates guard conditions in XState and their equivalent SCXML conditional expressions, including the 'In' predicate usage.

LANGUAGE: javascript
CODE:
{
  on: {
    e: {
      target: 'foo',
      cond: context => context.x === 1
    }
  }
}

LANGUAGE: xml
CODE:
<transition event="e" cond="x == 1" target="foo" />

----------------------------------------

TITLE: XState Guards and SCXML Conditions
DESCRIPTION: Demonstrates guard conditions in XState and their equivalent SCXML conditional expressions, including the 'In' predicate usage.

LANGUAGE: javascript
CODE:
{
  on: {
    e: {
      target: 'foo',
      cond: context => context.x === 1
    }
  }
}

LANGUAGE: xml
CODE:
<transition event="e" cond="x == 1" target="foo" />

----------------------------------------

TITLE: Event Type Narrowing in XState Assign Actions
DESCRIPTION: Shows how to narrow event types for assign actions using the second argument of model.assign(), providing better type safety.

LANGUAGE: typescript
CODE:
const assignAge = userModel.assign(
  {
    age: (_, event) => event.value // inferred as `number`
  },
  'updateAge' // Restricts the `event` allowed by the "assignAge" action
);

const machine = userModel.createMachine({
  context: userModel.initialContext,
  initial: 'active',
  states: {
    active: {
      on: {
        updateAge: {
          actions: assignAge
        }
      }
    }
  }
});

----------------------------------------

TITLE: Using Null Events for Immediate Transitions in XState
DESCRIPTION: Illustrates the use of null events (represented by an empty string) for immediate transitions upon entering a state.

LANGUAGE: javascript
CODE:
// 人为的例子
const skipMachine = createMachine({
  id: 'skip',
  initial: 'one',
  states: {
    one: {
      on: { CLICK: 'two' }
    },
    two: {
      // 一旦进入状态，null 事件 '' 总是发生立即转换为 'three'
      on: { '': 'three' }
    },
    three: {
      type: 'final'
    }
  }
});

const { initialState } = skipMachine;
const nextState = skipMachine.transition(initialState, { type: 'CLICK' });

console.log(nextState.value);
// => 'three'

----------------------------------------

TITLE: Creating a Toggle Machine in XState
DESCRIPTION: Defines a simple toggle machine using XState's createMachine function. The machine has two states: 'inactive' and 'active', with a 'TOGGLE' event to switch between them.

LANGUAGE: javascript
CODE:
import { createMachine } from 'xstate';

const toggleMachine = createMachine({
  id: 'toggle',
  initial: 'inactive',
  states: {
    inactive: {
      on: {
        TOGGLE: 'active'
      }
    },
    active: {
      on: {
        TOGGLE: 'inactive'
      }
    }
  }
});

----------------------------------------

TITLE: Installing XState Inspect Package
DESCRIPTION: Commands to install the @xstate/inspect package using npm or yarn package managers.

LANGUAGE: bash
CODE:
npm install @xstate/inspect
# or yarn add @xstate/inspect

----------------------------------------

TITLE: Persisting and Rehydrating State in JavaScript
DESCRIPTION: Example of persisting and rehydrating state when using useMachine, utilizing localStorage for persistence.

LANGUAGE: javascript
CODE:
// Get the persisted state config object from somewhere, e.g. localStorage

const persistedState = JSON.parse(
  localStorage.getItem('some-persisted-state-key')
);

const { state, send } = useMachine(someMachine, {
  state: persistedState
});

// state will initially be that persisted state, not the machine's initialState

----------------------------------------

TITLE: Implementing Transient State Nodes in XState JavaScript
DESCRIPTION: Example of implementing a transient state node using an 'always' transition to determine the next state based on conditions.

LANGUAGE: javascript
CODE:
const timeOfDayMachine = createMachine({
  id: 'timeOfDay',
  initial: 'unknown',
  context: {
    time: undefined
  },
  states: {
    // Transient state
    unknown: {
      always: [
        { target: 'morning', cond: 'isBeforeNoon' },
        { target: 'afternoon', cond: 'isBeforeSix' },
        { target: 'evening' }
      ]
    },
    morning: {},
    afternoon: {},
    evening: {}
  }
}, {
  guards: {
    isBeforeNoon: // ...
    isBeforeSix: // ...
  }
});

const timeOfDayService = interpret(timeOfDayMachine.withContext({ time: Date.now() }))
  .onTransition(state => console.log(state.value))
  .start();

// => 'morning' (assuming the time is before noon)

----------------------------------------

TITLE: Using Custom IDs for State Nodes in XState
DESCRIPTION: This example shows how to assign custom IDs to state nodes and target them using the '#' symbol, simplifying complex statecharts.

LANGUAGE: javascript
CODE:
const lightMachine = createMachine({
  id: 'light',
  initial: 'green',
  states: {
    green: {
      // custom identifier
      id: 'greenLight',
      on: {
        // target state node by its ID
        TIMER: { target: '#yellowLight' }
      }
    },
    yellow: {
      id: 'yellowLight',
      on: {
        TIMER: { target: '#redLight' }
      }
    },
    red: {
      id: 'redLight',
      on: {
        // relative targets will still work
        TIMER: { target: 'green' }
      }
    }
  }
});

----------------------------------------

TITLE: Defining State IDs in XState and SCXML
DESCRIPTION: Demonstrates how state IDs are defined in XState and their corresponding representation in SCXML. State IDs are crucial for uniquely identifying states within the machine.

LANGUAGE: javascript
CODE:
{
  green: {
    id: 'lightGreen';
  }
}

LANGUAGE: xml
CODE:
<state id="lightGreen">
  <!-- ... -->
</state>

----------------------------------------

TITLE: Installing XState and @xstate/graph
DESCRIPTION: Command to install the required packages xstate and @xstate/graph using npm.

LANGUAGE: bash
CODE:
npm install xstate @xstate/graph

----------------------------------------

TITLE: Standard XState Usage in Svelte Component
DESCRIPTION: Implementation of XState machine in a Svelte component using the interpret service with standard state management.

LANGUAGE: html
CODE:
<script>
  import { interpret } from 'xstate';
  import { toggleMachine } from './machine';

  let current;

  const toggleService = interpret(toggleMachine)
    .onTransition((state) => {
      current = state;
    })
    .start();
</script>

<button on:click="{() => toggleService.send({ type: 'TOGGLE' })}">
  {current.matches('inactive') ? 'Off' : 'On'}
</button>

----------------------------------------

TITLE: Using Tags in State Nodes with XState JavaScript
DESCRIPTION: Example of using tags in state nodes to categorize states and check for tags using state.hasTag() method.

LANGUAGE: javascript
CODE:
const machine = createMachine({
  initial: 'idle',
  states: {
    idle: {
      on: {
        FETCH: 'loadingUser'
      }
    },
    loadingUser: {
      tags: ['loading']
      // ...
    },
    loadingFriends: {
      tags: ['loading']
      // ...
    },
    editing: {
      // ...
    }
  }
});

machine.initialState.hasTag('loading');
// => false

machine.transition(machine.initialState, { type: 'FETCH' }).hasTag('loading');
// => true

----------------------------------------

TITLE: Transient State Implementation
DESCRIPTION: Example of a transient state node implementation using the 'always' transition to immediately move to another state based on conditions.

LANGUAGE: javascript
CODE:
const timeOfDayMachine = createMachine({
  id: 'timeOfDay',
  initial: 'unknown',
  context: {
    time: undefined
  },
  states: {
    // Transient state
    unknown: {
      always: [
        { target: 'morning', cond: 'isBeforeNoon' },
        { target: 'afternoon', cond: 'isBeforeSix' },
        { target: 'evening' }
      ]
    },
    morning: {},
    afternoon: {},
    evening: {}
  }
}, {
  guards: {
    isBeforeNoon: // ...
    isBeforeSix: // ...
  }
});

----------------------------------------

TITLE: Installing XState via NPM
DESCRIPTION: Simple NPM command to install the XState library.

LANGUAGE: bash
CODE:
npm install xstate

----------------------------------------

TITLE: Using getShortestPaths with XState Machine
DESCRIPTION: Example demonstrating the usage of getShortestPaths function with a feedback machine, showing the structure of the returned object.

LANGUAGE: javascript
CODE:
import { createMachine } from 'xstate';
import { getShortestPaths } from '@xstate/graph';

const feedbackMachine = createMachine({
  id: 'feedback',
  initial: 'question',
  states: {
    question: {
      on: {
        CLICK_GOOD: 'thanks',
        CLICK_BAD: 'form',
        CLOSE: 'closed',
        ESC: 'closed'
      }
    },
    form: {
      on: {
        SUBMIT: 'thanks',
        CLOSE: 'closed',
        ESC: 'closed'
      }
    },
    thanks: {
      on: {
        CLOSE: 'closed',
        ESC: 'closed'
      }
    },
    closed: {
      type: 'final'
    }
  }
});

const shortestPaths = getShortestPaths(feedbackMachine);

console.log(shortestPaths);

----------------------------------------

TITLE: Embedding XState Visualizer iFrame
DESCRIPTION: Example of embedding an XState Visualizer iframe with full configuration including mode, panel, readonly status, and interaction controls.

LANGUAGE: html
CODE:
<iframe src="https://stately.ai/viz/embed/7c0ec648-09d6-46fe-a912-fc0e46da5094?mode=full&panel=state&readOnly=1&showOriginalLink=0&controls=1&pan=1&zoom=1"
allow="accelerometer; ambient-light-sensor; camera; encrypted-media; geolocation; gyroscope; hid; microphone; midi; payment; usb; vr; xr-spatial-tracking"
sandbox="allow-forms allow-modals allow-popups allow-presentation allow-same-origin allow-scripts"
></iframe>

----------------------------------------

TITLE: State Node Meta Data Configuration
DESCRIPTION: Demonstration of adding meta data to state nodes for additional state information and properties.

LANGUAGE: javascript
CODE:
const fetchMachine = createMachine({
  id: 'fetch',
  initial: 'idle',
  states: {
    idle: {
      on: {
        FETCH: { target: 'loading' }
      }
    },
    loading: {
      after: {
        3000: { target: 'failure.timeout' }
      },
      on: {
        RESOLVE: { target: 'success' },
        REJECT: { target: 'failure' },
        TIMEOUT: { target: 'failure.timeout' }
      },
      meta: {
        message: 'Loading...'
      }
    },
    success: {
      meta: {
        message: 'The request succeeded!'
      }
    },
    failure: {
      initial: 'rejection',
      states: {
        rejection: {
          meta: {
            message: 'The request failed.'
          }
        },
        timeout: {
          meta: {
            message: 'The request timed out.'
          }
        }
      },
      meta: {
        alert: 'Uh oh.'
      }
    }
  }
});

----------------------------------------

TITLE: Creating a Simple Sequence State Machine in JavaScript with XState
DESCRIPTION: This snippet shows how to create a basic state machine for a three-step sequence using XState. It demonstrates transitions between states and includes an optional previous step.

LANGUAGE: javascript
CODE:
const stepMachine = createMachine({
  id: 'step',
  initial: 'one',
  states: {
    one: {
      on: { NEXT: 'two' }
    },
    two: {
      on: { NEXT: 'three', PREV: 'one' }
    },
    three: {
      type: 'final'
    }
  }
});

console.log(stepMachine.transition('one', { type: 'NEXT' }).value);
// => 'two'

----------------------------------------

TITLE: Importing XState in Deno using Skypack CDN
DESCRIPTION: This code snippet shows how to import the createMachine function from XState using Skypack CDN in a Deno environment. This method allows Deno to use XState without the need for a node_modules directory, as packages are installed at runtime.

LANGUAGE: javascript
CODE:
import { createMachine } from 'https://cdn.skypack.dev/xstate';

----------------------------------------

TITLE: Using getPathFromEvents with XState Machine
DESCRIPTION: Demonstration of using getPathFromEvents function to generate a path from a sequence of events for a given machine.

LANGUAGE: javascript
CODE:
import { createMachine } from 'xstate';
import { getSimplePaths } from '@xstate/graph';

const feedbackMachine = createMachine({
  id: 'feedback',
  initial: 'question',
  states: {
    question: {
      on: {
        CLICK_GOOD: 'thanks',
        CLICK_BAD: 'form',
        CLOSE: 'closed',
        ESC: 'closed'
      }
    },
    form: {
      on: {
        SUBMIT: 'thanks',
        CLOSE: 'closed',
        ESC: 'closed'
      }
    },
    thanks: {
      on: {
        CLOSE: 'closed',
        ESC: 'closed'
      }
    },
    closed: {
      type: 'final'
    }
  }
});

const path = getPathFromEvents(feedbackMachine, [
  { type: 'CLICK_GOOD' },
  { type: 'SUBMIT' },
  { type: 'CLOSE' }
]);

console.log(path);

----------------------------------------

TITLE: State Node Type Changes in XState 4
DESCRIPTION: Demonstrates the change in syntax for declaring parallel and history state nodes using the new type property instead of boolean flags.

LANGUAGE: diff
CODE:
- parallel: true,
+ type: 'parallel'

- history: true,
+ type: 'history',
+ history: 'deep', // 'shallow' by default

----------------------------------------

TITLE: Creating and Exporting XState Service in JavaScript
DESCRIPTION: Example of creating an XState machine and exporting it as an interpreted service for use in Svelte components.

LANGUAGE: javascript
CODE:
// service.js

import { createMachine, interpret } from 'xstate';

const toggleMachine = createMachine({
  id: 'toggle',
  initial: 'inactive',
  states: {
    inactive: {
      on: { TOGGLE: 'active' }
    },
    active: {
      on: { TOGGLE: 'inactive' }
    }
  }
});

export const toggleService = interpret(toggleMachine).start();

----------------------------------------

TITLE: Restoring Persisted Activities
DESCRIPTION: Code showing how to properly restore and restart activities when rehydrating a persisted state machine state.

LANGUAGE: javascript
CODE:
import { State, actions } from 'xstate';

const restoredState = State.create(somePersistedStateJSON);

Object.keys(restoredState.activities).forEach((activityKey) => {
  if (restoredState.activities[activityKey]) {
    restoredState.actions.push(actions.start(activityKey));
  }
});

someService.start(restoredState);

----------------------------------------

TITLE: Implementing XState Toggle Machine in a Vue Component
DESCRIPTION: This snippet shows how to use the XState toggle machine within a Vue component. It demonstrates creating a service, handling state transitions, and sending events to the machine.

LANGUAGE: html
CODE:
<!-- Toggle.vue -->
<template>
  <button v-on:click="send('TOGGLE');">
    {{ current.matches("inactive") ? "Off" : "On" }}
  </button>
</template>

<script>
  import { interpret } from 'xstate';
  import { toggleMachine } from '../path/to/toggleMachine';

  export default {
    name: 'Toggle',
    created() {
      // Start service on component creation
      this.toggleService
        .onTransition((state) => {
          // Update the current state component data property with the next state
          this.current = state;
          // Update the context component data property with the updated context
          this.context = state.context;
        })
        .start();
    },
    data() {
      return {
        // Interpret the machine and store it in data
        toggleService: interpret(toggleMachine),

        // Start with the machine's initial state
        current: toggleMachine.initialState,

        // Start with the machine's initial context
        context: toggleMachine.context
      };
    },
    methods: {
      // Send events to the service
      send(event) {
        this.toggleService.send(event);
      }
    }
  };
</script>

----------------------------------------

TITLE: Loading @xstate/react via CDN
DESCRIPTION: HTML script tag to load the @xstate/react package from a CDN.

LANGUAGE: html
CODE:
<script src="https://unpkg.com/@xstate/react/dist/xstate-react.umd.min.js"></script>

----------------------------------------

TITLE: Converting XState Machine to Directed Graph
DESCRIPTION: Example of using toDirectedGraph function to convert an XState machine into a directed graph structure.

LANGUAGE: javascript
CODE:
import { toDirectedGraph } from '@xstate/graph';

const machine = createMachine({/* ... */});

const digraph = toDirectedGraph(machine);

// returns an object with this structure:
{
  id: '...',
  stateNode: /* StateNode */,
  children: [
    { id: '...', children: [/* ... */], edges: [/* ... */] },
    { id: '...', /* ... */ },
    // ...
  ],
  edges: [
    { source: /* ... */, target: /* ... */, transition: /* ... */ }
    // ...
  ]
}

----------------------------------------

TITLE: Using Schema Property for Machine Types
DESCRIPTION: Providing metadata and type information through the schema property

LANGUAGE: typescript
CODE:
const machine = createMachine({
  schema: {
    context: createSchema<{ count: number }>(),
    events: createSchema<{ type: 'FOO' } | { type: 'BAR' }>()
  }
});

----------------------------------------

TITLE: Running Tests with Coverage using @xstate/test
DESCRIPTION: Demonstrates how to create test plans, run tests, and check for full coverage using the created test model. This snippet uses Jest's describe and it functions for test organization.

LANGUAGE: javascript
CODE:
// ...

describe('toggle', () => {
  const testPlans = toggleModel.getShortestPathPlans();

  testPlans.forEach((plan) => {
    describe(plan.description, () => {
      plan.paths.forEach((path) => {
        it(path.description, async () => {
          // do any setup, then...

          await path.test(page);
        });
      });
    });
  });

  it('should have full coverage', () => {
    return toggleModel.testCoverage();
  });
});

----------------------------------------

TITLE: Installing @xstate/inspect Package
DESCRIPTION: Instructions for installing the @xstate/inspect package using npm or yarn package managers.

LANGUAGE: bash
CODE:
npm install @xstate/inspect
# or yarn add @xstate/inspect

----------------------------------------

TITLE: Running Tests with Coverage using @xstate/test
DESCRIPTION: Demonstrates how to create test plans, run tests, and check for full coverage using the created test model. This snippet uses Jest's describe and it functions for test organization.

LANGUAGE: javascript
CODE:
// ...

describe('toggle', () => {
  const testPlans = toggleModel.getShortestPathPlans();

  testPlans.forEach((plan) => {
    describe(plan.description, () => {
      plan.paths.forEach((path) => {
        it(path.description, async () => {
          // do any setup, then...

          await path.test(page);
        });
      });
    });
  });

  it('should have full coverage', () => {
    return toggleModel.testCoverage();
  });
});

----------------------------------------

TITLE: Using useMachine Hook with React and XState
DESCRIPTION: Example of using the useMachine hook to create a toggle button component with XState.

LANGUAGE: javascript
CODE:
import { useMachine } from '@xstate/react';
import { createMachine } from 'xstate';

const toggleMachine = createMachine({
  id: 'toggle',
  initial: 'inactive',
  states: {
    inactive: {
      on: { TOGGLE: 'active' }
    },
    active: {
      on: { TOGGLE: 'inactive' }
    }
  }
});

export const Toggler = () => {
  const [state, send] = useMachine(toggleMachine);

  return (
    <button onClick={() => send('TOGGLE')}>
      {state.value === 'inactive'
        ? 'Click to activate'
        : 'Active! Click to deactivate'}
    </button>
  );
};

----------------------------------------

TITLE: Hierarchical Traffic Light State Machine
DESCRIPTION: Extended traffic light machine with nested pedestrian states, demonstrating hierarchical state composition.

LANGUAGE: javascript
CODE:
import { createMachine } from 'xstate';

const pedestrianStates = {
  initial: 'walk',
  states: {
    walk: {
      on: {
        PED_TIMER: 'wait'
      }
    },
    wait: {
      on: {
        PED_TIMER: 'stop'
      }
    },
    stop: {}
  }
};

const lightMachine = createMachine({
  id: 'light',
  initial: 'green',
  states: {
    green: {
      on: {
        TIMER: 'yellow'
      }
    },
    yellow: {
      on: {
        TIMER: 'red'
      }
    },
    red: {
      on: {
        TIMER: 'green'
      },
      ...pedestrianStates
    }
  }
});

----------------------------------------

TITLE: Submit Workflow Event API Request
DESCRIPTION: cURL command for submitting an event to an existing workflow instance with user data.

LANGUAGE: bash
CODE:
curl -X POST http://localhost:4242/workflows/:id -d '{"type": "Submit", "SSN": "123456789", "lastName": "Bauman", "firstName": "Gavin"}' -H "Content-Type: application/json"

----------------------------------------

TITLE: Modeling Min and Max Values in XState Counter
DESCRIPTION: This snippet extends the basic counter by adding guards to model minimum and maximum values. It prevents transitions on 'DEC' and 'INC' events when the count reaches certain thresholds.

LANGUAGE: javascript
CODE:
const isNotMax = (context) => context.count < 10;
const isNotMin = (context) => context.count >= 0;

const counterMachine = createMachine({
  initial: 'active',
  context: {
    count: 0
  },
  states: {
    active: {
      on: {
        INC: {
          actions: assign({ count: increment }),
          cond: isNotMax
        },
        DEC: {
          actions: assign({ count: decrement }),
          cond: isNotMin
        }
      }
    }
  }
});

// assume context is { count: 9 }
counterService.send({ type: 'INC' });
// => 10

counterService.send({ type: 'INC' }); // no transition taken!
// => 10

----------------------------------------

TITLE: Basic Toggle State Machine Implementation
DESCRIPTION: Demonstrates creating a simple toggle state machine with context and transitions between active/inactive states using XState.

LANGUAGE: typescript
CODE:
import { createMachine, createActor, assign } from 'xstate';

// State machine
const toggleMachine = createMachine({
  id: 'toggle',
  initial: 'inactive',
  context: {
    count: 0
  },
  states: {
    inactive: {
      on: {
        TOGGLE: { target: 'active' }
      }
    },
    active: {
      entry: assign({ count: ({ context }) => context.count + 1 }),
      on: {
        TOGGLE: { target: 'inactive' }
      }
    }
  }
});

// Actor (instance of the machine logic, like a store)
const toggleActor = createActor(toggleMachine);
toggleActor.subscribe((state) => console.log(state.value, state.context));
toggleActor.start();
// => logs 'inactive', { count: 0 }

toggleActor.send({ type: 'TOGGLE' });
// => logs 'active', { count: 1 }

toggleActor.send({ type: 'TOGGLE' });
// => logs 'inactive', { count: 1 }

----------------------------------------

TITLE: Transitioning with History States in XState Fan Machine
DESCRIPTION: This snippet shows how to use the fan machine with history states. It demonstrates transitions to initial states, history states, and how the machine remembers previous states when returning to a history state.

LANGUAGE: javascript
CODE:
const firstState = fanMachine.transition(fanMachine.initialState, {
  type: 'POWER'
});
console.log(firstState.value);
// transitions to the initial state of 'fanOn' since there is no history
// => {
//   fanOn: 'first'
// }

const secondState = fanMachine.transition(firstState, { type: 'SWITCH' });
console.log(secondState.value);
// => {
//   fanOn: 'second'
// }

const thirdState = fanMachine.transition(secondState, { type: 'POWER' });
console.log(thirdState.value);
// => 'fanOff'

console.log(thirdState.history);
// => State {
//   value: { fanOn: 'second' },
//   actions: []
// }

const fourthState = fanMachine.transition(thirdState, { type: 'POWER' });
console.log(fourthState.value);
// transitions to 'fanOn.second' from history
// => {
//   fanOn: 'second'
// }

----------------------------------------

TITLE: Configuring Machines with useMachine in React
DESCRIPTION: Example of configuring an existing machine with custom actions and services using the useMachine hook.

LANGUAGE: javascript
CODE:
const Fetcher = ({ onResolve }) => {
  const [state, send] = useMachine(fetchMachine, {
    actions: {
      notifySuccess: (ctx) => onResolve(ctx.data)
    },
    services: {
      fetchData: (_, e) =>
        fetch(`some/api/${e.query}`).then((res) => res.json())
    }
  });

  switch (state.value) {
    case 'idle':
      return (
        <button onClick={() => send({ type: 'FETCH', query: 'something' })}>
          Search for something
        </button>
      );
    case 'loading':
      return <div>Searching...</div>;
    case 'success':
      return <div>Success! Data: {state.context.data}</div>;
    case 'failure':
      return (
        <>
          <p>{state.context.error.message}</p>
          <button onClick={() => send('RETRY')}>Retry</button>
        </>
      );
    default:
      return null;
  }
};

----------------------------------------

TITLE: Payment State Machine with History
DESCRIPTION: Example of a payment system state machine using history states to remember previous selections.

LANGUAGE: javascript
CODE:
const paymentMachine = createMachine({
  id: 'payment',
  initial: 'method',
  states: {
    method: {
      initial: 'cash',
      states: {
        cash: { on: { SWITCH_CHECK: 'check' } },
        check: { on: { SWITCH_CASH: 'cash' } },
        hist: { type: 'history' }
      },
      on: { NEXT: 'review' }
    },
    review: {
      on: { PREVIOUS: 'method.hist' }
    }
  }
});

----------------------------------------

TITLE: MongoDB Connection String Configuration in TypeScript
DESCRIPTION: Configuration line for establishing MongoDB connection. Should be replaced with actual MongoDB connection string or loaded from environment variables.

LANGUAGE: typescript
CODE:
const uri = '<your mongodb connection string>';

----------------------------------------

TITLE: React UI Implementation with XState
DESCRIPTION: Shows how to integrate the XState machine with a React component using @xstate/react.

LANGUAGE: jsx
CODE:
import React from 'react';
import { useMachine } from '@xstate/react';
import { redditMachine } from '../path/to/redditMachine';

const subreddits = ['frontend', 'reactjs', 'vuejs'];

const App = () => {
  const [current, send] = useMachine(redditMachine);
  const { subreddit, posts } = current.context;

  return (
    <main>
      <header>
        <select
          onChange={(e) => {
            send({ type: 'SELECT', name: e.target.value });
          }}
        >
          {subreddits.map((subreddit) => {
            return <option key={subreddit}>{subreddit}</option>;
          })}
        </select>
      </header>
      <section>
        <h1>{current.matches('idle') ? 'Select a subreddit' : subreddit}</h1>
        {current.matches({ selected: 'loading' }) && <div>Loading...</div>}
        {current.matches({ selected: 'loaded' }) && (
          <ul>
            {posts.map((post) => (
              <li key={post.title}>{post.title}</li>
            ))}
          </ul>
        )}
      </section>
    </main>
  );
};

----------------------------------------

TITLE: Nested Parallel States in Traffic Light Machine
DESCRIPTION: Implements a traffic light state machine with a nested parallel state for the red light condition. The red state contains parallel states for both the walk sign and pedestrian signals, demonstrating nested parallel state functionality.

LANGUAGE: javascript
CODE:
const lightMachine = createMachine({
  id: 'light',
  initial: 'green',
  states: {
    green: {
      on: {
        TIMER: { target: 'yellow' }
      }
    },
    yellow: {
      on: {
        TIMER: { target: 'red' }
      }
    },
    red: {
      type: 'parallel',
      states: {
        walkSign: {
          initial: 'solid',
          states: {
            solid: {
              on: {
                COUNTDOWN: { target: 'flashing' }
              }
            },
            flashing: {
              on: {
                STOP_COUNTDOWN: { target: 'solid' }
              }
            }
          }
        },
        pedestrian: {
          initial: 'walk',
          states: {
            walk: {
              on: {
                COUNTDOWN: { target: 'wait' }
              }
            },
            wait: {
              on: {
                STOP_COUNTDOWN: { target: 'stop' }
              }
            },
            stop: {
              type: 'final'
            }
          }
        }
      }
    }
  }
});

console.log(lightMachine.transition('yellow', { type: 'TIMER' }).value);

----------------------------------------

TITLE: Using History States with Default Targets in JavaScript
DESCRIPTION: This code snippet demonstrates how a history state with a specified target behaves when there is no existing history for the state region.

LANGUAGE: javascript
CODE:
const firstState = fanMachine.transition(fanMachine.initialState, {
  type: 'HIGH_POWER'
});
console.log(firstState.value);
// transitions to the target state of 'fanOn.third' since there is no history
// => {
//   fanOn: 'third'
// }

----------------------------------------

TITLE: Project Installation and Startup Commands
DESCRIPTION: Commands for installing project dependencies and starting the application using pnpm package manager.

LANGUAGE: bash
CODE:
pnpm install
pnpm start

----------------------------------------

TITLE: Modeling Events and Using Typed Assignments in TypeScript
DESCRIPTION: Shows how to model events with createModel() in TypeScript, providing type safety for event creation and context assignments. Demonstrates creating a machine with typed context and events.

LANGUAGE: typescript
CODE:
import { createModel } from 'xstate/lib/model';

const userModel = createModel(
  // Initial context
  {
    name: 'David',
    age: 30
  },
  {
    // Create events
    events: {
      updateName: (value) => ({ value }),
      updateAge: (value) => ({ value }),
      anotherEvent: () => ({}) // No payload
    }
  }
);

const machine = userModel.createMachine(
  {
    context: userModel.initialContext,
    initial: 'active',
    states: {
      active: {
        on: {
          updateName: {
            actions: userModel.assign({
              name: (_, event) => event.value
            })
          },
          updateAge: {
            actions: 'assignAge'
          }
        }
      }
    }
  },
  {
    actions: {
      assignAge: userModel.assign({
        age: (_, event) => event.value // Inferred
      })
    }
  }
);

// This will send the following event:
// {
//   type: 'updateName',
//   value: 'David'
// }
const nextState = machine.transition(
  undefined,
  userModel.events.updateName('David')
);

----------------------------------------

TITLE: Creating Vite Project for XState Example
DESCRIPTION: Commands to create a new Vite project using a framework-specific template for an XState example.

LANGUAGE: bash
CODE:
pnpm create vite@latest my-example-react --template react-ts
cd my-example-react

----------------------------------------

TITLE: Implementing Asynchronous Sequences with XState and API Calls
DESCRIPTION: This snippet shows how to model asynchronous sequences using XState, specifically for fetching user information and friends data from an API. It demonstrates invoking Promise-based services in sequence, handling API responses, and updating the machine's context with the fetched data.

LANGUAGE: javascript
CODE:
function getUserInfo(context) {
  return fetch(`/api/users/${context.userId}`).then((response) =>
    response.json()
  );
}

function getUserFriends(context) {
  const { friends } = context.user;

  return Promise.all(
    friends.map((friendId) =>
      fetch(`/api/users/${friendId}/`).then((response) => response.json())
    )
  );
}

const friendsMachine = createMachine({
  id: 'friends',
  context: { userId: 42, user: undefined, friends: undefined },
  initial: 'gettingUser',
  states: {
    gettingUser: {
      invoke: {
        src: getUserInfo,
        onDone: {
          target: 'gettingFriends',
          actions: assign({
            user: (context, event) => event.data
          })
        }
      }
    },
    gettingFriends: {
      invoke: {
        src: getUserFriends,
        onDone: {
          target: 'success',
          actions: assign({
            friends: (context, event) => event.data
          })
        }
      }
    },
    success: {
      type: 'final'
    }
  }
});

----------------------------------------

TITLE: Installing XState via NPM
DESCRIPTION: Command to install the XState package using npm package manager.

LANGUAGE: bash
CODE:
npm install xstate

----------------------------------------

TITLE: Using XState Global Variable
DESCRIPTION: Example showing how to access XState functionality from the global variable after CDN inclusion.

LANGUAGE: javascript
CODE:
const { createMachine, actions, interpret } = XState; // global variable: window.XState

const lightMachine = createMachine({
  // ...
});

const lightService = interpret(lightMachine);

----------------------------------------

TITLE: Installing Dependencies with PNPM
DESCRIPTION: Command to install all required project dependencies using the PNPM package manager.

LANGUAGE: bash
CODE:
pnpm install

----------------------------------------

TITLE: Defining a Basic Event Object in JavaScript
DESCRIPTION: Shows how to create a simple event object with a type property, following the convention of using CONST_CASE for event names.

LANGUAGE: javascript
CODE:
const timerEvent = {
  type: 'TIMER' // 约定是使用 CONST_CASE 作为事件名称
};

----------------------------------------

TITLE: Displaying Frontmatter Title and Date in HTML
DESCRIPTION: This snippet demonstrates how to display the frontmatter title and formatted date using Vue.js template syntax within HTML tags.

LANGUAGE: HTML
CODE:
<h1>{{ $frontmatter.title }}</h1>
<p class="date">{{ new Date($frontmatter.date).toLocaleString('en-US',{ month:'long', day:'numeric', year:'numeric' }) }}</p>

----------------------------------------

TITLE: Retrieving Workflow Instance State
DESCRIPTION: cURL command to fetch the current state of a specific workflow instance using GET request

LANGUAGE: bash
CODE:
curl -X GET http://localhost:4242/workflows/:id

----------------------------------------

TITLE: Installing XState via Package Manager
DESCRIPTION: Commands for installing XState using npm or yarn package managers.

LANGUAGE: bash
CODE:
npm install xstate@latest --save
# or:
yarn add xstate@latest --save

----------------------------------------

TITLE: Enabling DevTools for XState Interpreted Machines
DESCRIPTION: Demonstrates how to enable developer tools for interpreted XState machines by setting the devTools option to true.

LANGUAGE: javascript
CODE:
import { interpret } from 'xstate';
import { inspect } from '@xstate/inspect';
// ...

const service = interpret(someMachine, { devTools: true });

----------------------------------------

TITLE: Initializing XState Machine as Actor in TypeScript
DESCRIPTION: Creates an XState actor from the mediaScannerMachine and injects input context for base and destination paths.

LANGUAGE: typescript
CODE:
const mediaScannerActor = createActor(mediaScannerMachine, {
  input: {
    basePath: 'YOUR BASE PATH HERE',
    destinationPath: 'YOUR DESTINATION PATH HERE'
  }
});

----------------------------------------

TITLE: Using String Shorthand for Simple Events in XState
DESCRIPTION: Demonstrates how events with only a type can be represented as a string shorthand in XState.

LANGUAGE: javascript
CODE:
// 等于 { type: 'TIMER' }
const timerEvent = 'TIMER';

----------------------------------------

TITLE: Displaying Frontmatter Title and Date in HTML
DESCRIPTION: This snippet shows how to render the title from frontmatter and format the date using Vue.js templating in HTML.

LANGUAGE: HTML
CODE:
<h1>{{ $frontmatter.title }}</h1>
<p class="date">{{ new Date($frontmatter.date).toLocaleString('en-US',{ month:'long', day:'numeric', year:'numeric' }) }}</p>

----------------------------------------

TITLE: Configuring Custom Serializer in XState Inspect
DESCRIPTION: Demonstrates how to specify a custom serializer function when using inspect() to handle special object types like Map.

LANGUAGE: javascript
CODE:
inspect({
  // ...
  serialize: (key, value) => {
    if (value instanceof Map) {
      return 'map';
    }

    return value;
  }
});

// ...

// Will be inspected as:
// {
//   type: 'EVENT_WITH_MAP',
//   map: 'map'
// }
someService.send({
  type: 'EVENT_WITH_MAP',
  map: new Map()
});

----------------------------------------

TITLE: Including XState via CDN Script Tag
DESCRIPTION: HTML script tag for including XState directly from unpkg CDN.

LANGUAGE: html
CODE:
<script src="https://unpkg.com/xstate@4/dist/xstate.js"></script>

----------------------------------------

TITLE: Implementing Custom XState Inspector with Window Receiver
DESCRIPTION: Example of creating a custom inspector using a window receiver to listen for and send events to inspected services.

LANGUAGE: javascript
CODE:
import { createWindowReceiver } from '@xstate/inspect';

const windowReceiver = createWindowReceiver(/* options? */);

windowReceiver.subscribe((event) => {
  // here, you will receive "service.*" events
  console.log(event);
});

// This will send the event to the inspected service
windowReceiver.send({
  type: 'xstate.event',
  event: JSON.stringify({ type: 'someEvent' }),
  service: /* session ID of the service this event is sent to */
});

----------------------------------------

TITLE: Deprecated States Configuration in XState 4
DESCRIPTION: Shows the deprecated nested object syntax for state transitions that will no longer work in version 4.

LANGUAGE: javascript
CODE:
const machine = createMachine({
  // ...
  states: {
    green: {
      on: {
        TIMER: {
          // ⚠️ deprecated in v4
          yellow: { actions: ['doSomething'] }
        }
      }
    }
  }
});

----------------------------------------

TITLE: Transitioning State Based on Events in XState
DESCRIPTION: Shows how to use the transition method to change state based on an event in an XState machine.

LANGUAGE: javascript
CODE:
import { createMachine } from 'xstate';

const lightMachine = createMachine({
  /* ... */
});

const { initialState } = lightMachine;

nextState = lightMachine.transition(nextState, { type: 'TIMER' }); // 事件对象
console.log(nextState.value);
// => 'red'

----------------------------------------

TITLE: Using XState Graph Utilities
DESCRIPTION: Example showing how to import and use graph utilities from @xstate/graph package, specifically demonstrating the getSimplePaths function with a state machine

LANGUAGE: javascript
CODE:
import { createMachine } from 'xstate';
import { getSimplePaths } from '@xstate/graph';

const machine = createMachine(/* ... */);
const paths = getSimplePaths(machine);

----------------------------------------

TITLE: Creating Basic XState Toggle Machine
DESCRIPTION: Defines a basic XState machine for toggle functionality that's framework-agnostic. The machine handles inactive and active states with toggle transitions between them.

LANGUAGE: javascript
CODE:
import { createMachine } from 'xstate';

// This machine is completely decoupled from Ember
export const toggleMachine = createMachine({
  id: 'toggle',
  context: {
    /* some data */
  },
  initial: 'inactive',
  states: {
    inactive: {
      on: { TOGGLE: 'active' }
    },
    active: {
      on: { TOGGLE: 'inactive' }
    }
  }
});

----------------------------------------

TITLE: Configuring Machine for Inspection
DESCRIPTION: Example of configuring an XState machine for inspection by enabling devTools

LANGUAGE: javascript
CODE:
import { interpret } from 'xstate';
import { inspect } from '@xstate/inspect';
// ...

const service = interpret(someMachine, { devTools: true });
service.start();

----------------------------------------

TITLE: Converting Adjacency Map to Array in TypeScript
DESCRIPTION: Example demonstrating how to convert a state machine adjacency map to an array of state/event/nextState objects using adjacencyMapToArray.

LANGUAGE: typescript
CODE:
import { getAdjacencyMap, adjacencyMapToArray } from '@xstate/graph';

const machine = createMachine({
  initial: 'green',
  states: {
    green: {
      on: {
        TIMER: 'yellow'
      }
    },
    yellow: {
      on: {
        TIMER: 'red'
      }
    },
    red: {
      on: {
        TIMER: 'green'
      }
    }
  }
});

const arr = adjacencyMapToArray(getAdjacencyMap(machine));

----------------------------------------

TITLE: Configuring Machines in Vue Component
DESCRIPTION: Example of configuring an existing machine with custom actions and services in a Vue component.

LANGUAGE: vue
CODE:
<script setup>
import { assign, createMachine } from 'xstate';
import { useMachine } from '@xstate/vue';

const fetchMachine = createMachine({
  id: 'fetch',
  initial: 'idle',
  context: {
    data: undefined,
    error: undefined
  },
  states: {
    idle: {
      on: { FETCH: 'loading' }
    },
    loading: {
      invoke: {
        src: 'fetchData',
        onDone: {
          target: 'success',
          actions: assign({
            data: (_context, event) => event.data
          })
        },
        onError: {
          target: 'failure',
          actions: assign({
            error: (_context, event) => event.data
          })
        }
      }
    },
    success: {
      entry: 'notifySuccess',
      type: 'final'
    },
    failure: {
      on: {
        RETRY: 'loading'
      }
    }
  }
});

const props = defineProps({
  onResolve: {
    type: Function,
    default: () => {}
  }
});

const { state, send } = useMachine(fetchMachine, {
  actions: {
    notifySuccess: (ctx) => props.onResolve(ctx.data)
  },
  services: {
    fetchData: (_context, event) =>
      fetch(`some/api/${event.query}`).then((res) => res.json())
  }
});
</script>

<template>
  <template v-if="state.value === 'idle'">
    <button @click="send({ type: 'FETCH', query: 'something' })">
      Search for something
    </button>
  </template>

  <template v-else-if="state.value === 'loading'">
    <div>Searching...</div>
  </template>

  <template v-else-if="state.value === 'success'">
    <div>Success! {{ state.context.data }}</div>
  </template>

  <template v-else-if="state.value === 'failure'">
    <p>{{ state.context.error.message }}</p>
    <button @click="send('RETRY')">Retry</button>
  </template>
</template>

----------------------------------------

TITLE: Input-based Path Generation in TypeScript
DESCRIPTION: Example showing path generation with input support for actor logic using a test model and getShortestPaths.

LANGUAGE: typescript
CODE:
const model = createTestModel(
  setup({
    types: {
      input: {} as {
        name: string;
      },
      context: {} as {
        name: string;
      }
    }
  }).createMachine({
    context: (x) => ({
      name: x.input.name
    }),
    initial: 'checking',
    states: {
      checking: {
        always: [
          { guard: (x) => x.context.name.length > 3, target: 'longName' },
          { target: 'shortName' }
        ]
      },
      longName: {},
      shortName: {}
    }
  })
);

const path1 = model.getShortestPaths({
  input: { name: 'ed' }
});

const path2 = model.getShortestPaths({
  input: { name: 'edward' }
});

----------------------------------------

TITLE: Using getSimplePaths with XState Machine
DESCRIPTION: Example showing how to use getSimplePaths function with a feedback machine, illustrating the structure of the returned object.

LANGUAGE: javascript
CODE:
import { createMachine } from 'xstate';
import { getSimplePaths } from '@xstate/graph';

const feedbackMachine = createMachine({
  id: 'feedback',
  initial: 'question',
  states: {
    question: {
      on: {
        CLICK_GOOD: 'thanks',
        CLICK_BAD: 'form',
        CLOSE: 'closed',
        ESC: 'closed'
      }
    },
    form: {
      on: {
        SUBMIT: 'thanks',
        CLOSE: 'closed',
        ESC: 'closed'
      }
    },
    thanks: {
      on: {
        CLOSE: 'closed',
        ESC: 'closed'
      }
    },
    closed: {
      type: 'final'
    }
  }
});

const simplePaths = getSimplePaths(feedbackMachine);

console.log(simplePaths);

----------------------------------------

TITLE: Custom Event Handling Implementation
DESCRIPTION: Example of implementing custom event handling with a separate locally hosted tool

LANGUAGE: typescript
CODE:
const url = 'http://127.0.0.1:8443/';
const targetWindow = window.open(url);

const inspector = inspect({
  url,
  targetWindow
});

createWindowReceiver({}).subscribe((event) => {
  if (event.type === 'service.register') {
    // Do something when a new machine is started
  } else if (event.type === 'service.stop') {
    // Do something when a machine enters a terminal state
  } else if (event.type === 'service.event') {
    // Do something when a machine receives an event
  } else if (event.type === 'service.state') {
    // Do something when a machine enters to a new state
    // Note: Does not handle transitional states.
  }
});

----------------------------------------

TITLE: Machine Event Logging Setup
DESCRIPTION: Configuration for logging all machine events and transitions in a local development environment

LANGUAGE: typescript
CODE:
const url = 'http://127.0.0.1:5174/';

const inspector = inspect({
  url,
  iframe: undefined,
  targetWindow: window
});

createWindowReceiver({}).subscribe(console.log);

interpret(machine, { devTools: true }).start({});

----------------------------------------

TITLE: Implementing Local State with XState and SolidJS
DESCRIPTION: Demonstrates how to use the useMachine hook from @xstate/solid to manage local state in a SolidJS component. The example shows a toggle button that switches between 'On' and 'Off' states.

LANGUAGE: javascript
CODE:
import { useMachine } from '@xstate/solid';
import { toggleMachine } from '../path/to/toggleMachine';

function Toggle() {
  const [current, send] = useMachine(toggleMachine);

  return (
    <button onClick={() => send({ type: 'TOGGLE' })}>
      {current.matches('inactive') ? 'Off' : 'On'}
    </button>
  );
}

----------------------------------------

TITLE: Dependency Update Links in Markdown
DESCRIPTION: Git commit links showing dependency updates and version changes for the XState Solid integration package.

LANGUAGE: markdown
CODE:
[[`d99df1d8f4fe49145c9974465b65028bf19b365f`](https://github.com/statelyai/xstate/commit/d99df1d8f4fe49145c9974465b65028bf19b365f)]:
  - xstate@5.19.2

----------------------------------------

TITLE: Using Options with getShortestPaths
DESCRIPTION: Example demonstrating the use of options in getShortestPaths to customize event handling and state traversal for a counter machine.

LANGUAGE: javascript
CODE:
const counterMachine = createMachine({
  id: 'counter',
  initial: 'active',
  context: { count: 0 },
  states: {
    active: {
      on: {
        INC: {
          actions: assign({ count: (ctx, e) => ctx.count + e.value })
        }
      }
    }
  }
});

const shortestPaths = getShortestPaths(counterMachine, {
  events: {
    INC: [
      { type: 'INC', value: 1 },
      { type: 'INC', value: 2 }
    ]
  },
  filter: (state) => state.context.count <= 5
});

console.log(shortestPaths);

----------------------------------------

TITLE: Creating Window Receiver for XState Inspector
DESCRIPTION: Shows how to create a window receiver to listen for inspector events from a parent window in both popup and iframe scenarios.

LANGUAGE: javascript
CODE:
import { createWindowReceiver } from '@xstate/inspect';

const windowReceiver = createWindowReceiver(/* options? */);

windowReceiver.subscribe((event) => {
  // here, you will receive events like:
  // { type: "service.register", machine: ..., state: ..., sessionId: ... }
  console.log(event);
});

----------------------------------------

TITLE: Using useSelector with XState Store in React
DESCRIPTION: Example showing how to use useSelector hook from @xstate/react with @xstate/store to access state values

LANGUAGE: tsx
CODE:
import { createStore } from '@xstate/store';
import { useSelector } from '@xstate/react';

const store = createStore(
  {
    count: 0
  },
  {
    inc: {
      count: (context) => context.count + 1
    }
  }
);

function Counter() {
  const count = useSelector(store, (state) => state.context.count);

  return (
    <div>
      <button onClick={() => store.send({ type: 'inc' })}>{count}</button>
    </div>
  );
}

----------------------------------------

TITLE: Accessing Global State from XState in SolidJS Components
DESCRIPTION: Demonstrates how to access and use global state managed by XState within a SolidJS component using the useContext hook.

LANGUAGE: javascript
CODE:
import { useContext } from 'solid-js';
import { GlobalStateContext } from './globalState';

export const SomeComponent = (props) => {
  const {
    authService: [state]
  } = useContext(GlobalStateContext);
  return <>{state.matches('loggedIn') ? 'Logged In' : 'Logged Out'}</>;
};

----------------------------------------

TITLE: Initializing XState Inspector
DESCRIPTION: Basic setup code for initializing the XState inspector with configuration options

LANGUAGE: javascript
CODE:
import { inspect } from '@xstate/inspect';

inspect({
  // options
  // url: 'https://stately.ai/viz?inspect', // (default)
  iframe: false // open in new window
});

----------------------------------------

TITLE: TypeScript Integration with XState Immer
DESCRIPTION: Demonstrates proper TypeScript typing for XState Immer, including context and event type definitions.

LANGUAGE: typescript
CODE:
import { createMachine } from 'xstate';
import { createUpdater, ImmerUpdateEvent } from '@xstate/immer';

interface FormContext {
  name: string;
  age: number | undefined;
}

type NameUpdateEvent = ImmerUpdateEvent<'UPDATE_NAME', string>;
type AgeUpdateEvent = ImmerUpdateEvent<'UPDATE_AGE', number>;

const nameUpdater = createUpdater<FormContext, NameUpdateEvent>(
  'UPDATE_NAME',
  (ctx, { input }) => {
    ctx.name = input;
  }
);

const ageUpdater = createUpdater<FormContext, AgeUpdateEvent>(
  'UPDATE_AGE',
  (ctx, { input }) => {
    ctx.age = input;
  }
);

----------------------------------------

TITLE: Using State Matching with Switch/Match in SolidJS
DESCRIPTION: Demonstrates how to handle complex state matching using SolidJS Switch and Match components with XState

LANGUAGE: jsx
CODE:
const Loader = () => {
  const [snapshot, send] = useActor(/* ... */);

  return (
    <div>
      <Switch fallback={null}>
        <Match when={snapshot.matches('idle')}>
          <Loader.Idle />
        </Match>
        <Match when={snapshot.matches({ loading: 'user' })}>
          <Loader.LoadingUser />
        </Match>
        <Match when={snapshot.matches({ loading: 'friends' })}>
          <Loader.LoadingFriends />
        </Match>
      </Switch>
    </div>
  );
};

----------------------------------------

TITLE: Installing XState with SolidJS Dependencies
DESCRIPTION: Installation command for adding XState and its SolidJS integration package

LANGUAGE: bash
CODE:
npm i xstate @xstate/solid

----------------------------------------

TITLE: Creating XState Toggle Machine
DESCRIPTION: Definition of a basic XState machine with toggle functionality between active and inactive states.

LANGUAGE: javascript
CODE:
import { createMachine } from 'xstate';

// This machine is completely decoupled from Svelte
export const toggleMachine = createMachine({
  id: 'toggle',
  initial: 'inactive',
  states: {
    inactive: {
      on: { TOGGLE: 'active' }
    },
    active: {
      on: { TOGGLE: 'inactive' }
    }
  }
});

----------------------------------------

TITLE: Rendering Updates Index Component in Markdown
DESCRIPTION: This snippet includes a component that renders a reverse chronological list of update posts from the /updates directory.

LANGUAGE: markdown
CODE:
<!-- Show a reverse chronological list of posts from inside /updates: -->
<UpdatesIndex />

----------------------------------------

TITLE: Using useSelector in Vue Component
DESCRIPTION: Example of using the useSelector composition function to select a specific value from a service's state in a Vue component.

LANGUAGE: javascript
CODE:
import { useSelector } from '@xstate/vue';

const props = defineProps(['service']);

const selectCount = (state) => state.context.count;

const count = useSelector(props.service, selectCount);

----------------------------------------

TITLE: Syncing External Data with XState using SolidJS createEffect
DESCRIPTION: Demonstrates how to synchronize data from external sources (like API calls) with an XState machine using SolidJS's createEffect and createResource hooks.

LANGUAGE: javascript
CODE:
import { createResource, createEffect } from 'solid-js';
import { useMachine } from '@xstate/solid';

const Component = () => {
  const [result, { mutate, refetch }] = createResource(() =>
    fetch('/api/user').then((r) => r.json())
  );
  const [state, send] = useMachine(machine);

  createEffect(() => {
    send({
      type: 'DATA_CHANGED',
      data: result(),
      error: result.error
    });
  });

  return null;
};

----------------------------------------

TITLE: Store Transition Method Usage
DESCRIPTION: Example of using the store.transition() method to compute next state and effects for a given state and event as a tuple.

LANGUAGE: typescript
CODE:
const [nextState, effects] = store.transition(store.getSnapshot(), {
  type: 'increment',
  by: 1
});

----------------------------------------

TITLE: Importing @rollup/plugin-replace in rollup.config.js
DESCRIPTION: Import statement for the @rollup/plugin-replace package in the rollup configuration file.

LANGUAGE: javascript
CODE:
import replace from '@rollup/plugin-replace';

----------------------------------------

TITLE: Configuring Updates Index in Markdown Frontmatter
DESCRIPTION: This snippet sets a frontmatter configuration to enable the updates index for the page.

LANGUAGE: markdown
CODE:
---
updatesIndex: true
---

----------------------------------------

TITLE: Configuring Machines in Vue Component
DESCRIPTION: Example of configuring a machine with custom actions and services in a Vue component using useMachine.

LANGUAGE: vue
CODE:
<script setup>
import { assign, createMachine } from 'xstate';
import { useMachine } from '@xstate/vue';

const fetchMachine = createMachine({
  id: 'fetch',
  initial: 'idle',
  context: {
    data: undefined,
    error: undefined
  },
  states: {
    idle: {
      on: { FETCH: 'loading' }
    },
    loading: {
      invoke: {
        src: 'fetchData',
        onDone: {
          target: 'success',
          actions: assign({
            data: (_context, event) => event.data
          })
        },
        onError: {
          target: 'failure',
          actions: assign({
            error: (_context, event) => event.data
          })
        }
      }
    },
    success: {
      entry: 'notifySuccess',
      type: 'final'
    },
    failure: {
      on: {
        RETRY: 'loading'
      }
    }
  }
});

const props = defineProps({
  onResolve: {
    type: Function,
    default: () => {}
  }
});

const { state, send } = useMachine(fetchMachine, {
  actions: {
    notifySuccess: (ctx) => props.onResolve(ctx.data)
  },
  services: {
    fetchData: (_context, event) =>
      fetch(`some/api/${event.query}`).then((res) => res.json())
  }
});
</script>

<template>
  <template v-if="state.value === 'idle'">
    <button @click="send({ type: 'FETCH', query: 'something' })">
      Search for something
    </button>
  </template>

  <template v-else-if="state.value === 'loading'">
    <div>Searching...</div>
  </template>

  <template v-else-if="state.value === 'success'">
    <div>Success! {{ state.context.data }}</div>
  </template>

  <template v-else-if="state.value === 'failure'">
    <p>{{ state.context.error.message }}</p>
    <button @click="send('RETRY')">Retry</button>
  </template>
</template>

----------------------------------------

TITLE: Implementing Stencil Component with XState
DESCRIPTION: Creates a Stencil web component that uses the toggle machine. Implements lifecycle methods for machine interpretation and state management, with a button UI that reflects the current state.

LANGUAGE: typescript
CODE:
import { Component, h, State } from "@stencil/core";
import { interpret } from "xstate";
import { toggleMachine } from "../helpers/toggle-machine";

@Component({
  tag: "my-toggle",
  styleUrl: "toggle.css",
  shadow: true
})
export class Toggle {
  private _service = interpret(toggleMachine);

  @State() state = this._service.getSnapshot();

  componentWillLoad() {
    this._service.subscribe(state => {
      this.state = state;
    });

    this._service.start();
  }

  disconnectedCallback() {
    this._service.stop();
  }

  render() {
    const { send } = this._service;

    return (
      <button onClick={() => send("toggle")}>
        {this.state.value === "inactive" ? "Off" : "On"}
      </button>
    );
  }
}

----------------------------------------

TITLE: Installing XState Store with Package Managers
DESCRIPTION: Commands for installing @xstate/store using different package managers

LANGUAGE: bash
CODE:
# yarn add @xstate/store
# pnpm add @xstate/store
npm install @xstate/store

----------------------------------------

TITLE: Configuring @rollup/plugin-replace in rollup.config.js
DESCRIPTION: Configuration for the @rollup/plugin-replace plugin in the rollup configuration file, setting the NODE_ENV environment variable.

LANGUAGE: javascript
CODE:
replace({
  'process.env.NODE_ENV': process.env.NODE_ENV
});

----------------------------------------

TITLE: Basic Toggle Machine Implementation with React
DESCRIPTION: Example of creating a simple toggle machine and using it in a React component with the useMachine hook.

LANGUAGE: javascript
CODE:
import { useMachine } from '@xstate/react';
import { createMachine } from 'xstate';

const toggleMachine = createMachine({
  id: 'toggle',
  initial: 'inactive',
  states: {
    inactive: {
      on: { TOGGLE: 'active' }
    },
    active: {
      on: { TOGGLE: 'inactive' }
    }
  }
});

export const Toggler = () => {
  const [state, send] = useMachine(toggleMachine);

  return (
    <button onClick={() => send('TOGGLE')}>
      {state.value === 'inactive'
        ? 'Click to activate'
        : 'Active! Click to deactivate'}
    </button>
  );
};

----------------------------------------

TITLE: HTML Implementation of Toggle Component
DESCRIPTION: Shows how to include and use the toggle component in an HTML page using both modern and legacy module loading approaches.

LANGUAGE: html
CODE:
<html>
  <head>
    <script type="module" src="/build/my-toggle.esm.js"></script>
    <script nomodule src="/build/my-toggle.js"></script>
  </head>
  <body>
    <my-toggle></my-toggle>
  </body>
</html>

----------------------------------------

TITLE: Loading XState Svelte via CDN
DESCRIPTION: HTML script tag to include XState Svelte directly from a CDN, making it available through the global XStateSvelte variable.

LANGUAGE: html
CODE:
<script src="https://unpkg.com/@xstate/svelte/dist/xstate-svelte.min.js"></script>

----------------------------------------

TITLE: Defining XState Machine for Toggle Functionality
DESCRIPTION: Creation of an XState machine for toggle functionality, defining states and transitions. This machine is decoupled from Svelte and can be reused.

LANGUAGE: javascript
CODE:
import { createMachine } from 'xstate';

// This machine is completely decoupled from Svelte
export const toggleMachine = createMachine({
  id: 'toggle',
  initial: 'inactive',
  states: {
    inactive: {
      on: { TOGGLE: 'active' }
    },
    active: {
      on: { TOGGLE: 'inactive' }
    }
  }
});

----------------------------------------

TITLE: Installing XState React Dependencies
DESCRIPTION: Instructions for installing XState and its React integration package via npm or CDN.

LANGUAGE: bash
CODE:
npm i xstate @xstate/react

LANGUAGE: html
CODE:
<script src="https://unpkg.com/@xstate/react/dist/xstate-react.umd.min.js"></script>

----------------------------------------

TITLE: Implementing XState in Svelte Component (Standard Usage)
DESCRIPTION: Example of using XState in a Svelte component with standard usage. It interprets the machine, subscribes to state changes, and renders a toggle button based on the current state.

LANGUAGE: html
CODE:
<script>
    import {interpret} from 'xstate';
    import {toggleMachine} from './machine';

    let current;

    const toggleService = interpret(toggleMachine)
        .onTransition((state) => {
            current = state;
        }).start()
</script>

<button on:click={() => toggleService.send({type:'TOGGLE'})}>
    {current.matches('inactive') ? 'Off' : 'On'}
</button>

----------------------------------------

TITLE: Implementing Toggle Component with Stencil and XState
DESCRIPTION: Creates a Stencil component that uses the toggleMachine. It interprets the machine, subscribes to state changes, and renders a button that toggles between 'On' and 'Off' states.

LANGUAGE: typescript
CODE:
import { Component, h, State } from "@stencil/core";
import { interpret } from "xstate";
import { toggleMachine } from "../helpers/toggle-machine";

@Component({
  tag: "my-toggle",
  styleUrl: "toggle.css",
  shadow: true
})
export class Toggle {
  private _service = interpret(toggleMachine);

  @State() state = this._service.getSnapshot();

  componentWillLoad() {
    this._service.subscribe(state => {
      this.state = state;
    });

    this._service.start();
  }

  disconnectedCallback() {
    this._service.stop();
  }

  render() {
    const { send } = this._service;

    return (
      <button onClick={() => send("toggle")}>
        {this.state.value === "inactive" ? "Off" : "On"}
      </button>
    );
  }
}

----------------------------------------

TITLE: Installing XState and @xstate/vue via npm
DESCRIPTION: Command to install the required packages for using XState with Vue.

LANGUAGE: bash
CODE:
npm i xstate @xstate/vue

----------------------------------------

TITLE: Including @xstate/vue via CDN
DESCRIPTION: HTML script tag to include the @xstate/vue library from a CDN. This makes the XStateVue global variable available.

LANGUAGE: html
CODE:
<script src="https://unpkg.com/@xstate/vue/dist/xstate-vue.min.js"></script>

----------------------------------------

TITLE: Implementing XState in Svelte Component (Standard Usage)
DESCRIPTION: Example of using XState in a Svelte component with standard usage. It interprets the machine, subscribes to state changes, and renders a toggle button based on the current state.

LANGUAGE: html
CODE:
<script>
    import {interpret} from 'xstate';
    import {toggleMachine} from './machine';

    let current;

    const toggleService = interpret(toggleMachine)
        .onTransition((state) => {
            current = state;
        }).start()
</script>

<button on:click={() => toggleService.send({type:'TOGGLE'})}>
    {current.matches('inactive') ? 'Off' : 'On'}
</button>

----------------------------------------

TITLE: Installing XState DevTools Dependencies
DESCRIPTION: Commands for installing dependencies and starting the development server for XState developer tools panel

LANGUAGE: bash
CODE:
npm install

LANGUAGE: bash
CODE:
npm start

----------------------------------------

TITLE: TypeScript Interface Definitions for Flight Booking Context and Events
DESCRIPTION: Type definitions for the flight booking state machine context and events, defining the shape of the data and possible events that can occur.

LANGUAGE: typescript
CODE:
interface FlightContext {
  startDate?: string;
  returnDate?: string;
  trip: 'oneWay' | 'roundTrip';
}

type FlightEvent =
  | {
      type: 'SET_TRIP';
      value: 'oneWay' | 'roundTrip';
    }
  | {
      type: 'startDate.UPDATE';
      value: string;
    }
  | {
      type: 'returnDate.UPDATE';
      value: string;
    }
  | { type: 'SUBMIT' };

----------------------------------------

TITLE: Using XState with Vue Composition API
DESCRIPTION: Vue component demonstrating the use of XState with Vue Composition API. It imports useMachine from @xstate/vue, creates a toggle machine, and uses it in the component.

LANGUAGE: vue
CODE:
<script setup>
import { useMachine } from '@xstate/vue';
import { createMachine } from 'xstate';

const toggleMachine = createMachine({
  id: 'toggle',
  initial: 'inactive',
  states: {
    inactive: {
      on: { TOGGLE: 'active' }
    },
    active: {
      on: { TOGGLE: 'inactive' }
    }
  }
});

const { snapshot, send } = useMachine(toggleMachine);
</script>

<template>
  <button @click="send({ type: 'TOGGLE' })">
    {{
      snapshot.value === 'inactive'
        ? 'Click to activate'
        : 'Active! Click to deactivate'
    }}
  </button>
</template>

----------------------------------------

TITLE: Transitioning to Initial Nested State in XState
DESCRIPTION: This code snippet demonstrates how to transition to a compound state with an initial substate in XState. It shows that when transitioning to the 'red' state, the machine automatically enters the initial 'walk' substate of the pedestrian states.

LANGUAGE: javascript
CODE:
console.log(lightMachine.transition('yellow', { type: 'TIMER' }).value);
// => {
//   red: 'walk'
// }

----------------------------------------

TITLE: Consuming XState Context with useActor
DESCRIPTION: Demonstrates how to consume XState context in child components using useActor hook.

LANGUAGE: javascript
CODE:
import React, { useContext } from 'react';
import { GlobalStateContext } from './globalState';
import { useActor } from '@xstate/react';

export const SomeComponent = (props) => {
  const globalServices = useContext(GlobalStateContext);
  const [state] = useActor(globalServices.authService);

  return state.matches('loggedIn') ? 'Logged In' : 'Logged Out';
};

----------------------------------------

TITLE: Defining Timer Event Types in TypeScript
DESCRIPTION: This snippet defines the TypeScript types for the timer's events, including TICK, DURATION.UPDATE, and RESET events.

LANGUAGE: typescript
CODE:
type TimerEvent =
  | {
      // The TICK event sent by the spawned interval service
      type: 'TICK';
    }
  | {
      // User intent to update the duration
      type: 'DURATION.UPDATE';
      value: number;
    }
  | {
      // User intent to reset the elapsed time to 0
      type: 'RESET';
    };

----------------------------------------

TITLE: Using useSelector in Vue Component
DESCRIPTION: Example of using the useSelector composition function to select and subscribe to specific parts of an actor's state in a Vue component.

LANGUAGE: javascript
CODE:
import { useSelector } from '@xstate/vue';

const props = defineProps(['service']);

const selectCount = (state) => state.context.count;

const count = useSelector(props.service, selectCount);

----------------------------------------

TITLE: Default State Node ID Example in XState
DESCRIPTION: Demonstrates how state nodes are automatically assigned IDs based on their path and how to target them using these default IDs.

LANGUAGE: javascript
CODE:
const lightMachine = createMachine({
  id: 'light',
  initial: 'green',
  states: {
    green: {
      // default ID: 'light.green'
      on: {
        // You can target state nodes by their default ID.
        // This is the same as TIMER: 'yellow'
        TIMER: { target: '#light.yellow' }
      }
    },
    yellow: {
      on: {
        TIMER: { target: 'red' }
      }
    },
    red: {
      on: {
        TIMER: { target: 'green' }
      }
    }
  }
});

----------------------------------------

TITLE: Adding Context and Select Event Handler
DESCRIPTION: Extends the Reddit machine with context for storing the selected subreddit and adds a SELECT event handler.

LANGUAGE: javascript
CODE:
const redditMachine = createMachine({
  id: 'reddit',
  initial: 'idle',
  context: {
    subreddit: null
  },
  states: {
    /* ... */
  },
  on: {
    SELECT: {
      target: '.selected',
      actions: assign({
        subreddit: (context, event) => event.name
      })
    }
  }
});

----------------------------------------

TITLE: Guards Implementation in XState and SCXML
DESCRIPTION: Demonstrates how guards are implemented in both XState and SCXML, including conditional expressions and state checking.

LANGUAGE: javascript
CODE:
{
  on: {
    e: {
      target: 'foo',
      cond: context => context.x === 1
    }
  }
}

LANGUAGE: xml
CODE:
<transition event="e" cond="x == 1" target="foo" />

----------------------------------------

TITLE: Accessing SCXML Events in XState Actions and Guards
DESCRIPTION: Demonstrates how to access the SCXML event form through the _event property in action and guard meta objects.

LANGUAGE: javascript
CODE:
{
  actions: {
    someAction: (context, event, { _event }) => {
      console.log(_event); // SCXML event
    };
  },
  guards: {
    someGuard: (context, event, { _event }) => {
      console.log(_event); // SCXML event
    }
  }
}

----------------------------------------

TITLE: Using useSelector in Svelte Component
DESCRIPTION: Example of using useSelector to efficiently select and react to specific state changes in an XState machine.

LANGUAGE: svelte
CODE:
<script lang="ts">
  import { interpret } from 'xstate';
  import { createModel } from 'xstate/lib/model';
  import { useSelector } from '../src';

  const model = createModel(
    {
      count: 0,
      anotherCount: 0
    },
    {
      events: {
        INCREMENT: () => ({}),
        INCREMENT_ANOTHER: () => ({})
      }
    }
  );

  const machine = model.createMachine({
    initial: 'idle',
    context: model.initialContext,
    states: {
      idle: {
        on: {
          INCREMENT: {
            actions: model.assign({ count: ({ count }) => count + 1 })
          },
          INCREMENT_ANOTHER: {
            actions: model.assign({
              anotherCount: ({ anotherCount }) => anotherCount + 1
            })
          }
        }
      }
    }
  });

  const service = interpret(machine).start();

  const count = useSelector(service, (state) => state.context.count);

  let withSelector = 0;
  $: $count && withSelector++;
  let withoutSelector = 0;
  $: $service.context.count && withoutSelector++;
</script>

<button data-testid="count" on:click={() => service.send({type:'INCREMENT'})}
  >Increment count</button
>
<button data-testid="another" on:click={() => service.send({type:'INCREMENT_ANOTHER'})}
  >Increment another count</button
>

<div data-testid="withSelector">{withSelector}</div>
<div data-testid="withoutSelector">{withoutSelector}</div>

----------------------------------------

TITLE: Event Modeling with TypeScript
DESCRIPTION: Shows how to model events with payload types and use them in a state machine with type-safe assignments

LANGUAGE: typescript
CODE:
import { createModel } from 'xstate/lib/model';

const userModel = createModel(
  // Initial context
  {
    name: 'David',
    age: 30
  },
  {
    // Event creators
    events: {
      updateName: (value) => ({ value }),
      updateAge: (value) => ({ value }),
      anotherEvent: () => ({}) // no payload
    }
  }
);

const machine = userModel.createMachine(
  {
    context: userModel.initialContext,
    initial: 'active',
    states: {
      active: {
        on: {
          updateName: {
            actions: userModel.assign({
              name: (_, event) => event.value
            })
          },
          updateAge: {
            actions: 'assignAge'
          }
        }
      }
    }
  },
  {
    actions: {
      assignAge: userModel.assign({
        age: (_, event) => event.value // inferred
      })
    }
  }
);

const nextState = machine.transition(
  undefined,
  userModel.events.updateName('David')
);

----------------------------------------

TITLE: Implementing Subreddit Data Fetching
DESCRIPTION: Adds async data fetching functionality to load subreddit posts using Promise invocation.

LANGUAGE: javascript
CODE:
function invokeFetchSubreddit(context) {
  const { subreddit } = context;

  return fetch(`https://www.reddit.com/r/${subreddit}.json`)
    .then((response) => response.json())
    .then((json) => json.data.children.map((child) => child.data));
}

const redditMachine = createMachine({
  /* ... */
  states: {
    idle: {},
    selected: {
      invoke: {
        id: 'fetch-subreddit',
        src: invokeFetchSubreddit
      }
    }
  }
});

----------------------------------------

TITLE: Basic State Node Configuration in XState
DESCRIPTION: Example of a basic state node configuration showing the idle state with a transition to pending on FETCH event.

LANGUAGE: javascript
CODE:
{
  states: {
    // state node
    idle: {
      on: {
        FETCH: {
          target: 'pending';
        }
      }
    }
  }
}

----------------------------------------

TITLE: Installing XState via NPM
DESCRIPTION: Command to install XState using NPM package manager.

LANGUAGE: bash
CODE:
npm install xstate --save

----------------------------------------

TITLE: Matching States in Svelte Component
DESCRIPTION: Example of using state.matches() to handle hierarchical and parallel machine states in a Svelte component.

LANGUAGE: svelte
CODE:
{#if $state.matches('idle')}
  //
{:else if $state.matches({ loading: 'user' })}
  //
{:else if $state.matches({ loading: 'friends' })}
  //
{/if}

----------------------------------------

TITLE: TypeScript Type Inference in Models
DESCRIPTION: Demonstrates type inference for context and events in XState models with explicit typing

LANGUAGE: typescript
CODE:
import { createModel } from 'xstate/lib/model';

const userModel = createModel(
  {
    name: 'David', // inferred as `string`
    age: 30, // inferred as `number`
    friends: [] as string[] // explicit type
  },
  {
    events: {
      updateName: (value: string) => ({ value }),
      updateAge: (value: number) => ({ value }),
      anotherEvent: () => ({}) // no payload
    }
  }
);

----------------------------------------

TITLE: React UI Implementation
DESCRIPTION: React component implementation using the Reddit state machine with @xstate/react hooks.

LANGUAGE: jsx
CODE:
import React from 'react';
import { useMachine } from '@xstate/react';
import { redditMachine } from '../path/to/redditMachine';

const subreddits = ['frontend', 'reactjs', 'vuejs'];

const App = () => {
  const [current, send] = useMachine(redditMachine);
  const { subreddit, posts } = current.context;

  return (
    <main>
      <header>
        <select
          onChange={(e) => {
            send('SELECT', { name: e.target.value });
          }}
        >
          {subreddits.map((subreddit) => {
            return <option key={subreddit}>{subreddit}</option>;
          })}
        </select>
      </header>
      <section>
        <h1>{current.matches('idle') ? 'Select a subreddit' : subreddit}</h1>
        {current.matches({ selected: 'loading' }) && <div>Loading...</div>}
        {current.matches({ selected: 'loaded' }) && (
          <ul>
            {posts.map((post) => (
              <li key={post.title}>{post.title}</li>
            ))}
          </ul>
        )}
      </section>
    </main>
  );
};

----------------------------------------

TITLE: Creating a Test Model with @xstate/test
DESCRIPTION: Creates a test model using the toggle machine and defines event execution.

LANGUAGE: javascript
CODE:
import { createMachine } from 'xstate';
import { createModel } from '@xstate/test';

const toggleMachine = createMachine(/* ... */);

const toggleModel = createModel(toggleMachine).withEvents({
  TOGGLE: {
    exec: async (page) => {
      await page.click('input');
    }
  }
});

----------------------------------------

TITLE: Installing XState and @xstate/graph
DESCRIPTION: Command to install the required packages using npm.

LANGUAGE: bash
CODE:
npm install xstate @xstate/graph

----------------------------------------

TITLE: Implementing XState Toggle Machine in Svelte
DESCRIPTION: Complete example of creating and using an XState machine in a Svelte component to implement a toggle button. Shows machine definition, state management with useMachine hook, and UI integration.

LANGUAGE: svelte
CODE:
<script>
  import { useMachine } from '@xstate/svelte';
  import { createMachine } from 'xstate';

  const toggleMachine = createMachine({
    id: 'toggle',
    initial: 'inactive',
    states: {
      inactive: {
        on: { TOGGLE: 'active' }
      },
      active: {
        on: { TOGGLE: 'inactive' }
      }
    }
  });

  const { state, send } = useMachine(toggleMachine);
</script>

<button on:click={() => send('TOGGLE')}>
  {$state.value === 'inactive'
    ? 'Click to activate'
    : 'Active! Click to deactivate'}
</button>

----------------------------------------

TITLE: Type Extraction from Models
DESCRIPTION: Shows how to extract context and event types from an XState model using utility types

LANGUAGE: typescript
CODE:
import { ContextFrom, EventFrom } from 'xstate';
import { createModel } from 'xstate/lib/model';

const someModel = createModel(
  {
    /* ... */
  },
  {
    events: {
      /* ... */
    }
  }
);

type SomeContext = ContextFrom<typeof someModel>;
type SomeEvent = EventFrom<typeof someModel>;

----------------------------------------

TITLE: Initializing Basic Reddit State Machine in XState
DESCRIPTION: Creates the initial state machine structure with idle and selected states for the Reddit client.

LANGUAGE: javascript
CODE:
import { createMachine, assign } from 'xstate';

const redditMachine = createMachine({
  id: 'reddit',
  initial: 'idle',
  states: {
    idle: {},
    selected: {}
  }
});

----------------------------------------

TITLE: Configuring XState Machines in Svelte
DESCRIPTION: Shows how to configure an XState machine with custom actions and services when using it in a Svelte component with useMachine.

LANGUAGE: svelte
CODE:
<script>
  import { useMachine } from '@xstate/svelte';
  import { createMachine, assign } from 'xstate';

  const fetchMachine = createMachine({
    id: 'fetch',
    initial: 'idle',
    context: {
      data: undefined,
      error: undefined
    },
    states: {
      idle: {
        on: { FETCH: 'loading' }
      },
      loading: {
        invoke: {
          src: 'fetchData',
          onDone: {
            target: 'success',
            actions: assign({
              data: (_, event) => event.data
            })
          },
          onError: {
            target: 'failure',
            actions: assign({
              error: (_, event) => event.data
            })
          }
        }
      },
      success: {
        entry: 'notifySuccess',
        type: 'final'
      },
      failure: {
        on: {
          RETRY: 'loading'
        }
      }
    }
  });

  const onResolve = (data) => {
    // Do something with data
  };

  const { state, send } = useMachine(fetchMachine, {
    actions: {
      notifySuccess: (context) => onResolve(context.data)
    },
    services: {
      fetchData: (_, event) =>
        fetch(`some/api/${event.query}`).then((res) => res.json())
    }
  });
</script>

{#if $state.value === 'idle'}
  <button on:click={() => send({ type: 'FETCH', query: 'something' })}>
    Search for something
  </button>
{:else if $state.value === 'loading'}
  <div>Searching...</div>
{:else if $state.value === 'success'}
  <div>Success! Data: {$state.context.data}</div>
{:else if $state.value === 'failure'}
  <p>{$state.context.error.message}</p>
  <button on:click={() => send('RETRY')}>Retry</button>
{/if}

----------------------------------------

TITLE: Configuring Machine for Inspection
DESCRIPTION: Example of setting up a state machine for inspection by enabling devTools option.

LANGUAGE: javascript
CODE:
import { interpret } from 'xstate';
import { inspect } from '@xstate/inspect';
// ...

const service = interpret(someMachine, { devTools: true });

----------------------------------------

TITLE: Installing XState and @xstate/svelte via npm
DESCRIPTION: Command to install the required packages xstate and @xstate/svelte using npm.

LANGUAGE: bash
CODE:
npm i xstate @xstate/svelte

----------------------------------------

TITLE: Basic XState Immer Usage Example
DESCRIPTION: Demonstrates basic usage of XState with Immer, including machine creation, state updates, and event handling.

LANGUAGE: javascript
CODE:
import { createMachine, interpret } from 'xstate';
import { assign, createUpdater } from '@xstate/immer';

const levelUpdater = createUpdater('UPDATE_LEVEL', (ctx, { input }) => {
  ctx.level = input;
});

const toggleMachine = createMachine({
  id: 'toggle',
  context: {
    count: 0,
    level: 0
  },
  initial: 'inactive',
  states: {
    inactive: {
      on: {
        TOGGLE: {
          target: 'active',
          actions: assign((ctx) => ctx.count++)
        }
      }
    },
    active: {
      on: {
        TOGGLE: {
          target: 'inactive'
        },
        [levelUpdater.type]: {
          actions: levelUpdater.action
        }
      }
    }
  }
});

----------------------------------------

TITLE: Adding Context and SELECT Event Handler to Reddit Machine
DESCRIPTION: Implements context management and event handling for subreddit selection in the state machine.

LANGUAGE: javascript
CODE:
const redditMachine = createMachine({
  id: 'reddit',
  initial: 'idle',
  context: {
    subreddit: null // none selected
  },
  states: {
    /* ... */
  },
  on: {
    SELECT: {
      target: '.selected',
      actions: assign({
        subreddit: (context, event) => event.name
      })
    }
  }
});

----------------------------------------

TITLE: Basic Usage of useMachine in Svelte
DESCRIPTION: Demonstrates how to use the useMachine function from @xstate/svelte to create and interact with an XState machine in a Svelte component.

LANGUAGE: svelte
CODE:
<script>
  import { useMachine } from '@xstate/svelte';
  import { createMachine } from 'xstate';

  const toggleMachine = createMachine({
    id: 'toggle',
    initial: 'inactive',
    states: {
      inactive: {
        on: { TOGGLE: 'active' }
      },
      active: {
        on: { TOGGLE: 'inactive' }
      }
    }
  });

  const { state, send } = useMachine(toggleMachine);
</script>

<button on:click={() => send('TOGGLE')}>
  {$state.value === 'inactive'
    ? 'Click to activate'
    : 'Active! Click to deactivate'}
</button>

----------------------------------------

TITLE: Implementing Custom Inspector Receiver
DESCRIPTION: Example of creating and subscribing to a custom inspector receiver for handling inspection events.

LANGUAGE: javascript
CODE:
import { createWindowReceiver } from '@xstate/inspect';

const windowReceiver = createWindowReceiver(/* options? */);

windowReceiver.subscribe((event) => {
  // here, you will receive "service.*" events
  console.log(event);
});

----------------------------------------

TITLE: Using useSelector with XState and Svelte
DESCRIPTION: Demonstrates the usage of useSelector function to efficiently select and subscribe to specific parts of the machine state in a Svelte component.

LANGUAGE: svelte
CODE:
<script lang="ts">
  import { interpret } from 'xstate';
  import { createModel } from 'xstate/lib/model';
  import { useSelector } from '../src';

  const model = createModel(
    {
      count: 0,
      anotherCount: 0
    },
    {
      events: {
        INCREMENT: () => ({}),
        INCREMENT_ANOTHER: () => ({})
      }
    }
  );

  const machine = model.createMachine({
    initial: 'idle',
    context: model.initialContext,
    states: {
      idle: {
        on: {
          INCREMENT: {
            actions: model.assign({ count: ({ count }) => count + 1 })
          },
          INCREMENT_ANOTHER: {
            actions: model.assign({
              anotherCount: ({ anotherCount }) => anotherCount + 1
            })
          }
        }
      }
    }
  });

  const service = interpret(machine).start();

  const count = useSelector(service, (state) => state.context.count);

  let withSelector = 0;
  $: $count && withSelector++;
  let withoutSelector = 0;
  $: $service.context.count && withoutSelector++;
</script>

<button data-testid="count" on:click={() => service.send({ type: 'INCREMENT' })}
  >Increment count</button
>
<button data-testid="another" on:click={() => service.send({ type: 'INCREMENT_ANOTHER' })}
  >Increment another count</button
>

<div data-testid="withSelector">{withSelector}</div>
<div data-testid="withoutSelector">{withoutSelector}</div>

----------------------------------------

TITLE: Actor Context Creation
DESCRIPTION: Example of creating and using a React Context for XState actors using createActorContext.

LANGUAGE: javascript
CODE:
import { createActorContext } from '@xstate/react';
import { someMachine } from '../path/to/someMachine';
const SomeMachineContext = createActorContext(someMachine);
function App() {
  return (
    <SomeMachineContext.Provider>
      <SomeComponent />
    </SomeMachineContext.Provider>
  );
}

----------------------------------------

TITLE: Initializing Basic Reddit XState Machine
DESCRIPTION: Creates the initial state machine structure with idle and selected states for the Reddit viewer application.

LANGUAGE: javascript
CODE:
import { createMachine, assign } from 'xstate';

const redditMachine = createMachine({
  id: 'reddit',
  initial: 'idle',
  states: {
    idle: {},
    selected: {}
  }
});

----------------------------------------

TITLE: Implementing Actions in XState and SCXML
DESCRIPTION: Shows how XState's entry, exit, and transition actions correspond to SCXML's <onentry>, <onexit>, and <script> elements. These are used to execute side effects when entering, exiting, or transitioning between states.

LANGUAGE: javascript
CODE:
{
  start: {
    entry: 'showStartScreen',
    exit: 'logScreenChange',
    on: {
      STOP: {
        target: 'stop',
        actions: ['logStop', 'stopEverything']
      }
    }
  }
}

LANGUAGE: xml
CODE:
<state id="start">
  <onentry>
    <script>showStartScreen();</script>
  </onentry>
  <onexit>
    <script>logScreenChange();</script>
  </onexit>
  <transition event="STOP" target="stop">
    <script>logStop();</script>
    <script>stopEverything();</script>
  </transition>
</state>

----------------------------------------

TITLE: NextJS Client-Side Inspector Implementation
DESCRIPTION: Example of implementing XState inspector in a NextJS application, ensuring it only runs on the client side.

LANGUAGE: javascript
CODE:
if (typeof window !== 'undefined') {
  inspect({
    /* options */
  });
}

----------------------------------------

TITLE: Installing XState Immer Dependencies
DESCRIPTION: Commands for installing the required packages including immer, xstate, and @xstate/immer.

LANGUAGE: bash
CODE:
npm install immer xstate @xstate/immer

----------------------------------------

TITLE: Installing @rollup/plugin-replace for XState-Svelte Integration
DESCRIPTION: Command to install the @rollup/plugin-replace package as a dev dependency for XState-Svelte integration.

LANGUAGE: javascript
CODE:
npm install @rollup/plugin-replace --save-dev

----------------------------------------

TITLE: Configuring Updates Index Page in Markdown
DESCRIPTION: Frontmatter configuration and component inclusion for displaying a chronological list of update posts. Uses YAML frontmatter to enable updates indexing and includes a custom UpdatesIndex component.

LANGUAGE: markdown
CODE:
---
updatesIndex: true
---

# Updates

<!-- Show a reverse chronological list of posts from inside /updates: -->
<UpdatesIndex />

----------------------------------------

TITLE: Accessing SCXML Event Object in XState Actions and Guards
DESCRIPTION: Demonstrates how to access the SCXML event object (_event) within XState actions and guards. This object contains additional metadata about the event not present in the standard XState event object.

LANGUAGE: javascript
CODE:
// ...
{
  actions: {
    someAction: (context, event, { _event }) => {
      console.log(_event); // SCXML event
    };
  },
  guards: {
    someGuard: (context, event, { _event }) => {
      console.log(_event); // SCXML event
    }
  }
}
// ..

----------------------------------------

TITLE: Installing xstate and @xstate/test with npm
DESCRIPTION: Command to install the required packages xstate and @xstate/test using npm.

LANGUAGE: bash
CODE:
npm install xstate @xstate/test

----------------------------------------

TITLE: Basic XState Immer Usage Example
DESCRIPTION: Demonstrates basic usage of XState with Immer, including machine creation, context updates, and state transitions.

LANGUAGE: javascript
CODE:
import { createMachine, interpret } from 'xstate';
import { assign, createUpdater } from '@xstate/immer';

const levelUpdater = createUpdater('UPDATE_LEVEL', (ctx, { input }) => {
  ctx.level = input;
});

const toggleMachine = createMachine({
  id: 'toggle',
  context: {
    count: 0,
    level: 0
  },
  initial: 'inactive',
  states: {
    inactive: {
      on: {
        TOGGLE: {
          target: 'active',
          actions: assign((ctx) => ctx.count++)
        }
      }
    },
    active: {
      on: {
        TOGGLE: {
          target: 'inactive'
        },
        [levelUpdater.type]: {
          actions: levelUpdater.action
        }
      }
    }
  }
});

----------------------------------------

TITLE: HTML Page for Stencil Toggle Component
DESCRIPTION: An HTML page that includes the necessary scripts to load the Stencil component and renders the 'my-toggle' custom element.

LANGUAGE: html
CODE:
<html>
  <head>
    <script type="module" src="/build/my-toggle.esm.js"></script>
    <script nomodule src="/build/my-toggle.js"></script>
  </head>
  <body>
    <my-toggle></my-toggle>
  </body>
</html>

----------------------------------------

TITLE: Displaying Frontmatter Title and Date in HTML
DESCRIPTION: This snippet demonstrates how to render the title from frontmatter and format the date using Vue.js template syntax within HTML tags.

LANGUAGE: HTML
CODE:
<h1>{{ $frontmatter.title }}</h1>
<p class="date">{{ new Date($frontmatter.date).toLocaleString('en-US',{ month:'long', day:'numeric', year:'numeric' }) }}</p>

----------------------------------------

TITLE: Creating a Machine from a Model in TypeScript
DESCRIPTION: Shows how to create a state machine from a model using the model.createMachine() method, which provides proper type inference for context and events.

LANGUAGE: typescript
CODE:
const machine = userModel.createMachine({
  context: userModel.initialContext,
  initial: 'active',
  states: {
    active: {
      on: {
        updateName: {
          actions: userModel.assign({
            name: (_, event) => event.value // Inferred
          })
        }
      }
    }
  }
});

----------------------------------------

TITLE: Implementing XState Machine with Immer Updates
DESCRIPTION: Example of creating an XState machine using @xstate/immer utilities. It demonstrates the usage of assign() for immutable context updates and createUpdater() for defining cohesive update actions.

LANGUAGE: javascript
CODE:
import { createMachine, interpret } from 'xstate';
import { assign, createUpdater } from '@xstate/immer';

const levelUpdater = createUpdater('UPDATE_LEVEL', (ctx, { input }) => {
  ctx.level = input;
});

const toggleMachine = createMachine({
  id: 'toggle',
  context: {
    count: 0,
    level: 0
  },
  initial: 'inactive',
  states: {
    inactive: {
      on: {
        TOGGLE: {
          target: 'active',
          // Immutably update context the same "mutable"
          // way as you would do with Immer!
          actions: assign((ctx) => ctx.count++)
        }
      }
    },
    active: {
      on: {
        TOGGLE: {
          target: 'inactive'
        },
        // Use the updater for more convenience:
        [levelUpdater.type]: {
          actions: levelUpdater.action
        }
      }
    }
  }
});

const toggleService = interpret(toggleMachine)
  .onTransition((state) => {
    console.log(state.context);
  })
  .start();

toggleService.send({ type: 'TOGGLE' });
// { count: 1, level: 0 }

toggleService.send(levelUpdater.update(9));
// { count: 1, level: 9 }

toggleService.send({ type: 'TOGGLE' });
// { count: 2, level: 9 }

toggleService.send(levelUpdater.update(-100));
// Notice how the level is not updated in 'inactive' state:
// { count: 2, level: 9 }

----------------------------------------

TITLE: Defining a Toggle State Machine with XState in JavaScript
DESCRIPTION: This snippet demonstrates how to create a simple toggle state machine using XState. The machine has two states (inactive and active) and a TOGGLE event to switch between them.

LANGUAGE: javascript
CODE:
import { createMachine } from 'xstate';

// This machine is completely decoupled from Vue
export const toggleMachine = createMachine({
  id: 'toggle',
  context: {
    /* some data */
  },
  initial: 'inactive',
  states: {
    inactive: {
      on: { TOGGLE: 'active' }
    },
    active: {
      on: { TOGGLE: 'inactive' }
    }
  }
});

----------------------------------------

TITLE: Markdown Frontmatter Configuration
DESCRIPTION: YAML frontmatter configuration for the blog post, including metadata like title, date, description, and update type.

LANGUAGE: markdown
CODE:
---
title: 'Added Roadmap'
date: 2022-03-24
description: 'We now have a Roadmap page in the "News and Useful Links" section. The Roadmap describes what Stately is working on for XState and Stately tools.'
reviewed: 2022-03-24
styleGuideVersion: 0
updateType: docs
---

----------------------------------------

TITLE: Implementing Conditional Transitions with Null Events in XState
DESCRIPTION: Shows how to use null events for immediate, conditional transitions based on the machine's context.

LANGUAGE: javascript
CODE:
const isAdult = ({ age }) => age >= 18;
const isMinor = ({ age }) => age < 18;

const ageMachine = createMachine({
  id: 'age',
  context: { age: undefined }, // age 不知道
  initial: 'unknown',
  states: {
    unknown: {
      on: {
        // 当满足 cond 条件时，立即 转换。 否则，不会发生 转换
        '': [
          { target: 'adult', cond: isAdult },
          { target: 'child', cond: isMinor }
        ]
      }
    },
    adult: { type: 'final' },
    child: { type: 'final' }
  }
});

console.log(ageMachine.initialState.value);
// => 'unknown'

const personData = { age: 28 };

const personMachine = ageMachine.withContext(personData);

console.log(personMachine.initialState.value);
// => 'adult'

----------------------------------------

TITLE: Defining Timer Events Type in TypeScript
DESCRIPTION: TypeScript type definition for all possible timer events including tick events, duration updates, and reset actions.

LANGUAGE: typescript
CODE:
type TimerEvent =
  | {
      // The TICK event sent by the spawned interval service
      type: 'TICK';
    }
  | {
      // User intent to update the duration
      type: 'DURATION.UPDATE';
      value: number;
    }
  | {
      // User intent to reset the elapsed time to 0
      type: 'RESET';
    };

----------------------------------------

TITLE: Running XState Typegen in Watch Mode
DESCRIPTION: Command to run XState typegen in watch mode, which monitors for file changes and automatically runs the typegen script against modified files.

LANGUAGE: bash
CODE:
xstate typegen "src/**/*.ts?(x)" --watch

----------------------------------------

TITLE: Creating Counter State Machine with XState
DESCRIPTION: Creates a state machine for a counter implementation using XState. The machine has a single 'active' state and maintains a count in its context. It handles an INCREMENT event that increases the count by 1 using an assign action.

LANGUAGE: javascript
CODE:
import { createMachine, assign } from 'xstate';

export const counterMachine = createMachine({
  initial: 'active',
  context: { count: 0 },
  states: {
    active: {
      on: {
        INCREMENT: {
          actions: assign({ count: (ctx) => ctx.count + 1 })
        }
      }
    }
  }
});

----------------------------------------

TITLE: Vue Template Header Markup
DESCRIPTION: Vue template markup for displaying the post title and formatted date.

LANGUAGE: html
CODE:
<h1>{{ $frontmatter.title }}</h1>
<p class="date">{{ new Date($frontmatter.date).toLocaleString('en-US',{ month:'long', day:'numeric', year:'numeric' }) }}</p>

----------------------------------------

TITLE: Handling DOM Events in XState
DESCRIPTION: Demonstrates how to use native DOM events directly with XState by specifying the event type.

LANGUAGE: javascript
CODE:
import { createMachine, interpret } from 'xstate';

const mouseMachine = createMachine({
  on: {
    mousemove: {
      actions: [
        (context, event) => {
          const { offsetX, offsetY } = event;
          console.log({ offsetX, offsetY });
        }
      ]
    }
  }
});
const mouseService = interpret(mouseMachine).start();

window.addEventListener('mousemove', (event) => {
  // 事件可以直接发送到服务
  mouseService.send(event);
});

----------------------------------------

TITLE: Implementing Guards in XState and SCXML
DESCRIPTION: Illustrates how XState's cond and in properties correspond to SCXML's cond attribute and In() predicate. These are used to add conditional logic to state transitions.

LANGUAGE: javascript
CODE:
{
  on: {
    e: {
      target: 'foo',
      cond: context => context.x === 1
    }
  }
}

LANGUAGE: xml
CODE:
<transition event="e" cond="x == 1" target="foo" />

LANGUAGE: javascript
CODE:
{
  on: {
    e: {
      target: 'cooking',
      in: '#closed'
    }
  }
}

LANGUAGE: xml
CODE:
<transition cond="In('closed')" target="cooking"/>

----------------------------------------

TITLE: Create Workflow API Request
DESCRIPTION: cURL command for creating a new workflow instance via POST request.

LANGUAGE: bash
CODE:
curl -X POST http://localhost:4242/workflows

----------------------------------------

TITLE: Implementing Basic Toggle Machine with Beeping Activity
DESCRIPTION: Example of creating a state machine with a beeping activity that runs continuously while in the active state. Shows activity definition and cleanup handling.

LANGUAGE: javascript
CODE:
const toggleMachine = createMachine(
  {
    id: 'toggle',
    initial: 'inactive',
    states: {
      inactive: {
        on: {
          TOGGLE: { target: 'active' }
        }
      },
      active: {
        activities: ['beeping'],
        on: {
          TOGGLE: { target: 'inactive' }
        }
      }
    }
  },
  {
    activities: {
      beeping: () => {
        const interval = setInterval(() => console.log('BEEP!'), 1000);
        return () => clearInterval(interval);
      }
    }
  }
);

----------------------------------------

TITLE: Displaying Frontmatter Title and Date in Markdown
DESCRIPTION: This snippet demonstrates how to display the title from frontmatter and format the date using Vue.js template syntax within Markdown.

LANGUAGE: markdown
CODE:
<h1>{{ $frontmatter.title }}</h1>
<p class="date">{{ new Date($frontmatter.date).toLocaleString('en-US',{ month:'long', day:'numeric', year:'numeric' }) }}</p>

----------------------------------------

TITLE: Using useActor in Vue Component
DESCRIPTION: Example of using the useActor composition function in a Vue component with a spawned actor.

LANGUAGE: javascript
CODE:
import { useActor } from '@xstate/vue';

const props = defineProps(['someSpawnedActor']);

const { state, send } = useActor(props.someSpawnedActor);

----------------------------------------

TITLE: Defining Invocations in XState and SCXML
DESCRIPTION: Illustrates how XState's invoke property corresponds to SCXML's <invoke> element. This is used for invoking services or other state machines from within a state.

LANGUAGE: javascript
CODE:
// XState
{
  loading: {
    invoke: {
      src: 'someSource',
      id: 'someID',
      autoForward: true, // 目前仅适用于状态机！
      onDone: 'success',
      onError: 'failure'
    }
  }
}

LANGUAGE: xml
CODE:
<!-- SCXML -->
<state id="loading">
  <invoke id="someID" src="someSource" autoforward />
  <transition event="done.invoke.someID" target="success" />
  <transition event="error.platform" cond="_event.src === 'someID'" target="failure" />
</state>

----------------------------------------

TITLE: Workflow Creation Response Format
DESCRIPTION: Example JSON response showing the format of a successful workflow instance creation

LANGUAGE: json
CODE:
{
  "workflowId": "7ky252"
}

----------------------------------------

TITLE: Creating Custom Activity with Context
DESCRIPTION: Example of implementing a custom beeping activity that uses machine context for configuration.

LANGUAGE: javascript
CODE:
function createBeepingActivity(context, activity) {
  const interval = setInterval(() => {
    console.log('BEEP!');
  }, context.interval);

  return () => clearInterval(interval);
}

----------------------------------------

TITLE: Using Tags in State Nodes
DESCRIPTION: Adding tags to state node configurations and querying state by tags

LANGUAGE: typescript
CODE:
const machine = createMachine({
  initial: 'green',
  states: {
    green: {
      tags: 'go' // single tag
    },
    yellow: {
      tags: 'go'
    },
    red: {
      tags: ['stop', 'other'] // multiple tags
    }
  }
});

const canGo = state.hasTag('go');

----------------------------------------

TITLE: Installing XState Immer Dependencies
DESCRIPTION: Commands for installing the required packages including immer, xstate, and @xstate/immer.

LANGUAGE: bash
CODE:
npm install immer xstate @xstate/immer

----------------------------------------

TITLE: Running XState Typegen on TypeScript Files
DESCRIPTION: Command to run the XState typegen tool on TypeScript and TypeScript React files. This command scans targeted files, generates typegen files, and imports them into the original files.

LANGUAGE: bash
CODE:
xstate typegen "src/**/*.ts?(x)"

----------------------------------------

TITLE: Sending Events to Workflow Instance
DESCRIPTION: cURL command demonstrating how to send events to a specific workflow instance using POST request with JSON payload

LANGUAGE: bash
CODE:
curl -X POST http://localhost:4242/workflows/:id -d '{"type": "TIMER"}' -H "Content-Type: application/json"

----------------------------------------

TITLE: Spawning and Communicating with Callback Actor
DESCRIPTION: Implementation of a counter-interval actor using callbacks that can receive and send events

LANGUAGE: javascript
CODE:
const counterInterval = (callback, receive) => {
  let count = 0;

  const intervalId = setInterval(() => {
    callback({ type: 'COUNT.UPDATE', count });
    count++;
  }, 1000);

  receive(event => {
    if (event.type === 'INC') {
      count++;
    }
  });

  return () => { clearInterval(intervalId); }
}

const machine = createMachine({
  // ...
  {
    actions: assign({
      counterRef: () => spawn(counterInterval)
    })
  }
  // ...
});

----------------------------------------

TITLE: Path Generation with Duplicate Paths in TypeScript
DESCRIPTION: Example showing how to generate state machine paths with the option to allow duplicate paths using getSimplePaths.

LANGUAGE: typescript
CODE:
const paths = model.getSimplePaths({
  allowDuplicatePaths: true
});
// a
// a -> b
// a -> b -> c
// a -> d
// a -> d -> e

----------------------------------------

TITLE: Including @xstate/vue via CDN in HTML
DESCRIPTION: HTML script tag to include the @xstate/vue package from a CDN.

LANGUAGE: html
CODE:
<script src="https://unpkg.com/@xstate/vue/dist/xstate-vue.min.js"></script>

----------------------------------------

TITLE: TypeScript Integration Example
DESCRIPTION: Shows how to properly type XState Immer functions including assign and createUpdater with TypeScript interfaces and types.

LANGUAGE: typescript
CODE:
import { createMachine } from 'xstate';
import { createUpdater, ImmerUpdateEvent } from '@xstate/immer';

interface FormContext {
  name: string;
  age: number | undefined;
}

type NameUpdateEvent = ImmerUpdateEvent<'UPDATE_NAME', string>;
type AgeUpdateEvent = ImmerUpdateEvent<'UPDATE_AGE', number>;

const nameUpdater = createUpdater<FormContext, NameUpdateEvent>(
  'UPDATE_NAME',
  (ctx, { input }) => {
    ctx.name = input;
  }
);

const ageUpdater = createUpdater<FormContext, AgeUpdateEvent>(
  'UPDATE_AGE',
  (ctx, { input }) => {
    ctx.age = input;
  }
);

type FormEvent =
  | NameUpdateEvent
  | AgeUpdateEvent
  | {
      type: 'SUBMIT';
    };

----------------------------------------

TITLE: Invoking Services and Capturing Results in XState TypeScript Machine
DESCRIPTION: Demonstrates how to invoke a service within an XState machine, handle its results, and assign them to the machine's context.

LANGUAGE: typescript
CODE:
invoke: {
  id: 'checkFilePermissions',
  input: ({ context: { directoriesToCheck } }) => ({
    directoriesToCheck
  }),
  src: fromPromise(async ({ input: { directoriesToCheck } }) =>
    await checkFilePermissions(directoriesToCheck)
  ),
  onDone: [
    {
      target: 'EvaluatingFiles',
      actions: assign(({ event }) => {
        return {
          dirsToEvaluate: event.output['dirsToEvaluate'],
          dirsToReport: event.output['dirsToReport']
        };
      })
    }
  ],
  onError: [
    {
      target: 'ReportingErrors',
      actions: assign(({ event }) => {
        return {
          dirsToReport: event.error['dirsToReport']
        };
      })
    }
  ]
}

----------------------------------------

TITLE: Implementing Toggle Component with XState in SolidJS
DESCRIPTION: Example showing how to create a basic toggle machine and use it in a SolidJS component using the useActor hook

LANGUAGE: javascript
CODE:
import { useActor } from '@xstate/solid';
import { createMachine } from 'xstate';

const toggleMachine = createMachine({
  id: 'toggle',
  initial: 'inactive',
  states: {
    inactive: {
      on: { TOGGLE: 'active' }
    },
    active: {
      on: { TOGGLE: 'inactive' }
    }
  }
});

export const Toggler = () => {
  const [snapshot, send] = useActor(toggleMachine);

  return (
    <button onclick={() => send({ type: 'TOGGLE' })}>
      {snapshot.value === 'inactive'
        ? 'Click to activate'
        : 'Active! Click to deactivate'}
    </button>
  );
};

----------------------------------------

TITLE: Installing XState and @xstate/vue via npm
DESCRIPTION: Command to install the required packages for using XState with Vue.

LANGUAGE: bash
CODE:
npm i xstate @xstate/vue

----------------------------------------

TITLE: Adding State Assertions to Toggle Machine
DESCRIPTION: Extends the toggle machine with test assertions for each state using Puppeteer.

LANGUAGE: javascript
CODE:
// ...

const toggleMachine = createMachine({
  id: 'toggle',
  initial: 'inactive',
  states: {
    inactive: {
      on: {
        /* ... */
      },
      meta: {
        test: async (page) => {
          await page.waitFor('input:checked');
        }
      }
    },
    active: {
      on: {
        /* ... */
      },
      meta: {
        test: async (page) => {
          await page.waitFor('input:not(:checked)');
        }
      }
    }
  }
});

----------------------------------------

TITLE: Installing XState Dependencies
DESCRIPTION: Commands to install XState core and framework-specific packages using pnpm.

LANGUAGE: bash
CODE:
pnpm install xstate @xstate/react

----------------------------------------

TITLE: Serializing Guards in XState
DESCRIPTION: This snippet shows how to serialize guards as strings or objects, with the implementation details specified in the machine options. This approach improves debugging, serialization, testing, and visualization of guards.

LANGUAGE: javascript
CODE:
const searchMachine = createMachine(
  {
    // ...
    states: {
      idle: {
        on: {
          SEARCH: {
            target: 'searching',
            // The 'searchValid' guard implementation details are
            // specified in the machine config
            cond: 'searchValid' // or { type: 'searchValid' }
          }
        }
      }
      // ...
    }
  },
  {
    guards: {
      searchValid: (context, event) => {
        return context.canSearch && event.query && event.query.length > 0;
      }
    }
  }
);

----------------------------------------

TITLE: React Integration with XState Store
DESCRIPTION: Shows how to use XState Store with React components using useSelector hook

LANGUAGE: tsx
CODE:
import { donutStore } from './donutStore.ts';
import { useSelector } from '@xstate/store/react';

function DonutCounter() {
  const donutCount = useSelector(donutStore, (state) => state.context.donuts);

  return (
    <div>
      <button onClick={() => donutStore.send({ type: 'addDonut' })}>
        Add donut ({donutCount})
      </button>
    </div>
  );
}

----------------------------------------

TITLE: Using useMachine in Svelte Component
DESCRIPTION: Example of importing and using useMachine in a Svelte component to create a toggle button with XState.

LANGUAGE: svelte
CODE:
<script>
  import { useMachine } from '@xstate/svelte';
  import { createMachine } from 'xstate';

  const toggleMachine = createMachine({
    id: 'toggle',
    initial: 'inactive',
    states: {
      inactive: {
        on: { TOGGLE: 'active' }
      },
      active: {
        on: { TOGGLE: 'inactive' }
      }
    }
  });

  const { state, send } = useMachine(toggleMachine);
</script>

<button on:click={() => send('TOGGLE')}>
  {$state.value === 'inactive'
    ? 'Click to activate'
    : 'Active! Click to deactivate'}
</button>

----------------------------------------

TITLE: Including XState Vue via CDN
DESCRIPTION: HTML script tag to include the XState Vue library from a CDN.

LANGUAGE: html
CODE:
<script src="https://unpkg.com/@xstate/vue/dist/xstate-vue.min.js"></script>

----------------------------------------

TITLE: Running Development Server
DESCRIPTION: Command to start the Vite development server for previewing the XState example.

LANGUAGE: bash
CODE:
pnpm run dev

----------------------------------------

TITLE: Checking Initial State Transition in XState
DESCRIPTION: Example showing how transitions work with initial states in compound states, demonstrating the automatic entry into initial substate.

LANGUAGE: javascript
CODE:
console.log(lightMachine.transition('yellow', { type: 'TIMER' }).value);
// => {
//   red: 'walk'
// }

----------------------------------------

TITLE: Immer Integration with XState Store
DESCRIPTION: Example of using XState Store with Immer for immutable state updates

LANGUAGE: typescript
CODE:
import { createStoreWithProducer } from '@xstate/store';
import { produce } from 'immer';

const donutStore = createStoreWithProducer(produce, {
  context: {
    donuts: 0,
    favoriteFlavor: 'chocolate'
  },
  on: {
    addDonut: (context) => {
      context.donuts++;
    },
    changeFlavor: (context, event: { flavor: string }) => {
      context.favoriteFlavor = event.flavor;
    },
    eatAllDonuts: (context) => {
      context.donuts = 0;
    }
  }
});

----------------------------------------

TITLE: Including XState-Svelte via CDN
DESCRIPTION: HTML script tag to include XState-Svelte from a CDN, making it available as a global variable.

LANGUAGE: html
CODE:
<script src="https://unpkg.com/@xstate/svelte/dist/xstate-svelte.min.js"></script>

----------------------------------------

TITLE: Using useInterpret in Vue Component
DESCRIPTION: Example of using the useInterpret composition function in a Vue component with options and a listener.

LANGUAGE: javascript
CODE:
import { useInterpret } from '@xstate/vue';
import { someMachine } from '../path/to/someMachine';

const service = useInterpret(
  someMachine,
  {
    actions: {
      /* ... */
    }
  },
  (state) => {
    // subscribes to state changes
    console.log(state.value);
  }
);

----------------------------------------

TITLE: New States Configuration in XState 4
DESCRIPTION: Demonstrates the new syntax for state transitions using explicit target property and simplified actions syntax.

LANGUAGE: javascript
CODE:
const machine = createMachine({
  // ...
  states: {
    green: {
      on: {
        // ✅ will work in v4
        TIMER: {
          target: 'yellow',
          actions: 'doSomething' // notice: array not necessary anymore!
        }
      }
    }
  }
});

----------------------------------------

TITLE: Store Configuration with Context and Events
DESCRIPTION: Example showing how to configure a store with context and event handlers using the new configuration API.

LANGUAGE: typescript
CODE:
const store = createStore({
  context: { count: 0 },
  on: {
    increment: (ctx, event: { by: number }) => ({
      count: ctx.count + event.by
    })
  }
});

store.trigger.increment({ by: 5 });

----------------------------------------

TITLE: Basic Toggle Machine Implementation
DESCRIPTION: Example of creating and using a simple toggle state machine with the useMachine hook in a React component.

LANGUAGE: javascript
CODE:
import { useMachine } from '@xstate/react';
import { createMachine } from 'xstate';

const toggleMachine = createMachine({
  id: 'toggle',
  initial: 'inactive',
  states: {
    inactive: {
      on: { TOGGLE: 'active' }
    },
    active: {
      on: { TOGGLE: 'inactive' }
    }
  }
});

export const Toggler = () => {
  const [state, send] = useMachine(toggleMachine);

  return (
    <button onClick={() => send('TOGGLE')}>
      {state.value === 'inactive'
        ? 'Click to activate'
        : 'Active! Click to deactivate'}
    </button>
  );
};

----------------------------------------

TITLE: Using useSelector in Vue Component
DESCRIPTION: Example of using the useSelector composition function in a Vue component to select a specific value from the machine's state.

LANGUAGE: javascript
CODE:
import { useSelector } from '@xstate/vue';

const props = defineProps(['service']);

const selectCount = (state) => state.context.count;

const count = useSelector(props.service, selectCount);

----------------------------------------

TITLE: Optional Array Syntax in XState 4
DESCRIPTION: Illustrates how properties that expect multiple entries can now accept either arrays or single values for better developer convenience.

LANGUAGE: javascript
CODE:
{
  // This still works
  onEntry: ['someEntryAction'],
  onExit: [{ type: 'someExitAction' }],

  // But you can do this instead, if you prefer:
  onEntry: 'someEntryAction',
  onExit: { type: 'someExitAction' }
}

----------------------------------------

TITLE: Demonstrating State Transitions with History in JavaScript
DESCRIPTION: This code snippet shows how to use the fan state machine, demonstrating transitions between states and the effect of history states on those transitions.

LANGUAGE: javascript
CODE:
const firstState = fanMachine.transition(fanMachine.initialState, {
  type: 'POWER'
});
console.log(firstState.value);
// transitions to the initial state of 'fanOn' since there is no history
// => {
//   fanOn: 'first'
// }

const secondState = fanMachine.transition(firstState, { type: 'SWITCH' });
console.log(secondState.value);
// => {
//   fanOn: 'second'
// }

const thirdState = fanMachine.transition(secondState, { type: 'POWER' });
console.log(thirdState.value);
// => 'fanOff'

console.log(thirdState.history);
// => State {
//   value: { fanOn: 'second' },
//   actions: []
// }

const fourthState = fanMachine.transition(thirdState, { type: 'POWER' });
console.log(fourthState.value);
// transitions to 'fanOn.second' from history
// => {
//   fanOn: 'second'
// }

----------------------------------------

TITLE: Vue 3 Component Using useSelector Hook
DESCRIPTION: Example showing how to use the useSelector hook to subscribe to an actor's state in a Vue 3 component.

LANGUAGE: typescript
CODE:
const store = createStore({
  count: 0
}, {
  inc: {
    count: (context) => context.count + 1
  }
});

function Counter() {
  const count = useSelector(store, (state) => state.context.count);

  return (
    <div>
      <button onClick={() => store.send({ type: 'inc' })}>{count}</button>
    </div>
  );
}

----------------------------------------

TITLE: Installing XState React Package
DESCRIPTION: Instructions for installing XState and its React integration package via npm or CDN.

LANGUAGE: bash
CODE:
npm i xstate @xstate/react

LANGUAGE: html
CODE:
<script src="https://unpkg.com/@xstate/react/dist/xstate-react.umd.min.js"></script>

----------------------------------------

TITLE: Implementing Async Reddit API Fetching
DESCRIPTION: Adds asynchronous data fetching capability using Promise invocation in the selected state.

LANGUAGE: javascript
CODE:
function invokeFetchSubreddit(context) {
  const { subreddit } = context;

  return fetch(`https://www.reddit.com/r/${subreddit}.json`)
    .then((response) => response.json())
    .then((json) => json.data.children.map((child) => child.data));
}

const redditMachine = createMachine({
  /* ... */
  states: {
    idle: {},
    selected: {
      invoke: {
        id: 'fetch-subreddit',
        src: invokeFetchSubreddit
      }
    }
  },
  on: {
    /* ... */
  }
});

----------------------------------------

TITLE: Using sendTo Action Creator in TypeScript
DESCRIPTION: Specifying the recipient actor ref of an event first allows for strong typing against allowed actor events.

LANGUAGE: typescript
CODE:
entry: sendTo(
  (ctx) => ctx.someActorRef,
  { type: 'EVENT_FOR_ACTOR' }
)

----------------------------------------

TITLE: Sending Events to XState Service
DESCRIPTION: Shows different ways to send events to a running XState service, including sending event objects.

LANGUAGE: javascript
CODE:
service.start();

service.send({ type: 'CLICK', x: 40, y: 21 });

----------------------------------------

TITLE: Installing XState and @xstate/vue via npm
DESCRIPTION: Command to install XState and @xstate/vue packages using npm.

LANGUAGE: bash
CODE:
npm i xstate @xstate/vue

----------------------------------------

TITLE: Installing XState Immer Dependencies
DESCRIPTION: Command to install the required packages including immer, xstate, and @xstate/immer.

LANGUAGE: bash
CODE:
npm install immer xstate @xstate/immer

----------------------------------------

TITLE: Installing and Starting the Workflow Engine
DESCRIPTION: Commands to install dependencies and start the workflow engine server

LANGUAGE: bash
CODE:
pnpm install
pnpm start

----------------------------------------

TITLE: Rendering Update Title and Date in HTML
DESCRIPTION: This snippet demonstrates how to render the update title and date using HTML and Vue.js template syntax. It uses frontmatter data to populate the title and formats the date using JavaScript's toLocaleString method.

LANGUAGE: html
CODE:
<h1>{{ $frontmatter.title }}</h1>
<p class="date">{{ new Date($frontmatter.date).toLocaleString('en-US',{ month:'long', day:'numeric', year:'numeric' }) }}</p>

----------------------------------------

TITLE: Async State Machine with waitFor
DESCRIPTION: Shows how to use waitFor to handle async operations in XState, including timeout configuration.

LANGUAGE: typescript
CODE:
import { interpret, createMachine } from 'xstate';
import { waitFor } from 'xstate/lib/waitFor';

const machine = createMachine({
  initial: 'pending',
  states: {
    pending: {
      after: {
        3000: {
          target: 'done'
        }
      }
    },
    done: {}
  }
});

const myFunc = async () => {
  const actor = interpret(machine).start();

  const doneState = await waitFor(actor, (state) => state.matches('done'));

  console.log(doneState.value); // 'done'
};

----------------------------------------

TITLE: Basic XState Toggle Machine Implementation in Svelte
DESCRIPTION: Example showing how to create and use a simple toggle state machine in a Svelte component using useMachine hook.

LANGUAGE: svelte
CODE:
<script>
  import { useMachine } from '@xstate/svelte';
  import { createMachine } from 'xstate';

  const toggleMachine = createMachine({
    id: 'toggle',
    initial: 'inactive',
    states: {
      inactive: {
        on: { TOGGLE: 'active' }
      },
      active: {
        on: { TOGGLE: 'inactive' }
      }
    }
  });

  const { state, send } = useMachine(toggleMachine);
</script>

<button on:click={() => send('TOGGLE')}>
  {$state.value === 'inactive'
    ? 'Click to activate'
    : 'Active! Click to deactivate'}
</button>

----------------------------------------

TITLE: Creating Toggle State Machine with XState
DESCRIPTION: Defines a simple toggle state machine using XState with two states (active/inactive) and a toggle transition between them.

LANGUAGE: javascript
CODE:
import { createMachine } from 'xstate';

export const toggleMachine = createMachine({
  id: 'toggle',
  initial: 'active',
  states: {
    inactive: { on: { toggle: 'active' } },
    active: { on: { toggle: 'inactive' } }
  }
});

----------------------------------------

TITLE: Get Workflow State API Request
DESCRIPTION: cURL command for retrieving the current state of a workflow instance.

LANGUAGE: bash
CODE:
curl -X GET http://localhost:4242/workflows/:id

----------------------------------------

TITLE: TypeScript Type Inference in XState Models
DESCRIPTION: Demonstrates type inference for context and events in XState models, including explicit type annotations and inferred types.

LANGUAGE: typescript
CODE:
import { createModel } from 'xstate/lib/model';

const userModel = createModel(
  {
    name: 'David', // inferred as `string`
    age: 30, // inferred as `number`
    friends: [] as string[] // explicit type
  },
  {
    events: {
      updateName: (value: string) => ({ value }),
      updateAge: (value: number) => ({ value }),
      anotherEvent: () => ({}) // no payload
    }
  }
);

----------------------------------------

TITLE: Subscribing to XState Actor State Changes in TypeScript
DESCRIPTION: Shows how to subscribe to the XState actor to log state changes, errors, and context information.

LANGUAGE: typescript
CODE:
mediaScannerActor.subscribe((state) => {
  console.log({
    state: state.value,
    error: state.error,
    context: state.context
  });
});

----------------------------------------

TITLE: Running XState Typegen with Watch Mode
DESCRIPTION: Command to run typegen in watch mode, which monitors for file changes and automatically runs typegen against modified files.

LANGUAGE: bash
CODE:
xstate typegen "src/**/*.ts?(x)" --watch

----------------------------------------

TITLE: Installing XState via NPM
DESCRIPTION: Command to install XState using NPM package manager.

LANGUAGE: bash
CODE:
npm install xstate --save

----------------------------------------

TITLE: Running XState Typegen with Watch Mode
DESCRIPTION: Command to run typegen in watch mode, which monitors for file changes and automatically runs typegen against modified files.

LANGUAGE: bash
CODE:
xstate typegen "src/**/*.ts?(x)" --watch

----------------------------------------

TITLE: Batching Results and Assigning Context in XState TypeScript Machine
DESCRIPTION: Shows how to batch results from a service and assign multiple properties to the XState machine's context.

LANGUAGE: typescript
CODE:
return { dirsToEvaluate, dirsToReport };

LANGUAGE: typescript
CODE:
actions: assign(({ event }) => {
  return {
    dirsToEvaluate: event.output['dirsToEvaluate'],
    dirsToReport: event.output['dirsToReport']
  };
});

----------------------------------------

TITLE: XState Actions and SCXML Scripts
DESCRIPTION: Illustrates how XState actions correspond to SCXML script elements, including entry and exit actions.

LANGUAGE: javascript
CODE:
{
  start: {
    entry: 'showStartScreen',
    exit: 'logScreenChange',
    on: {
      STOP: {
        target: 'stop',
        actions: ['logStop', 'stopEverything']
      }
    }
  }
}

LANGUAGE: xml
CODE:
<state id="start">
  <onentry>
    <script>showStartScreen();</script>
  </onentry>
  <onexit>
    <script>logScreenChange();</script>
  </onexit>
  <transition event="STOP" target="stop">
    <script>logStop();</script>
    <script>stopEverything();</script>
  </transition>
</state>

----------------------------------------

TITLE: Installing XState Inspect Package
DESCRIPTION: Commands for installing the @xstate/inspect package using npm or yarn package managers

LANGUAGE: bash
CODE:
npm install @xstate/inspect
# or yarn add @xstate/inspect

----------------------------------------

TITLE: Importing and Using getSimplePaths Function
DESCRIPTION: Example of importing createMachine from XState and getSimplePaths from @xstate/graph, then using them to analyze a machine.

LANGUAGE: javascript
CODE:
import { createMachine } from 'xstate';
import { getSimplePaths } from '@xstate/graph';

const machine = createMachine(/* ... */);
const paths = getSimplePaths(machine);

----------------------------------------

TITLE: Starting Development Server
DESCRIPTION: Command to start the development server on localhost:5173 using Yarn.

LANGUAGE: bash
CODE:
yarn dev

----------------------------------------

TITLE: Including XState Inspect via CDN
DESCRIPTION: HTML script tag for including XState Inspect via CDN, making it available through the global XStateInspect variable

LANGUAGE: html
CODE:
<script src="https://unpkg.com/@xstate/inspect/dist/xstate-inspect.umd.min.js"></script>

----------------------------------------

TITLE: Initializing XState Inspector
DESCRIPTION: Basic setup for XState inspector with default configuration options. Must be imported at the beginning of the project before any other code.

LANGUAGE: javascript
CODE:
import { inspect } from '@xstate/inspect';

inspect({
  // options
  // url: 'https://stately.ai/viz?inspect', // (default)
  iframe: false // open in new window
});

----------------------------------------

TITLE: Configuring MongoDB Connection String in TypeScript
DESCRIPTION: MongoDB connection string configuration in actorService.ts file for connecting to the creditCheck database.

LANGUAGE: typescript
CODE:
const uri = "<your mongo uri here>/creditCheck";

----------------------------------------

TITLE: Creating a Test Model with @xstate/test
DESCRIPTION: Creates a test model using the createModel function from @xstate/test. The model includes an event definition for the 'TOGGLE' event, specifying how to execute the event in the test environment.

LANGUAGE: javascript
CODE:
import { createMachine } from 'xstate';
import { createModel } from '@xstate/test';

const toggleMachine = createMachine(/* ... */);

const toggleModel = createModel(toggleMachine).withEvents({
  TOGGLE: {
    exec: async (page) => {
      await page.click('input');
    }
  }
});

----------------------------------------

TITLE: Custom Serializer Implementation
DESCRIPTION: Examples of implementing custom serializers for handling sensitive data and adding custom logging

LANGUAGE: typescript
CODE:
// Remove credentials from being forwarded
inspect({
  serialize: (key: string, value: any) => {
    return key === 'credentials' && typeof value === 'object' ? {} : value;
  }
});

// Add a custom local log
inspect({
  serialize: (key: string, value: any) => {
    if (key === 'ready') {
      console.log('Detected ready key');
    }
    return value;
  }
});

----------------------------------------

TITLE: Workflow Creation Response Example
DESCRIPTION: Example JSON response from the workflow creation endpoint showing success message and workflow ID.

LANGUAGE: json
CODE:
{
  {"message":"New worflow created successfully","workflowId":"uzkjyy"}
}

----------------------------------------

TITLE: Installing XState and @xstate/test with npm
DESCRIPTION: Command to install the required packages xstate and @xstate/test using npm.

LANGUAGE: bash
CODE:
npm install xstate @xstate/test

----------------------------------------

TITLE: Using Required Input with XState React Hooks
DESCRIPTION: Example showing how input is required when defined in types for useActor, useMachine and useActorRef hooks

LANGUAGE: tsx
CODE:
const machine = setup({
  types: {
    input: {} as { value: number }
  }
}).createMachine({});

function App() {
  const _ = useMachine(machine, {
    input: { value: 1 } // Now input is required at compile time!
  });
  return <></>;
}

----------------------------------------

TITLE: Installing XState Svelte Package
DESCRIPTION: Instructions for installing XState and its Svelte integration package via npm.

LANGUAGE: bash
CODE:
npm i xstate @xstate/svelte

----------------------------------------

TITLE: Creating New Workflow Instance
DESCRIPTION: cURL command to create a new workflow instance via POST request to /workflows endpoint

LANGUAGE: bash
CODE:
curl -X POST http://localhost:4242/workflows

----------------------------------------

TITLE: Creating Basic XState Store
DESCRIPTION: Demonstrates creating a store with context and event handlers for managing donut-related state

LANGUAGE: typescript
CODE:
import { createStore } from '@xstate/store';

export const donutStore = createStore({
  context: {
    donuts: 0,
    favoriteFlavor: 'chocolate'
  },
  on: {
    addDonut: (context) => ({
      ...context,
      donuts: context.donuts + 1
    }),
    changeFlavor: (context, event: { flavor: string }) => ({
      ...context,
      favoriteFlavor: event.flavor
    }),
    eatAllDonuts: (context) => ({
      ...context,
      donuts: 0
    })
  }
});

----------------------------------------

TITLE: State Persistence and Rehydration in XState
DESCRIPTION: Example showing how to persist and rehydrate state using useActor hook options

LANGUAGE: javascript
CODE:
const persistedSnapshot = JSON.parse(localStorage.getItem('some-persisted-state-key')) || someMachine.initialState;

const App = () => {
  const [snapshot, send] = useActor(someMachine, {
    snapshot: persistedSnapshot
  });

  return (/* ... */)
}

----------------------------------------

TITLE: Including @xstate/vue via CDN
DESCRIPTION: HTML script tag to include @xstate/vue package from a CDN.

LANGUAGE: html
CODE:
<script src="https://unpkg.com/@xstate/vue/dist/xstate-vue.min.js"></script>

----------------------------------------

TITLE: Creating Temperature Converter State Machine with XState in JavaScript
DESCRIPTION: This code snippet defines a state machine for a temperature converter using XState. It handles conversion between Celsius and Fahrenheit, updating both values simultaneously when either input changes. The machine has a single 'active' state and uses context to store the temperature values.

LANGUAGE: javascript
CODE:
import { createMachine, assign } from 'xstate';

export const temperatureMachine = createMachine({
  initial: 'active',
  context: { C: undefined, F: undefined },
  states: {
    active: {
      on: {
        CELSIUS: {
          actions: assign({
            C: (_, event) => event.value,
            F: (_, event) =>
              event.value.length ? +event.value * (9 / 5) + 32 : ''
          })
        },
        FAHRENHEIT: {
          actions: assign({
            C: (_, event) =>
              event.value.length ? (+event.value - 32) * (5 / 9) : '',
            F: (_, event) => event.value
          })
        }
      }
    }
  }
});

----------------------------------------

TITLE: Installing XState Svelte Dependencies
DESCRIPTION: Command to install the required XState and Svelte integration packages via npm.

LANGUAGE: bash
CODE:
npm i xstate @xstate/svelte

----------------------------------------

TITLE: Local State Management with useMachine Hook
DESCRIPTION: Basic implementation of XState in a React component using the useMachine hook from @xstate/react to manage toggle functionality.

LANGUAGE: javascript
CODE:
import { useMachine } from '@xstate/react';
import { toggleMachine } from '../path/to/toggleMachine';

function Toggle() {
  const [current, send] = useMachine(toggleMachine);

  return (
    <button onClick={() => send('TOGGLE')}>
      {current.matches('inactive') ? 'Off' : 'On'}
    </button>
  );
}

----------------------------------------

TITLE: Creating Reactive Atoms with createAtom
DESCRIPTION: Example showing how to create and use reactive atoms with the createAtom() function. Demonstrates creating simple atoms, subscribing to changes, and combining multiple atoms.

LANGUAGE: typescript
CODE:
import { createAtom } from '@xstate/store';

const countAtom = createAtom(0);
countAtom.get(); // 0
countAtom.set(1); // or use setter function: (prev) => prev + 1

countAtom.subscribe((value) => console.log(value));

const nameAtom = createAtom('hello');
const countAtom = createAtom(3);
const combinedAtom = createAtom((read) =>
  read(nameAtom).repeat(read(countAtom))
);
combinedAtom.get(); // "hellohellohello"

----------------------------------------

TITLE: Local State Management with useMachine Hook
DESCRIPTION: Basic implementation of XState in a React component using the useMachine hook from @xstate/react to manage toggle functionality.

LANGUAGE: javascript
CODE:
import { useMachine } from '@xstate/react';
import { toggleMachine } from '../path/to/toggleMachine';

function Toggle() {
  const [current, send] = useMachine(toggleMachine);

  return (
    <button onClick={() => send('TOGGLE')}>
      {current.matches('inactive') ? 'Off' : 'On'}
    </button>
  );
}

----------------------------------------

TITLE: Defining Timer Context Interface in TypeScript
DESCRIPTION: TypeScript interface defining the context structure for the timer state machine, including elapsed time, duration, and interval properties.

LANGUAGE: typescript
CODE:
interface TimerContext {
  // The elapsed time (in seconds)
  elapsed: number;
  // The maximum time (in seconds)
  duration: number;
  // The interval to send TICK events (in seconds)
  interval: number;
}

----------------------------------------

TITLE: Installing XState Immer Dependencies
DESCRIPTION: Command to install the required packages: immer, xstate, and @xstate/immer using npm.

LANGUAGE: bash
CODE:
npm install immer xstate @xstate/immer

----------------------------------------

TITLE: Vue Component Using useActor and useSpawn
DESCRIPTION: Example demonstrating how to use useActor and useSpawn hooks to manage state with a reducer-based actor.

LANGUAGE: vue
CODE:
<template>
  <div>
    Count: {{ count }}
    <button @click="send({ type: 'INC' })">Increment</button>
    <button @click="send({ type: 'DEC' })">Decrement</button>
  </div>
</template>

<script>
import { fromReducer } from 'xstate/lib/behaviors';
import { useActor, useSpawn } from '@xstate/vue';

type CountEvent = { type: 'INC' } | { type: 'DEC' };

const countBehavior = fromReducer(
  (count: number, event: CountEvent): number => {
    if (event.type === 'INC') {
      return count + 1;
    } else if (event.type === 'DEC') {
      return count - 1;
    }

    return count;
  },
  0
);

export default {
  setup() {
    const countActorRef = useSpawn(countBehavior);
    const { state: count, send } = useActor(countActorRef);

    return { count, send };
  }
};
</script>

----------------------------------------

TITLE: Installing Rollup Replace Plugin
DESCRIPTION: Installation command for the Rollup replace plugin required for legacy Svelte projects.

LANGUAGE: javascript
CODE:
npm install @rollup/plugin-replace --save-dev

----------------------------------------

TITLE: Implementing Timer State Machine in JavaScript
DESCRIPTION: Complete implementation of the timer state machine using XState, including running and paused states, interval-based tick generation, and event handlers for duration updates and reset.

LANGUAGE: javascript
CODE:
export const timerMachine = createMachine({
  initial: 'running',
  context: {
    elapsed: 0,
    duration: 5,
    interval: 0.1
  },
  states: {
    running: {
      invoke: {
        src: (context) => (cb) => {
          const interval = setInterval(() => {
            cb('TICK');
          }, 1000 * context.interval);

          return () => {
            clearInterval(interval);
          };
        }
      },
      on: {
        '': {
          target: 'paused',
          cond: (context) => {
            return context.elapsed >= context.duration;
          }
        },
        TICK: {
          actions: assign({
            elapsed: (context) =>
              +(context.elapsed + context.interval).toFixed(2)
          })
        }
      }
    },
    paused: {
      on: {
        '': {
          target: 'running',
          cond: (context) => context.elapsed < context.duration
        }
      }
    }
  },
  on: {
    'DURATION.UPDATE': {
      actions: assign({
        duration: (_, event) => event.value
      })
    },
    RESET: {
      actions: assign({
        elapsed: 0
      })
    }
  }
});

----------------------------------------

TITLE: Installing and Running TodoMVC React Example
DESCRIPTION: Shell commands to set up and run the TodoMVC React example locally using pnpm package manager.

LANGUAGE: shell
CODE:
    cd examples/todomvc-react
    pnpm install
    pnpm run dev

----------------------------------------

TITLE: Installing XState with NPM
DESCRIPTION: Command to install the XState package via NPM package manager.

LANGUAGE: bash
CODE:
npm install xstate

----------------------------------------

TITLE: Configuring Rollup Replace Plugin
DESCRIPTION: Configuration setup for the Rollup replace plugin in rollup.config.js to handle environment variables.

LANGUAGE: javascript
CODE:
replace({
  'process.env.NODE_ENV': process.env.NODE_ENV
});

----------------------------------------

TITLE: Installing XState with NPM
DESCRIPTION: Command to install the XState package via NPM package manager.

LANGUAGE: bash
CODE:
npm install xstate

----------------------------------------

TITLE: Running TypeScript Project with ts-node
DESCRIPTION: Command to execute the TypeScript project using ts-node with ECMAScript modules support.

LANGUAGE: bash
CODE:
yarn ts-node --esm ./main.ts

----------------------------------------

TITLE: Configuring XState Machine in Vue Component
DESCRIPTION: Example of configuring an XState machine with custom actions and services in a Vue component using useMachine.

LANGUAGE: vue
CODE:
<script setup>
import { assign, createMachine } from 'xstate';
import { useMachine } from '@xstate/vue';

const fetchMachine = createMachine({
  id: 'fetch',
  initial: 'idle',
  context: {
    data: undefined,
    error: undefined
  },
  states: {
    idle: {
      on: { FETCH: 'loading' }
    },
    loading: {
      invoke: {
        src: 'fetchData',
        onDone: {
          target: 'success',
          actions: assign({
            data: (_context, event) => event.data
          })
        },
        onError: {
          target: 'failure',
          actions: assign({
            error: (_context, event) => event.data
          })
        }
      }
    },
    success: {
      entry: 'notifySuccess',
      type: 'final'
    },
    failure: {
      on: {
        RETRY: 'loading'
      }
    }
  }
});

const props = defineProps({
  onResolve: {
    type: Function,
    default: () => {}
  }
});

const { state, send } = useMachine(fetchMachine, {
  actions: {
    notifySuccess: (ctx) => props.onResolve(ctx.data)
  },
  services: {
    fetchData: (_context, event) =>
      fetch(`some/api/${event.query}`).then((res) => res.json())
  }
});
</script>

<template>
  <template v-if="state.value === 'idle'">
    <button @click="send({ type: 'FETCH', query: 'something' })">
      Search for something
    </button>
  </template>

  <template v-else-if="state.value === 'loading'">
    <div>Searching...</div>
  </template>

  <template v-else-if="state.value === 'success'">
    <div>Success! {{ state.context.data }}</div>
  </template>

  <template v-else-if="state.value === 'failure'">
    <p>{{ state.context.error.message }}</p>
    <button @click="send('RETRY')">Retry</button>
  </template>
</template>

----------------------------------------

TITLE: Defining Flight Booking Types in TypeScript
DESCRIPTION: TypeScript interface and type definitions for the flight booking state machine, including context structure and event types.

LANGUAGE: typescript
CODE:
interface FlightContext {
  startDate?: string;
  returnDate?: string;
  trip: 'oneWay' | 'roundTrip';
}

type FlightEvent =
  | {
      type: 'SET_TRIP';
      value: 'oneWay' | 'roundTrip';
    }
  | {
      type: 'startDate.UPDATE';
      value: string;
    }
  | {
      type: 'returnDate.UPDATE';
      value: string;
    }
  | { type: 'SUBMIT' };

----------------------------------------

TITLE: Installing XState via Package Manager
DESCRIPTION: Commands to install XState using NPM or Yarn package managers.

LANGUAGE: bash
CODE:
npm install xstate@latest --save
# or:
yarn add xstate@latest --save

----------------------------------------

TITLE: Installing TodoMVC Dependencies
DESCRIPTION: Command to install the required npm dependencies for the TodoMVC template project.

LANGUAGE: bash
CODE:
npm install

----------------------------------------

TITLE: Installing XState
DESCRIPTION: Basic npm installation command for XState

LANGUAGE: bash
CODE:
npm install xstate

----------------------------------------

TITLE: Displaying Frontmatter Title and Date in Markdown
DESCRIPTION: This snippet demonstrates how to display the title from frontmatter and format the date using Vue.js syntax within a Markdown file.

LANGUAGE: markdown
CODE:
<h1>{{ $frontmatter.title }}</h1>
<p class="date">{{ new Date($frontmatter.date).toLocaleString('en-US',{ month:'long', day:'numeric', year:'numeric' }) }}</p>

----------------------------------------

TITLE: Including XState via CDN Script Tag
DESCRIPTION: HTML script tag to include XState directly from unpkg CDN.

LANGUAGE: html
CODE:
<script src="https://unpkg.com/xstate@4/dist/xstate.js"></script>

----------------------------------------

TITLE: Including @xstate/svelte via CDN
DESCRIPTION: HTML script tag to include the @xstate/svelte package via CDN, making it available through the global variable XStateSvelte.

LANGUAGE: html
CODE:
<script src="https://unpkg.com/@xstate/svelte/dist/xstate-svelte.min.js"></script>

----------------------------------------

TITLE: Rendering Blog Post Title and Date with Vue.js in Markdown
DESCRIPTION: This snippet demonstrates how to render a dynamic blog post title and formatted date using Vue.js template syntax within a Markdown file. It utilizes frontmatter data to populate the title and date fields.

LANGUAGE: html
CODE:
<h1>{{ $frontmatter.title }}</h1>
<p class="date">{{ new Date($frontmatter.date).toLocaleString('en-US',{ month:'long', day:'numeric', year:'numeric' }) }}</p>

----------------------------------------

TITLE: Installing XState CLI with npm
DESCRIPTION: Command to install the @xstate/cli package using npm. This is a prerequisite for using the XState CLI tools.

LANGUAGE: bash
CODE:
npm install @xstate/cli

----------------------------------------

TITLE: Persisting and Rehydrating State with useMachine in React
DESCRIPTION: Example of persisting and rehydrating state using the useMachine hook and the options.state property.

LANGUAGE: javascript
CODE:
const persistedState = JSON.parse(localStorage.getItem('some-persisted-state-key')) || someMachine.initialState;

const App = () => {
  const [state, send] = useMachine(someMachine, {
    state: persistedState // provide persisted state config object here
  });

  // state will initially be that persisted state, not the machine's initialState

  return (/* ... */)
}

----------------------------------------

TITLE: Installing XState CLI Package
DESCRIPTION: Command to install the XState CLI package using npm package manager.

LANGUAGE: bash
CODE:
npm install @xstate/cli

----------------------------------------

TITLE: Installing and Building XState Developer Tools
DESCRIPTION: These commands install dependencies and build the developer tools panel in development mode. The first command installs all necessary packages, while the second builds the panel for development.

LANGUAGE: bash
CODE:
npm install

LANGUAGE: bash
CODE:
npm start

----------------------------------------

TITLE: Installing XState CLI via npm
DESCRIPTION: Command to install the @xstate/cli package using npm. This is a prerequisite for using the XState CLI tools.

LANGUAGE: bash
CODE:
npm install @xstate/cli

----------------------------------------

TITLE: Importing XState in Deno
DESCRIPTION: Demonstrates how to import XState package in a Deno environment using Skypack CDN. This approach bypasses the need for node_modules since Deno handles package imports at runtime.

LANGUAGE: javascript
CODE:
import { createMachine } from 'https://cdn.skypack.dev/xstate';

----------------------------------------

TITLE: Installing XState and @xstate/react via npm
DESCRIPTION: Command to install XState and @xstate/react packages using npm.

LANGUAGE: bash
CODE:
npm i xstate @xstate/react