TITLE: Initializing Konva Stage and Creating a Circle Shape
DESCRIPTION: This snippet demonstrates how to create a Konva stage, add a layer, and create a basic circle shape. It shows the minimal setup required to get started with Konva.

LANGUAGE: javascript
CODE:
// first we need to create a stage
var stage = new Konva.Stage({
  container: 'container', // id of container <div>
  width: 500,
  height: 500,
});

// then create layer
var layer = new Konva.Layer();

// create our shape
var circle = new Konva.Circle({
  x: stage.width() / 2,
  y: stage.height() / 2,
  radius: 70,
  fill: 'red',
  stroke: 'black',
  strokeWidth: 4,
});

// add the shape to the layer
layer.add(circle);

// add the layer to the stage
stage.add(layer);

----------------------------------------

TITLE: Including Konva via Script Tag
DESCRIPTION: This snippet demonstrates how to include Konva in an HTML file using a script tag, loading it from a CDN.

LANGUAGE: html
CODE:
<script src="https://unpkg.com/konva@9/konva.min.js"></script>

----------------------------------------

TITLE: Installing Konva via npm
DESCRIPTION: This snippet shows how to install Konva using npm, a popular package manager for JavaScript.

LANGUAGE: bash
CODE:
npm install konva

----------------------------------------

TITLE: Connecting Objects with Lines in Vanilla JavaScript
DESCRIPTION: This snippet demonstrates how to connect two Konva Circle objects with a Line object and update the line position when the circles are dragged. It includes a basic setup for creating and updating the connection.

LANGUAGE: javascript
CODE:
const obj1 = new Konva.Circle({ ...obj1Props })
const obj2= new Konva.Circle({ ...obj2Props });

const line = new Konva.Line({ ...lineProps });

obj1.on('dragmove', updateLine);
obj2.on('dragmove', updateLine);

function updateLine() {
  line.points([obj1.x(), obj1.y(), obj2.x(), obj2.y]);
}

----------------------------------------

TITLE: Implementing Custom Drop Events in Konva with React
DESCRIPTION: This snippet shows how to create custom drop events for Konva shapes using React. It creates multiple draggable star shapes and implements dragStart, dragMove, dragEnd, dragEnter, dragLeave, dragOver, and drop event handlers.

LANGUAGE: jsx
CODE:
import { Stage, Layer, Text, Star } from 'react-konva';
import { useState, useRef } from 'react';

const App = () => {
  const [stars] = useState(() =>
    Array.from({ length: 10 }, (_, i) => ({
      id: i,
      x: window.innerWidth * Math.random(),
      y: window.innerHeight * Math.random(),
      fill: 'blue',
      name: `star ${i}`,
    }))
  );
  const [message, setMessage] = useState('');
  const previousShapeRef = useRef(null);
  const mainLayerRef = useRef(null);
  const tempLayerRef = useRef(null);

  const handleDragStart = (e) => {
    const shape = e.target;
    shape.moveTo(tempLayerRef.current);
    setMessage('Moving ' + shape.name());
  };

  const handleDragMove = (e) => {
    const stage = e.target.getStage();
    const pos = stage.getPointerPosition();
    const shape = mainLayerRef.current.getIntersection(pos);

    if (previousShapeRef.current && shape) {
      if (previousShapeRef.current !== shape) {
        // leave from old target
        previousShapeRef.current.fire('dragleave', { evt: e.evt }, true);
        // enter new target
        shape.fire('dragenter', { evt: e.evt }, true);
        previousShapeRef.current = shape;
      } else {
        previousShapeRef.current.fire('dragover', { evt: e.evt }, true);
      }
    } else if (!previousShapeRef.current && shape) {
      previousShapeRef.current = shape;
      shape.fire('dragenter', { evt: e.evt }, true);
    } else if (previousShapeRef.current && !shape) {
      previousShapeRef.current.fire('dragleave', { evt: e.evt }, true);
      previousShapeRef.current = undefined;
    }
  };

  const handleDragEnd = (e) => {
    const shape = e.target;
    const stage = e.target.getStage();
    const pos = stage.getPointerPosition();
    const dropShape = mainLayerRef.current.getIntersection(pos);
    
    if (dropShape) {
      previousShapeRef.current.fire('drop', { evt: e.evt }, true);
    }
    
    shape.moveTo(mainLayerRef.current);
    previousShapeRef.current = undefined;
  };

  const handleDragEnter = (e) => {
    e.target.fill('green');
    setMessage('dragenter ' + e.target.name());
  };

  const handleDragLeave = (e) => {
    e.target.fill('blue');
    setMessage('dragleave ' + e.target.name());
  };

  const handleDragOver = (e) => {
    setMessage('dragover ' + e.target.name());
  };

  const handleDrop = (e) => {
    e.target.fill('red');
    setMessage('drop ' + e.target.name());
  };

  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer ref={mainLayerRef}>
        <Text text={message} fill="black" />
        {stars.map((star) => (
          <Star
            key={star.id}
            id={star.id}
            name={star.name}
            x={star.x}
            y={star.y}
            numPoints={10}
            innerRadius={20}
            outerRadius={25}
            fill={star.fill}
            shadowOffsetX={5}
            shadowOffsetY={5}
            draggable
            onDragStart={handleDragStart}
            onDragMove={handleDragMove}
            onDragEnd={handleDragEnd}
            onDragEnter={handleDragEnter}
            onDragLeave={handleDragLeave}
            onDragOver={handleDragOver}
            onDrop={handleDrop}
          />
        ))}
      </Layer>
      <Layer ref={tempLayerRef} />
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Creating Draggable Group with Konva in React
DESCRIPTION: This snippet shows how to implement a draggable group of colored rectangles using Konva with React. It uses the react-konva library to create a Stage, Layer, and Group components. The group is made draggable and mouse events are handled for cursor changes.

LANGUAGE: jsx
CODE:
import { Stage, Layer, Group, Rect, Text } from 'react-konva';

const App = () => {
  const colors = ['red', 'orange', 'yellow', 'green', 'blue', 'purple'];

  const handleMouseOver = () => {
    document.body.style.cursor = 'move';
  };

  const handleMouseOut = () => {
    document.body.style.cursor = 'default';
  };

  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        <Group
          draggable
          onMouseEnter={handleMouseOver}
          onMouseLeave={handleMouseOut}
        >
          {colors.map((color, i) => (
            <Rect
              key={color}
              x={i * 30 + 10}
              y={i * 18 + 40}
              width={100}
              height={50}
              name={color}
              fill={color}
              stroke="black"
              strokeWidth={4}
            />
          ))}
        </Group>
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Implementing Rich Text Editor with Konva Canvas
DESCRIPTION: Creates an interactive rich text editor that converts formatted HTML content to canvas images using Quill editor, html2canvas, and Konva. The implementation includes dynamic text updates, drag-and-drop functionality, and support for various text styling options.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

// First we need to load Quill and html2canvas
const loadScript = (src) => {
  return new Promise((resolve, reject) => {
    const script = document.createElement('script');
    script.src = src;
    script.onload = resolve;
    script.onerror = reject;
    document.head.appendChild(script);
  });
};

const loadCSS = (href) => {
  const link = document.createElement('link');
  link.rel = 'stylesheet';
  link.href = href;
  document.head.appendChild(link);
};

// Create editor container
const editorContainer = document.createElement('div');
editorContainer.id = 'editor-container';
editorContainer.style.height = '80px';
editorContainer.innerHTML = `
  That is <u>some</u> <span style="color: red"> styled text</span> on
  <strong>canvas</strong>!
  <h2>What do you think about it?</h2>
`;
document.body.appendChild(editorContainer);

// Load dependencies
Promise.all([
  loadScript('https://cdn.quilljs.com/1.3.6/quill.js'),
  loadScript('https://html2canvas.hertzen.com/dist/html2canvas.min.js'),
]).then(() => {
  loadCSS('https://cdn.quilljs.com/1.3.6/quill.snow.css');

  const quill = new Quill('#editor-container', {
    modules: {
      toolbar: [
        [{ header: [1, 2, false] }],
        ['bold', 'italic', 'underline'],
        ['image', 'code-block'],
      ],
    },
    placeholder: 'Compose an epic...',
    theme: 'snow',
  });

  const stage = new Konva.Stage({
    container: 'container',
    width: window.innerWidth,
    height: 200,
  });

  const layer = new Konva.Layer();
  stage.add(layer);

  const shape = new Konva.Image({
    x: 10,
    y: 10,
    draggable: true,
    stroke: 'red',
    scaleX: 1 / window.devicePixelRatio,
    scaleY: 1 / window.devicePixelRatio,
  });
  layer.add(shape);

  function renderText() {
    // convert DOM into image
    html2canvas(document.querySelector('.ql-editor'), {
      backgroundColor: 'rgba(0,0,0,0)',
    }).then((canvas) => {
      // show it inside Konva.Image
      shape.image(canvas);
    });
  }

  // batch updates, so we don't render text too frequently
  let timeout = null;
  function requestTextUpdate() {
    if (timeout) {
      return;
    }
    timeout = setTimeout(function () {
      timeout = null;
      renderText();
    }, 500);
  }

  // render text on all changes
  quill.on('text-change', requestTextUpdate);
  // make initial rendering
  renderText();
});

----------------------------------------

TITLE: Initializing Konva in Web Worker with Offscreen Canvas
DESCRIPTION: This code sets up Konva to work in a Web Worker using Offscreen Canvas. It creates a stage, layers, and interactive objects, and handles event proxying from the main thread.

LANGUAGE: javascript
CODE:
// load konva framework
importScripts('https://unpkg.com/konva@9/konva.min.js');

// monkeypatch Konva for offscreen canvas usage
Konva.Util.createCanvasElement = () => {
  const canvas = new OffscreenCanvas(1, 1);
  canvas.style = {};
  return canvas;
};

// now we can create our canvas content
var stage = new Konva.Stage({
  width: 200,
  height: 200,
});

var layer = new Konva.Layer();
stage.add(layer);

var topGroup = new Konva.Group();
layer.add(topGroup);

// counter will show number of bunnies
var counter = new Konva.Text({
  x: 5,
  y: 35,
});
topGroup.add(counter);

// "add more bunnies" button
var button = new Konva.Label({
  x: 5,
  y: 5,
  opacity: 0.75,
});
topGroup.add(button);

button.add(
  new Konva.Tag({
    fill: 'black',
  })
);

button.add(
  new Konva.Text({
    text: 'Push me to add bunnies',
    fontFamily: 'Calibri',
    fontSize: 18,
    padding: 5,
    fill: 'white',
  })
);

// draggable circle to show interactivity
var circle = new Konva.Circle({
  x: stage.width() / 2,
  y: stage.height() / 2,
  radius: 20,
  fill: 'red',
  draggable: true,
});
topGroup.add(circle);

self.onmessage = function (evt) {
  // when canvas is passes we can start our worker
  if (evt.data.canvas) {
    var canvas = evt.data.canvas;
    stage.setSize({
      width: canvas.width,
      height: canvas.height,
    });

    const ctx = canvas.getContext('2d');

    layer.on('draw', () => {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(layer.getCanvas()._canvas, 0, 0);
    });
  }
  // emulate some drag&drop events
  if (evt.data.eventName === 'mouseup') {
    Konva.DD._endDragBefore(evt.data.event);
  }
  if (evt.data.eventName === 'touchend') {
    Konva.DD._endDragBefore(evt.data.event);
  }
  if (evt.data.eventName === 'mousemove') {
    Konva.DD._drag(evt.data.event);
  }
  if (evt.data.eventName === 'touchmove') {
    Konva.DD._drag(evt.data.event);
  }
  if (evt.data.eventName === 'mouseup') {
    Konva.DD._endDragAfter(evt.data.event);
  }
  if (evt.data.eventName === 'touchend') {
    Konva.DD._endDragAfter(evt.data.event);
  }

  // pass incoming events into the stage
  if (evt.data.eventName) {
    const event = evt.data.eventName.replace('mouse', 'pointer');
    stage['_' + event](evt.data.event);
  }
};

----------------------------------------

TITLE: Creating a Custom Shape in Konva
DESCRIPTION: This example shows how to create a custom shape in Konva using the Shape class and a custom drawing function. It demonstrates the flexibility of Konva in creating complex shapes.

LANGUAGE: javascript
CODE:
var triangle = new Konva.Shape({
  sceneFunc: function (context) {
    context.beginPath();
    context.moveTo(20, 50);
    context.lineTo(220, 80);
    context.quadraticCurveTo(150, 100, 260, 170);
    context.closePath();

    // special Konva.js method
    context.fillStrokeShape(this);
  },
  fill: '#00D2FF',
  stroke: 'black',
  strokeWidth: 4,
});

----------------------------------------

TITLE: Implementing Free Drawing with Konva Nodes in Vanilla JavaScript
DESCRIPTION: This snippet demonstrates how to create a free drawing tool using Konva nodes in vanilla JavaScript. It sets up a stage, layer, and event listeners for mouse/touch interactions to draw lines.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

// create tool select
const select = document.createElement('select');
select.innerHTML = `
  <option value="brush">Brush</option>
  <option value="eraser">Eraser</option>
`;
document.body.appendChild(select);

const width = window.innerWidth;
const height = window.innerHeight - 25;

// first we need Konva core things: stage and layer
const stage = new Konva.Stage({
  container: 'container',
  width: width,
  height: height,
});

const layer = new Konva.Layer();
stage.add(layer);

let isPaint = false;
let mode = 'brush';
let lastLine;

stage.on('mousedown touchstart', function (e) {
  isPaint = true;
  const pos = stage.getPointerPosition();
  lastLine = new Konva.Line({
    stroke: '#df4b26',
    strokeWidth: 5,
    globalCompositeOperation:
      mode === 'brush' ? 'source-over' : 'destination-out',
    // round cap for smoother lines
    lineCap: 'round',
    lineJoin: 'round',
    // add point twice, so we have some drawings even on a simple click
    points: [pos.x, pos.y, pos.x, pos.y],
  });
  layer.add(lastLine);
});

stage.on('mouseup touchend', function () {
  isPaint = false;
});

// and core function - drawing
stage.on('mousemove touchmove', function (e) {
  if (!isPaint) {
    return;
  }

  // prevent scrolling on touch devices
  e.evt.preventDefault();

  const pos = stage.getPointerPosition();
  const newPoints = lastLine.points().concat([pos.x, pos.y]);
  lastLine.points(newPoints);
});

select.addEventListener('change', function () {
  mode = select.value;
});

----------------------------------------

TITLE: Implementing Wheel of Fortune Game with Konva.js
DESCRIPTION: This code creates an interactive Wheel of Fortune game using Konva.js. It handles wheel creation, user input for spinning, animation, and prize determination. The game includes features like gradual slowdown, touch support, and visual feedback.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

Konva.angleDeg = false;
let angularVelocity = 6;
const angularVelocities = [];
let lastRotation = 0;
let controlled = false;
const numWedges = 25;
const angularFriction = 0.2;
let target, activeWedge, stage, layer, wheel, pointer;
let finished = false;

function getAverageAngularVelocity() {
  const total = angularVelocities.reduce((sum, vel) => sum + vel, 0);
  return angularVelocities.length ? total / angularVelocities.length : 0;
}

function purifyColor(color) {
  const randIndex = Math.round(Math.random() * 3);
  color[randIndex] = 0;
  return color;
}

function getRandomColor() {
  const r = 100 + Math.round(Math.random() * 55);
  const g = 100 + Math.round(Math.random() * 55);
  const b = 100 + Math.round(Math.random() * 55);
  return purifyColor([r, g, b]);
}

function getRandomReward() {
  const mainDigit = Math.round(Math.random() * 9);
  return mainDigit + '\n0\n0';
}

function addWedge(n) {
  const s = getRandomColor();
  const reward = getRandomReward();
  const [r, g, b] = s;
  const angle = (2 * Math.PI) / numWedges;

  const endColor = `rgb(${r},${g},${b})`;
  const startColor = `rgb(${r + 100},${g + 100},${b + 100})`;

  const wedge = new Konva.Group({
    rotation: (2 * n * Math.PI) / numWedges,
  });

  const wedgeBackground = new Konva.Wedge({
    radius: 400,
    angle: angle,
    fillRadialGradientStartPoint: 0,
    fillRadialGradientStartRadius: 0,
    fillRadialGradientEndPoint: 0,
    fillRadialGradientEndRadius: 400,
    fillRadialGradientColorStops: [0, startColor, 1, endColor],
    fill: '#64e9f8',
    fillPriority: 'radial-gradient',
    stroke: '#ccc',
    strokeWidth: 2,
  });

  wedge.add(wedgeBackground);

  const text = new Konva.Text({
    text: reward,
    fontFamily: 'Calibri',
    fontSize: 50,
    fill: 'white',
    align: 'center',
    stroke: 'yellow',
    strokeWidth: 1,
    rotation: (Math.PI + angle) / 2,
    x: 380,
    y: 30,
    listening: false,
  });

  wedge.add(text);
  text.cache();

  wedge.startRotation = wedge.rotation();
  wheel.add(wedge);
}

function animate(frame) {
  // handle wheel spin
  const angularVelocityChange =
    (angularVelocity * frame.timeDiff * (1 - angularFriction)) / 1000;
  angularVelocity -= angularVelocityChange;

  // activate / deactivate wedges based on point intersection
  const shape = stage.getIntersection({
    x: stage.width() / 2,
    y: 100,
  });

  if (controlled) {
    if (angularVelocities.length > 10) {
      angularVelocities.shift();
    }

    angularVelocities.push(
      ((wheel.rotation() - lastRotation) * 1000) / frame.timeDiff
    );
  } else {
    const diff = (frame.timeDiff * angularVelocity) / 1000;
    if (diff > 0.0001) {
      wheel.rotate(diff);
    } else if (!finished && !controlled) {
      if (shape) {
        const text = shape.getParent().findOne('Text').text();
        const price = text.split('\n').join('');
        alert('Your price is ' + price);
      }
      finished = true;
    }
  }
  lastRotation = wheel.rotation();

  if (shape && (!activeWedge || shape._id !== activeWedge._id)) {
    pointer.y(20);

    new Konva.Tween({
      node: pointer,
      duration: 0.3,
      y: 30,
      easing: Konva.Easings.ElasticEaseOut,
    }).play();

    if (activeWedge) {
      activeWedge.fillPriority('radial-gradient');
    }
    shape.fillPriority('fill');
    activeWedge = shape;
  }
}

stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: 400,
});

layer = new Konva.Layer();
wheel = new Konva.Group({
  x: stage.width() / 2,
  y: 410,
});

for (let n = 0; n < numWedges; n++) {
  addWedge(n);
}

pointer = new Konva.Wedge({
  fillRadialGradientStartPoint: 0,
  fillRadialGradientStartRadius: 0,
  fillRadialGradientEndPoint: 0,
  fillRadialGradientEndRadius: 30,
  fillRadialGradientColorStops: [0, 'white', 1, 'red'],
  stroke: 'white',
  strokeWidth: 2,
  lineJoin: 'round',
  angle: 1,
  radius: 30,
  x: stage.width() / 2,
  y: 33,
  rotation: -90,
  shadowColor: 'black',
  shadowOffsetX: 3,
  shadowOffsetY: 3,
  shadowBlur: 2,
  shadowOpacity: 0.5,
});

// add components to the stage
layer.add(wheel);
layer.add(pointer);
stage.add(layer);

// bind events
wheel.on('mousedown touchstart', function (evt) {
  angularVelocity = 0;
  controlled = true;
  target = evt.target;
  finished = false;
});

stage.on('mouseup touchend', function () {
  controlled = false;
  angularVelocity = getAverageAngularVelocity() * 5;

  if (angularVelocity > 20) {
    angularVelocity = 20;
  } else if (angularVelocity < -20) {
    angularVelocity = -20;
  }

  angularVelocities.length = 0;
});

stage.on('mousemove touchmove', function () {
  const mousePos = stage.getPointerPosition();
  if (controlled && mousePos && target) {
    const x = mousePos.x - wheel.getX();
    const y = mousePos.y - wheel.getY();
    const atan = Math.atan(y / x);
    const rotation = x >= 0 ? atan : atan + Math.PI;

    wheel.rotation(rotation);
  }
});

// create animation
const anim = new Konva.Animation(animate, layer);
anim.start();

----------------------------------------

TITLE: Creating a Konva Stage
DESCRIPTION: Constructor for creating a new Konva Stage instance which will contain multiple layers. Takes a configuration object with properties like container, dimensions, and other attributes.

LANGUAGE: javascript
CODE:
new Konva.Stage(config)

----------------------------------------

TITLE: Implementing Batch Draw with React and Konva
DESCRIPTION: Shows how to implement batch drawing optimization in a React application using react-konva. Uses refs to access Konva nodes and implements the same rotating rectangle functionality with React hooks.

LANGUAGE: javascript
CODE:
import { Stage, Layer, Rect } from 'react-konva';
import { useRef, useEffect } from 'react';

// For demo purposes, disable auto draw
Konva.autoDrawEnabled = false;

const App = () => {
  const rectRef = useRef(null);
  const layerRef = useRef(null);

  useEffect(() => {
    const stage = rectRef.current.getStage();
    
    stage.on('mousemove', () => {
      // rotate rectangle on mouse move
      rectRef.current.rotate(5);
      // use batchDraw instead of draw for better performance
      layerRef.current.getLayer().batchDraw();
    });
  }, []);

  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer ref={layerRef}>
        <Rect
          ref={rectRef}
          x={window.innerWidth / 2 - 50}
          y={window.innerHeight / 2 - 25}
          width={100}
          height={50}
          fill="green"
          stroke="black"
          strokeWidth={4}
        />
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Optimizing Canvas Animation with Vanilla JavaScript and Konva
DESCRIPTION: Demonstrates optimal animation patterns using Konva.Animation with shape caching for complex shapes and efficient property updates. Creates an animated star and circle with toggle functionality.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight,
});

const layer = new Konva.Layer();
stage.add(layer);

// Create a complex star shape
const star = new Konva.Star({
  x: stage.width() / 2,
  y: stage.height() / 2,
  numPoints: 6,
  innerRadius: 40,
  outerRadius: 70,
  fill: 'yellow',
  stroke: 'black',
  strokeWidth: 4,
});

// Cache the shape for better performance
star.cache();
layer.add(star);

// Create simple circle that doesn't need caching
const circle = new Konva.Circle({
  x: 100,
  y: 100,
  radius: 20,
  fill: 'red',
});
layer.add(circle);

// Create optimized animation
const anim = new Konva.Animation((frame) => {
  // Rotate star (cached shape)
  star.rotation(frame.time * 0.1);
  
  // Move circle in a circle pattern
  circle.x(100 + Math.cos(frame.time * 0.002) * 50);
  circle.y(100 + Math.sin(frame.time * 0.002) * 50);
}, layer);

// Add start/stop button
const button = document.createElement('button');
button.textContent = 'Toggle Animation';
button.style.position = 'absolute';
button.style.top = '10px';
button.style.left = '10px';
document.body.appendChild(button);

let isPlaying = true;
button.addEventListener('click', () => {
  if (isPlaying) {
    anim.stop();
    button.textContent = 'Start Animation';
  } else {
    anim.start();
    button.textContent = 'Stop Animation';
  }
  isPlaying = !isPlaying;
});

anim.start();

----------------------------------------

TITLE: Initializing and Managing Canvas State with Vanilla JavaScript
DESCRIPTION: This snippet demonstrates how to create, update, and manage the state of a Konva canvas using vanilla JavaScript. It includes functionality for adding images, applying filters, and implementing undo/redo operations.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

// Initial state
let state = {
  images: [
    { x: 50, y: 50, filter: 'none' },
    { x: 150, y: 50, filter: 'blur' }
  ]
};

// History for undo/redo
const history = [JSON.stringify(state)];
let historyStep = 0;

const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight,
});

const layer = new Konva.Layer();
stage.add(layer);

// Create UI buttons
const addButton = document.createElement('button');
addButton.textContent = 'Add Image';
document.body.appendChild(addButton);

const undoButton = document.createElement('button');
undoButton.textContent = 'Undo';
document.body.appendChild(undoButton);

const redoButton = document.createElement('button');
redoButton.textContent = 'Redo';
document.body.appendChild(redoButton);

// Load image
const imageObj = new Image();
imageObj.src = '/assets/lion.png';

function createImage(imageConfig) {
  const image = new Konva.Image({
    image: imageObj,
    x: imageConfig.x,
    y: imageConfig.y,
    width: 100,
    height: 100,
    draggable: true
  });

  if (imageConfig.filter === 'blur') {
    image.filters([Konva.Filters.Blur]);
    image.blurRadius(10);
  }

  return image;
}

function create(state) {
  layer.destroyChildren();
  
  state.images.forEach(imgConfig => {
    const image = createImage(imgConfig);
    
    image.on('dragend', () => {
      const pos = image.position();
      const index = layer.children.indexOf(image);
      state.images[index] = {
        ...state.images[index],
        x: pos.x,
        y: pos.y
      };
      saveHistory();
    });

    image.on('click', () => {
      const index = layer.children.indexOf(image);
      state.images[index] = {
        ...state.images[index],
        filter: state.images[index].filter === 'none' ? 'blur' : 'none'
      };
      saveHistory();
      create(state);
    });

    layer.add(image);
  });
}

function saveHistory() {
  historyStep++;
  history.length = historyStep;
  history.push(JSON.stringify(state));
}

addButton.addEventListener('click', () => {
  state.images.push({
    x: Math.random() * stage.width(),
    y: Math.random() * stage.height(),
    filter: 'none'
  });
  saveHistory();
  create(state);
});

undoButton.addEventListener('click', () => {
  if (historyStep === 0) return;
  historyStep--;
  state = JSON.parse(history[historyStep]);
  create(state);
});

redoButton.addEventListener('click', () => {
  if (historyStep === history.length - 1) return;
  historyStep++;
  state = JSON.parse(history[historyStep]);
  create(state);
});

imageObj.onload = () => {
  create(state);
};

----------------------------------------

TITLE: Implementing Konva Performance Optimizations in Vanilla JavaScript
DESCRIPTION: This snippet demonstrates various performance optimizations in Konva using vanilla JavaScript. It includes creating a stage with optimized settings, using layers with performance enhancements, shape caching, and optimizing drag operations.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

// Create stage with good performance settings
const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight,
});

// Create layers with performance optimizations
const backgroundLayer = new Konva.Layer({ listening: false });
const mainLayer = new Konva.Layer();
const dragLayer = new Konva.Layer();

stage.add(backgroundLayer);
stage.add(mainLayer);
stage.add(dragLayer);

// Create a shape with caching
const star = new Konva.Star({
  x: 200,
  y: 200,
  numPoints: 6,
  innerRadius: 40,
  outerRadius: 70,
  fill: 'yellow',
  stroke: 'black',
  strokeWidth: 4,
  draggable: true,
  perfectDrawEnabled: false, // performance optimization
});

// Cache the shape for better performance
star.cache();

// Optimize dragging performance
star.on('dragstart', () => {
  star.moveTo(dragLayer);
});

star.on('dragend', () => {
  star.moveTo(mainLayer);
});

// Create background with listening disabled
const rect = new Konva.Rect({
  x: 0,
  y: 0,
  width: stage.width(),
  height: stage.height(),
  fill: 'lightgray',
  listening: false,
});

backgroundLayer.add(rect);
mainLayer.add(star);

----------------------------------------

TITLE: Implementing Draggable Stars with React Konva Events
DESCRIPTION: Creates an interactive canvas with draggable star shapes using React Konva. The example demonstrates event handling for drag operations with visual feedback including shadow and scale effects. Uses React useState for state management and implements dragstart and dragend event handlers.

LANGUAGE: jsx
CODE:
import React from 'react';
import { Stage, Layer, Star, Text } from 'react-konva';

function generateShapes() {
  return [...Array(10)].map((_, i) => ({
    id: i.toString(),
    x: Math.random() * window.innerWidth,
    y: Math.random() * window.innerHeight,
    rotation: Math.random() * 180,
    isDragging: false,
  }));
}

const App = () => {
  const [stars, setStars] = React.useState(generateShapes());

  const handleDragStart = (e) => {
    const id = e.target.id();
    setStars(
      stars.map((star) => {
        return {
          ...star,
          isDragging: star.id === id,
        };
      })
    );
  };

  const handleDragEnd = (e) => {
    setStars(
      stars.map((star) => {
        return {
          ...star,
          isDragging: false,
        };
      })
    );
  };

  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        <Text text="Try to drag a star" />
        {stars.map((star) => (
          <Star
            key={star.id}
            id={star.id}
            x={star.x}
            y={star.y}
            numPoints={5}
            innerRadius={20}
            outerRadius={40}
            fill="#89b717"
            opacity={0.8}
            draggable
            rotation={star.rotation}
            shadowColor="black"
            shadowBlur={10}
            shadowOpacity={0.6}
            shadowOffsetX={star.isDragging ? 10 : 5}
            shadowOffsetY={star.isDragging ? 10 : 5}
            scaleX={star.isDragging ? 1.2 : 1}
            scaleY={star.isDragging ? 1.2 : 1}
            onDragStart={handleDragStart}
            onDragEnd={handleDragEnd}
          />
        ))}
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Implementing Image Events with Konva in React
DESCRIPTION: This snippet shows how to create image events in Konva using React. It demonstrates the use of hooks for state management and refs for accessing Konva nodes, as well as implementing precise hit detection for transparent areas.

LANGUAGE: jsx
CODE:
import { Stage, Layer, Image, Text } from 'react-konva';
import { useState, useEffect } from 'react';

const App = () => {
  const [message, setMessage] = useState('');
  const monkeyRef = useRef();
  const lionRef = useRef();
  const [monkeyImage] = useImage('https://konvajs.org/assets/monkey.png');
  const [lionImage] = useImage('https://konvajs.org/assets/lion.png');

  useEffect(() => {
    if (lionImage) {
    lionRef.current.cache();
      lionRef.current.drawHitFromCache();
    }
  }, [lionImage]);

  useEffect(() => {
    if (monkeyImage) {
      monkeyRef.current.cache();
      monkeyRef.current.drawHitFromCache();
    }
  }, [monkeyImage]);

  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        <Text
          x={10}
          y={10}
          fontFamily="Calibri"
          fontSize={24}
          text={message}
          fill="black"
        />
        {monkeyImage && (
          <Image
            x={120}
            y={50}
            image={monkeyImage}
            ref={monkeyRef}
            width={200}
            height={200}
            onMouseover={() => setMessage('mouseover monkey (regular image)')}
            onMouseout={() => setMessage('')}
          />
        )}
        {lionImage && (
          <Image
            x={320}
            y={50}
            image={lionImage}
            width={200}
            height={200}
            ref={lionRef}
            onMouseover={() =>
              setMessage('mouseover lion (with transparent pixels detection)')
            }
            onMouseout={() => setMessage('')}
          />
        )}
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Vanilla JavaScript Konva.js Game Implementation
DESCRIPTION: Classic JavaScript implementation using Konva.js to create a drag-and-drop game. Handles image loading, drag events, collision detection, and game state management. Uses anonymous functions for scope handling and includes glow effects on hover.

LANGUAGE: javascript
CODE:
const stage = new Konva.Stage({
  container: 'container',
  width: 578,
  height: 530,
});
// ... [rest of vanilla JS implementation]

----------------------------------------

TITLE: Implementing Shape Groups with Vue-Konva
DESCRIPTION: Creates a draggable group containing a circle and rectangle using Vue-Konva components. Demonstrates configuration-based approach to creating shapes and groups in Vue.

LANGUAGE: javascript
CODE:
<template>
  <v-stage :config="stageSize">
    <v-layer>
      <v-group :config="groupConfig">
        <v-circle :config="circleConfig" />
        <v-rect :config="rectConfig" />
      </v-group>
    </v-layer>
  </v-stage>
</template>

<script setup>
const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight
};

const groupConfig = {
  x: 50,
  y: 50,
  draggable: true
};

const circleConfig = {
  x: 40,
  y: 40,
  radius: 30,
  fill: 'red',
  stroke: 'black',
  strokeWidth: 4
};

const rectConfig = {
  x: 80,
  y: 20,
  width: 100,
  height: 50,
  fill: 'green',
  stroke: 'black',
  strokeWidth: 4
};
</script>

----------------------------------------

TITLE: Creating Basic Shapes with React-Konva
DESCRIPTION: This code snippet demonstrates how to create a Stage with a Layer containing various shapes including Text, Rectangle, Circle, and Line using react-konva components. It showcases different styling options such as fill colors, shadows, and gradients.

LANGUAGE: jsx
CODE:
import React from 'react';
import { Stage, Layer, Rect, Text, Circle, Line } from 'react-konva';

const App = () => {
  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        <Text text="Some text on canvas" fontSize={15} />
        <Rect
          x={20}
          y={50}
          width={100}
          height={100}
          fill="red"
          shadowBlur={10}
        />
        <Circle x={200} y={100} radius={50} fill="green" />
        <Line
          x={20}
          y={200}
          points={[0, 0, 100, 0, 100, 100]}
          tension={0.5}
          closed
          stroke="black"
          fillLinearGradientStartPoint={{ x: -50, y: -50 }}
          fillLinearGradientEndPoint={{ x: 50, y: 50 }}
          fillLinearGradientColorStops={[0, 'red', 1, 'yellow']}
        />
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Rendering 20,000 Interactive Nodes with Vue and Konva
DESCRIPTION: This Vue component creates an interactive scatter plot with 20,000 draggable circles using vue-konva. It demonstrates efficient rendering and event handling in a Vue environment.

LANGUAGE: javascript
CODE:
<template>
  <v-stage :config="stageConfig" @mousedown="handleStageMouseDown" @mouseup="handleStageMouseUp">
    <v-layer ref="circlesLayerRef">
      <v-circle
        v-for="node in nodes"
        :key="node.id"
        :config="{
          x: node.x,
          y: node.y,
          radius: 4,
          fill: node.color,
          id: node.id
        }"
        @mouseover="handleMouseOver($event, node)"
        @mousemove="handleMouseMove"
        @mouseout="handleMouseOut"
        @dragmove="handleMouseMove"
      />
    </v-layer>
    <v-layer ref="dragLayerRef"></v-layer>
    <v-layer>
      <v-label
        :config="{
          x: tooltip.x,
          y: tooltip.y,
          opacity: 0.75,
          visible: tooltip.visible
        }"
      >
        <v-tag
          :config="{
            fill: 'black',
            pointerDirection: 'down',
            pointerWidth: 10,
            pointerHeight: 10,
            lineJoin: 'round',
            shadowColor: 'black',
            shadowBlur: 10,
            shadowOffsetX: 10,
            shadowOffsetY: 10,
            shadowOpacity: 0.2
          }"
        />
        <v-text
          :config="{
            text: tooltip.text,
            fontFamily: 'Calibri',
            fontSize: 18,
            padding: 5,
            fill: 'white'
          }"
        />
      </v-label>
    </v-layer>
  </v-stage>
</template>

<script setup>
import { ref, computed, onMounted, reactive } from 'vue';

const width = window.innerWidth;
const height = window.innerHeight;

const stageConfig = {
  width: width,
  height: height
};

// For tooltip handling
const tooltip = reactive({
  visible: false,
  x: 0,
  y: 0,
  text: ''
});

// Store all nodes in a single array - not reactive after initial setup
const nodes = ref([]);
const circlesLayerRef = ref(null);
const dragLayerRef = ref(null);

// This key only changes when the nodes data changes, preventing unnecessary re-renders
const circlesKey = ref(0);

onMounted(() => {
  const colors = ['red', 'orange', 'cyan', 'green', 'blue', 'purple'];
  const data = [];
  
  for (let n = 0; n < 20000; n++) {
    const x = Math.random() * width;
    const y = height + Math.random() * 200 - 100 + (height / width) * -1 * x;
    data.push({
      x: x,
      y: y,
      id: n.toString(),
      color: colors[Math.round(Math.random() * 5)],
    });
  }
  
  // Set the nodes once and increment the key to trigger a single render
  nodes.value = data;
  circlesKey.value++;
});

function handleMouseOver(e, node) {
  const stage = e.target.getStage();
  const pos = stage.getPointerPosition();
  
  tooltip.visible = true;
  tooltip.x = pos.x;
  tooltip.y = pos.y - 5;
  tooltip.text = `node: ${node.id}, color: ${node.color}`;
}

function handleMouseMove(e) {
  const stage = e.target.getStage();
  const pos = stage.getPointerPosition();
  
  if (tooltip.visible) {
    tooltip.x = pos.x;
    tooltip.y = pos.y - 5;
  }
}

function handleMouseOut() {
  tooltip.visible = false;
}

// Drag and drop handlers that use the native Konva API
function handleStageMouseDown(e) {
  // Get the target shape
  const shape = e.target;
  // Only process if it's not the stage itself
  if (shape && shape !== e.target.getStage()) {
    // Store reference to the original layer for later
    shape._originalLayer = shape.getParent();
    
    // Move the shape to the drag layer manually using Konva's API
    // This avoids Vue's reactivity system during the drag
    if (dragLayerRef.value && dragLayerRef.value.getNode()) {
      shape.moveTo(dragLayerRef.value.getNode());
      // Start the drag operation
      shape.startDrag();
    }
  }
}

function handleStageMouseUp(e) {
  // Get the target shape
  const shape = e.target;
  // Only process if it's not the stage itself
  if (shape && shape !== e.target.getStage()) {
    // Move back to original layer if we have that reference
    if (shape._originalLayer) {
      shape.moveTo(shape._originalLayer);
      // Clear the reference
      shape._originalLayer = null;
    }
  }
}
</script>

----------------------------------------

TITLE: Optimizing Performance in Konva with Caching
DESCRIPTION: This example demonstrates how to use caching in Konva to improve performance. Caching complex shapes or groups can significantly reduce rendering time, especially for static elements.

LANGUAGE: javascript
CODE:
shape.cache();

----------------------------------------

TITLE: Drawing Basic Shapes with vue-konva in Vue
DESCRIPTION: Demonstrates creating a stage with multiple shapes including text, rectangle, circle, and line with gradient. Shows how to configure shape properties like position, size, fill color, and shadows using vue-konva components.

LANGUAGE: vue
CODE:
<template>
  <v-stage :config="stageSize">
    <v-layer>
      <v-text :config="{
        text: 'Some text on canvas',
        fontSize: 15
      }"/>
      <v-rect :config="{
        x: 20,
        y: 50,
        width: 100,
        height: 100,
        fill: 'red',
        shadowBlur: 10
      }"/>
      <v-circle :config="{
        x: 200,
        y: 100,
        radius: 50,
        fill: 'green'
      }"/>
      <v-line :config="{
        x: 20,
        y: 200,
        points: [0, 0, 100, 0, 100, 100],
        tension: 0.5,
        closed: true,
        stroke: 'black',
        fillLinearGradientStartPoint: { x: -50, y: -50 },
        fillLinearGradientEndPoint: { x: 50, y: 50 },
        fillLinearGradientColorStops: [0, 'red', 1, 'yellow']
      }"/>
    </v-layer>
  </v-stage>
</template>

<script setup>
const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight
};
</script>

----------------------------------------

TITLE: Creating Elastic Stars with Vanilla JavaScript and Konva
DESCRIPTION: Implements draggable star shapes with elastic animation effects using vanilla JavaScript and Konva. Stars are randomly positioned with shadow effects and respond to drag events with scaling and shadow adjustments.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const width = window.innerWidth;
const height = window.innerHeight;

let tween = null;

function addStar(layer, stage) {
  const scale = Math.random();

  const star = new Konva.Star({
    x: Math.random() * stage.width(),
    y: Math.random() * stage.height(),
    numPoints: 5,
    innerRadius: 30,
    outerRadius: 50,
    fill: '#89b717',
    opacity: 0.8,
    draggable: true,
    scale: {
      x: scale,
      y: scale,
    },
    rotation: Math.random() * 180,
    shadowColor: 'black',
    shadowBlur: 10,
    shadowOffset: {
      x: 5,
      y: 5,
    },
    shadowOpacity: 0.6,
    startScale: scale,
  });

  layer.add(star);
}

const stage = new Konva.Stage({
  container: 'container',
  width: width,
  height: height,
});

const layer = new Konva.Layer();

for (let n = 0; n < 10; n++) {
  addStar(layer, stage);
}

stage.add(layer);

stage.on('dragstart', function (evt) {
  const shape = evt.target;
  if (tween) {
    tween.pause();
  }
  shape.setAttrs({
    shadowOffset: {
      x: 15,
      y: 15,
    },
    scale: {
      x: shape.getAttr('startScale') * 1.2,
      y: shape.getAttr('startScale') * 1.2,
    },
  });
});

stage.on('dragend', function (evt) {
  const shape = evt.target;

  tween = new Konva.Tween({
    node: shape,
    duration: 0.5,
    easing: Konva.Easings.ElasticEaseOut,
    scaleX: shape.getAttr('startScale'),
    scaleY: shape.getAttr('startScale'),
    shadowOffsetX: 5,
    shadowOffsetY: 5,
  });

  tween.play();
});

----------------------------------------

TITLE: Implementing 10k Shapes with Tooltips in React using react-konva
DESCRIPTION: React implementation using react-konva components to create 10,000 circles with tooltips. Uses React state management and hooks for handling tooltip visibility and position.

LANGUAGE: javascript
CODE:
const App = () => {
  const [tooltipProps, setTooltipProps] = React.useState({
    text: '',
    visible: false,
    x: 0,
    y: 0
  });

  const colors = ['red', 'orange', 'yellow', 'green', 'blue', 'cyan', 'purple'];
  const circles = React.useMemo(() => {
    const items = [];
    let colorIndex = 0;
    
    for (let i = 0; i < 10000; i++) {
      const color = colors[colorIndex++];
      if (colorIndex >= colors.length) {
        colorIndex = 0;
      }
      
      items.push({
        id: i,
        x: Math.random() * window.innerWidth,
        y: Math.random() * window.innerHeight,
        color
      });
    }
    return items;
  }, []);

  const handleMouseMove = (e) => {
    const mousePos = e.target.getStage().getPointerPosition();
    setTooltipProps({
      text: `node: ${e.target.name()}, color: ${e.target.attrs.fill}`,
      visible: true,
      x: mousePos.x + 5,
      y: mousePos.y + 5
    });
  };

  const handleMouseOut = () => {
    setTooltipProps(prev => ({ ...prev, visible: false }));
  };

  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer onMouseMove={handleMouseMove} onMouseOut={handleMouseOut}>
        {circles.map(({ id, x, y, color }) => (
          <Circle
            key={id}
            x={x}
            y={y}
            radius={3}
            fill={color}
            name={id.toString()}
          />
        ))}
      </Layer>
      <Layer>
        <Text
          {...tooltipProps}
          fontFamily="Calibri"
          fontSize={12}
          padding={5}
          fill="black"
          opacity={0.75}
        />
      </Layer>
    </Stage>
  );

----------------------------------------

TITLE: Serializing and Deserializing Konva Objects
DESCRIPTION: This snippet shows how to serialize Konva objects to JSON and deserialize them back into Konva objects. This is useful for saving and restoring the state of a Konva application.

LANGUAGE: javascript
CODE:
var json = stage.toJSON();

// Deserializing
var json = '{"attrs":{"width":578,"height":200},"className":"Stage","children":[{"attrs":{},"className":"Layer","children":[{"attrs":{"x":100,"y":100,"sides":6,"radius":70,"fill":"red","stroke":"black","strokeWidth":4},"className":"RegularPolygon"}]}]}';

var stage = Konva.Node.create(json, 'container');

----------------------------------------

TITLE: Animating GIF on Canvas using Konva and gifler (Vanilla JavaScript)
DESCRIPTION: This snippet demonstrates how to render an animated GIF on a Konva canvas using vanilla JavaScript. It uses the gifler library to parse the GIF and draw each frame onto a canvas, which is then used as the source for a Konva.Image shape.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

// Load gifler library
const script = document.createElement('script');
script.src = 'https://unpkg.com/gifler@0.1.0/gifler.min.js';
document.head.appendChild(script);

const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight,
});

const layer = new Konva.Layer();
stage.add(layer);

const canvas = document.createElement('canvas');

// use external library to parse and draw gif animation
function onDrawFrame(ctx, frame) {
  // update canvas size
  canvas.width = frame.width;
  canvas.height = frame.height;
  // update canvas that we are using for Konva.Image
  ctx.drawImage(frame.buffer, 0, 0);
  // redraw the layer
  layer.draw();
}

script.onload = () => {
  gifler('https://konvajs.org/assets/yoda.gif').frames(canvas, onDrawFrame);
};

// draw resulted canvas into the stage as Konva.Image
const image = new Konva.Image({
  image: canvas,
});
layer.add(image);

----------------------------------------

TITLE: Enabling Drag and Drop in Konva
DESCRIPTION: This snippet shows how to enable drag and drop functionality for a Konva shape by setting the draggable property. It demonstrates the simplicity of implementing drag and drop in Konva.

LANGUAGE: javascript
CODE:
shape.draggable('true');

----------------------------------------

TITLE: Creating Animations in Konva using Konva.Tween
DESCRIPTION: This snippet shows how to create animations in Konva using the Konva.Tween class. It demonstrates how to animate properties of shapes smoothly over a specified duration.

LANGUAGE: javascript
CODE:
var tween = new Konva.Tween({
  node: rect,
  duration: 1,
  x: 140,
  rotation: Math.PI * 2,
  opacity: 1,
  strokeWidth: 6,
});
tween.play();

// or new shorter method:
circle.to({
  duration: 1,
  fill: 'green',
});

----------------------------------------

TITLE: Building Map Implementation - Vanilla JavaScript
DESCRIPTION: Creates an interactive building map using vanilla JavaScript and Konva. Displays different floors and areas with hover effects and tooltips. Uses layers for background image, interactive shapes, and tooltip overlay.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

function getData() {
  return {
    '1st Floor': {
      color: 'blue',
      points: [366, 298, 500, 284, 499, 204, 352, 183, 72, 228, 74, 274],
    },
    '2nd Floor': {
      color: 'red',
      points: [72, 228, 73, 193, 340, 96, 498, 154, 498, 191, 341, 171],
    },
    '3rd Floor': {
      color: 'yellow',
      points: [73, 192, 73, 160, 340, 23, 500, 109, 499, 139, 342, 93],
    },
    Gym: {
      color: 'green',
      points: [498, 283, 503, 146, 560, 136, 576, 144, 576, 278, 500, 283],
    },
  };
}

// ... rest of vanilla implementation

----------------------------------------

TITLE: Implementing Draggable Circle with Konva in Vanilla JavaScript
DESCRIPTION: This snippet creates a draggable red circle using Konva in vanilla JavaScript. It sets up a stage, layer, and circle, makes the circle draggable, and adds cursor styling on mouseover and mouseout events.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight,
});

const layer = new Konva.Layer();
stage.add(layer);

const circle = new Konva.Circle({
  x: stage.width() / 2,
  y: stage.height() / 2,
  radius: 70,
  fill: 'red',
  stroke: 'black',
  strokeWidth: 4,
  draggable: true,
});

// add cursor styling
circle.on('mouseover', function () {
  document.body.style.cursor = 'pointer';
});
circle.on('mouseout', function () {
  document.body.style.cursor = 'default';
});

layer.add(circle);

----------------------------------------

TITLE: Implementing Multi-touch Scale in Vanilla JavaScript with Konva
DESCRIPTION: Vanilla JavaScript implementation of multi-touch scaling and panning using Konva. Handles touch events to enable pinch-zoom functionality and stage dragging. Includes utility functions for calculating distances and center points between touch positions.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

Konva.hitOnDragEnabled = true;

const width = window.innerWidth;
const height = window.innerHeight;

const stage = new Konva.Stage({
  container: 'container',
  width: width,
  height: height,
  draggable: true,
});

// ... rest of vanilla implementation

----------------------------------------

TITLE: Implementing Shape Layering with React in Konva
DESCRIPTION: This snippet shows how to create draggable shapes and implement layering controls using React with react-konva. It uses React state to manage the layering order of the shapes and renders buttons to toggle the yellow rectangle's position.

LANGUAGE: jsx
CODE:
import { Stage, Layer, Rect } from 'react-konva';
import { useState } from 'react';

const App = () => {
  const [yellowOnTop, setYellowOnTop] = useState(false);

  return (
    <>
      <button onClick={() => setYellowOnTop(true)}>
        Move yellow box to top
      </button>
      <button onClick={() => setYellowOnTop(false)}>
        Move yellow box to bottom
      </button>
      <Stage width={window.innerWidth} height={window.innerHeight}>
        <Layer>
          {!yellowOnTop && (
            <Rect
              x={100}
              y={100}
              width={100}
              height={100}
              fill="red"
              stroke="black"
              strokeWidth={4}
              draggable
            />
          )}
          <Rect
            x={50}
            y={50}
            width={100}
            height={100}
            fill="yellow"
            stroke="black"
            strokeWidth={4}
            draggable
          />
          {yellowOnTop && (
            <Rect
              x={100}
              y={100}
              width={100}
              height={100}
              fill="red"
              stroke="black"
              strokeWidth={4}
              draggable
            />
          )}
        </Layer>
      </Stage>
    </>
  );
};

export default App;

----------------------------------------

TITLE: Implementing Drag and Drop for Multiple Shapes with Konva in React
DESCRIPTION: This React component creates a Konva stage with multiple draggable colored rectangles. It uses React hooks to manage state and demonstrates how to handle drag events, remove shapes on double-click/tap, and change cursor styles on hover.

LANGUAGE: jsx
CODE:
import { useState } from 'react';
import { Stage, Layer, Rect } from 'react-konva';

const App = () => {
  const colors = ['red', 'orange', 'yellow', 'green', 'blue', 'purple'];
  
  // Initialize boxes with proper IDs and positions
  const initialBoxes = colors.map((color, i) => ({
    id: i.toString(),
    x: i * 30 + 50,
    y: i * 18 + 40,
    width: 100,
    height: 50,
    fill: color,
    stroke: 'black',
    strokeWidth: 4
  }));
  
  const [boxes, setBoxes] = useState(initialBoxes);
  
  const handleDragStart = (e) => {
    // Move the dragged box to the end of the array to simulate moveToTop
    const id = e.target.id();
    const box = boxes.find(b => b.id === id);
    const filteredBoxes = boxes.filter(b => b.id !== id);
    setBoxes([...filteredBoxes, box]);
  };
  
  const handleDragMove = (e) => {
    // Update the position of the box
    const id = e.target.id();
    const newBoxes = boxes.map(box => {
      if (box.id === id) {
        return {
          ...box,
          x: e.target.x(),
          y: e.target.y()
        };
      }
      return box;
    });
    setBoxes(newBoxes);
  };
  
  const handleDoubleClick = (id) => {
    // Remove the box on double click
    setBoxes(boxes.filter(box => box.id !== id));
  };

  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        {boxes.map((box) => (
          <Rect
            key={box.id}
            id={box.id}
            x={box.x}
            y={box.y}
            width={box.width}
            height={box.height}
            fill={box.fill}
            stroke={box.stroke}
            strokeWidth={box.strokeWidth}
            draggable
            onDragStart={handleDragStart}
            onDragMove={handleDragMove}
            onDblClick={() => handleDoubleClick(box.id)}
            onDblTap={() => handleDoubleClick(box.id)}
            onMouseOver={(e) => {
              document.body.style.cursor = 'pointer';
            }}
            onMouseOut={(e) => {
              document.body.style.cursor = 'default';
            }}
          />
        ))}
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Vue Implementation of Canvas Context Menu with Konva
DESCRIPTION: Vue 3 composition API implementation of canvas context menu using vue-konva. Manages state with refs and provides reactive updates for shape manipulation and menu interactions.

LANGUAGE: vue
CODE:
<template>
  <div style="position: relative">
    <v-stage
      ref="stageRef"
      :config="stageConfig"
      @dblclick="handleDblClick"
      @contextmenu="handleContextMenu"
    >
    // ... [rest of Vue implementation]

----------------------------------------

TITLE: KonvaJS Memory Management - React Implementation
DESCRIPTION: Shows memory-safe implementation of KonvaJS in React using react-konva components. Demonstrates proper state management for shape visibility, position, and rotation.

LANGUAGE: javascript
CODE:
import { Stage, Layer, Circle } from 'react-konva';
import { useState } from 'react';

const App = () => {
  const [isVisible, setIsVisible] = useState(true);
  const [position, setPosition] = useState({ x: 100, y: 100 });
  const [rotation, setRotation] = useState(0);

  const handleAdd = () => {
    setIsVisible(true);
  };

  const handleRemove = () => {
    setIsVisible(false);
  };

  const handleAnimate = () => {
    // Update position
    setPosition({
      x: Math.random() * window.innerWidth,
      y: Math.random() * window.innerHeight
    });
    
    // Update rotation
    setRotation(rotation + 360);
  };

  return (
    <div>
      <button onClick={handleAdd} style={{ marginRight: '10px' }}>Add Circle</button>
      <button onClick={handleRemove} style={{ marginRight: '10px' }}>Remove Circle</button>
      <button onClick={handleAnimate}>Animate</button>
      
      <Stage width={window.innerWidth} height={window.innerHeight}>
        <Layer>
          {isVisible && (
            <Circle
              x={position.x}
              y={position.y}
              radius={30}
              fill="red"
              rotation={rotation}
            />
          )}
        </Layer>
      </Stage>
    </div>
  );
};

export default App;

----------------------------------------

TITLE: Implementing Free Drawing with React and Konva
DESCRIPTION: This code snippet demonstrates a complete React component for a free drawing application using Konva. It includes state management for tools and lines, event handlers for mouse/touch interactions, and rendering of the drawing canvas with configurable pen and eraser tools.

LANGUAGE: jsx
CODE:
import React from 'react';
import { Stage, Layer, Line, Text } from 'react-konva';

const App = () => {
  const [tool, setTool] = React.useState('pen');
  const [lines, setLines] = React.useState([]);
  const isDrawing = React.useRef(false);

  const handleMouseDown = (e) => {
    isDrawing.current = true;
    const pos = e.target.getStage().getPointerPosition();
    setLines([...lines, { tool, points: [pos.x, pos.y] }]);
  };

  const handleMouseMove = (e) => {
    // no drawing - skipping
    if (!isDrawing.current) {
      return;
    }
    const stage = e.target.getStage();
    const point = stage.getPointerPosition();
    let lastLine = lines[lines.length - 1];
    // add point
    lastLine.points = lastLine.points.concat([point.x, point.y]);

    // replace last
    lines.splice(lines.length - 1, 1, lastLine);
    setLines(lines.concat());
  };

  const handleMouseUp = () => {
    isDrawing.current = false;
  };

  return (
    <div>
      <select
        value={tool}
        onChange={(e) => {
          setTool(e.target.value);
        }}
      >
        <option value="pen">Pen</option>
        <option value="eraser">Eraser</option>
      </select>
      <Stage
        width={window.innerWidth}
        height={window.innerHeight}
        onMouseDown={handleMouseDown}
        onMousemove={handleMouseMove}
        onMouseup={handleMouseUp}
        onTouchStart={handleMouseDown}
        onTouchMove={handleMouseMove}
        onTouchEnd={handleMouseUp}
      >
        <Layer>
          <Text text="Just start drawing" x={5} y={30} />
          {lines.map((line, i) => (
            <Line
              key={i}
              points={line.points}
              stroke="#df4b26"
              strokeWidth={5}
              tension={0.5}
              lineCap="round"
              lineJoin="round"
              globalCompositeOperation={
                line.tool === 'eraser' ? 'destination-out' : 'source-over'
              }
            />
          ))}
        </Layer>
      </Stage>
    </div>
  );
};

export default App;

----------------------------------------

TITLE: Converting Konva Canvas to PDF - Vue Implementation
DESCRIPTION: Vue 3 implementation of the Konva canvas to PDF export functionality. Uses Vue composition API and vue-konva components to create and manage the stage, with identical PDF export capabilities.

LANGUAGE: vue
CODE:
<template>
  <div style="position: relative">
    <button 
      style="position: absolute; top: 5px; left: 5px; z-index: 10"
      @click="handleExport"
    >
      Save as PDF
    </button>
    
    <v-stage ref="stageRef" :config="stageConfig">
      <v-layer>
        <v-rect :config="backgroundConfig" />
        
        <v-text ref="textRef" :config="textConfig" />
        
        <v-arrow :config="arrowConfig" />
        
        <v-image 
          v-if="darthVaderImage"
          :config="imageConfig" 
        />
      </v-layer>
    </v-stage>
  </div>
</template>

----------------------------------------

TITLE: Rendering 20,000 Interactive Nodes with Vanilla JavaScript and Konva
DESCRIPTION: This snippet creates an interactive scatter plot with 20,000 draggable circles using Konva. It demonstrates efficient rendering, event delegation, and tooltip functionality.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

// create stage
const width = window.innerWidth;
const height = window.innerHeight;

const stage = new Konva.Stage({
  container: 'container',
  width: width,
  height: height,
});

// function to add a node to layer
function addNode(obj, layer) {
  const node = new Konva.Circle({
    x: obj.x,
    y: obj.y,
    radius: 4,
    fill: obj.color,
    id: obj.id,
  });

  layer.add(node);
}

// Create a single layer for all circles
const circlesLayer = new Konva.Layer();
const tooltipLayer = new Konva.Layer();
const dragLayer = new Konva.Layer();

// create tooltip
const tooltip = new Konva.Label({
  opacity: 0.75,
  visible: false,
  listening: false,
});

tooltip.add(
  new Konva.Tag({
    fill: 'black',
    pointerDirection: 'down',
    pointerWidth: 10,
    pointerHeight: 10,
    lineJoin: 'round',
    shadowColor: 'black',
    shadowBlur: 10,
    shadowOffsetX: 10,
    shadowOffsetY: 10,
    shadowOpacity: 0.2,
  })
);

tooltip.add(
  new Konva.Text({
    text: '',
    fontFamily: 'Calibri',
    fontSize: 18,
    padding: 5,
    fill: 'white',
  })
);

tooltipLayer.add(tooltip);

// build data
const data = [];
const colors = ['red', 'orange', 'cyan', 'green', 'blue', 'purple'];

for (let n = 0; n < 20000; n++) {
  const x = Math.random() * width;
  const y = height + Math.random() * 200 - 100 + (height / width) * -1 * x;
  data.push({
    x: x,
    y: y,
    id: n.toString(),
    color: colors[Math.round(Math.random() * 5)],
  });
}

// Add all nodes to a single layer
for (let n = 0; n < data.length; n++) {
  addNode(data[n], circlesLayer);
}

// Add all layers to stage
stage.add(circlesLayer);
stage.add(dragLayer);
stage.add(tooltipLayer);

// handle events
let originalLayer;

stage.on('mouseover mousemove dragmove', function (evt) {
  const node = evt.target;
  if (node === stage) {
    return;
  }
  if (node) {
    // update tooltip
    const mousePos = node.getStage().getPointerPosition();
    tooltip.position({
      x: mousePos.x,
      y: mousePos.y - 5,
    });
    tooltip
      .getText()
      .text('node: ' + node.id() + ', color: ' + node.fill());
    tooltip.show();
  }
});

stage.on('mouseout', function (evt) {
  tooltip.hide();
});

stage.on('mousedown', function (evt) {
  const shape = evt.target;
  if (shape) {
    originalLayer = shape.getLayer();
    shape.moveTo(dragLayer);
    // manually trigger drag and drop
    shape.startDrag();
  }
});

stage.on('mouseup', function (evt) {
  const shape = evt.target;
  if (shape) {
    shape.moveTo(originalLayer);
  }
});

----------------------------------------

TITLE: Implementing Drag-to-Reorder with React-Konva Circles
DESCRIPTION: React component that demonstrates proper z-index management in React-Konva by reordering circles through state manipulation. The example creates draggable circles that move to the top of the visual stack when dragged, achieved by updating the array order in state rather than using zIndex properties.

LANGUAGE: jsx
CODE:
import React, { Component } from 'react';
import Konva from 'konva';
import { Stage, Layer, Circle } from 'react-konva';

function generateItems() {
  const items = [];
  for (let i = 0; i < 10; i++) {
    items.push({
      x: Math.random() * window.innerWidth,
      y: Math.random() * window.innerHeight,
      id: 'node-' + i,
      color: Konva.Util.getRandomColor(),
    });
  }
  return items;
}

const App = () => {
  const [items, setItems] = React.useState(generateItems());

  const handleDragStart = (e) => {
    const id = e.target.name();
    const itemsCopy = items.slice();
    const item = itemsCopy.find((i) => i.id === id);
    const index = itemsCopy.indexOf(item);
    // remove from the list:
    itemsCopy.splice(index, 1);
    // add to the top
    itemsCopy.push(item);
    setItems(itemsCopy);
  };

  const onDragEnd = (e) => {
    const id = e.target.name();
    const itemsCopy = items.slice();
    const item = items.find((i) => i.id === id);
    const index = items.indexOf(item);
    // update item position
    itemsCopy[index] = {
      ...item,
      x: e.target.x(),
      y: e.target.y(),
    };
    setItems(itemsCopy);
  };

  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        {items.map((item) => (
          <Circle
            key={item.id}
            name={item.id}
            draggable
            x={item.x}
            y={item.y}
            fill={item.color}
            radius={50}
            onDragStart={handleDragStart}
            onDragEnd={onDragEnd}
          />
        ))}
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Implementing Custom Border Filter for Images in Konva
DESCRIPTION: This code snippet demonstrates how to create a custom filter in Konva to add a border around non-transparent parts of an image. It uses canvas manipulation and image data processing to achieve the effect. The filter applies a shadow, removes transparency, and then colors the border.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

// Create stage
const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight,
});

const layer = new Konva.Layer();
stage.add(layer);

// Define variables for our custom filter
let canvas = document.createElement('canvas');
let tempCanvas = document.createElement('canvas');

// Make all pixels opaque 100% (except pixels that are 100% transparent)
function removeTransparency(canvas) {
  const ctx = canvas.getContext('2d');
  const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
  const nPixels = imageData.data.length;
  
  for (let i = 3; i < nPixels; i += 4) {
    if (imageData.data[i] > 0) {
      imageData.data[i] = 255;
    }
  }
  
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.putImageData(imageData, 0, 0);
  return canvas;
}

// Define our custom Border filter
function Border(imageData) {
  const nPixels = imageData.data.length;
  const size = this.getAttr('borderSize') || 0;

  // Set correct dimensions for canvases
  canvas.width = imageData.width;
  canvas.height = imageData.height;

  tempCanvas.width = imageData.width;
  tempCanvas.height = imageData.height;

  // Draw original shape into temp canvas
  tempCanvas.getContext('2d').putImageData(imageData, 0, 0);

  // Remove alpha channel because it will affect shadow (transparent shapes have smaller shadow)
  removeTransparency(tempCanvas);

  const ctx = canvas.getContext('2d');
  const color = this.getAttr('borderColor') || 'black';

  // Use shadow as border
  ctx.save();
  ctx.shadowColor = color;
  ctx.shadowBlur = size;
  ctx.drawImage(tempCanvas, 0, 0);
  ctx.restore();

  // Get image data of [original image + shadow]
  const tempImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

  const SMOOTH_MIN_THRESHOLD = 3;
  const SMOOTH_MAX_THRESHOLD = 10;

  let val, hasValue;
  const offset = 3;

  for (let i = 3; i < nPixels; i += 4) {
    // Skip opaque pixels
    if (imageData.data[i] === 255) {
      continue;
    }

    val = tempImageData.data[i];
    hasValue = val !== 0;
    if (!hasValue) {
      continue;
    }
    
    if (val > SMOOTH_MAX_THRESHOLD) {
      val = 255;
    } else if (val < SMOOTH_MIN_THRESHOLD) {
      val = 0;
    } else {
      val = ((val - SMOOTH_MIN_THRESHOLD) / (SMOOTH_MAX_THRESHOLD - SMOOTH_MIN_THRESHOLD)) * 255;
    }
    tempImageData.data[i] = val;
  }

  // Draw resulting image (original + shadow without opacity) into canvas
  ctx.putImageData(tempImageData, 0, 0);

  // Fill whole image with color (after that shadow is colored)
  ctx.save();
  ctx.globalCompositeOperation = 'source-in';
  ctx.fillStyle = color;
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.restore();

  // Copy colored shadow into original imageData
  const newImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);

  const indexesToProcess = [];
  for (let i = 3; i < nPixels; i += 4) {
    const hasTransparentOnTop = imageData.data[i - imageData.width * 4 * offset] === 0;
    const hasTransparentOnTopRight = imageData.data[i - (imageData.width * 4 + 4) * offset] === 0;
    const hasTransparentOnTopLeft = imageData.data[i - (imageData.width * 4 - 4) * offset] === 0;
    const hasTransparentOnRight = imageData.data[i + 4 * offset] === 0;
    const hasTransparentOnLeft = imageData.data[i - 4 * offset] === 0;
    const hasTransparentOnBottom = imageData.data[i + imageData.width * 4 * offset] === 0;
    const hasTransparentOnBottomRight = imageData.data[i + (imageData.width * 4 + 4) * offset] === 0;
    const hasTransparentOnBottomLeft = imageData.data[i + (imageData.width * 4 - 4) * offset] === 0;
    
    const hasTransparentAround =
      hasTransparentOnTop ||
      hasTransparentOnRight ||
      hasTransparentOnLeft ||
      hasTransparentOnBottom ||
      hasTransparentOnTopRight ||
      hasTransparentOnTopLeft ||
      hasTransparentOnBottomRight ||
      hasTransparentOnBottomLeft;

    // Skip pixels presented in original image
    if (imageData.data[i] === 255 || (imageData.data[i] && !hasTransparentAround)) {
      continue;
    }
    
    if (!newImageData.data[i]) {
      // Skip transparent pixels
      continue;
    }
    
    indexesToProcess.push(i);
  }

  for (let index = 0; index < indexesToProcess.length; index += 1) {
    const i = indexesToProcess[index];
    const alpha = imageData.data[i] / 255;

    imageData.data[i] = newImageData.data[i];
    imageData.data[i - 1] = newImageData.data[i - 1] * (1 - alpha) + imageData.data[i - 1] * alpha;
    imageData.data[i - 2] = newImageData.data[i - 2] * (1 - alpha) + imageData.data[i - 2] * alpha;
    imageData.data[i - 3] = newImageData.data[i - 3] * (1 - alpha) + imageData.data[i - 3] * alpha;
  }
}

// Load image and apply filter
Konva.Image.fromURL('https://konvajs.org/assets/lion.png', function (image) {
  layer.add(image);
  image.setAttrs({
    x: 80,
    y: 30,
    borderSize: 5,
    borderColor: 'red',
  });

  image.filters([Border]);
  image.cache();
});

----------------------------------------

TITLE: KonvaJS Memory Management - Vue Implementation
DESCRIPTION: Demonstrates memory-safe implementation of KonvaJS in Vue using vue-konva components. Shows proper reactive state management for shape properties and animations.

LANGUAGE: javascript
CODE:
<template>
  <div>
    <button @click="handleAdd" style="margin-right: 10px">Add Circle</button>
    <button @click="handleRemove" style="margin-right: 10px">Remove Circle</button>
    <button @click="handleAnimate">Animate</button>
    
    <v-stage :config="stageSize">
      <v-layer>
        <v-circle
          v-if="isVisible"
          :config="circleConfig"
        />
      </v-layer>
    </v-stage>
  </div>
</template>

<script setup>
import { ref } from 'vue';

const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight
};

const isVisible = ref(true);
const position = ref({ x: 100, y: 100 });
const rotation = ref(0);

const circleConfig = ref({
  x: position.value.x,
  y: position.value.y,
  radius: 30,
  fill: 'red',
  rotation: rotation.value
});

const handleAdd = () => {
  isVisible.value = true;
};

const handleRemove = () => {
  isVisible.value = false;
};

const handleAnimate = () => {
  // Update position
  position.value = {
    x: Math.random() * window.innerWidth,
    y: Math.random() * window.innerHeight
  };
  
  // Update rotation
  rotation.value += 360;
  
  // Update config
  circleConfig.value = {
    ...circleConfig.value,
    x: position.value.x,
    y: position.value.y,
    rotation: rotation.value
  };
};
</script>

----------------------------------------

TITLE: Implementing Star Spinner with React and Konva
DESCRIPTION: React implementation of the spinning star using react-konva. Uses hooks for state management and refs for animation control. Implements the same functionality as the vanilla version with React-specific patterns.

LANGUAGE: jsx
CODE:
import { Stage, Layer, Star, Circle } from 'react-konva';
import { useEffect, useRef, useState } from 'react';

const App = () => {
  const [controlled, setControlled] = useState(false);
  const starRef = useRef(null);
  // ... rest of React implementation ...

----------------------------------------

TITLE: Implementing Konva Performance Optimizations in React
DESCRIPTION: This React component demonstrates Konva performance optimizations. It uses separate layers for background and draggable elements, implements shape caching, and optimizes drag operations by moving the dragged shape to a separate layer.

LANGUAGE: jsx
CODE:
import { Stage, Layer, Star, Rect } from 'react-konva';
import { useState, useRef, useEffect } from 'react';

const App = () => {
  const [starLayer, setStarLayer] = useState('main');
  const starRef = useRef(null);

  useEffect(() => {
    // Cache the shape for better performance
    if (starRef.current) {
      starRef.current.cache();
    }
  }, []);

  const handleDragStart = () => {
    setStarLayer('drag');
  };

  const handleDragEnd = () => {
    setStarLayer('main');
  };

  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer listening={false}>
        <Rect
          x={0}
          y={0}
          width={window.innerWidth}
          height={window.innerHeight}
          fill="lightgray"
        />
      </Layer>
      <Layer>
        {starLayer === 'main' && (
          <Star
            ref={starRef}
            x={200}
            y={200}
            numPoints={6}
            innerRadius={40}
            outerRadius={70}
            fill="yellow"
            stroke="black"
            strokeWidth={4}
            draggable
            perfectDrawEnabled={false}
            onDragStart={handleDragStart}
            onDragEnd={handleDragEnd}
          />
        )}
      </Layer>
      <Layer>
        {starLayer === 'drag' && (
          <Star
            ref={starRef}
            x={200}
            y={200}
            numPoints={6}
            innerRadius={40}
            outerRadius={70}
            fill="yellow"
            stroke="black"
            strokeWidth={4}
            draggable
            perfectDrawEnabled={false}
            onDragStart={handleDragStart}
            onDragEnd={handleDragEnd}
          />
        )}
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Implementing Canvas Background with React and Konva
DESCRIPTION: Shows how to create canvas backgrounds using React components with react-konva. Implements both CSS and gradient backgrounds with proper handling of stage dragging.

LANGUAGE: jsx
CODE:
import { useState, useRef, useEffect } from 'react';
import { Stage, Layer, Rect, Circle } from 'react-konva';

const App = () => {
  const width = window.innerWidth;
  const height = window.innerHeight;
  
  const stageRef = useRef(null);
  const backgroundRef = useRef(null);
  
  useEffect(() => {
    if (stageRef.current) {
      const container = stageRef.current.container();
      container.style.backgroundColor = 'green';
    }
  }, []);
  
  const handleDragMove = () => {
    if (backgroundRef.current) {
      backgroundRef.current.absolutePosition({ x: 0, y: 0 });
    }
  };
  
  return (
    <Stage 
      width={width} 
      height={height}
      draggable
      ref={stageRef}
      onDragMove={handleDragMove}
    >
      <Layer>
        <Rect
          ref={backgroundRef}
          x={0}
          y={0}
          width={width}
          height={height}
          fillLinearGradientStartPoint={{ x: 0, y: 0 }}
          fillLinearGradientEndPoint={{ x: width, y: height }}
          fillLinearGradientColorStops={[
            0, 'yellow',
            0.5, 'blue', 
            0.6, 'rgba(0, 0, 0, 0)'
          ]}
          listening={false}
        />
        <Circle
          x={width / 2}
          y={height / 2}
          radius={100}
          fill="red"
        />
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Implementing Animated Rectangle Component with React-Konva and React Spring
DESCRIPTION: Creates an interactive canvas animation using React-Konva and React Spring. The component renders a rectangle that animates its position, shadow, color, and size when clicked. Uses React Spring's animation system for smooth transitions between states.

LANGUAGE: javascript
CODE:
import React, { Component } from 'react';
import { Stage, Layer, Text } from 'react-konva';
import { Spring, animated } from '@react-spring/konva';

const ColoredRect = () => {
  const [flag, setFlag] = React.useState(false);
  const handleClick = () => setFlag(prev => !prev);

  return (
    <Spring
      native
      from={{ x: 0, shadowBlur: 0, fill: 'rgb(10,50,19)' }}
      to={{
        x: flag ? 150 : 50,
        shadowBlur: flag ? 25 : 5,
        fill: flag ? 'seagreen' : 'hotpink',
        width: flag ? 300 : 50,
        height: flag ? 300 : 50,
      }}
    >
      {(props) => (
        <animated.Rect {...props} y={50} onClick={handleClick} />
      )}
    </Spring>
  );
};

class App extends Component {
  render() {
    return (
      <Stage width={window.innerWidth} height={window.innerHeight}>
        <Layer>
          <Text text="Try clicking the rectangle" />
          <ColoredRect />
        </Layer>
      </Stage>
    );
  }
}

export default App;

----------------------------------------

TITLE: Implementing Limited Drag and Resize in Vanilla JavaScript with Konva
DESCRIPTION: Vanilla JavaScript implementation showing how to constrain shape dragging and resizing within canvas boundaries using Konva.js. Includes helper functions for bounding box calculations and transformer setup.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

// Helper functions for calculating bounding boxes
function getCorner(pivotX, pivotY, diffX, diffY, angle) {
  const distance = Math.sqrt(diffX * diffX + diffY * diffY);

  // Find angle from pivot to corner
  angle += Math.atan2(diffY, diffX);

  // Get new x and y coordinates
  const x = pivotX + distance * Math.cos(angle);
  const y = pivotY + distance * Math.sin(angle);

  return { x, y };
}

// [Rest of the vanilla implementation...]

----------------------------------------

TITLE: Implementing Canvas Context Menu with Vanilla JavaScript and Konva
DESCRIPTION: Creates a custom context menu for canvas shapes using plain JavaScript and Konva. Features include creating circles on double-click, showing a context menu on right-click with pulse and delete options, and handling menu positioning.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

// Create a div to use as a context menu
const menuNode = document.createElement('div');
menuNode.id = 'menu';
menuNode.style.display = 'none';
menuNode.style.position = 'absolute';
// ... [rest of vanilla JS implementation]

----------------------------------------

TITLE: Building Map Implementation - React
DESCRIPTION: React implementation of the interactive building map using react-konva components. Manages hover states and tooltip positioning using React hooks and state management.

LANGUAGE: jsx
CODE:
import { Stage, Layer, Line, Label, Tag, Text, Image } from 'react-konva';
import { useState } from 'react';
import useImage from 'use-image';

const getData = () => ({
  '1st Floor': {
    color: 'blue',
    points: [366, 298, 500, 284, 499, 204, 352, 183, 72, 228, 74, 274],
  },
  // ... rest of the data
});

// ... rest of React implementation

----------------------------------------

TITLE: Implementing Batch Draw with Vanilla JavaScript in Konva
DESCRIPTION: Demonstrates how to optimize canvas performance using batchDraw() for handling mouse movement animations. Creates a rotating rectangle that responds to mouse movements with better performance than regular draw() method.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

// For demo purposes, disable auto draw
Konva.autoDrawEnabled = false;

const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight,
});

const layer = new Konva.Layer();
stage.add(layer);

const rect = new Konva.Rect({
  x: stage.width() / 2 - 50,
  y: stage.height() / 2 - 25,
  width: 100,
  height: 50,
  fill: 'green',
  stroke: 'black',
  strokeWidth: 4,
});

layer.add(rect);

stage.on('mousemove', () => {
  // rotate rectangle on mouse move
  rect.rotate(5);
  // use batchDraw instead of draw for better performance
  layer.batchDraw();
});

----------------------------------------

TITLE: Connected Objects Demo in Vue with Konva
DESCRIPTION: This snippet implements the connected objects demo using Vue 3 and vue-konva. It uses Vue's composition API to manage state and update the connections dynamically when circles are dragged.

LANGUAGE: vue
CODE:
<template>
  <v-stage :config="stageConfig">
    <v-layer>
      <v-arrow
        v-for="connector in connectors"
        :key="connector.id"
        :config="getArrowConfig(connector)"
      />
      <v-circle
        v-for="target in targets"
        :key="target.id"
        :config="getCircleConfig(target)"
        @dragmove="handleDragMove"
      />
    </v-layer>
  </v-stage>
</template>

<script setup>
import { ref, onMounted } from 'vue';

const stageConfig = {
  width: window.innerWidth,
  height: window.innerHeight
};

// Generate initial targets
const generateTargets = () => {
  const number = 10;
  const result = [];
  while (result.length < number) {
    result.push({
      id: 'target-' + result.length,
      x: window.innerWidth * Math.random(),
      y: window.innerHeight * Math.random(),
      radius: 20 + Math.random() * 20,
      fill: '#' + Math.floor(Math.random()*16777215).toString(16),
    });
  }
  return result;
};

// Generate connectors between targets
const generateConnectors = (targets) => {
  const number = 10;
  const result = [];
  while (result.length < number) {
    const from = 'target-' + Math.floor(Math.random() * targets.length);
    const to = 'target-' + Math.floor(Math.random() * targets.length);
    if (from === to) {
      continue;
    }
    result.push({
      id: 'connector-' + result.length,
      from,
      to,
    });
  }
  return result;
};

const targets = ref([]);
const connectors = ref([]);

onMounted(() => {
  const initialTargets = generateTargets();
  targets.value = initialTargets;
  connectors.value = generateConnectors(initialTargets);
});

const getConnectorPoints = (from, to) => {
  const dx = to.x - from.x;
  const dy = to.y - from.y;
  let angle = Math.atan2(-dy, dx);

  const radius = 50;

  return [
    from.x + -radius * Math.cos(angle + Math.PI),
    from.y + radius * Math.sin(angle + Math.PI),
    to.x + -radius * Math.cos(angle),
    to.y + radius * Math.sin(angle),
  ];
};

const getArrowConfig = (connector) => {
  const fromNode = targets.value.find((t) => t.id === connector.from);
  const toNode = targets.value.find((t) => t.id === connector.to);
  if (!fromNode || !toNode) return { points: [0, 0, 0, 0] };

  return {
    id: connector.id,
    points: getConnectorPoints(fromNode, toNode),
    fill: 'black',
    stroke: 'black',
  };
};

const getCircleConfig = (target) => ({
  id: target.id,
  x: target.x,
  y: target.y,
  radius: target.radius,
  fill: target.fill,
  shadowBlur: 10,
  draggable: true,
});

const handleDragMove = (e) => {
  const id = e.target.id();
  targets.value = targets.value.map((target) =>
    target.id === id
      ? { ...target, x: e.target.x(), y: e.target.y() }
      : target
  );
};
</script>

----------------------------------------

TITLE: Implementing Free Drawing with Konva Nodes in React
DESCRIPTION: This snippet shows how to create a free drawing tool using Konva nodes in a React component. It uses React hooks to manage state and event handlers for drawing lines.

LANGUAGE: jsx
CODE:
import React from 'react';
import { Stage, Layer, Line } from 'react-konva';

const App = () => {
  const [tool, setTool] = React.useState('brush');
  const [lines, setLines] = React.useState([]);
  const isDrawing = React.useRef(false);

  const handleMouseDown = (e) => {
    isDrawing.current = true;
    const pos = e.target.getStage().getPointerPosition();
    setLines([...lines, { tool, points: [pos.x, pos.y] }]);
  };

  const handleMouseMove = (e) => {
    // no drawing - skipping
    if (!isDrawing.current) {
      return;
    }
    const stage = e.target.getStage();
    const point = stage.getPointerPosition();
    
    // To draw line
    let lastLine = lines[lines.length - 1];
    // add point
    lastLine.points = lastLine.points.concat([point.x, point.y]);

    // replace last
    lines.splice(lines.length - 1, 1, lastLine);
    setLines(lines.concat());
  };

  const handleMouseUp = () => {
    isDrawing.current = false;
  };

  return (
    <>
      <select
        value={tool}
        onChange={(e) => {
          setTool(e.target.value);
        }}
      >
        <option value="brush">Brush</option>
        <option value="eraser">Eraser</option>
      </select>
      <Stage
        width={window.innerWidth}
        height={window.innerHeight - 25}
        onMouseDown={handleMouseDown}
        onMousemove={handleMouseMove}
        onMouseup={handleMouseUp}
        onTouchStart={handleMouseDown}
        onTouchMove={handleMouseMove}
        onTouchEnd={handleMouseUp}
      >
        <Layer>
          {lines.map((line, i) => (
            <Line
              key={i}
              points={line.points}
              stroke="#df4b26"
              strokeWidth={5}
              tension={0.5}
              lineCap="round"
              lineJoin="round"
              globalCompositeOperation={
                line.tool === 'eraser' ? 'destination-out' : 'source-over'
              }
            />
          ))}
        </Layer>
      </Stage>
    </>
  );
};

export default App;

----------------------------------------

TITLE: Managing Canvas State with React and react-konva
DESCRIPTION: This snippet shows how to manage canvas state using React and react-konva. It includes functionality for adding images, applying filters, and implementing undo/redo operations using React hooks.

LANGUAGE: jsx
CODE:
import { Stage, Layer, Image } from 'react-konva';
import { useState, useEffect, useRef } from 'react';

const App = () => {
  const [images, setImages] = useState([
    { x: 50, y: 50, filter: 'none' },
    { x: 150, y: 50, filter: 'blur' }
  ]);
  const [history, setHistory] = useState([]);
  const [historyStep, setHistoryStep] = useState(0);
  const imageObj = useRef(null);

  useEffect(() => {
    imageObj.current = new window.Image();
    imageObj.current.src = '/assets/lion.png';
    imageObj.current.onload = () => {
      setHistory([JSON.stringify(images)]);
    };
  }, []);

  const handleDragEnd = (index, e) => {
    const newImages = [...images];
    newImages[index] = {
      ...newImages[index],
      x: e.target.x(),
      y: e.target.y()
    };
    setImages(newImages);
    saveHistory(newImages);
  };

  const handleClick = (index) => {
    const newImages = [...images];
    newImages[index] = {
      ...newImages[index],
      filter: newImages[index].filter === 'none' ? 'blur' : 'none'
    };
    setImages(newImages);
    saveHistory(newImages);
  };

  const saveHistory = (newImages) => {
    const newHistory = history.slice(0, historyStep + 1);
    newHistory.push(JSON.stringify(newImages));
    setHistory(newHistory);
    setHistoryStep(newHistory.length - 1);
  };

  const handleAdd = () => {
    const newImages = [...images, {
      x: Math.random() * window.innerWidth,
      y: Math.random() * window.innerHeight,
      filter: 'none'
    }];
    setImages(newImages);
    saveHistory(newImages);
  };

  const handleUndo = () => {
    if (historyStep === 0) return;
    const newStep = historyStep - 1;
    setHistoryStep(newStep);
    setImages(JSON.parse(history[newStep]));
  };

  const handleRedo = () => {
    if (historyStep === history.length - 1) return;
    const newStep = historyStep + 1;
    setHistoryStep(newStep);
    setImages(JSON.parse(history[newStep]));
  };

  return (
    <div>
      <div style={{ marginBottom: '10px' }}>
        <button onClick={handleAdd}>Add Image</button>
        <button onClick={handleUndo}>Undo</button>
        <button onClick={handleRedo}>Redo</button>
      </div>
      <Stage width={window.innerWidth} height={window.innerHeight}>
        <Layer>
          {imageObj.current && images.map((img, i) => (
            <Image
              key={i}
              image={imageObj.current}
              x={img.x}
              y={img.y}
              width={100}
              height={100}
              draggable
              filters={img.filter === 'blur' ? [Konva.Filters.Blur] : []}
              blurRadius={img.filter === 'blur' ? 10 : 0}
              onDragEnd={(e) => handleDragEnd(i, e)}
              onClick={() => handleClick(i)}
            />
          ))}
        </Layer>
      </Stage>
    </div>
  );
};

export default App;

----------------------------------------

TITLE: Vue-Konva Optimized Animation Component
DESCRIPTION: Vue 3 implementation of optimized Konva animations using composition API. Shows proper setup and teardown of animations with Vue lifecycle hooks.

LANGUAGE: vue
CODE:
<template>
  <div>
    <button
      @click="toggleAnimation"
      style="position: absolute; top: 10px; left: 10px"
    >
      {{ isPlaying ? 'Stop Animation' : 'Start Animation' }}
    </button>
    
    <v-stage :config="stageSize">
      <v-layer ref="layerRef">
        <v-star
          ref="starRef"
          :config="starConfig"
        />
        <v-circle
          ref="circleRef"
          :config="circleConfig"
        />
      </v-layer>
    </v-stage>
  </div>
</template>

<script setup>
import { ref, onMounted, onUnmounted } from 'vue';
import Konva from 'konva';

const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight
};

const starConfig = {
  x: window.innerWidth / 2,
  y: window.innerHeight / 2,
  numPoints: 6,
  innerRadius: 40,
  outerRadius: 70,
  fill: 'yellow',
  stroke: 'black',
  strokeWidth: 4
};

const circleConfig = ref({
  x: 100,
  y: 100,
  radius: 20,
  fill: 'red'
});

const layerRef = ref(null);
const starRef = ref(null);
const circleRef = ref(null);
const isPlaying = ref(true);
let anim = null;

onMounted(() => {
  // Cache the star shape for better performance
  starRef.value.getNode().cache();

  // Create animation
  anim = new Konva.Animation((frame) => {
    // Rotate star (cached shape)
    starRef.value.getNode().rotation(frame.time * 0.1);
    
    // Move circle in a circle pattern
    const circle = circleRef.value.getNode();
    circle.x(100 + Math.cos(frame.time * 0.002) * 50);
    circle.y(100 + Math.sin(frame.time * 0.002) * 50);
  }, layerRef.value.getNode());

  anim.start();
});

onUnmounted(() => {
  if (anim) {
    anim.stop();
  }
});

const toggleAnimation = () => {
  if (isPlaying.value) {
    anim.stop();
  } else {
    anim.start();
  }
  isPlaying.value = !isPlaying.value;
};
</script>

----------------------------------------

TITLE: Implementing Free Drawing with Konva Nodes in Vue
DESCRIPTION: This snippet demonstrates how to create a free drawing tool using Konva nodes in a Vue component. It uses Vue's composition API to manage state and event handlers for drawing lines.

LANGUAGE: vue
CODE:
<template>
  <div>
    <select v-model="tool">
      <option value="brush">Brush</option>
      <option value="eraser">Eraser</option>
    </select>
    <v-stage
      :config="stageConfig"
      @mousedown="handleMouseDown"
      @mousemove="handleMouseMove"
      @mouseup="handleMouseUp"
      @touchstart="handleMouseDown"
      @touchmove="handleMouseMove"
      @touchend="handleMouseUp"
    >
      <v-layer>
        <v-line
          v-for="(line, i) in lines"
          :key="i"
          :config="{
            points: line.points,
            stroke: '#df4b26',
            strokeWidth: 5,
            tension: 0.5,
            lineCap: 'round',
            lineJoin: 'round',
            globalCompositeOperation:
              line.tool === 'eraser' ? 'destination-out' : 'source-over'
          }"
        />
      </v-layer>
    </v-stage>
  </div>
</template>

<script setup>
import { ref } from 'vue';

const tool = ref('brush');
const lines = ref([]);
const isDrawing = ref(false);

const stageConfig = {
  width: window.innerWidth,
  height: window.innerHeight - 25
};

const handleMouseDown = (e) => {
  isDrawing.value = true;
  const pos = e.target.getStage().getPointerPosition();
  lines.value.push({ tool: tool.value, points: [pos.x, pos.y] });
};

const handleMouseMove = (e) => {
  if (!isDrawing.value) {
    return;
  }
  const stage = e.target.getStage();
  const point = stage.getPointerPosition();
  
  let lastLine = lines.value[lines.value.length - 1];
  lastLine.points = lastLine.points.concat([point.x, point.y]);
  lines.value.splice(lines.value.length - 1, 1, { ...lastLine });
};

const handleMouseUp = () => {
  isDrawing.value = false;
};
</script>

----------------------------------------

TITLE: Flipping Shapes with Vue and Konva
DESCRIPTION: Demonstrates shape flipping implementation using Vue-Konva. Uses Vue's reactive references to manage text elements and their scale properties, with a flip button to toggle horizontal orientation.

LANGUAGE: javascript
CODE:
<template>
  <div>
    <v-stage :config="stageConfig">
      <v-layer>
        <v-text
          v-for="text in texts"
          :key="text.id"
          :config="text"
        />
      </v-layer>
    </v-stage>
    <button
      @click="handleFlip"
      style="position: absolute; top: 5px; left: 5px;"
    >
      Flip horizontally
    </button>
  </div>
</template>

<script setup>
import { ref } from 'vue';

const stageConfig = {
  width: window.innerWidth,
  height: window.innerHeight
};

const texts = ref([
  {
    id: 1,
    text: 'Default text with no offset. Its origin is in top left corner.',
    x: 180,
    y: 50,
    width: 200,
    align: 'center',
    scaleX: 1,
    offsetX: 0
  },
  {
    id: 2,
    text: 'Text with the origin in its center',
    x: 270,
    y: 100,
    width: 200,
    align: 'center',
    scaleX: 1,
    offsetX: 100
  }
]);

const handleFlip = () => {
  texts.value = texts.value.map(text => ({
    ...text,
    scaleX: -text.scaleX
  }));
};
</script>

----------------------------------------

TITLE: Managing Canvas State with Vue and vue-konva
DESCRIPTION: This snippet demonstrates how to manage canvas state using Vue 3 and vue-konva. It includes functionality for adding images, applying filters, and implementing undo/redo operations using Vue's composition API.

LANGUAGE: vue
CODE:
<template>
  <div>
    <div style="margin-bottom: 10px">
      <button @click="handleAdd">Add Image</button>
      <button @click="handleUndo">Undo</button>
      <button @click="handleRedo">Redo</button>
    </div>
    <v-stage :config="stageSize">
      <v-layer>
        <v-image
          v-for="(img, i) in images"
          :key="i"
          :config="getImageConfig(img)"
          @dragend="handleDragEnd(i, $event)"
          @click="handleClick(i)"
        />
      </v-layer>
    </v-stage>
  </div>
</template>

<script setup>
import { ref, onMounted, computed } from 'vue';
import Konva from 'konva';

const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight
};

const images = ref([
  { x: 50, y: 50, filter: 'none' },
  { x: 150, y: 50, filter: 'blur' }
]);
const history = ref([]);
const historyStep = ref(0);
const imageObj = ref(null);

onMounted(() => {
  imageObj.value = new Image();
  imageObj.value.src = '/assets/lion.png';
  imageObj.value.onload = () => {
    history.value = [JSON.stringify(images.value)];
  };
});

const getImageConfig = (img) => ({
  image: imageObj.value,
  x: img.x,
  y: img.y,
  width: 100,
  height: 100,
  draggable: true,
  filters: img.filter === 'blur' ? [Konva.Filters.Blur] : [],
  blurRadius: img.filter === 'blur' ? 10 : 0
});

const saveHistory = (newImages) => {
  const newHistory = history.value.slice(0, historyStep.value + 1);
  newHistory.push(JSON.stringify(newImages));
  history.value = newHistory;
  historyStep.value = newHistory.length - 1;
};

const handleDragEnd = (index, e) => {
  const newImages = [...images.value];
  const pos = e.target.position();
  newImages[index] = {
    ...newImages[index],
    x: pos.x,
    y: pos.y
  };
  images.value = newImages;
  saveHistory(newImages);
};

const handleClick = (index) => {
  const newImages = [...images.value];
  newImages[index] = {
    ...newImages[index],
    filter: newImages[index].filter === 'none' ? 'blur' : 'none'
  };
  images.value = newImages;
  saveHistory(newImages);
};

const handleAdd = () => {
  const newImages = [...images.value, {
    x: Math.random() * window.innerWidth,
    y: Math.random() * window.innerHeight,
    filter: 'none'
  }];
  images.value = newImages;
  saveHistory(newImages);
};

const handleUndo = () => {
  if (historyStep.value === 0) return;
  historyStep.value--;
  images.value = JSON.parse(history.value[historyStep.value]);
};

const handleRedo = () => {
  if (historyStep.value === history.value.length - 1) return;
  historyStep.value++;
  images.value = JSON.parse(history.value[historyStep.value]);
};
</script>

----------------------------------------

TITLE: Implementing Draggable and Resizable Images with Konva.js
DESCRIPTION: Creates a canvas stage with two interactive images that can be dragged and resized using corner anchors. The implementation includes anchor creation, update logic for resizing, and image loading with proper event handling. Uses Konva.js for canvas manipulation and event management.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const width = window.innerWidth;
const height = window.innerHeight;

const stage = new Konva.Stage({
  container: 'container',
  width: width,
  height: height,
});

const layer = new Konva.Layer();
stage.add(layer);

// Function to update image size based on anchor movement
function update(activeAnchor) {
  const group = activeAnchor.getParent();

  const topLeft = group.findOne('.topLeft');
  const topRight = group.findOne('.topRight');
  const bottomRight = group.findOne('.bottomRight');
  const bottomLeft = group.findOne('.bottomLeft');
  const image = group.findOne('Image');

  const anchorX = activeAnchor.x();
  const anchorY = activeAnchor.y();

  // Update anchor positions based on which anchor was moved
  switch (activeAnchor.getName()) {
    case 'topLeft':
      topRight.y(anchorY);
      bottomLeft.x(anchorX);
      break;
    case 'topRight':
      topLeft.y(anchorY);
      bottomRight.x(anchorX);
      break;
    case 'bottomRight':
      bottomLeft.y(anchorY);
      topRight.x(anchorX);
      break;
    case 'bottomLeft':
      bottomRight.y(anchorY);
      topLeft.x(anchorX);
      break;
  }

  // Position image at top-left corner
  image.position(topLeft.position());

  // Update image dimensions
  const width = topRight.x() - topLeft.x();
  const height = bottomLeft.y() - topLeft.y();
  if (width && height) {
    image.width(width);
    image.height(height);
  }
}

// Function to add resize anchors to a group
function addAnchor(group, x, y, name) {
  const anchor = new Konva.Circle({
    x: x,
    y: y,
    stroke: '#666',
    fill: '#ddd',
    strokeWidth: 2,
    radius: 8,
    name: name,
    draggable: true,
    dragOnTop: false,
  });

  // Add event listeners for resize behavior
  anchor.on('dragmove', function () {
    update(this);
  });
  
  anchor.on('mousedown touchstart', function () {
    group.draggable(false);
    this.moveToTop();
  });
  
  anchor.on('dragend', function () {
    group.draggable(true);
  });
  
  // Add hover styling
  anchor.on('mouseover', function () {
    document.body.style.cursor = 'pointer';
    this.strokeWidth(4);
  });
  
  anchor.on('mouseout', function () {
    document.body.style.cursor = 'default';
    this.strokeWidth(2);
  });

  group.add(anchor);
}

// Create Darth Vader Group with Image and anchors
const darthVaderImg = new Konva.Image({
  width: 200,
  height: 137,
});

const darthVaderGroup = new Konva.Group({
  x: 180,
  y: 50,
  draggable: true,
});

layer.add(darthVaderGroup);
darthVaderGroup.add(darthVaderImg);

// Add anchors at the corners
addAnchor(darthVaderGroup, 0, 0, 'topLeft');
addAnchor(darthVaderGroup, 200, 0, 'topRight');
addAnchor(darthVaderGroup, 200, 137, 'bottomRight');
addAnchor(darthVaderGroup, 0, 137, 'bottomLeft');

// Create Yoda Group with Image and anchors
const yodaImg = new Konva.Image({
  width: 93,
  height: 104,
});

const yodaGroup = new Konva.Group({
  x: 20,
  y: 110,
  draggable: true,
});

layer.add(yodaGroup);
yodaGroup.add(yodaImg);

// Add anchors at the corners
addAnchor(yodaGroup, 0, 0, 'topLeft');
addAnchor(yodaGroup, 93, 0, 'topRight');
addAnchor(yodaGroup, 93, 104, 'bottomRight');
addAnchor(yodaGroup, 0, 104, 'bottomLeft');

// Load the images
const imageObj1 = new Image();
imageObj1.onload = function () {
  darthVaderImg.image(imageObj1);
};
imageObj1.src = 'https://konvajs.org/assets/darth-vader.jpg';

const imageObj2 = new Image();
imageObj2.onload = function () {
  yodaImg.image(imageObj2);
};
imageObj2.src = 'https://konvajs.org/assets/yoda.jpg';

----------------------------------------

TITLE: Implementing Multi-touch Shape Scaling with Vanilla JavaScript and Konva
DESCRIPTION: This code snippet demonstrates how to create a canvas with draggable and scalable shapes using Konva and vanilla JavaScript. It includes touch event handling for multi-touch scaling and shape activation.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

// by default Konva prevent some events when node is dragging
// it improve the performance and work well for 95% of cases
// we need to enable all events on Konva, even when we are dragging a node
// so it triggers touchmove correctly
Konva.hitOnDragEnabled = true;

const width = window.innerWidth;
const height = window.innerHeight;

let lastDist = 0;
let startScale = 1;
let activeShape = null;

function getDistance(p1, p2) {
  return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
}

const stage = new Konva.Stage({
  container: 'container',
  width: width,
  height: height,
  draggable: true,
  x: width / 2,
  y: height / 2,
  offset: {
    x: width / 2,
    y: height / 2,
  },
});

const layer = new Konva.Layer();

const triangle = new Konva.RegularPolygon({
  x: 190,
  y: stage.height() / 2,
  sides: 3,
  radius: 80,
  fill: 'green',
  stroke: 'black',
  strokeWidth: 4,
  draggable: true,
  name: 'triangle',
});

const circle = new Konva.Circle({
  x: 380,
  y: stage.height() / 2,
  radius: 70,
  fill: 'red',
  stroke: 'black',
  strokeWidth: 4,
  draggable: true,
  name: 'circle',
});

stage.on('tap', function (evt) {
  // set active shape
  const shape = evt.target;
  activeShape =
    activeShape && activeShape.getName() === shape.getName()
      ? null
      : shape;

  // sync scene graph
  triangle.setAttrs({
    fill:
      activeShape && activeShape.getName() === triangle.getName()
        ? '#78E7FF'
        : 'green',
    stroke:
      activeShape && activeShape.getName() === triangle.getName()
        ? 'blue'
        : 'black',
  });

  circle.setAttrs({
    fill:
      activeShape && activeShape.getName() === circle.getName()
        ? '#78E7FF'
        : 'red',
    stroke:
      activeShape && activeShape.getName() === circle.getName()
        ? 'blue'
        : 'black',
  });
});

stage.getContent().addEventListener(
  'touchmove',
  function (evt) {
    const touch1 = evt.touches[0];
    const touch2 = evt.touches[1];

    if (touch1 && touch2 && activeShape) {
      const dist = getDistance(
        {
          x: touch1.clientX,
          y: touch1.clientY,
        },
        {
          x: touch2.clientX,
          y: touch2.clientY,
        }
      );

      if (!lastDist) {
        lastDist = dist;
      }

      const scale = (activeShape.scaleX() * dist) / lastDist;

      activeShape.scaleX(scale);
      activeShape.scaleY(scale);
      lastDist = dist;
    }
  },
  false
);

stage.getContent().addEventListener(
  'touchend',
  function () {
    lastDist = 0;
  },
  false
);

layer.add(triangle);
layer.add(circle);
stage.add(layer);

----------------------------------------

TITLE: Implementing Drag and Drop for Multiple Shapes with Konva in Vue
DESCRIPTION: This Vue component creates a Konva stage with multiple draggable colored rectangles. It uses Vue's composition API to manage state and demonstrates how to handle drag events, remove shapes on double-click/tap, and change cursor styles on hover.

LANGUAGE: vue
CODE:
<template>
  <v-stage :config="stageConfig">
    <v-layer>
      <v-rect
        v-for="box in boxes"
        :key="box.id"
        :config="box"
        @dragstart="handleDragStart"
        @dragmove="handleDragMove"
        @mouseover="handleMouseOver"
        @mouseout="handleMouseOut"
        @dblclick="handleDoubleClick"
        @dbltap="handleDoubleClick"
      />
    </v-layer>
  </v-stage>
</template>

<script setup>
import { ref } from 'vue';

const stageConfig = {
  width: window.innerWidth,
  height: window.innerHeight
};

const colors = ['red', 'orange', 'yellow', 'green', 'blue', 'purple'];

// Initialize boxes with proper configuration
const initialBoxes = colors.map((color, i) => ({
  id: i.toString(),
  x: i * 30 + 50,
  y: i * 18 + 40,
  width: 100,
  height: 50,
  fill: color,
  stroke: 'black',
  strokeWidth: 4,
  draggable: true
}));

const boxes = ref(initialBoxes);

const handleDragStart = (e) => {
  const id = e.target.id();
  
  // Move the dragged box to the end of the array to simulate moveToTop
  const box = boxes.value.find(b => b.id === id);
  const filteredBoxes = boxes.value.filter(b => b.id !== id);
  boxes.value = [...filteredBoxes, box];
};

const handleDragMove = (e) => {
  const id = e.target.id();
  const index = boxes.value.findIndex(b => b.id === id);
  
  if (index !== -1) {
    // Update position
    const updatedBox = { ...boxes.value[index] };
    updatedBox.x = e.target.x();
    updatedBox.y = e.target.y();
    
    // Replace the box in the array
    const newBoxes = [...boxes.value];
    newBoxes[index] = updatedBox;
    boxes.value = newBoxes;
  }
  
  document.body.style.cursor = 'pointer';
};

const handleMouseOver = () => {
  document.body.style.cursor = 'pointer';
};

const handleMouseOut = () => {
  document.body.style.cursor = 'default';
};

const handleDoubleClick = (e) => {
  const id = e.target.id();
  // Remove the box
  boxes.value = boxes.value.filter(box => box.id !== id);
};
</script>

----------------------------------------

TITLE: Implementing Drag and Drop Stress Test with Vanilla JavaScript and Konva
DESCRIPTION: This snippet creates a Konva stage with 10,000 circles and implements drag and drop functionality. It uses two layers for efficient rendering and smooth dragging.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const width = window.innerWidth;
const height = window.innerHeight;

// Create stage
const stage = new Konva.Stage({
  container: 'container',
  width: width,
  height: height,
});

// Create main layer for all shapes
const mainLayer = new Konva.Layer();

// Create a dedicated layer for dragging
const dragLayer = new Konva.Layer();

// Define colors for random shapes
const colors = [
  'red',
  'orange',
  'yellow',
  'green',
  'blue',
  'cyan',
  'purple',
];
let colorIndex = 0;

// Helper function to add a circle to a layer
function addCircle(layer) {
  const color = colors[colorIndex++];
  if (colorIndex >= colors.length) {
    colorIndex = 0;
  }

  const randX = Math.random() * stage.width();
  const randY = Math.random() * stage.height();
  const circle = new Konva.Circle({
    x: randX,
    y: randY,
    radius: 6,
    fill: color,
  });

  layer.add(circle);
}

// Create 10,000 circles on the main layer
for (let n = 0; n < 10000; n++) {
  addCircle(mainLayer);
}

// Add the main layer and drag layer to the stage
stage.add(mainLayer);
stage.add(dragLayer);

// Setup drag and drop behavior
stage.on('mousedown', function (evt) {
  const circle = evt.target;
  
  // Only handle circle shapes (ignore clicks on empty space)
  if (!circle || circle.getClassName() !== 'Circle') {
    return;
  }
  
  // Move the circle to the drag layer
  circle.moveTo(dragLayer);
  circle.startDrag();
});

// When dragging stops, move the circle back to the main layer
stage.on('mouseup', function (evt) {
  const circle = evt.target;
  
  // Only handle circle shapes
  if (!circle || circle.getClassName() !== 'Circle') {
    return;
  }
  
  // Move the circle back to the main layer
  circle.moveTo(mainLayer);
});

----------------------------------------

TITLE: Implementing Physics Simulator with Konva in JavaScript
DESCRIPTION: This code snippet creates a physics simulator using Konva. It includes vector math functions, collision detection with a curved surface, ball movement physics, and user interaction. The simulator features a ball that can be thrown around and bounces off walls and a custom curve.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const width = window.innerWidth;
const height = window.innerHeight;

/*
 * Vector math functions
 */
function dot(a, b) {
  return a.x * b.x + a.y * b.y;
}
function magnitude(a) {
  return Math.sqrt(a.x * a.x + a.y * a.y);
}
function normalize(a) {
  var mag = magnitude(a);

  if (mag === 0) {
    return {
      x: 0,
      y: 0,
    };
  } else {
    return {
      x: a.x / mag,
      y: a.y / mag,
    };
  }
}
function add(a, b) {
  return {
    x: a.x + b.x,
    y: a.y + b.y,
  };
}
function angleBetween(a, b) {
  return Math.acos(dot(a, b) / (magnitude(a) * magnitude(b)));
}
function rotate(a, angle) {
  var ca = Math.cos(angle);
  var sa = Math.sin(angle);
  var rx = a.x * ca - a.y * sa;
  var ry = a.x * sa + a.y * ca;
  return {
    x: rx * -1,
    y: ry * -1,
  };
}
function invert(a) {
  return {
    x: a.x * -1,
    y: a.y * -1,
  };
}
/*
 * this cross product function has been simplified by
 * setting x and y to zero because vectors a and b
 * lie in the canvas plane
 */
function cross(a, b) {
  return {
    x: 0,
    y: 0,
    z: a.x * b.y - b.x * a.y,
  };
}
function getNormal(curve, ball) {
  var curveLayer = curve.getLayer();
  var context = curveLayer.getContext();
  var testRadius = 20;
  // pixels
  var totalX = 0;
  var totalY = 0;
  var x = ball.x();
  var y = ball.y();
  /*
   * check various points around the center point
   * to determine the normal vector
   */
  for (var n = 0; n < 20; n++) {
    var angle = (n * 2 * Math.PI) / 20;
    var offsetX = testRadius * Math.cos(angle);
    var offsetY = testRadius * Math.sin(angle);
    var testX = x + offsetX;
    var testY = y + offsetY;
    if (!context._context.isPointInPath(testX, testY)) {
      totalX += offsetX;
      totalY += offsetY;
    }
  }

  var normal;

  if (totalX === 0 && totalY === 0) {
    normal = {
      x: 0,
      y: -1,
    };
  } else {
    normal = {
      x: totalX,
      y: totalY,
    };
  }

  return normalize(normal);
}
function handleCurveCollision(ball, curve) {
  var curveLayer = curve.getLayer();
  var x = ball.x();
  var y = ball.y();

  var curveDamper = 0.05;
  // 5% energy loss
  if (curveLayer.getIntersection({ x: x, y: y })) {
    var normal = getNormal(curve, ball);
    if (normal !== null) {
      var angleToNormal = angleBetween(normal, invert(ball.velocity));
      var crossProduct = cross(normal, ball.velocity);
      var polarity = crossProduct.z > 0 ? 1 : -1;
      var collisonAngle = polarity * angleToNormal * 2;
      var collisionVector = rotate(ball.velocity, collisonAngle);

      ball.velocity.x = collisionVector.x;
      ball.velocity.y = collisionVector.y;
      ball.velocity.x *= 1 - curveDamper;
      ball.velocity.y *= 1 - curveDamper;

      x += normal.x;
      if (ball.velocity.y > 0.1) {
        y += normal.y;
      } else {
        y += normal.y / 10;
      }
      ball.x(x).y(y);
    }

    tween.finish();
  }
}
function updateBall(frame) {
  var timeDiff = frame.timeDiff;
  var stage = ball.getStage();
  var height = stage.height();
  var width = stage.width();
  var x = ball.x();
  var y = ball.y();
  var radius = ball.radius();

  tween.reverse();

  // physics variables
  var gravity = 10;
  // px / second^2
  var speedIncrementFromGravityEachFrame = (gravity * timeDiff) / 1000;
  var collisionDamper = 0.2;
  // 20% energy loss
  var floorFriction = 5;
  // px / second^2
  var floorFrictionSpeedReduction = (floorFriction * timeDiff) / 1000;

  // if ball is being dragged and dropped
  if (ball.isDragging()) {
    var mousePos = stage.getPointerPosition();

    if (mousePos) {
      var mouseX = mousePos.x;
      var mouseY = mousePos.y;

      var c = 0.06 * timeDiff;
      ball.velocity = {
        x: c * (mouseX - ball.lastMouseX),
        y: c * (mouseY - ball.lastMouseY),
      };

      ball.lastMouseX = mouseX;
      ball.lastMouseY = mouseY;
    }
  } else {
    // gravity
    ball.velocity.y += speedIncrementFromGravityEachFrame;
    x += ball.velocity.x;
    y += ball.velocity.y;

    // ceiling condition
    if (y < radius) {
      y = radius;
      ball.velocity.y *= -1;
      ball.velocity.y *= 1 - collisionDamper;
    }

    // floor condition
    if (y > height - radius) {
      y = height - radius;
      ball.velocity.y *= -1;
      ball.velocity.y *= 1 - collisionDamper;
    }

    // floor friction
    if (y == height - radius) {
      if (ball.velocity.x > 0.1) {
        ball.velocity.y -= floorFrictionSpeedReduction;
      } else if (ball.velocity.x < -0.1) {
        ball.velocity.x += floorFrictionSpeedReduction;
      } else {
        ball.velocity.x = 0;
      }
    }

    // right wall condition
    if (x > width - radius) {
      x = width - radius;
      ball.velocity.x *= -1;
      ball.velocity.x *= 1 - collisionDamper;
    }

    // left wall condition
    if (x < radius) {
      x = radius;
      ball.velocity.x *= -1;
      ball.velocity.x *= 1 - collisionDamper;
    }

    ball.position({ x: x, y: y });

    /*
     * if the ball comes into contact with the
     * curve, then bounce it in the direction of the
     * curve's surface normal
     */
    var collision = handleCurveCollision(ball, curve);
  }
}

// create stage
const stage = new Konva.Stage({
  container: 'container',
  width: width,
  height: height,
});

// create separate layers for curve and ball
const curveLayer = new Konva.Layer();
const ballLayer = new Konva.Layer();

// create curve with original bezier curve
const curve = new Konva.Shape({
  sceneFunc: function (context) {
    context.beginPath();
    context.moveTo(40, height);
    context.bezierCurveTo(
      width * 0.2,
      -1 * height * 0.5,
      width * 0.7,
      height * 1.3,
      width,
      height * 0.5
    );
    context.lineTo(width, height);
    context.lineTo(40, height);
    context.closePath();
    context.fillShape(this);
  },
  fill: '#8dbdff',
});

curveLayer.add(curve);

// create ball with original styling
const ball = new Konva.Circle({
  x: 190,
  y: 20,
  radius: 20,
  fill: 'blue',
  draggable: true,
  opacity: 0.8,
});

ball.velocity = {
  x: 0,
  y: 0,
};

// add original event handlers
ball.on('dragstart', function () {
  ball.velocity = {
    x: 0,
    y: 0,
  };
  anim.start();
});

ball.on('mousedown', function () {
  anim.stop();
});

ball.on('mouseover', function () {
  document.body.style.cursor = 'pointer';
});

ball.on('mouseout', function () {
  document.body.style.cursor = 'default';
});

ballLayer.add(ball);

// add layers to stage in correct order
stage.add(curveLayer);
stage.add(ballLayer);

// add tween with original styling
const tween = new Konva.Tween({
  node: ball,
  fill: 'red',
  duration: 0.3,
  easing: Konva.Easings.EaseOut,
});

// add animation
const anim = new Konva.Animation(function (frame) {
  updateBall(frame);
}, ballLayer);

anim.start();

----------------------------------------

TITLE: Applying HSL Filter to Image using Konva in Vue.js
DESCRIPTION: This snippet demonstrates how to apply an HSL filter to an image using Konva in a Vue.js component. It uses the vue-konva library and Vue 3 composition API to manage state and update the image filter based on user input from sliders.

LANGUAGE: vue
CODE:
<template>
  <div>
    <v-stage :config="stageSize">
      <v-layer>
        <v-image
          ref="imageNode"
          :config="{
            x: 50,
            y: 50,
            image: image,
            draggable: true,
            filters: [Konva.Filters.HSL],
            hue: hue,
            saturation: saturation,
            luminance: luminance,
          }"
        />
      </v-layer>
    </v-stage>
    <div style="position: absolute; top: 20px; left: 20px">
      <div>
        Hue
        <input
          type="range"
          min="-259"
          max="259"
          :value="hue"
          @input="(e) => hue = parseInt(e.target.value)"
        />
      </div>
      <div>
        Saturation
        <input
          type="range"
          min="-2"
          max="10"
          step="0.1"
          :value="saturation"
          @input="(e) => saturation = parseFloat(e.target.value)"
        />
      </div>
      <div>
        Luminance
        <input
          type="range"
          min="-2"
          max="2"
          step="0.1"
          :value="luminance"
          @input="(e) => luminance = parseFloat(e.target.value)"
        />
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, watch, nextTick } from 'vue';
import { useImage } from 'vue-konva';
import Konva from 'konva';

const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight,
};

const hue = ref(0);
const saturation = ref(0);
const luminance = ref(0);
const imageNode = ref(null);
const [image] = useImage('https://konvajs.org/assets/lion.png', 'anonymous');

watch(image, async (newImage) => {
  if (newImage) {
    await nextTick();
    imageNode.value.getNode().cache();
  }
});
</script>

----------------------------------------

TITLE: Serializing Konva Stage in Vanilla JavaScript
DESCRIPTION: This snippet shows how to create a Konva stage with a circle shape and serialize it using the toJSON() method in vanilla JavaScript. It includes event handling for a button click to trigger the serialization.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const stage = new Konva.Stage({
  container: 'container',
  width: 400,
  height: 400
});

const layer = new Konva.Layer();
stage.add(layer);

// create a shape
const circle = new Konva.Circle({
  x: 100,
  y: 100,
  radius: 50,
  fill: 'red',
  stroke: 'black',
  strokeWidth: 3
});

layer.add(circle);

// add button
const button = document.createElement('button');
button.textContent = 'Serialize Stage';
document.body.appendChild(button);

button.addEventListener('click', () => {
  // serialize the stage
  const json = stage.toJSON();
  
  // show the result
  console.log(json);
  alert('Stage serialized! Check the console for the JSON string.');
});

----------------------------------------

TITLE: Rendering Images on Canvas with React and Konva
DESCRIPTION: This code snippet demonstrates how to load and display an image on a Konva canvas using React. It utilizes the 'use-image' hook to handle image loading and the Konva components to render the canvas and image. The example creates a reusable URLImage component and renders it within a Konva Stage and Layer.

LANGUAGE: jsx
CODE:
import React from 'react';
import { Stage, Layer, Image } from 'react-konva';
import useImage from 'use-image';

const URLImage = ({ src, ...rest }) => {
  const [image] = useImage(src, 'anonymous');
  return <Image image={image} {...rest} />;
};

const App = () => {
  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        <URLImage src="https://konvajs.org/assets/yoda.jpg" x={150} />
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Rendering Images on Canvas with React and Konva
DESCRIPTION: This code snippet demonstrates how to load and display an image on a Konva canvas using React. It utilizes the 'use-image' hook to handle image loading and the Konva components to render the canvas and image. The example creates a reusable URLImage component and renders it within a Konva Stage and Layer.

LANGUAGE: jsx
CODE:
import React from 'react';
import { Stage, Layer, Image } from 'react-konva';
import useImage from 'use-image';

const URLImage = ({ src, ...rest }) => {
  const [image] = useImage(src, 'anonymous');
  return <Image image={image} {...rest} />;
};

const App = () => {
  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        <URLImage src="https://konvajs.org/assets/yoda.jpg" x={150} />
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Implementing Video Playback on Canvas with Vanilla JavaScript and Konva
DESCRIPTION: This snippet demonstrates how to display a video on a canvas using Konva in vanilla JavaScript. It includes play/pause functionality, drag-and-drop capability, and loading state management.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

// create buttons
const playButton = document.createElement('button');
playButton.textContent = 'Play';
playButton.id = 'play';
document.body.appendChild(playButton);

const pauseButton = document.createElement('button');
pauseButton.textContent = 'Pause';
pauseButton.id = 'pause';
document.body.appendChild(pauseButton);

const width = window.innerWidth;
const height = 300;

const stage = new Konva.Stage({
  container: 'container',
  width: width,
  height: height,
});

const layer = new Konva.Layer();
stage.add(layer);

const video = document.createElement('video');
video.src =
  'https://upload.wikimedia.org/wikipedia/commons/transcoded/c/c4/Physicsworks.ogv/Physicsworks.ogv.240p.vp9.webm';

const image = new Konva.Image({
  image: video,
  draggable: true,
  x: 50,
  y: 20,
});
layer.add(image);

const text = new Konva.Text({
  text: 'Loading video...',
  width: stage.width(),
  height: stage.height(),
  align: 'center',
  verticalAlign: 'middle',
});
layer.add(text);

const anim = new Konva.Animation(function () {
  // do nothing, animation just needs to update the layer
}, layer);

// update Konva.Image size when meta is loaded
video.addEventListener('loadedmetadata', function () {
  text.text('Press PLAY...');
  image.width(video.videoWidth);
  image.height(video.videoHeight);
});

document.getElementById('play').addEventListener('click', function () {
  text.destroy();
  video.play();
  anim.start();
});
document.getElementById('pause').addEventListener('click', function () {
  video.pause();
  anim.stop();
});

----------------------------------------

TITLE: Creating Sprite Animation with React and Konva
DESCRIPTION: Implements the same sprite animation using React with react-konva. Uses hooks for state management and refs for sprite control. Includes the same idle and punch animations with similar functionality to the vanilla version.

LANGUAGE: javascript
CODE:
import { Stage, Layer, Sprite } from 'react-konva';
import { useEffect, useRef } from 'react';
import useImage from 'use-image';

const App = () => {
  const spriteRef = useRef(null);
  const [image] = useImage('https://konvajs.org/assets/blob-sprite.png');

  const animations = {
    idle: [
      2, 2, 70, 119,      // frame 1
      71, 2, 74, 119,     // frame 2
      146, 2, 81, 119,    // frame 3
      226, 2, 76, 119,    // frame 4
    ],
    punch: [
      2, 138, 74, 122,    // frame 1
      76, 138, 84, 122,   // frame 2
      346, 138, 120, 122, // frame 3
    ],
  };

  useEffect(() => {
    if (spriteRef.current) {
      spriteRef.current.start();
    }
  }, [image]);

  const handlePunch = () => {
    if (spriteRef.current) {
      const sprite = spriteRef.current;
      sprite.animation('punch');
      sprite.on('frameIndexChange.button', function() {
        if (this.frameIndex() === 2) {
          setTimeout(() => {
            sprite.animation('idle');
            sprite.off('.button');
          }, 1000 / sprite.frameRate());
        }
      });
    }
  };

  return (
    <>
      <Stage width={window.innerWidth} height={window.innerHeight}>
        <Layer>
          <Sprite
            ref={spriteRef}
            x={50}
            y={50}
            image={image}
            animation="idle"
            animations={animations}
            frameRate={7}
            frameIndex={0}
          />
        </Layer>
      </Stage>
      <button 
        onClick={handlePunch}
        style={{ position: 'absolute', top: 0, left: 0 }}
      >
        Punch
      </button>
    </>
  );
};

export default App;

----------------------------------------

TITLE: Converting Konva Stage to Data URL in Vanilla JavaScript
DESCRIPTION: This snippet demonstrates how to create a Konva stage with a draggable rectangle and convert it to a data URL. It uses the toDataURL() method to generate both default and JPEG image URLs.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const stage = new Konva.Stage({
  container: 'container',
  width: 400,
  height: 400
});

const layer = new Konva.Layer();
stage.add(layer);

// create draggable rectangle
const rect = new Konva.Rect({
  x: 100,
  y: 100,
  width: 100,
  height: 100,
  fill: 'red',
  stroke: 'black',
  strokeWidth: 4,
  draggable: true
});

layer.add(rect);

// add button
const button = document.createElement('button');
button.textContent = 'Save as Image';
document.body.appendChild(button);

button.addEventListener('click', () => {
  // get data URL with default settings
  const dataURL = stage.toDataURL();
  
  // open in new window
  const win = window.open();
  win.document.write(`<img src="${dataURL}" alt="Stage"/>`);
  
  // you can also save with different settings
  const jpegURL = stage.toDataURL({
    mimeType: 'image/jpeg',
    quality: 0.8
  });
  console.log('JPEG URL:', jpegURL);
});

----------------------------------------

TITLE: Creating HSV Filter with Konva in Vue.js
DESCRIPTION: This Vue.js component demonstrates how to use Konva to load an image, apply an HSV filter, and create interactive sliders for adjusting the filter parameters. It uses the vue-konva library and Vue 3 composition API.

LANGUAGE: vue
CODE:
<template>
  <div>
    <v-stage :config="stageSize">
      <v-layer>
        <v-image
          ref="imageNode"
          :config="{
            x: 50,
            y: 50,
            image: image,
            draggable: true,
            filters: [Konva.Filters.HSV],
            hue: hue,
            saturation: saturation,
            value: value,
          }"
        />
      </v-layer>
    </v-stage>
    <div style="position: absolute; top: 20px; left: 20px">
      <div>
        Hue
        <input
          type="range"
          min="-259"
          max="259"
          :value="hue"
          @input="(e) => hue = parseInt(e.target.value)"
        />
      </div>
      <div>
        Saturation
        <input
          type="range"
          min="-2"
          max="10"
          step="0.1"
          :value="saturation"
          @input="(e) => saturation = parseFloat(e.target.value)"
        />
      </div>
      <div>
        Value
        <input
          type="range"
          min="-2"
          max="2"
          step="0.1"
          :value="value"
          @input="(e) => value = parseFloat(e.target.value)"
        />
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, watch, nextTick } from 'vue';
import { useImage } from 'vue-konva';
import Konva from 'konva';

const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight,
};

const hue = ref(0);
const saturation = ref(0);
const value = ref(0);
const imageNode = ref(null);
const [image] = useImage('https://konvajs.org/assets/lion.png', 'anonymous');

watch(image, async (newImage) => {
  if (newImage) {
    await nextTick();
    imageNode.value.getNode().cache();
  }
});
</script>

----------------------------------------

TITLE: Implementing Animation Controls in Vanilla JavaScript with Konva
DESCRIPTION: Creates an animated circle using Konva.js with start/stop controls. The animation moves the circle horizontally using a sine wave pattern. Includes stage setup, circle creation, and button controls for animation.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const stage = new Konva.Stage({
container: 'container',
width: window.innerWidth,
height: window.innerHeight,
});

const layer = new Konva.Layer();
stage.add(layer);

const circle = new Konva.Circle({
x: stage.width() / 2,
y: stage.height() / 2,
radius: 30,
fill: 'red',
stroke: 'black',
strokeWidth: 4,
});
layer.add(circle);

const container = document.createElement('div');
document.body.appendChild(container);
container.style.position = 'absolute';
container.style.top = '0px';
container.style.left = '0px';

const startBtn = document.createElement('button');
startBtn.textContent = 'Start Animation';
container.appendChild(startBtn);

const stopBtn = document.createElement('button');
stopBtn.textContent = 'Stop Animation';
container.appendChild(stopBtn);

const anim = new Konva.Animation(function(frame) {
circle.x(
amplitude * Math.sin((frame.time * 2 * Math.PI) / period) +
stage.width() / 2
);
}, layer);

const amplitude = 100;
const period = 2000;

startBtn.addEventListener('click', () => anim.start());
stopBtn.addEventListener('click', () => anim.stop());

----------------------------------------

TITLE: Implementing Shape Snapping with Konva.js
DESCRIPTION: Creates a canvas with draggable shapes that snap to stage borders, stage center, and other shapes' edges. Uses guidelines to visualize snapping points and includes logic for calculating snap positions and drawing guide lines.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

var width = window.innerWidth;
var height = window.innerHeight;
var GUIDELINE_OFFSET = 5;

var stage = new Konva.Stage({
  container: 'container',
  width: width,
  height: height,
});

var layer = new Konva.Layer();
stage.add(layer);

// first generate random rectangles
for (var i = 0; i < 5; i++) {
  layer.add(
    new Konva.Rect({
      x: Math.random() * stage.width(),
      y: Math.random() * stage.height(),
      width: 50 + Math.random() * 50,
      height: 50 + Math.random() * 50,
      fill: Konva.Util.getRandomColor(),
      rotation: Math.random() * 360,
      draggable: true,
      name: 'object',
    })
  );
}

// were can we snap our objects?
function getLineGuideStops(skipShape) {
  // we can snap to stage borders and the center of the stage
  var vertical = [0, stage.width() / 2, stage.width()];
  var horizontal = [0, stage.height() / 2, stage.height()];

  // and we snap over edges and center of each object on the canvas
  stage.find('.object').forEach((guideItem) => {
    if (guideItem === skipShape) {
      return;
    }
    var box = guideItem.getClientRect();
    // and we can snap to all edges of shapes
    vertical.push([box.x, box.x + box.width, box.x + box.width / 2]);
    horizontal.push([box.y, box.y + box.height, box.y + box.height / 2]);
  });
  return {
    vertical: vertical.flat(),
    horizontal: horizontal.flat(),
  };
}

// what points of the object will trigger to snapping?
// it can be just center of the object
// but we will enable all edges and center
function getObjectSnappingEdges(node) {
  var box = node.getClientRect();
  var absPos = node.absolutePosition();

  return {
    vertical: [
      {
        guide: Math.round(box.x),
        offset: Math.round(absPos.x - box.x),
        snap: 'start',
      },
      {
        guide: Math.round(box.x + box.width / 2),
        offset: Math.round(absPos.x - box.x - box.width / 2),
        snap: 'center',
      },
      {
        guide: Math.round(box.x + box.width),
        offset: Math.round(absPos.x - box.x - box.width),
        snap: 'end',
      },
    ],
    horizontal: [
      {
        guide: Math.round(box.y),
        offset: Math.round(absPos.y - box.y),
        snap: 'start',
      },
      {
        guide: Math.round(box.y + box.height / 2),
        offset: Math.round(absPos.y - box.y - box.height / 2),
        snap: 'center',
      },
      {
        guide: Math.round(box.y + box.height),
        offset: Math.round(absPos.y - box.y - box.height),
        snap: 'end',
      },
    ],
  };
}

// find all snapping possibilities
function getGuides(lineGuideStops, itemBounds) {
  var resultV = [];
  var resultH = [];

  lineGuideStops.vertical.forEach((lineGuide) => {
    itemBounds.vertical.forEach((itemBound) => {
      var diff = Math.abs(lineGuide - itemBound.guide);
      // if the distance between guild line and object snap point is close we can consider this for snapping
      if (diff < GUIDELINE_OFFSET) {
        resultV.push({
          lineGuide: lineGuide,
          diff: diff,
          snap: itemBound.snap,
          offset: itemBound.offset,
        });
      }
    });
  });

  lineGuideStops.horizontal.forEach((lineGuide) => {
    itemBounds.horizontal.forEach((itemBound) => {
      var diff = Math.abs(lineGuide - itemBound.guide);
      if (diff < GUIDELINE_OFFSET) {
        resultH.push({
          lineGuide: lineGuide,
          diff: diff,
          snap: itemBound.snap,
          offset: itemBound.offset,
        });
      }
    });
  });

  var guides = [];

  // find closest snap
  var minV = resultV.sort((a, b) => a.diff - b.diff)[0];
  var minH = resultH.sort((a, b) => a.diff - b.diff)[0];
  if (minV) {
    guides.push({
      lineGuide: minV.lineGuide,
      offset: minV.offset,
      orientation: 'V',
      snap: minV.snap,
    });
  }
  if (minH) {
    guides.push({
      lineGuide: minH.lineGuide,
      offset: minH.offset,
      orientation: 'H',
      snap: minH.snap,
    });
  }
  return guides;
}

function drawGuides(guides) {
  guides.forEach((lg) => {
    if (lg.orientation === 'H') {
      var line = new Konva.Line({
        points: [-6000, 0, 6000, 0],
        stroke: 'rgb(0, 161, 255)',
        strokeWidth: 1,
        name: 'guid-line',
        dash: [4, 6],
      });
      layer.add(line);
      line.absolutePosition({
        x: 0,
        y: lg.lineGuide,
      });
    } else if (lg.orientation === 'V') {
      var line = new Konva.Line({
        points: [0, -6000, 0, 6000],
        stroke: 'rgb(0, 161, 255)',
        strokeWidth: 1,
        name: 'guid-line',
        dash: [4, 6],
      });
      layer.add(line);
      line.absolutePosition({
        x: lg.lineGuide,
        y: 0,
      });
    }
  });
}

layer.on('dragmove', function (e) {
  // clear all previous lines on the screen
  layer.find('.guid-line').forEach((l) => l.destroy());

  // find possible snapping lines
  var lineGuideStops = getLineGuideStops(e.target);
  // find snapping points of current object
  var itemBounds = getObjectSnappingEdges(e.target);

  // now find where can we snap current object
  var guides = getGuides(lineGuideStops, itemBounds);

  // do nothing of no snapping
  if (!guides.length) {
    return;
  }

  drawGuides(guides);

  var absPos = e.target.absolutePosition();
  // now force object position
  guides.forEach((lg) => {
    switch (lg.orientation) {
      case 'V': {
        absPos.x = lg.lineGuide + lg.offset;
        break;
      }
      case 'H': {
        absPos.y = lg.lineGuide + lg.offset;
        break;
      }
    }
  });
  e.target.absolutePosition(absPos);
});

layer.on('dragend', function (e) {
  // clear all previous lines on the screen
  layer.find('.guid-line').forEach((l) => l.destroy());
});

----------------------------------------

TITLE: Applying Contrast Filter to Image in Vue.js with Konva.js
DESCRIPTION: This snippet demonstrates how to apply a contrast filter to an image using Konva.js in a Vue.js component. It uses the vue-konva library and includes a template with a stage, layer, and image, along with an interactive slider for adjusting the contrast value.

LANGUAGE: vue
CODE:
<template>
  <div>
    <v-stage :config="stageSize">
      <v-layer>
        <v-image
          ref="imageNode"
          :config="{
            x: 50,
            y: 50,
            image: image,
            draggable: true,
            filters: [Konva.Filters.Contrast],
            contrast: contrast,
          }"
        />
      </v-layer>
    </v-stage>
    <input
      type="range"
      min="-100"
      max="100"
      :value="contrast"
      @input="handleSlider"
      style="position: absolute; top: 20px; left: 20px"
    />
  </div>
</template>

<script setup>
import { ref, watch, nextTick } from 'vue';
import { useImage } from 'vue-konva';
import Konva from 'konva';

const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight,
};

const contrast = ref(50);
const imageNode = ref(null);
const [image] = useImage('https://konvajs.org/assets/lion.png', 'anonymous');

watch(image, async (newImage) => {
  if (newImage) {
    await nextTick();
    imageNode.value.getNode().cache();
  }
});

const handleSlider = (e) => {
  contrast.value = parseInt(e.target.value);
};
</script>

----------------------------------------

TITLE: Implementing Image Drag and Drop in React with Konva
DESCRIPTION: This code snippet demonstrates how to create a React component that enables dragging and dropping images into a Konva canvas. It uses the useImage hook for image loading, implements drag and drop event handlers, and dynamically renders dropped images on the canvas.

LANGUAGE: jsx
CODE:
import React from 'react';
import { Stage, Layer, Image } from 'react-konva';
import useImage from 'use-image';

const URLImage = ({ image }) => {
  const [img] = useImage(image.src);
  return (
    <Image
      image={img}
      x={image.x}
      y={image.y}
      // I will use offset to set origin to the center of the image
      offsetX={img ? img.width / 2 : 0}
      offsetY={img ? img.height / 2 : 0}
      draggable
    />
  );
};

const App = () => {
  const dragUrl = React.useRef();
  const stageRef = React.useRef();
  const [images, setImages] = React.useState([]);
  return (
    <div>
      Try to drag and drop the image into the stage:
      <br />
      <img
        alt="lion"
        src="https://konvajs.org/assets/lion.png"
        draggable="true"
        onDragStart={(e) => {
          dragUrl.current = e.target.src;
        }}
      />
      <div
        onDrop={(e) => {
          e.preventDefault();
          // register event position
          stageRef.current.setPointersPositions(e);
          // add image
          setImages(
            images.concat([
              {
                ...stageRef.current.getPointerPosition(),
                src: dragUrl.current,
              },
            ])
          );
        }}
        onDragOver={(e) => e.preventDefault()}
      >
        <Stage
          width={window.innerWidth}
          height={window.innerHeight}
          style={{ border: '1px solid grey' }}
          ref={stageRef}
        >
          <Layer>
            {images.map((image) => {
              return <URLImage image={image} />;
            })}
          </Layer>
        </Stage>
      </div>
    </div>
  );
};

export default App;

----------------------------------------

TITLE: Implementing Editable Text with Vanilla JavaScript and Konva
DESCRIPTION: Creates an editable text node using Konva with a textarea overlay for editing. Includes dragging, resizing, and text transformation capabilities. Uses DOM textarea element for actual text input handling.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

Konva._fixTextRendering = true;

const stage = new Konva.Stage({
container: 'container',
width: window.innerWidth,
height: window.innerHeight,
});

// ... [rest of vanilla JS implementation]

----------------------------------------

TITLE: Implementing Shape Resize with Ratio Preservation in Vue.js using vue-konva
DESCRIPTION: This snippet illustrates how to create resizable text shapes on an HTML5 Canvas using vue-konva in a Vue.js application. It shows two examples: one that preserves aspect ratio by default and another that only preserves ratio when the Shift key is held.

LANGUAGE: vue
CODE:
<template>
  <v-stage :config="stageSize">
    <v-layer>
      <v-text :config="text1Config" ref="text1Ref" />
      <v-transformer :config="tr1Config" ref="tr1Ref" />
      
      <v-text :config="text2Config" ref="text2Ref" />
      <v-transformer :config="tr2Config" ref="tr2Ref" />
    </v-layer>
  </v-stage>
</template>

<script setup>
import { ref, onMounted } from 'vue';

const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight
};

const text1Config = {
  x: 50,
  y: 50,
  text: 'keep ratio by default',
  fontSize: 20,
  draggable: true,
  width: 200
};

const text2Config = {
  x: 50,
  y: 150,
  text: 'no ratio, but hold shift to keep ratio',
  fontSize: 20,
  draggable: true,
  width: 200
};

const tr1Config = {};
const tr2Config = {
  keepRatio: false
};

const text1Ref = ref(null);
const text2Ref = ref(null);
const tr1Ref = ref(null);
const tr2Ref = ref(null);

onMounted(() => {
  tr1Ref.value.getNode().nodes([text1Ref.value.getNode()]);
  tr2Ref.value.getNode().nodes([text2Ref.value.getNode()]);
});
</script>

----------------------------------------

TITLE: Image Enhancement using Vue with Konva
DESCRIPTION: Vue 3 implementation of image enhancement using vue-konva. Uses the Composition API with refs and watchers to manage state and handle image caching.

LANGUAGE: javascript
CODE:
<template>
  <div>
    <v-stage :config="stageSize">
      <v-layer>
        <v-image
          ref="imageNode"
          :config="{
            x: 50,
            y: 50,
            image: image,
            draggable: true,
            filters: [Konva.Filters.Enhance],
            enhance: enhance,
          }"
        />
      </v-layer>
    </v-stage>
    <input
      type="range"
      min="-1"
      max="1"
      step="0.1"
      :value="enhance"
      @input="handleSlider"
      style="position: absolute; top: 20px; left: 20px"
    />
  </div>
</template>

<script setup>
import { ref, watch, nextTick } from 'vue';
import { useImage } from 'vue-konva';
import Konva from 'konva';

const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight,
};

const enhance = ref(0.4);
const imageNode = ref(null);
const [image] = useImage('https://konvajs.org/assets/lion.png', 'anonymous');

watch(image, async (newImage) => {
  if (newImage) {
    await nextTick();
    imageNode.value.getNode().cache();
  }
});

const handleSlider = (e) => {
  enhance.value = parseFloat(e.target.value);
};
</script>

----------------------------------------

TITLE: Implementing Drag and Drop for Multiple Shapes with Konva in Vanilla JavaScript
DESCRIPTION: This snippet creates a Konva stage with multiple draggable colored rectangles. It demonstrates how to handle drag events, remove shapes on double-click/tap, and change cursor styles on hover.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const width = window.innerWidth;
const height = window.innerHeight;

const stage = new Konva.Stage({
  container: 'container',
  width: width,
  height: height,
});

const layer = new Konva.Layer();

const colors = ['red', 'orange', 'yellow', 'green', 'blue', 'purple'];

for (let i = 0; i < 6; i++) {
  const box = new Konva.Rect({
    x: i * 30 + 50,
    y: i * 18 + 40,
    fill: colors[i],
    stroke: 'black',
    strokeWidth: 4,
    draggable: true,
    width: 100,
    height: 50,
  });

  box.on('dragstart', function () {
    this.moveToTop();
  });

  box.on('dragmove', function () {
    document.body.style.cursor = 'pointer';
  });
  
  // dblclick to remove box for desktop app
  // and dbltap to remove box for mobile app
  box.on('dblclick dbltap', function () {
    this.destroy();
  });

  box.on('mouseover', function () {
    document.body.style.cursor = 'pointer';
  });
  
  box.on('mouseout', function () {
    document.body.style.cursor = 'default';
  });

  layer.add(box);
}

// add the layer to the stage
stage.add(layer);

----------------------------------------

TITLE: Implementing Shape Rotation Snaps with Konva in React
DESCRIPTION: This React component uses react-konva to create a stage with a draggable rectangle and a transformer. It sets up rotation snaps at 0, 90, 180, and 270 degrees using the Transformer component's properties.

LANGUAGE: jsx
CODE:
import { Stage, Layer, Rect, Transformer } from 'react-konva';
import { useRef, useEffect } from 'react';

const App = () => {
  const rectRef = useRef();
  const trRef = useRef();

  useEffect(() => {
    trRef.current.nodes([rectRef.current]);
  }, []);

  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        <Rect
          x={50}
          y={50}
          width={100}
          height={50}
          fill="yellow"
          stroke="black"
          draggable
          ref={rectRef}
        />
        <Transformer
          ref={trRef}
          rotationSnaps={[0, 90, 180, 270]}
          rotationSnapTolerance={30}
        />
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Implementing Responsive Canvas with React and Konva
DESCRIPTION: React implementation of a responsive canvas using react-konva. Uses hooks (useState, useEffect, useRef) to manage stage dimensions and scaling. Implements the same visual elements as the vanilla version with React components.

LANGUAGE: jsx
CODE:
import { useState, useEffect, useRef } from 'react';
import { Stage, Layer, Circle, Rect, Text } from 'react-konva';

const App = () => {
  const sceneWidth = 1000;
  const sceneHeight = 1000;
  
  const [stageSize, setStageSize] = useState({
    width: sceneWidth,
    height: sceneHeight,
    scale: 1
  });
  
  const containerRef = useRef(null);
  
  const updateSize = () => {
    if (!containerRef.current) return;
    const containerWidth = containerRef.current.offsetWidth;
    const scale = containerWidth / sceneWidth;
    setStageSize({
      width: sceneWidth * scale,
      height: sceneHeight * scale,
      scale: scale
    });
  };
  
  useEffect(() => {
    updateSize();
    window.addEventListener('resize', updateSize);
    return () => {
      window.removeEventListener('resize', updateSize);
    };
  }, []);
  
  return (
    <div ref={containerRef} style={{ width: '100%', height: '100%' }}>
      <Stage 
        width={stageSize.width} 
        height={stageSize.height}
        scaleX={stageSize.scale}
        scaleY={stageSize.scale}
      >
        <Layer>
          <Circle
            radius={50}
            fill="red"
            x={sceneWidth / 2}
            y={sceneHeight / 2}
          />
          <Rect
            fill="green"
            x={sceneWidth - 100}
            y={sceneHeight - 100}
            width={100}
            height={100}
          />
          <Text
            x={20}
            y={20}
            text="Try resizing your browser window"
            fontSize={20}
            fontFamily="Arial"
            fill="black"
          />
        </Layer>
      </Stage>
    </div>
  );
};

----------------------------------------

TITLE: Implementing Responsive Canvas with Vanilla JavaScript and Konva
DESCRIPTION: Creates a responsive canvas stage that scales to fit the window width while maintaining aspect ratio. Includes a circle, rectangle, and text elements that scale proportionally. Uses event listeners to handle window resizing.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const sceneWidth = 1000;
const sceneHeight = 1000;

const stage = new Konva.Stage({
  container: 'container',
  width: sceneWidth,
  height: sceneHeight,
});

const layer = new Konva.Layer();
stage.add(layer);

const circle = new Konva.Circle({
  radius: 50,
  fill: 'red',
  x: stage.width() / 2,
  y: stage.height() / 2,
});
layer.add(circle);

const rect = new Konva.Rect({
  fill: 'green',
  x: stage.width() - 100,
  y: stage.height() - 100,
  width: 100,
  height: 100,
});
layer.add(rect);

const text = new Konva.Text({
  x: 20,
  y: 20,
  text: 'Try resizing your browser window',
  fontSize: 20,
  fontFamily: 'Arial',
  fill: 'black',
});
layer.add(text);

function fitStageIntoParentContainer() {
  const container = document.getElementById('container');
  container.style.width = '100%';
  const containerWidth = container.offsetWidth;
  const scale = containerWidth / sceneWidth;
  stage.width(sceneWidth * scale);
  stage.height(sceneHeight * scale);
  stage.scale({ x: scale, y: scale });
}

fitStageIntoParentContainer();
window.addEventListener('resize', fitStageIntoParentContainer);

----------------------------------------

TITLE: Creating Noise Filter with Vue and Konva
DESCRIPTION: Vue 3 implementation of image noise filtering using vue-konva. Uses composition API with refs and watchers for managing image state and caching. Includes a slider component for noise control.

LANGUAGE: javascript
CODE:
<template>
  <div>
    <v-stage :config="stageSize">
      <v-layer>
        <v-image
          ref="imageNode"
          :config="{
            x: 50,
            y: 50,
            image: image,
            draggable: true,
            filters: [Konva.Filters.Noise],
            noise: noise,
          }"
        />
      </v-layer>
    </v-stage>
    <input
      type="range"
      min="0"
      max="1"
      step="0.1"
      :value="noise"
      @input="handleSlider"
      style="position: absolute; top: 20px; left: 20px"
    />
  </div>
</template>

<script setup>
import { ref, watch, nextTick } from 'vue';
import { useImage } from 'vue-konva';
import Konva from 'konva';

const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight,
};

const noise = ref(0.5);
const imageNode = ref(null);
const [image] = useImage('https://konvajs.org/assets/lion.png', 'anonymous');

watch(image, async (newImage) => {
  if (newImage) {
    await nextTick();
    imageNode.value.getNode().cache();
  }
});

const handleSlider = (e) => {
  noise.value = parseFloat(e.target.value);
};
</script>

----------------------------------------

TITLE: Implementing Shape Caching with Konva.js in React
DESCRIPTION: This React component demonstrates shape caching in Konva.js. It creates two star shapes with blur filters, caches one, and animates both to show the performance difference. The component uses refs to access and manipulate Konva objects.

LANGUAGE: jsx
CODE:
import { Stage, Layer, Star, Text } from 'react-konva';
import { useEffect, useRef } from 'react';

const App = () => {
  const nonCachedStarRef = useRef(null);
  const cachedStarRef = useRef(null);
  const fpsTextRef = useRef(null);

  useEffect(() => {
    // Add blur filter and cache to the cached star
    if (cachedStarRef.current) {
      cachedStarRef.current.cache();
      cachedStarRef.current.filters([Konva.Filters.Blur]);
      cachedStarRef.current.blurRadius(5);
    }

    // Add blur filter to non-cached star
    if (nonCachedStarRef.current) {
      nonCachedStarRef.current.filters([Konva.Filters.Blur]);
      nonCachedStarRef.current.blurRadius(5);
    }

    const anim = new Konva.Animation((frame) => {
      // Rotate stars
      nonCachedStarRef.current.rotation(frame.time * 0.1);
      cachedStarRef.current.rotation(frame.time * 0.1);
      
      // Update FPS counter
      fpsTextRef.current.text('FPS: ' + frame.frameRate.toFixed(1));
    }, nonCachedStarRef.current.getLayer());

    anim.start();
    return () => anim.stop();
  }, []);

  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        {/* Non-cached complex shape */}
        <Star
          ref={nonCachedStarRef}
          x={100}
          y={100}
          numPoints={20}
          innerRadius={40}
          outerRadius={70}
          fill="yellow"
          stroke="black"
          strokeWidth={4}
        />
        
        {/* Cached complex shape */}
        <Star
          ref={cachedStarRef}
          x={250}
          y={100}
          numPoints={20}
          innerRadius={40}
          outerRadius={70}
          fill="yellow"
          stroke="black"
          strokeWidth={4}
        />
        
        {/* Labels */}
        <Text
          x={50}
          y={200}
          text="Non-Cached Shape"
          fontSize={16}
        />
        <Text
          x={200}
          y={200}
          text="Cached Shape\n(Better Performance)"
          fontSize={16}
        />
        
        {/* FPS counter */}
        <Text
          ref={fpsTextRef}
          x={10}
          y={10}
          text="FPS: 0"
          fontSize={16}
        />
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Converting Konva Canvas to PDF - Vanilla JavaScript
DESCRIPTION: Demonstrates creating a Konva stage with various elements (text, arrow, image) and exporting it to PDF using jsPDF. Includes special handling for text selectability and high-quality export using pixelRatio.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

// Create a button for PDF export
const saveButton = document.createElement('button');
saveButton.textContent = 'Save as PDF';
saveButton.style.position = 'absolute';
saveButton.style.top = '5px';
saveButton.style.left = '5px';
document.body.appendChild(saveButton);

// Create a stage
const width = window.innerWidth;
const height = window.innerHeight;

const stage = new Konva.Stage({
  container: 'container',
  width: width,
  height: height,
});

const layer = new Konva.Layer();
stage.add(layer);

// Add background
const back = new Konva.Rect({
  width: stage.width(),
  height: stage.height(),
  fill: 'rgba(200, 200, 200)',
});
layer.add(back);

// Add text with blur effect
const text = new Konva.Text({
  text: 'This is the Darth Vader',
  x: 15,
  y: 40,
  rotation: -10,
  filters: [Konva.Filters.Blur],
  blurRadius: 4,
  fontSize: 18,
});
text.cache();
layer.add(text);

// Add arrow
const arrow = new Konva.Arrow({
  points: [70, 50, 100, 80, 150, 100, 190, 100],
  tension: 0.5,
  stroke: 'black',
  fill: 'black',
});
layer.add(arrow);

// Add image
const imageUrl = 'https://konvajs.org/assets/darth-vader.jpg';
Konva.Image.fromURL(
  imageUrl,
  function (darthNode) {
    darthNode.setAttrs({
      x: 200,
      y: 50,
      scaleX: 0.5,
      scaleY: 0.5,
    });
    layer.add(darthNode);
  },
  function () {
    console.error('Failed to load image');
  }
);

// Handle PDF export
saveButton.addEventListener('click', function () {
  if (typeof jsPDF !== 'undefined') {
    const pdf = new jsPDF('l', 'px', [stage.width(), stage.height()]);
    pdf.setTextColor('#000000');
    
    // First add texts
    stage.find('Text').forEach((text) => {
      const size = text.fontSize() / 0.75;
      pdf.setFontSize(size);
      pdf.text(text.text(), text.x(), text.y(), {
        baseline: 'top',
        angle: -text.getAbsoluteRotation(),
      });
    });

    pdf.addImage(
      stage.toDataURL({ pixelRatio: 2 }),
      0,
      0,
      stage.width(),
      stage.height()
    );

    pdf.save('canvas.pdf');
  } else {
    console.error('jsPDF library is not loaded');
    alert('jsPDF library is not loaded. In a real project, you need to include it.');
  }
});

----------------------------------------

TITLE: Implementing RGB Filter with React and Konva
DESCRIPTION: React implementation of RGB filter controls using react-konva. Uses hooks for state management and ref for accessing the canvas node. Implements the same functionality as the vanilla version but with React components and state management.

LANGUAGE: jsx
CODE:
const App = () => {
  const [red, setRed] = useState(100);
  const [green, setGreen] = useState(100);
  const [blue, setBlue] = useState(100);
  const [image] = useImage('https://konvajs.org/assets/lion.png', 'anonymous');
  const imageRef = useRef(null);

  useEffect(() => {
    if (image && imageRef.current) {
      imageRef.current.cache();
    }
  }, [image]);

  return (
    <>
      <Stage width={window.innerWidth} height={window.innerHeight}>
        <Layer>
          <Image
            ref={imageRef}
            x={50}
            y={50}
            image={image}
            draggable
            filters={[Konva.Filters.RGB]}
            red={red}
            green={green}
            blue={blue}
          />
        </Layer>
      </Stage>
      <div style={{ position: 'absolute', top: '20px', left: '20px' }}>
        <div>
          Red
          <input
            type="range"
            min="0"
            max="255"
            value={red}
            onChange={(e) => setRed(parseInt(e.target.value))}
          />
        </div>
        <div>
          Green
          <input
            type="range"
            min="0"
            max="255"
            value={green}
            onChange={(e) => setGreen(parseInt(e.target.value))}
          />
        </div>
        <div>
          Blue
          <input
            type="range"
            min="0"
            max="255"
            value={blue}
            onChange={(e) => setBlue(parseInt(e.target.value))}
          />
        </div>
      </div>
    </>
  );
};

----------------------------------------

TITLE: Creating Konva Stage with Vue
DESCRIPTION: This snippet demonstrates how to create a Konva stage using Vue components. It sets up a stage with a circle and uses Vue's reactive properties to manage the circle's configuration, allowing for dynamic color changes on click.

LANGUAGE: vue
CODE:
<template>
  <v-stage :config="stageSize">
    <v-layer>
      <v-circle
        :config="circleConfig"
        @click="handleClick"
      />
    </v-layer>
  </v-stage>
</template>

<script setup>
import { ref } from 'vue';
import Konva from 'konva';

const stageSize = {
  width: 400,
  height: 400
};

const circleConfig = ref({
  x: 100,
  y: 100,
  radius: 50,
  fill: 'red',
  stroke: 'black',
  strokeWidth: 3
});

const handleClick = () => {
  circleConfig.value = {
    ...circleConfig.value,
    fill: Konva.Util.getRandomColor()
  };
};
</script>

----------------------------------------

TITLE: Applying Invert Filter to Image with Konva.js (Vanilla JavaScript)
DESCRIPTION: This snippet shows how to create a Konva stage, load an image, and apply an invert filter to it using vanilla JavaScript. It demonstrates the use of Konva.Image, caching, and the Konva.Filters.Invert filter.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight,
});

const layer = new Konva.Layer();
stage.add(layer);

const imageObj = new Image();
imageObj.onload = () => {
  const image = new Konva.Image({
    x: 50,
    y: 50,
    image: imageObj,
    draggable: true,
  });

  layer.add(image);

  image.cache();
  image.filters([Konva.Filters.Invert]);
};
imageObj.src = 'https://konvajs.org/assets/lion.png';
imageObj.crossOrigin = 'anonymous';

----------------------------------------

TITLE: Implementing Custom Hit Detection with Vanilla JavaScript and Konva
DESCRIPTION: Demonstrates how to create custom hit regions for stars and lines using Konva. Shows implementation of hitFunc for circular hit detection on a star shape and hitStrokeWidth for easier line interaction. Includes toggle functionality to visualize the hit canvas for debugging.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight,
});

const layer = new Konva.Layer();
stage.add(layer);

const text = new Konva.Text({
  x: 10,
  y: 10,
  text: '',
  fontSize: 24,
});
layer.add(text);

const star = new Konva.Star({
  x: stage.width() / 4,
  y: stage.height() / 2,
  numPoints: 5,
  innerRadius: 40,
  outerRadius: 70,
  fill: 'red',
  stroke: 'black',
  strokeWidth: 4,
});

star.hitFunc(function (context) {
  context.beginPath();
  context.arc(0, 0, 70, 0, Math.PI * 2, true);
  context.closePath();
  context.fillStrokeShape(this);
});

const line = new Konva.Line({
  x: stage.width() * 0.6,
  y: stage.height() / 2,
  points: [-50, -50, 50, 50],
  stroke: 'black',
  strokeWidth: 2,
  hitStrokeWidth: 20,
});

----------------------------------------

TITLE: Implementing Canvas Background with Vanilla JavaScript and Konva
DESCRIPTION: Demonstrates how to add both CSS and gradient backgrounds to a Konva stage using vanilla JavaScript. Includes stage initialization, background rectangle creation with gradient, and drag functionality handling.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const width = window.innerWidth;
const height = window.innerHeight;

const stage = new Konva.Stage({
  container: 'container',
  width: width,
  height: height,
  draggable: true,
});

const layer = new Konva.Layer();
stage.add(layer);

stage.container().style.backgroundColor = 'green';

const background = new Konva.Rect({
  x: 0,
  y: 0,
  width: stage.width(),
  height: stage.height(),
  fillLinearGradientStartPoint: { x: 0, y: 0 },
  fillLinearGradientEndPoint: { x: stage.width(), y: stage.height() },
  fillLinearGradientColorStops: [
    0,
    'yellow',
    0.5,
    'blue',
    0.6,
    'rgba(0, 0, 0, 0)',
  ],
  listening: false,
});
layer.add(background);

stage.on('dragmove', () => {
  background.absolutePosition({ x: 0, y: 0 });
});

const circle = new Konva.Circle({
  x: stage.width() / 2,
  y: stage.height() / 2,
  radius: 100,
  fill: 'red',
});
layer.add(circle);

----------------------------------------

TITLE: Creating Text Elements with Vanilla Konva
DESCRIPTION: Demonstrates creation of simple and complex text elements using vanilla Konva. Includes examples of text positioning, styling, and adding background rectangle with shadow effects.

LANGUAGE: javascript
CODE:
const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight
});

const layer = new Konva.Layer();
stage.add(layer);

// Simple text
const simpleText = new Konva.Text({
  x: stage.width() / 2,
  y: 15,
  text: 'Simple Text',
  fontSize: 30,
  fontFamily: 'Calibri',
  fill: 'green'
});

simpleText.offsetX(simpleText.width() / 2);

// Complex text with background
const complexText = new Konva.Text({
  x: 20,
  y: 60,
  text: "COMPLEX TEXT\n\nAll the world's a stage, and all the men and women merely players. They have their exits and their entrances.",
  fontSize: 18,
  fontFamily: 'Calibri',
  fill: '#555',
  width: 300,
  padding: 20,
  align: 'center'
});

----------------------------------------

TITLE: Implementing Responsive Canvas with Vue and Konva
DESCRIPTION: Vue 3 implementation of a responsive canvas using vue-konva. Uses the Composition API with refs and computed properties to manage stage dimensions and scaling. Implements the same visual elements as other versions with Vue components.

LANGUAGE: vue
CODE:
<template>
  <div ref="containerRef" style="width: 100%; height: 100%;">
    <v-stage
      :config="{
        width: stageWidth,
        height: stageHeight,
        scaleX: scale,
        scaleY: scale
      }"
    >
      <v-layer>
        <v-circle
          :config="{
            radius: 50,
            fill: 'red',
            x: sceneWidth / 2,
            y: sceneHeight / 2
          }"
        />
        <v-rect
          :config="{
            fill: 'green',
            x: sceneWidth - 100,
            y: sceneHeight - 100,
            width: 100,
            height: 100
          }"
        />
        <v-text
          :config="{
            x: 20,
            y: 20,
            text: 'Try resizing your browser window',
            fontSize: 20,
            fontFamily: 'Arial',
            fill: 'black'
          }"
        />
      </v-layer>
    </v-stage>
  </div>
</template>

<script setup>
import { ref, onMounted, onUnmounted, computed } from 'vue';

const sceneWidth = 1000;
const sceneHeight = 1000;

const containerRef = ref(null);
const scale = ref(1);

const stageWidth = computed(() => sceneWidth * scale.value);
const stageHeight = computed(() => sceneHeight * scale.value);

const updateSize = () => {
  if (!containerRef.value) return;
  const containerWidth = containerRef.value.offsetWidth;
  scale.value = containerWidth / sceneWidth;
};

onMounted(() => {
  updateSize();
  window.addEventListener('resize', updateSize);
});

onUnmounted(() => {
  window.removeEventListener('resize', updateSize);
});
</script>

----------------------------------------

TITLE: Implementing Multi-touch Gestures with Konva and Hammer.js
DESCRIPTION: Complete implementation showing how to add gesture support to Konva shapes using a modified version of Hammer.js. Demonstrates handling of swipe, rotate, press, and pinch-zoom gestures on a rectangle shape. Includes touch event emulation for desktop testing.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

// Load required scripts
const loadScript = (src) => {
  return new Promise((resolve, reject) => {
    if (document.querySelector(`script[src="${src}"]`)) {
      resolve();
      return;
    }
    const script = document.createElement('script');
    script.src = src;
    script.onload = resolve;
    script.onerror = reject;
    document.head.appendChild(script);
  });
};

// Initialize the demo after loading dependencies
async function initDemo() {
  try {
    await loadScript('https://cdn.rawgit.com/hammerjs/touchemulator/master/touch-emulator.js');
    await loadScript('https://konvajs.org/js/hammer-konva.js');

    // emulate touches on desktop
    TouchEmulator();
    Konva.hitOnDragEnabled = true;
    Konva.captureTouchEventsEnabled = true;

    const stage = new Konva.Stage({
      container: 'container',
      width: window.innerWidth,
      height: window.innerHeight,
    });

    const layer = new Konva.Layer();
    stage.add(layer);

    const originalAttrs = {
      x: stage.width() / 2,
      y: stage.height() / 2,
      scaleX: 1,
      scaleY: 1,
      draggable: true,
      rotation: 0,
    };

    const group = new Konva.Group(originalAttrs);
    layer.add(group);

    const size = 200;

    const rect = new Konva.Rect({
      width: size,
      height: size,
      fill: 'yellow',
      offsetX: size / 2,
      offsetY: size / 2,
      cornerRadius: 5,
      shadowBlur: 10,
      shadowColor: 'grey',
    });
    group.add(rect);

    const defaultText = 'Try\ndrag, swipe, pinch zoom, rotate, press...';
    const text = new Konva.Text({
      text: defaultText,
      x: -size / 2,
      width: size,
      align: 'center',
    });
    group.add(text);

    const hammertime = new Hammer(group, { domEvents: true });

    hammertime.get('rotate').set({ enable: true });

    group.on('swipe', function (ev) {
      text.text('swiping');
      group.to({
        x: group.x() + ev.evt.gesture.deltaX,
        y: group.y() + ev.evt.gesture.deltaY,
        onFinish: function () {
          group.to(Object.assign({}, originalAttrs));
          text.text(defaultText);
        },
      });
    });

    group.on('press', function (ev) {
      text.text('Under press');
      rect.to({
        fill: 'green',
      });
    });

    group.on('touchend', function (ev) {
      rect.to({
        fill: 'yellow',
      });

      setTimeout(() => {
        text.text(defaultText);
      }, 300);
    });

    group.on('dragend', () => {
      group.to(Object.assign({}, originalAttrs));
    });

    let oldRotation = 0;
    let startScale = 0;
    group.on('rotatestart', function (ev) {
      oldRotation = ev.evt.gesture.rotation;
      startScale = rect.scaleX();
      group.stopDrag();
      group.draggable(false);
      text.text('rotating...');
    });

    group.on('rotate', function (ev) {
      const delta = oldRotation - ev.evt.gesture.rotation;
      group.rotate(-delta);
      oldRotation = ev.evt.gesture.rotation;
      group.scaleX(startScale * ev.evt.gesture.scale);
      group.scaleY(startScale * ev.evt.gesture.scale);
    });

    group.on('rotateend rotatecancel', function (ev) {
      group.to(Object.assign({}, originalAttrs));
      text.text(defaultText);
      group.draggable(true);
    });
  } catch (error) {
    console.error('Failed to initialize demo:', error);
  }
}

// Start the demo
initDemo();

----------------------------------------

TITLE: React-Konva Optimized Animation Implementation
DESCRIPTION: React implementation of optimized Konva animations using hooks and refs. Demonstrates proper component lifecycle management and shape caching in a React context.

LANGUAGE: jsx
CODE:
import { Stage, Layer, Star, Circle } from 'react-konva';
import { useState, useEffect, useRef } from 'react';

const App = () => {
  const [isPlaying, setIsPlaying] = useState(true);
  const starRef = useRef(null);
  const circleRef = useRef(null);
  const animRef = useRef(null);

  useEffect(() => {
    // Cache the star shape for better performance
    if (starRef.current) {
      starRef.current.cache();
    }

    // Create animation
    const anim = new Konva.Animation((frame) => {
      // Rotate star (cached shape)
      starRef.current.rotation(frame.time * 0.1);
      
      // Move circle in a circle pattern
      circleRef.current.x(100 + Math.cos(frame.time * 0.002) * 50);
      circleRef.current.y(100 + Math.sin(frame.time * 0.002) * 50);
    }, starRef.current.getLayer());

    animRef.current = anim;
    anim.start();

    return () => anim.stop();
  }, []);

  const toggleAnimation = () => {
    if (isPlaying) {
      animRef.current.stop();
    } else {
      animRef.current.start();
    }
    setIsPlaying(!isPlaying);
  };

  return (
    <div>
      <button
        onClick={toggleAnimation}
        style={{ position: 'absolute', top: '10px', left: '10px' }}
      >
        {isPlaying ? 'Stop Animation' : 'Start Animation'}
      </button>
      
      <Stage width={window.innerWidth} height={window.innerHeight}>
        <Layer>
          <Star
            ref={starRef}
            x={window.innerWidth / 2}
            y={window.innerHeight / 2}
            numPoints={6}
            innerRadius={40}
            outerRadius={70}
            fill="yellow"
            stroke="black"
            strokeWidth={4}
          />
          <Circle
            ref={circleRef}
            x={100}
            y={100}
            radius={20}
            fill="red"
          />
        </Layer>
      </Stage>
    </div>
  );

----------------------------------------

TITLE: Applying HSV Filter to Image with Konva in Vanilla JavaScript
DESCRIPTION: This snippet demonstrates how to load an image, apply an HSV filter, and create interactive sliders to adjust the filter parameters using vanilla JavaScript and Konva library.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight,
});

const layer = new Konva.Layer();
stage.add(layer);

const imageObj = new Image();
imageObj.onload = () => {
  const image = new Konva.Image({
    x: 50,
    y: 50,
    image: imageObj,
    draggable: true,
  });

  layer.add(image);

  image.cache();
  image.filters([Konva.Filters.HSV]);
  
  // create sliders
  const createSlider = (label, min, max, defaultValue, property) => {
    const container = document.createElement('div');
    container.style.position = 'absolute';
    container.style.left = '20px';
    
    const text = document.createElement('span');
    text.textContent = `${label}: `;
    container.appendChild(text);
    
    const slider = document.createElement('input');
    slider.type = 'range';
    slider.min = min;
    slider.max = max;
    slider.step = '0.1';
    slider.value = defaultValue;
    slider.style.width = '200px';
    
    slider.addEventListener('input', (e) => {
      const value = parseFloat(e.target.value);
      image[property](value);
    });
    
    container.appendChild(slider);
    return container;
  };

  const hueSlider = createSlider('Hue', -180, 180, 0, 'hue');
  hueSlider.style.top = '20px';
  document.body.appendChild(hueSlider);

  const saturationSlider = createSlider('Saturation', -2, 10, 0, 'saturation');
  saturationSlider.style.top = '45px';
  document.body.appendChild(saturationSlider);

  const value = createSlider('Value', -2, 2, 0, 'value');
  value.style.top = '70px';
  document.body.appendChild(value);
};
imageObj.src = 'https://konvajs.org/assets/lion.png';
imageObj.crossOrigin = 'anonymous';

----------------------------------------

TITLE: Implementing Desktop and Mobile Events with Vue-Konva
DESCRIPTION: Vue implementation of cross-platform event handling using vue-konva components. Uses Vue reactive references to manage text feedback for both desktop and mobile interactions.

LANGUAGE: html
CODE:
<template>
  <v-stage :config="stageSize">
    <v-layer>
      <v-text :config="textConfig" />
      <v-circle
        :config="circleConfig"
        @mousedown="handleStart"
        @touchstart="handleStart"
        @mouseup="handleEnd"
        @touchend="handleEnd"
      />
    </v-layer>
  </v-stage>
</template>

<script setup>
import { ref, computed } from 'vue';

const message = ref('');

const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight
};

const textConfig = computed(() => ({
  x: 10,
  y: 10,
  fontFamily: 'Calibri',
  fontSize: 24,
  text: message.value,
  fill: 'black'
}));

const circleConfig = {
  x: window.innerWidth / 2,
  y: window.innerHeight / 2,
  radius: 70,
  fill: 'red',
  stroke: 'black',
  strokeWidth: 4
};

const handleStart = () => {
  message.value = 'Mousedown or touchstart';
};

const handleEnd = () => {
  message.value = 'Mouseup or touchend';
};
</script>

----------------------------------------

TITLE: React Implementation of Elastic Stars with Konva
DESCRIPTION: React component implementation of draggable stars using react-konva. Uses React hooks to manage state and handle drag events, creating the same elastic animation effect as the vanilla version.

LANGUAGE: jsx
CODE:
import { useState, useEffect } from 'react';
import { Stage, Layer, Star } from 'react-konva';

const App = () => {
  const [stars, setStars] = useState([]);
  
  useEffect(() => {
    const initialStars = [];
    for (let n = 0; n < 10; n++) {
      const scale = Math.random();
      initialStars.push({
        id: n.toString(),
        x: Math.random() * window.innerWidth,
        y: Math.random() * window.innerHeight,
        numPoints: 5,
        innerRadius: 30,
        outerRadius: 50,
        fill: '#89b717',
        opacity: 0.8,
        rotation: Math.random() * 180,
        shadowColor: 'black',
        shadowBlur: 10,
        shadowOffset: {
          x: 5,
          y: 5,
        },
        shadowOpacity: 0.6,
        scale: {
          x: scale,
          y: scale,
        },
        startScale: scale
      });
    }
    setStars(initialStars);
  }, []);
  
  const handleDragStart = (e) => {
    const index = stars.findIndex(star => star.id === e.target.attrs.id);
    
    if (index === -1) return;
    
    const newStars = [...stars];
    newStars[index] = {
      ...newStars[index],
      shadowOffset: {
        x: 15,
        y: 15,
      },
      scale: {
        x: newStars[index].startScale * 1.2,
        y: newStars[index].startScale * 1.2,
      }
    };
    
    setStars(newStars);
  };
  
  const handleDragEnd = (e) => {
    const index = stars.findIndex(star => star.id === e.target.attrs.id);
    
    if (index === -1) return;
    
    const newStars = [...stars];
    newStars[index] = {
      ...newStars[index],
      shadowOffset: {
        x: 5,
        y: 5,
      },
      scale: {
        x: newStars[index].startScale,
        y: newStars[index].startScale,
      }
    };
    
    setStars(newStars);
  };

  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        {stars.map(star => (
          <Star
            key={star.id}
            id={star.id}
            x={star.x}
            y={star.y}
            numPoints={star.numPoints}
            innerRadius={star.innerRadius}
            outerRadius={star.outerRadius}
            fill={star.fill}
            opacity={star.opacity}
            rotation={star.rotation}
            shadowColor={star.shadowColor}
            shadowBlur={star.shadowBlur}
            shadowOffset={star.shadowOffset}
            shadowOpacity={star.shadowOpacity}
            scale={star.scale}
            draggable
            onDragStart={handleDragStart}
            onDragEnd={handleDragEnd}
          />
        ))}
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Creating Interactive Planets Image Map with Vanilla JavaScript and Konva
DESCRIPTION: This snippet demonstrates how to create an interactive planets image map using Konva in vanilla JavaScript. It sets up a stage with multiple layers, loads an image, creates hoverable circular regions for each planet, and implements a checkbox to toggle the visibility of map overlays.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const stage = new Konva.Stage({
container: 'container',
width: window.innerWidth,
height: window.innerHeight,
});

const planetsLayer = new Konva.Layer();
const circlesLayer = new Konva.Layer();
const messageLayer = new Konva.Layer();

stage.add(planetsLayer);
stage.add(circlesLayer);
stage.add(messageLayer);

const text = new Konva.Text({
x: 10,
y: 10,
fontFamily: 'Calibri',
fontSize: 24,
text: '',
fill: 'white',
});
messageLayer.add(text);

function writeMessage(message) {
text.text(message);
}

const planets = {
Mercury: {
x: 46,
y: 126,
radius: 32,
},
Venus: {
x: 179,
y: 126,
radius: 79,
},
Earth: {
x: 366,
y: 127,
radius: 85,
},
Mars: {
x: 515,
y: 127,
radius: 45,
},
};

// create checkbox
const container = document.createElement('div');
container.style.position = 'absolute';
container.style.top = '10px';
container.style.left = '10px';
container.style.zIndex = '99999';
container.innerHTML = `  <label style="color: white;">
    <input type="checkbox" id="checkbox" />
    Show map overlay
  </label>`;
document.body.appendChild(container);

// draw shape overlays
for (const key in planets) {
const planet = planets[key];
const planetOverlay = new Konva.Circle({
x: planet.x,
y: planet.y,
radius: planet.radius,
});

planetOverlay.on('mouseover', () => {
writeMessage(key);
});
planetOverlay.on('mouseout', () => {
writeMessage('');
});

circlesLayer.add(planetOverlay);
}

const checkbox = document.getElementById('checkbox');
checkbox.addEventListener('click', () => {
const shapes = circlesLayer.getChildren();
shapes.forEach(shape => {
const f = shape.fill();
shape.fill(f === 'red' ? null : 'red');
});
});

// load the image
Konva.Image.fromURL('https://konvajs.org/assets/planets.png', (planetsImage) => {
planetsLayer.add(planetsImage);
});

----------------------------------------

TITLE: Creating Labels with Vanilla Konva.js
DESCRIPTION: Demonstrates creating three different types of labels using vanilla Konva.js: a tooltip pointing down with shadow effects, a label pointing left, and a simple label. Shows configuration of Tag and Text components within Labels.

LANGUAGE: javascript
CODE:
const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight
});

const layer = new Konva.Layer();

// tooltip pointing down
const tooltip = new Konva.Label({
  x: 170,
  y: 75,
  opacity: 0.75
});

tooltip.add(
  new Konva.Tag({
    fill: 'black',
    pointerDirection: 'down',
    pointerWidth: 10,
    pointerHeight: 10,
    lineJoin: 'round',
    shadowColor: 'black',
    shadowBlur: 10,
    shadowOffsetX: 10,
    shadowOffsetY: 10,
    shadowOpacity: 0.5
  })
);

tooltip.add(
  new Konva.Text({
    text: 'Tooltip pointing down',
    fontFamily: 'Calibri',
    fontSize: 18,
    padding: 5,
    fill: 'white'
  })
);

----------------------------------------

TITLE: Implementing Multiple Filters on Konva.Image with React
DESCRIPTION: This React component demonstrates applying multiple filters (blur, brightness, contrast) to a Konva.Image. It uses the react-konva library and hooks to manage filter states and values.

LANGUAGE: jsx
CODE:
import { Stage, Layer, Image } from 'react-konva';
import { useState, useEffect, useRef } from 'react';
import useImage from 'use-image';

const FilterControl = ({ name, min, max, step, filters, setFilters }) => {
  const capitalizedName = name.charAt(0).toUpperCase() + name.slice(1);
  return (
    <div style={{ marginBottom: '10px' }}>
      <input
        type="checkbox"
        id={name}
        checked={filters[name].active}
        onChange={(e) => {
          setFilters({
            ...filters,
            [name]: { ...filters[name], active: e.target.checked },
          });
        }}
      />
      <label htmlFor={name}> {capitalizedName}: </label>
      <input
        type="range"
        min={min}
        max={max}
        step={step}
        value={filters[name].value}
        disabled={!filters[name].active}
        onChange={(e) => {
          setFilters({
            ...filters,
            [name]: { ...filters[name], value: parseFloat(e.target.value) },
          });
        }}
        style={{ width: '200px' }}
      />
    </div>
  );
};

const App = () => {
  const [filters, setFilters] = useState({
    blur: { active: false, value: 10 },
    brightness: { active: false, value: 0.3 },
    contrast: { active: false, value: 50 },
  });

  const [image] = useImage('https://konvajs.org/assets/lion.png', 'anonymous');
  const imageRef = useRef(null);

  useEffect(() => {
    if (image && imageRef.current) {
      imageRef.current.cache();
    }
  }, [image]);



  const activeFilters = [];
  if (filters.blur.active) activeFilters.push(Konva.Filters.Blur);
  if (filters.brightness.active) activeFilters.push(Konva.Filters.Brighten);
  if (filters.contrast.active) activeFilters.push(Konva.Filters.Contrast);

  return (
    <>
      
      <Stage width={window.innerWidth} height={window.innerHeight}>
        <Layer>
          {image && (
            <Image
              ref={imageRef}
              x={50}
              y={50}
              image={image}
              draggable
              filters={activeFilters}
              blurRadius={filters.blur.value}
              brightness={filters.brightness.value}
              contrast={filters.contrast.value}
            />
          )}
        </Layer>
      </Stage>
      <div style={{ position: 'absolute', top: '20px', left: '20px' }}>
        <FilterControl name="blur" min={0} max={40} step={1} filters={filters} setFilters={setFilters} />
        <FilterControl name="brightness" min={-1} max={1} step={0.1} filters={filters} setFilters={setFilters} />
        <FilterControl name="contrast" min={-100} max={100} step={1} filters={filters} setFilters={setFilters} />
      </div>
    </>
  );
};

export default App;

----------------------------------------

TITLE: Implementing Konva Stage in React
DESCRIPTION: Shows how to create a Konva stage with a hexagon in React using react-konva components. Implements state management for color changes on click events.

LANGUAGE: javascript
CODE:
import { Stage, Layer, RegularPolygon } from 'react-konva';
import { useState } from 'react';

const App = () => {
  const [color, setColor] = useState('red');

  const handleClick = () => {
    setColor(Konva.Util.getRandomColor());
  };

  return (
    <Stage width={578} height={200}>
      <Layer>
        <RegularPolygon
          x={100}
          y={100}
          sides={6}
          radius={70}
          fill={color}
          stroke="black"
          strokeWidth={4}
          onClick={handleClick}
        />
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Creating a Konva.Node instance
DESCRIPTION: Creates a new Konva.Node instance with the given configuration options.

LANGUAGE: javascript
CODE:
new Konva.Node(config)

----------------------------------------

TITLE: Implementing Shape Groups with Vanilla JavaScript and Konva
DESCRIPTION: Creates a draggable group containing a circle and rectangle using vanilla JavaScript and Konva. Demonstrates group initialization, shape creation, and composition of shapes into a draggable group.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const width = window.innerWidth;
const height = window.innerHeight;

const stage = new Konva.Stage({
container: 'container',
width: width,
height: height,
});

const layer = new Konva.Layer();

const group = new Konva.Group({
x: 50,
y: 50,
draggable: true,
});

const circle = new Konva.Circle({
x: 40,
y: 40,
radius: 30,
fill: 'red',
stroke: 'black',
strokeWidth: 4,
});

const rect = new Konva.Rect({
x: 80,
y: 20,
width: 100,
height: 50,
fill: 'green',
stroke: 'black',
strokeWidth: 4,
});

group.add(circle);
group.add(rect);
layer.add(group);
stage.add(layer);

----------------------------------------

TITLE: Initializing a Konva Group
DESCRIPTION: Creates a new Konva.Group instance. Groups are used to contain shapes or other groups.

LANGUAGE: javascript
CODE:
new Konva.Group(config)

----------------------------------------

TITLE: Configuring Image Smoothing
DESCRIPTION: Gets or sets the imageSmoothingEnabled flag for the layer canvas.

LANGUAGE: javascript
CODE:
// get imageSmoothingEnabled flag
var imageSmoothingEnabled = layer.imageSmoothingEnabled();

layer.imageSmoothingEnabled(false);

layer.imageSmoothingEnabled(true);

----------------------------------------

TITLE: Creating a Custom Triangle Shape with Konva in React
DESCRIPTION: This snippet demonstrates how to create a custom triangle shape using Konva components in a React application. It uses the Shape component from react-konva to define a custom sceneFunc.

LANGUAGE: javascript
CODE:
import { Stage, Layer, Shape } from 'react-konva';

const App = () => {
  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        <Shape
          sceneFunc={(context, shape) => {
            context.beginPath();
            context.moveTo(20, 50);
            context.lineTo(220, 80);
            context.lineTo(100, 150);
            context.closePath();
            context.fillStrokeShape(shape);
          }}
          fill="#00D2FF"
          stroke="black"
          strokeWidth={4}
        />
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Complex Connected Objects Demo in Vanilla JavaScript
DESCRIPTION: This snippet creates a more complex demo with multiple connected objects. It generates random targets (circles) and connectors (arrows) between them. The connections update dynamically when the circles are dragged.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const width = window.innerWidth;
const height = window.innerHeight;

const stage = new Konva.Stage({
  container: 'container',
  width: width,
  height: height,
});

const layer = new Konva.Layer();
stage.add(layer);

// function to generate a list of "targets" (circles)
function generateTargets() {
  const number = 10;
  const result = [];
  while (result.length < number) {
    result.push({
      id: 'target-' + result.length,
      x: stage.width() * Math.random(),
      y: stage.height() * Math.random(),
    });
  }
  return result;
}

const targets = generateTargets();

// function to generate arrows between targets
function generateConnectors() {
  const number = 10;
  const result = [];
  while (result.length < number) {
    const from = 'target-' + Math.floor(Math.random() * targets.length);
    const to = 'target-' + Math.floor(Math.random() * targets.length);
    if (from === to) {
      continue;
    }
    result.push({
      id: 'connector-' + result.length,
      from: from,
      to: to,
    });
  }
  return result;
}

function getConnectorPoints(from, to) {
  const dx = to.x - from.x;
  const dy = to.y - from.y;
  let angle = Math.atan2(-dy, dx);

  const radius = 50;

  return [
    from.x + -radius * Math.cos(angle + Math.PI),
    from.y + radius * Math.sin(angle + Math.PI),
    to.x + -radius * Math.cos(angle),
    to.y + radius * Math.sin(angle),
  ];
}

const connectors = generateConnectors();

// update all objects on the canvas from the state of the app
function updateObjects() {
  targets.forEach((target) => {
    const node = layer.findOne('#' + target.id);
    node.x(target.x);
    node.y(target.y);
  });
  connectors.forEach((connect) => {
    const line = layer.findOne('#' + connect.id);
    const fromNode = layer.findOne('#' + connect.from);
    const toNode = layer.findOne('#' + connect.to);

    const points = getConnectorPoints(
      fromNode.position(),
      toNode.position()
    );
    line.points(points);
  });
}

// generate nodes for the app
connectors.forEach((connect) => {
  const line = new Konva.Arrow({
    stroke: 'black',
    id: connect.id,
    fill: 'black',
  });
  layer.add(line);
});

targets.forEach((target) => {
  const node = new Konva.Circle({
    id: target.id,
    fill: Konva.Util.getRandomColor(),
    radius: 20 + Math.random() * 20,
    shadowBlur: 10,
    draggable: true,
  });
  layer.add(node);

  node.on('dragmove', () => {
    // mutate the state
    target.x = node.x();
    target.y = node.y();

    // update nodes from the new state
    updateObjects();
  });
});

updateObjects();

----------------------------------------

TITLE: Implementing Resizable and Rotatable Shapes with Vue and Konva
DESCRIPTION: This Vue.js component creates a stage with two rectangles that can be selected, resized, and rotated using Konva's Transformer tool. It demonstrates how to handle shape selection, transformation, and color change after transformation.

LANGUAGE: html
CODE:
<template>
  <v-stage
    ref="stage"
    :config="stageSize"
    @mousedown="handleStageMouseDown"
    @touchstart="handleStageMouseDown"
  >
    <v-layer ref="layer">
      <v-rect
        v-for="item in rectangles"
        :key="item.id"
        :config="item"
        @transformend="handleTransformEnd"
      />
      <v-transformer ref="transformer" />
    </v-layer>
  </v-stage>
</template>

LANGUAGE: javascript
CODE:
<script setup>
import { ref } from 'vue';
import Konva from 'konva';

const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight
};

const rectangles = ref([
  {
    rotation: 0,
    x: 10,
    y: 10,
    width: 100,
    height: 100,
    scaleX: 1,
    scaleY: 1,
    fill: 'red',
    name: 'rect1',
    draggable: true
  },
  {
    rotation: 0,
    x: 150,
    y: 150,
    width: 100,
    height: 100,
    scaleX: 1,
    scaleY: 1,
    fill: 'green',
    name: 'rect2',
    draggable: true
  }
]);

const selectedShapeName = ref('');
const transformer = ref(null);

const handleTransformEnd = (e) => {
  // find element in our state
  const rect = rectangles.value.find(
    (r) => r.name === selectedShapeName.value
  );
  if (!rect) return;

  // update the state with new properties
  rect.x = e.target.x();
  rect.y = e.target.y();
  rect.rotation = e.target.rotation();
  rect.scaleX = e.target.scaleX();
  rect.scaleY = e.target.scaleY();

  // change fill color randomly
  rect.fill = Konva.Util.getRandomColor();
};

const updateTransformer = () => {
  const transformerNode = transformer.value.getNode();
  const stage = transformerNode.getStage();
  const selected = selectedShapeName.value;

  const selectedNode = stage.findOne('.' + selected);
  // do nothing if selected node is already attached
  if (selectedNode === transformerNode.node()) {
    return;
  }

  if (selectedNode) {
    // attach to selected node
    transformerNode.nodes([selectedNode]);
  } else {
    // remove transformer
    transformerNode.nodes([]);
  }
};

const handleStageMouseDown = (e) => {
  // clicked on stage - clear selection
  if (e.target === e.target.getStage()) {
    selectedShapeName.value = '';
    updateTransformer();
    return;
  }

  // clicked on transformer - do nothing
  const clickedOnTransformer =
    e.target.getParent().className === 'Transformer';
  if (clickedOnTransformer) {
    return;
  }

  // find clicked rect by its name
  const name = e.target.name();
  const rect = rectangles.value.find((r) => r.name === name);
  if (rect) {
    selectedShapeName.value = name;
  } else {
    selectedShapeName.value = '';
  }
  updateTransformer();
};
</script>

----------------------------------------

TITLE: Implementing Collision Detection in React with Konva
DESCRIPTION: React implementation of collision detection using react-konva. Uses React state to manage shapes and their properties. Includes bounding box calculations for rotated rectangles and handles drag events.

LANGUAGE: javascript
CODE:
import { Stage, Layer, Group, Rect } from 'react-konva';
import { useState } from 'react';

const createInitialShapes = () => {
  const shapes = [];
  for (let i = 0; i < 10; i++) {
    const width = 30 + Math.random() * 30;
    const height = 30 + Math.random() * 30;
    const rotation = 360 * Math.random();

    const radians = (rotation * Math.PI) / 180;
    const cos = Math.cos(radians);
    const sin = Math.sin(radians);

    const corners = [
      { x: 0, y: 0 },
      { x: width, y: 0 },
      { x: width, y: height },
      { x: 0, y: height }
    ].map(point => ({
      x: point.x * cos - point.y * sin,
      y: point.x * sin + point.y * cos
    }));

    const minX = Math.min(...corners.map(p => p.x));
    const maxX = Math.max(...corners.map(p => p.x));
    const minY = Math.min(...corners.map(p => p.y));
    const maxY = Math.max(...corners.map(p => p.y));

    shapes.push({
      id: i,
      x: Math.random() * window.innerWidth,
      y: Math.random() * window.innerHeight,
      rotation,
      width,
      height,
      fill: 'grey',
      box: {
        x: minX,
        y: minY,
        width: maxX - minX,
        height: maxY - minY
      }
    });
  }
  return shapes;
};

----------------------------------------

TITLE: Implementing Stage Events with Vanilla JavaScript and Konva
DESCRIPTION: Creates a canvas with a red circle and text display using Konva. Demonstrates click event handling that distinguishes between clicks on shapes versus empty stage space. Updates text display based on click location.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight,
});

const layer = new Konva.Layer();
stage.add(layer);

const text = new Konva.Text({
  x: 10,
  y: 10,
  fontFamily: 'Calibri',
  fontSize: 24,
  text: '',
  fill: 'black',
});
layer.add(text);

const circle = new Konva.Circle({
  x: stage.width() / 2,
  y: stage.height() / 2,
  radius: 70,
  fill: 'red',
  stroke: 'black',
  strokeWidth: 4,
});

function writeMessage(message) {
  text.text(message);
}

stage.on('click', function (e) {
  if (e.target === stage) {
    writeMessage('clicked on stage');
    return;
  }
  writeMessage('clicked on ' + e.target.name());
});

circle.name('circle');
layer.add(circle);

----------------------------------------

TITLE: Getting Children of a Konva Container
DESCRIPTION: Returns an array of direct descendant nodes of a Konva container. Can optionally filter the children using a provided function.

LANGUAGE: javascript
CODE:
// get all children
var children = layer.getChildren();

// get only circles
var circles = layer.getChildren(function(node){
   return node.getClassName() === 'Circle';
});

----------------------------------------

TITLE: Implementing Pixelate Filter with Vanilla JavaScript and Konva.js
DESCRIPTION: Creates a draggable image with an adjustable pixelate filter using vanilla JavaScript and Konva.js. Includes a slider control to modify the pixel size in real-time.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight,
});

const layer = new Konva.Layer();
stage.add(layer);

const imageObj = new Image();
imageObj.onload = () => {
  const image = new Konva.Image({
    x: 50,
    y: 50,
    image: imageObj,
    draggable: true,
  });

  layer.add(image);

  image.cache();
  image.filters([Konva.Filters.Pixelate]);
  image.pixelSize(8);

  const container = document.createElement('div');
  container.style.position = 'absolute';
  container.style.top = '20px';
  container.style.left = '20px';
  
  const text = document.createElement('span');
  text.textContent = 'Pixel Size: ';
  container.appendChild(text);
  
  const slider = document.createElement('input');
  slider.type = 'range';
  slider.min = '2';
  slider.max = '32';
  slider.step = '1';
  slider.value = image.pixelSize();
  slider.style.width = '200px';
  
  slider.addEventListener('input', (e) => {
    const value = parseInt(e.target.value);
    image.pixelSize(value);
  });
  
  container.appendChild(slider);
  document.body.appendChild(container);
};
imageObj.src = 'https://konvajs.org/assets/lion.png';
imageObj.crossOrigin = 'anonymous';

----------------------------------------

TITLE: Implementing Clipping Function with Vue and Konva
DESCRIPTION: This snippet demonstrates how to create a clipping function using Vue with vue-konva. It defines a template with a v-stage component containing a v-layer and v-group with a clipping function, and multiple v-circle components representing blobs.

LANGUAGE: vue
CODE:
<template>
  <v-stage :config="stageSize">
    <v-layer>
      <v-group :config="groupConfig">
        <v-circle
          v-for="(blob, i) in blobs"
          :key="i"
          :config="blob"
        />
      </v-group>
    </v-layer>
  </v-stage>
</template>

<script setup>
const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight
};

const groupConfig = {
  clipFunc: (ctx) => {
    ctx.beginPath();
    ctx.arc(200, 120, 50, 0, Math.PI * 2, false);
    ctx.arc(280, 120, 50, 0, Math.PI * 2, false);
  }
};

const blobs = Array.from({ length: 20 }, () => ({
  x: Math.random() * window.innerWidth,
  y: Math.random() * window.innerHeight,
  radius: Math.random() * 50,
  fill: 'green',
  opacity: 0.8
}));
</script>

----------------------------------------

TITLE: Finding Nodes in a Konva Container
DESCRIPTION: Searches for nodes within a container using various selectors like id, name, type or a custom function.

LANGUAGE: javascript
CODE:
// select node with id foo
var node = stage.find('#foo');

// select nodes with name bar inside layer
var nodes = layer.find('.bar');

// select all groups inside layer
var nodes = layer.find('Group');

// select all rectangles inside layer
var nodes = layer.find('Rect');

// select node with an id of foo or a name of bar inside layer
var nodes = layer.find('#foo, .bar');

// get all groups with a function
var groups = stage.find(node => {
 return node.getType() === 'Group';
});

// get only Nodes with partial opacity
var alphaNodes = layer.find(node => {
 return node.getType() === 'Node' && node.getAbsoluteOpacity() < 1;
});

----------------------------------------

TITLE: Toggling Event Listening for Shapes in Vanilla JavaScript with Konva
DESCRIPTION: This snippet creates a Konva stage with an oval shape and a button to toggle event listening. It demonstrates how to set the 'listening' property and redraw the hit graph.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight,
});

const layer = new Konva.Layer();
stage.add(layer);

const text = new Konva.Text({
  x: 10,
  y: 10,
  fontFamily: 'Calibri',
  fontSize: 24,
  text: '',
  fill: 'black',
});
layer.add(text);

const oval = new Konva.Ellipse({
  x: stage.width() / 2,
  y: stage.height() / 2,
  radiusX: 100,
  radiusY: 50,
  fill: 'yellow',
  stroke: 'black',
  strokeWidth: 4,
  listening: false,
});

oval.on('mouseover', function () {
  writeMessage('Mouseover oval');
});
oval.on('mouseout', function () {
  writeMessage('');
});

function writeMessage(message) {
  text.text(message);
}

layer.add(oval);

// add button to toggle listening
const button = document.createElement('button');
button.innerHTML = 'Listen';
document.body.appendChild(button);
button.addEventListener('click', () => {
  const listening = !oval.listening();
  oval.listening(listening);
  button.innerHTML = listening ? 'Stop listening' : 'Listen';
  layer.drawHit();
});

----------------------------------------

TITLE: Applying Sepia Filter with Vanilla JavaScript and Konva
DESCRIPTION: Demonstrates how to load an image, create a Konva stage and layer, and apply a sepia filter using vanilla JavaScript. The code shows initialization of the canvas, image loading with cross-origin handling, and filter application.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight,
});

const layer = new Konva.Layer();
stage.add(layer);

const imageObj = new Image();
imageObj.onload = () => {
  const image = new Konva.Image({
    x: 50,
    y: 50,
    image: imageObj,
    draggable: true,
  });

  layer.add(image);

  // Apply Sepia filter
  image.cache();
  image.filters([Konva.Filters.Sepia]);
};
imageObj.src = 'https://konvajs.org/assets/lion.png';
imageObj.crossOrigin = 'anonymous';

----------------------------------------

TITLE: Binding Multiple Events in Konva
DESCRIPTION: This snippet shows how to bind multiple events (mouseover, mousedown, mouseup) to a single handler function using Konva's on() method.

LANGUAGE: javascript
CODE:
shape.on('mouseover mousedown mouseup', function (e) {
  console.log('events: ' + e.type);
});

----------------------------------------

TITLE: Checking Layer Width
DESCRIPTION: Gets the width of the layer, which returns the stage width. Setting width has no effect.

LANGUAGE: javascript
CODE:
var width = layer.width();

----------------------------------------

TITLE: Implementing Shape Animation with Vanilla Konva
DESCRIPTION: Creates an interactive canvas with draggable shapes that animate when a button is clicked. Uses Konva's tweening system to animate position, rotation, size and color of regular polygons.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const button = document.createElement('button');
button.textContent = 'Tango!';
button.style.position = 'absolute';
button.style.top = '10px';
button.style.left = '10px';
button.style.padding = '10px';
document.body.appendChild(button);

const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight,
});

const layer = new Konva.Layer();
stage.add(layer);

const colors = ['red', 'orange', 'yellow', 'green', 'blue', 'purple'];

function getRandomColor() {
  return colors[Math.floor(Math.random() * colors.length)];
}

function tango(layer) {
  layer.getChildren().forEach((shape) => {
    const radius = Math.random() * 100 + 20;
    
    new Konva.Tween({
      node: shape,
      duration: 1,
      x: Math.random() * stage.width(),
      y: Math.random() * stage.height(),
      rotation: Math.random() * 360,
      radius: radius,
      opacity: (radius - 20) / 100,
      easing: Konva.Easings.EaseInOut,
      fill: getRandomColor(),
    }).play();
  });
}

for (let n = 0; n < 10; n++) {
  const radius = Math.random() * 100 + 20;
  const shape = new Konva.RegularPolygon({
    x: Math.random() * stage.width(),
    y: Math.random() * stage.height(),
    sides: Math.ceil(Math.random() * 5 + 3),
    radius: radius,
    fill: getRandomColor(),
    opacity: (radius - 20) / 100,
    draggable: true,
  });

  layer.add(shape);
}

button.addEventListener('click', () => tango(layer));

----------------------------------------

TITLE: Creating Circular Animation with Konva in Vanilla JavaScript
DESCRIPTION: This snippet demonstrates how to create a circular animation of a rectangle using Konva.Animation in vanilla JavaScript. It initializes a stage, layer, and rectangle, then animates the rectangle's position in a circular path.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const stage = new Konva.Stage({
container: 'container',
width: window.innerWidth,
height: window.innerHeight,
});

const layer = new Konva.Layer();
stage.add(layer);

const rect = new Konva.Rect({
x: 50,
y: 50,
width: 50,
height: 50,
fill: 'green',
});
layer.add(rect);

const anim = new Konva.Animation(function(frame) {
const time = frame.time;
const timeDiff = frame.timeDiff;
const frameRate = frame.frameRate;

// Example: move rectangle in a circle
const radius = 50;
const x = radius * Math.cos(frame.time * 2 * Math.PI / 2000) + 100;
const y = radius * Math.sin(frame.time * 2 * Math.PI / 2000) + 100;
rect.position({ x, y });
}, layer);

anim.start();

----------------------------------------

TITLE: Implementing Video Playback on Canvas with React and Konva
DESCRIPTION: This snippet shows how to display a video on a canvas using Konva in a React application. It includes play/pause functionality, drag-and-drop capability, and responsive design considerations.

LANGUAGE: jsx
CODE:
import { Stage, Layer, Image, Text } from 'react-konva';
import { useEffect, useRef, useState } from 'react';

const App = () => {
  const [dimensions, setDimensions] = useState({
    width: window.innerWidth,
    height: 400,
  });
  const [videoElement] = useState(() => {
    const element = document.createElement('video');
    element.src =
      'https://upload.wikimedia.org/wikipedia/commons/transcoded/c/c4/Physicsworks.ogv/Physicsworks.ogv.240p.vp9.webm';
    return element;
  });
  const [videoSize, setVideoSize] = useState({ width: 0, height: 0 });
  const [status, setStatus] = useState('Loading video...');
  const animationRef = useRef(null);
  const layerRef = useRef(null);

  useEffect(() => {
    const handleResize = () => {
      setDimensions({
        width: window.innerWidth,
        height: 400,
      });
    };

    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  useEffect(() => {
    const handleMetadata = () => {
      setStatus('Press PLAY...');
      setVideoSize({
        width: videoElement.videoWidth,
        height: videoElement.videoHeight,
      });
    };

    videoElement.addEventListener('loadedmetadata', handleMetadata);
    return () => videoElement.removeEventListener('loadedmetadata', handleMetadata);
  }, [videoElement]);

  const handlePlay = () => {
    setStatus('');
    videoElement.play();
    if (layerRef.current) {
      const anim = new Konva.Animation(() => {}, layerRef.current);
      animationRef.current = anim;
      anim.start();
    }
  };

  const handlePause = () => {
    videoElement.pause();
    if (animationRef.current) {
      animationRef.current.stop();
    }
  };

  return (
    <div>
      <button onClick={handlePlay}>Play</button>
      <button onClick={handlePause}>Pause</button>
      <Stage width={dimensions.width} height={dimensions.height}>
        <Layer ref={layerRef}>
          <Image
            image={videoElement}
            x={50}
            y={20}
            width={videoSize.width}
            height={videoSize.height}
            draggable
          />
          {status && (
            <Text
              text={status}
              width={dimensions.width}
              height={dimensions.height}
              align="center"
              verticalAlign="middle"
            />
          )}
        </Layer>
      </Stage>
    </div>
  );
};

export default App;

----------------------------------------

TITLE: Binding Mouse Events to Shapes in Vanilla JavaScript with Konva
DESCRIPTION: This snippet demonstrates how to create a Konva stage with a triangle and circle, and bind various mouse events to them. It includes handlers for mouseover, mouseout, mousemove, mousedown, and mouseup events.

LANGUAGE: javascript
CODE:
import Konva from 'konva';
const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight,
});

const layer = new Konva.Layer();

const text = new Konva.Text({
x: 10,
y: 10,
fontFamily: 'Calibri',
fontSize: 24,
text: '',
fill: 'black',
});

const triangle = new Konva.RegularPolygon({
x: 80,
y: 120,
sides: 3,
radius: 80,
fill: '#00D2FF',
stroke: 'black',
strokeWidth: 4,
});

const circle = new Konva.Circle({
x: 230,
y: 100,
radius: 60,
fill: 'red',
stroke: 'black',
strokeWidth: 4,
});

function writeMessage(message) {
text.text(message);
}

triangle.on('mouseout', () => {
writeMessage('Mouseout triangle');
});

triangle.on('mousemove', () => {
const mousePos = stage.getPointerPosition();
writeMessage('x: ' + mousePos.x + ', y: ' + mousePos.y);
});

circle.on('mouseover', () => {
writeMessage('Mouseover circle');
});
circle.on('mouseout', () => {
writeMessage('Mouseout circle');
});
circle.on('mousedown', () => {
writeMessage('Mousedown circle');
});
circle.on('mouseup', () => {
writeMessage('Mouseup circle');
});

layer.add(triangle);
layer.add(circle);
layer.add(text);
stage.add(layer);

----------------------------------------

TITLE: Implementing Mobile Touch Events with Vanilla JavaScript and Konva
DESCRIPTION: Creates an interactive canvas with a triangle and circle that respond to touch events. The triangle tracks touch coordinates while the circle displays touch start/end events. Uses Konva's Stage, Layer, and Shape components with touch event handlers.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight,
});

const layer = new Konva.Layer();

const text = new Konva.Text({
  x: 10,
  y: 10,
  fontFamily: 'Calibri',
  fontSize: 24,
  text: '',
  fill: 'black',
});

const triangle = new Konva.RegularPolygon({
  x: 80,
  y: 120,
  sides: 3,
  radius: 80,
  fill: '#00D2FF',
  stroke: 'black',
  strokeWidth: 4,
});

const circle = new Konva.Circle({
  x: 230,
  y: 100,
  radius: 60,
  fill: 'red',
  stroke: 'black',
  strokeWidth: 4,
});

function writeMessage(message) {
  text.text(message);
}

triangle.on('touchmove', function () {
  const touchPos = stage.getPointerPosition();
  const x = touchPos.x;
  const y = touchPos.y;
  writeMessage('x: ' + x + ', y: ' + y);
});

circle.on('touchstart', function () {
  writeMessage('touchstart circle');
});
circle.on('touchend', function () {
  writeMessage('touchend circle');
});

layer.add(triangle);
layer.add(circle);
layer.add(text);
stage.add(layer);

----------------------------------------

TITLE: Styling a Konva Shape with Various Properties
DESCRIPTION: This snippet demonstrates how to apply various styling properties to a Konva shape, including fill, stroke, shadow, and opacity. It showcases the rich styling capabilities of Konva.

LANGUAGE: javascript
CODE:
var pentagon = new Konva.RegularPolygon({
  x: stage.width() / 2,
  y: stage.height() / 2,
  sides: 5,
  radius: 70,
  fill: 'red',
  stroke: 'black',
  strokeWidth: 4,
  shadowOffsetX: 20,
  shadowOffsetY: 25,
  shadowBlur: 40,
  opacity: 0.5,
});

----------------------------------------

TITLE: Implementing Threshold Filter with React and Konva
DESCRIPTION: Demonstrates how to create a threshold filter effect using React with react-konva components. Uses hooks for state management and image loading, with a controlled slider input for threshold adjustment.

LANGUAGE: jsx
CODE:
const App = () => {
  const [threshold, setThreshold] = useState(0.5);
  const [image] = useImage('https://konvajs.org/assets/lion.png', 'anonymous');
  const imageRef = useRef(null);

  useEffect(() => {
    if (image && imageRef.current) {
      imageRef.current.cache();
    }
  }, [image]);

  return (
    <>
      <Stage width={window.innerWidth} height={window.innerHeight}>
        <Layer>
          <Image
            ref={imageRef}
            x={50}
            y={50}
            image={image}
            draggable
            filters={[Konva.Filters.Threshold]}
            threshold={threshold}
          />
        </Layer>
      </Stage>
      <input
        type="range"
        min="0"
        max="1"
        step="0.1"
        value={threshold}
        onChange={(e) => setThreshold(parseFloat(e.target.value))}
        style={{ position: 'absolute', top: '20px', left: '20px' }}
      />
    </>
  );
};

----------------------------------------

TITLE: Implementing Rotation Animation with Konva in Vanilla JavaScript
DESCRIPTION: This snippet demonstrates how to create a rotation animation for three rectangles using Konva in vanilla JavaScript. It sets up a stage, layer, and rectangles with different rotation points, then uses Konva.Animation to continuously rotate them.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const stage = new Konva.Stage({
container: 'container',
width: window.innerWidth,
height: window.innerHeight,
});

const layer = new Konva.Layer();
stage.add(layer);

// blue rectangle - rotate around top-left corner
const blueRect = new Konva.Rect({
x: 50,
y: 50,
width: 100,
height: 50,
fill: '#00D2FF',
stroke: 'black',
strokeWidth: 4,
offset: {
x: 0,
y: 0,
},
});

// yellow rectangle - rotate around center
const yellowRect = new Konva.Rect({
x: 200,
y: 50,
width: 100,
height: 50,
fill: 'yellow',
stroke: 'black',
strokeWidth: 4,
offset: {
x: 50,
y: 25,
},
});

// red rectangle - rotate around point outside shape
const redRect = new Konva.Rect({
x: 350,
y: 50,
width: 100,
height: 50,
fill: 'red',
stroke: 'black',
strokeWidth: 4,
offset: {
x: -50,
y: 25,
},
});

layer.add(blueRect);
layer.add(yellowRect);
layer.add(redRect);

const angularSpeed = 90;
const anim = new Konva.Animation(function(frame) {
const angleDiff = (frame.timeDiff * angularSpeed) / 1000;
blueRect.rotate(angleDiff);
yellowRect.rotate(angleDiff);
redRect.rotate(angleDiff);
}, layer);

anim.start();

----------------------------------------

TITLE: Implementing Keyboard Events in React with Konva
DESCRIPTION: Implements a movable circle using React and React-Konva components. Uses hooks for state management and event handling to control circle position with arrow keys.

LANGUAGE: jsx
CODE:
import { Stage, Layer, Circle } from 'react-konva';
import { useRef, useEffect, useState } from 'react';

const App = () => {
  const stageRef = useRef();
  const [position, setPosition] = useState({
    x: window.innerWidth / 2,
    y: window.innerHeight / 2,
  });

  useEffect(() => {
    const container = stageRef.current.container();
    container.tabIndex = 1;
    container.focus();
  }, []);

  const handleKeyDown = (e) => {
    const DELTA = 4;
    
    switch (e.keyCode) {
      case 37:
        setPosition(pos => ({ ...pos, x: pos.x - DELTA }));
        break;
      case 38:
        setPosition(pos => ({ ...pos, y: pos.y - DELTA }));
        break;
      case 39:
        setPosition(pos => ({ ...pos, x: pos.x + DELTA }));
        break;
      case 40:
        setPosition(pos => ({ ...pos, y: pos.y + DELTA }));
        break;
      default:
        return;
    }
    e.preventDefault();
  };

  return (
    <Stage
      width={window.innerWidth}
      height={window.innerHeight}
      ref={stageRef}
      onKeyDown={handleKeyDown}
    >
      <Layer>
        <Circle
          x={position.x}
          y={position.y}
          radius={50}
          fill="red"
          stroke="black"
          strokeWidth={4}
        />
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Creating Oscillating Blobs with Vanilla JavaScript and Konva
DESCRIPTION: This snippet creates an interactive animation of oscillating blobs using Konva in vanilla JavaScript. It generates 6 draggable blobs with random positions, colors, and opacities, and animates their tension using a sine wave function.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

var width = window.innerWidth;
var height = window.innerHeight;

var stage = new Konva.Stage({
  container: 'container',
  width: width,
  height: height,
});
var layer = new Konva.Layer();
var colors = ['red', 'orange', 'yellow', 'green', 'blue', 'purple'];
var blobs = [];

// create 6 blobs
for (var n = 0; n < 6; n++) {
  // build array of random points
  var points = [];
  for (var i = 0; i < 5; i++) {
    points.push(stage.width() * Math.random());
    points.push(height * Math.random());
  }

  var blob = new Konva.Line({
    points: points,
    fill: colors[n],
    stroke: 'black',
    strokeWidth: 2,
    tension: 0,
    opacity: Math.random(),
    draggable: true,
    closed: true,
  });

  layer.add(blob);
  blobs.push(blob);
}

stage.add(layer);

var period = 2000;
var centerTension = 0;
var amplitude = 1;

var anim = new Konva.Animation(function (frame) {
  for (var n = 0; n < blobs.length; n++) {
    blobs[n].tension(
      amplitude * Math.sin((frame.time * 2 * Math.PI) / period) +
        centerTension
    );
  }
}, layer);

anim.start();

----------------------------------------

TITLE: Implementing Bouncing Bunnies Animation with Vanilla JavaScript and Konva
DESCRIPTION: This snippet creates a performance test using Konva to animate multiple bouncing bunny images. It sets up a stage, handles user interactions to add more bunnies, and updates their positions in an animation loop.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

// Set up stage and layer
const width = window.innerWidth;
const height = window.innerHeight;

const stage = new Konva.Stage({
  container: 'container',
  width: width,
  height: height,
});

const layer = new Konva.FastLayer();
stage.add(layer);

// Create stats and counter display
const counterDiv = document.createElement('div');
counterDiv.style.position = 'absolute';
counterDiv.style.top = '50px';
counterDiv.style.backgroundColor = 'white';
counterDiv.style.fontSize = '12px';
counterDiv.style.padding = '5px';
counterDiv.innerHTML = '0 BUNNIES';
document.getElementById('container').appendChild(counterDiv);

// Define variables
const bunnys = [];
const GRAVITY = 0.75;
const maxX = width;
const minX = 0;
const maxY = height;
const minY = 0;
const startBunnyCount = 100; // Starting with fewer bunnies for better initial performance
const amount = 10; // Add this many bunnies at a time
let isAdding = false;
let count = 0;
let wabbitTexture;

// Load the bunny image
wabbitTexture = new Image();
wabbitTexture.onload = function() {
  addBunnies(startBunnyCount);
  counterDiv.innerHTML = startBunnyCount + ' BUNNIES';
  count = startBunnyCount;
  
  // Start animation loop
  requestAnimationFrame(update);
};
wabbitTexture.src = 'https://konvajs.org/assets/bunny.png';

// Add event listeners
stage.on('mousedown touchstart', function() {
  isAdding = true;
});

stage.on('mouseup touchend', function() {
  isAdding = false;
});

// Function to add bunnies
function addBunnies(num) {
  for (let i = 0; i < num; i++) {
    const bunny = new Konva.Image({
      image: wabbitTexture,
      transformsEnabled: 'position',
      perfectDrawEnabled: false,
      x: Math.random() * width,
      y: Math.random() * height,
    });

    bunny.speedX = Math.random() * 10;
    bunny.speedY = Math.random() * 10 - 5;

    bunnys.push(bunny);
    layer.add(bunny);
  }
}

// Animation update function
function update() {
  // Add more bunnies if mouse is down
  if (isAdding) {
    addBunnies(amount);
    count += amount;
    counterDiv.innerHTML = count + ' BUNNIES';
  }

  // Update all bunnies
  for (let i = 0; i < bunnys.length; i++) {
    const bunny = bunnys[i];
    let x = bunny.x();
    let y = bunny.y();

    x += bunny.speedX;
    y += bunny.speedY;
    bunny.speedY += GRAVITY;

    // Bounce off the edges
    if (x > maxX - wabbitTexture.width) {
      bunny.speedX *= -1;
      x = maxX - wabbitTexture.width;
    } else if (x < minX) {
      bunny.speedX *= -1;
      x = minX;
    }

    if (y > maxY - wabbitTexture.height) {
      bunny.speedY *= -0.85;
      y = maxY - wabbitTexture.height;
      if (Math.random() > 0.5) {
        bunny.speedY -= Math.random() * 6;
      }
    } else if (y < minY) {
      bunny.speedY = 0;
      y = minY;
    }

    bunny.position({ x, y });
  }

  layer.batchDraw();
  requestAnimationFrame(update);
}

----------------------------------------

TITLE: Implementing Complex Tweening with Gradient Changes in Vanilla JavaScript
DESCRIPTION: This snippet demonstrates how to create a complex animation with gradient changes using Konva in vanilla JavaScript. It includes creating a circle shape, setting up click events, and animating both the scale and gradient colors.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const width = window.innerWidth;
const height = window.innerHeight;

const stage = new Konva.Stage({
container: 'container',
width: width,
height: height,
});

const layer = new Konva.Layer();

const circle = new Konva.Circle({
x: width / 2,
y: height / 2,
radius: 70,
fillLinearGradientStartPoint: { x: -50, y: -50 },
fillLinearGradientEndPoint: { x: 50, y: 50 },
fillLinearGradientColorStops: [0, 'red', 1, 'yellow'],
stroke: 'black',
strokeWidth: 4,
draggable: true,
});

layer.add(circle);
stage.add(layer);

circle.on('click tap', () => {
// using regular Konva tween
const tween = new Konva.Tween({
node: circle,
duration: 1,
scaleX: 1.5,
scaleY: 1.5,
easing: Konva.Easings.EaseInOut,
onFinish: () => {
// scale back with another tween
const tween2 = new Konva.Tween({
node: circle,
duration: 1,
scaleX: 1,
scaleY: 1,
easing: Konva.Easings.Bounce.EaseOut,
});
tween2.play();
},
});
tween.play();

// manually update gradient
let ratio = 0;
const anim = new Konva.Animation((frame) => {
ratio += frame.timeDiff / 1000;
if (ratio > 1) {
ratio = 0;
}
circle.fillLinearGradientColorStops([
0,
'red',
ratio,
'yellow',
1,
'blue',
]);
}, layer);
anim.start();
setTimeout(() => anim.stop(), 2000);
});

----------------------------------------

TITLE: Creating Images with Konva.js in Vanilla JavaScript
DESCRIPTION: This snippet demonstrates how to create a Konva stage, add a layer, and create images using both the Konva.Image() constructor and Konva.Image.fromURL() method. It loads two images (Yoda and Darth Vader) and positions them on the canvas with different attributes.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight
});

const layer = new Konva.Layer();
stage.add(layer);

// main API:
const imageObj = new Image();
imageObj.onload = function () {
  const yoda = new Konva.Image({
    x: 50,
    y: 50,
    image: imageObj,
    width: 106,
    height: 118
  });

  layer.add(yoda);
};
imageObj.src = 'https://konvajs.org/assets/yoda.jpg';

// alternative API:
Konva.Image.fromURL('https://konvajs.org/assets/darth-vader.jpg', function (darthNode) {
  darthNode.setAttrs({
    x: 200,
    y: 50,
    scaleX: 0.5,
    scaleY: 0.5,
    cornerRadius: 20
  });
  layer.add(darthNode);
});

----------------------------------------

TITLE: Binding events to a node
DESCRIPTION: Attaches event listeners to the node for various events like click, mousedown, etc.

LANGUAGE: javascript
CODE:
node.on('click', function() {
  console.log('you clicked me!');
});

node.on('click', function(evt) {
  console.log(evt.target);
});

node.on('click', function(evt) {
  evt.cancelBubble = true;
});

node.on('click touchstart', function() {
  console.log('you clicked/touched me!');
});

node.on('click.foo', function() {
  console.log('you clicked/touched me!');
});

node.on('click tap', function(evt) {
  var eventType = evt.type;
});

node.on('click tap', function(evt) {
  var nativeEvent = evt.evt;
});

node.on('xChange', function(evt) {
  var oldVal = evt.oldVal;
  var newVal = evt.newVal;
});

layer.on('click', 'Group', function(evt) {
  var shape = evt.target;
  var group = evt.currentTarget;
});

----------------------------------------

TITLE: Custom Hit Detection in React with react-konva
DESCRIPTION: React implementation of custom hit detection using react-konva components. Demonstrates the same functionality as the vanilla version but with React component structure and hooks for state management.

LANGUAGE: jsx
CODE:
import { Stage, Layer, Star, Line, Text } from 'react-konva';
import { useState, useEffect } from 'react';

const App = () => {
  const [message, setMessage] = useState('');
  const [showHit, setShowHit] = useState(false);

  const handleStarEvent = (evt) => {
    setMessage(evt.type + ' star');
  };

  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        <Star
          x={window.innerWidth / 4}
          y={window.innerHeight / 2}
          numPoints={5}
          innerRadius={40}
          outerRadius={70}
          fill="red"
          stroke="black"
          strokeWidth={4}
          hitFunc={(context, shape) => {
            context.beginPath();
            context.arc(0, 0, 70, 0, Math.PI * 2, true);
            context.closePath();
            context.fillStrokeShape(shape);
          }}
        />
      </Layer>
    </Stage>
  );
};

----------------------------------------

TITLE: Implementing Kaleidoscope Filter with React and Konva
DESCRIPTION: This snippet demonstrates how to create a kaleidoscope effect on an image using React and react-konva. It uses hooks to manage state and applies the Kaleidoscope filter to a Konva Image component. Sliders are provided to adjust the kaleidoscope power and angle.

LANGUAGE: jsx
CODE:
import { Stage, Layer, Image } from 'react-konva';
import { useState, useEffect, useRef } from 'react';
import useImage from 'use-image';

const App = () => {
  const [angle, setAngle] = useState(0);
  const [power, setPower] = useState(3);
  const [image] = useImage('https://konvajs.org/assets/lion.png', 'anonymous');
  const imageRef = useRef(null);

  useEffect(() => {
    if (image && imageRef.current) {
      imageRef.current.cache();
    }
  }, [image]);

  return (
    <>
      <Stage width={window.innerWidth} height={window.innerHeight}>
        <Layer>
          <Image
            ref={imageRef}
            x={50}
            y={50}
            image={image}
            draggable
            filters={[Konva.Filters.Kaleidoscope]}
            kaleidoscopePower={power}
            kaleidoscopeAngle={angle}
          />
        </Layer>
      </Stage>
      <div style={{ position: 'absolute', top: '20px', left: '20px' }}>
        <div>
          Power
          <input
            type="range"
            min="2"
            max="8"
            step="1"
            value={power}
            onChange={(e) => setPower(parseInt(e.target.value))}
            style={{ width: '200px' }}
          />
        </div>
        <div>
          Angle
          <input
            type="range"
            min="0"
            max="360"
            step="0.1"
            value={angle}
            onChange={(e) => setAngle(parseFloat(e.target.value))}
            style={{ width: '200px' }}
          />
        </div>
      </div>
    </>
  );
};

export default App;

----------------------------------------

TITLE: Implementing Content Truncation in Markdown
DESCRIPTION: This snippet demonstrates the use of an HTML comment to indicate where the blog post content should be truncated for preview purposes. It's a common technique used in static site generators.

LANGUAGE: markdown
CODE:
<!-- truncate -->

----------------------------------------

TITLE: Implementing Complex Tweening with Gradient Changes in React
DESCRIPTION: This snippet shows how to create a complex animation with gradient changes using Konva in a React component. It uses the react-konva library and demonstrates how to handle click events, animate scale, and update gradient colors.

LANGUAGE: jsx
CODE:
import { Stage, Layer, Circle } from 'react-konva';
import { useRef } from 'react';

const App = () => {
  const circleRef = useRef();

  const handleClick = () => {
    const circle = circleRef.current;

    // using regular Konva tween
    const tween = new Konva.Tween({
      node: circle,
      duration: 1,
      scaleX: 1.5,
      scaleY: 1.5,
      easing: Konva.Easings.EaseInOut,
      onFinish: () => {
        // scale back with another tween
        const tween2 = new Konva.Tween({
          node: circle,
          duration: 1,
          scaleX: 1,
          scaleY: 1,
          easing: Konva.Easings.Bounce.EaseOut,
        });
        tween2.play();
      },
    });
    tween.play();

    // manually update gradient
    let ratio = 0;
    const anim = new Konva.Animation((frame) => {
      ratio += frame.timeDiff / 1000;
      if (ratio > 1) {
        ratio = 0;
      }
      circle.fillLinearGradientColorStops([
        0,
        'red',
        ratio,
        'yellow',
        1,
        'blue',
      ]);
    }, circle.getLayer());
    anim.start();
    setTimeout(() => anim.stop(), 2000);
  };

  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        <Circle
          ref={circleRef}
          x={window.innerWidth / 2}
          y={window.innerHeight / 2}
          radius={70}
          fillLinearGradientStartPoint={{ x: -50, y: -50 }}
          fillLinearGradientEndPoint={{ x: 50, y: 50 }}
          fillLinearGradientColorStops={[0, 'red', 1, 'yellow']}
          stroke="black"
          strokeWidth={4}
          draggable
          onClick={handleClick}
          onTap={handleClick}
        />
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Applying Contrast Filter in Konva.js
DESCRIPTION: Demonstrates contrast adjustment on a Konva node using the Contrast filter.

LANGUAGE: javascript
CODE:
node.cache();
node.filters([Konva.Filters.Contrast]);
node.contrast(10);

----------------------------------------

TITLE: Implementing Edge-Scroll with React-Konva
DESCRIPTION: React implementation of edge-scrolling functionality using React-Konva components. Uses React hooks (useState, useRef, useCallback) to manage state and intervals for smooth scrolling behavior.

LANGUAGE: jsx
CODE:
import React from 'react';
import { Stage, Layer, Circle } from 'react-konva';

const NUMBER = 100;

const generateNodes = (width, height) => {
  return Array.from({ length: NUMBER }, () => ({
    x: width * (Math.random() * 2 - 1),
    y: height * (Math.random() * 2 - 1),
  }));
};

const App = () => {
  const [stagePos, setStagePos] = React.useState({ x: 0, y: 0 });
  const [nodes, setNodes] = React.useState([]);
  const scrollInterval = React.useRef(null);
  const stageRef = React.useRef(null);
  const draggedNodeRef = React.useRef(null);

  React.useEffect(() => {
    setNodes(generateNodes(window.innerWidth, window.innerHeight));
  }, []);

  const handleDragStart = React.useCallback((e) => {
    draggedNodeRef.current = e.target;
    const duration = 1000 / 60;
    scrollInterval.current = setInterval(() => {
      const stage = stageRef.current;
      if (!stage) return;

      const pos = stage.getPointerPosition();
      if (!pos) return;

      const offset = 100;
      let newX = stagePos.x;
      let newY = stagePos.y;
      let moved = false;

      if (pos.x < offset) {
        newX += 2;
        draggedNodeRef.current.x(draggedNodeRef.current.x() - 2);
        moved = true;
      } else if (pos.x > stage.width() - offset) {
        newX -= 2;
        draggedNodeRef.current.x(draggedNodeRef.current.x() + 2);
        moved = true;
      }

      if (pos.y < offset) {
        newY += 2;
        draggedNodeRef.current.y(draggedNodeRef.current.y() - 2);
        moved = true;
      } else if (pos.y > stage.height() - offset) {
        newY -= 2;
        draggedNodeRef.current.y(draggedNodeRef.current.y() + 2);
        moved = true;
      }

      if (moved) {
        setStagePos({ x: stage.x() + newX, y: stage.y() + newY });
      }
    }, duration);
  }, [stagePos]);

  const handleDragEnd = React.useCallback(() => {
    draggedNodeRef.current = null;
    if (scrollInterval.current) {
      clearInterval(scrollInterval.current);
      scrollInterval.current = null;
    }
  }, []);

  React.useEffect(() => {
    return () => {
      if (scrollInterval.current) {
        clearInterval(scrollInterval.current);
      }
    };
  }, []);

  return (
    <Stage
      width={window.innerWidth}
      height={window.innerHeight}
      x={stagePos.x}
      y={stagePos.y}
      ref={stageRef}
    >
      <Layer>
        {nodes.map((node, i) => (
          <Circle
            key={i}
            x={node.x}
            y={node.y}
            radius={40}
            fill="red"
            stroke="black"
            draggable
            onDragStart={handleDragStart}
            onDragEnd={handleDragEnd}
          />
        ))}
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Implementing Image Mask Filter with Vanilla JavaScript and Konva.js
DESCRIPTION: Creates a draggable image with an adjustable mask filter using vanilla JavaScript and Konva.js. The code sets up a canvas stage, loads an image, applies a mask filter, and provides a slider to control the mask threshold.

LANGUAGE: javascript
CODE:
const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight,
});

const layer = new Konva.Layer();
stage.add(layer);

const imageObj = new Image();
imageObj.onload = () => {
  const image = new Konva.Image({
    x: 50,
    y: 50,
    image: imageObj,
    draggable: true,
  });

  layer.add(image);

  image.cache();
  image.filters([Konva.Filters.Mask]);
  image.threshold(10);

  const slider = document.createElement('input');
  slider.type = 'range';
  slider.min = '0';
  slider.max = '255';
  slider.value = image.threshold();

  slider.style.position = 'absolute';
  slider.style.top = '20px';
  slider.style.left = '20px';

  slider.addEventListener('input', (e) => {
    const value = parseInt(e.target.value);
    image.threshold(value);
  });

  document.body.appendChild(slider);
};
imageObj.src = 'https://konvajs.org/assets/lion.png';
imageObj.crossOrigin = 'anonymous';

----------------------------------------

TITLE: Implementing Draggable Text with Color Change in Vue and Konva
DESCRIPTION: This snippet demonstrates how to create a draggable text element on a Konva stage using Vue.js. The text changes color from black to green while being dragged. It utilizes Konva's v-stage, v-layer, and v-text components, and implements dragstart and dragend event handlers.

LANGUAGE: vue
CODE:
<template>
  <v-stage ref="stage" :config="stageSize">
    <v-layer ref="layer">
      <v-text
        @dragstart="handleDragStart"
        @dragend="handleDragEnd"
        :config="{
          text: 'Draggable Text',
          x: 50,
          y: 50,
          draggable: true,
          fill: isDragging ? 'green' : 'black'
        }"
      />
    </v-layer>
  </v-stage>
</template>

<script>
const width = window.innerWidth;
const height = window.innerHeight;

export default {
  data() {
    return {
      stageSize: {
        width: width,
        height: height
      },
      isDragging: false
    };
  },
  methods: {
    handleDragStart() {
      this.isDragging = true;
    },
    handleDragEnd() {
      this.isDragging = false;
    }
  }
};
</script>

----------------------------------------

TITLE: Firing Custom Events with Konva in Vanilla JavaScript
DESCRIPTION: This snippet demonstrates how to create a Konva stage, add a circle shape, attach a custom event listener, and fire the custom event using vanilla JavaScript. It also includes a button to trigger the event.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight,
});

const layer = new Konva.Layer();
stage.add(layer);

const circle = new Konva.Circle({
  x: stage.width() / 2,
  y: stage.height() / 2,
  radius: 70,
  fill: 'red',
  stroke: 'black',
  strokeWidth: 4,
});

// add shape event listener
circle.on('customEvent', function (evt) {
  alert('custom event fired');
});

// add button to trigger custom event
const button = document.createElement('button');
button.innerHTML = 'Fire Custom Event';
document.body.appendChild(button);
button.addEventListener('click', () => {
  // fire custom event
  circle.fire('customEvent', {
    bubbles: true,
  });
});

layer.add(circle);

----------------------------------------

TITLE: Creating Draggable Circle with Konva in React
DESCRIPTION: This snippet demonstrates how to create a draggable red circle using Konva in a React component. It uses React hooks to manage the circle's position state and includes event handlers for drag end and cursor styling.

LANGUAGE: jsx
CODE:
import { Stage, Layer, Circle } from 'react-konva';
import { useState } from 'react';

const App = () => {
  const [position, setPosition] = useState({ x: window.innerWidth / 2, y: window.innerHeight / 2 });

  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        <Circle
          x={position.x}
          y={position.y}
          radius={70}
          fill="red"
          stroke="black"
          strokeWidth={4}
          draggable
          onMouseEnter={(e) => {
            document.body.style.cursor = 'pointer';
          }}
          onMouseLeave={(e) => {
            document.body.style.cursor = 'default';
          }}
          onDragEnd={(e) => {
            setPosition({
              x: e.target.x(),
              y: e.target.y()
            });
          }}
        />
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Creating a Group of Shapes with Konva in Vanilla JavaScript
DESCRIPTION: This snippet demonstrates how to create a draggable group containing a circle and a rectangle using Konva in vanilla JavaScript. It initializes a stage, adds a layer, creates a group, and adds shapes to the group.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight
});

const layer = new Konva.Layer();
stage.add(layer);

const group = new Konva.Group({
  x: 50,
  y: 50,
  draggable: true
});

const circle = new Konva.Circle({
  x: 0,
  y: 0,
  radius: 30,
  fill: 'red'
});

const rect = new Konva.Rect({
  x: 20,
  y: 20,
  width: 100,
  height: 50,
  fill: 'green'
});

group.add(circle);
group.add(rect);
layer.add(group);

----------------------------------------

TITLE: Creating Regular Polygon with Konva in Vanilla JavaScript
DESCRIPTION: This snippet demonstrates how to create a hexagon using Konva in vanilla JavaScript. It sets up a stage, adds a layer, and creates a RegularPolygon with specified properties such as position, sides, radius, fill color, and stroke.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight
});

const layer = new Konva.Layer();
stage.add(layer);

const hexagon = new Konva.RegularPolygon({
  x: stage.width() / 2,
  y: stage.height() / 2,
  sides: 6,
  radius: 70,
  fill: 'red',
  stroke: 'black',
  strokeWidth: 4
});

layer.add(hexagon);

----------------------------------------

TITLE: Implementing Line Dragging with Vue and Konva
DESCRIPTION: Creates a draggable red line using Vue-Konva components. Utilizes Vue's reactive state management and composition API with separate event handlers for drag operations and cursor styling.

LANGUAGE: vue
CODE:
<template>
  <v-stage :config="stageSize">
    <v-layer>
      <v-line
        :config="lineConfig"
        @dragend="handleDragEnd"
        @mouseenter="handleMouseEnter"
        @mouseleave="handleMouseLeave"
      />
    </v-layer>
  </v-stage>
</template>

<script setup>
import { ref, reactive } from 'vue';

const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight
};

const position = reactive({ x: 50, y: 50 });

const lineConfig = {
  x: position.x,
  y: position.y,
  points: [0, 0, 150, 0],
  stroke: 'red',
  strokeWidth: 15,
  lineCap: 'round',
  lineJoin: 'round',
  draggable: true
};

const handleDragEnd = (e) => {
  position.x = e.target.x();
  position.y = e.target.y();
};

const handleMouseEnter = () => {
  document.body.style.cursor = 'pointer';
};

const handleMouseLeave = () => {
  document.body.style.cursor = 'default';
};
</script>

----------------------------------------

TITLE: Creating Basic Custom Filter in JavaScript
DESCRIPTION: Demonstrates the basic structure of a custom filter function that manipulates image data. The function takes ImageData as input and modifies it directly.

LANGUAGE: javascript
CODE:
function Filter(imageData) {
  // do something with image data
  imageData.data[0] = 0;
}

----------------------------------------

TITLE: Custom Scrollbar Implementation
DESCRIPTION: Advanced implementation with custom-drawn scrollbars. Includes vertical and horizontal scrolling with manual scroll handling and wheel event support.

LANGUAGE: javascript
CODE:
const scrollLayers = new Konva.Layer();
stage.add(scrollLayers);

const verticalBar = new Konva.Rect({
  width: 10,
  height: 100,
  fill: 'grey',
  opacity: 0.8,
  x: stage.width() - PADDING - 10,
  y: PADDING,
  draggable: true
});

----------------------------------------

TITLE: Implementing Common Easings with Konva in Vanilla JavaScript
DESCRIPTION: This snippet demonstrates how to create rectangles with different easing functions using Konva in vanilla JavaScript. It sets up a stage, creates rectangles for each easing type, and applies tweens with the corresponding easing function on mouse enter and leave events.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const width = window.innerWidth;
const height = window.innerHeight;

const stage = new Konva.Stage({
container: 'container',
width: width,
height: height,
});

const layer = new Konva.Layer();

const easings = ['Linear', 'EaseIn', 'EaseOut', 'EaseInOut'];
const boxes = [];

easings.forEach((easing, i) => {
const box = new Konva.Rect({
x: 50,
y: 50 + i * 80,
width: 100,
height: 50,
fill: '#00D2FF',
stroke: 'black',
strokeWidth: 4,
});
layer.add(box);
boxes.push(box);

const text = new Konva.Text({
x: 160,
y: 65 + i * 80,
text: easing,
fontSize: 16,
fontFamily: 'Calibri',
fill: 'black',
});
layer.add(text);

box.on('mouseenter touchstart', () => {
const tween = new Konva.Tween({
node: box,
duration: 1,
x: width - 150,
easing: Konva.Easings[easing],
}).play();
});

box.on('mouseleave touchend', () => {
const tween = new Konva.Tween({
node: box,
duration: 1,
x: 50,
easing: Konva.Easings[easing],
}).play();
});
});

stage.add(layer);

----------------------------------------

TITLE: Creating Interactive Canvas Shapes with React Konva
DESCRIPTION: Example React component demonstrating how to create a canvas with draggable shapes using react-konva. Shows usage of Stage, Layer, and various shape components with properties for positioning, styling, and interactivity.

LANGUAGE: javascript
CODE:
import React from 'react';
import { Stage, Layer, Rect, Circle, Text } from 'react-konva';

const App = () => {
  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        <Text text="Try to drag shapes" fontSize={15} />
        <Rect
          x={20}
          y={50}
          width={100}
          height={100}
          fill="red"
          shadowBlur={10}
          draggable
        />
        <Circle
          x={200}
          y={100}
          radius={50}
          fill="green"
          draggable
        />
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Batch Drawing Layer
DESCRIPTION: Method to schedule drawing of the layer on the next animation frame for improved performance.

LANGUAGE: javascript
CODE:
batchDraw()

----------------------------------------

TITLE: Integrating DOM Elements in Konva Stage using React
DESCRIPTION: This code snippet demonstrates how to use the `<Html />` component from react-konva-utils to render a DOM input element inside a Konva stage. It also includes a Konva Rect shape to show the coexistence of DOM and canvas elements.

LANGUAGE: jsx
CODE:
import React from 'react';
import { Stage, Layer, Rect } from 'react-konva';
import { Html } from 'react-konva-utils';

const App = () => {
  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        <Html>
          <input placeholder="DOM input from Konva nodes" />
        </Html>
        <Rect
          x={20}
          y={20}
          width={50}
          height={50}
          fill="red"
          shadowBlur={5}
        />
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Applying Brightness Filter in Konva.js
DESCRIPTION: Shows how to adjust brightness of a Konva node by caching and applying the brightness filter.

LANGUAGE: javascript
CODE:
node.cache();
node.filters([Konva.Filters.Brighten]);
node.brightness(0.8);

----------------------------------------

TITLE: Implementing Image Hover Effects with Vanilla Konva.js
DESCRIPTION: Creates a canvas with two draggable images that expand on hover using vanilla Konva.js. Implements mouse event handling for hover effects and image loading.

LANGUAGE: javascript
CODE:
const width = window.innerWidth;
const height = window.innerHeight;

const stage = new Konva.Stage({
  container: 'container',
  width: width,
  height: height,
});

const layer = new Konva.Layer();
stage.add(layer);

// Create Darth Vader image
const darthVaderImg = new Konva.Image({
  x: 110,
  y: 88,
  width: 200,
  height: 137,
  offset: {
    x: 100,
    y: 68,
  },
  draggable: true,
});
layer.add(darthVaderImg);

// Create Yoda image
const yodaImg = new Konva.Image({
  x: 290,
  y: 70,
  width: 93,
  height: 104,
  offset: {
    x: 46,
    y: 52,
  },
  draggable: true,
});
layer.add(yodaImg);

// Load Darth Vader image
const imageObj1 = new Image();
imageObj1.onload = function () {
  darthVaderImg.image(imageObj1);
};
imageObj1.src = 'https://konvajs.org/assets/darth-vader.jpg';

// Load Yoda image
const imageObj2 = new Image();
imageObj2.onload = function () {
  yodaImg.image(imageObj2);
};
imageObj2.src = 'https://konvajs.org/assets/yoda.jpg';

// Use event delegation to update pointer style and apply scaling
layer.on('mouseover', function (evt) {
  const shape = evt.target;
  document.body.style.cursor = 'pointer';
  
  // Scale up the image on hover
  shape.to({
    scaleX: 1.2,
    scaleY: 1.2,
    duration: 0.2,
  });
});

layer.on('mouseout', function (evt) {
  const shape = evt.target;
  document.body.style.cursor = 'default';
  
  // Scale back to normal when mouse leaves
  shape.to({
    scaleX: 1,
    scaleY: 1,
    duration: 0.2,
  });
});

----------------------------------------

TITLE: Implementing Drag and Drop with Vanilla JavaScript and Konva
DESCRIPTION: This snippet shows how to set up drag and drop functionality for DOM images into a Konva canvas using vanilla JavaScript. It includes creating the stage, handling drag events, and adding dropped images to the canvas.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const width = window.innerWidth;
const height = window.innerHeight;

// Add DOM elements to render outside the container
document.getElementById('container').insertAdjacentHTML(
  'beforebegin',
  `
  <p>Drag&drop yoda into the grey area.</p>
  <div id="drag-items">
    <img src="https://konvajs.org/assets/yoda.jpg" draggable="true" style="height: 100px; margin: 5px;" />
    <img src="https://konvajs.org/assets/darth-vader.jpg" draggable="true" style="height: 100px; margin: 5px;" />
  </div>
`
);

// Style the container with grey background
document.getElementById('container').style.backgroundColor = 'rgba(0, 0, 0, 0.1)';

// Create stage and layer
const stage = new Konva.Stage({
  container: 'container',
  width: width,
  height: height - 150, // leave space for the DOM elements
});

const layer = new Konva.Layer();
stage.add(layer);

// Track URL of the dragging element
let itemURL = '';
document
  .getElementById('drag-items')
  .addEventListener('dragstart', function (e) {
    itemURL = e.target.src;
  });

// Handle dragover on container
const container = stage.container();
container.addEventListener('dragover', function (e) {
  e.preventDefault(); // important - must prevent default behavior
});

// Handle drop on container
container.addEventListener('drop', function (e) {
  e.preventDefault();
  
  // Register the pointer position manually since this is a DOM event
  stage.setPointersPositions(e);
  
  // Load the image and add it to the layer
  Konva.Image.fromURL(itemURL, function (image) {
    // Calculate appropriate size based on image dimensions
    const img = image.image();
    const maxDimension = 100;
    let width = img.width;
    let height = img.height;
    
    if (width > height) {
      height = (height / width) * maxDimension;
      width = maxDimension;
    } else {
      width = (width / height) * maxDimension;
      height = maxDimension;
    }
    
    image.size({
      width: width,
      height: height
    });
    
    layer.add(image);
    image.position(stage.getPointerPosition());
    image.draggable(true);
  });
});

----------------------------------------

TITLE: Transform-based Scrolling
DESCRIPTION: Optimized scrolling implementation using CSS transforms and position calculations. Creates a virtual scrolling effect while maintaining good performance.

LANGUAGE: javascript
CODE:
function repositionStage() {
  const dx = scrollContainer.scrollLeft - PADDING;
  const dy = scrollContainer.scrollTop - PADDING;
  stage.container().style.transform =
    'translate(' + dx + 'px, ' + dy + 'px)';
  stage.x(-dx);
  stage.y(-dy);
}

----------------------------------------

TITLE: Implementing Animation Controls in React with Konva
DESCRIPTION: React implementation of a Konva animation with start/stop controls. Uses hooks (useRef, useState, useEffect) to manage animation state and cleanup. The component creates an animated circle with controlled motion.

LANGUAGE: jsx
CODE:
import { Stage, Layer, Circle } from 'react-konva';
import { useEffect, useRef, useState } from 'react';

const App = () => {
  const circleRef = useRef(null);
  const [isAnimating, setIsAnimating] = useState(false);
  const animRef = useRef(null);

  useEffect(() => {
    const amplitude = 100;
    const period = 2000;

    animRef.current = new Konva.Animation((frame) => {
      circleRef.current.x(
        amplitude * Math.sin((frame.time * 2 * Math.PI) / period) +
        window.innerWidth / 2
      );
    }, circleRef.current.getLayer());

    return () => {
      if (animRef.current) {
        animRef.current.stop();
      }
    };
  }, []);

  const handleStart = () => {
    animRef.current.start();
    setIsAnimating(true);
  };

  const handleStop = () => {
    animRef.current.stop();
    setIsAnimating(false);
  };

  return (
    <div>
      <div style={{ marginBottom: '10px' }}>
        <button onClick={handleStart} disabled={isAnimating}>Start Animation</button>
        <button onClick={handleStop} disabled={!isAnimating}>Stop Animation</button>
      </div>
      <Stage width={window.innerWidth} height={window.innerHeight}>
        <Layer>
          <Circle
            ref={circleRef}
            x={window.innerWidth / 2}
            y={window.innerHeight / 2}
            radius={30}
            fill="red"
            stroke="black"
            strokeWidth={4}
          />
        </Layer>
      </Stage>
    </div>
  );

----------------------------------------

TITLE: Implementing Shape Layering with Vanilla JavaScript in Konva
DESCRIPTION: This snippet demonstrates how to create draggable shapes and implement layering controls using Vanilla JavaScript with Konva. It creates a stage, layer, and two draggable rectangles, along with buttons to change the layering order of the yellow rectangle.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const width = window.innerWidth;
const height = window.innerHeight;

const stage = new Konva.Stage({
container: 'container',
width: width,
height: height,
});

const layer = new Konva.Layer();

const yellowBox = new Konva.Rect({
x: 50,
y: 50,
width: 100,
height: 100,
fill: 'yellow',
stroke: 'black',
strokeWidth: 4,
draggable: true,
});

const redBox = new Konva.Rect({
x: 100,
y: 100,
width: 100,
height: 100,
fill: 'red',
stroke: 'black',
strokeWidth: 4,
draggable: true,
});

layer.add(yellowBox);
layer.add(redBox);
stage.add(layer);

// create buttons
const toTopBtn = document.createElement('button');
toTopBtn.textContent = 'Move yellow box to top';
toTopBtn.addEventListener('click', () => {
yellowBox.moveToTop();
});

const toBottomBtn = document.createElement('button');
toBottomBtn.textContent = 'Move yellow box to bottom';
toBottomBtn.addEventListener('click', () => {
yellowBox.moveToBottom();
});

document.body.appendChild(toTopBtn);
document.body.appendChild(toBottomBtn);

----------------------------------------

TITLE: Implementing Stage Preview with Node Cloning in Vanilla JavaScript
DESCRIPTION: Creates a preview of a Konva stage by cloning the layer and its shapes, with the preview updating on drag events and shape additions. The preview is scaled down to 1/4 size and disables interactivity.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

// Create preview container
const preview = document.createElement('div');
preview.id = 'preview';
preview.style.position = 'absolute';
preview.style.top = '2px';
preview.style.right = '2px';
preview.style.border = '1px solid grey';
preview.style.backgroundColor = 'lightgrey';
document.body.appendChild(preview);

const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight,
});

// Rest of implementation...

----------------------------------------

TITLE: Getting Layer Canvas
DESCRIPTION: Method to get the layer's canvas wrapper.

LANGUAGE: javascript
CODE:
getCanvas()

----------------------------------------

TITLE: Starting Local Development Server
DESCRIPTION: Command to start a local development server that provides live reload functionality for real-time preview of changes.

LANGUAGE: bash
CODE:
$ yarn start

----------------------------------------

TITLE: Implementing Linear Tween Animation in Vanilla JavaScript with Konva
DESCRIPTION: Creates a simple animation that moves a circle horizontally across the screen using Konva.Tween with linear easing. The animation is triggered by clicking the circle and moves it from left to right.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const width = window.innerWidth;
const height = window.innerHeight;

const stage = new Konva.Stage({
container: 'container',
width: width,
height: height,
});

const layer = new Konva.Layer();

const circle = new Konva.Circle({
x: 100,
y: height / 2,
radius: 70,
fill: 'red',
stroke: 'black',
strokeWidth: 4,
});

layer.add(circle);
stage.add(layer);

circle.on('click tap', () => {
// simple tween
const tween = new Konva.Tween({
node: circle,
duration: 1,
x: width - 100,
easing: Konva.Easings.Linear,
});
tween.play();
});

----------------------------------------

TITLE: Demonstrating Position in Konva with Draggable Shapes
DESCRIPTION: This snippet creates a stage with a draggable rectangle and circle, showcasing how position (x and y) affects their placement. It also includes a text element to display the current position of the dragged shape.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight,
});
var layer = new Konva.Layer();

var rect = new Konva.Rect({
x: 20,
y: 20,
width: 100,
height: 100,
fill: 'yellow',
stroke: 'black',
strokeWidth: 4,
draggable: true,
});

// add the shape to the layer
layer.add(rect);

var circle = new Konva.Circle({
x: 150,
y: 120,
radius: 50,
fill: 'red',
stroke: 'black',
strokeWidth: 4,
draggable: true,
});

// add the shape to the layer
layer.add(circle);

var text = new Konva.Text();
layer.add(text);

// add the layer to the stage
stage.add(layer);

function updateText(e) {
    text.text('Position: x = ' + e.target.x() + '   y = ' + e.target.y());
}

rect.on('dragmove', updateText);
circle.on('dragmove', updateText);

----------------------------------------

TITLE: Implementing Linear Tween Animation in React with Konva
DESCRIPTION: React implementation of the circle animation using react-konva components. Uses useRef hook to access the circle node and implements the same linear tween animation triggered by click events.

LANGUAGE: javascript
CODE:
import { Stage, Layer, Circle } from 'react-konva';
import { useRef } from 'react';

const App = () => {
  const circleRef = useRef();

  const handleClick = () => {
    const tween = new Konva.Tween({
      node: circleRef.current,
      duration: 1,
      x: window.innerWidth - 100,
      easing: Konva.Easings.Linear,
    });
    tween.play();
  };

  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        <Circle
          ref={circleRef}
          x={100}
          y={window.innerHeight / 2}
          radius={70}
          fill="red"
          stroke="black"
          strokeWidth={4}
          onClick={handleClick}
          onTap={handleClick}
        />
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Setting Star Outer Radius - JavaScript
DESCRIPTION: Example showing how to get and set the outer radius of a star shape.

LANGUAGE: javascript
CODE:
// get inner radius
var outerRadius = star.outerRadius();

// set inner radius
star.outerRadius(20);

----------------------------------------

TITLE: Loading Konva Stage from JSON in Vanilla JavaScript
DESCRIPTION: This snippet demonstrates how to load a Konva stage from a JSON string using the Konva.Node.create() method. It creates a stage with a circle and adds a click event to change the circle's color randomly.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

// JSON string from a previous save
const json = '{"attrs":{"width":400,"height":400},"className":"Stage","children":[{"attrs":{},"className":"Layer","children":[{"attrs":{"x":100,"y":100,"radius":50,"fill":"red","stroke":"black","strokeWidth":3},"className":"Circle"}]}]}';

// create node using json string
const stage = Konva.Node.create(json, 'container');

// you can keep adding events, etc
const circle = stage.findOne('Circle');
circle.on('click', () => {
  circle.fill(Konva.Util.getRandomColor());
});

----------------------------------------

TITLE: Implementing Common Easings with Konva in React
DESCRIPTION: This snippet shows how to create rectangles with different easing functions using Konva in a React application. It defines a Box component that applies tweens with the specified easing function on mouse enter and leave events, and renders multiple boxes for different easing types.

LANGUAGE: jsx
CODE:
import { Stage, Layer, Rect, Text } from 'react-konva';
import { useRef } from 'react';

const Box = ({ easing, y }) => {
  const boxRef = useRef();

  const handleMouseEnter = () => {
    new Konva.Tween({
      node: boxRef.current,
      duration: 1,
      x: window.innerWidth - 150,
      easing: Konva.Easings[easing],
    }).play();
  };

  const handleMouseLeave = () => {
    new Konva.Tween({
      node: boxRef.current,
      duration: 1,
      x: 50,
      easing: Konva.Easings[easing],
    }).play();
  };

  return (
    <>
      <Rect
        ref={boxRef}
        x={50}
        y={y}
        width={100}
        height={50}
        fill="#00D2FF"
        stroke="black"
        strokeWidth={4}
        onMouseEnter={handleMouseEnter}
        onMouseLeave={handleMouseLeave}
        onTouchStart={handleMouseEnter}
        onTouchEnd={handleMouseLeave}
      />
      <Text
        x={160}
        y={y + 15}
        text={easing}
        fontSize={16}
        fontFamily="Calibri"
        fill="black"
      />
    </>
  );
};

const App = () => {
  const easings = ['Linear', 'EaseIn', 'EaseOut', 'EaseInOut'];

  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        {easings.map((easing, i) => (
          <Box key={i} easing={easing} y={50 + i * 80} />
        ))}
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Animating Multiple Shapes with Vanilla Konva
DESCRIPTION: Creates 300 rectangles with random properties and animates them using Konva's animation system. Performance is optimized by disabling the layer's hit detection through the listening property.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const width = window.innerWidth;
const height = window.innerHeight;

function update(layer, frame) {
  const angularSpeed = 100;
  const angularDiff = (angularSpeed * frame.timeDiff) / 1000;
  const shapes = layer.getChildren();

  for (let n = 0; n < shapes.length; n++) {
    const shape = shapes[n];
    shape.rotate(angularDiff);
  }
}

const stage = new Konva.Stage({
  container: 'container',
  width: width,
  height: height,
});

const layer = new Konva.Layer({
  listening: false,
});

const colors = [
  'red',
  'orange',
  'yellow',
  'green',
  'blue',
  'cyan',
  'purple',
];
let colorIndex = 0;

for (let i = 0; i < 300; i++) {
  const color = colors[colorIndex++];
  if (colorIndex >= colors.length) {
    colorIndex = 0;
  }

  const randWidth = Math.random() * 100 + 20;
  const randHeight = Math.random() * 100 + 20;
  const randX = Math.random() * stage.width() - 20;
  const randY = Math.random() * stage.height() - 20;

  const box = new Konva.Rect({
    x: randX,
    y: randY,
    offset: {
      x: randWidth / 2,
      y: randHeight / 2,
    },
    width: randWidth,
    height: randHeight,
    fill: color,
    stroke: 'black',
    strokeWidth: 4,
  });

  layer.add(box);
}

stage.add(layer);

const anim = new Konva.Animation(function (frame) {
  update(layer, frame);
}, layer);

anim.start();

----------------------------------------

TITLE: Setting the points of a Konva.Line
DESCRIPTION: Gets or sets the points array of the line. Points is a flat array [x1, y1, x2, y2, ...] for performance reasons.

LANGUAGE: javascript
CODE:
// get points
var points = line.points();

// set points
line.points([10, 20, 30, 40, 50, 60]);

// push a new point
line.points(line.points().concat([70, 80]));

----------------------------------------

TITLE: Implementing Linear Tween Animation in Vue with Konva
DESCRIPTION: Vue implementation of the circle animation using Vue Konva components. Uses ref to access the circle node and implements the same linear tween animation with click event handling.

LANGUAGE: javascript
CODE:
<template>
  <v-stage :config="stageSize">
    <v-layer>
      <v-circle
        :config="circleConfig"
        @click="handleClick"
        @tap="handleClick"
        ref="circleRef"
      />
    </v-layer>
  </v-stage>
</template>

<script setup>
import { ref } from 'vue';
import Konva from 'konva';

const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight
};

const circleConfig = {
  x: 100,
  y: window.innerHeight / 2,
  radius: 70,
  fill: 'red',
  stroke: 'black',
  strokeWidth: 4
};

const circleRef = ref(null);

const handleClick = () => {
  const tween = new Konva.Tween({
    node: circleRef.value.getNode(),
    duration: 1,
    x: window.innerWidth - 100,
    easing: Konva.Easings.Linear,
  });
  tween.play();
};
</script>

----------------------------------------

TITLE: Initializing Konva Path
DESCRIPTION: Create a new Path instance with configuration options.

LANGUAGE: javascript
CODE:
new Konva.Path(config)

----------------------------------------

TITLE: Creating Konva Ellipse
DESCRIPTION: Constructor for creating a new ellipse shape with specified configuration

LANGUAGE: javascript
CODE:
new Konva.Ellipse(config)

----------------------------------------

TITLE: Implementing Tween Controls in Vue with Konva
DESCRIPTION: Vue implementation of tween animation controls using vue-konva. Uses Vue's composition API with refs to manage the circle and tween instances, implementing the same control functionality.

LANGUAGE: javascript
CODE:
<template>
  <div>
    <button
      v-for="control in controls"
      :key="control"
      @click="handleControl(control)"
    >
      {{ control }}
    </button>
    <button @click="handleSeek">Seek to 50%</button>
    <v-stage :config="stageSize">
      <v-layer>
        <v-circle
          :config="circleConfig"
          ref="circleRef"
        />
      </v-layer>
    </v-stage>
  </div>
</template>

<script setup>
import { ref, onMounted } from 'vue';
import Konva from 'konva';

const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight
};

const circleConfig = {
  x: 100,
  y: window.innerHeight / 2,
  radius: 70,
  fill: 'red',
  stroke: 'black',
  strokeWidth: 4
};

const controls = ['play', 'pause', 'reverse', 'reset', 'finish'];
const circleRef = ref(null);
let tween = null;

onMounted(() => {
  tween = new Konva.Tween({
    node: circleRef.value.getNode(),
    duration: 2,
    x: window.innerWidth - 100,
    easing: Konva.Easings.EaseInOut,
  });
});

const handleControl = (control) => {
  tween[control]();
};

const handleSeek = () => {
  tween.seek(1);
};
</script>

----------------------------------------

TITLE: Getting and Setting zIndex in Konva
DESCRIPTION: Demonstrates how to retrieve and set the zIndex of a Konva shape. The zIndex represents the index of a node in its parent's children array.

LANGUAGE: javascript
CODE:
// get
const zIndex = shape.zIndex();

// set
shape.zIndex(1);

----------------------------------------

TITLE: Initializing Konva Transform
DESCRIPTION: Constructor for creating a new Transform instance. Accepts an optional six-element matrix parameter for initialization.

LANGUAGE: javascript
CODE:
new Konva.Transform(config)

----------------------------------------

TITLE: Implementing Easing Functions with Konva in React
DESCRIPTION: This code snippet shows how to use Konva easing functions in a React component. It creates a stage with text nodes for each easing type and applies tweens using useEffect. A button is provided to trigger the animations.

LANGUAGE: jsx
CODE:
import { Stage, Layer, Text } from 'react-konva';
import { useEffect, useRef } from 'react';

const App = () => {
  const tweensRef = useRef([]);
  const textsRef = useRef([]);

  const easings = [
    'Linear',
    'EaseIn',
    'EaseOut',
    'EaseInOut',
    'BackEaseIn',
    'BackEaseOut',
    'BackEaseInOut',
    'ElasticEaseIn',
    'ElasticEaseOut',
    'ElasticEaseInOut',
    'BounceEaseIn',
    'BounceEaseOut',
    'BounceEaseInOut',
    'StrongEaseIn',
    'StrongEaseOut',
    'StrongEaseInOut',
  ];

  useEffect(() => {
    tweensRef.current = textsRef.current.map((text, i) => {
      return new Konva.Tween({
        node: text,
        duration: 2,
        x: window.innerWidth - 200,
        easing: Konva.Easings[easings[i]],
      });
    });
  }, []);

  const handlePlay = () => {
    tweensRef.current.forEach((tween) => {
      tween.reset();
      tween.play();
    });
  };

  return (
    <>
      <button onClick={handlePlay}>Play</button>
      <Stage width={window.innerWidth} height={window.innerHeight}>
        <Layer>
          {easings.map((easing, i) => (
            <Text
              key={i}
              ref={(node) => (textsRef.current[i] = node)}
              x={50}
              y={30 + i * 25}
              text={easing}
              fontSize={16}
              fontFamily="Calibri"
              fill="black"
            />
          ))}
        </Layer>
      </Stage>
    </>
  );
};

export default App;

----------------------------------------

TITLE: Setting Star Points - JavaScript
DESCRIPTION: Example showing how to get and set the number of points on a star shape.

LANGUAGE: javascript
CODE:
// get inner radius
var numPoints = star.numPoints();

// set inner radius
star.numPoints(20);

----------------------------------------

TITLE: Implementing Easing Functions with Konva in Vanilla JavaScript
DESCRIPTION: This code snippet demonstrates how to use various easing functions in Konva with Vanilla JavaScript. It creates a stage, adds text nodes for each easing type, and applies tweens with different easing functions. A button is added to trigger the animations.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const width = window.innerWidth;
const height = window.innerHeight;

const stage = new Konva.Stage({
container: 'container',
width: width,
height: height,
});

const layer = new Konva.Layer();

const easings = [
'Linear',
'EaseIn',
'EaseOut',
'EaseInOut',
'BackEaseIn',
'BackEaseOut',
'BackEaseInOut',
'ElasticEaseIn',
'ElasticEaseOut',
'ElasticEaseInOut',
'BounceEaseIn',
'BounceEaseOut',
'BounceEaseInOut',
'StrongEaseIn',
'StrongEaseOut',
'StrongEaseInOut',
];

const tweens = [];

easings.forEach((easing, i) => {
const text = new Konva.Text({
x: 50,
y: 30 + i * 25,
text: easing,
fontSize: 16,
fontFamily: 'Calibri',
fill: 'black',
});
layer.add(text);

tweens.push(
new Konva.Tween({
node: text,
duration: 2,
x: width - 200,
easing: Konva.Easings[easing],
})
);
});

stage.add(layer);

// create button
const button = document.createElement('button');
button.textContent = 'Play';
button.style.position = 'absolute';
button.style.top = '0px';
button.style.left = '0px';
button.addEventListener('click', () => {
tweens.forEach((tween) => {
tween.reset();
tween.play();
});
});
document.body.appendChild(button);

----------------------------------------

TITLE: Implementing Solarize Filter with Vanilla JavaScript and Konva
DESCRIPTION: Creates a draggable image with an adjustable solarize filter using vanilla JavaScript and Konva. Includes a slider control to adjust the threshold value of the solarize effect. Requires Konva library and an image source.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight,
});

const layer = new Konva.Layer();
stage.add(layer);

const imageObj = new Image();
imageObj.onload = () => {
  const image = new Konva.Image({
    x: 50,
    y: 50,
    image: imageObj,
    draggable: true,
  });

  layer.add(image);

  image.cache();
  image.filters([Konva.Filters.Solarize]);
  image.threshold(0.5);

  const container = document.createElement('div');
  container.style.position = 'absolute';
  container.style.top = '20px';
  container.style.left = '20px';
  
  const text = document.createElement('span');
  text.textContent = 'Threshold: ';
  container.appendChild(text);
  
  const slider = document.createElement('input');
  slider.type = 'range';
  slider.min = '0';
  slider.max = '1';
  slider.step = '0.1';
  slider.value = image.threshold();
  slider.style.width = '200px';
  
  slider.addEventListener('input', (e) => {
    const value = parseFloat(e.target.value);
    image.threshold(value);
  });
  
  container.appendChild(slider);
  document.body.appendChild(container);
};
imageObj.src = 'https://konvajs.org/assets/lion.png';
imageObj.crossOrigin = 'anonymous';

----------------------------------------

TITLE: Creating Simple Lines with Konva in JavaScript
DESCRIPTION: This snippet demonstrates how to create simple lines and dashed lines using Konva. It initializes a stage, adds a layer, and creates two lines with different properties.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight
});

const layer = new Konva.Layer();
stage.add(layer);

const redLine = new Konva.Line({
  points: [5, 70, 140, 23, 250, 60, 300, 20],
  stroke: 'red',
  strokeWidth: 15,
  lineCap: 'round',
  lineJoin: 'round'
});

// dashed line
const greenLine = new Konva.Line({
  points: [5, 70, 140, 23, 250, 60, 300, 20],
  stroke: 'green',
  strokeWidth: 2,
  lineJoin: 'round',
  dash: [33, 10]
});

greenLine.y(50);
layer.add(redLine, greenLine);

----------------------------------------

TITLE: Mobile Touch Events with Vue-Konva Components
DESCRIPTION: Vue 3 implementation of mobile touch events using vue-konva components. Uses the Composition API with refs and computed properties for reactive state management. Implements the same touch event functionality in a Vue-specific way.

LANGUAGE: html
CODE:
<template>
  <v-stage :config="stageSize" ref="stageRef">
    <v-layer>
      <v-text :config="textConfig" />
      <v-regular-polygon
        :config="triangleConfig"
        @touchmove="handleTriangleTouch"
      />
      <v-circle
        :config="circleConfig"
        @touchstart="handleTouchStart"
        @touchend="handleTouchEnd"
      />
    </v-layer>
  </v-stage>
</template>

<script setup>
import { ref, computed } from 'vue';

const stageRef = ref(null);
const message = ref('');

const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight
};

const textConfig = computed(() => ({
  x: 10,
  y: 10,
  fontFamily: 'Calibri',
  fontSize: 24,
  text: message.value,
  fill: 'black'
}));

const triangleConfig = {
  x: 80,
  y: 120,
  sides: 3,
  radius: 80,
  fill: '#00D2FF',
  stroke: 'black',
  strokeWidth: 4
};

const circleConfig = {
  x: 230,
  y: 100,
  radius: 60,
  fill: 'red',
  stroke: 'black',
  strokeWidth: 4
};

const handleTriangleTouch = () => {
  const touchPos = stageRef.value.getNode().getPointerPosition();
  message.value = `x: ${touchPos.x}, y: ${touchPos.y}`;
};

const handleTouchStart = () => {
  message.value = 'touchstart circle';
};

const handleTouchEnd = () => {
  message.value = 'touchend circle';
};
</script>

----------------------------------------

TITLE: Creating a Custom Rectangle Shape with Konva in JavaScript
DESCRIPTION: This snippet demonstrates how to create a custom rectangle shape using Konva.Shape(). It defines a sceneFunc that draws a rectangle and applies styles using the Konva-specific fillStrokeShape method.

LANGUAGE: javascript
CODE:
const rect = new Konva.Shape({
  x: 10,
  y: 20,
  fill: '#00D2FF',
  width: 100,
  height: 50,
  sceneFunc: function (context, shape) {
    context.beginPath();
    // don't need to set position of rect, Konva will handle it
    context.rect(0, 0, shape.getAttr('width'), shape.getAttr('height'));
    // (!) Konva specific method, it is very important
    // it will apply all required styles
    context.fillStrokeShape(shape);
  }
});

----------------------------------------

TITLE: Implementing Canvas Clipping with Vanilla Konva
DESCRIPTION: Creates a canvas stage with a clipped group containing random green circles. Uses Konva's clip property to define a rectangular clipping region with specific dimensions.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight,
});

const layer = new Konva.Layer();

const group = new Konva.Group({
  clip: {
    x: 100,
    y: 20,
    width: 200,
    height: 200,
  },
});

for (let i = 0; i < 20; i++) {
  const blob = new Konva.Circle({
    x: Math.random() * stage.width(),
    y: Math.random() * stage.height(),
    radius: Math.random() * 50,
    fill: 'green',
    opacity: 0.8,
  });
  group.add(blob);
}

layer.add(group);
stage.add(layer);

----------------------------------------

TITLE: Creating a Rectangle Shape
DESCRIPTION: Constructor for creating a new rectangular shape with configuration options for appearance and behavior

LANGUAGE: javascript
CODE:
new Konva.Rect(config)

----------------------------------------

TITLE: Animating Circle Position with Vue-Konva
DESCRIPTION: Demonstrates the circle animation implementation using Vue-Konva components. Uses Vue's composition API with ref and lifecycle hooks to manage the animation. Implements the same sinusoidal movement pattern while following Vue's component structure.

LANGUAGE: javascript
CODE:
<template>
  <v-stage :config="stageSize">
    <v-layer ref="layerRef">
      <v-circle
        ref="circleRef"
        :config="circleConfig"
      />
    </v-layer>
  </v-stage>
</template>

<script setup>
import { ref, onMounted, onUnmounted } from 'vue';
import Konva from 'konva';

const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight
};

const circleConfig = ref({
  x: 50,
  y: window.innerHeight / 2,
  radius: 30,
  fill: 'red',
  stroke: 'black',
  strokeWidth: 4
});

const layerRef = ref(null);
const circleRef = ref(null);
let anim = null;

onMounted(() => {
  const amplitude = 100;
  const period = 2000; // in milliseconds

  anim = new Konva.Animation((frame) => {
    circleRef.value.getNode().x(
      amplitude * Math.sin((frame.time * 2 * Math.PI) / period) +
      window.innerWidth / 2
    );
  }, layerRef.value.getNode());

  anim.start();
});

onUnmounted(() => {
  if (anim) {
    anim.stop();
  }
});
</script>

----------------------------------------

TITLE: Creating Star Shape with Vue-Konva
DESCRIPTION: Illustrates star shape creation using Vue-Konva components. Uses Vue's template syntax and setup script to define stage configuration and star properties.

LANGUAGE: javascript
CODE:
<template>
  <v-stage :config="stageSize">
    <v-layer>
      <v-star :config="starConfig" />
    </v-layer>
  </v-stage>
</template>

<script setup>
const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight
};

const starConfig = {
  x: window.innerWidth / 2,
  y: window.innerHeight / 2,
  numPoints: 5,
  innerRadius: 30,
  outerRadius: 70,
  fill: 'yellow',
  stroke: 'black',
  strokeWidth: 4
};
</script>

----------------------------------------

TITLE: Selecting and Animating Shapes by ID in Konva (Vanilla JavaScript)
DESCRIPTION: This snippet demonstrates how to create a stage, layer, and rectangle using Konva in vanilla JavaScript. It shows how to select the rectangle by id using the findOne() method and animate it upon button click. The rectangle is also made draggable.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight,
});

const layer = new Konva.Layer();
stage.add(layer);

// create a rectangle with id
const rect = new Konva.Rect({
  x: stage.width() / 2 - 25,
  y: stage.height() / 2 - 25,
  width: 50,
  height: 50,
  fill: 'red',
  id: 'myRect',
  draggable: true
});

layer.add(rect);

// add button
const button = document.createElement('button');
button.textContent = 'Activate Rectangle';
document.body.appendChild(button);

button.addEventListener('click', () => {
  // find rectangle by id and animate it
  const rectangle = layer.findOne('#myRect');
  rectangle.to({
    duration: 1,
    rotation: 360,
    fill: 'blue',
    easing: Konva.Easings.EaseInOut
  });
});

----------------------------------------

TITLE: Implementing Blur Filter Tween in Vanilla JavaScript with Konva
DESCRIPTION: Shows how to create an interactive blur effect on an image using Konva in vanilla JavaScript. The code sets up a stage, loads an image, applies a blur filter, and creates a tween animation that responds to mouse/touch events.

LANGUAGE: javascript
CODE:
const width = window.innerWidth;
const height = window.innerHeight;

const stage = new Konva.Stage({
container: 'container',
width: width,
height: height,
});

const layer = new Konva.Layer();

// create image
const imageObj = new Image();
imageObj.onload = () => {
const lion = new Konva.Image({
x: 50,
y: 50,
image: imageObj,
draggable: true,
});

layer.add(lion);

// add blur filter
lion.cache();
lion.filters([Konva.Filters.Blur]);
lion.blurRadius(10);

// create blur tween
const tween = new Konva.Tween({
node: lion,
duration: 0.5,
blurRadius: 0,
easing: Konva.Easings.EaseInOut,
});

// bind events
lion.on('mouseenter touchstart', () => {
tween.play();
});

lion.on('mouseleave touchend', () => {
tween.reverse();
});

};
imageObj.src = '/images/lion.png';

stage.add(layer);

----------------------------------------

TITLE: Creating a Polygon with Konva in Vanilla JavaScript
DESCRIPTION: This snippet demonstrates how to create a polygon using Konva in vanilla JavaScript. It initializes a stage, adds a layer, and creates a closed line (polygon) with specified points, fill color, stroke, and stroke width.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight
});

const layer = new Konva.Layer();
stage.add(layer);

const polygon = new Konva.Line({
  points: [73, 192, 73, 160, 340, 23, 500, 109, 499, 139, 342, 93],
  fill: '#00D2FF',
  stroke: 'black',
  strokeWidth: 5,
  closed: true
});

layer.add(polygon);

----------------------------------------

TITLE: Implementing HSV Filter with Konva in React
DESCRIPTION: This React component uses Konva to load an image, apply an HSV filter, and create interactive sliders for adjusting the filter parameters. It utilizes the react-konva library and hooks for state management.

LANGUAGE: jsx
CODE:
import { Stage, Layer, Image } from 'react-konva';
import { useState, useEffect, useRef } from 'react';
import useImage from 'use-image';

const App = () => {
  const [hue, setHue] = useState(0);
  const [saturation, setSaturation] = useState(0);
  const [value, setValue] = useState(0);
  const [image] = useImage('https://konvajs.org/assets/lion.png', 'anonymous');
  const imageRef = useRef(null);

  useEffect(() => {
    if (image && imageRef.current) {
      imageRef.current.cache();
    }
  }, [image]);

  return (
    <>
      <Stage width={window.innerWidth} height={window.innerHeight}>
        <Layer>
          <Image
            ref={imageRef}
            x={50}
            y={50}
            image={image}
            draggable
            filters={[Konva.Filters.HSV]}
            hue={hue}
            saturation={saturation}
            value={value}
          />
        </Layer>
      </Stage>
      <div style={{ position: 'absolute', top: '20px', left: '20px' }}>
        <div>
          Hue
          <input
            type="range"
            min="-259"
            max="259"
            value={hue}
            onChange={(e) => setHue(parseInt(e.target.value))}
          />
        </div>
        <div>
          Saturation
          <input
            type="range"
            min="-2"
            max="10"
            step="0.1"
            value={saturation}
            onChange={(e) => setSaturation(parseFloat(e.target.value))}
          />
        </div>
        <div>
          Value
          <input
            type="range"
            min="-2"
            max="2"
            step="0.1"
            value={value}
            onChange={(e) => setValue(parseFloat(e.target.value))}
          />
        </div>
      </div>
    </>
  );
};

export default App;

----------------------------------------

TITLE: Implementing Keyboard Events in Vue with Konva
DESCRIPTION: Creates a movable circle using Vue 3 and Vue-Konva components. Utilizes Vue's composition API and refs to manage state and handle keyboard events for circle movement.

LANGUAGE: html
CODE:
<template>
  <v-stage
    :config="stageSize"
    ref="stageRef"
    @keydown="handleKeyDown"
  >
    <v-layer>
      <v-circle :config="circleConfig" />
    </v-layer>
  </v-stage>
</template>

<script setup>
import { ref, onMounted, computed } from 'vue';

const stageRef = ref(null);
const position = ref({
  x: window.innerWidth / 2,
  y: window.innerHeight / 2,
});

const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight
};

const circleConfig = computed(() => ({
  x: position.value.x,
  y: position.value.y,
  radius: 50,
  fill: 'red',
  stroke: 'black',
  strokeWidth: 4
}));

onMounted(() => {
  const container = stageRef.value.getNode().container();
  container.tabIndex = 1;
  container.focus();
});

const handleKeyDown = (e) => {
  const DELTA = 4;
  
  switch (e.keyCode) {
    case 37:
      position.value.x -= DELTA;
      break;
    case 38:
      position.value.y -= DELTA;
      break;
    case 39:
      position.value.x += DELTA;
      break;
    case 40:
      position.value.y += DELTA;
      break;
    default:
      return;
  }
  e.preventDefault();
};
</script>

----------------------------------------

TITLE: Creating Sprite Animation with Vanilla JavaScript and Konva
DESCRIPTION: Implements a sprite animation using Konva in vanilla JavaScript. Creates a character with idle and punch animations, including a button to trigger the punch animation. Uses sprite sheet coordinates for animation frames and handles animation transitions.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight
});

const layer = new Konva.Layer();
stage.add(layer);

const animations = {
  idle: [
    2, 2, 70, 119,      // frame 1
    71, 2, 74, 119,     // frame 2
    146, 2, 81, 119,    // frame 3
    226, 2, 76, 119,    // frame 4
  ],
  punch: [
    2, 138, 74, 122,    // frame 1
    76, 138, 84, 122,   // frame 2
    346, 138, 120, 122, // frame 3
  ],
};

const imageObj = new Image();
imageObj.onload = function() {
  const sprite = new Konva.Sprite({
    x: 50,
    y: 50,
    image: imageObj,
    animation: 'idle',
    animations: animations,
    frameRate: 7,
    frameIndex: 0
  });

  layer.add(sprite);
  sprite.start();

  const button = document.createElement('button');
  button.textContent = 'Punch';
  button.style.position = 'absolute';
  button.style.top = '0';
  button.style.left = '0';
  document.body.appendChild(button);

  button.addEventListener('click', () => {
    sprite.animation('punch');
    sprite.on('frameIndexChange.button', function() {
      if (this.frameIndex() === 2) {
        setTimeout(() => {
          sprite.animation('idle');
          sprite.off('.button');
        }, 1000 / sprite.frameRate());
      }
    });
  });
};
imageObj.src = 'https://konvajs.org/assets/blob-sprite.png';

----------------------------------------

TITLE: Creating a Konva Sprite
DESCRIPTION: Creates a new sprite animation object that can play animations from a sprite sheet

LANGUAGE: javascript
CODE:
new Konva.Sprite(config)

----------------------------------------

TITLE: Configuring Rotation Snaps
DESCRIPTION: Shows how to configure rotation snap angles for the transformer.

LANGUAGE: javascript
CODE:
// get
var rotationSnaps = transformer.rotationSnaps();

// set
transformer.rotationSnaps([0, 90, 180, 270]);

----------------------------------------

TITLE: Creating Rectangles with React-Konva
DESCRIPTION: Shows how to create rectangles using React-Konva components. Implements the same rectangle configurations as the vanilla version but using React's declarative syntax with Stage, Layer, and Rect components.

LANGUAGE: javascript
CODE:
import { Stage, Layer, Rect } from 'react-konva';

const App = () => {
  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        <Rect
          x={20}
          y={20}
          width={100}
          height={50}
          fill="green"
          stroke="black"
          strokeWidth={4}
        />
        <Rect
          x={150}
          y={40}
          width={100}
          height={50}
          fill="red"
          shadowBlur={10}
          cornerRadius={10}
        />
        <Rect
          x={50}
          y={120}
          width={100}
          height={100}
          fill="blue"
          cornerRadius={[0, 10, 20, 30]}
        />
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Creating Arc Shape with Vanilla JavaScript and Konva
DESCRIPTION: Creates a yellow arc shape with black stroke using vanilla JavaScript and Konva. The arc is positioned at the center of the stage with inner radius of 40, outer radius of 70, and angle of 60 degrees.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight
});

const layer = new Konva.Layer();
stage.add(layer);

const arc = new Konva.Arc({
  x: stage.width() / 2,
  y: stage.height() / 2,
  innerRadius: 40,
  outerRadius: 70,
  angle: 60,
  fill: 'yellow',
  stroke: 'black',
  strokeWidth: 4
});

layer.add(arc);

----------------------------------------

TITLE: Adding Children to a Konva Container
DESCRIPTION: Adds one or more child nodes to a Konva container.

LANGUAGE: javascript
CODE:
layer.add(rect);
layer.add(shape1, shape2, shape3);
// empty arrays are accepted, though each individual child must be defined
layer.add(...shapes);

----------------------------------------

TITLE: Implementing Image Mask Filter with Vue and Konva.js
DESCRIPTION: Shows how to create an image mask filter using Vue 3 and vue-konva. Uses the Composition API with setup script and refs for reactive state management. Implements watch to handle image loading and caching.

LANGUAGE: javascript
CODE:
<script setup>
import { ref, watch, nextTick } from 'vue';
import { useImage } from 'vue-konva';
import Konva from 'konva';

const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight,
};

const threshold = ref(10);
const imageNode = ref(null);
const [image] = useImage('https://konvajs.org/assets/lion.png', 'anonymous');

watch(image, async (newImage) => {
  if (newImage) {
    await nextTick();
    imageNode.value.getNode().cache();
  }
});

const handleSlider = (e) => {
  threshold.value = parseInt(e.target.value);
};
</script>

----------------------------------------

TITLE: Creating Custom Shape with React-Konva
DESCRIPTION: This snippet demonstrates how to use the Shape component from react-konva to create a custom shape. It defines a drawing function that uses the HTML5 Canvas context to draw a custom path, and applies fill and stroke styles.

LANGUAGE: jsx
CODE:
import React from 'react';
import { Stage, Layer, Shape } from 'react-konva';

const App = () => {
  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        <Shape
          width={260}
          height={170}
          sceneFunc={function (context, shape) {
            const width = shape.width();
            const height = shape.height();
            context.beginPath();
            context.moveTo(0, 0);
            context.lineTo(width - 40, height - 90);
            context.quadraticCurveTo(width - 110, height - 70, width, height);
            context.closePath();

            // (!) Konva specific method, it is very important
            context.fillStrokeShape(shape);
          }}
          fill="#00D2FF"
          stroke="black"
          strokeWidth={4}
        />
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Implementing Scale Animation with Vue and Konva
DESCRIPTION: Vue implementation of the scaling animation using vue-konva components. Uses Vue's composition API with refs for shape management and lifecycle hooks for animation control. Includes reactive state for shape configurations.

LANGUAGE: vue
CODE:
<template>
  <v-stage :config="stageSize">
    <v-layer ref="layerRef">
      <v-regular-polygon
        ref="blueHexRef"
        :config="blueHexConfig"
        @dragend="handleDragEnd('blue', $event)"
      />
      <v-regular-polygon
        ref="yellowHexRef"
        :config="yellowHexConfig"
        @dragend="handleDragEnd('yellow', $event)"
      />
      <v-regular-polygon
        ref="redHexRef"
        :config="redHexConfig"
        @dragend="handleDragEnd('red', $event)"
      />
    </v-layer>
  </v-stage>
</template>

----------------------------------------

TITLE: Manipulating zIndex with Vanilla JavaScript in Konva
DESCRIPTION: Creates a Konva stage with multiple shapes and groups, and provides buttons to move a red circle between groups, demonstrating zIndex changes.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const width = window.innerWidth;
const height = window.innerHeight;

const stage = new Konva.Stage({
container: 'container',
width: width,
height: height,
});

const layer = new Konva.Layer();

// first group
const group1 = new Konva.Group();
layer.add(group1);

const blackRect = new Konva.Rect({
x: 10,
y: 10,
width: 100,
height: 100,
fill: 'black',
});
group1.add(blackRect);

const redCircle = new Konva.Circle({
x: 80,
y: 80,
radius: 40,
fill: 'red',
});
group1.add(redCircle);

// second group
const group2 = new Konva.Group();
layer.add(group2);

const greenRect = new Konva.Rect({
x: 50,
y: 50,
width: 100,
height: 100,
fill: 'green',
});
group2.add(greenRect);

stage.add(layer);

// create buttons
const btn1 = document.createElement('button');
btn1.textContent = 'Move red circle to group2';
btn1.addEventListener('click', () => {
redCircle.moveTo(group2);
});

const btn2 = document.createElement('button');
btn2.textContent = 'Move red circle to group1';
btn2.addEventListener('click', () => {
redCircle.moveTo(group1);
});

document.body.appendChild(btn1);
document.body.appendChild(btn2);

----------------------------------------

TITLE: Applying Blur Filter to Image with Konva in React
DESCRIPTION: This snippet shows how to create a Konva stage, add an image, apply a blur filter, and use a slider to adjust the blur radius in a React component. It uses the react-konva library and the useImage hook for loading the image.

LANGUAGE: jsx
CODE:
import { Stage, Layer, Image } from 'react-konva';
import { useState, useEffect, useRef } from 'react';
import useImage from 'use-image';

const App = () => {
  const [blurRadius, setBlurRadius] = useState(10);
  const [image] = useImage('https://konvajs.org/assets/lion.png', 'anonymous');
  const imageRef = useRef(null);

  useEffect(() => {
    if (image && imageRef.current) {
      imageRef.current.cache();
    }
  }, [image]);

  return (
    <>
      <Stage width={window.innerWidth} height={window.innerHeight}>
        <Layer>
          <Image
            ref={imageRef}
            x={50}
            y={50}
            image={image}
            draggable
            filters={[Konva.Filters.Blur]}
            blurRadius={blurRadius}
          />
        </Layer>
      </Stage>
      <input
        type="range"
        min="0"
        max="40"
        value={blurRadius}
        onChange={(e) => setBlurRadius(parseInt(e.target.value))}
        style={{ position: 'absolute', top: '20px', left: '20px' }}
      />
    </>
  );
};

export default App;

----------------------------------------

TITLE: Getting Intersection with Layer
DESCRIPTION: Method to get the visible intersection shape at a given point.

LANGUAGE: javascript
CODE:
getIntersection(pos)

----------------------------------------

TITLE: Loading Cross-Origin Images in React with Konva
DESCRIPTION: Shows how to handle cross-origin images in a React application using react-konva and the useImage hook, which automatically handles crossOrigin settings.

LANGUAGE: javascript
CODE:
import { Stage, Layer, Image } from 'react-konva';
import useImage from 'use-image';

const MyImage = ({ url }) => {
  // useImage hook handles crossOrigin automatically
  const [image] = useImage(url, 'Anonymous');
  
  return (
    <Image
      x={50}
      y={50}
      image={image}
    />
  );
}

const App = () => {
  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        <MyImage url="your-image-url" />
      </Layer>
    </Stage>
  );
};

----------------------------------------

TITLE: Initializing Konva.Context in JavaScript
DESCRIPTION: Creates a new Konva.Context instance, which wraps the native 2D canvas context and provides additional functionality for Konva shapes and custom hit regions.

LANGUAGE: javascript
CODE:
new Konva.Context(config)

----------------------------------------

TITLE: Creating Arrow Shape with Vanilla JavaScript and Konva
DESCRIPTION: Demonstrates how to create a basic arrow shape using Konva in vanilla JavaScript. Creates a stage, adds a layer, and renders an arrow with customizable properties like pointer dimensions, fill, stroke, and position.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight
});

const layer = new Konva.Layer();
stage.add(layer);

const arrow = new Konva.Arrow({
  x: stage.width() / 4,
  y: stage.height() / 4,
  points: [0, 0, 100, 100],
  pointerLength: 20,
  pointerWidth: 20,
  fill: 'black',
  stroke: 'black',
  strokeWidth: 4
});

layer.add(arrow);

----------------------------------------

TITLE: Setting the bezier property of a Konva.Line
DESCRIPTION: Gets or sets the bezier flag of the line. When true, the line is drawn as a bezier curve using the provided points.

LANGUAGE: javascript
CODE:
// get whether the line is a bezier
var isBezier = line.bezier();

// set whether the line is a bezier
line.bezier(true);

----------------------------------------

TITLE: Implementing Clipping Function with React and Konva
DESCRIPTION: This snippet shows how to create a clipping function using React with react-konva. It renders a Stage component with a Layer and a Group that has a clipping function, containing multiple Circle components representing blobs.

LANGUAGE: jsx
CODE:
import { Stage, Layer, Group, Circle } from 'react-konva';

const App = () => {
  const blobs = Array.from({ length: 20 }, (_, i) => ({
    x: Math.random() * window.innerWidth,
    y: Math.random() * window.innerHeight,
    radius: Math.random() * 50,
  }));

  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        <Group
          clipFunc={(ctx) => {
            ctx.beginPath();
            ctx.arc(200, 120, 50, 0, Math.PI * 2, false);
            ctx.arc(280, 120, 50, 0, Math.PI * 2, false);
          }}
        >
          {blobs.map((blob, i) => (
            <Circle
              key={i}
              x={blob.x}
              y={blob.y}
              radius={blob.radius}
              fill="green"
              opacity={0.8}
            />
          ))}
        </Group>
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Applying Multiple Filters to Konva.Image in Vue.js
DESCRIPTION: This Vue.js component demonstrates how to apply multiple filters (blur, brightness, contrast) to a Konva.Image using vue-konva. It uses reactive data and computed properties to manage filter states and values.

LANGUAGE: vue
CODE:
<template>
  <div>
    
    <v-stage :config="stageSize">
      <v-layer>
        <v-image
          v-if="image"
          ref="imageNode"
          :config="{
            x: 50,
            y: 50,
            image: image,
            draggable: true,
            filters: activeFilters,
            blurRadius: filters.blur.value,
            brightness: filters.brightness.value,
            contrast: filters.contrast.value,
          }"
        />
      </v-layer>
    </v-stage>
    <div style="position: absolute; top: 20px; left: 20px">
      <div v-for="(filter, name) in filters" :key="name" style="marginBottom: 10px">
        <input
          type="checkbox"
          :id="name"
          v-model="filter.active"
        />
        <label :for="name"> {{ capitalize(name) }}: </label>
        <input
          type="range"
          :min="filterRanges[name].min"
          :max="filterRanges[name].max"
          :step="filterRanges[name].step"
          v-model="filter.value"
          :disabled="!filter.active"
          style="width: 200px"
        />
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, computed, watch, nextTick } from 'vue';
import { useImage } from 'vue-konva';

const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight,
};

const imageNode = ref(null);
const [image] = useImage('https://konvajs.org/assets/lion.png', 'anonymous');

const filters = ref({
  blur: { active: false, value: 10 },
  brightness: { active: false, value: 0.3 },
  contrast: { active: false, value: 50 },
});

const filterRanges = {
  blur: { min: 0, max: 40, step: 1 },
  brightness: { min: -1, max: 1, step: 0.1 },
  contrast: { min: -100, max: 100, step: 1 },
};

const activeFilters = computed(() => {
  const active = [];
  if (filters.value.blur.active) active.push(Konva.Filters.Blur);
  if (filters.value.brightness.active) active.push(Konva.Filters.Brighten);
  if (filters.value.contrast.active) active.push(Konva.Filters.Contrast);
  return active;
});

const capitalize = (str) => str.charAt(0).toUpperCase() + str.slice(1);

watch(image, async (newImage) => {
  if (newImage) {
    await nextTick();
    imageNode.value.getNode().cache();
  }
});
</script>

----------------------------------------

TITLE: Creating Wedge Shape with Konva in Vanilla JavaScript
DESCRIPTION: This snippet demonstrates how to create a wedge shape using Konva in vanilla JavaScript. It initializes a stage, adds a layer, and creates a wedge with specified properties such as radius, angle, fill, stroke, and rotation.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight
});

const layer = new Konva.Layer();
stage.add(layer);

const wedge = new Konva.Wedge({
  x: stage.width() / 2,
  y: stage.height() / 2,
  radius: 70,
  angle: 60,
  fill: 'red',
  stroke: 'black',
  strokeWidth: 4,
  rotation: -120
});

layer.add(wedge);

----------------------------------------

TITLE: Implementing Shape Caching with Konva.js in Vue
DESCRIPTION: This Vue component demonstrates shape caching in Konva.js. It creates two star shapes with blur filters, caches one, and animates both to show the performance difference. The component uses refs to access and manipulate Konva objects within the lifecycle hooks.

LANGUAGE: vue
CODE:
<template>
  <v-stage :config="stageSize">
    <v-layer ref="layerRef">
      <!-- Non-cached complex shape -->
      <v-star
        ref="nonCachedStarRef"
        :config="starConfig"
      />
      
      <!-- Cached complex shape -->
      <v-star
        ref="cachedStarRef"
        :config="{ ...starConfig, x: 250 }"
      />
      
      <!-- Labels -->
      <v-text :config="nonCachedLabelConfig" />
      <v-text :config="cachedLabelConfig" />
      
      <!-- FPS counter -->
      <v-text
        ref="fpsTextRef"
        :config="fpsConfig"
      />
    </v-layer>
  </v-stage>
</template>

<script setup>
import { ref, onMounted, onUnmounted } from 'vue';
import Konva from 'konva';

const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight
};

const starConfig = {
  x: 100,
  y: 100,
  numPoints: 20,
  innerRadius: 40,
  outerRadius: 70,
  fill: 'yellow',
  stroke: 'black',
  strokeWidth: 4
};

const nonCachedLabelConfig = {
  x: 50,
  y: 200,
  text: 'Non-Cached Shape',
  fontSize: 16
};

const cachedLabelConfig = {
  x: 200,
  y: 200,
  text: 'Cached Shape\n(Better Performance)',
  fontSize: 16
};

const fpsConfig = ref({
  x: 10,
  y: 10,
  text: 'FPS: 0',
  fontSize: 16
});

const layerRef = ref(null);
const nonCachedStarRef = ref(null);
const cachedStarRef = ref(null);
const fpsTextRef = ref(null);
let anim = null;

onMounted(() => {
  // Add blur filter and cache to the cached star
  const cachedStar = cachedStarRef.value.getNode();
  cachedStar.cache();
  cachedStar.filters([Konva.Filters.Blur]);
  cachedStar.blurRadius(5);

  // Add blur filter to non-cached star
  const nonCachedStar = nonCachedStarRef.value.getNode();
  nonCachedStar.filters([Konva.Filters.Blur]);
  nonCachedStar.blurRadius(5);

  anim = new Konva.Animation((frame) => {
    // Rotate stars
    nonCachedStar.rotation(frame.time * 0.1);
    cachedStar.rotation(frame.time * 0.1);
    
    // Update FPS counter
    fpsTextRef.value.getNode().text('FPS: ' + frame.frameRate.toFixed(1));
  }, layerRef.value.getNode());

  anim.start();
});

onUnmounted(() => {
  if (anim) {
    anim.stop();
  }
});
</script>

----------------------------------------

TITLE: Resizing Konva Shapes with Stroke Preservation (React)
DESCRIPTION: This React component implements two methods for resizing Konva shapes without scaling the stroke. It uses hooks to manage state and refs, and demonstrates both the scale resetting and stroke scaling disabling approaches.

LANGUAGE: jsx
CODE:
import { Stage, Layer, Rect, Transformer } from 'react-konva';
import { useRef, useEffect, useState } from 'react';

const App = () => {
  const [rect1Size, setRect1Size] = useState({
    width: 100,
    height: 100,
  });

  const rect1Ref = useRef();
  const rect2Ref = useRef();
  const tr1Ref = useRef();
  const tr2Ref = useRef();

  useEffect(() => {
    tr1Ref.current.nodes([rect1Ref.current]);
    tr2Ref.current.nodes([rect2Ref.current]);
  }, []);

  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        <Rect
          x={50}
          y={50}
          width={rect1Size.width}
          height={rect1Size.height}
          fill="#00ff00"
          stroke="black"
          strokeWidth={5}
          draggable
          ref={rect1Ref}
          onTransformEnd={(e) => {
            const node = rect1Ref.current;
            setRect1Size({
              width: node.width() * node.scaleX(),
              height: node.height() * node.scaleY(),
            });
            node.scaleX(1);
            node.scaleY(1);
          }}
        />
        <Transformer ref={tr1Ref} />

        <Rect
          x={200}
          y={50}
          width={100}
          height={100}
          fill="#ff0000"
          stroke="black"
          strokeWidth={5}
          draggable
          strokeScaleEnabled={false}
          ref={rect2Ref}
        />
        <Transformer ref={tr2Ref} ignoreStroke={true} />
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Implementing Edge-Scroll with Vanilla Konva.js
DESCRIPTION: Creates a Konva stage with draggable circles that trigger automatic scrolling when dragged near the viewport edges. Uses setInterval to continuously check pointer position and adjust stage position accordingly.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight,
});

const layer = new Konva.Layer();
stage.add(layer);

const NUMBER = 100;

function generateNode() {
  return new Konva.Circle({
    x: stage.width() * (Math.random() * 2 - 1),
    y: stage.height() * (Math.random() * 2 - 1),
    radius: 40,
    fill: 'red',
    stroke: 'black',
    draggable: true,
  });
}

for (let i = 0; i < NUMBER; i++) {
  layer.add(generateNode());
}

let scrollInterval = null;

stage.on('dragstart', (e) => {
  const duration = 1000 / 60;
  scrollInterval = setInterval(() => {
    const pos = stage.getPointerPosition();
    const offset = 100;
    
    const isNearLeft = pos.x < offset;
    if (isNearLeft) {
      stage.x(stage.x() + 2);
      e.target.x(e.target.x() - 2);
    }
    
    const isNearRight = pos.x > stage.width() - offset;
    if (isNearRight) {
      stage.x(stage.x() - 2);
      e.target.x(e.target.x() + 2);
    }
    
    const isNearTop = pos.y < offset;
    if (isNearTop) {
      stage.y(stage.y() + 2);
      e.target.y(e.target.y() - 2);
    }
    
    const isNearBottom = pos.y > stage.height() - offset;
    if (isNearBottom) {
      stage.y(stage.y() - 2);
      e.target.y(e.target.y() + 2);
    }
  }, duration);
});

stage.on('dragend', () => {
  clearInterval(scrollInterval);
});

----------------------------------------

TITLE: Applying Contrast Filter to Image in React with Konva.js
DESCRIPTION: This snippet shows how to apply a contrast filter to an image using Konva.js in a React component. It uses the react-konva library and includes a functional component with state management for the contrast value and an interactive slider.

LANGUAGE: jsx
CODE:
import { Stage, Layer, Image } from 'react-konva';
import { useState, useEffect, useRef } from 'react';
import useImage from 'use-image';

const App = () => {
  const [contrast, setContrast] = useState(50);
  const [image] = useImage('https://konvajs.org/assets/lion.png', 'anonymous');
  const imageRef = useRef(null);

  useEffect(() => {
    if (image && imageRef.current) {
      imageRef.current.cache();
    }
  }, [image]);

  return (
    <>
      <Stage width={window.innerWidth} height={window.innerHeight}>
        <Layer>
          <Image
            ref={imageRef}
            x={50}
            y={50}
            image={image}
            draggable
            filters={[Konva.Filters.Contrast]}
            contrast={contrast}
          />
        </Layer>
      </Stage>
      <input
        type="range"
        min="-100"
        max="100"
        value={contrast}
        onChange={(e) => setContrast(parseInt(e.target.value))}
        style={{ position: 'absolute', top: '20px', left: '20px' }}
      />
    </>
  );
};

export default App;

----------------------------------------

TITLE: Animating Circle Position with Vanilla Konva
DESCRIPTION: Creates an animated circle using vanilla Konva that moves in a sinusoidal pattern. The animation uses Konva.Animation to modify the circle's x-position based on time, creating a smooth back-and-forth motion with configurable amplitude and period.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const stage = new Konva.Stage({
container: 'container',
width: window.innerWidth,
height: window.innerHeight,
});

const layer = new Konva.Layer();
stage.add(layer);

const circle = new Konva.Circle({
x: 50,
y: window.innerHeight / 2,
radius: 30,
fill: 'red',
stroke: 'black',
strokeWidth: 4,
});
layer.add(circle);

const amplitude = 100;
const period = 2000; // in milliseconds

const anim = new Konva.Animation(function(frame) {
circle.x(
amplitude * Math.sin((frame.time * 2 * Math.PI) / period) +
window.innerWidth / 2
);
}, layer);

anim.start();

----------------------------------------

TITLE: Getting Point at Length
DESCRIPTION: Get coordinates of a point at a specific length along the path.

LANGUAGE: javascript
CODE:
var point = path.getPointAtLength(10);

----------------------------------------

TITLE: Animating Circle Position with React-Konva
DESCRIPTION: Implements the same circular animation using React-Konva components. Uses useRef and useEffect hooks to manage the animation lifecycle and circle reference. The animation creates the same sinusoidal movement pattern as the vanilla version.

LANGUAGE: javascript
CODE:
import { Stage, Layer, Circle } from 'react-konva';
import { useEffect, useRef } from 'react';

const App = () => {
  const circleRef = useRef(null);

  useEffect(() => {
    const amplitude = 100;
    const period = 2000; // in milliseconds

    const anim = new Konva.Animation((frame) => {
      circleRef.current.x(
        amplitude * Math.sin((frame.time * 2 * Math.PI) / period) +
        window.innerWidth / 2
      );
    }, circleRef.current.getLayer());

    anim.start();

    return () => {
      anim.stop();
    };
  }, []);

  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        <Circle
          ref={circleRef}
          x={50}
          y={window.innerHeight / 2}
          radius={30}
          fill="red"
          stroke="black"
          strokeWidth={4}
        />
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Implementing Horizontal and Vertical Drag Constraints in Vanilla JavaScript
DESCRIPTION: This code creates a Konva stage with two draggable text elements. One is constrained to move horizontally, and the other vertically. It uses the 'dragmove' event to enforce these constraints.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight,
});

const layer = new Konva.Layer();
stage.add(layer);

const horizontalText = new Konva.Text({
  x: 50,
  y: 50,
  text: 'Drag me horizontally',
  fontSize: 16,
  draggable: true,
  fill: 'black',
});

horizontalText.on('dragmove', function () {
  // horizontal only
  this.y(50);
});

const verticalText = new Konva.Text({
  x: 200,
  y: 50,
  text: 'Drag me vertically',
  fontSize: 16,
  draggable: true,
  fill: 'black',
});

verticalText.on('dragmove', function () {
  // vertical only
  this.x(200);
});

layer.add(horizontalText);
layer.add(verticalText);

----------------------------------------

TITLE: Implementing Layer Management in Konva with Vanilla JavaScript
DESCRIPTION: This snippet demonstrates how to create separate layers for static text and animated shapes in Konva using Vanilla JavaScript. It includes the creation of a stage, layers, text, and an animated circle moving in a figure-8 pattern.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight,
});

// Static layer for text
const textLayer = new Konva.Layer();
stage.add(textLayer);

// Animated layer for shapes
const animLayer = new Konva.Layer();
stage.add(animLayer);

// Add static text
const text = new Konva.Text({
  x: 20,
  y: 20,
  text: 'This text is in a static layer.\nThe circle below is in an animated layer.',
  fontSize: 16,
  fill: 'black'
});
textLayer.add(text);

// Add animated circle
const circle = new Konva.Circle({
  x: 100,
  y: 100,
  radius: 30,
  fill: 'red',
});
animLayer.add(circle);

// Create animation
const anim = new Konva.Animation((frame) => {
  // Move circle in a figure-8 pattern
  const scale = 100;
  const centerX = stage.width() / 2;
  const centerY = stage.height() / 2;
  
  circle.x(centerX + Math.sin(frame.time / 1000) * scale);
  circle.y(centerY + Math.sin(frame.time / 2000) * scale);
}, animLayer);

anim.start();

----------------------------------------

TITLE: Setting Stage Pointer Positions
DESCRIPTION: Manually registers pointer positions for mouse/touch events. Useful when events are triggered outside the stage but you still need Konva pointer position functionality.

LANGUAGE: javascript
CODE:
window.addEventListener('mousemove', (e) => {
  stage.setPointersPositions(e);
});

----------------------------------------

TITLE: Setting Wedge Direction
DESCRIPTION: Example showing how to control the direction of the wedge (clockwise vs counter-clockwise)

LANGUAGE: javascript
CODE:
// get clockwise flag
var clockwise = wedge.clockwise();

// draw wedge counter-clockwise
wedge.clockwise(false);

// draw wedge clockwise
wedge.clockwise(true);

----------------------------------------

TITLE: Implementing Konva Performance Optimizations in Vue
DESCRIPTION: This Vue component showcases Konva performance optimizations. It uses separate layers for background and draggable elements, implements shape caching, and optimizes drag operations by moving the dragged shape to a separate layer.

LANGUAGE: vue
CODE:
<template>
  <v-stage :config="stageSize">
    <v-layer :config="{ listening: false }">
      <v-rect :config="rectConfig" />
    </v-layer>
    <v-layer>
      <v-star
        v-if="starLayer === 'main'"
        ref="starRef"
        :config="starConfig"
        @dragstart="handleDragStart"
        @dragend="handleDragEnd"
      />
    </v-layer>
    <v-layer>
      <v-star
        v-if="starLayer === 'drag'"
        ref="starRef"
        :config="starConfig"
        @dragstart="handleDragStart"
        @dragend="handleDragEnd"
      />
    </v-layer>
  </v-stage>
</template>

<script setup>
import { ref, onMounted } from 'vue';

const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight
};

const rectConfig = {
  x: 0,
  y: 0,
  width: window.innerWidth,
  height: window.innerHeight,
  fill: 'lightgray'
};

const starConfig = {
  x: 200,
  y: 200,
  numPoints: 6,
  innerRadius: 40,
  outerRadius: 70,
  fill: 'yellow',
  stroke: 'black',
  strokeWidth: 4,
  draggable: true,
  perfectDrawEnabled: false
};

const starLayer = ref('main');
const starRef = ref(null);

onMounted(() => {
  // Cache the shape for better performance
  if (starRef.value) {
    starRef.value.getNode().cache();
  }
});

const handleDragStart = () => {
  starLayer.value = 'drag';
};

const handleDragEnd = () => {
  starLayer.value = 'main';
};
</script>

----------------------------------------

TITLE: Implementing Canvas Filters with Vue and Konva
DESCRIPTION: This code snippet demonstrates how to apply a noise filter to a rectangle using Vue.js and Konva. It includes component setup, data management, and event handling for dynamic color changes and filter application.

LANGUAGE: vue
CODE:
<template>
  <v-stage ref="stage" :config="stageSize">
    <v-layer ref="layer">
      <v-rect
        ref="rect"
        @mousemove="handleMouseMove"
        :config="{
          filters: filters,
          noise: 1,
          x: 10,
          y: 10,
          width: 50,
          height: 50,
          fill: color,
          shadowBlur: 10
        }"
      />
    </v-layer>
  </v-stage>
</template>

<script>
const width = window.innerWidth;
const height = window.innerHeight;
import Konva from 'konva';

export default {
  data() {
    return {
      stageSize: {
        width: width,
        height: height
      },
      color: 'green',
      filters: [Konva.Filters.Noise]
    };
  },
  methods: {
    handleMouseMove() {
      this.color = Konva.Util.getRandomColor();
      // recache after changing properties
      const rectNode = this.$refs.rect.getNode();
      rectNode.cache();
    }
  },
  mounted() {
    // initial cache
    const rectNode = this.$refs.rect.getNode();
    rectNode.cache();
  }
};
</script>

----------------------------------------

TITLE: Creating Path Shape with Vanilla JavaScript and Konva
DESCRIPTION: Demonstrates how to create a custom path shape using Konva in vanilla JavaScript. Creates a stage, adds a layer, and draws a path with specific coordinates, data path string, fill color, and scale properties.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight
});

const layer = new Konva.Layer();
stage.add(layer);

const path = new Konva.Path({
  x: 50,
  y: 50,
  data: 'M12.582,9.551C3.251,16.237,0.921,29.021,7.08,38.564l-2.36,1.689l4.893,2.262l4.893,2.262l-0.568-5.36l-0.567-5.359l-2.365,1.694c-4.657-7.375-2.83-17.185,4.352-22.33c7.451-5.338,17.817-3.625,23.156,3.824c5.337,7.449,3.625,17.813-3.821,23.152l2.857,3.988c9.617-6.893,11.827-20.277,4.935-29.896C35.591,4.87,22.204,2.658,12.582,9.551z',
  fill: 'green',
  scale: {
    x: 2,
    y: 2
  }
});

layer.add(path);

----------------------------------------

TITLE: Setting Star Inner Radius - JavaScript
DESCRIPTION: Example showing how to get and set the inner radius of a star shape.

LANGUAGE: javascript
CODE:
// get inner radius
var innerRadius = star.innerRadius();

// set inner radius
star.innerRadius(20);

----------------------------------------

TITLE: Implementing Threshold Filter with Vanilla JavaScript and Konva
DESCRIPTION: Creates a draggable image with an adjustable threshold filter using vanilla JavaScript and Konva.js. Includes a slider control for real-time threshold adjustment and proper image caching setup.

LANGUAGE: javascript
CODE:
const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight,
});

const layer = new Konva.Layer();
stage.add(layer);

const imageObj = new Image();
imageObj.onload = () => {
  const image = new Konva.Image({
    x: 50,
    y: 50,
    image: imageObj,
    draggable: true,
  });

  layer.add(image);

  image.cache();
  image.filters([Konva.Filters.Threshold]);
  image.threshold(0.5);

  const container = document.createElement('div');
  container.style.position = 'absolute';
  container.style.top = '20px';
  container.style.left = '20px';
  
  const text = document.createElement('span');
  text.textContent = 'Threshold: ';
  container.appendChild(text);
  
  const slider = document.createElement('input');
  slider.type = 'range';
  slider.min = '0';
  slider.max = '1';
  slider.step = '0.1';
  slider.value = image.threshold();
  slider.style.width = '200px';
  
  slider.addEventListener('input', (e) => {
    const value = parseFloat(e.target.value);
    image.threshold(value);
  });
  
  container.appendChild(slider);
  document.body.appendChild(container);
};
imageObj.src = 'https://konvajs.org/assets/lion.png';
imageObj.crossOrigin = 'anonymous';

----------------------------------------

TITLE: Checking Rectangle Intersection with Konva.Util in JavaScript
DESCRIPTION: Demonstrates the use of haveIntersection(r1, r2) method from Konva.Util to check if two client rectangles intersect. The method takes two objects representing rectangles with x, y, width, and height properties.

LANGUAGE: javascript
CODE:
const overlapping = Konva.Util.haveIntersection(shape1.getClientRect(), shape2.getClientRect());

----------------------------------------

TITLE: Implementing Line Join Styles with Konva in Vanilla JavaScript
DESCRIPTION: This snippet creates a Konva stage with a triangle shape. It demonstrates how to set the initial line join style and change it on mouseenter events. The code cycles through miter, bevel, and round line join styles.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight,
});

const layer = new Konva.Layer();
stage.add(layer);

const triangle = new Konva.RegularPolygon({
  x: stage.width() / 2,
  y: stage.height() / 2,
  sides: 3,
  radius: 70,
  fill: '#00D2FF',
  stroke: 'black',
  strokeWidth: 20,
  lineJoin: 'miter'
});

layer.add(triangle);

triangle.on('mouseenter', function() {
  const lineJoins = ['miter', 'bevel', 'round'];
  const index = lineJoins.indexOf(triangle.lineJoin());
  const nextIndex = (index + 1) % lineJoins.length;
  triangle.lineJoin(lineJoins[nextIndex]);
});

----------------------------------------

TITLE: Attaching Shape to Transformer
DESCRIPTION: Demonstrates how to attach a shape to the transformer. This method is deprecated and will be replaced by nodes() method.

LANGUAGE: javascript
CODE:
transformer.attachTo(shape);

----------------------------------------

TITLE: Configuring Sprite Animations
DESCRIPTION: Defines multiple animation sequences using sprite sheet coordinates

LANGUAGE: javascript
CODE:
// get animations map
var animations = sprite.animations();

// set animations map
sprite.animations({
  standing: [
    // x, y, width, height (6 frames)
    0, 0, 49, 109,
    52, 0, 49, 109,
    105, 0, 49, 109,
    158, 0, 49, 109,
    210, 0, 49, 109,
    262, 0, 49, 109
  ],
  kicking: [
    // x, y, width, height (6 frames)
    0, 109, 45, 98,
    45, 109, 45, 98,
    95, 109, 63, 98,
    156, 109, 70, 98,
    229, 109, 60, 98,
    287, 109, 41, 98
  ]
});

----------------------------------------

TITLE: Implementing Desktop and Mobile Events with Vanilla Konva
DESCRIPTION: Creates a canvas with Konva that responds to both desktop and mobile input events. Demonstrates mousedown/touchstart and mouseup/touchend event handling with a red circle and text feedback.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight,
});

const layer = new Konva.Layer();

const text = new Konva.Text({
  x: 10,
  y: 10,
  fontFamily: 'Calibri',
  fontSize: 24,
  text: '',
  fill: 'black',
});

const circle = new Konva.Circle({
  x: stage.width() / 2,
  y: stage.height() / 2,
  radius: 70,
  fill: 'red',
  stroke: 'black',
  strokeWidth: 4,
});

function writeMessage(message) {
  text.text(message);
}

// desktop and mobile events
circle.on('mousedown touchstart', function () {
  writeMessage('Mousedown or touchstart');
});

circle.on('mouseup touchend', function () {
  writeMessage('Mouseup or touchend');
});

layer.add(circle);
layer.add(text);
stage.add(layer);

----------------------------------------

TITLE: Implementing Shape Caching with Konva.js in Vanilla JavaScript
DESCRIPTION: This snippet demonstrates how to create and animate complex shapes in Konva.js, comparing the performance of cached and non-cached shapes. It includes creating a star shape with a blur filter, caching one instance, and animating both to show the performance difference.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight,
});

const layer = new Konva.Layer();
stage.add(layer);

// Create a complex shape (star with blur filter)
const createComplexShape = (x, isCached) => {
  const star = new Konva.Star({
    x: x,
    y: 100,
    numPoints: 20,
    innerRadius: 40,
    outerRadius: 70,
    fill: 'yellow',
    stroke: 'black',
    strokeWidth: 4,
  });

  // Add blur filter
  star.filters([Konva.Filters.Blur]);
  star.blurRadius(5);

  // Cache the shape if specified
  if (isCached) {
    star.cache();
  }

  return star;
};

// Create non-cached shape
const nonCachedStar = createComplexShape(100, false);

// Create cached shape
const cachedStar = createComplexShape(250, true);

// Add labels
const nonCachedLabel = new Konva.Text({
  x: 50,
  y: 200,
  text: 'Non-Cached Shape',
  fontSize: 16,
});

const cachedLabel = new Konva.Text({
  x: 200,
  y: 200,
  text: 'Cached Shape\n(Better Performance)',
  fontSize: 16,
});

// Add FPS counter
const fpsText = new Konva.Text({
  x: 10,
  y: 10,
  text: 'FPS: 0',
  fontSize: 16,
});

layer.add(nonCachedStar);
layer.add(cachedStar);
layer.add(nonCachedLabel);
layer.add(cachedLabel);
layer.add(fpsText);

// Create animation to demonstrate performance
const anim = new Konva.Animation((frame) => {
  nonCachedStar.rotation(frame.time * 0.1);
  cachedStar.rotation(frame.time * 0.1);
  
  // Update FPS counter
  fpsText.text('FPS: ' + frame.frameRate.toFixed(1));
}, layer);

anim.start();

----------------------------------------

TITLE: Implementing Layer Management in Konva with React
DESCRIPTION: This snippet shows how to create separate layers for static text and animated shapes in Konva using React. It utilizes the react-konva library and React hooks to manage the animation of a circle moving in a figure-8 pattern.

LANGUAGE: jsx
CODE:
import { Stage, Layer, Text, Circle } from 'react-konva';
import { useEffect, useRef } from 'react';

const App = () => {
  const circleRef = useRef(null);

  useEffect(() => {
    const anim = new Konva.Animation((frame) => {
      const scale = 100;
      const centerX = window.innerWidth / 2;
      const centerY = window.innerHeight / 2;
      
      circleRef.current.x(centerX + Math.sin(frame.time / 1000) * scale);
      circleRef.current.y(centerY + Math.sin(frame.time / 2000) * scale);
    }, circleRef.current.getLayer());

    anim.start();
    return () => anim.stop();
  }, []);

  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      {/* Static layer for text */}
      <Layer>
        <Text
          x={20}
          y={20}
          text="This text is in a static layer.\nThe circle below is in an animated layer."
          fontSize={16}
          fill="black"
        />
      </Layer>
      
      {/* Animated layer for shapes */}
      <Layer>
        <Circle
          ref={circleRef}
          x={100}
          y={100}
          radius={30}
          fill="red"
        />
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Implementing Batch Draw with Vue and Konva
DESCRIPTION: Demonstrates batch drawing implementation in a Vue application using vue-konva. Uses Vue's composition API with refs to manage Konva nodes and implement the rotating rectangle functionality.

LANGUAGE: javascript
CODE:
<template>
  <v-stage :config="stageSize" @mousemove="handleMouseMove">
    <v-layer ref="layerRef">
      <v-rect :config="rectConfig" ref="rectRef" />
    </v-layer>
  </v-stage>
</template>

<script setup>
import { ref, onMounted } from 'vue';
import Konva from 'konva';

// For demo purposes, disable auto draw
Konva.autoDrawEnabled = false;

const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight
};

const rectConfig = ref({
  x: window.innerWidth / 2 - 50,
  y: window.innerHeight / 2 - 25,
  width: 100,
  height: 50,
  fill: 'green',
  stroke: 'black',
  strokeWidth: 4
});

const layerRef = ref(null);
const rectRef = ref(null);

const handleMouseMove = () => {
  // rotate rectangle on mouse move
  rectRef.value.getNode().rotate(5);
  // use batchDraw instead of draw for better performance
  layerRef.value.getNode().batchDraw();
};
</script>

----------------------------------------

TITLE: Implementing Centered Scaling with Konva in Vue
DESCRIPTION: This snippet illustrates how to create a stage, layer, text nodes, and transformers using Konva with Vue components. It shows how to enable centered scaling for one transformer while leaving the other with default scaling.

LANGUAGE: vue
CODE:
<template>
  <v-stage :config="stageSize">
    <v-layer>
      <v-text :config="textConfig1" />
      <v-transformer :config="transformerConfig1" />
      <v-text :config="textConfig2" />
      <v-transformer :config="transformerConfig2" />
    </v-layer>
  </v-stage>
</template>

<script setup>
const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight
};

const textConfig1 = {
  x: 50,
  y: 80,
  text: 'Simple text',
  fontSize: 30,
  draggable: true,
  width: 200
};

const textConfig2 = {
  x: 50,
  y: 180,
  text: 'Simple text', 
  fontSize: 30,
  draggable: true,
  width: 200
};

const transformerConfig1 = {
  centeredScaling: true
};

const transformerConfig2 = {};
</script>

----------------------------------------

TITLE: Implementing Custom Drop Events in Konva with Vanilla JavaScript
DESCRIPTION: This snippet demonstrates how to create custom drop events for Konva shapes using vanilla JavaScript. It creates multiple draggable star shapes and implements dragstart, dragmove, dragend, dragenter, dragleave, dragover, and drop events.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight,
});

const layer = new Konva.Layer();
const tempLayer = new Konva.Layer();
stage.add(layer);
stage.add(tempLayer);

const text = new Konva.Text({
  fill: 'black',
});
layer.add(text);

let previousShape;

// create multiple stars
for (let i = 0; i < 10; i++) {
  const star = new Konva.Star({
    x: stage.width() * Math.random(),
    y: stage.height() * Math.random(),
    fill: 'blue',
    numPoints: 10,
    innerRadius: 20,
    outerRadius: 25,
    draggable: true,
    name: 'star ' + i,
    shadowOffsetX: 5,
    shadowOffsetY: 5,
  });

  star.on('dragstart', () => {
    star.moveTo(tempLayer);
    text.text('Moving ' + star.name());
    layer.draw();
  });

  star.on('dragmove', (e) => {
    const pos = stage.getPointerPosition();
    const shape = layer.getIntersection(pos);

    if (previousShape && shape) {
      if (previousShape !== shape) {
        // leave from old target
        previousShape.fire('dragleave', { evt: e.evt }, true);
        // enter new target
        shape.fire('dragenter', { evt: e.evt }, true);
        previousShape = shape;
      } else {
        previousShape.fire('dragover', { evt: e.evt }, true);
      }
    } else if (!previousShape && shape) {
      previousShape = shape;
      shape.fire('dragenter', { evt: e.evt }, true);
    } else if (previousShape && !shape) {
      previousShape.fire('dragleave', { evt: e.evt }, true);
      previousShape = undefined;
    }
    layer.draw();
  });

  star.on('dragend', (e) => {
    const pos = stage.getPointerPosition();
    const shape = layer.getIntersection(pos);
    if (shape) {
      previousShape.fire('drop', { evt: e.evt }, true);
    }
    previousShape = undefined;
    star.moveTo(layer);
    layer.draw();
  });

  star.on('dragenter', () => {
    star.fill('green');
    text.text('dragenter ' + star.name());
    layer.draw();
  });

  star.on('dragleave', () => {
    star.fill('blue');
    text.text('dragleave ' + star.name());
    layer.draw();
  });

  star.on('dragover', () => {
    text.text('dragover ' + star.name());
    layer.draw();
  });

  star.on('drop', () => {
    star.fill('red');
    text.text('drop ' + star.name());
    layer.draw();
  });

  layer.add(star);
}

layer.draw();

----------------------------------------

TITLE: Setting the tension of a Konva.Line
DESCRIPTION: Gets or sets the tension of the line. Higher values result in a more curvy line. A value of 0 results in no interpolation.

LANGUAGE: javascript
CODE:
// get tension
var tension = line.tension();

// set tension
line.tension(3);

----------------------------------------

TITLE: Getting and Setting Radius
DESCRIPTION: Shows how to get and set the radius of a RegularPolygon

LANGUAGE: javascript
CODE:
// get radius
var radius = shape.radius();

// set radius
shape.radius(10);

----------------------------------------

TITLE: Implementing Draggable Image with Vue-Konva
DESCRIPTION: Creates a draggable image using Vue-Konva components. Uses the useImage composable for image loading and implements mouse event handlers through Vue template syntax.

LANGUAGE: vue
CODE:
<template>
  <v-stage :config="stageSize">
    <v-layer>
      <v-image
        v-if="yodaImage"
        :config="imageConfig"
        @mouseenter="handleMouseEnter"
        @mouseleave="handleMouseLeave"
      />
    </v-layer>
  </v-stage>
</template>

<script setup>
import { ref } from 'vue';
import { useImage } from 'vue-konva';

const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight
};

const [yodaImage] = useImage('https://konvajs.org/assets/yoda.jpg');

const imageConfig = ref({
  x: 50,
  y: 50,
  image: yodaImage,
  width: 106,
  height: 118,
  draggable: true
});

const handleMouseEnter = () => {
  document.body.style.cursor = 'pointer';
};

const handleMouseLeave = () => {
  document.body.style.cursor = 'default';
};
</script>

----------------------------------------

TITLE: Getting Layer Hit Canvas
DESCRIPTION: Method to get the layer's hit canvas for detecting mouse interactions.

LANGUAGE: javascript
CODE:
getHitCanvas()

----------------------------------------

TITLE: Implementing RGB Filter with Vanilla JavaScript and Konva.js
DESCRIPTION: Creates an interactive canvas with RGB filter controls using vanilla JavaScript and Konva.js. The code sets up a draggable image with three sliders to control red, green, and blue color components. Requires Konva.js library and uses HTML5 Canvas.

LANGUAGE: javascript
CODE:
const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight,
});

const layer = new Konva.Layer();
stage.add(layer);

const imageObj = new Image();
imageObj.onload = () => {
  const image = new Konva.Image({
    x: 50,
    y: 50,
    image: imageObj,
    draggable: true,
  });

  layer.add(image);

  image.cache();
  image.filters([Konva.Filters.RGB]);
  image.red(100);
  image.green(100);
  image.blue(100);

  // create sliders
  const createSlider = (label, property) => {
    const container = document.createElement('div');
    container.style.position = 'absolute';
    container.style.left = '20px';
    
    const text = document.createElement('span');
    text.textContent = `${label}: `;
    container.appendChild(text);
    
    const slider = document.createElement('input');
    slider.type = 'range';
    slider.min = '0';
    slider.max = '255';
    slider.step = '1';
    slider.value = image[property]();
    slider.style.width = '200px';
    
    slider.addEventListener('input', (e) => {
      const value = parseInt(e.target.value);
      image[property](value);
    });
    
    container.appendChild(slider);
    return container;
  };

  const redSlider = createSlider('Red', 'red');
  redSlider.style.top = '20px';
  document.body.appendChild(redSlider);

  const greenSlider = createSlider('Green', 'green');
  greenSlider.style.top = '45px';
  document.body.appendChild(greenSlider);

  const blueSlider = createSlider('Blue', 'blue');
  blueSlider.style.top = '70px';
  document.body.appendChild(blueSlider);
};
imageObj.src = 'https://konvajs.org/assets/lion.png';
imageObj.crossOrigin = 'anonymous';

----------------------------------------

TITLE: Setting Enabled Anchors
DESCRIPTION: Example of getting and setting enabled transform handles for the transformer.

LANGUAGE: javascript
CODE:
// get list of handlers
var enabledAnchors = transformer.enabledAnchors();

// set handlers
transformer.enabledAnchors(['top-left', 'top-center', 'top-right', 'middle-right', 'middle-left', 'bottom-left', 'bottom-center', 'bottom-right']);

----------------------------------------

TITLE: Getting Layer Width
DESCRIPTION: Method to get the width of the layer. Returns the width of the stage.

LANGUAGE: javascript
CODE:
width()

----------------------------------------

TITLE: Retrieving Pixel Ratio in Konva Canvas
DESCRIPTION: Example of how to get the pixel ratio from a Konva layer's canvas. This is useful for handling device-specific pixel densities.

LANGUAGE: javascript
CODE:
var pixelRatio = layer.getCanvas.getPixelRatio();

----------------------------------------

TITLE: Implementing Emboss Filter with React and Konva.js
DESCRIPTION: React implementation of an emboss filter effect using react-konva. Uses React hooks for state management and includes slider controls for adjusting filter parameters.

LANGUAGE: javascript
CODE:
const App = () => {
  const [strength, setStrength] = useState(0.5);
  const [whiteLevel, setWhiteLevel] = useState(0.5);
  const [blend, setBlend] = useState(0.5);
  const [image] = useImage('https://konvajs.org/assets/lion.png', 'anonymous');
  const imageRef = useRef(null);

  useEffect(() => {
    if (image) {
      imageRef.current.cache();
    }
  }, [image]);

  return (
    <>
      <Stage width={window.innerWidth} height={window.innerHeight}>
        <Layer>
          <Image
            ref={imageRef}
            x={50}
            y={50}
            image={image}
            draggable
            filters={[Konva.Filters.Emboss]}
            embossStrength={strength}
            embossWhiteLevel={whiteLevel}
            embossDirection="top-left"
            embossBlend={blend}
          />
        </Layer>
      </Stage>
      <div style={{ position: 'absolute', top: '20px', left: '20px' }}>
        <div>
          <label>Strength: </label>
          <input
            type="range"
            min="0"
            max="1"
            step="0.1"
            value={strength}
            onChange={(e) => setStrength(parseFloat(e.target.value))}
          />
        </div>
        <div style={{ marginTop: '10px' }}>
          <label>White Level: </label>
          <input
            type="range"
            min="0"
            max="1"
            step="0.1"
            value={whiteLevel}
            onChange={(e) => setWhiteLevel(parseFloat(e.target.value))}
          />
        </div>
        <div style={{ marginTop: '10px' }}>
          <label>Blend: </label>
          <input
            type="range"
            min="0"
            max="1"
            step="0.1"
            value={blend}
            onChange={(e) => setBlend(parseFloat(e.target.value))}
          />
        </div>
      </div>
    </>
  );
};

----------------------------------------

TITLE: Implementing Drag and Drop Stress Test with React and Konva
DESCRIPTION: This snippet creates a React component using react-konva to render 10,000 draggable circles. It manages the circles' state and implements drag and drop functionality using refs for layer manipulation.

LANGUAGE: javascript
CODE:
import { useState, useEffect, useRef } from 'react';
import { Stage, Layer, Circle } from 'react-konva';

const COLORS = ['red', 'orange', 'yellow', 'green', 'blue', 'cyan', 'purple'];
const SHAPE_COUNT = 10000;

const App = () => {
  // State to hold all the circles data
  const [circles, setCircles] = useState([]);
  
  // Refs to layers
  const mainLayerRef = useRef(null);
  const dragLayerRef = useRef(null);
  
  // Initialize circles data
  useEffect(() => {
    const circlesData = [];
    
    // Create 10,000 circles
    for (let i = 0; i < SHAPE_COUNT; i++) {
      circlesData.push({
        id: i,
        x: Math.random() * window.innerWidth,
        y: Math.random() * window.innerHeight,
        radius: 6,
        fill: COLORS[i % COLORS.length]
      });
    }
    
    setCircles(circlesData);
  }, []);
  
  // This is not the typical "React way" of managing components.
  // In a more React-friendly approach, we would update state and let React handle the DOM.
  // However, for this performance demo, we're directly manipulating the nodes
  // to match the vanilla JS implementation.
  const handleDragStart = (e) => {
    const target = e.target;
    
    // Move the circle to the drag layer
    target.moveTo(dragLayerRef.current);
  };
  
  const handleDragEnd = (e) => {
    const target = e.target;
    
    // Move the circle back to the main layer
    target.moveTo(mainLayerRef.current);
  };
  
  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      {/* Main layer for all circles */}
      <Layer ref={mainLayerRef}>
        {circles.map(circle => (
          <Circle
            key={circle.id}
            id={circle.id}
            x={circle.x}
            y={circle.y}
            radius={circle.radius}
            fill={circle.fill}
            draggable
            onDragStart={handleDragStart}
            onDragEnd={handleDragEnd}
          />
        ))}
      </Layer>
      
      {/* Empty drag layer that will receive circles during drag */}
      <Layer ref={dragLayerRef} />
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Implementing Star Spinner with Vanilla JavaScript and Konva
DESCRIPTION: Creates an interactive spinning star using vanilla JavaScript and Konva. The star can be spun with mouse/touch input and gradually slows down with angular friction. Includes shadow effects and smooth rotation animation.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

// disable degree mode to use radians
Konva.angleDeg = false;

const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight,
});

// ... rest of vanilla implementation ...

----------------------------------------

TITLE: Drawing Hit Area
DESCRIPTION: Example showing how to draw a hit detection area using a cached canvas

LANGUAGE: javascript
CODE:
shape.cache();
shape.drawHitFromCache();

----------------------------------------

TITLE: Loading an Image from URL
DESCRIPTION: Creates a Konva.Image instance by loading an image from a URL

LANGUAGE: javascript
CODE:
Konva.Image.fromURL(imageURL, function(image){
   // image is Konva.Image instance
   layer.add(image);
 });

----------------------------------------

TITLE: Canceling Event Propagation with Konva in Vanilla JavaScript
DESCRIPTION: This snippet creates a Konva stage with a circle shape and demonstrates how to cancel event bubbling when the circle is clicked. It uses the cancelBubble property to prevent the event from propagating to the layer.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight,
});

const layer = new Konva.Layer();
stage.add(layer);

const circle = new Konva.Circle({
  x: stage.width() / 2,
  y: stage.height() / 2,
  radius: 70,
  fill: 'red',
  stroke: 'black',
  strokeWidth: 4,
});

circle.on('click', function (evt) {
  alert('You clicked on the circle');
  // stop event bubble
  evt.cancelBubble = true;
});

layer.on('click', function () {
  alert('You clicked on the layer');
});

layer.add(circle);

----------------------------------------

TITLE: Setting Wedge Radius
DESCRIPTION: Example showing how to get and set the radius of a wedge

LANGUAGE: javascript
CODE:
// get radius
var radius = wedge.radius();

// set radius
wedge.radius(10);

----------------------------------------

TITLE: Implementing Image Enhancement with Vanilla JavaScript and Konva.js
DESCRIPTION: Creates an interactive canvas with a draggable image that can be enhanced using a slider control. The implementation uses Konva.js to apply the enhance filter and includes image caching for performance.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight,
});

const layer = new Konva.Layer();
stage.add(layer);

const imageObj = new Image();
imageObj.onload = () => {
  const image = new Konva.Image({
    x: 50,
    y: 50,
    image: imageObj,
    draggable: true,
  });

  layer.add(image);

  image.cache();
  image.filters([Konva.Filters.Enhance]);
  image.enhance(0.4);

  const slider = document.createElement('input');
  slider.type = 'range';
  slider.min = '-1';
  slider.max = '1';
  slider.step = '0.1';
  slider.value = image.enhance();

  slider.style.position = 'absolute';
  slider.style.top = '20px';
  slider.style.left = '20px';

  slider.addEventListener('input', (e) => {
    const value = parseFloat(e.target.value);
    image.enhance(value);
  });

  document.body.appendChild(slider);
};
imageObj.src = 'https://konvajs.org/assets/lion.png';
imageObj.crossOrigin = 'anonymous';

----------------------------------------

TITLE: Setting Image Source
DESCRIPTION: Gets or sets the image source which can be an image, canvas or video element

LANGUAGE: javascript
CODE:
// get value
var image = shape.image();

// set value
shape.image(img);

----------------------------------------

TITLE: Loading Konva Stage from JSON in Vanilla JavaScript
DESCRIPTION: Demonstrates loading a Konva stage from JSON string and adding click event handler to a hexagon shape. Uses Konva.Node.create() for initialization and findOne() for element selection.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

// JSON string from a previous save
const json = '{"attrs":{"width":578,"height":200},"className":"Stage","children":[{"attrs":{},"className":"Layer","children":[{"attrs":{"x":100,"y":100,"sides":6,"radius":70,"fill":"red","stroke":"black","strokeWidth":4},"className":"RegularPolygon"}]}]}';

// create node using json string
const stage = Konva.Node.create(json, 'container');

// get reference to the hexagon
const hexagon = stage.findOne('RegularPolygon');

// bind events
hexagon.on('click', () => {
  hexagon.fill(Konva.Util.getRandomColor());
});

----------------------------------------

TITLE: Implementing Remove Alpha Filter in Vanilla JavaScript
DESCRIPTION: Creates a custom filter that removes transparency from images by setting all alpha values to 255. Demonstrates how to apply the filter to a Konva image node with full stage setup.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

// create our custom filter
Konva.Filters.RemoveAlpha = function (imageData) {
  const data = imageData.data;
  for (let i = 0; i < data.length; i += 4) {
    data[i + 3] = 255; // set alpha to 1
  }
};

const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight,
});

const layer = new Konva.Layer();
stage.add(layer);

const imageObj = new Image();
imageObj.onload = () => {
  const image = new Konva.Image({
    x: 50,
    y: 50,
    image: imageObj,
    draggable: true,
  });

  layer.add(image);

  image.cache();
  image.filters([Konva.Filters.RemoveAlpha]);
};
imageObj.src = 'https://konvajs.org/assets/lion.png';
imageObj.crossOrigin = 'anonymous';

----------------------------------------

TITLE: Interactive Star Caching Demo with Vue-Konva
DESCRIPTION: Complete Vue component demonstrating canvas caching with multiple star shapes. Includes stage configuration, shape generation, and toggle functionality for caching demonstration.

LANGUAGE: vue
CODE:
<template>
  <div>
    <v-stage ref="stage" :config="stageConfig">
      <v-layer ref="layer">
        <v-group ref="group">
          <v-star
            v-for="item in list"
            :key="item.id"
            :config="{
              x: item.x,
              y: item.y,
              rotation: item.rotation,
              id: item.id,
              numPoints: 5,
              innerRadius: 30,
              outerRadius: 50,
              fill: '#89b717',
              opacity: 0.8,
              shadowColor: 'black',
              shadowBlur: 10,
              shadowOpacity: 0.6,
              scaleX: item.scale,
              scaleY: item.scale,
            }"
          />
        </v-group>
      </v-layer>
    </v-stage>
    <div class="cache">
      <input type="checkbox" @change="handleCacheChange"> cache shapes
    </div>
  </div>
</template>

<script>
const width = window.innerWidth;
const height = window.innerHeight;

export default {
  data() {
    return {
      list: [],
      dragItemId: null,
      stageConfig: {
        width: width,
        height: height,
        draggable: true
      }
    };
  },
  methods: {
    handleCacheChange(e) {
      const shouldCache = e.target.checked;
      if (shouldCache) {
        this.$refs.group.getNode().cache();
      } else {
        this.$refs.group.getNode().clearCache();
      }
    }
  },
  mounted() {
    // Generate 300 random stars
    for (let n = 0; n < 1000; n++) {
      this.list.push({
        id: Math.round(Math.random() * 10000).toString(),
        x: Math.random() * width,
        y: Math.random() * height,
        rotation: Math.random() * 180,
        scale: Math.random()
      });
    }
  }
};
</script>

<style>
.cache {
  position: absolute;
  top: 0;
  left: 0;
}
</style>

----------------------------------------

TITLE: Rendering SVG Image with Konva.Image in JavaScript
DESCRIPTION: This snippet demonstrates how to load and display an SVG image using Konva.Image.fromURL method. It's a simple approach but may have cross-browser compatibility issues.

LANGUAGE: javascript
CODE:
Konva.Image.fromURL('/image.svg', (image) => {
  layer.add(image);
});

----------------------------------------

TITLE: Implementing Threshold Filter with Vue and Konva
DESCRIPTION: Shows how to implement a threshold filter using Vue 3 with vue-konva integration. Uses composition API with refs and watchers for reactive image handling and threshold control.

LANGUAGE: vue
CODE:
<template>
  <div>
    <v-stage :config="stageSize">
      <v-layer>
        <v-image
          ref="imageNode"
          :config="{
            x: 50,
            y: 50,
            image: image,
            draggable: true,
            filters: [Konva.Filters.Threshold],
            threshold: threshold,
          }"
        />
      </v-layer>
    </v-stage>
    <input
      type="range"
      min="0"
      max="1"
      step="0.1"
      :value="threshold"
      @input="handleSlider"
      style="position: absolute; top: 20px; left: 20px"
    />
  </div>
</template>

<script setup>
import { ref, watch, nextTick } from 'vue';
import { useImage } from 'vue-konva';
import Konva from 'konva';

const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight,
};

const threshold = ref(0.5);
const imageNode = ref(null);
const [image] = useImage('https://konvajs.org/assets/lion.png', 'anonymous');

watch(image, async (newImage) => {
  if (newImage) {
    await nextTick();
    imageNode.value.getNode().cache();
  }
});

const handleSlider = (e) => {
  threshold.value = parseFloat(e.target.value);
};
</script>

----------------------------------------

TITLE: Creating External Svelte Store
DESCRIPTION: Demonstrates how to create a simple external store in Svelte to maintain component state during Hot Module Replacement (HMR). This approach helps preserve local state that would otherwise be lost during development hot-reloading.

LANGUAGE: javascript
CODE:
// store.js
// An extremely simple external store
import { writable } from 'svelte/store'
export default writable(0)

----------------------------------------

TITLE: Getting client rectangle
DESCRIPTION: Returns the client rectangle (x, y, width, height) of the node, including all styling.

LANGUAGE: javascript
CODE:
var rect = new Konva.Rect({
     width : 100,
     height : 100,
     x : 50,
     y : 50,
     strokeWidth : 4,
     stroke : 'black',
     offsetX : 50,
     scaleY : 2
});

rect.getClientRect({ skipTransform: true});

rect.getClientRect();

----------------------------------------

TITLE: Configuring Arrow Pointer at Ending
DESCRIPTION: Method to get or set whether the arrow should have a pointer at the ending. Takes a boolean parameter to set the value, or returns the current setting when called without arguments.

LANGUAGE: javascript
CODE:
// get value
var pointerAtEnding = line.pointerAtEnding();

// set value
line.pointerAtEnding(false);

----------------------------------------

TITLE: Creating External Store in Svelte
DESCRIPTION: Demonstrates how to create a simple external store in Svelte to preserve component state during Hot Module Replacement (HMR). This approach helps maintain state that needs to persist through hot reloads.

LANGUAGE: javascript
CODE:
// store.js
// An extremely simple external store
import { writable } from 'svelte/store'
export default writable(0)

----------------------------------------

TITLE: Initializing a Konva.Container in JavaScript
DESCRIPTION: Creates a new Konva.Container instance with the provided configuration options.

LANGUAGE: javascript
CODE:
new Konva.Container(config)

----------------------------------------

TITLE: Generating Random Color with Konva.Util in JavaScript
DESCRIPTION: Demonstrates how to use the getRandomColor() method from Konva.Util to set a random fill color for a shape.

LANGUAGE: javascript
CODE:
shape.fill(Konva.Util.getRandomColor());

----------------------------------------

TITLE: Serializing Konva Stage in React
DESCRIPTION: This snippet demonstrates how to create a Konva stage with a circle shape and serialize it using the toJSON() method in a React component. It uses the useRef hook to access the stage and includes a button to trigger the serialization.

LANGUAGE: jsx
CODE:
import { Stage, Layer, Circle } from 'react-konva';
import { useRef } from 'react';

const App = () => {
  const stageRef = useRef(null);

  const handleSerialize = () => {
    const json = stageRef.current.toJSON();
    console.log(json);
    alert('Stage serialized! Check the console for the JSON string.');
  };

  return (
    <div>
      <button onClick={handleSerialize} style={{ marginBottom: '10px' }}>
        Serialize Stage
      </button>
      <Stage width={400} height={400} ref={stageRef}>
        <Layer>
          <Circle
            x={100}
            y={100}
            radius={50}
            fill="red"
            stroke="black"
            strokeWidth={3}
          />
        </Layer>
      </Stage>
    </div>
  );
};

export default App;

----------------------------------------

TITLE: Creating External Store for HMR State Preservation in Svelte
DESCRIPTION: This code snippet demonstrates how to create a simple external store using Svelte's writable store. This approach helps retain important component state during Hot Module Replacement (HMR), addressing the limitations of HMR state preservation in Svelte components.

LANGUAGE: javascript
CODE:
// store.js
// An extremely simple external store
import { writable } from 'svelte/store'
export default writable(0)

----------------------------------------

TITLE: Applying Grayscale Filter to Image with React-Konva
DESCRIPTION: This React component uses react-konva to create a stage, layer, and image. It applies a grayscale filter to the image using Konva.Filters.Grayscale. The useImage hook is used for image loading.

LANGUAGE: jsx
CODE:
import { Stage, Layer, Image } from 'react-konva';
import { useState, useEffect, useRef } from 'react';
import useImage from 'use-image';

const App = () => {
  const [image] = useImage('https://konvajs.org/assets/lion.png', 'anonymous');
  const imageRef = useRef(null);

  useEffect(() => {
    if (image) {
      imageRef.current.cache();
    }
  }, [image]);

  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        {image && (
          <Image
            ref={imageRef}
            x={50}
            y={50}
            image={image}
            draggable
            filters={[Konva.Filters.Grayscale]}
          />
        )}
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Implementing Emboss Filter with Vue and Konva.js
DESCRIPTION: Vue 3 implementation of an emboss filter effect using vue-konva. Uses Vue composition API and reactive references for state management, with slider controls for adjusting filter parameters.

LANGUAGE: javascript
CODE:
<template>
  <div>
    <v-stage :config="stageSize">
      <v-layer>
        <v-image
          ref="imageNode"
          :config="{
            x: 50,
            y: 50,
            image: image,
            draggable: true,
            filters: [Konva.Filters.Emboss],
            embossStrength: embossValues.strength,
            embossWhiteLevel: embossValues.whiteLevel,
            embossDirection: 'top-left',
            embossBlend: embossValues.blend,
          }"
        />
      </v-layer>
    </v-stage>
    <div :style="{ position: 'absolute', top: '20px', left: '20px' }">
      <div v-for="control in controls" :key="control.label" :style="{ margin: '10px' }">
        <label>{{ control.label }}: </label>
        <input
          type="range"
          min="0"
          max="1"
          step="0.1"
          :value="control.value"
          @input="(e) => updateValue(control.prop, parseFloat(e.target.value))"
          :style="{ width: '200px' }"
        />
      </div>
    </div>
  </div>
</template>

----------------------------------------

TITLE: Creating Ellipse with Vanilla Konva.js
DESCRIPTION: Demonstrates how to create an ellipse shape using vanilla Konva.js. The code initializes a stage, adds a layer, and creates a centered yellow ellipse with black stroke.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight
});

const layer = new Konva.Layer();
stage.add(layer);

const ellipse = new Konva.Ellipse({
  x: stage.width() / 2,
  y: stage.height() / 2,
  radiusX: 100,
  radiusY: 50,
  fill: 'yellow',
  stroke: 'black',
  strokeWidth: 4
});

layer.add(ellipse);

----------------------------------------

TITLE: Applying Noise Filter with Vanilla JavaScript and Konva.js
DESCRIPTION: Implementation of image noise filtering using vanilla JavaScript and Konva.js. Creates a stage, loads an image, applies a noise filter, and provides an interactive slider for noise level control. Requires Konva.js library and uses HTML5 Canvas.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight,
});

const layer = new Konva.Layer();
stage.add(layer);

const imageObj = new Image();
imageObj.onload = () => {
  const image = new Konva.Image({
    x: 50,
    y: 50,
    image: imageObj,
    draggable: true,
  });

  layer.add(image);

  image.cache();
  image.filters([Konva.Filters.Noise]);
  image.noise(0.3);

  const container = document.createElement('div');
  container.style.position = 'absolute';
  container.style.top = '20px';
  container.style.left = '20px';
  
  const text = document.createElement('span');
  text.textContent = 'Noise: ';
  container.appendChild(text);
  
  const slider = document.createElement('input');
  slider.type = 'range';
  slider.min = '0';
  slider.max = '1';
  slider.step = '0.1';
  slider.value = image.noise();
  slider.style.width = '200px';
  
  slider.addEventListener('input', (e) => {
    const value = parseFloat(e.target.value);
    image.noise(value);
  });
  
  container.appendChild(slider);
  document.body.appendChild(container);
};
imageObj.src = 'https://konvajs.org/assets/lion.png';
imageObj.crossOrigin = 'anonymous';

----------------------------------------

TITLE: Creating External Store in Svelte
DESCRIPTION: Demonstrates how to create a simple external store in Svelte using the writable store. This approach helps retain component state during Hot Module Replacement (HMR) by storing state externally.

LANGUAGE: javascript
CODE:
// store.js
// An extremely simple external store
import { writable } from 'svelte/store'
export default writable(0)

----------------------------------------

TITLE: Implementing Line Dragging with React and Konva
DESCRIPTION: Creates a draggable red line using React-Konva components. Uses React hooks for position state management and includes event handlers for drag operations and cursor styling.

LANGUAGE: jsx
CODE:
import { Stage, Layer, Line } from 'react-konva';
import { useState } from 'react';

const App = () => {
  const [position, setPosition] = useState({ x: 50, y: 50 });

  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        <Line
          x={position.x}
          y={position.y}
          points={[0, 0, 150, 0]}
          stroke="red"
          strokeWidth={15}
          lineCap="round"
          lineJoin="round"
          draggable
          onDragEnd={(e) => {
            setPosition({
              x: e.target.x(),
              y: e.target.y(),
            });
          }}
          onMouseEnter={(e) => {
            document.body.style.cursor = 'pointer';
          }}
          onMouseLeave={(e) => {
            document.body.style.cursor = 'default';
          }}
        />
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Creating a Konva.TextPath Instance in JavaScript
DESCRIPTION: Constructor for creating a new TextPath instance in Konva. It allows you to define various properties for the text path, including font settings, text content, and SVG path data.

LANGUAGE: javascript
CODE:
new Konva.TextPath(config)

----------------------------------------

TITLE: Accessing Konva Nodes through Event Objects in react-konva
DESCRIPTION: This snippet shows how to access a Konva node instance using the event object in an event callback. It creates a circle shape and logs the clicked Konva.Circle instance to the console when clicked.

LANGUAGE: jsx
CODE:
import { Stage, Layer, Circle } from 'react-konva';

const App = () => {
  const handleClick = (e) => {
    // logs clicked Konva.Circle instance
    console.log(e.target);
  };
  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        <Circle
          x={window.innerWidth / 2}
          y={window.innerHeight / 2}
          radius={50}
          fill="green"
          onClick={handleClick}
        />
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Creating External Store in Svelte
DESCRIPTION: Demonstrates how to create a simple external store in Svelte to preserve component state during Hot Module Replacement (HMR). This approach provides a solution for retaining important state data that would otherwise be lost during HMR updates.

LANGUAGE: javascript
CODE:
// store.js
// An extremely simple external store
import { writable } from 'svelte/store'
export default writable(0)

----------------------------------------

TITLE: Creating a Circle Shape
DESCRIPTION: Demonstrates how to create a new circle shape using the Konva.Circle constructor with configuration options

LANGUAGE: javascript
CODE:
new Konva.Circle(config)

----------------------------------------

TITLE: Initializing Konva FastLayer
DESCRIPTION: Creates a new FastLayer instance with optional configuration parameters. This class is deprecated in favor of using Layer with listening disabled.

LANGUAGE: javascript
CODE:
new Konva.FastLayer(config)

----------------------------------------

TITLE: Implementing Centered Scaling with Konva in Vanilla JavaScript
DESCRIPTION: This snippet demonstrates how to create a stage, layer, text nodes, and transformers using Konva in vanilla JavaScript. It shows how to enable centered scaling for one transformer while leaving the other with default scaling.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const width = window.innerWidth;
const height = window.innerHeight;

const stage = new Konva.Stage({
container: 'container',
width: width,
height: height,
});

const layer = new Konva.Layer();
stage.add(layer);

const text = new Konva.Text({
x: 50,
y: 80,
text: 'Simple text',
fontSize: 30,
draggable: true,
width: 200,
});
layer.add(text);

const text2 = new Konva.Text({
x: 50,
y: 180,
text: 'Simple text',
fontSize: 30,
draggable: true,
width: 200,
});
layer.add(text2);

const tr = new Konva.Transformer({
nodes: [text],
centeredScaling: true,
});
layer.add(tr);

const tr2 = new Konva.Transformer({
nodes: [text2],
});
layer.add(tr2);

----------------------------------------

TITLE: Implementing Manual Free Drawing with Native Canvas in Vue
DESCRIPTION: This snippet shows how to create a free drawing tool using native canvas API and Konva in a Vue component. It uses Vue's composition API to manage state and refs for canvas operations.

LANGUAGE: vue
CODE:
<template>
  <div>
    <select v-model="tool">
      <option value="brush">Brush</option>
      <option value="eraser">Eraser</option>
    </select>
    <v-stage
      :config="stageConfig"
      @mousedown="handleMouseDown"
      @mousemove="handleMouseMove"
      @mouseup="handleMouseUp"
      @touchstart="handleMouseDown"
      @touchmove="handleMouseMove"
      @touchend="handleMouseUp"
    >
      <v-layer ref="layerRef">
        <v-image
          ref="imageRef"
          :config="imageConfig"
        />
      </v-layer>
    </v-stage>
  </div>
</template>

<script setup>
import { ref, onMounted } from 'vue';

const tool = ref('brush');
const isDrawing = ref(false);
const lastPos = ref(null);
const imageRef = ref(null);
const layerRef = ref(null);

const stageConfig = {
  width: window.innerWidth,
  height: window.innerHeight - 25
};

// create canvas element
const canvas = document.createElement('canvas');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight - 25;

// get context
const context = canvas.getContext('2d');
context.strokeStyle = '#df4b26';
context.lineJoin = 'round';
context.lineWidth = 5;

const imageConfig = {
  image: canvas,
  x: 0,
  y: 0
};

const handleMouseDown = (e) => {
  isDrawing.value = true;
  lastPos.value = e.target.getStage().getPointerPosition();
};

const handleMouseUp = () => {
  isDrawing.value = false;
};

const handleMouseMove = (e) => {
  if (!isDrawing.value) {
    return;
  }

  const ctx = context;
  const image = imageRef.value.getNode();
  const stage = e.target.getStage();

  ctx.globalCompositeOperation = tool.value === 'eraser' ? 'destination-out' : 'source-over';
  ctx.beginPath();

  const localPos = {
    x: lastPos.value.x - image.x(),
    y: lastPos.value.y - image.y(),
  };
  ctx.moveTo(localPos.x, localPos.y);

  const pos = stage.getPointerPosition();
  const newLocalPos = {
    x: pos.x - image.x(),
    y: pos.y - image.y(),
  };
  ctx.lineTo(newLocalPos.x, newLocalPos.y);
  ctx.closePath();
  ctx.stroke();

  lastPos.value = pos;
  layerRef.value.getNode().batchDraw();
};
</script>

----------------------------------------

TITLE: Implementing Shape Rotation Snaps with Konva in Vanilla JavaScript
DESCRIPTION: This snippet creates a stage, layer, and a draggable rectangle with a transformer that implements rotation snaps. It uses the Konva library to set up the canvas and shape, with rotation snaps at 0, 90, 180, and 270 degrees.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const width = window.innerWidth;
const height = window.innerHeight;

const stage = new Konva.Stage({
container: 'container',
width: width,
height: height,
});

const layer = new Konva.Layer();
stage.add(layer);

const rect = new Konva.Rect({
x: 50,
y: 50,
width: 100,
height: 50,
fill: 'yellow',
stroke: 'black',
draggable: true,
});
layer.add(rect);

const tr = new Konva.Transformer({
nodes: [rect],
rotationSnaps: [0, 90, 180, 270],
rotationSnapTolerance: 30,
});
layer.add(tr);

----------------------------------------

TITLE: Implementing Drag Events in Konva with Vanilla JavaScript
DESCRIPTION: This snippet demonstrates how to create a draggable text element and handle drag events using Konva in vanilla JavaScript. It sets up a stage, layer, and text elements, then adds event listeners for dragstart, dragend, and dragmove events.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight,
});

const layer = new Konva.Layer();
stage.add(layer);

const text = new Konva.Text({
  x: 40,
  y: 40,
  text: 'Draggable Text',
  fontSize: 20,
  draggable: true,
  width: 200,
});
layer.add(text);

const status = new Konva.Text({
  x: 40,
  y: 100,
  text: '',
  fontSize: 16,
  width: 200,
});
layer.add(status);

text.on('dragstart', () => {
  status.text('drag started');
});

text.on('dragend', () => {
  status.text('drag ended');
});

text.on('dragmove', () => {
  status.text('dragging');
});

----------------------------------------

TITLE: Creating External Store for HMR State Preservation in Svelte
DESCRIPTION: This code snippet demonstrates how to create a simple external store using Svelte's writable store. This approach is recommended for retaining important component state during Hot Module Replacement (HMR), as HMR state preservation can be unpredictable with local component state.

LANGUAGE: javascript
CODE:
// store.js
// An extremely simple external store
import { writable } from 'svelte/store'
export default writable(0)

----------------------------------------

TITLE: Implementing Event Listener on Konva Shape with Svelte
DESCRIPTION: This snippet demonstrates how to add a click event listener to a Konva rectangle shape in a Svelte component. It uses the on:click directive to bind the event handler.

LANGUAGE: svelte
CODE:
<script>
  import { Circle, Layer, Stage } from 'svelte-konva';

  function handleClick() {
    console.log('click on rectangle');
  }
</script>

<Stage width={window.innerWidth} height={window.innerHeight}>
  <Layer>
    <Circle
      x={200}
      y={100}
      radius={50}
      fill="green"
      on:click={handleClick}
    />
  </Layer>
</Stage>

----------------------------------------

TITLE: Installing Docusaurus Live Codeblock Theme
DESCRIPTION: Command to install the live codeblock theme package using npm or yarn package managers.

LANGUAGE: bash
CODE:
npm i @docusaurus/theme-live-codeblock # or yarn add @docusaurus/theme-live-codeblock

----------------------------------------

TITLE: Creating an Arc Shape
DESCRIPTION: Creates a new Arc shape instance with configuration options

LANGUAGE: javascript
CODE:
new Konva.Arc(config)

----------------------------------------

TITLE: Setting Clip Function on a Konva.Container in JavaScript
DESCRIPTION: Sets or gets the clip function for the container.

LANGUAGE: javascript
CODE:
// get clip function
var clipFunction = container.clipFunc();

// set clip function
container.clipFunc(function(ctx) {
  ctx.rect(0, 0, 100, 100);
});

container.clipFunc(function(ctx) {
  // optionally return a clip Path2D and clip-rule or just the clip-rule
  return [new Path2D('M0 0v50h50Z'), 'evenodd']
});

----------------------------------------

TITLE: Accessing and Caching Konva Nodes in Svelte
DESCRIPTION: To cache a Konva node in a Svelte app, you need to access the node using the 'handle' prop and then call the cache() function on it. This method improves rendering performance, especially for complex shapes or groups.

LANGUAGE: svelte
CODE:
node.cache()

----------------------------------------

TITLE: Styling Konva Transformer in Vanilla JavaScript
DESCRIPTION: Implementation of a styled Konva Transformer using vanilla JavaScript. Creates a stage with a draggable rectangle and adds a customized transformer with styled borders and anchors.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const width = window.innerWidth;
const height = window.innerHeight;

const stage = new Konva.Stage({
container: 'container',
width: width,
height: height,
});

const layer = new Konva.Layer();
stage.add(layer);

const rect = new Konva.Rect({
x: 50,
y: 50,
width: 100,
height: 100,
fill: 'yellow',
stroke: 'black',
draggable: true,
});
layer.add(rect);

const tr = new Konva.Transformer({
nodes: [rect],
borderStroke: '#000',
borderStrokeWidth: 3,
anchorFill: '#fff',
anchorStroke: '#000',
anchorStrokeWidth: 2,
anchorSize: 20,
anchorCornerRadius: 50,
});
layer.add(tr);

----------------------------------------

TITLE: Creating a Custom Triangle Shape with Konva in Vue
DESCRIPTION: This example illustrates how to create a custom triangle shape using Konva components in a Vue application. It uses v-stage and v-shape components to define the custom shape with a sceneFunc.

LANGUAGE: javascript
CODE:
<template>
  <v-stage :config="stageSize">
    <v-layer>
      <v-shape :config="shapeConfig" />
    </v-layer>
  </v-stage>
</template>

<script setup>
const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight
};

const shapeConfig = {
  sceneFunc: (context, shape) => {
    context.beginPath();
    context.moveTo(20, 50);
    context.lineTo(220, 80);
    context.lineTo(100, 150);
    context.closePath();
    context.fillStrokeShape(shape);
  },
  fill: '#00D2FF',
  stroke: 'black',
  strokeWidth: 4
};
</script>

----------------------------------------

TITLE: Vanilla JS Konva Resize Snapping Implementation
DESCRIPTION: Complete implementation of resize snapping using vanilla JavaScript and Konva. Creates a stage with guide lines and a resizable rectangle that snaps to the center when transformed.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const width = window.innerWidth;
const height = window.innerHeight;

const stage = new Konva.Stage({
container: 'container',
width: width,
height: height,
});

const layer = new Konva.Layer();
stage.add(layer);

// create guides
const horizontalLine = new Konva.Line({
points: [0, height / 2, width, height / 2],
stroke: '#000',
strokeWidth: 1,
dash: [4, 4],
});
layer.add(horizontalLine);

const verticalLine = new Konva.Line({
points: [width / 2, 0, width / 2, height],
stroke: '#000',
strokeWidth: 1,
dash: [4, 4],
});
layer.add(verticalLine);

const rect = new Konva.Rect({
x: 60,
y: 60,
width: 100,
height: 100,
fill: 'red',
draggable: true,
});
layer.add(rect);

const tr = new Konva.Transformer({
nodes: [rect],
anchorDragBoundFunc: function (oldPos, newPos) {
const dist = Math.sqrt(Math.pow(newPos.x - width / 2, 2));
if (dist < 10) {
return {
...newPos,
x: width / 2,
};
}
return newPos;
},
});
layer.add(tr);

----------------------------------------

TITLE: Setting Outer Radius of Konva Ring in JavaScript
DESCRIPTION: Method to get or set the outer radius of the Ring. Returns the current outer radius if no argument is provided.

LANGUAGE: javascript
CODE:
// get outer radius
var outerRadius = ring.outerRadius();

// set outer radius
ring.outerRadius(20);

----------------------------------------

TITLE: Creating Circle Shape with React-Konva
DESCRIPTION: This snippet shows how to create a circle shape using React-Konva. It uses the Stage, Layer, and Circle components from react-konva to render a circle with specified properties.

LANGUAGE: jsx
CODE:
import { Stage, Layer, Circle } from 'react-konva';

const App = () => {
  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        <Circle
          x={window.innerWidth / 2}
          y={window.innerHeight / 2}
          radius={70}
          fill="red"
          stroke="black"
          strokeWidth={4}
        />
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Initializing Konva.Animation in JavaScript
DESCRIPTION: Constructor for creating a new Konva.Animation instance. It takes a configuration object with a function to be executed on each animation frame and optional layers to be redrawn.

LANGUAGE: javascript
CODE:
new Konva.Animation(config)

----------------------------------------

TITLE: Creating External Store for HMR State Preservation in Svelte
DESCRIPTION: This code snippet demonstrates how to create a simple external store using Svelte's writable store. This approach helps retain important component state during Hot Module Replacement (HMR).

LANGUAGE: javascript
CODE:
// store.js
// An extremely simple external store
import { writable } from 'svelte/store'
export default writable(0)

----------------------------------------

TITLE: Implementing Scale Animation with Vanilla JavaScript and Konva
DESCRIPTION: Creates a canvas stage with three draggable hexagons (blue, yellow, and red) that animate their scale properties. Uses Konva.Animation to create smooth scaling effects with different parameters for each shape.

LANGUAGE: javascript
CODE:
const stage = new Konva.Stage({
container: 'container',
width: window.innerWidth,
height: window.innerHeight,
});

const layer = new Konva.Layer();
stage.add(layer);

// blue hexagon - scale x and y
const blueHex = new Konva.RegularPolygon({
x: 50,
y: 50,
sides: 6,
radius: 20,
fill: '#00D2FF',
stroke: 'black',
strokeWidth: 4,
draggable: true
});

// yellow hexagon - scale y only
const yellowHex = new Konva.RegularPolygon({
x: 150,
y: 50,
sides: 6,
radius: 20,
fill: 'yellow',
stroke: 'black',
strokeWidth: 4,
draggable: true
});

// red hexagon - scale x only
const redHex = new Konva.RegularPolygon({
x: 250,
y: 50,
sides: 6,
radius: 20,
fill: 'red',
stroke: 'black',
strokeWidth: 4,
draggable: true
});

layer.add(blueHex);
layer.add(yellowHex);
layer.add(redHex);

const period = 2000;

const anim = new Konva.Animation(function(frame) {
const scale = Math.sin(frame.time * 2 * Math.PI / period) + 2;

// blue hex - scale x and y
blueHex.scale({ x: scale, y: scale });

// yellow hex - scale y only
yellowHex.scaleY(scale);

// red hex - scale x only
redHex.scaleX(scale);
}, layer);

anim.start();

----------------------------------------

TITLE: Creating Shape Tooltips with React and react-konva
DESCRIPTION: This snippet shows how to implement shape tooltips using React and react-konva. It creates a custom shape component and uses React state to manage tooltip visibility and position.

LANGUAGE: jsx
CODE:
import React from 'react';
import { Stage, Layer, Shape, Circle, Text } from 'react-konva';

const CustomShape = ({ onMouseMove, onMouseOut }) => {
  return (
    <Shape
      stroke="black"
      fill="#00D2FF"
      strokeWidth={1}
      sceneFunc={(context, shape) => {
        context.beginPath();
        context.moveTo(120, 50);
        context.lineTo(250, 80);
        context.lineTo(150, 170);
        context.closePath();
        context.fillStrokeShape(shape);
      }}
      onMouseMove={onMouseMove}
      onMouseOut={onMouseOut}
    />
  );
};

const App = () => {
  const [tooltipPos, setTooltipPos] = React.useState({ x: 0, y: 0 });
  const [tooltipText, setTooltipText] = React.useState('');
  const [isTooltipVisible, setTooltipVisible] = React.useState(false);

  const handleMouseMove = (e, text) => {
    const stage = e.target.getStage();
    const pos = stage.getPointerPosition();
    setTooltipPos({
      x: pos.x + 5,
      y: pos.y + 5,
    });
    setTooltipText(text);
    setTooltipVisible(true);
  };

  const handleMouseOut = () => {
    setTooltipVisible(false);
  };

  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        <CustomShape
          onMouseMove={(e) => handleMouseMove(e, 'Cyan Triangle')}
          onMouseOut={handleMouseOut}
        />
        <Circle
          x={250}
          y={window.innerHeight / 2}
          radius={70}
          fill="red"
          stroke="black"
          strokeWidth={4}
          onMouseMove={(e) => handleMouseMove(e, 'Red Circle')}
          onMouseOut={handleMouseOut}
        />
      </Layer>
      <Layer>
        <Text
          x={tooltipPos.x}
          y={tooltipPos.y}
          text={tooltipText}
          fontFamily="Calibri"
          fontSize={12}
          padding={5}
          textFill="white"
          fill="black"
          alpha={0.75}
          visible={isTooltipVisible}
        />
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Creating Shape Tooltips with React and react-konva
DESCRIPTION: This snippet shows how to implement shape tooltips using React and react-konva. It creates a custom shape component and uses React state to manage tooltip visibility and position.

LANGUAGE: jsx
CODE:
import React from 'react';
import { Stage, Layer, Shape, Circle, Text } from 'react-konva';

const CustomShape = ({ onMouseMove, onMouseOut }) => {
  return (
    <Shape
      stroke="black"
      fill="#00D2FF"
      strokeWidth={1}
      sceneFunc={(context, shape) => {
        context.beginPath();
        context.moveTo(120, 50);
        context.lineTo(250, 80);
        context.lineTo(150, 170);
        context.closePath();
        context.fillStrokeShape(shape);
      }}
      onMouseMove={onMouseMove}
      onMouseOut={onMouseOut}
    />
  );
};

const App = () => {
  const [tooltipPos, setTooltipPos] = React.useState({ x: 0, y: 0 });
  const [tooltipText, setTooltipText] = React.useState('');
  const [isTooltipVisible, setTooltipVisible] = React.useState(false);

  const handleMouseMove = (e, text) => {
    const stage = e.target.getStage();
    const pos = stage.getPointerPosition();
    setTooltipPos({
      x: pos.x + 5,
      y: pos.y + 5,
    });
    setTooltipText(text);
    setTooltipVisible(true);
  };

  const handleMouseOut = () => {
    setTooltipVisible(false);
  };

  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        <CustomShape
          onMouseMove={(e) => handleMouseMove(e, 'Cyan Triangle')}
          onMouseOut={handleMouseOut}
        />
        <Circle
          x={250}
          y={window.innerHeight / 2}
          radius={70}
          fill="red"
          stroke="black"
          strokeWidth={4}
          onMouseMove={(e) => handleMouseMove(e, 'Red Circle')}
          onMouseOut={handleMouseOut}
        />
      </Layer>
      <Layer>
        <Text
          x={tooltipPos.x}
          y={tooltipPos.y}
          text={tooltipText}
          fontFamily="Calibri"
          fontSize={12}
          padding={5}
          textFill="white"
          fill="black"
          alpha={0.75}
          visible={isTooltipVisible}
        />
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Styling Konva Transformer Anchors with Vue
DESCRIPTION: This Vue component creates a Konva stage with a yellow rectangle and a transformer. It uses the anchorStyleFunc to customize the appearance of transformer anchors, making them circular, red, and adjusting their size based on position.

LANGUAGE: vue
CODE:
<template>
  <v-stage :config="stageSize">
    <v-layer>
      <v-rect
        :config="rectConfig"
        ref="rectRef"
      />
      <v-transformer
        :config="transformerConfig"
        ref="transformerRef"
      />
    </v-layer>
  </v-stage>
</template>

<script setup>
import { ref, onMounted } from 'vue';

const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight
};

const rectConfig = {
  x: 50,
  y: 50,
  width: 100,
  height: 100,
  fill: 'yellow',
  stroke: 'black',
  draggable: true
};

const transformerConfig = {
  anchorStyleFunc: (anchor) => {
    // make all anchors circles
    anchor.cornerRadius(50);
    // make all anchors red
    anchor.fill('red');

    // make right-middle bigger
    if (anchor.hasName('middle-right')) {
      anchor.scale({ x: 2, y: 2 });
    }
    // make top-left invisible
    if (anchor.hasName('top-left')) {
      anchor.scale({ x: 0, y: 0 });
    }
  }
};

const rectRef = ref(null);
const transformerRef = ref(null);

onMounted(() => {
  transformerRef.value.getNode().nodes([rectRef.value.getNode()]);
});
</script>

----------------------------------------

TITLE: Basic Svelte Konva Component Usage
DESCRIPTION: Example showing how to import and use Svelte Konva components to create a basic canvas with a blue rectangle. Demonstrates Stage, Layer, and Rect components with configuration props.

LANGUAGE: javascript
CODE:
<script>
  import { Stage, Layer, Rect } from 'svelte-konva';
</script>

<Stage config={{ width: window.innerWidth, height: window.innerHeight }}>
  <Layer>
    <Rect config={{ x: 100, y: 100, width: 400, height: 200, fill: 'blue' }} />
  </Layer>
</Stage>

----------------------------------------

TITLE: Creating Arc Shape with React-Konva
DESCRIPTION: Implements the same arc shape using React-Konva components. Creates a centered yellow arc with black stroke using declarative React syntax.

LANGUAGE: jsx
CODE:
import { Stage, Layer, Arc } from 'react-konva';

const App = () => {
  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        <Arc
          x={window.innerWidth / 2}
          y={window.innerHeight / 2}
          innerRadius={40}
          outerRadius={70}
          angle={60}
          fill="yellow"
          stroke="black"
          strokeWidth={4}
        />
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Creating a Konva Ring Shape in JavaScript
DESCRIPTION: Constructor for creating a new Ring shape. Takes a configuration object with properties like innerRadius, outerRadius, fill, stroke, etc.

LANGUAGE: javascript
CODE:
new Konva.Ring(config)

----------------------------------------

TITLE: Configuring Web Crawler Access Rules in robots.txt
DESCRIPTION: Default robots.txt configuration that allows all user agents (crawlers) to access all parts of the website. The empty Disallow directive indicates no restrictions are placed on crawler access.

LANGUAGE: txt
CODE:
User-agent: *
Disallow:

----------------------------------------

TITLE: Creating Oscillating Blobs with Vue and vue-konva
DESCRIPTION: This snippet implements an interactive animation of oscillating blobs using vue-konva in a Vue 3 component. It generates 6 draggable blobs with random positions, colors, and opacities, and animates their tension using a sine wave function. The component uses Vue 3 Composition API for reactivity and lifecycle management.

LANGUAGE: vue
CODE:
<template>
  <v-stage :config="stageSize">
    <v-layer>
      <v-line
        v-for="(blob, i) in blobs"
        :key="i"
        :config="{
          points: blob.points,
          fill: blob.fill,
          stroke: 'black',
          strokeWidth: 2,
          tension: tension,
          opacity: blob.opacity,
          draggable: true,
          closed: true,
          x: blob.x,
          y: blob.y
        }"
        @dragend="handleDragEnd($event, i)"
      />
    </v-layer>
  </v-stage>
</template>

<script setup>
import { ref, onMounted, onUnmounted } from 'vue';

const COLORS = ['red', 'orange', 'yellow', 'green', 'blue', 'purple'];

const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight
};

const blobs = ref([]);
const tension = ref(0);

onMounted(() => {
  // Generate initial blobs
  blobs.value = COLORS.map(color => {
    const points = [];
    for (let i = 0; i < 5; i++) {
      points.push(window.innerWidth * Math.random());
      points.push(window.innerHeight * Math.random());
    }
    return {
      points,
      fill: color,
      opacity: Math.random(),
      x: 0,
      y: 0
    };
  });

  const period = 2000;
  const centerTension = 0;
  const amplitude = 1;

  const interval = setInterval(() => {
    const time = new Date().getTime();
    tension.value =
      amplitude * Math.sin((time * 2 * Math.PI) / period) + centerTension;
  }, 1000 / 60);

  onUnmounted(() => clearInterval(interval));
});

const handleDragEnd = (e, index) => {
  const newBlobs = [...blobs.value];
  newBlobs[index] = {
    ...newBlobs[index],
    x: e.target.x(),
    y: e.target.y()
  };
  blobs.value = newBlobs;
};
</script>

----------------------------------------

TITLE: Styling Konva Transformer in Vue
DESCRIPTION: Vue implementation of a styled Konva Transformer using v-konva. Demonstrates the setup of a transformer with custom styling applied to borders and anchors, connected to a draggable rectangle.

LANGUAGE: vue
CODE:
<template>
  <v-stage :config="stageSize">
    <v-layer>
      <v-rect
        :config="rectConfig"
        ref="rectRef"
      />
      <v-transformer
        :config="transformerConfig"
        ref="transformerRef"
      />
    </v-layer>
  </v-stage>
</template>

<script setup>
import { ref, onMounted } from 'vue';

const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight
};

const rectConfig = {
  x: 50,
  y: 50,
  width: 100,
  height: 100,
  fill: 'yellow',
  stroke: 'black',
  draggable: true
};

const transformerConfig = {
  borderStroke: '#000',
  borderStrokeWidth: 3,
  anchorFill: '#fff',
  anchorStroke: '#000',
  anchorStrokeWidth: 2,
  anchorSize: 20,
  anchorCornerRadius: 50
};

const rectRef = ref(null);
const transformerRef = ref(null);

onMounted(() => {
  transformerRef.value.getNode().nodes([rectRef.value.getNode()]);
});
</script>

----------------------------------------

TITLE: Creating an External Store in Svelte
DESCRIPTION: Demonstrates how to create a simple external store in Svelte using the writable function. This approach is recommended for state that needs to be preserved during Hot Module Replacement (HMR).

LANGUAGE: javascript
CODE:
// store.js
// An extremely simple external store
import { writable } from 'svelte/store'
export default writable(0)

----------------------------------------

TITLE: Implementing Drag and Drop with React and Konva
DESCRIPTION: This snippet demonstrates how to implement drag and drop functionality for DOM images into a Konva canvas using React. It includes components for draggable items, handling drag events, and rendering dropped images on the canvas.

LANGUAGE: jsx
CODE:
import { useState, useRef, useEffect } from 'react';
import { Stage, Layer, Image } from 'react-konva';
import { useImage } from 'react-konva-utils';

const DragItem = ({ src, onDragStart }) => {
  return (
    <img 
      src={src} 
      draggable={true}
      style={{ height: '100px', margin: '5px' }}
      onDragStart={() => onDragStart(src)} 
    />
  );
};

const App = () => {
  const [images, setImages] = useState([]);
  const [dragImageSrc, setDragImageSrc] = useState('');
  const stageRef = useRef(null);
  
  const handleDragStart = (src) => {
    setDragImageSrc(src);
  };
  
  const handleDragOver = (e) => {
    e.preventDefault(); // prevent default behavior
  };
  
  const handleDrop = (e) => {
    e.preventDefault();
    
    if (!dragImageSrc || !stageRef.current) return;
    
    // Get stage and pointer position
    const stage = stageRef.current;
    
    // Register the pointer position manually since this is a DOM event
    stage.setPointersPositions(e);
    const position = stage.getPointerPosition();
    
    // Add new image to the list
    setImages([
      ...images,
      {
        src: dragImageSrc,
        x: position.x,
        y: position.y,
        id: Date.now().toString()
      }
    ]);
  };
  
  return (
    <div>
      <p>Drag&drop yoda into the grey area.</p>
      <div style={{ marginBottom: '10px' }}>
        <DragItem 
          src="https://konvajs.org/assets/yoda.jpg" 
          onDragStart={handleDragStart} 
        />
        <DragItem 
          src="https://konvajs.org/assets/darth-vader.jpg" 
          onDragStart={handleDragStart} 
        />
      </div>
      
      <div 
        onDragOver={handleDragOver}
        onDrop={handleDrop}
        style={{ backgroundColor: 'rgba(0, 0, 0, 0.1)' }}
      >
        <Stage
          width={window.innerWidth}
          height={window.innerHeight - 150}
          ref={stageRef}
        >
          <Layer>
            {images.map((img) => (
              <KonvaImage
                key={img.id}
                src={img.src}
                x={img.x}
                y={img.y}
                draggable
              />
            ))}
          </Layer>
        </Stage>
      </div>
    </div>
  );
};

// Separate component for Konva Image with proper loading
const KonvaImage = ({ src, x, y, draggable }) => {
  const [image] = useImage(src);
  
  if (!image) return null;
  
  // Calculate appropriate size
  const maxDimension = 100;
  let width = image.width;
  let height = image.height;
  
  if (width > height) {
    height = (height / width) * maxDimension;
    width = maxDimension;
  } else {
    width = (width / height) * maxDimension;
    height = maxDimension;
  }
  
  return (
    <Image
      image={image}
      x={x}
      y={y}
      width={width}
      height={height}
      draggable={draggable}
    />
  );
};

export default App;

----------------------------------------

TITLE: Basic Transformer Anchor Position Control
DESCRIPTION: Demonstrates basic anchor position control using anchorDragBoundFunc in Konva. This snippet shows how to limit transformer anchor positions along the x-axis.

LANGUAGE: javascript
CODE:
transformer.anchorDragBoundFunc(function (oldAbsPos, newAbsPos, event) {
  // limit any another position on the x axis
  return {
    x: 0,
    y: newAbsolutePosition.y,
  };
});

----------------------------------------

TITLE: Installing Vue Konva Dependencies
DESCRIPTION: Command to install vue-konva and its core dependency konva via npm

LANGUAGE: bash
CODE:
npm install vue-konva konva --save

----------------------------------------

TITLE: Implementing Persistent Canvas Elements with Vue and Konva
DESCRIPTION: This snippet demonstrates how to create a Vue component that renders a Konva stage with clickable functionality to add circles. It includes methods for saving and loading the circle data using local storage, ensuring persistence across page reloads.

LANGUAGE: html
CODE:
<template>
  <div>
    Click on canvas to create a circle.
    <a href=".">Reload the page</a>. Circles should stay here.
    <v-stage
      ref="stage"
      :config="stageSize"
      @click="handleClick"
    >
      <v-layer ref="layer">
        <v-circle
          v-for="item in list"
          :key="item.id"
          :config="item"
        />
      </v-layer>
    </v-stage>
  </div>
</template>

LANGUAGE: javascript
CODE:
<script setup>
import { ref, onMounted } from 'vue';

const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight
};

const list = ref([{ x: 100, y: 100, radius: 50, fill: 'blue' }]);

const handleClick = (evt) => {
  const stage = evt.target.getStage();
  const pos = stage.getPointerPosition();
  list.value.push({
    radius: 50,
    fill: 'red',
    ...pos
  });

  save();
};

const load = () => {
  const data = localStorage.getItem('storage');
  if (data) list.value = JSON.parse(data);
};

const save = () => {
  localStorage.setItem('storage', JSON.stringify(list.value));
};

onMounted(() => {
  load();
});
</script>

----------------------------------------

TITLE: Applying Invert Filter to Image with Konva.js (React)
DESCRIPTION: This snippet demonstrates how to use Konva with React to load an image and apply an invert filter. It uses the react-konva library and the useImage hook for image loading. The useEffect hook is used to cache the image after it's loaded.

LANGUAGE: jsx
CODE:
import { Stage, Layer, Image } from 'react-konva';
import { useRef, useEffect } from 'react';
import useImage from 'use-image';

const App = () => {
  const [image] = useImage('https://konvajs.org/assets/lion.png', 'anonymous');
  const imageRef = useRef(null);

  useEffect(() => {
    if (image && imageRef.current) {
      imageRef.current.cache();
    }
  }, [image]);

  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        {image && (
          <Image
            ref={imageRef}
            x={50}
            y={50}
            image={image}
            draggable
            filters={[Konva.Filters.Invert]}
          />
        )}
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Creating Simple Lines with Konva in Vue
DESCRIPTION: This snippet demonstrates how to create simple lines and dashed lines using Konva in a Vue component. It uses v-stage and v-layer components with v-line for creating the lines.

LANGUAGE: vue
CODE:
<template>
  <v-stage :config="stageSize">
    <v-layer>
      <v-line :config="redLineConfig" />
      <v-line :config="greenLineConfig" />
    </v-layer>
  </v-stage>
</template>

<script setup>
const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight
};

const redLineConfig = {
  points: [5, 70, 140, 23, 250, 60, 300, 20],
  stroke: 'red',
  strokeWidth: 15,
  lineCap: 'round',
  lineJoin: 'round'
};

const greenLineConfig = {
  points: [5, 70, 140, 23, 250, 60, 300, 20],
  stroke: 'green',
  strokeWidth: 2,
  lineJoin: 'round',
  dash: [33, 10],
  y: 50
};
</script>

----------------------------------------

TITLE: React Clock Component with Live Preview
DESCRIPTION: Example React component demonstrating live code editing functionality, showing a clock that updates every second using useState and useEffect hooks.

LANGUAGE: jsx
CODE:
function Clock(props) {
  const [date, setDate] = useState(new Date());
  useEffect(() => {
    var timerID = setInterval(() => tick(), 1000);

    return function cleanup() {
      clearInterval(timerID);
    };
  });

  function tick() {
    setDate(new Date());
  }

  return (
    <div>
      <h2>It is {date.toLocaleTimeString()}.</h2>
    </div>
  );
}

----------------------------------------

TITLE: Implementing Shape Animation with React-Konva
DESCRIPTION: React implementation of the shape animation using react-konva components. Manages shape state and animations using React hooks while maintaining the same functionality as the vanilla version.

LANGUAGE: javascript
CODE:
import React from 'react';
import { Stage, Layer, RegularPolygon } from 'react-konva';

const COLORS = ['red', 'orange', 'yellow', 'green', 'blue', 'purple'];
const NUM_SHAPES = 10;

const getRandomColor = () => COLORS[Math.floor(Math.random() * COLORS.length)];

const getRandomShapeProps = (width, height) => {
  const radius = Math.random() * 100 + 20;
  return {
    x: Math.random() * width,
    y: Math.random() * height,
    sides: Math.ceil(Math.random() * 5 + 3),
    radius,
    fill: getRandomColor(),
    opacity: (radius - 20) / 100,
  };
};

const App = () => {
  const [shapes, setShapes] = React.useState([]);
  const stageRef = React.useRef();

  React.useEffect(() => {
    const initialShapes = Array.from({ length: NUM_SHAPES }, () =>
      getRandomShapeProps(window.innerWidth, window.innerHeight)
    );
    setShapes(initialShapes);
  }, []);

  const handleDragEnd = (e, index) => {
    const newShapes = [...shapes];
    newShapes[index] = {
      ...newShapes[index],
      x: e.target.x(),
      y: e.target.y(),
    };
    setShapes(newShapes);
  };

  const handleTango = () => {
    const layer = stageRef.current.findOne('Layer');
    const shapeNodes = layer.find('RegularPolygon');

    shapeNodes.forEach((node, i) => {
      const radius = Math.random() * 100 + 20;
      const newProps = {
        duration: 1,
        x: Math.random() * window.innerWidth,
        y: Math.random() * window.innerHeight,
        rotation: Math.random() * 360,
        radius: radius,
        opacity: (radius - 20) / 100,
        easing: Konva.Easings.EaseInOut,
        fill: getRandomColor(),
      };

      node.to(newProps);

      setTimeout(() => {
        setShapes(prev => {
          const newShapes = [...prev];
          newShapes[i] = { ...newShapes[i], ...newProps };
          return newShapes;
        });
      }, 1000);
    });
  };

  return (
    <>
      <Stage
        width={window.innerWidth}
        height={window.innerHeight}
        ref={stageRef}
      >
        <Layer>
          {shapes.map((shape, i) => (
            <RegularPolygon
              key={i}
              {...shape}
              draggable
              onDragEnd={(e) => handleDragEnd(e, i)}
            />
          ))}
        </Layer>
      </Stage>
      <button
        onClick={handleTango}
        style={{
          position: 'absolute',
          top: '10px',
          left: '10px',
          padding: '10px',
        }}
      >
        Tango!
      </button>
    </>
  );
};

export default App;

----------------------------------------

TITLE: Creating Arc Shape with Svelte-Konva
DESCRIPTION: Demonstrates arc shape creation using Svelte-Konva components. Uses Svelte's script and markup syntax to configure the stage and arc properties.

LANGUAGE: svelte
CODE:
<script>
  import { Stage, Layer, Arc } from 'svelte-konva';

  const width = window.innerWidth;
  const height = window.innerHeight;
</script>

<Stage config={{ width, height }}>
  <Layer>
    <Arc 
      config={{
        x: width / 2,
        y: height / 2,
        innerRadius: 40,
        outerRadius: 70,
        angle: 60,
        fill: 'yellow',
        stroke: 'black',
        strokeWidth: 4
      }} 
    />
  </Layer>
</Stage>

----------------------------------------

TITLE: Resizing Text on Canvas with Konva in Vue
DESCRIPTION: This snippet illustrates how to resize text on a canvas using Konva in a Vue.js application. It uses the composition API with refs and computed properties to manage the text and transformer components. The handleTransform method updates the text width while preserving the original scale.

LANGUAGE: vue
CODE:
<template>
  <v-stage :config="stageSize">
    <v-layer>
      <v-text
        :config="textConfig"
        @transform="handleTransform"
        ref="textRef"
      />
      <v-transformer
        :config="transformerConfig"
        ref="transformerRef"
      />
    </v-layer>
  </v-stage>
</template>

<script setup>
import { ref, computed, onMounted } from 'vue';

const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight
};

const textWidth = ref(200);

const textConfig = computed(() => ({
  x: 50,
  y: 50,
  text: 'Hello from Konva! Try to resize me.',
  fontSize: 24,
  draggable: true,
  width: textWidth.value
}));

const transformerConfig = {
  enabledAnchors: ['middle-left', 'middle-right']
};

const textRef = ref(null);
const transformerRef = ref(null);

const handleTransform = () => {
  const node = textRef.value.getNode();
  textWidth.value = node.width() * node.scaleX();
  node.scaleX(1);
};

onMounted(() => {
  transformerRef.value.getNode().nodes([textRef.value.getNode()]);
});
</script>

----------------------------------------

TITLE: Building Static Website Content
DESCRIPTION: Command to generate static website content in the build directory for production deployment.

LANGUAGE: bash
CODE:
$ yarn build

----------------------------------------

TITLE: Implementing Shape Resize Limits with Konva in Vue
DESCRIPTION: This snippet shows how to create a resizable rectangle with a width limit of 200 pixels using Konva in a Vue component. It uses the Composition API with refs and onMounted hook to set up the stage, layer, rectangle, and transformer.

LANGUAGE: vue
CODE:
<template>
  <v-stage :config="stageSize">
    <v-layer>
      <v-rect
        :config="rectConfig"
        ref="rectRef"
      />
      <v-transformer
        :config="transformerConfig"
        ref="transformerRef"
      />
    </v-layer>
  </v-stage>
</template>

<script setup>
import { ref, onMounted } from 'vue';

const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight
};

const rectConfig = {
  x: 50,
  y: 50,
  width: 100,
  height: 100,
  fill: 'yellow',
  stroke: 'black',
  draggable: true
};

const transformerConfig = {
  boundBoxFunc: (oldBox, newBox) => {
    // limit resize
    if (newBox.width > 200) {
      return oldBox;
    }
    return newBox;
  }
};

const rectRef = ref(null);
const transformerRef = ref(null);

onMounted(() => {
  transformerRef.value.getNode().nodes([rectRef.value.getNode()]);
});
</script>

----------------------------------------

TITLE: Implementing Namespaced Event Listeners with Konva in JavaScript
DESCRIPTION: This code snippet creates a Konva stage with a circle shape and two namespaced click event listeners. It also includes buttons to remove these listeners individually, demonstrating the use of 'on()' and 'off()' methods with event namespacing.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight,
});

const layer = new Konva.Layer();
stage.add(layer);

const circle = new Konva.Circle({
  x: stage.width() / 2,
  y: stage.height() / 2,
  radius: 70,
  fill: 'red',
  stroke: 'black',
  strokeWidth: 4,
});

// add click listeners
circle.on('click.event1', function () {
  alert('first click listener');
});

circle.on('click.event2', function () {
  alert('second click listener');
});

layer.add(circle);

// add buttons to remove listeners
const button1 = document.createElement('button');
button1.innerHTML = 'Remove first listener';
button1.style.position = 'absolute';
button1.style.top = '0';
button1.style.left = '0';
document.getElementById('container').appendChild(button1);

const button2 = document.createElement('button');
button2.innerHTML = 'Remove second listener';
button2.style.position = 'absolute';
button2.style.top = '30px';
button2.style.left = '0';
document.getElementById('container').appendChild(button2);

----------------------------------------

TITLE: Implementing Shape Animation with Vue-Konva
DESCRIPTION: Vue implementation of the shape animation using vue-konva components. Uses Vue's composition API and refs to manage state and animations while maintaining the same functionality as other versions.

LANGUAGE: javascript
CODE:
<template>
  <div>
    <v-stage
      :config="stageConfig"
      ref="stageRef"
    >
      <v-layer>
        <v-regular-polygon
          v-for="(shape, i) in shapes"
          :key="i"
          :config="{ ...shape, draggable: true }"
          @dragend="(e) => handleDragEnd(e, i)"
        />
      </v-layer>
    </v-stage>
    <button
      @click="handleTango"
      style="position: absolute; top: 10px; left: 10px; padding: 10px"
    >
      Tango!
    </button>
  </div>
</template>

<script setup>
import { ref, onMounted } from 'vue';

const COLORS = ['red', 'orange', 'yellow', 'green', 'blue', 'purple'];
const NUM_SHAPES = 10;

const shapes = ref([]);
const stageRef = ref(null);

const stageConfig = {
  width: window.innerWidth,
  height: window.innerHeight,
};

const getRandomColor = () => COLORS[Math.floor(Math.random() * COLORS.length)];

const getRandomShapeProps = () => {
  const radius = Math.random() * 100 + 20;
  return {
    x: Math.random() * stageConfig.width,
    y: Math.random() * stageConfig.height,
    sides: Math.ceil(Math.random() * 5 + 3),
    radius,
    fill: getRandomColor(),
    opacity: (radius - 20) / 100,
  };
};

const handleDragEnd = (e, index) => {
  const newShapes = [...shapes.value];
  newShapes[index] = {
    ...newShapes[index],
    x: e.target.x(),
    y: e.target.y(),
  };
  shapes.value = newShapes;
};

const handleTango = () => {
  const stage = stageRef.value.getStage();
  const layer = stage.findOne('Layer');
  const shapeNodes = layer.find('RegularPolygon');

  shapeNodes.forEach((node, i) => {
    const radius = Math.random() * 100 + 20;
    const newProps = {
      duration: 1,
      x: Math.random() * stageConfig.width,
      y: Math.random() * stageConfig.height,
      rotation: Math.random() * 360,
      radius: radius,
      opacity: (radius - 20) / 100,
      easing: Konva.Easings.EaseInOut,
      fill: getRandomColor(),
    };

    node.to(newProps);

    setTimeout(() => {
      const newShapes = [...shapes.value];
      newShapes[i] = { ...newShapes[i], ...newProps };
      shapes.value = newShapes;
    }, 1000);
  });
};

onMounted(() => {
  shapes.value = Array.from({ length: NUM_SHAPES }, getRandomShapeProps);
});
</script>

----------------------------------------

TITLE: Getting/Setting Outer Radius
DESCRIPTION: Gets or sets the outer radius of the arc

LANGUAGE: javascript
CODE:
// get outer radius
var outerRadius = arc.outerRadius();

// set outer radius
arc.outerRadius(20);

----------------------------------------

TITLE: Applying Kaleidoscope Filter to Image using Konva.js (Vanilla JavaScript)
DESCRIPTION: This snippet shows how to apply a kaleidoscope filter to an image using Konva.js in vanilla JavaScript. It creates a stage, loads an image, applies the filter, and adds interactive sliders to control the kaleidoscope power and angle.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight,
});

const layer = new Konva.Layer();
stage.add(layer);

const imageObj = new Image();
imageObj.onload = () => {
  const image = new Konva.Image({
    x: 50,
    y: 50,
    image: imageObj,
    draggable: true,
  });

  layer.add(image);

  image.cache();
  image.filters([Konva.Filters.Kaleidoscope]);
  image.kaleidoscopePower(3);
  image.kaleidoscopeAngle(0);

  // create sliders
  const createSlider = (label, min, max, defaultValue, property) => {
    const container = document.createElement('div');
    container.style.position = 'absolute';
    container.style.left = '20px';
    
    const text = document.createElement('span');
    text.textContent = `${label}: `;
    container.appendChild(text);
    
    const slider = document.createElement('input');
    slider.type = 'range';
    slider.min = min;
    slider.max = max;
    slider.step = property === 'kaleidoscopePower' ? '1' : '0.1';
    slider.value = defaultValue;
    slider.style.width = '200px';
    
    slider.addEventListener('input', (e) => {
      const value = parseFloat(e.target.value);
      image[property](value);
    });
    
    container.appendChild(slider);
    return container;
  };

  const powerSlider = createSlider('Power', 2, 8, 3, 'kaleidoscopePower');
  powerSlider.style.top = '20px';
  document.body.appendChild(powerSlider);

  const angleSlider = createSlider('Angle', 0, 360, 0, 'kaleidoscopeAngle');
  angleSlider.style.top = '45px';
  document.body.appendChild(angleSlider);
};
imageObj.src = 'https://konvajs.org/assets/lion.png';
imageObj.crossOrigin = 'anonymous';

----------------------------------------

TITLE: Converting Konva Stage to Data URL in Vue
DESCRIPTION: This Vue component creates a Konva stage with a draggable rectangle and provides functionality to convert it to a data URL. It uses the ref function to access the stage and manage reactive state for the rectangle's position.

LANGUAGE: vue
CODE:
<template>
  <div>
    <button @click="handleExport" style="margin-bottom: 10px">
      Save as Image
    </button>
    <v-stage ref="stageRef" :config="stageSize">
      <v-layer>
        <v-rect
          :config="rectConfig"
          @dragend="handleDragEnd"
        />
      </v-layer>
    </v-stage>
  </div>
</template>

<script setup>
import { ref } from 'vue';

const stageSize = {
  width: 400,
  height: 400
};

const position = ref({ x: 100, y: 100 });

const rectConfig = ref({
  x: position.value.x,
  y: position.value.y,
  width: 100,
  height: 100,
  fill: 'red',
  stroke: 'black',
  strokeWidth: 4,
  draggable: true
});

const stageRef = ref(null);

const handleExport = () => {
  // get data URL with default settings
  const dataURL = stageRef.value.getNode().toDataURL();
  
  // open in new window
  const win = window.open();
  win.document.write(`<img src="${dataURL}" alt="Stage"/>`);
  
  // you can also save with different settings
  const jpegURL = stageRef.value.getNode().toDataURL({
    mimeType: 'image/jpeg',
    quality: 0.8
  });
  console.log('JPEG URL:', jpegURL);
};

const handleDragEnd = (e) => {
  const newPos = e.target.position();
  position.value = newPos;
  rectConfig.value.x = newPos.x;
  rectConfig.value.y = newPos.y;
};
</script>

----------------------------------------

TITLE: Setting Pixel Ratio in Konva Canvas
DESCRIPTION: Demonstrates how to set a custom pixel ratio for a Konva layer's canvas. This can be used to override the default device pixel ratio for special situations.

LANGUAGE: javascript
CODE:
layer.getCanvas().setPixelRatio(3);

----------------------------------------

TITLE: Selecting Shapes by Type with Vanilla JavaScript and Konva
DESCRIPTION: Demonstrates how to create a canvas with different shapes and select circles to apply animations using Konva's find() method. Creates two circles and a rectangle, then uses find('Circle') to select and animate only the circular shapes.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight,
});

const layer = new Konva.Layer();
stage.add(layer);

// create shapes of different types
const circle1 = new Konva.Circle({
  x: 50,
  y: stage.height() / 2,
  radius: 30,
  fill: 'red'
});

const circle2 = new Konva.Circle({
  x: 150,
  y: stage.height() / 2,
  radius: 30,
  fill: 'green'
});

const rect = new Konva.Rect({
  x: 250,
  y: stage.height() / 2 - 25,
  width: 50,
  height: 50,
  fill: 'blue'
});

layer.add(circle1);
layer.add(circle2);
layer.add(rect);

// find all circles by type
const circles = layer.find('Circle');
circles.forEach(circle => {
  // add animation to circles only
  circle.to({
    duration: 1,
    scale: { x: 1.5, y: 1.5 },
    easing: Konva.Easings.EaseInOut
  });
});

----------------------------------------

TITLE: Implementing Multi-Event Handling in Vue.js with vue-konva
DESCRIPTION: This Vue.js component uses vue-konva to create a stage with a circle and text, demonstrating how to handle multiple events (mouseover, mousedown, mouseup) on the circle and display the event type.

LANGUAGE: html
CODE:
<template>
  <v-stage :config="stageSize">
    <v-layer>
      <v-text :config="textConfig" />
      <v-circle
        :config="circleConfig"
        @mouseover="handleMultiEvent"
        @mousedown="handleMultiEvent"
        @mouseup="handleMultiEvent"
      />
    </v-layer>
  </v-stage>
</template>

<script setup>
import { ref, computed } from 'vue';

const message = ref('');

const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight
};

const textConfig = computed(() => ({
  x: 10,
  y: 10,
  fontFamily: 'Calibri',
  fontSize: 24,
  text: message.value,
  fill: 'black'
}));

const circleConfig = {
  x: window.innerWidth / 2,
  y: window.innerHeight / 2,
  radius: 70,
  fill: 'red',
  stroke: 'black',
  strokeWidth: 4
};

const handleMultiEvent = (e) => {
  message.value = 'event: ' + e.type;
};
</script>

----------------------------------------

TITLE: Implementing 10k Shapes with Tooltips in Vanilla JavaScript using Konva
DESCRIPTION: Creates a Konva stage with 10,000 randomly positioned colored circles and a tooltip layer that shows circle information on hover. Uses direct DOM manipulation and Konva's event system.

LANGUAGE: javascript
CODE:
const width = window.innerWidth;
const height = window.innerHeight;

const stage = new Konva.Stage({
  container: 'container',
  width: width,
  height: height,
});

const circlesLayer = new Konva.Layer();
const tooltipLayer = new Konva.Layer();
const colors = ['red', 'orange', 'yellow', 'green', 'blue', 'cyan', 'purple'];
let colorIndex = 0;

for (let i = 0; i < 10000; i++) {
  const color = colors[colorIndex++];
  if (colorIndex >= colors.length) {
    colorIndex = 0;
  }

  const randX = Math.random() * stage.width();
  const randY = Math.random() * stage.height();
  const circle = new Konva.Circle({
    x: randX,
    y: randY,
    radius: 3,
    fill: color,
    name: i.toString(),
  });

  circlesLayer.add(circle);
}

const tooltip = new Konva.Text({
  text: '',
  fontFamily: 'Calibri',
  fontSize: 12,
  padding: 5,
  visible: false,
  fill: 'black',
  opacity: 0.75,
});

tooltipLayer.add(tooltip);
stage.add(circlesLayer);
stage.add(tooltipLayer);

circlesLayer.on('mousemove', (e) => {
  const mousePos = stage.getPointerPosition();
  tooltip.position({
    x: mousePos.x + 5,
    y: mousePos.y + 5,
  });
  tooltip.text('node: ' + e.target.name() + ', color: ' + e.target.fill());
  tooltip.show();
});

circlesLayer.on('mouseout', () => {
  tooltip.hide();
});

----------------------------------------

TITLE: Setting Ellipse Radius
DESCRIPTION: Example showing how to get and set the x and y radius values of an ellipse

LANGUAGE: javascript
CODE:
// get radius
var radius = ellipse.radius();

// set radius
ellipse.radius({
  x: 200,
  y: 100
});

----------------------------------------

TITLE: Applying Multiple Filters to Konva.Image in Vanilla JavaScript
DESCRIPTION: This snippet shows how to apply multiple filters (blur, brightness, contrast) to a Konva.Image using vanilla JavaScript. It creates a draggable image and interactive controls for toggling and adjusting filter values.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight,
});

const layer = new Konva.Layer();
stage.add(layer);

const imageObj = new Image();
imageObj.onload = () => {
  const image = new Konva.Image({
    x: 50,
    y: 50,
    image: imageObj,
    draggable: true,
  });

  layer.add(image);
  image.cache();

  // Create controls container
  const container = document.createElement('div');
  container.style.position = 'absolute';
  container.style.top = '20px';
  container.style.left = '20px';
  document.body.appendChild(container);

  // Filter states
  const filterStates = {
    blur: false,
    brightness: false,
    contrast: false,
  };

  const filterValues = {
    blur: 10,
    brightness: 0.3,
    contrast: 50,
  };

  // Create filter controls
  const createFilterControl = (name, min, max, step, defaultValue) => {
    const div = document.createElement('div');
    div.style.marginBottom = '10px';
    
    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.id = name;
    checkbox.checked = filterStates[name];
    
    const label = document.createElement('label');
    label.htmlFor = name;
    label.textContent = ` ${name.charAt(0).toUpperCase() + name.slice(1)}: `;
    
    const slider = document.createElement('input');
    slider.type = 'range';
    slider.min = min;
    slider.max = max;
    slider.step = step;
    slider.value = defaultValue;
    slider.style.width = '200px';
    slider.disabled = !filterStates[name];
    
    div.appendChild(checkbox);
    div.appendChild(label);
    div.appendChild(slider);
    
    checkbox.addEventListener('change', (e) => {
      filterStates[name] = e.target.checked;
      slider.disabled = !e.target.checked;
      updateFilters();
    });
    
    slider.addEventListener('input', (e) => {
      filterValues[name] = parseFloat(e.target.value);
      updateFilters();
    });
    
    return div;
  };

  // Add controls
  container.appendChild(createFilterControl('blur', 0, 40, 1, filterValues.blur));
  container.appendChild(createFilterControl('brightness', -1, 1, 0.1, filterValues.brightness));
  container.appendChild(createFilterControl('contrast', -100, 100, 1, filterValues.contrast));

  function updateFilters() {
    const activeFilters = [];
    
    if (filterStates.blur) {
      activeFilters.push(Konva.Filters.Blur);
      image.blurRadius(filterValues.blur);
    }
    if (filterStates.brightness) {
      activeFilters.push(Konva.Filters.Brighten);
      image.brightness(filterValues.brightness);
    }
    if (filterStates.contrast) {
      activeFilters.push(Konva.Filters.Contrast);
      image.contrast(filterValues.contrast);
    }
    
    image.filters(activeFilters);
  }
};
imageObj.src = 'https://konvajs.org/assets/lion.png';
imageObj.crossOrigin = 'anonymous';

----------------------------------------

TITLE: Creating a Ring Shape with React-Konva
DESCRIPTION: This snippet shows how to create a ring shape using React-Konva. It uses the Stage, Layer, and Ring components from react-konva to render a ring with specified properties.

LANGUAGE: jsx
CODE:
import { Stage, Layer, Ring } from 'react-konva';

const App = () => {
  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        <Ring
          x={window.innerWidth / 2}
          y={window.innerHeight / 2}
          innerRadius={40}
          outerRadius={70}
          fill="yellow"
          stroke="black"
          strokeWidth={4}
        />
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Serializing Konva Stage in Vue
DESCRIPTION: This snippet shows how to create a Konva stage with a circle shape and serialize it using the toJSON() method in a Vue component. It uses the ref attribute to access the stage and includes a button to trigger the serialization.

LANGUAGE: vue
CODE:
<template>
  <div>
    <button @click="handleSerialize" style="margin-bottom: 10px">
      Serialize Stage
    </button>
    <v-stage ref="stageRef" :config="stageSize">
      <v-layer>
        <v-circle :config="circleConfig" />
      </v-layer>
    </v-stage>
  </div>
</template>

<script setup>
import { ref } from 'vue';

const stageSize = {
  width: 400,
  height: 400
};

const circleConfig = {
  x: 100,
  y: 100,
  radius: 50,
  fill: 'red',
  stroke: 'black',
  strokeWidth: 3
};

const stageRef = ref(null);

const handleSerialize = () => {
  const json = stageRef.value.getNode().toJSON();
  console.log(json);
  alert('Stage serialized! Check the console for the JSON string.');
};
</script>

----------------------------------------

TITLE: Exporting Konva Stage with High Resolution - React
DESCRIPTION: React implementation of high quality Konva stage export using React-Konva components. Uses useRef hook to access stage instance for export functionality.

LANGUAGE: javascript
CODE:
import { Stage, Layer, Circle, Text } from 'react-konva';
import { useRef } from 'react';

const App = () => {
  const stageRef = useRef(null);

  const handleExport = () => {
    const dataURL = stageRef.current.toDataURL({
      pixelRatio: 2
    });
    
    const link = document.createElement('a');
    link.download = 'stage.png';
    link.href = dataURL;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
  };

  return (
    <div>
      <button onClick={handleExport} style={{ marginBottom: '10px' }}>
        Save as High Quality Image
      </button>
      <Stage width={400} height={400} ref={stageRef}>
        <Layer>
          <Circle
            x={200}
            y={200}
            radius={70}
            fill="red"
            stroke="black"
            strokeWidth={4}
          />
          <Text
            x={150}
            y={190}
            text="High Quality Export"
            fontSize={20}
            fill="white"
          />
        </Layer>
      </Stage>
    </div>
  );
};

----------------------------------------

TITLE: Implementing Custom Font with React and Konva
DESCRIPTION: Shows how to implement custom font loading in a React component using react-konva. Uses hooks for state management and CSS Font Loading API for font detection.

LANGUAGE: javascript
CODE:
import { Stage, Layer, Text } from 'react-konva';
import { useState, useEffect } from 'react';

const App = () => {
  const [fontLoaded, setFontLoaded] = useState(false);
  const [fontStatus, setFontStatus] = useState('Loading font...');
  
  useEffect(() => {
    const fontLink = document.createElement('link');
    fontLink.href = 'https://fonts.googleapis.com/css2?family=Kavivanar&display=swap';
    fontLink.rel = 'stylesheet';
    document.head.appendChild(fontLink);
    
    document.fonts.ready.then(() => {
      if (document.fonts.check('1em Kavivanar')) {
        setFontStatus('Font loaded successfully!');
        setFontLoaded(true);
      } else {
        setTimeout(() => {
          setFontStatus('Using fallback timer - attempting to set font now');
          setFontLoaded(true);
        }, 500);
      }
    }).catch(err => {
      setFontStatus('Error loading font: ' + err.message);
      console.error('Font loading failed:', err);
    });
  }, []);

  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        <Text
          x={50}
          y={50}
          fontSize={40}
          text="A text with custom font."
          width={250}
          fontFamily={fontLoaded ? 'Kavivanar' : 'Arial'}
        />
        <Text
          x={50}
          y={0}
          fontSize={16}
          text={fontStatus}
          fill={fontStatus.includes('Error') ? 'red' : 'green'}
        />
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Creating Draggable Stage with React-Konva
DESCRIPTION: This snippet shows how to implement a draggable Konva stage using React-Konva. It creates a stage component with the draggable prop set to true and adds a circle and text as child components.

LANGUAGE: jsx
CODE:
import { Stage, Layer, Circle, Text } from 'react-konva';

const App = () => {
  return (
    <Stage
      width={window.innerWidth}
      height={window.innerHeight}
      draggable
    >
      <Layer>
        <Circle
          x={window.innerWidth / 2}
          y={window.innerHeight / 2}
          radius={70}
          fill="red"
          stroke="black"
          strokeWidth={4}
        />
        <Text
          x={10}
          y={10}
          text="Drag the stage anywhere"
          fontSize={20}
          fontFamily="Calibri"
          fill="black"
        />
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Implementing Draggable Text with React-Konva
DESCRIPTION: Creates a draggable text element on a Konva canvas using React hooks for state management. The component tracks the dragging state and position, updating the text color while dragging and storing the final position after drag ends.

LANGUAGE: jsx
CODE:
import React from 'react';
import { Stage, Layer, Text } from 'react-konva';

const App = () => {
  const [isDragging, setIsDragging] = React.useState(false);
  const [position, setPosition] = React.useState({
    x: 50,
    y: 50,
  });

  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        <Text
          text="Draggable Text"
          x={position.x}
          y={position.y}
          draggable
          fill={isDragging ? 'green' : 'black'}
          onDragStart={() => {
            setIsDragging(true);
          }}
          onDragEnd={(e) => {
            setIsDragging(false);
            setPosition({
              x: e.target.x(),
              y: e.target.y(),
            });
          }}
        />
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Getting Shape Intersection
DESCRIPTION: Gets visible intersection shape at the provided coordinates.

LANGUAGE: javascript
CODE:
var shape = layer.getIntersection({x: 50, y: 50});

----------------------------------------

TITLE: Creating Konva Stage with React
DESCRIPTION: This snippet shows how to create a Konva stage using React components. It creates a stage with a circle and uses React state to manage the circle's color, which changes randomly when clicked.

LANGUAGE: jsx
CODE:
import { Stage, Layer, Circle } from 'react-konva';
import { useState } from 'react';

const App = () => {
  const [color, setColor] = useState('red');

  const handleClick = () => {
    setColor(Konva.Util.getRandomColor());
  };

  return (
    <Stage width={400} height={400}>
      <Layer>
        <Circle
          x={100}
          y={100}
          radius={50}
          fill={color}
          stroke="black"
          strokeWidth={3}
          onClick={handleClick}
        />
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Configuring File Structure for Docusaurus Blog Posts
DESCRIPTION: Example file naming conventions for Docusaurus blog posts showing how to structure dates and content. Demonstrates both single file and folder-based approaches.

LANGUAGE: markdown
CODE:
- `2019-05-30-welcome.md`
- `2019-05-30-welcome/index.md`

----------------------------------------

TITLE: Implementing Blend Mode with Konva in React
DESCRIPTION: This snippet shows how to create a Konva stage with a text and a draggable rectangle using XOR blend mode in a React component. It uses the react-konva library to create Konva components within a React application.

LANGUAGE: jsx
CODE:
import { Stage, Layer, Text, Rect } from 'react-konva';

const App = () => {
  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        <Text
          text="Text Shadow!"
          fontFamily="Calibri"
          fontSize={40}
          x={20}
          y={20}
          fill="green"
          shadowColor="white"
          shadowOffset={{ x: 10, y: 10 }}
        />
        <Rect
          x={50}
          y={50}
          width={100}
          height={100}
          fill="red"
          draggable={true}
          globalCompositeOperation="xor"
        />
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Setting Rectangle Corner Radius
DESCRIPTION: Examples of getting and setting the corner radius property of a rectangle

LANGUAGE: javascript
CODE:
// get corner radius
var cornerRadius = rect.cornerRadius();

// set corner radius
rect.cornerRadius(10);

// set different corner radius values
// top-left, top-right, bottom-right, bottom-left
rect.cornerRadius([0, 10, 20, 30]);

----------------------------------------

TITLE: Rendering SVG on Canvas with Konva and canvg in React
DESCRIPTION: This React component demonstrates how to render an SVG image on a Konva canvas using both native rendering and the canvg library. It uses the useImage hook from react-konva-utils for native rendering and dynamically loads the canvg library for the second rendering method.

LANGUAGE: javascript
CODE:
import React from 'react';
import { Stage, Layer, Image } from 'react-konva';
import { useImage } from 'react-konva-utils';

const SOURCE = 'https://konvajs.org/assets/tiger.svg';

const App = () => {
  const [nativeImage] = useImage(SOURCE);
  const [canvgImage, setCanvgImage] = React.useState(null);

  React.useEffect(() => {
    // Load canvg library and render SVG
    const script = document.createElement('script');
    script.src = 'https://cdn.jsdelivr.net/npm/canvg/dist/browser/canvg.min.js';
    script.onload = () => {
      const canvas = document.createElement('canvas');
      canvg(canvas, SOURCE, {
        renderCallback: function () {
          setCanvgImage(canvas);
        },
      });
    };
    document.head.appendChild(script);

    return () => {
      script.remove();
    };
  }, []);

  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        {nativeImage && (
          <Image
            image={nativeImage}
            width={150}
            height={150}
          />
        )}
        {canvgImage && (
          <Image
            image={canvgImage}
            x={200}
            width={150}
            height={150}
          />
        )}
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Vue Implementation of Window Frame Designer
DESCRIPTION: Vue 3 composition API implementation using v-konva with reactive properties and computed values.

LANGUAGE: vue
CODE:
<template>
  <div ref="containerRef" style="position: relative; width: 100%; height: 100%">
    // ... rest of Vue implementation

----------------------------------------

TITLE: Embedding CodeSandbox Demo of Seats Reservation Widget
DESCRIPTION: This code snippet embeds a CodeSandbox demo of the seats reservation widget. It uses an iframe to display the interactive demo, with specific styling applied for proper rendering within the page.

LANGUAGE: JSX
CODE:
<iframe 
  src="https://codesandbox.io/embed/github/konvajs/site/tree/master/react-demos/seats-reservation?hidenavigation=1&view=split&fontsize=10" 
  style={{
    width: "100%",
    height: "500px",
    border: 0,
    borderRadius: "4px",
    overflow: "hidden"
  }}
  sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"
/>

----------------------------------------

TITLE: Selecting Shapes by Type with Vue and Konva
DESCRIPTION: Vue implementation of shape selection using vue-konva. Uses ref and onMounted to access the layer and find circles for animation after component mount.

LANGUAGE: javascript
CODE:
<template>
  <v-stage :config="stageSize">
    <v-layer ref="layerRef">
      <v-circle :config="circle1Config" />
      <v-circle :config="circle2Config" />
      <v-rect :config="rectConfig" />
    </v-layer>
  </v-stage>
</template>

<script setup>
import { ref, onMounted } from 'vue';
import Konva from 'konva';

const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight
};

const circle1Config = {
  x: 50,
  y: window.innerHeight / 2,
  radius: 30,
  fill: 'red'
};

const circle2Config = {
  x: 150,
  y: window.innerHeight / 2,
  radius: 30,
  fill: 'green'
};

const rectConfig = {
  x: 250,
  y: window.innerHeight / 2 - 25,
  width: 50,
  height: 50,
  fill: 'blue'
};

const layerRef = ref(null);

onMounted(() => {
  // find all circles by type and animate them
  const circles = layerRef.value.getNode().find('Circle');
  circles.forEach(circle => {
    circle.to({
      duration: 1,
      scale: { x: 1.5, y: 1.5 },
      easing: Konva.Easings.EaseInOut
    });
  });
});
</script>

----------------------------------------

TITLE: Accessing Native Canvas Context - React Implementation
DESCRIPTION: Shows how to integrate native canvas context with React-Konva components. Uses useMemo hook for canvas creation and manages draggable state with useState.

LANGUAGE: jsx
CODE:
import { Stage, Layer, Image } from 'react-konva';
import { useMemo, useState } from 'react';

const App = () => {
  const [position, setPosition] = useState({ x: 50, y: 50 });

  const canvas = useMemo(() => {
    const canvas = document.createElement('canvas');
    canvas.width = 200;
    canvas.height = 150;
    const ctx = canvas.getContext('2d');

    ctx.fillStyle = 'blue';
    ctx.fillRect(5, 5, canvas.width - 10, canvas.height / 2);
    ctx.fillStyle = 'red';
    ctx.beginPath();
    ctx.arc(100, 75, 50, 0, 2 * Math.PI);
    ctx.fill();

    return canvas;
  }, []);

  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        <Image
          x={position.x}
          y={position.y}
          image={canvas}
          draggable
          onDragEnd={(e) => {
            setPosition({
              x: e.target.x(),
              y: e.target.y(),
            });
          }}
        />
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Setting Custom Pixel Ratio in Konva
DESCRIPTION: Overrides the automatically detected pixel ratio with a custom value. Must be set before any component initialization.

LANGUAGE: javascript
CODE:
Konva.pixelRatio = 1;

----------------------------------------

TITLE: Implementing Fill Styles with Konva in Vanilla JavaScript
DESCRIPTION: This snippet demonstrates how to create and manipulate different fill styles for shapes using Konva in vanilla JavaScript. It includes examples of solid color, pattern, linear gradient, and radial gradient fills, along with interactive mouse events.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

function loadImages(sources, callback) {
  var images = {};
  var loadedImages = 0;
  var numImages = 0;
  // get num of sources
  for (var src in sources) {
    numImages++;
  }
  for (var src in sources) {
    images[src] = new Image();
    images[src].onload = function () {
      if (++loadedImages >= numImages) {
        callback(images);
      }
    };
    images[src].src = sources[src];
  }
}
function draw(images) {
  var width = window.innerWidth;
  var height = window.innerHeight;

  var stage = new Konva.Stage({
    container: 'container',
    width: width,
    height: height,
  });
  var layer = new Konva.Layer();

  var colorPentagon = new Konva.RegularPolygon({
    x: 80,
    y: stage.height() / 2,
    sides: 5,
    radius: 70,
    fill: 'red',
    stroke: 'black',
    strokeWidth: 4,
    draggable: true,
  });

  var patternPentagon = new Konva.RegularPolygon({
    x: 220,
    y: stage.height() / 2,
    sides: 5,
    radius: 70,
    fillPatternImage: images.darthVader,
    fillPatternOffset: { x: -220, y: 70 },
    stroke: 'black',
    strokeWidth: 4,
    draggable: true,
  });

  var linearGradPentagon = new Konva.RegularPolygon({
    x: 360,
    y: stage.height() / 2,
    sides: 5,
    radius: 70,
    fillLinearGradientStartPoint: { x: -50, y: -50 },
    fillLinearGradientEndPoint: { x: 50, y: 50 },
    fillLinearGradientColorStops: [0, 'red', 1, 'yellow'],
    stroke: 'black',
    strokeWidth: 4,
    draggable: true,
  });

  var radialGradPentagon = new Konva.RegularPolygon({
    x: 500,
    y: stage.height() / 2,
    sides: 5,
    radius: 70,
    fillRadialGradientStartPoint: { x: 0, y: 0 },
    fillRadialGradientStartRadius: 0,
    fillRadialGradientEndPoint: { x: 0, y: 0 },
    fillRadialGradientEndRadius: 70,
    fillRadialGradientColorStops: [0, 'red', 0.5, 'yellow', 1, 'blue'],
    stroke: 'black',
    strokeWidth: 4,
    draggable: true,
  });

  /*
    * bind listeners
    */
  colorPentagon.on('mouseover touchstart', function () {
    this.fill('blue');
  });

  colorPentagon.on('mouseout touchend', function () {
    this.fill('red');
  });

  patternPentagon.on('mouseover touchstart', function () {
    this.fillPatternImage(images.yoda);
    this.fillPatternOffset({ x: -100, y: 70 });
  });

  patternPentagon.on('mouseout touchend', function () {
    this.fillPatternImage(images.darthVader);
    this.fillPatternOffset({ x: -220, y: 70 });
  });

  linearGradPentagon.on('mouseover touchstart', function () {
    this.fillLinearGradientStartPoint({ x: -50 });
    this.fillLinearGradientEndPoint({ x: 50 });
    this.fillLinearGradientColorStops([0, 'green', 1, 'yellow']);
  });

  linearGradPentagon.on('mouseout touchend', function () {
    // set multiple properties at once with setAttrs
    this.setAttrs({
      fillLinearGradientStartPoint: { x: -50, y: -50 },
      fillLinearGradientEndPoint: { x: 50, y: 50 },
      fillLinearGradientColorStops: [0, 'red', 1, 'yellow'],
    });
  });

  radialGradPentagon.on('mouseover touchstart', function () {
    this.fillRadialGradientColorStops([
      0,
      'red',
      0.5,
      'yellow',
      1,
      'green',
    ]);
  });

  radialGradPentagon.on('mouseout touchend', function () {
    // set multiple properties at once with setAttrs
    this.setAttrs({
      fillRadialGradientStartPoint: 0,
      fillRadialGradientStartRadius: 0,
      fillRadialGradientEndPoint: 0,
      fillRadialGradientEndRadius: 70,
      fillRadialGradientColorStops: [0, 'red', 0.5, 'yellow', 1, 'blue'],
    });
  });

  layer.add(colorPentagon);
  layer.add(patternPentagon);
  layer.add(linearGradPentagon);
  layer.add(radialGradPentagon);
  stage.add(layer);
}
var sources = {
  darthVader: 'https://konvajs.org/assets/darth-vader.jpg',
  yoda: 'https://konvajs.org/assets/yoda.jpg',
};

loadImages(sources, function (images) {
  draw(images);
});

----------------------------------------

TITLE: Creating a Konva Shape
DESCRIPTION: Basic usage showing how to instantiate a new Konva.Shape

LANGUAGE: javascript
CODE:
new Konva.Shape(config)

----------------------------------------

TITLE: Optimizing Canvas Performance with Konva in Vanilla JavaScript
DESCRIPTION: Creates a performance comparison between interactive and non-interactive circles on canvas using Konva. Demonstrates how disabling event listening can improve performance when handling large numbers of shapes.

LANGUAGE: javascript
CODE:
const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight,
});

const layer = new Konva.Layer();
stage.add(layer);

// Create many circles with listening enabled
for (let i = 0; i < 100; i++) {
  const circle = new Konva.Circle({
    x: Math.random() * stage.width(),
    y: Math.random() * stage.height(),
    radius: 20,
    fill: 'blue',
    opacity: 0.5,
    // Enable event detection (default)
    listening: true,
  });
  
  // Add hover effect
  circle.on('mouseover', function() {
    this.fill('red');
  });
  
  circle.on('mouseout', function() {
    this.fill('blue');
  });
  
  layer.add(circle);
}

// Create many circles with listening disabled
for (let i = 0; i < 1000; i++) {
  const circle = new Konva.Circle({
    x: Math.random() * stage.width(),
    y: Math.random() * stage.height(),
    radius: 20,
    fill: 'green',
    opacity: 0.5,
    // Disable event detection for better performance
    listening: false,
  });
  layer.add(circle);
}

----------------------------------------

TITLE: Implementing Image Zoom with Vue and Konva
DESCRIPTION: Creates a zoomable image component using Vue 3 with vue-konva. Utilizes Vue's composition API with refs to manage state for scaling and position. Implements mouse event handlers for zoom functionality.

LANGUAGE: javascript
CODE:
<template>
  <v-stage :config="stageSize">
    <v-layer
      :config="{
        scaleX: scale,
        scaleY: scale,
        x: position.x,
        y: position.y
      }"
      @mouseenter="handleMouseEnter"
      @mousemove="handleMouseMove"
      @mouseleave="handleMouseLeave"
    >
      <v-image
        v-if="image"
        :config="{
          image: image,
          width: stageSize.width,
          height: stageSize.height
        }"
      />
    </v-layer>
  </v-stage>
</template>

<script setup>
import { ref, onMounted } from 'vue';
import { useImage } from 'vue-konva';

const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight
};

const scale = ref(1);
const position = ref({ x: 0, y: 0 });
const [image] = useImage('https://konvajs.org/assets/space.jpg');

const handleMouseEnter = () => {
  scale.value = 2;
};

const handleMouseMove = (e) => {
  const stage = e.target.getStage();
  const pos = stage.getPointerPosition();
  position.value = {
    x: -pos.x,
    y: -pos.y
  };
};

const handleMouseLeave = () => {
  scale.value = 1;
  position.value = { x: 0, y: 0 };
};
</script>

----------------------------------------

TITLE: React-Konva Undo/Redo Implementation
DESCRIPTION: A React component that implements undo/redo functionality for a draggable rectangle using React-Konva. Uses React.useState for position state and React.useRef to maintain history of position changes without triggering re-renders. Includes handlers for undo, redo, and drag operations.

LANGUAGE: jsx
CODE:
import React, { Component } from 'react';
import { Stage, Layer, Rect, Text } from 'react-konva';


const App = () => {
  const [position, setPosition] = React.useState({ x: 20, y: 20 });
  // We use refs to keep history to avoid unnecessary re-renders
  const history = React.useRef([{ x: 20, y: 20 }]);
  const historyStep = React.useRef(0);

  const handleUndo = () => {
    if (historyStep.current === 0) {
      return;
    }
    historyStep.current -= 1;
    const previous = history.current[historyStep.current];
    setPosition(previous);
  };

  const handleRedo = () => {
    if (historyStep.current === history.current.length - 1) {
      return;
    }
    historyStep.current += 1;
    const next = history.current[historyStep.current];
    setPosition(next);
  };

  const handleDragEnd = (e) => {
    // Remove all states after current step
    history.current = history.current.slice(0, historyStep.current + 1);
    const pos = {
      x: e.target.x(),
      y: e.target.y(),
    };
    // Push the new state
    history.current = history.current.concat([pos]);
    historyStep.current += 1;
    setPosition(pos);
  };

  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        <Text text="undo" onClick={handleUndo} />
        <Text text="redo" x={40} onClick={handleRedo} />
        <Rect
          x={position.x}
          y={position.y}
          width={50}
          height={50}
          fill="black"
          draggable
          onDragEnd={handleDragEnd}
        />
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Creating Circle Shape with Vue-Konva
DESCRIPTION: This snippet demonstrates how to create a circle shape using Vue-Konva. It uses v-stage, v-layer, and v-circle components to render a circle with specified properties defined in the script section.

LANGUAGE: vue
CODE:
<template>
  <v-stage :config="stageSize">
    <v-layer>
      <v-circle :config="circleConfig" />
    </v-layer>
  </v-stage>
</template>

<script setup>
const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight
};

const circleConfig = {
  x: window.innerWidth / 2,
  y: window.innerHeight / 2,
  radius: 70,
  fill: 'red',
  stroke: 'black',
  strokeWidth: 4
};
</script>

----------------------------------------

TITLE: Initializing Konva.Canvas in JavaScript
DESCRIPTION: Constructor for the Konva.Canvas class. It creates a wrapper around the native canvas element with specified configuration options.

LANGUAGE: javascript
CODE:
new Konva.Canvas(config)

----------------------------------------

TITLE: Implementing Transform Events with Konva in Vanilla JavaScript
DESCRIPTION: This snippet demonstrates how to set up a Konva stage with a rectangle and a transformer, and how to attach transform event listeners to both the transformer and the rectangle. It uses the Konva library to create interactive graphics on an HTML5 canvas.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const width = window.innerWidth;
const height = window.innerHeight;

const stage = new Konva.Stage({
container: 'container',
width: width,
height: height,
});

const layer = new Konva.Layer();
stage.add(layer);

const rect = new Konva.Rect({
x: 50,
y: 50,
width: 100,
height: 100,
fill: 'yellow',
stroke: 'black',
draggable: true,
});
layer.add(rect);

const tr = new Konva.Transformer({
nodes: [rect],
});
layer.add(tr);

tr.on('transformstart', () => {
console.log('transform start');
});

tr.on('transform', () => {
console.log('transforming');
});

tr.on('transformend', () => {
console.log('transform end');
});

rect.on('transformstart', () => {
console.log('rect transform start');
});

rect.on('transform', () => {
console.log('rect transforming');
});

rect.on('transformend', () => {
console.log('rect transform end');
});

----------------------------------------

TITLE: Implementing Konva Stage in Vue
DESCRIPTION: Demonstrates creating a Konva stage with a hexagon in Vue using v-stage components. Uses Vue's reactive system to manage hexagon properties and handle click events.

LANGUAGE: javascript
CODE:
<template>
  <v-stage :config="stageSize">
    <v-layer>
      <v-regular-polygon
        :config="hexagonConfig"
        @click="handleClick"
      />
    </v-layer>
  </v-stage>
</template>

<script setup>
import { ref } from 'vue';
import Konva from 'konva';

const stageSize = {
  width: 578,
  height: 200
};

const hexagonConfig = ref({
  x: 100,
  y: 100,
  sides: 6,
  radius: 70,
  fill: 'red',
  stroke: 'black',
  strokeWidth: 4
});

const handleClick = () => {
  hexagonConfig.value = {
    ...hexagonConfig.value,
    fill: Konva.Util.getRandomColor()
  };
};
</script>

----------------------------------------

TITLE: Implementing Sepia Filter with React-Konva
DESCRIPTION: Shows how to implement a sepia filter in a React application using react-konva. Uses hooks for image loading and ref management, demonstrating proper handling of image caching and filter application in React context.

LANGUAGE: javascript
CODE:
import { Stage, Layer, Image } from 'react-konva';
import { useRef, useEffect } from 'react';
import useImage from 'use-image';

const App = () => {
  const [image] = useImage('https://konvajs.org/assets/lion.png', 'anonymous');
  const imageRef = useRef(null);

  useEffect(() => {
    if (image && imageRef.current) {
      imageRef.current.cache();
    }
  }, [image]);

  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        {image && (
          <Image
            ref={imageRef}
            x={50}
            y={50}
            image={image}
            draggable
            filters={[Konva.Filters.Sepia]}
          />
        )}
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: React Component for Editable Text in Konva
DESCRIPTION: React implementation of editable text using react-konva and react-konva-utils. Features a separate TextEditor component for handling text editing functionality with proper React state management.

LANGUAGE: jsx
CODE:
import { Stage, Layer, Text, Transformer } from 'react-konva';
import { Html } from 'react-konva-utils';
import { useEffect, useRef, useState, useCallback } from 'react';

// ... [rest of React implementation]

----------------------------------------

TITLE: Implementing Oscillating Blobs with React and react-konva
DESCRIPTION: This snippet creates an interactive animation of oscillating blobs using react-konva in a React component. It generates 6 draggable blobs with random positions, colors, and opacities, and animates their tension using a sine wave function. The component uses React hooks for state management and animation.

LANGUAGE: jsx
CODE:
import { Stage, Layer, Line } from 'react-konva';
import { useState, useEffect } from 'react';

const COLORS = ['red', 'orange', 'yellow', 'green', 'blue', 'purple'];

const App = () => {
  const [blobs, setBlobs] = useState([]);
  const [tension, setTension] = useState(0);

  useEffect(() => {
    // Generate initial blobs
    const newBlobs = COLORS.map((color) => {
      const points = [];
      for (let i = 0; i < 5; i++) {
        points.push(window.innerWidth * Math.random());
        points.push(window.innerHeight * Math.random());
      }
      return {
        points,
        fill: color,
        opacity: Math.random(),
        x: 0,
        y: 0
      };
    });
    setBlobs(newBlobs);
  }, []);

  useEffect(() => {
    const period = 2000;
    const centerTension = 0;
    const amplitude = 1;

    const interval = setInterval(() => {
      const time = new Date().getTime();
      setTension(
        amplitude * Math.sin((time * 2 * Math.PI) / period) + centerTension
      );
    }, 1000 / 60);

    return () => clearInterval(interval);
  }, []);

  const handleDragEnd = (e, index) => {
    const newBlobs = [...blobs];
    newBlobs[index] = {
      ...newBlobs[index],
      x: e.target.x(),
      y: e.target.y()
    };
    setBlobs(newBlobs);
  };

  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        {blobs.map((blob, i) => (
          <Line
            key={i}
            points={blob.points}
            fill={blob.fill}
            stroke="black"
            strokeWidth={2}
            tension={tension}
            opacity={blob.opacity}
            draggable
            closed
            x={blob.x}
            y={blob.y}
            onDragEnd={(e) => handleDragEnd(e, i)}
          />
        ))}
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Creating a Ring Shape with Vue-Konva
DESCRIPTION: This snippet demonstrates how to create a ring shape using Vue-Konva. It uses v-stage and v-layer components to set up the canvas, and v-ring to render the ring shape with specified configuration.

LANGUAGE: vue
CODE:
<template>
  <v-stage :config="stageSize">
    <v-layer>
      <v-ring :config="ringConfig" />
    </v-layer>
  </v-stage>
</template>

<script setup>
const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight
};

const ringConfig = {
  x: window.innerWidth / 2,
  y: window.innerHeight / 2,
  innerRadius: 40,
  outerRadius: 70,
  fill: 'yellow',
  stroke: 'black',
  strokeWidth: 4
};
</script>

----------------------------------------

TITLE: Configuring React iFrame Component
DESCRIPTION: React component configuration for embedding a CodeSandbox demo of the window frame designer. The iframe includes custom styling and sandbox security attributes.

LANGUAGE: jsx
CODE:
<iframe 
  src="https://codesandbox.io/embed/github/konvajs/site/tree/master/react-demos/window-frame-design-app?hidenavigation=1&view=split&fontsize=10" 
  style={{
    width: "100%",
    height: "500px",
    border: 0,
    borderRadius: "4px",
    overflow: "hidden"
  }}
  sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"
/>

----------------------------------------

TITLE: Installing React Konva Dependencies
DESCRIPTION: Command to install required npm packages for using react-konva library with React applications.

LANGUAGE: bash
CODE:
npm install react-konva konva --save

----------------------------------------

TITLE: Applying Blur Filter to Image with Konva in Vue.js
DESCRIPTION: This snippet demonstrates how to create a Konva stage, add an image, apply a blur filter, and use a slider to adjust the blur radius in a Vue.js component. It uses the vue-konva library and the useImage composable for loading the image.

LANGUAGE: vue
CODE:
<template>
  <div>
    <v-stage :config="stageSize">
      <v-layer>
        <v-image
          ref="imageNode"
          :config="{
            x: 50,
            y: 50,
            image: image,
            draggable: true,
            filters: [Konva.Filters.Blur],
            blurRadius: blurRadius,
          }"
        />
      </v-layer>
    </v-stage>
    <input
      type="range"
      min="0"
      max="40"
      :value="blurRadius"
      @input="handleSlider"
      style="position: absolute; top: 20px; left: 20px"
    />
  </div>
</template>

<script setup>
import { ref, watch, nextTick } from 'vue';
import { useImage } from 'vue-konva';
import Konva from 'konva';

const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight,
};

const blurRadius = ref(10);
const imageNode = ref(null);
const [image] = useImage('https://konvajs.org/assets/lion.png', 'anonymous');

watch(image, async (newImage) => {
  if (newImage) {
    await nextTick();
    imageNode.value.getNode().cache();
  }
});

const handleSlider = (e) => {
  blurRadius.value = parseInt(e.target.value);
};
</script>

----------------------------------------

TITLE: Implementing Canvas Filters with React-Konva
DESCRIPTION: Complete example showing how to apply Blur and Noise filters to Image and Rectangle components in React-Konva. Demonstrates proper caching techniques, filter application, and handling filter updates on property changes.

LANGUAGE: jsx
CODE:
import React from 'react';
import Konva from 'konva';
import { Stage, Layer, Rect, Image } from 'react-konva';
import useImage from 'use-image';

// Example of functional component with image filter
const FilterImage = () => {
  const [image] = useImage('https://konvajs.org/assets/lion.png', 'anonymous');
  const imageRef = React.useRef();

  // when image is loaded we need to cache the shape
  React.useEffect(() => {
    if (image) {
      // you many need to reapply cache on some props changes like shadow, stroke, etc.
      imageRef.current.cache();
    }
  }, [image]);

  return (
    <Image
      ref={imageRef}
      x={10}
      y={10}
      image={image}
      filters={[Konva.Filters.Blur]}
      blurRadius={10}
    />
  );
};

// Example of class component with noise filter
// Try to click on rect to see color updates
const FilterRect = () => {
  const [color, setColor] = React.useState('green');
  const rectRef = React.useRef();

  React.useEffect(() => {
    if (rectRef.current) {
      rectRef.current.cache();
    }
  }, []);

  const handleClick = () => {
    setColor(Konva.Util.getRandomColor());
    // recache shape when we updated it
    rectRef.current.cache();
  };

  return (
    <Rect
      filters={[Konva.Filters.Noise]}
      noise={1}
      x={200}
      y={10}
      width={50}
      height={50}
      fill={color}
      shadowBlur={10}
      ref={rectRef}
      onClick={handleClick}
    />
  );
};

const App = () => {
  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        <FilterImage />
        <FilterRect />
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Creating Star Shape with React-Konva
DESCRIPTION: Shows how to implement a star shape using React-Konva components. Uses declarative syntax to define stage, layer, and star with the same customization options.

LANGUAGE: javascript
CODE:
import { Stage, Layer, Star } from 'react-konva';

const App = () => {
  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        <Star
          x={window.innerWidth / 2}
          y={window.innerHeight / 2}
          numPoints={5}
          innerRadius={30}
          outerRadius={70}
          fill="yellow"
          stroke="black"
          strokeWidth={4}
        />
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Vue 3 Implementation of Custom Hit Detection with vue-konva
DESCRIPTION: Vue 3 implementation of custom hit detection using vue-konva components. Uses composition API and setup script to manage component state and event handling for hit detection visualization.

LANGUAGE: vue
CODE:
<template>
  <div>
    <v-stage :config="stageSize" ref="stageRef">
      <v-layer ref="layerRef">
        <v-star
          :config="starConfig"
          @mouseover="handleStarEvent"
        />
        <v-line
          :config="lineConfig"
          @mouseover="handleLineEvent"
        />
      </v-layer>
    </v-stage>
  </div>
</template>

<script setup>
const starConfig = {
  x: window.innerWidth / 4,
  y: window.innerHeight / 2,
  numPoints: 5,
  innerRadius: 40,
  outerRadius: 70,
  fill: 'red',
  stroke: 'black',
  strokeWidth: 4,
  hitFunc: function(context, shape) {
    context.beginPath();
    context.arc(0, 0, 70, 0, Math.PI * 2, true);
    context.closePath();
    context.fillStrokeShape(shape);
  }
};</script>

----------------------------------------

TITLE: Creating Star Shape with Vanilla JavaScript and Konva
DESCRIPTION: Demonstrates how to create a star shape using vanilla JavaScript and Konva.js. Creates a stage, layer, and star with customizable properties like radius, points, and styling.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight
});

const layer = new Konva.Layer();
stage.add(layer);

const star = new Konva.Star({
  x: stage.width() / 2,
  y: stage.height() / 2,
  numPoints: 5,
  innerRadius: 30,
  outerRadius: 70,
  fill: 'yellow',
  stroke: 'black',
  strokeWidth: 4
});

layer.add(star);

----------------------------------------

TITLE: Creating a Konva Image
DESCRIPTION: Creates a new Konva.Image instance with configuration options

LANGUAGE: javascript
CODE:
new Konva.Image(config)

----------------------------------------

TITLE: Initializing Konva Tween Animation in JavaScript
DESCRIPTION: Constructor for creating a new Tween animation in Konva. Tweens allow animating a node between its current state and a new state. By default, tweens use linear easing, but custom easing functions can be specified using Konva.Easings.

LANGUAGE: javascript
CODE:
new Konva.Tween(config)

----------------------------------------

TITLE: Setting Wedge Angle
DESCRIPTION: Example showing how to get and set the angle of a wedge in degrees

LANGUAGE: javascript
CODE:
// get angle
var angle = wedge.angle();

// set angle
wedge.angle(20);

----------------------------------------

TITLE: Implementing Image Mask Filter with React and Konva.js
DESCRIPTION: Implements the same image masking functionality using React and react-konva components. Uses hooks for state management and refs for accessing the image node. Includes a slider control for adjusting the mask threshold.

LANGUAGE: javascript
CODE:
const App = () => {
  const [threshold, setThreshold] = useState(10);
  const [image] = useImage('https://konvajs.org/assets/lion.png', 'anonymous');
  const imageRef = useRef(null);

  useEffect(() => {
    if (image) {
      imageRef.current.cache();
    }
  }, [image]);

  return (
    <>
      <Stage width={window.innerWidth} height={window.innerHeight}>
        <Layer>
          <Image
            ref={imageRef}
            x={50}
            y={50}
            image={image}
            draggable
            filters={[Konva.Filters.Mask]}
            threshold={threshold}
          />
        </Layer>
      </Stage>
      <input
        type="range"
        min="0"
        max="255"
        value={threshold}
        onChange={(e) => setThreshold(parseInt(e.target.value))}
        style={{ position: 'absolute', top: '20px', left: '20px' }}
      />
    </>
  );
};

----------------------------------------

TITLE: React Implementation of Window Frame Designer
DESCRIPTION: React-based implementation using react-konva with hooks and components for better state management and reusability.

LANGUAGE: jsx
CODE:
import { Stage, Layer, Group, Line, Rect, Shape, Label, Tag, Text } from 'react-konva';
import { useState, useEffect, useRef, useCallback, useMemo, useReducer } from 'react';
// ... rest of React implementation

----------------------------------------

TITLE: Implementing Edge-Scroll with Vue-Konva
DESCRIPTION: Vue 3 implementation of edge-scrolling using Vue-Konva components. Uses composition API with refs and computed properties to manage stage position and scrolling behavior.

LANGUAGE: vue
CODE:
<template>
  <v-stage
    :config="stageConfig"
    ref="stageRef"
  >
    <v-layer>
      <v-circle
        v-for="(node, i) in nodes"
        :key="i"
        :config="{
          x: node.x,
          y: node.y,
          radius: 40,
          fill: 'red',
          stroke: 'black',
          draggable: true,
          onDragStart: handleDragStart,
          onDragEnd: handleDragEnd,
        }"
      />
    </v-layer>
  </v-stage>
</template>

<script setup>
import { ref, computed, onMounted, onUnmounted } from 'vue';

const NUMBER = 100;
const stageRef = ref(null);
const stagePos = ref({ x: 0, y: 0 });
const nodes = ref([]);
let scrollInterval = null;
let draggedNode = null;

const stageConfig = computed(() => ({
  width: window.innerWidth,
  height: window.innerHeight,
  x: stagePos.value.x,
  y: stagePos.value.y,
}));

function generateNodes() {
  return Array.from({ length: NUMBER }, () => ({
    x: window.innerWidth * (Math.random() * 2 - 1),
    y: window.innerHeight * (Math.random() * 2 - 1),
  }));
}

const handleDragStart = (e) => {
  draggedNode = e.target;
  const duration = 1000 / 60;
  scrollInterval = setInterval(() => {
    const stage = stageRef.value.getNode();
    const pos = stage.getPointerPosition();
    if (!pos) return;

    const offset = 100;
    let newX = stagePos.value.x;
    let newY = stagePos.value.y;
    let moved = false;

    if (pos.x < offset) {
      newX += 2;
      draggedNode.x(draggedNode.x() - 2);
      moved = true;
    } else if (pos.x > stage.width() - offset) {
      newX -= 2;
      draggedNode.x(draggedNode.x() + 2);
      moved = true;
    }

    if (pos.y < offset) {
      newY += 2;
      draggedNode.y(draggedNode.y() - 2);
      moved = true;
    } else if (pos.y > stage.height() - offset) {
      newY -= 2;
      draggedNode.y(draggedNode.y() + 2);
      moved = true;
    }

    if (moved) {
      stagePos.value = { x: newX, y: newY };
    }
  }, duration);
};

const handleDragEnd = () => {
  draggedNode = null;
  if (scrollInterval) {
    clearInterval(scrollInterval);
    scrollInterval = null;
  }
};

onMounted(() => {
  nodes.value = generateNodes();
});

onUnmounted(() => {
  if (scrollInterval) {
    clearInterval(scrollInterval);
  }
});
</script>

----------------------------------------

TITLE: Creating Arc Shape with Vue-Konva
DESCRIPTION: Shows how to create the arc shape using Vue-Konva components. Uses Vue's template syntax and script setup to define the stage and arc configurations.

LANGUAGE: vue
CODE:
<template>
  <v-stage :config="stageSize">
    <v-layer>
      <v-arc :config="arcConfig" />
    </v-layer>
  </v-stage>
</template>

<script setup>
const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight
};

const arcConfig = {
  x: window.innerWidth / 2,
  y: window.innerHeight / 2,
  innerRadius: 40,
  outerRadius: 70,
  angle: 60,
  fill: 'yellow',
  stroke: 'black',
  strokeWidth: 4
};
</script>

----------------------------------------

TITLE: Creating Blobs with Konva in JavaScript
DESCRIPTION: This snippet shows how to create a blob shape using Konva by combining the closed and tension properties. It initializes a stage, adds a layer, and creates a closed, curved blob shape.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight
});

const layer = new Konva.Layer();
stage.add(layer);

const blob = new Konva.Line({
  points: [23, 20, 23, 160, 70, 93, 150, 109, 290, 139, 270, 93],
  fill: '#00D2FF',
  stroke: 'black',
  strokeWidth: 5,
  closed: true,
  tension: 0.3
});

layer.add(blob);

----------------------------------------

TITLE: Configuring Hit Detection During Drag in Konva
DESCRIPTION: Enables or disables hit detection while dragging. Default is false for performance reasons, but can be enabled to check intersections during drag operations.

LANGUAGE: javascript
CODE:
Konva.hitOnDragEnabled = true;

----------------------------------------

TITLE: Adding Circles on Click Using Relative Mouse Position in Vanilla Konva
DESCRIPTION: This snippet demonstrates how to create a Konva stage with nested, transformed nodes and add circles to a group based on the relative mouse position. It uses the `getRelativePointerPosition()` method to calculate the correct position within the transformed group.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

var width = window.innerWidth;
var height = window.innerHeight;

var stage = new Konva.Stage({
  container: 'container',
  width: width,
  height: height,
  x: 20,
  y: 50,
});

var layer = new Konva.Layer({
  scaleX: 1.2,
  scaleY: 0.8,
  rotation: 5,
});
stage.add(layer);

var group = new Konva.Group({
  x: 30,
  rotation: 10,
  scaleX: 1.5,
});
layer.add(group);

var text = new Konva.Text({
  text: 'Click on the canvas to draw a circle',
  fontSize: 20,
});
group.add(text);

stage.on('click', function () {
  var pos = group.getRelativePointerPosition();
  var shape = new Konva.Circle({
    x: pos.x,
    y: pos.y,
    fill: 'red',
    radius: 20,
  });

  group.add(shape);
});

----------------------------------------

TITLE: Implementing Stage Events with React and Konva
DESCRIPTION: React implementation of stage event handling using react-konva. Creates a stage with a circle and text display, managing click event state using React hooks. Shows how to handle click events in a React component context.

LANGUAGE: jsx
CODE:
import { Stage, Layer, Circle, Text } from 'react-konva';
import { useState } from 'react';

const App = () => {
  const [message, setMessage] = useState('');

  const handleStageClick = (e) => {
    if (e.target === e.target.getStage()) {
      setMessage('clicked on stage');
      return;
    }
    setMessage('clicked on ' + e.target.name());
  };

  return (
    <Stage
      width={window.innerWidth}
      height={window.innerHeight}
      onClick={handleStageClick}
    >
      <Layer>
        <Text
          x={10}
          y={10}
          fontFamily="Calibri"
          fontSize={24}
          text={message}
          fill="black"
        />
        <Circle
          x={window.innerWidth / 2}
          y={window.innerHeight / 2}
          radius={70}
          fill="red"
          stroke="black"
          strokeWidth={4}
          name="circle"
        />
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Creating a Group of Shapes with Konva in Vue
DESCRIPTION: This snippet illustrates how to create a draggable group containing a circle and a rectangle using Konva in a Vue component. It uses Vue 3's composition API and vue-konva to render Konva components as Vue elements.

LANGUAGE: vue
CODE:
<template>
  <v-stage :config="stageSize">
    <v-layer>
      <v-group :config="groupConfig">
        <v-circle :config="circleConfig" />
        <v-rect :config="rectConfig" />
      </v-group>
    </v-layer>
  </v-stage>
</template>

<script setup>
const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight
};

const groupConfig = {
  x: 50,
  y: 50,
  draggable: true
};

const circleConfig = {
  x: 0,
  y: 0,
  radius: 30,
  fill: 'red'
};

const rectConfig = {
  x: 20,
  y: 20,
  width: 100,
  height: 50,
  fill: 'green'
};
</script>

----------------------------------------

TITLE: Implementing Pointer Events with React and Konva
DESCRIPTION: React implementation of the pointer events demo using react-konva. Uses hooks for state management and refs for accessing stage properties.

LANGUAGE: jsx
CODE:
import { Stage, Layer, RegularPolygon, Text } from 'react-konva';
import { useState, useRef } from 'react';

const App = () => {
  const [message, setMessage] = useState('');
  const stageRef = useRef();

  const handlePointerMove = () => {
    const pos = stageRef.current.getPointerPosition();
    setMessage(`x: ${pos.x}, y: ${pos.y}`);
  };

  return (
    <Stage width={window.innerWidth} height={window.innerHeight} ref={stageRef}>
      <Layer>
        <Text
          x={10}
          y={10}
          fontFamily="Calibri"
          fontSize={24}
          text={message}
          fill="black"
        />
        <RegularPolygon
          x={window.innerWidth / 2}
          y={window.innerHeight / 2}
          sides={3}
          radius={80}
          fill="#00D2FF"
          stroke="black"
          strokeWidth={4}
          onPointermove={handlePointerMove}
          onPointerout={() => setMessage('')}
        />
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Implementing Event Listening Toggle in React with react-konva
DESCRIPTION: This React component uses react-konva to create a stage with an oval shape. It uses React state to manage the listening status and message display.

LANGUAGE: jsx
CODE:
import { Stage, Layer, Ellipse, Text } from 'react-konva';
import { useState } from 'react';

const App = () => {
  const [message, setMessage] = useState('');
  const [listening, setListening] = useState(false);

  return (
    <>
      <button onClick={() => setListening(!listening)}>
        {listening ? 'Stop listening' : 'Listen'}
      </button>
      <Stage width={window.innerWidth} height={window.innerHeight}>
        <Layer>
          <Text
            x={10}
            y={10}
            fontFamily="Calibri"
            fontSize={24}
            text={message}
            fill="black"
          />
          <Ellipse
            x={window.innerWidth / 2}
            y={window.innerHeight / 2}
            radiusX={100}
            radiusY={50}
            fill="yellow"
            stroke="black"
            strokeWidth={4}
            listening={listening}
            onMouseover={() => setMessage('Mouseover oval')}
            onMouseout={() => setMessage('')}
          />
        </Layer>
      </Stage>
    </>
  );
};

export default App;

----------------------------------------

TITLE: Rendering SVG on Canvas with Konva and canvg in Vue
DESCRIPTION: This Vue component demonstrates how to render an SVG image on a Konva canvas using both native rendering and the canvg library. It uses the useImage hook for native rendering and dynamically loads the canvg library for the second rendering method.

LANGUAGE: javascript
CODE:
<template>
  <v-stage :config="stageConfig">
    <v-layer>
      <v-image
        v-if="nativeImage"
        :config="{
          image: nativeImage,
          width: 150,
          height: 150
        }"
      />
      <v-image
        v-if="canvgImage"
        :config="{
          image: canvgImage,
          x: 200,
          width: 150,
          height: 150
        }"
      />
    </v-layer>
  </v-stage>
</template>

<script setup>
import { ref, onMounted, onUnmounted } from 'vue';
import { useImage } from 'vue-konva';

const SOURCE = 'https://konvajs.org/assets/tiger.svg';
const [nativeImage] = useImage(SOURCE);
const canvgImage = ref(null);

const stageConfig = {
  width: window.innerWidth,
  height: window.innerHeight
};

onMounted(() => {
  // Load canvg library and render SVG
  const script = document.createElement('script');
  script.src = 'https://cdn.jsdelivr.net/npm/canvg/dist/browser/canvg.min.js';
  script.onload = () => {
    const canvas = document.createElement('canvas');
    canvg(canvas, SOURCE, {
      renderCallback: function () {
        canvgImage.value = canvas;
      },
    });
  };
  document.head.appendChild(script);

  return () => {
    script.remove();
  };
});
</script>

----------------------------------------

TITLE: Draggable Stage Navigation
DESCRIPTION: Implementation of drag-and-drop navigation for large canvas content. Creates a viewport-sized stage that can be dragged to view different areas of the content.

LANGUAGE: javascript
CODE:
const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight,
  draggable: true,
});

----------------------------------------

TITLE: Implementing Star Spinner with Vue and Konva
DESCRIPTION: Vue 3 implementation of the spinning star using vue-konva. Uses composition API with setup script for state management and refs for DOM manipulation. Maintains feature parity with other implementations.

LANGUAGE: vue
CODE:
<template>
  <v-stage
    :config="stageSize"
    @mouseup="handleMouseUp"
    @touchend="handleMouseUp"
    @mousemove="handleMouseMove"
    @touchmove="handleMouseMove"
  >
    // ... rest of Vue implementation ...

----------------------------------------

TITLE: Configuring Arrow Pointer at Beginning
DESCRIPTION: Method to get or set whether the arrow should have a pointer at the beginning. Takes a boolean parameter to set the value, or returns the current setting when called without arguments.

LANGUAGE: javascript
CODE:
// get value
var pointerAtBeginning = line.pointerAtBeginning();

// set value
line.pointerAtBeginning(true);

----------------------------------------

TITLE: Creating Path Shape with React-Konva
DESCRIPTION: Shows how to implement a path shape using React-Konva components. Uses Stage, Layer, and Path components with properties for positioning, path data, fill color, and scale.

LANGUAGE: javascript
CODE:
import { Stage, Layer, Path } from 'react-konva';

const App = () => {
  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        <Path
          x={50}
          y={50}
          data="M12.582,9.551C3.251,16.237,0.921,29.021,7.08,38.564l-2.36,1.689l4.893,2.262l4.893,2.262l-0.568-5.36l-0.567-5.359l-2.365,1.694c-4.657-7.375-2.83-17.185,4.352-22.33c7.451-5.338,17.817-3.625,23.156,3.824c5.337,7.449,3.625,17.813-3.821,23.152l2.857,3.988c9.617-6.893,11.827-20.277,4.935-29.896C35.591,4.87,22.204,2.658,12.582,9.551z"
          fill="green"
          scaleX={2}
          scaleY={2}
        />
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Initializing Konva Tag Constructor
DESCRIPTION: Creates a new Tag instance with configuration options including pointer direction, dimensions and corner radius.

LANGUAGE: javascript
CODE:
new Konva.Tag(config)

----------------------------------------

TITLE: Setting Image Corner Radius
DESCRIPTION: Gets or sets the corner radius of the image, supporting both uniform and individual corner values

LANGUAGE: javascript
CODE:
// get corner radius
var cornerRadius = image.cornerRadius();

// set corner radius
image.cornerRadius(10);

// set different corner radius values
// top-left, top-right, bottom-right, bottom-left
image.cornerRadius([0, 10, 20, 30]);

----------------------------------------

TITLE: Implementing Complex Drag and Drop Bounds in Vanilla JavaScript with Konva
DESCRIPTION: This snippet creates a Konva stage with two draggable groups, each containing a rectangle and text. The blue group is bound below y=50, while the yellow group is bound inside an imaginary circle. It uses the 'dragmove' event to enforce these boundaries.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight,
});

const layer = new Konva.Layer();

const blueGroup = new Konva.Group({
x: 30,
y: 70,
draggable: true,
});

// bound below y=50
blueGroup.on('dragmove', () => {
blueGroup.y(Math.max(blueGroup.y(), 50));
});

// bound inside a circle
const yellowGroup = new Konva.Group({
x: stage.width() / 2,
y: 70,
draggable: true,
});

yellowGroup.on('dragmove', () => {
const x = stage.width() / 2;
const y = 70;
const radius = 50;
const pos = yellowGroup.absolutePosition();
const scale = radius / Math.sqrt(Math.pow(pos.x - x, 2) + Math.pow(pos.y - y, 2));

if (scale < 1) {
yellowGroup.x(Math.round((pos.x - x) * scale + x));
yellowGroup.y(Math.round((pos.y - y) * scale + y));
}
});

const blueText = new Konva.Text({
fontSize: 26,
fontFamily: 'Calibri',
text: 'bound below',
fill: 'black',
padding: 10,
width: 150,
align: 'center',
});

const blueRect = new Konva.Rect({
width: 150,
height: 72,
fill: '#aaf',
stroke: 'black',
strokeWidth: 4,
});

const yellowText = new Konva.Text({
fontSize: 26,
fontFamily: 'Calibri',
text: 'bound in circle',
fill: 'black',
padding: 10,
width: 150,
align: 'center',
});

const yellowRect = new Konva.Rect({
width: 150,
height:72,
fill: 'yellow',
stroke: 'black',
strokeWidth: 4,
});

blueGroup.add(blueRect).add(blueText);
yellowGroup.add(yellowRect).add(yellowText);

layer.add(blueGroup);
layer.add(yellowGroup);
stage.add(layer);

----------------------------------------

TITLE: Implementing Force Update with Vue 3 and Konva.js
DESCRIPTION: Vue 3 implementation using composition API and vue-konva components. Demonstrates reactive handling of text changes and transformer updates.

LANGUAGE: javascript
CODE:
<script setup>
import { ref, computed, onMounted } from 'vue';

const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight
};

const text = ref('Some text here');
const groupRef = ref(null);
const transformerRef = ref(null);

const groupConfig = {
  x: 50,
  y: 50,
  draggable: true
};

const textConfig = computed(() => ({
  text: text.value,
  fontSize: 24
}));

const rectConfig = computed(() => ({
  width: text.value.length * 10,
  height: 30,
  fill: 'yellow'
}));

const transformerConfig = {
  padding: 5,
  enabledAnchors: ['middle-left', 'middle-right']
};

const changeText = () => {
  text.value = 'Something else is here';
};

onMounted(() => {
  if (transformerRef.value && groupRef.value) {
    transformerRef.value.getNode().nodes([groupRef.value.getNode()]);
  }
});</script>

----------------------------------------

TITLE: Basic Large Canvas Implementation
DESCRIPTION: Simple approach creating a large canvas with native scrollbars. Demonstrates basic canvas setup with random circles, but may have performance issues due to large canvas size.

LANGUAGE: javascript
CODE:
const WIDTH = 3000;
const HEIGHT = 3000;
const NUMBER = 200;

const stage = new Konva.Stage({
  container: 'container',
  width: WIDTH,
  height: HEIGHT,
});

const layer = new Konva.Layer();
stage.add(layer);

function generateNode() {
  return new Konva.Circle({
    x: WIDTH * Math.random(),
    y: HEIGHT * Math.random(),
    radius: 50,
    fill: 'red',
    stroke: 'black',
  });
}

for (let i = 0; i < NUMBER; i++) {
  layer.add(generateNode());
}

----------------------------------------

TITLE: Rotating a Shape Around its Center in Konva
DESCRIPTION: This code snippet provides a function to rotate a shape around its center without using the offset property. It calculates the new position based on trigonometry to achieve the desired rotation effect.

LANGUAGE: javascript
CODE:
const rotatePoint = ({ x, y }, rad) => {
  const rcos = Math.cos(rad);
  const rsin = Math.sin(rad);
  return { x: x * rcos - y * rsin, y: y * rcos + x * rsin };
};

// will work for shapes with top-left origin, like rectangle
function rotateAroundCenter(node, rotation) {
  //current rotation origin (0, 0) relative to desired origin - center (node.width()/2, node.height()/2)
  const topLeft = { x: -node.width() / 2, y: -node.height() / 2 };
  const current = rotatePoint(topLeft, Konva.getAngle(node.rotation()));
  const rotated = rotatePoint(topLeft, Konva.getAngle(rotation));
  const dx = rotated.x - current.x,
    dy = rotated.y - current.y;

  node.rotation(rotation);
  node.x(node.x() + dx);
  node.y(node.y() + dy);
}

// then use it
rotateAroundCenter(rect, 180);

----------------------------------------

TITLE: Vue Konva CDN Implementation
DESCRIPTION: Complete HTML template showing how to implement vue-konva using CDN links and create a basic circle shape

LANGUAGE: html
CODE:
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
    <meta http-equiv="x-ua-compatible" content="ie=edge" />
  </head>
  <body>
    <div id="app">
      <v-stage ref="stage" :config="configKonva">
        <v-layer ref="layer">
          <v-circle :config="configCircle" />
        </v-layer>
      </v-stage>
    </div>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://unpkg.com/konva@9/konva.min.js"></script>
    <script src="https://unpkg.com/vue-konva@3/umd/vue-konva.min.js"></script>
    <script>
      const { createApp, ref } = Vue;
      
      const app = createApp({
        setup() {
          const configKonva = {
            width: 200,
            height: 200
          };
          
          const configCircle = {
            x: 100,
            y: 100,
            radius: 70,
            fill: 'red',
            stroke: 'black',
            strokeWidth: 4
          };
          
          return {
            configKonva,
            configCircle
          };
        }
      });
      
      app.use(VueKonva);
      app.mount('#app');
    </script>
  </body>
</html>

----------------------------------------

TITLE: Getting and Setting Number of Sides
DESCRIPTION: Shows how to get and set the number of sides of a RegularPolygon

LANGUAGE: javascript
CODE:
// get sides
var sides = shape.sides();

// set sides
shape.sides(10);

----------------------------------------

TITLE: Implementing Shape Visibility Control with React and Konva
DESCRIPTION: React implementation using react-konva to manage shape visibility through React state. Uses a boolean state variable to control the visibility property of the rectangle component.

LANGUAGE: jsx
CODE:
import React, { useState } from 'react';
import { Stage, Layer, Rect } from 'react-konva';

function App() {
  const [visible, setVisible] = useState(true);

  return (
    <div style={{ position: 'relative' }}>
      <div style={{ position: 'absolute', zIndex: 1, padding: '10px' }}>
        <button onClick={() => setVisible(true)}>Show</button>
        <button onClick={() => setVisible(false)}>Hide</button>
      </div>
      <Stage width={window.innerWidth} height={window.innerHeight}>
        <Layer>
          <Rect
            x={window.innerWidth / 2 - 50}
            y={window.innerHeight / 2 - 25}
            width={100}
            height={50}
            fill="green"
            stroke="black"
            strokeWidth={4}
            visible={visible}
          />
        </Layer>
      </Stage>
    </div>
  );
}

export default App;

----------------------------------------

TITLE: Controlling Fill and Stroke Order in React-Konva
DESCRIPTION: This React component demonstrates the use of fillAfterStrokeEnabled prop in React-Konva to control the rendering order of fill and stroke in Text components.

LANGUAGE: jsx
CODE:
import { Stage, Layer, Text } from 'react-konva';

const App = () => {
  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        <Text
          text="Default shape rendering.\nfillAfterStrokeEnabled = false"
          x={50}
          y={50}
          fontSize={40}
          stroke="green"
          fill="yellow"
          strokeWidth={3}
        />
        <Text
          text="Reversed rendering order.\nfillAfterStrokeEnabled = true"
          x={50}
          y={150}
          fontSize={40}
          stroke="green"
          fill="yellow"
          strokeWidth={3}
          fillAfterStrokeEnabled={true}
        />
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Initializing Vue Konva Plugin
DESCRIPTION: Configuration code to import and initialize vue-konva plugin in a Vue.js application

LANGUAGE: javascript
CODE:
import { createApp } from 'vue';
import App from './App.vue';
import VueKonva from 'vue-konva';

const app = createApp(App);
app.use(VueKonva);
app.mount('#app');

----------------------------------------

TITLE: Creating Kaleidoscope Effect with Vue 3 and vue-konva
DESCRIPTION: This snippet shows how to implement a kaleidoscope effect on an image using Vue 3 and vue-konva. It uses the composition API to manage state and applies the Kaleidoscope filter to a v-image component. Sliders are provided to adjust the number of sides and angle of the kaleidoscope.

LANGUAGE: vue
CODE:
<template>
  <div>
    <v-stage :config="stageSize">
      <v-layer>
        <v-image
          ref="imageNode"
          :config="{
            x: 50,
            y: 50,
            image: image,
            draggable: true,
            filters: [Konva.Filters.Kaleidoscope],
            kaleidoscopePower: sides,
            kaleidoscopeAngle: angle,
          }"
        />
      </v-layer>
    </v-stage>
    <div style="position: absolute; top: 20px; left: 20px">
      <div>
        Sides
        <input
          type="range"
          min="3"
          max="20"
          step="1"
          :value="sides"
          @input="(e) => sides = parseInt(e.target.value)"
        />
      </div>
      <div>
        Angle
        <input
          type="range"
          min="0"
          max="360"
          step="1"
          :value="angle"
          @input="(e) => angle = parseInt(e.target.value)"
        />
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, watch, nextTick } from 'vue';
import { useImage } from 'vue-konva';
import Konva from 'konva';

const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight,
};

const sides = ref(6);
const angle = ref(0);
const imageNode = ref(null);
const [image] = useImage('https://konvajs.org/assets/lion.png', 'anonymous');

watch(image, async (newImage) => {
  if (newImage) {
    await nextTick();
    imageNode.value.getNode().cache();
  }
});
</script>

----------------------------------------

TITLE: Interactive Star Drawing Component
DESCRIPTION: Vue component implementing draggable star shapes with scaling and shadow effects using vue-konva

LANGUAGE: javascript
CODE:
<template>
  <v-stage
    ref="stage"
    :config="stageSize"
    @dragstart="handleDragstart"
    @dragend="handleDragend"
  >
    <v-layer ref="layer">
      <v-star
        v-for="item in list"
        :key="item.id"
        :config="{
          x: item.x,
          y: item.y,
          rotation: item.rotation,
          id: item.id,
          numPoints: 5,
          innerRadius: 30,
          outerRadius: 50,
          fill: '#89b717',
          opacity: 0.8,
          draggable: true,
          scaleX: dragItemId === item.id ? item.scale * 1.2 : item.scale,
          scaleY: dragItemId === item.id ? item.scale * 1.2 : item.scale,
          shadowColor: 'black',
          shadowBlur: 10,
          shadowOffsetX: dragItemId === item.id ? 15 : 5,
          shadowOffsetY: dragItemId === item.id ? 15 : 5,
          shadowOpacity: 0.6
        }"
      />
    </v-layer>
  </v-stage>
</template>

<script setup>
import { ref, onMounted } from 'vue';

const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight
};

const list = ref([]);
const dragItemId = ref(null);

const handleDragstart = (e) => {
  dragItemId.value = e.target.id();
  const item = list.value.find(i => i.id === dragItemId.value);
  const index = list.value.indexOf(item);
  list.value.splice(index, 1);
  list.value.push(item);
};

const handleDragend = () => {
  dragItemId.value = null;
};

onMounted(() => {
  for (let n = 0; n < 30; n++) {
    list.value.push({
      id: Math.round(Math.random() * 10000).toString(),
      x: Math.random() * stageSize.width,
      y: Math.random() * stageSize.height,
      rotation: Math.random() * 180,
      scale: Math.random()
    });
  }
});
</script>

----------------------------------------

TITLE: Disabling Perfect Drawing for Konva Shapes in JavaScript
DESCRIPTION: This snippet demonstrates how to create and compare two circles in Konva, one with perfect drawing enabled (default) and another with it disabled. It also adds labels to explain the difference.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight,
});

const layer = new Konva.Layer();
stage.add(layer);

// With perfect drawing (default)
const perfectCircle = new Konva.Circle({
  x: 100,
  y: 100,
  radius: 50,
  fill: 'red',
  stroke: 'black',
  strokeWidth: 10,
  opacity: 0.5,
});

// Without perfect drawing
const nonPerfectCircle = new Konva.Circle({
  x: 250,
  y: 100,
  radius: 50,
  fill: 'red',
  stroke: 'black',
  strokeWidth: 10,
  opacity: 0.5,
  perfectDrawEnabled: false,
});

// Add labels
const perfectLabel = new Konva.Text({
  x: 50,
  y: 170,
  text: 'Perfect Drawing',
  fontSize: 16,
});

const nonPerfectLabel = new Konva.Text({
  x: 200,
  y: 170,
  text: 'Perfect Drawing Disabled',
  fontSize: 16,
});

layer.add(perfectCircle);
layer.add(nonPerfectCircle);
layer.add(perfectLabel);
layer.add(nonPerfectLabel);

----------------------------------------

TITLE: Implementing Transform Events with Konva in React
DESCRIPTION: This React component sets up a Konva stage with a rectangle and a transformer, demonstrating how to use transform events in a React environment. It uses the react-konva library to create Konva components and attaches event listeners for transform events.

LANGUAGE: jsx
CODE:
import { Stage, Layer, Rect, Transformer } from 'react-konva';
import { useRef, useEffect } from 'react';

const App = () => {
  const rectRef = useRef();
  const trRef = useRef();

  useEffect(() => {
    trRef.current.nodes([rectRef.current]);
  }, []);

  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        <Rect
          x={50}
          y={50}
          width={100}
          height={100}
          fill="yellow"
          stroke="black"
          draggable
          ref={rectRef}
          onTransformStart={() => console.log('rect transform start')}
          onTransform={() => console.log('rect transforming')}
          onTransformEnd={() => console.log('rect transform end')}
        />
        <Transformer
          ref={trRef}
          onTransformStart={() => console.log('transform start')}
          onTransform={() => console.log('transforming')}
          onTransformEnd={() => console.log('transform end')}
        />
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Configuring Clear Before Draw
DESCRIPTION: Gets or sets whether the layer should be cleared before drawing.

LANGUAGE: javascript
CODE:
// get clearBeforeDraw flag
var clearBeforeDraw = layer.clearBeforeDraw();

// disable clear before draw
layer.clearBeforeDraw(false);

// enable clear before draw
layer.clearBeforeDraw(true);

----------------------------------------

TITLE: Creating TextPath with Vanilla JavaScript and Konva
DESCRIPTION: Demonstrates how to create a text path using vanilla JavaScript and Konva library. Creates a stage, layer, and text path with custom styling and path data.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight
});

const layer = new Konva.Layer();
stage.add(layer);

const textPath = new Konva.TextPath({
  x: 0,
  y: 50,
  fill: '#333',
  fontSize: 16,
  fontFamily: 'Arial',
  text: 'All the world\'s a stage, and all the men and women merely players.',
  data: 'M10,10 C0,0 10,150 100,100 S300,150 400,50',
});

layer.add(textPath);

----------------------------------------

TITLE: Moving Shapes Between Groups - React Implementation
DESCRIPTION: React version of the container movement demo using react-konva. Uses React state to manage the red box's container affiliation instead of direct DOM manipulation.

LANGUAGE: jsx
CODE:
const App = () => {
  const [redBoxGroup, setRedBoxGroup] = useState('yellow');

  return (
    <>
      <button onClick={() => setRedBoxGroup('yellow')}>
        Move to yellow group
      </button>
      <button onClick={() => setRedBoxGroup('blue')}>
        Move to blue group
      </button>
      <Stage width={window.innerWidth} height={window.innerHeight}>
        <Layer>
          <Group x={50} y={50} draggable>
            <Rect
              width={100}
              height={100}
              fill="yellow"
              stroke="black"
              strokeWidth={4}
            />
            {redBoxGroup === 'yellow' && (
              <Rect x={10} y={10} width={30} height={30} fill="red" />
            )}
          </Group>
          <Group x={200} y={50} draggable>
            <Rect
              width={100}
              height={100}
              fill="blue"
              stroke="black"
              strokeWidth={4}
            />
            {redBoxGroup === 'blue' && (
              <Rect x={10} y={10} width={30} height={30} fill="red" />
            )}
          </Group>
        </Layer>
      </Stage>
    </>
  );
};

----------------------------------------

TITLE: Creating Custom Shape with Vue-Konva
DESCRIPTION: This snippet demonstrates how to create a custom shape using vue-konva's v-shape component. It defines a stage, layer, and a custom shape with specific drawing instructions using canvas commands.

LANGUAGE: vue
CODE:
<template>
  <v-stage ref="stage" :config="stageSize">
    <v-layer>
      <v-shape :config="{
        width: 260,
        height: 170,
        sceneFunc: function(context, shape) {
          const width = shape.width();
          const height = shape.height();
          context.beginPath();
          context.moveTo(0, 0);
          context.lineTo(width - 40, height - 90);
          context.quadraticCurveTo(width - 110, height - 70, width, height);
          context.closePath();

          // (!) Konva specific method, it is very important
          context.fillStrokeShape(shape);
        },
        fill: '#00D2FF',
        stroke: 'black',
        strokeWidth: 4
      }"/>
    </v-layer>
  </v-stage>
</template>

<script>
const width = window.innerWidth;
const height = window.innerHeight;

export default {
  data() {
    return {
      stageSize: {
        width: width,
        height: height
      }
    };
  }
};
</script>

----------------------------------------

TITLE: Applying HSL Filter to Image using Konva in Vanilla JavaScript
DESCRIPTION: This snippet demonstrates how to apply an HSL filter to an image using Konva in vanilla JavaScript. It creates a Konva stage, adds an image, applies the HSL filter, and creates interactive sliders for adjusting hue, saturation, and luminance values.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight,
});

const layer = new Konva.Layer();
stage.add(layer);

const imageObj = new Image();
imageObj.onload = () => {
  const image = new Konva.Image({
    x: 50,
    y: 50,
    image: imageObj,
    draggable: true,
  });

  layer.add(image);

  image.cache();
  image.filters([Konva.Filters.HSL]);
  
  // create sliders
  const createSlider = (label, min, max, defaultValue, property) => {
    const container = document.createElement('div');
    container.style.position = 'absolute';
    container.style.left = '20px';
    
    const text = document.createElement('span');
    text.textContent = `${label}: `;
    container.appendChild(text);
    
    const slider = document.createElement('input');
    slider.type = 'range';
    slider.min = min;
    slider.max = max;
    slider.step = '0.1';
    slider.value = defaultValue;
    slider.style.width = '200px';
    
    slider.addEventListener('input', (e) => {
      const value = parseFloat(e.target.value);
      image[property](value);
    });
    
    container.appendChild(slider);
    return container;
  };

  const hueSlider = createSlider('Hue', -180, 180, 0, 'hue');
  hueSlider.style.top = '20px';
  document.body.appendChild(hueSlider);

  const saturationSlider = createSlider('Saturation', -2, 10, 0, 'saturation');
  saturationSlider.style.top = '45px';
  document.body.appendChild(saturationSlider);

  const luminanceSlider = createSlider('Luminance', -2, 2, 0, 'luminance');
  luminanceSlider.style.top = '70px';
  document.body.appendChild(luminanceSlider);
};
imageObj.src = 'https://konvajs.org/assets/lion.png';
imageObj.crossOrigin = 'anonymous';

----------------------------------------

TITLE: Styling Konva Transformer in React
DESCRIPTION: React implementation of a styled Konva Transformer using react-konva. Uses refs to connect the transformer to a draggable rectangle and applies custom styling to the transformer's borders and anchors.

LANGUAGE: jsx
CODE:
import { Stage, Layer, Rect, Transformer } from 'react-konva';
import { useRef, useEffect } from 'react';

const App = () => {
  const rectRef = useRef();
  const trRef = useRef();

  useEffect(() => {
    trRef.current.nodes([rectRef.current]);
  }, []);

  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        <Rect
          x={50}
          y={50}
          width={100}
          height={100}
          fill="yellow"
          stroke="black"
          draggable
          ref={rectRef}
        />
        <Transformer
          ref={trRef}
          borderStroke="#000"
          borderStrokeWidth={3}
          anchorFill="#fff"
          anchorStroke="#000"
          anchorStrokeWidth={2}
          anchorSize={20}
          anchorCornerRadius={50}
        />
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Implementing Video Playback on Canvas with Vue.js and Konva
DESCRIPTION: This snippet demonstrates how to display a video on a canvas using Konva in a Vue.js application. It includes play/pause functionality, drag-and-drop capability, and responsive design considerations.

LANGUAGE: vue
CODE:
<template>
  <div>
    <button @click="handlePlay">Play</button>
    <button @click="handlePause">Pause</button>
    <v-stage :config="stageConfig">
      <v-layer ref="layerRef">
        <v-image
          :config="{
            image: videoElement,
            x: 50,
            y: 20,
            width: videoSize.width,
            height: videoSize.height,
            draggable: true,
          }"
        />
        <v-text
          v-if="status"
          :config="{
            text: status,
            width: stageConfig.width,
            height: stageConfig.height,
            align: 'center',
            verticalAlign: 'middle',
          }"
        />
      </v-layer>
    </v-stage>
  </div>
</template>

<script>
import { ref, onMounted, onUnmounted } from 'vue';

export default {
  setup() {
    const width = ref(window.innerWidth);
    const height = ref(400);
    const layerRef = ref(null);
    const status = ref('Loading video...');
    const animation = ref(null);
    const videoElement = ref(document.createElement('video'));
    const videoSize = ref({ width: 0, height: 0 });

    videoElement.value.src =
      'https://upload.wikimedia.org/wikipedia/commons/transcoded/c/c4/Physicsworks.ogv/Physicsworks.ogv.240p.vp9.webm';

    const stageConfig = {
      width: width.value,
      height: height.value,
    };

    const handleResize = () => {
      width.value = window.innerWidth;
    };

    const handleMetadata = () => {
      status.value = 'Press PLAY...';
      videoSize.value = {
        width: videoElement.value.videoWidth,
        height: videoElement.value.videoHeight,
      };
    };

    const handlePlay = () => {
      status.value = '';
      videoElement.value.play();
      if (layerRef.value) {
        const anim = new Konva.Animation(() => {}, layerRef.value.getNode());
        animation.value = anim;
        anim.start();
      }
    };

    const handlePause = () => {
      videoElement.value.pause();
      if (animation.value) {
        animation.value.stop();
      }
    };

    onMounted(() => {
      window.addEventListener('resize', handleResize);
      videoElement.value.addEventListener('loadedmetadata', handleMetadata);
    });

    onUnmounted(() => {
      window.removeEventListener('resize', handleResize);
      videoElement.value.removeEventListener('loadedmetadata', handleMetadata);
      if (animation.value) {
        animation.value.stop();
      }
    });

    return {
      stageConfig,
      layerRef,
      status,
      videoElement,
      videoSize,
      handlePlay,
      handlePause,
    };
  },
};
</script>

----------------------------------------

TITLE: Applying Blur Filter to Image with Konva in Vanilla JavaScript
DESCRIPTION: This snippet demonstrates how to create a Konva stage, add an image, apply a blur filter, and use a slider to adjust the blur radius. It uses the Konva.Filters.Blur filter and sets the blurRadius property.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const width = window.innerWidth;
const height = window.innerHeight;

const stage = new Konva.Stage({
  container: 'container',
  width: width,
  height: height,
});

const layer = new Konva.Layer();
stage.add(layer);

const imageObj = new Image();
imageObj.onload = () => {
  const image = new Konva.Image({
    x: 50,
    y: 50,
    image: imageObj,
    draggable: true,
  });

  layer.add(image);

  image.cache();
  image.filters([Konva.Filters.Blur]);
  image.blurRadius(10);

  const slider = document.createElement('input');
  slider.type = 'range';
  slider.min = '0';
  slider.max = '40';
  slider.value = image.blurRadius();

  slider.style.position = 'absolute';
  slider.style.top = '20px';
  slider.style.left = '20px';

  slider.addEventListener('input', (e) => {
    const value = parseInt(e.target.value);
    image.blurRadius(value);
  });

  document.body.appendChild(slider);
};

imageObj.src = 'https://konvajs.org/assets/lion.png';
imageObj.crossOrigin = 'anonymous';

----------------------------------------

TITLE: Implementing Draggable Circle with Konva in Vue
DESCRIPTION: This snippet shows how to create a draggable red circle using Konva in a Vue component. It sets up the stage and circle configurations, and includes methods for handling mouse enter and leave events for cursor styling.

LANGUAGE: vue
CODE:
<template>
  <v-stage :config="stageSize">
    <v-layer>
      <v-circle
        :config="circleConfig"
        @mouseenter="handleMouseEnter"
        @mouseleave="handleMouseLeave"
      />
    </v-layer>
  </v-stage>
</template>

<script setup>
const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight
};

const circleConfig = {
  x: window.innerWidth / 2,
  y: window.innerHeight / 2,
  radius: 70,
  fill: 'red',
  stroke: 'black',
  strokeWidth: 4,
  draggable: true
};

const handleMouseEnter = () => {
  document.body.style.cursor = 'pointer';
};

const handleMouseLeave = () => {
  document.body.style.cursor = 'default';
};
</script>

----------------------------------------

TITLE: Creating Splines (Curved Lines) with Konva in JavaScript
DESCRIPTION: This snippet shows how to create a curved line using Konva by adding the tension property. It initializes a stage, adds a layer, and creates a curved line.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight
});

const layer = new Konva.Layer();
stage.add(layer);

const line = new Konva.Line({
  points: [5, 70, 140, 23, 250, 60, 300, 20],
  stroke: 'red',
  strokeWidth: 15,
  lineCap: 'round',
  lineJoin: 'round',
  tension: 1
});

layer.add(line);

----------------------------------------

TITLE: Managing Node Order in Vue Konva
DESCRIPTION: A Vue component that demonstrates reactive ordering of Konva circle shapes through array manipulation. The component creates draggable circles with random positions and colors, and manages their stacking order by rearranging array elements instead of using zIndex.

LANGUAGE: vue
CODE:
<template>
  <v-stage :config="stageSize">
    <v-layer>
      <v-circle
        v-for="item in items"
        :key="item.id"
        :config="item"
        @dragstart="handleDragstart"
        @dragend="handleDragend"
      />
    </v-layer>
  </v-stage>
</template>

<script setup>
import { ref, onMounted } from 'vue';
import Konva from 'konva';

const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight
};

const items = ref([]);
const dragItemId = ref(null);

const generateItems = () => {
  const newItems = [];
  for (let i = 0; i < 10; i++) {
    newItems.push({
      x: Math.random() * stageSize.width,
      y: Math.random() * stageSize.height,
      radius: 50,
      id: "node-" + i,
      fill: Konva.Util.getRandomColor(),
      draggable: true
    });
  }
  return newItems;
};

const handleDragstart = (e) => {
  // save drag element:
  dragItemId.value = e.target.id();
  // move current element to the top by rearranging the items array:
  const item = items.value.find(i => i.id === dragItemId.value);
  const index = items.value.indexOf(item);
  items.value.splice(index, 1);
  items.value.push(item);
};

const handleDragend = () => {
  dragItemId.value = null;
};

onMounted(() => {
  items.value = generateItems();
});
</script>

----------------------------------------

TITLE: Canceling Event Propagation with Konva in React
DESCRIPTION: This React component creates a Konva stage with a circle shape and demonstrates how to cancel event bubbling when the circle is clicked. It uses the cancelBubble property in the click event handler to prevent propagation.

LANGUAGE: jsx
CODE:
import { Stage, Layer, Circle } from 'react-konva';

const App = () => {
  const handleCircleClick = (e) => {
    alert('You clicked on the circle');
    // stop event bubble
    e.cancelBubble = true;
  };

  const handleLayerClick = () => {
    alert('You clicked on the layer');
  };

  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer onClick={handleLayerClick}>
        <Circle
          x={window.innerWidth / 2}
          y={window.innerHeight / 2}
          radius={70}
          fill="red"
          stroke="black"
          strokeWidth={4}
          onClick={handleCircleClick}
        />
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Implementing Solarize Filter with Vue and Konva
DESCRIPTION: Shows how to implement a draggable image with solarize filter using Vue 3 and vue-konva. Uses Vue composition API and includes a threshold control slider. Requires vue-konva and Konva libraries.

LANGUAGE: javascript
CODE:
<template>
  <div>
    <v-stage :config="stageSize">
      <v-layer>
        <v-image
          ref="imageNode"
          :config="{
            x: 50,
            y: 50,
            image: image,
            draggable: true,
            filters: [Konva.Filters.Solarize],
            threshold: threshold,
          }"
        />
      </v-layer>
    </v-stage>
    <input
      type="range"
      min="0"
      max="1"
      step="0.1"
      :value="threshold"
      @input="handleSlider"
      style="position: absolute; top: 20px; left: 20px"
    />
  </div>
</template>

<script setup>
import { ref, watch, nextTick } from 'vue';
import { useImage } from 'vue-konva';
import Konva from 'konva';

const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight,
};

const threshold = ref(0.5);
const imageNode = ref(null);
const [image] = useImage('https://konvajs.org/assets/lion.png', 'anonymous');

watch(image, async (newImage) => {
  if (newImage) {
    await nextTick();
    imageNode.value.getNode().cache();
  }
});

const handleSlider = (e) => {
  threshold.value = parseFloat(e.target.value);
};
</script>

----------------------------------------

TITLE: Implementing Fill and Stroke Order in Vue-Konva
DESCRIPTION: This Vue component shows how to use the fillAfterStrokeEnabled config option in Vue-Konva to control the rendering order of fill and stroke in Text components.

LANGUAGE: vue
CODE:
<template>
  <v-stage :config="stageSize">
    <v-layer>
      <v-text :config="textConfig1" />
      <v-text :config="textConfig2" />
    </v-layer>
  </v-stage>
</template>

<script setup>
const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight
};

const textConfig1 = {
  text: 'Default shape rendering.\nfillAfterStrokeEnabled = false',
  x: 50,
  y: 50,
  fontSize: 40,
  stroke: 'green',
  fill: 'yellow',
  strokeWidth: 3
};

const textConfig2 = {
  text: 'Reversed rendering order.\nfillAfterStrokeEnabled = true',
  x: 50,
  y: 150,
  fontSize: 40,
  stroke: 'green',
  fill: 'yellow',
  strokeWidth: 3,
  fillAfterStrokeEnabled: true
};
</script>

----------------------------------------

TITLE: Selecting and Animating Shapes by ID in Konva (Vue)
DESCRIPTION: This snippet demonstrates the same functionality as the previous examples, but implemented in Vue 3 with the Composition API. It uses v-stage and v-layer components to create the Konva stage and layer.

LANGUAGE: vue
CODE:
<template>
  <div>
    <button @click="handleClick" style="margin-bottom: 10px">
      Activate Rectangle
    </button>
    <v-stage :config="stageSize">
      <v-layer ref="layerRef">
        <v-rect
          :config="rectConfig"
          @dragend="handleDragEnd"
        />
      </v-layer>
    </v-stage>
  </div>
</template>

<script setup>
import { ref } from 'vue';
import Konva from 'konva';

const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight
};

const position = ref({
  x: window.innerWidth / 2 - 25,
  y: window.innerHeight / 2 - 25
});

const rectConfig = ref({
  x: position.value.x,
  y: position.value.y,
  width: 50,
  height: 50,
  fill: 'red',
  id: 'myRect',
  draggable: true
});

const layerRef = ref(null);

const handleClick = () => {
  // find rectangle by id and animate it
  const rectangle = layerRef.value.getNode().findOne('#myRect');
  rectangle.to({
    duration: 1,
    rotation: 360,
    fill: 'blue',
    easing: Konva.Easings.EaseInOut
  });
};

const handleDragEnd = (e) => {
  const newPos = e.target.position();
  position.value = newPos;
  rectConfig.value.x = newPos.x;
  rectConfig.value.y = newPos.y;
};
</script>

----------------------------------------

TITLE: Implementing Blur Filter Tween in Vue with vue-konva
DESCRIPTION: Shows how to create the blur filter animation using Vue 3 composition API and vue-konva. Implements the same functionality using Vue's reactive system and template syntax.

LANGUAGE: javascript
CODE:
<script setup>
import { ref, onMounted, computed } from 'vue';
import Konva from 'konva';

const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight
};

const image = ref(null);
const imageRef = ref(null);
let tween = null;

// Load image
const img = new Image();
img.onload = () => {
  image.value = img;
};
img.src = '/images/lion.png';

const imageConfig = computed(() => ({
  x: 50,
  y: 50,
  image: image.value,
  draggable: true
}));

onMounted(() => {
  if (!imageRef.value) return;

  const node = imageRef.value.getNode();
  node.cache();
  node.filters([Konva.Filters.Blur]);
  node.blurRadius(10);

  tween = new Konva.Tween({
    node: node,
    duration: 0.5,
    blurRadius: 0,
    easing: Konva.Easings.EaseInOut,
  });
});

const handleMouseEnter = () => {
  tween.play();
};

const handleMouseLeave = () => {
  tween.reverse();
};</script>

----------------------------------------

TITLE: Implementing Emboss Filter with Vanilla JavaScript and Konva.js
DESCRIPTION: Creates an interactive canvas with an image that has an emboss filter applied. Includes slider controls for adjusting emboss strength, white level, and blend values. The implementation uses vanilla JavaScript with Konva.js library.

LANGUAGE: javascript
CODE:
const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight,
});

const layer = new Konva.Layer();
stage.add(layer);

const imageObj = new Image();
imageObj.onload = () => {
  const image = new Konva.Image({
    x: 50,
    y: 50,
    image: imageObj,
    draggable: true,
  });

  layer.add(image);

  image.cache();
  image.filters([Konva.Filters.Emboss]);
  image.embossStrength(0.5);
  image.embossWhiteLevel(0.5);
  image.embossDirection('top-left');
  image.embossBlend(0.5);

  // create sliders
  const strengthSlider = document.createElement('input');
  strengthSlider.type = 'range';
  strengthSlider.min = '0';
  strengthSlider.max = '1';
  strengthSlider.step = '0.1';
  strengthSlider.value = image.embossStrength();
  strengthSlider.style.position = 'absolute';
  strengthSlider.style.top = '20px';
  strengthSlider.style.left = '20px';

  const whiteLevelSlider = document.createElement('input');
  whiteLevelSlider.type = 'range';
  whiteLevelSlider.min = '0';
  whiteLevelSlider.max = '1';
  whiteLevelSlider.step = '0.1';
  whiteLevelSlider.value = image.embossWhiteLevel();
  whiteLevelSlider.style.position = 'absolute';
  whiteLevelSlider.style.top = '45px';
  whiteLevelSlider.style.left = '20px';

  const blendSlider = document.createElement('input');
  blendSlider.type = 'range';
  blendSlider.min = '0';
  blendSlider.max = '1';
  blendSlider.step = '0.1';
  blendSlider.value = image.embossBlend();
  blendSlider.style.position = 'absolute';
  blendSlider.style.top = '70px';
  blendSlider.style.left = '20px';

  // add labels
  const strengthLabel = document.createElement('div');
  strengthLabel.textContent = 'Strength';
  strengthLabel.style.position = 'absolute';
  strengthLabel.style.top = '20px';
  strengthLabel.style.left = '200px';

  const whiteLevelLabel = document.createElement('div');
  whiteLevelLabel.textContent = 'White Level';
  whiteLevelLabel.style.position = 'absolute';
  whiteLevelLabel.style.top = '45px';
  whiteLevelLabel.style.left = '200px';

  const blendLabel = document.createElement('div');
  blendLabel.textContent = 'Blend';
  blendLabel.style.position = 'absolute';
  blendLabel.style.top = '70px';
  blendLabel.style.left = '200px';

  // add event listeners
  strengthSlider.addEventListener('input', (e) => {
    image.embossStrength(parseFloat(e.target.value));
  });

  whiteLevelSlider.addEventListener('input', (e) => {
    image.embossWhiteLevel(parseFloat(e.target.value));
  });

  blendSlider.addEventListener('input', (e) => {
    image.embossBlend(parseFloat(e.target.value));
  });

  // add elements to the page
  document.body.appendChild(strengthSlider);
  document.body.appendChild(whiteLevelSlider);
  document.body.appendChild(blendSlider);
  document.body.appendChild(strengthLabel);
  document.body.appendChild(whiteLevelLabel);
  document.body.appendChild(blendLabel);
};
imageObj.src = 'https://konvajs.org/assets/lion.png';
imageObj.crossOrigin = 'anonymous';

----------------------------------------

TITLE: Setting Circle Radius
DESCRIPTION: Shows how to get and set the radius of a circle shape

LANGUAGE: javascript
CODE:
// get radius
var radius = circle.radius();

// set radius
circle.radius(10);

----------------------------------------

TITLE: Implementing Solarize Filter with React and Konva
DESCRIPTION: Demonstrates how to create a draggable image with solarize filter using React and react-konva components. Uses React hooks for state management and includes a threshold control slider. Requires react-konva and use-image hook.

LANGUAGE: javascript
CODE:
import { Stage, Layer, Image } from 'react-konva';
import { useState, useEffect, useRef } from 'react';
import useImage from 'use-image';

const App = () => {
  const [threshold, setThreshold] = useState(0.5);
  const [image] = useImage('https://konvajs.org/assets/lion.png', 'anonymous');
  const imageRef = useRef(null);

  useEffect(() => {
    if (image && imageRef.current) {
      imageRef.current.cache();
    }
  }, [image]);

  return (
    <>
      <Stage width={window.innerWidth} height={window.innerHeight}>
        <Layer>
          <Image
            ref={imageRef}
            x={50}
            y={50}
            image={image}
            draggable
            filters={[Konva.Filters.Solarize]}
            threshold={threshold}
          />
        </Layer>
      </Stage>
      <input
        type="range"
        min="0"
        max="1"
        step="0.1"
        value={threshold}
        onChange={(e) => setThreshold(parseFloat(e.target.value))}
        style={{ position: 'absolute', top: '20px', left: '20px' }}
      />
    </>
  );
};

export default App;

----------------------------------------

TITLE: Implementing Keyboard Events in Vanilla JavaScript with Konva
DESCRIPTION: Creates a canvas with a movable circle that responds to arrow key inputs using vanilla JavaScript and Konva. Makes the stage container focusable and handles keydown events to update circle position.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight,
});

const layer = new Konva.Layer();
stage.add(layer);

const circle = new Konva.Circle({
  x: stage.width() / 2,
  y: stage.height() / 2,
  radius: 50,
  fill: 'red',
  stroke: 'black',
  strokeWidth: 4,
});
layer.add(circle);

stage.container().tabIndex = 1;
stage.container().focus();

const DELTA = 4;

stage.container().addEventListener('keydown', (e) => {
  if (e.keyCode === 37) {
    circle.x(circle.x() - DELTA);
  } else if (e.keyCode === 38) {
    circle.y(circle.y() - DELTA);
  } else if (e.keyCode === 39) {
    circle.x(circle.x() + DELTA);
  } else if (e.keyCode === 40) {
    circle.y(circle.y() + DELTA);
  } else {
    return;
  }
  e.preventDefault();
});

----------------------------------------

TITLE: Executing MCP Command for Konva Documentation
DESCRIPTION: Command-line instruction for running the Model Context Protocol to access Konva documentation in AI-powered development environments. This command initiates the connection to the Konva-specific AI assistant.

LANGUAGE: plaintext
CODE:
npx crawl-chat-mcp --id=67d221efb4b9de65095a2579 --name=konva_documentation

----------------------------------------

TITLE: Creating External Store in Svelte
DESCRIPTION: Demonstrates how to create a simple external store in Svelte to preserve component state during Hot Module Replacement (HMR). This approach helps retain important state data that would otherwise be lost during HMR updates.

LANGUAGE: javascript
CODE:
// store.js
// An extremely simple external store
import { writable } from 'svelte/store'
export default writable(0)

----------------------------------------

TITLE: Implementing Tween Controls in Vanilla JavaScript with Konva
DESCRIPTION: Creates a circular shape and implements tween animation controls using vanilla JavaScript and Konva. Demonstrates basic animation control methods including play, pause, reverse, reset, finish, and seek functionality.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const width = window.innerWidth;
const height = window.innerHeight;

const stage = new Konva.Stage({
container: 'container',
width: width,
height: height,
});

const layer = new Konva.Layer();

const circle = new Konva.Circle({
x: 100,
y: height / 2,
radius: 70,
fill: 'red',
stroke: 'black',
strokeWidth: 4,
});

layer.add(circle);
stage.add(layer);

const tween = new Konva.Tween({
node: circle,
duration: 2,
x: width - 100,
easing: Konva.Easings.EaseInOut,
});

// create buttons
const controls = ['play', 'pause', 'reverse', 'reset', 'finish'];
controls.forEach(control => {
const button = document.createElement('button');
button.textContent = control;
button.addEventListener('click', () => {
tween[control]();
});
document.body.appendChild(button);
});

// seek control
const seekBtn = document.createElement('button');
seekBtn.textContent = 'Seek to 50%';
seekBtn.addEventListener('click', () => {
tween.seek(1); // seek to 1 second
});
document.body.appendChild(seekBtn);

----------------------------------------

TITLE: Implementing Layer Management in Konva with Vue
DESCRIPTION: This snippet demonstrates how to create separate layers for static text and animated shapes in Konva using Vue 3. It uses the vue-konva library and Vue Composition API to manage the animation of a circle moving in a figure-8 pattern.

LANGUAGE: vue
CODE:
<template>
  <v-stage :config="stageSize">
    <!-- Static layer for text -->
    <v-layer>
      <v-text :config="textConfig" />
    </v-layer>
    
    <!-- Animated layer for shapes -->
    <v-layer ref="animLayerRef">
      <v-circle
        ref="circleRef"
        :config="circleConfig"
      />
    </v-layer>
  </v-stage>
</template>

<script setup>
import { ref, onMounted, onUnmounted } from 'vue';
import Konva from 'konva';

const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight
};

const textConfig = {
  x: 20,
  y: 20,
  text: 'This text is in a static layer.\nThe circle below is in an animated layer.',
  fontSize: 16,
  fill: 'black'
};

const circleConfig = ref({
  x: 100,
  y: 100,
  radius: 30,
  fill: 'red'
});

const animLayerRef = ref(null);
const circleRef = ref(null);
let anim = null;

onMounted(() => {
  anim = new Konva.Animation((frame) => {
    const scale = 100;
    const centerX = window.innerWidth / 2;
    const centerY = window.innerHeight / 2;
    
    const circle = circleRef.value.getNode();
    circle.x(centerX + Math.sin(frame.time / 1000) * scale);
    circle.y(centerY + Math.sin(frame.time / 2000) * scale);
  }, animLayerRef.value.getNode());

  anim.start();
});

onUnmounted(() => {
  if (anim) {
    anim.stop();
  }
});
</script>

----------------------------------------

TITLE: Vue-Konva Sepia Filter Implementation
DESCRIPTION: Demonstrates sepia filter implementation in a Vue.js application using vue-konva. Shows the component setup, image loading with composition API, and proper handling of image caching after component mounting.

LANGUAGE: javascript
CODE:
<template>
  <v-stage :config="stageSize">
    <v-layer>
      <v-image
        v-if="image"
        ref="imageNode"
        :config="{
          x: 50,
          y: 50,
          image: image,
          draggable: true,
          filters: [Konva.Filters.Sepia],
        }"
      />
    </v-layer>
  </v-stage>
</template>

<script setup>
import { ref, watch, nextTick } from 'vue';
import { useImage } from 'vue-konva';
import Konva from 'konva';
const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight,
};

const imageNode = ref(null);
const [image] = useImage('https://konvajs.org/assets/lion.png', 'anonymous');

watch(image, async (newImage) => {
  if (newImage) {
    await nextTick();
    imageNode.value.getNode().cache();
  }
});
</script>

----------------------------------------

TITLE: Embedding CodeSandbox Demo for Konva Labels with Svelte
DESCRIPTION: This code snippet embeds a CodeSandbox demo that showcases the implementation of labels in Konva using Svelte components. The demo allows users to hover over circles to display tooltips.

LANGUAGE: html
CODE:
<iframe 
  src="https://codesandbox.io/p/sandbox/github/konvajs/site/tree/master/svelte-demos/labels?file=/src/App.svelte" 
  style={{
    width: "100%",
    height: "800px",
    border: 0,
    borderRadius: "4px",
    overflow: "hidden"
  }}
  sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"
/>

----------------------------------------

TITLE: Scaling Image with Konva in Vanilla JavaScript
DESCRIPTION: This snippet demonstrates how to scale an image to fit a fixed area on a Konva canvas using vanilla JavaScript. It includes functions for calculating crop values, applying the crop, and handling image transformations.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

// Create select element for crop position
const select = document.createElement('select');
select.style.position = 'absolute';
select.style.top = '4px';
select.style.left = '4px';

const positions = [
  'left-top', 'center-top', 'right-top', '--',
  'left-middle', 'center-middle', 'right-middle', '--',
  'left-bottom', 'center-bottom', 'right-bottom'
];

positions.forEach(pos => {
  const option = document.createElement('option');
  option.value = pos;
  option.text = pos;
  if (pos === 'center-middle') option.selected = true;
  select.appendChild(option);
});

document.body.appendChild(select);

const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight,
});

const layer = new Konva.Layer();
stage.add(layer);

// function to calculate crop values from source image, its visible size and a crop strategy
function getCrop(image, size, clipPosition = 'center-middle') {
  const width = size.width;
  const height = size.height;
  const aspectRatio = width / height;

  let newWidth;
  let newHeight;

  const imageRatio = image.width / image.height;

  if (aspectRatio >= imageRatio) {
    newWidth = image.width;
    newHeight = image.width / aspectRatio;
  } else {
    newWidth = image.height * aspectRatio;
    newHeight = image.height;
  }

  let x = 0;
  let y = 0;
  if (clipPosition === 'left-top') {
    x = 0;
    y = 0;
  } else if (clipPosition === 'left-middle') {
    x = 0;
    y = (image.height - newHeight) / 2;
  } else if (clipPosition === 'left-bottom') {
    x = 0;
    y = image.height - newHeight;
  } else if (clipPosition === 'center-top') {
    x = (image.width - newWidth) / 2;
    y = 0;
  } else if (clipPosition === 'center-middle') {
    x = (image.width - newWidth) / 2;
    y = (image.height - newHeight) / 2;
  } else if (clipPosition === 'center-bottom') {
    x = (image.width - newWidth) / 2;
    y = image.height - newHeight;
  } else if (clipPosition === 'right-top') {
    x = image.width - newWidth;
    y = 0;
  } else if (clipPosition === 'right-middle') {
    x = image.width - newWidth;
    y = (image.height - newHeight) / 2;
  } else if (clipPosition === 'right-bottom') {
    x = image.width - newWidth;
    y = image.height - newHeight;
  }

  return {
    cropX: x,
    cropY: y,
    cropWidth: newWidth,
    cropHeight: newHeight,
  };
}

// function to apply crop
function applyCrop(img, pos) {
  img.setAttr('lastCropUsed', pos);
  const crop = getCrop(
    img.image(),
    { width: img.width(), height: img.height() },
    pos
  );
  img.setAttrs(crop);
}

Konva.Image.fromURL('https://konvajs.org/assets/darth-vader.jpg', (img) => {
  img.setAttrs({
    width: 300,
    height: 100,
    x: 80,
    y: 100,
    name: 'image',
    draggable: true,
  });
  layer.add(img);
  // apply default center-middle crop
  applyCrop(img, 'center-middle');

  const tr = new Konva.Transformer({
    nodes: [img],
    keepRatio: false,
    flipEnabled: false,
    boundBoxFunc: (oldBox, newBox) => {
      if (Math.abs(newBox.width) < 10 || Math.abs(newBox.height) < 10) {
        return oldBox;
      }
      return newBox;
    },
  });

  layer.add(tr);

  img.on('transform', () => {
    // reset scale on transform
    img.setAttrs({
      scaleX: 1,
      scaleY: 1,
      width: img.width() * img.scaleX(),
      height: img.height() * img.scaleY(),
    });
    applyCrop(img, img.getAttr('lastCropUsed'));
  });
});

select.addEventListener('change', (e) => {
  const img = layer.findOne('.image');
  applyCrop(img, e.target.value);
});

----------------------------------------

TITLE: Configuring Hit Graph
DESCRIPTION: Gets or sets whether hit detection is enabled for the layer (deprecated in favor of listening property).

LANGUAGE: javascript
CODE:
// get hitGraphEnabled flag
var hitGraphEnabled = layer.hitGraphEnabled();

// disable hit graph
layer.hitGraphEnabled(false);

// enable hit graph
layer.hitGraphEnabled(true);

----------------------------------------

TITLE: Configuring Draggable Shapes in Svelte-Konva
DESCRIPTION: Shows how to enable drag and drop functionality for canvas nodes using the draggable property. The component automatically synchronizes the node's position with the configuration on dragend events.

LANGUAGE: svelte
CODE:
draggable: true

----------------------------------------

TITLE: Implementing Pointer Events with Vue and Konva
DESCRIPTION: Vue 3 implementation of the pointer events demo using vue-konva. Uses composition API with refs and computed properties for reactive state management.

LANGUAGE: vue
CODE:
<template>
  <v-stage :config="stageSize" ref="stageRef">
    <v-layer>
      <v-text :config="textConfig" />
      <v-regular-polygon
        :config="triangleConfig"
        @pointermove="handlePointerMove"
        @pointerout="handlePointerOut"
      />
    </v-layer>
  </v-stage>
</template>

<script setup>
import { ref, computed } from 'vue';

const stageRef = ref(null);
const message = ref('');

const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight
};

const textConfig = computed(() => ({
  x: 10,
  y: 10,
  fontFamily: 'Calibri',
  fontSize: 24,
  text: message.value,
  fill: 'black'
}));

const triangleConfig = {
  x: window.innerWidth / 2,
  y: window.innerHeight / 2,
  sides: 3,
  radius: 80,
  fill: '#00D2FF',
  stroke: 'black',
  strokeWidth: 4
};

const handlePointerMove = () => {
  const pos = stageRef.value.getNode().getPointerPosition();
  message.value = `x: ${pos.x}, y: ${pos.y}`;
};

const handlePointerOut = () => {
  message.value = '';
};
</script>

----------------------------------------

TITLE: Flipping Shapes with React and Konva
DESCRIPTION: Shows how to implement shape flipping using React-Konva. Uses React state to manage text elements and their scale properties, with a flip button to toggle horizontal orientation.

LANGUAGE: javascript
CODE:
import { Stage, Layer, Text } from 'react-konva';
import { useState, useRef } from 'react';

const App = () => {
  const [texts, setTexts] = useState([
    {
      id: 1,
      text: 'Default text with no offset. Its origin is in top left corner.',
      x: 180,
      y: 50,
      width: 200,
      align: 'center',
      scaleX: 1,
      offsetX: 0
    },
    {
      id: 2,
      text: 'Text with the origin in its center',
      x: 270,
      y: 100,
      width: 200,
      align: 'center',
      scaleX: 1,
      offsetX: 100
    }
  ]);

  const handleFlip = () => {
    setTexts(texts.map(text => ({
      ...text,
      scaleX: -text.scaleX
    })));
  };

  return (
    <div>
      <Stage width={window.innerWidth} height={window.innerHeight}>
        <Layer>
          {texts.map((text) => (
            <Text
              key={text.id}
              x={text.x}
              y={text.y}
              text={text.text}
              width={text.width}
              align={text.align}
              scaleX={text.scaleX}
              offsetX={text.offsetX}
            />
          ))}
        </Layer>
      </Stage>
      <button
        onClick={handleFlip}
        style={{
          position: 'absolute',
          top: '5px',
          left: '5px'
        }}
      >
        Flip horizontally
      </button>
    </div>
  );
};

export default App;

----------------------------------------

TITLE: Implementing Collision Detection in Vanilla JavaScript with Konva
DESCRIPTION: Creates a canvas with draggable shapes that detect collisions using bounding box intersection. When shapes overlap, they turn red. The implementation includes creating random shapes with rotation and displaying their bounding boxes.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

var width = window.innerWidth;
var height = window.innerHeight;

var stage = new Konva.Stage({
  container: 'container',
  width: width,
  height: height,
});

var layer = new Konva.Layer();
stage.add(layer);

function createShape() {
  var group = new Konva.Group({
    x: Math.random() * width,
    y: Math.random() * height,
    draggable: true,
  });
  var shape = new Konva.Rect({
    width: 30 + Math.random() * 30,
    height: 30 + Math.random() * 30,
    fill: 'grey',
    rotation: 360 * Math.random(),
    name: 'fillShape',
  });
  group.add(shape);

  var boundingBox = shape.getClientRect({ relativeTo: group });

  var box = new Konva.Rect({
    x: boundingBox.x,
    y: boundingBox.y,
    width: boundingBox.width,
    height: boundingBox.height,
    stroke: 'red',
    strokeWidth: 1,
  });
  group.add(box);
  return group;
}

for (var i = 0; i < 10; i++) {
  layer.add(createShape());
}

layer.on('dragmove', function (e) {
  var target = e.target;
  var targetRect = e.target.getClientRect();
  layer.children.forEach(function (group) {
    if (group === target) {
      return;
    }
    if (haveIntersection(group.getClientRect(), targetRect)) {
      group.findOne('.fillShape').fill('red');
    } else {
      group.findOne('.fillShape').fill('grey');
    }
  });
});

function haveIntersection(r1, r2) {
  return !(
    r2.x > r1.x + r1.width ||
    r2.x + r2.width < r1.x ||
    r2.y > r1.y + r1.height ||
    r2.y + r2.height < r1.y
  );
}

----------------------------------------

TITLE: Resizing Konva Shapes with Stroke Preservation (Vue.js)
DESCRIPTION: This Vue.js component demonstrates two methods for resizing Konva shapes without scaling the stroke. It uses the Composition API with refs and onMounted hook to set up the shapes and transformers, implementing both scale resetting and stroke scaling disabling approaches.

LANGUAGE: vue
CODE:
<template>
  <v-stage :config="stageSize">
    <v-layer>
      <v-rect
        :config="rect1Config"
        @transformend="handleTransformEnd"
        ref="rect1Ref"
      />
      <v-transformer
        :config="tr1Config"
        ref="tr1Ref"
      />
      
      <v-rect
        :config="rect2Config"
        ref="rect2Ref"
      />
      <v-transformer
        :config="tr2Config"
        ref="tr2Ref"
      />
    </v-layer>
  </v-stage>
</template>

<script setup>
import { ref, onMounted } from 'vue';

const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight
};

const rect1Size = ref({
  width: 100,
  height: 100
});

const rect1Config = {
  x: 50,
  y: 50,
  width: rect1Size.value.width,
  height: rect1Size.value.height,
  fill: '#00ff00',
  stroke: 'black',
  strokeWidth: 5,
  draggable: true
};

const rect2Config = {
  x: 200,
  y: 50,
  width: 100,
  height: 100,
  fill: '#ff0000',
  stroke: 'black',
  strokeWidth: 5,
  draggable: true,
  strokeScaleEnabled: false
};

const tr1Config = {};
const tr2Config = {
  ignoreStroke: true
};

const rect1Ref = ref(null);
const rect2Ref = ref(null);
const tr1Ref = ref(null);
const tr2Ref = ref(null);

const handleTransformEnd = () => {
  const node = rect1Ref.value.getNode();
  rect1Size.value = {
    width: node.width() * node.scaleX(),
    height: node.height() * node.scaleY()
  };
  node.scaleX(1);
  node.scaleY(1);
};

onMounted(() => {
  tr1Ref.value.getNode().nodes([rect1Ref.value.getNode()]);
  tr2Ref.value.getNode().nodes([rect2Ref.value.getNode()]);
});
</script>

----------------------------------------

TITLE: Cropping an Image
DESCRIPTION: Gets or sets the crop settings for the image, allowing you to display only a portion of the source image

LANGUAGE: javascript
CODE:
// get crop
var crop = image.crop();

// set crop
image.crop({
  x: 20,
  y: 20,
  width: 20,
  height: 20
});

----------------------------------------

TITLE: Implementing Shape Visibility Control with Vue and Konva
DESCRIPTION: Vue implementation using vue-konva to manage shape visibility through Vue's reactive system. Uses a ref variable to control the visibility property of the rectangle component.

LANGUAGE: vue
CODE:
<template>
  <div style="position: relative;">
    <div style="position: absolute; z-index: 1; padding: 10px;">
      <button @click="showShape">Show</button>
      <button @click="hideShape">Hide</button>
    </div>
    <v-stage :config="stageSize">
      <v-layer>
        <v-rect :config="rectConfig"/>
      </v-layer>
    </v-stage>
  </div>
</template>

<script setup>
import { ref } from 'vue';

const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight
};

const visible = ref(true);

const rectConfig = {
  x: window.innerWidth / 2 - 50,
  y: window.innerHeight / 2 - 25,
  width: 100,
  height: 50,
  fill: 'green',
  stroke: 'black',
  strokeWidth: 4,
  visible: visible.value
};

const showShape = () => {
  visible.value = true;
  rectConfig.visible = true;
};

const hideShape = () => {
  visible.value = false;
  rectConfig.visible = false;
};
</script>

----------------------------------------

TITLE: Removing Event Listeners in Vanilla JavaScript with Konva
DESCRIPTION: Demonstrates creating a circle with a click event listener and providing a button to remove the listener using Konva's off() method. Uses vanilla JavaScript to create and manage the stage, layer, and circle elements.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight,
});

const layer = new Konva.Layer();
stage.add(layer);

const circle = new Konva.Circle({
  x: stage.width() / 2,
  y: stage.height() / 2,
  radius: 70,
  fill: 'red',
  stroke: 'black',
  strokeWidth: 4,
});

// add click listener
circle.on('click', function () {
  alert('you clicked the circle');
});

layer.add(circle);

// add button to remove listener
const button = document.createElement('button');
button.style.position = 'absolute';
button.style.top = '10px';
button.style.left = '10px';
button.innerHTML = 'Remove click listener';
document.body.appendChild(button);
button.addEventListener('click', () => {
  // remove click listener
  circle.off('click');
});

----------------------------------------

TITLE: Implementing Horizontal and Vertical Drag Constraints in React with react-konva
DESCRIPTION: This React component uses react-konva to create a stage with two draggable text elements. It demonstrates how to implement horizontal and vertical drag constraints using the onDragMove prop.

LANGUAGE: jsx
CODE:
import { Stage, Layer, Text } from 'react-konva';

const App = () => {
  const handleHorizontalDragMove = (e) => {
    e.target.y(50);
  };

  const handleVerticalDragMove = (e) => {
    e.target.x(200);
  };

  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        <Text
          x={50}
          y={50}
          text="Drag me horizontally"
          fontSize={16}
          draggable
          fill="black"
          onDragMove={handleHorizontalDragMove}
        />
        <Text
          x={200}
          y={50}
          text="Drag me vertically"
          fontSize={16}
          draggable
          fill="black"
          onDragMove={handleVerticalDragMove}
        />
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Creating Arrow Shape with React-Konva
DESCRIPTION: Shows how to implement an arrow shape using React-Konva components. Uses the Arrow component with props to define dimensions, position, and styling properties.

LANGUAGE: javascript
CODE:
import { Stage, Layer, Arrow } from 'react-konva';

const App = () => {
  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        <Arrow
          x={window.innerWidth / 4}
          y={window.innerHeight / 4}
          points={[0, 0, 100, 100]}
          pointerLength={20}
          pointerWidth={20}
          fill="black"
          stroke="black"
          strokeWidth={4}
        />
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Deploying Website without SSH
DESCRIPTION: Command to deploy the website using GitHub username authentication.

LANGUAGE: bash
CODE:
$ GIT_USER=<Your GitHub username> yarn deploy

----------------------------------------

TITLE: Creating Simple Lines with Konva in React
DESCRIPTION: This snippet shows how to create three different styled lines using Konva components in a React application. It demonstrates the use of the Stage, Layer, and Line components from react-konva, setting various line properties as component props.

LANGUAGE: jsx
CODE:
import { Stage, Layer, Line } from 'react-konva';

const App = () => {
  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        <Line
          points={[5, 70, 140, 23, 250, 60, 300, 20]}
          stroke="red"
          strokeWidth={15}
          lineCap="round"
          lineJoin="round"
          y={5}
        />
        <Line
          points={[5, 70, 140, 23, 250, 60, 300, 20]}
          stroke="green"
          strokeWidth={2}
          lineJoin="round"
          dash={[33, 10]}
          y={55}
        />
        <Line
          points={[5, 70, 140, 23, 250, 60, 300, 20]}
          stroke="blue"
          strokeWidth={10}
          lineCap="round"
          lineJoin="round"
          dash={[29, 20, 0.001, 20]}
          y={105}
        />
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Creating Wedge Shape with Konva in Vue
DESCRIPTION: This snippet illustrates how to create a wedge shape using Konva in a Vue application. It uses Vue 3 composition API and v-konva components to render a stage, layer, and wedge with specified configuration.

LANGUAGE: vue
CODE:
<template>
  <v-stage :config="stageSize">
    <v-layer>
      <v-wedge :config="wedgeConfig" />
    </v-layer>
  </v-stage>
</template>

<script setup>
const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight
};

const wedgeConfig = {
  x: window.innerWidth / 2,
  y: window.innerHeight / 2,
  radius: 70,
  angle: 60,
  fill: 'red',
  stroke: 'black',
  strokeWidth: 4,
  rotation: -120
};
</script>

----------------------------------------

TITLE: Removing Event Listeners in React with Konva
DESCRIPTION: Shows how to implement event listener removal in a React component using react-konva. Uses state management to conditionally render the click handler on a circle component.

LANGUAGE: jsx
CODE:
import { Stage, Layer, Circle } from 'react-konva';
import { useState } from 'react';

const App = () => {
  const [hasListener, setHasListener] = useState(true);

  return (
    <>
      <button onClick={() => setHasListener(false)}>
        Remove click listener
      </button>
      <Stage width={window.innerWidth} height={window.innerHeight}>
        <Layer>
          <Circle
            x={window.innerWidth / 2}
            y={window.innerHeight / 2}
            radius={70}
            fill="red"
            stroke="black"
            strokeWidth={4}
            onClick={hasListener ? () => alert('you clicked the circle') : null}
          />
        </Layer>
      </Stage>
    </>
  );
};

export default App;

----------------------------------------

TITLE: Implementing Drag Events in Konva with Vue
DESCRIPTION: This snippet demonstrates how to create a draggable text element and handle drag events using Konva in a Vue component. It uses the vue-konva library and Vue's composition API to manage the drag status.

LANGUAGE: vue
CODE:
<template>
  <v-stage :config="stageSize">
    <v-layer>
      <v-text
        :config="textConfig"
        @dragstart="handleDragStart"
        @dragend="handleDragEnd"
        @dragmove="handleDragMove"
      />
      <v-text :config="statusConfig" />
    </v-layer>
  </v-stage>
</template>

<script setup>
import { ref } from 'vue';

const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight
};

const textConfig = {
  x: 40,
  y: 40,
  text: 'Draggable Text',
  fontSize: 20,
  draggable: true,
  width: 200
};

const status = ref('');

const statusConfig = {
  x: 40,
  y: 100,
  text: status,
  fontSize: 16,
  width: 200
};

const handleDragStart = () => {
  status.value = 'drag started';
};

const handleDragEnd = () => {
  status.value = 'drag ended';
};

const handleDragMove = () => {
  status.value = 'dragging';
};
</script>

----------------------------------------

TITLE: Vue Implementation of Expandable Images with Konva
DESCRIPTION: Vue 3 component implementation using Vue-Konva for expandable images. Uses composition API and refs for state management.

LANGUAGE: javascript
CODE:
<template>
  <v-stage :config="stageConfig">
    <v-layer ref="layerRef">
      <v-image
        v-for="(img, index) in images"
        :key="index"
        :config="getImageConfig(img, index)"
        @mouseenter="handleMouseEnter(index)"
        @mouseleave="handleMouseLeave(index)"
      />
    </v-layer>
  </v-stage>
</template>

<script setup>
import { ref, onMounted, computed } from 'vue';

const stageConfig = {
  width: window.innerWidth,
  height: window.innerHeight
};

const layerRef = ref(null);
const hoveredIndex = ref(null);
const loadedImages = ref({});

const images = ref([
  {
    src: 'https://konvajs.org/assets/darth-vader.jpg',
    x: 110,
    y: 88,
    width: 200,
    height: 137,
    offsetX: 100,
    offsetY: 68,
    loaded: false
  },
  {
    src: 'https://konvajs.org/assets/yoda.jpg',
    x: 290,
    y: 70,
    width: 93,
    height: 104,
    offsetX: 46,
    offsetY: 52,
    loaded: false
  }
]);

onMounted(() => {
  images.value.forEach((img, index) => {
    const imageObj = new Image();
    imageObj.onload = () => {
      loadedImages.value = {
        ...loadedImages.value,
        [index]: imageObj
      };
    };
    imageObj.src = img.src;
  });
});

const getImageConfig = (img, index) => {
  const isHovered = hoveredIndex.value === index;
  const scale = isHovered ? 1.2 : 1;
  
  return {
    image: loadedImages.value[index],
    x: img.x,
    y: img.y,
    width: img.width,
    height: img.height,
    offsetX: img.offsetX,
    offsetY: img.offsetY,
    scaleX: scale,
    scaleY: scale,
    draggable: true
  };
};

const handleMouseEnter = (index) => {
  hoveredIndex.value = index;
  document.body.style.cursor = 'pointer';
};

const handleMouseLeave = () => {
  hoveredIndex.value = null;
  document.body.style.cursor = 'default';
};
</script>

----------------------------------------

TITLE: Creating Bouncing Bunnies Animation with React and Konva
DESCRIPTION: This React component uses react-konva to create a performance test with bouncing bunnies. It manages state for the bunnies, handles user interactions, and updates positions using direct node manipulation for better performance.

LANGUAGE: jsx
CODE:
import { useState, useEffect, useRef } from 'react';
import { Stage, FastLayer, Image } from 'react-konva';
import { useImage } from 'react-konva-utils';

const BunnyMark = () => {
  // Constants
  const width = window.innerWidth;
  const height = window.innerHeight;
  const GRAVITY = 0.75;
  const START_COUNT = 100;
  const ADD_AMOUNT = 10;
  
  // State and refs
  const [count, setCount] = useState(0);
  const [isAdding, setIsAdding] = useState(false);
  const layerRef = useRef(null);
  const bunniesRef = useRef([]);
  const bunnyNodesRef = useRef([]); // Store references to the actual Konva nodes
  const [bunnyImage] = useImage('https://konvajs.org/assets/bunny.png');
  
  // Create a bunny with position and velocity
  const createBunny = (x, y) => ({
    x,
    y,
    speedX: Math.random() * 10,
    speedY: Math.random() * 10 - 5
  });
  
  // Store references to Konva image nodes
  const storeNodeRef = (index, node) => {
    if (node) {
      bunnyNodesRef.current[index] = node;
    }
  };
  
  // Initialize bunnies when image loads
  useEffect(() => {
    if (!bunnyImage) return;
    
    const initialBunnies = Array(START_COUNT).fill(0).map(() => createBunny(
      Math.random() * width,
      Math.random() * height
    ));
    
    bunniesRef.current = initialBunnies;
    bunnyNodesRef.current = new Array(START_COUNT);
    setCount(START_COUNT);
  }, [bunnyImage]);
  
  // Animation loop
  useEffect(() => {
    if (!bunnyImage) return;
    
    let animationFrameId;
    
    const update = () => {
      // Add more bunnies if needed
      if (isAdding) {
        const currentLength = bunniesRef.current.length;
        const newBunnies = Array(ADD_AMOUNT).fill(0).map(() => 
          createBunny(
            Math.random() * width,
            Math.random() * height
          )
        );
        
        bunniesRef.current = [...bunniesRef.current, ...newBunnies];
        // Extend the nodes array to accommodate new bunnies
        bunnyNodesRef.current = [...bunnyNodesRef.current, ...new Array(ADD_AMOUNT)];
        setCount(prevCount => prevCount + ADD_AMOUNT);
      }
      
      // Update all bunnies - DIRECT NODE MANIPULATION FOR PERFORMANCE
      // This avoids expensive React re-renders for position updates
      bunniesRef.current.forEach((bunny, i) => {
        // Update data model
        bunny.x += bunny.speedX;
        bunny.y += bunny.speedY;
        bunny.speedY += GRAVITY;
        
        // Bounce off edges
        if (bunny.x > width - bunnyImage.width) {
          bunny.speedX *= -1;
          bunny.x = width - bunnyImage.width;
        } else if (bunny.x < 0) {
          bunny.speedX *= -1;
          bunny.x = 0;
        }
        
        if (bunny.y > height - bunnyImage.height) {
          bunny.speedY *= -0.85;
          bunny.y = height - bunnyImage.height;
          if (Math.random() > 0.5) {
            bunny.speedY -= Math.random() * 6;
          }
        } else if (bunny.y < 0) {
          bunny.speedY = 0;
          bunny.y = 0;
        }
        
        // Direct node update if we have a reference (much faster than React updates)
        const node = bunnyNodesRef.current[i];
        if (node) {
          node.x(bunny.x);
          node.y(bunny.y);
        }
      });
      
      // Batch draw the layer once instead of updating each node individually
      if (layerRef.current) {
        layerRef.current.getLayer().batchDraw();
      }
      
      animationFrameId = requestAnimationFrame(update);
    };
    
    update();
    
    return () => {
      cancelAnimationFrame(animationFrameId);
    };
  }, [isAdding, bunnyImage]);
  
  // Handle mouse/touch events
  const handleDown = () => setIsAdding(true);
  const handleUp = () => setIsAdding(false);
  
  if (!bunnyImage) return <div>Loading bunny image...</div>;
  
  return (
    <>
      
      <Stage
        width={width}
        height={height}
        onMouseDown={handleDown}
        onMouseUp={handleUp}
        onTouchStart={handleDown}
        onTouchEnd={handleUp}
      >
        <FastLayer ref={layerRef}>
          {bunniesRef.current.map((bunny, i) => (
            <Image
              key={i}
              ref={(node) => storeNodeRef(i, node)}
              image={bunnyImage}
              x={bunny.x}
              y={bunny.y}
              transformsEnabled="position"
              perfectDrawEnabled={false}
            />
          ))}
        </FastLayer>
      </Stage>
      <div 
        style={{
          position: 'absolute',
          top: '50px',
          backgroundColor: 'white',
          fontSize: '12px',
          padding: '5px'
        }}
      >
        {count} BUNNIES
      </div>
    </>
  );
};

export default BunnyMark;

----------------------------------------

TITLE: Firing Custom Events with Konva in React
DESCRIPTION: This snippet shows how to create a Konva stage with a circle shape in React, attach a custom event listener, and fire the custom event. It uses the useRef hook to reference the circle and includes a button to trigger the event.

LANGUAGE: jsx
CODE:
import { Stage, Layer, Circle } from 'react-konva';
import { useRef } from 'react';

const App = () => {
  const circleRef = useRef();

  const handleCustomEvent = () => {
    alert('custom event fired');
  };

  const fireCustomEvent = () => {
    circleRef.current.fire('customEvent', {
      bubbles: true,
    });
  };

  return (
    <>
      <button onClick={fireCustomEvent}>Fire Custom Event</button>
      <Stage width={window.innerWidth} height={window.innerHeight}>
        <Layer>
          <Circle
            ref={circleRef}
            x={window.innerWidth / 2}
            y={window.innerHeight / 2}
            radius={70}
            fill="red"
            stroke="black"
            strokeWidth={4}
            onCustomEvent={handleCustomEvent}
          />
        </Layer>
      </Stage>
    </>
  );
};

export default App;

----------------------------------------

TITLE: Creating a Konva.Text Object in JavaScript
DESCRIPTION: Constructor for creating a new Konva.Text object with configuration options.

LANGUAGE: javascript
CODE:
new Konva.Text(config)

----------------------------------------

TITLE: Implementing Shape Tooltips with Vue and vue-konva
DESCRIPTION: This snippet demonstrates how to create shape tooltips using Vue and vue-konva. It uses Vue's composition API to manage tooltip state and implements custom shape drawing and event handling.

LANGUAGE: vue
CODE:
<template>
  <v-stage :config="stageConfig">
    <v-layer>
      <v-shape
        :config="{
          stroke: 'black',
          fill: '#00D2FF',
          strokeWidth: 1,
          sceneFunc: drawTriangle,
        }"
        @mousemove="(e) => handleMouseMove(e, 'Cyan Triangle')"
        @mouseout="handleMouseOut"
      />
      <v-circle
        :config="{
          x: 250,
          y: stageConfig.height / 2,
          radius: 70,
          fill: 'red',
          stroke: 'black',
          strokeWidth: 4,
        }"
        @mousemove="(e) => handleMouseMove(e, 'Red Circle')"
        @mouseout="handleMouseOut"
      />
    </v-layer>
    <v-layer>
      <v-text
        :config="{
          ...tooltipConfig,
          visible: isTooltipVisible,
        }"
      />
    </v-layer>
  </v-stage>
</template>

<script setup>
import { ref, computed } from 'vue';

const stageConfig = {
  width: window.innerWidth,
  height: window.innerHeight,
};

const tooltipPos = ref({ x: 0, y: 0 });
const tooltipText = ref('');
const isTooltipVisible = ref(false);

const tooltipConfig = computed(() => ({
  x: tooltipPos.value.x,
  y: tooltipPos.value.y,
  text: tooltipText.value,
  fontFamily: 'Calibri',
  fontSize: 12,
  padding: 5,
  textFill: 'white',
  fill: 'black',
  alpha: 0.75,
}));

const drawTriangle = (context, shape) => {
  context.beginPath();
  context.moveTo(120, 50);
  context.lineTo(250, 80);
  context.lineTo(150, 170);
  context.closePath();
  context.fillStrokeShape(shape);
};

const handleMouseMove = (e, text) => {
  const stage = e.target.getStage();
  const pos = stage.getPointerPosition();
  tooltipPos.value = {
    x: pos.x + 5,
    y: pos.y + 5,
  };
  tooltipText.value = text;
  isTooltipVisible.value = true;
};

const handleMouseOut = () => {
  isTooltipVisible.value = false;
};
</script>

----------------------------------------

TITLE: Applying Grayscale Filter to Image with Vue-Konva
DESCRIPTION: This Vue.js component uses vue-konva to create a stage, layer, and image. It applies a grayscale filter to the image using Konva.Filters.Grayscale. The useImage composable is used for image loading.

LANGUAGE: vue
CODE:
<template>
  <v-stage :config="stageSize">
    <v-layer>
      <v-image
        ref="imageNode"
        :config="{
          x: 50,
          y: 50,
          image: image,
          draggable: true,
          filters: [Konva.Filters.Grayscale],
        }"
      />
    </v-layer>
  </v-stage>
</template>

<script setup>
import { ref, watch, nextTick } from 'vue';
import { useImage } from 'vue-konva';
import Konva from 'konva';

const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight,
};

const imageNode = ref(null);
const [image] = useImage('https://konvajs.org/assets/lion.png', 'anonymous');

watch(image, async (newImage) => {
  if (newImage) {
    await nextTick();
    imageNode.value.getNode().cache();
  }
});
</script>

----------------------------------------

TITLE: Disabling Perfect Drawing for Konva Shapes in React
DESCRIPTION: This React component creates a Konva stage with two circles, one with perfect drawing enabled (default) and another with it disabled. It also adds labels to explain the difference.

LANGUAGE: jsx
CODE:
import { Stage, Layer, Circle, Text } from 'react-konva';

const App = () => {
  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        {/* With perfect drawing (default) */}
        <Circle
          x={100}
          y={100}
          radius={50}
          fill="red"
          stroke="black"
          strokeWidth={10}
          opacity={0.5}
        />
        
        {/* Without perfect drawing */}
        <Circle
          x={250}
          y={100}
          radius={50}
          fill="red"
          stroke="black"
          strokeWidth={10}
          opacity={0.5}
          perfectDrawEnabled={false}
        />
        
        {/* Labels */}
        <Text
          x={50}
          y={170}
          text="Perfect Drawing"
          fontSize={16}
        />
        <Text
          x={200}
          y={170}
          text="Perfect Drawing Disabled"
          fontSize={16}
        />
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Implementing Image Events with Konva in Vue
DESCRIPTION: This snippet demonstrates how to create image events in Konva using Vue. It shows the use of Vue's Composition API, computed properties, and refs to manage state and implement precise hit detection for images with transparent areas.

LANGUAGE: html
CODE:
<template>
  <v-stage :config="stageSize">
    <v-layer>
      <v-text :config="textConfig" />
      <v-image
        v-if="monkeyImage"
        :config="monkeyConfig"
        @mouseover="handleMonkeyOver"
        @mouseout="handleMouseOut"
      />
      <v-image
        v-if="lionImage"
        :config="lionConfig"
        @mouseover="handleLionOver"
        @mouseout="handleMouseOut"
        ref="lionRef"
      />
    </v-layer>
  </v-stage>
</template>

<script setup>
import { ref, computed, onMounted } from 'vue';

const message = ref('');
const monkeyImage = ref(null);
const lionImage = ref(null);
const lionRef = ref(null);

const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight
};

const textConfig = computed(() => ({
  x: 10,
  y: 10,
  fontFamily: 'Calibri',
  fontSize: 24,
  text: message.value,
  fill: 'black'
}));

const monkeyConfig = computed(() => ({
  x: 120,
  y: 50,
  image: monkeyImage.value,
  width: 200,
  height: 200
}));

const lionConfig = computed(() => ({
  x: 320,
  y: 50,
  image: lionImage.value,
  width: 200,
  height: 200
}));

const loadImage = (src) => {
  return new Promise((resolve) => {
    const img = new Image();
    img.onload = () => resolve(img);
    img.src = src;
  });
};

onMounted(async () => {
  const [monkey, lion] = await Promise.all([
    loadImage('/images/monkey.png'),
    loadImage('/images/lion.png'),
  ]);
  monkeyImage.value = monkey;
  lionImage.value = lion;
  
  // Wait for the next tick to ensure the image is rendered
  nextTick(() => {
    if (lionRef.value) {
      lionRef.value.getNode().drawHitFromCache();
    }
  });
});

const handleMonkeyOver = () => {
  message.value = 'mouseover monkey (regular image)';
};

const handleLionOver = () => {
  message.value = 'mouseover lion (with transparent pixels detection)';
};

const handleMouseOut = () => {
  message.value = '';
};
</script>

----------------------------------------

TITLE: Adding Circles on Click Using Relative Mouse Position in React Konva
DESCRIPTION: This React component creates a Konva stage with nested, transformed nodes and adds circles to a group based on the relative mouse position. It uses the `getRelativePointerPosition()` method and React state to manage the circles.

LANGUAGE: jsx
CODE:
import { useState } from 'react';
import { Stage, Layer, Group, Text, Circle } from 'react-konva';

const App = () => {
  const [circles, setCircles] = useState([]);
  
  const handleStageClick = (e) => {
    // Get the group reference from konva tree
    const group = e.target.getStage().findOne('Group');
    if (!group) return;
    
    // Get position relative to the group
    const pos = group.getRelativePointerPosition();
    
    // Add new circle
    setCircles([
      ...circles,
      {
        x: pos.x,
        y: pos.y,
        radius: 20,
        fill: 'red',
        id: Date.now().toString()
      }
    ]);
  };

  return (
    <Stage 
      width={window.innerWidth} 
      height={window.innerHeight}
      x={20}
      y={50}
      onClick={handleStageClick}
    >
      <Layer
        scaleX={1.2}
        scaleY={0.8}
        rotation={5}
      >
        <Group
          x={30}
          rotation={10}
          scaleX={1.5}
        >
          <Text 
            text="Click on the canvas to draw a circle" 
            fontSize={20}
          />
          {circles.map((circle) => (
            <Circle
              key={circle.id}
              x={circle.x}
              y={circle.y}
              radius={circle.radius}
              fill={circle.fill}
            />
          ))}
        </Group>
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Mobile Touch Events with React-Konva Components
DESCRIPTION: React implementation of mobile touch events using react-konva components. Uses hooks for state management and refs for accessing stage properties. Demonstrates the same functionality as the vanilla version with React-specific patterns.

LANGUAGE: jsx
CODE:
import { Stage, Layer, RegularPolygon, Circle, Text } from 'react-konva';
import { useState, useRef } from 'react';

const App = () => {
  const [message, setMessage] = useState('');
  const stageRef = useRef();

  const handleTriangleTouch = () => {
    const touchPos = stageRef.current.getPointerPosition();
    setMessage(`x: ${touchPos.x}, y: ${touchPos.y}`);
  };

  return (
    <Stage width={window.innerWidth} height={window.innerHeight} ref={stageRef}>
      <Layer>
        <Text
          x={10}
          y={10}
          fontFamily="Calibri"
          fontSize={24}
          text={message}
          fill="black"
        />
        <RegularPolygon
          x={80}
          y={120}
          sides={3}
          radius={80}
          fill="#00D2FF"
          stroke="black"
          strokeWidth={4}
          onTouchmove={handleTriangleTouch}
        />
        <Circle
          x={230}
          y={100}
          radius={60}
          fill="red"
          stroke="black"
          strokeWidth={4}
          onTouchstart={() => setMessage('touchstart circle')}
          onTouchend={() => setMessage('touchend circle')}
        />
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Exporting Konva Stage with High Resolution - Vue
DESCRIPTION: Vue 3 implementation of high quality Konva stage export using Vue-Konva components. Uses ref to access stage instance and composition API for component setup.

LANGUAGE: javascript
CODE:
<template>
  <div>
    <button @click="handleExport" style="margin-bottom: 10px">
      Save as High Quality Image
    </button>
    <v-stage ref="stageRef" :config="stageSize">
      <v-layer>
        <v-circle :config="circleConfig" />
        <v-text :config="textConfig" />
      </v-layer>
    </v-stage>
  </div>
</template>

<script setup>
import { ref } from 'vue';

const stageSize = {
  width: 400,
  height: 400
};

const circleConfig = {
  x: 200,
  y: 200,
  radius: 70,
  fill: 'red',
  stroke: 'black',
  strokeWidth: 4
};

const textConfig = {
  x: 150,
  y: 190,
  text: 'High Quality Export',
  fontSize: 20,
  fill: 'white'
};

const stageRef = ref(null);

const handleExport = () => {
  const dataURL = stageRef.value.getNode().toDataURL({
    pixelRatio: 2
  });
  
  const link = document.createElement('a');
  link.download = 'stage.png';
  link.href = dataURL;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
};
</script>

----------------------------------------

TITLE: Adding Circles on Click Using Relative Mouse Position in Vue Konva
DESCRIPTION: This Vue component creates a Konva stage with nested, transformed nodes and adds circles to a group based on the relative mouse position. It uses the `getRelativePointerPosition()` method and Vue's reactive system to manage the circles.

LANGUAGE: vue
CODE:
<template>
  <v-stage 
    :config="stageConfig"
    @click="handleStageClick"
  >
    <v-layer :config="layerConfig">
      <v-group :config="groupConfig">
        <v-text :config="textConfig" />
        <v-circle 
          v-for="circle in circles"
          :key="circle.id"
          :config="circle"
        />
      </v-group>
    </v-layer>
  </v-stage>
</template>

<script setup>
import { ref } from 'vue';

const stageConfig = {
  width: window.innerWidth,
  height: window.innerHeight,
  x: 20,
  y: 50
};

const layerConfig = {
  scaleX: 1.2,
  scaleY: 0.8,
  rotation: 5
};

const groupConfig = {
  x: 30,
  rotation: 10,
  scaleX: 1.5
};

const textConfig = {
  text: 'Click on the canvas to draw a circle',
  fontSize: 20
};

const circles = ref([]);

const handleStageClick = (e) => {
  // Get the group reference from konva tree
  const group = e.target.getStage().findOne('Group');
  if (!group) return;
  
  // Get position relative to the group
  const pos = group.getRelativePointerPosition();
  
  // Add new circle
  circles.value.push({
    x: pos.x,
    y: pos.y,
    radius: 20,
    fill: 'red',
    id: Date.now().toString()
  });
};
</script>

----------------------------------------

TITLE: Creating Wedge Shape with Konva in React
DESCRIPTION: This snippet shows how to create a wedge shape using Konva in a React application. It uses the react-konva library to render a Stage, Layer, and Wedge component with specified properties.

LANGUAGE: jsx
CODE:
import { Stage, Layer, Wedge } from 'react-konva';

const App = () => {
  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        <Wedge
          x={window.innerWidth / 2}
          y={window.innerHeight / 2}
          radius={70}
          angle={60}
          fill="red"
          stroke="black"
          strokeWidth={4}
          rotation={-120}
        />
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Building Planets Image Map with Vue and Konva
DESCRIPTION: This snippet demonstrates how to create the planets image map using Vue 3 and vue-konva. It utilizes the composition API with setup script to manage reactive state and event handling. The code sets up a stage with layers for the image, planet overlays, and text, along with a checkbox to toggle overlay visibility.

LANGUAGE: vue
CODE:
<template>
  <div>
    <div :style="styles.container">
      <label :style="styles.label">
        <input
          type="checkbox"
          :style="styles.input"
          v-model="showOverlay"
        />
        Show map overlay
      </label>
    </div>
    <v-stage :config="stageSize">
      <v-layer>
        <v-image
          v-if="planetsImage"
          :config="{ image: planetsImage }"
        />
      </v-layer>
      <v-layer>
        <v-circle
          v-for="(planet, name) in planets"
          :key="name"
          :config="{
            x: planet.x,
            y: planet.y,
            radius: planet.radius,
            fill: showOverlay ? 'red' : null,
          }"
          @mouseenter="message = name"
          @mouseleave="message = ''"
        />
      </v-layer>
      <v-layer>
        <v-text :config="textConfig" />
      </v-layer>
    </v-stage>
  </div>
</template>

<script setup>
import { ref, computed } from 'vue';
import { useImage } from 'vue-konva';

const message = ref('');
const showOverlay = ref(false);
const [planetsImage] = useImage('https://konvajs.org/assets/planets.png');

const planets = {
  Mercury: {
    x: 46,
    y: 126,
    radius: 32,
  },
  Venus: {
    x: 179,
    y: 126,
    radius: 79,
  },
  Earth: {
    x: 366,
    y: 127,
    radius: 85,
  },
  Mars: {
    x: 515,
    y: 127,
    radius: 45,
  },
};

const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight,
};

const styles = {
  container: {
    position: 'absolute',
    left: '10px',
    top: '10px',
    zIndex: 99999,
  },
  label: {
    color: 'white',
    display: 'flex',
    alignItems: 'center',
    gap: '5px',
    cursor: 'pointer',
  },
  input: {
    cursor: 'pointer',
  },
};

const textConfig = computed(() => ({
  x: 10,
  y: 10,
  fontFamily: 'Calibri',
  fontSize: 24,
  text: message.value,
  fill: 'white',
}));
</script>

----------------------------------------

TITLE: Implementing Draggable Image with React-Konva
DESCRIPTION: Creates a draggable image using React-Konva components. Uses the useImage hook for image loading and implements mouse event handlers for cursor styling.

LANGUAGE: jsx
CODE:
import { Stage, Layer, Image } from 'react-konva';
import useImage from 'use-image';

const App = () => {
  const [yodaImage] = useImage('https://konvajs.org/assets/yoda.jpg');

  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        <Image
          x={50}
          y={50}
          image={yodaImage}
          width={106}
          height={118}
          draggable
          onMouseEnter={(e) => {
            document.body.style.cursor = 'pointer';
          }}
          onMouseLeave={(e) => {
            document.body.style.cursor = 'default';
          }}
        />
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Getting Stage Intersection
DESCRIPTION: Method to find visible shapes at a specific point. Returns the topmost intersecting node at the given coordinates.

LANGUAGE: javascript
CODE:
var shape = stage.getIntersection({x: 50, y: 50});

----------------------------------------

TITLE: Implementing Planets Image Map with React and Konva
DESCRIPTION: This snippet shows how to create the planets image map using React and react-konva. It uses functional components and hooks to manage state and event handling. The code sets up a stage with layers for the image, planet overlays, and text, and includes a checkbox to toggle overlay visibility.

LANGUAGE: jsx
CODE:
import { Stage, Layer, Image, Circle, Text } from 'react-konva';
import { useState } from 'react';
import useImage from 'use-image';

const planets = {
  Mercury: {
    x: 46,
    y: 126,
    radius: 32,
  },
  Venus: {
    x: 179,
    y: 126,
    radius: 79,
  },
  Earth: {
    x: 366,
    y: 127,
    radius: 85,
  },
  Mars: {
    x: 515,
    y: 127,
    radius: 45,
  },
};

const CheckboxStyles = {
  container: {
    position: 'absolute',
    left: '10px',
    top: '10px',
    zIndex: 99999,
  },
  label: {
    color: 'white',
    display: 'flex',
    alignItems: 'center',
    gap: '5px',
    cursor: 'pointer',
  },
  input: {
    cursor: 'pointer',
  },
};

const App = () => {
  const [message, setMessage] = useState('');
  const [showOverlay, setShowOverlay] = useState(false);
  const [planetsImage] = useImage('https://konvajs.org/assets/planets.png');

  return (
    <>
      <div style={CheckboxStyles.container}>
        <label style={CheckboxStyles.label}>
          <input
            type="checkbox"
            style={CheckboxStyles.input}
            checked={showOverlay}
            onChange={(e) => setShowOverlay(e.target.checked)}
          />
          Show map overlay
        </label>
      </div>
      <Stage width={window.innerWidth} height={window.innerHeight}>
        <Layer>
          {planetsImage && <Image image={planetsImage} />}
        </Layer>
        <Layer>
          {Object.entries(planets).map(([name, planet]) => (
            <Circle
              key={name}
              x={planet.x}
              y={planet.y}
              radius={planet.radius}
              fill={showOverlay ? 'red' : null}
              onMouseEnter={() => setMessage(name)}
              onMouseLeave={() => setMessage('')}
            />
          ))}
        </Layer>
        <Layer>
          <Text
            x={10}
            y={10}
            fontFamily="Calibri"
            fontSize={24}
            text={message}
            fill="white"
          />
        </Layer>
      </Stage>
    </>
  );
};

export default App;

----------------------------------------

TITLE: Implementing Image Events with Konva in Vanilla JavaScript
DESCRIPTION: This snippet demonstrates how to create image events in Konva using vanilla JavaScript. It shows how to load images, add them to a Konva stage, and implement mouseover events with different hit detection for transparent pixels.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight,
});

const layer = new Konva.Layer();
stage.add(layer);

const text = new Konva.Text({
  x: 10,
  y: 10,
  fontFamily: 'Calibri',
  fontSize: 24,
  text: '',
  fill: 'black',
});
layer.add(text);

function writeMessage(message) {
  text.text(message);
}

const imageObj1 = new Image();
imageObj1.onload = () => {
  const monkey = new Konva.Image({
    x: 120,
    y: 50,
    image: imageObj1,
    width: 200,
    height: 200,
  });

  monkey.on('mouseover', function () {
    writeMessage('mouseover monkey (regular image)');
  });
  monkey.on('mouseout', function () {
    writeMessage('');
  });

  layer.add(monkey);
};
imageObj1.src = 'https://konvajs.org/assets/monkey.png';

const imageObj2 = new Image();
imageObj2.onload = () => {
  const lion = new Konva.Image({
    x: 320,
    y: 50,
    image: imageObj2,
    width: 200,
    height: 200,
  });

  // override color detection region
  lion.on('mouseover', function () {
    writeMessage('mouseover lion (with transparent pixels detection)');
  });
  lion.on('mouseout', function () {
    writeMessage('');
  });

  layer.add(lion);
  lion.cache();
  lion.drawHitFromCache();
};
imageObj2.src = 'https://konvajs.org/assets/lion.png';

----------------------------------------

TITLE: Configuring Pointer Event Capture in Konva
DESCRIPTION: Controls whether touch events should be captured and bound to the touchstart target. Affects how touch events propagate between elements.

LANGUAGE: javascript
CODE:
Konva.capturePointerEventsEnabled = true;

----------------------------------------

TITLE: Implementing Pointer Events with Vanilla JavaScript and Konva.js
DESCRIPTION: Creates an interactive triangle shape that displays pointer coordinates when moved over. Uses Konva.js to handle pointer events and display text updates on canvas.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight,
});

const layer = new Konva.Layer();

const text = new Konva.Text({
  x: 10,
  y: 10,
  fontFamily: 'Calibri',
  fontSize: 24,
  text: '',
  fill: 'black',
});

const triangle = new Konva.RegularPolygon({
  x: stage.width() / 2,
  y: stage.height() / 2,
  sides: 3,
  radius: 80,
  fill: '#00D2FF',
  stroke: 'black',
  strokeWidth: 4,
});

function writeMessage(message) {
  text.text(message);
}

triangle.on('pointermove', function () {
  const pos = stage.getPointerPosition();
  writeMessage('x: ' + pos.x + ', y: ' + pos.y);
});

triangle.on('pointerout', function () {
  writeMessage('');
});

layer.add(triangle);
layer.add(text);
stage.add(layer);

----------------------------------------

TITLE: Implementing Image Zoom with React and Konva
DESCRIPTION: Implements zoomable image functionality using React with react-konva. Uses React hooks to manage state for scaling and position. The component handles mouse events to create a smooth zoom effect on hover.

LANGUAGE: javascript
CODE:
const App = () => {
  const [image] = useImage('https://konvajs.org/assets/space.jpg');
  const [scale, setScale] = useState(1);
  const [position, setPosition] = useState({ x: 0, y: 0 });

  const handleMouseEnter = () => {
    setScale(2);
  };

  const handleMouseMove = (e) => {
    const stage = e.target.getStage();
    const pos = stage.getPointerPosition();
    setPosition({
      x: -pos.x,
      y: -pos.y,
    });
  };

  const handleMouseLeave = () => {
    setScale(1);
    setPosition({ x: 0, y: 0 });
  };

  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer
        scaleX={scale}
        scaleY={scale}
        x={position.x}
        y={position.y}
        onMouseEnter={handleMouseEnter}
        onMouseMove={handleMouseMove}
        onMouseLeave={handleMouseLeave}
      >
        {image && (
          <Image
            image={image}
            width={window.innerWidth}
            height={window.innerHeight}
          />
        )}
      </Layer>
    </Stage>
  );
};

----------------------------------------

TITLE: Installing Svelte Konva Dependencies
DESCRIPTION: NPM installation command for adding svelte-konva and konva packages to a Svelte project.

LANGUAGE: npm
CODE:
npm i svelte-konva konva

----------------------------------------

TITLE: Firing Custom Events with Konva in Vue
DESCRIPTION: This snippet demonstrates how to create a Konva stage with a circle shape in Vue, attach a custom event listener, and fire the custom event. It uses the ref attribute to reference the circle and includes a button to trigger the event.

LANGUAGE: html
CODE:
<template>
  <div>
    <button @click="fireCustomEvent">Fire Custom Event</button>
    <v-stage :config="stageSize">
      <v-layer>
        <v-circle
          ref="circleRef"
          :config="circleConfig"
          @customEvent="handleCustomEvent"
        />
      </v-layer>
    </v-stage>
  </div>
</template>

<script setup>
import { ref } from 'vue';

const circleRef = ref(null);

const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight
};

const circleConfig = {
  x: window.innerWidth / 2,
  y: window.innerHeight / 2,
  radius: 70,
  fill: 'red',
  stroke: 'black',
  strokeWidth: 4
};

const handleCustomEvent = () => {
  alert('custom event fired');
};

const fireCustomEvent = () => {
  circleRef.value.getNode().fire('customEvent', {
    bubbles: true,
  });
};
</script>

----------------------------------------

TITLE: Creating a Blob Shape with Konva in Vanilla JavaScript
DESCRIPTION: This snippet demonstrates how to create a blob shape using Konva.Line in vanilla JavaScript. It sets up a stage, adds a layer, and creates a blob with specific points, fill, stroke, and tension properties.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight
});

const layer = new Konva.Layer();
stage.add(layer);

const blob = new Konva.Line({
  points: [23, 20, 23, 160, 70, 93, 150, 109, 290, 139, 270, 93],
  fill: '#00D2FF',
  stroke: 'black',
  strokeWidth: 5,
  closed: true,
  tension: 0.3
});

layer.add(blob);

----------------------------------------

TITLE: Implementing Shape Groups with React-Konva
DESCRIPTION: Creates a draggable group containing a circle and rectangle using React-Konva components. Shows how to compose shapes within a group using React's declarative syntax.

LANGUAGE: javascript
CODE:
import { Stage, Layer, Group, Circle, Rect } from 'react-konva';

const App = () => {
  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        <Group x={50} y={50} draggable>
          <Circle
            x={40}
            y={40}
            radius={30}
            fill="red"
            stroke="black"
            strokeWidth={4}
          />
          <Rect
            x={80}
            y={20}
            width={100}
            height={50}
            fill="green"
            stroke="black"
            strokeWidth={4}
          />
        </Group>
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Implementing Stage Events with Vue and Konva
DESCRIPTION: Vue implementation of stage event handling using vue-konva. Uses Vue's composition API with refs and computed properties to manage state and handle click events. Creates a responsive canvas with interactive circle and text elements.

LANGUAGE: html
CODE:
<template>
  <v-stage :config="stageSize" @click="handleStageClick">
    <v-layer>
      <v-text :config="textConfig" />
      <v-circle :config="circleConfig" />
    </v-layer>
  </v-stage>
</template>

<script setup>
import { ref, computed } from 'vue';

const message = ref('');

const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight
};

const textConfig = computed(() => ({
  x: 10,
  y: 10,
  fontFamily: 'Calibri',
  fontSize: 24,
  text: message.value,
  fill: 'black'
}));

const circleConfig = {
  x: window.innerWidth / 2,
  y: window.innerHeight / 2,
  radius: 70,
  fill: 'red',
  stroke: 'black',
  strokeWidth: 4,
  name: 'circle'
};

const handleStageClick = (e) => {
  if (e.target === e.target.getStage()) {
    message.value = 'clicked on stage';
    return;
  }
  message.value = 'clicked on ' + e.target.name();
};
</script>

----------------------------------------

TITLE: Disabling Automatic Syncing in svelte-konva
DESCRIPTION: This snippet demonstrates how to use the staticConfig prop to disable automatic syncing of the config object with Konva's internal state. It creates a Stage with a draggable Rectangle, where the x and y values won't be synced after dragging.

LANGUAGE: javascript
CODE:
<script>
  import { Stage, Layer, Rect } from 'svelte-konva';

  // x and y values will not be synced with actual position after dragend
  const config = { x: 100, y: 100, width: 400, height: 200, fill: 'blue', draggable: true };
</script>

<Stage config={{ width: window.innerWidth, height: window.innerHeight }}>
  <Layer>
    <Rect {config} staticConfig />
  </Layer>
</Stage>

----------------------------------------

TITLE: Setting Tag Pointer Height
DESCRIPTION: Sets the height of the tag's pointer element.

LANGUAGE: javascript
CODE:
tag.pointerHeight(20);

----------------------------------------

TITLE: Stopping Shape Transform with React and react-konva
DESCRIPTION: This React component uses react-konva to create a yellow rectangle with a transformer. It stops the transformation when the width of the shape exceeds 200 pixels.

LANGUAGE: jsx
CODE:
import { Stage, Layer, Rect, Transformer } from 'react-konva';
import { useRef, useEffect } from 'react';

const App = () => {
  const rectRef = useRef();
  const trRef = useRef();

  useEffect(() => {
    trRef.current.nodes([rectRef.current]);
  }, []);

  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        <Rect
          x={50}
          y={50}
          width={100}
          height={100}
          fill="yellow"
          stroke="black"
          draggable
          ref={rectRef}
          onTransform={() => {
            const node = rectRef.current;
            const width = node.width() * node.scaleX();
            if (width > 200) {
              trRef.current.stopTransform();
            }
          }}
        />
        <Transformer ref={trRef} />
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Using Selectors in Konva
DESCRIPTION: This example demonstrates how to use selectors in Konva to find specific elements. It shows how to search for shapes by type, id, and name, which is useful for managing large applications.

LANGUAGE: javascript
CODE:
var circle = new Konva.Circle({
  radius: 10,
  fill: 'red',
  id: 'face',
  name: 'red circle',
});
layer.add(circle);

// then try to search

// find by type
layer.find('Circle'); // returns array of all circles

// find by id
layer.findOne('#face');

// find by name (like css class)
layer.find('.red');

----------------------------------------

TITLE: Creating a Konva Wedge
DESCRIPTION: Constructor code for creating a new Konva.Wedge instance with configuration options

LANGUAGE: javascript
CODE:
new Konva.Wedge(config)

----------------------------------------

TITLE: Drawing SVG on Canvas with Konva and canvg in Vanilla JavaScript
DESCRIPTION: This code demonstrates how to render an SVG image on a Konva canvas using both native rendering and the canvg library. It creates a stage, adds a layer, and displays two versions of the same SVG image.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

// Load canvg library
const script = document.createElement('script');
script.src = 'https://cdn.jsdelivr.net/npm/canvg/dist/browser/canvg.min.js';
document.head.appendChild(script);

const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight,
});

const layer = new Konva.Layer();
stage.add(layer);

const SOURCE = 'https://konvajs.org/assets/tiger.svg';

// try to draw SVG natively
Konva.Image.fromURL(SOURCE, (imageNode) => {
  layer.add(imageNode);
  imageNode.setAttrs({
    width: 150,
    height: 150,
  });
});

// draw svg with external library
script.onload = () => {
  const canvas = document.createElement('canvas');
  canvg(canvas, SOURCE, {
    renderCallback: function () {
      const image = new Konva.Image({
        image: canvas,
        x: 200,
        width: 150,
        height: 150,
      });
      layer.add(image);
    },
  });
};

----------------------------------------

TITLE: Embedding Custom Shape Demo in Svelte
DESCRIPTION: This snippet shows how to embed a CodeSandbox demo of a custom shape implementation using svelte-konva. The iframe is styled to fit the page and allows various sandbox permissions.

LANGUAGE: svelte
CODE:
<iframe 
  src="https://codesandbox.io/p/sandbox/github/konvajs/site/tree/master/svelte-demos/custom_shape?file=/src/App.svelte" 
  style={{
    width: "100%",
    height: "800px",
    border: 0,
    borderRadius: "4px",
    overflow: "hidden"
  }}
  sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"
/>

----------------------------------------

TITLE: Implementing Force Update with React and Konva.js
DESCRIPTION: React implementation of the force update example using react-konva components. Uses hooks to manage state and references for the transformer and group elements.

LANGUAGE: javascript
CODE:
const App = () => {
  const [text, setText] = useState('Some text here');
  const groupRef = useRef();
  const trRef = useRef();

  const handleClick = () => {
    setText('Something else is here');
  };

  useEffect(() => {
    if (trRef.current) {
      trRef.current.nodes([groupRef.current]);
    }
  }, []);

  return (
    <>
      <button onClick={handleClick}>Change text</button>
      <Stage width={window.innerWidth} height={window.innerHeight}>
        <Layer>
          <Group
            x={50}
            y={50}
            draggable
            ref={groupRef}
          >
            <Rect
              width={text.length * 10}
              height={30}
              fill="yellow"
            />
            <Text
              text={text}
              fontSize={24}
            />
          </Group>
          <Transformer
            ref={trRef}
            padding={5}
            enabledAnchors={['middle-left', 'middle-right']}
          />
        </Layer>
      </Stage>
    </>
  );

----------------------------------------

TITLE: Styling Konva Transformer Anchors with Vanilla JavaScript
DESCRIPTION: This snippet demonstrates how to create a Konva stage with a yellow rectangle and a transformer. It uses the anchorStyleFunc to customize the appearance of transformer anchors, making them circular, red, and adjusting their size based on position.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const width = window.innerWidth;
const height = window.innerHeight;

const stage = new Konva.Stage({
container: 'container',
width: width,
height: height,
});

const layer = new Konva.Layer();
stage.add(layer);

const rect = new Konva.Rect({
x: 50,
y: 50,
width: 100,
height: 100,
fill: 'yellow',
stroke: 'black',
draggable: true,
});
layer.add(rect);

const tr = new Konva.Transformer({
nodes: [rect],
anchorStyleFunc: (anchor) => {
// make all anchors circles
anchor.cornerRadius(50);
// make all anchors red
anchor.fill('red');

    // make right-middle bigger
    if (anchor.hasName('middle-right')) {
      anchor.scale({ x: 2, y: 2 });
    }
    // make top-left invisible
    if (anchor.hasName('top-left')) {
      anchor.scale({ x: 0, y: 0 });
    }

},
});
layer.add(tr);

----------------------------------------

TITLE: Creating Circular Animation with Konva in Vue
DESCRIPTION: This snippet illustrates how to implement a circular animation of a rectangle using Konva.Animation in a Vue component. It utilizes Vue 3's composition API with ref, onMounted, and onUnmounted to manage the animation lifecycle.

LANGUAGE: vue
CODE:
<template>
  <v-stage :config="stageSize">
    <v-layer ref="layerRef">
      <v-rect
        ref="rectRef"
        :config="rectConfig"
      />
    </v-layer>
  </v-stage>
</template>

<script setup>
import { ref, onMounted, onUnmounted } from 'vue';
import Konva from 'konva';

const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight
};

const rectConfig = ref({
  x: 50,
  y: 50,
  width: 50,
  height: 50,
  fill: 'green'
});

const layerRef = ref(null);
const rectRef = ref(null);
let anim = null;

onMounted(() => {
  anim = new Konva.Animation((frame) => {
    const time = frame.time;
    const timeDiff = frame.timeDiff;
    const frameRate = frame.frameRate;
    
    // Example: move rectangle in a circle
    const radius = 50;
    const x = radius * Math.cos(frame.time * 2 * Math.PI / 2000) + 100;
    const y = radius * Math.sin(frame.time * 2 * Math.PI / 2000) + 100;
    rectRef.value.getNode().position({ x, y });
  }, layerRef.value.getNode());

  anim.start();
});

onUnmounted(() => {
  if (anim) {
    anim.stop();
  }
});
</script>

----------------------------------------

TITLE: Implementing Common Easings with Konva in Vue
DESCRIPTION: This snippet demonstrates how to create rectangles with different easing functions using Konva in a Vue application. It sets up a stage with multiple rectangles, each using a different easing function, and applies tweens on mouse enter and leave events.

LANGUAGE: vue
CODE:
<template>
  <v-stage :config="stageSize">
    <v-layer>
      <template v-for="(easing, i) in easings" :key="i">
        <v-rect
          :config="getRectConfig(i)"
          @mouseenter="handleMouseEnter($event, easing)"
          @mouseleave="handleMouseLeave($event, easing)"
          @touchstart="handleMouseEnter($event, easing)"
          @touchend="handleMouseLeave($event, easing)"
          ref="rectRefs"
        />
        <v-text :config="getTextConfig(easing, i)" />
      </template>
    </v-layer>
  </v-stage>
</template>

<script setup>
import { ref } from 'vue';
import Konva from 'konva';

const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight
};

const easings = ['Linear', 'EaseIn', 'EaseOut', 'EaseInOut'];
const rectRefs = ref([]);

const getRectConfig = (i) => ({
  x: 50,
  y: 50 + i * 80,
  width: 100,
  height: 50,
  fill: '#00D2FF',
  stroke: 'black',
  strokeWidth: 4
});

const getTextConfig = (easing, i) => ({
  x: 160,
  y: 65 + i * 80,
  text: easing,
  fontSize: 16,
  fontFamily: 'Calibri',
  fill: 'black'
});

const handleMouseEnter = (e, easing) => {
  new Konva.Tween({
    node: e.target,
    duration: 1,
    x: window.innerWidth - 150,
    easing: Konva.Easings[easing]
  }).play();
};

const handleMouseLeave = (e, easing) => {
  new Konva.Tween({
    node: e.target,
    duration: 1,
    x: 50,
    easing: Konva.Easings[easing]
  }).play();
};
</script>

----------------------------------------

TITLE: Embedding CodeSandbox Demo for Konva Image Drawing in Svelte
DESCRIPTION: This code snippet embeds a CodeSandbox demonstration of how to draw images on a canvas using Konva and Svelte. The iframe provides an interactive environment for users to explore and experiment with the code.

LANGUAGE: svelte
CODE:
<iframe 
  src="https://codesandbox.io/p/sandbox/github/konvajs/site/tree/master/svelte-demos/images?file=/src/App.svelte" 
  style={{
    width: "100%",
    height: "800px",
    border: 0,
    borderRadius: "4px",
    overflow: "hidden"
  }}
  sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"
/>

----------------------------------------

TITLE: Selecting Shapes by Name in React with react-konva
DESCRIPTION: React implementation of shape selection using react-konva components. Uses useRef and useEffect hooks to access and animate shapes after component mounting.

LANGUAGE: javascript
CODE:
import { Stage, Layer, Circle, Rect } from 'react-konva';
import { useEffect, useRef } from 'react';

const App = () => {
  const layerRef = useRef(null);
  
  useEffect(() => {
    // find all circles by name and animate them
    const circles = layerRef.current.find('.myCircle');
    circles.forEach(circle => {
      circle.to({
        duration: 1,
        rotation: 360,
        easing: Konva.Easings.EaseInOut
      });
    });
  }, []);

  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer ref={layerRef}>
        <Circle
          x={50}
          y={window.innerHeight / 2}
          radius={30}
          fill="red"
          name="myCircle"
        />
        <Circle
          x={150}
          y={window.innerHeight / 2}
          radius={30}
          fill="green"
          name="myCircle"
        />
        <Rect
          x={250}
          y={window.innerHeight / 2 - 25}
          width={50}
          height={50}
          fill="blue"
          name="myRect"
        />
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Implementing Shape Resize with Ratio Preservation in React using react-konva
DESCRIPTION: This snippet shows how to create resizable text shapes on an HTML5 Canvas using react-konva in a React application. It demonstrates two examples: one that preserves aspect ratio by default and another that only preserves ratio when the Shift key is held.

LANGUAGE: jsx
CODE:
import { Stage, Layer, Text, Transformer } from 'react-konva';
import { useRef, useEffect } from 'react';

const App = () => {
  const text1Ref = useRef();
  const text2Ref = useRef();
  const tr1Ref = useRef();
  const tr2Ref = useRef();

  useEffect(() => {
    tr1Ref.current.nodes([text1Ref.current]);
    tr2Ref.current.nodes([text2Ref.current]);
  }, []);

  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        <Text
          x={50}
          y={50}
          text="keep ratio by default"
          fontSize={20}
          draggable
          width={200}
          ref={text1Ref}
        />
        <Transformer ref={tr1Ref} />

        <Text
          x={50}
          y={150}
          text="no ratio, but hold shift to keep ratio"
          fontSize={20}
          draggable
          width={200}
          ref={text2Ref}
        />
        <Transformer ref={tr2Ref} keepRatio={false} />
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Moving Shapes Between Groups - Vanilla JavaScript Implementation
DESCRIPTION: Creates a canvas with two draggable groups (yellow and blue) and a red box that can be moved between them using buttons. Uses Konva's moveTo() method to handle container changes.

LANGUAGE: javascript
CODE:
const width = window.innerWidth;
const height = window.innerHeight;

const stage = new Konva.Stage({
container: 'container',
width: width,
height: height,
});

const layer = new Konva.Layer();

// yellow group
const group1 = new Konva.Group({
x: 50,
y: 50,
draggable: true,
});

const yellow = new Konva.Rect({
width: 100,
height: 100,
fill: 'yellow',
stroke: 'black',
strokeWidth: 4,
});
group1.add(yellow);

// blue group
const group2 = new Konva.Group({
x: 200,
y: 50,
draggable: true,
});

const blue = new Konva.Rect({
width: 100,
height: 100,
fill: 'blue',
stroke: 'black',
strokeWidth: 4,
});
group2.add(blue);

// red box
const redBox = new Konva.Rect({
x: 10,
y: 10,
width: 30,
height: 30,
fill: 'red',
});
group1.add(redBox);

layer.add(group1);
layer.add(group2);
stage.add(layer);

----------------------------------------

TITLE: Initializing Konva Transformer
DESCRIPTION: Creates a new Transformer instance with optional configuration parameters. The transformer allows transforming Konva primitives and shapes by changing scaleX and scaleY properties rather than width and height.

LANGUAGE: javascript
CODE:
new Konva.Transformer(config)

----------------------------------------

TITLE: Implementing Line Join Styles with React-Konva
DESCRIPTION: This React component creates a Konva stage with a triangle shape using React-Konva. It uses React state to manage the line join style and changes it on mouseenter events, cycling through miter, bevel, and round styles.

LANGUAGE: jsx
CODE:
import { Stage, Layer, RegularPolygon } from 'react-konva';
import { useState } from 'react';

const App = () => {
  const [lineJoin, setLineJoin] = useState('miter');

  const handleMouseEnter = () => {
    const lineJoins = ['miter', 'bevel', 'round'];
    const index = lineJoins.indexOf(lineJoin);
    const nextIndex = (index + 1) % lineJoins.length;
    setLineJoin(lineJoins[nextIndex]);
  };

  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        <RegularPolygon
          x={window.innerWidth / 2}
          y={window.innerHeight / 2}
          sides={3}
          radius={70}
          fill="#00D2FF"
          stroke="black"
          strokeWidth={20}
          lineJoin={lineJoin}
          onMouseEnter={handleMouseEnter}
        />
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Embedding CodeSandbox for Konva Node Access in Svelte
DESCRIPTION: This code snippet embeds a CodeSandbox iframe demonstrating how to access the Konva node in a Svelte application. The sandbox contains an example implementation in the App.svelte file.

LANGUAGE: svelte
CODE:
<iframe 
  src="https://codesandbox.io/p/sandbox/github/konvajs/site/tree/master/svelte-demos/konva_node?file=/src/App.svelte" 
  style={{
    width: "100%",
    height: "800px",
    border: 0,
    borderRadius: "4px",
    overflow: "hidden"
  }}
  sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"
/>

----------------------------------------

TITLE: Implementing Rotation Animation with Konva in React
DESCRIPTION: This snippet shows how to create a rotation animation for three rectangles using Konva in a React component. It uses useRef and useEffect hooks to manage the animation and component lifecycle.

LANGUAGE: jsx
CODE:
import { Stage, Layer, Rect } from 'react-konva';
import { useEffect, useRef } from 'react';

const App = () => {
  const blueRectRef = useRef(null);
  const yellowRectRef = useRef(null);
  const redRectRef = useRef(null);

  useEffect(() => {
    const angularSpeed = 90;
    const anim = new Konva.Animation((frame) => {
      const angleDiff = (frame.timeDiff * angularSpeed) / 1000;
      blueRectRef.current.rotate(angleDiff);
      yellowRectRef.current.rotate(angleDiff);
      redRectRef.current.rotate(angleDiff);
    }, blueRectRef.current.getLayer());

    anim.start();

    return () => {
      anim.stop();
    };
  }, []);

  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        <Rect
          ref={blueRectRef}
          x={50}
          y={50}
          width={100}
          height={50}
          fill="#00D2FF"
          stroke="black"
          strokeWidth={4}
          offsetX={0}
          offsetY={0}
        />
        <Rect
          ref={yellowRectRef}
          x={200}
          y={50}
          width={100}
          height={50}
          fill="yellow"
          stroke="black"
          strokeWidth={4}
          offsetX={50}
          offsetY={25}
        />
        <Rect
          ref={redRectRef}
          x={350}
          y={50}
          width={100}
          height={50}
          fill="red"
          stroke="black"
          strokeWidth={4}
          offsetX={-50}
          offsetY={25}
        />
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Implementing Multi-touch Shape Scaling with React and Konva
DESCRIPTION: This code snippet shows how to create a canvas with draggable and scalable shapes using React and react-konva. It uses React hooks for state management and includes touch event handling for multi-touch scaling and shape activation.

LANGUAGE: jsx
CODE:
import { Stage, Layer, RegularPolygon, Circle } from 'react-konva';
import { useState, useEffect } from 'react';

// by default Konva prevent some events when node is dragging
// it improve the performance and work well for 95% of cases
// we need to enable all events on Konva, even when we are dragging a node
// so it triggers touchmove correctly
window.Konva.hitOnDragEnabled = true;

const App = () => {
  const [activeShape, setActiveShape] = useState(null);
  const [lastDist, setLastDist] = useState(0);
  const [shapes, setShapes] = useState({
    triangle: {
      scaleX: 1,
      scaleY: 1,
      fill: 'green',
      stroke: 'black'
    },
    circle: {
      scaleX: 1,
      scaleY: 1,
      fill: 'red',
      stroke: 'black'
    }
  });

  const getDistance = (p1, p2) => {
    return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
  };

  const handleTap = (shapeName) => {
    setActiveShape(activeShape === shapeName ? null : shapeName);
    
    setShapes(prev => ({
      ...prev,
      triangle: {
        ...prev.triangle,
        fill: shapeName === 'triangle' ? '#78E7FF' : 'green',
        stroke: shapeName === 'triangle' ? 'blue' : 'black'
      },
      circle: {
        ...prev.circle,
        fill: shapeName === 'circle' ? '#78E7FF' : 'red',
        stroke: shapeName === 'circle' ? 'blue' : 'black'
      }
    }));
  };

  useEffect(() => {
    const handleTouchMove = (evt) => {
      const touch1 = evt.touches[0];
      const touch2 = evt.touches[1];

      if (touch1 && touch2 && activeShape) {
        const dist = getDistance(
          {
            x: touch1.clientX,
            y: touch1.clientY,
          },
          {
            x: touch2.clientX,
            y: touch2.clientY,
          }
        );

        if (!lastDist) {
          setLastDist(dist);
          return;
        }

        const scale = (shapes[activeShape].scaleX * dist) / lastDist;

        setShapes(prev => ({
          ...prev,
          [activeShape]: {
            ...prev[activeShape],
            scaleX: scale,
            scaleY: scale
          }
        }));

        setLastDist(dist);
      }
    };

    const handleTouchEnd = () => {
      setLastDist(0);
    };

    const content = document.getElementsByClassName('konvajs-content')[0];
    if (content) {
      content.addEventListener('touchmove', handleTouchMove, false);
      content.addEventListener('touchend', handleTouchEnd, false);
    }

    return () => {
      if (content) {
        content.removeEventListener('touchmove', handleTouchMove);
        content.removeEventListener('touchend', handleTouchEnd);
      }
    };
  }, [activeShape, lastDist, shapes]);

  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        <RegularPolygon
          x={190}
          y={window.innerHeight / 2}
          sides={3}
          radius={80}
          fill={shapes.triangle.fill}
          stroke={shapes.triangle.stroke}
          strokeWidth={4}
          draggable
          name="triangle"
          scaleX={shapes.triangle.scaleX}
          scaleY={shapes.triangle.scaleY}
          onTap={() => handleTap('triangle')}
        />
        <Circle
          x={380}
          y={window.innerHeight / 2}
          radius={70}
          fill={shapes.circle.fill}
          stroke={shapes.circle.stroke}
          strokeWidth={4}
          draggable
          name="circle"
          scaleX={shapes.circle.scaleX}
          scaleY={shapes.circle.scaleY}
          onTap={() => handleTap('circle')}
        />
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Optimizing Canvas Performance with Konva - Vue Implementation
DESCRIPTION: Vue 3 version of the performance comparison demo using v-konva components. Uses the Composition API with refs to manage animations and demonstrates the stroke shadow optimization technique in a Vue context.

LANGUAGE: javascript
CODE:
<template>
  <v-stage :config="stageSize">
    <v-layer ref="layerRef">
      <v-circle
        ref="circleWithShadowRef"
        :config="circleWithShadowConfig"
      />
      
      <v-circle
        ref="circleOptimizedRef"
        :config="circleOptimizedConfig"
      />
      
      <v-text :config="defaultLabelConfig" />
      <v-text :config="optimizedLabelConfig" />
      
      <v-text
        ref="fpsTextRef"
        :config="fpsConfig"
      />
    </v-layer>
  </v-stage>
</template>

<script setup>
import { ref, onMounted, onUnmounted } from 'vue';
import Konva from 'konva';

const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight
};

const circleWithShadowConfig = {
  x: 100,
  y: 100,
  radius: 50,
  fill: 'red',
  stroke: 'black',
  strokeWidth: 4,
  shadowColor: 'black',
  shadowBlur: 10,
  shadowOffset: { x: 5, y: 5 },
  shadowOpacity: 0.5
};

const circleOptimizedConfig = {
  x: 250,
  y: 100,
  radius: 50,
  fill: 'red',
  stroke: 'black',
  strokeWidth: 4,
  shadowColor: 'black',
  shadowBlur: 10,
  shadowOffset: { x: 5, y: 5 },
  shadowOpacity: 0.5,
  shadowForStrokeEnabled: false
};

const defaultLabelConfig = {
  x: 50,
  y: 170,
  text: 'With Stroke Shadow',
  fontSize: 16
};

const optimizedLabelConfig = {
  x: 200,
  y: 170,
  text: 'Without Stroke Shadow\n(Better Performance)',
  fontSize: 16
};

const fpsConfig = ref({
  x: 10,
  y: 10,
  text: 'FPS: 0',
  fontSize: 16
});

const layerRef = ref(null);
const circleWithShadowRef = ref(null);
const circleOptimizedRef = ref(null);
const fpsTextRef = ref(null);
let anim = null;

onMounted(() => {
  anim = new Konva.Animation((frame) => {
    circleWithShadowRef.value.getNode().rotation(frame.time * 0.1);
    circleOptimizedRef.value.getNode().rotation(frame.time * 0.1);
    
    fpsTextRef.value.getNode().text('FPS: ' + frame.frameRate.toFixed(1));
  }, layerRef.value.getNode());

  anim.start();
});

onUnmounted(() => {
  if (anim) {
    anim.stop();
  }
});
</script>

----------------------------------------

TITLE: Image Enhancement using React with Konva
DESCRIPTION: React implementation of image enhancement using react-konva. Uses hooks for state management and refs for accessing the Konva node. Demonstrates integration with React's component lifecycle.

LANGUAGE: javascript
CODE:
import { Stage, Layer, Image } from 'react-konva';
import { useState, useEffect, useRef } from 'react';
import useImage from 'use-image';

const App = () => {
  const [enhance, setEnhance] = useState(0.4);
  const [image] = useImage('https://konvajs.org/assets/lion.png', 'anonymous');
  const imageRef = useRef(null);

  useEffect(() => {
    if (image) {
      imageRef.current.cache();
    }
  }, [image]);

  return (
    <>
      <Stage width={window.innerWidth} height={window.innerHeight}>
        <Layer>
          <Image
            ref={imageRef}
            x={50}
            y={50}
            image={image}
            draggable
            filters={[Konva.Filters.Enhance]}
            enhance={enhance}
          />
        </Layer>
      </Stage>
      <input
        type="range"
        min="-1"
        max="1"
        step="0.1"
        value={enhance}
        onChange={(e) => setEnhance(parseFloat(e.target.value))}
        style={{ position: 'absolute', top: '20px', left: '20px' }}
      />
    </>
  );
};

export default App;

----------------------------------------

TITLE: Dynamically importing svelte-konva component in SvelteKit page
DESCRIPTION: This SvelteKit page component demonstrates how to dynamically import a svelte-konva canvas component inside onMount() to avoid SSR issues. It uses svelte:component to render the dynamically imported component.

LANGUAGE: javascript
CODE:
<script>
  import { onMount } from 'svelte';
  // typescript:
  // import type MyCanvasComponent from '$lib/MyCanvas.svelte';

  let MyCanvas;
  // typescript:
  // let MyCanvas: typeof MyCanvasComponent;

  onMount(async () => {
    // Dynamically import your canvas component encapsulating all svelte-konva functionality inside onMount()
    MyCanvas = (await import('$lib/MyCanvas.svelte')).default;
  });
</script>

<div>
  <p>This is my fancy server side rendered (or prerendered) page.</p>

  <!-- Use your dynamically imported svelte-konva canvas component with a svelte:component block, you can pass any component props as usual -->
  <svelte:component this={MyCanvas} someProp="SomeString" />
</div>

----------------------------------------

TITLE: Creating a Blob Shape with Konva in React
DESCRIPTION: This snippet shows how to create a blob shape using react-konva components in a React application. It uses the Stage, Layer, and Line components to render a blob with specific properties.

LANGUAGE: javascript
CODE:
import { Stage, Layer, Line } from 'react-konva';

const App = () => {
  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        <Line
          points={[23, 20, 23, 160, 70, 93, 150, 109, 290, 139, 270, 93]}
          fill="#00D2FF"
          stroke="black"
          strokeWidth={5}
          closed
          tension={0.3}
        />
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: React Implementation of Canvas Context Menu with Konva
DESCRIPTION: React-specific implementation of canvas context menu using react-konva. Uses React hooks for state management and handles circle creation, menu positioning, and shape manipulations.

LANGUAGE: jsx
CODE:
import { useState, useRef, useEffect } from 'react';
import { Stage, Layer, Circle } from 'react-konva';

const App = () => {
  const [circles, setCircles] = useState([
    {
      id: 'initial-circle',
      x: window.innerWidth / 2,
      y: window.innerHeight / 2,
      radius: 50,
      fill: 'red',
      shadowBlur: 10
    }
  ]);
  // ... [rest of React implementation]

----------------------------------------

TITLE: Implementing Bouncing Bunnies Animation with Vue and Konva
DESCRIPTION: This Vue component uses v-konva to create a performance test with bouncing bunnies. It manages reactive state for the bunnies, handles user interactions, and updates positions using direct node manipulation for optimal performance.

LANGUAGE: vue
CODE:
<template>
  <div>
    
    <v-stage
      :config="stageConfig"
      @mousedown="isAdding = true"
      @mouseup="isAdding = false"
      @touchstart="isAdding = true"
      @touchend="isAdding = false"
    >
      <v-fast-layer ref="layerRef">
        <v-image
          v-for="(bunny, index) in bunnies"
          :key="index"
          :config="{
            image: bunnyImage,
            x: bunny.x,
            y: bunny.y,
            transformsEnabled: 'position',
            perfectDrawEnabled: false
          }"
          :ref="el => storeNodeRef(index, el)"
        />
      </v-fast-layer>
    </v-stage>
    <div 
      style="position: absolute; top: 50px; background-color: white; font-size: 12px; padding: 5px;"
    >
      {{ count }} BUNNIES
    </div>
  </div>
</template>

<script setup>
import { ref, reactive, onMounted, onUnmounted } from 'vue';

// Stage setup with fixed dimensions
const stageConfig = {
  width: window.innerWidth,
  height: window.innerHeight
};

// Refs
const layerRef = ref(null);
const bunnyImage = ref(null);
const bunnies = ref([]);
const count = ref(0);
const isAdding = ref(false);
const animationFrameId = ref(null);
const bunnyNodesMap = ref({}); // Store references to Konva nodes by index

// Constants
const GRAVITY = 0.75;
const START_COUNT = 100;
const ADD_AMOUNT = 10;

// Store references to Konva image nodes
const storeNodeRef = (index, el) => {
  if (el) {
    bunnyNodesMap.value[index] = el;
  }
};

// Create a bunny with position and velocity
const createBunny = (x, y) => ({
  x,
  y,
  speedX: Math.random() * 10,
  speedY: Math.random() * 10 - 5
});

// Animation update function - Using direct node manipulation for performance
const update = () => {
  // Add more bunnies if needed
  if (isAdding.value) {
    const newBunnies = Array(ADD_AMOUNT)
      .fill(0)
      .map(() => 
        createBunny(
          Math.random() * stageConfig.width,
          Math.random() * stageConfig.height
        )
      );
    
    // Update the reactive array only once for the new bunnies
    bunnies.value.push(...newBunnies);
    count.value += ADD_AMOUNT;
  }
  
  // Update all bunnies - DIRECT NODE MANIPULATION FOR PERFORMANCE
  // This avoids expensive Vue reactivity for position updates
  bunnies.value.forEach((bunny, index) => {
    // Update data model
    bunny.x += bunny.speedX;
    bunny.y += bunny.speedY;
    bunny.speedY += GRAVITY;
    
    // Bounce off edges
    if (bunny.x > stageConfig.width - bunnyImage.value.width) {
      bunny.speedX *= -1;
      bunny.x = stageConfig.width - bunnyImage.value.width;
    } else if (bunny.x < 0) {
      bunny.speedX *= -1;
      bunny.x = 0;
    }
    
    if (bunny.y > stageConfig.height - bunnyImage.value.height) {
      bunny.speedY *= -0.85;
      bunny.y = stageConfig.height - bunnyImage.value.height;
      if (Math.random() > 0.5) {
        bunny.speedY -= Math.random() * 6;
      }
    } else if (bunny.y < 0) {
      bunny.speedY = 0;
      bunny.y = 0;
    }
    
    // Direct node update if we have a reference (much faster than Vue reactivity)
    const node = bunnyNodesMap.value[index];
    if (node) {
      // Get the Konva node and update position directly
      const konvaNode = node.getNode();
      if (konvaNode) {
        konvaNode.x(bunny.x);
        konvaNode.y(bunny.y);
      }
    }
  });
  
  // Batch draw the layer once instead of updating each node individually
  if (layerRef.value) {
    layerRef.value.getNode().batchDraw();
  }
  
  animationFrameId.value = requestAnimationFrame(update);
};

// Load the bunny image
onMounted(() => {
  const img = new Image();
  img.src = 'https://konvajs.org/assets/bunny.png';
  img.onload = () => {
    bunnyImage.value = img;
    
    // Add initial bunnies
    const initialBunnies = Array(START_COUNT)
      .fill(0)
      .map(() => 
        createBunny(
          Math.random() * stageConfig.width,
          Math.random() * stageConfig.height
        )
      );
    
    bunnies.value = initialBunnies;
    count.value = START_COUNT;
    
    // Start animation
    animationFrameId.value = requestAnimationFrame(update);
  };
  
  onUnmounted(() => {
    if (animationFrameId.value) {
      cancelAnimationFrame(animationFrameId.value);
    }
  });
});
</script>

----------------------------------------

TITLE: Managing Layer Children
DESCRIPTION: Gets array of child nodes with optional filter function.

LANGUAGE: javascript
CODE:
// get all children
var children = layer.getChildren();

// get only circles
var circles = layer.getChildren(function(node){
   return node.getClassName() === 'Circle';
});

----------------------------------------

TITLE: Converting Konva Stage to Data URL in React
DESCRIPTION: This React component creates a Konva stage with a draggable rectangle and provides functionality to convert it to a data URL. It uses the useRef hook to access the stage and the useState hook to manage the rectangle's position.

LANGUAGE: jsx
CODE:
import { Stage, Layer, Rect } from 'react-konva';
import { useRef, useState } from 'react';

const App = () => {
  const stageRef = useRef(null);
  const [position, setPosition] = useState({ x: 100, y: 100 });

  const handleExport = () => {
    // get data URL with default settings
    const dataURL = stageRef.current.toDataURL();
    
    // open in new window
    const win = window.open();
    win.document.write(`<img src="${dataURL}" alt="Stage"/>`);
    
    // you can also save with different settings
    const jpegURL = stageRef.current.toDataURL({
      mimeType: 'image/jpeg',
      quality: 0.8
    });
    console.log('JPEG URL:', jpegURL);
  };

  const handleDragEnd = (e) => {
    setPosition({
      x: e.target.x(),
      y: e.target.y()
    });
  };

  return (
    <div>
      <button onClick={handleExport} style={{ marginBottom: '10px' }}>
        Save as Image
      </button>
      <Stage width={400} height={400} ref={stageRef}>
        <Layer>
          <Rect
            x={position.x}
            y={position.y}
            width={100}
            height={100}
            fill="red"
            stroke="black"
            strokeWidth={4}
            draggable
            onDragEnd={handleDragEnd}
          />
        </Layer>
      </Stage>
    </div>
  );
};

export default App;

----------------------------------------

TITLE: Using vite-plugin-iso-import for client-side only imports in SvelteKit
DESCRIPTION: This SvelteKit page component shows how to use vite-plugin-iso-import to make client-side only imports of svelte-konva components. It demonstrates conditional rendering based on whether the page is being server-side rendered or not.

LANGUAGE: javascript
CODE:
<script>
  import MyCanvasComponent from '$lib/MyCanvas.svelte?client'; // Client-side only import

  // Set component variable to null if page is rendered in SSR, otherwise use client-side only import
  let MyCanvas = import.meta.env.SSR ? null : MyCanvasComponent;
</script>

<div>
  <p>This is my fancy server side rendered (or prerendered) page.</p>

  <!-- Use your dynamically imported svelte-konva canvas component with a svelte:component block, you can pass any component props as usual -->
  <svelte:component this={MyCanvas} someProp="SomeString" />
</div>

----------------------------------------

TITLE: Copying Konva Transform
DESCRIPTION: Creates a copy of an existing Transform object.

LANGUAGE: javascript
CODE:
const tr = shape.getTransform().copy()

----------------------------------------

TITLE: Rendering 20,000 Interactive Nodes with React and Konva
DESCRIPTION: This React component creates an interactive scatter plot with 20,000 draggable circles using react-konva. It demonstrates efficient rendering using memoization and hooks for performance optimization.

LANGUAGE: javascript
CODE:
import { useState, useEffect, useRef, useMemo, useCallback, memo } from 'react';
import { Stage, Layer, Circle, Label, Tag, Text } from 'react-konva';

const CirclesLayer = ({ nodes, onMouseOver, onMouseMove, onMouseOut, onMouseDown, onMouseUp }) => {
  // Only re-render when the nodes array reference changes
  return (
    <Layer>
      {nodes.map(node => (
        <Circle
          key={node.id}
          x={node.x}
          y={node.y}
          radius={4}
          fill={node.color}
          onMouseOver={e => onMouseOver(e, node)}
          onMouseMove={onMouseMove}
          onMouseOut={onMouseOut}
          onDragMove={onMouseMove}
          onMouseDown={e => onMouseDown(e, node)}
          onMouseUp={e => onMouseUp(e, node)}
          draggable
        />
      ))}
    </Layer>
  );
};

// Memoize the CirclesLayer component to prevent unnecessary re-renders
const MemoizedCirclesLayer = memo(CirclesLayer);

const TooltipLayer = ({ tooltip }) => (
  <Layer>
    <Label
      x={tooltip.x}
      y={tooltip.y}
      opacity={0.75}
      visible={tooltip.visible}
    >
      <Tag
        fill="black"
        pointerDirection="down"
        pointerWidth={10}
        pointerHeight={10}
        lineJoin="round"
        shadowColor="black"
        shadowBlur={10}
        shadowOffsetX={10}
        shadowOffsetY={10}
        shadowOpacity={0.2}
      />
      <Text
        text={tooltip.text}
        fontFamily="Calibri"
        fontSize={18}
        padding={5}
        fill="white"
      />
    </Label>
  </Layer>
);

// Memoize the TooltipLayer to only re-render when tooltip props change
const MemoizedTooltipLayer = memo(TooltipLayer);

const App = () => {
  const width = window.innerWidth;
  const height = window.innerHeight;
  
  // Create refs for the layers
  const dragLayerRef = useRef(null);
  
  // State for tooltip
  const [tooltip, setTooltip] = useState({
    visible: false,
    x: 0,
    y: 0,
    text: ''
  });
  
  // State for nodes data - using useMemo to ensure it doesn't regenerate on re-renders
  const nodes = useMemo(() => {
    const colors = ['red', 'orange', 'cyan', 'green', 'blue', 'purple'];
    const data = [];
    
    for (let n = 0; n < 20000; n++) {
      const x = Math.random() * width;
      const y = height + Math.random() * 200 - 100 + (height / width) * -1 * x;
      data.push({
        x,
        y,
        id: n,
        color: colors[Math.round(Math.random() * 5)],
      });
    }
    
    return data;
  }, [width, height]);
  
  // Event handlers - wrap in useCallback to prevent recreating functions on each render
  const handleMouseOver = useCallback((e, node) => {
    const stage = e.target.getStage();
    const pos = stage.getPointerPosition();
    setTooltip({
      visible: true,
      x: pos.x,
      y: pos.y - 5,
      text: `node: ${node.id}, color: ${node.color}`
    });
  }, []);
  
  const handleMouseMove = useCallback((e) => {
    const stage = e.target.getStage();
    const pos = stage.getPointerPosition();
    setTooltip(prev => ({
      ...prev,
      x: pos.x,
      y: pos.y - 5
    }));
  }, []);
  
  const handleMouseOut = useCallback(() => {
    setTooltip(prev => ({
      ...prev,
      visible: false
    }));
  }, []);
  
  const handleMouseDown = useCallback((e, node) => {
    // For drag handling if needed
  }, []);
  
  const handleMouseUp = useCallback((e, node) => {
    // For drag handling if needed
  }, []);
  
  return (
    <Stage width={width} height={height}>
      {/* Render single layer for all circles */}
      <MemoizedCirclesLayer 
        nodes={nodes}
        onMouseOver={handleMouseOver}
        onMouseMove={handleMouseMove}
        onMouseOut={handleMouseOut}
        onMouseDown={handleMouseDown}
        onMouseUp={handleMouseUp}
      />
      
      {/* Drag layer - if needed */}
      <Layer ref={dragLayerRef} />
      
      {/* Tooltip layer */}
      <MemoizedTooltipLayer tooltip={tooltip} />
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Creating Path Shape with Vue-Konva
DESCRIPTION: Illustrates path shape creation using Vue-Konva components. Implements the shape using v-stage, v-layer, and v-path components with configuration objects for stage size and path properties.

LANGUAGE: javascript
CODE:
<template>
  <v-stage :config="stageSize">
    <v-layer>
      <v-path :config="pathConfig" />
    </v-layer>
  </v-stage>
</template>

<script setup>
const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight
};

const pathConfig = {
  x: 50,
  y: 50,
  data: 'M12.582,9.551C3.251,16.237,0.921,29.021,7.08,38.564l-2.36,1.689l4.893,2.262l4.893,2.262l-0.568-5.36l-0.567-5.359l-2.365,1.694c-4.657-7.375-2.83-17.185,4.352-22.33c7.451-5.338,17.817-3.625,23.156,3.824c5.337,7.449,3.625,17.813-3.821,23.152l2.857,3.988c9.617-6.893,11.827-20.277,4.935-29.896C35.591,4.87,22.204,2.658,12.582,9.551z',
  fill: 'green',
  scale: {
    x: 2,
    y: 2
  }
};
</script>

----------------------------------------

TITLE: Connected Objects Demo in React with Konva
DESCRIPTION: This snippet implements the connected objects demo using React and react-konva. It uses React hooks to manage state and update the connections dynamically when circles are dragged.

LANGUAGE: jsx
CODE:
import { useState, useEffect } from 'react';
import { Stage, Layer, Circle, Arrow } from 'react-konva';

const App = () => {
  // Generate initial targets
  const generateTargets = () => {
    const number = 10;
    const result = [];
    while (result.length < number) {
      result.push({
        id: 'target-' + result.length,
        x: window.innerWidth * Math.random(),
        y: window.innerHeight * Math.random(),
        radius: 20 + Math.random() * 20,
        fill: '#' + Math.floor(Math.random()*16777215).toString(16),
      });
    }
    return result;
  };

  // Generate connectors between targets
  const generateConnectors = (targets) => {
    const number = 10;
    const result = [];
    while (result.length < number) {
      const from = 'target-' + Math.floor(Math.random() * targets.length);
      const to = 'target-' + Math.floor(Math.random() * targets.length);
      if (from === to) {
        continue;
      }
      result.push({
        id: 'connector-' + result.length,
        from,
        to,
      });
    }
    return result;
  };

  const [targets, setTargets] = useState([]);
  const [connectors, setConnectors] = useState([]);

  useEffect(() => {
    const initialTargets = generateTargets();
    setTargets(initialTargets);
    setConnectors(generateConnectors(initialTargets));
  }, []);

  const getConnectorPoints = (from, to) => {
    const dx = to.x - from.x;
    const dy = to.y - from.y;
    let angle = Math.atan2(-dy, dx);

    const radius = 50;

    return [
      from.x + -radius * Math.cos(angle + Math.PI),
      from.y + radius * Math.sin(angle + Math.PI),
      to.x + -radius * Math.cos(angle),
      to.y + radius * Math.sin(angle),
    ];
  };

  const handleDragMove = (e) => {
    const id = e.target.id();
    setTargets(
      targets.map((target) =>
        target.id === id
          ? { ...target, x: e.target.x(), y: e.target.y() }
          : target
      )
    );
  };

  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        {connectors.map((connector) => {
          const fromNode = targets.find((t) => t.id === connector.from);
          const toNode = targets.find((t) => t.id === connector.to);
          if (!fromNode || !toNode) return null;

          const points = getConnectorPoints(fromNode, toNode);
          
          return (
            <Arrow
              key={connector.id}
              id={connector.id}
              points={points}
              fill="black"
              stroke="black"
            />
          );
        })}
        {targets.map((target) => (
          <Circle
            key={target.id}
            id={target.id}
            x={target.x}
            y={target.y}
            radius={target.radius}
            fill={target.fill}
            shadowBlur={10}
            draggable
            onDragMove={handleDragMove}
          />
        ))}
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Creating Interactive Button with JavaScript in MDX
DESCRIPTION: This snippet demonstrates how to create an interactive button using JavaScript within an MDX blog post. It uses a React-like syntax to define a button with an onClick event handler that displays an alert when clicked.

LANGUAGE: javascript
CODE:
<button onClick={() => alert('button clicked!')}>Click me!</button>

----------------------------------------

TITLE: Implementing Manual Free Drawing with Native Canvas in Vanilla JavaScript
DESCRIPTION: This snippet shows how to create a free drawing tool using native canvas API and Konva in vanilla JavaScript. It sets up an offscreen canvas for drawing and uses Konva.Image to display the result.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

// create tool select
const select = document.createElement('select');
select.innerHTML = `
  <option value="brush">Brush</option>
  <option value="eraser">Eraser</option>
`;
document.body.appendChild(select);

const width = window.innerWidth;
const height = window.innerHeight - 25;

// first we need Konva core things: stage and layer
const stage = new Konva.Stage({
  container: 'container',
  width: width,
  height: height,
});

const layer = new Konva.Layer();
stage.add(layer);

// then we are going to draw into special canvas element
const canvas = document.createElement('canvas');
canvas.width = stage.width();
canvas.height = stage.height();

// created canvas we can add to layer as "Konva.Image" element
const image = new Konva.Image({
  image: canvas,
  x: 0,
  y: 0,
});
layer.add(image);

// Good. Now we need to get access to context element
const context = canvas.getContext('2d');
context.strokeStyle = '#df4b26';
context.lineJoin = 'round';
context.lineWidth = 5;

let isPaint = false;
let lastPointerPosition;
let mode = 'brush';

// now we need to bind some events
// we need to start drawing on mousedown
// and stop drawing on mouseup
image.on('mousedown touchstart', function () {
  isPaint = true;
  lastPointerPosition = stage.getPointerPosition();
});

stage.on('mouseup touchend', function () {
  isPaint = false;
});

// and core function - drawing
stage.on('mousemove touchmove', function () {
  if (!isPaint) {
    return;
  }

  if (mode === 'brush') {
    context.globalCompositeOperation = 'source-over';
  }
  if (mode === 'eraser') {
    context.globalCompositeOperation = 'destination-out';
  }
  context.beginPath();

  const localPos = {
    x: lastPointerPosition.x - image.x(),
    y: lastPointerPosition.y - image.y(),
  };
  context.moveTo(localPos.x, localPos.y);
  const pos = stage.getPointerPosition();
  const newLocalPos = {
    x: pos.x - image.x(),
    y: pos.y - image.y(),
  };
  context.lineTo(newLocalPos.x, newLocalPos.y);
  context.closePath();
  context.stroke();

  lastPointerPosition = pos;
  // redraw manually
  layer.batchDraw();
});

select.addEventListener('change', function () {
  mode = select.value;
});

----------------------------------------

TITLE: React Konva Game Implementation
DESCRIPTION: React implementation using react-konva components. Utilizes hooks for state management and custom components for Animals and Outlines. Implements the same functionality as vanilla version but with React's component-based architecture.

LANGUAGE: jsx
CODE:
const Animal = ({ name, startX, startY, outline, onScore }) => {
  const [pos, setPos] = useState({ x: startX, y: startY });
  // ... [rest of React implementation]

----------------------------------------

TITLE: Implementing Drag and Drop with Vue and Konva
DESCRIPTION: This snippet shows how to implement drag and drop functionality for DOM images into a Konva canvas using Vue. It includes components for draggable items, handling drag events, and rendering dropped images on the canvas.

LANGUAGE: vue
CODE:
<template>
  <div>
    <p>Drag&drop yoda into the grey area.</p>
    <div style="margin-bottom: 10px;">
      <img 
        src="https://konvajs.org/assets/yoda.jpg" 
        draggable="true" 
        style="height: 100px; margin: 5px;"
        @dragstart="handleDragStart('https://konvajs.org/assets/yoda.jpg')" 
      />
      <img 
        src="https://konvajs.org/assets/darth-vader.jpg" 
        draggable="true" 
        style="height: 100px; margin: 5px;"
        @dragstart="handleDragStart('https://konvajs.org/assets/darth-vader.jpg')" 
      />
    </div>
    
    <div 
      @dragover.prevent
      @drop="handleDrop"
      style="background-color: rgba(0, 0, 0, 0.1);"
    >
      <v-stage 
        ref="stageRef"
        :config="stageConfig"
      >
        <v-layer>
          <v-image
            v-for="img in images"
            :key="img.id"
            :config="getImageConfig(img)"
          />
        </v-layer>
      </v-stage>
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted, computed } from 'vue';

const stageConfig = {
  width: window.innerWidth,
  height: window.innerHeight - 150
};

const stageRef = ref(null);
const images = ref([]);
const dragImageSrc = ref('');
const loadedImages = ref({});

// Handle drag start to track the image being dragged
const handleDragStart = (src) => {
  dragImageSrc.value = src;
};

// Handle drop event to add image to stage
const handleDrop = (e) => {
  e.preventDefault();
  
  if (!dragImageSrc.value || !stageRef.value) return;
  
  // Get stage reference and register pointer positions
  const stage = stageRef.value.getNode();
  stage.setPointersPositions(e);
  const position = stage.getPointerPosition();
  
  // Load the image if not loaded already
  if (!loadedImages.value[dragImageSrc.value]) {
    const img = new Image();
    img.onload = () => {
      loadedImages.value = {
        ...loadedImages.value,
        [dragImageSrc.value]: img
      };
      
      // Add image to the stage
      addImageToStage(dragImageSrc.value, position);
    };
    img.src = dragImageSrc.value;
  } else {
    // Image already loaded, add it to stage
    addImageToStage(dragImageSrc.value, position);
  }
};

// Helper to add image to stage
const addImageToStage = (src, position) => {
  images.value.push({
    src: src,
    x: position.x,
    y: position.y,
    id: Date.now().toString()
  });
};

// Configure image properties 
const getImageConfig = (img) => {
  const image = loadedImages.value[img.src];
  if (!image) return { x: img.x, y: img.y, draggable: true };
  
  // Calculate appropriate size
  const maxDimension = 100;
  let width = image.width;
  let height = image.height;
  
  if (width > height) {
    height = (height / width) * maxDimension;
    width = maxDimension;
  } else {
    width = (width / height) * maxDimension;
    height = maxDimension;
  }
  
  return {
    image: image,
    x: img.x,
    y: img.y,
    width: width,
    height: height,
    draggable: true
  };
};
</script>

----------------------------------------

TITLE: Applying Canvas Filters with Konva in Svelte
DESCRIPTION: Demonstrates the implementation of canvas filters in a Svelte application using Konva.Node. The code shows how to cache nodes and handle dynamic style updates through manual recaching or automatic updates in the afterUpdate lifecycle method.

LANGUAGE: javascript
CODE:
// Initial caching in onMount
onMount(() => {
  node.cache();
});

// Recaching after style changes
node.cache();

// Automatic recaching in afterUpdate
afterUpdate(() => {
  node.cache();
});

----------------------------------------

TITLE: Defining Frontmatter for Docusaurus Blog Post in Markdown
DESCRIPTION: This snippet shows the frontmatter section of a Docusaurus blog post. It defines metadata such as slug, title, authors, and tags.

LANGUAGE: markdown
CODE:
---
slug: long-blog-post
title: Long Blog Post
authors: yangshun
tags: [hello, docusaurus]
---

----------------------------------------

TITLE: Setting Shape Fill
DESCRIPTION: Examples of different ways to set a shape's fill color

LANGUAGE: javascript
CODE:
// get fill color
var fill = shape.fill();

// set fill color with color string
shape.fill('green');

// set fill color with hex
shape.fill('#00ff00');

// set fill color with rgb
shape.fill('rgb(0,255,0)');

// set fill color with rgba and make it 50% opaque
shape.fill('rgba(0,255,0,0.5');

// shape without fill
shape.fill(null);

----------------------------------------

TITLE: Building Svelte Project for Production in Bash
DESCRIPTION: Command to create a production version of the Svelte app.

LANGUAGE: bash
CODE:
npm run build

----------------------------------------

TITLE: Binding Mouse Events to Shapes in React with react-konva
DESCRIPTION: This React component uses react-konva to create a stage with a triangle and circle, binding various mouse events to them. It uses React hooks (useState and useRef) to manage state and access the stage reference.

LANGUAGE: jsx
CODE:
import { Stage, Layer, RegularPolygon, Circle, Text } from 'react-konva';
import { useRef, useState } from 'react';

const App = () => {
  const [message, setMessage] = useState('');
  const stageRef = useRef();

  const writeMessage = (text) => {
    setMessage(text);
  };

  return (
    <Stage width={window.innerWidth} height={window.innerHeight} ref={stageRef}>
      <Layer>
        <Text
          x={10}
          y={10}
          fontFamily="Calibri"
          fontSize={24}
          text={message}
          fill="black"
        />
        <RegularPolygon
          x={80}
          y={120}
          sides={3}
          radius={80}
          fill="#00D2FF"
          stroke="black"
          strokeWidth={4}
          onMouseout={() => writeMessage('Mouseout triangle')}
          onMousemove={() => {
            const mousePos = stageRef.current.getPointerPosition();
            writeMessage('x: ' + mousePos.x + ', y: ' + mousePos.y);
          }}
        />
        <Circle
          x={230}
          y={100}
          radius={60}
          fill="red"
          stroke="black"
          strokeWidth={4}
          onMouseover={() => writeMessage('Mouseover circle')}
          onMouseout={() => writeMessage('Mouseout circle')}
          onMousedown={() => writeMessage('Mousedown circle')}
          onMouseup={() => writeMessage('Mouseup circle')}
        />
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Using Truncate Comment in Docusaurus Blog Post
DESCRIPTION: This snippet demonstrates how to use a truncate comment in a Docusaurus blog post to limit the post size in the list view.

LANGUAGE: markdown
CODE:
<!-- truncate -->

----------------------------------------

TITLE: Setting the closed property of a Konva.Line
DESCRIPTION: Gets or sets the closed flag of the line. When closed is true, the line forms a closed shape (polygon).

LANGUAGE: javascript
CODE:
// get closed flag
var closed = line.closed();

// close the shape
line.closed(true);

// open the shape
line.closed(false);

----------------------------------------

TITLE: Starting Svelte Development Server in Bash
DESCRIPTION: Commands to start the Svelte development server, with an option to open the app in a new browser tab.

LANGUAGE: bash
CODE:
npm run dev

# or start the server and open the app in a new browser tab
npm run dev -- --open

----------------------------------------

TITLE: Applying HSL Filter to Image using Konva in React
DESCRIPTION: This snippet shows how to apply an HSL filter to an image using Konva in a React component. It uses the react-konva library and hooks to manage state and update the image filter based on user input from sliders.

LANGUAGE: jsx
CODE:
import { Stage, Layer, Image } from 'react-konva';
import { useState, useEffect, useRef } from 'react';
import useImage from 'use-image';

const App = () => {
  const [hue, setHue] = useState(0);
  const [saturation, setSaturation] = useState(0);
  const [luminance, setLuminance] = useState(0);
  const [image] = useImage('https://konvajs.org/assets/lion.png', 'anonymous');
  const imageRef = useRef(null);

  useEffect(() => {
    if (image && imageRef.current) {
      imageRef.current.cache();
    }
  }, [image]);

  return (
    <>
      <Stage width={window.innerWidth} height={window.innerHeight}>
        <Layer>
          <Image
            ref={imageRef}
            x={50}
            y={50}
            image={image}
            draggable
            filters={[Konva.Filters.HSL]}
            hue={hue}
            saturation={saturation}
            luminance={luminance}
          />
        </Layer>
      </Stage>
      <div style={{ position: 'absolute', top: '20px', left: '20px' }}>
        <div>
          Hue
          <input
            type="range"
            min="-259"
            max="259"
            value={hue}
            onChange={(e) => setHue(parseInt(e.target.value))}
          />
        </div>
        <div>
          Saturation
          <input
            type="range"
            min="-2"
            max="10"
            step="0.1"
            value={saturation}
            onChange={(e) => setSaturation(parseFloat(e.target.value))}
          />
        </div>
        <div>
          Luminance
          <input
            type="range"
            min="-2"
            max="2"
            step="0.1"
            value={luminance}
            onChange={(e) => setLuminance(parseFloat(e.target.value))}
          />
        </div>
      </div>
    </>
  );
};

export default App;

----------------------------------------

TITLE: Implementing Canvas Portal with React-Konva
DESCRIPTION: This code snippet demonstrates the use of the Portal component from react-konva-utils to dynamically move a draggable rectangle to a top layer during drag operations. It includes a Stage with multiple shapes and uses state to control the portal's enabled property.

LANGUAGE: jsx
CODE:
import React from 'react';
import { Stage, Layer, Rect, Text, Circle, Line } from 'react-konva';
import { Portal } from 'react-konva-utils';

const App = () => {
  const [isDragging, setDragging] = React.useState(false);

  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        <Text
          text="Try to drag the rectangle. It should be on top while drag."
          fontSize={15}
        />
        <Portal selector=".top-layer" enabled={isDragging}>
          <Rect
            x={20}
            y={50}
            width={150}
            height={150}
            fill="red"
            draggable={true}
            onDragStart={() => {
              setDragging(true);
            }}
            onDragEnd={() => {
              setDragging(false);
            }}
          />
        </Portal>
        <Circle x={200} y={100} radius={50} fill="green" />
        <Line
          x={20}
          y={200}
          points={[0, 0, 100, 0, 100, 100]}
          tension={0.5}
          closed
          stroke="black"
          fillLinearGradientStartPoint={{ x: -50, y: -50 }}
          fillLinearGradientEndPoint={{ x: 50, y: 50 }}
          fillLinearGradientColorStops={[0, 'red', 1, 'yellow']}
          draggable
        />
      </Layer>
      <Layer name="top-layer" />
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Defining Blog Post Frontmatter in Markdown
DESCRIPTION: This snippet shows the frontmatter section of a blog post, which includes metadata such as slug, title, authors, and tags. It is written in YAML format within the Markdown file.

LANGUAGE: markdown
CODE:
---
slug: first-blog-post
title: First Blog Post
authors: [slorber, yangshun]
tags: [hola, docusaurus]
---

----------------------------------------

TITLE: Creating Images with Konva.js in Vue
DESCRIPTION: This Vue component uses vue-konva to create a stage with two images (Yoda and Darth Vader). It employs the useImage composable to load the images and then renders them using v-image components with various attributes. The images are conditionally rendered based on their loading state.

LANGUAGE: vue
CODE:
<template>
  <v-stage :config="stageSize">
    <v-layer>
      <v-image
        v-if="yodaImage"
        :config="{
          x: 50,
          y: 50,
          image: yodaImage,
          width: 106,
          height: 118
        }"
      />
      <v-image
        v-if="vaderImage"
        :config="{
          x: 200,
          y: 50,
          image: vaderImage,
          scaleX: 0.5,
          scaleY: 0.5,
          cornerRadius: 20
        }"
      />
    </v-layer>
  </v-stage>
</template>

<script setup>
import { useImage } from 'vue-konva';

const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight
};

const [yodaImage] = useImage('https://konvajs.org/assets/yoda.jpg');
const [vaderImage] = useImage('https://konvajs.org/assets/darth-vader.jpg');
</script>

----------------------------------------

TITLE: Creating a Svelte Project with create-svelte in Bash
DESCRIPTION: Commands to create a new Svelte project using create-svelte, either in the current directory or in a specified directory.

LANGUAGE: bash
CODE:
# create a new project in the current directory
npm create svelte@latest

# create a new project in my-app
npm create svelte@latest my-app

----------------------------------------

TITLE: Creating Animations in Konva using Konva.Animation
DESCRIPTION: This example demonstrates how to create animations in Konva using the Konva.Animation class. It shows how to update properties of shapes over time to create dynamic animations.

LANGUAGE: javascript
CODE:
var anim = new Konva.Animation(function (frame) {
  var time = frame.time,
    timeDiff = frame.timeDiff,
    frameRate = frame.frameRate;
  // update stuff
}, layer);
anim.start();

----------------------------------------

TITLE: Deploying Website with SSH
DESCRIPTION: Command to deploy the website using SSH authentication method.

LANGUAGE: bash
CODE:
$ USE_SSH=true yarn deploy

----------------------------------------

TITLE: Implementing Remove Alpha Filter in Vue with Konva
DESCRIPTION: Vue implementation of the remove alpha filter using vue-konva components. Uses Vue composition API with setup script and refs.

LANGUAGE: javascript
CODE:
<template>
  <v-stage :config="stageSize">
    <v-layer>
      <v-image
        ref="imageNode"
        :config="{
          x: 50,
          y: 50,
          image: image,
          draggable: true,
          filters: [Konva.Filters.RemoveAlpha],
        }"
      />
    </v-layer>
  </v-stage>
</template>

<script setup>
import { ref, watch, nextTick } from 'vue';
import { useImage } from 'vue-konva';
import Konva from 'konva';

// create our custom filter
Konva.Filters.RemoveAlpha = function (imageData) {
  const data = imageData.data;
  for (let i = 0; i < data.length; i += 4) {
    data[i + 3] = 255; // set alpha to 1
  }
};

const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight,
};

const imageNode = ref(null);
const [image] = useImage('https://konvajs.org/assets/lion.png', 'anonymous');

watch(image, async (newImage) => {
  if (newImage) {
    await nextTick();
    imageNode.value.getNode().cache();
  }
});
</script>

----------------------------------------

TITLE: Creating External Store in Svelte
DESCRIPTION: Demonstrates how to create a simple external store in Svelte to retain component state during Hot Module Replacement (HMR). This approach helps preserve important state that would otherwise be lost during HMR updates.

LANGUAGE: javascript
CODE:
// store.js
// An extremely simple external store
import { writable } from 'svelte/store'
export default writable(0)

----------------------------------------

TITLE: Changing Mouse Cursor in Vue with vue-konva
DESCRIPTION: This snippet demonstrates how to change the mouse cursor style when hovering over different pentagons using Vue and vue-konva. It uses a template to define the stage and shapes, and methods to handle mouseover and mouseout events.

LANGUAGE: vue
CODE:
<template>
  <v-stage :config="stageSize">
    <v-layer>
      <v-regular-polygon
        v-for="(pentagon, i) in pentagons"
        :key="i"
        :config="pentagon"
        @mouseover="handleMouseOver($event, pentagon.cursor)"
        @mouseout="handleMouseOut"
      />
    </v-layer>
  </v-stage>
</template>

<script setup>
const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight
};

const pentagons = [
  {
    x: 80,
    y: window.innerHeight / 2,
    sides: 5,
    radius: 30,
    fill: 'red',
    stroke: 'black',
    strokeWidth: 4,
    cursor: 'pointer'
  },
  {
    x: 180,
    y: window.innerHeight / 2,
    sides: 5,
    radius: 30,
    fill: 'green',
    stroke: 'black',
    strokeWidth: 4,
    cursor: 'crosshair'
  },
  {
    x: 280,
    y: window.innerHeight / 2,
    sides: 5,
    radius: 30,
    fill: 'blue',
    stroke: 'black',
    strokeWidth: 4,
    cursor: 'move'
  }
];

const handleMouseOver = (e, cursor) => {
  e.target.getStage().container().style.cursor = cursor;
};

const handleMouseOut = (e) => {
  e.target.getStage().container().style.cursor = 'default';
};
</script>

----------------------------------------

TITLE: Converting Konva Canvas to PDF - React Implementation
DESCRIPTION: React version of the Konva canvas to PDF export functionality. Uses React hooks and Konva's React components to create and manage the stage, with the same PDF export capabilities.

LANGUAGE: jsx
CODE:
import { useRef, useEffect, useState } from 'react';
import { Stage, Layer, Rect, Text, Arrow, Image } from 'react-konva';
import useImage from 'use-image';

const App = () => {
  const stageRef = useRef(null);
  const [darthVaderImage] = useImage('https://konvajs.org/assets/darth-vader.jpg', 'anonymous');
  const width = window.innerWidth;
  const height = window.innerHeight;
  
  useEffect(() => {
    const script = document.createElement('script');
    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jspdf/1.5.3/jspdf.debug.js';
    script.integrity = 'sha384-NaWTHo/8YCBYJ59830LTz/P4aQZK1sS0SneOgAvhsIl3zBu8r9RevNg5lHCHAuQ/';
    script.crossOrigin = 'anonymous';
    document.head.appendChild(script);
    
    return () => {
      document.head.removeChild(script);
    };
  }, []);
  
  const handleExport = () => {
    if (stageRef.current && typeof window.jsPDF !== 'undefined') {
      const stage = stageRef.current;
      const pdf = new window.jsPDF('l', 'px', [width, height]);
      pdf.setTextColor('#000000');
      
      stage.find('Text').forEach((text) => {
        const size = text.fontSize() / 0.75;
        pdf.setFontSize(size);
        pdf.text(text.text(), text.x(), text.y(), {
          baseline: 'top',
          angle: -text.getAbsoluteRotation(),
        });
      });

      pdf.addImage(
        stage.toDataURL({ pixelRatio: 2 }),
        0,
        0,
        width,
        height
      );

      pdf.save('canvas.pdf');
    }
  };
  
  return (
    <div style={{ position: 'relative' }}>
      <button 
        style={{ position: 'absolute', top: '5px', left: '5px', zIndex: 10 }}
        onClick={handleExport}
      >
        Save as PDF
      </button>
      
      <Stage width={width} height={height} ref={stageRef}>
        <Layer>
          <Rect
            width={width}
            height={height}
            fill="rgba(200, 200, 200)"
          />
          
          <Text
            text="This is the Darth Vader"
            x={15}
            y={40}
            rotation={-10}
            fontSize={18}
            filters={[Konva.Filters.Blur]}
            blurRadius={4}
          />
          
          <Arrow
            points={[70, 50, 100, 80, 150, 100, 190, 100]}
            tension={0.5}
            stroke="black"
            fill="black"
          />
          
          {darthVaderImage && (
            <Image
              image={darthVaderImage}
              x={200}
              y={50}
              scaleX={0.5}
              scaleY={0.5}
            />
          )}
        </Layer>
      </Stage>
    </div>
  );
};

----------------------------------------

TITLE: Configuring Cursor MCP for Konva Documentation
DESCRIPTION: JSON configuration snippet for setting up Model Context Protocol in Cursor IDE to access Konva documentation. This enables AI-assisted development specifically tailored for Konva projects.

LANGUAGE: json
CODE:
{
  "konva-documentation": {
    "command": "npx",
    "args": [
      "crawl-chat-mcp",
      "--id=67d221efb4b9de65095a2579",
      "--name=konva_documentation"
    ]
  }
}

----------------------------------------

TITLE: Setting Inner Radius of Konva Ring in JavaScript
DESCRIPTION: Method to get or set the inner radius of the Ring. Returns the current inner radius if no argument is provided.

LANGUAGE: javascript
CODE:
// get inner radius
var innerRadius = ring.innerRadius();

// set inner radius
ring.innerRadius(20);

----------------------------------------

TITLE: Creating External Store in Svelte
DESCRIPTION: Demonstrates how to create a simple external store in Svelte to preserve component state during Hot Module Replacement (HMR). Uses the writable store from Svelte's store module to maintain state persistence.

LANGUAGE: javascript
CODE:
// store.js
// An extremely simple external store
import { writable } from 'svelte/store'
export default writable(0)

----------------------------------------

TITLE: Implementing Draggable Image with Vanilla JavaScript and Konva
DESCRIPTION: Creates a draggable image using Konva in vanilla JavaScript. Sets up a stage, layer, and image with drag functionality and cursor styling on hover events.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

const stage = new Konva.Stage({
  container: 'container',
  width: window.innerWidth,
  height: window.innerHeight,
});

const layer = new Konva.Layer();

const imageObj = new Image();
imageObj.onload = () => {
  const yoda = new Konva.Image({
    x: 50,
    y: 50,
    image: imageObj,
    width: 106,
    height: 118,
    draggable: true,
  });

  // add cursor styling
  yoda.on('mouseover', function () {
    document.body.style.cursor = 'pointer';
  });
  yoda.on('mouseout', function () {
    document.body.style.cursor = 'default';
  });

  layer.add(yoda);
};
imageObj.src = 'https://konvajs.org/assets/yoda.jpg';

stage.add(layer);

----------------------------------------

TITLE: Applying Enhance Filter in Konva.js
DESCRIPTION: Demonstrates color enhancement by adjusting color ranges to span maximum possible values.

LANGUAGE: javascript
CODE:
node.cache();
node.filters([Konva.Filters.Enhance]);
node.enhance(0.4);

----------------------------------------

TITLE: Creating an external store for state preservation in Svelte HMR
DESCRIPTION: This snippet demonstrates how to create a simple external store using Svelte's writable store. This approach can be used to retain important state within a component during Hot Module Replacement (HMR), which otherwise might not preserve local component state.

LANGUAGE: javascript
CODE:
// store.js
// An extremely simple external store
import { writable } from 'svelte/store'
export default writable(0)

----------------------------------------

TITLE: Implementing Canvas Clipping with Vue-Konva
DESCRIPTION: Vue implementation of canvas clipping using vue-konva components. Demonstrates how to create a clipped group with random circles using Vue's template syntax and composition API.

LANGUAGE: javascript
CODE:
<template>
  <v-stage :config="stageSize">
    <v-layer>
      <v-group :config="groupConfig">
        <v-circle
          v-for="(blob, i) in blobs"
          :key="i"
          :config="blob"
        />
      </v-group>
    </v-layer>
  </v-stage>
</template>

<script setup>
const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight
};

const groupConfig = {
  clip: {
    x: 100,
    y: 20,
    width: 200,
    height: 200,
  }
};

const blobs = Array.from({ length: 20 }, () => ({
  x: Math.random() * window.innerWidth,
  y: Math.random() * window.innerHeight,
  radius: Math.random() * 50,
  fill: 'green',
  opacity: 0.8
}));
</script>

----------------------------------------

TITLE: Implementing Vanilla JS Konva Shape Resizing
DESCRIPTION: Creates a stress test demo with 10,000 randomly positioned circles that can be selected and transformed. Uses separate layers and caching for performance optimization. Implements rectangle selection and shape transformation features.

LANGUAGE: javascript
CODE:
import Konva from 'konva';

var width = window.innerWidth;
var height = window.innerHeight;

var stage = new Konva.Stage({
  container: 'container',
  width: width,
  height: height,
});

// layer for all shapes
var layer = new Konva.Layer();
stage.add(layer);
for (var i = 0; i < 10000; i++) {
  var shape = new Konva.Circle({
    x: Math.random() * window.innerWidth,
    y: Math.random() * window.innerHeight,
    radius: 10,
    name: 'shape',
    fill: Konva.Util.getRandomColor(),
  });
  layer.add(shape);
}

// remaining implementation...

----------------------------------------

TITLE: Structuring Components in svelte-konva
DESCRIPTION: Demonstrates the structure of components in svelte-konva, including a Stage, Layer, and various shapes. Shows potential issues with using if-blocks for dynamic visibility.

LANGUAGE: javascript
CODE:
<Stage bind:config={stageConfig}>
    <Layer>
        <Rect bind:config={rectConfig} />
        {#if showRing}
            <Ring bind:config={ringConfig}/>
        {/if}
        <Circle bind:config={circleConfig} />
    </Layer>
</Stage>

----------------------------------------

TITLE: Creating an External Store for HMR State Preservation in Svelte
DESCRIPTION: This code snippet demonstrates how to create a simple external store using Svelte's writable store. This approach can be used to retain important state within a component during Hot Module Replacement (HMR).

LANGUAGE: javascript
CODE:
// store.js
// An extremely simple external store
import { writable } from 'svelte/store'
export default writable(0)

----------------------------------------

TITLE: Getting/Setting Inner Radius
DESCRIPTION: Gets or sets the inner radius of the arc

LANGUAGE: javascript
CODE:
// get inner radius
var innerRadius = arc.innerRadius();

// set inner radius
arc.innerRadius(20);

----------------------------------------

TITLE: Implementing Blend Mode with Konva in Vue
DESCRIPTION: This snippet demonstrates how to create a Konva stage with a text and a draggable rectangle using XOR blend mode in a Vue component. It uses the vue-konva library to integrate Konva components within a Vue application.

LANGUAGE: vue
CODE:
<template>
  <v-stage :config="stageSize">
    <v-layer>
      <v-text :config="textConfig" />
      <v-rect :config="rectConfig" />
    </v-layer>
  </v-stage>
</template>

<script setup>
const stageSize = {
  width: window.innerWidth,
  height: window.innerHeight
};

const textConfig = {
  text: 'Text Shadow!',
  fontFamily: 'Calibri',
  fontSize: 40,
  x: 20,
  y: 20,
  fill: 'green',
  shadowColor: 'white',
  shadowOffset: { x: 10, y: 10 }
};

const rectConfig = {
  x: 50,
  y: 50,
  width: 100,
  height: 100,
  fill: 'red',
  draggable: true,
  globalCompositeOperation: 'xor'
};
</script>

----------------------------------------

TITLE: Creating External Store for HMR State Preservation in Svelte
DESCRIPTION: Demonstrates how to create a simple external store using Svelte's writable store. This approach is recommended for retaining important state within components during Hot Module Replacement (HMR).

LANGUAGE: javascript
CODE:
// store.js
// An extremely simple external store
import { writable } from 'svelte/store'
export default writable(0)

----------------------------------------

TITLE: Embedding CodeSandbox Demo for Svelte-Konva Save/Load Example
DESCRIPTION: This code snippet embeds a CodeSandbox demo that illustrates how to implement save and load functionality in a Svelte-Konva application. The demo is loaded from a GitHub repository and displays in an iframe with custom styling.

LANGUAGE: jsx
CODE:
<iframe 
  src="https://codesandbox.io/p/sandbox/github/konvajs/site/tree/master/svelte-demos/save_load?file=/src/App.svelte" 
  style={{
    width: "100%",
    height: "800px",
    border: 0,
    borderRadius: "4px",
    overflow: "hidden"
  }}
  sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"
/>

----------------------------------------

TITLE: Implementing Drag Events in Konva with React
DESCRIPTION: This snippet shows how to create a draggable text element and handle drag events using Konva in a React component. It uses the react-konva library and React hooks to manage the drag status state.

LANGUAGE: jsx
CODE:
import { Stage, Layer, Text } from 'react-konva';
import { useState } from 'react';

const App = () => {
  const [status, setStatus] = useState('');

  return (
    <Stage width={window.innerWidth} height={window.innerHeight}>
      <Layer>
        <Text
          x={40}
          y={40}
          text="Draggable Text"
          fontSize={20}
          draggable
          width={200}
          onDragStart={() => setStatus('drag started')}
          onDragEnd={() => setStatus('drag ended')}
          onDragMove={() => setStatus('dragging')}
        />
        <Text
          x={40}
          y={100}
          text={status}
          fontSize={16}
          width={200}
        />
      </Layer>
    </Stage>
  );
};

export default App;

----------------------------------------

TITLE: Clearing the node cache
DESCRIPTION: Clears the cached canvas for the node.

LANGUAGE: javascript
CODE:
node.clearCache();

----------------------------------------

TITLE: Configuring Docusaurus Config File
DESCRIPTION: Configuration changes needed in docusaurus.config.js to enable the live codeblock theme.

LANGUAGE: diff
CODE:
module.exports = {
  ...
+ themes: ['@docusaurus/theme-live-codeblock'],
  presets: ['@docusaurus/preset-classic']
  ...
}