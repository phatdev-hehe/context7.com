TITLE: Prisma Client Query Examples
DESCRIPTION: Collection of common Prisma Client query examples including finding records, filtering, including relations, and creating/updating records.

LANGUAGE: typescript
CODE:
// Retrieve all users
const allUsers = await prisma.user.findMany()

// Include posts relation
const allUsers = await prisma.user.findMany({
  include: { posts: true },
})

// Filter posts containing 'prisma'
const filteredPosts = await prisma.post.findMany({
  where: {
    OR: [
      { title: { contains: 'prisma' } },
      { content: { contains: 'prisma' } },
    ],
  },
})

// Create user with post
const user = await prisma.user.create({
  data: {
    name: 'Alice',
    email: 'alice@prisma.io',
    posts: {
      create: { title: 'Join us for Prisma Day 2020' },
    },
  },
})

// Update post
const post = await prisma.post.update({
  where: { id: 42 },
  data: { published: true },
})

----------------------------------------

TITLE: Initializing Prisma Client in TypeScript
DESCRIPTION: Shows how to import and instantiate Prisma Client in a TypeScript application.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

----------------------------------------

TITLE: Instantiating PrismaClient in TypeScript
DESCRIPTION: Shows how to import and create a new PrismaClient instance using TypeScript. This is the recommended way to instantiate the client when using TypeScript, providing full type safety.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

----------------------------------------

TITLE: Configuring Prisma Database Source
DESCRIPTION: Defines the database connection configuration in the Prisma schema file using an environment variable for the connection URL.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

----------------------------------------

TITLE: Creating Records with Prisma Client
DESCRIPTION: Examples of creating single and multiple records using Prisma Client's create() and createMany() methods. Shows how to create records with relationships and handle duplicates.

LANGUAGE: typescript
CODE:
const user = await prisma.user.create({
  data: {
    email: 'elsa@prisma.io',
    name: 'Elsa Prisma',
  },
})

----------------------------------------

TITLE: N+1 Solution with Fluent API in TypeScript
DESCRIPTION: Demonstrates solving the n+1 problem using Prisma's fluent API and dataloader batching capabilities.

LANGUAGE: typescript
CODE:
const User = objectType({
  name: 'User',
  definition(t) {
    t.nonNull.int('id')
    t.string('name')
    t.nonNull.string('email')
    t.nonNull.list.nonNull.field('posts', {
      type: 'Post',
      resolve: (parent, _, context) => {
        return context.prisma.user
          .findUnique({
            where: { id: parent.id || undefined },
          })
          .posts()
      },
    })
  },
})

----------------------------------------

TITLE: Defining Prisma Schema with PostgreSQL and User Model
DESCRIPTION: This snippet shows a basic Prisma schema file with a PostgreSQL database connection, Prisma Client generator, and a User model. It defines the structure for the database and Prisma Client generation.

LANGUAGE: prisma
CODE:
datasource db {
  url      = env("DATABASE_URL")
  provider = "postgresql"
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  email     String   @unique
  name      String?
}

----------------------------------------

TITLE: Creating Static Methods with Prisma Client Extensions in TypeScript
DESCRIPTION: This snippet demonstrates how to create a Prisma Client extension that adds custom 'signUp' and 'findManyByDomain' methods to the User model. It uses bcrypt for password hashing and includes example usage of the custom methods.

LANGUAGE: typescript
CODE:
import bcrypt from 'bcryptjs'
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient().$extends({
  model: {
    user: {
      async signUp(email: string, password: string) {
        const hash = await bcrypt.hash(password, 10)
        return prisma.user.create({
          data: {
            email,
            password: {
              create: {
                hash,
              },
            },
          },
        })
      },

      async findManyByDomain(domain: string) {
        return prisma.user.findMany({
          where: { email: { endsWith: `@${domain}` } },
        })
      },
    },
  },
})

async function main() {
  // Example usage
  await prisma.user.signUp('user2@example2.com', 's3cret')

  await prisma.user.findManyByDomain('example2.com')
}

----------------------------------------

TITLE: Initializing Single PrismaClient Instance
DESCRIPTION: Creates and exports a single reusable PrismaClient instance to be used across the application. This pattern ensures connection pooling is properly managed by preventing multiple client instances.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client'

let prisma = new PrismaClient()

export default prisma

----------------------------------------

TITLE: Including Relations with Field Selection in Prisma Client
DESCRIPTION: This example shows how to use 'include' with 'select' to return all user fields along with selected fields from related posts.

LANGUAGE: typescript
CODE:
const usersWithPostTitles = await prisma.user.findFirst({
  include: {
    posts: {
      select: { title: true },
    },
  },
})

----------------------------------------

TITLE: Executing Sequential Operations in a Transaction using Prisma Client
DESCRIPTION: This example demonstrates how to use the $transaction API to execute multiple Prisma Client queries sequentially within a transaction.

LANGUAGE: typescript
CODE:
const [posts, totalPosts] = await prisma.$transaction([
  prisma.post.findMany({ where: { title: { contains: 'prisma' } } }),
  prisma.post.count(),
])

----------------------------------------

TITLE: Using native database type attributes in Prisma
DESCRIPTION: Example of using native database type attributes to specify exact database column types.

LANGUAGE: prisma
CODE:
model Post {
  id      Int    @id
  title   String @db.VarChar(200)
  content String
}

----------------------------------------

TITLE: Basic One-to-Many Relation in Prisma Schema
DESCRIPTION: Demonstrates how to define a one-to-many relation between User and Post models in a Prisma schema, showing both relational database and MongoDB variants.

LANGUAGE: prisma
CODE:
model User {
  id    Int    @id @default(autoincrement())
  posts Post[]
}

model Post {
  id       Int  @id @default(autoincrement())
  author   User @relation(fields: [authorId], references: [id])
  authorId Int
  title String
}

----------------------------------------

TITLE: Reading Records with Prisma Client
DESCRIPTION: Examples of reading records using findUnique(), findMany(), findFirst() and filtering. Shows how to query by ID, unique fields and complex filters.

LANGUAGE: typescript
CODE:
const user = await prisma.user.findUnique({
  where: {
    email: 'elsa@prisma.io',
  },
})

----------------------------------------

TITLE: Creating Related Records in a Nested Write
DESCRIPTION: Shows how to create a user and multiple related posts in a single nested write operation.

LANGUAGE: typescript
CODE:
const result = await prisma.user.create({
  data: {
    email: 'elsa@prisma.io',
    name: 'Elsa Prisma',
    posts: {
      create: [
        { title: 'How to make an omelette' },
        { title: 'How to eat an omelette' },
      ],
    },
  },
  include: {
    posts: true,
  },
})

----------------------------------------

TITLE: Defining Prisma Schema for Relational Databases
DESCRIPTION: Example of a Prisma schema file defining models for Posts and Users with PostgreSQL as the database provider. Shows basic model structure with relations and field definitions.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model Post {
  id        Int     @id @default(autoincrement())
  title     String
  content   String?
  published Boolean @default(false)
  author    User?   @relation(fields: [authorId], references: [id])
  authorId  Int?
}

model User {
  id    Int     @id @default(autoincrement())
  email String  @unique
  name  String?
  posts Post[]
}

----------------------------------------

TITLE: Implementing Custom Validation with Prisma Client Extensions and Zod in TypeScript
DESCRIPTION: This snippet demonstrates how to add runtime validation for creating and updating products using Prisma Client extensions and Zod schema. It includes a Zod schema definition, Prisma Client extension implementation, and example usage for both valid and invalid product creation.

LANGUAGE: typescript
CODE:
import { PrismaClient, Prisma } from '@prisma/client'
import { z } from 'zod'

/**
 * Zod schema
 */
export const ProductCreateInput = z.object({
  slug: z
    .string()
    .max(100)
    .regex(/^[a-z0-9]+(?:-[a-z0-9]+)*$/),
  name: z.string().max(100),
  description: z.string().max(1000),
  price: z
    .instanceof(Prisma.Decimal)
    .refine((price) => price.gte('0.01') && price.lt('1000000.00')),
}) satisfies z.Schema<Prisma.ProductUncheckedCreateInput>

/**
 * Prisma Client Extension
 */
const prisma = new PrismaClient().$extends({
  query: {
    product: {
      create({ args, query }) {
        args.data = ProductCreateInput.parse(args.data)
        return query(args)
      },
      update({ args, query }) {
        args.data = ProductCreateInput.partial().parse(args.data)
        return query(args)
      },
      updateMany({ args, query }) {
        args.data = ProductCreateInput.partial().parse(args.data)
        return query(args)
      },
      upsert({ args, query }) {
        args.create = ProductCreateInput.parse(args.create)
        args.update = ProductCreateInput.partial().parse(args.update)
        return query(args)
      },
    },
  },
})

async function main() {
  /**
   * Example usage
   */
  // Valid product
  const product = await prisma.product.create({
    data: {
      slug: 'example-product',
      name: 'Example Product',
      description: 'Lorem ipsum dolor sit amet',
      price: new Prisma.Decimal('10.95'),
    },
  })

  // Invalid product
  try {
    await prisma.product.create({
      data: {
        slug: 'invalid-product',
        name: 'Invalid Product',
        description: 'Lorem ipsum dolor sit amet',
        price: new Prisma.Decimal('-1.00'),
      },
    })
  } catch (err: any) {
    console.log(err?.cause?.issues)
  }
}

main()

----------------------------------------

TITLE: Reading Data with Prisma Client
DESCRIPTION: Example of querying all users from the database using Prisma Client's findMany operation.

LANGUAGE: typescript
CODE:
async function main() {
  const allUsers = await prisma.user.findMany()
  console.log(allUsers)
}

----------------------------------------

TITLE: N+1 Problem Example in GraphQL Resolvers
DESCRIPTION: Shows how n+1 query problem occurs in GraphQL resolvers when fetching related data without proper optimization.

LANGUAGE: typescript
CODE:
const User = objectType({
  name: 'User',
  definition(t) {
    t.nonNull.int('id')
    t.string('name')
    t.nonNull.string('email')
    t.nonNull.list.nonNull.field('posts', {
      type: 'Post',
      resolve: (parent, _, context) => {
        return context.prisma.post.findMany({
          where: { authorId: parent.id || undefined },
        })
      },
    })
  },
})

----------------------------------------

TITLE: Implementing Cursor-based Pagination in Prisma with TypeScript
DESCRIPTION: This example shows how to implement cursor-based pagination in Prisma Client. It retrieves the first 4 Post records containing 'Prisma' in the title and sets up a cursor for the next query.

LANGUAGE: typescript
CODE:
const firstQueryResults = await prisma.post.findMany({
  take: 4,
  where: {
    title: {
      contains: 'Prisma' /* Optional filter */,
    },
  },
  orderBy: {
    id: 'asc',
  },
})

const lastPostInResults = firstQueryResults[3] // Remember: zero-based index! :)
const myCursor = lastPostInResults.id // Example: 29

----------------------------------------

TITLE: Defining One-to-one Relation in Prisma Schema for MongoDB
DESCRIPTION: This snippet shows how to define a one-to-one relation between User and Profile models in a Prisma schema for MongoDB. It demonstrates the use of @id, @default, @map, @db.ObjectId, @relation, and @unique attributes.

LANGUAGE: prisma
CODE:
model User {
  id      String   @id @default(auto()) @map("_id") @db.ObjectId
  profile Profile?
}

model Profile {
  id     String @id @default(auto()) @map("_id") @db.ObjectId
  user   User   @relation(fields: [userId], references: [id])
  userId String @unique @db.ObjectId // relation scalar field (used in the `@relation` attribute above)
}

----------------------------------------

TITLE: Optimized PrismaClient Instance Sharing in TypeScript
DESCRIPTION: Demonstrates the recommended approach of creating a single shared PrismaClient instance and reusing it across the application.

LANGUAGE: typescript
CODE:
export const prisma = new PrismaClient()

LANGUAGE: typescript
CODE:
import { prisma } from "db.ts"

async function getPosts() {
  await prisma.post.findMany()
}

async function getUsers() {
  await prisma.user.findMany()
}

----------------------------------------

TITLE: Deleting Records with Prisma Client
DESCRIPTION: Examples of deleting single and multiple records using delete() and deleteMany(). Shows how to handle cascading deletes and related records.

LANGUAGE: typescript
CODE:
const deleteUser = await prisma.user.delete({
  where: {
    email: 'bert@prisma.io',
  },
})

----------------------------------------

TITLE: Fetching Relations with Prisma ORM and Sequelize in TypeScript
DESCRIPTION: Illustrates how to fetch related data (posts) for a user. Prisma offers two methods: using include or a fluent API. Sequelize uses the include option with the related model specified.

LANGUAGE: typescript
CODE:
const posts = await prisma.user.findUnique({
  where: {
    id: 2,
  },
  include: {
    post: true,
  },
})

LANGUAGE: typescript
CODE:
const posts = await prisma.user
  .findUnique({
    where: {
      id: 2,
    },
  })
  .post()

LANGUAGE: typescript
CODE:
const user = await User.findByPk(id, {
  include: [
    {
      model: Post,
    },
  ],
})

----------------------------------------

TITLE: Updating Records with Prisma Client
DESCRIPTION: Examples of updating single and multiple records using update(), updateMany() and upsert(). Shows atomic operations and handling related records.

LANGUAGE: typescript
CODE:
const updateUser = await prisma.user.update({
  where: {
    email: 'viola@prisma.io',
  },
  data: {
    name: 'Viola the Magnificent',
  },
})

----------------------------------------

TITLE: Disconnecting Explicitly with Prisma Client in TypeScript
DESCRIPTION: Shows how to explicitly disconnect from the database using Prisma Client's $disconnect() method. This script creates a new PrismaClient instance, performs a task, and then disconnects to close the connection pool.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()
const emailService = new EmailService()

async function main() {
  const allUsers = await prisma.user.findMany()
  const emails = allUsers.map((x) => x.email)

  await emailService.send(emails, 'Hello!')
}

main()
  .then(async () => {
    await prisma.$disconnect()
  })
  .catch(async (e) => {
    console.error(e)
    await prisma.$disconnect()
    process.exit(1)
  })

----------------------------------------

TITLE: Combining Prisma.validator with Form Input
DESCRIPTION: Complex example showing how to create type-safe functions using Prisma.validator for handling form inputs and database operations.

LANGUAGE: typescript
CODE:
import { Prisma, PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

const createUserAndPost = (
  name: string,
  email: string,
  postTitle: string,
  profileBio: string
) => {
  return Prisma.validator<Prisma.UserCreateInput>()({ 
    name,
    email,
    posts: {
      create: {
        title: postTitle,
      },
    },
    profile: {
      create: {
        bio: profileBio,
      },
    },
  })
}

const findSpecificUser = (email: string) => {
  return Prisma.validator<Prisma.UserWhereInput>()({ 
    email,
  })
}

// Create the user in the database based on form input
// Run inside async function
await prisma.user.create({
  data: createUserAndPost(
    'Rich',
    'rich@boop.com',
    'Life of Pie',
    'Learning each day'
  ),
})

// Find the specific user based on form input
// Run inside async function
const oneUser = await prisma.user.findUnique({
  where: findSpecificUser('rich@boop.com'),
})

----------------------------------------

TITLE: Complex Schema with Multiple Relation Types
DESCRIPTION: Illustrates a complete schema showing one-to-one, one-to-many, and many-to-many relations between multiple models.

LANGUAGE: prisma
CODE:
model User {
  id      Int      @id @default(autoincrement())
  posts   Post[]
  profile Profile?
}

model Profile {
  id     Int  @id @default(autoincrement())
  user   User @relation(fields: [userId], references: [id])
  userId Int  @unique
}

model Post {
  id         Int        @id @default(autoincrement())
  author     User       @relation(fields: [authorId], references: [id])
  authorId   Int
  categories Category[]
}

model Category {
  id    Int    @id @default(autoincrement())
  posts Post[]
}

----------------------------------------

TITLE: Querying All Users with Prisma Client in TypeScript
DESCRIPTION: This snippet demonstrates how to use Prisma Client to query all User records from the database and log the result.

LANGUAGE: typescript
CODE:
async function main() {
  const allUsers = await prisma.user.findMany()
  console.log(allUsers)
}

----------------------------------------

TITLE: Using the Fluent API for Relations
DESCRIPTION: Demonstrates using the fluent API to traverse relations between models.

LANGUAGE: typescript
CODE:
const postsByUser: Post[] = await prisma.user
  .findUnique({ where: { email: 'alice@prisma.io' } })
  .posts()

----------------------------------------

TITLE: Filtering Users with Related Posts in Prisma
DESCRIPTION: Demonstrates how to filter User records by email domain and published posts, while including related post data. Uses where and include clauses to specify filter conditions.

LANGUAGE: typescript
CODE:
const result = await prisma.user.findMany({
  where: {
    email: {
      endsWith: 'prisma.io',
    },
    posts: {
      some: {
        published: true,
      },
    },
  },
  include: {
    posts: {
      where: {
        published: true,
      },
    },
  },
})

----------------------------------------

TITLE: Using Environment Variables in Prisma Schema
DESCRIPTION: This snippet demonstrates how to use environment variables in a Prisma schema to keep sensitive information like database URLs secure.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

----------------------------------------

TITLE: Creating Nested Records with Prisma Client in TypeScript
DESCRIPTION: Shows how to create a new User record along with associated Post and Profile records using a nested write query. Also demonstrates including related records in the query result.

LANGUAGE: typescript
CODE:
async function main() {
  await prisma.user.create({
    data: {
      name: 'Alice',
      email: 'alice@prisma.io',
      posts: {
        create: { title: 'Hello World' },
      },
      profile: {
        create: { bio: 'I like turtles' },
      },
    },
  })

  const allUsers = await prisma.user.findMany({
    include: {
      posts: true,
      profile: true,
    },
  })
  console.dir(allUsers, { depth: null })
}

----------------------------------------

TITLE: Installing Prisma Project Template
DESCRIPTION: Command to create a new Prisma project using the try-prisma template with PostgreSQL database configuration.

LANGUAGE: terminal
CODE:
npx try-prisma@latest \
  --template databases/prisma-postgres \
  --name hello-prisma \
  --install npm

----------------------------------------

TITLE: Defining Prisma Schema for Relational Databases
DESCRIPTION: This snippet demonstrates a Prisma schema for a PostgreSQL database, defining data sources, generators, models, and enums. It includes two models (User and Post) with a relation between them.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  email     String   @unique
  name      String?
  role      Role     @default(USER)
  posts     Post[]
}

model Post {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  published Boolean  @default(false)
  title     String   @db.VarChar(255)
  author    User?    @relation(fields: [authorId], references: [id])
  authorId  Int?
}

enum Role {
  USER
  ADMIN
}

----------------------------------------

TITLE: Extending Prisma Client with Custom Model Methods in TypeScript
DESCRIPTION: This snippet demonstrates how to use $extends to create an extended Prisma Client with custom methods added to models.

LANGUAGE: typescript
CODE:
const prisma = new PrismaClient().$extends({
  name?: '<name>',  // (optional) names the extension for error logs
  model?: {
    user: { ... }   // in this case, we extend the `user` model
  },
});

----------------------------------------

TITLE: Updating a Post Record with Prisma Client in TypeScript
DESCRIPTION: This snippet demonstrates how to update an existing Post record in the database using Prisma Client's update method.

LANGUAGE: typescript
CODE:
async function main() {
  const post = await prisma.post.update({
    where: { id: 1 },
    data: { published: true },
  })
  console.log(post)
}

----------------------------------------

TITLE: Extending Prisma Client with Custom Methods in TypeScript
DESCRIPTION: This snippet demonstrates how to use the `$extends` method to add custom top-level methods to Prisma Client. It adds a `$log` method for outputting messages and a `$totalQueries` method that uses the metrics feature to count the total number of queries executed.

LANGUAGE: typescript
CODE:
const prisma = new PrismaClient().$extends({
  client: {
    $log: (s: string) => console.log(s),
    async $totalQueries() {
      const index_prisma_client_queries_total = 0
      // Prisma.getExtensionContext(this) in the following block
      // returns the current client instance
      const metricsCounters = await (
        await Prisma.getExtensionContext(this).$metrics.json()
      ).counters

      return metricsCounters[index_prisma_client_queries_total].value
    },
  },
})

async function main() {
  prisma.$log('Hello world')
  const totalQueries = await prisma.$totalQueries()
  console.log(totalQueries)
}

----------------------------------------

TITLE: Deeply Nested Relation Queries in Prisma Client
DESCRIPTION: This snippet demonstrates a deeply nested query that fetches a post's title, the author's name, and the author's profile biography.

LANGUAGE: typescript
CODE:
const postsWithAuthorsAndProfiles = await prisma.post.findFirst({
  select: {
    title: true,
    author: {
      select: { 
        name: true,
        profile: {
          select: { biography: true }
        }
      },
    },
  },
})

----------------------------------------

TITLE: Using Interactive Transactions for Money Transfer in Prisma Client
DESCRIPTION: This example shows how to use interactive transactions to implement a money transfer between accounts, ensuring atomicity and consistency.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client'
const prisma = new PrismaClient()

async function transfer(from: string, to: string, amount: number) {
  return await prisma.$transaction(async (tx) => {
    const sender = await tx.account.update({
      data: {
        balance: {
          decrement: amount,
        },
      },
      where: {
        email: from,
      },
    })

    if (sender.balance < 0) {
      throw new Error(`${from} doesn't have enough to send ${amount}`)
    }

    const recipient = tx.account.update({
      data: {
        balance: {
          increment: amount,
        },
      },
      where: {
        email: to,
      },
    })

    return recipient
  })
}

async function main() {
  await transfer('alice@prisma.io', 'bob@prisma.io', 100)
  await transfer('alice@prisma.io', 'bob@prisma.io', 100)
}

main()

----------------------------------------

TITLE: Sorting and Offset Pagination in Prisma with TypeScript
DESCRIPTION: This snippet demonstrates sorting combined with offset pagination in Prisma Client. It filters posts by email content, sorts by title, skips the first 200 records, and returns records 201-220.

LANGUAGE: typescript
CODE:
const results = await prisma.post.findMany({
  skip: 200,
  take: 20,
  where: {
    email: {
      contains: 'Prisma',
    },
  },
  orderBy: {
    title: 'desc',
  },
})

----------------------------------------

TITLE: Prisma Schema Definition
DESCRIPTION: Example Prisma schema showing model definitions, relations, and database configuration

LANGUAGE: prisma
CODE:
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model Post {
  id        Int     @id @default(autoincrement())
  title     String
  content   String? @map("post_content")
  published Boolean @default(false)
  author    User?   @relation(fields: [authorId], references: [id])
  authorId  Int?
}

model User {
  id    Int     @id @default(autoincrement())
  email String  @unique
  name  String?
  posts Post[]
}

----------------------------------------

TITLE: Defining Composite Types in Prisma Schema
DESCRIPTION: Example Prisma schema demonstrating the definition of composite types (Photo and Address) and their usage in Product and Order models.

LANGUAGE: prisma
CODE:
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

model Product {
  id     String  @id @default(auto()) @map("_id") @db.ObjectId
  name   String  @unique
  price  Float
  colors Color[]
  sizes  Size[]
  photos Photo[]
  orders Order[]
}

model Order {
  id              String   @id @default(auto()) @map("_id") @db.ObjectId
  product         Product  @relation(fields: [productId], references: [id])
  color           Color
  size            Size
  shippingAddress Address
  billingAddress  Address?
  productId       String   @db.ObjectId
}

enum Color {
  Red
  Green
  Blue
}

enum Size {
  Small
  Medium
  Large
  XLarge
}

type Photo {
  height Int    @default(200)
  width  Int    @default(100)
  url    String
}

type Address {
  street String
  city   String
  zip    String
}

----------------------------------------

TITLE: Defining Database Schema with Prisma
DESCRIPTION: Sample Prisma schema defining models for User, Post, Category and ExtendedProfile with relationships between them. Includes versions for both relational databases and MongoDB.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model ExtendedProfile {
  id        Int    @id @default(autoincrement())
  biography String
  user      User   @relation(fields: [userId], references: [id])
  userId    Int    @unique
}

----------------------------------------

TITLE: Initializing Prisma Client in Node.js
DESCRIPTION: Sets up a basic Node.js script that initializes Prisma Client and defines the main query execution structure with proper error handling and connection management.

LANGUAGE: javascript
CODE:
const { PrismaClient } = require('@prisma/client')

const prisma = new PrismaClient()

async function main() {
  // ... you will write your Prisma Client queries here
}

main()
  .then(async () => {
    await prisma.$disconnect()
  })
  .catch(async (e) => {
    console.error(e)
    await prisma.$disconnect()
    process.exit(1)
  })

----------------------------------------

TITLE: Importing and Using Generated Types in Prisma Client
DESCRIPTION: Demonstrates how to import the Prisma namespace and use generated types like UserSelect to create type-safe select objects for queries.

LANGUAGE: typescript
CODE:
import { Prisma } from '@prisma/client'

// Build 'select' object
const userEmail: Prisma.UserSelect = {
  email: true,
}

// Use select object
const createUser = await prisma.user.create({
  data: {
    email: 'bob@prisma.io',
  },
  select: userEmail,
})

----------------------------------------

TITLE: Connecting Explicitly with Prisma Client in TypeScript
DESCRIPTION: Demonstrates how to explicitly connect to the database using Prisma Client's $connect() method. This is useful when you need the first request to respond instantly without waiting for a lazy connection.

LANGUAGE: typescript
CODE:
const prisma = new PrismaClient()

// run inside `async` function
await prisma.$connect()

----------------------------------------

TITLE: Filtering on Related Records
DESCRIPTION: Example of using relation filters to query users based on properties of their related posts.

LANGUAGE: typescript
CODE:
const users = await prisma.user.findMany({
  where: {
    posts: {
      none: {
        views: {
          gt: 100,
        },
      },
      every: {
        likes: {
          lte: 50,
        },
      },
    },
  },
  include: {
    posts: true,
  },
})

----------------------------------------

TITLE: Configuring Custom Output Path for Prisma Client Generator
DESCRIPTION: This snippet demonstrates how to specify a custom output path for the generated Prisma Client in the Prisma schema file.

LANGUAGE: prisma
CODE:
generator client {
  provider = "prisma-client-js"
  output   = "../src/generated/client"
}

----------------------------------------

TITLE: Creating Related Records with Prisma Client
DESCRIPTION: Complex query demonstrating nested writes to create a user with related post and profile records in a single transaction.

LANGUAGE: javascript
CODE:
async function main() {
  await prisma.user.create({
    data: {
      name: 'Alice',
      email: 'alice@prisma.io',
      posts: {
        create: { title: 'Hello World' },
      },
      profile: {
        create: { bio: 'I like turtles' },
      },
    },
  })

  const allUsers = await prisma.user.findMany({
    include: {
      posts: true,
      profile: true,
    },
  })
  console.dir(allUsers, { depth: null })
}

----------------------------------------

TITLE: Defining a basic Prisma schema with models
DESCRIPTION: Example of a basic Prisma schema with User, Profile, Post and Category models for a blogging platform.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id      Int      @id @default(autoincrement())
  email   String   @unique
  name    String?
  role    Role     @default(USER)
  posts   Post[]
  profile Profile?
}

model Profile {
  id     Int    @id @default(autoincrement())
  bio    String
  user   User   @relation(fields: [userId], references: [id])
  userId Int    @unique
}

model Post {
  id         Int        @id @default(autoincrement())
  createdAt  DateTime   @default(now())
  updatedAt  DateTime   @updatedAt
  title      String
  published  Boolean    @default(false)
  author     User       @relation(fields: [authorId], references: [id])
  authorId   Int
  categories Category[]
}

model Category {
  id    Int    @id @default(autoincrement())
  name  String
  posts Post[]
}

enum Role {
  USER
  ADMIN
}

----------------------------------------

TITLE: Selecting Specific Fields in Prisma Client Query
DESCRIPTION: This example shows how to use the 'select' option to return only specific fields (email and name) from the User model.

LANGUAGE: typescript
CODE:
const user = await prisma.user.findFirst({
  select: {
    email: true,
    name: true,
  },
})

----------------------------------------

TITLE: Initializing Prisma Client in Node.js
DESCRIPTION: Sets up a basic Node.js script that initializes Prisma Client and defines the main query execution structure with proper error handling and connection management.

LANGUAGE: javascript
CODE:
const { PrismaClient } = require('@prisma/client')

const prisma = new PrismaClient()

async function main() {
  // ... you will write your Prisma Client queries here
}

main()
  .then(async () => {
    await prisma.$disconnect()
  })
  .catch(async (e) => {
    console.error(e)
    await prisma.$disconnect()
    process.exit(1)
  })

----------------------------------------

TITLE: Defining Prisma Schema for REST API
DESCRIPTION: This Prisma schema defines models for Post and User with their relationships and database configuration.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "sqlite"
  url      = "file:./dev.db"
}

generator client {
  provider = "prisma-client-js"
}

model Post {
  id        Int     @id @default(autoincrement())
  title     String
  content   String?
  published Boolean @default(false)
  author    User?   @relation(fields: [authorId], references: [id])
  authorId  Int?
}

model User {
  id    Int     @id @default(autoincrement())
  email String  @unique
  name  String?
  posts Post[]
}

----------------------------------------

TITLE: Prisma Schema Definition
DESCRIPTION: Defines the data models for User and Post entities with their relationships using Prisma schema syntax.

LANGUAGE: prisma
CODE:
model User {
  id    Int     @id @default(autoincrement())
  email String  @unique
  name  String?
  posts Post[]
}

model Post {
  id        Int     @id @default(autoincrement())
  title     String
  content   String?
  published Boolean @default(false)
  author    User    @relation(fields: [authorId], references: [id])
  authorId  Int
}

----------------------------------------

TITLE: Excluding Fields Locally in Prisma Client (TypeScript)
DESCRIPTION: This snippet shows how to exclude a field locally for a single query using the 'omit' option within the query itself. It excludes the 'password' field from a specific User model query.

LANGUAGE: typescript
CODE:
const prisma = new PrismaClient()

// The password field is excluded only in this query
const user = await prisma.user.findUnique({
  omit: {
    password: true
  },
  where: { 
    id: 1 
  } 
})

LANGUAGE: prisma
CODE:
model User {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  firstName String
  lastName  String
  email     String   @unique
  password  String
}

----------------------------------------

TITLE: Updating a Post's Author using Nested Writes in Prisma Client
DESCRIPTION: This example shows how to use nested writes to update a post's author in a single transaction.

LANGUAGE: typescript
CODE:
const updatedPost: Post = await prisma.post.update({
  where: { id: 42 },
  data: {
    author: {
      connect: { email: 'alice@prisma.io' },
    },
  },
})

----------------------------------------

TITLE: Adding a createdAt Column to User Table
DESCRIPTION: This SQL command alters the User table in PostgreSQL by adding a createdAt column with a date data type.

LANGUAGE: sql
CODE:
ALTER TABLE "public"."User"
ADD COLUMN "createdAt" date NOT NULL;

----------------------------------------

TITLE: Basic One-to-Many Relation Schema for Relational Databases
DESCRIPTION: Defines a one-to-many relation between User and Post models where one user can have multiple posts. Uses auto-incrementing integer IDs and demonstrates required relation fields.

LANGUAGE: prisma
CODE:
model User {
  id    Int    @id @default(autoincrement())
  posts Post[]
}

model Post {
  id       Int  @id @default(autoincrement())
  author   User @relation(fields: [authorId], references: [id])
  authorId Int
}

----------------------------------------

TITLE: Defining Prisma Schema with Post and User Models
DESCRIPTION: This Prisma schema defines the data model for a blog-like application. It includes a Post model with a language field, a User model with various fields including an enum Role, and establishes a relationship between Posts and Users.

LANGUAGE: prisma
CODE:
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model Post {
  authorId  Int?
  content   String?
  id        Int     @id @default(autoincrement())
  published Boolean @default(false)
  title     String
  user      User?   @relation(fields: [authorId], references: [id])
  language  String?

  @@index([authorId], name: "authorId")
}

model User {
  email           String  @unique
  id              Int     @id @default(autoincrement())
  name            String?
  posts           Post[]
  extendedProfile Json?
  role            Role    @default(USER)
}

enum Role {
  ADMIN
  USER
  MODERATOR
}

----------------------------------------

TITLE: Initializing Prisma Client with Accelerate Extension in TypeScript
DESCRIPTION: This snippet shows how to import and initialize PrismaClient with the Accelerate extension, define a main function for queries, and handle connection management.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client'
import { withAccelerate } from '@prisma/extension-accelerate'

const prisma = new PrismaClient()
  .$extends(withAccelerate())

async function main() {
  // ... you will write your Prisma Client queries here
}

main()
  .then(async () => {
    await prisma.$disconnect()
  })
  .catch(async (e) => {
    console.error(e)
    await prisma.$disconnect()
    process.exit(1)
  })

----------------------------------------

TITLE: Extending Specific Model Operation
DESCRIPTION: Example of modifying the findMany operation specifically for the user model to filter users over 18 years old.

LANGUAGE: typescript
CODE:
const prisma = new PrismaClient().$extends({
  query: {
    user: {
      async findMany({ model, operation, args, query }) {
        args.where = { ...args.where, age: { gt: 18 } }
        return query(args)
      },
    },
  },
})

----------------------------------------

TITLE: Creating a Prisma Client Extension with $extends
DESCRIPTION: Demonstrates how to create a Prisma Client extension using the $extends method, adding custom functionality to a model.

LANGUAGE: typescript
CODE:
const prisma = new PrismaClient().$extends({
  name: 'signUp', // Optional: name appears in error logs
  model: {        // This is a `model` component
    user: { ... } // The extension logic for the `user` model goes inside the curly braces
  },
})

----------------------------------------

TITLE: Setting up Prisma Client for Next.js
DESCRIPTION: Creates a singleton instance of Prisma Client with Accelerate extension for use in Next.js application.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client'
import { withAccelerate } from '@prisma/extension-accelerate'

const globalForPrisma = global as unknown as { prisma: typeof prisma }

const prisma = globalForPrisma.prisma || new PrismaClient().$extends(withAccelerate())

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma

export default prisma

----------------------------------------

TITLE: Creating Initial Migration Directory in Bash
DESCRIPTION: This command creates a new directory for the initial migration inside the prisma/migrations folder. The '0_init' naming ensures it will be the first migration in lexicographic order.

LANGUAGE: bash
CODE:
mkdir -p prisma/migrations/0_init

----------------------------------------

TITLE: Defining scalar fields in Prisma models
DESCRIPTION: Example of defining scalar fields with different types and attributes in Prisma models.

LANGUAGE: prisma
CODE:
model Comment {
  id      Int    @id @default(autoincrement())
  title   String
  content String
}

model Tag {
  name String @id
}

----------------------------------------

TITLE: Implementing Computed Fields with Prisma Client Extension (TypeScript)
DESCRIPTION: This snippet demonstrates how to create a Prisma Client extension that adds a fullName computed field to the User model. It computes the full name by combining the firstName and lastName fields.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient().$extends({
  result: {
    user: {
      fullName: {
        needs: { firstName: true, lastName: true },
        compute(user) {
          return `${user.firstName} ${user.lastName}`
        },
      },
    },
  },
})

async function main() {
  /**
   * Example query containing the `fullName` computed field in the response
   */
  const user = await prisma.user.findFirst()
}

main()

----------------------------------------

TITLE: Defining One-to-one Relation in Prisma Schema for Relational Databases
DESCRIPTION: This snippet demonstrates how to define a one-to-one relation between User and Profile models in a Prisma schema for relational databases. It shows the use of @id, @default, @relation, and @unique attributes.

LANGUAGE: prisma
CODE:
model User {
  id      Int      @id @default(autoincrement())
  profile Profile?
}

model Profile {
  id     Int  @id @default(autoincrement())
  user   User @relation(fields: [userId], references: [id])
  userId Int  @unique // relation scalar field (used in the `@relation` attribute above)
}

----------------------------------------

TITLE: Defining Prisma Schema Models for Blog Application
DESCRIPTION: This snippet defines three models (Post, Profile, and User) in the Prisma schema file. It establishes relationships between the models and specifies field types and constraints.

LANGUAGE: prisma
CODE:
model Post {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  title     String   @db.VarChar(255)
  content   String?
  published Boolean  @default(false)
  author    User     @relation(fields: [authorId], references: [id])
  authorId  Int
}

model Profile {
  id     Int     @id @default(autoincrement())
  bio    String?
  user   User    @relation(fields: [userId], references: [id])
  userId Int     @unique
}

model User {
  id      Int      @id @default(autoincrement())
  email   String   @unique
  name    String?
  posts   Post[]
  profile Profile?
}

----------------------------------------

TITLE: Continuing Cursor-based Pagination in Prisma with TypeScript
DESCRIPTION: This snippet demonstrates how to continue cursor-based pagination in Prisma Client. It retrieves the next 4 Post records after the previously set cursor, skipping the cursor itself.

LANGUAGE: typescript
CODE:
const secondQueryResults = await prisma.post.findMany({
  take: 4,
  skip: 1, // Skip the cursor
  cursor: {
    id: myCursor,
  },
  where: {
    title: {
      contains: 'Prisma' /* Optional filter */,
    },
  },
  orderBy: {
    id: 'asc',
  },
})

const lastPostInResults = secondQueryResults[3] // Remember: zero-based index! :)
const myCursor = lastPostInResults.id // Example: 52

----------------------------------------

TITLE: Getting Current Model Name at Runtime in Prisma Client Extension
DESCRIPTION: This snippet shows how to retrieve the name of the current model at runtime using Prisma.getExtensionContext(this).$name.

LANGUAGE: typescript
CODE:
// `context` refers to the current model
const context = Prisma.getExtensionContext(this)

// `context.name` returns the name of the current model
console.log(context.name)

// Usage
await(context as any).findFirst({ args })

----------------------------------------

TITLE: Event-based Logging for Queries in Prisma Client (TypeScript)
DESCRIPTION: This snippet illustrates how to set up event-based logging for queries in Prisma Client. It configures the client to emit query events and sets up an event listener to log query details.

LANGUAGE: typescript
CODE:
const prisma = new PrismaClient({
  log: [
    {
      emit: 'event',
      level: 'query',
    },
    {
      emit: 'stdout',
      level: 'error',
    },
    {
      emit: 'stdout',
      level: 'info',
    },
    {
      emit: 'stdout',
      level: 'warn',
    },
  ],
})

prisma.$on('query', (e) => {
  console.log('Query: ' + e.query)
  console.log('Params: ' + e.params)
  console.log('Duration: ' + e.duration + 'ms')
})

----------------------------------------

TITLE: Group By Operation in Prisma
DESCRIPTION: Demonstrates grouping users by country and calculating sum of profile views for each group.

LANGUAGE: typescript
CODE:
const groupUsers = await prisma.user.groupBy({
  by: ['country'],
  _sum: {
    profileViews: true,
  },
})

----------------------------------------

TITLE: Filtering with Cursor-based Pagination in Prisma using TypeScript
DESCRIPTION: This example shows how to combine filtering with cursor-based pagination in Prisma Client. It retrieves the next 4 Post records after a cursor, filtering for posts containing 'Prisma' in the title.

LANGUAGE: typescript
CODE:
const secondQuery = await prisma.post.findMany({
  take: 4,
  cursor: {
    id: myCursor,
  },
  where: {
    title: {
      contains: 'Prisma' /* Optional filter */,
    },
  },
  orderBy: {
    id: 'asc',
  },
})

----------------------------------------

TITLE: Selecting Specific Fields from Related Records
DESCRIPTION: Demonstrates using a nested select to choose specific fields from related records to return.

LANGUAGE: typescript
CODE:
const user = await prisma.user.findFirst({
  select: {
    name: true,
    posts: {
      select: {
        title: true,
      },
    },
  },
})

----------------------------------------

TITLE: Basic Aggregation in Prisma TypeScript
DESCRIPTION: Demonstrates how to perform basic aggregation operations like calculating average age of users using Prisma Client.

LANGUAGE: typescript
CODE:
const aggregations = await prisma.user.aggregate({
  _avg: {
    age: true,
  },
})

console.log('Average age:' + aggregations._avg.age)

----------------------------------------

TITLE: Production Migration Deployment
DESCRIPTION: Command to safely apply pending migrations in production and testing environments. Should be part of CI/CD pipeline.

LANGUAGE: terminal
CODE:
npx prisma migrate deploy

----------------------------------------

TITLE: Installing Prisma CLI
DESCRIPTION: Commands to install the Prisma CLI as a dev dependency and run it. This is a prerequisite for using Prisma Client.

LANGUAGE: shell
CODE:
npm install prisma --save-dev
npx prisma

----------------------------------------

TITLE: Configuring Prisma Client Generator in Prisma Schema
DESCRIPTION: This snippet shows how to add the generator definition to your Prisma schema file to enable Prisma Client generation.

LANGUAGE: prisma
CODE:
generator client {
  provider = "prisma-client-js"
}

----------------------------------------

TITLE: Creating Related Records with Prisma Client
DESCRIPTION: Shows how to create a User record with nested Post records using Prisma Client's create operation.

LANGUAGE: typescript
CODE:
const userAndPosts = await prisma.user.create({
  data: {
    posts: {
      create: [
        { title: 'Prisma Day 2020' },
        { title: 'How to write a Prisma schema' },
      ],
    },
  },
})

----------------------------------------

TITLE: Defining User model with unique email in Prisma schema
DESCRIPTION: This Prisma schema defines a User model with an id, email, and optional name field. The email field has a unique constraint.

LANGUAGE: prisma
CODE:
model User {
  id    Int     @id @default(autoincrement())
  email String  @unique
  name  String?
}

----------------------------------------

TITLE: SQL schema for ambiguous relations
DESCRIPTION: SQL commands to create User and Post tables with ambiguous relations, where a post can have both an author and a user who favorited it.

LANGUAGE: sql
CODE:
CREATE TABLE "User" (
    id SERIAL PRIMARY KEY
);
CREATE TABLE "Post" (
    id SERIAL PRIMARY KEY,
    "author" integer NOT NULL,
    "favoritedBy" INTEGER,
    FOREIGN KEY ("author") REFERENCES "User"(id),
    FOREIGN KEY ("favoritedBy") REFERENCES "User"(id)
);

----------------------------------------

TITLE: Including Related Records in a Query
DESCRIPTION: Example of using the include option to return a single user and their related posts.

LANGUAGE: typescript
CODE:
const user = await prisma.user.findFirst({
  include: {
    posts: true,
  },
})

----------------------------------------

TITLE: Creating a User with Related Posts using Nested Writes in Prisma Client
DESCRIPTION: This example demonstrates how to use nested writes to create a new user and two related blog posts in a single transaction.

LANGUAGE: typescript
CODE:
const newUser: User = await prisma.user.create({
  data: {
    email: 'alice@prisma.io',
    posts: {
      create: [
        { title: 'Join the Prisma Discord at https://pris.ly/discord' },
        { title: 'Follow @prisma on Twitter' },
      ],
    },
  },
})

----------------------------------------

TITLE: Creating Related Records with Nested Writes in Prisma
DESCRIPTION: Example of creating a User record with associated Post and Profile records using Prisma Client's nested write capability. Demonstrates relationship creation and data querying with included relations.

LANGUAGE: javascript
CODE:
async function main() {
  await prisma.user.create({
    data: {
      name: 'Alice',
      email: 'alice@prisma.io',
      posts: {
        create: { title: 'Hello World' },
      },
      profile: {
        create: { bio: 'I like turtles' },
      },
    },
  })

  const allUsers = await prisma.user.findMany({
    include: {
      posts: true,
      profile: true,
    },
  })
  console.dir(allUsers, { depth: null })
}

----------------------------------------

TITLE: Initializing Prisma Client in TypeScript
DESCRIPTION: Sets up a Prisma Client instance and defines a main function for executing database queries. Includes error handling and proper disconnection.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

async function main() {
  // ... you will write your Prisma Client queries here
}

main()
  .then(async () => {
    await prisma.$disconnect()
  })
  .catch(async (e) => {
    console.error(e)
    await prisma.$disconnect()
    process.exit(1)
  })

----------------------------------------

TITLE: Incorrect PrismaClient Instance Creation in TypeScript
DESCRIPTION: Example showing the inefficient way of creating multiple PrismaClient instances, which can lead to connection pool exhaustion.

LANGUAGE: typescript
CODE:
async function getPosts() {
  const prisma = new PrismaClient()
  await prisma.post.findMany()
}

async function getUsers() {
  const prisma = new PrismaClient()
  await prisma.user.findMany()
}

----------------------------------------

TITLE: Writing Unit Tests with Dependency Injection
DESCRIPTION: Write unit tests for user creation and update functions using the dependency injection pattern for Prisma Client mocking.

LANGUAGE: typescript
CODE:
import { MockContext, Context, createMockContext } from '../context'
import { createUser, updateUsername } from '../functions-with-context'

let mockCtx: MockContext
let ctx: Context

beforeEach(() => {
  mockCtx = createMockContext()
  ctx = mockCtx as unknown as Context
})

test('should create new user ', async () => {
  const user = {
    id: 1,
    name: 'Rich',
    email: 'hello@prisma.io',
    acceptTermsAndConditions: true,
  }
  mockCtx.prisma.user.create.mockResolvedValue(user)

  await expect(createUser(user, ctx)).resolves.toEqual({
    id: 1,
    name: 'Rich',
    email: 'hello@prisma.io',
    acceptTermsAndConditions: true,
  })
})

test('should update a users name ', async () => {
  const user = {
    id: 1,
    name: 'Rich Haines',
    email: 'hello@prisma.io',
    acceptTermsAndConditions: true,
  }
  mockCtx.prisma.user.update.mockResolvedValue(user)

  await expect(updateUsername(user, ctx)).resolves.toEqual({
    id: 1,
    name: 'Rich Haines',
    email: 'hello@prisma.io',
    acceptTermsAndConditions: true,
  })
})

test('should fail if user does not accept terms', async () => {
  const user = {
    id: 1,
    name: 'Rich Haines',
    email: 'hello@prisma.io',
    acceptTermsAndConditions: false,
  }

  mockCtx.prisma.user.create.mockImplementation()

  await expect(createUser(user, ctx)).resolves.toEqual(
    new Error('User must accept terms!')
  )
})

----------------------------------------

TITLE: Using Prisma Client with Neon in Cloudflare Worker
DESCRIPTION: Illustrates how to configure PrismaClient with the Neon adapter and perform a database query in a Cloudflare Worker.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client'
import { PrismaNeon } from '@prisma/adapter-neon'
import { Pool } from '@neondatabase/serverless'

export default {
  async fetch(request, env, ctx) {
    const neon = new Pool({ connectionString: env.DATABASE_URL })
    const adapter = new PrismaNeon(neon)
    const prisma = new PrismaClient({ adapter })

    const users = await prisma.user.findMany()
    const result = JSON.stringify(users)
    return new Response(result)
  },
}

----------------------------------------

TITLE: Opening Prisma Studio for Database Visualization
DESCRIPTION: This command opens Prisma Studio, a visual editor for the database, allowing you to inspect the newly created tables.

LANGUAGE: bash
CODE:
npx prisma studio

----------------------------------------

TITLE: Importing Prisma Client in TypeScript
DESCRIPTION: Shows how to import and instantiate Prisma Client in a TypeScript project.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()
// use `prisma` in your application to read and write data in your DB

----------------------------------------

TITLE: Reading Json Field Data
DESCRIPTION: Example showing how to read and type-check JSON field data using Prisma.JsonArray utility

LANGUAGE: typescript
CODE:
const { PrismaClient, Prisma } = require('@prisma/client')

const user = await prisma.user.findFirst({
  where: {
    id: 9,
  },
})

if (
  user?.extendedPetsData &&
  typeof user?.extendedPetsData === 'object' &&
  Array.isArray(user?.extendedPetsData)
) {
  const petsObject = user?.extendedPetsData as Prisma.JsonArray

  const firstPet = petsObject[0]
}

----------------------------------------

TITLE: Backward Cursor-based Pagination in Prisma with TypeScript
DESCRIPTION: This snippet demonstrates how to implement backward cursor-based pagination in Prisma Client. It retrieves 4 Post records with an id less than 200, excluding the cursor, and filters for posts containing 'Prisma' in the title.

LANGUAGE: typescript
CODE:
const myOldCursor = 200

const firstQueryResults = await prisma.post.findMany({
  take: -4,
  skip: 1,
  cursor: {
    id: myOldCursor,
  },
  where: {
    title: {
      contains: 'Prisma' /* Optional filter */,
    },
  },
  orderBy: {
    id: 'asc',
  },
})

----------------------------------------

TITLE: Using Prisma Client with PlanetScale in Cloudflare Worker
DESCRIPTION: Shows how to set up PrismaClient with the PlanetScale adapter and execute a database query in a Cloudflare Worker, including the necessary cache workaround.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client'
import { PrismaPlanetScale } from '@prisma/adapter-planetscale'
import { Client } from '@planetscale/database'

export default {
  async fetch(request, env, ctx) {
    const client = new Client({
      url: env.DATABASE_URL,
      fetch(url, init) {
        delete init['cache']
        return fetch(url, init)
      },
    })
    const adapter = new PrismaPlanetScale(client)
    const prisma = new PrismaClient({ adapter })

    const users = await prisma.user.findMany()
    const result = JSON.stringify(users)
    return new Response(result)
  },
}

----------------------------------------

TITLE: Fetching Selected Scalars of Single Objects with Prisma ORM and Sequelize in TypeScript
DESCRIPTION: Shows how to fetch only specific fields (scalars) of a user object. Prisma uses the select option, while Sequelize uses the attributes option with raw: true to return plain JavaScript objects.

LANGUAGE: typescript
CODE:
const user = await prisma.user.findUnique({
  where: {
    id: 1,
  },
  select: {
    name: true,
  },
})

LANGUAGE: typescript
CODE:
const user = await User.findByPk(1, { attributes: ['name'], raw: true })

----------------------------------------

TITLE: Generating Prisma Client in TypeScript project
DESCRIPTION: This command generates the Prisma Client library based on your Prisma schema. It reads the schema and creates a unique client tailored to your database structure in the .prisma/client folder.

LANGUAGE: bash
CODE:
npx prisma generate

----------------------------------------

TITLE: Full-text search with raw SQL for PostgreSQL
DESCRIPTION: Example of using TypedSQL to perform full-text search with PostgreSQL's to_tsvector and to_tsquery functions.

LANGUAGE: sql
CODE:
SELECT * FROM "Blog" WHERE to_tsvector('english', "Blog"."content") @@ to_tsquery('english', ${term});

LANGUAGE: typescript
CODE:
import { fullTextSearch } from "@prisma/client/sql"

const term = `cat`
const result = await prisma.$queryRawTyped(fullTextSearch(term))

----------------------------------------

TITLE: Querying Nested Relations with Prisma Client
DESCRIPTION: This snippet demonstrates how to use nested 'select' to query related data, returning a user's name and the titles of their posts.

LANGUAGE: typescript
CODE:
const usersWithPostTitles = await prisma.user.findFirst({
  select: {
    name: true,
    posts: {
      select: { title: true },
    },
  },
})

----------------------------------------

TITLE: Basic Prisma Client Query Extension Structure
DESCRIPTION: Shows the basic structure for creating a custom query extension with optional name property.

LANGUAGE: typescript
CODE:
const prisma = new PrismaClient().$extends({
  name?: 'name',
  query?: {
    user: { ... } // in this case, we add a query to the `user` model
  },
});

----------------------------------------

TITLE: Defining Models with Prisma Schema
DESCRIPTION: Illustrates how to define User and Post models using Prisma schema language, including relation fields.

LANGUAGE: prisma
CODE:
model User {
  id    Int     @id @default(autoincrement())
  name  String?
  email String  @unique
  posts Post[]
}

model Post {
  id        Int     @id @default(autoincrement())
  title     String
  content   String?
  published Boolean @default(false)
  authorId  Int?
  author    User?   @relation(fields: [authorId], references: [id])
}

----------------------------------------

TITLE: Defining optional and list fields in Prisma
DESCRIPTION: Example of defining optional fields and list fields in Prisma models.

LANGUAGE: prisma
CODE:
model Post {
  id       Int       @id @default(autoincrement())
  comments Comment[] // A list of comments
  keywords String[] // A scalar list
}

model Comment {
  id      Int     @id @default(autoincrement())
  title   String
  content String?
}

----------------------------------------

TITLE: Defining Prisma Schema for Post and User Models
DESCRIPTION: This Prisma schema defines a SQLite datasource, generates Prisma Client, and creates Post and User models with a one-to-many relationship.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "sqlite"
  url      = "file:./dev.db"
}

generator client {
  provider = "prisma-client-js"
}

model Post {
  id        Int     @id @default(autoincrement())
  title     String
  content   String?
  published Boolean @default(false)
  author    User?   @relation(fields: [authorId], references: [id])
  authorId  Int?
}

model User {
  id    Int     @id @default(autoincrement())
  email String  @unique
  name  String?
  posts Post[]
}

----------------------------------------

TITLE: Middleware Stack Execution Order
DESCRIPTION: Comprehensive example demonstrating the execution order of multiple middleware functions, including logging of execution flow.

LANGUAGE: typescript
CODE:
const prisma = new PrismaClient()

// Middleware 1
prisma.$use(async (params, next) => {
  console.log(params.args.data.title)
  console.log('1')
  const result = await next(params)
  console.log('6')
  return result
})

// Middleware 2
prisma.$use(async (params, next) => {
  console.log('2')
  const result = await next(params)
  console.log('5')
  return result
})

// Middleware 3
prisma.$use(async (params, next) => {
  console.log('3')
  const result = await next(params)
  console.log('4')
  return result
})

const create = await prisma.post.create({
  data: {
    title: 'Welcome to Prisma Day 2020',
  },
})

const create2 = await prisma.post.create({
  data: {
    title: 'How to Prisma!',
  },
})

----------------------------------------

TITLE: Defining an ID field in Prisma models
DESCRIPTION: Examples of defining single-field and composite ID fields in Prisma models.

LANGUAGE: prisma
CODE:
model User {
  id      Int      @id @default(autoincrement())
  email   String   @unique
  name    String?
  role    Role     @default(USER)
  posts   Post[]
  profile Profile?
}

model User {
  firstName String
  lastName  String
  email     String  @unique
  isAdmin   Boolean @default(false)

  @@id([firstName, lastName])
}

----------------------------------------

TITLE: Defining Multiple Database Schemas in Prisma Schema
DESCRIPTION: This snippet demonstrates how to include multiple database schemas in the Prisma schema by adding them to the schemas array in the datasource block.

LANGUAGE: prisma
CODE:
generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["multiSchema"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
  schemas  = ["base", "transactional"]
}

----------------------------------------

TITLE: Reusing Computed Fields in Prisma Client Extensions
DESCRIPTION: Shows how to create multiple computed fields and reuse them in Prisma Client extensions. This example computes a user's full name and then uses it to create a title with full name field.

LANGUAGE: typescript
CODE:
const prisma = new PrismaClient()
  .$extends({
    result: {
      user: {
        fullName: {
          needs: { firstName: true, lastName: true },
          compute(user) {
            return `${user.firstName} ${user.lastName}`
          },
        },
      },
    },
  })
  .$extends({
    result: {
      user: {
        titleFullName: {
          needs: { title: true, fullName: true },
          compute(user) {
            return `${user.title} (${user.fullName})`
          },
        },
      },
    },
  })

----------------------------------------

TITLE: Defining Basic Prisma Schema Models
DESCRIPTION: Prisma schema defining User and Post models with relationships and field definitions.

LANGUAGE: prisma
CODE:
model User {
  id    Int     @id
  email String  @unique
  name  String?
  posts Post[]
}

model Post {
  id        Int     @id
  author    User    @relation(fields: [userId], references: [id])
  title     String
  published Boolean @default(false)
  userId    Int
}

----------------------------------------

TITLE: Implementing GET Route with Prisma and Express
DESCRIPTION: This code snippet shows how to implement a GET route using Express and Prisma Client to fetch and return published posts with their authors.

LANGUAGE: typescript
CODE:
app.get('/feed', async (req, res) => {
  const posts = await prisma.post.findMany({
    where: { published: true },
    include: { author: true },
  })
  res.json(posts)
})

----------------------------------------

TITLE: Executing a parameterized query with $queryRawUnsafe
DESCRIPTION: Shows how to use parameterized queries with $queryRawUnsafe for better SQL injection protection.

LANGUAGE: typescript
CODE:
prisma.$queryRawUnsafe("SELECT * FROM users WHERE email = $1", "emelie@prisma.io");

----------------------------------------

TITLE: Invalidating Cache in Prisma Accelerate
DESCRIPTION: This code snippet shows how to invalidate a cached query result using tags and the $accelerate.invalidate API in Prisma Accelerate.

LANGUAGE: typescript
CODE:
await prisma.user.findMany({
  where: {
    email: {
      contains: "alice@prisma.io",
    },
  },
  cacheStrategy: {
    swr: 60,
    ttl: 60,
    tags: ["emails_with_alice"],
  },
});

LANGUAGE: typescript
CODE:
try {
  await prisma.$accelerate.invalidate({
    tags: ["emails_with_alice"],
  });
} catch (e) {
  if (e instanceof Prisma.PrismaClientKnownRequestError) {
    if (e.code === "P6003") {
      console.log(
        "You've reached the cache invalidation rate limit. Please try again shortly."
      );
    }
  }
  throw e;
}

----------------------------------------

TITLE: Defining Post model schema with soft delete field in Prisma
DESCRIPTION: Prisma schema defining a Post model with a 'deleted' boolean field to enable soft delete functionality.

LANGUAGE: prisma
CODE:
model Post {
  id      Int     @id @default(autoincrement())
  title   String
  content String?
  user    User?   @relation(fields: [userId], references: [id])
  userId  Int?
  tags    Tag[]
  views   Int     @default(0)
  deleted Boolean @default(false)
}

----------------------------------------

TITLE: Defining Mandatory One-to-one Relation in Prisma Schema
DESCRIPTION: This snippet shows how to define a mandatory one-to-one relation between User and Profile models in a Prisma schema. The relation is mandatory on the User side, meaning a User must have a Profile.

LANGUAGE: prisma
CODE:
model User {
  id        Int     @id @default(autoincrement())
  profile   Profile @relation(fields: [profileId], references: [id]) // references `id` of `Profile`
  profileId Int     @unique // relation scalar field (used in the `@relation` attribute above)
}

model Profile {
  id   Int   @id @default(autoincrement())
  user User?
}

----------------------------------------

TITLE: Using $on and $use with Extended Prisma Clients
DESCRIPTION: Demonstrates how to use $on and $use methods with extended Prisma Clients by hooking them up before extending the client.

LANGUAGE: typescript
CODE:
const prisma = new PrismaClient()

prisma.$use(async (params, next) => {
  console.log('This is middleware!')
  return next(params)
})

const xPrisma = prisma.$extends({
  name: 'myExtension',
  model: {
    user: {
      async signUp(email: string) {
        await prisma.user.create({ data: { email } })
      },
    },
  },
})

----------------------------------------

TITLE: Adding a Custom Method to User Query Results in Prisma Client
DESCRIPTION: Demonstrates how to add a custom 'save' method to the user model query results using Prisma Client extensions. This method allows updating the user directly from the result object.

LANGUAGE: typescript
CODE:
const prisma = new PrismaClient().$extends({
  result: {
    user: {
      save: {
        needs: { id: true },
        compute(user) {
          return () =>
            prisma.user.update({ where: { id: user.id }, data: user })
        },
      },
    },
  },
})

const user = await prisma.user.findUniqueOrThrow({ where: { id: someId } })
user.email = 'mynewmail@mailservice.com'
await user.save()

----------------------------------------

TITLE: Initializing Prisma Schema for Next.js Blog
DESCRIPTION: Defines Prisma schema with User and Post models for a blog application using PostgreSQL database.

LANGUAGE: prisma
CODE:
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id    Int     @id @default(autoincrement())
  email String  @unique
  name  String?
  posts Post[]
}

model Post {
  id        Int     @id @default(autoincrement())
  title     String
  content   String?
  published Boolean @default(false)
  authorId  Int
  author    User    @relation(fields: [authorId], references: [id])
}

----------------------------------------

TITLE: Implementing Query Logging Middleware in Prisma
DESCRIPTION: Example of using Prisma middleware to log the execution time of database queries. The middleware wraps each query, measures the time taken, and logs it along with the model and action type.

LANGUAGE: typescript
CODE:
const prisma = new PrismaClient()

prisma.$use(async (params, next) => {
  const before = Date.now()

  const result = await next(params)

  const after = Date.now()

  console.log(`Query ${params.model}.${params.action} took ${after - before}ms`)

  return result
})

const create = await prisma.post.create({
  data: {
    title: 'Welcome to Prisma Day 2020',
  },
})

const createAgain = await prisma.post.create({
  data: {
    title: 'All about database collation',
  },
})

----------------------------------------

TITLE: Defining Prisma Schema for MongoDB
DESCRIPTION: Example of a Prisma schema file configured for MongoDB, showing the same Post and User models adapted for document database structures.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model Post {
  id        String  @id @default(auto()) @map("_id") @db.ObjectId
  title     String
  content   String?
  published Boolean @default(false)
  author    User?   @relation(fields: [authorId], references: [id])
  authorId  String  @db.ObjectId
}

model User {
  id    String  @id @default(auto()) @map("_id") @db.ObjectId
  email String  @unique
  name  String?
  posts Post[]
}

----------------------------------------

TITLE: Creating Project Directory and Installing Dependencies
DESCRIPTION: Terminal commands to create a new project directory and initialize a TypeScript project with necessary dependencies.

LANGUAGE: terminal
CODE:
mkdir hello-prisma
cd hello-prisma
npm init -y
npm install typescript tsx @types/node --save-dev

----------------------------------------

TITLE: Defining Prisma Schema for MongoDB
DESCRIPTION: This snippet shows a Prisma schema for a MongoDB database, defining data sources, generators, models, and enums. It includes two models (User and Post) with a relation between them, using MongoDB-specific types.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  createdAt DateTime @default(now())
  email     String   @unique
  name      String?
  role      Role     @default(USER)
  posts     Post[]
}

model Post {
  id        String   @id @default(auto()) @map("_id") @db.ObjectId
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  published Boolean  @default(false)
  title     String
  author    User?    @relation(fields: [authorId], references: [id])
  authorId  String   @db.ObjectId
}

enum Role {
  USER
  ADMIN
}

----------------------------------------

TITLE: Complex Email Filtering with OR and NOT Operators
DESCRIPTION: Shows how to combine OR and NOT operators to filter users by multiple email domains while excluding specific patterns.

LANGUAGE: typescript
CODE:
const result = await prisma.user.findMany({
  where: {
    OR: [
      {
        email: {
          endsWith: 'gmail.com',
        },
      },
      { email: { endsWith: 'company.com' } },
    ],
    NOT: {
      email: {
        endsWith: 'admin.company.com',
      },
    },
  },
  select: {
    email: true,
  },
})

----------------------------------------

TITLE: Implementing Cache Invalidation with Tags in Prisma
DESCRIPTION: This snippet shows how to implement cache invalidation using tags in Prisma Accelerate. It sets a cache tag for a findMany query and then demonstrates how to invalidate the cache using the $accelerate.invalidate API.

LANGUAGE: typescript
CODE:
await prisma.user.findMany({
    cacheStrategy: {
      ttl: 60,
      tags: ["findMany_users"],
    },
});

// This is how you would invalidate the cached query above.
await prisma.$accelerate.invalidate({
    tags: ["findMany_users"],
});

----------------------------------------

TITLE: Fetching Single Objects with Prisma ORM and Sequelize in TypeScript
DESCRIPTION: Demonstrates how to fetch a single user object by ID using Prisma ORM and Sequelize. Prisma uses the findUnique method with a where clause, while Sequelize uses the findByPk method.

LANGUAGE: typescript
CODE:
const user = await prisma.user.findUnique({
  where: {
    id: 1,
  },
})

LANGUAGE: typescript
CODE:
const user = await User.findByPk(id)

----------------------------------------

TITLE: Detailed Stdout Logging Configuration in Prisma Client (TypeScript)
DESCRIPTION: This example shows a more detailed configuration for stdout logging in Prisma Client, using an array of LogDefinition objects to specify emission type and log level for each category.

LANGUAGE: typescript
CODE:
const prisma = new PrismaClient({
  log: [
    {
      emit: 'stdout',
      level: 'query',
    },
    {
      emit: 'stdout',
      level: 'error',
    },
    {
      emit: 'stdout',
      level: 'info',
    },
    {
      emit: 'stdout',
      level: 'warn',
    },
  ],
})

----------------------------------------

TITLE: Instantiating Prisma Client in TypeScript
DESCRIPTION: This code demonstrates how to import and instantiate Prisma Client in a TypeScript file after generation.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client'
const prisma = new PrismaClient()
// use `prisma` in your application to read and write data in your DB

----------------------------------------

TITLE: Creating SQL Tables for Many-to-Many Self-Relation
DESCRIPTION: This SQL snippet shows how to create tables representing a many-to-many self-relation in relational databases. It includes the creation of the User table and the join table _UserFollows.

LANGUAGE: sql
CODE:
CREATE TABLE "User" (
    id integer DEFAULT nextval('"User_id_seq"'::regclass) PRIMARY KEY,
    name text
);
CREATE TABLE "_UserFollows" (
    "A" integer NOT NULL REFERENCES "User"(id) ON DELETE CASCADE ON UPDATE CASCADE,
    "B" integer NOT NULL REFERENCES "User"(id) ON DELETE CASCADE ON UPDATE CASCADE
);

----------------------------------------

TITLE: Using Prisma Client with PostgreSQL in Cloudflare Worker
DESCRIPTION: Demonstrates how to instantiate PrismaClient with the PostgreSQL adapter and execute a database query in a Cloudflare Worker.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client'
import { PrismaPg } from '@prisma/adapter-pg'
import { Pool } from 'pg'

export default {
  async fetch(request, env, ctx) {
    const pool = new Pool({ connectionString: env.DATABASE_URL })
    const adapter = new PrismaPg(pool)
    const prisma = new PrismaClient({ adapter })

    const users = await prisma.user.findMany()
    const result = JSON.stringify(users)
    return new Response(result)
  },
}

----------------------------------------

TITLE: Pagination with Prisma ORM and Mongoose in TypeScript
DESCRIPTION: Demonstrates pagination techniques. Prisma offers both cursor-style and offset pagination, while Mongoose uses skip and limit for offset pagination.

LANGUAGE: typescript
CODE:
const page = prisma.post.findMany({
  before: {
    id: 242,
  },
  last: 20,
})

LANGUAGE: typescript
CODE:
const cc = prisma.post.findMany({
  skip: 200,
  first: 20,
})

LANGUAGE: typescript
CODE:
const posts = await Post.find({
  skip: 200,
  limit: 20,
})

----------------------------------------

TITLE: Deleting records by compound ID in Prisma Client
DESCRIPTION: This TypeScript snippet shows how to delete a record using a compound ID in a Prisma Client query. It uses the delete() method to remove a specific Like record.

LANGUAGE: typescript
CODE:
const like = await prisma.like.delete({
  where: {
    likeId: {
      userId: 1,
      postId: 1,
    },
  },
})

----------------------------------------

TITLE: Creating New Post with Prisma in Next.js
DESCRIPTION: Implements a form to create a new blog post, saves it to the database using Prisma Client, and redirects to the posts list.

LANGUAGE: tsx
CODE:
import Form from "next/form";
import prisma from "@/lib/prisma";
import { revalidatePath } from "next/cache";
import { redirect } from "next/navigation";

export default function NewPost() {
  async function createPost(formData: FormData) {
    "use server";

    const title = formData.get("title") as string;
    const content = formData.get("content") as string;

    await prisma.post.create({
      data: {
        title,
        content,
        authorId: 1,
      },
    });

    revalidatePath("/posts");
    redirect("/posts");
  }

  return (
    <div className="max-w-2xl mx-auto p-4">
      <h1 className="text-2xl font-bold mb-6">Create New Post</h1>
      <Form action={createPost} className="space-y-6">
        {/* Form fields */}
      </Form>
    </div>
  );
}

----------------------------------------

TITLE: Setting Database Connection URL in Environment File
DESCRIPTION: This snippet demonstrates how to define the DATABASE_URL environment variable in a .env file, using a PostgreSQL connection string as an example.

LANGUAGE: bash
CODE:
DATABASE_URL="postgresql://johndoe:randompassword@localhost:5432/mydb?schema=public"

----------------------------------------

TITLE: Updating Multiple User Records
DESCRIPTION: Example of using updateMany() to update all User records matching certain criteria.

LANGUAGE: typescript
CODE:
const updatedUserCount = await prisma.user.updateMany({
  where: {
    email: {
      contains: 'prisma.io'
    }
  },
  data: {
    role: 'USER'
  }
});

----------------------------------------

TITLE: Example Heroku PostgreSQL Connection URL for Prisma
DESCRIPTION: This snippet shows an example of a PostgreSQL connection URL for a database hosted on Heroku, including the necessary components like user, password, host, port, and database name.

LANGUAGE: bash
CODE:
DATABASE_URL="postgresql://opnmyfngbknppm:XXX@ec2-46-137-91-216.eu-west-1.compute.amazonaws.com:5432/d50rgmkqi2ipus?schema=hello-prisma"

----------------------------------------

TITLE: Creating Migration for Adding Job Title
DESCRIPTION: SQL migration that adds a jobTitle field to the User table. This demonstrates schema evolution with Prisma Migrate.

LANGUAGE: sql
CODE:
-- AlterTable
ALTER TABLE "User" ADD COLUMN     "jobTitle" TEXT NOT NULL;

----------------------------------------

TITLE: Basic Prisma Middleware Implementation
DESCRIPTION: Example showing how to implement multiple middleware functions using prisma.$use method. Each middleware can manipulate parameters before and after query execution.

LANGUAGE: typescript
CODE:
const prisma = new PrismaClient()

// Middleware 1
prisma.$use(async (params, next) => {
  // Manipulate params here
  const result = await next(params)
  // See results here
  return result
})

// Middleware 2
prisma.$use(async (params, next) => {
  // Manipulate params here
  const result = await next(params)
  // See results here
  return result
})

// Queries here

----------------------------------------

TITLE: Implementing Custom Validation with Superstruct for User Signup in TypeScript
DESCRIPTION: This example demonstrates how to use Superstruct to validate user signup data before creating a new user with Prisma Client. It includes custom validation rules for email, password, and name fields.

LANGUAGE: typescript
CODE:
import { PrismaClient, Prisma, User } from '@prisma/client'
import { assert, object, string, size, refine } from 'superstruct'
import isEmail from 'isemail'

const prisma = new PrismaClient()

// Runtime validation
const Signup = object({
  // string and a valid email address
  email: refine(string(), 'email', (v) => isEmail.validate(v)),
  // password is between 7 and 30 characters long
  password: size(string(), 7, 30),
  // first name is between 2 and 50 characters long
  firstName: size(string(), 2, 50),
  // last name is between 2 and 50 characters long
  lastName: size(string(), 2, 50),
})

type Signup = Omit<Prisma.UserCreateArgs['data'], 'id'>

// Signup function
async function signup(input: Signup): Promise<User> {
  // Assert that input conforms to Signup, throwing with a helpful
  // error message if input is invalid.
  assert(input, Signup)
  return prisma.user.create({
    data: input.user,
  })
}

----------------------------------------

TITLE: Implicit Many-to-Many MongoDB Schema
DESCRIPTION: Defines a many-to-many relation in MongoDB using array fields to store related IDs.

LANGUAGE: prisma
CODE:
model Post {
  id          String     @id @default(auto()) @map("_id") @db.ObjectId
  categoryIDs String[]   @db.ObjectId
  categories  Category[] @relation(fields: [categoryIDs], references: [id])
}

model Category {
  id      String   @id @default(auto()) @map("_id") @db.ObjectId
  name    String
  postIDs String[] @db.ObjectId
  posts   Post[]   @relation(fields: [postIDs], references: [id])
}

----------------------------------------

TITLE: Creating Related Records with Prisma Client
DESCRIPTION: Demonstrates how to create a User record with nested Profile and Post records using Prisma Client's nested write functionality. Includes querying the created data with relationship inclusion.

LANGUAGE: typescript
CODE:
async function main() {
  await prisma.user.create({
    data: {
      name: 'Alice',
      email: 'alice@prisma.io',
      posts: {
        create: { title: 'Hello World' },
      },
      profile: {
        create: { bio: 'I like turtles' },
      },
    },
  })

  const allUsers = await prisma.user.findMany({
    include: {
      posts: true,
      profile: true,
    },
  })
  console.dir(allUsers, { depth: null })

----------------------------------------

TITLE: Initializing Prisma Schema with User and Post Models
DESCRIPTION: Basic Prisma schema definition that creates User and Post models with a one-to-many relationship. The schema uses PostgreSQL as the database provider and includes environment variable configuration.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id    Int    @id @default(autoincrement())
  name  String
  posts Post[]
}

model Post {
  id        Int     @id @default(autoincrement())
  title     String
  published Boolean @default(true)
  authorId  Int
  author    User    @relation(fields: [authorId], references: [id])
}

----------------------------------------

TITLE: Adding a Sign Up Method to User Model in Prisma Client Extension
DESCRIPTION: This example adds a 'signUp' method to the user model, which creates a new user with the specified email address.

LANGUAGE: typescript
CODE:
const prisma = new PrismaClient().$extends({
  model: {
    user: {
      async signUp(email: string) {
        await prisma.user.create({ data: { email } })
      },
    },
  },
})

----------------------------------------

TITLE: Creating Records with Prisma Client in TypeScript
DESCRIPTION: Example of creating a new record using Prisma Client, replacing a Drizzle insert query in a TypeScript application.

LANGUAGE: typescript
CODE:
import { revalidatePath } from "next/cache";

import { prisma } from "@/db/prisma";

export const addTodo = async (id: number, text: string) => {
  await prisma.todo.create({
    data: { id, text },
  })
  revalidatePath("/");
};

----------------------------------------

TITLE: Basic Querying in Prisma vs Drizzle
DESCRIPTION: Comparison of basic database query operations like findMany, findFirst, and findUnique between Prisma and Drizzle.

LANGUAGE: typescript
CODE:
// find all users
const allUsers = await prisma.user.findMany()

// find a single user
const user = await prisma.user.findFirst({
  where: { id: 27 },
})

// find a unique user
const user = await prisma.user.findUnique({
  where: { email: 'nilu@prisma.io' },
})

LANGUAGE: typescript
CODE:
import { eq } from 'drizzle-orm'

// find all users
const allUsers = await db.query.users.findMany()

// find a single user
const user = await db.query.users.findFirst({
  where: eq(users.id, 1),
})

// find a unique post
const user = await db.query.users.findFirst({
  where: eq(users.email, 'nilu@prisma.io'),
})

----------------------------------------

TITLE: Configuring GIN Index in PostgreSQL
DESCRIPTION: Example showing how to create a GIN index with JsonbPathOps operator class for JSON data.

LANGUAGE: prisma
CODE:
model Example {
  id    Int  @id
  value Json

  @@index([value(ops: JsonbPathOps)], type: Gin)
}

----------------------------------------

TITLE: Configuring PostgreSQL Datasource in Prisma Schema
DESCRIPTION: This snippet shows how to configure a PostgreSQL datasource in the Prisma schema file. It specifies the provider as 'postgresql' and uses an environment variable for the database URL.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

----------------------------------------

TITLE: Implementing Cloudflare Worker with Prisma Client
DESCRIPTION: TypeScript implementation of a Cloudflare Worker that uses Prisma Client with D1 adapter to query the database.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client'
import { PrismaD1 } from '@prisma/adapter-d1'

export interface Env {
  DB: D1Database
}

export default {
  async fetch(
    request: Request,
    env: Env,
    ctx: ExecutionContext
  ): Promise<Response> {
    const adapter = new PrismaD1(env.DB)
    const prisma = new PrismaClient({ adapter })

    const users = await prisma.user.findMany()
    const result = JSON.stringify(users)
    return new Response(result)
  },
}

----------------------------------------

TITLE: Omitting Multiple Fields in Prisma Client (TypeScript)
DESCRIPTION: This snippet demonstrates how to omit multiple fields in a single query using the 'omit' option. It excludes both the 'password' and 'email' fields from a User model query.

LANGUAGE: typescript
CODE:
const prisma = new PrismaClient()

// password and email are excluded
const user = await prisma.user.findUnique({
  omit: {
    email: true,
    password: true,
  },
  where: {
    id: 1,
  },
})

----------------------------------------

TITLE: StatsD Integration Example
DESCRIPTION: Shows how to send Prisma Client metrics to StatsD for time-series visualization.

LANGUAGE: typescript
CODE:
import StatsD from 'hot-shots'
let statsd = new StatsD({
  port: 8125,
})

const diffMetrics = (metrics: Metric<MetricHistogram>[]) => {
  return metrics.map((metric) => {
    let prev = 0;
    const diffBuckets = metric.value.buckets.map<MetricHistogramBucket>(
      (values) => {
        const [bucket, value] = values
        const diff = value - prev
        prev = value
        return [bucket, diff]
      }
    )
    metric.value.buckets = diffBuckets
    return metric
  })
}

let previousHistograms: Metric<MetricHistogram>[] = []

const statsdSender = async () => {
  const metrics = await prisma.$metrics.json()
  
  metrics.counters.forEach((counter: any) => {
    statsd.gauge('prisma.' + counter.key, counter.value, (...res) => {})
  });

  metrics.gauges.forEach((counter: any) => {
    statsd.gauge('prisma.' + counter.key, counter.value, (...res) => {})
  })

  if (!previousHistograms.length) {
    previousHistograms = diffMetrics(metrics.histograms)
    return
  }

  const diffHistograms = diffMetrics(metrics.histograms);

  diffHistograms.forEach((diffHistogram, histogramIndex) => {
    diffHistogram.value.buckets.forEach((values, bucketIndex) => {
      const [bucket, count] = values
      const [_, prev] =
        previousHistograms[histogramIndex].value.buckets[bucketIndex]
      const change = count - prev

      for (let sendTimes = 0; sendTimes < change; sendTimes++) {
        statsd.timing('prisma.' + diffHistograms.key, bucket)
      }
    })
  })

  previousHistograms = diffHistograms
}

setInterval(async () => await statsdSender(), 10000)

----------------------------------------

TITLE: Basic One-to-Many Relation Schema for MongoDB
DESCRIPTION: Defines a one-to-many relation between User and Post models in MongoDB using ObjectId fields. Shows how to map fields to MongoDB's _id convention.

LANGUAGE: prisma
CODE:
model User {
  id    String @id @default(auto()) @map("_id") @db.ObjectId
  posts Post[]
}

model Post {
  id       String @id @default(auto()) @map("_id") @db.ObjectId
  author   User   @relation(fields: [authorId], references: [id])
  authorId String @db.ObjectId
}

----------------------------------------

TITLE: Sequelize ORM Model Definition
DESCRIPTION: Example of defining a User model using Sequelize ORM with field configurations.

LANGUAGE: javascript
CODE:
class User extends Model {}
User.init(
  {
    user_id: {
      type: Sequelize.INTEGER,
      primaryKey: true,
      autoIncrement: true,
    },
    name: Sequelize.STRING(255),
    email: {
      type: Sequelize.STRING(255),
      unique: true,
    },
    isAdmin: Sequelize.BOOLEAN,
  },
  { sequelize, modelName: 'user' }
)

----------------------------------------

TITLE: Client-Level Method Extension Example
DESCRIPTION: Example of creating an extension that uses client-level methods and handles transactions.

LANGUAGE: typescript
CODE:
export default Prisma.defineExtension((client) => {
  return client.$extends({
    name: 'prisma-extension-find-or-create',
    query: {
      $allModels: {
        async findOrCreate({ args, query, operation }) {
          return (await client.$transaction([query(args)]))[0]
        },
      },
    },
  })
})

----------------------------------------

TITLE: Calculating Default Connection Pool Size in Prisma
DESCRIPTION: Formula used to calculate the default number of connections in Prisma's connection pool based on physical CPU count.

LANGUAGE: bash
CODE:
num_physical_cpus * 2 + 1

----------------------------------------

TITLE: Using the @map attribute
DESCRIPTION: Maps a field name to a different column name in the database using the @map attribute.

LANGUAGE: prisma
CODE:
model User {
  id        Int    @id @default(autoincrement())
  firstName String @map("first_name")
}

----------------------------------------

TITLE: Deploying to Fly.io using CLI
DESCRIPTION: This command initiates the deployment process to Fly.io using the fly CLI. It automatically configures and deploys the application.

LANGUAGE: terminal
CODE:
fly launch

----------------------------------------

TITLE: Using the @relation attribute
DESCRIPTION: Defines meta information about a relation using the @relation attribute.

LANGUAGE: prisma
CODE:
model Post {
  id       Int    @id @default(autoincrement())
  author   User   @relation(fields: [authorId], references: [id])
  authorId Int
}

model User {
  id    Int    @id @default(autoincrement())
  posts Post[]
}

----------------------------------------

TITLE: Defining Prisma Data Model for Post, Profile, and User
DESCRIPTION: This Prisma schema defines three models: Post, Profile, and User. It includes relationships between the models and specifies field types and constraints.

LANGUAGE: prisma
CODE:
model Post {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  title     String   @db.VarChar(255)
  content   String?
  published Boolean  @default(false)
  author    User     @relation(fields: [authorId], references: [id])
  authorId  Int
}

model Profile {
  id     Int     @id @default(autoincrement())
  bio    String?
  user   User    @relation(fields: [userId], references: [id])
  userId Int     @unique
}

model User {
  id      Int      @id @default(autoincrement())
  email   String   @unique
  name    String?
  posts   Post[]
  profile Profile?
}

----------------------------------------

TITLE: Initializing PrismaClient with Custom Options
DESCRIPTION: Example of creating a PrismaClient instance with custom logging and error formatting options.

LANGUAGE: typescript
CODE:
const prisma = new PrismaClient({
  log: ['query', 'info', 'warn'],
  errorFormat: 'pretty'
});

----------------------------------------

TITLE: Configuring OpenTelemetry Tracing with SDK-Trace-Node
DESCRIPTION: This snippet demonstrates how to set up OpenTelemetry tracing using @opentelemetry/sdk-trace-node, providing fine-grained control over tracing configuration.

LANGUAGE: typescript
CODE:
import { ATTR_SERVICE_NAME, ATTR_SERVICE_VERSION } from '@opentelemetry/semantic-conventions'
import { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-http'
import { SimpleSpanProcessor } from '@opentelemetry/sdk-trace-base'
import { NodeTracerProvider } from '@opentelemetry/sdk-trace-node'
import { PrismaInstrumentation, registerInstrumentations } from '@prisma/instrumentation'
import { Resource } from '@opentelemetry/resources'

const provider = new NodeTracerProvider({
  resource: new Resource({
    [SEMRESATTRS_SERVICE_NAME]: 'example application',
    [SEMRESATTRS_SERVICE_VERSION]: '0.0.1',
  }),
})

provider.addSpanProcessor(new SimpleSpanProcessor(new OTLPTraceExporter()))

registerInstrumentations({
  tracerProvider: provider,
  instrumentations: [new PrismaInstrumentation()],
})

provider.register()

----------------------------------------

TITLE: Installing Prisma Client via npm for JavaScript and CockroachDB
DESCRIPTION: This command installs the @prisma/client package and automatically generates Prisma Client based on the Prisma schema. It's essential for setting up Prisma in a JavaScript project with CockroachDB.

LANGUAGE: terminal
CODE:
npm install @prisma/client

----------------------------------------

TITLE: Retrieving JSON Metrics
DESCRIPTION: Demonstrates how to retrieve metrics in JSON format from Prisma Client.

LANGUAGE: typescript
CODE:
const metrics = await prisma.$metrics.json()
console.log(metrics)

----------------------------------------

TITLE: Adding Native Database Function to Prisma Schema
DESCRIPTION: This snippet demonstrates how to add a field with a native database function (gen_random_uuid()) to a Prisma model. It uses the @default(dbgenerated()) attribute to specify the function.

LANGUAGE: prisma
CODE:
model User {
  id String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
}

----------------------------------------

TITLE: Defining Prisma schema for MongoDB with JavaScript
DESCRIPTION: This schema defines the data source as MongoDB, sets up the Prisma client generator, and creates models for Post, User, and Comment with their relationships. It also includes an embedded Address type for the User model. The schema uses MongoDB-specific attributes like @db.ObjectId and @map("_id") for ID fields.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model Post {
  id       String    @id @default(auto()) @map("_id") @db.ObjectId
  slug     String    @unique
  title    String
  body     String
  author   User      @relation(fields: [authorId], references: [id])
  authorId String    @db.ObjectId
  comments Comment[]
}

model User {
  id      String   @id @default(auto()) @map("_id") @db.ObjectId
  email   String   @unique
  name    String?
  address Address?
  posts   Post[]
}

model Comment {
  id      String @id @default(auto()) @map("_id") @db.ObjectId
  comment String
  post    Post   @relation(fields: [postId], references: [id])
  postId  String @db.ObjectId
}

// Address is an embedded document
type Address {
  street String
  city   String
  state  String
  zip    String
}

----------------------------------------

TITLE: Prisma Client Query Example
DESCRIPTION: Example showing how to query data using Prisma Client with type safety

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

const user = await prisma.user.findUnique({
  where: {
    email: 'alice@prisma.io',
  },
  include: {
    posts: true,
  },
})

----------------------------------------

TITLE: Installing Prisma Client
DESCRIPTION: Command to install Prisma Client in your project. This also runs prisma generate to generate the client code.

LANGUAGE: shell
CODE:
npm install @prisma/client

----------------------------------------

TITLE: Basic SQL Query Example
DESCRIPTION: Sample SQL query for retrieving users with post counts using joins and grouping

LANGUAGE: sql
CODE:
SELECT u.id, u.name, COUNT(p.id) as "postCount"
FROM "User" u
LEFT JOIN "Post" p ON u.id = p."authorId"
GROUP BY u.id, u.name

----------------------------------------

TITLE: Data Copy Migration SQL
DESCRIPTION: SQL migration to copy data from old field to new field as part of the expand and contract pattern.

LANGUAGE: sql
CODE:
UPDATE "Profile" SET biography = bio;

----------------------------------------

TITLE: Logging Connection Pool Size in Prisma Client
DESCRIPTION: Example of using Prisma Client logging to view the connection pool size at runtime.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient({
  log: ['info'],
})

async function main() {
  await prisma.user.findMany()
}

main()

----------------------------------------

TITLE: Filtering for Concrete Values with Prisma ORM and Mongoose in TypeScript
DESCRIPTION: Demonstrates how to filter posts based on a specific title. Prisma uses a contains operator within the where clause, while Mongoose directly uses the field name for exact matching.

LANGUAGE: typescript
CODE:
const posts = await prisma.post.findMany({
  where: {
    title: {
      contains: 'Hello World',
    },
  },
})

LANGUAGE: typescript
CODE:
const posts = await Post.find({
  title: 'Hello World',
})

----------------------------------------

TITLE: Implementing Offset Pagination in Prisma with TypeScript
DESCRIPTION: This snippet demonstrates how to use offset pagination in Prisma Client. It skips the first 3 Post records and returns records 4-7 using the skip and take parameters.

LANGUAGE: typescript
CODE:
const results = await prisma.post.findMany({
  skip: 3,
  take: 4,
})

----------------------------------------

TITLE: Invoking Prisma CLI
DESCRIPTION: Shows how to invoke the Prisma CLI using npx.

LANGUAGE: bash
CODE:
npx prisma

----------------------------------------

TITLE: Adding Comments in Prisma Schema
DESCRIPTION: This snippet shows different types of comments in Prisma Schema Language, including comments for reader clarity and comments that appear in the abstract syntax tree (AST).

LANGUAGE: prisma
CODE:
/// This comment will get attached to the `User` node in the AST
model User {
  /// This comment will get attached to the `id` node in the AST
  id     Int   @default(autoincrement())
  // This comment is just for you
  weight Float /// This comment gets attached to the `weight` node
}

// This comment is just for you. It will not
// show up in the AST.

/// This comment will get attached to the
/// Customer node.
model Customer {}

----------------------------------------

TITLE: Handling unique constraint violation in TypeScript with Prisma Client
DESCRIPTION: This TypeScript code demonstrates how to handle a unique constraint violation error when trying to create a user with an existing email. It uses Prisma Client and checks for specific error codes.

LANGUAGE: typescript
CODE:
import { PrismaClient, Prisma } from '@prisma/client'

const client = new PrismaClient()

try {
  await client.user.create({ data: { email: 'alreadyexisting@mail.com' } })
} catch (e) {
  if (e instanceof Prisma.PrismaClientKnownRequestError) {
    // The .code property can be accessed in a type-safe manner
    if (e.code === 'P2002') {
      console.log(
        'There is a unique constraint violation, a new user cannot be created with this email'
      )
    }
  }
  throw e
}

----------------------------------------

TITLE: Using Prisma CLI with Package Runners
DESCRIPTION: Commands for executing Prisma CLI using different package runners after local installation.

LANGUAGE: bash
CODE:
npx prisma

LANGUAGE: bash
CODE:
yarn prisma

LANGUAGE: bash
CODE:
pnpm dlx prisma

LANGUAGE: bash
CODE:
bunx prisma

----------------------------------------

TITLE: Order Creation Business Logic Implementation
DESCRIPTION: TypeScript function implementing order creation logic with customer handling and product validation.

LANGUAGE: typescript
CODE:
import prisma from '../client'

export interface Customer {
  id?: number
  name?: string
  email: string
  address?: string
}

export interface OrderInput {
  customer: Customer
  productId: number
  quantity: number
}

export async function createOrder(input: OrderInput) {
  const { productId, quantity, customer } = input
  const { name, email, address } = customer

  const product = await prisma.product.findUnique({
    where: {
      id: productId,
    },
  })

  if (!product) return new Error('Out of stock')

  await prisma.customerOrder.create({
    data: {
      customer: {
        connectOrCreate: {
          create: {
            name,
            email,
            address,
          },
          where: {
            email,
          },
        },
      },
      orderDetails: {
        create: {
          total: product.price,
          quantity,
          products: {
            connect: {
              id: product.id,
            },
          },
        },
      },
    },
  })
}

----------------------------------------

TITLE: Querying Posts in Next.js getServerSideProps
DESCRIPTION: This snippet demonstrates how to use Prisma Client to query published posts in Next.js getServerSideProps function, which can also be used with getStaticProps.

LANGUAGE: typescript
CODE:
export const getServerSideProps = async () => {
  const feed = await prisma.post.findMany({
    where: {
      published: true,
    },
  })
  return { props: { feed } }
}

----------------------------------------

TITLE: Creating Related Records with Nested Writes
DESCRIPTION: Demonstrates how to create a User record with related Post and Profile records using Prisma Client's nested write functionality. Includes querying the created data with relation fields.

LANGUAGE: javascript
CODE:
async function main() {
  await prisma.user.create({
    data: {
      name: 'Alice',
      email: 'alice@prisma.io',
      posts: {
        create: { title: 'Hello World' },
      },
      profile: {
        create: { bio: 'I like turtles' },
      },
    },
  })

  const allUsers = await prisma.user.findMany({
    include: {
      posts: true,
      profile: true,
    },
  })
  console.dir(allUsers, { depth: null })
}

----------------------------------------

TITLE: Adding Custom Cache Strategy to findMany Method
DESCRIPTION: Shows how to extend the findMany method with custom cache strategy arguments using Prisma's Exact and Args type utilities. Adds TTL and SWR parameters to the method signature while maintaining type safety.

LANGUAGE: typescript
CODE:
type CacheStrategy = {
  swr: number
  ttl: number
}

const prisma = new PrismaClient().$extends({
  model: {
    $allModels: {
      findMany<T, A>(
        this: T,
        args: Prisma.Exact<
          A,
          Prisma.Args<T, 'findMany'> & CacheStrategy
        >
      ): Prisma.Result<T, A, 'findMany'> {
        // method implementation with the cache strategy
      },
    },
  },
})

async function main() {
  await prisma.post.findMany({
    cacheStrategy: {
      ttl: 360,
      swr: 60,
    },
  })
}

----------------------------------------

TITLE: Creating Initial Database Migration
DESCRIPTION: SQL migration that creates User and Post tables with proper relationships and constraints. This migration is generated using the 'prisma migrate dev' command.

LANGUAGE: sql
CODE:
-- CreateTable
CREATE TABLE "User" (
    "id" SERIAL,
    "name" TEXT NOT NULL,

    PRIMARY KEY ("id")
);
  -- CreateTable
CREATE TABLE "Post" (
    "id" SERIAL,
    "title" TEXT NOT NULL,
    "published" BOOLEAN NOT NULL DEFAULT true,
    "authorId" INTEGER NOT NULL,

    PRIMARY KEY ("id")
);

  -- AddForeignKey
ALTER TABLE "Post" ADD FOREIGN KEY("authorId")REFERENCES "User"("id") ON DELETE CASCADE ON UPDATE CASCADE;

----------------------------------------

TITLE: Pushing Schema Changes to Database
DESCRIPTION: Pushes schema changes to the database without using migrations using the prisma db push command.

LANGUAGE: terminal
CODE:
prisma db push

----------------------------------------

TITLE: Expand and Contract Pattern Schema
DESCRIPTION: Prisma schema showing the expand phase of the expand and contract pattern with both old and new fields.

LANGUAGE: prisma
CODE:
model Profile {
  id        Int    @id @default(autoincrement())
  bio       String
  biography String
  userId    Int    @unique
  user      User   @relation(fields: [userId], references: [id])
}

----------------------------------------

TITLE: Fetching Posts in Next.js API Route
DESCRIPTION: This code snippet shows how to create a Next.js API route that uses Prisma Client to fetch all published posts and return them as JSON.

LANGUAGE: typescript
CODE:
const prisma = new PrismaClient()

export default async function handle(req, res) {
  const posts = await prisma.post.findMany({
    where: {
      published: true,
    },
  })
  res.json(posts)
}

----------------------------------------

TITLE: Creating Objects with Prisma ORM and Mongoose in TypeScript
DESCRIPTION: Shows how to create new user objects. Prisma uses the create method with a data object, while Mongoose offers both create and save methods.

LANGUAGE: typescript
CODE:
const user = await prisma.user.create({
  data: {
    name: 'Alice',
    email: 'alice@prisma.io',
  },
})

LANGUAGE: typescript
CODE:
const user = await User.create({
  name: 'Alice',
  email: 'alice@prisma.io',
})

LANGUAGE: typescript
CODE:
const user = new User({
  name: 'Alice',
  email: 'alice@prisma.io',
})
await user.save()

----------------------------------------

TITLE: Configuring Prisma Schema for Database Connection in TypeScript
DESCRIPTION: This snippet shows how to set up the datasource block in the Prisma schema file to connect to a PostgreSQL database using an environment variable for the connection URL.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

----------------------------------------

TITLE: Creating Basic Typed Query Statement in TypeScript
DESCRIPTION: Example showing how to create a typed but not type-safe query statement for selecting a user's email using Prisma.

LANGUAGE: typescript
CODE:
import { Prisma } from '@prisma/client'

const userEmail: Prisma.UserSelect = {
  email: true,
}

// Run inside async function
const user = await prisma.user.findUnique({
  where: {
    id: 3,
  },
  select: userEmail,
})

----------------------------------------

TITLE: Creating Migration for New Feature
DESCRIPTION: This command creates a new migration for the added 'tags' field after prototyping changes.

LANGUAGE: bash
CODE:
npx prisma migrate dev --name added-tags

----------------------------------------

TITLE: Using Exported PrismaClient Instance
DESCRIPTION: Demonstrates how to import and use the shared PrismaClient instance to perform database queries.

LANGUAGE: typescript
CODE:
import prisma from './client'

async function main() {
  const allUsers = await prisma.user.findMany()
}

main()

----------------------------------------

TITLE: Upserting records by compound ID in Prisma Client
DESCRIPTION: This TypeScript snippet shows how to upsert a record using a compound ID in a Prisma Client query. It uses the upsert() method to update or create a Like record.

LANGUAGE: typescript
CODE:
await prisma.like.upsert({
  where: {
    likeId: {
      userId: 1,
      postId: 1,
    },
  },
  update: {
    userId: 2,
  },
  create: {
    userId: 2,
    postId: 1,
  },
})

----------------------------------------

TITLE: Initializing Prisma Client in TypeScript
DESCRIPTION: Basic setup code for initializing PrismaClient and creating a main function wrapper with proper error handling and connection management.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

async function main() {
  // ... you will write your Prisma Client queries here
}

main()
  .then(async () => {
    await prisma.$disconnect()
  })
  .catch(async (e) => {
    console.error(e)
    await prisma.$disconnect()
    process.exit(1)
  })

----------------------------------------

TITLE: Explicit Many-to-Many Schema Definition in Prisma
DESCRIPTION: Defines an explicit many-to-many relation between Post and Category models with a CategoriesOnPosts relation table that includes additional metadata fields.

LANGUAGE: prisma
CODE:
model Post {
  id         Int                 @id @default(autoincrement())
  title      String
  categories CategoriesOnPosts[]
}

model Category {
  id    Int                 @id @default(autoincrement())
  name  String
  posts CategoriesOnPosts[]
}

model CategoriesOnPosts {
  post       Post     @relation(fields: [postId], references: [id])
  postId     Int
  category   Category @relation(fields: [categoryId], references: [id])
  categoryId Int
  assignedAt DateTime @default(now())
  assignedBy String

  @@id([postId, categoryId])
}

----------------------------------------

TITLE: Implementing Query Caching in Prisma Postgres with TypeScript
DESCRIPTION: Demonstrates how to enable caching for a Prisma query using the cacheStrategy option. The example shows setting both TTL (Time To Live) and SWR (Stale While Revalidate) parameters to 60 seconds.

LANGUAGE: typescript
CODE:
const users = await prisma.user.findMany({
  cacheStrategy: {
    ttl: 60,
    swr: 60
  }
})

----------------------------------------

TITLE: Prisma schema with custom naming using @map and @@map
DESCRIPTION: The modified Prisma schema using @map and @@map attributes to customize model and field names, adhering to Prisma ORM naming conventions while maintaining the original database structure.

LANGUAGE: prisma
CODE:
model Category {
  id                 Int                @id @default(autoincrement()) @map("category_id")
  name               String?            @db.VarChar(256)
  post_in_categories PostInCategories[]

  @@map("categories")
}

model PostInCategories {
  post_id     Int
  category_id Int
  categories  Category @relation(fields: [category_id], references: [id], onDelete: NoAction, onUpdate: NoAction)
  posts       Post     @relation(fields: [post_id], references: [id], onDelete: NoAction, onUpdate: NoAction)

  @@unique([post_id, category_id], map: "post_id_category_id_unique")
  @@map("post_in_categories")
}

model Post {
  id                 Int                @id @default(autoincrement()) @map("post_id")
  created_at         DateTime?          @default(now()) @db.Timestamptz(6)
  title              String             @db.VarChar(256)
  content            String?
  author_id          Int?
  users              User?              @relation(fields: [author_id], references: [id], onDelete: NoAction, onUpdate: NoAction)
  post_in_categories PostInCategories[]

  @@map("posts")
}

model Profile {
  id      Int     @id @default(autoincrement()) @map("profile_id")
  bio     String?
  user_id Int     @unique
  users   User    @relation(fields: [user_id], references: [id], onDelete: NoAction, onUpdate: NoAction)

  @@map("profiles")
}

model User {
  id       Int      @id @default(autoincrement()) @map("user_id")
  name     String?  @db.VarChar(256)
  email    String   @unique @db.VarChar(256)
  posts    Post[]
  profiles Profile?

  @@map("users")
}

----------------------------------------

TITLE: Basic Referential Action Example with Cascade Delete
DESCRIPTION: Demonstrates configuring a cascade delete between User and Post models where deleting a User will also delete all related Posts.

LANGUAGE: prisma
CODE:
model Post {
  id       Int    @id @default(autoincrement())
  title    String
  author   User   @relation(fields: [authorId], references: [id], onDelete: Cascade)
  authorId Int
}

model User {
  id    Int    @id @default(autoincrement())
  posts Post[]
}

----------------------------------------

TITLE: Configuring Multiple Database Replicas in TypeScript
DESCRIPTION: Shows how to configure multiple database replicas by passing an array of connection strings to the url property of the readReplicas extension.

LANGUAGE: typescript
CODE:
const prisma = new PrismaClient().$extends(
  readReplicas({
    url: [
      process.env.DATABASE_URL_REPLICA_1,
      process.env.DATABASE_URL_REPLICA_2,
    ],
  })
)

----------------------------------------

TITLE: Initializing Prisma Client in TypeScript
DESCRIPTION: Basic setup code for initializing PrismaClient and creating a main function wrapper with proper error handling and connection management.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

async function main() {
  // ... you will write your Prisma Client queries here
}

main()
  .then(async () => {
    await prisma.$disconnect()
  })
  .catch(async (e) => {
    console.error(e)
    await prisma.$disconnect()
    process.exit(1)
  })

----------------------------------------

TITLE: Custom Constraint Names in Prisma Schema
DESCRIPTION: Example of using custom constraint and index names in Prisma schema using the map argument.

LANGUAGE: prisma
CODE:
model User {
  id    Int    @id(map: "Custom_Primary_Key_Constraint_Name") @default(autoincrement())
  name  String @unique
  posts Post[]
}

model Post {
  id         Int    @id @default(autoincrement())
  title      String
  authorName String @default("Anonymous")
  author     User?  @relation(fields: [authorName], references: [name])

  @@index([title, authorName], map: "My_Custom_Index_Name")
}

----------------------------------------

TITLE: Defining a Post Model in Prisma Schema
DESCRIPTION: Prisma schema definition for a 'Post' model corresponding to the CockroachDB table, showing the use of CockroachDB-specific type annotations.

LANGUAGE: prisma
CODE:
model Post {
  id    BigInt @id
  title String @db.String(200)
}

----------------------------------------

TITLE: Initializing PrismaClient with Accelerate Extension in TypeScript
DESCRIPTION: This snippet demonstrates how to set up a PrismaClient instance with the Prisma Accelerate extension. It imports necessary modules, creates a new PrismaClient, and applies the withAccelerate extension.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client'
import { withAccelerate } from '@prisma/extension-accelerate'

const prisma = new PrismaClient()
  .$extends(withAccelerate())

----------------------------------------

TITLE: Creating Example Content with Prisma Client
DESCRIPTION: This TypeScript snippet demonstrates how to create a user with a related post using Prisma Client.

LANGUAGE: typescript
CODE:
const add = await prisma.user.create({
  data: {
    name: 'Eloise',
    jobTitle: 'Programmer',
    posts: {
      create: {
        title: 'How to create a MySQL database',
        content: 'Some content',
      },
    },
  },
})

----------------------------------------

TITLE: Marking Squashed Migration as Applied in Production
DESCRIPTION: This command uses 'migrate resolve' to mark the newly created squashed migration as already applied in the production environment, preventing it from being run again.

LANGUAGE: bash
CODE:
npx prisma migrate resolve \
 --applied 000000000000_squashed_migrations

----------------------------------------

TITLE: Deleting Objects with Prisma ORM and Mongoose in TypeScript
DESCRIPTION: Shows how to delete user objects. Prisma uses the delete method with a where clause, while Mongoose uses the deleteOne method.

LANGUAGE: typescript
CODE:
const user = prisma.user.delete({
  where: {
    id: 10,
  },
})

LANGUAGE: typescript
CODE:
await User.deleteOne({ _id: 10 })

----------------------------------------

TITLE: Implementing Cache Strategy in Prisma Query
DESCRIPTION: Example of using cacheStrategy in a Prisma findMany query with SWR, TTL, and cache tags. Demonstrates how to set cache duration and tag-based invalidation.

LANGUAGE: typescript
CODE:
await prisma.user.findMany({
  where: {
    email: {
      contains: "alice@prisma.io",
    },
  },
  cacheStrategy: {
    swr: 60,
    ttl: 60,
    tags: ["emails_with_alice"],
  },
});

----------------------------------------

TITLE: Event-based Logging for MongoDB Queries in Prisma Client (TypeScript)
DESCRIPTION: This example shows how to configure event-based logging specifically for MongoDB queries in Prisma Client. It sets up the client to emit query events and logs the MongoDB query strings.

LANGUAGE: typescript
CODE:
const prisma = new PrismaClient({
  log: [
    {
      emit: 'event',
      level: 'query',
    },
    {
      emit: 'stdout',
      level: 'error',
    },
    {
      emit: 'stdout',
      level: 'info',
    },
    {
      emit: 'stdout',
      level: 'warn',
    },
  ],
})

prisma.$on('query', (e) => {
  console.log('Query: ' + e.query)
})

----------------------------------------

TITLE: Generate Down Migration Using Schema Datasource
DESCRIPTION: Alternative command to generate down migration SQL using schema datasource comparison.

LANGUAGE: bash
CODE:
npx prisma migrate diff \
 --from-schema-datamodel prisma/schema.prisma \
 --to-schema-datasource prisma/schema.prisma \
 --script > down.sql

----------------------------------------

TITLE: Enabling All Debug Output
DESCRIPTION: Command to enable all possible debug output using the * wildcard, which will show debug messages from all available namespaces.

LANGUAGE: terminal
CODE:
export DEBUG="*"

----------------------------------------

TITLE: Updating Objects with Prisma ORM and Sequelize in TypeScript
DESCRIPTION: Demonstrates how to update existing database objects. Prisma uses the update method with a where clause, while Sequelize offers instance method (save) and class method (update) approaches.

LANGUAGE: typescript
CODE:
const user = await prisma.user.update({
  data: {
    name: 'Alicia',
  },
  where: {
    id: 2,
  },
})

LANGUAGE: typescript
CODE:
user.name = 'James'
user.email = ' alice@prisma.com'
await user.save()

LANGUAGE: typescript
CODE:
await User.update({
  name: 'James',
  email: 'james@prisma.io',
})

----------------------------------------

TITLE: Inserting DbNull into JSON Field in Prisma Client
DESCRIPTION: This code demonstrates how to insert a database NULL value into a JSON field using Prisma.DbNull in a create operation with Prisma Client.

LANGUAGE: typescript
CODE:
import { Prisma } from '@prisma/client'

prisma.log.create({
  data: {
    meta: Prisma.DbNull,
  },
})

----------------------------------------

TITLE: Serverless PrismaClient Initialization
DESCRIPTION: Shows correct placement of PrismaClient instantiation in a serverless function context to optimize connection reuse between invocations.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client'

const client = new PrismaClient()

export async function handler() {
  /* ... */
}

----------------------------------------

TITLE: Using Native Type Attribute in Prisma Schema
DESCRIPTION: This example shows how to use a native type attribute (@db.Date) to specify a more specific database type for the createdAt field in the Post model.

LANGUAGE: prisma
CODE:
model Post {
  id        Int      @id
  title     String
  createdAt DateTime @db.Date
}

----------------------------------------

TITLE: Defining Json Field in Prisma Schema
DESCRIPTION: Example of how to define an optional Json field in a Prisma model schema

LANGUAGE: prisma
CODE:
model User {
  id               Int     @id @default(autoincrement())
  email            String  @unique
  name             String?
  posts            Post[]
  extendedPetsData Json?
}

----------------------------------------

TITLE: Sorting search results by relevance in Prisma Client
DESCRIPTION: Example of ordering search results by relevance to a given term using the _relevance field.

LANGUAGE: typescript
CODE:
const posts = await prisma.post.findMany({
  orderBy: {
    _relevance: {
      fields: ['title'],
      search: 'database',
      sort: 'asc'
    },
  },
})

----------------------------------------

TITLE: Defining Prisma schema with MongoDB datasource
DESCRIPTION: Specifies the database connection and Prisma Client generator in the schema file.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

----------------------------------------

TITLE: Filtering scalar lists in Prisma
DESCRIPTION: Shows how to use scalar list filters to query records based on conditions on scalar list fields, such as finding posts with specific tags.

LANGUAGE: typescript
CODE:
const posts = await prisma.post.findMany({
  where: {
    tags: {
      hasEvery: ['databases', 'typescript'],
    },
  },
})

----------------------------------------

TITLE: Defining Prisma Schema for Custom Model Example
DESCRIPTION: This Prisma schema defines the data model for the User and Password entities used in the custom model examples. It includes datasource and generator configurations for PostgreSQL and Prisma Client.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id       String    @id @default(cuid())
  email    String
  password Password?
}

model Password {
  hash   String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId String @unique
}

----------------------------------------

TITLE: Executing an UPDATE query with $executeRaw
DESCRIPTION: Use $executeRaw to execute UPDATE, DELETE or other queries that modify data. Returns the number of affected rows.

LANGUAGE: typescript
CODE:
const result: number = await prisma.$executeRaw`UPDATE User SET active = true WHERE emailValidated = true`;

----------------------------------------

TITLE: Implementing Stale-While-Revalidate (SWR) Caching in Prisma
DESCRIPTION: This snippet shows how to use the SWR caching strategy in Prisma Client. It sets an SWR duration of 60 seconds for a findMany query on the user model.

LANGUAGE: javascript
CODE:
await prisma.user.findMany({
  cacheStrategy: {
    swr: 60,
  },
});

----------------------------------------

TITLE: Initializing Prisma Client Connection
DESCRIPTION: Sets up the basic Prisma Client connection structure with error handling and proper disconnection. Includes initialization, main function definition, and connection lifecycle management.

LANGUAGE: javascript
CODE:
const { PrismaClient } = require('@prisma/client')

const prisma = new PrismaClient()

async function main() {
  // ... you will write your Prisma Client queries here
}

main()
  .then(async () => {
    await prisma.$disconnect()
  })
  .catch(async (e) => {
    console.error(e)
    await prisma.$disconnect()
    process.exit(1)
  })

----------------------------------------

TITLE: SQL One-to-One Relation Example
DESCRIPTION: Example of a one-to-one relation defined using SQL with foreign key constraints

LANGUAGE: sql
CODE:
CREATE TABLE "User" (
    id SERIAL PRIMARY KEY
);
CREATE TABLE "Profile" (
    id SERIAL PRIMARY KEY,
    "user" integer NOT NULL UNIQUE,
    FOREIGN KEY ("user") REFERENCES "User"(id)
);

----------------------------------------

TITLE: Generated SQL for Foreign Key Relations
DESCRIPTION: SQL generated by Prisma Migrate for creating tables with foreign key constraints in PostgreSQL

LANGUAGE: sql
CODE:
-- CreateTable
CREATE TABLE "Post" (
    "id" SERIAL NOT NULL,
    "title" TEXT NOT NULL,
    "authorId" INTEGER NOT NULL,

    CONSTRAINT "Post_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "User" (
    "id" SERIAL NOT NULL,

    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
);

-- AddForeignKey
ALTER TABLE "Post"
  ADD CONSTRAINT "Post_authorId_fkey"
  FOREIGN KEY ("authorId")
  REFERENCES "User"("id") ON DELETE CASCADE ON UPDATE CASCADE;

----------------------------------------

TITLE: Omitting Fields in Prisma Client Query
DESCRIPTION: This example shows how to use the 'omit' option to exclude specific fields (like password) from the query result.

LANGUAGE: typescript
CODE:
const users = await prisma.user.findFirst({
  omit: {
    password: true
  }
})

----------------------------------------

TITLE: Querying a View with Prisma Client
DESCRIPTION: Example of querying the UserInfo view using Prisma Client to find users with a specific name.

LANGUAGE: typescript
CODE:
const userinfo = await prisma.userInfo.findMany({
  where: {
    name: 'Alice',
  },
})

----------------------------------------

TITLE: Writing to Json Field
DESCRIPTION: Example demonstrating how to write JSON data to a field using Prisma.JsonArray

LANGUAGE: typescript
CODE:
var json = [
  { name: 'Bob the dog' },
  { name: 'Claudine the cat' },
] as Prisma.JsonArray

const createUser = await prisma.user.create({
  data: {
    email: 'birgitte@prisma.io',
    extendedPetsData: json,
  },
})

----------------------------------------

TITLE: GraphQL Resolver with Null Handling
DESCRIPTION: Example of properly handling null values in a GraphQL resolver to prevent unwanted updates.

LANGUAGE: typescript
CODE:
updateUser: (parent, args, ctx: Context) => {
  return ctx.prisma.user.update({
    where: { id: Number(args.id) },
    data: {
      email: args.authorEmail != null ? args.authorEmail : undefined,
      name: args.authorName != null ? args.authorName : undefined
    },
  })
}

----------------------------------------

TITLE: Configuring Prisma Schema for PlanetScale
DESCRIPTION: Sets up the Prisma schema for PlanetScale, using the driverAdapters preview feature and specific configuration.

LANGUAGE: prisma
CODE:
generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["driverAdapters"]
}

datasource db {
  provider     = "mysql"
  url          = env("DATABASE_URL")
  relationMode = "prisma" // required for PlanetScale (as by default foreign keys are disabled)
}

----------------------------------------

TITLE: Pushing Initial Schema to Database
DESCRIPTION: This command uses db push to synchronize the initial Prisma schema with the database.

LANGUAGE: bash
CODE:
npx prisma db push

----------------------------------------

TITLE: Schema Drift Detection Output Example
DESCRIPTION: Example console output showing how Prisma reports schema drift when detected, specifically showing changes to an enum type.

LANGUAGE: text
CODE:
[*] Changed the `Color` enum
  [+] Added variant `TRANSPARENT`
  [-] Removed variant `RED`

----------------------------------------

TITLE: Basic User Schema Model
DESCRIPTION: Initial Prisma schema showing basic User model structure

LANGUAGE: prisma
CODE:
model User {
  id   Int    @id
  name String
}

----------------------------------------

TITLE: Filtering and Offset Pagination in Prisma with TypeScript
DESCRIPTION: This example shows how to combine filtering with offset pagination in Prisma Client. It filters posts by email content, skips the first 40 records, and returns records 41-50.

LANGUAGE: typescript
CODE:
const results = await prisma.post.findMany({
  skip: 40,
  take: 10,
  where: {
    email: {
      contains: 'prisma.io',
    },
  },
})

----------------------------------------

TITLE: Implementing Combined TTL and SWR Caching in Prisma
DESCRIPTION: This snippet demonstrates how to use both TTL and SWR caching strategies together in Prisma Client. It sets a TTL of 30 seconds and an SWR of 60 seconds for a findMany query on the user model.

LANGUAGE: javascript
CODE:
await prisma.user.findMany({
  cacheStrategy: {
    ttl: 30,
    swr: 60,
  },
});

----------------------------------------

TITLE: Sample Query Logging Output
DESCRIPTION: Example console output showing the timing logs generated by the middleware for two consecutive Post creation operations.

LANGUAGE: plaintext
CODE:
Query Post.create took 92ms
Query Post.create took 15ms

----------------------------------------

TITLE: Initial Prisma Schema Definition
DESCRIPTION: Base Prisma schema showing Post and User models with their relationships before team modifications.

LANGUAGE: prisma
CODE:
model Post {
  id        Int     @id @default(autoincrement())
  title     String
  content   String?
  published Boolean @default(false)
  author    User?   @relation(fields: [authorId], references: [id])
  authorId  Int?
}

model User {
  id    Int     @id @default(autoincrement())
  email String  @unique
  name  String?
  posts Post[]
}

----------------------------------------

TITLE: Mocking Prisma Client with Singleton Pattern
DESCRIPTION: Set up a mock for the Prisma Client using the singleton pattern and jest-mock-extended.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client'
import { mockDeep, mockReset, DeepMockProxy } from 'jest-mock-extended'

import prisma from './client'

jest.mock('./client', () => ({
  __esModule: true,
  default: mockDeep<PrismaClient>(),
}))

beforeEach(() => {
  mockReset(prismaMock)
})

export const prismaMock = prisma as unknown as DeepMockProxy<PrismaClient>

----------------------------------------

TITLE: Creating Singleton Prisma Client Instance
DESCRIPTION: Create a file to instantiate a singleton Prisma Client instance for use in the application.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()
export default prisma

----------------------------------------

TITLE: Client-Level Custom Error Extension
DESCRIPTION: Implements a Prisma Client extension to handle custom error logic globally for different models

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client';

const customErrorFunc = async (model, query, args) => {
  try {
    await query(args)
  } catch (error: any) {
    if (error.code === 'P2025') {
      throw new Error(`${model} error`)
    }
    throw error;
  }
}

const prisma = (new PrismaClient()).$extends({
  query: {
    user: {
      async findFirstOrThrow({ model, query, args }) {
        return await customErrorFunc(model, query, args)
      },
      async findUniqueOrThrow({ model, query, args }) {
        return await customErrorFunc(model, query, args)
      },
    },
    post: {
      async findFirstOrThrow({ model, query, args }) {
        return await customErrorFunc(model, query, args)
      },
      async findUniqueOrThrow({ model, query, args }) {
        return await customErrorFunc(model, query, args)
      },
    },
  },
})

----------------------------------------

TITLE: Configuring wrangler.toml for node compatibility
DESCRIPTION: Adds the node_compat setting to wrangler.toml to enable Node.js compatibility for Cloudflare Workers.

LANGUAGE: toml
CODE:
node_compat = true

----------------------------------------

TITLE: Synchronizing Embedded Replica with Express Middleware
DESCRIPTION: Implements an Express middleware function to synchronize the embedded Turso database replica before each request, ensuring data freshness.

LANGUAGE: typescript
CODE:
import express from 'express'
const app = express()

app.use(async (req, res, next) => {
  await libsql.sync()
  next()
})

app.listen(3000, () => console.log(`Server ready at http://localhost:3000`))

----------------------------------------

TITLE: Example of Problematic Long-running Transaction in Prisma
DESCRIPTION: Demonstrates a problematic pattern where multiple database operations are wrapped in a single massive transaction. This includes creating an order, updating user balance, and creating shipping information, which can lead to extended resource locking and connection holding.

LANGUAGE: typescript
CODE:
await prisma.$transaction(async (prisma) => {
  const order = await prisma.order.create({
    data: {
      /* ... */
    },
  });
  await prisma.user.update({
    where: { id: userId },
    data: { balance: { decrement: order.total } },
  });
  await prisma.shipping.create({ data: { orderId: order.id /* ... */ } });
  // Additional dependent operations
});

----------------------------------------

TITLE: Defining Relations in Prisma Schema
DESCRIPTION: Example schema showing a one-to-many relation between User and Post models using the @relation attribute

LANGUAGE: prisma
CODE:
model Post {
  id       Int    @id @default(autoincrement())
  title    String
  author   User   @relation(fields: [authorId], references: [id], onDelete: Cascade, onUpdate: Cascade)
  authorId Int
}

model User {
  id    Int    @id @default(autoincrement())
  posts Post[]
}

----------------------------------------

TITLE: Defining a composite ID in Prisma schema
DESCRIPTION: This snippet demonstrates how to define a composite ID using the @@id attribute in a Prisma schema. It shows a Like model with a composite ID made up of postId and userId fields.

LANGUAGE: prisma
CODE:
model User {
  id    Int    @id @default(autoincrement())
  name  String
  post  Post[]
  likes Like[]
}

model Post {
  id      Int    @id @default(autoincrement())
  content String
  User    User?  @relation(fields: [userId], references: [id])
  userId  Int?
  likes   Like[]
}

model Like {
  postId Int
  userId Int
  User   User @relation(fields: [userId], references: [id])
  Post   Post @relation(fields: [postId], references: [id])

  @@id([postId, userId])
}

----------------------------------------

TITLE: Calling Custom Methods Within Prisma Client Extensions
DESCRIPTION: This example demonstrates how to call a custom method from another custom method within the same model extension.

LANGUAGE: typescript
CODE:
const prisma = new PrismaClient().$extends({
  model: {
    user: {
      firstMethod() {
        ...
      },
      secondMethod() {
          Prisma.getExtensionContext(this).firstMethod()
      }
    }
  }
})

----------------------------------------

TITLE: Configuring Binary Targets in Prisma Schema for Node.js 20+
DESCRIPTION: Prisma schema configuration for binary targets to ensure compatibility with Netlify's runtime environment for Node.js version 20 and above.

LANGUAGE: prisma
CODE:
binaryTargets = ["native", "rhel-openssl-3.0.x"]

----------------------------------------

TITLE: Defining a model with scalar fields
DESCRIPTION: Defines a User model with ID and email fields.

LANGUAGE: prisma
CODE:
model User {
  id    Int    @id @default(autoincrement())
  email String @unique
}

----------------------------------------

TITLE: Finding a Unique User Record
DESCRIPTION: Example of using findUnique() to retrieve a single User record by ID.

LANGUAGE: typescript
CODE:
const user = await prisma.user.findUnique({
  where: {
    id: 42
  }
});

----------------------------------------

TITLE: Setting Optimize API Key in Environment
DESCRIPTION: Environment variable configuration for Prisma Optimize API key.

LANGUAGE: bash
CODE:
OPTIMIZE_API_KEY="YOUR_OPTIMIZE_API_KEY"

----------------------------------------

TITLE: Defining Many-to-Many Self-Relation in Prisma
DESCRIPTION: This snippet demonstrates how to define a many-to-many self-relation in Prisma ORM for both relational databases and MongoDB. It models a user with a follower-following relationship.

LANGUAGE: prisma
CODE:
model User {
  id         Int     @id @default(autoincrement())
  name       String?
  followedBy User[]  @relation("UserFollows")
  following  User[]  @relation("UserFollows")
}

LANGUAGE: prisma
CODE:
model User {
  id            String   @id @default(auto()) @map("_id") @db.ObjectId
  name          String?
  followedBy    User[]   @relation("UserFollows", fields: [followedByIDs], references: [id])
  followedByIDs String[] @db.ObjectId
  following     User[]   @relation("UserFollows", fields: [followingIDs], references: [id])
  followingIDs  String[] @db.ObjectId
}

----------------------------------------

TITLE: Querying All Users with Prisma Client
DESCRIPTION: Simple query to fetch all users from the database using Prisma Client's findMany method.

LANGUAGE: javascript
CODE:
async function main() {
  const allUsers = await prisma.user.findMany()
  console.log(allUsers)
}

----------------------------------------

TITLE: Configuring Port Binding in Node.js
DESCRIPTION: This code snippet shows how to configure the server to bind to the port specified by Heroku's PORT environment variable, with a fallback to a default port.

LANGUAGE: javascript
CODE:
const PORT = process.env.PORT || 3000
const server = app.listen(PORT, () => {
  console.log(`app running on port ${PORT}`)
})

----------------------------------------

TITLE: PostgreSQL Case-Insensitive Mode
DESCRIPTION: Example showing how to use the insensitive mode option for case-insensitive filtering in PostgreSQL.

LANGUAGE: typescript
CODE:
const users = await prisma.user.findMany({
  where: {
    email: {
      endsWith: 'prisma.io',
      mode: 'insensitive',
    },
  },
})

----------------------------------------

TITLE: Implementing soft delete middleware in TypeScript
DESCRIPTION: Prisma middleware that intercepts delete operations and converts them to updates, setting the 'deleted' field to true instead of removing records.

LANGUAGE: typescript
CODE:
prisma.$use(async (params, next) => {
  if (params.model == 'Post') {
    if (params.action == 'delete') {
      params.action = 'update'
      params.args['data'] = { deleted: true }
    }
    if (params.action == 'deleteMany') {
      params.action = 'updateMany'
      if (params.args.data != undefined) {
        params.args.data['deleted'] = true
      } else {
        params.args['data'] = { deleted: true }
      }
    }
  }
  return next(params)
})

----------------------------------------

TITLE: Using Prisma Client in Vercel Edge Function with Vercel Postgres
DESCRIPTION: Demonstrates how to instantiate PrismaClient and query a Vercel Postgres database in a Vercel Edge Function.

LANGUAGE: typescript
CODE:
import { NextResponse } from 'next/server'
import { PrismaClient } from '@prisma/client'
import { PrismaNeon } from '@prisma/adapter-neon'
import { Pool } from '@neondatabase/serverless'

export const runtime = 'edge'

export async function GET(request: Request) {
  const neon = new Pool({ connectionString: process.env.POSTGRES_PRISMA_URL })
  const adapter = new PrismaNeon(neon)
  const prisma = new PrismaClient({ adapter })

  const users = await prisma.user.findMany()

  return NextResponse.json(users, { status: 200 })
}

----------------------------------------

TITLE: Deploying Database Changes with GitHub Actions
DESCRIPTION: This YAML configuration sets up a GitHub Action to automatically apply pending Prisma migrations to a production database when changes are pushed to the main branch. It includes steps for checking out the repo, setting up Node.js, installing dependencies, and running the migration command.

LANGUAGE: yaml
CODE:
name: Deploy
on:
  push:
    paths:
      - prisma/migrations/** # Only run this workflow when migrations are updated
    branches:
      - main

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repo
        uses: actions/checkout@v3
      - name: Setup Node
        uses: actions/setup-node@v3
      - name: Install dependencies
        run: npm install
      - name: Apply all pending migrations to the database
        run: npx prisma migrate deploy
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}

----------------------------------------

TITLE: Filtered Aggregation with Ordering in Prisma
DESCRIPTION: Shows how to combine aggregation with filtering, ordering, and limiting results when calculating user age averages.

LANGUAGE: typescript
CODE:
const aggregations = await prisma.user.aggregate({
  _avg: {
    age: true,
  },
  where: {
    email: {
      contains: 'prisma.io',
    },
  },
  orderBy: {
    age: 'asc',
  },
  take: 10,
})

----------------------------------------

TITLE: Enabling a Prisma Client Preview Feature in schema.prisma
DESCRIPTION: Add the Preview feature flag to the generator block in your schema.prisma file to enable a Preview feature. This example enables the 'relationJoins' feature.

LANGUAGE: prisma
CODE:
generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["relationJoins"]
}

----------------------------------------

TITLE: Creating a custom Vercel build command in package.json
DESCRIPTION: Define a custom build command that generates Prisma Client, applies migrations, and builds the Next.js application for more sophisticated CI/CD workflows.

LANGUAGE: json
CODE:
{
  ...
  "scripts" {
    "vercel-build": "prisma generate && prisma migrate deploy && next build"
  }
  ...
}

----------------------------------------

TITLE: Defining PostgreSQL Data Source in Prisma Schema
DESCRIPTION: This snippet demonstrates how to define a data source for a PostgreSQL database in the Prisma schema. It specifies the provider and connection URL.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "postgresql"
  url      = "postgresql://johndoe:mypassword@localhost:5432/mydb?schema=public"
}

----------------------------------------

TITLE: Prisma Schema Model Definition
DESCRIPTION: Definition of a User model in Prisma schema language with field types and attributes.

LANGUAGE: prisma
CODE:
model User {
  user_id Int     @id @default(autoincrement())
  name    String?
  email   String  @unique
  isAdmin Boolean @default(false)
}

----------------------------------------

TITLE: Implementing User Functions without Context
DESCRIPTION: Implement functions for creating and updating users using singleton pattern.

LANGUAGE: typescript
CODE:
import prisma from './client'

interface CreateUser {
  name: string
  email: string
  acceptTermsAndConditions: boolean
}

export async function createUser(user: CreateUser) {
  if (user.acceptTermsAndConditions) {
    return await prisma.user.create({
      data: user,
    })
  } else {
    return new Error('User must accept terms!')
  }
}

interface UpdateUser {
  id: number
  name: string
  email: string
}

export async function updateUsername(user: UpdateUser) {
  return await prisma.user.update({
    where: { id: user.id },
    data: user,
  }
)}

----------------------------------------

TITLE: Configuring NPM for AWS Elastic Beanstalk Deployment
DESCRIPTION: NPM configuration required to allow Prisma Client generation in AWS Elastic Beanstalk's restricted filesystem environment. Sets unsafe-perm to true to run npm as root.

LANGUAGE: config
CODE:
unsafe-perm=true

----------------------------------------

TITLE: Git Repository Setup
DESCRIPTION: Commands to initialize Git repository and push code to GitHub

LANGUAGE: bash
CODE:
git init
git add .
git commit -m 'Initial commit'
git remote add origin git@github.com:<YOUR_GITHUB_USERNAME>/<YOUR_GITHUB_REPOSITORY_NAME>.git
git push -u origin main

----------------------------------------

TITLE: Querying Default Fields with Prisma Client
DESCRIPTION: This snippet demonstrates a basic Prisma Client query that returns all scalar fields of the User model by default.

LANGUAGE: typescript
CODE:
const users = await prisma.user.findFirst()

----------------------------------------

TITLE: Sorting Users with Nested Post Ordering
DESCRIPTION: Example of sorting users by role and name while simultaneously ordering their related posts by title in descending order.

LANGUAGE: typescript
CODE:
const usersWithPosts = await prisma.user.findMany({
  orderBy: [
    {
      role: 'desc',
    },
    {
      name: 'desc',
    },
  ],
  include: {
    posts: {
      orderBy: {
        title: 'desc',
      },
      select: {
        title: true,
      },
    },
  },
})

----------------------------------------

TITLE: Instantiating Prisma Client with Node-Postgres Driver Adapter
DESCRIPTION: This TypeScript snippet shows how to instantiate Prisma Client using the node-postgres driver adapter. It creates a connection pool, initializes the adapter, and passes it to the PrismaClient constructor.

LANGUAGE: typescript
CODE:
import { Pool } from 'pg'
import { PrismaPg } from '@prisma/adapter-pg'
import { PrismaClient } from '@prisma/client'

const connectionString = `${process.env.DATABASE_URL}`

const pool = new Pool({ connectionString })
const adapter = new PrismaPg(pool)
const prisma = new PrismaClient({ adapter })

----------------------------------------

TITLE: Importing Prisma Client in JavaScript
DESCRIPTION: Shows how to import and instantiate Prisma Client in a JavaScript project.

LANGUAGE: javascript
CODE:
const { PrismaClient } = require('@prisma/client')

const prisma = new PrismaClient()
// use `prisma` in your application to read and write data in your DB

----------------------------------------

TITLE: Implementing Prisma Accelerate with TypeScript
DESCRIPTION: Example showing how to extend Prisma Client with Accelerate extension and implement caching strategies. The code demonstrates setting up connection pooling and configuring cache TTL and SWR parameters for query optimization.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client'
import { withAccelerate } from '@prisma/extension-accelerate'

// 1. Extend your Prisma Client with the Accelerate extension
const prisma = new PrismaClient().$extends(withAccelerate())

// 2. (Optionally) add cache to your Prisma queries
const users = await prisma.user.findMany({
  cacheStrategy: { 
    ttl: 30, // Consider data fresh for 30 seconds
    swr: 60  // Serve stale data for up to 60 seconds while fetching fresh data
  }
})

----------------------------------------

TITLE: Setting Up Prisma Client with PG Driver Adapter
DESCRIPTION: This TypeScript snippet demonstrates how to set up Prisma Client using the PG driver adapter. It creates a new database pool, initializes the adapter, and creates a PrismaClient instance with the adapter.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client'
import { PrismaPg } from '@prisma/adapter-pg'
import { Pool } from 'pg'

const pool = new Pool({ connectionString: env.DATABASE_URL })
const adapter = new PrismaPg(pool)
const prisma = new PrismaClient({ adapter })

----------------------------------------

TITLE: Configuring All Log Levels for Stdout in Prisma Client (TypeScript)
DESCRIPTION: This snippet demonstrates how to configure Prisma Client to log all levels (query, info, warn, error) to stdout using an array of LogLevel objects.

LANGUAGE: typescript
CODE:
const prisma = new PrismaClient({
  log: ['query', 'info', 'warn', 'error'],
})

----------------------------------------

TITLE: Defining Optional One-to-one Relation in Prisma Schema
DESCRIPTION: This snippet demonstrates how to define an optional one-to-one relation between User and Profile models in a Prisma schema. The relation is optional on both sides, allowing a User to exist without a Profile.

LANGUAGE: prisma
CODE:
model User {
  id        Int      @id @default(autoincrement())
  profile   Profile? @relation(fields: [profileId], references: [id]) // references `id` of `Profile`
  profileId Int?     @unique // relation scalar field (used in the `@relation` attribute above)
}

model Profile {
  id   Int   @id @default(autoincrement())
  user User?
}

----------------------------------------

TITLE: JavaScript User Class Definition
DESCRIPTION: ES6 class definition for representing User model in JavaScript application code.

LANGUAGE: javascript
CODE:
class User {
  constructor(user_id, name, email, isAdmin) {
    this.user_id = user_id
    this.name = name
    this.email = email
    this.isAdmin = isAdmin
  }
}

----------------------------------------

TITLE: Initializing Prisma Client in JavaScript
DESCRIPTION: Basic setup code for initializing a Prisma Client instance and creating a main function for database operations. Includes error handling and proper connection management.

LANGUAGE: javascript
CODE:
const { PrismaClient } = require('@prisma/client')

const prisma = new PrismaClient()

async function main() {
  // ... you will write your Prisma Client queries here
}

main()
  .then(async () => {
    await prisma.$disconnect()
  })
  .catch(async (e) => {
    console.error(e)
    await prisma.$disconnect()
    process.exit(1)
  })

----------------------------------------

TITLE: Creating Server Component for User Display
DESCRIPTION: Vue server component that fetches and displays user data using Prisma Client

LANGUAGE: html
CODE:
<script setup>
   import { withAccelerate } from "@prisma/extension-accelerate";
   const prisma = usePrismaClient().$extends(withAccelerate());
   const user = await prisma.user.findFirst();
</script>

<template>
  <p>{{ user?.name ?? "No user has been added yet." }}</p>
</template>

----------------------------------------

TITLE: Installing Example Application
DESCRIPTION: Commands to create directory, download example code, and view project structure

LANGUAGE: bash
CODE:
mkdir prisma-on-koyeb
cd prisma-on-koyeb
curl https://github.com/koyeb/example-prisma/tarball/main/latest | tar xz  --strip=1

----------------------------------------

TITLE: Installing @prisma/client package using npm
DESCRIPTION: This command installs the @prisma/client package, which is necessary for using Prisma Client in your project.

LANGUAGE: terminal
CODE:
npm install @prisma/client

----------------------------------------

TITLE: Instantiating Prisma Client in JavaScript
DESCRIPTION: This code shows how to import and instantiate Prisma Client in a JavaScript file after generation.

LANGUAGE: javascript
CODE:
const { PrismaClient } = require('@prisma/client')
const prisma = new PrismaClient()
// use `prisma` in your application to read and write data in your DB

----------------------------------------

TITLE: Defining Notes Model Schema in Prisma
DESCRIPTION: Prisma schema definition for a Notes model with basic fields including id, title, and timestamp fields.

LANGUAGE: prisma
CODE:
model Notes {
  id        Int       @id @default(autoincrement())
  title     String
  createdAt DateTime  @default(now())
  updatedAt DateTime? @updatedAt
}

----------------------------------------

TITLE: Creating MySQL Database Schema
DESCRIPTION: SQL commands to create a sample database schema with User, Post, and Profile tables. This schema includes primary keys, foreign keys, and various column types.

LANGUAGE: sql
CODE:
CREATE TABLE User (
  id INTEGER PRIMARY KEY AUTO_INCREMENT NOT NULL,
  name VARCHAR(255),
  email VARCHAR(255) UNIQUE NOT NULL
);

CREATE TABLE Post (
  id INTEGER PRIMARY KEY AUTO_INCREMENT NOT NULL,
  title VARCHAR(255) NOT NULL,
  createdAt TIMESTAMP NOT NULL DEFAULT now(),
  content TEXT,
  published BOOLEAN NOT NULL DEFAULT false,
  authorId INTEGER NOT NULL,
  FOREIGN KEY (authorId) REFERENCES User(id)
);

CREATE TABLE Profile (
  id INTEGER PRIMARY KEY AUTO_INCREMENT NOT NULL,
  bio TEXT,
  userId INTEGER UNIQUE NOT NULL,
  FOREIGN KEY (userId) REFERENCES User(id)
);

----------------------------------------

TITLE: Initializing Read Replicas Extension in TypeScript
DESCRIPTION: Demonstrates how to initialize the read replicas extension by extending a Prisma Client instance. It shows how to configure a single read replica and execute read and write operations.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client'
import { readReplicas } from '@prisma/extension-read-replicas'

const prisma = new PrismaClient().$extends(
  readReplicas({
    url: process.env.DATABASE_URL_REPLICA,
  })
)

// Query is run against the database replica
await prisma.post.findMany()

// Query is run against the primary database
await prisma.post.create({ 
  data: {/** */},
})

----------------------------------------

TITLE: Deploying to Heroku with Git Push in Bash
DESCRIPTION: This command deploys the application to Heroku by pushing the code to the Heroku Git remote.

LANGUAGE: bash
CODE:
git push heroku main

----------------------------------------

TITLE: Creating Migration Directory for Prisma
DESCRIPTION: Creates a directory structure for storing Prisma migrations. The -p flag ensures all necessary parent directories are created.

LANGUAGE: bash
CODE:
mkdir -p prisma/migrations/0_init

----------------------------------------

TITLE: Exporting Generated Prisma Client in TypeScript
DESCRIPTION: This snippet illustrates how the @prisma/client package exports the generated client from its default location.

LANGUAGE: typescript
CODE:
export * from '.prisma/client'

----------------------------------------

TITLE: Creating Generic Shareable Extension
DESCRIPTION: Example of creating a shareable extension using Prisma.defineExtension with generic model methods.

LANGUAGE: typescript
CODE:
export default Prisma.defineExtension({
  name: 'prisma-extension-find-or-create', //Extension name
  model: {
    $allModels: {
      // new method
      findOrCreate(/* args */) {
        /* code for the new method */
        return query(args)
      },
    },
  },
})

----------------------------------------

TITLE: Fetching Single Objects with Prisma ORM and Mongoose in TypeScript
DESCRIPTION: Demonstrates how to fetch a single user object by ID using Prisma ORM and Mongoose. Prisma uses the findUnique method with a where clause, while Mongoose uses the findById method.

LANGUAGE: typescript
CODE:
const user = await prisma.user.findUnique({
  where: {
    id: 1,
  },
})

LANGUAGE: typescript
CODE:
const result = await User.findById(1)

----------------------------------------

TITLE: Basic Environment Variable Definition in .env
DESCRIPTION: Shows the basic syntax for defining an environment variable in a .env file.

LANGUAGE: env
CODE:
MY_VALUE=prisma

----------------------------------------

TITLE: Generating Prisma Schema for SaaS App
DESCRIPTION: Example of a Prisma schema for a SaaS application using PostgreSQL as the provider. It includes User, Organization, and Subscription models with proper relationships, timestamps, and soft-delete fields.

LANGUAGE: prisma
CODE:
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}


model User {
  id            Int           @id @default(autoincrement())
  email         String        @unique
  name          String
  password      String
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  deletedAt     DateTime?
  organization  Organization  @relation(fields: [organizationId], references: [id])
  organizationId Int
  role          UserRole     @default(MEMBER)
}


model Organization {
  id            Int           @id @default(autoincrement())
  name          String
  slug          String        @unique
  subscription  Subscription?
  users         User[]
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  deletedAt     DateTime?
}

model Subscription {
  id              Int           @id @default(autoincrement())
  organization    Organization  @relation(fields: [organizationId], references: [id])
  organizationId  Int          @unique
  plan           SubscriptionPlan
  status         SubscriptionStatus @default(ACTIVE)
  startDate      DateTime
  endDate        DateTime?
  createdAt      DateTime      @default(now())
  updatedAt      DateTime      @updatedAt
  deletedAt      DateTime?
}

enum UserRole {
  ADMIN
  MEMBER
}

enum SubscriptionPlan {
  FREE
  BASIC
  PREMIUM
  ENTERPRISE
}

enum SubscriptionStatus {
  ACTIVE
  CANCELED
  EXPIRED
  PAST_DUE
}

----------------------------------------

TITLE: Using $runCommandRaw with MongoDB
DESCRIPTION: Execute a raw MongoDB command against the database using $runCommandRaw.

LANGUAGE: typescript
CODE:
prisma.$runCommandRaw({
  insert: "Pets",
  bypassDocumentValidation: true,
  documents: [
    {
      _id: 1,
      name: "Felinecitas",
      type: "Cat",
      breed: "Russian Blue",
      age: 12,
    },
    {
      _id: 1,
      name: "Nao Nao",
      type: "Dog",
      breed: "Chow Chow",
      age: 2,
    },
  ],
});

----------------------------------------

TITLE: Defining Initial Prisma Schema
DESCRIPTION: This snippet shows the initial Prisma schema definition with User, Profile, Post, and Category models. It includes model relationships and field definitions.

LANGUAGE: prisma
CODE:
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id       Int      @id @default(autoincrement())
  name     String
  jobTitle String
  posts    Post[]
  profile  Profile?
}

model Profile {
  id       Int    @id @default(autoincrement())
  biograpy String // Intentional typo!
  userId   Int    @unique
  user     User   @relation(fields: [userId], references: [id])
}

model Post {
  id         Int        @id @default(autoincrement())
  title      String
  published  Boolean    @default(true)
  content    String     @db.VarChar(500)
  authorId   Int
  author     User       @relation(fields: [authorId], references: [id])
  categories Category[]
}

model Category {
  id    Int    @id @default(autoincrement())
  name  String @db.VarChar(50)
  posts Post[]

  @@unique([name])
}

----------------------------------------

TITLE: Generating Migration SQL with Prisma Migrate
DESCRIPTION: This command uses prisma migrate diff to generate a SQL migration script. It compares an empty state to the current schema and saves the result to a file.

LANGUAGE: bash
CODE:
npx prisma migrate diff \
--from-empty \
--to-schema-datamodel prisma/schema.prisma \
--script > prisma/migrations/0_init/migration.sql

----------------------------------------

TITLE: MySQL Connection via Socket
DESCRIPTION: This example shows how to configure a MySQL connection URL to connect via a socket instead of TCP/IP.

LANGUAGE: text
CODE:
mysql://USER:PASSWORD@HOST/DATABASE?socket=/run/mysqld/mysqld.sock

----------------------------------------

TITLE: Enabling Prisma Client Metrics
DESCRIPTION: Shows how to enable the metrics preview feature in the Prisma schema file.

LANGUAGE: prisma
CODE:
generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["metrics"]
}

----------------------------------------

TITLE: Updating Scalar List Operations in Prisma Client
DESCRIPTION: Scalar list values must be arrays in all operations in Prisma ORM 5, including create and findMany queries.

LANGUAGE: javascript
CODE:
prisma.post.create({
  data: {
    tags: ['databases'],
  },
})

prisma.post.findMany({
  where: {
    tags: ['databases'],
  },
})

----------------------------------------

TITLE: Specifying Absolute Path for SQLite Database in Prisma Schema
DESCRIPTION: This snippet shows how to use an absolute file path to specify the location of the SQLite database file in the Prisma schema. This allows targeting files from the root or any other place in the file system.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "sqlite"
  url      = "file:/Users/janedoe/dev.db"
}

----------------------------------------

TITLE: Initializing PrismaClient and Basic Query Structure in TypeScript
DESCRIPTION: Sets up a PrismaClient instance and defines a main function for executing database queries. Includes error handling and proper disconnection from the database.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

async function main() {
  // ... you will write your Prisma Client queries here
}

main()
  .then(async () => {
    await prisma.$disconnect()
  })
  .catch(async (e) => {
    console.error(e)
    await prisma.$disconnect()
    process.exit(1)
  })

----------------------------------------

TITLE: Loading Required Files in AWS SAM
DESCRIPTION: TypeScript code to ensure required Prisma files are bundled correctly in AWS SAM deployments.

LANGUAGE: typescript
CODE:
import schema from './prisma/schema.prisma'
import x from './node_modules/.prisma/client/libquery_engine-rhel-openssl-1.0.x.so.node'

if (process.env.NODE_ENV !== 'production') {
  console.debug(schema, x)
}

----------------------------------------

TITLE: Final Prisma v2 Schema
DESCRIPTION: Complete upgraded Prisma schema with models, enums and relations

LANGUAGE: prisma
CODE:
model User {
  id       String   @id @default(cuid())
  name     String
  email    String?  @unique
  jsonData Json?
  role     Role     @default(CUSTOMER)
  posts    Post[]
  profile  Profile?
}

model Post {
  id        String     @id @default(cuid())
  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt
  title     String
  content   String?
  published Boolean    @default(false)
  authorId  String?
  author    User?      @relation(fields: [authorId], references: [id])
  categories Category[] @relation(references: [id])
}

model Profile {
  id   String  @id @default(cuid())
  bio  String?
  user String? @unique
  owner User?   @relation(fields: [user], references: [id])
}

model Category {
  id    String @id @default(cuid())
  name  String
  posts Post[] @relation(references: [id])
}

enum Role {
  ADMIN
  CUSTOMER
}

----------------------------------------

TITLE: Creating Deno Application with Prisma Client
DESCRIPTION: Implements a Deno server that handles HTTP requests, creates log entries using Prisma Client, and returns the created log as a JSON response. It uses the Prisma Client generated for Deno and Prisma Accelerate.

LANGUAGE: typescript
CODE:
import { serve } from 'https://deno.land/std@0.140.0/http/server.ts'
import { PrismaClient } from './generated/client/deno/edge.ts'

const prisma = new PrismaClient()

async function handler(request: Request) {
  const log = await prisma.log.create({
    data: {
      level: 'Info',
      message: `${request.method} ${request.url}`,
      meta: {
        headers: JSON.stringify(request.headers),
      },
    },
  })
  const body = JSON.stringify(log, null, 2)
  return new Response(body, {
    headers: { 'content-type': 'application/json; charset=utf-8' },
  })
}

serve(handler)

----------------------------------------

TITLE: Using PostgreSQL search operators with Prisma Client
DESCRIPTION: Examples of using PostgreSQL 'and' (&) and 'or' (|) operators in full-text search queries.

LANGUAGE: typescript
CODE:
// All posts that contain the words 'cat' or 'dog'.
const result = await prisma.posts.findMany({
  where: {
    body: {
      search: 'cat | dog',
    },
  },
})

// All drafts that contain the words 'cat' and 'dog'.
const result = await prisma.posts.findMany({
  where: {
    status: 'Draft',
    body: {
      search: 'cat & dog',
    },
  },
})

----------------------------------------

TITLE: TypeORM Database Migration Example
DESCRIPTION: Sample migration class showing how to add a new column in TypeORM using QueryRunner

LANGUAGE: typescript
CODE:
import { MigrationInterface, QueryRunner } from 'typeorm'

export class UserRefactoring1604448000 implements MigrationInterface {
  async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`ALTER TABLE "User" ADD COLUMN "salutation" TEXT`)
  }

  async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`ALTER TABLE "User" DROP COLUMN "salutation"`)
  }
}

----------------------------------------

TITLE: Running Prisma Introspection Command
DESCRIPTION: This command introspects the database using Prisma, reading the DATABASE_URL environment variable and generating a Prisma schema based on the existing database structure.

LANGUAGE: shell
CODE:
npx prisma db pull

----------------------------------------

TITLE: Checking Directory Contents in Bash
DESCRIPTION: This command lists the contents of the current directory to verify the correct files are present after downloading the example code.

LANGUAGE: bash
CODE:
ls -1

----------------------------------------

TITLE: Reset Development Database
DESCRIPTION: Command to reset the development database, undo manual changes, and reapply all migrations. Includes running seed scripts.

LANGUAGE: terminal
CODE:
npx prisma migrate reset

----------------------------------------

TITLE: Setting up PrismaClient instance in GraphQL context
DESCRIPTION: Replaces the Prisma 1 binding instance with a new PrismaClient instance in the GraphQL server context.

LANGUAGE: javascript
CODE:
const { PrismaClient } = require('@prisma/client')

// ...

const server = new GraphQLServer({
  typeDefs: 'src/schema.graphql',
  resolvers,
  context: (req) => ({
    ...req,
    prisma: new PrismaClient(),
  }),
})

----------------------------------------

TITLE: Updating records by compound ID in Prisma Client
DESCRIPTION: This TypeScript snippet demonstrates how to update a record using a compound ID in a Prisma Client query. It uses the update() method to modify a specific Like record.

LANGUAGE: typescript
CODE:
const like = await prisma.like.update({
  where: {
    likeId: {
      userId: 1,
      postId: 1,
    },
  },
  data: {
    postId: 2,
  },
})

----------------------------------------

TITLE: Creating Related Records with Nested Write in Prisma Client
DESCRIPTION: Shows how to create a new User record along with related Post and Profile records using a nested write query. It then fetches all users including their related records using the include option.

LANGUAGE: typescript
CODE:
async function main() {
  await prisma.user.create({
    data: {
      name: 'Alice',
      email: 'alice@prisma.io',
      posts: {
        create: { title: 'Hello World' },
      },
      profile: {
        create: { bio: 'I like turtles' },
      },
    },
  })

  const allUsers = await prisma.user.findMany({
    include: {
      posts: true,
      profile: true,
    },
  })
  console.dir(allUsers, { depth: null })
}

----------------------------------------

TITLE: SQL Migration for Field Rename
DESCRIPTION: Modified SQL migration to rename a column instead of dropping and recreating it.

LANGUAGE: sql
CODE:
ALTER TABLE "Profile"
RENAME COLUMN "biograpy" TO "biography"

LANGUAGE: sql
CODE:
EXEC sp_rename 'dbo.Profile.biograpy', 'biography', 'COLUMN';

----------------------------------------

TITLE: Basic Prisma Schema without Inheritance
DESCRIPTION: Simple Prisma schema showing Video and Article models without inheritance pattern implementation.

LANGUAGE: prisma
CODE:
model Video {
  id       Int    @id
  url      String @unique
  duration Int

  user   User @relation(fields: [userId], references: [id])
  userId Int
}

model Article {
  id   Int    @id
  url  String @unique
  body String

  user   User @relation(fields: [userId], references: [id])
  userId Int
}

model User {
  id       Int       @id
  name     String
  videos   Video[]
  articles Article[]
}

----------------------------------------

TITLE: PrismaClientInitializationError Interface Definition
DESCRIPTION: Interface defining the structure of initialization errors thrown during query engine startup and database connection.

LANGUAGE: typescript
CODE:
interface PrismaClientInitializationError {
  errorCode?: string;
  message: string;
  clientVersion: string;
}

----------------------------------------

TITLE: Configuring Database Connection Pool Timeout in ENV
DESCRIPTION: Example of setting connection pool timeout in the database connection string. The pool_timeout parameter specifies maximum seconds a query will wait for a connection.

LANGUAGE: env
CODE:
postgresql://user:password@localhost:5432/db?connection_limit=10&pool_timeout=20

----------------------------------------

TITLE: Creating SQL Table Definition
DESCRIPTION: SQL command to create a users table with primary key, name, email, and admin status fields. Demonstrates basic table structure with constraints.

LANGUAGE: sql
CODE:
CREATE TABLE users (
  user_id SERIAL PRIMARY KEY NOT NULL,
  name VARCHAR(255),
  email VARCHAR(255) UNIQUE NOT NULL,
  isAdmin BOOLEAN NOT NULL DEFAULT false
);

----------------------------------------

TITLE: Importing Components in React/JSX
DESCRIPTION: React component imports for the Prisma Optimize documentation page UI elements, including various custom components like LinkCard, List, and IconTitle.

LANGUAGE: jsx
CODE:
import {
  Bolt,
  BorderBox,
  BoxTitle,
  Database,
  Grid,
  LinkCard,
  List,
  SignalStream,
  SquareLogo,
} from '@site/src/components/GettingStarted';

import {
    IconTitle
} from '@site/src/components/shortcodes/index';

----------------------------------------

TITLE: Configuring OpenTelemetry Tracing with SDK-Node
DESCRIPTION: This snippet shows how to set up OpenTelemetry tracing using @opentelemetry/sdk-node, which offers a simpler configuration for quick integration with OTLP-compatible backends.

LANGUAGE: typescript
CODE:
import { OTLPTraceExporter } from '@opentelemetry/exporter-trace-otlp-proto'
import { NodeSDK } from '@opentelemetry/sdk-node'
import { PrismaInstrumentation } from '@prisma/instrumentation'

const traceExporter = new OTLPTraceExporter({
  url: 'https://api.honeycomb.io/v1/traces',
  headers: {
    'x-honeycomb-team': 'HONEYCOMB_API_KEY',
  },
})

const sdk = new NodeSDK({
  serviceName: 'my-service-name',
  traceExporter,
  instrumentations: [
    new PrismaInstrumentation({
      middleware: true,
    }),
  ],
})

sdk.start()

process.on('SIGTERM', async () => {
  try {
    await sdk.shutdown()
    console.log('Tracing shut down successfully')
  } catch (err) {
    console.error('Error shutting down tracing', err)
  } finally {
    process.exit(0)
  }
})

----------------------------------------

TITLE: Prisma Schema with Default Values
DESCRIPTION: Prisma schema representation of a table with default values specified.

LANGUAGE: prisma
CODE:
model cats {
  id   Int     @id @default(autoincrement())
  name String? @default("musti")
}

----------------------------------------

TITLE: Using Prisma.skip Instead of Undefined
DESCRIPTION: Example showing how to use Prisma.skip to omit fields in queries instead of undefined with strictUndefinedChecks enabled.

LANGUAGE: typescript
CODE:
prisma.user.create({
  data: {
    name: 'Alice',
    email: Prisma.skip // This field will be omitted from the query
  }
})

----------------------------------------

TITLE: SQLite Case-Insensitive Migration
DESCRIPTION: SQL migration script to add case-insensitive collation to a SQLite table.

LANGUAGE: sql
CODE:
ALTER TABLE "User" RENAME TO "User_old";

CREATE TABLE "User" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "email" TEXT NOT NULL COLLATE NOCASE
);

INSERT INTO "User" (id, email)
SELECT id, email FROM "User_old";

DROP TABLE "User_old";

----------------------------------------

TITLE: Correcting cyclic relation in Prisma by setting onUpdate to NoAction
DESCRIPTION: This updated Prisma schema resolves the cyclic relation issue by setting onUpdate to NoAction in one of the relations (Chicken.egg in this example).

LANGUAGE: prisma
CODE:
model Chicken {
  id        Int   @id @default(autoincrement())
  egg       Egg   @relation(fields: [eggId], references: [id], onUpdate: NoAction)
  eggId     Int
  predators Fox[]
}

----------------------------------------

TITLE: Querying Multiple Posts with Prisma Client 2 in Express Route Handler
DESCRIPTION: Update the GET /feed route to use Prisma Client 2's findMany method for retrieving all published posts.

LANGUAGE: typescript
CODE:
app.get('/feed', async (req, res) => {
  const posts = await prisma.post.findMany({ where: { published: true } })
  res.json(posts)
})

----------------------------------------

TITLE: Relation Table SQL Creation
DESCRIPTION: SQL statements to create the underlying tables and constraints for an explicit many-to-many relation.

LANGUAGE: sql
CODE:
CREATE TABLE "Post" (
    "id" SERIAL NOT NULL,
    "title" TEXT NOT NULL,
    CONSTRAINT "Post_pkey" PRIMARY KEY ("id")
);

CREATE TABLE "Category" (
    "id" SERIAL NOT NULL,
    "name" TEXT NOT NULL,
    CONSTRAINT "Category_pkey" PRIMARY KEY ("id")
);

CREATE TABLE "CategoriesOnPosts" (
    "postId" INTEGER NOT NULL,
    "categoryId" INTEGER NOT NULL,
    "assignedAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT "CategoriesOnPosts_pkey" PRIMARY KEY ("postId","categoryId")
);

----------------------------------------

TITLE: Executing Repeated Query on Post Model in Prisma
DESCRIPTION: This snippet demonstrates a repeated query on the Post model in Prisma. The query retrieves up to 20 published posts. When executed multiple times with identical parameters, it can lead to performance issues.

LANGUAGE: typescript
CODE:
await prisma.post.findMany({
  where: {
    published: true
  },
  take: 20
})

----------------------------------------

TITLE: Database Introspection Command
DESCRIPTION: Terminal command to pull and synchronize the database schema with the Prisma schema using introspection.

LANGUAGE: terminal
CODE:
prisma db pull

----------------------------------------

TITLE: Defining Prisma schema with MongoDB models
DESCRIPTION: Shows the Prisma schema after introspection, including models for categories, posts, and users.

LANGUAGE: prisma
CODE:
type UsersProfile {
  bio String
}

model categories {
  id   String @id @default(auto()) @map("_id") @db.ObjectId
  v    Int    @map("__v")
  name String
}

model posts {
  id         String   @id @default(auto()) @map("_id") @db.ObjectId
  v          Int      @map("__v")
  author     String   @db.ObjectId
  categories String[] @db.ObjectId
  content    String
  published  Boolean
  title      String
}

model users {
  id      String        @id @default(auto()) @map("_id") @db.ObjectId
  v       Int           @map("__v")
  email   String        @unique(map: "email_1")
  name    String
  profile UsersProfile?
}

----------------------------------------

TITLE: Alternative Selector Pattern with Prisma.validator
DESCRIPTION: Shows how to use Prisma.validator with a selector pattern using an existing Prisma Client instance.

LANGUAGE: typescript
CODE:
import { Prisma } from '@prisma/client'
import prisma from './lib/prisma'

const userEmail = Prisma.validator(
  prisma,
  'user',
  'findUnique',
  'select'
)({
  email: true,
})

----------------------------------------

TITLE: Using Prisma PromiseReturnType
DESCRIPTION: Simplified approach to extracting return types using Prisma's built-in PromiseReturnType utility.

LANGUAGE: typescript
CODE:
import { Prisma } from '@prisma/client'

type UsersWithPosts = Prisma.PromiseReturnType<typeof getUsersWithPosts>

----------------------------------------

TITLE: Creating Demo SQL Schema for CockroachDB
DESCRIPTION: This SQL snippet creates three tables: User, Post, and Profile. It defines primary keys, foreign key relationships, and various column types and constraints.

LANGUAGE: sql
CODE:
CREATE TABLE "User" (
  id INT8 PRIMARY KEY DEFAULT unique_rowid(),
  name STRING(255),
  email STRING(255) UNIQUE NOT NULL
);

CREATE TABLE "Post" (
  id INT8 PRIMARY KEY DEFAULT unique_rowid(),
  title STRING(255) UNIQUE NOT NULL,
  "createdAt" TIMESTAMP NOT NULL DEFAULT now(),
  content STRING,
  published BOOLEAN NOT NULL DEFAULT false,
  "authorId" INT8 NOT NULL,
  FOREIGN KEY ("authorId") REFERENCES "User"(id)
);

CREATE TABLE "Profile" (
  id INT8 PRIMARY KEY DEFAULT unique_rowid(),
  bio STRING,
  "userId" INT8 UNIQUE NOT NULL,
  FOREIGN KEY ("userId") REFERENCES "User"(id)
);

----------------------------------------

TITLE: Execute Down Migration Commands
DESCRIPTION: Commands to execute the down migration SQL and mark the migration as rolled back.

LANGUAGE: bash
CODE:
npx prisma db execute --file ./down.sql --schema prisma/schema.prisma
npx prisma migrate resolve --rolled-back add_profile

----------------------------------------

TITLE: Creating a Post and Connecting to a User with Prisma Client in JavaScript
DESCRIPTION: This code shows how to create a new Post record and connect it to an existing User record using Prisma Client.

LANGUAGE: javascript
CODE:
const post = await prisma.post.create({
  data: {
    title: 'Join us for Prisma Day 2020',
    slug: 'prisma-day-2020',
    body: 'A conference on modern application development and databases.',
    user: {
      connect: { email: 'hello@prisma.com' },
    },
  },
})

----------------------------------------

TITLE: Configuring Prisma Client for Turso Connection
DESCRIPTION: Sets up Prisma Client to connect to a Turso database using the libSQL adapter. It includes creating a libSQL client and configuring Prisma to use it.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client'
import { PrismaLibSQL } from '@prisma/adapter-libsql'
import { createClient } from '@libsql/client'

const libsql = createClient({
  url: `${process.env.TURSO_DATABASE_URL}`,
  authToken: `${process.env.TURSO_AUTH_TOKEN}`,
})

const adapter = new PrismaLibSQL(libsql)
const prisma = new PrismaClient({ adapter })

----------------------------------------

TITLE: Querying a Single Post with Prisma Client 2 in Express Route Handler
DESCRIPTION: Update the GET /post/:id route to use Prisma Client 2's findUnique method for retrieving a specific post.

LANGUAGE: typescript
CODE:
app.get(`/post/:id`, async (req, res) => {
  const { id } = req.params
  const post = await prisma.post.findUnique({
    where: { id },
  })
  res.json(post)
})

----------------------------------------

TITLE: SQL One-to-Many Table Creation
DESCRIPTION: SQL commands to create tables representing a one-to-many relation between User and Post, including foreign key constraint definition.

LANGUAGE: sql
CODE:
CREATE TABLE "User" (
    id SERIAL PRIMARY KEY
);
CREATE TABLE "Post" (
    id SERIAL PRIMARY KEY,
    "authorId" integer NOT NULL,
    FOREIGN KEY ("authorId") REFERENCES "User"(id)
);

----------------------------------------

TITLE: Creating Project Directory for Prisma TypeScript Setup
DESCRIPTION: Commands to create a new project directory and navigate into it for setting up a Prisma TypeScript project.

LANGUAGE: bash
CODE:
mkdir hello-prisma
cd hello-prisma

----------------------------------------

TITLE: Querying Self-Relations in Prisma with TypeScript
DESCRIPTION: Example of querying a self-relation model to retrieve related records. Shows how to include related fields in the query results.

LANGUAGE: typescript
CODE:
const getAnimals = await prisma.animal.findMany({
  where: {
    name: 'Salmon',
  },
  include: {
    b_eats: true,
    a_eatenBy: true,
  },
})

----------------------------------------

TITLE: Updating Objects with Prisma ORM and Mongoose in TypeScript
DESCRIPTION: Demonstrates how to update user objects. Prisma uses the update method with data and where clauses, while Mongoose offers findOneAndUpdate or direct property assignment with save.

LANGUAGE: typescript
CODE:
const user = await prisma.user.update({
  data: {
    name: 'Alicia',
  },
  where: {
    id: 2,
  },
})

LANGUAGE: typescript
CODE:
const updatedUser = await User.findOneAndUpdate(
  { _id: 2 },
  {
    $set: {
      name: 'Alicia',
    },
  }
)

LANGUAGE: typescript
CODE:
user.name = 'Alicia'
await user.save()

----------------------------------------

TITLE: Monitoring Connection Pool Metrics in Prisma
DESCRIPTION: Example of using Prisma Client metrics to monitor connection pool status and usage.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

async function main() {
  await Promise.all([prisma.user.findMany(), prisma.post.findMany()])

  const metrics = await prisma.$metrics.json()
  console.dir(metrics, { depth: Infinity })
}

main()

----------------------------------------

TITLE: ESLint Configuration for SafeQL
DESCRIPTION: ESLint configuration file that sets up SafeQL plugin and rules for SQL query linting.

LANGUAGE: javascript
CODE:
require('dotenv').config()

/** @type {import('eslint').Linter.Config} */
module.exports = {
  plugins: ['@ts-safeql/eslint-plugin'],
  parserOptions: {
    project: './tsconfig.json',
  },
  rules: {
    '@ts-safeql/check-sql': [
      'error',
      {
        connections: [
          {
            connectionUrl: process.env.DATABASE_URL,
            migrationsDir: './prisma/migrations',
            targets: [
              { tag: 'prisma.+($queryRaw|$executeRaw)', transform: '{type}[]' },
            ],
          },
        ],
      },
    ],
  },
}

----------------------------------------

TITLE: Defining Post Model with Prisma Schema
DESCRIPTION: Prisma schema definition for a Post model with fields for likes and comments counts.

LANGUAGE: prisma
CODE:
model Post {
  id            Int      @id @default(autoincrement())
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
  title         String
  content       String?
  published     Boolean  @default(false)
  author        User     @relation(fields: [authorId], references: [id])
  authorId      Int
  likesCount    Int
  commentsCount Int
}

----------------------------------------

TITLE: PgBouncer Error Example
DESCRIPTION: Example of error message when using Prisma Migrate with PgBouncer connection pooling.

LANGUAGE: bash
CODE:
Error: undefined: Database error
Error querying the database: db error: ERROR: prepared statement "s0" already exists

----------------------------------------

TITLE: Generating Baseline Migration
DESCRIPTION: Terminal commands to create and generate a baseline migration for existing databases using prisma migrate diff.

LANGUAGE: terminal
CODE:
mkdir -p prisma/migrations/0_init

npx prisma migrate diff \
--from-empty \
--to-schema-datamodel prisma/schema.prisma \
--script > prisma/migrations/0_init/migration.sql

----------------------------------------

TITLE: Environment Variables Configuration
DESCRIPTION: Example of environment variable configuration for database connection in a .env file.

LANGUAGE: bash
CODE:
# Connect to DB
DATABASE_URL="postgresql://postgres:__PASSWORD__@__HOST__:__PORT__/__DB_NAME__"

----------------------------------------

TITLE: Configuring Prisma Schema for SQL Server Connection
DESCRIPTION: Defines the database connection configuration in the Prisma schema file. Specifies SQL Server as the provider and uses an environment variable for the connection URL.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "sqlserver"
  url      = env("DATABASE_URL")
}

----------------------------------------

TITLE: Marking Migration as Applied
DESCRIPTION: Command to mark a migration as already applied without executing it, used after manual production changes

LANGUAGE: bash
CODE:
prisma migrate resolve --applied "20201127134938-retroactively-add-index"

----------------------------------------

TITLE: Adding Comments to Posts with Update Query
DESCRIPTION: Demonstrates how to update an existing Post record by adding multiple comments using createMany nested write operation and querying the results with included relations.

LANGUAGE: javascript
CODE:
async function main() {
  await prisma.post.update({
    where: {
      slug: 'my-first-post',
    },
    data: {
      comments: {
        createMany: {
          data: [
            { comment: 'Great post!' },
            { comment: "Can't wait to read more!" },
          ],
        },
      },
    },
  })
  const posts = await prisma.post.findMany({
    include: {
      comments: true,
    },
  })

  console.dir(posts, { depth: Infinity })

----------------------------------------

TITLE: Docker Compose Configuration for Test Database
DESCRIPTION: Docker compose configuration to set up a PostgreSQL database container for integration testing.

LANGUAGE: yaml
CODE:
version: '3.9'

services:
  db:
    image: postgres:13
    restart: always
    container_name: integration-tests-prisma
    ports:
      - '5433:5432'
    environment:
      POSTGRES_USER: prisma
      POSTGRES_PASSWORD: prisma
      POSTGRES_DB: tests

----------------------------------------

TITLE: Initializing a Prisma Project with SQLite
DESCRIPTION: Initializes a new Prisma project with a SQLite database using the prisma init command.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "sqlite"
  url      = "file:my-database.db"
}

----------------------------------------

TITLE: Removing jsonProtocol Preview Feature in Prisma Schema
DESCRIPTION: In Prisma ORM 5, the jsonProtocol is the default and only protocol, so the Preview Feature is no longer needed in the schema.

LANGUAGE: prisma
CODE:
generator client {
  provider = "prisma-client-js"
}

----------------------------------------

TITLE: Data Migration Script
DESCRIPTION: TypeScript script using Prisma Client to migrate existing data from implicit to explicit relation table.

LANGUAGE: typescript
CODE:
import { PrismaClient } from "@prisma/client";

const prisma = new PrismaClient();

async function main() {
  try {
    const users = await prisma.user.findMany({
      include: { posts: true },
    });

    for (const user of users) {
      for (const post of user.posts) {
        await prisma.userPost.create({
          data: {
            userId: user.id,
            postId: post.id,
          },
        });
      }
    }

    console.log("Data migration completed.");
  } catch (e) {
    console.error(e);
  }
}

main()
  .catch((e) => {
    throw e;
  })
  .finally(async () => {
    await prisma.$disconnect();
  });

----------------------------------------

TITLE: Instantiating PrismaClient in JavaScript
DESCRIPTION: Demonstrates how to require and instantiate PrismaClient using CommonJS syntax in JavaScript. This approach is suitable for JavaScript projects not using TypeScript.

LANGUAGE: javascript
CODE:
const { PrismaClient } = require('@prisma/client')

const prisma = new PrismaClient()

----------------------------------------

TITLE: TypeScript Type Definitions for MTI
DESCRIPTION: TypeScript type definitions and mapping functions for multi-table inheritance pattern.

LANGUAGE: typescript
CODE:
import { Prisma, Video as VideoDB, Activity } from '@prisma/client'

type Video = Omit<VideoDB & Activity, 'type'>

const videoWithActivity = Prisma.validator<Prisma.VideoDefaultArgs>()({ include: { activity: true } })
type VideoWithActivity = Prisma.VideoGetPayload<typeof videoWithActivity>

function toVideo(a: VideoWithActivity): Video {
  return {
    id: a.id,
    url: a.activity.url,
    ownerId: a.activity.ownerId,
    duration: a.duration,
    activityId: a.activity.id,
  }
}

----------------------------------------

TITLE: SST Prisma Client Configuration
DESCRIPTION: TypeScript code for setting up PrismaClient with SST Config for secure environment variable handling.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client'
import { Config } from 'sst/node/config'

const globalForPrisma = global as unknown as { prisma: PrismaClient }

export const prisma =
  globalForPrisma.prisma ||
  new PrismaClient({
    datasourceUrl: Config.DATABASE_URL,
  })

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma

export default prisma

----------------------------------------

TITLE: Argument Type Definitions
DESCRIPTION: Example of defining argument types in SQL files using TypedSQL comments

LANGUAGE: sql
CODE:
-- @param {Int} $1:minAge
-- @param {Int} $2:maxAge
SELECT id, name, age
FROM users
WHERE age > $1 AND age < $2

----------------------------------------

TITLE: Prisma Client Extension for Geographic Data
DESCRIPTION: TypeScript implementation of Prisma Client extensions for handling geographic data operations with type safety.

LANGUAGE: typescript
CODE:
const prisma = new PrismaClient().$extends({
  model: {
    pointOfInterest: {
      async create(data: {
        name: string
        latitude: number
        longitude: number
      }) {
        const poi: MyPointOfInterest = {
          name: data.name,
          location: {
            latitude: data.latitude,
            longitude: data.longitude,
          },
        }
        const point = `POINT(${poi.location.longitude} ${poi.location.latitude})`
        await prisma.$queryRaw`
          INSERT INTO "PointOfInterest" (name, location) VALUES (${poi.name}, ST_GeomFromText(${point}, 4326));
        `
        return poi
      },
      async findClosestPoints(latitude: number, longitude: number) {
        const result = await prisma.$queryRaw<{
          id: number | null
          name: string | null
          st_x: number | null
          st_y: number | null
        }[]>`SELECT id, name, ST_X(location::geometry), ST_Y(location::geometry) 
            FROM "PointOfInterest" 
            ORDER BY ST_DistanceSphere(location::geometry, ST_MakePoint(${longitude}, ${latitude})) DESC`
        const pois: MyPointOfInterest[] = result.map((data) => ({
          name: data.name,
          location: {
            latitude: data.st_x || 0,
            longitude: data.st_y || 0,
          },
        }))
        return pois
      },
    },
  },
})

----------------------------------------

TITLE: Creating Posts with Explicit Relations in Prisma
DESCRIPTION: TypeScript example demonstrating how to create a post with tags using explicit many-to-many relations.

LANGUAGE: typescript
CODE:
await prisma.post.create({
  data: {
    title: 'Types of relations',
    tags: {
      create: [
        { tag: { create: { name: 'dev' } } },
        { tag: { create: { name: 'prisma' } } },
      ],
    },
  },
})

----------------------------------------

TITLE: Applying Prisma Schema Changes with Migrate Dev
DESCRIPTION: This command uses Prisma Migrate to create and apply a new migration based on the schema changes. It generates a new SQL migration file, applies it to the database, and regenerates Prisma Client.

LANGUAGE: bash
CODE:
npx prisma migrate dev --name tags-model

----------------------------------------

TITLE: Defining an index in Prisma models
DESCRIPTION: Example of defining a multi-column index in a Prisma model.

LANGUAGE: prisma
CODE:
model Post {
  id      Int     @id @default(autoincrement())
  title   String
  content String?

  @@index([title, content])
}

----------------------------------------

TITLE: Defining One-to-One Self-Relation in Prisma
DESCRIPTION: This snippet demonstrates how to define a one-to-one self-relation in Prisma ORM for both relational databases and MongoDB. It models a user with a successor and predecessor relationship.

LANGUAGE: prisma
CODE:
model User {
  id          Int     @id @default(autoincrement())
  name        String?
  successorId Int?    @unique
  successor   User?   @relation("BlogOwnerHistory", fields: [successorId], references: [id])
  predecessor User?   @relation("BlogOwnerHistory")
}

LANGUAGE: prisma
CODE:
model User {
  id          String  @id @default(auto()) @map("_id") @db.ObjectId
  name        String?
  successorId String? @unique @db.ObjectId
  successor   User?   @relation("BlogOwnerHistory", fields: [successorId], references: [id])
  predecessor User?   @relation("BlogOwnerHistory")
}

----------------------------------------

TITLE: Setting Basic Debug Levels in Unix Environment
DESCRIPTION: Examples of setting different debug namespace levels using the DEBUG environment variable in bash. Shows how to enable engine-level, client-level, or combined debugging output.

LANGUAGE: terminal
CODE:
# enable only `prisma:engine`-level debugging output
export DEBUG="prisma:engine"

# enable only `prisma:client`-level debugging output
export DEBUG="prisma:client"

# enable both `prisma-client`- and `engine`-level debugging output
export DEBUG="prisma:client,prisma:engine"

----------------------------------------

TITLE: Data Migration Script in TypeScript
DESCRIPTION: TypeScript script to migrate existing data from the boolean published field to the new status enum field within a transaction.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

async function main() {
  await prisma.$transaction(async (tx) => {
    const posts = await tx.post.findMany()
    for (const post of posts) {
      await tx.post.update({
        where: { id: post.id },
        data: {
          status: post.published ? 'Published' : 'Unknown',
        },
      })
    }
  })
}

main()
  .catch(async (e) => {
    console.error(e)
    process.exit(1)
  })
  .finally(async () => await prisma.$disconnect())

----------------------------------------

TITLE: PrismaClientValidationError Interface Definition
DESCRIPTION: Interface defining the structure of validation errors thrown when field validation fails during operations.

LANGUAGE: typescript
CODE:
interface PrismaClientValidationError {
  message: string;
  clientVersion: string;
}

----------------------------------------

TITLE: Querying Unindexed Columns in Prisma TypeScript
DESCRIPTION: Example queries demonstrating filtering on unindexed columns using Prisma Client. Shows findFirst and count operations with where clauses filtering on the 'name' column.

LANGUAGE: typescript
CODE:
await prisma.user.findFirst({
   where: {
      name: "Marc"
   }
})

await prisma.user.findFirst({
   where: {
      name: "Jon"
   }
})

await prisma.user.count({
   where: {
      name: "Nikolas"
   }
})

----------------------------------------

TITLE: Creating Related Records with Nested Writes
DESCRIPTION: Shows how to create a User record with related Post and Profile records using Prisma Client's nested write capabilities and include option for returning related data.

LANGUAGE: javascript
CODE:
async function main() {
  await prisma.user.create({
    data: {
      name: 'Alice',
      email: 'alice@prisma.io',
      posts: {
        create: { title: 'Hello World' },
      },
      profile: {
        create: { bio: 'I like turtles' },
      },
    },
  })

  const allUsers = await prisma.user.findMany({
    include: {
      posts: true,
      profile: true,
    },
  })
  console.dir(allUsers, { depth: null })
}

----------------------------------------

TITLE: Applying Modified Migration
DESCRIPTION: Command to apply the customized migration to the database after adding unsupported features.

LANGUAGE: bash
CODE:
npx prisma migrate dev

----------------------------------------

TITLE: Updating a Post Record with Prisma Client in Node.js
DESCRIPTION: This code demonstrates how to update an existing Post record by setting its 'published' field to true and then log the updated post.

LANGUAGE: javascript
CODE:
async function main() {
  const post = await prisma.post.update({
    where: { id: 1 },
    data: { published: true },
  })
  console.log(post)
}

----------------------------------------

TITLE: Enabling Driver Adapters Preview Feature in Prisma Schema
DESCRIPTION: This snippet demonstrates how to enable the 'driverAdapters' preview feature in the Prisma schema file. It also includes the basic datasource configuration for PostgreSQL.

LANGUAGE: prisma
CODE:
generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["driverAdapters"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

----------------------------------------

TITLE: Configuring Prisma datasource for PostgreSQL
DESCRIPTION: This snippet shows the default Prisma schema configuration for PostgreSQL. It demonstrates how to set the datasource provider and use an environment variable for the database URL.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

----------------------------------------

TITLE: Migrating Simple rejectOnNotFound Query
DESCRIPTION: Shows how to convert a basic rejectOnNotFound query to use findFirstOrThrow

LANGUAGE: javascript
CODE:
prisma.user.findFirst({
  where: { name: 'Alice' },
  rejectOnNotFound: true,
})

LANGUAGE: javascript
CODE:
prisma.user.findFirstOrThrow({
  where: { name: 'Alice' },
})

----------------------------------------

TITLE: Basic GraphQL Resolver with Prisma Client
DESCRIPTION: Example of a basic GraphQL resolver without type hints for autocompletion.

LANGUAGE: javascript
CODE:
filterPosts: (parent, args, ctx) => {
  return ctx.prisma.post.findMany({
    where: {
      OR: [
        { title: { contains: args.searchString } },
        { content: { contains: args.searchString } },
      ],
    },
  })
}

----------------------------------------

TITLE: Docker Compose Configuration for PostGIS
DESCRIPTION: Docker Compose configuration for setting up a PostgreSQL database with PostGIS installed.

LANGUAGE: yaml
CODE:
version: '3.6'
services:
  pgDB:
    image: postgis/postgis:13-3.1-alpine
    restart: always
    ports:
      - '5432:5432'
    volumes:
      - db_data:/var/lib/postgresql/data
    environment:
      POSTGRES_PASSWORD: password
      POSTGRES_DB: geoexample
volumes:
  db_data:

----------------------------------------

TITLE: Handling Non-inline Relations in Prisma ORM 2.x+ (MySQL)
DESCRIPTION: This snippet shows how to handle non-inline relations that are recognized as m-n in Prisma ORM 2.x+. It demonstrates migrating the data structure to be compatible with Prisma ORM's 1-n relation.

LANGUAGE: prisma
CODE:
model User {
  id   String @id
  Post Post[]
}

model Post {
  id       String @id
  User     User   @relation(fields: [authorId], references: [id])
  authorId String
}

----------------------------------------

TITLE: Creating SQL Server Docker Container Instance
DESCRIPTION: This command creates and runs a new SQL Server container instance. It sets the EULA acceptance, SA password, and maps the container's port 1433 to the host's port 1433.

LANGUAGE: terminal
CODE:
docker run --name sql_container -e 'ACCEPT_EULA=Y' -e 'SA_PASSWORD=myPassword' -p 1433:1433 -d mcr.microsoft.com/mssql/server:2019-latest

----------------------------------------

TITLE: Working with BigInt Type in Prisma
DESCRIPTION: Shows how to use BigInt type for handling large integers in Prisma Client. Requires Node.js 10.4.0+.

LANGUAGE: typescript
CODE:
import { PrismaClient, Prisma } from '@prisma/client'

const newTypes = await prisma.sample.create({
  data: {
    revenue: BigInt(534543543534),
  },
})

----------------------------------------

TITLE: Deleting a Post with Prisma Client 2 in Express Route Handler
DESCRIPTION: Update the DELETE /post/:id route to use Prisma Client 2's delete method for removing a post.

LANGUAGE: typescript
CODE:
app.delete(`/post/:id`, async (req, res) => {
  const { id } = req.params
  const post = await prisma.post.delete({
    where: { id },
  })
  res.json(post)
})

----------------------------------------

TITLE: Adding a New Model to an Existing Schema in Prisma
DESCRIPTION: This example demonstrates how to add a new Profile model to the base schema in an existing Prisma schema with multiple database schemas.

LANGUAGE: prisma
CODE:
model User {
  id      Int      @id
  orders  Order[]
  profile Profile?

  @@schema("base")
}

model Profile {
  id     Int    @id @default(autoincrement())
  bio    String
  user   User   @relation(fields: [userId], references: [id])
  userId Int    @unique

  @@schema("base")
}

model Order {
  id      Int  @id
  user    User @relation(fields: [id], references: [id])
  user_id Int

  @@schema("transactional")
}

enum Size {
  Small
  Medium
  Large

  @@schema("transactional")
}

----------------------------------------

TITLE: Filtering Posts with Prisma Client API
DESCRIPTION: Demonstrates how to filter Post records that contain a specific string using Prisma Client's findMany method with OR conditions.

LANGUAGE: javascript
CODE:
const filteredPosts = await prisma.post.findMany({
  where: {
    OR: [
      { title: { contains: "hello" },
      { content: { contains: "hello" },
    ],
  },
})

----------------------------------------

TITLE: Generated Prisma Schema After Introspection
DESCRIPTION: The Prisma schema generated after running introspection on the database, showing model definitions with relationships and field types.

LANGUAGE: prisma
CODE:
model Post {
  id        Int      @id @default(autoincrement())
  title     String   @db.VarChar(255)
  createdAt DateTime @default(now()) @db.Timestamp(6)
  content   String?
  published Boolean  @default(false)
  authorId  Int
  User      User     @relation(fields: [authorId], references: [id], onDelete: NoAction, onUpdate: NoAction)
}

model Profile {
  id     Int     @id @default(autoincrement())
  bio    String?
  userId Int     @unique
  User   User    @relation(fields: [userId], references: [id], onDelete: NoAction, onUpdate: NoAction)
}

model User {
  id      Int      @id @default(autoincrement())
  name    String?  @db.VarChar(255)
  email   String   @unique @db.VarChar(255)
  Post    Post[]
  Profile Profile?
}

----------------------------------------

TITLE: Using the @unique attribute
DESCRIPTION: Defines a unique constraint for a field using the @unique attribute.

LANGUAGE: prisma
CODE:
model User {
  email String @unique
  name  String
}

----------------------------------------

TITLE: Updating Records with Nested Relations
DESCRIPTION: Demonstrates how to update existing records and create related records using createMany within an update operation.

LANGUAGE: typescript
CODE:
async function main() {
  await prisma.post.update({
    where: {
      slug: 'my-first-post',
    },
    data: {
      comments: {
        createMany: {
          data: [
            { comment: 'Great post!' },
            { comment: "Can't wait to read more!" },
          ],
        },
      },
    },
  })
  const posts = await prisma.post.findMany({
    include: {
      comments: true,
    },
  })

  console.dir(posts, { depth: Infinity })
}

----------------------------------------

TITLE: Activating PostgreSQL Extensions in Prisma Schema
DESCRIPTION: This snippet shows how to declare and activate PostgreSQL extensions in the Prisma schema file using the 'postgresqlExtensions' preview feature. It enables the pgcrypto extension.

LANGUAGE: prisma
CODE:
generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  extensions = [pgcrypto]
}

----------------------------------------

TITLE: Creating SQL Table for One-to-Many Self-Relation
DESCRIPTION: This SQL snippet shows how to create a table representing a one-to-many self-relation in relational databases. It includes the creation of the User table and the necessary foreign key constraint.

LANGUAGE: sql
CODE:
CREATE TABLE "User" (
    id SERIAL PRIMARY KEY,
    "name" TEXT,
    "teacherId" INTEGER
);

ALTER TABLE "User" ADD CONSTRAINT fk_teacherid_user FOREIGN KEY ("teacherId") REFERENCES "User" (id);

----------------------------------------

TITLE: Installing jest-mock-extended for Prisma Client Mocking
DESCRIPTION: Install the jest-mock-extended package to help with mocking Prisma Client in unit tests.

LANGUAGE: bash
CODE:
npm install jest-mock-extended@2.0.4 --save-dev

----------------------------------------

TITLE: MongoDB User Model Definition
DESCRIPTION: Example of defining a User model with MongoDB-specific ID mapping and optional fields.

LANGUAGE: prisma
CODE:
model User {
  id    String  @id @default(auto()) @map("_id") @db.ObjectId
  email String
  name  String?
}

----------------------------------------

TITLE: Marking Migration as Applied in Prisma Migrate
DESCRIPTION: This command uses prisma migrate resolve to mark the '0_init' migration as already applied, preventing Prisma from attempting to apply it to existing databases.

LANGUAGE: bash
CODE:
npx prisma migrate resolve --applied 0_init

----------------------------------------

TITLE: Creating a User with Prisma Client 2 in Express Route Handler
DESCRIPTION: Update the POST /user route to use Prisma Client 2's create method for creating a new user.

LANGUAGE: typescript
CODE:
app.post(`/user`, async (req, res) => {
  const result = await prisma.user.create({
    data: {
      ...req.body,
    },
  })
  res.json(result)
})

----------------------------------------

TITLE: Extended Schema with Post Model
DESCRIPTION: Modified Prisma schema adding Post model and unique constraint to User name

LANGUAGE: prisma
CODE:
model User {
  id    Int     @id
  name  String  @unique
  email String?
}

model Post {
  id    Int    @id
  title String
}

----------------------------------------

TITLE: Updating Prisma Schema for Neon Connection
DESCRIPTION: Modifies the Prisma schema to use the pooled connection and direct URL for database operations.

LANGUAGE: prisma
CODE:
datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

----------------------------------------

TITLE: Configuring Docker Compose for PostgreSQL
DESCRIPTION: Sets up a Docker Compose configuration for a standalone PostgreSQL database, including network setup and volume persistence.

LANGUAGE: yaml
CODE:
version: '3.7'

services:
  postgres:
    image: postgres:15
    restart: always
    environment:
      - POSTGRES_DB=postgres
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=prisma
    ports:
      - "5432:5432"
    networks:
      - prisma-network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U prisma -d postgres"]
      interval: 5s
      timeout: 2s
      retries: 20
    volumes:
      - postgres_data:/var/lib/postgresql/data
    command: postgres -c listen_addresses='*'
    logging:
      options:
        max-size: "10m"
        max-file: "3"

networks:
  prisma-network:

volumes:
  postgres_data:

----------------------------------------

TITLE: Transactions with Prisma ORM and Sequelize in TypeScript
DESCRIPTION: Demonstrates how to perform transactions. Prisma handles transactions automatically for nested writes, while Sequelize requires explicit transaction management.

LANGUAGE: typescript
CODE:
const user = await prisma.user.create({
  data: {
    email: 'bob.rufus@prisma.io',
    name: 'Bob Rufus',
    Post: {
      create: [
        { title: 'Working at Prisma' },
        { title: 'All about databases' },
      ],
    },
  },
})

LANGUAGE: typescript
CODE:
return sequelize.$transaction(async (t) => {
  const user = await User.create(
    {
      name: 'Alice',
      email: 'alice@prisma,io',
    },
    {
      transaction: t,
    }
  )
  const post1 = await Post.create(
    {
      title: 'Join us for GraphQL Conf in 2019',
    },
    {
      transaction: t,
    }
  )
  const post2 = await Post.create(
    {
      title: 'Subscribe to GraphQL Weekly for GraphQL news',
    },
    {
      transaction: t,
    }
  )
  await user.setPosts([post1, post2])
})

LANGUAGE: typescript
CODE:
return sequelize.$transaction(async (transaction) => {
  try {
    const user = await User.create({
      name: 'Alice',
      email: 'alice@prisma,io',
    })
    const post1 = await Post.create({
      title: 'Join us for GraphQL Conf in 2019',
    })
    const post2 = await Post.create({
      title: 'Subscribe to GraphQL Weekly for GraphQL news',
    })
    await user.setPosts([post1, post2])
  } catch (e) {
    return transaction.rollback()
  }
})

----------------------------------------

TITLE: Using aggregateRaw with MongoDB
DESCRIPTION: Perform aggregation operations on a MongoDB collection using aggregateRaw.

LANGUAGE: typescript
CODE:
const result = await prisma.user.aggregateRaw({
  pipeline: [
    { $match: { status: "registered" } },
    { $group: { _id: "$country", total: { $sum: 1 } } },
  ],
});

----------------------------------------

TITLE: Importing and Instantiating Prisma Client 2 in TypeScript
DESCRIPTION: Import the PrismaClient constructor from @prisma/client and create a new instance for use in the application.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

----------------------------------------

TITLE: Creating User and Post Records with Prisma Client in TypeScript
DESCRIPTION: This snippet shows how to create a new User record with a nested Post using Prisma Client, and then query all Users including their posts.

LANGUAGE: typescript
CODE:
async function main() {
  await prisma.user.create({
    data: {
      name: 'Rich',
      email: 'hello@prisma.com',
      posts: {
        create: {
          title: 'My first post',
          body: 'Lots of really interesting stuff',
          slug: 'my-first-post',
        },
      },
    },
  })

  const allUsers = await prisma.user.findMany({
    include: {
      posts: true,
    },
  })
  console.dir(allUsers, { depth: null })
}

----------------------------------------

TITLE: Defining User and Post Models in Prisma Schema
DESCRIPTION: This Prisma schema defines both User and Post models, including a relation between them. It's used to demonstrate schema evolution in Cloudflare D1.

LANGUAGE: prisma
CODE:
model User {
  id    Int     @id @default(autoincrement())
  email String  @unique
  name  String?
  posts Post[]
}

model Post {
  id       Int    @id @default(autoincrement())
  title    String
  author   User   @relation(fields: [authorId], references: [id])
  authorId Int
}

----------------------------------------

TITLE: Creating Employee table with self-referential foreign key in SQL Server
DESCRIPTION: This SQL snippet creates an Employee table with a self-referential foreign key for the manager-employee relationship. However, this will cause an error in SQL Server due to potential cycles or multiple cascade paths.

LANGUAGE: sql
CODE:
CREATE TABLE [dbo].[Employee] (
  [id] INT NOT NULL IDENTITY(1,1),
  [managerId] INT,
  CONSTRAINT [PK__Employee__id] PRIMARY KEY ([id])
);

ALTER TABLE [dbo].[Employee]
  ADD CONSTRAINT [FK__Employee__managerId]
    FOREIGN KEY ([managerId]) REFERENCES [dbo].[Employee]([id])
    ON DELETE CASCADE ON UPDATE CASCADE;

----------------------------------------

TITLE: MySQL Connection URL Structure
DESCRIPTION: This example demonstrates the structure of a MySQL connection URL, including placeholders for user, password, host, port, and database name.

LANGUAGE: text
CODE:
mysql://USER:PASSWORD@HOST:PORT/DATABASE

----------------------------------------

TITLE: Defining Union Types in TypeScript
DESCRIPTION: Basic TypeScript union type definition for combining Video and Article types.

LANGUAGE: typescript
CODE:
type Activity = Video | Article

----------------------------------------

TITLE: Using the @@unique attribute
DESCRIPTION: Defines a compound unique constraint for multiple fields using the @@unique attribute.

LANGUAGE: prisma
CODE:
model User {
  firstName String
  lastName  String
  email     String  @unique
  isAdmin   Boolean @default(false)

  @@unique([firstName, lastName])
}

----------------------------------------

TITLE: Defining Native Types in Prisma Schema
DESCRIPTION: Example of using native type attributes (@db.VarChar) in a Prisma schema to specify exact database column types for PostgreSQL. Shows relationship between User and Post models with custom varchar lengths.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id    Int    @id @default(autoincrement())
  name  String @db.VarChar(200)
  posts Post[]
}

model Post {
  id        Int     @id @default(autoincrement())
  title     String  @db.VarChar(150)
  published Boolean @default(true)
  authorId  Int
  author    User    @relation(fields: [authorId], references: [id])
}

----------------------------------------

TITLE: Batch Deletes with Prisma ORM and Mongoose in TypeScript
DESCRIPTION: Demonstrates how to perform batch deletions. Prisma uses deleteMany with a where clause containing an 'in' operator, while Mongoose uses deleteMany with a $in operator.

LANGUAGE: typescript
CODE:
const users = await prisma.user.deleteMany({
  where: {
    id: {
      in: [1, 2, 6, 6, 22, 21, 25],
    },
  },
})

LANGUAGE: typescript
CODE:
await User.deleteMany({ id: { $in: [1, 2, 6, 6, 22, 21, 25] } })

----------------------------------------

TITLE: Using Cast Operator with Native Database Function in Prisma
DESCRIPTION: This snippet shows how to use a cast operator (::TEXT) with a native database function in Prisma. The entire function must be surrounded by parentheses when using a cast operator.

LANGUAGE: prisma
CODE:
@default(dbgenerated("(gen_random_uuid()::TEXT)"))

----------------------------------------

TITLE: Setting MongoDB Connection URL in Environment File
DESCRIPTION: This snippet demonstrates how to define the MongoDB connection URL as an environment variable in a .env file. It includes a sample URL for MongoDB Atlas.

LANGUAGE: bash
CODE:
DATABASE_URL="mongodb+srv://test:test@cluster0.ns1yp.mongodb.net/myFirstDatabase"

----------------------------------------

TITLE: Prisma Studio Error Message
DESCRIPTION: Example error message when Prisma Studio encounters caching issues

LANGUAGE: terminal
CODE:
Error in request:  PrismaClientKnownRequestError: Failed to validate the query Error occurred during query validation & transformation

----------------------------------------

TITLE: Basic Generator Configuration in Prisma Schema
DESCRIPTION: Basic configuration of a generator block in Prisma schema that specifies the provider and output directory for generated assets.

LANGUAGE: prisma
CODE:
generator client {
  provider = "prisma-client-js"
  output   = "./generated/prisma-client-js"
}

----------------------------------------

TITLE: Basic Generator Configuration in Prisma Schema
DESCRIPTION: Basic configuration of a generator block in Prisma schema that specifies the provider and output directory for generated assets.

LANGUAGE: prisma
CODE:
generator client {
  provider = "prisma-client-js"
  output   = "./generated/prisma-client-js"
}

----------------------------------------

TITLE: Upgrading Prisma packages using yarn
DESCRIPTION: Command to upgrade prisma and @prisma/client packages to version 5 using yarn.

LANGUAGE: terminal
CODE:
yarn up prisma@5 @prisma/client@5

----------------------------------------

TITLE: Basic Nexus Server Setup with Prisma Plugin
DESCRIPTION: Initial setup for a Nexus GraphQL server with Prisma plugin integration. Defines basic schema structure and context.

LANGUAGE: TypeScript
CODE:
import { queryType, makeSchema } from '@nexus/schema'
import { nexusSchemaPrisma } from 'nexus-plugin-prisma/schema'
import { GraphQLServer } from 'graphql-yoga'
import { createContext } from './context'

const Query = queryType({
  definition(t) {
    t.string('hello', () => {
      return 'Hello Nexus!'
    })
  },
})

export const schema = makeSchema({
  types: [Query],
  plugins: [nexusSchemaPrisma({ experimentalCRUD: true })],
  outputs: {
    schema: __dirname + '/../schema.graphql',
    typegen: __dirname + '/generated/nexus.ts',
  },
  typegenAutoConfig: {
    contextType: 'Context.Context',
    sources: [
      {
        source: '@prisma/client',
        alias: 'prisma',
      },
      {
        source: require.resolve('./context'),
        alias: 'Context',
      },
    ],
  },
})

new GraphQLServer({ schema, context: createContext() }).start(() =>
  console.log(`Server ready at: http://localhost:4000`)
)

----------------------------------------

TITLE: Data Transformation for API Response
DESCRIPTION: TypeScript utility function to transform nested relation data into a simplified format suitable for frontend consumption.

LANGUAGE: typescript
CODE:
const result = posts.map((post) => {
  return { ...post, tags: post.tags.map((tag) => tag.tag) }
})

----------------------------------------

TITLE: Creating a New Database in SQL Server
DESCRIPTION: This SQL command creates a new database named 'quickstart' in the SQL Server instance.

LANGUAGE: sql
CODE:
CREATE DATABASE quickstart
GO

----------------------------------------

TITLE: Representing a View in Prisma Schema (MongoDB)
DESCRIPTION: Define a UserInfo view in the Prisma schema for MongoDB using the 'view' keyword.

LANGUAGE: prisma
CODE:
view UserInfo {
  id    String @id @default(auto()) @map("_id") @db.ObjectId
  email String
  name  String
  bio   String
}

----------------------------------------

TITLE: Schema Without Index in Prisma Mode
DESCRIPTION: Example schema demonstrating a relation without an index when using prisma relation mode

LANGUAGE: prisma
CODE:
datasource db {
  provider     = "mysql"
  url          = env("DATABASE_URL")
  relationMode = "prisma"
}

model User {
  id    Int    @id
  posts Post[]
}

model Post {
  id     Int  @id
  userId Int
  user   User @relation(fields: [userId], references: [id])
}

----------------------------------------

TITLE: Updating Records with Composite Types
DESCRIPTION: Examples of updating records containing composite types using various operations like set, unset, update, and upsert.

LANGUAGE: typescript
CODE:
const order = await prisma.order.update({
  where: {
    id: 'some-object-id',
  },
  data: {
    shippingAddress: {
      update: {
        zip: '41232',
      },
    },
  },
})

----------------------------------------

TITLE: Defining GraphQL Object Types with nexus-plugin-prisma
DESCRIPTION: Demonstrates how to define GraphQL object types using nexus-plugin-prisma with model fields exposed

LANGUAGE: typescript
CODE:
const User = objectType({
  name: 'User',
  definition(t) {
    t.model.id()
    t.model.name()
    t.model.email()
    t.model.jsonData()
    t.model.role()
    t.model.posts({
      pagination: false,
      ordering: false,
      filtering: false,
    })
    t.model.profile()
  },
})

----------------------------------------

TITLE: Creating a Post with Prisma Client 2 in Express Route Handler
DESCRIPTION: Update the POST /post route to use Prisma Client 2's create method for creating a new post with author connection.

LANGUAGE: typescript
CODE:
app.post(`/post`, async (req, res) => {
  const { title, content, authorEmail } = req.body
  const result = await prisma.post.create({
    data: {
      title: title,
      content: content,
      author: { connect: { email: authorEmail } },
    },
  })
  res.json(result)
})

----------------------------------------

TITLE: Defining self-referential Employee model in Prisma
DESCRIPTION: This Prisma schema defines an Employee model with a self-referential relationship. The initial version will cause an error due to default referential actions creating a cycle.

LANGUAGE: prisma
CODE:
model Employee {
  id        Int        @id @default(autoincrement())
  manager   Employee?  @relation(name: "management", fields: [managerId], references: [id])
  managees  Employee[] @relation(name: "management")
  managerId Int?
}

----------------------------------------

TITLE: Defining User Model in Prisma Schema
DESCRIPTION: This snippet shows how to define a User model in the Prisma schema language for use with Cloudflare D1. It includes fields for id, email, and name.

LANGUAGE: prisma
CODE:
model User {
  id    Int     @id @default(autoincrement())
  email String  @unique
  name  String?
}

----------------------------------------

TITLE: RDS Postgres Connection URL Configuration
DESCRIPTION: Database connection string configuration that bypasses strict SSL certificate verification for AWS RDS Postgres connections.

LANGUAGE: bash
CODE:
DATABASE_URL=postgresql://<username>:<password>@<host>/<database>?sslmode=no-verify&schema=public

----------------------------------------

TITLE: Using the @@id attribute
DESCRIPTION: Defines a multi-field ID (composite ID) on a model using the @@id attribute.

LANGUAGE: prisma
CODE:
model User {
  firstName String
  lastName  String
  email     String  @unique
  isAdmin   Boolean @default(false)

  @@id([firstName, lastName])
}

----------------------------------------

TITLE: Pagination with Prisma ORM and Sequelize in TypeScript
DESCRIPTION: Demonstrates cursor-style and offset pagination techniques for both Prisma ORM and Sequelize. Prisma offers built-in methods, while Sequelize uses limit, offset, and operators for similar functionality.

LANGUAGE: typescript
CODE:
const page = await prisma.post.findMany({
  before: {
    id: 242,
  },
  last: 20,
})

LANGUAGE: typescript
CODE:
const cc = await prisma.post.findMany({
  skip: 200,
  first: 20,
})

LANGUAGE: typescript
CODE:
const posts = await Post.findAll({
  limit: 20,
  where: {
    id: {
      [Op.gt]: 242,
    },
  },
})

LANGUAGE: typescript
CODE:
const posts = await Post.findAll({
  offset: 5,
  limit: 10,
})

----------------------------------------

TITLE: PrismaClientRustPanicError Interface Definition
DESCRIPTION: Interface defining the structure of errors thrown when the underlying engine crashes with a non-zero exit code.

LANGUAGE: typescript
CODE:
interface PrismaClientRustPanicError {
  message: string;
  clientVersion: string;
}

----------------------------------------

TITLE: Configuring Prisma datasource for PostgreSQL
DESCRIPTION: This snippet shows the default Prisma schema configuration for a PostgreSQL database. It uses an environment variable for the database URL.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

----------------------------------------

TITLE: Running Prisma Studio via CLI
DESCRIPTION: Command to launch Prisma Studio through the terminal

LANGUAGE: terminal
CODE:
npx prisma studio

----------------------------------------

TITLE: Configuring SQLite Connection in Prisma Schema
DESCRIPTION: Shows how to configure a connection to a SQLite database file in Prisma schema. Demonstrates the simple file-based connection format.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "sqlite"
  url      = "file:./dev.db"
}

----------------------------------------

TITLE: Enabling fullTextSearch preview feature for PostgreSQL
DESCRIPTION: Prisma schema configuration to enable the fullTextSearchPostgres preview feature for PostgreSQL in Prisma v6.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["fullTextSearchPostgres"]
}

----------------------------------------

TITLE: CUID Generation Migration Example
DESCRIPTION: Example showing how CUID generation for IDs isn't preserved when migrating from Prisma 1 to Prisma 2+, with workaround to manually add the CUID default.

LANGUAGE: graphql
CODE:
type Post {
  id: ID! @id
}

LANGUAGE: sql
CODE:
CREATE TABLE "Post" (
  id VARCHAR(25) PRIMARY KEY NOT NULL
);

LANGUAGE: prisma
CODE:
model Post {
  id String @id @default(cuid())
}

----------------------------------------

TITLE: Configuring Table of Contents in YAML Front Matter
DESCRIPTION: This snippet shows how to enable the table of contents and set its depth using YAML front matter. It enables the ToC and sets it to display headings up to level 2.

LANGUAGE: yaml
CODE:
toc: true
tocDepth: 2

----------------------------------------

TITLE: Enabling PostgreSQL Extension in Migration SQL
DESCRIPTION: This SQL snippet demonstrates how to enable the pgcrypto extension as part of a migration. It creates the extension if it doesn't exist and adds a UUID column with a default value using gen_random_uuid().

LANGUAGE: sql
CODE:
CREATE EXTENSION IF NOT EXISTS pgcrypto;

ADD COLUMN "id" UUID NOT NULL DEFAULT gen_random_uuid(),
ADD PRIMARY KEY ("id");

----------------------------------------

TITLE: Updating package.json with Prisma Client Generation Script
DESCRIPTION: This snippet shows the complete package.json file with the added postinstall script for generating Prisma Client, along with other project dependencies and scripts.

LANGUAGE: json
CODE:
{
    "name": "next-netlify-platform-starter",
    "version": "0.1.0",
    "private": true,
    "scripts": {
        "dev": "next dev",
        "build": "next build",
        "start": "next start",
        "lint": "next lint",
        // add-next-line
        "postinstall": "prisma generate --no-engine"
    },
    "dependencies": {
        "@netlify/blobs": "^8.1.0",
        "@prisma/client": "^6.3.0",
        "@prisma/extension-accelerate": "^1.2.1",
        "blobshape": "^1.0.0",
        "bright": "^0.8.5",
        "markdown-to-jsx": "^7.4.5",
        "next": "15.1.6",
        "react": "18.3.1",
        "react-dom": "18.3.1",
        "unique-names-generator": "^4.7.1"
    },
    "devDependencies": {
        "autoprefixer": "^10.4.18",
        "daisyui": "^4.12.8",
        "eslint": "8.57.1",
        "eslint-config-next": "15.1.6",
        "postcss": "^8.4.36",
        "prisma": "^6.3.0",
        "tailwindcss": "^3.4.1"
    }
}

----------------------------------------

TITLE: Defining One-to-Many Self-Relation in Prisma
DESCRIPTION: This snippet demonstrates how to define a one-to-many self-relation in Prisma ORM for both relational databases and MongoDB. It models a user with a teacher-student relationship.

LANGUAGE: prisma
CODE:
model User {
  id        Int     @id @default(autoincrement())
  name      String?
  teacherId Int?
  teacher   User?   @relation("TeacherStudents", fields: [teacherId], references: [id])
  students  User[]  @relation("TeacherStudents")
}

LANGUAGE: prisma
CODE:
model User {
  id        String  @id @default(auto()) @map("_id") @db.ObjectId
  name      String?
  teacherId String? @db.ObjectId
  teacher   User?   @relation("TeacherStudents", fields: [teacherId], references: [id])
  students  User[]  @relation("TeacherStudents")
}

----------------------------------------

TITLE: Deleting Records with Composite Types
DESCRIPTION: Shows how to delete records containing composite types using delete and deleteMany methods.

LANGUAGE: typescript
CODE:
const deleteProduct = await prisma.product.deleteMany({
  where: {
    sizes: {
      equals: 'Small',
    },
  },
})

----------------------------------------

TITLE: Handling Default Values in Prisma ORM 2.x+ (MySQL)
DESCRIPTION: This snippet demonstrates how to handle default values that were previously generated by Prisma 1 server at runtime. It shows how to add a DEFAULT constraint to the database column or manually add @default attribute to the Prisma model.

LANGUAGE: prisma
CODE:
model Post {
  id        String  @id
  published Boolean @default(false)
}

----------------------------------------

TITLE: Configuring Prisma Schema for MySQL Database Connection
DESCRIPTION: This snippet shows how to set up the datasource block in the Prisma schema file to connect to a MySQL database. It includes changing the provider from PostgreSQL to MySQL and using an environment variable for the connection URL.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

----------------------------------------

TITLE: Introspected Prisma Schema for CockroachDB
DESCRIPTION: This Prisma schema is the result of introspecting the CockroachDB database. It defines three models: Post, Profile, and User, with their respective fields and relationships.

LANGUAGE: prisma
CODE:
model Post {
  id        BigInt   @id @default(autoincrement())
  title     String   @unique @db.String(255)
  createdAt DateTime @default(now()) @db.Timestamp(6)
  content   String?
  published Boolean  @default(false)
  authorId  BigInt
  User      User     @relation(fields: [authorId], references: [id], onDelete: NoAction, onUpdate: NoAction)
}

model Profile {
  id     BigInt  @id @default(autoincrement())
  bio    String?
  userId BigInt  @unique
  User   User    @relation(fields: [userId], references: [id], onDelete: NoAction, onUpdate: NoAction)
}

model User {
  id      BigInt   @id @default(autoincrement())
  name    String?  @db.String(255)
  email   String   @unique @db.String(255)
  Post    Post[]
  Profile Profile?
}

----------------------------------------

TITLE: Creating One-to-one Relation in SQL
DESCRIPTION: This SQL snippet demonstrates how to create a one-to-one relation between User and Profile tables in a relational database. It shows the creation of tables with primary keys and a foreign key with a UNIQUE constraint.

LANGUAGE: sql
CODE:
CREATE TABLE "User" (
    id SERIAL PRIMARY KEY
);
CREATE TABLE "Profile" (
    id SERIAL PRIMARY KEY,
    "userId" INTEGER NOT NULL UNIQUE,
    FOREIGN KEY ("userId") REFERENCES "User"(id)
);

----------------------------------------

TITLE: Adding full-text indexes in Prisma schema for MySQL
DESCRIPTION: Example of adding full-text indexes to the Blog model in the Prisma schema file for MySQL.

LANGUAGE: prisma
CODE:
generator client {
  provider        = "prisma-client-js"
}

model Blog {
  id      Int    @unique
  content String
  title   String

  @@fulltext([content])
  @@fulltext([content, title])
}

----------------------------------------

TITLE: Adding Prisma Generate to Build Script in package.json
DESCRIPTION: This snippet demonstrates how to prepend prisma generate to the existing build command in package.json. This ensures Prisma Client is generated before the build process starts.

LANGUAGE: json
CODE:
{
  ...
  "scripts" {
    "build": "prisma generate && <actual-build-command>"
  }
  ...
}

----------------------------------------

TITLE: Defining a generator
DESCRIPTION: Specifies the Prisma Client JS generator with default options.

LANGUAGE: prisma
CODE:
generator client {
  provider = "prisma-client-js"
}

----------------------------------------

TITLE: Enabling Views Preview Feature in Prisma Schema
DESCRIPTION: Add the 'views' feature flag to the previewFeatures field of the generator block in the Prisma schema to enable support for views.

LANGUAGE: prisma
CODE:
generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["views"]
}

----------------------------------------

TITLE: Querying Active Users with Active Subscriptions
DESCRIPTION: TypeScript code snippet demonstrating a Prisma query to retrieve all User records associated with an Organization that has an active Subscription, excluding any soft-deleted records.

LANGUAGE: typescript
CODE:
const activeUsers = await prisma.user.findMany({
  where: {
    deletedAt: null,
    organization: {
      deletedAt: null,
      subscription: {
        deletedAt: null,
        status: 'ACTIVE'
      }
    }
  },
  include: {
    organization: {
      include: {
        subscription: true
      }
    }
  },
  orderBy: {
    createdAt: 'desc'
  },
  skip: 0,
  take: 10
});

----------------------------------------

TITLE: Setting Custom Query Engine Library Location
DESCRIPTION: Uses PRISMA_QUERY_ENGINE_LIBRARY to set a custom location for the query engine library file.

LANGUAGE: env
CODE:
PRISMA_QUERY_ENGINE_LIBRARY=custom/libquery_engine-<target>.so.node
# Example: ./prisma/binaries/libquery_engine-linux-arm64-openssl-1.0.x.so.node

----------------------------------------

TITLE: Generated Prisma Schema from Introspection
DESCRIPTION: The Prisma schema generated after introspecting the MongoDB database, showing User and Post models with their fields and types.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model Post {
  id     String @id @default(auto()) @map("_id") @db.ObjectId
  title  String
  userId String @db.ObjectId
}

model User {
  id    String @id @default(auto()) @map("_id") @db.ObjectId
  email String
}

----------------------------------------

TITLE: Initializing Prisma Client in JavaScript
DESCRIPTION: Shows how to import and instantiate Prisma Client in a JavaScript application using require.

LANGUAGE: javascript
CODE:
const { PrismaClient } = require('@prisma/client')

const prisma = new PrismaClient()

----------------------------------------

TITLE: Using Native Database Function with dbgenerated()
DESCRIPTION: Shows how to use PostgreSQL's native gen_random_uuid() function as a default value using the dbgenerated() directive.

LANGUAGE: prisma
CODE:
model User {
  id String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
}

----------------------------------------

TITLE: CockroachDB Cloud connection string example
DESCRIPTION: This snippet shows an example of a connection string for a CockroachDB Serverless or Dedicated database hosted on CockroachDB Cloud. It includes placeholders for user credentials and cluster details.

LANGUAGE: bash
CODE:
DATABASE_URL="postgresql://<myusername>:<mypassword>@<short-id>.<region>.cockroachlabs.cloud:26257/defaultdb?sslmode=verify-full&sslrootcert=$HOME/.postgresql/root.crt&options=--<mycluster>"

----------------------------------------

TITLE: Executing SQL Commands for Schema Compatibility in Prisma Upgrade
DESCRIPTION: This snippet represents the process of running SQL commands generated by the Prisma 1 Upgrade CLI to fix schema incompatibilities when upgrading from Prisma 1 to Prisma ORM 2.x or later. The commands are executed against the database to make it compatible with the newer Prisma versions.

LANGUAGE: SQL
CODE:
-- Example SQL commands generated by Prisma 1 Upgrade CLI
-- These are placeholder commands and will vary based on your specific schema

ALTER TABLE "User" ADD COLUMN "createdAt" TIMESTAMP;
ALTER TABLE "Post" ADD CONSTRAINT "author_unique" UNIQUE ("authorId");
ALTER TABLE "Comment" ALTER COLUMN "content" TYPE JSONB USING "content"::jsonb;

----------------------------------------

TITLE: Setting MySQL Database Connection URL in Environment Variable
DESCRIPTION: This snippet demonstrates how to set the DATABASE_URL environment variable in a .env file. It includes an example of a MySQL connection URL with placeholders for user credentials and database details.

LANGUAGE: bash
CODE:
DATABASE_URL="mysql://johndoe:randompassword@localhost:3306/mydb"

----------------------------------------

TITLE: Generating Initial Migration with Prisma CLI
DESCRIPTION: Prisma CLI command to generate an initial migration SQL script by comparing an empty state to the current schema.

LANGUAGE: bash
CODE:
npx prisma migrate diff --from-empty --to-schema-datamodel prisma/schema.prisma --script > prisma/migrations/0_init/migration.sql

----------------------------------------

TITLE: Prisma Schema After Sanitization
DESCRIPTION: Resulting Prisma schema showing how invalid characters are mapped using @map and @@map attributes

LANGUAGE: prisma
CODE:
model User {
  id      Int     @id @default(autoincrement()) @map("_id")
  name    String? @map("_name")
  two_two Int?    @map("two$two")

  @@map("42User")
}

----------------------------------------

TITLE: Using Prisma UUID Function
DESCRIPTION: Demonstrates how to use Prisma's built-in uuid() function to set a default value for an ID field in a model.

LANGUAGE: prisma
CODE:
model Post {
  id String @id @default(uuid())
}

----------------------------------------

TITLE: Defining unique constraints in Prisma models
DESCRIPTION: Examples of defining single-field and composite unique constraints in Prisma models.

LANGUAGE: prisma
CODE:
model User {
  id    Int     @id @default(autoincrement())
  email String  @unique
  name  String?
}

model Post {
  id         Int        @id @default(autoincrement())
  createdAt  DateTime   @default(now())
  title      String
  published  Boolean    @default(false)
  author     User       @relation(fields: [authorId], references: [id])
  authorId   Int
  categories Category[] @relation(references: [id])

  @@unique([authorId, title])
}

----------------------------------------

TITLE: Upgrading Prisma packages using npm
DESCRIPTION: Commands to upgrade prisma and @prisma/client packages to version 5 using npm.

LANGUAGE: terminal
CODE:
npm install @prisma/client@5
npm install -D prisma@5

----------------------------------------

TITLE: Counting Relations in Prisma
DESCRIPTION: Shows how to count related records using include with _count select parameter.

LANGUAGE: typescript
CODE:
const usersWithCount = await prisma.user.findMany({
  include: {
    _count: {
      select: { posts: true },
    },
  },
})

----------------------------------------

TITLE: Writing Unit Tests with Singleton Pattern
DESCRIPTION: Write unit tests for user creation and update functions using the singleton pattern for Prisma Client mocking.

LANGUAGE: typescript
CODE:
import { createUser, updateUsername } from '../functions-without-context'
import { prismaMock } from '../singleton'

test('should create new user ', async () => {
  const user = {
    id: 1,
    name: 'Rich',
    email: 'hello@prisma.io',
    acceptTermsAndConditions: true,
  }

  prismaMock.user.create.mockResolvedValue(user)

  await expect(createUser(user)).resolves.toEqual({
    id: 1,
    name: 'Rich',
    email: 'hello@prisma.io',
    acceptTermsAndConditions: true,
  })
})

test('should update a users name ', async () => {
  const user = {
    id: 1,
    name: 'Rich Haines',
    email: 'hello@prisma.io',
    acceptTermsAndConditions: true,
  }

  prismaMock.user.update.mockResolvedValue(user)

  await expect(updateUsername(user)).resolves.toEqual({
    id: 1,
    name: 'Rich Haines',
    email: 'hello@prisma.io',
    acceptTermsAndConditions: true,
  })
})

test('should fail if user does not accept terms', async () => {
  const user = {
    id: 1,
    name: 'Rich Haines',
    email: 'hello@prisma.io',
    acceptTermsAndConditions: false,
  }

  prismaMock.user.create.mockImplementation()

  await expect(createUser(user)).resolves.toEqual(
    new Error('User must accept terms!')
  )
})

----------------------------------------

TITLE: Prisma Client Query Setup
DESCRIPTION: Basic TypeScript setup for executing Prisma Client queries with error handling and connection management.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

async function main() {
  // ... you will write your Prisma Client queries here
}

main()
  .then(async () => {
    await prisma.$disconnect()
  })
  .catch(async (e) => {
    console.error(e)
    await prisma.$disconnect()
    process.exit(1)
  })

----------------------------------------

TITLE: Defining Prisma Schema Models for PostgreSQL
DESCRIPTION: This snippet defines three models (Post, Profile, and User) in the Prisma schema. It includes field definitions, relationships, and database-specific attributes for PostgreSQL.

LANGUAGE: prisma
CODE:
model Post {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  title     String   @db.VarChar(255)
  content   String?
  published Boolean  @default(false)
  author    User     @relation(fields: [authorId], references: [id])
  authorId  Int
}

model Profile {
  id     Int     @id @default(autoincrement())
  bio    String?
  user   User    @relation(fields: [userId], references: [id])
  userId Int     @unique
}

model User {
  id      Int      @id @default(autoincrement())
  email   String   @unique
  name    String?
  posts   Post[]
  profile Profile?
}

----------------------------------------

TITLE: Configuring CockroachDB Connection in Prisma Schema
DESCRIPTION: Demonstrates the configuration for connecting to a CockroachDB database in Prisma schema. Uses PostgreSQL connection format with CockroachDB-specific port.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "cockroachdb"
  url      = "postgresql://janedoe:mypassword@localhost:26257/mydb?schema=public"
}

----------------------------------------

TITLE: Testing Prisma Client Reads with MongoDB
DESCRIPTION: TypeScript script to test reading data from MongoDB using the newly generated Prisma Client. This example retrieves and logs all posts from the database.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client'
const prisma = new PrismaClient()

async function main() {
  await prisma.$connect()
  const posts = await prisma.post.findMany()
  console.log(posts)
}

main()
  .catch(console.error)
  .finally(() => prisma.$disconnect())

----------------------------------------

TITLE: Specifying Multi-File Prisma Schema Folder Path (TypeScript)
DESCRIPTION: This snippet demonstrates how to specify a custom folder path for multi-file Prisma schemas in the Prisma Config. It requires the 'prismaSchemaFolder' Preview feature to be enabled and sets the 'kind' property to 'multi'.

LANGUAGE: typescript
CODE:
import path from "node:path";

export default {
  schema: {
    kind: "multi",
    folderPath: path.join("custom", "prisma", "schema"),
  },
};

----------------------------------------

TITLE: Configuring Prisma MongoDB Data Source
DESCRIPTION: Defines the database connection configuration in the Prisma schema file using an environment variable for the connection URL.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

----------------------------------------

TITLE: Configuring Neon Connection with Timeout Parameters
DESCRIPTION: Sets up the DATABASE_URL with connect_timeout and pool_timeout parameters to resolve connection timeout issues.

LANGUAGE: env
CODE:
DATABASE_URL=postgres://daniel:<password>@ep-mute-rain-952417.us-east-2.aws.neon.tech/neondb?connect_timeout=15&pool_timeout=15

----------------------------------------

TITLE: Mapping PostgreSQL Extension Names in Prisma Schema
DESCRIPTION: Use the map argument to represent PostgreSQL extensions with names that are invalid identifiers in the Prisma schema, such as extensions with hyphens.

LANGUAGE: prisma
CODE:
datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  extensions = [uuidOssp(map: "uuid-ossp")]
}

----------------------------------------

TITLE: Example PostgreSQL Connection URL for Local macOS Setup
DESCRIPTION: This snippet shows a typical PostgreSQL connection URL for a local database on macOS, where the user, password, and database name often match the OS user.

LANGUAGE: bash
CODE:
DATABASE_URL="postgresql://janedoe:janedoe@localhost:5432/janedoe?schema=hello-prisma"

----------------------------------------

TITLE: Custom Environment File Loading in TypeScript
DESCRIPTION: Shows how to load environment variables from a custom file using dotenv.

LANGUAGE: typescript
CODE:
import * as dotenv from 'dotenv'

var envFile = path.resolve(join(__dirname, "myenv.env"))
dotenv.config({path: envFile}) // Load the environment variables
console.log(`The connection URL is ${process.env.DATABASE_URL}`)

----------------------------------------

TITLE: Adding Relations to Prisma Schema
DESCRIPTION: Updated Prisma schema with manually added relation fields to establish connections between models. This step is necessary as Prisma doesn't automatically infer relations during introspection.

LANGUAGE: prisma
CODE:
model Post {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime
  title     String   @db.VarChar(255)
  content   String?
  published Boolean  @default(false)
  author    User     @relation(fields: [authorId], references: [id])
  authorId  Int

  @@index([authorId])
}

model Profile {
  id     Int     @id @default(autoincrement())
  bio    String?
  user   User    @relation(fields: [userId], references: [id])
  userId Int     @unique

  @@index([userId])
}

model User {
  id      Int      @id @default(autoincrement())
  email   String   @unique
  name    String?
  posts   Post[]
  profile Profile?
}

----------------------------------------

TITLE: Setting Database Environment Variables
DESCRIPTION: Demonstrates the format of the DATABASE_URL environment variable for PostgreSQL connection, including credentials and connection parameters.

LANGUAGE: bash
CODE:
DATABASE_URL="postgresql://johndoe:randompassword@localhost:5432/mydb?schema=public"

----------------------------------------

TITLE: Creating a Table with Multiple CHECK Constraints in PostgreSQL
DESCRIPTION: This SQL snippet creates a 'secondtolastproduct' table with multiple CHECK constraints. It ensures the reduced price is less than the regular price and that the 'tags' array contains the 'product' tag.

LANGUAGE: sql
CODE:
CREATE TABLE "public"."secondtolastproduct" (
  reducedprice NUMERIC CONSTRAINT reduced_price_check CHECK (price > reducedprice),
  price NUMERIC,
  tags TEXT[] CONSTRAINT tags_contains_product CHECK ('product' = ANY(tags))
);
ALTER TABLE "public"."secondtolastproduct"
  ADD COLUMN "productid" serial,
  ADD PRIMARY KEY ("productid");

----------------------------------------

TITLE: Prisma CLI Output for Schema Location
DESCRIPTION: Displays the terminal output when running a Prisma CLI command, showing how it identifies and loads the schema file location.

LANGUAGE: terminal
CODE:
Environment variables loaded from .env
Prisma Schema loaded from prisma/schema.prisma

Introspecting based on datasource defined in prisma/schema.prisma 

 Introspected 4 models and wrote them into prisma/schema.prisma in 239ms

Run prisma generate to generate Prisma Client.

----------------------------------------

TITLE: Mapping Field Names in Prisma Schema
DESCRIPTION: Demonstrates how to map individual field names to different database column names using the @map attribute.

LANGUAGE: prisma
CODE:
model Comment {
  content String @map("comment_text")
  email   String @map("commenter_email")
  type    Enum   @map("comment_type")

  @@map("comments")
}

----------------------------------------

TITLE: Filtering Json Fields
DESCRIPTION: Example of how to filter records based on JSON field values

LANGUAGE: typescript
CODE:
var json = { [{ name: 'Bob the dog' }, { name: 'Claudine the cat' }] }

const getUsers = await prisma.user.findMany({
  where: {
    extendedPetsData: {
      equals: json,
    },
  },
})

----------------------------------------

TITLE: Creating PostgreSQL database schema
DESCRIPTION: SQL commands to create tables for users, posts, profiles, categories, and post_in_categories with their respective columns and relationships.

LANGUAGE: sql
CODE:
CREATE TABLE users (
	user_id SERIAL PRIMARY KEY NOT NULL,
	name VARCHAR(256),
	email VARCHAR(256) UNIQUE NOT NULL
);
CREATE TABLE posts (
	post_id SERIAL PRIMARY KEY NOT NULL,
	created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
	title VARCHAR(256) NOT NULL,
	content TEXT,
	author_id INTEGER REFERENCES users(user_id)
);
CREATE TABLE profiles (
	profile_id SERIAL PRIMARY KEY NOT NULL,
	bio TEXT,
	user_id INTEGER NOT NULL UNIQUE REFERENCES users(user_id)
);
CREATE TABLE categories (
	category_id SERIAL PRIMARY KEY NOT NULL,
	name VARCHAR(256)
);
CREATE TABLE post_in_categories (
	post_id INTEGER NOT NULL REFERENCES posts(post_id),
	category_id INTEGER NOT NULL REFERENCES categories(category_id)
);
CREATE UNIQUE INDEX post_id_category_id_unique ON post_in_categories(post_id int4_ops,category_id int4_ops);

----------------------------------------

TITLE: Example MySQL Connection URL for AWS RDS
DESCRIPTION: This snippet shows an example of a MySQL connection URL for a database hosted on AWS RDS. It includes placeholders for user credentials and the specific AWS RDS endpoint.

LANGUAGE: bash
CODE:
DATABASE_URL="mysql://johndoe:XXX@mysqlinstance1.123456789012.us-east-1.rds.amazonaws.com:3306/mydb"

----------------------------------------

TITLE: Implementing Time-to-Live (TTL) Caching in Prisma
DESCRIPTION: This snippet demonstrates how to use the TTL caching strategy in Prisma Client. It sets a TTL of 60 seconds for a findMany query on the user model.

LANGUAGE: javascript
CODE:
await prisma.user.findMany({
  cacheStrategy: {
    ttl: 60,
  },
});

----------------------------------------

TITLE: Validating CHECK Constraints with Prisma Client in Node.js
DESCRIPTION: This JavaScript code uses Prisma Client to attempt creating a product with a price that violates the CHECK constraint, demonstrating how the constraint is enforced.

LANGUAGE: javascript
CODE:
const { PrismaClient } = require('@prisma/client')

const prisma = new PrismaClient()

async function main() {
  const newProduct = await prisma.product.create({
    data: {
      price: 0.0,
    },
  })

  console.log(newProduct)
}

main()

----------------------------------------

TITLE: Setting Browser for Prisma Studio
DESCRIPTION: Uses the BROWSER environment variable to specify which browser Prisma Studio should open in.

LANGUAGE: terminal
CODE:
BROWSER=firefox prisma studio --port 5555

----------------------------------------

TITLE: Using the @@map attribute
DESCRIPTION: Maps a model name to a different table name in the database using the @@map attribute.

LANGUAGE: prisma
CODE:
model User {
  id   Int    @id @default(autoincrement())
  name String

  @@map("users")
}

----------------------------------------

TITLE: Implementing User type resolver with Prisma Client
DESCRIPTION: Adds type resolvers for the User type to resolve posts and profile relations using Prisma Client queries.

LANGUAGE: javascript
CODE:
const resolvers = {
  User: {
    posts: (parent, args, context) => {
      return context.prisma.user
        .findUnique({
          where: { id: parent.id },
        })
        .posts()
    },
    profile: (parent, args, context) => {
      return context.prisma.user
        .findUnique({
          where: { id: parent.id },
        })
        .profile()
    },
  },
}

----------------------------------------

TITLE: Creating Prisma v6 upgrade migration
DESCRIPTION: Command to create a new migration for Prisma v6 upgrade, isolating schema changes for relation tables.

LANGUAGE: bash
CODE:
npx prisma migrate dev --name upgrade-to-v6

----------------------------------------

TITLE: Adjusting Prisma Schema for MongoDB
DESCRIPTION: Example of refining the auto-generated Prisma schema to improve the API. This includes renaming models and fields while maintaining proper mapping to the underlying MongoDB collections and field names.

LANGUAGE: typescript
CODE:
- model posts {
+ model Post {
    id        String  @id @default(auto()) @map("_id") @db.ObjectId
    published Boolean
    title     String
+    @@map("posts")
  }

- model users {
+ model User {
    id    String   @id @default(auto()) @map("_id") @db.ObjectId
    email String   @unique(map: "email_U")
    name  String
-    posts String[] @db.ObjectId
+    postIds String[] @db.ObjectId @map("posts")

    @@index([posts], map: "posts_R")
+    @@map("users")
  }

----------------------------------------

TITLE: Defining relation fields in Prisma models
DESCRIPTION: Example of defining relation fields between Prisma models.

LANGUAGE: prisma
CODE:
model Post {
  id       Int       @id @default(autoincrement())
  comments Comment[] // A post can have many comments
}

model Comment {
  id     Int
  post   Post? @relation(fields: [postId], references: [id]) // A comment can have one post
  postId Int?
}

----------------------------------------

TITLE: Inferring Extended Prisma Client Type
DESCRIPTION: Demonstrates how to infer the type of an extended Prisma Client instance using TypeScript's typeof utility.

LANGUAGE: typescript
CODE:
const extendedPrismaClient = new PrismaClient().$extends({
  /** extension */
})

type ExtendedPrismaClient = typeof extendedPrismaClient

----------------------------------------

TITLE: Filtering Records with Composite Types
DESCRIPTION: Examples of using various filtering operations (is, equals, isNot, isSet) to query records containing composite types.

LANGUAGE: typescript
CODE:
const orders = await prisma.order.findMany({
  where: {
    shippingAddress: {
      is: {
        street: '555 Candy Cane Lane',
      },
    },
  },
})

LANGUAGE: typescript
CODE:
const orders = await prisma.order.findMany({
  where: {
    shippingAddress: {
      equals: {
        street: '555 Candy Cane Lane',
        city: 'Wonderland',
        zip: '52337',
      },
    },
  },
})

----------------------------------------

TITLE: Introspecting MongoDB Database with Prisma
DESCRIPTION: Command to pull the structure of the MongoDB database into the Prisma schema file using the 'prisma db pull' command.

LANGUAGE: bash
CODE:
$ npx prisma db pull

----------------------------------------

TITLE: Setting PlanetScale Database Connection URL in Environment File
DESCRIPTION: This snippet demonstrates how to set the DATABASE_URL environment variable in the .env file to connect to a PlanetScale database. It includes the format for the MySQL connection string used by PlanetScale.

LANGUAGE: bash
CODE:
DATABASE_URL="mysql://myusername:mypassword@server.us-east-2.psdb.cloud/mydb?sslaccept=strict"

----------------------------------------

TITLE: Setting Database URL Environment Variable
DESCRIPTION: Command to set the DATABASE_URL environment variable for Prisma Postgres connection.

LANGUAGE: bash
CODE:
export DATABASE_URL="prisma+postgres://accelerate.prisma-data.net/?api_key=eyJhbGciOiJIUzI..."

----------------------------------------

TITLE: Creating a New User with Related Posts
DESCRIPTION: Example of using create() to add a new User record with nested Post records.

LANGUAGE: typescript
CODE:
const user = await prisma.user.create({
  data: {
    email: 'alice@prisma.io',
    posts: {
      create: [
        { title: 'My first post' },
        { title: 'My second post' }
      ]
    }
  }
});

----------------------------------------

TITLE: Querying Across Multiple Database Schemas with Prisma Client
DESCRIPTION: This TypeScript snippet shows how to query models across multiple database schemas using Prisma Client without any changes to the query syntax.

LANGUAGE: typescript
CODE:
const orders = await prisma.order.findMany({
  where: {
    user: {
      id: 1,
    },
  },
})

----------------------------------------

TITLE: Array Parameters in TypedSQL
DESCRIPTION: Example of using array parameters in PostgreSQL queries with TypedSQL

LANGUAGE: sql
CODE:
SELECT id, name, email
FROM users
WHERE id = ANY($1)

----------------------------------------

TITLE: Configuring database connection in .env file
DESCRIPTION: Sets up the DATABASE_URL environment variable for Prisma to connect to the database.

LANGUAGE: env
CODE:
DATABASE_URL="postgresql://USER:PASSWORD@HOST:PORT/DATABASE"

----------------------------------------

TITLE: Defining enums in Prisma schema
DESCRIPTION: Example of defining an enum type in a Prisma schema.

LANGUAGE: prisma
CODE:
model User {
  id    Int     @id @default(autoincrement())
  email String  @unique
  name  String?
  role  Role    @default(USER)
}

enum Role {
  USER
  ADMIN
}

----------------------------------------

TITLE: Configuring Index Sort Order
DESCRIPTION: Example demonstrating how to specify the sort order for index entries using the sort argument.

LANGUAGE: prisma
CODE:
model CompoundUnique {
  unique_1 Int
  unique_2 Int

  @@unique([unique_1(sort: Desc), unique_2])
}

----------------------------------------

TITLE: Defining Models with TypeORM Decorators
DESCRIPTION: Shows how to define User and Post entities using TypeORM decorators in TypeScript, including relation decorators.

LANGUAGE: typescript
CODE:
import { Entity, PrimaryGeneratedColumn, Column, OneToMany, ManyToOne } from 'typeorm'

@Entity()
export class User {
  @PrimaryGeneratedColumn()
  id: number

  @Column({ nullable: true })
  name: string

  @Column({ unique: true })
  email: string

  @OneToMany((type) => Post, (post) => post.author)
  posts: Post[]
}

@Entity()
export class Post {
  @PrimaryGeneratedColumn()
  id: number

  @Column()
  title: string

  @Column({ nullable: true })
  content: string

  @Column({ default: false })
  published: boolean

  @ManyToOne((type) => User, (user) => user.posts)
  author: User
}

----------------------------------------

TITLE: Implementing GraphQL Queries with Prisma Client
DESCRIPTION: Shows how to implement GraphQL queries using the new Prisma Client API within resolvers

LANGUAGE: typescript
CODE:
queryType({
  definition(t) {
    t.list.field('posts', {
      type: 'Post',
      args: {
        searchString: stringArg({ nullable: true }),
      },
      resolve: (parent, { searchString }, context) => {
        return context.prisma.post.findMany({
          where: {
            OR: [
              { title: { contains: searchString } },
              { content: { contains: searchString } },
            ],
          },
        })
      },
    })
  },
})

----------------------------------------

TITLE: Upgrading Prisma packages using pnpm
DESCRIPTION: Command to upgrade prisma and @prisma/client packages to version 5 using pnpm.

LANGUAGE: terminal
CODE:
pnpm upgrade prisma@5 @prisma/client@5

----------------------------------------

TITLE: Generating a Squashed Migration SQL for Production
DESCRIPTION: This command uses 'migrate diff' to create a single migration SQL file that represents the entire schema. It compares an empty database to the current schema and outputs the result to a new migration file.

LANGUAGE: bash
CODE:
npx prisma migrate diff \
 --from-empty \
 --to-schema-datamodel ./prisma/schema.prisma \
 --script > ./prisma/migrations/000000000000_squashed_migrations/migration.sql

----------------------------------------

TITLE: Defining Project Model with Prisma Schema
DESCRIPTION: Prisma schema definition for a Project model with fields for due date and completed date.

LANGUAGE: prisma
CODE:
model Project {
  id            Int      @id @default(autoincrement())
  title         String
  author        User     @relation(fields: [authorId], references: [id])
  authorId      Int
  dueDate       DateTime
  completedDate DateTime
  createdAt     DateTime @default(now())
}

----------------------------------------

TITLE: Creating and Applying Migrations
DESCRIPTION: Creates and applies new migrations based on schema changes using the prisma migrate dev command.

LANGUAGE: terminal
CODE:
prisma migrate dev

----------------------------------------

TITLE: Specifying CLI Binary Targets
DESCRIPTION: Uses PRISMA_CLI_BINARY_TARGETS to specify binary targets for Prisma CLI to download during installation.

LANGUAGE: terminal
CODE:
PRISMA_CLI_BINARY_TARGETS=darwin-arm64,rhel-openssl-3.0.x npm install

----------------------------------------

TITLE: Using TypedSQL Queries in TypeScript
DESCRIPTION: Example of importing and executing a TypedSQL query using Prisma Client

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client'
import { getUsersWithPosts } from '@prisma/client/sql'

const prisma = new PrismaClient()

const usersWithPostCounts = await prisma.$queryRawTyped(getUsersWithPosts())
console.log(usersWithPostCounts)

----------------------------------------

TITLE: TypeScript Error Example - GroupBy Feature
DESCRIPTION: Example of TypeScript errors when attempting to use the groupBy preview feature with an incompatible TypeScript version. Shows both circular reference and argument count errors.

LANGUAGE: typescript
CODE:
server.ts:6:25 - error TS2615: Type of property 'OR' circularly references itself in mapped type '{ [K in keyof { AND?: Enumerable<ProductScalarWhereWithAggregatesInput>; OR?: Enumerable<ProductScalarWhereWithAggregatesInput>; ... 4 more ...; category?: string | StringWithAggregatesFilter; }]: Or<...> extends 1 ? { ...; }[K] extends infer TK ? GetHavingFields<...> : never : {} extends FieldPaths<...> ? never : K...'
6   const grouped = await prisma.product.groupBy({
                          ~~~~~~~~~~~~~~~~~~~~~~~~
7     by: ['category']
  ~~~~~~~~~~~~~~~~~~~~
8   });
  ~~~~
server.ts:6:48 - error TS2554: Expected 0 arguments, but got 1.
6   const grouped = await prisma.product.groupBy({
                                                 ~
7     by: ['category']
  ~~~~~~~~~~~~~~~~~~~~
8   });
  ~~~

----------------------------------------

TITLE: Local MySQL Connection URL Example
DESCRIPTION: Example of a DATABASE_URL environment variable configuration for connecting to a locally hosted MySQL database.

LANGUAGE: bash
CODE:
DATABASE_URL="mysql://root:randompassword@localhost:3306/mydb"

----------------------------------------

TITLE: MySQL Connection URL with SSL Configuration
DESCRIPTION: This example demonstrates a MySQL connection URL with SSL configuration parameters including certificate paths and password.

LANGUAGE: text
CODE:
mysql://USER:PASSWORD@HOST:PORT/DATABASE?sslidentity=client-identity.p12&sslpassword=mypassword&sslcert=rootca.cert

----------------------------------------

TITLE: Configuring Prisma Seed in package.json
DESCRIPTION: Configuration for TypeScript and JavaScript seed scripts in package.json, specifying the seed command path and optional compiler options.

LANGUAGE: json
CODE:
{
  "prisma": {
    "seed": "ts-node prisma/seed.ts"
  }
}

----------------------------------------

TITLE: Configuring Jest for Prisma Client Mocking
DESCRIPTION: Update the Jest configuration to include the setup file for Prisma Client mocking.

LANGUAGE: javascript
CODE:
module.exports = {
  clearMocks: true,
  preset: 'ts-jest',
  testEnvironment: 'node',
  setupFilesAfterEnv: ['<rootDir>/singleton.ts'],
}

----------------------------------------

TITLE: Finding Records with Null Values
DESCRIPTION: Example of using findMany to query for records with null values in specific fields.

LANGUAGE: typescript
CODE:
const users = await prisma.user.findMany({
  where: {
    name: null,
  },
})

----------------------------------------

TITLE: Customized Prisma Schema with Renamed Relations
DESCRIPTION: Modified Prisma schema with renamed relation fields to adhere to Prisma's naming conventions and improve API ergonomics.

LANGUAGE: prisma
CODE:
model Post {
  id        Int      @id @default(autoincrement())
  title     String   @db.VarChar(255)
  createdAt DateTime @default(now()) @db.Timestamp(0)
  content   String?  @db.Text
  published Boolean  @default(false)
  authorId  Int
  author    User     @relation(fields: [authorId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "Post_ibfk_1")

  @@index([authorId], map: "authorId")
}

model Profile {
  id     Int     @id @default(autoincrement())
  bio    String? @db.Text
  userId Int     @unique(map: "userId")
  user   User    @relation(fields: [userId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "Profile_ibfk_1")
}

model User {
  id      Int      @id @default(autoincrement())
  name    String?  @db.VarChar(255)
  email   String   @unique(map: "email") @db.VarChar(255)
  posts   Post[]
  profile Profile?
}

----------------------------------------

TITLE: Using findRaw with MongoDB
DESCRIPTION: Execute a raw find query on a MongoDB collection using findRaw.

LANGUAGE: typescript
CODE:
const result = await prisma.user.findRaw({
  filter: { age: { $gt: 25 } },
  options: { projection: { _id: false } },
});

----------------------------------------

TITLE: Creating SQL Server tables for Post, Profile, and User
DESCRIPTION: This SQL script creates three tables (Post, Profile, User) with their respective columns, primary keys, foreign keys, and constraints in SQL Server.

LANGUAGE: sql
CODE:
CREATE TABLE [dbo].[Post] (
    [id] INT NOT NULL IDENTITY(1,1),
    [createdAt] DATETIME2 NOT NULL CONSTRAINT [Post_createdAt_df] DEFAULT CURRENT_TIMESTAMP,
    [updatedAt] DATETIME2 NOT NULL,
    [title] VARCHAR(255) NOT NULL,
    [content] NVARCHAR(1000),
    [published] BIT NOT NULL CONSTRAINT [Post_published_df] DEFAULT 0,
    [authorId] INT NOT NULL,
    CONSTRAINT [Post_pkey] PRIMARY KEY ([id])
);

CREATE TABLE [dbo].[Profile] (
    [id] INT NOT NULL IDENTITY(1,1),
    [bio] NVARCHAR(1000),
    [userId] INT NOT NULL,
    CONSTRAINT [Profile_pkey] PRIMARY KEY ([id]),
    CONSTRAINT [Profile_userId_key] UNIQUE ([userId])
);

CREATE TABLE [dbo].[User] (
    [id] INT NOT NULL IDENTITY(1,1),
    [email] NVARCHAR(1000) NOT NULL,
    [name] NVARCHAR(1000),
    CONSTRAINT [User_pkey] PRIMARY KEY ([id]),
    CONSTRAINT [User_email_key] UNIQUE ([email])
);

ALTER TABLE [dbo].[Post] ADD CONSTRAINT [Post_authorId_fkey] FOREIGN KEY ([authorId]) REFERENCES [dbo].[User]([id]) ON DELETE NO ACTION ON UPDATE CASCADE;

ALTER TABLE [dbo].[Profile] ADD CONSTRAINT [Profile_userId_fkey] FOREIGN KEY ([userId]) REFERENCES [dbo].[User]([id]) ON DELETE NO ACTION ON UPDATE CASCADE;

----------------------------------------

TITLE: Setting Database Environment Variable
DESCRIPTION: Command to set the DATABASE_URL environment variable for Prisma Postgres connection.

LANGUAGE: bash
CODE:
export DATABASE_URL="prisma+postgres://accelerate.prisma-data.net/?api_key=__API_KEY__"

----------------------------------------

TITLE: Deleting Objects with Prisma ORM and Sequelize in TypeScript
DESCRIPTION: Shows how to delete database objects. Prisma uses the delete method with a where clause, while Sequelize uses the destroy method on the instance.

LANGUAGE: typescript
CODE:
const user = await prisma.user.delete({
  where: {
    id: 10,
  },
})

LANGUAGE: typescript
CODE:
await user.destroy()

----------------------------------------

TITLE: Configuring Neon Connection with Pooling in Environment Variables
DESCRIPTION: Sets up environment variables for connecting to Neon with pooling, including a direct URL for Prisma CLI operations.

LANGUAGE: env
CODE:
# Connect to Neon with Pooling.
DATABASE_URL=postgres://daniel:<password>@ep-mute-rain-952417-pooler.us-east-2.aws.neon.tech:5432/neondb?sslmode=require

# Direct connection to the database used by Prisma CLI for e.g. migrations.
DIRECT_URL="postgres://daniel:<password>@ep-mute-rain-952417.us-east-2.aws.neon.tech/neondb"

----------------------------------------

TITLE: Introspecting database
DESCRIPTION: Use the prisma db pull command to introspect your existing database and generate a Prisma schema.

LANGUAGE: bash
CODE:
npx prisma db pull

----------------------------------------

TITLE: Handling Generated CUIDs as ID Values in Prisma ORM 2.x+ (MySQL)
DESCRIPTION: This snippet shows how to handle auto-generated CUID values for ID fields that were previously managed by Prisma 1 server. It demonstrates adding the @default(cuid()) attribute to the Prisma model.

LANGUAGE: prisma
CODE:
model Post {
  id String @id @default(cuid())
}

----------------------------------------

TITLE: Representing a View in Prisma Schema (Relational Databases)
DESCRIPTION: Define a UserInfo view in the Prisma schema for relational databases using the 'view' keyword.

LANGUAGE: prisma
CODE:
view UserInfo {
  id    Int    @unique
  email String
  name  String
  bio   String
}

----------------------------------------

TITLE: Specifying Schema Location in package.json for Prisma
DESCRIPTION: Shows how to specify a custom location for the Prisma schema file in the package.json configuration. This allows for flexibility in schema placement within the project structure.

LANGUAGE: json
CODE:
"prisma": {
  "schema": "db/schema.prisma"
}

----------------------------------------

TITLE: Pulling Database Schema
DESCRIPTION: Pulls the current database schema and updates the Prisma schema file using the prisma db pull command.

LANGUAGE: terminal
CODE:
prisma db pull

----------------------------------------

TITLE: Specifying Custom Engine Mirror
DESCRIPTION: Sets PRISMA_ENGINES_MIRROR to specify a custom CDN endpoint for downloading Prisma engine files.

LANGUAGE: env
CODE:
PRISMA_ENGINES_MIRROR=https://example.org/custom-engines/

----------------------------------------

TITLE: Preventing read/update of soft deleted records with middleware
DESCRIPTION: Additional middleware to filter out soft deleted records from read queries and prevent updates to deleted records.

LANGUAGE: typescript
CODE:
prisma.$use(async (params, next) => {
  if (params.model == 'Post') {
    if (params.action === 'findUnique' || params.action === 'findFirst') {
      params.action = 'findFirst'
      params.args.where['deleted'] = false
    }
    if (params.action === 'findMany') {
      if (params.args.where) {
        if (params.args.where.deleted == undefined) {
          params.args.where['deleted'] = false
        }
      } else {
        params.args['where'] = { deleted: false }
      }
    }
  }
  return next(params)
})

----------------------------------------

TITLE: Creating Dynamic Prisma Clients for Multi-Tenant Setup
DESCRIPTION: Factory function implementation for creating tenant-specific Prisma Client instances. Allows dynamic database configuration based on tenant requirements.

LANGUAGE: typescript
CODE:
import { PrismaClient } from "@prisma/client";

type TenantConfig = {
  databaseUrl: string;
};

export function createPrismaClient(config: TenantConfig): PrismaClient {
  return new PrismaClient({
    datasources: {
      db: {
        url: config.databaseUrl,
      },
    },
  });
}

----------------------------------------

TITLE: Marking Migration as Applied
DESCRIPTION: Marks the initial migration as applied in the _prisma_migrations table using the prisma migrate resolve command.

LANGUAGE: terminal
CODE:
npx prisma migrate resolve --applied 0_init

----------------------------------------

TITLE: Initial Prisma Schema with Implicit Relations
DESCRIPTION: Base Prisma schema showing User and Post models with implicit many-to-many relationship.

LANGUAGE: prisma
CODE:
model User {
  id        Int       @id @default(autoincrement())
  name      String
  posts     Post[]
}

model Post {
  id        Int       @id @default(autoincrement())
  title     String
  authors   User[]
}

----------------------------------------

TITLE: Enabling Driver Adapters in Prisma Schema
DESCRIPTION: Updates the Prisma schema to enable the driverAdapters preview feature for using Neon's serverless driver.

LANGUAGE: prisma
CODE:
generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["driverAdapters"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

----------------------------------------

TITLE: Raw SQL Seeding Implementation
DESCRIPTION: Example of using raw SQL queries within a seed script to insert data directly into the database.

LANGUAGE: javascript
CODE:
async function rawSql() {
  const result = await prisma.$executeRaw`INSERT INTO \"User\" (\"id\", \"email\", \"name\") VALUES (3, 'foo@example.com', 'Foo') ON CONFLICT DO NOTHING;`
  console.log({ result })
}

----------------------------------------

TITLE: Using omit Query Option with Result Extension in Prisma Client
DESCRIPTION: Illustrates how to use the 'omit' query option with custom fields in Prisma Client extensions. It shows how to omit fields that are dependencies of custom fields and how to completely exclude custom fields from queries.

LANGUAGE: typescript
CODE:
const xprisma = prisma.$extends({
  result: {
    user: {
      sanitizedPassword: {
        needs: { password: true },
        compute(user) {
          return sanitize(user.password)
        },
      },
    },
  },
})

const user = await xprisma.user.findFirstOrThrow({
  omit: {
    sanitizedPassword: true,
    password: true,
  },
})

----------------------------------------

TITLE: Marking Migration as Applied
DESCRIPTION: Marks the initial migration as applied in the Prisma migrations table

LANGUAGE: terminal
CODE:
npx prisma migrate resolve --applied 0_init

----------------------------------------

TITLE: MongoDB Document Example
DESCRIPTION: Sample MongoDB document structure showing ObjectId and other field types.

LANGUAGE: json
CODE:
{
  "_id": { "$oid": "60d599cb001ef98000f2cad2" },
  "createdAt": { "$date": { "$numberLong": "1624611275577" } },
  "email": "ella@prisma.io",
  "name": "Ella",
  "role": "ADMIN"
}

----------------------------------------

TITLE: Basic MongoDB Prisma Schema Configuration
DESCRIPTION: Example of configuring a MongoDB datasource in Prisma schema with environment-based connection URL.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

----------------------------------------

TITLE: Fetching Active Users with Organization Data using Prisma
DESCRIPTION: This snippet shows how to construct a Prisma query to fetch all active users from an organization with an active subscription, including data about the users' organizations.

LANGUAGE: typescript
CODE:
const activeUsers = await prisma.user.findMany({
  where: {
    organization: {
      subscription: {
        status: "ACTIVE"
      }
    }
  },
  include: {
    organization: true
  }
});

----------------------------------------

TITLE: Configuring Scalar List Defaults in Prisma Schema
DESCRIPTION: Example showing how to set default values for scalar lists in Prisma schema for both relational databases and MongoDB. This feature is new in Prisma ORM 4.

LANGUAGE: prisma
CODE:
model User {
  id             Int      @id @default(autoincrement())
  posts          Post[]
  favoriteColors String[] @default(["red", "yellow", "purple"])
}

----------------------------------------

TITLE: Timestamp Migration Example
DESCRIPTION: Example showing how @createdAt and @updatedAt timestamps aren't preserved when migrating from Prisma 1 to Prisma 2+, with SQL workaround to add timestamp defaults.

LANGUAGE: graphql
CODE:
type Post {
  id: ID! @id
  createdAt: DateTime! @createdAt
  updatedAt: DateTime! @updatedAt
}

LANGUAGE: sql
CODE:
CREATE TABLE "Post" (
  id VARCHAR(25) PRIMARY KEY NOT NULL,
  "createdAt" TIMESTAMP NOT NULL,
  "updatedAt" TIMESTAMP
);

LANGUAGE: prisma
CODE:
model Post {
  id        String   @id
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

----------------------------------------

TITLE: Initializing Prisma Project for MongoDB
DESCRIPTION: Terminal commands to create a new project directory, initialize npm, install Prisma as a dev dependency, and initialize Prisma in the project.

LANGUAGE: terminal
CODE:
mkdir blog
cd blog
npm init -y
npm install -D prisma
npx prisma init

----------------------------------------

TITLE: PrismaClientKnownRequestError Interface Definition
DESCRIPTION: Interface defining the structure of known request errors thrown by Prisma Client when the query engine returns an error with a specific error code.

LANGUAGE: typescript
CODE:
interface PrismaClientKnownRequestError {
  code: string;
  meta?: { target: string[] };
  message: string;
  clientVersion: string;
}

----------------------------------------

TITLE: Generating Prisma Client
DESCRIPTION: Generates Prisma Client based on the schema using the prisma generate command.

LANGUAGE: terminal
CODE:
prisma generate

----------------------------------------

TITLE: Customizing TCP Tunnel Host and Port
DESCRIPTION: Command to start the TCP tunnel with custom host and port settings using command line flags.

LANGUAGE: terminal
CODE:
npx @prisma/ppg-tunnel --host 127.0.0.1 --port 5432

----------------------------------------

TITLE: Applying Multiple Extensions to a Prisma Client
DESCRIPTION: Demonstrates how to apply multiple extensions to a Prisma Client instance in a single line of code.

LANGUAGE: typescript
CODE:
// First of all, store your original Prisma Client in a variable as usual
const prisma = new PrismaClient()

// Declare an extended client that has an extensionA and extensionB
const prismaAB = prisma.$extends(extensionA).$extends(extensionB)

----------------------------------------

TITLE: Configuring CockroachDB Datasource in Prisma Schema
DESCRIPTION: Prisma schema configuration for connecting to a CockroachDB database using the cockroachdb provider and an environment variable for the connection URL.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "cockroachdb"
  url      = env("DATABASE_URL")
}

----------------------------------------

TITLE: Using Fluent Relations API
DESCRIPTION: Demonstrates how to use Prisma's fluent relations API to retrieve Post records of a User by traversing relations between Profile, User and Posts.

LANGUAGE: javascript
CODE:
const posts = await prisma.profile
  .findUnique({
    where: { id: 1 },
  })
  .user()
  .posts()

----------------------------------------

TITLE: Managing Projects in Prisma Data Platform
DESCRIPTION: Commands for listing, creating, and deleting projects within a specified workspace in the Prisma Data Platform. Requires workspace ID for creation and project ID for deletion.

LANGUAGE: bash
CODE:
npx prisma platform project show \
--workspace $INSERT_WORKSPACE_ID \
--early-access

LANGUAGE: bash
CODE:
npx prisma platform project create \
--workspace $INSERT_WORKSPACE_ID \
--name "INSERT_PROJECT_NAME" \
--early-access

LANGUAGE: bash
CODE:
npx prisma platform project delete \
--project $INSERT_PROJECT_ID \
--early-access

----------------------------------------

TITLE: Configuring Supabase Connection Pool URL in Environment
DESCRIPTION: Sets up the DATABASE_URL environment variable to connect to Supabase using connection pooling via Supavisor. The connection string includes the pgbouncer parameter for enabling connection pooling.

LANGUAGE: env
CODE:
# Connect to Supabase via connection pooling with Supavisor.
DATABASE_URL="postgres://postgres.[your-supabase-project]:[password]@aws-0-[aws-region].pooler.supabase.com:6543/postgres?pgbouncer=true"

----------------------------------------

TITLE: Bash Script for Alternative Language Seeding
DESCRIPTION: Shell script example for running database seeds using other languages or SQL scripts.

LANGUAGE: bash
CODE:
#!/bin/sh
# -e Exit immediately when a command returns a non-zero status.
# -x Print commands before they are executed
set -ex
# Seeding command
go run ./seed/

----------------------------------------

TITLE: Type Safety with Prisma Type Utilities
DESCRIPTION: Example showing how to use Prisma's type utilities to enforce type safety when creating posts.

LANGUAGE: typescript
CODE:
type PostCreateBody = Prisma.Args<typeof prisma.post, 'create'>['data']

const addPost = async (postBody: PostCreateBody) => {
  const post = await prisma.post.create({ data: postBody })
  return post
}

await addPost(myData)

----------------------------------------

TITLE: Generating SQL Migration for Tag Model and Relations
DESCRIPTION: This SQL migration script creates the 'Tag' table, a junction table '_PostToTag' for the many-to-many relation between 'Post' and 'Tag', and adds the necessary foreign key constraints and indexes.

LANGUAGE: sql
CODE:
-- CreateTable
CREATE TABLE [dbo].[Tag] (
    [id] SERIAL NOT NULL,
    [name] VARCHAR(255) NOT NULL,

    CONSTRAINT [Tag_pkey] PRIMARY KEY ([id])
);

-- CreateTable
CREATE TABLE [dbo].[_PostToTag] (
    [A] INTEGER NOT NULL,
    [B] INTEGER NOT NULL
);

-- CreateIndex
CREATE UNIQUE INDEX [_PostToTag_AB_unique] ON _PostToTag([A], [B]);

-- CreateIndex
CREATE INDEX [_PostToTag_B_index] ON [_PostToTag]([B]);

-- AddForeignKey
ALTER TABLE [dbo].[_PostToTag] ADD CONSTRAINT [_PostToTag_A_fkey] FOREIGN KEY ([A]) REFERENCES [dbo].[Post]([id]) ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE [dbo].[_PostToTag] ADD CONSTRAINT [_PostToTag_B_fkey] FOREIGN KEY ([B]) REFERENCES [dbo].[Tag]([id]) ON DELETE CASCADE ON UPDATE CASCADE;

----------------------------------------

TITLE: Initializing Prisma Project
DESCRIPTION: Command to initialize a new Prisma project by creating the schema file and environment configuration. Creates a prisma directory with schema.prisma file and a .env file in the root directory.

LANGUAGE: terminal
CODE:
npx prisma init

----------------------------------------

TITLE: Downloading Microsoft SQL Server 2019 Docker Image
DESCRIPTION: This command pulls the latest Microsoft SQL Server 2019 image from the Docker registry.

LANGUAGE: terminal
CODE:
docker pull mcr.microsoft.com/mssql/server:2019-latest

----------------------------------------

TITLE: Configuring MongoDB Connection in Prisma Schema
DESCRIPTION: Shows how to set up a connection to a MongoDB database using Prisma schema. Includes MongoDB connection string format with cluster and database specifications.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "mongodb"
  url      = "mongodb+srv://root:<password>@cluster0.ab1cd.mongodb.net/myDatabase?retryWrites=true&w=majority"
}

----------------------------------------

TITLE: Setting Global Environment Variable for Query Engine
DESCRIPTION: Terminal commands to set global environment variable for custom query engine path

LANGUAGE: terminal
CODE:
export PRISMA_QUERY_ENGINE_BINARY=/custom/my-query-engine-unix

LANGUAGE: terminal
CODE:
set PRISMA_QUERY_ENGINE_BINARY=c:\custom\my-query-engine-windows.exe

----------------------------------------

TITLE: Generating SQL Query for Subscription Status Percentages
DESCRIPTION: This snippet demonstrates how to create a SQL query that calculates the percentage of subscriptions that are Active, Paused, and Expired, which can be used with Prisma's TypedSQL feature.

LANGUAGE: sql
CODE:
SELECT 
  status,
  COUNT(*) * 100.0 / (SELECT COUNT(*) FROM "Subscription") AS percentage
FROM "Subscription"
GROUP BY status;

----------------------------------------

TITLE: Updating Prisma packages to v6 using pnpm
DESCRIPTION: Command to update both the prisma and @prisma/client packages to version 6 using pnpm.

LANGUAGE: bash
CODE:
pnpm upgrade prisma@6 @prisma/client@6

----------------------------------------

TITLE: Installing Latest Dev Distribution of Prisma in Node.js
DESCRIPTION: This command installs the most recent development version of Prisma Client and Prisma CLI using npm. It's used for testing new features or verifying fixes before official release, but should not be used in production.

LANGUAGE: bash
CODE:
npm install @prisma/client@dev prisma@dev

----------------------------------------

TITLE: Database Connection URL Format
DESCRIPTION: Example of DATABASE_URL environment variable configuration

LANGUAGE: bash
CODE:
DATABASE_URL="postgresql://janedoe:randompassword@localhost:5432/prisma?schema=myproject$dev"

----------------------------------------

TITLE: Installing Prisma Client with npm for TypeScript and MongoDB
DESCRIPTION: This command installs the @prisma/client package and automatically invokes prisma generate to create a version of Prisma Client tailored to the project's models. After making changes to the Prisma schema, prisma generate must be manually run to update the Prisma Client API.

LANGUAGE: shell
CODE:
npm install @prisma/client

----------------------------------------

TITLE: Configuring Guide Frontmatter in MDX
DESCRIPTION: Required frontmatter configuration for Prisma ORM documentation guides. Includes title, metaTitle, description, sidebar label and image path specifications.

LANGUAGE: mdx
CODE:
---
title: 'How to [do something] with Prisma ORM'
metaTitle: 'How to [do something] with Prisma ORM'
description: 'Learn how to [do something] with Prisma ORM'
sidebar_label: '[Concise Label]'
image: '/img/guides/[guide-name]-cover.png'
---

----------------------------------------

TITLE: Using the @id attribute
DESCRIPTION: Defines a single-field ID on a model using the @id attribute.

LANGUAGE: prisma
CODE:
model User {
  id   Int    @id @default(autoincrement())
  name String
}

----------------------------------------

TITLE: Installing Project Dependencies
DESCRIPTION: Commands to initialize a TypeScript project and install necessary dependencies including Prisma CLI, TypeScript, and Node.js types

LANGUAGE: bash
CODE:
npm init -y
npm install prisma typescript tsx @types/node --save-dev

----------------------------------------

TITLE: Using Prisma.validator for Type-Safe Queries
DESCRIPTION: Demonstrates how to use Prisma.validator to create a type-safe object for selecting user email, ensuring better type inference and safety.

LANGUAGE: typescript
CODE:
import { Prisma } from '@prisma/client'

const userEmail = Prisma.validator<Prisma.UserSelect>()({ 
  email: true,
})

// Run inside async function
const user = await prisma.user.findUnique({
  where: {
    id: 3,
  },
  select: userEmail,
})

----------------------------------------

TITLE: Generated SQL Migration for Tag Model
DESCRIPTION: SQL migration script that creates the Tag table and establishes many-to-many relationship tables and constraints with the Post model. Includes table creation, index creation, and foreign key constraints.

LANGUAGE: sql
CODE:
-- CreateTable
CREATE TABLE "Tag" (
    "id" SERIAL NOT NULL,
    "name" VARCHAR(255) NOT NULL,

    CONSTRAINT "Tag_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "_PostToTag" (
    "A" INTEGER NOT NULL,
    "B" INTEGER NOT NULL
);

-- CreateIndex
CREATE UNIQUE INDEX "_PostToTag_AB_unique" ON "_PostToTag"("A", "B");

-- CreateIndex
CREATE INDEX "_PostToTag_B_index" ON "_PostToTag"("B");

-- AddForeignKey
ALTER TABLE "_PostToTag" ADD CONSTRAINT "_PostToTag_A_fkey" FOREIGN KEY ("A") REFERENCES "Post"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "_PostToTag" ADD CONSTRAINT "_PostToTag_B_fkey" FOREIGN KEY ("B") REFERENCES "Tag"("id") ON DELETE CASCADE ON UPDATE CASCADE;

----------------------------------------

TITLE: Invoking Prisma CLI
DESCRIPTION: Command to invoke the Prisma CLI using npx. This allows you to run Prisma commands in your project.

LANGUAGE: bash
CODE:
npx prisma

----------------------------------------

TITLE: Adding Optimize with Middleware
DESCRIPTION: Example demonstrating the correct order for implementing Prisma Middleware with the Optimize extension.

LANGUAGE: typescript
CODE:
const prisma = new PrismaClient().$use(middleware).$extends(withOptimize())

----------------------------------------

TITLE: Reusable Error Adapter Pattern
DESCRIPTION: Shows how to create a reusable error adapter function for consistent error handling across queries

LANGUAGE: javascript
CODE:
const adaptError = (customThrowFn) => (error) => {
  if (error.code === 'P2025') {
    throw customThrowFn()
  }
  throw error
}

const user = await prisma.user.findFirstOrThrow({
  where: { name: 'Alice' },
}).catch(adaptError(() => new MyCustomError())

----------------------------------------

TITLE: Adding a Required Field to Post Model
DESCRIPTION: This Prisma schema snippet shows the addition of a required 'description' field to the Post model.

LANGUAGE: prisma
CODE:
model Post {
  id          Int        @id @default(autoincrement())
  title       String
  description String
  published   Boolean    @default(true)
  content     String     @db.VarChar(500)
  authorId    Int
  author      User       @relation(fields: [authorId], references: [id])
  categories  Category[]
}

----------------------------------------

TITLE: Relation Filters with Prisma ORM in TypeScript
DESCRIPTION: Shows how to use relation filters in Prisma ORM to find users with posts containing a specific word in the title. This feature is unique to Prisma and not directly available in Mongoose.

LANGUAGE: typescript
CODE:
const posts = await prisma.user.findMany({
  where: {
    Post: {
      some: {
        title: {
          contains: 'Hello',
        },
      },
    },
  },
})

----------------------------------------

TITLE: Prisma Schema without Default Values
DESCRIPTION: Prisma schema representation of a table without default values.

LANGUAGE: prisma
CODE:
model cats {
  id   Int     @id @default(autoincrement())
  name String?
}

----------------------------------------

TITLE: Configuring Prisma Schema for Accelerate
DESCRIPTION: This snippet demonstrates how to update the Prisma schema file to use the Accelerate connection string and include the direct URL for migrations and introspection.

LANGUAGE: prisma
CODE:
datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_DATABASE_URL")
}

----------------------------------------

TITLE: Handling Json Fields in Prisma ORM 2.x+ (MySQL)
DESCRIPTION: This snippet demonstrates how to handle Json fields that were previously stored as TEXT in the database. It shows how to change the column type to JSON.

LANGUAGE: prisma
CODE:
model User {
  id       String @id
  jsonData Json?
}

----------------------------------------

TITLE: Defining Project Rules with .cursorrules for Prisma and TypeScript
DESCRIPTION: Example configuration for a .cursorrules file to enforce best practices and development standards for Prisma projects using TypeScript. It covers general TypeScript guidelines, Prisma-specific rules, and coding standards.

LANGUAGE: text
CODE:
You are a senior TypeScript/JavaScript programmer with expertise in Prisma, clean code principles, and modern backend development.
Generate code, corrections, and refactorings that comply with the following guidelines:
TypeScript General Guidelines
Basic Principles
- Use English for all code and documentation.
- Always declare explicit types for variables and functions.
  - Avoid using "any".
  - Create precise, descriptive types.
- Use JSDoc to document public classes and methods.
- Maintain a single export per file.
- Write self-documenting, intention-revealing code.
Nomenclature
- Use PascalCase for classes and interfaces.
- Use camelCase for variables, functions, methods.
- Use kebab-case for file and directory names.
- Use UPPERCASE for environment variables and constants.
- Start function names with a verb.
- Use verb-based names for boolean variables:
  - isLoading, hasError, canDelete
- Use complete words, avoiding unnecessary abbreviations.
  - Exceptions: standard abbreviations like API, URL
  - Accepted short forms: 
    - i, j for loop indices
    - err for errors
    - ctx for contexts
Functions
- Write concise, single-purpose functions.
  - Aim for less than 20 lines of code.
- Name functions descriptively with a verb.
- Minimize function complexity:
  - Use early returns.
  - Extract complex logic to utility functions.
- Leverage functional programming techniques:
  - Prefer map, filter, reduce.
  - Use arrow functions for simple operations.
  - Use named functions for complex logic.
- Use object parameters for multiple arguments.
- Maintain a single level of abstraction.
Data Handling
- Encapsulate data in composite types.
- Prefer immutability.
  - Use readonly for unchanging data.
  - Use as const for literal values.
- Validate data at the boundaries.
Error Handling
- Use specific, descriptive error types.
- Provide context in error messages.
- Use global error handling where appropriate.
- Log errors with sufficient context.
Prisma-Specific Guidelines
Schema Design
- Use meaningful, domain-driven model names.
- Leverage Prisma schema features:
  - Use @id for primary keys.
  - Use @unique for natural unique identifiers.
  - Utilize @relation for explicit relationship definitions.
- Keep schemas normalized and DRY.
- Use meaningful field names and types.
- Implement soft delete with deletedAt timestamp.
- Use Prisma's native type decorators.
Prisma Client Usage
- Always use type-safe Prisma client operations.
- Prefer transactions for complex, multi-step operations.
- Use Prisma middleware for cross-cutting concerns:
  - Logging
  - Soft delete
  - Auditing
- Handle optional relations explicitly.
- Use Prisma's filtering and pagination capabilities.
Database Migrations
- Create migrations for schema changes.
- Use descriptive migration names.
- Review migrations before applying.
- Never modify existing migrations.
- Keep migrations idempotent.
Error Handling with Prisma
- Catch and handle Prisma-specific errors:
  - PrismaClientKnownRequestError
  - PrismaClientUnknownRequestError
  - PrismaClientValidationError
- Provide user-friendly error messages.
- Log detailed error information for debugging.
Testing Prisma Code
- Use in-memory database for unit tests.
- Mock Prisma client for isolated testing.
- Test different scenarios:
  - Successful operations
  - Error cases
  - Edge conditions
- Use factory methods for test data generation.
- Implement integration tests with actual database.
Performance Considerations
- Use select and include judiciously.
- Avoid N+1 query problems.
- Use findMany with take and skip for pagination.
- Leverage Prisma's distinct for unique results.
- Profile and optimize database queries.
Security Best Practices
- Never expose raw Prisma client in APIs.
- Use input validation before database operations.
- Implement row-level security.
- Sanitize and validate all user inputs.
- Use Prisma's built-in protections against SQL injection.
Coding Style
- Keep Prisma-related code in dedicated repositories/modules.
- Separate data access logic from business logic.
- Create repository patterns for complex queries.
- Use dependency injection for Prisma services.
Code Quality
- Follow SOLID principles.
- Prefer composition over inheritance.
- Write clean, readable, and maintainable code.
- Continuously refactor and improve code structure.
Development Workflow
- Use version control (Git).
- Implement comprehensive test coverage.
- Use continuous integration.
- Perform regular code reviews.
- Keep dependencies up to date.

----------------------------------------

TITLE: Configuring Prisma Generation Scripts in Monorepo
DESCRIPTION: NPM script configuration for generating Prisma Client in a monorepo environment. Specifies custom schema location for centralized schema management.

LANGUAGE: json
CODE:
{
  "scripts": {
    "prisma:generate": "prisma generate --schema=./packages/db/schema.prisma"
  }
}

----------------------------------------

TITLE: Creating React Component for User Management
DESCRIPTION: This snippet shows how to create a React component for managing users, including fetching, creating, and deleting users using the API endpoints created with Prisma.

LANGUAGE: typescript
CODE:
import React, { useState, useEffect } from 'react';

interface User {
  id: number;
  email: string;
  name: string;
  organizationId: number;
}

const User: React.FC = () => {
  const [users, setUsers] = useState<User[]>([]);
  const [newUser, setNewUser] = useState({ email: '', name: '', organizationId: 0 });

  useEffect(() => {
    fetchUsers();
  }, []);

  const fetchUsers = async () => {
    const response = await fetch('/api/users');
    const data = await response.json();
    setUsers(data);
  };

  const createUser = async () => {
    await fetch('/api/users', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(newUser),
    });
    fetchUsers();
    setNewUser({ email: '', name: '', organizationId: 0 });
  };

  const deleteUser = async (id: number) => {
    await fetch(`/api/users?id=${id}`, { method: 'DELETE' });
    fetchUsers();
  };

  return (
    <div>
      <h2>Users</h2>
      <ul>
        {users.map((user) => (
          <li key={user.id}>
            {user.name} ({user.email}) - Org ID: {user.organizationId}
            <button onClick={() => deleteUser(user.id)}>Delete</button>
          </li>
        ))}
      </ul>
      <h3>Create New User</h3>
      <input
        type="text"
        placeholder="Name"
        value={newUser.name}
        onChange={(e) => setNewUser({ ...newUser, name: e.target.value })}
      />
      <input
        type="email"
        placeholder="Email"
        value={newUser.email}
        onChange={(e) => setNewUser({ ...newUser, email: e.target.value })}
      />
      <input
        type="number"
        placeholder="Organization ID"
        value={newUser.organizationId}
        onChange={(e) => setNewUser({ ...newUser, organizationId: Number(e.target.value) })}
      />
      <button onClick={createUser}>Create User</button>
    </div>
  );
};

export default User;

----------------------------------------

TITLE: Prisma Client Initialization
DESCRIPTION: TypeScript code for initializing and exporting Prisma Client with Accelerate extension.

LANGUAGE: typescript
CODE:
import { PrismaClient } from "./generated/client";
import { withAccelerate } from '@prisma/extension-accelerate'

const prisma = new PrismaClient().$extends(withAccelerate())

const globalForPrisma = global as unknown as { prisma: typeof prisma }

if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma

export { prisma };

----------------------------------------

TITLE: Initializing Node.js Project with package.json
DESCRIPTION: Creates a basic package.json file for a new Node.js project named 'docker-test'.

LANGUAGE: json
CODE:
{
  "name": "docker-test",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {},
  "keywords": [],
  "author": "",
  "license": "ISC"
}

----------------------------------------

TITLE: Initializing Prisma Schema
DESCRIPTION: Command to initialize Prisma project by creating the schema file and environment configuration

LANGUAGE: bash
CODE:
npx prisma init

----------------------------------------

TITLE: Initializing TypeScript Project with Prisma Dependencies
DESCRIPTION: Commands to initialize a new npm project and install required TypeScript and Prisma dependencies

LANGUAGE: terminal
CODE:
npm init -y
npm install prisma typescript tsx @types/node --save-dev

----------------------------------------

TITLE: Launching Prisma Studio
DESCRIPTION: Command to start Prisma Studio, a GUI tool for viewing and editing database records.

LANGUAGE: terminal
CODE:
npx prisma studio

----------------------------------------

TITLE: Fetching Selected Scalars of Single Objects with Prisma ORM and Mongoose in TypeScript
DESCRIPTION: Shows how to fetch specific fields (scalars) of a user object by ID. Prisma uses the select option within findUnique, while Mongoose uses the select method chained to findById.

LANGUAGE: typescript
CODE:
const user = await prisma.user.findUnique({
  where: {
    id: 1,
  },
  select: {
    name: true,
  },
})

LANGUAGE: typescript
CODE:
const user = await User.findById(1).select(['name'])

----------------------------------------

TITLE: Initializing Node.js Project and Installing Prisma CLI
DESCRIPTION: Commands to initialize a new Node.js project with npm and install the Prisma CLI as a development dependency.

LANGUAGE: bash
CODE:
npm init -y
npm install prisma --save-dev

----------------------------------------

TITLE: Configuring Prisma Schema for PlanetScale Database Connection
DESCRIPTION: This snippet shows how to set up the datasource block in the Prisma schema file for connecting to a PlanetScale database. It includes changing the provider to MySQL and setting the relation mode to 'prisma' for emulating foreign key constraints.

LANGUAGE: prisma
CODE:
datasource db {
  provider     = "mysql"
  url          = env("DATABASE_URL")
  relationMode = "prisma"
}

----------------------------------------

TITLE: Configuring Prisma Schema for PlanetScale Database Connection
DESCRIPTION: This snippet shows how to set up the datasource block in the Prisma schema file for connecting to a PlanetScale database. It includes changing the provider to MySQL and setting the relation mode to 'prisma' for emulating foreign key constraints.

LANGUAGE: prisma
CODE:
datasource db {
  provider     = "mysql"
  url          = env("DATABASE_URL")
  relationMode = "prisma"
}

----------------------------------------

TITLE: Removing jsonProtocol from preview features in Prisma schema
DESCRIPTION: Example of how to remove the jsonProtocol preview feature from the Prisma schema when upgrading to Prisma ORM 5.

LANGUAGE: prisma
CODE:
generator client {
  provider = "prisma-client-js"
}

----------------------------------------

TITLE: Generating Migration Without Applying
DESCRIPTION: Command to create a new migration file without immediately applying it to the database, allowing for customization.

LANGUAGE: bash
CODE:
npx prisma migrate dev --create-only

----------------------------------------

TITLE: Running Database Queries
DESCRIPTION: Command to execute the CRUD queries script that demonstrates database operations.

LANGUAGE: terminal
CODE:
npm run queries

----------------------------------------

TITLE: Comparing CRUD operations between Sequelize and Prisma Client
DESCRIPTION: Demonstrates how to perform basic CRUD operations using Sequelize and their equivalent Prisma Client queries.

LANGUAGE: typescript
CODE:
// Sequelize
// Find one
const user = await User.findOne({ 
  where: { id: 1 } 
});

// Create
const user = await User.create({
  email: 'alice@prisma.io',
  name: 'Alice'
});

// Update
await User.update({ name: 'New name' }, { 
  where: { id: 1 } 
});

// Delete
await User.destroy({
  where: { id: 1 }
});

// Prisma Client
// Find one
const user = await prisma.user.findUnique({ 
  where: { id: 1 } 
});

// Create
const user = await prisma.user.create({
  data: {
    email: 'alice@prisma.io',
    name: 'Alice'
  }
});

// Update
await prisma.user.update({
  where: { id: 1 },
  data: { name: 'New name' }
});

// Delete
await prisma.user.delete({
  where: { id: 1 }
});

----------------------------------------

TITLE: Initializing TypeScript Project with Prisma Dependencies
DESCRIPTION: Commands to initialize a new Node.js project and install required TypeScript and Prisma dependencies.

LANGUAGE: terminal
CODE:
npm init -y
npm install prisma typescript tsx @types/node --save-dev

----------------------------------------

TITLE: Sample Prisma v2 Initial Schema
DESCRIPTION: Basic Prisma schema configuration with datasource and generator blocks

LANGUAGE: prisma
CODE:
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

----------------------------------------

TITLE: Correcting self-referential Employee model in Prisma
DESCRIPTION: This updated Prisma schema for the Employee model explicitly sets onDelete and onUpdate actions to NoAction, resolving the cyclic referential action issue.

LANGUAGE: prisma
CODE:
model Employee {
  id        Int        @id @default(autoincrement())
  manager   Employee   @relation(name: "management", fields: [managerId], references: [id], onDelete: NoAction, onUpdate: NoAction)
  managees  Employee[] @relation(name: "management")
  managerId Int
}

----------------------------------------

TITLE: Creating Migration Directory Structure
DESCRIPTION: Creates the necessary directory structure for storing migration files, specifically creating a 0_init directory under prisma/migrations

LANGUAGE: terminal
CODE:
mkdir -p prisma/migrations/0_init

----------------------------------------

TITLE: Initializing Prisma Client and Basic Query Structure in Node.js
DESCRIPTION: Sets up Prisma Client, creates a main function for queries, and handles connection management. This structure is used as a foundation for executing Prisma queries.

LANGUAGE: javascript
CODE:
const { PrismaClient } = require('@prisma/client')

const prisma = new PrismaClient()

async function main() {
  // ... you will write your Prisma Client queries here
}

main()
  .then(async () => {
    await prisma.$disconnect()
  })
  .catch(async (e) => {
    console.error(e)
    await prisma.$disconnect()
    process.exit(1)
  })

----------------------------------------

TITLE: Filtering JSON Field with AnyNull in Prisma Client Query
DESCRIPTION: This code demonstrates how to filter a JSON field using the new AnyNull type in Prisma Client queries after the 3.0.1 update.

LANGUAGE: typescript
CODE:
import { Prisma } from '@prisma/client'

prisma.log.findMany({
  where: {
    data: {
      meta: {
        equals: Prisma.AnyNull,
      },
    },
  },
})

----------------------------------------

TITLE: Prisma Migration Command
DESCRIPTION: Terminal command to generate and apply database migrations for the schema changes.

LANGUAGE: terminal
CODE:
npx prisma migrate dev --name "added explicit relation"

----------------------------------------

TITLE: Filtering Records with Prisma ORM
DESCRIPTION: Demonstrates how to filter records using Prisma ORM's findMany method with a where clause. This example filters posts that contain 'Hello World' in the title.

LANGUAGE: typescript
CODE:
const posts = await prisma.post.findMany({
  where: {
    title: { contains: 'Hello World' },
  },
})

----------------------------------------

TITLE: Case-Insensitive Filtering with Prisma Client
DESCRIPTION: Example of performing a case-insensitive filter query using Prisma Client to search for users by email.

LANGUAGE: typescript
CODE:
const users = await prisma.user.findMany({
  where: {
    email: {
      contains: 'prisMa',
    },
  },
  select: {
    id: true,
    name: true,
  },
})

----------------------------------------

TITLE: Initializing Prisma Client in TypeScript
DESCRIPTION: Example code showing how to import and initialize PrismaClient in a TypeScript application. Demonstrates proper import statement and client instantiation with comments.

LANGUAGE: typescript
CODE:
// Import required dependencies
import { PrismaClient } from '@prisma/client'

// Initialize Prisma Client
const prisma = new PrismaClient()

----------------------------------------

TITLE: Configuring Nuxt with Prisma Module
DESCRIPTION: Configuration setup in nuxt.config.ts to enable Prisma module and experimental features

LANGUAGE: typescript
CODE:
export default defineNuxtConfig({
  compatibilityDate: "2024-11-01",
  modules: ["@prisma/nuxt"],
  experimental: {
    componentIslands: true,
  },
  devtools: { enabled: true },
});

----------------------------------------

TITLE: Initializing TypeScript Configuration
DESCRIPTION: Command to create TypeScript configuration file (tsconfig.json) with default settings.

LANGUAGE: bash
CODE:
npx tsc --init

----------------------------------------

TITLE: Installing Prisma Client Package
DESCRIPTION: Installs the @prisma/client package via npm and automatically generates the Prisma Client tailored to your schema models. After any schema updates, prisma db push must be run to create new indexes and regenerate the client.

LANGUAGE: terminal
CODE:
npm install @prisma/client

----------------------------------------

TITLE: Using Prisma CLI with Custom Schema Location
DESCRIPTION: Shows how to use the Prisma CLI with a custom schema location using the --schema flag. This is useful when the schema is not in the default location.

LANGUAGE: terminal
CODE:
prisma generate --schema=./alternative/schema.prisma

----------------------------------------

TITLE: Installing Prisma Accelerate Extension
DESCRIPTION: Command to install the Prisma Accelerate client extension, which provides connection pooling and optional caching capabilities for Prisma Postgres.

LANGUAGE: terminal
CODE:
npm install @prisma/extension-accelerate

----------------------------------------

TITLE: Creating SQL Tables for Prisma Introspection
DESCRIPTION: SQL commands to create sample tables (Post, Profile, User) for demonstrating Prisma's introspection feature. These tables include various column types and relationships.

LANGUAGE: sql
CODE:
CREATE TABLE `Post` (
  `id` int NOT NULL AUTO_INCREMENT,
  `createdAt` datetime(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3),
  `updatedAt` datetime(3) NOT NULL,
  `title` varchar(255) COLLATE utf8mb4_unicode_ci NOT NULL,
  `content` varchar(191) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `published` tinyint(1) NOT NULL DEFAULT '0',
  `authorId` int NOT NULL,
  PRIMARY KEY (`id`),
  KEY `Post_authorId_idx` (`authorId`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

CREATE TABLE `Profile` (
  `id` int NOT NULL AUTO_INCREMENT,
  `bio` varchar(191) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  `userId` int NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `Profile_userId_key` (`userId`),
  KEY `Profile_userId_idx` (`userId`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

CREATE TABLE `User` (
  `id` int NOT NULL AUTO_INCREMENT,
  `email` varchar(191) COLLATE utf8mb4_unicode_ci NOT NULL,
  `name` varchar(191) COLLATE utf8mb4_unicode_ci DEFAULT NULL,
  PRIMARY KEY (`id`),
  UNIQUE KEY `User_email_key` (`email`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci;

----------------------------------------

TITLE: Setting MongoDB Connection String in Environment File
DESCRIPTION: Example of setting the DATABASE_URL environment variable in the .env file with a MongoDB connection string. This includes the database name 'default_default' used by Prisma 1.

LANGUAGE: bash
CODE:
DATABASE_URL="mongodb://prisma:prisma@localhost:27017/default_default"

----------------------------------------

TITLE: Create Migration Without Applying
DESCRIPTION: Command to create a new migration file without applying it, allowing for customization of the migration before execution.

LANGUAGE: terminal
CODE:
npx prisma migrate dev --create-only

----------------------------------------

TITLE: Setting MongoDB Connection URL in Environment Variable
DESCRIPTION: This snippet demonstrates how to set the MongoDB connection URL as an environment variable in a .env file. It uses a MongoDB Atlas URL as an example.

LANGUAGE: bash
CODE:
DATABASE_URL="mongodb+srv://test:test@cluster0.ns1yp.mongodb.net/myFirstDatabase"

----------------------------------------

TITLE: Configuring PostgreSQL Connection URL with PgBouncer
DESCRIPTION: Connection string format for using Prisma Client with PgBouncer. Adds the pgbouncer=true flag to enable PgBouncer compatibility for versions below 1.21.0.

LANGUAGE: shell
CODE:
postgresql://USER:PASSWORD@HOST:PORT/DATABASE?pgbouncer=true

----------------------------------------

TITLE: Using Prisma Client for Database Operations
DESCRIPTION: Demonstrates how to use Prisma Client to create a new user and fetch all users from the database. These operations should be run inside an async function.

LANGUAGE: typescript
CODE:
// run inside `async` function
const newUser = await prisma.user.create({
  data: {
    name: 'Alice',
    email: 'alice@prisma.io',
  },
})

const users = await prisma.user.findMany()

----------------------------------------

TITLE: Initializing Prisma Schema
DESCRIPTION: Command to initialize the Prisma schema file. This creates a new 'prisma' directory with a 'schema.prisma' file and a '.env' file in the root directory for environment variables.

LANGUAGE: bash
CODE:
npx prisma init

----------------------------------------

TITLE: Finding Records with Undefined Values
DESCRIPTION: Example showing how undefined values in queries effectively remove the filter condition.

LANGUAGE: typescript
CODE:
const users = await prisma.user.findMany({
  where: {
    name: undefined,
  },
})

----------------------------------------

TITLE: Creating Related Records with Nested Writes in Prisma
DESCRIPTION: Shows how to create a new User record along with related Post and Profile records using Prisma's nested write functionality. It then queries and logs all users with their related data.

LANGUAGE: javascript
CODE:
async function main() {
  await prisma.user.create({
    data: {
      name: 'Alice',
      email: 'alice@prisma.io',
      posts: {
        create: { title: 'Hello World' },
      },
      profile: {
        create: { bio: 'I like turtles' },
      },
    },
  })

  const allUsers = await prisma.user.findMany({
    include: {
      posts: true,
      profile: true,
    },
  })
  console.dir(allUsers, { depth: null })
}

----------------------------------------

TITLE: Defining Implicit Many-to-Many Schema in Prisma
DESCRIPTION: Schema definition for implicit many-to-many relationship between Post and Tag models where Prisma handles the relation table internally.

LANGUAGE: prisma
CODE:
model Post {
  id    Int    @id @default(autoincrement())
  title String
  tags  Tag[]
}

model Tag {
  id    Int    @id @default(autoincrement())
  name  String @unique
  posts Post[]
}

----------------------------------------

TITLE: Creating Objects with Prisma ORM and Sequelize in TypeScript
DESCRIPTION: Shows how to create new database objects. Prisma uses the create method, while Sequelize offers both build + save and create methods.

LANGUAGE: typescript
CODE:
const user = await prisma.user.create({
  data: {
    email: 'alice@prisma.io',
  },
})

LANGUAGE: typescript
CODE:
const user = User.build({
  name: 'Alice',
  email: 'alice@prisma,io',
})
await user.save()

LANGUAGE: typescript
CODE:
const user = await User.create({
  name: 'Alice',
  email: 'alice@prisma,io',
})

----------------------------------------

TITLE: Comparing Date Columns with Raw Query in SQLite
DESCRIPTION: Execute a raw SQL query to compare completedDate and dueDate columns in the Project table for SQLite.

LANGUAGE: javascript
CODE:
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

async function initiateDatesComparisonRawQuery() {
  const response =
    await prisma.$queryRaw`SELECT * FROM "Project" WHERE "completedDate" > "dueDate";`

  console.log(response)
}

await initiateDatesComparisonRawQuery()

----------------------------------------

TITLE: Configuring Docker Compose for Full Application Stack
DESCRIPTION: Sets up a Docker Compose configuration for the full application stack, including the PostgreSQL database, Node.js server, and Prisma Studio for database management.

LANGUAGE: yaml
CODE:
version: '3.7'

services:
  postgres_db:
    image: postgres:15
    hostname: postgres_db
    container_name: postgres_db
    restart: always
    environment:
      POSTGRES_DB: postgres
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: prisma
    ports:
      - '5432:5432'
    networks:
      - prisma-network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres -d postgres"]
      interval: 5s
      timeout: 2s
      retries: 20

  server:
    build: 
      context: .  
      dockerfile: Dockerfile
    ports:
      - '3000:3000'
    stdin_open: true
    tty: true  # Keeps the container running for debugging
    depends_on:
      postgres_db:
        condition: service_healthy
    env_file:
      - .env.prod
    networks:
      - prisma-network
  prisma-studio:
    image: node:lts-alpine3.17
    working_dir: /usr/src/app
    volumes:
      - .:/usr/src/app
    command: npx prisma studio --port 5555 --browser none
    ports:
      - "5555:5555"
    env_file:
      - .env.prod
    networks:
      - prisma-network
    depends_on:
      postgres_db:
        condition: service_healthy
      server:
        condition: service_started
networks:
  prisma-network:
    name: prisma-network

----------------------------------------

TITLE: Creating Code with Result Block in MDX
DESCRIPTION: Shows how to implement a code block with its execution result using the CodeWithResult component. This example demonstrates the output of a Prisma CLI command.

LANGUAGE: markdown
CODE:
<CodeWithResult expanded={true}>

<cmd>

```
yarn prisma init
```

</cmd>

<cmdResult>

```code no-copy wrap
$ yarn prisma init
yarn run v1.22.0
warning package.json: No license field
$ /Users/janedoe/Desktop/tsdf/node_modules/.bin/prisma init

 Your Prisma schema was created at prisma/schema.prisma.
  You can now open it in your favorite editor.

Next steps:
1. Set the DATABASE_URL in the .env file to point to your existing database. If your database has no tables yet, read https://pris.ly/d/getting-started.
2. Set the provider of the datasource block in schema.prisma to match your database: postgresql, mysql or sqlite.
3. Run `prisma db pull` to introspect your database schema and update the Prisma schema data models accordingly.
4. Run `prisma generate` to install Prisma Client. You can then start querying your database.

More information in our documentation:
https://pris.ly/d/getting-started
```

</cmdResult>

</CodeWithResult>

----------------------------------------

TITLE: Initializing TypeScript Configuration
DESCRIPTION: Command to create a TypeScript configuration file (tsconfig.json) for the project.

LANGUAGE: bash
CODE:
npx tsc --init

----------------------------------------

TITLE: Initializing Prisma Client in TypeScript
DESCRIPTION: Sets up the basic structure for using Prisma Client, including client instantiation, main function definition, and connection handling. Includes error handling and proper database disconnection.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

async function main() {
  // ... you will write your Prisma Client queries here
}

main()
  .then(async () => {
    await prisma.$disconnect()
  })
  .catch(async (e) => {
    console.error(e)
    await prisma.$disconnect()
    process.exit(1)
  })

----------------------------------------

TITLE: Evaluating Prisma Accelerate Edge Caching
DESCRIPTION: TypeScript script for measuring edge caching performance by running repeated queries with caching enabled. Includes TTL configuration and calculates performance metrics.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client'
import { withAccelerate } from '@prisma/extension-accelerate'

const prisma = new PrismaClient().$extends(withAccelerate())

function calculateStatistics(numbers: number[]): {
  average: number
  p50: number
  p75: number
  p99: number
} {
  if (numbers.length === 0) {
    throw new Error('The input array is empty.')
  }

  // Sort the array in ascending order
  numbers.sort((a, b) => a - b)

  const sum = numbers.reduce((acc, num) => acc + num, 0)
  const count = numbers.length

  const average = sum / count
  const p50 = getPercentile(numbers, 50)
  const p75 = getPercentile(numbers, 75)
  const p99 = getPercentile(numbers, 99)

  return { average, p50, p75, p99 }
}

function getPercentile(numbers: number[], percentile: number): number {
  if (percentile <= 0 || percentile >= 100) {
    throw new Error('Percentile must be between 0 and 100.')
  }

  const index = (percentile / 100) * (numbers.length - 1)
  if (Number.isInteger(index)) {
    // If the index is an integer, return the corresponding value
    return numbers[index]
  } else {
    // If the index is not an integer, interpolate between two adjacent values
    const lowerIndex = Math.floor(index)
    const upperIndex = Math.ceil(index)
    const lowerValue = numbers[lowerIndex]
    const upperValue = numbers[upperIndex]
    const interpolationFactor = index - lowerIndex
    return lowerValue + (upperValue - lowerValue) * interpolationFactor
  }
}

async function main() {
  const timings = []

  // fire a query before going to the loop
  await prisma.notes.findMany({
    take: 20,
    cacheStrategy: {
      ttl: 30,
    },
  })

  // we recommend evaluating Prisma Accelerate with a large loop
  const LOOP_LENGTH = 10000

  for (let i = 0; i < LOOP_LENGTH; i++) {
    const start = Date.now()
    await prisma.notes.findMany({
      take: 20,
      cacheStrategy: {
        ttl: 30,
      },
    })

    timings.push(Date.now() - start)
  }

  const statistics = calculateStatistics(timings)
  console.log('Average:', statistics.average)
  console.log('P50:', statistics.p50)
  console.log('P75:', statistics.p75)
  console.log('P99:', statistics.p99)
}

main()
  .then(async () => {
    await prisma.$disconnect()
  })
  .catch((e) => {
    await prisma.$disconnect()
    process.exit(1)
  })

----------------------------------------

TITLE: Running Prisma Migration Reset
DESCRIPTION: Command to reset the database and reapply all migrations when encountering migration conflicts or failed migrations.

LANGUAGE: bash
CODE:
npx prisma migrate reset

----------------------------------------

TITLE: Filtering Posts with Prisma Client 2 in Express Route Handler
DESCRIPTION: Update the GET /filterPosts route to use Prisma Client 2's findMany method with complex filtering conditions.

LANGUAGE: typescript
CODE:
app.get('/filterPosts', async (req, res) => {
  const { searchString } = req.query
  const filteredPosts = await prisma.post.findMany({
    where: {
      OR: [
        {
          title: { contains: searchString },
        },
        {
          content: { contains: searchString },
        },
      ],
    },
  })
  res.json(filteredPosts)
})

----------------------------------------

TITLE: Development Migration Command
DESCRIPTION: Command to generate and apply new migrations in development environment.

LANGUAGE: bash
CODE:
npx prisma migrate dev

----------------------------------------

TITLE: Installing Prisma Client via NPM
DESCRIPTION: Command to install the @prisma/client package via NPM. This installation automatically triggers prisma generate to create a client tailored to your schema models.

LANGUAGE: terminal
CODE:
npm install @prisma/client

----------------------------------------

TITLE: Handling Enum Fields in Prisma ORM 2.x+ (MySQL)
DESCRIPTION: This snippet shows how to handle enum fields that were previously stored as TEXT in the database. It demonstrates creating an enum type and changing the column type to use the new enum.

LANGUAGE: prisma
CODE:
model User {
  id   String @id
  role Role?
}

enum Role {
  ADMIN
  CUSTOMER
}

----------------------------------------

TITLE: Updating Records with Prisma Client
DESCRIPTION: Shows how to update an existing database record using Prisma Client's update operation, specifically updating a Post's published status.

LANGUAGE: javascript
CODE:
async function main() {
  const post = await prisma.post.update({
    where: { id: 1 },
    data: { published: true },
  })
  console.log(post)
}

----------------------------------------

TITLE: Default Values Migration Example
DESCRIPTION: Example showing how default values aren't properly represented when migrating from Prisma 1 to Prisma 2+, with SQL workaround to add DEFAULT constraints.

LANGUAGE: graphql
CODE:
type Post {
  id: ID! @id
  published: Boolean @default(value: false)
}

LANGUAGE: sql
CODE:
CREATE TABLE "Post" (
  id VARCHAR(25) PRIMARY KEY NOT NULL,
  published BOOLEAN NOT NULL
);

LANGUAGE: prisma
CODE:
model Post {
  id        String  @id
  published Boolean
}

----------------------------------------

TITLE: Regenerating Prisma Client
DESCRIPTION: Command to regenerate Prisma Client after making changes to the database schema. This updates the generated code in node_modules/.prisma/client.

LANGUAGE: shell
CODE:
prisma generate

----------------------------------------

TITLE: Handling Inline 1-1 Relations in Prisma ORM 2.x+ (MySQL)
DESCRIPTION: This snippet demonstrates how to handle inline 1-1 relations that are recognized as 1-n due to missing UNIQUE constraints. It shows how to add a UNIQUE constraint to the foreign key column.

LANGUAGE: prisma
CODE:
model User {
  id      String   @id
  Profile Profile?
}

model Profile {
  id   String  @id
  user String? @unique
  User User?   @relation(fields: [user], references: [id])
}

----------------------------------------

TITLE: Database Schema Introspection
DESCRIPTION: Commands to pull database schema changes and create a new migration based on manual database modifications.

LANGUAGE: bash
CODE:
npx prisma db pull
npx prisma migrate dev --name introspected_change

----------------------------------------

TITLE: Batch Updates with Prisma ORM and Sequelize in TypeScript
DESCRIPTION: Demonstrates how to perform batch updates on multiple records. Prisma uses updateMany, while Sequelize uses the update method with a where clause.

LANGUAGE: typescript
CODE:
const user = await prisma.user.updateMany({
  data: {
    name: 'Published author!',
  },
  where: {
    email: {
      contains: 'prisma.io',
    },
  },
})

LANGUAGE: typescript
CODE:
const updatedUsers = await User.update(
  { role: "Admin" },
  {
    where: {
      email: {
        [Op.like]: "%@prisma.io"
      }
    },
  }
)

----------------------------------------

TITLE: Setting Database Environment Variables
DESCRIPTION: Example of setting the PostgreSQL database connection URL in the .env file with credentials and connection details.

LANGUAGE: bash
CODE:
DATABASE_URL="postgresql://johndoe:randompassword@localhost:5432/mydb?schema=public"

----------------------------------------

TITLE: Prisma Schema Definition
DESCRIPTION: Prisma schema file defining database configuration, client generator settings, and User model.

LANGUAGE: prisma
CODE:
generator client {
  provider = "prisma-client-js"
  output = "../generated/client"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id    Int     @id @default(autoincrement())
  email String  @unique
  name  String?
}

----------------------------------------

TITLE: Implementing Expandable Section in MDX
DESCRIPTION: Demonstrates how to create an expandable (details/summary) section in MDX. This is useful for hiding additional information that can be revealed on demand.

LANGUAGE: markdown
CODE:
<details>
<summary>Expand if you want to view more</summary>

Here's more!

</details>

----------------------------------------

TITLE: Using the @default attribute
DESCRIPTION: Defines a default value for a field using the @default attribute.

LANGUAGE: prisma
CODE:
model User {
  email        String @unique
  profileViews Int    @default(0)
}

----------------------------------------

TITLE: Running Prisma Migration Command
DESCRIPTION: Terminal command to create and execute the initial database migration. This command creates a new SQL migration file and runs it against the database to create the specified tables.

LANGUAGE: terminal
CODE:
npx prisma migrate dev --name init

----------------------------------------

TITLE: Handling @createdAt Fields in Prisma ORM 2.x+ (MySQL)
DESCRIPTION: This snippet demonstrates how to handle @createdAt fields that were previously managed by Prisma 1 server. It shows how to add a DEFAULT CURRENT_TIMESTAMP constraint to the database column or manually add @default(now()) attribute to the Prisma model.

LANGUAGE: prisma
CODE:
model Post {
  id        String   @id
  createdAt DateTime @default(now())
}

----------------------------------------

TITLE: Initial Database Migration SQL for CockroachDB
DESCRIPTION: SQL script generated by Prisma to create the initial database schema. It defines tables for User, Post, and Profile with their respective columns and relationships.

LANGUAGE: sql
CODE:
CREATE TABLE "User" (
  id INT8 PRIMARY KEY DEFAULT unique_rowid(),
  name STRING(255),
  email STRING(255) UNIQUE NOT NULL
);

CREATE TABLE "Post" (
  id INT8 PRIMARY KEY DEFAULT unique_rowid(),
  title STRING(255) UNIQUE NOT NULL,
  "createdAt" TIMESTAMP NOT NULL DEFAULT now(),
  content STRING,
  published BOOLEAN NOT NULL DEFAULT false,
  "authorId" INT8 NOT NULL,
  FOREIGN KEY ("authorId") REFERENCES "User"(id)
);

CREATE TABLE "Profile" (
  id INT8 PRIMARY KEY DEFAULT unique_rowid(),
  bio STRING,
  "userId" INT8 UNIQUE NOT NULL,
  FOREIGN KEY ("userId") REFERENCES "User"(id)
);

----------------------------------------

TITLE: Nuxt Module Configuration
DESCRIPTION: Configuration options for the Prisma Nuxt module in nuxt.config.ts

LANGUAGE: typescript
CODE:
export default defineNuxtConfig({
  // ...
  prisma: {
    // Options
  }
})

----------------------------------------

TITLE: Defining a PostgreSQL datasource
DESCRIPTION: Specifies a PostgreSQL datasource with connection details.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "postgresql"
  url      = "postgresql://johndoe:mypassword@localhost:5432/mydb?schema=public"
}

----------------------------------------

TITLE: Running Prisma Migrate to Create Database Tables
DESCRIPTION: This command creates a new SQL migration file and runs it against the database to create the tables defined in the Prisma schema. It also generates the Prisma Client if necessary.

LANGUAGE: terminal
CODE:
npx prisma migrate dev --name init

----------------------------------------

TITLE: Setting SQL Server Connection URL in Environment
DESCRIPTION: Defines the database connection URL in the environment file including server location, database name, authentication credentials, and SSL settings.

LANGUAGE: bash
CODE:
DATABASE_URL="sqlserver://localhost:1433;database=mydb;user=sa;password=r@ndomP@$$w0rd;trustServerCertificate=true"

----------------------------------------

TITLE: Batch Deletes with Prisma ORM and Sequelize in TypeScript
DESCRIPTION: Shows how to perform batch deletes on multiple records. Prisma uses deleteMany, while Sequelize uses the destroy method with a where clause.

LANGUAGE: typescript
CODE:
const users = await prisma.user.deleteMany({
  where: {
    id: {
      in: [1, 2, 6, 6, 22, 21, 25],
    },
  },
})

LANGUAGE: typescript
CODE:
await User.destroy({
  where: {
    id: {
      [Op.in]: [id1, id2, id3],
    },
  },
})

----------------------------------------

TITLE: Configuring MongoDB Datasource in Prisma Schema
DESCRIPTION: This snippet shows how to set up the datasource block in the Prisma schema file to connect to a MongoDB database. It uses an environment variable for the database URL.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

----------------------------------------

TITLE: Disabling Prisma Telemetry
DESCRIPTION: Command to opt-out of Prisma's telemetry data collection by setting an environment variable.

LANGUAGE: terminal
CODE:
export CHECKPOINT_DISABLE=1

----------------------------------------

TITLE: Querying All Users with Prisma Client in TypeScript
DESCRIPTION: Demonstrates how to use Prisma Client to query all User records from the database and log the results.

LANGUAGE: typescript
CODE:
async function main() {
  const allUsers = await prisma.user.findMany()
  console.log(allUsers)
}

----------------------------------------

TITLE: Creating Migration for Retroactive Index
DESCRIPTION: Example of generating a new migration to document a retroactively added index in production

LANGUAGE: bash
CODE:
npx prisma migrate dev --name retroactively-add-index

----------------------------------------

TITLE: Fetching Relations with Prisma ORM and Mongoose in TypeScript
DESCRIPTION: Illustrates how to fetch a user object along with its related posts. Prisma offers two methods: using include or the Fluent API. Mongoose uses the populate method to achieve this.

LANGUAGE: typescript
CODE:
const userWithPost = await prisma.user.findUnique({
  where: {
    id: 2,
  },
  include: {
    post: true,
  },
})

LANGUAGE: typescript
CODE:
const userWithPost = await prisma.user
  .findUnique({
    where: {
      id: 2,
    },
  })
  .post()

LANGUAGE: typescript
CODE:
const userWithPost = await User.findById(2).populate('post')

----------------------------------------

TITLE: Executing a SELECT query with $queryRaw
DESCRIPTION: Use $queryRaw to execute a SELECT query and return database records. The method uses a tagged template for SQL injection protection.

LANGUAGE: typescript
CODE:
const result = await prisma.$queryRaw`SELECT * FROM User`;

----------------------------------------

TITLE: Database Package Configuration
DESCRIPTION: Package.json configuration for the shared database package including Prisma dependencies and scripts.

LANGUAGE: json
CODE:
{
  "devDependencies": {
    "prisma": "catalog:prisma"
  }
}

----------------------------------------

TITLE: Implementing Code Block without Copy Option in MDX
DESCRIPTION: Shows how to create a code block without the copy option using the 'no-copy' attribute. This is useful for code that shouldn't be copied directly.

LANGUAGE: javascript
CODE:
```js no-copy
async function main() {
  const allUsers = await prisma.user.findMany()
  console.log(allUsers)
}
```

----------------------------------------

TITLE: Configuring Package.json Scripts
DESCRIPTION: Custom npm scripts for managing multiple Prisma Clients including generation, migration, and deployment commands.

LANGUAGE: json
CODE:
{
  "script": {
    "postinstall": "npx prisma generate --schema ./prisma-user-database/schema.prisma --no-engine && npx prisma generate --schema ./prisma-post-database/schema.prisma --no-engine",
    "generate": "npx prisma generate --schema ./prisma-user-database/schema.prisma --no-engine && npx prisma generate --schema ./prisma-post-database/schema.prisma --no-engine",
    "migrate": "npx prisma migrate dev --schema ./prisma-user-database/schema.prisma && npx prisma migrate dev --schema ./prisma-post-database/schema.prisma",
    "deploy": "npx prisma migrate deploy --schema ./prisma-user-database/schema.prisma && npx prisma migrate deploy --schema ./prisma-post-database/schema.prisma",
    "studio": "npx prisma studio --schema ./prisma-user-database/schema.prisma --port 5555 & npx prisma studio --schema ./prisma-post-database/schema.prisma --port 5556"
  }
}

----------------------------------------

TITLE: Configuring Prisma Database Source with SQL Server
DESCRIPTION: Sets up the database connection configuration in the Prisma schema file. Defines the database provider as SQL Server and uses an environment variable for the connection URL.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "sqlserver"
  url      = env("DATABASE_URL")
}

----------------------------------------

TITLE: GraphQL Resolver with Type Hints
DESCRIPTION: Enhanced GraphQL resolver with JSDoc type hints for proper autocompletion.

LANGUAGE: javascript
CODE:
/**
 * @param {any} parent
 * @param {{ searchString: string }} args
 * @param {{ prisma: Prisma }} ctx
 */
filterPosts: (parent, args, ctx) => {
  return ctx.prisma.post.findMany({
    where: {
      OR: [
        { title: { contains: args.searchString } },
        { content: { contains: args.searchString } },
      ],
    },
  })
}

----------------------------------------

TITLE: Creating Project Directory in Bash
DESCRIPTION: Commands to create a new project directory and navigate into it using the terminal.

LANGUAGE: bash
CODE:
mkdir hello-prisma
cd hello-prisma

----------------------------------------

TITLE: Creating a Table with Single Column CHECK Constraint in PostgreSQL
DESCRIPTION: This SQL snippet creates a 'product' table with a CHECK constraint on the 'price' column. It ensures the price is greater than 0.01 and not equal to 1240.00.

LANGUAGE: sql
CODE:
CREATE TABLE "public"."product" (
  price NUMERIC CONSTRAINT price_value_check CHECK (price > 0.01 AND price <> 1240.00)
);
ALTER TABLE "public"."product"
  ADD COLUMN "productid" serial,
  ADD PRIMARY KEY ("productid");

----------------------------------------

TITLE: Using the @@index attribute
DESCRIPTION: Defines an index in the database using the @@index attribute.

LANGUAGE: prisma
CODE:
model Post {
  id      Int     @id @default(autoincrement())
  title   String
  content String?

  @@index([title])
}

----------------------------------------

TITLE: CockroachDB Cloud Connection String Example
DESCRIPTION: Example connection string for CockroachDB Serverless or Dedicated hosted on CockroachDB Cloud, including SSL configuration.

LANGUAGE: bash
CODE:
DATABASE_URL="postgresql://<myusername>:<mypassword>@<short-id>.<region>.cockroachlabs.cloud:26257/defaultdb?sslmode=verify-full&sslrootcert=$HOME/.postgresql/root.crt&options=--<mycluster>"

----------------------------------------

TITLE: Final Contracted Prisma Schema
DESCRIPTION: Final schema after removing the old published field, completing the migration to the new status enum.

LANGUAGE: prisma
CODE:
model Post {
  id      Int      @id @default(autoincrement())
  title   String
  content String?
  status  Status   @default(Unknown)
}

enum Status {
  Draft
  InProgress
  InReview
  Published
}

----------------------------------------

TITLE: Initializing Prisma Schema
DESCRIPTION: Command to initialize the Prisma schema. This creates a new 'prisma' directory with a 'schema.prisma' file and a '.env' file in the root directory for environment variables.

LANGUAGE: bash
CODE:
npx prisma init

----------------------------------------

TITLE: Initializing Single Prisma Client Instance in Next.js
DESCRIPTION: Implementation of a singleton pattern for Prisma Client to prevent multiple instances during Next.js hot-reloading. Uses global variables to maintain a single client instance across development reloads.

LANGUAGE: typescript
CODE:
import { PrismaClient } from "@prisma/client";

const globalForPrisma = global as unknown as { prisma: PrismaClient };

export const prisma =
  globalForPrisma.prisma || new PrismaClient();

if (process.env.NODE_ENV !== "production") globalForPrisma.prisma = prisma;

----------------------------------------

TITLE: Generating Prisma Client for Local Development
DESCRIPTION: Generates Prisma Client artifacts for use with a local database in a development environment.

LANGUAGE: bash
CODE:
npx prisma generate

----------------------------------------

TITLE: Installing Prisma Client in TypeScript Project
DESCRIPTION: Command to install Prisma Client as a dependency in a TypeScript project.

LANGUAGE: bash
CODE:
npm install @prisma/client

----------------------------------------

TITLE: Updating Post Records
DESCRIPTION: Demonstrates how to update an existing Post record by setting its published status using Prisma Client's update method.

LANGUAGE: javascript
CODE:
async function main() {
  const post = await prisma.post.update({
    where: { id: 1 },
    data: { published: true },
  })
  console.log(post)
}

----------------------------------------

TITLE: Adding a CHECK Constraint to an Existing Table in PostgreSQL
DESCRIPTION: This SQL snippet demonstrates how to add a CHECK constraint to an existing table. It creates a 'lastproduct' table and then alters it to add a constraint ensuring the category is not 'clothing'.

LANGUAGE: sql
CODE:
CREATE TABLE "public"."lastproduct" (
  category TEXT
);

ALTER TABLE "public"."lastproduct"
  ADD CONSTRAINT "category_not_clothing" CHECK (category <> 'clothing');

----------------------------------------

TITLE: Initializing Migration History
DESCRIPTION: This command initializes the migration history after prototyping, creating an initial migration file.

LANGUAGE: bash
CODE:
npx prisma migrate dev --name initial-state

----------------------------------------

TITLE: Data Modeling in Prisma vs Drizzle
DESCRIPTION: Comparison of data modeling approaches between Prisma schema and Drizzle TypeScript definitions for User and Post models with relations.

LANGUAGE: prisma
CODE:
model User {
  id    Int     @id @default(autoincrement())
  name  String?
  email String  @unique
  posts Post[]
}

model Post {
  id        Int     @id @default(autoincrement())
  title     String
  content   String?
  published Boolean @default(false)
  authorId  Int?
  author    User?   @relation(fields: [authorId], references: [id])
}

LANGUAGE: typescript
CODE:
import {
  boolean,
  integer,
  pgTable,
  serial,
  text,
  uniqueIndex,
  varchar,
} from 'drizzle-orm/pg-core'

export const users = pgTable('users', {
  id: serial('id').primaryKey(),
  name: varchar('name', { length: 256 }),
  email: varchar('email', { length: 256 }).unique(),
})

export const posts = pgTable('posts', {
  id: serial('id').primaryKey(),
  title: varchar('title', { length: 256 }).notNull(),
  content: text('content'),
  published: boolean('published'),
  authorId: integer('author_id').references(() => users.id),
})

----------------------------------------

TITLE: Configuring Prisma Schema for MongoDB
DESCRIPTION: Initial Prisma schema configuration specifying MongoDB as the database provider and setting up the Prisma Client generator.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

----------------------------------------

TITLE: Querying Users with Prisma in Next.js Home Page
DESCRIPTION: Fetches all users from the database using Prisma Client and displays them in a list on the home page.

LANGUAGE: tsx
CODE:
import prisma from '@/lib/prisma'

export default async function Home() {
  const users = await prisma.user.findMany();
  return (
    <div className="min-h-screen bg-gray-50 flex flex-col items-center justify-center -mt-16">
      <h1 className="text-4xl font-bold mb-8 font-[family-name:var(--font-geist-sans)] text-[#333333]">
        Superblog
      </h1>
      <ol className="list-decimal list-inside font-[family-name:var(--font-geist-sans)]">
        {users.map((user) => (
          <li key={user.id} className="mb-2">
            {user.name}
          </li>
        ))}
      </ol>
    </div>
  );
}

----------------------------------------

TITLE: Documenting Step Results in Markdown
DESCRIPTION: Shows the correct way to document important step results with proper formatting and line breaks.

LANGUAGE: markdown
CODE:
<!-- Good -->

1. Click **Invite Member**.<br />
   Your team member receives an email with a link to join the project.

----------------------------------------

TITLE: Adding Prisma Client Generation Script to package.json
DESCRIPTION: This snippet demonstrates how to add a postinstall script to package.json to generate Prisma Client on Netlify deployment, ensuring the generated library is available on the deployed site.

LANGUAGE: json
CODE:
{
  // ...
  "scripts": {
    // ...
    // add-next-line
    "postinstall": "prisma generate --no-engine"
  }
  //
}

----------------------------------------

TITLE: Initializing Prisma Client in TypeScript
DESCRIPTION: Basic setup code for initializing PrismaClient and creating a main function for database operations. Includes error handling and proper connection management.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

async function main() {
  // ... you will write your Prisma Client queries here
}

main()
  .then(async () => {
    await prisma.$disconnect()
  })
  .catch(async (e) => {
    console.error(e)
    await prisma.$disconnect()
    process.exit(1)
  })

----------------------------------------

TITLE: Managing Workspaces in Prisma Data Platform
DESCRIPTION: Command to list all available workspaces for the authenticated user in the Prisma Data Platform.

LANGUAGE: bash
CODE:
npx prisma platform workspace show --early-access

----------------------------------------

TITLE: Invoking Prisma CLI
DESCRIPTION: Command to invoke the Prisma CLI using npx. This allows you to run Prisma commands in your project.

LANGUAGE: bash
CODE:
npx prisma

----------------------------------------

TITLE: Installing Prisma Client Package
DESCRIPTION: Command to install the @prisma/client package via npm. This is the first step in setting up Prisma Client in your project.

LANGUAGE: terminal
CODE:
npm install @prisma/client

----------------------------------------

TITLE: Complete GraphQL Schema with Typed Resolvers
DESCRIPTION: Full implementation of a GraphQL schema with typed resolvers using Prisma Client, including queries and mutations for a blog application.

LANGUAGE: javascript
CODE:
/**
 * @typedef { import("@prisma/client").PrismaClient } Prisma
 * @typedef { import("@prisma/client").UserCreateArgs } UserCreateArgs
 */

const { makeExecutableSchema } = require('graphql-tools')

const typeDefs = `
type User {
  email: String!
  id: ID!
  name: String
  posts: [Post!]!
}

type Post {
  author: User
  content: String
  id: ID!
  published: Boolean!
  title: String!
}


type Query {
  feed: [Post!]!
  filterPosts(searchString: String): [Post!]!
  post(where: PostWhereUniqueInput!): Post
}

type Mutation {
  createDraft(authorEmail: String, content: String, title: String!): Post!
  deleteOnePost(where: PostWhereUniqueInput!): Post
  publish(id: ID): Post
  signupUser(data: UserCreateInput!): User!
}

input PostWhereUniqueInput {
  id: ID
}

input UserCreateInput {
  email: String!
  id: ID
  name: String
  posts: PostCreateManyWithoutPostsInput
}

input PostCreateManyWithoutPostsInput {
  connect: [PostWhereUniqueInput!]
  create: [PostCreateWithoutAuthorInput!]
}

input PostCreateWithoutAuthorInput {
  content: String
  id: ID
  published: Boolean
  title: String!
}
`

const resolvers = {
  Query: {
    /**
     * @param {any} parent
     * @param {any} args
     * @param {{ prisma: Prisma }} ctx
     */
    feed: (parent, args, ctx) => {
      return ctx.prisma.post.findMany({
        where: { published: true },
      })
    },
    /**
     * @param {any} parent
     * @param {{ searchString: string }} args
     * @param {{ prisma: Prisma }} ctx
     */
    filterPosts: (parent, args, ctx) => {
      return ctx.prisma.post.findMany({
        where: {
          OR: [
            { title: { contains: args.searchString } },
            { content: { contains: args.searchString } },
          ],
        },
      })
    },
    /**
     * @param {any} parent
     * @param {{ where: { id: string }}} args
     * @param {{ prisma: Prisma }} ctx
     */
    post: (parent, args, ctx) => {
      return ctx.prisma.post.findUnique({
        where: { id: Number(args.where.id) },
      })
    },
  },
  Mutation: {
    /**
     * @param {any} parent
     * @param {{ title: string, content: string, authorEmail: (string|undefined) }} args
     * @param {{ prisma: Prisma }} ctx
     */
    createDraft: (parent, args, ctx) => {
      return ctx.prisma.post.create({
        data: {
          title: args.title,
          content: args.content,
          published: false,
          author: args.authorEmail && {
            connect: { email: args.authorEmail },
          },
        },
      })
    },
    /**
     * @param {any} parent
     * @param {{ where: { id: string }}} args
     * @param {{ prisma: Prisma }} ctx
     */
    deleteOnePost: (parent, args, ctx) => {
      return ctx.prisma.post.delete({
        where: { id: Number(args.where.id) },
      })
    },
    /**
     * @param {any} parent
     * @param {{ id: string }} args
     * @param {{ prisma: Prisma }} ctx
     */
    publish: (parent, args, ctx) => {
      return ctx.prisma.post.update({
        where: { id: Number(args.id) },
        data: { published: true },
      })
    },
    /**
     * @param {any} parent
     * @param {UserCreateArgs} args
     * @param {{ prisma: Prisma }} ctx
     */
    signupUser: (parent, args, ctx) => {
      return ctx.prisma.user.create(args)
    },
  },
  User: {
    /**
     * @param {{ id: number }} parent
     * @param {any} args
     * @param {{ prisma: Prisma }} ctx
     */
    posts: (parent, args, ctx) => {
      return ctx.prisma.user
        .findUnique({
          where: { id: parent.id },
        })
        .posts()
    },
  },
  Post: {
    /**
     * @param {{ id: number }} parent
     * @param {any} args
     * @param {{ prisma: Prisma }} ctx
     */
    author: (parent, args, ctx) => {
      return ctx.prisma.post
        .findUnique({
          where: { id: parent.id },
        })
        .author()
    },
  },
}

const schema = makeExecutableSchema({
  resolvers,
  typeDefs,
})

module.exports = {
  schema,
}

----------------------------------------

TITLE: Manually Loading Environment Variables in Prisma Config (TypeScript)
DESCRIPTION: This example shows how to manually load environment variables in the Prisma Config file using the 'dotenv' package. It imports 'dotenv/config' to enable access to environment variables via process.env.

LANGUAGE: typescript
CODE:
import "dotenv/config";

// now you can access env vars via:
// `process.env`
// for example:
// `process.env.DATABASE_URL`

----------------------------------------

TITLE: Authenticating with Prisma Data Platform CLI
DESCRIPTION: Commands for logging in, logging out, and displaying authentication information for the Prisma Data Platform CLI. Requires Prisma CLI version 5.10.0 or later and the --early-access flag.

LANGUAGE: bash
CODE:
npx prisma platform auth login --early-access

LANGUAGE: bash
CODE:
npx prisma platform auth logout --early-access

LANGUAGE: bash
CODE:
npx prisma platform auth show --early-access

----------------------------------------

TITLE: Error Example with Vercel/pkg Query Engine
DESCRIPTION: Example of the ENOENT error message that occurs when the Prisma query engine binary is not properly included in the packaged application.

LANGUAGE: plaintext
CODE:
spawn /snapshot/enoent-problem/node_modules/.prisma/client/query-engine-debian-openssl-1.1.x ENOENT

----------------------------------------

TITLE: MySQL AWS RDS Connection URL Example
DESCRIPTION: Example of a MySQL connection URL for a database hosted on AWS RDS with typical formatting.

LANGUAGE: bash
CODE:
DATABASE_URL="mysql://johndoe:XXX@mysqlinstance1.123456789012.us-east-1.rds.amazonaws.com:3306/mydb"

----------------------------------------

TITLE: Configuring Prisma Client with Accelerate Extension
DESCRIPTION: TypeScript code showing how to configure Prisma Client with the required Accelerate extension.

LANGUAGE: typescript
CODE:
import { withAccelerate } from '@prisma/extension-accelerate'

const prisma = new PrismaClient().$extends(withAccelerate())

----------------------------------------

TITLE: TypeScript Seeding Implementation
DESCRIPTION: TypeScript seed script using Prisma Client to create sample users and posts with upsert operations.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client'
const prisma = new PrismaClient()
async function main() {
  const alice = await prisma.user.upsert({
    where: { email: 'alice@prisma.io' },
    update: {},
    create: {
      email: 'alice@prisma.io',
      name: 'Alice',
      posts: {
        create: {
          title: 'Check out Prisma with Next.js',
          content: 'https://www.prisma.io/nextjs',
          published: true,
        },
      },
    },
  })
  console.log({ alice })
}
main()
  .then(async () => {
    await prisma.$disconnect()
  })
  .catch(async (e) => {
    console.error(e)
    await prisma.$disconnect()
    process.exit(1)
  })

----------------------------------------

TITLE: Comparing Numeric Columns with Raw Query in PostgreSQL/CockroachDB
DESCRIPTION: Execute a raw SQL query to compare likesCount and commentsCount columns in the Post table for PostgreSQL or CockroachDB.

LANGUAGE: javascript
CODE:
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

async function initiateNumbersComparisonRawQuery() {
  const response =
    await prisma.$queryRaw`SELECT * FROM "public"."Post" WHERE "likesCount" < "commentsCount";`

  console.log(response)
}

await initiateNumbersComparisonRawQuery()

----------------------------------------

TITLE: Comparing Mongoose and Prisma Client queries
DESCRIPTION: Shows examples of common database operations using Mongoose and their Prisma Client equivalents.

LANGUAGE: typescript
CODE:
// Mongoose
// Find one
const user = await User.findById(id);

// Create
const user = await User.create({
  email: 'alice@prisma.io',
  name: 'Alice'
});

// Update
await User.findByIdAndUpdate(id, { 
  name: 'New name' 
});

// Delete
await User.findByIdAndDelete(id);

// Prisma Client
// Find one
const user = await prisma.user.findUnique({ 
  where: { id } 
});

// Create
const user = await prisma.user.create({
  data: {
    email: 'alice@prisma.io',
    name: 'Alice'
  }
});

// Update
await prisma.user.update({
  where: { id },
  data: { name: 'New name' }
});

// Delete
await prisma.user.delete({
  where: { id }
});

----------------------------------------

TITLE: Turbo JSON Task Configuration
DESCRIPTION: Configuration for Turborepo tasks including database operations and build dependencies.

LANGUAGE: json
CODE:
{
  "tasks": {
    "dev": {
      "dependsOn": ["^db:generate"],
      "cache": false
    },
    "build": {
      "dependsOn": ["^db:generate"]
    }
  }
}

----------------------------------------

TITLE: Markdown Example for Version Number References
DESCRIPTION: This snippet demonstrates the correct way to refer to version numbers in Prisma documentation, using 'version' and 'later' terminology.

LANGUAGE: markdown
CODE:
<!-- Good -->

This feature is in Preview in versions 3.5.0 and later.

<!-- Bad -->

This feature is in Preview in v3.5.0 and higher.

----------------------------------------

TITLE: Defining Prisma Schema with User and Post Models
DESCRIPTION: This Prisma schema defines two models: User and Post, with a one-to-many relationship between them. It demonstrates the basic structure before applying named constraints.

LANGUAGE: prisma
CODE:
model User {
  id    Int    @id @default(autoincrement())
  name  String @unique
  posts Post[]
}

model Post {
  id         Int    @id @default(autoincrement())
  title      String
  authorName String @default("Anonymous")
  author     User?  @relation(fields: [authorName], references: [name])
}

----------------------------------------

TITLE: Comparing Numeric Columns with Raw Query in SQLite
DESCRIPTION: Execute a raw SQL query to compare likesCount and commentsCount columns in the Post table for SQLite.

LANGUAGE: javascript
CODE:
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

async function initiateNumbersComparisonRawQuery() {
  const response =
    await prisma.$queryRaw`SELECT * FROM "Post" WHERE "likesCount" < "commentsCount";`

  console.log(response)
}

await initiateNumbersComparisonRawQuery()

----------------------------------------

TITLE: Initializing Prisma Schema
DESCRIPTION: Creates the initial Prisma schema file and .env file for environment variables.

LANGUAGE: bash
CODE:
npx prisma init

----------------------------------------

TITLE: Installing Prisma Client package with npm
DESCRIPTION: Installs the @prisma/client package using npm. This package is required to use Prisma Client in your project.

LANGUAGE: bash
CODE:
npm install @prisma/client

----------------------------------------

TITLE: Creating Express.js Server with Prisma Client
DESCRIPTION: Sets up a basic Express.js server that uses Prisma Client to interact with the database. It includes a route to get the user count.

LANGUAGE: javascript
CODE:
const express = require("express");
const { PrismaClient } = require("./generated/prisma_client");

const app = express();
const prisma = new PrismaClient();
app.use(express.json());

// Get all users
app.get("/", async (req, res) => {
  const userCount = await prisma.user.count();
  res.json(
    userCount == 0
      ? "No users have been added yet."
      : "Sonme users have been added to the database."
  );
});

const PORT = 3000;

app.listen(PORT, () => {
  console.log(`Server is running on http://localhost:${PORT}`);
});

----------------------------------------

TITLE: Configuring PostgreSQL Connection in Prisma Schema
DESCRIPTION: Demonstrates how to set up a PostgreSQL database connection in the Prisma schema file. Includes connection parameters for user authentication, host, port, and database name.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "postgresql"
  url      = "postgresql://janedoe:mypassword@localhost:5432/mydb?schema=sample"
}

----------------------------------------

TITLE: Updating Prisma Schema with Tag Model and Relations
DESCRIPTION: This snippet shows the updated Prisma schema with a new 'Tag' model and a many-to-many relation between 'Post' and 'Tag'. It includes the existing 'Post', 'Profile', and 'User' models with the added 'tags' field in the 'Post' model.

LANGUAGE: prisma
CODE:
model Post {
  id        Int      @id @default(autoincrement())
  title     String   @db.VarChar(255)
  createdAt DateTime @default(now()) @db.Timestamp(6)
  content   String?
  published Boolean  @default(false)
  authorId  Int
  user      User     @relation(fields: [authorId], references: [id])
  tags      Tag[]
}

model Profile {
  id     Int     @id @default(autoincrement())
  bio    String?
  userId Int     @unique
  user   User    @relation(fields: [userId], references: [id])
}

model User {
  id      Int      @id @default(autoincrement())
  name    String?  @db.VarChar(255)
  email   String   @unique @db.VarChar(255)
  post    Post[]
  profile Profile?
}

model Tag {
  id    Int    @id @default(autoincrement())
  name  String
  posts Post[]
}

----------------------------------------

TITLE: Final Prisma Schema
DESCRIPTION: Updated schema with implicit relations removed after data migration.

LANGUAGE: prisma
CODE:
model User {
  id        Int        @id @default(autoincrement())
  name      String
  posts     Post[]
  userPosts UserPost[]
}

model Post {
  id        Int        @id @default(autoincrement())
  title     String
  authors   User[]
  userPosts UserPost[]
}

----------------------------------------

TITLE: Creating Project Directory
DESCRIPTION: Commands to create and navigate into a new project directory

LANGUAGE: bash
CODE:
mkdir hello-prisma
cd hello-prisma

----------------------------------------

TITLE: Setting Query Engine Binary Path in Environment File
DESCRIPTION: Example of setting custom query engine binary path in .env file for different operating systems

LANGUAGE: env
CODE:
PRISMA_QUERY_ENGINE_BINARY=custom/my-query-engine-unix

LANGUAGE: env
CODE:
PRISMA_QUERY_ENGINE_BINARY=c:\custom\path\my-query-engine-binary.exe

----------------------------------------

TITLE: Initial Prisma Schema Configuration
DESCRIPTION: Base Prisma schema configuration with a Post model containing basic fields including a boolean published flag.

LANGUAGE: prisma
CODE:
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Post {
  id        Int     @id @default(autoincrement())
  title     String
  content   String?
  published Boolean @default(false)
}

----------------------------------------

TITLE: Generating Prisma Client
DESCRIPTION: Command to generate Prisma Client based on the current schema.

LANGUAGE: bash
CODE:
npx prisma generate

----------------------------------------

TITLE: Generating Prisma Client library
DESCRIPTION: This command reads your Prisma schema and generates the Prisma Client library. It should be run after any changes to the schema.

LANGUAGE: terminal
CODE:
npx prisma generate

----------------------------------------

TITLE: Deleting Records with Prisma Client in TypeScript
DESCRIPTION: Example of deleting a record using Prisma Client, replacing a Drizzle delete query in a TypeScript application.

LANGUAGE: typescript
CODE:
import { revalidatePath } from "next/cache";

import { prisma } from "@/db/prisma";

export const deleteTodo = async (id: number) => {
  await prisma.todo.delete({ where: { id } });
  revalidatePath("/");
};

----------------------------------------

TITLE: Defining models with multiple cascade paths in Prisma
DESCRIPTION: This Prisma schema defines User, Post, and Comment models with relations that create multiple cascade paths between User and Comment. This configuration causes validation errors in SQL Server.

LANGUAGE: prisma
CODE:
model User {
  id       Int       @id @default(autoincrement())
  comments Comment[]
  posts    Post[]
}

model Post {
  id       Int       @id @default(autoincrement())
  authorId Int
  author   User      @relation(fields: [authorId], references: [id])
  comments Comment[]
}

model Comment {
  id          Int  @id @default(autoincrement())
  writtenById Int
  postId      Int
  writtenBy   User @relation(fields: [writtenById], references: [id])
  post        Post @relation(fields: [postId], references: [id])
}

----------------------------------------

TITLE: Adding Prisma Generate to Postinstall Script in package.json
DESCRIPTION: Adds a postinstall script to package.json that runs prisma generate. This ensures Prisma Client is generated after dependencies are installed, solving the caching issue on Vercel.

LANGUAGE: json
CODE:
{
  ...
  "scripts" {
    "postinstall": "prisma generate"
  }
  ...
}

----------------------------------------

TITLE: Configuring Prisma Schema for Edge Deployment
DESCRIPTION: Sets up the Prisma schema with the database URL as an environment variable and enables the driverAdapters preview feature.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "postgresql" // this might also be `mysql` or another value depending on your database
  url      = env("DATABASE_URL")
}

----------------------------------------

TITLE: Configuring Wrangler for D1 Connection
DESCRIPTION: Defines the Wrangler configuration file for connecting Workers with D1 database instance.

LANGUAGE: toml
CODE:
name = "prisma-cloudflare-worker-example"
main = "src/index.ts"
compatibility_date = "2024-03-20"
compatibility_flags = ["nodejs_compat"]

[[d1_databases]]
binding = "DB"
database_name = "__YOUR_D1_DATABASE_NAME__"
database_id = "__YOUR_D1_DATABASE_ID__"

----------------------------------------

TITLE: Writing Present Tense Documentation in Markdown
DESCRIPTION: Example demonstrating correct and incorrect usage of present tense in documentation writing.

LANGUAGE: markdown
CODE:
<!-- Good -->

When you run this command, Prisma writes the following log file.

<!-- Bad -->

When you run this command, Prisma will write the following log file.

----------------------------------------

TITLE: Creating Code Block with File Icon in MDX
DESCRIPTION: Demonstrates how to add a file icon to a code block using the 'file' attribute. This example shows a Prisma schema with a specified filename.

LANGUAGE: prisma
CODE:
```prisma file=schema.prisma
datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model Post {
  id        Int     @id @default(autoincrement())
  title     String
  content   String?
  published Boolean @default(false)
  author    User?   @relation(fields: [authorId], references: [id])
  authorId  Int?
}

model User {
  id    Int     @id @default(autoincrement())
  email String  @unique
  name  String?
  posts Post[]
}
```

----------------------------------------

TITLE: Generated SQL Migration for Tag Model
DESCRIPTION: SQL migration script that creates the Tag table and junction table _PostToTag for the many-to-many relationship between Post and Tag models. Includes foreign key constraints and indexes.

LANGUAGE: sql
CODE:
-- CreateTable
CREATE TABLE "Tag" (
    "id" SERIAL NOT NULL,
    "name" VARCHAR(255) NOT NULL,

    CONSTRAINT "Tag_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "_PostToTag" (
    "A" INTEGER NOT NULL,
    "B" INTEGER NOT NULL
);

-- CreateIndex
CREATE UNIQUE INDEX "_PostToTag_AB_unique" ON "_PostToTag"("A", "B");

-- CreateIndex
CREATE INDEX "_PostToTag_B_index" ON "_PostToTag"("B");

-- AddForeignKey
ALTER TABLE "_PostToTag" ADD CONSTRAINT "_PostToTag_A_fkey" FOREIGN KEY ("A") REFERENCES "Post"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "_PostToTag" ADD CONSTRAINT "_PostToTag_B_fkey" FOREIGN KEY ("B") REFERENCES "Tag"("id") ON DELETE CASCADE ON UPDATE CASCADE;

----------------------------------------

TITLE: Initializing Prisma configuration
DESCRIPTION: Creates a new Prisma schema file with database connection and client generator settings.

LANGUAGE: prisma
CODE:
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

----------------------------------------

TITLE: Defining Prisma Schema in MDX Code Block
DESCRIPTION: Illustrates how to represent a Prisma schema within an MDX code block. The schema includes datasource, generator, and model definitions for a basic blog application.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model Post {
  id        Int     @id @default(autoincrement())
  title     String
  content   String?
  published Boolean @default(false)
  author    User?   @relation(fields: [authorId], references: [id])
  authorId  Int?
}

model User {
  id    Int     @id @default(autoincrement())
  email String  @unique
  name  String?
  posts Post[]
}

----------------------------------------

TITLE: Installing Prisma Client Package
DESCRIPTION: Installs the @prisma/client package via npm which is required to use Prisma Client in your project.

LANGUAGE: terminal
CODE:
npm install @prisma/client

----------------------------------------

TITLE: Installing Prisma CLI in TypeScript Project
DESCRIPTION: Command to install the Prisma CLI as a development dependency in a TypeScript project.

LANGUAGE: bash
CODE:
npm install prisma --save-dev

----------------------------------------

TITLE: Configuring MySQL Connection in Prisma Schema
DESCRIPTION: Shows the configuration for connecting to a MySQL database using Prisma schema. Specifies the connection URL format with authentication credentials and database location.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "mysql"
  url      = "mysql://janedoe:mypassword@localhost:3306/mydb"
}

----------------------------------------

TITLE: Generated SQL Migration for Tag Model
DESCRIPTION: This SQL migration file is generated by Prisma Migrate based on the schema changes. It creates the Tag table, a junction table for the many-to-many relationship, and adds necessary indexes and foreign key constraints.

LANGUAGE: sql
CODE:
-- CreateTable
CREATE TABLE Tag (
    id SERIAL NOT NULL,
    name VARCHAR(255) NOT NULL,

    CONSTRAINT Tag_pkey PRIMARY KEY (id)
);

-- CreateTable
CREATE TABLE _PostToTag (
    A INTEGER NOT NULL,
    B INTEGER NOT NULL
);

-- CreateIndex
CREATE UNIQUE INDEX _PostToTag_AB_unique ON _PostToTag(A, B);

-- CreateIndex
CREATE INDEX _PostToTag_B_index ON _PostToTag(B);

-- AddForeignKey
ALTER TABLE _PostToTag ADD CONSTRAINT _PostToTag_A_fkey FOREIGN KEY (A) REFERENCES Post(id) ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE _PostToTag ADD CONSTRAINT _PostToTag_B_fkey FOREIGN KEY (B) REFERENCES Tag(id) ON DELETE CASCADE ON UPDATE CASCADE;

----------------------------------------

TITLE: Configuring Prisma Client Logging
DESCRIPTION: TypeScript code showing how to configure query logging in Prisma Client

LANGUAGE: typescript
CODE:
const prisma = new PrismaClient({
  log: ['query'],
})

----------------------------------------

TITLE: Enabling Prisma Client Debugging Output
DESCRIPTION: Sets the DEBUG environment variable to enable Prisma Client level debugging output.

LANGUAGE: terminal
CODE:
# enable only `prisma:client`-level debugging output
export DEBUG="prisma:client"

----------------------------------------

TITLE: Migrating createDraft mutation to Prisma Client
DESCRIPTION: Updates the createDraft mutation resolver to use Prisma Client create with nested connect for the author relation.

LANGUAGE: javascript
CODE:
const resolvers = {
  Mutation: {
    createDraft: (_, args, context, info) => {
      return context.prisma.post.create({
        data: {
          title: args.title,
          content: args.content,
          author: {
            connect: {
              id: args.authorId,
            },
          },
        },
      })
    },
  },
}

----------------------------------------

TITLE: Configuring Binary Targets in Prisma Schema for Node.js 16/18
DESCRIPTION: Prisma schema configuration for binary targets to ensure compatibility with Netlify's runtime environment for Node.js versions 16 and 18.

LANGUAGE: prisma
CODE:
binaryTargets = ["native", "rhel-openssl-1.0.x"]

----------------------------------------

TITLE: Initial Migration SQL Script for MySQL Database
DESCRIPTION: Generated SQL script that creates tables for Post, Profile, and User entities with their respective fields and constraints.

LANGUAGE: sql
CODE:
-- CreateTable
CREATE TABLE `Post` (
    `id` INTEGER NOT NULL AUTO_INCREMENT,
    `title` VARCHAR(255) NOT NULL,
    `createdAt` TIMESTAMP(0) NOT NULL DEFAULT CURRENT_TIMESTAMP(0),
    `content` TEXT NULL,
    `published` BOOLEAN NOT NULL DEFAULT false,
    `authorId` INTEGER NOT NULL,

    INDEX `authorId`(`authorId`),
    PRIMARY KEY (`id`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- CreateTable
CREATE TABLE `Profile` (
    `id` INTEGER NOT NULL AUTO_INCREMENT,
    `bio` TEXT NULL,
    `userId` INTEGER NOT NULL,

    UNIQUE INDEX `userId`(`userId`),
    PRIMARY KEY (`id`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- CreateTable
CREATE TABLE `User` (
    `id` INTEGER NOT NULL AUTO_INCREMENT,
    `name` VARCHAR(255) NULL,
    `email` VARCHAR(255) NOT NULL,

    UNIQUE INDEX `email`(`email`),
    PRIMARY KEY (`id`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- AddForeignKey
ALTER TABLE `Post` ADD CONSTRAINT `Post_ibfk_1` FOREIGN KEY (`authorId`) REFERENCES `User`(`id`) ON DELETE RESTRICT ON UPDATE RESTRICT;

-- AddForeignKey
ALTER TABLE `Profile` ADD CONSTRAINT `Profile_ibfk_1` FOREIGN KEY (`userId`) REFERENCES `User`(`id`) ON DELETE RESTRICT ON UPDATE RESTRICT;

----------------------------------------

TITLE: Defining cyclic relation between Chicken, Egg, and Fox models in Prisma
DESCRIPTION: This Prisma schema defines a cyclic relation between three models: Chicken, Egg, and Fox. This configuration will cause validation errors due to referential action cycles.

LANGUAGE: prisma
CODE:
model Chicken {
  id        Int   @id @default(autoincrement())
  egg       Egg   @relation(fields: [eggId], references: [id])
  eggId     Int
  predators Fox[]
}

model Egg {
  id         Int       @id @default(autoincrement())
  predator   Fox       @relation(fields: [predatorId], references: [id])
  predatorId Int
  parents    Chicken[]
}

model Fox {
  id        Int     @id @default(autoincrement())
  meal      Chicken @relation(fields: [mealId], references: [id])
  mealId    Int
  foodStore Egg[]
}

----------------------------------------

TITLE: Defining Prisma Model with VarChar Field
DESCRIPTION: Example of a Prisma schema model using @db.VarChar(n) native type on a String field, which is not recommended for PostgreSQL databases due to lack of performance benefits and potential content restrictions.

LANGUAGE: prisma
CODE:
model Item {
  // ...
  name String @db.VarChar(1)
  // ...
}

----------------------------------------

TITLE: Creating Dual PrismaClient Instances for Error Handling in JavaScript
DESCRIPTION: Code example showing how to create two PrismaClient instances - one using Accelerate connection and another using direct database connection for handling specific operations that might exceed query limits.

LANGUAGE: jsx
CODE:
export const prisma = new PrismaClient({
  datasourceUrl: process.env.DIRECT_DB_CONNECTION,
})

export const prismaAccelerate = new PrismaClient({
  datasourceUrl: process.env.ACCELERATE_CONNECTION,
}).$extends(withAccelerate())

----------------------------------------

TITLE: Creating User Table Migration SQL
DESCRIPTION: SQL migration script for creating the User table with required fields and constraints.

LANGUAGE: sql
CODE:
-- CreateTable
CREATE TABLE "User" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "email" TEXT NOT NULL,
    "name" TEXT
);

-- CreateIndex
CREATE UNIQUE INDEX "User_email_key" ON "User"("email");

----------------------------------------

TITLE: Handling Cache Invalidation Errors in Prisma
DESCRIPTION: This snippet demonstrates how to handle errors that may occur during cache invalidation in Prisma Accelerate. It specifically checks for the P6003 error code, which indicates that the cache invalidation rate limit has been reached.

LANGUAGE: typescript
CODE:
try {
  await prisma.$accelerate.invalidate({
    tags: ["emails_with_alice"],
  });
} catch (e) {
  if (e instanceof Prisma.PrismaClientKnownRequestError) {
    if (e.code === "P6003") {
      console.log(
        "The cache invalidation rate limit has been reached. Please try again later."
      );
    }
  }
  throw e;
}

----------------------------------------

TITLE: Configuring Preview Features in Prisma Schema
DESCRIPTION: Example showing how to enable preview features in the Prisma schema generator block using the previewFeatures parameter.

LANGUAGE: prisma
CODE:
generator client {
  provider        = "prisma-client-js"
  //highlight-next-line
  previewFeatures = ["namedConstraints"]
}

----------------------------------------

TITLE: Adding Tag Model to Prisma Schema
DESCRIPTION: Extends the existing Prisma schema by adding a Tag model with an ID and name field, plus establishing a many-to-many relationship with Posts. Also updates the Post model to include the tags relationship.

LANGUAGE: prisma
CODE:
model Post {
  id        Int      @id @default(autoincrement())
  title     String   @db.VarChar(255)
  createdAt DateTime @default(now()) @db.Timestamp(6)
  content   String?
  published Boolean  @default(false)
  authorId  Int
  user      User     @relation(fields: [authorId], references: [id])
  tags      Tag[]
}

model Profile {
  id     Int     @id @default(autoincrement())
  bio    String?
  userId Int     @unique
  user   User    @relation(fields: [userId], references: [id])
}

model User {
  id      Int      @id @default(autoincrement())
  name    String?  @db.VarChar(255)
  email   String   @unique @db.VarChar(255)
  post    Post[]
  profile Profile?
}

model Tag {
  id    Int    @id @default(autoincrement())
  name  String
  posts Post[]
}

----------------------------------------

TITLE: Deleting User Records
DESCRIPTION: Shows how to delete a User record using Prisma Client's delete method with email-based filtering.

LANGUAGE: javascript
CODE:
const deletedUser = await prisma.user.delete({
  where: { email: 'sarah@prisma.io' },
})

----------------------------------------

TITLE: Creating Terminal-styled Code Block in MDX
DESCRIPTION: Illustrates how to create a terminal-styled code block in MDX. This is useful for showing command-line instructions or outputs.

LANGUAGE: terminal
CODE:
```terminal
npm run dev
```

----------------------------------------

TITLE: Creating Related Tables with SQL
DESCRIPTION: SQL commands to create Profile and Post tables with foreign key relationships to User table.

LANGUAGE: sql
CODE:
CREATE TABLE "Profile" (
    id SERIAL PRIMARY KEY,
    bio TEXT NOT NULL,
    "user" integer NOT NULL UNIQUE,
    FOREIGN KEY ("user") REFERENCES "User"(id)
);
CREATE TABLE "Post" (
    id SERIAL PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    author integer NOT NULL,
    FOREIGN KEY (author) REFERENCES "User"(id)
);

----------------------------------------

TITLE: Creating Related Tables with SQL
DESCRIPTION: SQL commands to create Profile and Post tables with foreign key relationships to User table.

LANGUAGE: sql
CODE:
CREATE TABLE "Profile" (
    id SERIAL PRIMARY KEY,
    bio TEXT NOT NULL,
    "user" integer NOT NULL UNIQUE,
    FOREIGN KEY ("user") REFERENCES "User"(id)
);
CREATE TABLE "Post" (
    id SERIAL PRIMARY KEY,
    title VARCHAR(255) NOT NULL,
    author integer NOT NULL,
    FOREIGN KEY (author) REFERENCES "User"(id)
);

----------------------------------------

TITLE: Expanded Prisma Schema with Status Enum
DESCRIPTION: Updated schema that adds a new Status enum and status field while maintaining the existing published field as nullable.

LANGUAGE: prisma
CODE:
model Post {
  id        Int      @id @default(autoincrement())
  title     String
  content   String?
  published Boolean? @default(false)
  status    Status   @default(Unknown)
}

enum Status {
  Unknown
  Draft
  InProgress
  InReview
  Published
}

----------------------------------------

TITLE: Configuring Prisma Schema for SQL Server Connection
DESCRIPTION: This snippet shows how to set up the datasource block in the Prisma schema to connect to a SQL Server database. It uses an environment variable for the connection URL.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "sqlserver"
  url      = env("DATABASE_URL")
}

----------------------------------------

TITLE: Generated SQL Migration for Adding Tag Model
DESCRIPTION: This SQL migration script creates the 'Tag' table, a junction table '_PostToTag' for the many-to-many relationship, and adds necessary indexes and foreign key constraints.

LANGUAGE: sql
CODE:
-- CreateTable
CREATE TABLE Tag (
    id SERIAL NOT NULL,
    name VARCHAR(255) NOT NULL,

    CONSTRAINT Tag_pkey PRIMARY KEY (id)
);

-- CreateTable
CREATE TABLE _PostToTag (
    A INTEGER NOT NULL,
    B INTEGER NOT NULL
);

-- CreateIndex
CREATE UNIQUE INDEX _PostToTag_AB_unique ON _PostToTag(A, B);

-- CreateIndex
CREATE INDEX _PostToTag_B_index ON _PostToTag(B);

-- AddForeignKey
ALTER TABLE _PostToTag ADD CONSTRAINT _PostToTag_A_fkey FOREIGN KEY (A) REFERENCES Post(id) ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE _PostToTag ADD CONSTRAINT _PostToTag_B_fkey FOREIGN KEY (B) REFERENCES Tag(id) ON DELETE CASCADE ON UPDATE CASCADE;

----------------------------------------

TITLE: Unsetting a scalar list value in Prisma (MongoDB)
DESCRIPTION: Shows how to unset the value of a scalar list field 'coinflips' when creating a new User record in MongoDB using Prisma Client.

LANGUAGE: typescript
CODE:
const createdUser = await prisma.user.create({
  data: {
    email: 'eloise@prisma.io',
    coinflips: {
      unset: true,
    },
  },
})

----------------------------------------

TITLE: Implementing TopBlock Component in MDX
DESCRIPTION: Demonstrates how to use the TopBlock component at the beginning of a page to avoid styling issues. It wraps introductory content.

LANGUAGE: markdown
CODE:
<TopBlock>

This page describes how to use [MDX](https://mdxjs.com/) components (e.g. code blocks) in the Prisma docs.

Components not listed here are part of the [Docusaurus Markdown features](https://docusaurus.io/docs/markdown-features)

</TopBlock>

----------------------------------------

TITLE: Enabling postgresqlExtensions Preview Feature in Prisma Schema
DESCRIPTION: Add the postgresqlExtensions feature flag to the previewFeatures field of the generator block in the Prisma schema to enable PostgreSQL extension support.

LANGUAGE: prisma
CODE:
generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

----------------------------------------

TITLE: Migrating posts query to Prisma Client
DESCRIPTION: Updates the posts query resolver to use Prisma Client findMany with a custom where condition for searching.

LANGUAGE: javascript
CODE:
const resolvers = {
  Query: {
    posts: (_, args, context) => {
      return context.prisma.post.findMany({
        where: {
          OR: [
            { title: { contains: args.searchString } },
            { content: { contains: args.searchString } },
          ],
        },
      })
    },
  },
}

----------------------------------------

TITLE: Local CockroachDB connection string example
DESCRIPTION: This snippet provides an example of a connection string for a locally hosted CockroachDB instance. It uses the root user and disables SSL for local development purposes.

LANGUAGE: bash
CODE:
DATABASE_URL="postgresql://root@localhost:26257?sslmode=disable"

----------------------------------------

TITLE: Marking Migration as Applied with Prisma CLI
DESCRIPTION: Prisma CLI command to mark the initial migration as applied in the database.

LANGUAGE: bash
CODE:
npx prisma migrate resolve --applied 0_init

----------------------------------------

TITLE: Overfetching Example in Prisma Query with TypeScript
DESCRIPTION: Example of a Prisma query that demonstrates overfetching by retrieving all fields from the User model and including all fields from related links. This query pattern can lead to performance issues by fetching unnecessary data.

LANGUAGE: typescript
CODE:
await prisma.user.findMany({
  where: {
    email: { contains: "gmail" },
  },
  include: {
    links: true,
  },
});

----------------------------------------

TITLE: Using functions for default values in Prisma
DESCRIPTION: Example of using built-in functions to specify default values for fields in Prisma models.

LANGUAGE: prisma
CODE:
model Post {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
}

----------------------------------------

TITLE: React Component Usage Example
DESCRIPTION: Example of using React components to create a grid of link cards for navigation and a list of supported databases with logos.

LANGUAGE: jsx
CODE:
<Grid>
  <LinkCard
    icon="fa-solid fa-arrow-right"
    title="Get started"
    desc="Start analyzing the prisma queries in your app in 5 minutes."
    link="/optimize/getting-started"
  />
  <LinkCard
    icon="fa-brands fa-github"
    title="Examples"
    desc="Explore our ready-to-run examples using Optimize."
    link="https://github.com/prisma/prisma-examples?tab=readme-ov-file#prisma-optimize"
  />
</Grid>

----------------------------------------

TITLE: Initializing TypeScript Configuration
DESCRIPTION: Initializes TypeScript configuration for the project.

LANGUAGE: shell
CODE:
npx tsc --init

----------------------------------------

TITLE: Querying Data with Prisma Client in TypeScript
DESCRIPTION: Example of querying data using Prisma Client, replacing a Drizzle query in a TypeScript application.

LANGUAGE: typescript
CODE:
import { prisma } from "@/db/prisma";

export const getData = async () => {
  const data = await prisma.todo.findMany();
  return data;
};

----------------------------------------

TITLE: Extending Prisma Client with Accelerate Extension
DESCRIPTION: This code snippet shows how to extend the Prisma Client instance with the Accelerate extension for regular and edge runtimes.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client'
import { withAccelerate } from '@prisma/extension-accelerate'

const prisma = new PrismaClient().$extends(withAccelerate())

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client/edge'
import { withAccelerate } from '@prisma/extension-accelerate'

const prisma = new PrismaClient().$extends(withAccelerate())

----------------------------------------

TITLE: Installing Prisma Client via NPM
DESCRIPTION: Command to install the @prisma/client package which automatically triggers prisma generate to create a client tailored to your models. This needs to be run in your project directory.

LANGUAGE: terminal
CODE:
npm install @prisma/client

----------------------------------------

TITLE: Applying Prisma Schema Changes with Migrate Dev
DESCRIPTION: This command uses Prisma Migrate to create a new migration, apply it to the database, and regenerate the Prisma Client. It names the migration 'tags-model'.

LANGUAGE: bash
CODE:
npx prisma migrate dev --name tags-model

----------------------------------------

TITLE: Adding a Custom Field to User Query Results in Prisma Client
DESCRIPTION: Demonstrates how to add a custom 'fullName' field to the user model query results using Prisma Client extensions. The field is computed at runtime by combining firstName and lastName.

LANGUAGE: typescript
CODE:
const prisma = new PrismaClient().$extends({
  result: {
    user: {
      fullName: {
        // the dependencies
        needs: { firstName: true, lastName: true },
        compute(user) {
          // the computation logic
          return `${user.firstName} ${user.lastName}`
        },
      },
    },
  },
})

const user = await prisma.user.findFirst()

// return the user's full name, such as "John Doe"
console.log(user.fullName)

----------------------------------------

TITLE: Demonstrating Prisma Client Model Properties in JavaScript
DESCRIPTION: This snippet shows how to use model properties in Prisma Client queries. It demonstrates accessing the 'user' and 'post' models.

LANGUAGE: javascript
CODE:
const result = await prisma.user.findMany(...) // "user" model property
const result = await prisma.post.findMany(...) // "post" model property

----------------------------------------

TITLE: Installing Prisma CLI with Package Managers
DESCRIPTION: Commands for installing Prisma CLI as a development dependency using different package managers (npm, yarn, pnpm, bun).

LANGUAGE: bash
CODE:
npm install prisma --save-dev

LANGUAGE: bash
CODE:
yarn add prisma --dev

LANGUAGE: bash
CODE:
pnpm install prisma --save-dev

LANGUAGE: bash
CODE:
bun add prisma

----------------------------------------

TITLE: Extending Prisma Client with Optimize
DESCRIPTION: TypeScript implementation for extending Prisma Client with the Optimize extension using the API key.

LANGUAGE: typescript
CODE:
import { PrismaClient } from "@prisma/client";
import { withOptimize } from "@prisma/extension-optimize";

const prisma = new PrismaClient().$extends(
  withOptimize({ apiKey: process.env.OPTIMIZE_API_KEY }),
);

----------------------------------------

TITLE: Running Prisma Migration Command
DESCRIPTION: CLI command to create and run a new database migration. The command creates an SQL migration file and executes it against the database. It also automatically runs the prisma generate command if prisma-client-js generator is defined.

LANGUAGE: terminal
CODE:
npx prisma migrate dev --name init

----------------------------------------

TITLE: Updating Prisma Schema with Tag Model
DESCRIPTION: Prisma schema file showing the addition of a new Tag model and establishing many-to-many relationship with Post model. Includes field definitions for id, name, and relationship fields.

LANGUAGE: prisma
CODE:
model Post {
  id        Int      @id @default(autoincrement())
  title     String   @db.VarChar(255)
  createdAt DateTime @default(now()) @db.Timestamp(6)
  content   String?
  published Boolean  @default(false)
  authorId  Int
  user      User     @relation(fields: [authorId], references: [id])
  tags      Tag[]
}

model Profile {
  id     Int     @id @default(autoincrement())
  bio    String?
  userId Int     @unique
  user   User    @relation(fields: [userId], references: [id])
}

model User {
  id      Int      @id @default(autoincrement())
  name    String?  @db.VarChar(255)
  email   String   @unique @db.VarChar(255)
  post    Post[]
  profile Profile?
}

model Tag {
  id    Int    @id @default(autoincrement())
  name  String
  posts Post[]
}

----------------------------------------

TITLE: Configuring Search Exclusion in YAML Front Matter
DESCRIPTION: This snippet demonstrates how to exclude a page from search results using YAML front matter. It sets the 'search' property to false.

LANGUAGE: yaml
CODE:
search: false

----------------------------------------

TITLE: Mapping Tables with Same Names in Different Schemas in Prisma
DESCRIPTION: This snippet illustrates how to map tables with the same name in different database schemas to unique model names in the Prisma schema using the @@map attribute.

LANGUAGE: prisma
CODE:
model BaseConfig {
  id Int @id

  @@map("config")
  @@schema("base")
}

model UserConfig {
  id Int @id

  @@map("config")
  @@schema("users")
}

----------------------------------------

TITLE: Installing Prisma CLI as Development Dependency
DESCRIPTION: Adds the Prisma CLI to the project as a development dependency using npm. This allows using Prisma commands with npx.

LANGUAGE: bash
CODE:
npm install prisma --save-dev

----------------------------------------

TITLE: Querying CURRENT_TIME with Prisma Raw Query
DESCRIPTION: Example of using Prisma's $queryRaw to execute a raw SQL query that retrieves the current time. This approach is discouraged as CURRENT_TIME only returns the time portion without date information and uses the problematic timetz type.

LANGUAGE: typescript
CODE:
prisma.$queryRaw`SELECT CURRENT_TIME;`

----------------------------------------

TITLE: Creating PostgreSQL Database Schema
DESCRIPTION: SQL commands to create three related tables (User, Post, Profile) with primary keys, foreign keys, and various column constraints.

LANGUAGE: sql
CODE:
CREATE TABLE "public"."User" (
  id SERIAL PRIMARY KEY NOT NULL,
  name VARCHAR(255),
  email VARCHAR(255) UNIQUE NOT NULL
);

CREATE TABLE "public"."Post" (
  id SERIAL PRIMARY KEY NOT NULL,
  title VARCHAR(255) NOT NULL,
  "createdAt" TIMESTAMP NOT NULL DEFAULT now(),
  content TEXT,
  published BOOLEAN NOT NULL DEFAULT false,
  "authorId" INTEGER NOT NULL,
  FOREIGN KEY ("authorId") REFERENCES "public"."User"(id)
);

CREATE TABLE "public"."Profile" (
  id SERIAL PRIMARY KEY NOT NULL,
  bio TEXT,
  "userId" INTEGER UNIQUE NOT NULL,
  FOREIGN KEY ("userId") REFERENCES "public"."User"(id)
);

----------------------------------------

TITLE: Using Prisma CLI with Multi-file Schema Directory
DESCRIPTION: Demonstrates how to use Prisma CLI commands with a multi-file schema setup, specifying a directory instead of a single file.

LANGUAGE: terminal
CODE:
npx prisma db push --schema custom/path/to/my/schema

----------------------------------------

TITLE: Running Prisma Migration Commands
DESCRIPTION: Terminal commands for executing Prisma migrations in a team environment.

LANGUAGE: terminal
CODE:
npx prisma migrate dev

----------------------------------------

TITLE: Modified Prisma Schema with Team Changes
DESCRIPTION: Updated Prisma schema incorporating changes from multiple team members, including new fields and models.

LANGUAGE: prisma
CODE:
model Post {
  id        Int     @id @default(autoincrement())
  title     String
  content   String?
  published Boolean @default(false)
  author    User?   @relation(fields: [authorId], references: [id])
  authorId  Int?
}

model User {
  id              Int     @id @default(autoincrement())
  email           String  @unique
  name            String?
  favoriteColor   String?
  bestPacmanScore Int?
  posts           Post[]
}

model Tag {
  tagName     String   @id
  tagCategory Category
}

----------------------------------------

TITLE: Defining Implicit Many-to-Many Relations in Prisma Schema
DESCRIPTION: Example of defining an implicit many-to-many relation in a Prisma schema, demonstrating a more concise approach compared to Drizzle.

LANGUAGE: prisma
CODE:
model Post {
  id         Int        @id @default(autoincrement())
  title      String
  content    String?
  published  Boolean    @default(false)
  categories Category[]
}

model Category {
  id    Int    @id @default(autoincrement())
  name  String
  posts Post[]
}

----------------------------------------

TITLE: Setting Database URL Environment Variable
DESCRIPTION: Commands for setting the DATABASE_URL environment variable across different operating systems to connect to Prisma Postgres.

LANGUAGE: terminal
CODE:
export DATABASE_URL="prisma+postgres://accelerate.prisma-data.net/?api_key=API_KEY"

LANGUAGE: cmd
CODE:
set DATABASE_URL="prisma+postgres://accelerate.prisma-data.net/?api_key=API_KEY"

----------------------------------------

TITLE: Updating a Post Record with Prisma Client in TypeScript
DESCRIPTION: Demonstrates how to update an existing Post record by changing its published status using Prisma Client's update method.

LANGUAGE: typescript
CODE:
async function main() {
  const post = await prisma.post.update({
    where: { id: 1 },
    data: { published: true },
  })
  console.log(post)
}

----------------------------------------

TITLE: Installing TypeScript and Prisma Dependencies
DESCRIPTION: npm commands to initialize a TypeScript project and install required dependencies including Prisma CLI, TypeScript, tsx, and Node.js types.

LANGUAGE: bash
CODE:
npm init -y
npm install prisma typescript tsx @types/node --save-dev

----------------------------------------

TITLE: Markdown Examples for Clear Hyperlinks
DESCRIPTION: These snippets demonstrate best practices for creating clear and meaningful hyperlinks in Prisma documentation, avoiding phrases like 'click here'.

LANGUAGE: markdown
CODE:
<!-- Good -->

Read more in the [Prisma ORM docs](/orm)

<!-- Bad -->

Read more in the Prisma ORM docs [here](/orm)

LANGUAGE: markdown
CODE:
<!-- Good -->

For more information, see [Relation queries](/orm/prisma-client/queries/relation-queries).

<!-- Bad -->

For more information, see [Relation Queries](/orm/prisma-client/queries/relation-queries).

LANGUAGE: markdown
CODE:
[Learn more](/orm/prisma-client/queries/relation-queries)

----------------------------------------

TITLE: Installing Prisma Extension Package with NPM
DESCRIPTION: Command to install a shared Prisma Client extension package from npm registry.

LANGUAGE: bash
CODE:
npm install prisma-extension-<package-name>

----------------------------------------

TITLE: Configuring Prisma Schema with Tracing Feature
DESCRIPTION: Schema configuration required for enabling tracing in Prisma ORM versions 4.2.0 to 6.1.0.

LANGUAGE: prisma
CODE:
generator client {
  provider = "prisma-client-js"
  previewFeatures = ["tracing"]
}

----------------------------------------

TITLE: Installing Prisma Client via npm
DESCRIPTION: This command installs the @prisma/client package and automatically invokes prisma generate to create a tailored version of Prisma Client based on your models.

LANGUAGE: terminal
CODE:
npm install @prisma/client

----------------------------------------

TITLE: Creating Migration Directory in Bash
DESCRIPTION: Command to create a nested directory structure for the initial migration using mkdir.

LANGUAGE: bash
CODE:
mkdir -p prisma/migrations/0_init

----------------------------------------

TITLE: Initializing Prisma Project Structure
DESCRIPTION: Command to initialize Prisma project by creating the schema file and environment configuration.

LANGUAGE: bash
CODE:
npx prisma init

----------------------------------------

TITLE: Interactive Transaction Example in TypeScript
DESCRIPTION: Demonstrates how to use interactive transactions in Prisma Accelerate with multiple database operations. Each operation within the transaction is counted as a separate billable query.

LANGUAGE: typescript
CODE:
await prisma.$transaction(async (tx) => {
  await tx.user.deleteMany({ where: { name: 'John Doe' } });
  await tx.user.createMany({ data });
});

----------------------------------------

TITLE: Creating Posts with Tags using Prisma Client
DESCRIPTION: TypeScript example showing how to create a post with associated tags using Prisma Client's create operation.

LANGUAGE: typescript
CODE:
await prisma.post.create({
  data: {
    title: 'Types of relations',
    tags: { create: [{ name: 'dev' }, { name: 'prisma' }] },
  },
})

----------------------------------------

TITLE: Initializing Prisma Project
DESCRIPTION: Creates a new Prisma schema file and .env file for environment variables using the Prisma CLI init command.

LANGUAGE: bash
CODE:
npx prisma init

----------------------------------------

TITLE: Creating Project Directory for Prisma ORM Setup
DESCRIPTION: Commands to create a new project directory and navigate into it for setting up a Prisma ORM project.

LANGUAGE: bash
CODE:
mkdir hello-prisma
cd hello-prisma

----------------------------------------

TITLE: Updated Prisma Schema with Relation Fields
DESCRIPTION: This Prisma schema includes manually added relation fields to represent the relationships between Post, Profile, and User models. It defines one-to-many and one-to-one relationships.

LANGUAGE: prisma
CODE:
model Post {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime
  title     String   @db.VarChar(255)
  content   String?
  published Boolean  @default(false)
  author    User     @relation(fields: [authorId], references: [id])
  authorId  Int

  @@index([authorId])
}

model Profile {
  id     Int     @id @default(autoincrement())
  bio    String?
  user   User    @relation(fields: [userId], references: [id])
  userId Int     @unique

  @@index([userId])
}

model User {
  id      Int      @id @default(autoincrement())
  email   String   @unique
  name    String?
  posts   Post[]
  profile Profile?
}

----------------------------------------

TITLE: Implementing Parallel Blocks in MDX
DESCRIPTION: Demonstrates how to create parallel code blocks for comparison using the ParallelBlocks component. This example compares Prisma and TypeORM code snippets.

LANGUAGE: markdown
CODE:
<ParallelBlocks>

<block content="Prisma">

```ts
const posts = await postRepository.find({
  where: {
    title: 'Hello World',
  },
})
```

</block>

<block content="TypeORM">

```ts
const posts = await postRepository.find({
  where: {
    title: ILike('Hello World'),
  },
})
```

</block>

</ParallelBlocks>

----------------------------------------

TITLE: PrismaClient Instance Configuration
DESCRIPTION: TypeScript configuration for creating and exporting a singleton PrismaClient instance.

LANGUAGE: typescript
CODE:
import { PrismaClient } from "../generated/client";

const globalForPrisma = global as unknown as { prisma: PrismaClient };

export const prisma =
  globalForPrisma.prisma || new PrismaClient();

if (process.env.NODE_ENV !== "production") globalForPrisma.prisma = prisma;

----------------------------------------

TITLE: Implementing Express Controller with Prisma Client
DESCRIPTION: Example of updating an Express controller to use Prisma Client for user creation

LANGUAGE: typescript
CODE:
import { prisma } from '../client'

export class CreateUserAction {
  async run(req: Request, res: Response) {
    const { email, name } = req.body
    
    const result = await prisma.user.create({
      data: {
        email,
        name,
      },
    })
    
    return res.json(result)
  }
}

----------------------------------------

TITLE: Creating Project Directory for Prisma Node.js Application
DESCRIPTION: Creates a new directory for the Prisma project and navigates into it using terminal commands.

LANGUAGE: Terminal
CODE:
mkdir hello-prisma
cd hello-prisma

----------------------------------------

TITLE: Inserting Full-width Images in MDX
DESCRIPTION: Demonstrates how to insert a full-width image in an MDX file using the shorter image component syntax.

LANGUAGE: markdown
CODE:
![Alt text](./peer-file.png)

----------------------------------------

TITLE: Setting DATABASE_URL Environment Variable
DESCRIPTION: Commands to export the Prisma Postgres connection string as an environment variable across different operating systems. The connection string includes the API key for authentication.

LANGUAGE: terminal
CODE:
export DATABASE_URL="prisma+postgres://accelerate.prisma-data.net/?api_key=API_KEY"

LANGUAGE: terminal
CODE:
set DATABASE_URL="prisma+postgres://accelerate.prisma-data.net/?api_key=API_KEY"

----------------------------------------

TITLE: Creating Migration Directory in Bash
DESCRIPTION: Creates a nested directory structure for the initial migration using the mkdir command with the -p flag for recursive creation.

LANGUAGE: bash
CODE:
mkdir -p prisma/migrations/0_init

----------------------------------------

TITLE: Connecting to PlanetScale Database Using CLI
DESCRIPTION: This snippet shows an alternative method to connect to a PlanetScale database using the PlanetScale CLI. It includes the command to establish a connection and the corresponding local connection URL format.

LANGUAGE: bash
CODE:
DATABASE_URL="mysql://root@localhost:PORT/mydb"

LANGUAGE: bash
CODE:
pscale connect prisma-test branchname --port PORT

----------------------------------------

TITLE: Importing Prisma Client for Edge Functions
DESCRIPTION: Demonstrates how to import Prisma Client specifically for use in edge function environments, such as Vercel's edge runtime.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client/edge'

----------------------------------------

TITLE: Initializing New Nuxt Project
DESCRIPTION: Command to create a new Nuxt project using npx

LANGUAGE: terminal
CODE:
npx nuxi@latest init hello-world

----------------------------------------

TITLE: Including Subsections Component in Prisma Documentation
DESCRIPTION: This snippet demonstrates how to include a Subsections component in the Prisma documentation. The component is configured to display subsections up to a depth of 3.

LANGUAGE: markdown
CODE:
<Subsections depth="3" />

----------------------------------------

TITLE: Updating a Record with Prisma Client
DESCRIPTION: Demonstrates how to update an existing Post record by changing its published status using Prisma Client's update method.

LANGUAGE: typescript
CODE:
async function main() {
  const post = await prisma.post.update({
    where: { id: 1 },
    data: { published: true },
  })
  console.log(post)
}

----------------------------------------

TITLE: Refined Prisma Schema
DESCRIPTION: An improved version of the Prisma schema with renamed relation fields to adhere to Prisma's naming conventions and improve API ergonomics.

LANGUAGE: prisma
CODE:
model Post {
  id        Int      @id @default(autoincrement())
  title     String   @db.VarChar(255)
  createdAt DateTime @default(now()) @db.Timestamp(0)
  content   String?  @db.Text
  published Boolean  @default(false)
  authorId  Int
  author    User     @relation(fields: [authorId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "Post_ibfk_1")

  @@index([authorId], map: "authorId")
}

model Profile {
  id     Int     @id @default(autoincrement())
  bio    String? @db.Text
  userId Int     @unique(map: "userId")
  user   User    @relation(fields: [userId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "Profile_ibfk_1")
}

model User {
  id      Int      @id @default(autoincrement())
  name    String?  @db.VarChar(255)
  email   String   @unique(map: "email") @db.VarChar(255)
  posts   Post[]
  profile Profile?
}

----------------------------------------

TITLE: Invoking Prisma CLI
DESCRIPTION: Demonstrates how to run the Prisma CLI using npx prefix.

LANGUAGE: terminal
CODE:
npx prisma

----------------------------------------

TITLE: Installing Prisma Client with npm
DESCRIPTION: This command installs the @prisma/client package and automatically invokes prisma generate to create a version of Prisma Client tailored to your models based on your Prisma schema.

LANGUAGE: shell
CODE:
npm install @prisma/client

----------------------------------------

TITLE: Express Integration with Prisma Middleware
DESCRIPTION: Demonstrates correct placement of Prisma middleware in an Express application context, showing middleware should be added outside request handlers.

LANGUAGE: typescript
CODE:
import express from 'express'
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

prisma.$use(async (params, next) => {
  // Manipulate params here
  const result = await next(params)
  // See results here
  return result
})

const app = express()
app.get('/feed', async (req, res) => {
  // NO MIDDLEWARE HERE
  const posts = await prisma.post.findMany({
    where: { published: true },
    include: { author: true },
  })
  res.json(posts)
})

----------------------------------------

TITLE: TypeScript Error Example - Invalid Type Building
DESCRIPTION: Example of a TypeScript error that occurs when using an outdated TypeScript version with @prisma/client. The error shows type-checking issues in the Prisma Client type definitions.

LANGUAGE: typescript
CODE:
./node_modules/.prisma/client/index.d.ts:10:33
Type error: Type expected.
   8 | export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
   9 | type UnwrapTuple<Tuple extends readonly unknown[]> = {
> 10 |   [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : never : never
     |                                 ^
  11 | };
  12 |
  13 |

----------------------------------------

TITLE: Adjusted Prisma schema with renamed relation fields
DESCRIPTION: This Prisma schema shows the adjustments made to follow Prisma's naming conventions and improve the semantics of relation fields. The virtual relation fields are renamed without affecting the database structure.

LANGUAGE: prisma
CODE:
model Post {
  id        Int      @id @default(autoincrement())
  title     String   @db.VarChar(255)
  createdAt DateTime @default(now()) @db.Timestamp(6)
  content   String?
  published Boolean  @default(false)
  author    User     @relation(fields: [authorId], references: [id])
  authorId  Int
}

model Profile {
  id     Int     @id @default(autoincrement())
  bio    String?
  user   User    @relation(fields: [userId], references: [id])
  userId Int     @unique
}

model User {
  id      Int      @id @default(autoincrement())
  email   String   @unique @db.VarChar(255)
  name    String?  @db.VarChar(255)
  posts   Post[]
  profile Profile?
}

----------------------------------------

TITLE: Initializing PrismaClient in TypeScript
DESCRIPTION: Code to initialize and export a PrismaClient instance for use in TypeScript applications.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client'

export const prisma = new PrismaClient()

----------------------------------------

TITLE: Updating Express controller to use Prisma Client
DESCRIPTION: Shows how to modify an Express controller to use Prisma Client for database operations instead of Sequelize.

LANGUAGE: typescript
CODE:
import { prisma } from '../client'

export class UserController {
  async create(req: Request, res: Response) {
    const { email, name } = req.body
    
    const result = await prisma.user.create({
      data: {
        email,
        name,
      },
    })
    
    return res.json(result)
  }
}

----------------------------------------

TITLE: Creating a Squashed Migration in Development
DESCRIPTION: This command creates a new migration that combines all changes from the feature branch into a single migration file. It takes the state from the main branch and applies all changes to match the current schema.

LANGUAGE: bash
CODE:
npx prisma migrate dev --name squashed_migrations

----------------------------------------

TITLE: Configuring Prisma Accelerate in Prisma Data Platform
DESCRIPTION: Commands for enabling and disabling Prisma Accelerate for a specified environment. Enabling requires environment ID, database URL, and optional region and API key generation. Disabling only requires environment ID.

LANGUAGE: bash
CODE:
npx prisma platform accelerate enable \
--environment $INSERT_ENVIRONMENT_ID \
--url "postgresql://username:password@host:port/database" \
--region $INSERT_CONNECTION_POOL_REGION \
--apikey true \
--early-access

LANGUAGE: bash
CODE:
npx prisma platform accelerate disable \
--environment $INSERT_ENVIRONMENT_ID \
--early-access

----------------------------------------

TITLE: Configuring Prisma ORM Data Source for PostgreSQL
DESCRIPTION: This Prisma schema snippet sets up the data source configuration for connecting to a PostgreSQL database using an environment variable for the connection URL.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

----------------------------------------

TITLE: Adjusted Prisma Schema with Improved Naming Conventions
DESCRIPTION: This Prisma schema shows the adjusted version after manual modifications to improve naming conventions. Relation field names have been changed to be more idiomatic and follow Prisma's conventions.

LANGUAGE: prisma
CODE:
model Post {
  id        BigInt   @id @default(autoincrement())
  title     String   @unique @db.String(255)
  createdAt DateTime @default(now()) @db.Timestamp(6)
  content   String?
  published Boolean  @default(false)
  authorId  BigInt
  author    User     @relation(fields: [authorId], references: [id], onDelete: NoAction, onUpdate: NoAction)
}

model Profile {
  id     BigInt  @id @default(autoincrement())
  bio    String?
  userId BigInt  @unique
  user   User    @relation(fields: [userId], references: [id], onDelete: NoAction, onUpdate: NoAction)
}

model User {
  id      BigInt   @id @default(autoincrement())
  name    String?  @db.String(255)
  email   String   @unique @db.String(255)
  posts   Post[]
  profile Profile?
}

----------------------------------------

TITLE: Initializing Prisma Project
DESCRIPTION: Creates the initial Prisma schema file and environment configuration. This command generates a prisma directory with schema.prisma file and a .env file for database connection variables.

LANGUAGE: terminal
CODE:
npx prisma init

----------------------------------------

TITLE: AccelerateInfo Interface Definition
DESCRIPTION: TypeScript interface definition for AccelerateInfo, detailing the structure of cache response information including status, timestamps, and request details.

LANGUAGE: typescript
CODE:
interface AccelerateInfo {
  cacheStatus: 'ttl' | 'swr' | 'miss' | 'none'
  lastModified: Date
  region: string
  requestId: string
  signature: string
}

----------------------------------------

TITLE: Configuring Wide Layout in YAML Front Matter
DESCRIPTION: This snippet shows how to enable a wider page layout using YAML front matter. It sets the 'wide' property to true, which increases the content width to 988px.

LANGUAGE: yaml
CODE:
wide: true

----------------------------------------

TITLE: Inserting Resized Images in MDX using HTML
DESCRIPTION: Shows how to insert and resize an image in an MDX file using the HTML img tag with width attribute. This method is used when image resizing is needed.

LANGUAGE: html
CODE:
<img
  src={require("./images/snagit-text-annotation-config.png").default}
  alt="SnagIt - Screenshot text annotations"
  width="250"
/>

----------------------------------------

TITLE: Updating Post with Comments using Prisma Client in TypeScript
DESCRIPTION: This code demonstrates how to update a Post record by adding comments using Prisma Client, and then query all Posts including their comments.

LANGUAGE: typescript
CODE:
async function main() {
  await prisma.post.update({
    where: {
      slug: 'my-first-post',
    },
    data: {
      comments: {
        createMany: {
          data: [
            { comment: 'Great post!' },
            { comment: "Can't wait to read more!" },
          ],
        },
      },
    },
  })
  const posts = await prisma.post.findMany({
    include: {
      comments: true,
    },
  })

  console.dir(posts, { depth: Infinity })
}

----------------------------------------

TITLE: Running Prisma Introspection Command
DESCRIPTION: Terminal command to introspect the database using Prisma CLI. This command reads the DATABASE_URL from the .env file and generates a Prisma schema based on the existing database structure.

LANGUAGE: bash
CODE:
npx prisma db pull

----------------------------------------

TITLE: Defining Prisma Model with Timestamp(0) and Timestamptz(0)
DESCRIPTION: Example showing problematic timestamp precision definitions in a User model. The model uses @db.Timestamp(0) and @db.Timestamptz(0) which can cause rounding issues where times are rounded to the nearest second, potentially affecting data accuracy.

LANGUAGE: prisma
CODE:
model User {
  // ...
  date DateTime @db.Timestamp(0)
  deletedAt DateTime @db.Timestamptz(0)
  // ...
}

----------------------------------------

TITLE: Defining Model Field with @db.Char(n) in Prisma Schema
DESCRIPTION: Example showing how to define a field using the @db.Char(n) native type in a Prisma model. This pattern is generally discouraged due to PostgreSQL's space-padding behavior and lack of optimization for fixed-length character fields.

LANGUAGE: prisma
CODE:
model Item {
  // ...
  name String @db.Char(1)
  // ...
}

----------------------------------------

TITLE: Using Accelerate with Cache Strategy in Prisma Queries
DESCRIPTION: This snippet demonstrates how to use the Accelerate extension with a cache strategy in a Prisma query to improve performance.

LANGUAGE: typescript
CODE:
const user = await prisma.user.findMany({
  where: {
    email: {
      contains: 'alice@prisma.io',
    },
  },
  cacheStrategy: { swr: 60, ttl: 60 },
})

----------------------------------------

TITLE: Inserting JsonNull into JSON Field in Prisma Client
DESCRIPTION: This snippet shows how to insert a JSON null value into a JSON field using Prisma.JsonNull in a create operation with Prisma Client.

LANGUAGE: typescript
CODE:
import { Prisma } from '@prisma/client'

prisma.log.create({
  data: {
    meta: Prisma.JsonNull,
  },
})

----------------------------------------

TITLE: Creating Project Directory
DESCRIPTION: Commands to create and navigate into the project directory for the Prisma application.

LANGUAGE: terminal
CODE:
mkdir hello-prisma
cd hello-prisma

----------------------------------------

TITLE: Creating MySQL Tables for User, Post, and Profile
DESCRIPTION: SQL commands to create three tables (User, Post, and Profile) with appropriate columns and relationships.

LANGUAGE: sql
CODE:
CREATE TABLE User (
  id INTEGER PRIMARY KEY AUTO_INCREMENT NOT NULL,
  name VARCHAR(255),
  email VARCHAR(255) UNIQUE NOT NULL
);

CREATE TABLE Post (
  id INTEGER PRIMARY KEY AUTO_INCREMENT NOT NULL,
  title VARCHAR(255) NOT NULL,
  createdAt TIMESTAMP NOT NULL DEFAULT now(),
  content TEXT,
  published BOOLEAN NOT NULL DEFAULT false,
  authorId INTEGER NOT NULL,
  FOREIGN KEY (authorId) REFERENCES User(id)
);

CREATE TABLE Profile (
  id INTEGER PRIMARY KEY AUTO_INCREMENT NOT NULL,
  bio TEXT,
  userId INTEGER UNIQUE NOT NULL,
  FOREIGN KEY (userId) REFERENCES User(id)
);

----------------------------------------

TITLE: Writing TypeScript Query Examples in Prisma
DESCRIPTION: Example showing the recommended way to structure Prisma query examples using constants for better reference.

LANGUAGE: typescript
CODE:
const aggregations = await prisma.user.aggregate({
  ...
})

----------------------------------------

TITLE: Configuring Prisma Datasource for PostgreSQL
DESCRIPTION: Prisma schema configuration for connecting to a PostgreSQL database using an environment variable.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

----------------------------------------

TITLE: Creating Prisma Migration Baseline
DESCRIPTION: Commands to create a baseline migration for an existing database schema.

LANGUAGE: bash
CODE:
mkdir -p prisma/migrations/0_init

npx prisma migrate diff --from-empty --to-schema-datamodel prisma/schema.prisma --script > prisma/migrations/0_init/migration.sql

npx prisma migrate resolve --applied 0_init

----------------------------------------

TITLE: Running Prisma 1 Upgrade CLI
DESCRIPTION: Use the Prisma 1 Upgrade CLI to resolve schema incompatibilities between Prisma 1 and Prisma ORM 2.

LANGUAGE: bash
CODE:
npx prisma-upgrade prisma1/prisma.yml prisma/schema.prisma

----------------------------------------

TITLE: Managing Environments in Prisma Data Platform
DESCRIPTION: Commands for listing, creating, and deleting environments within a specified project in the Prisma Data Platform. Requires project ID for creation and environment ID for deletion.

LANGUAGE: bash
CODE:
npx prisma platform environment show \
--project $INSERT_PROJECT_ID \
--early-access

LANGUAGE: bash
CODE:
npx prisma platform environment create \
--project $INSERT_PROJECT_ID \
--name $INSERT_ENVIRONMENT_NAME \
--early-access

LANGUAGE: bash
CODE:
npx prisma platform environment delete \
--environment $INSERT_ENVIRONMENT_ID \
--early-access

----------------------------------------

TITLE: Package.json Configuration for Prisma Assets
DESCRIPTION: Configuration to add the Prisma query engine binary path to the pkg/assets section of package.json to resolve the ENOENT error.

LANGUAGE: json
CODE:
{
  "pkg": {
    "assets": ["node_modules/.prisma/client/*.node"]
  }
}

----------------------------------------

TITLE: Local PostgreSQL Connection Example
DESCRIPTION: Illustrates a typical local PostgreSQL connection URL format for macOS users, where database credentials match the OS user.

LANGUAGE: bash
CODE:
DATABASE_URL="postgresql://janedoe:janedoe@localhost:5432/janedoe?schema=hello-prisma"

----------------------------------------

TITLE: Optimized Prisma Schema with Renamed Relations
DESCRIPTION: The refined Prisma schema with properly named relation fields following Prisma's naming conventions for better API ergonomics.

LANGUAGE: prisma
CODE:
model Post {
  id        Int      @id @default(autoincrement())
  title     String   @db.VarChar(255)
  createdAt DateTime @default(now()) @db.Timestamp(6)
  content   String?
  published Boolean  @default(false)
  authorId  Int
  author    User     @relation(fields: [authorId], references: [id], onDelete: NoAction, onUpdate: NoAction)
}

model Profile {
  id     Int     @id @default(autoincrement())
  bio    String?
  userId Int     @unique
  user   User    @relation(fields: [userId], references: [id], onDelete: NoAction, onUpdate: NoAction)
}

model User {
  id      Int      @id @default(autoincrement())
  name    String?  @db.VarChar(255)
  email   String   @unique @db.VarChar(255)
  posts   Post[]
  profile Profile?
}

----------------------------------------

TITLE: Defining Prisma Model with BLOB Storage
DESCRIPTION: Example Prisma schema showing how to define a User model with direct image storage using the Bytes type. This demonstrates a pattern that should generally be avoided due to performance implications.

LANGUAGE: prisma
CODE:
model User {
  id    Int    @id @default(autoincrement())
  name  String?
  // Storing raw image data directly in the database
  avatarBytes Bytes?
}

----------------------------------------

TITLE: Querying and Displaying User Records with Next.js and Prisma
DESCRIPTION: This code snippet demonstrates how to use Prisma Client in a Next.js page component to query User records from the database and display them in a list.

LANGUAGE: javascript
CODE:
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient();

export default async function Page() {
  const users = await prisma.user.findMany();

  return (
    <main className="p-8">
      <h1 className="text-2xl font-bold mb-4">Users</h1>
      <ul className="space-y-2">
        {users.length > 0 ? (
          users.map(user => (
            <li key={user.id} className="p-4 border rounded shadow-sm">
              <p><strong>ID:</strong> {user.id}</p>
              <p><strong>Name:</strong> {user.name || 'N/A'}</p>
              <p><strong>Email:</strong> {user.email}</p>
            </li>
          ))
        ) : (
          <p>No users found.</p>
        )}
      </ul>
    </main>
  );
}

----------------------------------------

TITLE: React Component Import Declaration
DESCRIPTION: Import statement for React components used in the getting started guide documentation page.

LANGUAGE: JavaScript
CODE:
import {
  Bolt,
  BorderBox,
  BoxTitle,
  Inspect,
  Database,
  Grid,
  LinkCard,
  List,
  SignalStream,
  PrismaPostgres,
  SquareLogo,
} from '@site/src/components/GettingStarted';

----------------------------------------

TITLE: Filtering Posts with Prisma Client
DESCRIPTION: Demonstrates how to query Post records containing specific text using Prisma Client's findMany method with OR conditions.

LANGUAGE: javascript
CODE:
const filteredPosts = await prisma.post.findMany({
  where: {
    OR: [{ title: { contains: 'hello' } }, { body: { contains: 'hello' } }],
  },
})

----------------------------------------

TITLE: Initializing Prisma Schema for SQL Server Project
DESCRIPTION: Command to initialize the Prisma schema file. This creates a prisma directory with a schema.prisma file and a .env file in the project root for environment variables.

LANGUAGE: bash
CODE:
npx prisma init

----------------------------------------

TITLE: Installing mdtool Documentation Management Utility
DESCRIPTION: Installation commands for mdtool, a utility for managing documentation file ordering and organization. Requires wget to be installed first.

LANGUAGE: bash
CODE:
brew install wget

LANGUAGE: bash
CODE:
wget https://gist.githubusercontent.com/steebchen/bd085ebde1fcf4242e3fdd0df4d202a6/raw/c04e3d262eb6a302a9fab98f6428fec9329681e2/mdtool -qO /usr/local/bin/mdtool
chmod +x /usr/local/bin/mdtool

----------------------------------------

TITLE: Implementing Stale-While-Revalidate Caching in Prisma Accelerate
DESCRIPTION: This snippet demonstrates how to use the stale-while-revalidate caching strategy in Prisma Accelerate. It shows how to set a cache policy directly in the query, allowing for fine-grained control over caching behavior.

LANGUAGE: jsx
CODE:
await prisma.user.findMany({
  cacheStrategy: {
    swr: 60,
  },
});

----------------------------------------

TITLE: Installing Prisma Client
DESCRIPTION: Install Prisma Client after upgrading the Prisma schema.

LANGUAGE: bash
CODE:
npm install @prisma/client

----------------------------------------

TITLE: Documenting UI Actions in Markdown
DESCRIPTION: Examples showing correct and incorrect ways to document UI status changes and actions using Markdown formatting.

LANGUAGE: markdown
CODE:
<!-- Bad -->

The status changes to **Completed**.

<!-- Good -->

From **Status**, select **Completed**.

----------------------------------------

TITLE: Generated Prisma Schema after Introspection
DESCRIPTION: The Prisma schema generated after running 'prisma db pull' command, showing the data model with relations between User, Post, and Profile models.

LANGUAGE: prisma
CODE:
model Post {
  id        BigInt   @id @default(autoincrement())
  title     String   @unique @db.String(255)
  createdAt DateTime @default(now()) @db.Timestamp(6)
  content   String?
  published Boolean  @default(false)
  authorId  BigInt
  author    User     @relation(fields: [authorId], references: [id], onDelete: NoAction, onUpdate: NoAction)
}

model Profile {
  id     BigInt  @id @default(autoincrement())
  bio    String?
  userId BigInt  @unique
  user   User    @relation(fields: [userId], references: [id], onDelete: NoAction, onUpdate: NoAction)
}

model User {
  id      BigInt   @id @default(autoincrement())
  name    String?  @db.String(255)
  email   String   @unique @db.String(255)
  posts   Post[]
  profile Profile?
}

----------------------------------------

TITLE: Initializing Prisma Schema in TypeScript Project
DESCRIPTION: Command to create a basic Prisma schema file in a TypeScript project.

LANGUAGE: bash
CODE:
npx prisma init

----------------------------------------

TITLE: Initializing pnpm Workspace Structure
DESCRIPTION: Commands to create the initial monorepo directory structure and initialize a Node.js project.

LANGUAGE: terminal
CODE:
mkdir my-monorepo
cd my-monorepo
pnpm init

----------------------------------------

TITLE: Using compound ID in connectOrCreate in Prisma Client
DESCRIPTION: This TypeScript snippet shows how to use a compound ID in a connectOrCreate operation in a Prisma Client query. It attempts to connect an existing Like record or create a new one when creating a User.

LANGUAGE: typescript
CODE:
await prisma.user.create({
  data: {
    name: 'Alice',
    likes: {
      connectOrCreate: {
        create: {
          postId: 1,
        },
        where: {
          likeId: {
            postId: 1,
            userId: 1,
          },
        },
      },
    },
  },
})

----------------------------------------

TITLE: Managing API Keys in Prisma Data Platform
DESCRIPTION: Commands for listing, creating, and deleting API keys for a specified environment in the Prisma Data Platform. Requires environment ID for listing and creation, and API key ID for deletion.

LANGUAGE: bash
CODE:
npx prisma platform apikey show \
--environment $INSERT_ENVIRONMENT_ID \
--early-access

LANGUAGE: bash
CODE:
npx prisma platform apikey create \
--environment $INSERT_ENVIRONMENT_ID \
--name $INSERT_API_KEY_NAME \
--early-access

LANGUAGE: bash
CODE:
npx prisma platform apikey delete \
--apikey $INSERT_API_KEY_ID \
--early-access

----------------------------------------

TITLE: Creating a PostgreSQL relation table with unique index
DESCRIPTION: SQL commands to create a relation table for an implicit many-to-many relationship in PostgreSQL, using a unique index on columns A and B.

LANGUAGE: sql
CODE:
-- CreateTable
CREATE TABLE "_PostToTag" (
    "A" INTEGER NOT NULL,
    "B" INTEGER NOT NULL
);

-- CreateIndex
CREATE UNIQUE INDEX "_PostToTag_AB_unique" ON "_PostToTag"("A", "B");

-- CreateIndex
CREATE INDEX "_PostToTag_B_index" ON "_PostToTag"("B");

-- AddForeignKey
ALTER TABLE "_PostToTag" ADD CONSTRAINT "_PostToTag_A_fkey" FOREIGN KEY ("A") REFERENCES "Post"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "_PostToTag" ADD CONSTRAINT "_PostToTag_B_fkey" FOREIGN KEY ("B") REFERENCES "Tag"("id") ON DELETE CASCADE ON UPDATE CASCADE;

----------------------------------------

TITLE: Initializing Prisma Project
DESCRIPTION: Command to initialize a new Prisma project by creating the schema file and environment configuration. Creates a prisma directory with schema.prisma file and a .env file in the root directory.

LANGUAGE: terminal
CODE:
npx prisma init

----------------------------------------

TITLE: Custom Index Names for Prisma Client API
DESCRIPTION: Shows how to customize the Prisma Client API using the name argument in @@id and @@unique attributes, with TypeScript example.

LANGUAGE: typescript
CODE:
const user = await prisma.user.findUnique({
  where: {
    fullName: {
      firstName: 'Paul',
      lastName: 'Panther',
    },
  },
})

----------------------------------------

TITLE: Combining Optimize with Accelerate Extension
DESCRIPTION: Example showing how to combine Prisma Optimize with the Accelerate extension in the correct order.

LANGUAGE: typescript
CODE:
const prisma = new PrismaClient().$extends(withOptimize()).$extends(withAccelerate())

----------------------------------------

TITLE: Installing Prisma ORM 2 CLI
DESCRIPTION: Install the Prisma ORM 2 CLI as a development dependency in your Node.js project.

LANGUAGE: bash
CODE:
npm install prisma --save-dev

----------------------------------------

TITLE: Creating Nested Records with Prisma Client
DESCRIPTION: Example showing how to create related records using nested writes, creating a user with an associated post in a single query.

LANGUAGE: typescript
CODE:
async function main() {
  await prisma.user.create({
    data: {
      name: 'Rich',
      email: 'hello@prisma.com',
      posts: {
        create: {
          title: 'My first post',
          body: 'Lots of really interesting stuff',
          slug: 'my-first-post',
        },
      },
    },
  })

  const allUsers = await prisma.user.findMany({
    include: {
      posts: true,
    },
  })
  console.dir(allUsers, { depth: null })
}

----------------------------------------

TITLE: Generated SQL Migration for Tag Model
DESCRIPTION: SQL migration script that creates the Tag table and establishes a many-to-many relationship with Posts through a junction table _PostToTag. Includes primary key constraints, indexes, and foreign key relationships.

LANGUAGE: sql
CODE:
-- CreateTable
CREATE TABLE "Tag" (
    "id" SERIAL NOT NULL,
    "name" VARCHAR(255) NOT NULL,

    CONSTRAINT "Tag_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "_PostToTag" (
    "A" INTEGER NOT NULL,
    "B" INTEGER NOT NULL
);

-- CreateIndex
CREATE UNIQUE INDEX "_PostToTag_AB_unique" ON "_PostToTag"("A", "B");

-- CreateIndex
CREATE INDEX "_PostToTag_B_index" ON "_PostToTag"("B");

-- AddForeignKey
ALTER TABLE "_PostToTag" ADD CONSTRAINT "_PostToTag_A_fkey" FOREIGN KEY ("A") REFERENCES "Post"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "_PostToTag" ADD CONSTRAINT "_PostToTag_B_fkey" FOREIGN KEY ("B") REFERENCES "Tag"("id") ON DELETE CASCADE ON UPDATE CASCADE;

----------------------------------------

TITLE: Invoking Prisma CLI
DESCRIPTION: This command demonstrates how to invoke the Prisma CLI using npx after installation. It's used to run Prisma commands in your project.

LANGUAGE: bash
CODE:
npx prisma

----------------------------------------

TITLE: Configuring database connection
DESCRIPTION: Configure the DATABASE_URL environment variable in the .env file to connect to your MySQL database.

LANGUAGE: bash
CODE:
DATABASE_URL="mysql://root:randompassword@localhost:3306/myproject@dev"

----------------------------------------

TITLE: Creating a Table with Multi-Column CHECK Constraint in PostgreSQL
DESCRIPTION: This SQL snippet creates an 'anotherproduct' table with a CHECK constraint comparing the 'reducedprice' and 'price' columns. It ensures the reduced price is always less than the regular price.

LANGUAGE: sql
CODE:
CREATE TABLE "public"."anotherproduct" (
  reducedprice NUMERIC CONSTRAINT reduced_price_check CHECK (price > reducedprice),
  price NUMERIC
);
ALTER TABLE "public"."anotherproduct"
  ADD COLUMN "productid" serial,
  ADD PRIMARY KEY ("productid");

----------------------------------------

TITLE: Running Prisma Init with DB Flag
DESCRIPTION: Example of running prisma init command with the --db flag and its updated version to resolve caching issues.

LANGUAGE: terminal
CODE:
npx prisma init --db

LANGUAGE: terminal
CODE:
npx prisma@latest init --db

----------------------------------------

TITLE: Importing Environment Variables to Netlify
DESCRIPTION: Command for importing environment variables from .env file to Netlify using the Netlify CLI.

LANGUAGE: terminal
CODE:
netlify env:import .env

----------------------------------------

TITLE: Invoking Prisma CLI
DESCRIPTION: Basic command to invoke the Prisma CLI using npx prefix.

LANGUAGE: terminal
CODE:
npx prisma

----------------------------------------

TITLE: Configuring Prisma Database Source
DESCRIPTION: Defines the database connection configuration in the Prisma schema file using an environment variable for the connection URL. Specifies PostgreSQL as the database provider.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

----------------------------------------

TITLE: Installing Prisma Client via npm for MongoDB and JavaScript
DESCRIPTION: This command installs the @prisma/client package, which automatically invokes prisma generate to create a version of Prisma Client tailored to your models based on your Prisma schema.

LANGUAGE: terminal
CODE:
npm install @prisma/client

----------------------------------------

TITLE: Installing Prisma Client
DESCRIPTION: Installs the Prisma Client package and generates the client.

LANGUAGE: shell
CODE:
npm install @prisma/client
npx prisma generate

----------------------------------------

TITLE: Configuring pnpm Workspace
DESCRIPTION: YAML configuration for pnpm workspace structure defining packages directory layout and Prisma version pinning.

LANGUAGE: yaml
CODE:
packages:
  - "apps/*"
  - "packages/*"
catalogs:
  prisma:
    prisma: latest

----------------------------------------

TITLE: Running Prisma Migrate to Create Database Schema
DESCRIPTION: This command generates a new SQL migration file and applies it to the database, creating the tables defined in the Prisma schema.

LANGUAGE: bash
CODE:
npx prisma migrate dev --name init

----------------------------------------

TITLE: Sequential Transaction Operations in TypeScript
DESCRIPTION: Shows how to perform sequential transaction operations that count as a single billable query regardless of the number of operations. This approach is more cost-effective and performs better than interactive transactions.

LANGUAGE: typescript
CODE:
await prisma.$transaction([
  prisma.user.deleteMany({ where: { name: 'John Doe' } }),
  prisma.user.createMany({ data }),
]);

----------------------------------------

TITLE: Updating Prisma packages to v6 using bun
DESCRIPTION: Commands to update both the prisma and @prisma/client packages to version 6 using bun.

LANGUAGE: bash
CODE:
bun add @prisma/client@6
bun add prisma@6 --dev

----------------------------------------

TITLE: Restoring Backup to GA Database with pg_restore
DESCRIPTION: Command to restore the database backup to the new GA database using pg_restore through the secure tunnel.

LANGUAGE: bash
CODE:
PGSSLMODE=disable \
pg_restore \
  -h 127.0.0.1 \
  -p 5432 \
  -v \
  -d postgres \
  ./mydatabase.bak \
&& echo "-complete-"

----------------------------------------

TITLE: One-to-One Relations with Explicit Unique Constraints
DESCRIPTION: Example demonstrating the required explicit @unique attribute for one-to-one relations in Prisma ORM 4.

LANGUAGE: prisma
CODE:
model User {
  id        Int      @id @default(autoincrement())
  profile   Profile? @relation(fields: [profileId], references: [id])
  profileId Int?     @unique
}

model Profile {
  id   Int   @id @default(autoincrement())
  user User?
}

----------------------------------------

TITLE: Comparing Date Columns with Raw Query in MySQL
DESCRIPTION: Execute a raw SQL query to compare completedDate and dueDate columns in the Project table for MySQL.

LANGUAGE: javascript
CODE:
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

async function initiateDatesComparisonRawQuery() {
  const response =
    await prisma.$queryRaw`SELECT * FROM \`public\`.\`Project\` WHERE \`completedDate\` > \`dueDate\`;`

  console.log(response)
}

await initiateDatesComparisonRawQuery()

----------------------------------------

TITLE: mdtool Usage Examples
DESCRIPTION: Example commands demonstrating the usage of mdtool for inserting, swapping, moving and removing documentation files while maintaining proper ordering.

LANGUAGE: bash
CODE:
mdtool insert 3
mdtool swap A B
mdtool move A B
mdtool remove 4

----------------------------------------

TITLE: Setting MongoDB Connection Environment Variable
DESCRIPTION: Example of setting the MongoDB connection URL in the .env file, including credentials and database name.

LANGUAGE: bash
CODE:
DATABASE_URL="mongodb+srv://test:test@cluster0.ns1yp.mongodb.net/myFirstDatabase"

----------------------------------------

TITLE: Adding Tag Model and Relationship to Prisma Schema
DESCRIPTION: This snippet shows how to add a new 'Tag' model to the Prisma schema and create a many-to-many relationship with the 'Post' model. It includes the full schema with highlighted changes.

LANGUAGE: prisma
CODE:
model Post {
  id        Int      @id @default(autoincrement())
  title     String   @db.VarChar(255)
  createdAt DateTime @default(now()) @db.Timestamp(6)
  content   String?
  published Boolean  @default(false)
  authorId  Int
  user      User     @relation(fields: [authorId], references: [id])
  tags      Tag[]
}

model Profile {
  id     Int     @id @default(autoincrement())
  bio    String?
  userId Int     @unique
  user   User    @relation(fields: [userId], references: [id])
}

model User {
  id      Int      @id @default(autoincrement())
  name    String?  @db.VarChar(255)
  email   String   @unique @db.VarChar(255)
  post    Post[]
  profile Profile?
}

model Tag {
  id    Int    @id @default(autoincrement())
  name  String
  posts Post[]
}

----------------------------------------

TITLE: Initializing Prisma Project
DESCRIPTION: Command to initialize Prisma project, creating the schema file and environment configuration.

LANGUAGE: terminal
CODE:
npx prisma init

----------------------------------------

TITLE: Database Migration Commands for Prisma
DESCRIPTION: Terminal commands for creating and applying baseline database migrations

LANGUAGE: bash
CODE:
npx prisma migrate diff --from-empty --to-schema-datamodel prisma/schema.prisma --script > baseline.sql
npx prisma migrate resolve --applied "baseline"

----------------------------------------

TITLE: Defining Prisma Data Models
DESCRIPTION: Defines three interconnected data models (Post, Profile, User) with relationships and field definitions. Uses BigInt for IDs with sequence generation, and includes timestamps, optional fields, and relationship mappings.

LANGUAGE: prisma
CODE:
model Post {
  id        BigInt   @id @default(sequence())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  title     String   
  content   String?
  published Boolean  @default(false)
  author    User     @relation(fields: [authorId], references: [id])
  authorId  BigInt
}

model Profile {
  id     BigInt  @id @default(sequence())
  bio    String?
  user   User    @relation(fields: [userId], references: [id])
  userId BigInt  @unique
}

model User {
  id      BigInt   @id @default(sequence())
  email   String   @unique
  name    String?
  posts   Post[]
  profile Profile?
}

----------------------------------------

TITLE: Configuring Dockerfile for Node.js Application
DESCRIPTION: Creates a Dockerfile for the Node.js application using Alpine Linux as the base image. It sets up the working directory, copies necessary files, installs dependencies, and specifies the command to run the application.

LANGUAGE: dockerfile
CODE:
FROM node:lts-alpine3.17

WORKDIR /usr/src/app

COPY package.json package-lock.json ./

RUN npm ci

COPY . .

CMD ["sh", "-c", "npm run db:deploy && npm run dev"]

----------------------------------------

TITLE: Local CockroachDB connection string example
DESCRIPTION: Example of a connection string for a locally hosted CockroachDB instance. Uses the root user and disables SSL for local development.

LANGUAGE: bash
CODE:
DATABASE_URL="postgresql://root@localhost:26257?sslmode=disable"

----------------------------------------

TITLE: Querying User Model with LIKE Operations in Prisma (JavaScript)
DESCRIPTION: This snippet demonstrates a Prisma query using 'contains' and 'endsWith' operators, which translate to LIKE and ILIKE SQL operators. These operations can lead to full table scans, potentially causing performance issues with larger datasets.

LANGUAGE: jsx
CODE:
await prisma.user.findMany({ 
  where: { 
    email: { contains: "gmail.com" }, 
    name: { endsWith: "Burk" } 
  } 
})

----------------------------------------

TITLE: Next.js Page Implementation
DESCRIPTION: Example Next.js page component demonstrating Prisma Client usage from the shared database package.

LANGUAGE: tsx
CODE:
import { prisma } from "database";

export default async function Home() {
  const user = await prisma.user.findFirst({
    select: {
      name: true
    }
  })

  return (
    <div>
      {user?.name && <p>Hello from {user.name}</p>}
      {!user?.name && <p>No user has been added to the database yet. </p>}
    </div>
  );
}

----------------------------------------

TITLE: Defining a scalar list field in Prisma schema (MongoDB)
DESCRIPTION: Shows how to define a scalar String list field named 'pets' in a Prisma schema for MongoDB.

LANGUAGE: prisma
CODE:
model User {
  id   String   @id @default(auto()) @map("_id") @db.ObjectId
  name String
  pets String[]
}

----------------------------------------

TITLE: Setting up Prisma Client with Accelerate Extension
DESCRIPTION: Configures Prisma Client with the Accelerate client extension, allowing seamless use in both development and production environments.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client'
import { withAccelerate } from '@prisma/extension-accelerate'

const prisma = new PrismaClient().$extends(withAccelerate())

----------------------------------------

TITLE: Updating Prisma packages to v6 using yarn
DESCRIPTION: Command to update both the prisma and @prisma/client packages to version 6 using yarn.

LANGUAGE: bash
CODE:
yarn up prisma@6 @prisma/client@6

----------------------------------------

TITLE: Initializing TypeScript Configuration
DESCRIPTION: Command to create TypeScript configuration file (tsconfig.json) with default settings.

LANGUAGE: terminal
CODE:
npx tsc --init

----------------------------------------

TITLE: Querying User Model without Row Limit in Prisma (TypeScript)
DESCRIPTION: This snippet demonstrates a Prisma query that retrieves all users with a specific email address without limiting the number of rows returned. This can lead to performance issues and excessive resource consumption.

LANGUAGE: typescript
CODE:
await prisma.user.findMany({ where: { email: "janedoe@gmail.com" }})

----------------------------------------

TITLE: Updated Prisma Schema with Explicit Relations
DESCRIPTION: Modified schema that introduces UserPost relation table for explicit many-to-many relationship with additional metadata.

LANGUAGE: prisma
CODE:
model User {
  id        Int        @id @default(autoincrement())
  name      String
  posts     Post[]
  userPosts UserPost[]
}

model Post {
  id        Int        @id @default(autoincrement())
  title     String
  authors   User[]
  userPosts UserPost[]
}

model UserPost {
  id        Int       @id @default(autoincrement())
  userId    Int
  postId    Int
  user      User      @relation(fields: [userId], references: [id])
  post      Post      @relation(fields: [postId], references: [id])
  createdAt DateTime  @default(now())

  @@unique([userId, postId])
}

----------------------------------------

TITLE: Updating Post Status with Prisma Client
DESCRIPTION: Query to update an existing post's published status using Prisma Client's update method.

LANGUAGE: typescript
CODE:
async function main() {
  const post = await prisma.post.update({
    where: { title: 'Hello World' },
    data: { published: true },
  })
  console.log(post)
}

----------------------------------------

TITLE: Updating Post Status with Prisma Client
DESCRIPTION: Query to update an existing post's published status using Prisma Client's update method.

LANGUAGE: typescript
CODE:
async function main() {
  const post = await prisma.post.update({
    where: { title: 'Hello World' },
    data: { published: true },
  })
  console.log(post)
}

----------------------------------------

TITLE: Installing PostgreSQL CLI Tools on Linux
DESCRIPTION: Commands to install PostgreSQL 16 client tools and verify pg_dump and pg_restore on Linux using apt.

LANGUAGE: terminal
CODE:
sudo apt-get update
sudo apt-get install postgresql-client-16
which pg_dump
which pg_restore

----------------------------------------

TITLE: Updating Records with Prisma Client
DESCRIPTION: Shows how to update an existing database record using Prisma Client's update operation, specifically changing the published status of a Post.

LANGUAGE: javascript
CODE:
async function main() {
  const post = await prisma.post.update({
    where: { id: 1 },
    data: { published: true },
  })
  console.log(post)
}

----------------------------------------

TITLE: Updating Prisma schema with relations
DESCRIPTION: Modifies the Prisma schema to include relations between posts, users, and categories models.

LANGUAGE: prisma
CODE:
type UsersProfile {
  bio String
}

model categories {
  id   String @id @default(auto()) @map("_id") @db.ObjectId
  v    Int    @map("__v")
  name String
  posts    posts[]  @relation(fields: [postIds], references: [id])
  postIds String[] @db.ObjectId
}

model posts {
  id        String  @id @default(auto()) @map("_id") @db.ObjectId
  title     String
  content   String
  published Boolean
  v         Int     @map("__v")

  author   users  @relation(fields: [authorId], references: [id])
  authorId String @map("author") @db.ObjectId

  categories  categories[] @relation(fields: [categoryIds], references: [id])
  categoryIds String[] @map("categories") @db.ObjectId
}

model users {
  id      String        @id @default(auto()) @map("_id") @db.ObjectId
  v       Int           @map("__v")
  email   String        @unique(map: "email_1")
  name    String
  profile UsersProfile?
  posts   posts[]
}

----------------------------------------

TITLE: Invoking Prisma CLI
DESCRIPTION: Command to invoke the Prisma CLI using npx.

LANGUAGE: bash
CODE:
npx prisma

----------------------------------------

TITLE: Defining Explicit Many-to-Many Schema in Prisma
DESCRIPTION: Schema definition for explicit many-to-many relationship using a PostTags junction table to store the relationships between Posts and Tags.

LANGUAGE: prisma
CODE:
model Post {
  id    Int        @id @default(autoincrement())
  title String
  tags  PostTags[]
}

model PostTags {
  id     Int   @id @default(autoincrement())
  post   Post? @relation(fields: [postId], references: [id])
  tag    Tag?  @relation(fields: [tagId], references: [id])
  postId Int?
  tagId  Int?

  @@index([postId, tagId])
}

model Tag {
  id    Int        @id @default(autoincrement())
  name  String     @unique
  posts PostTags[]
}

----------------------------------------

TITLE: Creating Nested Records with Prisma Client
DESCRIPTION: Shows how to create a User record with associated Post and Profile records using a nested write query. Includes retrieving the created data with related records.

LANGUAGE: typescript
CODE:
async function main() {
  await prisma.user.create({
    data: {
      name: 'Alice',
      email: 'alice@prisma.io',
      posts: {
        create: { title: 'Hello World' },
      },
      profile: {
        create: { bio: 'I like turtles' },
      },
    },
  })

  const allUsers = await prisma.user.findMany({
    include: {
      posts: true,
      profile: true,
    },
  })
  console.dir(allUsers, { depth: null })
}

----------------------------------------

TITLE: Opening Netlify Admin UI
DESCRIPTION: Command to open Netlify admin interface using Netlify CLI.

LANGUAGE: terminal
CODE:
netlify open --admin

----------------------------------------

TITLE: Configuring Prisma datasource for PostgreSQL
DESCRIPTION: Initial Prisma schema configuration using PostgreSQL as the database provider. The connection URL is set via an environment variable.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

----------------------------------------

TITLE: Initializing Prisma Client Connection
DESCRIPTION: Sets up a basic Node.js script that initializes Prisma Client and handles database connections with proper error handling and cleanup.

LANGUAGE: javascript
CODE:
const { PrismaClient } = require('@prisma/client')

const prisma = new PrismaClient()

async function main() {
  // ... you will write your Prisma Client queries here
}

main()
  .then(async () => {
    await prisma.$disconnect()
  })
  .catch(async (e) => {
    console.error(e)
    await prisma.$disconnect()
    process.exit(1)
  })

----------------------------------------

TITLE: Creating JavaScript Code Block in MDX
DESCRIPTION: Shows how to create a basic JavaScript code block using MDX syntax. This example includes an async function that queries all users using Prisma.

LANGUAGE: javascript
CODE:
async function main() {
  const allUsers = await prisma.user.findMany()
  console.log(allUsers)
}

----------------------------------------

TITLE: Initializing Node.js Project and Installing Prisma CLI
DESCRIPTION: Commands to initialize a Node.js project and install Prisma CLI as a development dependency.

LANGUAGE: bash
CODE:
npm init -y
npm install prisma --save-dev

----------------------------------------

TITLE: Updating Records with Prisma Client
DESCRIPTION: Shows how to update an existing database record using Prisma Client's update operation, specifically changing the published status of a Post.

LANGUAGE: javascript
CODE:
async function main() {
  const post = await prisma.post.update({
    where: { id: 1 },
    data: { published: true },
  })
  console.log(post)
}

----------------------------------------

TITLE: Using withAccelerateInfo for Cache Status
DESCRIPTION: Example showing how to retrieve cache status and response information using withAccelerateInfo() method with a cached count query.

LANGUAGE: typescript
CODE:
const { data, info } = await prisma.user
  .count({
    cacheStrategy: { ttl: 60, swr: 600 },
    where: { myField: 'value' },
  })
  .withAccelerateInfo()

console.dir(info)

----------------------------------------

TITLE: Prisma schema with renamed relation fields
DESCRIPTION: The modified Prisma schema with custom names for relation fields to improve readability and API ergonomics.

LANGUAGE: prisma
CODE:
model Post {
  id                          Int   @id @default(autoincrement())
  author                      Int
  favoritedBy                 Int?
  User_Post_authorToUser      User  @relation("Post_authorToUser", fields: [author], references: [id], onDelete: NoAction, onUpdate: NoAction)
  User_Post_favoritedByToUser User? @relation("Post_favoritedByToUser", fields: [favoritedBy], references: [id], onDelete: NoAction, onUpdate: NoAction)
}

model User {
  id             Int    @id @default(autoincrement())
  writtenPosts   Post[] @relation("Post_authorToUser")
  favoritedPosts Post[] @relation("Post_favoritedByToUser")
}

----------------------------------------

TITLE: JSDoc Type Definition for Prisma Client
DESCRIPTION: Type definition import using JSDoc to enable Prisma Client autocompletion.

LANGUAGE: javascript
CODE:
/**
 * @typedef { import("@prisma/client").PrismaClient } Prisma
 */

----------------------------------------

TITLE: Updating Post Records with Prisma Client
DESCRIPTION: Example of updating an existing post record using Prisma Client's update method with a where clause.

LANGUAGE: javascript
CODE:
async function main() {
  const post = await prisma.post.update({
    where: { id: 1 },
    data: { published: true },
  })
  console.log(post)
}

----------------------------------------

TITLE: TypeScript User Interface Definition
DESCRIPTION: TypeScript interface definition for User model showing typed properties.

LANGUAGE: typescript
CODE:
interface User {
  user_id: number
  name: string
  email: string
  isAdmin: boolean
}

----------------------------------------

TITLE: Adding Prisma Generate to Postinstall Script in package.json
DESCRIPTION: This snippet shows how to add a postinstall script to package.json that runs prisma generate. This ensures Prisma Client is generated after dependencies are installed.

LANGUAGE: json
CODE:
{
  ...
  "scripts" {
    "postinstall": "prisma generate"
  }
  ...
}

----------------------------------------

TITLE: Installing Prisma CLI as Development Dependency
DESCRIPTION: Command to install the Prisma CLI as a development dependency in the project. This allows using Prisma commands with npx.

LANGUAGE: bash
CODE:
npm install prisma --save-dev

----------------------------------------

TITLE: Adding Tag Model to Prisma Schema
DESCRIPTION: Demonstrates how to define a Tag model with many-to-many relationship to Posts in a Prisma schema. Includes fields for id, name, and a posts relation array.

LANGUAGE: prisma
CODE:
model Post {
  id        Int      @id @default(autoincrement())
  title     String   @db.VarChar(255)
  createdAt DateTime @default(now()) @db.Timestamp(6)
  content   String?
  published Boolean  @default(false)
  authorId  Int
  user      User     @relation(fields: [authorId], references: [id])
  tags      Tag[]
}

model Profile {
  id     Int     @id @default(autoincrement())
  bio    String?
  userId Int     @unique
  user   User    @relation(fields: [userId], references: [id])
}

model User {
  id      Int      @id @default(autoincrement())
  name    String?  @db.VarChar(255)
  email   String   @unique @db.VarChar(255)
  post    Post[]
  profile Profile?
}

model Tag {
  id    Int    @id @default(autoincrement())
  name  String
  posts Post[]
}

----------------------------------------

TITLE: Creating Migration Directory in Terminal
DESCRIPTION: Command to create a nested directory structure for storing migration files.

LANGUAGE: bash
CODE:
mkdir -p prisma/migrations/0_init

----------------------------------------

TITLE: Invoking Prisma CLI
DESCRIPTION: Basic command to invoke the Prisma CLI using npx prefix.

LANGUAGE: terminal
CODE:
npx prisma

----------------------------------------

TITLE: Initializing Prisma Schema
DESCRIPTION: Command to initialize the Prisma schema file and create the necessary project structure.

LANGUAGE: bash
CODE:
npx prisma init

----------------------------------------

TITLE: Adding PostgreSQL Database to Heroku App in Bash
DESCRIPTION: This command provisions a PostgreSQL database for the Heroku app using the Heroku CLI.

LANGUAGE: bash
CODE:
heroku addons:create heroku-postgresql:hobby-dev

----------------------------------------

TITLE: Displaying IPv4 Address Range for Prisma Accelerate Static IP
DESCRIPTION: This snippet shows an example of IPv4 address ranges provided when enabling static IP for Prisma Accelerate. These addresses should be used to configure database firewall rules for allowing incoming connections.

LANGUAGE: plaintext
CODE:
52.86.207.46/32
100.29.164.162/32
54.211.230.107/32
18.235.169.169/32
54.209.237.70/32
44.221.111.173/32

----------------------------------------

TITLE: Installing and Running Prisma Docs Site Locally
DESCRIPTION: Commands for installing dependencies and starting the local development server for the Prisma documentation site. Includes steps for building and serving the static site version.

LANGUAGE: bash
CODE:
npm install
npm run start

LANGUAGE: bash
CODE:
npm run clean && npm run build
npm run serve

LANGUAGE: bash
CODE:
npm run format

----------------------------------------

TITLE: Heroku PostgreSQL Connection Example
DESCRIPTION: Example of a PostgreSQL connection URL for a database hosted on Heroku's cloud platform.

LANGUAGE: bash
CODE:
DATABASE_URL="postgresql://opnmyfngbknppm:XXX@ec2-46-137-91-216.eu-west-1.compute.amazonaws.com:5432/d50rgmkqi2ipus?schema=hello-prisma"

----------------------------------------

TITLE: Installing Prisma ORM 3.12.0+ with MongoDB
DESCRIPTION: Commands to install the latest version of Prisma ORM and initialize a new project with MongoDB as the datasource provider. This creates a Prisma schema file and an environment file for the database connection string.

LANGUAGE: bash
CODE:
$ npm install prisma@latest
$ npx prisma init --datasource-provider=mongodb

----------------------------------------

TITLE: Generating Prisma Client
DESCRIPTION: Generates the Prisma Client library based on your schema definition. This command needs to be run after any changes to your Prisma schema to update the generated client code.

LANGUAGE: terminal
CODE:
npx prisma generate

----------------------------------------

TITLE: Prisma Generated TypeScript Type
DESCRIPTION: Example of TypeScript type declaration generated by Prisma Client for User model.

LANGUAGE: typescript
CODE:
export declare type User = {
  id: number
  name: string | null
  email: string
  isAdmin: boolean
}

----------------------------------------

TITLE: Configuring SSL Connection with Relative Certificate Paths in Prisma Schema
DESCRIPTION: This example shows how to configure an SSL connection for a PostgreSQL database using relative paths for certificate files located outside the ./prisma directory.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "postgresql"
  url      = "postgresql://johndoe:mypassword@localhost:5432/mydb?schema=public&sslmode=require&sslcert=../server-ca.pem&sslidentity=../client-identity.p12&sslpassword=<REDACTED>"
}

----------------------------------------

TITLE: Migrating users query from forwardTo to Prisma Client
DESCRIPTION: Updates the users query resolver to use Prisma Client findMany with argument transformation for compatibility.

LANGUAGE: javascript
CODE:
const {
  makeOrderByPrisma2Compatible,
  makeWherePrisma2Compatible,
} = require('@prisma/binding-argument-transform')

const resolvers = {
  Query: {
    users: (_, args, context) => {
      const { where, orderBy, skip, first, last, after, before } = args
      const prisma2Where = makeWherePrisma2Compatible(where)
      const prisma2OrderBy = makeOrderByPrisma2Compatible(orderBy)
      const skipValue = skip || 0
      const prisma2Skip = Boolean(before) ? skipValue + 1 : skipValue
      const prisma2Take = Boolean(last) ? -last : first
      const prisma2Before = { id: before }
      const prisma2After = { id: after }
      const prisma2Cursor =
        !Boolean(before) && !Boolean(after)
          ? undefined
          : Boolean(before)
          ? prisma2Before
          : prisma2After
      return context.prisma.user.findMany({
        where: prisma2Where,
        orderBy: prisma2OrderBy,
        skip: prisma2Skip,
        cursor: prisma2Cursor,
        take: prisma2Take,
      })
    },
  },
}

----------------------------------------

TITLE: Heroku PostgreSQL Connection Example
DESCRIPTION: Shows a sample connection URL for a PostgreSQL database hosted on Heroku, including the required credentials and connection parameters.

LANGUAGE: bash
CODE:
DATABASE_URL="postgresql://opnmyfngbknppm:XXX@ec2-46-137-91-216.eu-west-1.compute.amazonaws.com:5432/d50rgmkqi2ipus?schema=hello-prisma"

----------------------------------------

TITLE: Configuring Prisma Schema for Vercel Postgres
DESCRIPTION: Sets up the Prisma schema for Vercel Postgres, using the driverAdapters preview feature and specific environment variables.

LANGUAGE: prisma
CODE:
generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["driverAdapters"]
}

datasource db {
  provider  = "postgresql"
  url       = env("POSTGRES_PRISMA_URL") // uses connection pooling
  directUrl = env("POSTGRES_URL_NON_POOLING") // uses a direct connection
}

----------------------------------------

TITLE: Using Fluent Relations API with Prisma Client in JavaScript
DESCRIPTION: This snippet demonstrates how to use the fluent relations API to retrieve Post records of a User by traversing the relations.

LANGUAGE: javascript
CODE:
const user = await prisma.comment
  .findUnique({
    where: { id: '60ff4e9500acc65700ebf470' },
  })
  .post()
  .user()

----------------------------------------

TITLE: Generating Initial Migration SQL
DESCRIPTION: Generates a migration SQL file by comparing an empty state to the current schema using prisma migrate diff

LANGUAGE: terminal
CODE:
npx prisma migrate diff --from-empty --to-schema-datamodel prisma/schema.prisma --script > prisma/migrations/0_init/migration.sql

----------------------------------------

TITLE: Enabling Preview Features in Prisma Schema
DESCRIPTION: Demonstrates how to add a preview feature to the Prisma schema configuration. This example shows enabling the 'namedConstraints' feature in the generator block.

LANGUAGE: prisma
CODE:
generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["namedConstraints"]
}

----------------------------------------

TITLE: Local MySQL Connection URL Example
DESCRIPTION: Example of a MySQL connection URL for a locally hosted database instance.

LANGUAGE: bash
CODE:
DATABASE_URL="mysql://root:randompassword@localhost:3306/mydb"

----------------------------------------

TITLE: Generating Prisma Client with Driver Adapters
DESCRIPTION: This bash command generates the Prisma Client after enabling the driver adapters preview feature. It uses the npx command to run prisma generate.

LANGUAGE: bash
CODE:
npx prisma generate

----------------------------------------

TITLE: Defining Prisma Schema with User Model
DESCRIPTION: This snippet shows the Prisma schema file with a User model definition, including database connection configuration using the DATABASE_URL environment variable.

LANGUAGE: prisma
CODE:
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// add-start
model User {
  id    Int     @id @default(autoincrement())
  name  String?
  email String  @unique
}
// add-end

----------------------------------------

TITLE: Running Docker in Interactive Mode for Prisma Migrate
DESCRIPTION: This snippet shows how to run a Docker image in interactive mode to ensure it responds to the 'migrate dev' command. It includes examples of the Docker run command with the --interactive and --tty flags.

LANGUAGE: bash
CODE:
docker run --interactive --tty <image name>
# or
docker -it <image name>

# Example usage
docker run -it node

----------------------------------------

TITLE: GraphQL Type Definitions with Nexus
DESCRIPTION: Example of defining GraphQL object types using Nexus that map to Prisma models, with support for filtering and ordering.

LANGUAGE: TypeScript
CODE:
const User = objectType({
  name: 'User',
  definition(t) {
    t.model.id()
    t.model.email()
    t.model.name()
    t.model.jsonData()
    t.model.role()
    t.model.profile()
    t.model.posts({
      filtering: true,
      ordering: true,
    })
  },
})

----------------------------------------

TITLE: Marking Migration as Applied with Prisma CLI
DESCRIPTION: Uses the prisma migrate resolve command to mark the initial migration as applied in the _prisma_migrations table.

LANGUAGE: bash
CODE:
npx prisma migrate resolve --applied 0_init

----------------------------------------

TITLE: Configuring MySQL Data Source in Prisma Schema
DESCRIPTION: This snippet shows how to configure a MySQL data source in the Prisma schema file. It specifies the provider as 'mysql' and uses an environment variable for the database URL.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

----------------------------------------

TITLE: Local PostgreSQL Connection URL for Prisma on macOS
DESCRIPTION: This snippet provides an example of a connection URL for a locally hosted PostgreSQL database on macOS, where the user, password, and database name typically correspond to the current OS user.

LANGUAGE: bash
CODE:
DATABASE_URL="postgresql://janedoe:janedoe@localhost:5432/janedoe?schema=hello-prisma"

----------------------------------------

TITLE: Configuring Prisma Schema for Neon
DESCRIPTION: Sets up the Prisma schema for Neon, using the driverAdapters preview feature.

LANGUAGE: prisma
CODE:
generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["driverAdapters"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

----------------------------------------

TITLE: Enhanced Prisma Schema with Relations
DESCRIPTION: Final Prisma schema with added relationships between User and Post models using @relation attribute to enable joins in Prisma Client queries.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model Post {
  id     String @id @default(auto()) @map("_id") @db.ObjectId
  title  String
  userId String @db.ObjectId
  user   User   @relation(fields: [userId], references: [id])
}

model User {
  id    String @id @default(auto()) @map("_id") @db.ObjectId
  email String
  posts Post[]
}

----------------------------------------

TITLE: Structuring Multiple UI Steps in Markdown
DESCRIPTION: Demonstrates how to properly structure multiple UI actions into separate, clear steps using Markdown formatting.

LANGUAGE: markdown
CODE:
<!-- Bad -->

When you click **Invite Member** and the **Add member** pop-up opens, select the role for the new team member.

<!-- Good -->

1. Click **Invite Member**.
2. In the **Add member** pop-up, select the role for the new team member and click **Invite**.

----------------------------------------

TITLE: Updating Prisma datasource for CockroachDB
DESCRIPTION: Modified Prisma schema configuration to use CockroachDB as the database provider. The connection URL remains set via an environment variable.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "cockroachdb"
  url      = env("DATABASE_URL")
}

----------------------------------------

TITLE: Enabling full-text search for PostgreSQL in Prisma schema
DESCRIPTION: Update the Prisma schema to include the fullTextSearchPostgres preview feature flag in the generator block.

LANGUAGE: prisma
CODE:
generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["fullTextSearchPostgres"]
}

----------------------------------------

TITLE: Incorporating Prisma Generate into Build Script in package.json
DESCRIPTION: Modifies the build script in package.json to run prisma generate before the actual build command. This ensures Prisma Client is up-to-date before each build on Vercel.

LANGUAGE: json
CODE:
{
  ...
  "scripts" {
    "build": "prisma generate && <actual-build-command>"
  }
  ...
}

----------------------------------------

TITLE: Error Message for Mismatched Database Provider in Prisma Migrate
DESCRIPTION: This snippet shows the error message displayed when the datasource provider specified in the schema does not match the one in migration_lock.toml. It instructs the user to remove the current migration directory and start a new migration history.

LANGUAGE: bash
CODE:
Error: P3014

The datasource provider `postgresql` specified in your schema does not match the one specified in the migration_lock.toml, mysql. Please remove your current migration directory and start a new migration history with prisma migrate dev.

----------------------------------------

TITLE: Handling @updatedAt Fields in Prisma ORM 2.x+ (MySQL)
DESCRIPTION: This snippet shows how to handle @updatedAt fields that were previously managed by Prisma 1 server. It demonstrates adding the @updatedAt attribute to the Prisma model.

LANGUAGE: prisma
CODE:
model Post {
  id        String   @id
  updatedAt DateTime @updatedAt
}

----------------------------------------

TITLE: Running Prisma Introspection Command
DESCRIPTION: Terminal command to introspect the database and generate a Prisma schema

LANGUAGE: terminal
CODE:
npx prisma db pull

----------------------------------------

TITLE: Configuring SQL Server Data Source in Prisma Schema
DESCRIPTION: Basic configuration for connecting Prisma to a Microsoft SQL Server database using environment variables for the connection URL.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "sqlserver"
  url      = env("DATABASE_URL")
}

----------------------------------------

TITLE: Configuring Cascade Delete in Prisma Schema
DESCRIPTION: Example schema showing how to configure cascading deletes between User and Post models using referential actions.

LANGUAGE: prisma
CODE:
model Post {
  id       Int    @id @default(autoincrement())
  title    String
  author   User   @relation(fields: [authorId], references: [id], onDelete: Cascade)
  authorId Int
}

model User {
  id    Int    @id @default(autoincrement())
  posts Post[]
}

----------------------------------------

TITLE: Generating Initial Migration with Prisma Migrate Diff
DESCRIPTION: Generates a SQL migration script by comparing an empty state to the current schema. Uses --from-empty to start from scratch and --to-schema-datamodel to target current schema state.

LANGUAGE: terminal
CODE:
npx prisma migrate diff --from-empty --to-schema-datamodel prisma/schema.prisma --script > prisma/migrations/0_init/migration.sql

----------------------------------------

TITLE: Using Prisma Client in Vercel Edge Function with Neon
DESCRIPTION: Demonstrates how to instantiate PrismaClient and query a Neon database in a Vercel Edge Function.

LANGUAGE: typescript
CODE:
import { NextResponse } from 'next/server'
import { PrismaClient } from '@prisma/client'
import { PrismaNeon } from '@prisma/adapter-neon'
import { Pool } from '@neondatabase/serverless'

export const runtime = 'edge'

export async function GET(request: Request) {
  const neon = new Pool({ connectionString: process.env.DATABASE_URL })
  const adapter = new PrismaNeon(neon)
  const prisma = new PrismaClient({ adapter })

  const users = await prisma.user.findMany()

  return NextResponse.json(users, { status: 200 })
}

----------------------------------------

TITLE: Initializing Basic Prisma Schema for MongoDB
DESCRIPTION: Initial Prisma schema configuration file that sets up MongoDB as the database provider and configures the Prisma client generator.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

----------------------------------------

TITLE: Creating SQL Database Schema for Introspection
DESCRIPTION: SQL script to create a demo database schema with three related tables: Post, Profile, and User. Includes primary keys, foreign keys, and constraints.

LANGUAGE: sql
CODE:
CREATE TABLE [dbo].[Post] (
    [id] INT NOT NULL IDENTITY(1,1),
    [createdAt] DATETIME2 NOT NULL CONSTRAINT [Post_createdAt_df] DEFAULT CURRENT_TIMESTAMP,
    [updatedAt] DATETIME2 NOT NULL,
    [title] VARCHAR(255) NOT NULL,
    [content] NVARCHAR(1000),
    [published] BIT NOT NULL CONSTRAINT [Post_published_df] DEFAULT 0,
    [authorId] INT NOT NULL,
    CONSTRAINT [Post_pkey] PRIMARY KEY ([id])
);

CREATE TABLE [dbo].[Profile] (
    [id] INT NOT NULL IDENTITY(1,1),
    [bio] NVARCHAR(1000),
    [userId] INT NOT NULL,
    CONSTRAINT [Profile_pkey] PRIMARY KEY ([id]),
    CONSTRAINT [Profile_userId_key] UNIQUE ([userId])
);

CREATE TABLE [dbo].[User] (
    [id] INT NOT NULL IDENTITY(1,1),
    [email] NVARCHAR(1000) NOT NULL,
    [name] NVARCHAR(1000),
    CONSTRAINT [User_pkey] PRIMARY KEY ([id]),
    CONSTRAINT [User_email_key] UNIQUE ([email])
);

ALTER TABLE [dbo].[Post] ADD CONSTRAINT [Post_authorId_fkey] FOREIGN KEY ([authorId]) REFERENCES [dbo].[User]([id]) ON DELETE NO ACTION ON UPDATE CASCADE;

ALTER TABLE [dbo].[Profile] ADD CONSTRAINT [Profile_userId_fkey] FOREIGN KEY ([userId]) REFERENCES [dbo].[User]([id]) ON DELETE NO ACTION ON UPDATE CASCADE;

----------------------------------------

TITLE: Adding Figma Diagram Source in Markdown
DESCRIPTION: Shows how to include a comment with the Figma source URL above an image tag in a Markdown file. This helps maintain traceability to the original diagram source.

LANGUAGE: markdown
CODE:
<!-- https://www.figma.com/file/H7EMWAuCaRVHrdNoQpky7J/Tracing?node-id=2%3A37 -->

![image](./trace-diagram.png)

----------------------------------------

TITLE: Configuring Prisma Schema for PlanetScale Database Connection
DESCRIPTION: This snippet shows how to set up the datasource block in the Prisma schema file to connect to a PlanetScale database. It includes changing the provider to MySQL and setting the relation mode to 'prisma'.

LANGUAGE: prisma
CODE:
datasource db {
  provider     = "mysql"
  url          = env("DATABASE_URL")
  relationMode = "prisma"
}

----------------------------------------

TITLE: Defining Prisma Schema Models
DESCRIPTION: Schema definition for User and Post models with relationships in Prisma schema format.

LANGUAGE: prisma
CODE:
model User {
  id    Int     @id @default(autoincrement())
  email String  @unique
  name  String?
  posts Post[]
}

model Post {
  id        Int     @id @default(autoincrement())
  title     String
  content   String?
  published Boolean @default(false)
  author    User    @relation(fields: [authorId], references: [id])
  authorId  Int
}

----------------------------------------

TITLE: Refactoring Prisma Query for Soft Deletion
DESCRIPTION: This snippet shows how to refactor a Prisma query to support soft deletion using a 'deletedAt' timestamp field in the User model.

LANGUAGE: typescript
CODE:
const users = await prisma.user.findMany({
  where: { deletedAt: null }
});

----------------------------------------

TITLE: Prisma Schema Definition
DESCRIPTION: Sample Prisma schema defining User and Post models with their relationships and field definitions.

LANGUAGE: prisma
CODE:
model User {
  id    Int    @id @default(autoincrement())
  email String @unique
  name  String
  posts Post[]
}

model Post {
  id        Int     @id @default(autoincrement())
  title     String
  content   String
  published Boolean
  user      User    @relation(fields: [userId], references: [id])
  userId    Int
}

----------------------------------------

TITLE: Schema with Restrict Delete Action
DESCRIPTION: Prisma schema demonstrating the Restrict referential action to prevent deletion of referenced records.

LANGUAGE: prisma
CODE:
model Post {
  id       Int    @id @default(autoincrement())
  title    String
  author   User   @relation(fields: [authorId], references: [id], onDelete: Restrict)
  authorId String
}

model User {
  id    Int    @id @default(autoincrement())
  posts Post[]
}

----------------------------------------

TITLE: Generated Prisma Schema from Introspection
DESCRIPTION: This Prisma schema is the result of the introspection process. It defines models for Post, Profile, and User based on the database structure, but without relation fields.

LANGUAGE: prisma
CODE:
model Post {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime
  title     String   @db.VarChar(255)
  content   String?
  published Boolean  @default(false)
  authorId  Int

  @@index([authorId])
}

model Profile {
  id     Int     @id @default(autoincrement())
  bio    String?
  userId Int     @unique

  @@index([userId])
}

model User {
  id    Int     @id @default(autoincrement())
  email String  @unique
  name  String?
}

----------------------------------------

TITLE: Shared Default Values SQL Definition
DESCRIPTION: Example demonstrating the creation of shared default values in SQL Server, which has limited support in Prisma.

LANGUAGE: sql
CODE:
CREATE DEFAULT catcat AS 'musti';

CREATE TABLE cats (
    id INT IDENTITY PRIMARY KEY,
    name NVARCHAR(1000)
);

sp_bindefault 'catcat', 'dbo.cats.name';

----------------------------------------

TITLE: Checking Prisma CLI Installation
DESCRIPTION: Command to verify Prisma CLI installation and view available commands.

LANGUAGE: bash
CODE:
npx prisma

----------------------------------------

TITLE: Database Package Configuration
DESCRIPTION: Package.json configuration for the database package within the monorepo.

LANGUAGE: json
CODE:
{
  "name": "@repo/db",
  "version": "0.0.0"
}

----------------------------------------

TITLE: MongoDB Connection URL Format
DESCRIPTION: Generic format for MongoDB connection URL showing the required components: username, password, host, port, and database name.

LANGUAGE: plaintext
CODE:
mongodb://USERNAME:PASSWORD@HOST:PORT/DATABASE

----------------------------------------

TITLE: TypeScript Function Naming Examples
DESCRIPTION: Examples demonstrating good and bad practices for naming functions in TypeScript code.

LANGUAGE: typescript
CODE:
const getUsers = (...)
const deleteUsers = (...)

LANGUAGE: typescript
CODE:
const results = (...) // Too generic
const foo = (...) // Too vague

----------------------------------------

TITLE: Creating SQL Tables for User, Post, and Profile in PostgreSQL
DESCRIPTION: This SQL snippet creates three tables: User, Post, and Profile. It defines the structure of each table including primary keys, foreign keys, and constraints.

LANGUAGE: sql
CODE:
CREATE TABLE "public"."User" (
  id SERIAL PRIMARY KEY NOT NULL,
  name VARCHAR(255),
  email VARCHAR(255) UNIQUE NOT NULL
);

CREATE TABLE "public"."Post" (
  id SERIAL PRIMARY KEY NOT NULL,
  title VARCHAR(255) NOT NULL,
  "createdAt" TIMESTAMP NOT NULL DEFAULT now(),
  content TEXT,
  published BOOLEAN NOT NULL DEFAULT false,
  "authorId" INTEGER NOT NULL,
  FOREIGN KEY ("authorId") REFERENCES "public"."User"(id)
);

CREATE TABLE "public"."Profile" (
  id SERIAL PRIMARY KEY NOT NULL,
  bio TEXT,
  "userId" INTEGER UNIQUE NOT NULL,
  FOREIGN KEY ("userId") REFERENCES "public"."User"(id)
);

----------------------------------------

TITLE: Installing Fig CLI Autocomplete for Prisma
DESCRIPTION: Command to install Fig via Homebrew for shell autocompletion features. Compatible with bash, zsh, and fish shells.

LANGUAGE: bash
CODE:
brew install fig

----------------------------------------

TITLE: Express.js Prometheus Integration
DESCRIPTION: Example of exposing Prisma Client metrics via an Express.js endpoint for Prometheus scraping.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client'
import express, { Request, Response } from 'express'
import prom from 'prom-client'

const app = express()
const port = 4000
const prisma = new PrismaClient()

const register = new prom.Registry()
prom.collectDefaultMetrics({ register })

app.get('/metrics', async (_req, res: Response) => {
  const prismaMetrics = await prisma.$metrics.prometheus()
  const appMetrics = await register.metrics()
  res.end(prismaMetrics + appMetrics)
})

app.listen(port, () => {
  console.log(`Example app listening on port ${port}`)
})

----------------------------------------

TITLE: Prisma Schema with Different Constraint Names in Development and Production
DESCRIPTION: These snippets show how constraint names might differ between development and production environments, highlighting the need for alignment.

LANGUAGE: prisma
CODE:
// Development environment:
model Post {
  id         Int    @id @default(autoincrement())
  title      String
  authorName String @default("Anonymous")
  author     User?  @relation(fields: [authorName], references: [name], map: "Custom_Foreign_Key_Constraint")
}

// Production environment:
model Post {
  id         Int    @id @default(autoincrement())
  title      String
  authorName String @default("Anonymous")
  author     User?  @relation(fields: [authorName], references: [name], map: "Custom_Production_Name")
}

----------------------------------------

TITLE: Adjusted Prisma Schema with Improved Naming Conventions
DESCRIPTION: This Prisma schema shows the adjusted version of the introspected schema. It renames relation fields to follow Prisma's naming conventions and improve the generated Prisma Client API.

LANGUAGE: prisma
CODE:
model Post {
  id        Int      @id @default(autoincrement())
  title     String   @db.VarChar(255)
  createdAt DateTime @default(now()) @db.Timestamp(6)
  content   String?
  published Boolean  @default(false)
  authorId  Int
  author    User     @relation(fields: [authorId], references: [id], onDelete: NoAction, onUpdate: NoAction)
}

model Profile {
  id     Int     @id @default(autoincrement())
  bio    String?
  userId Int     @unique
  user   User    @relation(fields: [userId], references: [id], onDelete: NoAction, onUpdate: NoAction)
}

model User {
  id      Int      @id @default(autoincrement())
  name    String?  @db.VarChar(255)
  email   String   @unique @db.VarChar(255)
  posts   Post[]
  profile Profile?
}

----------------------------------------

TITLE: Updating OR Operator Usage in Prisma Client Queries
DESCRIPTION: The OR operator in Prisma ORM 5 only accepts array values, requiring a change in how it's used in queries.

LANGUAGE: javascript
CODE:
prisma.user.findMany({
  where: {
    OR: [{ email: 'foo@example.com' }],
  },
})

----------------------------------------

TITLE: Prisma Schema with Custom Constraint Names After Introspection
DESCRIPTION: This schema shows the result of running 'prisma db pull' to introspect the database. Custom constraint names that don't match Prisma ORM's naming convention are added using the 'map' attribute.

LANGUAGE: prisma
CODE:
model User {
  id    Int    @id(map: "Custom_Constraint_Name") @default(autoincrement())
  name  String @unique
  posts Post[]
}

model Post {
  id         Int    @id @default(autoincrement())
  title      String
  authorName String @default("Anonymous")
  author     User?  @relation(fields: [authorName], references: [name], map: "Custom_Foreign_Key_Constraint")
}

----------------------------------------

TITLE: Updating Records with Prisma Client in TypeScript
DESCRIPTION: Example of updating a record using Prisma Client, replacing a Drizzle update query in a TypeScript application.

LANGUAGE: typescript
CODE:
import { revalidatePath } from "next/cache";

import { prisma } from "@/db/prisma";

export const toggleTodo = async (id: number) => {
  const todo = await prisma.todo.findUnique({ where: { id } });
  if (todo) {
    await prisma.todo.update({
      where: { id: todo.id },
      data: { done: !todo.done },
    })
    revalidatePath("/");
  }
};

----------------------------------------

TITLE: Creating Turborepo Project
DESCRIPTION: Command to create a new Turborepo monorepo project named hello-world.

LANGUAGE: terminal
CODE:
npx create-turbo@latest hello-world

----------------------------------------

TITLE: MySQL Connection URL with Arguments
DESCRIPTION: This example shows a MySQL connection URL with additional arguments for connection limit and socket timeout.

LANGUAGE: text
CODE:
mysql://USER:PASSWORD@HOST:PORT/DATABASE?connection_limit=5&socket_timeout=3

----------------------------------------

TITLE: Introspected Prisma Schema for User, Post, and Profile Models
DESCRIPTION: This Prisma schema represents the data model generated after introspecting the PostgreSQL database. It defines the structure and relationships between User, Post, and Profile models.

LANGUAGE: prisma
CODE:
model Post {
  id        Int      @id @default(autoincrement())
  title     String   @db.VarChar(255)
  createdAt DateTime @default(now()) @db.Timestamp(6)
  content   String?
  published Boolean  @default(false)
  authorId  Int
  User      User     @relation(fields: [authorId], references: [id], onDelete: NoAction, onUpdate: NoAction)
}

model Profile {
  id     Int     @id @default(autoincrement())
  bio    String?
  userId Int     @unique
  User   User    @relation(fields: [userId], references: [id], onDelete: NoAction, onUpdate: NoAction)
}

model User {
  id      Int      @id @default(autoincrement())
  name    String?  @db.VarChar(255)
  email   String   @unique @db.VarChar(255)
  Post    Post[]
  Profile Profile?
}

----------------------------------------

TITLE: Configuring PostgreSQL Database Connection
DESCRIPTION: Examples showing how to configure a PostgreSQL database connection in the Prisma schema, first with a placeholder and then with an actual connection string.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "postgresql"
  url      = "__DATABASE_CONNECTION_STRING__"
}

LANGUAGE: prisma
CODE:
datasource db {
  provider = "postgresql"
  url      = "postgresql://opnmyfngbknppm:XXX@ec2-46-137-91-216.eu-west-1.compute.amazonaws.com:5432/d50rgmkqi2ipus?schema=hello-prisma2"
}

----------------------------------------

TITLE: Generated Prisma schema after introspection
DESCRIPTION: This Prisma schema is the result of introspecting the SQL Server database. It defines models for Post, Profile, and User with their respective fields and relationships.

LANGUAGE: prisma
CODE:
model Post {
  id        Int      @id @default(autoincrement())
  title     String   @db.VarChar(255)
  createdAt DateTime @default(now()) @db.Timestamp(6)
  content   String?
  published Boolean  @default(false)
  authorId  Int
  User      User     @relation(fields: [authorId], references: [id])
}

model Profile {
  id     Int     @id @default(autoincrement())
  bio    String?
  userId Int     @unique
  User   User    @relation(fields: [userId], references: [id])
}

model User {
  id      Int      @id @default(autoincrement())
  name    String?  @db.VarChar(255)
  email   String   @unique @db.VarChar(255)
  Post    Post[]
  Profile Profile?
}

----------------------------------------

TITLE: Evaluating Prisma Accelerate Connection Pooling
DESCRIPTION: TypeScript script that measures performance statistics for connection pooling by running repeated queries. Calculates average, P50, P75, and P99 response times across 10000 iterations.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client'
import { withAccelerate } from '@prisma/extension-accelerate'

const prisma = new PrismaClient().$extends(withAccelerate())

function calculateStatistics(numbers: number[]): {
  average: number
  p50: number
  p75: number
  p99: number
} {
  if (numbers.length === 0) {
    throw new Error('The input array is empty.')
  }

  // Sort the array in ascending order
  numbers.sort((a, b) => a - b)

  const sum = numbers.reduce((acc, num) => acc + num, 0)
  const count = numbers.length

  const average = sum / count
  const p50 = getPercentile(numbers, 50)
  const p75 = getPercentile(numbers, 75)
  const p99 = getPercentile(numbers, 99)

  return { average, p50, p75, p99 }
}

function getPercentile(numbers: number[], percentile: number): number {
  if (percentile <= 0 || percentile >= 100) {
    throw new Error('Percentile must be between 0 and 100.')
  }

  const index = (percentile / 100) * (numbers.length - 1)
  if (Number.isInteger(index)) {
    // If the index is an integer, return the corresponding value
    return numbers[index]
  } else {
    // If the index is not an integer, interpolate between two adjacent values
    const lowerIndex = Math.floor(index)
    const upperIndex = Math.ceil(index)
    const lowerValue = numbers[lowerIndex]
    const upperValue = numbers[upperIndex]
    const interpolationFactor = index - lowerIndex
    return lowerValue + (upperValue - lowerValue) * interpolationFactor
  }
}

async function main() {
  const timings = []

  // fire a query before going to the loop
  await prisma.notes.findMany({
    take: 20,
  })

  // we recommend evaluationg Prisma Accelerate with a large loop
  const LOOP_LENGTH = 10000

  for (let i = 0; i < LOOP_LENGTH; i++) {
    const start = Date.now()
    await prisma.notes.findMany({
      take: 20,
    })

    timings.push(Date.now() - start)
  }

  const statistics = calculateStatistics(timings)
  console.log('Average:', statistics.average)
  console.log('P50:', statistics.p50)
  console.log('P75:', statistics.p75)
  console.log('P99:', statistics.p99)
}

main()
  .then(async () => {
    await prisma.$disconnect()
  })
  .catch((e) => {
    await prisma.$disconnect()
    process.exit(1)
  })

----------------------------------------

TITLE: Altering PostgreSQL relation table for Prisma v6 upgrade
DESCRIPTION: SQL commands to alter a relation table, changing the unique index to a primary key constraint for Prisma v6 upgrade.

LANGUAGE: sql
CODE:
-- AlterTable
ALTER TABLE "_PostToTag" ADD CONSTRAINT "_PostToTag_AB_pkey" PRIMARY KEY ("A", "B");

-- DropIndex
DROP INDEX "_PostToTag_AB_unique";

----------------------------------------

TITLE: Implementing User Functions with Context
DESCRIPTION: Implement functions for creating and updating users using dependency injection pattern.

LANGUAGE: typescript
CODE:
import { Context } from './context'

interface CreateUser {
  name: string
  email: string
  acceptTermsAndConditions: boolean
}

export async function createUser(user: CreateUser, ctx: Context) {
  if (user.acceptTermsAndConditions) {
    return await ctx.prisma.user.create({
      data: user,
    })
  } else {
    return new Error('User must accept terms!')
  }
}

interface UpdateUser {
  id: number
  name: string
  email: string
}

export async function updateUsername(user: UpdateUser, ctx: Context) {
  return await ctx.prisma.user.update({
    where: { id: user.id },
    data: user,
  }
)}

----------------------------------------

TITLE: Updating path Argument for JSON Field Filtering in PostgreSQL
DESCRIPTION: When filtering on JSON fields in PostgreSQL models, the path argument now only accepts an array in Prisma ORM 5.

LANGUAGE: javascript
CODE:
prisma.user.findMany({
  where: {
    settings: {
      path: ['someSetting'],
      equals: someValue,
    },
  },
})

----------------------------------------

TITLE: Setting Database Connection URL in Environment Variable for Prisma
DESCRIPTION: This snippet demonstrates how to define the DATABASE_URL environment variable in a .env file, which is used by Prisma to connect to a PostgreSQL database.

LANGUAGE: bash
CODE:
DATABASE_URL="postgresql://johndoe:randompassword@localhost:5432/mydb?schema=public"

----------------------------------------

TITLE: Auto-Syncing Embedded Replica with Prisma Client Extension
DESCRIPTION: Extends Prisma Client to automatically synchronize the embedded replica after create, update, or delete operations, ensuring data consistency.

LANGUAGE: typescript
CODE:
const prisma = new PrismaClient().$extends({
  query: {
    $allModels: {
      async $allOperations({ operation, model, args, query }) {
        const result = await query(args)
        
        // Synchronize the embedded replica after any write operation
        if (['create', 'update', 'delete'].includes(operation)) {
          await libsql.sync()
        }
        
        return result
      }
    }
  }
})

----------------------------------------

TITLE: Default Value Per Table SQL Definition
DESCRIPTION: Example showing how to define default values directly in a table creation statement for SQL Server.

LANGUAGE: sql
CODE:
CREATE TABLE cats (
    id INT IDENTITY PRIMARY KEY,
    name NVARCHAR(1000) CONSTRAINT DF_cat_name DEFAULT 'musti'
);

----------------------------------------

TITLE: Markdown Example for Deprecation Notices
DESCRIPTION: This snippet shows the recommended way to write deprecation notices in Prisma documentation, mentioning the deprecation version but not the planned removal version.

LANGUAGE: markdown
CODE:
<!-- Good -->

From v3.0.0, the `command name` command is deprecated.

<!-- Bad -->

From v3.0.0, the `command name` command is deprecated.
We plan to remove `command name` in v.4.0.0.

----------------------------------------

TITLE: Generating Initial Migration SQL with Prisma CLI
DESCRIPTION: Uses the prisma migrate diff command to generate an initial migration SQL file by comparing an empty state to the current schema.

LANGUAGE: bash
CODE:
npx prisma migrate diff --from-empty --to-schema-datamodel prisma/schema.prisma --script > prisma/migrations/0_init/migration.sql

----------------------------------------

TITLE: Filtering for Concrete Values with Prisma ORM and Sequelize in TypeScript
DESCRIPTION: Demonstrates how to filter results based on a specific condition. Prisma uses the contains operator, while Sequelize uses the Op.like operator for partial string matching.

LANGUAGE: typescript
CODE:
const posts = await prisma.post.findMany({
  where: {
    title: {
      contains: 'Hello',
    },
  },
})

LANGUAGE: typescript
CODE:
const post = await Post.findAll({
  raw: true,
  where: {
    title: {
      [Op.like]: '%Hello%',
    },
  },
})

----------------------------------------

TITLE: Creating a PostgreSQL relation table with primary key
DESCRIPTION: SQL commands to create a relation table for an implicit many-to-many relationship in PostgreSQL, using a primary key constraint on columns A and B.

LANGUAGE: sql
CODE:
-- CreateTable
CREATE TABLE "_PostToTag" (
    "A" INTEGER NOT NULL,
    "B" INTEGER NOT NULL,

    CONSTRAINT "_PostToTag_AB_pkey" PRIMARY KEY ("A","B")
);

-- CreateIndex
CREATE INDEX "_PostToTag_B_index" ON "_PostToTag"("B");

-- AddForeignKey
ALTER TABLE "_PostToTag" ADD CONSTRAINT "_PostToTag_A_fkey" FOREIGN KEY ("A") REFERENCES "Post"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "_PostToTag" ADD CONSTRAINT "_PostToTag_B_fkey" FOREIGN KEY ("B") REFERENCES "Tag"("id") ON DELETE CASCADE ON UPDATE CASCADE;

----------------------------------------

TITLE: Raw Query Extensions
DESCRIPTION: Example of extending raw query operations for both relational databases and MongoDB.

LANGUAGE: typescript
CODE:
const prisma = new PrismaClient().$extends({
  query: {
    $queryRaw({ args, query, operation }) {
      return query(args)
    },
    $executeRaw({ args, query, operation }) {
      return query(args)
    },
    $queryRawUnsafe({ args, query, operation }) {
      return query(args)
    },
    $executeRawUnsafe({ args, query, operation }) {
      return query(args)
    },
  },
})

----------------------------------------

TITLE: Handling Custom Error Logic
DESCRIPTION: Demonstrates how to implement custom error handling with OrThrow methods using try-catch

LANGUAGE: javascript
CODE:
prisma.user.findFirst({
  where: { name: 'Alice' },
  rejectOnNotFound: () => new UserNotFoundError(),
})

LANGUAGE: javascript
CODE:
try {
  await prisma.user.findFirstOrThrow({
    where: { name: 'Alice' },
  })
} catch (err) {
  if (err.code === 'P2025') {
    throw new UserNotFoundError()
  }
  throw err
}

----------------------------------------

TITLE: Defining Log Model with JSON Field in Prisma Schema
DESCRIPTION: This code snippet defines a Log model in the Prisma schema with an id field and a meta field of type Json.

LANGUAGE: typescript
CODE:
model Log {
  id Int @id
  meta Json
}

----------------------------------------

TITLE: Handling PrismaClientKnownRequestError in Prisma v6
DESCRIPTION: TypeScript code showing how to handle the PrismaClientKnownRequestError with error code P2025 in Prisma v6, replacing the previous NotFoundError.

LANGUAGE: typescript
CODE:
import { PrismaClient, Prisma } from '@prisma/client';

// inside an `async` function
try {
  const user = await prisma.user.findUniqueOrThrow({
    where: { id: 42 },
  });
  console.log(user);
} catch (error) {
  if (
    error instanceof Prisma.PrismaClientKnownRequestError &&
    error.code === 'P2025' // Specific code for "record not found"
  ) {
    console.error("User not found!");
  } 
  else {
    console.error("Unexpected error:", error);
  }
}

----------------------------------------

TITLE: Initial Database Schema Migration in MySQL
DESCRIPTION: SQL migration script that creates tables for Post, Profile, and User entities with their relationships and constraints. Includes creation of foreign keys and indexes.

LANGUAGE: sql
CODE:
-- CreateTable
CREATE TABLE `Post` (
    `id` INTEGER NOT NULL AUTO_INCREMENT,
    `title` VARCHAR(255) NOT NULL,
    `createdAt` TIMESTAMP(0) NOT NULL DEFAULT CURRENT_TIMESTAMP(0),
    `content` TEXT NULL,
    `published` BOOLEAN NOT NULL DEFAULT false,
    `authorId` INTEGER NOT NULL,

    INDEX `authorId`(`authorId`),
    PRIMARY KEY (`id`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- CreateTable
CREATE TABLE `Profile` (
    `id` INTEGER NOT NULL AUTO_INCREMENT,
    `bio` TEXT NULL,
    `userId` INTEGER NOT NULL,

    UNIQUE INDEX `userId`(`userId`),
    PRIMARY KEY (`id`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- CreateTable
CREATE TABLE `User` (
    `id` INTEGER NOT NULL AUTO_INCREMENT,
    `name` VARCHAR(255) NULL,
    `email` VARCHAR(255) NOT NULL,

    UNIQUE INDEX `email`(`email`),
    PRIMARY KEY (`id`)
) DEFAULT CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;

-- AddForeignKey
ALTER TABLE `Post` ADD CONSTRAINT `Post_ibfk_1` FOREIGN KEY (`authorId`) REFERENCES `User`(`id`) ON DELETE RESTRICT ON UPDATE RESTRICT;

-- AddForeignKey
ALTER TABLE `Profile` ADD CONSTRAINT `Profile_ibfk_1` FOREIGN KEY (`userId`) REFERENCES `User`(`id`) ON DELETE RESTRICT ON UPDATE RESTRICT;

----------------------------------------

TITLE: Listing Databases in SQL Server
DESCRIPTION: This SQL command lists all databases in the SQL Server instance to verify the creation of the new database.

LANGUAGE: sql
CODE:
sp_databases
GO

----------------------------------------

TITLE: Updating Database Connection String for Prisma Accelerate
DESCRIPTION: This snippet shows how to update the .env file with the new Accelerate connection string and maintain the direct database URL for migrations and introspection.

LANGUAGE: env
CODE:
# New Accelerate connection string with generated API_KEY
DATABASE_URL="prisma://accelerate.prisma-data.net/?api_key=__API_KEY__"
DIRECT_DATABASE_URL="postgresql://user:password@host:port/db_name?schema=public"

----------------------------------------

TITLE: Creating Migration Directory Structure
DESCRIPTION: Creates a nested directory structure for storing migration files using the mkdir command with recursive flag.

LANGUAGE: terminal
CODE:
mkdir -p prisma/migrations/0_init

----------------------------------------

TITLE: Configuring Prisma Schema with User Model
DESCRIPTION: Defines the Prisma schema with a PostgreSQL datasource, client generator, and a User model. It specifies a custom output path for generated Prisma client.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
  output = "../generated/prisma_client"
}

model User {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  email     String   @unique
  name      String?
}

----------------------------------------

TITLE: Adding Column with Default Value in SQL
DESCRIPTION: SQL command to add a published column with default value to Post table.

LANGUAGE: sql
CODE:
ALTER TABLE "Post"
ADD COLUMN published BOOLEAN DEFAULT false;

----------------------------------------

TITLE: Correcting multiple cascade paths in Prisma by setting onUpdate to NoAction
DESCRIPTION: This updated Prisma schema resolves the multiple cascade paths issue by setting onUpdate to NoAction in one of the relations (Comment.writtenBy in this example).

LANGUAGE: prisma
CODE:
model Comment {
  id          Int  @id @default(autoincrement())
  writtenById Int
  postId      Int
  writtenBy   User @relation(fields: [writtenById], references: [id], onUpdate: NoAction)
  post        Post @relation(fields: [postId], references: [id])
}

----------------------------------------

TITLE: Updating Prisma packages to v6 using npm
DESCRIPTION: Commands to update both the prisma and @prisma/client packages to version 6 using npm.

LANGUAGE: bash
CODE:
npm install @prisma/client@6
npm install -D prisma@6

----------------------------------------

TITLE: SQL Server Initial Schema Migration
DESCRIPTION: SQL migration script that creates tables for Post, Profile, and User entities with their relationships and constraints

LANGUAGE: sql
CODE:
CREATE TABLE [dbo].[Post] (
    [id] INT NOT NULL IDENTITY(1,1),
    [createdAt] DATETIME2 NOT NULL CONSTRAINT [Post_createdAt_df] DEFAULT CURRENT_TIMESTAMP,
    [updatedAt] DATETIME2 NOT NULL,
    [title] VARCHAR(255) NOT NULL,
    [content] NVARCHAR(1000),
    [published] BIT NOT NULL CONSTRAINT [Post_published_df] DEFAULT 0,
    [authorId] INT NOT NULL,
    CONSTRAINT [Post_pkey] PRIMARY KEY ([id])
);

CREATE TABLE [dbo].[Profile] (
    [id] INT NOT NULL IDENTITY(1,1),
    [bio] NVARCHAR(1000),
    [userId] INT NOT NULL,
    CONSTRAINT [Profile_pkey] PRIMARY KEY ([id]),
    CONSTRAINT [Profile_userId_key] UNIQUE ([userId])
);

CREATE TABLE [dbo].[User] (
    [id] INT NOT NULL IDENTITY(1,1),
    [email] NVARCHAR(1000) NOT NULL,
    [name] NVARCHAR(1000),
    CONSTRAINT [User_pkey] PRIMARY KEY ([id]),
    CONSTRAINT [User_email_key] UNIQUE ([email])
);

ALTER TABLE [dbo].[Post] ADD CONSTRAINT [Post_authorId_fkey] FOREIGN KEY ([authorId]) REFERENCES [dbo].[User]([id]) ON DELETE NO ACTION ON UPDATE CASCADE;

ALTER TABLE [dbo].[Profile] ADD CONSTRAINT [Profile_userId_fkey] FOREIGN KEY ([userId]) REFERENCES [dbo].[User]([id]) ON DELETE NO ACTION ON UPDATE CASCADE;

----------------------------------------

TITLE: Creating Prisma schema
DESCRIPTION: Initialize a new Prisma schema using the prisma init command.

LANGUAGE: bash
CODE:
npx prisma init

----------------------------------------

TITLE: Integrating Neon Serverless Driver with Prisma Client
DESCRIPTION: Sets up Prisma Client to use Neon's serverless driver through a driver adapter, enabling low-latency database access over HTTP or WebSockets.

LANGUAGE: typescript
CODE:
import { Pool, neonConfig } from '@neondatabase/serverless'
import { PrismaNeon } from '@prisma/adapter-neon'
import { PrismaClient } from '@prisma/client'
import dotenv from 'dotenv'
import ws from 'ws'

dotenv.config()
neonConfig.webSocketConstructor = ws
const connectionString = `${process.env.DATABASE_URL}`

const pool = new Pool({ connectionString })
const adapter = new PrismaNeon(pool)
const prisma = new PrismaClient({ adapter })

----------------------------------------

TITLE: Workspace Plan Limit Error
DESCRIPTION: Error message shown when workspace project limit is reached and the command that triggers it.

LANGUAGE: terminal
CODE:
npx prisma@latest init --db

LANGUAGE: terminal
CODE:
Workspace plan limit reached for feature "Project".

----------------------------------------

TITLE: Initial Database Schema Migration
DESCRIPTION: SQL migration script that creates tables for Post, Profile, and User entities with their relationships, indexes, and constraints.

LANGUAGE: sql
CODE:
-- CreateTable
CREATE TABLE "Post" (
    "id" SERIAL NOT NULL,
    "title" VARCHAR(255) NOT NULL,
    "createdAt" TIMESTAMP(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "content" TEXT,
    "published" BOOLEAN NOT NULL DEFAULT false,
    "authorId" INTEGER NOT NULL,

    CONSTRAINT "Post_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Profile" (
    "id" SERIAL NOT NULL,
    "bio" TEXT,
    "userId" INTEGER NOT NULL,

    CONSTRAINT "Profile_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "User" (
    "id" SERIAL NOT NULL,
    "name" VARCHAR(255),
    "email" VARCHAR(255) NOT NULL,

    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "Profile_userId_key" ON "Profile"("userId");

-- CreateIndex
CREATE UNIQUE INDEX "User_email_key" ON "User"("email");

-- AddForeignKey
ALTER TABLE "Post" ADD CONSTRAINT "Post_authorId_fkey" FOREIGN KEY ("authorId") REFERENCES "User"("id") ON DELETE NO ACTION ON UPDATE NO ACTION;

-- AddForeignKey
ALTER TABLE "Profile" ADD CONSTRAINT "Profile_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE NO ACTION ON UPDATE NO ACTION;

----------------------------------------

TITLE: Seeding Database with Realistic Data for Prisma Schema
DESCRIPTION: TypeScript seed script to populate the database with realistic data for User, Organization, and Subscription models based on the Prisma schema. It creates multiple organizations with associated users and subscriptions.

LANGUAGE: typescript
CODE:
import {
  PrismaClient,
  UserRole,
  SubscriptionPlan,
  SubscriptionStatus,
} from "@prisma/client";

const prisma = new PrismaClient();

async function main() {
  // Clear existing data
  await prisma.user.deleteMany();
  await prisma.subscription.deleteMany();
  await prisma.organization.deleteMany();

  const organizations = [
    {
      name: "Tech Innovators",
      slug: "tech-innovators",
      subscription: {
        plan: SubscriptionPlan.ENTERPRISE,
        status: SubscriptionStatus.ACTIVE,
        startDate: new Date("2024-01-01"),
      },
      users: [
        {
          name: "Emma Thompson",
          email: "emma@techinnovators.com",
          role: UserRole.ADMIN,
          password: "password123",
        },
        {
          name: "Michael Chen",
          email: "michael@techinnovators.com",
          role: UserRole.MEMBER,
          password: "password123",
        },
      ],
    },
    {
      name: "Digital Solutions",
      slug: "digital-solutions",
      subscription: {
        plan: SubscriptionPlan.PREMIUM,
        status: SubscriptionStatus.ACTIVE,
        startDate: new Date("2024-01-15"),
      },
      users: [
        {
          name: "Sarah Wilson",
          email: "sarah@digitalsolutions.com",
          role: UserRole.ADMIN,
          password: "password123",
        },
        {
          name: "James Miller",
          email: "james@digitalsolutions.com",
          role: UserRole.MEMBER,
          password: "password123",
        },
      ],
    },
    {
      name: "Cloud Systems",
      slug: "cloud-systems",
      subscription: {
        plan: SubscriptionPlan.BASIC,
        status: SubscriptionStatus.ACTIVE,
        startDate: new Date("2024-02-01"),
      },
      users: [
        {
          name: "David Garcia",
          email: "david@cloudsystems.com",
          role: UserRole.ADMIN,
          password: "password123",
        },
        {
          name: "Lisa Wang",
          email: "lisa@cloudsystems.com",
          role: UserRole.MEMBER,
          password: "password123",
        },
      ],
    },
    {
      name: "Data Analytics Co",
      slug: "data-analytics",
      subscription: {
        plan: SubscriptionPlan.PREMIUM,
        status: SubscriptionStatus.ACTIVE,
        startDate: new Date("2024-01-10"),
      },
      users: [
        {
          name: "Alex Johnson",
          email: "alex@dataanalytics.com",
          role: UserRole.ADMIN,
          password: "password123",
        },
        {
          name: "Rachel Kim",
          email: "rachel@dataanalytics.com",
          role: UserRole.MEMBER,
          password: "password123",
        },
      ],
    },
    {
      name: "Smart Solutions",
      slug: "smart-solutions",
      subscription: {
        plan: SubscriptionPlan.FREE,
        status: SubscriptionStatus.ACTIVE,
        startDate: new Date("2024-02-15"),
      },
      users: [
        {
          name: "Daniel Brown",
          email: "daniel@smartsolutions.com",
          role: UserRole.ADMIN,
          password: "password123",
        },
        {
          name: "Maria Rodriguez",
          email: "maria@smartsolutions.com",
          role: UserRole.MEMBER,
          password: "password123",
        },
      ],
    },
  ];

  for (const org of organizations) {
    const createdOrg = await prisma.organization.create({
      data: {
        name: org.name,
        slug: org.slug,
        subscription: {
          create: {
            plan: org.subscription.plan,
            status: org.subscription.status,
            startDate: org.subscription.startDate,
          },
        },
      },
    });

    for (const user of org.users) {
      await prisma.user.create({
        data: {
          name: user.name,
          email: user.email,
          password: user.password,
          role: user.role,
          organizationId: createdOrg.id,
        },
      });
    }
  }

  console.log("Seed data created successfully");
}

main()
  .catch((e) => {
    console.error(e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });

----------------------------------------

TITLE: Creating User Model in Prisma Schema
DESCRIPTION: Prisma schema definition for User model with id, name, and email fields.

LANGUAGE: prisma
CODE:
model User {
  id    Int     @id @default(autoincrement())
  name  String?
  email String  @unique
}

----------------------------------------

TITLE: Setting Relation Mode in Schema
DESCRIPTION: Configuration example showing how to set the relation mode in the datasource block

LANGUAGE: prisma
CODE:
datasource db {
  provider     = "mysql"
  url          = env("DATABASE_URL")
  relationMode = "prisma"
}

----------------------------------------

TITLE: Executing Prisma Codemods in Bash
DESCRIPTION: This command demonstrates how to run Prisma codemods. It takes a transform type, a path to the project, and optional arguments. The command helps in automating codebase updates for Prisma ORM.

LANGUAGE: bash
CODE:
$ npx @prisma/codemods <transform> <path> <...options>

----------------------------------------

TITLE: Specifying Single-File Prisma Schema Path (TypeScript)
DESCRIPTION: This example shows how to specify a custom path for a single-file Prisma schema in the Prisma Config. It uses the 'path' module to join path segments and sets the 'kind' property to 'single'.

LANGUAGE: typescript
CODE:
import path from "node:path";

export default {
  schema: {
    kind: "single",
    filePath: path.join("custom", "prisma", "schema.prisma"),
  },
};

----------------------------------------

TITLE: Configuring MongoDB connection string
DESCRIPTION: Sets the DATABASE_URL environment variable for MongoDB connection in the .env file.

LANGUAGE: env
CODE:
DATABASE_URL="mongodb://USER:PASSWORD@HOST:PORT/DATABASE"

----------------------------------------

TITLE: Comparing TypeORM and Prisma Client CRUD Operations
DESCRIPTION: Side-by-side comparison of basic CRUD operations in TypeORM versus Prisma Client, including find, create, update, and delete operations

LANGUAGE: typescript
CODE:
// Find one
const user = await userRepository.findOne({ 
  where: { id: 1 } 
});

// Create
const user = await userRepository.save({
  email: 'alice@prisma.io',
  name: 'Alice'
});

// Update
await userRepository.update(1, { 
  name: 'New name' 
});

// Delete
await userRepository.delete(1);

LANGUAGE: typescript
CODE:
// Find one
const user = await prisma.user.findUnique({ 
  where: { id: 1 } 
});

// Create
const user = await prisma.user.create({
  data: {
    email: 'alice@prisma.io',
    name: 'Alice'
  }
});

// Update
await prisma.user.update({
  where: { id: 1 },
  data: { name: 'New name' }
});

// Delete
await prisma.user.delete({
  where: { id: 1 }
});

----------------------------------------

TITLE: Creating TCP Tunnel for Database Access
DESCRIPTION: Command to establish a TCP tunnel using @prisma/ppg-tunnel package for direct database access.

LANGUAGE: terminal
CODE:
npx @prisma/ppg-tunnel --host 127.0.0.1 --port 52604

----------------------------------------

TITLE: Demonstrating Basic SQL Query Operation - SQL
DESCRIPTION: Example of a simple SQL query that counts as a billable operation in Prisma Postgres, despite not accessing actual data.

LANGUAGE: sql
CODE:
SELECT 1

----------------------------------------

TITLE: Marking Migration as Applied
DESCRIPTION: Marks the initial migration as applied in the Prisma migrations table

LANGUAGE: terminal
CODE:
npx prisma migrate resolve --applied 0_init

----------------------------------------

TITLE: Installing Prisma Client with npm for TypeScript and PlanetScale
DESCRIPTION: This command installs the @prisma/client package, which automatically invokes prisma generate to create a version of Prisma Client tailored to your models based on your Prisma schema.

LANGUAGE: shell
CODE:
npm install @prisma/client

----------------------------------------

TITLE: PgBouncer Error Message with Prisma Migrate
DESCRIPTION: This snippet demonstrates the error message that may occur when attempting to run Prisma Migrate commands in an environment using PgBouncer for connection pooling. It indicates a conflict with an existing prepared statement.

LANGUAGE: bash
CODE:
Error: undefined: Database error
Error querying the database: db error: ERROR: prepared statement "s0" already exists

----------------------------------------

TITLE: MongoDB One-to-Many Document Structure
DESCRIPTION: Example of how one-to-many relations are stored in MongoDB documents using ObjectId references between collections.

LANGUAGE: json
CODE:
{ "_id": { "$oid": "60d5922d00581b8f0062e3a8" }, "name": "Ella" }

LANGUAGE: json
CODE:
[
  {
    "_id": { "$oid": "60d5922e00581b8f0062e3a9" },
    "title": "How to make sushi",
    "authorId": { "$oid": "60d5922d00581b8f0062e3a8" }
  },
  {
    "_id": { "$oid": "60d5922e00581b8f0062e3aa" },
    "title": "How to re-install Windows",
    "authorId": { "$oid": "60d5922d00581b8f0062e3a8" }
  }
]

----------------------------------------

TITLE: Starting Prisma Studio
DESCRIPTION: Starts Prisma Studio, an interactive database browser, using the prisma studio command.

LANGUAGE: terminal
CODE:
prisma studio

----------------------------------------

TITLE: Initializing Prisma configuration
DESCRIPTION: Creates a new Prisma schema file with MongoDB as the datasource provider.

LANGUAGE: shell
CODE:
npx prisma init --datasource-provider mongodb

----------------------------------------

TITLE: DateTime Schema Definition in Prisma
DESCRIPTION: Example schema showing DateTime field definition in Prisma.

LANGUAGE: prisma
CODE:
model User {
  id        Int       @id @default(autoincrement())
  birthDate DateTime?
}

----------------------------------------

TITLE: Prisma Generate Production Warning
DESCRIPTION: Warning message displayed in production environments regarding query engine usage and the recommended command to resolve it.

LANGUAGE: terminal
CODE:
prisma:warn: In production, we recommend using 'prisma generate --no-engine'

LANGUAGE: terminal
CODE:
npx prisma generate --no-engine

----------------------------------------

TITLE: Configuring HTTP Proxy for Prisma CLI
DESCRIPTION: Sets the HTTP_PROXY environment variable to specify a proxy server for Prisma CLI to use when downloading engines.

LANGUAGE: env
CODE:
HTTP_PROXY=http://proxy.example.com

----------------------------------------

TITLE: Installing Prisma Client Package
DESCRIPTION: Installs the @prisma/client package via npm, which is required to use Prisma Client in your project.

LANGUAGE: terminal
CODE:
npm install @prisma/client

----------------------------------------

TITLE: Configuring Prisma Optimize Extension for Development Environment
DESCRIPTION: Demonstrates how to initialize Prisma Client with the Optimize extension and configure it to run only in development environments. Uses environment variables for API key and environment detection.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client'
import { withOptimize } from "@prisma/extension-optimize"

const prisma = new PrismaClient().$extends(
  withOptimize({
    apiKey: process.env.OPTIMIZE_API_KEY,
    enable: process.env.ENVIRONMENT === 'development',
  })
);

----------------------------------------

TITLE: Enabling multiSchema Preview Feature in Prisma Schema
DESCRIPTION: This snippet shows how to enable the multiSchema preview feature by adding it to the previewFeatures field in the generator block of the Prisma schema.

LANGUAGE: prisma
CODE:
generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["multiSchema"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

----------------------------------------

TITLE: Single-Table Inheritance Schema
DESCRIPTION: Prisma schema implementing single-table inheritance pattern with Activity model and discriminator.

LANGUAGE: prisma
CODE:
model Activity {
  id       Int          @id
  url      String       @unique
  duration Int?
  body     String?
  type     ActivityType

  owner   User @relation(fields: [ownerId], references: [id])
  ownerId Int
}

enum ActivityType {
  Video
  Article
}

model User {
  id         Int        @id @default(autoincrement())
  name       String?
  activities Activity[]
}

----------------------------------------

TITLE: Prisma CLI Help Command Output
DESCRIPTION: Output of the Prisma CLI when run without arguments, showing available commands and usage examples.

LANGUAGE: terminal
CODE:
Prisma is a modern DB toolkit to query, migrate and model your database (https://www.prisma.io)

Usage

  $ prisma [command]

Commands

            init   Setup Prisma for your app
        generate   Generate artifacts (e.g. Prisma Client)
              db   Manage your database schema and lifecycle
         migrate   Migrate your database
          studio   Browse your data with Prisma Studio
        validate   Validate your Prisma schema
          format   Format your Prisma schema

Flags

     --preview-feature   Run Preview Prisma commands

Examples

  Setup a new Prisma project
  $ prisma init

  Generate artifacts (e.g. Prisma Client)
  $ prisma generate

  Browse your data
  $ prisma studio

  Create migrations from your Prisma schema, apply them to the database, generate artifacts (e.g. Prisma Client)
  $ prisma migrate dev

  Pull the schema from an existing database, updating the Prisma schema
  $ prisma db pull

  Push the Prisma schema state to the database
  $ prisma db push

----------------------------------------

TITLE: Migration Diff Generation
DESCRIPTION: Command to generate SQL diff between production and local migration state

LANGUAGE: bash
CODE:
npx prisma migrate diff \
 --from-url "$DATABASE_URL_PROD" \
 --to-migrations ./prisma/migrations \
 --shadow-database-url $SHADOW_DATABASE_URL \
 --script > backward.sql

----------------------------------------

TITLE: Initializing Prisma Schema
DESCRIPTION: Command to initialize the Prisma schema, creating a prisma directory with schema.prisma file and a .env file for environment variables.

LANGUAGE: bash
CODE:
npx prisma init

----------------------------------------

TITLE: Installing Nuxt Prisma Module
DESCRIPTION: Terminal commands for creating a new Nuxt project and installing the Prisma module

LANGUAGE: terminal
CODE:
npx nuxi@latest init test-nuxt-app
cd test-nuxt-app
npx nuxi@latest module add @prisma/nuxt

----------------------------------------

TITLE: Setting Interactive Transaction Timeout in TypeScript
DESCRIPTION: Example of configuring a custom timeout duration for an interactive transaction using Prisma Client. The timeout value must match the limit set in Prisma Console.

LANGUAGE: typescript
CODE:
await prisma.$transaction(
  async (tx) => {
    // Your queries go here
  },
  {
    timeout: 30000, // 30s
  }
);

----------------------------------------

TITLE: Defining Prisma Schema for E-commerce Application
DESCRIPTION: Prisma schema defining models for an e-commerce application including CustomerOrder, OrderDetails, Product, Category, and Customer with their relationships.

LANGUAGE: prisma
CODE:
// Can have 1 customer
// Can have many order details
model CustomerOrder {
  id           Int            @id @default(autoincrement())
  createdAt    DateTime       @default(now())
  customer     Customer       @relation(fields: [customerId], references: [id])
  customerId   Int
  orderDetails OrderDetails[]
}

// Can have 1 order
// Can have many products
model OrderDetails {
  id        Int           @id @default(autoincrement())
  products  Product       @relation(fields: [productId], references: [id])
  productId Int
  order     CustomerOrder @relation(fields: [orderId], references: [id])
  orderId   Int
  total     Decimal
  quantity  Int
}

----------------------------------------

TITLE: Generating Prisma Client for JavaScript and PostgreSQL
DESCRIPTION: This command generates the Prisma Client library based on your Prisma schema. It should be run after any changes to the schema to update the client.

LANGUAGE: terminal
CODE:
npx prisma generate

----------------------------------------

TITLE: Generating SQL Migration for Adding Post Table
DESCRIPTION: This SQL script creates the Post table in Cloudflare D1, establishing a relation with the User table. It's generated using prisma migrate diff for a schema update.

LANGUAGE: sql
CODE:
-- CreateTable
CREATE TABLE "Post" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "title" TEXT NOT NULL,
    "authorId" INTEGER NOT NULL,
    CONSTRAINT "Post_authorId_fkey" FOREIGN KEY ("authorId") REFERENCES "User" ("id") ON DELETE RESTRICT ON UPDATE CASCADE
);

----------------------------------------

TITLE: Defining attributes in Prisma models
DESCRIPTION: Example of defining field and block attributes in Prisma models.

LANGUAGE: prisma
CODE:
model User {
  id        Int     @id @default(autoincrement())
  firstName String
  lastName  String
  email     String  @unique
  isAdmin   Boolean @default(false)

  @@unique([firstName, lastName])
}

----------------------------------------

TITLE: Mapping Enum Names and Values in Prisma
DESCRIPTION: Shows how to map enum values and names to different database representations using @map and @@map attributes.

LANGUAGE: prisma
CODE:
enum Type {
  Blog,
  Twitter @map("comment_twitter")

  @@map("comment_source_enum")
}

----------------------------------------

TITLE: RDS Postgres Connection Error Example
DESCRIPTION: Example of the connection error encountered when attempting to connect to AWS RDS Postgres without proper SSL configuration.

LANGUAGE: bash
CODE:
Error: P1010: User <username> was denied access on the database <database>

----------------------------------------

TITLE: Invoking Prisma CLI
DESCRIPTION: Example of how to invoke the Prisma CLI using npx after installation.

LANGUAGE: bash
CODE:
npx prisma

----------------------------------------

TITLE: Basic Prisma Schema Definition
DESCRIPTION: Default Prisma schema file with User and Post models using SQLite database

LANGUAGE: prisma
CODE:
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model User {
  id    Int     @id @default(autoincrement())
  email String  @unique
  name  String?
  posts Post[]
}

model Post {
  id        Int     @id @default(autoincrement())
  title     String
  content   String?
  published Boolean @default(false)
  author    User    @relation(fields: [authorId], references: [id])
  authorId  Int
}

----------------------------------------

TITLE: Displaying IPv6 Address Range for Prisma Accelerate Static IP
DESCRIPTION: This snippet demonstrates an example of IPv6 address ranges provided when enabling static IP for Prisma Accelerate. These addresses should be used to configure database firewall rules for allowing incoming connections.

LANGUAGE: plaintext
CODE:
2600:1f18:51ce:b00::/64
2600:1f18:5acb:9a00::/56

----------------------------------------

TITLE: Installing Specific Prisma Extension Example
DESCRIPTION: Example of installing a specific find-or-create extension package.

LANGUAGE: bash
CODE:
npm install prisma-extension-find-or-create

----------------------------------------

TITLE: Generating Prisma Client
DESCRIPTION: This command reads your Prisma schema and generates the Prisma Client library. It should be run after any changes to the schema.

LANGUAGE: shell
CODE:
npx prisma generate

----------------------------------------

TITLE: Deleting User Record with Prisma Client
DESCRIPTION: Shows how to delete a User record by email using Prisma Client's delete method

LANGUAGE: javascript
CODE:
const deletedUser = await prisma.user.delete({
  where: { email: 'sarah@prisma.io' },
})

----------------------------------------

TITLE: Configuring Prisma Schema for Supabase Direct URL
DESCRIPTION: Updates the Prisma schema datasource configuration to include both the pooled connection URL and direct connection URL for CLI operations.

LANGUAGE: prisma
CODE:
datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

----------------------------------------

TITLE: Configuring Prisma Schema for Supabase Direct URL
DESCRIPTION: Updates the Prisma schema datasource configuration to include both the pooled connection URL and direct connection URL for CLI operations.

LANGUAGE: prisma
CODE:
datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

----------------------------------------

TITLE: Configuring Prisma Relation Mode for PlanetScale
DESCRIPTION: Schema configuration to enable relation emulation in Prisma Client for PlanetScale compatibility. Sets relationMode to 'prisma' in the datasource block to handle relations without foreign key constraints.

LANGUAGE: prisma
CODE:
datasource db {
  provider     = "mysql"
  url          = env("DATABASE_URL")
  relationMode = "prisma"
}

----------------------------------------

TITLE: Using Prisma Client in Vercel Edge Function with PlanetScale
DESCRIPTION: Demonstrates how to instantiate PrismaClient and query a PlanetScale database in a Vercel Edge Function.

LANGUAGE: typescript
CODE:
import { NextResponse } from 'next/server'
import { PrismaClient } from '@prisma/client'
import { PrismaPlanetScale } from '@prisma/adapter-planetscale'
import { Client } from '@planetscale/database'

export const runtime = 'edge'

export async function GET(request: Request) {
  const client = new Client({ url: process.env.DATABASE_URL })
  const adapter = new PrismaPlanetScale(client)
  const prisma = new PrismaClient({ adapter })

  const users = await prisma.user.findMany()

  return NextResponse.json(users, { status: 200 })
}

----------------------------------------

TITLE: Setting preview environment database URL
DESCRIPTION: Example of a database connection string for a separate preview environment database to prevent conflicts with production data.

LANGUAGE: terminal
CODE:
postgresql://dbUsername:dbPassword@myhost:5432/mydb

----------------------------------------

TITLE: Initializing Prisma Project
DESCRIPTION: Command to initialize a new Prisma project by creating the schema file and environment configuration. Creates prisma/schema.prisma and .env files.

LANGUAGE: bash
CODE:
npx prisma init

----------------------------------------

TITLE: Prisma Client Global Instance Setup
DESCRIPTION: TypeScript code for creating a global Prisma Client instance with singleton pattern

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client'

const prismaClientSingleton = () => {
  return new PrismaClient()
}

declare const globalThis: {
  prismaGlobal: ReturnType<typeof prismaClientSingleton>;
} & typeof global;

const prisma = globalThis.prismaGlobal ?? prismaClientSingleton()

export default prisma

if (process.env.NODE_ENV !== 'production') globalThis.prismaGlobal = prisma

----------------------------------------

TITLE: Installing Prisma Client and Optimize Extension
DESCRIPTION: Command to install the required Prisma Client and Optimize extension packages.

LANGUAGE: bash
CODE:
npm install @prisma/client@latest @prisma/extension-optimize

----------------------------------------

TITLE: Transaction Wrapped Query Extension
DESCRIPTION: Example of wrapping an extended query in a batch transaction.

LANGUAGE: typescript
CODE:
const transactionExtension = Prisma.defineExtension((prisma) => 
  prisma.$extends({
    query: {
      user: {
        async findFirst({ args, query, operation }) {
          const [result] = await prisma.$transaction([query(args)])
          return result
        },
      },
    },
  })
)
const prisma = new PrismaClient().$extends(transactionExtension)

----------------------------------------

TITLE: Initializing Prisma Client and Defining Main Function in Node.js
DESCRIPTION: This snippet shows how to import and instantiate PrismaClient, define an async main function for database queries, and handle connection closure and error handling.

LANGUAGE: javascript
CODE:
const { PrismaClient } = require('@prisma/client')

const prisma = new PrismaClient()

async function main() {
  // ... you will write your Prisma Client queries here
}

main()
  .then(async () => {
    await prisma.$disconnect()
  })
  .catch(async (e) => {
    console.error(e)
    await prisma.$disconnect()
    process.exit(1)
  })

----------------------------------------

TITLE: Prisma Schema Database Configuration
DESCRIPTION: Prisma schema configuration for database connection using environment variable.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

----------------------------------------

TITLE: Starting TCP Tunnel for Prisma Postgres
DESCRIPTION: Command to start a TCP tunnel for secure connection to Prisma Postgres database.

LANGUAGE: bash
CODE:
npx @prisma/ppg-tunnel --host 127.0.0.1 --port 5433

----------------------------------------

TITLE: Configuring Supabase Direct and Pool URLs in Environment
DESCRIPTION: Sets up both DATABASE_URL for connection pooling and DIRECT_URL for CLI operations like migrations. The direct connection bypasses Supavisor for administrative tasks.

LANGUAGE: env
CODE:
# Connect to Supabase via connection pooling with Supavisor.
DATABASE_URL="postgres://postgres.[your-supabase-project]:[password]@aws-0-[aws-region].pooler.supabase.com:6543/postgres?pgbouncer=true"

# Direct connection to the database. Used for migrations.
DIRECT_URL="postgres://postgres.[your-supabase-project]:[password]@aws-0-[aws-region].pooler.supabase.com:5432/postgres"

----------------------------------------

TITLE: Prisma Schema Configuration with PgBouncer
DESCRIPTION: Datasource configuration in schema.prisma that enables both PgBouncer connection pooling and direct database access for migrations. Uses url for pooled connections and directUrl for direct database access.

LANGUAGE: prisma
CODE:
datasource db {
  provider  = "postgresql"
  url       = "postgres://USER:PASSWORD@HOST:PORT/DATABASE?pgbouncer=true"
  directUrl = "postgres://USER:PASSWORD@HOST:PORT/DATABASE"
}

----------------------------------------

TITLE: SQL Server Initial Schema Migration
DESCRIPTION: Generated SQL migration that creates tables for Post, Profile, and User entities with their relationships and constraints

LANGUAGE: sql
CODE:
CREATE TABLE [dbo].[Post] (
    [id] INT NOT NULL IDENTITY(1,1),
    [createdAt] DATETIME2 NOT NULL CONSTRAINT [Post_createdAt_df] DEFAULT CURRENT_TIMESTAMP,
    [updatedAt] DATETIME2 NOT NULL,
    [title] VARCHAR(255) NOT NULL,
    [content] NVARCHAR(1000),
    [published] BIT NOT NULL CONSTRAINT [Post_published_df] DEFAULT 0,
    [authorId] INT NOT NULL,
    CONSTRAINT [Post_pkey] PRIMARY KEY ([id])
);

CREATE TABLE [dbo].[Profile] (
    [id] INT NOT NULL IDENTITY(1,1),
    [bio] NVARCHAR(1000),
    [userId] INT NOT NULL,
    CONSTRAINT [Profile_pkey] PRIMARY KEY ([id]),
    CONSTRAINT [Profile_userId_key] UNIQUE ([userId])
);

CREATE TABLE [dbo].[User] (
    [id] INT NOT NULL IDENTITY(1,1),
    [email] NVARCHAR(1000) NOT NULL,
    [name] NVARCHAR(1000),
    CONSTRAINT [User_pkey] PRIMARY KEY ([id]),
    CONSTRAINT [User_email_key] UNIQUE ([email])
);

ALTER TABLE [dbo].[Post] ADD CONSTRAINT [Post_authorId_fkey] FOREIGN KEY ([authorId]) REFERENCES [dbo].[User]([id]) ON DELETE NO ACTION ON UPDATE CASCADE;

ALTER TABLE [dbo].[Profile] ADD CONSTRAINT [Profile_userId_fkey] FOREIGN KEY ([userId]) REFERENCES [dbo].[User]([id]) ON DELETE NO ACTION ON UPDATE CASCADE;

----------------------------------------

TITLE: Using Prisma in Nuxt Server Component
DESCRIPTION: Example of using Prisma Client in a Nuxt server component with the usePrismaClient composable

LANGUAGE: html
CODE:
<script setup>
  const prisma = usePrismaClient()
  const user = await prisma.user.findFirst()
</script>

<template>
  <p>{{ user.name }}</p>
</template>

----------------------------------------

TITLE: Defining a Prisma model with @db.Money type
DESCRIPTION: This snippet demonstrates how to use the @db.Money native type in a Prisma model. It shows the definition of an 'Item' model with a 'price' field of type Decimal mapped to @db.Money.

LANGUAGE: prisma
CODE:
model Item {
  // ...
  price Decimal @db.Money
  // ...
}

----------------------------------------

TITLE: Using $queryRawUnsafe for dynamic queries
DESCRIPTION: Use $queryRawUnsafe to execute a query with a raw string. This method carries SQL injection risks if not used carefully.

LANGUAGE: typescript
CODE:
const result = await prisma.$queryRawUnsafe("SELECT * FROM User");

----------------------------------------

TITLE: Querying All Users with Prisma Client in Node.js
DESCRIPTION: This code demonstrates how to use Prisma Client to query all User records from the database and log the results.

LANGUAGE: javascript
CODE:
async function main() {
  const allUsers = await prisma.user.findMany()
  console.log(allUsers)
}

----------------------------------------

TITLE: Deleting a User with Prisma Client in JavaScript
DESCRIPTION: This code shows how to delete a User record using Prisma Client based on the user's email address.

LANGUAGE: javascript
CODE:
const deletedUser = await prisma.user.delete({
  where: { email: 'sarah@prisma.io' },
})

----------------------------------------

TITLE: Database Import with pg_restore
DESCRIPTION: Command to import data into Prisma Postgres using pg_restore through TCP tunnel.

LANGUAGE: bash
CODE:
PGSSLMODE=disable \
pg_restore \
  -h 127.0.0.1 \
  -p 5433 \
  -v \
  -d postgres \
  ./db_dump.bak \
&& echo "-complete-"

----------------------------------------

TITLE: Defining a User Model with Autoincrement in Prisma Schema
DESCRIPTION: Prisma schema definition for a 'User' model demonstrating the use of autoincrement() for generating unique identifiers in CockroachDB.

LANGUAGE: prisma
CODE:
model User {
  id   BigInt @id @default(autoincrement())
  name String
}

----------------------------------------

TITLE: Mapping Model Names in Prisma Schema
DESCRIPTION: Shows how to map a Prisma model name to a different database table name using the @@map attribute. This example maps the 'Comment' model to a 'comments' table.

LANGUAGE: prisma
CODE:
model Comment {
  // Fields

  @@map("comments")
}

----------------------------------------

TITLE: Defining Crawler Access Rules for Prisma Documentation Site
DESCRIPTION: Configures web crawler behavior by preventing access to search and pagination URLs while providing sitemap information. Blocks access to URLs containing query and page parameters to prevent duplicate content indexing.

LANGUAGE: robotstxt
CODE:
User-agent: *
Disallow: /
Disallow: /*?query=*
Disallow: /*?page=*
Disallow: /*&query=*
Disallow: /*&page=*
Sitemap: https://www.prisma.io/docs/sitemap.xml
Host: https://www.prisma.io

----------------------------------------

TITLE: Invoking Prisma CLI
DESCRIPTION: Command to run Prisma CLI using npx.

LANGUAGE: terminal
CODE:
npx prisma

----------------------------------------

TITLE: Defining Prisma Schema
DESCRIPTION: Prisma schema file defining User and Post models with their relationships

LANGUAGE: prisma
CODE:
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model User {
  id    Int     @id @default(autoincrement())
  email String  @unique
  name  String?
  posts Post[]
}

model Post {
  id        Int     @id @default(autoincrement())
  title     String
  content   String?
  published Boolean @default(false)
  author    User    @relation(fields: [authorId], references: [id])
  authorId  Int
}

----------------------------------------

TITLE: Package.json Migration Script Configuration
DESCRIPTION: NPM script configuration for running the data migration process.

LANGUAGE: json
CODE:
{
  "scripts": {
    "data-migration:add-status-column": "tsx ./prisma/migrations/<migration-timestamp>/data-migration.ts"
  }
}

----------------------------------------

TITLE: Using variables in a $queryRaw query
DESCRIPTION: Demonstrates how to safely use variables in a $queryRaw query using tagged templates.

LANGUAGE: typescript
CODE:
const email = "emelie@prisma.io";
const result = await prisma.$queryRaw`SELECT * FROM User WHERE email = ${email}`;

----------------------------------------

TITLE: Render Blueprint Configuration (YAML)
DESCRIPTION: YAML configuration for Render Blueprint, defining the web service and PostgreSQL database setup.

LANGUAGE: yaml
CODE:
# Web service configuration
Build Command: npm install --production=false
Pre-Deploy Command: npx prisma migrate deploy
Start Command: npm run start

----------------------------------------

TITLE: Reading Data with Prisma Client
DESCRIPTION: Example of querying all users from the database using Prisma Client's findMany method.

LANGUAGE: typescript
CODE:
async function main() {
  const allUsers = await prisma.user.findMany()
  console.log(allUsers)
}

----------------------------------------

TITLE: Creating a Post Table in CockroachDB
DESCRIPTION: SQL command to create a 'Post' table in CockroachDB with 'id' and 'title' fields.

LANGUAGE: sql
CODE:
CREATE TABLE public."Post" (
  "id" INT8 NOT NULL,
  "title" VARCHAR(200) NOT NULL,
  CONSTRAINT "Post_pkey" PRIMARY KEY ("id" ASC),
  FAMILY "primary" ("id", "title")
);

----------------------------------------

TITLE: Creating Project Directory
DESCRIPTION: Commands to create and navigate into a new project directory for the Prisma MongoDB application.

LANGUAGE: terminal
CODE:
mkdir hello-prisma
cd hello-prisma

----------------------------------------

TITLE: Running Prisma introspection command
DESCRIPTION: This command uses Prisma CLI to introspect the connected database and generate a Prisma schema based on the existing database structure.

LANGUAGE: shell
CODE:
npx prisma db pull

----------------------------------------

TITLE: Introspecting MongoDB database
DESCRIPTION: Runs Prisma introspection to create a schema from the existing MongoDB database.

LANGUAGE: shell
CODE:
npx prisma db pull

----------------------------------------

TITLE: Full-text search with raw SQL for MySQL
DESCRIPTION: Example of using TypedSQL to perform full-text search with MySQL's MATCH AGAINST function.

LANGUAGE: sql
CODE:
SELECT * FROM Blog WHERE MATCH(content) AGAINST(${term} IN NATURAL LANGUAGE MODE);

LANGUAGE: typescript
CODE:
const term = `cat`
const result = await prisma.$queryRawTyped(fullTextSearch(term))

----------------------------------------

TITLE: Initializing Prisma Client and Basic Query Structure in TypeScript
DESCRIPTION: This snippet demonstrates how to import and instantiate PrismaClient, define an async main function for database queries, and handle connection management and error handling.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

async function main() {
  // ... you will write your Prisma Client queries here
}

main()
  .then(async () => {
    await prisma.$disconnect()
  })
  .catch(async (e) => {
    console.error(e)
    await prisma.$disconnect()
    process.exit(1)
  })

----------------------------------------

TITLE: Updating a Post Record with Prisma Client in TypeScript
DESCRIPTION: Demonstrates how to update an existing Post record by changing its 'published' status to true. This example uses the update method of Prisma Client's Post model.

LANGUAGE: typescript
CODE:
async function main() {
  const post = await prisma.post.update({
    where: { id: 1 },
    data: { published: true },
  })
  console.log(post)
}

----------------------------------------

TITLE: Updating a Post Record with Prisma Client in TypeScript
DESCRIPTION: Demonstrates how to update an existing Post record by changing its 'published' status to true. This example uses the update method of Prisma Client's Post model.

LANGUAGE: typescript
CODE:
async function main() {
  const post = await prisma.post.update({
    where: { id: 1 },
    data: { published: true },
  })
  console.log(post)
}

----------------------------------------

TITLE: Installing Prisma CLI Dependencies
DESCRIPTION: Command to install the Prisma CLI as a development dependency in the project.

LANGUAGE: bash
CODE:
npm install prisma --save-dev

----------------------------------------

TITLE: TypeORM Entity Class Definition
DESCRIPTION: Example of defining a User entity class in TypeORM with decorators to map class properties to database columns

LANGUAGE: typescript
CODE:
import { Entity, PrimaryGeneratedColumn, Column } from 'typeorm'

@Entity()
export class User {
  @PrimaryGeneratedColumn()
  id: number

  @Column({ name: 'first_name' })
  firstName: string

  @Column({ name: 'last_name' })
  lastName: string

  @Column({ unique: true })
  email: string
}

----------------------------------------

TITLE: Configuring Prisma Schema for D1
DESCRIPTION: Defines the Prisma schema configuration with driver adapters preview feature and a basic User model for SQLite database.

LANGUAGE: prisma
CODE:
generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["driverAdapters"]
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model User {
  id    Int     @id @default(autoincrement())
  email String  @unique
  name  String?
}

----------------------------------------

TITLE: Comparing Date Columns with Raw Query in PostgreSQL/CockroachDB
DESCRIPTION: Execute a raw SQL query to compare completedDate and dueDate columns in the Project table for PostgreSQL or CockroachDB.

LANGUAGE: javascript
CODE:
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

async function initiateDatesComparisonRawQuery() {
  const response =
    await prisma.$queryRaw`SELECT * FROM "public"."Project" WHERE "completedDate" > "dueDate";`

  console.log(response)
}

await initiateDatesComparisonRawQuery()

----------------------------------------

TITLE: Updating Main App Template
DESCRIPTION: Main app.vue template file incorporating the User server component

LANGUAGE: html
CODE:
<template>
  <div>
    <NuxtIsland name="User"></NuxtIsland>
  </div>
</template>

----------------------------------------

TITLE: Configuring error format using PrismaClient constructor in TypeScript
DESCRIPTION: This snippet demonstrates how to set the error format using the PrismaClient constructor. The 'errorFormat' parameter is used to specify the desired error formatting level.

LANGUAGE: typescript
CODE:
const prisma = new PrismaClient({
  errorFormat: 'pretty',
})

----------------------------------------

TITLE: Querying All Users with Prisma Client in TypeScript
DESCRIPTION: This code snippet shows how to use Prisma Client to query all User records from the database and print the result.

LANGUAGE: typescript
CODE:
async function main() {
  const allUsers = await prisma.user.findMany()
  console.log(allUsers)
}

----------------------------------------

TITLE: Creating a View in SQL (Relational Databases)
DESCRIPTION: SQL statement to create a UserInfo view that combines fields from User and Profile models in a relational database.

LANGUAGE: sql
CODE:
CREATE VIEW "UserInfo" AS
    SELECT u.id, email, name, bio
    FROM "User" u
    LEFT JOIN "Profile" p ON u.id = p."userId";

----------------------------------------

TITLE: Retrieving Posts Using Fluent Relations API
DESCRIPTION: Demonstrates using Prisma's fluent relations API to traverse relationships from Profile to User to Posts

LANGUAGE: javascript
CODE:
const posts = await prisma.profile
  .findUnique({
    where: { id: 1 },
  })
  .user()
  .posts()

----------------------------------------

TITLE: MongoDB Document Structure Example
DESCRIPTION: Example of a MongoDB document structure showing basic document fields and values.

LANGUAGE: javascript
CODE:
{
  _id: '607ee94800bbe41f001fd568',
  slug: 'prisma-loves-mongodb',
  title: 'Prisma <3 MongoDB',
  body: "This is my first post. Isn't MongoDB + Prisma awesome?!"
}

----------------------------------------

TITLE: Configuring Database Switcher in YAML Front Matter
DESCRIPTION: This snippet demonstrates how to configure a database switcher for a page using YAML front matter. It lists several database options including PostgreSQL, MySQL, SQL Server, PlanetScale, and CockroachDB.

LANGUAGE: yaml
CODE:
dbSwitcher: ['postgresql', 'mysql', 'sqlserver', 'planetscale', 'cockroachdb']

----------------------------------------

TITLE: Implementing Computed Fields Without Client Extensions (TypeScript)
DESCRIPTION: This snippet shows an alternative approach to implementing computed fields for versions prior to Prisma ORM 4.16.0. It defines types and a function to compute the full name.

LANGUAGE: typescript
CODE:
// Define a type that needs a first and last name
type FirstLastName = {
  firstName: string
  lastName: string
}

// Extend the T generic with the fullName attribute
type WithFullName<T> = T & {
  fullName: string
}

// Take objects that satisfy FirstLastName and computes a full name
function computeFullName<User extends FirstLastName>(
  user: User
): WithFullName<User> {
  return {
    ...user,
    fullName: user.firstName + ' ' + user.lastName,
  }
}

async function main() {
  const user = await prisma.user.findUnique({ where: 1 })
  const userWithFullName = computeFullName(user)
}

----------------------------------------

TITLE: Initializing Prisma Client and Basic Query Structure in TypeScript
DESCRIPTION: Sets up Prisma Client, defines a main function for queries, and handles database connection and error management. This structure is used as a foundation for subsequent database operations.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

async function main() {
  // ... you will write your Prisma Client queries here
}

main()
  .then(async () => {
    await prisma.$disconnect()
  })
  .catch(async (e) => {
    console.error(e)
    await prisma.$disconnect()
    process.exit(1)
  })

----------------------------------------

TITLE: Explicit Many-to-Many Relations in Prisma Schema
DESCRIPTION: Demonstrates correct implementation of explicit many-to-many relationships using a join table. Shows proper relation field definitions between models.

LANGUAGE: prisma
CODE:
model Post {
  id             Int              @id @default(autoincrement())
  title          String
  postCategories PostCategories[]
}

model PostCategories {
  post       Post     @relation(fields: [postId], references: [id])
  postId     Int
  category   Category @relation(fields: [categoryId], references: [id])
  categoryId Int
  @@id([postId, categoryId])
}

model Category {
  id             Int              @id @default(autoincrement())
  name           String
  postCategories PostCategories[]
}

----------------------------------------

TITLE: Specifying Relative Path for SQLite Database in Prisma Schema
DESCRIPTION: This example demonstrates how to specify a relative path for the SQLite database file in the Prisma schema. Both snippets are equivalent, showing that './' is optional for files in the same directory.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "sqlite"
  url      = "file:./dev.db"
}

LANGUAGE: prisma
CODE:
datasource db {
  provider = "sqlite"
  url      = "file:dev.db"
}

----------------------------------------

TITLE: Initializing Prisma Client and Basic Query Structure in TypeScript
DESCRIPTION: Sets up Prisma Client, defines a main function for queries, and handles database connection and error management. This structure is used as a foundation for subsequent database operations.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

async function main() {
  // ... you will write your Prisma Client queries here
}

main()
  .then(async () => {
    await prisma.$disconnect()
  })
  .catch(async (e) => {
    console.error(e)
    await prisma.$disconnect()
    process.exit(1)
  })

----------------------------------------

TITLE: Querying All Users with Prisma Client
DESCRIPTION: Demonstrates a simple query to retrieve all User records from the database using Prisma Client's findMany method.

LANGUAGE: typescript
CODE:
async function main() {
  const allUsers = await prisma.user.findMany()
  console.log(allUsers)
}

----------------------------------------

TITLE: Installing Prisma CLI Dependencies
DESCRIPTION: Command to install Prisma CLI as a development dependency in an existing Node.js project.

LANGUAGE: terminal
CODE:
npm install prisma --save-dev

----------------------------------------

TITLE: Implementing Cache Invalidation
DESCRIPTION: Example of using $accelerate.invalidate API to invalidate cached queries by tags, including error handling for rate limits.

LANGUAGE: typescript
CODE:
try {
  await prisma.$accelerate.invalidate({
    tags: ["emails_with_alice"],
  });
} catch (e) {
  if (e instanceof Prisma.PrismaClientKnownRequestError) {
    if (e.code === "P6003") {
      console.log(
        "The cache invalidation rate limit has been reached. Please try again later."
      );
    }
  }
  throw e;
}

----------------------------------------

TITLE: Starting Prisma TCP Tunnel
DESCRIPTION: Command to start the TCP tunnel using the @prisma/ppg-tunnel package. The tunnel starts on a random port and displays connection details.

LANGUAGE: terminal
CODE:
npx @prisma/ppg-tunnel

----------------------------------------

TITLE: Enabling PostgreSQL Extension via SQL
DESCRIPTION: SQL command to enable the pgcrypto extension in PostgreSQL for versions prior to Prisma 4.5.0.

LANGUAGE: sql
CODE:
CREATE EXTENSION IF NOT EXISTS pgcrypto;

----------------------------------------

TITLE: Backing Up EA Database with pg_dump
DESCRIPTION: Command to create a backup of the EA database using pg_dump through the secure tunnel.

LANGUAGE: bash
CODE:
PGSSLMODE=disable \
pg_dump \
  -h 127.0.0.1 \
  -p 5432 \
  -Fc \
  -v \
  -d postgres \
  -f ./mydatabase.bak \
&& echo "-complete-"

----------------------------------------

TITLE: Querying All Users with Prisma Client in TypeScript
DESCRIPTION: Demonstrates how to use Prisma Client to query all User records from the database and log the results.

LANGUAGE: typescript
CODE:
async function main() {
  const allUsers = await prisma.user.findMany()
  console.log(allUsers)
}

----------------------------------------

TITLE: Creating Related Records with Nested Writes
DESCRIPTION: Demonstrates creating a new user record with related post and profile records using Prisma Client's nested write capabilities.

LANGUAGE: typescript
CODE:
await prisma.user.create({
  data: {
    name: 'Alice',
    email: 'alice@prisma.io',
    posts: {
      create: { title: 'Hello World' },
    },
    profile: {
      create: { bio: 'I like turtles' },
    },
  },
})

const allUsers = await prisma.user.findMany({
  include: {
    posts: true,
    profile: true,
  },
})
console.dir(allUsers, { depth: null })

----------------------------------------

TITLE: Database Connection Configuration
DESCRIPTION: Example of the database connection URL configuration in the .env file for Prisma Postgres.

LANGUAGE: bash
CODE:
DATABASE_URL="prisma+postgres://accelerate.prisma-data.net/?api_key=ey...."

----------------------------------------

TITLE: Creating Related Records with Nested Writes
DESCRIPTION: Demonstrates creating a new user record with related post and profile records using Prisma Client's nested write capabilities.

LANGUAGE: typescript
CODE:
await prisma.user.create({
  data: {
    name: 'Alice',
    email: 'alice@prisma.io',
    posts: {
      create: { title: 'Hello World' },
    },
    profile: {
      create: { bio: 'I like turtles' },
    },
  },
})

const allUsers = await prisma.user.findMany({
  include: {
    posts: true,
    profile: true,
  },
})
console.dir(allUsers, { depth: null })

----------------------------------------

TITLE: Configuring MongoDB Datasource in Prisma Schema
DESCRIPTION: This snippet shows how to set up the datasource block in the Prisma schema file to connect to a MongoDB database. It uses an environment variable for the database URL.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

----------------------------------------

TITLE: Creating Prisma Seed Script for Database Population
DESCRIPTION: This snippet demonstrates how to create a Prisma seed script for populating User, Organization, and Subscription models with sample data.

LANGUAGE: typescript
CODE:
import { PrismaClient } from "@prisma/client";

const prisma = new PrismaClient();

async function main() {
  await prisma.organization.create({
    data: {
      name: "Prisma Corp",
      slug: "prisma-corp",
      subscription: {
        create: {
          plan: "PRO",
          status: "ACTIVE"
        }
      },
      users: {
        create: [
          { name: "Alice Doe", email: "alice@prisma.io" },
          { name: "Bob Smith", email: "bob@prisma.io" }
        ]
      }
    }
  });

  console.log("Seed data created successfully");
}

main()
  .catch((e) => {
    console.error(e);
    process.exit(1);
  })
  .finally(async () => {
    await prisma.$disconnect();
  });

----------------------------------------

TITLE: Configuring Custom Model and Field Names in Prisma Schema
DESCRIPTION: Example of using @map and @@map to customize model and field names in the Prisma schema without changing the underlying database structure.

LANGUAGE: prisma
CODE:
model MyUser {
  userId    Int     @id @default(autoincrement()) @map("user_id")
  firstName String? @map("first_name")
  lastName  String  @unique @map("last_name")

  @@map("my_user")
}

----------------------------------------

TITLE: Representing PostgreSQL Extensions in Prisma Schema
DESCRIPTION: Add the extensions field to the datasource block in the Prisma schema to list required PostgreSQL extensions with optional arguments for schema, version, and mapping.

LANGUAGE: prisma
CODE:
datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  extensions = [hstore(schema: "myHstoreSchema"), pg_trgm, postgis(version: "2.1")]
}

----------------------------------------

TITLE: Initializing Prisma Postgres Database
DESCRIPTION: Command to initialize a new Prisma Postgres database instance using the CLI.

LANGUAGE: terminal
CODE:
npx prisma@latest init --db

----------------------------------------

TITLE: Updating a Post with Prisma Client in TypeScript
DESCRIPTION: Demonstrates how to update an existing Post record by changing its 'published' status to true.

LANGUAGE: typescript
CODE:
async function main() {
  const post = await prisma.post.update({
    where: { id: 1 },
    data: { published: true },
  })
  console.log(post)
}

----------------------------------------

TITLE: UI Element References in Steps
DESCRIPTION: Examples of correct and incorrect ways to reference UI elements at the beginning of documentation steps.

LANGUAGE: markdown
CODE:
<!-- Bad -->

1. Enter a name for your project in **Display Name**.
2. Select a GitHub account or an organization from **GitHub Accounts & Organizations**.
3. Select **Create a repository**.
4. (Optional) Enter a name for the repository in **Repository Name**.

<!-- Good -->

1. In **Display Name**, enter a name for your project.
2. From the **GitHub Accounts & Organizations** drop-down menu, select a GitHub account or an organization.
3. Select **Create a repository**.
4. (Optional) In **Repository Name**, enter a name for the repository.

----------------------------------------

TITLE: Updating Post Record with Prisma Client
DESCRIPTION: Shows how to update an existing post record using Prisma Client's update method with where clause filtering.

LANGUAGE: typescript
CODE:
const post = await prisma.post.update({
  where: { id: 1 },
  data: { published: true },
})
console.log(post)

----------------------------------------

TITLE: Creating Nested Records with Prisma Client in TypeScript
DESCRIPTION: This snippet demonstrates how to create a new user record along with associated post and profile records using a nested write query. It also shows how to fetch and display the created records with their relations included.

LANGUAGE: typescript
CODE:
async function main() {
  await prisma.user.create({
    data: {
      name: 'Alice',
      email: 'alice@prisma.io',
      posts: {
        create: { title: 'Hello World' },
      },
      profile: {
        create: { bio: 'I like turtles' },
      },
    },
  })

  const allUsers = await prisma.user.findMany({
    include: {
      posts: true,
      profile: true,
    },
  })
  console.dir(allUsers, { depth: null })
}

----------------------------------------

TITLE: Querying All Users with Prisma Client in JavaScript
DESCRIPTION: Demonstrates how to use Prisma Client to query all users from the database. This basic read operation retrieves all records from the User table and logs them to the console.

LANGUAGE: javascript
CODE:
async function main() {
  const allUsers = await prisma.user.findMany()
  console.log(allUsers)
}

----------------------------------------

TITLE: Error Handling for Delete Operations
DESCRIPTION: TypeScript example showing how to handle foreign key constraint errors when deleting records with referential actions.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

async function main() {
  try {
    await prisma.user.delete({
      where: {
        id: 'some-long-id'
      }
    })
  } catch (error) {
    if (error instanceof Prisma.PrismaClientKnownRequestError) {
      if (error.code === 'P2003') {
        console.log(error.message)
      }
    }
  }
}

main()
  .then(async () => {
    await prisma.$disconnect()
  })
  .catch(async (e) => {
    console.error(e)
    await prisma.$disconnect()
    process.exit(1)
  })

----------------------------------------

TITLE: Querying All Users with Prisma Client
DESCRIPTION: Demonstrates a simple query to retrieve all users from the database using Prisma Client's findMany method.

LANGUAGE: javascript
CODE:
async function main() {
  const allUsers = await prisma.user.findMany()
  console.log(allUsers)
}

----------------------------------------

TITLE: Generated SQL Migration for Native Types
DESCRIPTION: SQL migration generated by Prisma Migrate showing how the Prisma schema native types are translated into actual PostgreSQL column definitions with VARCHAR constraints.

LANGUAGE: sql
CODE:
  -- CreateTable
CREATE TABLE "User" (
    "id" SERIAL,
    "name" VARCHAR(200) NOT NULL,
    PRIMARY KEY ("id")
);
  -- CreateTable
CREATE TABLE "Post" (
    "id" SERIAL,
    "title" VARCHAR(150) NOT NULL,
    "published" BOOLEAN NOT NULL DEFAULT true,
    "authorId" INTEGER NOT NULL,
    PRIMARY KEY ("id")
);

  -- AddForeignKey
ALTER TABLE "Post" ADD FOREIGN KEY("authorId")REFERENCES "User"("id") ON DELETE CASCADE ON UPDATE CASCADE;

----------------------------------------

TITLE: Initializing Prisma Client with TypeScript
DESCRIPTION: Basic setup code for initializing PrismaClient and creating a main function for database operations with proper error handling and connection management.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

async function main() {
  // ... you will write your Prisma Client queries here
}

main()
  .then(async () => {
    await prisma.$disconnect()
  })
  .catch(async (e) => {
    console.error(e)
    await prisma.$disconnect()
    process.exit(1)
  })

----------------------------------------

TITLE: Updating Prisma Schema with Tag Model and Relationship
DESCRIPTION: This snippet shows how to add a new 'Tag' model and update the 'Post' model in a Prisma schema. It includes fields for both models and establishes a many-to-many relationship between them.

LANGUAGE: prisma
CODE:
model Post {
  id        Int      @id @default(autoincrement())
  title     String   @db.VarChar(255)
  createdAt DateTime @default(now()) @db.Timestamp(6)
  content   String?
  published Boolean  @default(false)
  authorId  Int
  user      User     @relation(fields: [authorId], references: [id])
  tags      Tag[]
}

model Profile {
  id     Int     @id @default(autoincrement())
  bio    String?
  userId Int     @unique
  user   User    @relation(fields: [userId], references: [id])
}

model User {
  id      Int      @id @default(autoincrement())
  name    String?  @db.VarChar(255)
  email   String   @unique @db.VarChar(255)
  post    Post[]
  profile Profile?
}

model Tag {
  id    Int    @id @default(autoincrement())
  name  String
  posts Post[]
}

----------------------------------------

TITLE: Running Prisma Introspection Command
DESCRIPTION: Terminal command to introspect the MongoDB database and generate the Prisma schema.

LANGUAGE: terminal
CODE:
npx prisma db pull

----------------------------------------

TITLE: Querying All Users with Prisma Client in JavaScript
DESCRIPTION: Demonstrates how to use Prisma Client to query all users from the database. This basic read operation retrieves all records from the User table and logs them to the console.

LANGUAGE: javascript
CODE:
async function main() {
  const allUsers = await prisma.user.findMany()
  console.log(allUsers)
}

----------------------------------------

TITLE: Updating a Post Record with Prisma Client in JavaScript
DESCRIPTION: Demonstrates how to update an existing Post record in the database using Prisma Client. This example updates the 'published' status of a post with a specific ID.

LANGUAGE: javascript
CODE:
async function main() {
  const post = await prisma.post.update({
    where: { id: 1 },
    data: { published: true },
  })
  console.log(post)
}

----------------------------------------

TITLE: Updating Composite List Operations for MongoDB in Prisma Client
DESCRIPTION: Operations on lists of Composite types for MongoDB now only accept array values in Prisma ORM 5.

LANGUAGE: javascript
CODE:
prisma.post.findMany({
  where: {
    commentsList: {
      equals: [{ text: 'hello' }],
    },
  },
})

----------------------------------------

TITLE: Updating Records with Prisma Client
DESCRIPTION: Demonstrates how to update an existing record in the database using Prisma Client's update method.

LANGUAGE: javascript
CODE:
async function main() {
  const post = await prisma.post.update({
    where: { title: 'Hello World' },
    data: { published: true },
  })
  console.log(post)
}

----------------------------------------

TITLE: Generate Down Migration Using Shadow Database
DESCRIPTION: Command to generate down migration SQL using migrate diff with shadow database comparison.

LANGUAGE: bash
CODE:
npx prisma migrate diff \
 --from-schema-datamodel prisma/schema.prisma \
 --to-migrations prisma/migrations \
 --shadow-database-url $SHADOW_DATABASE_URL \
 --script > down.sql

----------------------------------------

TITLE: Auto-Generated Prisma Schema from MongoDB Introspection
DESCRIPTION: The Prisma schema generated after introspecting the MongoDB database, containing User and Post models with their basic fields and MongoDB-specific type mappings.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model Post {
  id     String @id @default(auto()) @map("_id") @db.ObjectId
  title  String
  userId String @db.ObjectId
}

model User {
  id    String @id @default(auto()) @map("_id") @db.ObjectId
  email String
}

----------------------------------------

TITLE: Installing Prisma CLI as a Development Dependency
DESCRIPTION: Adds the Prisma CLI to the project as a development dependency using npm. This allows you to use Prisma commands in your project.

LANGUAGE: bash
CODE:
npm install prisma --save-dev

----------------------------------------

TITLE: Next.js Page Implementation with Multiple Clients
DESCRIPTION: TypeScript implementation of the Next.js page component that fetches and displays data from both databases.

LANGUAGE: typescript
CODE:
import { postDBPrismaClient } from "@/lib/post-prisma-client";
import { userDBPrismaClient } from "@/lib/user-prisma-client";

export default async function Home() {
  const user = await userDBPrismaClient.user.findFirst();
  const post = await postDBPrismaClient.post.findFirst();

  return (
    <main className="min-h-screen bg-gray-50 py-12">
      <div className="max-w-4xl mx-auto px-4">
        <header className="mb-12 text-center">
          <h1 className="text-5xl font-extrabold text-gray-900">Multi-DB Showcase</h1>
          <p className="mt-4 text-xl text-gray-600">
            Data fetched from two distinct databases.
          </p>
        </header>

        <section className="mb-8 bg-white shadow-md rounded-lg p-6">
          <h2 className="text-2xl font-semibold text-gray-800 border-b pb-2 mb-4">
            User Data
          </h2>
          <pre className="whitespace-pre-wrap text-sm text-gray-700">
            {user ? JSON.stringify(user, null, 2) : "No user data available."}
          </pre>
        </section>

        <section className="bg-white shadow-md rounded-lg p-6">
          <h2 className="text-2xl font-semibold text-gray-800 border-b pb-2 mb-4">
            Post Data
          </h2>
          <pre className="whitespace-pre-wrap text-sm text-gray-700">
            {post ? JSON.stringify(post, null, 2) : "No post data available."}
          </pre>
        </section>
      </div>
    </main>
  );
}

----------------------------------------

TITLE: Installing Prisma Client Package
DESCRIPTION: Command to install the @prisma/client package via npm, which is required for using Prisma Client in your project.

LANGUAGE: terminal
CODE:
npm install @prisma/client

----------------------------------------

TITLE: Initializing PrismaClient and Basic Query Structure in JavaScript
DESCRIPTION: Sets up PrismaClient, defines a main function for database operations, and includes error handling and connection management. This structure is used as a foundation for subsequent database queries.

LANGUAGE: javascript
CODE:
const { PrismaClient } = require('@prisma/client')

const prisma = new PrismaClient()

async function main() {
  // ... you will write your Prisma Client queries here
}

main()
  .then(async () => {
    await prisma.$disconnect()
  })
  .catch(async (e) => {
    console.error(e)
    await prisma.$disconnect()
    process.exit(1)
  })

----------------------------------------

TITLE: Installing Prisma CLI v2
DESCRIPTION: Command to install Prisma v2 CLI as a development dependency

LANGUAGE: terminal
CODE:
npm install prisma --save-dev

----------------------------------------

TITLE: Setting MongoDB Connection URL in Environment
DESCRIPTION: Example of setting the MongoDB connection URL in the .env file. Uses MongoDB Atlas connection string format.

LANGUAGE: bash
CODE:
DATABASE_URL="mongodb+srv://test:test@cluster0.ns1yp.mongodb.net/myFirstDatabase"

----------------------------------------

TITLE: Raw Query Type Mapping Example
DESCRIPTION: Example showing how raw queries deserialize scalar values to their corresponding JavaScript types in Prisma ORM 4.

LANGUAGE: typescript
CODE:
const res = await prisma.$queryRaw`SELECT bigint, bytes, decimal, date FROM "Table";`
console.log(res) // [{ bigint: BigInt("123"), bytes: Buffer.from([1, 2]), decimal: new Prisma.Decimal("12.34"), date: Date("<some_date>") }]

----------------------------------------

TITLE: Enhanced Prisma Schema with Relations
DESCRIPTION: Modified Prisma schema that adds relationships between User and Post models using the @relation attribute.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model Post {
  id     String @id @default(auto()) @map("_id") @db.ObjectId
  title  String
  userId String @db.ObjectId
  user   User   @relation(fields: [userId], references: [id])
}

model User {
  id    String @id @default(auto()) @map("_id") @db.ObjectId
  email String
  posts Post[]
}

----------------------------------------

TITLE: Invoking Prisma CLI
DESCRIPTION: Command to invoke the Prisma CLI using npx prefix to verify installation.

LANGUAGE: bash
CODE:
npx prisma

----------------------------------------

TITLE: Configuring CockroachDB Datasource in Prisma Schema
DESCRIPTION: Modified Prisma schema configuration specifically for CockroachDB. Changes the provider from postgresql to cockroachdb while maintaining the environment variable connection URL.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "cockroachdb"
  url      = env("DATABASE_URL")
}

----------------------------------------

TITLE: Configuring CockroachDB Datasource in Prisma Schema
DESCRIPTION: Modified Prisma schema configuration specifically for CockroachDB. Changes the provider from postgresql to cockroachdb while maintaining the environment variable connection URL.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "cockroachdb"
  url      = env("DATABASE_URL")
}

----------------------------------------

TITLE: Running Prisma Migration
DESCRIPTION: Command to create and execute the initial database migration. Creates a new SQL migration file and applies it to the database, automatically running the generate command afterward.

LANGUAGE: terminal
CODE:
npx prisma migrate dev --name init

----------------------------------------

TITLE: Creating Related Records with Prisma Client
DESCRIPTION: Demonstrates how to create a User record with nested creation of related Post and Profile records using Prisma Client's nested write functionality.

LANGUAGE: javascript
CODE:
async function main() {
  await prisma.user.create({
    data: {
      name: 'Alice',
      email: 'alice@prisma.io',
      posts: {
        create: { title: 'Hello World' },
      },
      profile: {
        create: { bio: 'I like turtles' },
      },
    },
  })

  const allUsers = await prisma.user.findMany({
    include: {
      posts: true,
      profile: true,
    },
  })
  console.dir(allUsers, { depth: null })
}

----------------------------------------

TITLE: Initializing Prisma Client in Node.js
DESCRIPTION: Sets up the Prisma Client instance and defines the main execution structure with proper connection handling and error management.

LANGUAGE: javascript
CODE:
const { PrismaClient } = require('@prisma/client')

const prisma = new PrismaClient()

async function main() {
  // ... you will write your Prisma Client queries here
}

main()
  .then(async () => {
    await prisma.$disconnect()
  })
  .catch(async (e) => {
    console.error(e)
    await prisma.$disconnect()
    process.exit(1)
  })

----------------------------------------

TITLE: Defining an enum
DESCRIPTION: Defines an enum type with possible values.

LANGUAGE: prisma
CODE:
enum Role {
  USER
  ADMIN
}

model User {
  id   Int  @id @default(autoincrement())
  role Role
}

----------------------------------------

TITLE: Configuring MongoDB Datasource in Prisma Schema
DESCRIPTION: Defines the MongoDB datasource configuration in schema.prisma file. Uses environment variable for the database connection URL.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

----------------------------------------

TITLE: Configuring GraphQL Schema with @nexus/schema
DESCRIPTION: Shows how to configure a GraphQL schema using makeSchema from @nexus/schema with the Prisma plugin enabled

LANGUAGE: typescript
CODE:
const schema = makeSchema({
  types: [Query, Mutation, UserUniqueInput, User, Post, Category, Profile],
  plugins: [nexusSchemaPrisma({
    experimentalCRUD: true,
  })],
  outputs: {
    schema: path.join(__dirname, './generated/schema.graphql'),
    typegen: path.join(__dirname, './generated/nexus.ts'),
  },
  nonNullDefaults: {
    input: false,
    output: false,
  },
  typegenAutoConfig: {
    sources: [
      {
        source: path.join(__dirname, './types.ts'),
        alias: 'types',
      },
    ],
    contextType: 'types.Context',
  },
})

----------------------------------------

TITLE: Running MongoDB Introspection
DESCRIPTION: Command to introspect the MongoDB database and generate the Prisma schema based on existing collections.

LANGUAGE: terminal
CODE:
npx prisma db pull

----------------------------------------

TITLE: Creating User and Post Records with Relations
DESCRIPTION: Example of creating related User and Post records using Prisma Client's nested write functionality, followed by querying the data with included relations.

LANGUAGE: javascript
CODE:
async function main() {
  await prisma.user.create({
    data: {
      name: 'Rich',
      email: 'hello@prisma.com',
      posts: {
        create: {
          title: 'My first post',
          body: 'Lots of really interesting stuff',
          slug: 'my-first-post',
        },
      },
    },
  })

  const allUsers = await prisma.user.findMany({
    include: {
      posts: true,
    },
  })
  console.dir(allUsers, { depth: null })

----------------------------------------

TITLE: Configuring Binary Targets for Azure Functions Deployment
DESCRIPTION: Schema configuration showing how to specify binary targets for Prisma Client to ensure compatibility with Azure Functions' build and hosting environments. This configuration includes both native and debian-openssl-1.1.x targets.

LANGUAGE: prisma
CODE:
generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-1.1.x"]
}

----------------------------------------

TITLE: Defining Prisma Data Models for User, Post and Profile
DESCRIPTION: Schema definition for three related models: Post, Profile, and User. Includes field definitions, relationships, and database constraints. The schema uses auto-incrementing IDs, timestamps, and defines relationships between tables using foreign keys.

LANGUAGE: prisma
CODE:
model Post {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  title     String   @db.VarChar(255)
  content   String?
  published Boolean  @default(false)
  author    User     @relation(fields: [authorId], references: [id])
  authorId  Int
}

model Profile {
  id     Int     @id @default(autoincrement())
  bio    String?
  user   User    @relation(fields: [userId], references: [id])
  userId Int     @unique
}

model User {
  id      Int      @id @default(autoincrement())
  email   String   @unique
  name    String?
  posts   Post[]
  profile Profile?
}

----------------------------------------

TITLE: Initializing Prisma Client in Node.js
DESCRIPTION: Sets up the Prisma Client instance and defines the main execution structure with proper connection handling and error management.

LANGUAGE: javascript
CODE:
const { PrismaClient } = require('@prisma/client')

const prisma = new PrismaClient()

async function main() {
  // ... you will write your Prisma Client queries here
}

main()
  .then(async () => {
    await prisma.$disconnect()
  })
  .catch(async (e) => {
    console.error(e)
    await prisma.$disconnect()
    process.exit(1)
  })

----------------------------------------

TITLE: Development Migration Command
DESCRIPTION: Command to generate and apply migrations in development environment. Should never be used in production.

LANGUAGE: terminal
CODE:
npx prisma migrate dev

----------------------------------------

TITLE: Modified Prisma Schema with Profile Model
DESCRIPTION: Updated Prisma schema that adds a new Profile model with a one-to-one relationship to User.

LANGUAGE: prisma
CODE:
model Post {
  id       Int     @id @default(autoincrement())
  title    String  @db.VarChar(255)
  content  String?
  author   User    @relation(fields: [authorId], references: [id])
  authorId Int
}

model Profile {
  id     Int     @id @default(autoincrement())
  bio    String?
  user   User    @relation(fields: [userId], references: [id])
  userId Int     @unique
}

model User {
  id      Int      @id @default(autoincrement())
  name    String?
  posts   Post[]
  profile Profile?
}

----------------------------------------

TITLE: GraphQL Query Implementation
DESCRIPTION: Example of implementing a GraphQL query resolver using Nexus with Prisma Client for data access.

LANGUAGE: TypeScript
CODE:
t.list.field('posts', {
  type: 'Post',
  nullable: false,
  args: { searchString: stringArg() },
  resolve: (_, args, context) => {
    return context.prisma.post.findMany({
      where: {
        OR: [
          {
            title: { contains: args.searchString },
          },
          {
            content: { contains: args.searchString },
          },
        ],
      },
    })
  },
})

----------------------------------------

TITLE: Initializing Prisma in the Project
DESCRIPTION: Creates a new Prisma schema file and .env file for environment variables. This sets up the basic structure for using Prisma in your project.

LANGUAGE: bash
CODE:
npx prisma init

----------------------------------------

TITLE: Filtering Posts with Prisma Client in JavaScript
DESCRIPTION: This snippet demonstrates how to use Prisma Client to filter Post records that contain the word 'hello' in either the title or body.

LANGUAGE: javascript
CODE:
const filteredPosts = await prisma.post.findMany({
  where: {
    OR: [{ title: { contains: 'hello' } }, { body: { contains: 'hello' } }],
  },
})

----------------------------------------

TITLE: Configuring Language Switcher in YAML Front Matter
DESCRIPTION: This snippet shows how to set up a language switcher for a page using YAML front matter. It specifies TypeScript and Node.js as available language options.

LANGUAGE: yaml
CODE:
langSwitcher: ['typescript', 'node']

----------------------------------------

TITLE: Running Prisma Migrate for CockroachDB
DESCRIPTION: This command creates a new SQL migration file and runs it against the CockroachDB database. It initializes the database schema based on the Prisma data model.

LANGUAGE: bash
CODE:
npx prisma migrate dev --name init

----------------------------------------

TITLE: Installing Prisma Client Package
DESCRIPTION: Installs the Prisma Client package via npm and automatically triggers prisma generate to create a client tailored to your models. This command needs to be run in your project directory where package.json is located.

LANGUAGE: terminal
CODE:
npm install @prisma/client

----------------------------------------

TITLE: Interactive EA to GA Migration Command
DESCRIPTION: Single command to run the interactive migration process using @prisma/ppg-tunnel CLI tool.

LANGUAGE: bash
CODE:
npx @prisma/ppg-tunnel migrate-from-ea

----------------------------------------

TITLE: Initial Prisma Schema Definition
DESCRIPTION: Base Prisma schema showing User and Post models with a one-to-many relationship between them.

LANGUAGE: prisma
CODE:
model Post {
  id       Int     @id @default(autoincrement())
  title    String  @db.VarChar(255)
  content  String?
  author   User    @relation(fields: [authorId], references: [id])
  authorId Int
}

model User {
  id    Int     @id @default(autoincrement())
  name  String?
  posts Post[]
}

----------------------------------------

TITLE: Legacy Version Extension Import
DESCRIPTION: Example of importing Prisma for extension creation in versions earlier than 4.16.0.

LANGUAGE: typescript
CODE:
import { Prisma } from '@prisma/client/scripts/default-index'

export default Prisma.defineExtension({
  name: 'prisma-extension-<extension-name>',
})

----------------------------------------

TITLE: Initializing Prisma Client and Query Structure in TypeScript
DESCRIPTION: Sets up the basic structure for using Prisma Client in a TypeScript file. It imports PrismaClient, creates an instance, defines a main function for queries, and handles connection management.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

async function main() {
  // ... you will write your Prisma Client queries here
}

main()
  .then(async () => {
    await prisma.$disconnect()
  })
  .catch(async (e) => {
    console.error(e)
    await prisma.$disconnect()
    process.exit(1)
  })

----------------------------------------

TITLE: Configuring pgloader Migration Script
DESCRIPTION: Configuration file for pgloader that defines the source MySQL database and target Postgres database connection details along with migration settings

LANGUAGE: text
CODE:
LOAD DATABASE
    FROM mysql://username:password@host:PORT/database_name
    INTO postgresql://user:password@127.0.0.1:5433/postgres

WITH quote identifiers,    -- preserve table/column name case by quoting them
     include drop,
     create tables,
     create indexes,
     reset sequences

ALTER SCHEMA 'database_name' RENAME TO 'public';

----------------------------------------

TITLE: Updating in and notIn Operators in Prisma Client Queries
DESCRIPTION: The in and notIn operators in Prisma ORM 5 require array values, even for single elements.

LANGUAGE: javascript
CODE:
prisma.user.findMany({
  where: {
    id: {
      in: [123],
    },
  },
})

prisma.user.findMany({
  where: {
    id: {
      notIn: [123],
    },
  },
})

----------------------------------------

TITLE: Configuring Prisma Schema for PlanetScale Connection
DESCRIPTION: This snippet shows how to configure the datasource block in the Prisma schema file for connecting to a PlanetScale database. It sets the provider to MySQL and enables Prisma's relation mode for emulating foreign key constraints.

LANGUAGE: prisma
CODE:
datasource db {
  provider     = "mysql"
  url          = env("DATABASE_URL")
  relationMode = "prisma"
}

----------------------------------------

TITLE: Installing Prisma Client Package via NPM
DESCRIPTION: Installs the @prisma/client package which automatically triggers prisma generate to create a client tailored to your schema models. This needs to be re-run whenever the Prisma schema is updated to regenerate the client.

LANGUAGE: terminal
CODE:
npm install @prisma/client

----------------------------------------

TITLE: Setting up Prisma Client with Accelerate
DESCRIPTION: Basic TypeScript setup for Prisma Client with error handling and Accelerate extension.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client'
import { withAccelerate } from '@prisma/extension-accelerate'

const prisma = new PrismaClient().$extends(withAccelerate())

async function main() {
  // ... you will write your Prisma ORM queries here
}

main()
  .then(async () => {
    await prisma.$disconnect()
  })
  .catch(async (e) => {
    console.error(e)
    await prisma.$disconnect()
    process.exit(1)
  })

----------------------------------------

TITLE: Defining Prisma Documentation Metadata in Markdown
DESCRIPTION: This snippet shows the frontmatter metadata for a Prisma documentation page. It includes the title, meta title, meta description, and configuration options for search and table of contents.

LANGUAGE: markdown
CODE:
---
title: 'Prisma docs components'
metaTitle: 'Prisma documentation components'
metaDescription: 'This section describes the Prisma docs file format.'
search: false
hide_table_of_contents: true
---

----------------------------------------

TITLE: Configuring Connection Pool Timeout in Prisma Schema
DESCRIPTION: Example of setting a custom pool timeout duration using the pool_timeout parameter in the database connection URL.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "postgresql"
  url      = "postgresql://johndoe:mypassword@localhost:5432/mydb?connection_limit=5&pool_timeout=2"
}

----------------------------------------

TITLE: Querying All Users with Prisma Client in Node.js
DESCRIPTION: Demonstrates how to use Prisma Client to fetch all user records from the database. This query returns an array of all users, which is then logged to the console.

LANGUAGE: javascript
CODE:
async function main() {
  const allUsers = await prisma.user.findMany()
  console.log(allUsers)
}

----------------------------------------

TITLE: Installing PostgreSQL CLI Tools on macOS
DESCRIPTION: Commands to install PostgreSQL 16 and verify pg_dump and pg_restore tools on macOS using Homebrew.

LANGUAGE: terminal
CODE:
brew install postgresql@16
which pg_dump
which pg_restore

----------------------------------------

TITLE: Prisma Schema Database Source Configuration
DESCRIPTION: Configuration of the datasource block in Prisma schema file to use the DATABASE_URL environment variable for database connection.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

----------------------------------------

TITLE: Defining Prisma Data Model for Posts, Profiles, and Users
DESCRIPTION: This Prisma schema defines three models: Post, Profile, and User. It includes relationships between the models, unique constraints, and indexes for optimized queries.

LANGUAGE: prisma
CODE:
model Post {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  title     String   @db.VarChar(255)
  content   String?
  published Boolean  @default(false)
  author    User     @relation(fields: [authorId], references: [id])
  authorId  Int

  @@index(authorId)
}

model Profile {
  id     Int     @id @default(autoincrement())
  bio    String?
  user   User    @relation(fields: [userId], references: [id])
  userId Int     @unique

  @@index(userId)
}

model User {
  id      Int      @id @default(autoincrement())
  email   String   @unique
  name    String?
  posts   Post[]
  profile Profile?
}

----------------------------------------

TITLE: Installing Prisma Client package using npm
DESCRIPTION: This command installs the @prisma/client package, which is necessary for using Prisma Client in your project. It adds the package to your project's dependencies.

LANGUAGE: terminal
CODE:
npm install @prisma/client

----------------------------------------

TITLE: Organizing Image Files in Bash
DESCRIPTION: Demonstrates the file structure for organizing image files alongside MDX documentation. It shows how to handle cases with few images and cases requiring a separate images directory.

LANGUAGE: bash
CODE:
...
06-image-guidelines.mdx
...
snagit-arrow-line-config.png
snagit-arrow-line-config.snagx
snagit-text-annotation-config.png
snagit-text-annotation-config.snagx

LANGUAGE: bash
CODE:
...
06-image-guidelines.mdx
...
images/
  06-01-snagit-arrow-line-config.png
  06-01-snagit-arrow-line-config.snagx
  06-02-snagit-text-annotation-config.png
  06-02-snagit-text-annotation-config.snagx

----------------------------------------

TITLE: Introspected Prisma schema with ambiguous relations
DESCRIPTION: The Prisma schema generated after introspecting the database with ambiguous relations, showing auto-generated relation field names.

LANGUAGE: prisma
CODE:
model Post {
  id                          Int   @id @default(autoincrement())
  author                      Int
  favoritedBy                 Int?
  User_Post_authorToUser      User  @relation("Post_authorToUser", fields: [author], references: [id], onDelete: NoAction, onUpdate: NoAction)
  User_Post_favoritedByToUser User? @relation("Post_favoritedByToUser", fields: [favoritedBy], references: [id], onDelete: NoAction, onUpdate: NoAction)
}

model User {
  id                          Int    @id @default(autoincrement())
  Post_Post_authorToUser      Post[] @relation("Post_authorToUser")
  Post_Post_favoritedByToUser Post[] @relation("Post_favoritedByToUser")
}

----------------------------------------

TITLE: Running Node.js Script
DESCRIPTION: Command to execute the Node.js script containing Prisma Client queries.

LANGUAGE: bash
CODE:
node index.js

----------------------------------------

TITLE: Configuring Nuxt for Driver Adapters in Edge Functions
DESCRIPTION: This TypeScript snippet shows how to configure Nuxt to enable WebAssembly support, which is necessary for using driver adapters in edge function environments. It sets the nitro.experimental.wasm option to true.

LANGUAGE: typescript
CODE:
export default defineNuxtConfig({
  // ...
  nitro: {
    // ...
    experimental: {
      wasm: true,
    },
  },
  // ...
})

----------------------------------------

TITLE: Generated SQL Migration for Tag Model
DESCRIPTION: SQL migration file that creates the Tag table and necessary junction table _PostToTag for the many-to-many relationship. Includes table creation, index creation, and foreign key constraints.

LANGUAGE: sql
CODE:
-- CreateTable
CREATE TABLE "Tag" (
    "id" SERIAL NOT NULL,
    "name" VARCHAR(255) NOT NULL,

    CONSTRAINT "Tag_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "_PostToTag" (
    "A" INTEGER NOT NULL,
    "B" INTEGER NOT NULL
);

-- CreateIndex
CREATE UNIQUE INDEX "_PostToTag_AB_unique" ON "_PostToTag"("A", "B");

-- CreateIndex
CREATE INDEX "_PostToTag_B_index" ON "_PostToTag"("B");

-- AddForeignKey
ALTER TABLE "_PostToTag" ADD CONSTRAINT "_PostToTag_A_fkey" FOREIGN KEY ("A") REFERENCES "Post"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "_PostToTag" ADD CONSTRAINT "_PostToTag_B_fkey" FOREIGN KEY ("B") REFERENCES "Tag"("id") ON DELETE CASCADE ON UPDATE CASCADE;

----------------------------------------

TITLE: Configuring Prisma Schema with PostgreSQL Provider
DESCRIPTION: Initial Prisma schema configuration using PostgreSQL provider, showing the datasource block with database URL set via environment variable.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

----------------------------------------

TITLE: Running Prisma Migrate for Initial Database Setup
DESCRIPTION: This command creates and runs an initial SQL migration file to map the Prisma data model to the database schema. It also generates Prisma Client if needed.

LANGUAGE: bash
CODE:
npx prisma migrate dev --name init

----------------------------------------

TITLE: Generating Prisma Client library
DESCRIPTION: Generates the Prisma Client library based on your Prisma schema. This command reads the schema and creates a unique client tailored to your data model.

LANGUAGE: bash
CODE:
npx prisma generate

----------------------------------------

TITLE: Manual Type Definition Example
DESCRIPTION: Example of manually defining TypeScript types for User variations including relationships and subset of fields.

LANGUAGE: typescript
CODE:
// 1: Define a type that includes the relation to `Post`
type UserWithPosts = {
  id: string
  email: string
  name: string | null
  posts: Post[]
}

// 2: Define a type that only contains a subset of the scalar fields
type UserPersonalData = {
  email: string
  name: string | null
}

----------------------------------------

TITLE: Installing @prisma/client Package
DESCRIPTION: This command installs the @prisma/client package, which is necessary for using Prisma Client in your project.

LANGUAGE: shell
CODE:
npm install @prisma/client

----------------------------------------

TITLE: Introspected Prisma schema without custom naming
DESCRIPTION: The Prisma schema generated after introspecting the PostgreSQL database, showing models and their relationships without custom naming.

LANGUAGE: prisma
CODE:
model categories {
  category_id        Int                  @id @default(autoincrement())
  name               String?              @db.VarChar(256)
  post_in_categories post_in_categories[]
}

model post_in_categories {
  post_id     Int
  category_id Int
  categories  categories @relation(fields: [category_id], references: [category_id], onDelete: NoAction, onUpdate: NoAction)
  posts       posts      @relation(fields: [post_id], references: [post_id], onDelete: NoAction, onUpdate: NoAction)

  @@unique([post_id, category_id], map: "post_id_category_id_unique")
}

model posts {
  post_id            Int                  @id @default(autoincrement())
  created_at         DateTime?            @default(now()) @db.Timestamptz(6)
  title              String               @db.VarChar(256)
  content            String?
  author_id          Int?
  users              users?               @relation(fields: [author_id], references: [user_id], onDelete: NoAction, onUpdate: NoAction)
  post_in_categories post_in_categories[]
}

model profiles {
  profile_id Int     @id @default(autoincrement())
  bio        String?
  user_id    Int     @unique
  users      users   @relation(fields: [user_id], references: [user_id], onDelete: NoAction, onUpdate: NoAction)
}

model users {
  user_id  Int       @id @default(autoincrement())
  name     String?   @db.VarChar(256)
  email    String    @unique @db.VarChar(256)
  posts    posts[]
  profiles profiles?
}

----------------------------------------

TITLE: Installing @prisma/client Package
DESCRIPTION: This command installs the @prisma/client package, which is necessary for using Prisma Client in your project.

LANGUAGE: shell
CODE:
npm install @prisma/client

----------------------------------------

TITLE: Configuring SQLite Datasource in Prisma Schema
DESCRIPTION: This snippet shows how to configure a datasource block in the Prisma schema to connect to a SQLite database file. It specifies the provider as 'sqlite' and provides the connection URL pointing to the database file.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "sqlite"
  url      = "file:./dev.db"
}

----------------------------------------

TITLE: MongoDB Connection URL Format
DESCRIPTION: Template showing the standard format for MongoDB connection URLs with placeholders for connection details.

LANGUAGE: plaintext
CODE:
mongodb://USERNAME:PASSWORD@HOST:PORT/DATABASE

----------------------------------------

TITLE: Example PostgreSQL Connection URL for Heroku
DESCRIPTION: This snippet provides an example of a PostgreSQL connection URL for a database hosted on Heroku, illustrating the format with actual values.

LANGUAGE: bash
CODE:
DATABASE_URL="postgresql://opnmyfngbknppm:XXX@ec2-46-137-91-216.eu-west-1.compute.amazonaws.com:5432/d50rgmkqi2ipus?schema=hello-prisma"

----------------------------------------

TITLE: Running Prisma Migrate to Create Database Tables
DESCRIPTION: This command creates a new SQL migration file and runs it against the database to create the tables defined in the Prisma schema. It also generates the Prisma Client if necessary.

LANGUAGE: bash
CODE:
npx prisma migrate dev --name init

----------------------------------------

TITLE: Configuring Prisma Schema for SQL Server Connection
DESCRIPTION: Sets up the datasource configuration in the Prisma schema file to connect to a SQL Server database. Uses environment variables for secure credential management.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "sqlserver"
  url      = env("DATABASE_URL")
}

----------------------------------------

TITLE: Defining Prisma Data Model for Post, Profile, and User
DESCRIPTION: This Prisma schema defines three models: Post, Profile, and User. It includes relationships between the models and specifies field types and constraints.

LANGUAGE: prisma
CODE:
model Post {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  title     String   @db.VarChar(255)
  content   String?
  published Boolean  @default(false)
  author    User     @relation(fields: [authorId], references: [id])
  authorId  Int
}

model Profile {
  id     Int     @id @default(autoincrement())
  bio    String?
  user   User    @relation(fields: [userId], references: [id])
  userId Int     @unique
}

model User {
  id      Int      @id @default(autoincrement())
  email   String   @unique
  name    String?
  posts   Post[]
  profile Profile?
}

----------------------------------------

TITLE: Filtering records by compound ID in Prisma Client
DESCRIPTION: This TypeScript snippet demonstrates how to use a compound ID to filter records in a Prisma Client query. It uses the findUnique() method to locate a specific Like record.

LANGUAGE: typescript
CODE:
const like = await prisma.like.findUnique({
  where: {
    likeId: {
      userId: 1,
      postId: 1,
    },
  },
})

----------------------------------------

TITLE: Generating Prisma Client library
DESCRIPTION: This command generates the Prisma Client library based on your Prisma schema. It reads the schema and creates the necessary client code in the .prisma/client folder. This should be run after any changes to the schema.

LANGUAGE: terminal
CODE:
npx prisma generate

----------------------------------------

TITLE: Blog Schema with Posts and Comments
DESCRIPTION: Example schema showing relation between Post and Comment models, including index configuration for foreign key optimization when using PlanetScale.

LANGUAGE: prisma
CODE:
model Post {
  id       Int       @id @default(autoincrement())
  title    String
  content  String
  likes    Int       @default(0)
  comments Comment[]
}

model Comment {
  id      Int    @id @default(autoincrement())
  comment String
  postId  Int
  post    Post   @relation(fields: [postId], references: [id], onDelete: Cascade)

  @@index([postId])
}

----------------------------------------

TITLE: Defining Basic Prisma User Model Schema
DESCRIPTION: Basic Prisma schema definition for a User model with id, name, and email fields. The schema demonstrates primary key, optional field, and unique constraint usage.

LANGUAGE: prisma
CODE:
model User {
  id    Int     @id @default(autoincrement())
  name  String?
  email String  @unique
}

----------------------------------------

TITLE: Configuring Database Connection in Prisma Schema
DESCRIPTION: This snippet shows how to set up the datasource block in a Prisma schema file to connect to a PostgreSQL database using an environment variable for the connection URL.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

----------------------------------------

TITLE: Updating Prisma Schema for CockroachDB Provider
DESCRIPTION: Modified Prisma schema configuration changing the provider from PostgreSQL to CockroachDB.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "cockroachdb"
  url      = env("DATABASE_URL")
}

----------------------------------------

TITLE: Introspecting Database with Prisma CLI
DESCRIPTION: Command to introspect an existing database and generate Prisma models.

LANGUAGE: bash
CODE:
npx prisma db pull

----------------------------------------

TITLE: Installing Prisma CLI Dependency
DESCRIPTION: Adds the Prisma CLI as a development dependency to the project using npm.

LANGUAGE: terminal
CODE:
npm install prisma --save-dev

----------------------------------------

TITLE: Running custom Vercel build command
DESCRIPTION: Execute the custom Vercel build command in a CI/CD pipeline to handle Prisma Client generation and database migrations.

LANGUAGE: terminal
CODE:
npm run vercel-build

----------------------------------------

TITLE: Installing Prisma Client with npm for JavaScript and CockroachDB
DESCRIPTION: This command installs the @prisma/client package, which is necessary for using Prisma Client in your JavaScript project with CockroachDB.

LANGUAGE: terminal
CODE:
npm install @prisma/client

----------------------------------------

TITLE: Enabling Driver Adapters in Prisma Schema
DESCRIPTION: Updates the Prisma schema to enable the driverAdapters preview feature, which is necessary for connecting to Turso.

LANGUAGE: prisma
CODE:
generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["driverAdapters"]
}

datasource db {
  provider = "sqlite"
  url      = "file:./dev.db"
}

----------------------------------------

TITLE: Updating Prisma Schema Provider
DESCRIPTION: Schema modification to change the database provider from MySQL to PostgreSQL in the Prisma configuration

LANGUAGE: prisma
CODE:
datasource db {
  provider = "postgres"
  url      = env("DATABASE_URL")
}

----------------------------------------

TITLE: MySQL AWS RDS Connection URL Example
DESCRIPTION: Example of a DATABASE_URL environment variable configuration for connecting to a MySQL database hosted on AWS RDS.

LANGUAGE: bash
CODE:
DATABASE_URL="mysql://johndoe:XXX@mysqlinstance1.123456789012.us-east-1.rds.amazonaws.com:3306/mydb"

----------------------------------------

TITLE: Setting SQL Server Connection URL in Environment Variable
DESCRIPTION: This snippet demonstrates how to define the DATABASE_URL environment variable in a .env file. It includes the connection string for SQL Server with authentication details.

LANGUAGE: bash
CODE:
DATABASE_URL="sqlserver://localhost:1433;database=mydb;user=sa;password=r@ndomP@$$w0rd;trustServerCertificate=true"

----------------------------------------

TITLE: Creating User Table with SQL
DESCRIPTION: SQL command to create a User table with id, name, and email fields.

LANGUAGE: sql
CODE:
CREATE TABLE "User" (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255),
    email VARCHAR(255) NOT NULL
);

----------------------------------------

TITLE: Configuring Prisma schema for Cloudflare deployment
DESCRIPTION: Sets up the Prisma schema with the necessary configuration for deploying to Cloudflare, including the driverAdapters preview feature and environment variable for the database URL.

LANGUAGE: prisma
CODE:
generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["driverAdapters"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

----------------------------------------

TITLE: Adding Postinstall Script for Prisma Client Generation
DESCRIPTION: Adds a postinstall script to package.json to generate Prisma Client during deployment.

LANGUAGE: json
CODE:
{
  // ...,
  "postinstall": "prisma generate"
}

----------------------------------------

TITLE: Creating Migration Directory
DESCRIPTION: Creates a migrations directory structure for the initial baseline migration

LANGUAGE: terminal
CODE:
mkdir -p prisma/migrations/0_init

----------------------------------------

TITLE: Generating Initial SQL Migration for D1
DESCRIPTION: This SQL script creates the User table in Cloudflare D1 based on the Prisma schema. It's generated using the prisma migrate diff command for the initial migration.

LANGUAGE: sql
CODE:
-- CreateTable
CREATE TABLE "User" (
    "id" INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT,
    "email" TEXT NOT NULL,
    "name" TEXT
);

-- CreateIndex
CREATE UNIQUE INDEX "User_email_key" ON "User"("email");

----------------------------------------

TITLE: Generating CRUD API Endpoints with Next.js and Prisma
DESCRIPTION: This snippet demonstrates how to create CRUD (Create, Read, Update, Delete) API endpoints for a Next.js application using Prisma ORM, based on the User model from the schema.

LANGUAGE: typescript
CODE:
import { NextResponse } from 'next/server';
import prisma from '../../../lib/prisma';

export async function GET() {
  const users = await prisma.user.findMany({
    include: { organization: true },
  });
  return NextResponse.json(users);
}

export async function POST(request: Request) {
  const body = await request.json();
  const user = await prisma.user.create({
    data: {
      email: body.email,
      name: body.name,
      organization: {
        connect: { id: body.organizationId },
      },
    },
    include: { organization: true },
  });
  return NextResponse.json(user);
}

export async function PUT(request: Request) {
  const body = await request.json();
  const user = await prisma.user.update({
    where: { id: body.id },
    data: {
      email: body.email,
      name: body.name,
      organizationId: body.organizationId,
    },
    include: { organization: true },
  });
  return NextResponse.json(user);
}

export async function DELETE(request: Request) {
  const { searchParams } = new URL(request.url);
  const id = searchParams.get('id');
  const user = await prisma.user.delete({
    where: { id: Number(id) },
  });
  return NextResponse.json(user);
}

----------------------------------------

TITLE: Configuring PostgreSQL Database Source in Prisma Schema
DESCRIPTION: Default Prisma schema configuration showing the datasource block with PostgreSQL provider and environment variable for database URL.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

----------------------------------------

TITLE: Initializing TypeScript Configuration
DESCRIPTION: Command to create TypeScript configuration file

LANGUAGE: terminal
CODE:
npx tsc --init

----------------------------------------

TITLE: Setting Debug Options in Windows Environment
DESCRIPTION: Windows-specific command for setting debug options using the set command instead of export.

LANGUAGE: terminal
CODE:
set DEBUG="prisma*"

----------------------------------------

TITLE: Creating baseline migration with Prisma Migrate
DESCRIPTION: Generates a SQL migration file from the current database schema and marks it as applied.

LANGUAGE: bash
CODE:
npx prisma migrate diff --from-empty --to-schema-datamodel prisma/schema.prisma --script > prisma/migrations/0_init/migration.sql
npx prisma migrate resolve --applied 0_init

----------------------------------------

TITLE: Creating baseline migration with Prisma Migrate
DESCRIPTION: Generates a SQL migration file from the current database schema and marks it as applied.

LANGUAGE: bash
CODE:
npx prisma migrate diff --from-empty --to-schema-datamodel prisma/schema.prisma --script > prisma/migrations/0_init/migration.sql
npx prisma migrate resolve --applied 0_init

----------------------------------------

TITLE: Creating Heroku App in Bash
DESCRIPTION: This command creates a new Heroku app with a specified name using the Heroku CLI.

LANGUAGE: bash
CODE:
heroku apps:create your-app-name

----------------------------------------

TITLE: Initial Migration SQL for PostgreSQL Database
DESCRIPTION: Generated SQL script for creating initial tables and relationships in a PostgreSQL database based on the Prisma schema.

LANGUAGE: sql
CODE:
-- CreateTable
CREATE TABLE "Post" (
    "id" SERIAL NOT NULL,
    "title" VARCHAR(255) NOT NULL,
    "createdAt" TIMESTAMP(6) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "content" TEXT,
    "published" BOOLEAN NOT NULL DEFAULT false,
    "authorId" INTEGER NOT NULL,

    CONSTRAINT "Post_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Profile" (
    "id" SERIAL NOT NULL,
    "bio" TEXT,
    "userId" INTEGER NOT NULL,

    CONSTRAINT "Profile_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "User" (
    "id" SERIAL NOT NULL,
    "name" VARCHAR(255),
    "email" VARCHAR(255) NOT NULL,

    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "Profile_userId_key" ON "Profile"("userId");

-- CreateIndex
CREATE UNIQUE INDEX "User_email_key" ON "User"("email");

-- AddForeignKey
ALTER TABLE "Post" ADD CONSTRAINT "Post_authorId_fkey" FOREIGN KEY ("authorId") REFERENCES "User"("id") ON DELETE NO ACTION ON UPDATE NO ACTION;

-- AddForeignKey
ALTER TABLE "Profile" ADD CONSTRAINT "Profile_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE NO ACTION ON UPDATE NO ACTION;

----------------------------------------

TITLE: Advanced Prisma Client Generator Configuration
DESCRIPTION: Extended configuration of the Prisma Client JS generator including preview features and binary targets for specific deployment environments.

LANGUAGE: prisma
CODE:
generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["sample-preview-feature"]
  binaryTargets   = ["linux-musl"]
}

----------------------------------------

TITLE: Installing Prisma Client via npm for JavaScript and PostgreSQL
DESCRIPTION: This command installs the @prisma/client package, which is necessary for using Prisma Client in your JavaScript project with PostgreSQL.

LANGUAGE: terminal
CODE:
npm install @prisma/client

----------------------------------------

TITLE: Installing Prisma Client via npm for JavaScript and PostgreSQL
DESCRIPTION: This command installs the @prisma/client package, which is necessary for using Prisma Client in your JavaScript project with PostgreSQL.

LANGUAGE: terminal
CODE:
npm install @prisma/client

----------------------------------------

TITLE: Configuring Prisma datasource for CockroachDB
DESCRIPTION: This snippet demonstrates how to modify the Prisma schema to use CockroachDB as the datasource provider instead of PostgreSQL. It highlights the change in the provider field.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "cockroachdb"
  url      = env("DATABASE_URL")
}

----------------------------------------

TITLE: Initializing TypeScript Project with Prisma Dependencies
DESCRIPTION: Commands to initialize a new npm project and install required TypeScript and Prisma dependencies.

LANGUAGE: terminal
CODE:
npm init -y
npm install prisma typescript tsx @types/node --save-dev

----------------------------------------

TITLE: Initializing Prisma Schema
DESCRIPTION: Command to create the initial Prisma schema file and .env file for environment variables, setting up the basic Prisma ORM project structure.

LANGUAGE: bash
CODE:
npx prisma init

----------------------------------------

TITLE: Defining a scalar list field in Prisma schema (Relational databases)
DESCRIPTION: Demonstrates how to define a scalar String list field named 'pets' in a Prisma schema for relational databases.

LANGUAGE: prisma
CODE:
model User {
  id   Int      @id @default(autoincrement())
  name String
  pets String[]
}

----------------------------------------

TITLE: Generating Initial Migration SQL
DESCRIPTION: Uses prisma migrate diff command to generate SQL migration by comparing empty state to current schema. The command outputs a SQL script to initialize the database structure.

LANGUAGE: terminal
CODE:
npx prisma migrate diff --from-empty --to-schema-datamodel prisma/schema.prisma --script > prisma/migrations/0_init/migration.sql

----------------------------------------

TITLE: PrismaClientUnknownRequestError Interface Definition
DESCRIPTION: Interface defining the structure of unknown request errors thrown by Prisma Client for request-related errors without specific error codes.

LANGUAGE: typescript
CODE:
interface PrismaClientUnknownRequestError {
  message: string;
  clientVersion: string;
}

----------------------------------------

TITLE: Marking Migration as Applied with Prisma Migrate Resolve
DESCRIPTION: Marks the initial migration as applied in the _prisma_migrations table using the prisma migrate resolve command.

LANGUAGE: terminal
CODE:
npx prisma migrate resolve --applied 0_init

----------------------------------------

TITLE: Creating SQL Table for One-to-One Self-Relation
DESCRIPTION: This SQL snippet shows how to create a table representing a one-to-one self-relation in relational databases. It includes the creation of the User table and the necessary constraints.

LANGUAGE: sql
CODE:
CREATE TABLE "User" (
    id SERIAL PRIMARY KEY,
    "name" TEXT,
    "successorId" INTEGER
);

ALTER TABLE "User" ADD CONSTRAINT fk_successor_user FOREIGN KEY ("successorId") REFERENCES "User" (id);

ALTER TABLE "User" ADD CONSTRAINT successor_unique UNIQUE ("successorId");

----------------------------------------

TITLE: Creating Next.js Project with Multiple Prisma Clients
DESCRIPTION: Terminal commands to create a new Next.js project using create-next-app and install required dependencies.

LANGUAGE: terminal
CODE:
npx create-next-app@latest my-multi-client-app
cd my-multi-client-app
npm install -D prisma
npm install @prisma/extension-accelerate

----------------------------------------

TITLE: Creating Project Directory with Terminal Commands
DESCRIPTION: Commands to create and navigate into a new project directory for the Prisma application.

LANGUAGE: bash
CODE:
mkdir hello-prisma
cd hello-prisma

----------------------------------------

TITLE: Initializing Prisma Schema
DESCRIPTION: Command to create the initial Prisma schema file and .env file for environment variables, setting up the basic Prisma ORM project structure.

LANGUAGE: bash
CODE:
npx prisma init

----------------------------------------

TITLE: Configuring Prisma Database Source with PostgreSQL
DESCRIPTION: Initial Prisma schema configuration showing the datasource block with PostgreSQL as provider and database URL from environment variable.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

----------------------------------------

TITLE: Installing inshellisense CLI Autocomplete for Prisma
DESCRIPTION: Command to install inshellisense globally via npm for IDE-style autocompletion of Prisma CLI commands. Supports bash, zsh, fish, pwsh, and powershell.

LANGUAGE: bash
CODE:
npm install -g @microsoft/inshellisense

----------------------------------------

TITLE: Comparing Numeric Columns with Raw Query in MySQL
DESCRIPTION: Execute a raw SQL query to compare likesCount and commentsCount columns in the Post table for MySQL.

LANGUAGE: javascript
CODE:
import { PrismaClient } from '@prisma/client'

const prisma = new PrismaClient()

async function initiateNumbersComparisonRawQuery() {
  const response =
    await prisma.$queryRaw`SELECT * FROM \`public\`.\`Post\` WHERE \`likesCount\` < \`commentsCount\`;`

  console.log(response)
}

await initiateNumbersComparisonRawQuery()

----------------------------------------

TITLE: Generating Initial Migration Script
DESCRIPTION: Uses prisma migrate diff to generate an initial migration SQL script by comparing an empty state to the current schema

LANGUAGE: terminal
CODE:
npx prisma migrate diff --from-empty --to-schema-datamodel prisma/schema.prisma --script > prisma/migrations/0_init/migration.sql

----------------------------------------

TITLE: Assigning Models to Specific Database Schemas in Prisma
DESCRIPTION: This example shows how to designate models and enums to specific database schemas using the @@schema attribute in the Prisma schema.

LANGUAGE: prisma
CODE:
model User {
  id     Int     @id
  orders Order[]

  @@schema("base")
}

model Order {
  id      Int  @id
  user    User @relation(fields: [id], references: [id])
  user_id Int

  @@schema("transactional")
}

enum Size {
  Small
  Medium
  Large

  @@schema("transactional")
}

----------------------------------------

TITLE: Defining Prisma Schema for User Model
DESCRIPTION: Define the Prisma schema for the User model used in the unit tests.

LANGUAGE: prisma
CODE:
model User {
  id                       Int     @id @default(autoincrement())
  email                    String  @unique
  name                     String?
  acceptTermsAndConditions Boolean
}

----------------------------------------

TITLE: Initializing TypeScript Project with Prisma Dependencies
DESCRIPTION: Commands to initialize a TypeScript project and install necessary dependencies including Prisma CLI, TypeScript, and Node.js types.

LANGUAGE: bash
CODE:
npm init -y
npm install prisma typescript tsx @types/node --save-dev

----------------------------------------

TITLE: Initializing Prisma Project
DESCRIPTION: Command to initialize Prisma project structure by creating schema file and environment configuration

LANGUAGE: terminal
CODE:
npx prisma init

----------------------------------------

TITLE: Initializing TypeScript Project with Prisma Dependencies
DESCRIPTION: Commands to initialize a TypeScript project and install necessary dependencies including Prisma CLI, TypeScript, and Node.js types.

LANGUAGE: bash
CODE:
npm init -y
npm install prisma typescript tsx @types/node --save-dev

----------------------------------------

TITLE: Configuring Prisma Client with Optimize and Accelerate Extensions in TypeScript
DESCRIPTION: This snippet demonstrates how to properly configure a Prisma Client instance with both the Optimize and Accelerate extensions. The Accelerate extension must be added last to ensure cacheable operations are received by Optimize.

LANGUAGE: typescript
CODE:
const prisma = new PrismaClient()
  .$extends(
    withOptimize({
      apiKey: process.env.OPTIMIZE_API_KEY,
    }),
  )
  .$extends(withAccelerate());

----------------------------------------

TITLE: Generating Initial Migration SQL with Prisma Migrate
DESCRIPTION: Prisma CLI command to generate a SQL migration script by comparing an empty state to the current schema.

LANGUAGE: bash
CODE:
npx prisma migrate diff --from-empty --to-schema-datamodel prisma/schema.prisma --script > prisma/migrations/0_init/migration.sql

----------------------------------------

TITLE: Enabling strictUndefinedChecks in Prisma Schema
DESCRIPTION: Configuration needed in the Prisma schema file to enable the strictUndefinedChecks preview feature.

LANGUAGE: prisma
CODE:
generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["strictUndefinedChecks"]
}

----------------------------------------

TITLE: Configuring Local Database URL in Environment Variables
DESCRIPTION: Sets the DATABASE_URL environment variable to connect to a local PostgreSQL database for development purposes.

LANGUAGE: env
CODE:
DATABASE_URL="postgres://username:password@127.0.0.1:5432/localdb"

----------------------------------------

TITLE: Initializing TypeScript Configuration
DESCRIPTION: Command to create TypeScript configuration file (tsconfig.json).

LANGUAGE: terminal
CODE:
npx tsc --init

----------------------------------------

TITLE: Creating Project Directory and Initializing TypeScript Project
DESCRIPTION: Creates a new project directory, initializes a TypeScript project, and installs necessary dependencies including Prisma CLI.

LANGUAGE: shell
CODE:
mkdir hello-prisma
cd hello-prisma
npm init -y
npm install prisma typescript tsx @types/node --save-dev

----------------------------------------

TITLE: Loading Environment Variables in TypeScript
DESCRIPTION: Demonstrates how to load environment variables in TypeScript using dotenv package.

LANGUAGE: typescript
CODE:
import * as dotenv from 'dotenv'

dotenv.config() // Load the environment variables
console.log(`The connection URL is ${process.env.DATABASE_URL}`)

----------------------------------------

TITLE: ARM64 Architecture Configuration in Prisma Schema
DESCRIPTION: Configuration for Lambda functions using arm64 architectures (AWS Graviton2 processor), requiring specific binary target setting.

LANGUAGE: prisma
CODE:
binaryTargets = ["native", "linux-arm64-openssl-1.0.x"]

----------------------------------------

TITLE: Generated Prisma Schema
DESCRIPTION: The Prisma schema generated after introspecting the database. It includes models for Post, Profile, and User with their respective fields and relationships.

LANGUAGE: prisma
CODE:
model Post {
  id        Int      @id @default(autoincrement())
  title     String   @db.VarChar(255)
  createdAt DateTime @default(now()) @db.Timestamp(0)
  content   String?  @db.Text
  published Boolean  @default(false)
  authorId  Int
  User      User     @relation(fields: [authorId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "Post_ibfk_1")

  @@index([authorId], map: "authorId")
}

model Profile {
  id     Int     @id @default(autoincrement())
  bio    String? @db.Text
  userId Int     @unique(map: "userId")
  User   User    @relation(fields: [userId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "Profile_ibfk_1")
}

model User {
  id      Int      @id @default(autoincrement())
  name    String?  @db.VarChar(255)
  email   String   @unique(map: "email") @db.VarChar(255)
  Post    Post[]
  Profile Profile?
}

----------------------------------------

TITLE: Adding items to a scalar list in Prisma
DESCRIPTION: Demonstrates how to add a single value to a scalar list field 'coinflips' using the push method in Prisma Client.

LANGUAGE: typescript
CODE:
const userUpdate = await prisma.user.update({
  where: {
    id: 9,
  },
  data: {
    coinflips: {
      push: true,
    },
  },
})

----------------------------------------

TITLE: Creating Related Records with Nested Write in Prisma Client
DESCRIPTION: Shows how to create a new User record along with related Post and Profile records using a nested write query. It also demonstrates how to retrieve the created data with related records included.

LANGUAGE: javascript
CODE:
async function main() {
  await prisma.user.create({
    data: {
      name: 'Alice',
      email: 'alice@prisma.io',
      posts: {
        create: { title: 'Hello World' },
      },
      profile: {
        create: { bio: 'I like turtles' },
      },
    },
  })

  const allUsers = await prisma.user.findMany({
    include: {
      posts: true,
      profile: true,
    },
  })
  console.dir(allUsers, { depth: null })
}

----------------------------------------

TITLE: Creating Project Directory in Bash
DESCRIPTION: Creates a new directory for the Prisma project and navigates into it.

LANGUAGE: bash
CODE:
mkdir hello-prisma
cd hello-prisma

----------------------------------------

TITLE: Invoking Prisma CLI
DESCRIPTION: Command to invoke the Prisma CLI using npx.

LANGUAGE: bash
CODE:
npx prisma

----------------------------------------

TITLE: Troubleshooting Implicit Many-to-Many Self Relations in Prisma
DESCRIPTION: Demonstrates how lexicographic order of relation fields affects data retrieval in self-relations. Shows the importance of maintaining alphabetic order in field names to prevent incorrect data relationships.

LANGUAGE: prisma
CODE:
model Animal {
  id        Int      @id @default(autoincrement())
  name      String
  a_eats    Animal[] @relation(name: "FoodChain")
  b_eatenBy Animal[] @relation(name: "FoodChain")
}

----------------------------------------

TITLE: Relation Filters with Prisma ORM in TypeScript
DESCRIPTION: Shows how to filter users based on a condition applied to a related model (posts) using Prisma ORM. This feature is not directly available in Sequelize without using raw SQL queries.

LANGUAGE: typescript
CODE:
const posts = await prisma.user.findMany({
  where: {
    Post: {
      some: {
        title: {
          contains: 'Hello',
        },
      },
    },
  },
})

----------------------------------------

TITLE: Generated Prisma Schema After Introspection
DESCRIPTION: The Prisma schema generated after introspecting the MySQL database, showing models for User, Post, and Profile.

LANGUAGE: prisma
CODE:
model Post {
  id        Int      @id @default(autoincrement())
  title     String   @db.VarChar(255)
  createdAt DateTime @default(now()) @db.Timestamp(0)
  content   String?  @db.Text
  published Boolean  @default(false)
  authorId  Int
  User      User     @relation(fields: [authorId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "Post_ibfk_1")

  @@index([authorId], map: "authorId")
}

model Profile {
  id     Int     @id @default(autoincrement())
  bio    String? @db.Text
  userId Int     @unique(map: "userId")
  User   User    @relation(fields: [userId], references: [id], onDelete: NoAction, onUpdate: NoAction, map: "Profile_ibfk_1")
}

model User {
  id      Int      @id @default(autoincrement())
  name    String?  @db.VarChar(255)
  email   String   @unique(map: "email") @db.VarChar(255)
  Post    Post[]
  Profile Profile?
}

----------------------------------------

TITLE: Working with DateTime in Prisma
DESCRIPTION: Examples of creating records with DateTime fields using different date formats.

LANGUAGE: typescript
CODE:
await prisma.user.create({
  data: {
    birthDate: new Date('1998-12-24T06:22:33.444Z')
  }
})

----------------------------------------

TITLE: Configuring PostgreSQL Extensions in Schema
DESCRIPTION: Example of enabling PostgreSQL extensions in the Prisma schema using the postgresqlExtensions preview feature.

LANGUAGE: prisma
CODE:
generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  extensions = [pgcrypto]
}

----------------------------------------

TITLE: Initializing Prisma Project
DESCRIPTION: Command to set up a Prisma project by creating the Prisma schema file and .env file.

LANGUAGE: bash
CODE:
npx prisma init

----------------------------------------

TITLE: Initializing Node.js Project and Installing Prisma
DESCRIPTION: Commands to initialize a new Node.js project and install Prisma CLI as a development dependency using npm.

LANGUAGE: bash
CODE:
npm init -y
npm install prisma --save-dev

----------------------------------------

TITLE: Multi-Table Inheritance Schema
DESCRIPTION: Prisma schema implementing multi-table inheritance pattern with separate tables and relations.

LANGUAGE: prisma
CODE:
model Activity {
  id   Int          @id @default(autoincrement())
  url  String
  type ActivityType

  video   Video?
  article Article?

  owner   User @relation(fields: [ownerId], references: [id])
  ownerId Int
}

model Video {
  id         Int      @id @default(autoincrement())
  duration   Int
  activityId Int      @unique
  activity   Activity @relation(fields: [activityId], references: [id])
}

model Article {
  id         Int      @id @default(autoincrement())
  body       String
  activityId Int      @unique
  activity   Activity @relation(fields: [activityId], references: [id])
}

enum ActivityType {
  Video
  Article
}

model User {
  id         Int        @id @default(autoincrement())
  name       String?
  activities Activity[]
}

----------------------------------------

TITLE: Initializing TypeScript Configuration
DESCRIPTION: Command to create TypeScript configuration file

LANGUAGE: bash
CODE:
npx tsc --init

----------------------------------------

TITLE: Example MySQL Connection URL for Local Database
DESCRIPTION: This snippet provides an example of a MySQL connection URL for a locally hosted database. It includes placeholders for user credentials and uses localhost as the host.

LANGUAGE: bash
CODE:
DATABASE_URL="mysql://root:randompassword@localhost:3306/mydb"

----------------------------------------

TITLE: Downloading Prisma Render Deployment Example (Terminal)
DESCRIPTION: Commands to download and extract the Prisma Render deployment example code from GitHub.

LANGUAGE: shell
CODE:
curl https://codeload.github.com/prisma/prisma-examples/tar.gz/latest | tar -xz --strip=2 prisma-examples-latest/deployment-platforms/render
cd render

----------------------------------------

TITLE: Creating Nested Records with Prisma Client
DESCRIPTION: Advanced query demonstrating nested writes to create a user with associated posts and profile in a single transaction.

LANGUAGE: typescript
CODE:
async function main() {
  await prisma.user.create({
    data: {
      name: 'Alice',
      email: 'alice@prisma.io',
      posts: {
        create: { title: 'Hello World' },
      },
      profile: {
        create: { bio: 'I like turtles' },
      },
    },
  })

  const allUsers = await prisma.user.findMany({
    include: {
      posts: true,
      profile: true,
    },
  })
  console.dir(allUsers, { depth: null })
}

----------------------------------------

TITLE: Defining Prisma Schema for MongoDB with TypeScript
DESCRIPTION: This snippet shows how to create a Prisma schema for MongoDB, including datasource and generator configurations, and model definitions for Post, User, Comment, and an embedded Address type. It demonstrates MongoDB-specific schema features like @map("_id") and @db.ObjectId.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "mongodb"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model Post {
  id       String    @id @default(auto()) @map("_id") @db.ObjectId
  slug     String    @unique
  title    String
  body     String
  author   User      @relation(fields: [authorId], references: [id])
  authorId String    @db.ObjectId
  comments Comment[]
}

model User {
  id      String   @id @default(auto()) @map("_id") @db.ObjectId
  email   String   @unique
  name    String?
  address Address?
  posts   Post[]
}

model Comment {
  id      String @id @default(auto()) @map("_id") @db.ObjectId
  comment String
  post    Post   @relation(fields: [postId], references: [id])
  postId  String @db.ObjectId
}

// Address is an embedded document
type Address {
  street String
  city   String
  state  String
  zip    String
}

----------------------------------------

TITLE: Creating Initial Database Migration
DESCRIPTION: Command to create and execute the initial schema migration using Prisma CLI.

LANGUAGE: terminal
CODE:
npx prisma migrate dev --name init

----------------------------------------

TITLE: Initializing Prisma Schema
DESCRIPTION: Command to initialize a new Prisma project by creating the schema file and environment configuration. Creates prisma directory with schema.prisma file and .env file in root directory.

LANGUAGE: terminal
CODE:
npx prisma init

----------------------------------------

TITLE: Generated TypeScript User Type
DESCRIPTION: The TypeScript type automatically generated by Prisma Client for the User model.

LANGUAGE: typescript
CODE:
export declare type User = {
  id: string
  email: string
  name: string | null
}

----------------------------------------

TITLE: Generated TypeScript User Type
DESCRIPTION: The TypeScript type automatically generated by Prisma Client for the User model.

LANGUAGE: typescript
CODE:
export declare type User = {
  id: string
  email: string
  name: string | null
}

----------------------------------------

TITLE: Setting SQL Server Connection URL in Environment
DESCRIPTION: Defines the database connection URL as an environment variable. Includes server location, database name, authentication credentials, and SSL settings for SQL Server connection.

LANGUAGE: bash
CODE:
DATABASE_URL="sqlserver://localhost:1433;database=mydb;user=sa;password=r@ndomP@$$w0rd;trustServerCertificate=true"

----------------------------------------

TITLE: Configuring custom Prisma Client output path in schema.prisma
DESCRIPTION: Set a custom output path for Prisma Client in the schema file to ensure the correct client is included in version control and deployments.

LANGUAGE: prisma
CODE:
generator client {
  provider = "prisma-client-js"
  output   = "./generated/client"
}

----------------------------------------

TITLE: Creating User with Related Posts
DESCRIPTION: Example of a nested write query that creates a User record with associated Post records using Prisma Client.

LANGUAGE: typescript
CODE:
const user = await prisma.user.create({
  data: {
    name: 'Bob',
    email: 'bob@prisma.io',
    posts: {
      create: [
        {
          title: 'Hello World',
          published: true
        },
        {
          title: 'My second post',
          content: 'This is still a draft'
        }
      ],
    },
  },
})

----------------------------------------

TITLE: Initializing Prisma Project Structure
DESCRIPTION: Creates the initial Prisma project structure by generating a prisma directory with a schema.prisma file and a .env file for environment variables.

LANGUAGE: bash
CODE:
npx prisma init

----------------------------------------

TITLE: Using Uint8Array instead of Buffer in Prisma v6
DESCRIPTION: TypeScript code demonstrating the use of Uint8Array for Bytes fields in Prisma v6, replacing the previous Buffer usage.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client'

async function main() {
  const prisma = new PrismaClient()
  await prisma.user.deleteMany()

  const bytesCreated = await prisma.user.create({
    data: {
      bytes: Uint8Array.from([1, 2, 3, 4]),
    },
  })
  // `bytesCreated` now has type: {
  //    bytes: Uint8Array
  //    id: number
  // }

  for (const bytesFound of await prisma.user.findMany()) {
    bytesFound.bytes // Uint8Array [ 1, 2, 3, 4 ]
  }
}

main()

----------------------------------------

TITLE: Switching Prisma Provider to MySQL
DESCRIPTION: Modified Prisma schema configuration changing the database provider from PostgreSQL to MySQL while maintaining the environment variable for the connection URL.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

----------------------------------------

TITLE: Configuring Binary Targets for Node.js in Prisma Schema
DESCRIPTION: Configuration for specifying binary targets in Prisma schema based on Node.js version. For Node.js 16/18 uses rhel-openssl-1.0.x and for Node.js 20+ uses rhel-openssl-3.0.x.

LANGUAGE: prisma
CODE:
binaryTargets = ["native", "rhel-openssl-1.0.x"]

LANGUAGE: prisma
CODE:
binaryTargets = ["native", "rhel-openssl-3.0.x"]

----------------------------------------

TITLE: Creating Context for Dependency Injection
DESCRIPTION: Set up a context file for dependency injection pattern with Prisma Client mocking.

LANGUAGE: typescript
CODE:
import { PrismaClient } from '@prisma/client'
import { mockDeep, DeepMockProxy } from 'jest-mock-extended'

export type Context = {
  prisma: PrismaClient
}

export type MockContext = {
  prisma: DeepMockProxy<PrismaClient>
}

export const createMockContext = (): MockContext => {
  return {
    prisma: mockDeep<PrismaClient>(),
  }
}

----------------------------------------

TITLE: Installing Prisma CLI Dependencies
DESCRIPTION: Command to install the Prisma CLI as a development dependency in an existing Node.js project.

LANGUAGE: terminal
CODE:
npm install prisma --save-dev

----------------------------------------

TITLE: Configuring PostgreSQL Datasource in Prisma Schema
DESCRIPTION: Default Prisma schema configuration using PostgreSQL provider. This shows the basic datasource block structure with environment variable for the database URL.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

----------------------------------------

TITLE: Deploying to Netlify
DESCRIPTION: Command to initiate a new Netlify build and deployment.

LANGUAGE: terminal
CODE:
netlify deploy

----------------------------------------

TITLE: Starting Prisma Postgres Tunnel
DESCRIPTION: Command to establish a secure tunnel connection to Prisma Postgres database using ppg-tunnel.

LANGUAGE: bash
CODE:
npx @prisma/ppg-tunnel --host 127.0.0.1  --port 5432

----------------------------------------

TITLE: Executing Prisma Database Push
DESCRIPTION: Command to push the defined schema to the database's main branch using Prisma's db push CLI command.

LANGUAGE: terminal
CODE:
npx prisma db push

----------------------------------------

TITLE: Configuring Microsoft SQL Server Connection in Prisma Schema
DESCRIPTION: Illustrates the setup for connecting to a Microsoft SQL Server database through Prisma schema. Details the connection string format specific to SQL Server.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "sqlserver"
  url      = "sqlserver://localhost:1433;initial catalog=sample;user=sa;password=mypassword;"
}

----------------------------------------

TITLE: Updating Post with Multiple Comments
DESCRIPTION: Shows how to update an existing Post record by adding multiple comments using createMany. Demonstrates querying related data using the include option.

LANGUAGE: javascript
CODE:
async function main() {
  await prisma.post.update({
    where: {
      slug: 'my-first-post',
    },
    data: {
      comments: {
        createMany: {
          data: [
            { comment: 'Great post!' },
            { comment: "Can't wait to read more!" },
          ],
        },
      },
    },
  })
  const posts = await prisma.post.findMany({
    include: {
      comments: true,
    },
  })

  console.dir(posts, { depth: Infinity })
}

----------------------------------------

TITLE: Setting up environment variables for Cloudflare Workers
DESCRIPTION: Creates a .dev.vars file to store the DATABASE_URL environment variable for local development with Cloudflare Workers.

LANGUAGE: bash
CODE:
DATABASE_URL="postgresql://admin:mypassword42@somehost.aws.com:5432/mydb"

----------------------------------------

TITLE: Conditional Environment File Loading
DESCRIPTION: Shows how to conditionally load different environment files based on NODE_ENV.

LANGUAGE: typescript
CODE:
import { config } from 'dotenv'

const envFile = process.env.NODE_ENV === 'development' ? '.env.development' : '.env.production'
config({ path: envFile })

----------------------------------------

TITLE: Initializing Node.js Project and Installing Prisma CLI
DESCRIPTION: Commands to create a new Node.js project and install Prisma CLI as a development dependency. This sets up the initial project structure and adds Prisma to the project.

LANGUAGE: bash
CODE:
npm init -y
npm install prisma --save-dev

----------------------------------------

TITLE: Renaming Field Example Schema
DESCRIPTION: Prisma schema showing a field that needs to be renamed from 'biograpy' to 'biography'.

LANGUAGE: prisma
CODE:
model Profile {
  id       Int    @id @default(autoincrement())
  biograpy String
  userId   Int    @unique
  user     User   @relation(fields: [userId], references: [id])
}

----------------------------------------

TITLE: Initializing Prisma Project
DESCRIPTION: Command to initialize a Prisma project, which creates a prisma directory with a schema file and a .env file for environment variables.

LANGUAGE: bash
CODE:
npx prisma init

----------------------------------------

TITLE: Updating Database Connection URL in .env File
DESCRIPTION: This snippet demonstrates how to swap the local database connection URL for a production connection URL in the .env file. It highlights the risks associated with this approach, such as exposing production credentials and potential accidental overrides.

LANGUAGE: bash
CODE:
//delete-next-line
DATABASE_URL="postgresql://johndoe:randompassword@localhost:5432/my_local_database"

//add-next-line
DATABASE_URL="postgresql://johndoe:randompassword@localhost:5432/my_production_database"

----------------------------------------

TITLE: Environment Variable Expansion with dotenv-expand
DESCRIPTION: Example of using dotenv-expand for variable expansion in environment files.

LANGUAGE: typescript
CODE:
import * as dotenv from 'dotenv'
const dotenvExpand = require('dotenv-expand')

var envFile = path.resolve(join(__dirname, "myenv.env"))
var mySqlEnv = dotenv.config({path: envFile})
dotenvExpand.expand(mySqlEnv)

----------------------------------------

TITLE: Creating Connected Post and User Records
DESCRIPTION: Shows how to create a new Post record and connect it to an existing User record using Prisma Client's create method with nested connect operation.

LANGUAGE: javascript
CODE:
const post = await prisma.post.create({
  data: {
    title: 'Join us for Prisma Day 2020',
    slug: 'prisma-day-2020',
    body: 'A conference on modern application development and databases.',
    user: {
      connect: { email: 'hello@prisma.com' },
    },
  },
})

----------------------------------------

TITLE: Declaring Multiple Extended Prisma Clients
DESCRIPTION: Shows how to create multiple extended Prisma Clients with different combinations of extensions.

LANGUAGE: typescript
CODE:
// First of all, store your original Prisma Client in a variable as usual
const prisma = new PrismaClient()

// Declare an extended client that has extensionA applied
const prismaA = prisma.$extends(extensionA)

// Declare an extended client that has extensionB applied
const prismaB = prisma.$extends(extensionB)

// Declare an extended client that is a combination of clientA and clientB
const prismaAB = prismaA.$extends(extensionB)

----------------------------------------

TITLE: Invoking Prisma CLI
DESCRIPTION: Command to invoke the Prisma CLI using npx, which is useful for running Prisma commands in the project.

LANGUAGE: bash
CODE:
npx prisma

----------------------------------------

TITLE: Modifying SQL Migration Example
DESCRIPTION: Example showing a SQL migration that alters a table column's data type. Used to demonstrate how modifying existing migrations can cause inconsistencies.

LANGUAGE: sql
CODE:
-- AlterTable
ALTER TABLE "Post" ALTER COLUMN "content" SET DATA TYPE VARCHAR(560);

----------------------------------------

TITLE: Defining Prisma Data Models for User, Post and Profile
DESCRIPTION: Prisma schema definition that creates three related models: Post, Profile, and User. The models include relationships, field types, and database constraints. This schema will be used to generate the database tables.

LANGUAGE: prisma
CODE:
model Post {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  title     String   @db.VarChar(255)
  content   String?
  published Boolean  @default(false)
  author    User     @relation(fields: [authorId], references: [id])
  authorId  Int
}

model Profile {
  id     Int     @id @default(autoincrement())
  bio    String?
  user   User    @relation(fields: [userId], references: [id])
  userId Int     @unique
}

model User {
  id      Int      @id @default(autoincrement())
  email   String   @unique
  name    String?
  posts   Post[]
  profile Profile?
}

----------------------------------------

TITLE: Extending All Prisma Models with a Custom Method in TypeScript
DESCRIPTION: This snippet shows how to add an 'exists' method to all models in the Prisma schema using $allModels.

LANGUAGE: typescript
CODE:
const prisma = new PrismaClient().$extends({
  model: {
    $allModels: {
      async exists<T>(
        this: T,
        where: Prisma.Args<T, 'findFirst'>['where']
      ): Promise<boolean> {
        // Get the current model at runtime
        const context = Prisma.getExtensionContext(this)

        const result = await (context as any).findFirst({ where })
        return result !== null
      },
    },
  },
})

----------------------------------------

TITLE: Installing Prisma Client via NPM
DESCRIPTION: Command to install the @prisma/client package. This installation process automatically triggers prisma generate to create a type-safe client based on your schema models.

LANGUAGE: bash
CODE:
npm install @prisma/client

----------------------------------------

TITLE: Creating Project Directory and Navigating
DESCRIPTION: Commands to create a new project directory named 'hello-prisma' and navigate into it using the terminal.

LANGUAGE: bash
CODE:
mkdir hello-prisma
cd hello-prisma

----------------------------------------

TITLE: Creating Related Models in Prisma Schema
DESCRIPTION: Prisma schema definition for User, Profile, and Post models with relationships.

LANGUAGE: prisma
CODE:
model User {
  id      Int      @id @default(autoincrement())
  name    String?
  email   String   @unique
  posts   Post[]
  profile Profile?
}

model Profile {
  id     Int    @id @default(autoincrement())
  bio    String
  user   User   @relation(fields: [userId], references: [id])
  userId Int
}

model Post {
  id       Int    @id @default(autoincrement())
  title    String
  author   User   @relation(fields: [authorId], references: [id])
  authorId Int
}

----------------------------------------

TITLE: Initializing Prisma Client with Node.js
DESCRIPTION: Basic setup code for initializing Prisma Client and creating a connection to the database with proper error handling and connection cleanup.

LANGUAGE: javascript
CODE:
const { PrismaClient } = require('@prisma/client')

const prisma = new PrismaClient()

async function main() {
  // ... you will write your Prisma Client queries here
}

main()
  .then(async () => {
    await prisma.$disconnect()
  })
  .catch(async (e) => {
    console.error(e)
    await prisma.$disconnect()
    process.exit(1)
  })

----------------------------------------

TITLE: Initializing Prisma Client with Node.js
DESCRIPTION: Basic setup code for initializing Prisma Client and creating a connection to the database with proper error handling and connection cleanup.

LANGUAGE: javascript
CODE:
const { PrismaClient } = require('@prisma/client')

const prisma = new PrismaClient()

async function main() {
  // ... you will write your Prisma Client queries here
}

main()
  .then(async () => {
    await prisma.$disconnect()
  })
  .catch(async (e) => {
    console.error(e)
    await prisma.$disconnect()
    process.exit(1)
  })

----------------------------------------

TITLE: Initial Migration SQL for CockroachDB
DESCRIPTION: SQL script generated by Prisma Migrate to create tables for User, Post, and Profile in CockroachDB, including primary keys, foreign keys, and default values.

LANGUAGE: sql
CODE:
CREATE TABLE "User" (
  id INT8 PRIMARY KEY DEFAULT unique_rowid(),
  name STRING(255),
  email STRING(255) UNIQUE NOT NULL
);

CREATE TABLE "Post" (
  id INT8 PRIMARY KEY DEFAULT unique_rowid(),
  title STRING(255) UNIQUE NOT NULL,
  "createdAt" TIMESTAMP NOT NULL DEFAULT now(),
  content STRING,
  published BOOLEAN NOT NULL DEFAULT false,
  "authorId" INT8 NOT NULL,
  FOREIGN KEY ("authorId") REFERENCES "User"(id)
);

CREATE TABLE "Profile" (
  id INT8 PRIMARY KEY DEFAULT unique_rowid(),
  bio STRING,
  "userId" INT8 UNIQUE NOT NULL,
  FOREIGN KEY ("userId") REFERENCES "User"(id)
);

----------------------------------------

TITLE: Deploying Migrations
DESCRIPTION: Applies all pending migrations in production environments using the prisma migrate deploy command.

LANGUAGE: terminal
CODE:
prisma migrate deploy

----------------------------------------

TITLE: Configuring User Database Prisma Schema
DESCRIPTION: Prisma schema configuration for the user database including model definition and client generation settings.

LANGUAGE: prisma
CODE:
generator client {
  provider = "prisma-client-js"
  output = "../prisma-user-database/user-database-client-types"
}

datasource db {
  provider = "postgresql"
  url      = env("PPG_USER_DATABASE_URL")
}

model User {
  id    Int     @id @default(autoincrement())
  email String  @unique
  name  String?
}

----------------------------------------

TITLE: Defining User and Post Models in Prisma Schema
DESCRIPTION: This snippet shows a Prisma schema defining User and Post models with relations between them, as well as an enum for User roles.

LANGUAGE: prisma
CODE:
model User {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  name      String?
  role      Role     @default(USER)
  posts     Post[]
}

model Post {
  id        Int      @id @default(autoincrement())
  published Boolean  @default(false)
  title     String  
  author    User?    @relation(fields: [authorId], references: [id])
  authorId  Int?
}

enum Role {
  USER
  ADMIN
}

----------------------------------------

TITLE: Defining User and Post Models in Prisma Schema
DESCRIPTION: This snippet shows a Prisma schema defining User and Post models with relations between them, as well as an enum for User roles.

LANGUAGE: prisma
CODE:
model User {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  name      String?
  role      Role     @default(USER)
  posts     Post[]
}

model Post {
  id        Int      @id @default(autoincrement())
  published Boolean  @default(false)
  title     String  
  author    User?    @relation(fields: [authorId], references: [id])
  authorId  Int?
}

enum Role {
  USER
  ADMIN
}

----------------------------------------

TITLE: Using Environment Variables for Database Connection in Prisma
DESCRIPTION: Demonstrates how to use environment variables for database connection URLs in Prisma schema and .env file configuration.

LANGUAGE: prisma
CODE:
datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

LANGUAGE: text
CODE:
DATABASE_URL=postgresql://janedoe:mypassword@localhost:5432/mydb

----------------------------------------

TITLE: Executing Operations on Database Replica in TypeScript
DESCRIPTION: Shows how to use the $replica() method to explicitly execute a query against a replica instead of the primary database.

LANGUAGE: typescript
CODE:
const result = await prisma.$replica().user.findFirst(...)

----------------------------------------

TITLE: Configuring Prisma Schema for Netlify Deployment
DESCRIPTION: This snippet shows how to configure the data source in the schema.prisma file to use the DATABASE_URL environment variable, which is automatically set by the Netlify extension.

LANGUAGE: prisma
CODE:
// schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

----------------------------------------

TITLE: Filtering Records with TypeORM
DESCRIPTION: Shows how to filter records using TypeORM's find method with a where clause and the ILike operator. This example filters posts that contain 'Hello World' in the title.

LANGUAGE: typescript
CODE:
const posts = await postRepository.find({
  where: {
    title: ILike('%Hello World%'),
  },
})

----------------------------------------

TITLE: Installing Prisma CLI Command
DESCRIPTION: Example showing how to install Prisma using npm in the terminal.

LANGUAGE: terminal
CODE:
npm install prisma

----------------------------------------

TITLE: Running Prisma CLI
DESCRIPTION: Command to invoke the Prisma CLI

LANGUAGE: bash
CODE:
npx prisma