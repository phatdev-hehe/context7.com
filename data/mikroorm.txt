TITLE: Implementing OneToMany Relationships in TypeScript with MikroORM
DESCRIPTION: Shows different approaches to define OneToMany relationships using Collections. Includes examples of mapped relationships, entity type inference, and orphan removal configuration.

LANGUAGE: typescript
CODE:
@Entity()
export class Author {

  @OneToMany(() => Book, book => book.author)
  books1 = new Collection<Book>(this);

  @OneToMany('Book', 'author')
  books2 = new Collection<Book>(this);

  @OneToMany({ mappedBy: book => book.author })
  books3 = new Collection<Book>(this);

  @OneToMany({ entity: () => Book, mappedBy: 'author', orphanRemoval: true })
  books4 = new Collection<Book>(this);

}

----------------------------------------

TITLE: TypeScript Configuration for MikroORM
DESCRIPTION: TypeScript compiler and ts-node configuration required for ESM support and MikroORM functionality

LANGUAGE: json
CODE:
{
  "compilerOptions": {
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "target": "ES2022",
    "strict": true,
    "outDir": "dist",
    "declaration": true,
    "experimentalDecorators": true
  },
  "include": [
    "./src/**/*.ts"
  ],
  "ts-node": {
    "esm": true,
    "transpileOnly": true
  }
}

----------------------------------------

TITLE: Defining Author Entity with Reflect Metadata
DESCRIPTION: Example of defining an Author entity for MongoDB using decorators with the reflect-metadata provider. Shows how to use ObjectId as primary key and define various property types.

LANGUAGE: typescript
CODE:
@Entity()
export class Author {

  @PrimaryKey()
  _id!: ObjectId;

  @SerializedPrimaryKey()
  id!: string;

  @Property()
  createdAt = new Date();

  @Property({ onUpdate: () => new Date() })
  updatedAt = new Date();

  @Property()
  name!: string;

  @Property()
  email!: string;

  @Property({ nullable: true })
  age?: number;

  @Property()
  termsAccepted: boolean = false;

  @Property({ nullable: true })
  identities?: string[];

  @Property({ nullable: true })
  born?: string;

  @OneToMany(() => Book, book => book.author)
  books = new Collection<Book>(this);

  @ManyToMany(() => Author)
  friends = new Collection<Author>(this);

  @ManyToOne(() => Book, { nullable: true })
  favouriteBook?: Book;

  @Property({ version: true })
  version!: number;

  constructor(name: string, email: string) {
    this.name = name;
    this.email = email;
  }

}

----------------------------------------

TITLE: MikroORM Configuration for SQLite
DESCRIPTION: Configuration file for MikroORM using SQLite driver and ts-morph metadata provider.

LANGUAGE: typescript
CODE:
import { Options, SqliteDriver } from '@mikro-orm/sqlite';
import { TsMorphMetadataProvider } from '@mikro-orm/reflection';

const config: Options = {
  driver: SqliteDriver,
  dbName: 'sqlite.db',
  entities: ['dist/**/*.entity.js'],
  entitiesTs: ['src/**/*.entity.ts'],
  metadataProvider: TsMorphMetadataProvider,
  debug: true,
};

export default config;

----------------------------------------

TITLE: Defining an Entity with UUID Primary Key in TypeScript
DESCRIPTION: This example demonstrates how to use a UUID as the primary key for an entity in TypeScript.

LANGUAGE: typescript
CODE:
import { v4 } from 'uuid';

@Entity()
export class Book {

  @PrimaryKey()
  uuid = v4();

  @Property()
  title!: string;

  @ManyToOne(() => Author)
  author!: Author;

}

----------------------------------------

TITLE: Configuring Cascade Options in MikroORM Entity Relationships
DESCRIPTION: This snippet demonstrates how to configure cascade options for different types of entity relationships in MikroORM. It shows various cascade settings including default, persist only, remove only, no cascade, and cascade all.

LANGUAGE: typescript
CODE:
// cascade persist is default value
@OneToMany({ entity: () => Book, mappedBy: 'author' })
books = new Collection<Book>(this);

// same as previous definition
@OneToMany({ entity: () => Book, mappedBy: 'author', cascade: [Cascade.PERSIST] })
books = new Collection<Book>(this);

// only cascade remove
@OneToMany({ entity: () => Book, mappedBy: 'author', cascade: [Cascade.REMOVE] })
books = new Collection<Book>(this);

// no cascade
@OneToMany({ entity: () => Book, mappedBy: 'author', cascade: [] })
books = new Collection<Book>(this);

// cascade all (persist and remove)
@OneToMany({ entity: () => Book, mappedBy: 'author', cascade: [Cascade.ALL] })
books = new Collection<Book>(this);

// same as previous definition
@OneToMany({ entity: () => Book, mappedBy: 'author', cascade: [Cascade.PERSIST, Cascade.REMOVE] })
books = new Collection<Book>(this);

----------------------------------------

TITLE: Basic Entity Management with Flush
DESCRIPTION: Demonstrates how to update a managed entity and flush changes to the database. Shows that managed entities don't need explicit persist calls.

LANGUAGE: typescript
CODE:
const book = await orm.em.findOne(Book, 1);
book.title = 'How to persist things...';

// no need to persist `book` as its already managed by the EM
await orm.em.flush();

----------------------------------------

TITLE: Configuring Entity Discovery in MikroORM
DESCRIPTION: Shows different ways to configure entity discovery in MikroORM, including direct entity references and folder-based discovery with TypeScript support.

LANGUAGE: typescript
CODE:
MikroORM.init({
  entities: [Author, Book, Publisher, BookTag],
});

LANGUAGE: typescript
CODE:
MikroORM.init({
  entities: ['./dist/modules/users/entities', './dist/modules/projects/entities'],
  entitiesTs: ['./src/modules/users/entities', './src/modules/projects/entities'],
  baseDir: process.cwd(),
});

----------------------------------------

TITLE: Initializing MikroORM in TypeScript
DESCRIPTION: Example of initializing MikroORM with basic configuration options.

LANGUAGE: typescript
CODE:
import { MikroORM } from '@mikro-orm/postgresql'; // or any other driver package

const orm = await MikroORM.init({
  entities: ['./dist/entities'], // path to your JS entities (dist), relative to `baseDir`
  dbName: 'my-db-name',
});
console.log(orm.em); // access EntityManager via `em` property

----------------------------------------

TITLE: Defining Custom Types in MikroORM
DESCRIPTION: This example shows how to define custom types by extending the Type abstract class in MikroORM.

LANGUAGE: typescript
CODE:
class CustomType extends Type<any, any> {
  convertToDatabaseValue(value: any, platform: Platform): any {
    // Convert to database value
  }

  convertToJSValue(value: any, platform: Platform): any {
    // Convert to JS value
  }

  getColumnType(prop: EntityProperty, platform: Platform): string {
    // Get SQL type
  }
}

----------------------------------------

TITLE: Defining Custom Base Entity
DESCRIPTION: Example of defining a custom base entity with common properties

LANGUAGE: typescript
CODE:
import { v4 } from 'uuid';

export abstract class CustomBaseEntity {

  @PrimaryKey()
  uuid = v4();

  @Property()
  createdAt = new Date();

  @Property({ onUpdate: () => new Date() })
  updatedAt = new Date();

}

----------------------------------------

TITLE: Basic Entity Definition with Reflect Metadata
DESCRIPTION: Example of a basic Book entity definition using class decorators and reflect-metadata provider.

LANGUAGE: typescript
CODE:
@Entity()
export class Book extends CustomBaseEntity {
  @Property()
  title!: string;

  @ManyToOne(() => Author)
  author!: Author;

  @ManyToOne(() => Publisher, { ref: true, nullable: true })
  publisher?: Ref<Publisher>;

  @ManyToMany({ entity: 'BookTag', fixedOrder: true })
  tags = new Collection<BookTag>(this);
}

----------------------------------------

TITLE: Configuring MikroORM Module in NestJS
DESCRIPTION: Setting up MikroORM in the root AppModule with entity configuration and database connection settings.

LANGUAGE: typescript
CODE:
@Module({
  imports: [
    MikroOrmModule.forRoot({
      entities: ['./dist/entities'],
      entitiesTs: ['./src/entities'],
      dbName: 'my-db-name.sqlite3',
    }),
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}

----------------------------------------

TITLE: User Entity Definition
DESCRIPTION: Example User entity class with property decorators for database mapping

LANGUAGE: typescript
CODE:
import { Entity, PrimaryKey, Property } from '@mikro-orm/core';

@Entity()
export class User {

   @PrimaryKey()
   id!: number;

   @Property()
   fullName!: string;

   @Property()
   email!: string;

   @Property()
   password!: string;

   @Property({ type: 'text' })
   bio = '';

}

----------------------------------------

TITLE: Initializing MikroORM in TypeScript
DESCRIPTION: Example of initializing MikroORM with PostgreSQL driver, including entity configuration and database connection settings.

LANGUAGE: typescript
CODE:
import type { PostgreSqlDriver } from '@mikro-orm/postgresql'; // or any other driver package

const orm = await MikroORM.init<PostgreSqlDriver>({
  entities: ['./dist/entities'], // path to your JS entities (dist), relative to `baseDir`
  dbName: 'my-db-name',
  type: 'postgresql',
});
console.log(orm.em); // access EntityManager via `em` property

----------------------------------------

TITLE: Defining Book Entity with Decorators (reflect-metadata)
DESCRIPTION: Example of defining a Book entity using decorators with reflect-metadata provider

LANGUAGE: typescript
CODE:
@Entity()
export class Book extends CustomBaseEntity {

  @Property()
  title!: string;

  @ManyToOne(() => Author)
  author!: Author;

  @ManyToOne(() => Publisher, { ref: true, nullable: true })
  publisher?: Ref<Publisher>;

  @ManyToMany({ entity: 'BookTag', fixedOrder: true })
  tags = new Collection<BookTag>(this);

}

----------------------------------------

TITLE: Defining Author Entity with Decorators
DESCRIPTION: Example of defining an Author entity using class decorators in TypeScript for MongoDB. Demonstrates various property types and relationships.

LANGUAGE: TypeScript
CODE:
@Entity()
export class Author {

  @PrimaryKey()
  _id!: ObjectId;

  @SerializedPrimaryKey()
  id!: string;

  @Property()
  createdAt = new Date();

  @Property({ onUpdate: () => new Date() })
  updatedAt = new Date();

  @Property()
  name!: string;

  @Property()
  email!: string;

  @Property({ nullable: true })
  age?: number;

  @Property()
  termsAccepted: boolean = false;

  @Property({ nullable: true })
  identities?: string[];

  @Property({ nullable: true })
  born?: Date;

  @OneToMany(() => Book, book => book.author)
  books = new Collection<Book>(this);

  @ManyToMany(() => Author)
  friends = new Collection<Author>(this);

  @ManyToOne(() => Book, { nullable: true })
  favouriteBook?: Book;

  @Property({ version: true })
  version!: number;

  constructor(name: string, email: string) {
    this.name = name;
    this.email = email;
  }

}

----------------------------------------

TITLE: Defining MikroORM Configuration
DESCRIPTION: TypeScript code showing how to define MikroORM configuration using the defineConfig helper.

LANGUAGE: typescript
CODE:
import { defineConfig } from '@mikro-orm/sqlite';

export default defineConfig({
  entities: [Author, Book, BookTag],
  dbName: 'my-db-name',
  // this is inferred as you import `defineConfig` from sqlite package
  // driver: SqliteDriver,
});

----------------------------------------

TITLE: Basic Entity Schema Definition in TypeScript
DESCRIPTION: Demonstrates how to define a basic Book entity schema with relationships to Author, Publisher and BookTags using EntitySchema.

LANGUAGE: typescript
CODE:
export interface Book extends CustomBaseEntity {
  title: string;
  author: Author;
  publisher: Publisher;
  tags: Collection<BookTag>;
}

export const schema = new EntitySchema<Book, CustomBaseEntity>({
  name: 'Book',
  extends: CustomBaseEntitySchema,
  properties: {
    title: { type: 'string' },
    author: { kind: 'm:1', entity: 'Author', inversedBy: 'books' },
    publisher: { kind: 'm:1', entity: 'Publisher', inversedBy: 'books' },
    tags: { kind: 'm:n', entity: 'BookTag', inversedBy: 'books', fixedOrder: true },
  },
});

----------------------------------------

TITLE: Defining Book Entity with Decorators
DESCRIPTION: Example of defining a Book entity using class decorators in TypeScript. Shows how to use @Entity, @Property, and relationship decorators.

LANGUAGE: TypeScript
CODE:
@Entity()
export class Book extends CustomBaseEntity {

  @Property()
  title!: string;

  @ManyToOne(() => Author)
  author!: Author;

  @ManyToOne(() => Publisher, { ref: true, nullable: true })
  publisher?: Ref<Publisher>;

  @ManyToMany({ entity: 'BookTag', fixedOrder: true })
  tags = new Collection<BookTag>(this);

}

----------------------------------------

TITLE: Updating Deep Entity Graph with assign() in TypeScript
DESCRIPTION: Demonstrates how to update a deep entity graph using assign() by providing the primary key in the data.

LANGUAGE: typescript
CODE:
const book = await em.findOneOrFail(Book, 1, { populate: ['author'] });

// update existing book's author's name
wrap(book).assign({
  author: {
    id: book.author.id,
    name: 'New name...',
  },
});

----------------------------------------

TITLE: Creating MikroORM Configuration File
DESCRIPTION: TypeScript code showing how to create a MikroORM configuration file using the defineConfig helper.

LANGUAGE: typescript
CODE:
import { defineConfig } from '@mikro-orm/sqlite';

export default defineConfig({
  entities: [Author, Book, BookTag],
  dbName: 'my-db-name',
  // this is inferred as you import `defineConfig` from sqlite package
  // driver: SqliteDriver,
});

----------------------------------------

TITLE: Configuring OneToOne Relationships (Inverse Side) in MikroORM
DESCRIPTION: Shows how to implement the inverse side of OneToOne relationships with mappedBy parameter and orphanRemoval option.

LANGUAGE: typescript
CODE:
@Entity()
export class User {

  @OneToOne({ mappedBy: 'bestFriend1', orphanRemoval: true })
  bestFriend1!: User;

  @OneToOne(() => User, user => user.bestFriend2, { orphanRemoval: true })
  bestFriend2!: User;

}

----------------------------------------

TITLE: Relationship Decorators
DESCRIPTION: Examples of defining entity relationships using @ManyToOne, @OneToOne, @OneToMany and @ManyToMany decorators

LANGUAGE: typescript
CODE:
@ManyToOne()
author1?: Author;

@OneToOne({ inversedBy: 'bestFriend1', orphanRemoval: true })
bestFriend2!: User;

@OneToMany(() => Book, book => book.author)
books1 = new Collection<Book>(this);

@ManyToMany({ entity: () => BookTag, cascade: [], fixedOrderColumn: 'order' })
tags = new Collection<BookTag>(this);

----------------------------------------

TITLE: Defining Book Entity with Decorators (reflect-metadata)
DESCRIPTION: Example of defining a Book entity using decorators with reflect-metadata provider

LANGUAGE: typescript
CODE:
@Entity()
export class Book extends CustomBaseEntity {

  @Property()
  title!: string;

  @ManyToOne(() => Author)
  author!: Author;

  @ManyToOne(() => Publisher, { ref: true, nullable: true })
  publisher?: Ref<Publisher>;

  @ManyToMany({ entity: 'BookTag', fixedOrder: true })
  tags = new Collection<BookTag>(this);

}

----------------------------------------

TITLE: Persisting and Flushing Entities in MikroORM
DESCRIPTION: Example of how to persist and flush entities using the EntityManager in MikroORM. This demonstrates working with managed entities and automatic cascading.

LANGUAGE: typescript
CODE:
const book = await em.findOne(Book, 1);
book.title = 'How to persist things...';

// no need to persist `book` as its already managed by the EM
await em.flush();

LANGUAGE: typescript
CODE:
// use constructors in our entities for required parameters
const author = new Author('Jon Snow', 'snow@wall.st');
author.born = new Date();

const publisher = new Publisher('7K publisher');

const book1 = new Book('My Life on The Wall, part 1', author);
book1.publisher = publisher;
const book2 = new Book('My Life on The Wall, part 2', author);
book2.publisher = publisher;
const book3 = new Book('My Life on The Wall, part 3', author);
book3.publisher = publisher;

// just persist books, author and publisher will be automatically cascade persisted
await em.persist([book1, book2, book3]).flush();

// or one by one
em.persist(book1);
em.persist(book2);
em.persist(book3);
await em.flush(); // flush everything to database at once

----------------------------------------

TITLE: Basic Entity Schema Definition in TypeScript
DESCRIPTION: Demonstrates how to define a basic Book entity schema with relationships to Author, Publisher and BookTags using EntitySchema.

LANGUAGE: typescript
CODE:
export interface Book extends CustomBaseEntity {
  title: string;
  author: Author;
  publisher: Publisher;
  tags: Collection<BookTag>;
}

export const schema = new EntitySchema<Book, CustomBaseEntity>({
  name: 'Book',
  extends: CustomBaseEntitySchema,
  properties: {
    title: { type: 'string' },
    author: { kind: 'm:1', entity: 'Author', inversedBy: 'books' },
    publisher: { kind: 'm:1', entity: 'Publisher', inversedBy: 'books' },
    tags: { kind: 'm:n', entity: 'BookTag', inversedBy: 'books', fixedOrder: true },
  },
});

----------------------------------------

TITLE: Defining Entity with @Entity Decorator in TypeScript
DESCRIPTION: Example of using the @Entity decorator to define an entity class with a custom table name.

LANGUAGE: typescript
CODE:
@Entity({ tableName: 'authors' })
export class Author { ... }

----------------------------------------

TITLE: Initializing MikroORM
DESCRIPTION: TypeScript code to initialize MikroORM with basic configuration options.

LANGUAGE: typescript
CODE:
import { MikroORM } from '@mikro-orm/postgresql'; // or any other driver package

const orm = await MikroORM.init({
  entities: ['./dist/entities'], // path to your JS entities (dist), relative to `baseDir`
  dbName: 'my-db-name',
});
console.log(orm.em); // access EntityManager via `em` property

----------------------------------------

TITLE: Adding Timestamps to User Entity
DESCRIPTION: Demonstrates how to add created and updated timestamp fields to a User entity using MikroORM Property decorators.

LANGUAGE: typescript
CODE:
@Property()
createdAt = new Date();

@Property({ onUpdate: () => new Date() })
updatedAt = new Date();

----------------------------------------

TITLE: Configuring Entity Discovery in MikroORM
DESCRIPTION: Shows how to configure entity discovery either through explicit entity array or folder-based discovery with support for TypeScript files.

LANGUAGE: typescript
CODE:
MikroORM.init({
  entities: [Author, Book, Publisher, BookTag],
});

LANGUAGE: typescript
CODE:
MikroORM.init({
  entities: ['./dist/modules/users/entities', './dist/modules/projects/entities'],
  entitiesTs: ['./src/modules/users/entities', './src/modules/projects/entities'],
  // optionally you can override the base directory (defaults to `process.cwd()`)
  baseDir: process.cwd(),
});

----------------------------------------

TITLE: Using RequestContext Middleware in MikroORM (TypeScript)
DESCRIPTION: This code demonstrates how to use the RequestContext helper as middleware to create a new request context for each incoming HTTP request.

LANGUAGE: typescript
CODE:
app.use((req, res, next) => {
  // calls `orm.em.fork()` and attaches it to the async context
  RequestContext.create(orm.em, next);
});

app.get('/', async (req, res) => {
  // uses fork from the async context automatically
  const authors = await orm.em.find(Book, {});
  res.json(authors);
});

----------------------------------------

TITLE: Defining ManyToOne Relationships in TypeScript with MikroORM
DESCRIPTION: Demonstrates various ways to define ManyToOne relationships in MikroORM entities. Shows different syntax options including plain decorator, callback type specification, string type specification, and options object usage.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @ManyToOne() // plain decorator is enough, type will be sniffer via reflection!
  author1!: Author;

  @ManyToOne(() => Author) // you can specify type manually as a callback
  author2!: Author;

  @ManyToOne('Author') // or as a string
  author3!: Author;

  @ManyToOne({ entity: () => Author }) // or use options object
  author4!: Author;

}

----------------------------------------

TITLE: Basic MikroORM Initialization
DESCRIPTION: Example showing how to initialize MikroORM with basic configuration options including entity paths and database name.

LANGUAGE: typescript
CODE:
import { MikroORM } from '@mikro-orm/postgresql';

const orm = await MikroORM.init({
  entities: ['./dist/entities'], // path to your JS entities (dist), relative to `baseDir`
  dbName: 'my-db-name',
});
console.log(orm.em); // access EntityManager via `em` property

----------------------------------------

TITLE: Installing MikroORM Database Drivers
DESCRIPTION: Commands for installing MikroORM core and various database drivers including MongoDB, MySQL, PostgreSQL, SQLite, and MSSQL.

LANGUAGE: bash
CODE:
# for mongodb
npm install @mikro-orm/core @mikro-orm/mongodb

# for mysql (works with mariadb too)
npm install @mikro-orm/core @mikro-orm/mysql

# for mariadb (works with mysql too)
npm install @mikro-orm/core @mikro-orm/mariadb

# for postgresql (works with cockroachdb too)
npm install @mikro-orm/core @mikro-orm/postgresql

# for sqlite
npm install @mikro-orm/core @mikro-orm/sqlite

# for better-sqlite
npm install @mikro-orm/core @mikro-orm/better-sqlite

# for libsql/turso
npm install @mikro-orm/core @mikro-orm/libsql

# for mssql
npm install @mikro-orm/core @mikro-orm/mssql

----------------------------------------

TITLE: Initializing MikroORM
DESCRIPTION: TypeScript code to initialize MikroORM with basic configuration options.

LANGUAGE: typescript
CODE:
import { MikroORM } from '@mikro-orm/postgresql'; // or any other driver package

const orm = await MikroORM.init({
  entities: ['./dist/entities'], // path to your JS entities (dist), relative to `baseDir`
  dbName: 'my-db-name',
});
console.log(orm.em); // access EntityManager via `em` property

----------------------------------------

TITLE: Defining a Basic Entity with Decorators in TypeScript
DESCRIPTION: This snippet shows how to define a basic Book entity using decorators in TypeScript. It includes a primary key, a simple property, and relationships.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @PrimaryKey()
  id!: number;

  @Property()
  title!: string;

  @ManyToOne(() => Author)
  author!: Author;

  @ManyToOne(() => Publisher, { ref: true, nullable: true })
  publisher?: Ref<Publisher>;

}

----------------------------------------

TITLE: Manual Transaction Control with Begin/Commit/Rollback
DESCRIPTION: Demonstrates explicit transaction control using begin, commit, and rollback methods with proper error handling.

LANGUAGE: typescript
CODE:
const em = orm.em.fork();
await em.begin();

try {
  //... do some work
  const user = new User(...);
  user.name = 'George';
  em.persist(user);
  await em.commit(); // will flush before making the actual commit query
} catch (e) {
  await em.rollback();
  throw e;
}

----------------------------------------

TITLE: Defining ManyToMany Collections in MikroORM
DESCRIPTION: Illustrates how to define unidirectional and bidirectional ManyToMany collections in MikroORM. It shows examples for both owning and inverse sides of the relationship.

LANGUAGE: typescript
CODE:
// Unidirectional
@ManyToMany({ entity: () => Book, owner: true })
books = new Collection<Book>(this);

// Bidirectional - owning side
@ManyToMany({ entity: () => BookTag, inversedBy: 'books' })
tags = new Collection<BookTag>(this);

// Bidirectional - inverse side
@ManyToMany({ entity: () => Book, mappedBy: 'tags' })
books = new Collection<Book>(this);

----------------------------------------

TITLE: Processing Generated Metadata in MikroORM EntityGenerator
DESCRIPTION: Example of using onInitialMetadata and onProcessedMetadata hooks to modify generated metadata, such as making password columns lazy and hidden, and hiding all ManyToMany relations.

LANGUAGE: typescript
CODE:
import { ReferenceKind } from '@mikro-orm/core';

await orm.entityGenerator.generate({
  onInitialMetadata: (metadata, platform) => {
    metadata.forEach(meta => {
      meta.props.forEach(prop => {
        if (prop.name === 'password') {
          prop.hidden = true;
          prop.lazy = true;
        }
      });
    });
  },
  onProcessedMetadata: (metadata, platform) => {
    metadata.forEach(meta => {
      meta.props.forEach(prop => {
        if (prop.kind === ReferenceKind.MANY_TO_MANY) {
          prop.hidden = true;
        }
      });
    });
  },
});

----------------------------------------

TITLE: Initializing MikroORM with PostgreSQL Driver
DESCRIPTION: This code snippet shows how to initialize MikroORM with a PostgreSQL driver. It sets up the ORM configuration including entity paths and database name.

LANGUAGE: typescript
CODE:
import type { PostgreSqlDriver } from '@mikro-orm/postgresql';

const orm = await MikroORM.init<PostgreSqlDriver>({
  entities: ['./dist/entities'],
  dbName: 'my-db-name',
  type: 'postgresql',
});
console.log(orm.em);

----------------------------------------

TITLE: Implementing ManyToMany Relationships (Inverse Side) in MikroORM
DESCRIPTION: Shows how to define the inverse side of ManyToMany relationships using the mappedBy parameter and Collection initialization.

LANGUAGE: typescript
CODE:
@Entity()
export class BookTag {

  @ManyToMany(() => Book, book => book.tags)
  books = new Collection<Book>(this);

}

----------------------------------------

TITLE: Entity Definition Example
DESCRIPTION: Sample entity class definition showing primary key, properties, and relationships using decorators.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @PrimaryKey()
  id: bigint;

  @Property()
  title: string;

  @ManyToOne(() => Author)
  author: Author;

  @ManyToMany(() => BookTag)
  tags = new Collection<BookTag>(this);

  constructor(title: string, author: Author) {
    this.title = title;
    this.author = author;
  }

}

----------------------------------------

TITLE: MikroORM Initialization
DESCRIPTION: Basic setup for initializing MikroORM with entity path configuration and database connection.

LANGUAGE: typescript
CODE:
import { MikroORM } from '@mikro-orm/postgresql';

const orm = await MikroORM.init({
  entities: ['./dist/entities'], // path to your JS entities (dist), relative to `baseDir`
  dbName: 'my-db-name',
});
console.log(orm.em); // access EntityManager via `em` property

----------------------------------------

TITLE: Installing MikroORM Database Drivers
DESCRIPTION: Commands for installing MikroORM core and different database drivers including MongoDB, MySQL, PostgreSQL, SQLite and others.

LANGUAGE: bash
CODE:
# for mongodb
npm install @mikro-orm/core @mikro-orm/mongodb

# for mysql (works with mariadb too)
npm install @mikro-orm/core @mikro-orm/mysql

# for mariadb (works with mysql too)
npm install @mikro-orm/core @mikro-orm/mariadb

# for postgresql (works with cockroachdb too)
npm install @mikro-orm/core @mikro-orm/postgresql

# for sqlite
npm install @mikro-orm/core @mikro-orm/sqlite

# for better-sqlite
npm install @mikro-orm/core @mikro-orm/better-sqlite

# for libsql/turso
npm install @mikro-orm/core @mikro-orm/libsql

# for mssql
npm install @mikro-orm/core @mikro-orm/mssql

----------------------------------------

TITLE: Installing MikroORM and Database Drivers
DESCRIPTION: Commands for installing MikroORM core and database-specific drivers using yarn or npm.

LANGUAGE: sh
CODE:
yarn add @mikro-orm/core @mikro-orm/mongodb     # for mongo
yarn add @mikro-orm/core @mikro-orm/mysql       # for mysql/mariadb
yarn add @mikro-orm/core @mikro-orm/mariadb     # for mysql/mariadb
yarn add @mikro-orm/core @mikro-orm/postgresql  # for postgresql
yarn add @mikro-orm/core @mikro-orm/sqlite      # for sqlite

LANGUAGE: sh
CODE:
npm i -s @mikro-orm/core @mikro-orm/mongodb     # for mongo
npm i -s @mikro-orm/core @mikro-orm/mysql       # for mysql/mariadb
npm i -s @mikro-orm/core @mikro-orm/mariadb     # for mysql/mariadb
npm i -s @mikro-orm/core @mikro-orm/postgresql  # for postgresql
npm i -s @mikro-orm/core @mikro-orm/sqlite      # for sqlite

----------------------------------------

TITLE: Defining an Entity with MikroORM Decorators
DESCRIPTION: TypeScript code demonstrating how to define a Book entity using MikroORM decorators.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @PrimaryKey()
  id: bigint;

  @Property()
  title: string;

  @ManyToOne(() => Author)
  author: Author;

  @ManyToMany(() => BookTag)
  tags = new Collection<BookTag>(this);

  constructor(title: string, author: Author) {
    this.title = title;
    this.author = author;
  }

}

----------------------------------------

TITLE: Defining ManyToMany Relationships in MikroORM with TypeScript
DESCRIPTION: This snippet illustrates how to define ManyToMany relationships in MikroORM, including both owning and inverse sides. It shows the use of the Collection type and demonstrates unidirectional relationships.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  // when none of `owner/inverseBy/mappedBy` is provided, it will be considered owning side
  @ManyToMany()
  tags1 = new Collection<BookTag>(this);

  @ManyToMany(() => BookTag, 'books', { owner: true })
  tags2 = new Collection<BookTag>(this);

  @ManyToMany(() => BookTag, 'books', { owner: true })
  tags3 = new Collection<BookTag>(this);

  @ManyToMany(() => BookTag, 'books', { owner: true })
  tags4 = new Collection<BookTag>(this);

  // to define uni-directional many to many, simply provide only
  @ManyToMany(() => Author)
  friends: Collection<Author> = new Collection<Author>(this);

}

@Entity()
export class BookTag {

  // inverse side has to point to the owning side via `mappedBy` attribute/parameter
  @ManyToMany(() => Book, book => book.tags)
  books = new Collection<Book>(this);

}

----------------------------------------

TITLE: Defining Custom Base Entity
DESCRIPTION: Example of defining a custom base entity with common properties like primary key and timestamps.

LANGUAGE: typescript
CODE:
import { v4 } from 'uuid';

export abstract class CustomBaseEntity {

  @PrimaryKey()
  uuid = v4();

  @Property()
  createdAt = new Date();

  @Property({ onUpdate: () => new Date() })
  updatedAt = new Date();

}

----------------------------------------

TITLE: Creating a Base Entity with Timestamps in TypeScript for MikroORM
DESCRIPTION: Defines an abstract BaseEntity class with id, createdAt, and updatedAt properties. This class can be extended by other entities to provide common fields and functionality.

LANGUAGE: TypeScript
CODE:
import { PrimaryKey, Property } from '@mikro-orm/core';

export abstract class BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property()
  createdAt = new Date();

  @Property({ onUpdate: () => new Date() })
  updatedAt = new Date();

}

----------------------------------------

TITLE: Basic Entity and Property Definition in TypeScript with MikroORM
DESCRIPTION: Example showing how to define a basic entity with primary key and properties using MikroORM decorators

LANGUAGE: typescript
CODE:
@Entity({ tableName: 'authors' })
export class Author { ... }

@Property({ length: 50, fieldName: 'first_name' })
name!: string;

@Property({ columnType: 'datetime', fieldName: 'born_date' })
born?: Date;

@Property({ columnType: 'tinyint' })
age?: number;

@Property({ onUpdate: () => new Date() })
updatedAt = new Date();

@Property()
registered = false;

----------------------------------------

TITLE: Using EntityRepository in TypeScript with MikroORM
DESCRIPTION: Demonstrates how to use the EntityRepository to find books with specific criteria. The repository is obtained from the EntityManager and provides a convenient way to query entities without specifying the entity type in each call.

LANGUAGE: typescript
CODE:
const booksRepository = em.getRepository(Book);

// same as `em.find(Book, { author: '...' }, { ... })`
const books = await booksRepository.find({ author: '...' }, {
  populate: ['author'],
  limit: 1,
  offset: 2,
  orderBy: { title: QueryOrder.DESC },
});

console.log(books); // Book[]

----------------------------------------

TITLE: Assigning References in MikroORM
DESCRIPTION: Shows how to correctly assign Reference instances to entity properties in MikroORM.

LANGUAGE: typescript
CODE:
import { ref } from '@mikro-orm/core';

const book = await em.findOne(Book, 1);
const repo = em.getRepository(Author);

book.author = repo.getReference(2, { wrapped: true });

// same as:
book.author = ref(repo.getReference(2));
await em.flush();

----------------------------------------

TITLE: Using EntityRepository in TypeScript with MikroORM
DESCRIPTION: Demonstrates how to use the EntityRepository to find books with specific criteria. The repository is obtained from the EntityManager and provides a convenient way to query entities without specifying the entity type in each call.

LANGUAGE: typescript
CODE:
const booksRepository = em.getRepository(Book);

// same as `em.find(Book, { author: '...' }, { ... })`
const books = await booksRepository.find({ author: '...' }, {
  populate: ['author'],
  limit: 1,
  offset: 2,
  orderBy: { title: QueryOrder.DESC },
});

console.log(books); // Book[]

----------------------------------------

TITLE: MikroORM Basic Initialization
DESCRIPTION: Example of initializing MikroORM with PostgreSQL driver and basic configuration options.

LANGUAGE: typescript
CODE:
import { MikroORM } from '@mikro-orm/postgresql';

const orm = await MikroORM.init({
  entities: ['./dist/entities'], // path to your JS entities (dist), relative to `baseDir`
  dbName: 'my-db-name',
});
console.log(orm.em);

----------------------------------------

TITLE: Initializing MikroORM with PostgreSQL Driver
DESCRIPTION: Example of initializing MikroORM with PostgreSQL driver, including entity path configuration and database connection settings.

LANGUAGE: typescript
CODE:
import type { PostgreSqlDriver } from '@mikro-orm/postgresql';

const orm = await MikroORM.init<PostgreSqlDriver>({
  entities: ['./dist/entities'], // path to our JS entities (dist), relative to `baseDir`
  entitiesTs: ['./src/entities'], // path to our TS entities (src), relative to `baseDir`
  dbName: 'my-db-name',
  type: 'postgresql',
});
console.log(orm.em);

----------------------------------------

TITLE: Initializing Fastify Server with MikroORM
DESCRIPTION: This function bootstraps the Fastify server with MikroORM integration. It sets up request context handling, database connection management, and defines a sample endpoint for listing articles.

LANGUAGE: typescript
CODE:
import { RequestContext } from '@mikro-orm/core';
import { fastify } from 'fastify';
import { initORM } from './db.js';

export async function bootstrap(port = 3001, migrate = true) {
  const db = await initORM();

  if (migrate) {
    // sync the schema
    await db.orm.migrator.up();
  }

  const app = fastify();

  // register request context hook
  app.addHook('onRequest', (request, reply, done) => {
    RequestContext.create(db.em, done);
  });

  // shut down the connection when closing the app
  app.addHook('onClose', async () => {
    await db.orm.close();
  });

  // register routes here
  app.get('/article', async request => {
    const { limit, offset } = request.query as { limit?: number; offset?: number };
    const [items, total] = await db.article.findAndCount({}, {
      limit, offset,
    });

    return { items, total };
  });

  const url = await app.listen({ port });

  return { app, url };
}

----------------------------------------

TITLE: Defining OneToOne Relationships in MikroORM (TypeScript)
DESCRIPTION: This snippet demonstrates how to define both owning and inverse sides of a OneToOne relationship in MikroORM using TypeScript decorators. It includes examples of self-referencing relationships and orphan removal.

LANGUAGE: typescript
CODE:
@Entity()
export class User {

  // when none of `owner/inverseBy/mappedBy` is provided, it will be considered owning side
  @OneToOne()
  bestFriend1!: User;

  // side with `inversedBy` is the owning one, to define inverse side use `mappedBy`
  @OneToOne({ inversedBy: 'bestFriend1' })
  bestFriend2!: User;

  // when defining it like this, you need to specifically mark the owning side with `owner: true`
  @OneToOne(() => User, user => user.bestFriend2, { owner: true })
  bestFriend3!: User;

}

@Entity()
export class User {

  @OneToOne({ mappedBy: 'bestFriend1', orphanRemoval: true })
  bestFriend1!: User;

  @OneToOne(() => User, user => user.bestFriend2, { orphanRemoval: true })
  bestFriend2!: User;

}

----------------------------------------

TITLE: Defining User Entity in TypeScript with MikroORM
DESCRIPTION: This snippet demonstrates how to define a User entity using MikroORM decorators. It includes primary key, properties, and relationships with other entities.

LANGUAGE: typescript
CODE:
@Entity()
export class User {

  @PrimaryKey()
  id!: number;

  @Property()
  name!: string;

  @OneToOne(() => Address)
  address?: Address;

  @ManyToMany(() => Car)
  cars = new Collection<Car>(this);

  constructor(name: string) {
    this.name = name;
  }

}

----------------------------------------

TITLE: Defining a Book Entity with ts-morph
DESCRIPTION: Example of defining a Book entity using the @Entity decorator and ts-morph approach.

LANGUAGE: typescript
CODE:
@Entity()
export class Book extends CustomBaseEntity {

  @Property()
  title!: string;

  @ManyToOne()
  author!: Author;

  @ManyToOne()
  publisher?: Ref<Publisher>;

  @ManyToMany({ fixedOrder: true })
  tags = new Collection<BookTag>(this);

}

----------------------------------------

TITLE: Configuring TypeScript for Decorators
DESCRIPTION: JSON configuration to enable decorator support in TypeScript.

LANGUAGE: json
CODE:
"experimentalDecorators": true,
"emitDecoratorMetadata": true,
"esModuleInterop": true

----------------------------------------

TITLE: Demonstrating Identity Map in MikroORM with TypeScript
DESCRIPTION: This snippet shows how the Identity Map ensures that the same entity instance is returned across multiple queries within a single request context.

LANGUAGE: typescript
CODE:
const authorRepository = em.getRepository(Author);
const jon = await authorRepository.findOne({ name: 'Jon Snow' }, { populate: ['books'] });
const authors = await authorRepository.findAll({ populate: ['books'] });

// identity map in action
console.log(jon === authors[0]); // true

----------------------------------------

TITLE: Querying Entities with EntityRepository in TypeScript
DESCRIPTION: Demonstrates how to use EntityRepository to query entities, showcasing its convenience over direct EntityManager usage. The example retrieves Book entities with specific filters and options.

LANGUAGE: typescript
CODE:
const booksRepository = em.getRepository(Book);

// same as `em.find(Book, { author: '...' }, { ... })`
const books = await booksRepository.find({ author: '...' }, {
  populate: ['author'],
  limit: 1,
  offset: 2,
  orderBy: { title: QueryOrder.DESC },
});

console.log(books); // Book[]

----------------------------------------

TITLE: Using Custom Pivot Table Entity in ManyToMany Relationships with MikroORM
DESCRIPTION: This snippet shows how to use a custom pivot table entity in ManyToMany relationships in MikroORM. It demonstrates the definition of the pivot entity and how to use it in the ManyToMany relationship.

LANGUAGE: typescript
CODE:
@Entity()
export class Order {

  @ManyToMany({ entity: () => Product, pivotEntity: () => OrderItem })
  products = new Collection<Product>(this);

}

@Entity()
export class Product {

  @ManyToMany({ entity: () => Order, mappedBy: o => o.products })
  orders = new Collection<Order>(this);

}

@Entity()
export class OrderItem {

  @ManyToOne({ primary: true })
  order: Order;

  @ManyToOne({ primary: true })
  product: Product;

  @Property({ default: 1 })
  amount!: number;

}

// create new item
const item = em.create(OrderItem, {
  order: 123,
  product: 321,
  amount: 999,
});
await em.persist(item).flush();

// or remove an item via delete query
const em.nativeDelete(OrderItem, { order: 123, product: 321 });

----------------------------------------

TITLE: Configuring OneToOne Relationships - Owning Side
DESCRIPTION: Demonstrates defining the owning side of OneToOne relationships, including self-referencing relationships and different configuration options.

LANGUAGE: typescript
CODE:
@Entity()
export class User {

  @OneToOne()
  bestFriend1!: User;

  @OneToOne({ inversedBy: 'bestFriend1' })
  bestFriend2!: User;

  @OneToOne(() => User, user => user.bestFriend2, { owner: true })
  bestFriend3!: User;

}

----------------------------------------

TITLE: Using MikroORM SchemaGenerator Programmatically
DESCRIPTION: TypeScript code demonstrating how to use the SchemaGenerator programmatically to perform various schema operations, including getting SQL dumps and executing schema changes.

LANGUAGE: typescript
CODE:
import { MikroORM } from '@mikro-orm/core';

(async () => {
  const orm = await MikroORM.init({
    entities: [Author, Book, ...],
    dbName: 'your-db-name',
    // ...
  });
  const generator = orm.schema;

  const dropDump = await generator.getDropSchemaSQL();
  console.log(dropDump);

  const createDump = await generator.getCreateSchemaSQL();
  console.log(createDump);

  const updateDump = await generator.getUpdateSchemaSQL();
  console.log(updateDump);

  // there is also `generate()` method that returns drop + create queries
  const dropAndCreateDump = await generator.generate();
  console.log(dropAndCreateDump);

  // or you can run those queries directly, but be sure to check them first!
  await generator.dropSchema();
  await generator.createSchema();
  await generator.updateSchema();

  // in tests it can be handy to use those:
  await generator.refreshDatabase(); // ensure db exists and is fresh
  await generator.clearDatabase(); // removes all data

  await orm.close(true);
})();

----------------------------------------

TITLE: Explicit Transaction Handling with Begin/Commit/Rollback in MikroORM
DESCRIPTION: Demonstrates explicit transaction handling using begin(), commit(), and rollback() methods. This approach offers full control over the transaction lifecycle and error handling.

LANGUAGE: typescript
CODE:
const em = orm.em.fork();
await em.begin();

try {
  //... do some work
  const user = new User(...);
  user.name = 'George';
  em.persist(user);
  await em.commit(); // will flush before making the actual commit query
} catch (e) {
  await em.rollback();
  throw e;
}

----------------------------------------

TITLE: Defining Book Entity with Decorators (ts-morph)
DESCRIPTION: Example of defining a Book entity using decorators with ts-morph provider

LANGUAGE: typescript
CODE:
@Entity()
export class Book extends CustomBaseEntity {

  @Property()
  title!: string;

  @ManyToOne()
  author!: Author;

  @ManyToOne()
  publisher?: Ref<Publisher>;

  @ManyToMany({ fixedOrder: true })
  tags = new Collection<BookTag>(this);

}

----------------------------------------

TITLE: Defining Book Entity with Constructor in TypeScript
DESCRIPTION: This snippet demonstrates how to define a Book entity with a constructor that requires title and author. It shows the use of decorators for defining entity properties and relationships.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @PrimaryKey()
  id!: number;

  @Property()
  title: string;

  @Property()
  foo!: number;

  @ManyToOne()
  author: Author;

  @ManyToOne()
  publisher?: Publisher;

  @ManyToMany({ entity: () => BookTag, inversedBy: 'books' })
  tags = new Collection<BookTag>(this);

  constructor(title: string, author: Author) {
    this.title = title;
    this.author = author;
  }

}

----------------------------------------

TITLE: Installing MikroORM and NestJS Module
DESCRIPTION: Commands for installing MikroORM core, NestJS module, and database-specific drivers using yarn or npm.

LANGUAGE: bash
CODE:
$ yarn add @mikro-orm/core @mikro-orm/nestjs @mikro-orm/mongodb     # for mongo
$ yarn add @mikro-orm/core @mikro-orm/nestjs @mikro-orm/mysql       # for mysql/mariadb
$ yarn add @mikro-orm/core @mikro-orm/nestjs @mikro-orm/mariadb     # for mysql/mariadb
$ yarn add @mikro-orm/core @mikro-orm/nestjs @mikro-orm/postgresql  # for postgresql
$ yarn add @mikro-orm/core @mikro-orm/nestjs @mikro-orm/sqlite      # for sqlite

LANGUAGE: bash
CODE:
$ npm i -s @mikro-orm/core @mikro-orm/nestjs @mikro-orm/mongodb     # for mongo
$ npm i -s @mikro-orm/core @mikro-orm/nestjs @mikro-orm/mysql       # for mysql/mariadb
$ npm i -s @mikro-orm/core @mikro-orm/nestjs @mikro-orm/mariadb     # for mysql/mariadb
$ npm i -s @mikro-orm/core @mikro-orm/nestjs @mikro-orm/postgresql  # for postgresql
$ npm i -s @mikro-orm/core @mikro-orm/nestjs @mikro-orm/sqlite      # for sqlite

----------------------------------------

TITLE: User Entity Definition
DESCRIPTION: First entity class definition with basic user properties using MikroORM decorators.

LANGUAGE: typescript
CODE:
import { Entity, PrimaryKey, Property } from '@mikro-orm/core';

@Entity()
export class User {
   @PrimaryKey()
   id!: number;

   @Property()
   fullName!: string;

   @Property()
   email!: string;

   @Property()
   password!: string;

   @Property({ type: 'text' })
   bio = '';
}

----------------------------------------

TITLE: Entity Definition Example
DESCRIPTION: Sample entity class definition using decorators to define relationships and properties.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @PrimaryKey()
  id: bigint;

  @Property()
  title: string;

  @ManyToOne(() => Author)
  author: Author;

  @ManyToMany(() => BookTag)
  tags = new Collection<BookTag>(this);

  constructor(title: string, author: Author) {
    this.title = title;
    this.author = author;
  }

}

----------------------------------------

TITLE: Property Definitions with @Property Decorator
DESCRIPTION: Examples of defining entity properties using @Property decorator with various configurations like field names, types and auto-update.

LANGUAGE: typescript
CODE:
@Property({ length: 50, fieldName: 'first_name' })
name!: string;

@Property({ type: 'date', fieldName: 'born_date' })
born?: string;

@Property({ columnType: 'tinyint' })
age?: number;

@Property({ onUpdate: () => new Date() })
updatedAt = new Date();

@Property()
registered = false;

----------------------------------------

TITLE: Installing MikroORM and NestJS Module
DESCRIPTION: Commands for installing MikroORM core, NestJS module, and database-specific drivers using yarn or npm.

LANGUAGE: bash
CODE:
$ yarn add @mikro-orm/core @mikro-orm/nestjs @mikro-orm/mongodb     # for mongo
$ yarn add @mikro-orm/core @mikro-orm/nestjs @mikro-orm/mysql       # for mysql/mariadb
$ yarn add @mikro-orm/core @mikro-orm/nestjs @mikro-orm/mariadb     # for mysql/mariadb
$ yarn add @mikro-orm/core @mikro-orm/nestjs @mikro-orm/postgresql  # for postgresql
$ yarn add @mikro-orm/core @mikro-orm/nestjs @mikro-orm/sqlite      # for sqlite

LANGUAGE: bash
CODE:
$ npm i -s @mikro-orm/core @mikro-orm/nestjs @mikro-orm/mongodb     # for mongo
$ npm i -s @mikro-orm/core @mikro-orm/nestjs @mikro-orm/mysql       # for mysql/mariadb
$ npm i -s @mikro-orm/core @mikro-orm/nestjs @mikro-orm/mariadb     # for mysql/mariadb
$ npm i -s @mikro-orm/core @mikro-orm/nestjs @mikro-orm/postgresql  # for postgresql
$ npm i -s @mikro-orm/core @mikro-orm/nestjs @mikro-orm/sqlite      # for sqlite

----------------------------------------

TITLE: Configuring Folder-based Entity Discovery
DESCRIPTION: Example of configuring MikroORM to discover entities using folder paths and glob patterns.

LANGUAGE: typescript
CODE:
const orm = await MikroORM.init({
  entities: ['./dist/app/**/*.entity.js'],
  entitiesTs: ['./src/app/**/*.entity.ts'],
  // ...
});

----------------------------------------

TITLE: Creating a Custom Repository in TypeScript for MikroORM
DESCRIPTION: Shows how to create a custom repository by extending EntityRepository<T> class. This allows adding custom methods or altering existing ones for specific entity types.

LANGUAGE: typescript
CODE:
import { EntityRepository } from '@mikro-orm/mysql'; // or any other driver package

export class CustomAuthorRepository extends EntityRepository<Author> {

  // custom methods...
  public findAndUpdate(...) {
    // ...
  }

}

----------------------------------------

TITLE: Defining OneToOne Relationships in MikroORM with TypeScript
DESCRIPTION: This snippet illustrates how to define OneToOne relationships in MikroORM using TypeScript decorators. It shows examples for both owning and inverse sides of the relationship, including self-referencing relationships.

LANGUAGE: typescript
CODE:
@Entity()
export class User {

  // when none of `owner/inverseBy/mappedBy` is provided, it will be considered owning side
  @OneToOne()
  bestFriend1!: User;

  // side with `inversedBy` is the owning one, to define inverse side use `mappedBy`
  @OneToOne({ inversedBy: 'bestFriend1' })
  bestFriend2!: User;

  // when defining it like this, you need to specifically mark the owning side with `owner: true`
  @OneToOne(() => User, user => user.bestFriend2, { owner: true })
  bestFriend3!: User;

}

@Entity()
export class User {

  @OneToOne({ mappedBy: 'bestFriend1', orphanRemoval: true })
  bestFriend1!: User;

  @OneToOne(() => User, user => user.bestFriend2, { orphanRemoval: true })
  bestFriend2!: User;

}

----------------------------------------

TITLE: Explicit Transaction Handling with Begin/Commit/Rollback in MikroORM
DESCRIPTION: Demonstrates explicit transaction handling using begin(), commit(), and rollback() methods. This approach offers full control over the transaction lifecycle and error handling.

LANGUAGE: typescript
CODE:
const em = orm.em.fork();
await em.begin();

try {
  //... do some work
  const user = new User(...);
  user.name = 'George';
  em.persist(user);
  await em.commit(); // will flush before making the actual commit query
} catch (e) {
  await em.rollback();
  throw e;
}

----------------------------------------

TITLE: Basic Repository Usage in MikroORM TypeScript
DESCRIPTION: Demonstrates how to use the basic EntityRepository to find and query entities. Shows how repository methods map to EntityManager operations with simplified entity type handling.

LANGUAGE: typescript
CODE:
const booksRepository = em.getRepository(Book);

// same as `em.find(Book, { author: '...' }, { ... })`
const books = await booksRepository.find({ author: '...' }, {
  populate: ['author'],
  limit: 1,
  offset: 2,
  orderBy: { title: QueryOrder.DESC },
});

console.log(books); // Book[]

----------------------------------------

TITLE: Configuring OneToOne Relationships - Owning Side
DESCRIPTION: Demonstrates defining the owning side of OneToOne relationships, including self-referencing relationships and different configuration options.

LANGUAGE: typescript
CODE:
@Entity()
export class User {

  @OneToOne()
  bestFriend1!: User;

  @OneToOne({ inversedBy: 'bestFriend1' })
  bestFriend2!: User;

  @OneToOne(() => User, user => user.bestFriend2, { owner: true })
  bestFriend3!: User;

}

----------------------------------------

TITLE: Cursor-based Pagination in MikroORM
DESCRIPTION: Explains how to implement cursor-based pagination using the EntityManager's findByCursor method. It shows how to use the cursor for forward and backward pagination.

LANGUAGE: typescript
CODE:
const currentCursor = await em.findByCursor(User, {}, {
  first: 10,
  after: previousCursor, // cursor instance
  orderBy: { id: 'desc' },
});

// to fetch next page
const nextCursor = await em.findByCursor(User, {}, {
  first: 10,
  after: currentCursor.endCursor, // opaque string
  orderBy: { id: 'desc' },
});

// to fetch next page
const nextCursor2 = await em.findByCursor(User, {}, {
  first: 10,
  after: { id: lastSeenId }, // entity-like POJO
  orderBy: { id: 'desc' },
});

----------------------------------------

TITLE: Implementing a Comprehensive EventSubscriber in TypeScript
DESCRIPTION: Example of an EventSubscriber class that subscribes to all possible events for all entities, including entity lifecycle, flush, and transaction events.

LANGUAGE: typescript
CODE:
import { EventArgs, TransactionEventArgs, EventSubscriber } from '@mikro-orm/core';

export class EverythingSubscriber implements EventSubscriber {

  // entity life cycle events
  onInit<T>(args: EventArgs<T>): void { ... }
  async onLoad<T>(args: EventArgs<T>): Promise<void> { ... }
  async beforeCreate<T>(args: EventArgs<T>): Promise<void> { ... }
  async afterCreate<T>(args: EventArgs<T>): Promise<void> { ... }
  async beforeUpdate<T>(args: EventArgs<T>): Promise<void> { ... }
  async afterUpdate<T>(args: EventArgs<T>): Promise<void> { ... }
  async beforeUpsert<T>(args: EventArgs<T>): Promise<void> { ... }
  async afterUpsert<T>(args: EventArgs<T>): Promise<void> { ... }
  async beforeDelete<T>(args: EventArgs<T>): Promise<void> { ... }
  async afterDelete<T>(args: EventArgs<T>): Promise<void> { ... }

  // flush events
  async beforeFlush<T>(args: FlushEventArgs): Promise<void> { ... }
  async onFlush<T>(args: FlushEventArgs): Promise<void> { ... }
  async afterFlush<T>(args: FlushEventArgs): Promise<void> { ... }

  // transaction events
  async beforeTransactionStart(args: TransactionEventArgs): Promise<void> { ... }
  async afterTransactionStart(args: TransactionEventArgs): Promise<void> { ... }
  async beforeTransactionCommit(args: TransactionEventArgs): Promise<void> { ... }
  async afterTransactionCommit(args: TransactionEventArgs): Promise<void> { ... }
  async beforeTransactionRollback(args: TransactionEventArgs): Promise<void> { ... }
  async afterTransactionRollback(args: TransactionEventArgs): Promise<void> { ... }

}

----------------------------------------

TITLE: Demonstrating Identity Map in MikroORM with TypeScript
DESCRIPTION: This snippet shows how MikroORM's Identity Map optimizes database queries by returning the same instance for repeated entity lookups.

LANGUAGE: typescript
CODE:
const jon1 = await em.findOne(Author, 1);
const jon2 = await em.findOne(Author, 1);

// identity map in action
console.log(jon1 === jon2); // true

----------------------------------------

TITLE: Creating an Extended EntityRepository in TypeScript with MikroORM
DESCRIPTION: Demonstrates how to create an extended EntityRepository that includes methods removed in v6. This custom base repository can be used globally to maintain backward compatibility or add custom functionality.

LANGUAGE: typescript
CODE:
import { EntityManager, EntityRepository, AnyEntity } from '@mikro-orm/mysql';

export class ExtendedEntityRepository<T extends object> extends EntityRepository<T> {

  persist(entity: AnyEntity | AnyEntity[]): EntityManager {
    return this.em.persist(entity);
  }

  async persistAndFlush(entity: AnyEntity | AnyEntity[]): Promise<void> {
    await this.em.persistAndFlush(entity);
  }

  remove(entity: AnyEntity): EntityManager {
    return this.em.remove(entity);
  }

  async removeAndFlush(entity: AnyEntity): Promise<void> {
    await this.em.removeAndFlush(entity);
  }

  async flush(): Promise<void> {
    return this.em.flush();
  }

}

----------------------------------------

TITLE: Persisting and Flushing Entities in MikroORM
DESCRIPTION: Demonstrates how to persist and flush entities using the EntityManager. It shows that entities fetched from the database are automatically managed and can be updated without explicitly calling persist.

LANGUAGE: typescript
CODE:
const book = await em.findOne(Book, 1);
book.title = 'How to persist things...';

// no need to persist `book` as its already managed by the EM
await em.flush();

----------------------------------------

TITLE: Manual Transaction Control in MikroORM
DESCRIPTION: Demonstrates explicit transaction control using begin/commit/rollback methods with proper error handling.

LANGUAGE: typescript
CODE:
const em = orm.em.fork();
await em.begin();

try {
  //... do some work
  const user = new User(...);
  user.name = 'George';
  em.persist(user);
  await em.commit();
} catch (e) {
  await em.rollback();
  throw e;
}

----------------------------------------

TITLE: Injecting EntityManager in NestJS Service
DESCRIPTION: Example of injecting MikroORM and EntityManager into a NestJS service for database operations.

LANGUAGE: typescript
CODE:
import { MikroORM } from '@mikro-orm/core';
import { EntityManager } from '@mikro-orm/mysql'; // Import EntityManager from your driver package or `@mikro-orm/knex`

@Injectable()
export class MyService {

  constructor(private readonly orm: MikroORM,
              private readonly em: EntityManager) {
  }

}

----------------------------------------

TITLE: Querying Entities with EntityRepository in TypeScript
DESCRIPTION: This snippet demonstrates how to use EntityRepository to query entities. It shows how to get a repository instance and use it to find books with specific criteria, including population, pagination, and sorting.

LANGUAGE: typescript
CODE:
const booksRepository = em.getRepository(Book);

const books = await booksRepository.find({ author: '...' }, {
  populate: ['author'],
  limit: 1,
  offset: 2,
  orderBy: { title: QueryOrder.DESC },
});

console.log(books); // Book[]

----------------------------------------

TITLE: Nested Population in MikroORM TypeScript
DESCRIPTION: Demonstrates how to populate nested relations in MikroORM using TypeScript. Shows populating multiple levels of relationships including books, publishers, tests, and authors.

LANGUAGE: typescript
CODE:
const tags = await em.find(BookTag, {}, {
  populate: ['books.publisher.tests', 'books.author'],
});
console.log(tags[0].books[0].publisher.tests[0].name); // prints name of nested test
console.log(tags[0].books[0].author.name); // prints name of nested author

----------------------------------------

TITLE: Basic Entity Configuration in MikroORM
DESCRIPTION: Shows how to configure entities by directly providing entity classes or through folder-based discovery with TypeScript support.

LANGUAGE: typescript
CODE:
MikroORM.init({
  entities: [Author, Book, Publisher, BookTag],
});

----------------------------------------

TITLE: Defining Basic Entity Schema in TypeScript
DESCRIPTION: Demonstrates how to define a basic Book entity schema with relationships to Author, Publisher, and BookTags using EntitySchema helper.

LANGUAGE: typescript
CODE:
export interface Book extends CustomBaseEntity {
  title: string;
  author: Author;
  publisher: Publisher;
  tags: Collection<BookTag>;
}

export const schema = new EntitySchema<Book, CustomBaseEntity>({
  name: 'Book',
  extends: CustomBaseEntitySchema,
  properties: {
    title: { type: 'string' },
    author: { kind: 'm:1', entity: 'Author', inversedBy: 'books' },
    publisher: { kind: 'm:1', entity: 'Publisher', inversedBy: 'books' },
    tags: { kind: 'm:n', entity: 'BookTag', inversedBy: 'books', fixedOrder: true },
  },
});

----------------------------------------

TITLE: Initializing MikroORM with ReflectMetadataProvider
DESCRIPTION: Demonstrates how to initialize MikroORM using ReflectMetadataProvider. This provider uses the reflect-metadata module to read type information from decorator metadata.

LANGUAGE: typescript
CODE:
await MikroORM.init({
  metadataProvider: ReflectMetadataProvider,
  // ...
});

----------------------------------------

TITLE: Installing MikroORM Dependencies
DESCRIPTION: Commands for installing MikroORM core and database-specific drivers using npm or yarn.

LANGUAGE: bash
CODE:
# for mongodb
npm install @mikro-orm/core @mikro-orm/mongodb

# for mysql (works with mariadb too)
npm install @mikro-orm/core @mikro-orm/mysql

# for mariadb (works with mysql too)
npm install @mikro-orm/core @mikro-orm/mariadb

# for postgresql (works with cockroachdb too)
npm install @mikro-orm/core @mikro-orm/postgresql

# for sqlite
npm install @mikro-orm/core @mikro-orm/sqlite

# for better-sqlite
npm install @mikro-orm/core @mikro-orm/better-sqlite

----------------------------------------

TITLE: Implementing Concurrency Checks in MikroORM
DESCRIPTION: Shows how to implement concurrency checks in MikroORM by marking specific properties to be included in the check. This provides more granular control over concurrency than version fields.

LANGUAGE: typescript
CODE:
@Entity()
export class ConcurrencyCheckUser {

  // all primary keys are by default part of the concurrency check
  @PrimaryKey({ length: 100 })
  firstName: string;

  // all primary keys are by default part of the concurrency check
  @PrimaryKey({ length: 100 })
  lastName: string;

  @Property({ concurrencyCheck: true })
  age: number;

  @Property({ nullable: true })
  other?: string;

}

----------------------------------------

TITLE: Defining SQL Virtual Entity with Query Builder
DESCRIPTION: Implementation of a virtual entity using a callback function with QueryBuilder. Shows how to create virtual entities programmatically using MikroORM's QueryBuilder API.

LANGUAGE: typescript
CODE:
@Entity({
  expression: (em: EntityManager) => {
    return em.createQueryBuilder(Book, 'b')
      .select(['b.title', 'a.name as author_name', 'group_concat(t.name) as tags'])
      .join('b.author', 'a')
      .join('b.tags', 't')
      .groupBy('b.id');
  },
})
export class BookWithAuthor {

  @Property()
  title!: string;

  @Property()
  authorName!: string;

  @Property()
  tags!: string[];

}

----------------------------------------

TITLE: Defining ManyToMany Relationships in MikroORM with TypeScript
DESCRIPTION: This snippet demonstrates how to define ManyToMany relationships in MikroORM using TypeScript decorators. It includes examples for both owning and inverse sides of the relationship, as well as unidirectional relationships.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  // when none of `owner/inverseBy/mappedBy` is provided, it will be considered owning side
  @ManyToMany()
  tags1 = new Collection<BookTag>(this);

  @ManyToMany(() => BookTag, 'books', { owner: true })
  tags2 = new Collection<BookTag>(this);

  @ManyToMany(() => BookTag, 'books', { owner: true })
  tags3 = new Collection<BookTag>(this);

  @ManyToMany(() => BookTag, 'books', { owner: true })
  tags4 = new Collection<BookTag>(this);

  // to define uni-directional many to many, simply provide only
  @ManyToMany(() => Author)
  friends: Collection<Author> = new Collection<Author>(this);

}

@Entity()
export class BookTag {

  // inverse side has to point to the owning side via `mappedBy` attribute/parameter
  @ManyToMany(() => Book, book => book.tags)
  books = new Collection<Book>(this);

}

----------------------------------------

TITLE: Defining Custom Base Entity
DESCRIPTION: Example of defining a custom base entity with common properties for all entities.

LANGUAGE: TypeScript
CODE:
import { v4 } from 'uuid';

export abstract class CustomBaseEntity {

  @PrimaryKey()
  uuid = v4();

  @Property()
  createdAt = new Date();

  @Property({ onUpdate: () => new Date() })
  updatedAt = new Date();

}

----------------------------------------

TITLE: Using Rel Type for ESM Projects in MikroORM with TypeScript
DESCRIPTION: This snippet shows how to use the Rel mapped type to avoid circular dependency issues in ESM projects when using MikroORM with TypeScript and reflect-metadata.

LANGUAGE: typescript
CODE:
import { Rel } from '@mikro-orm/core';

@Entity()
export class Book {

  @ManyToOne(() => Author)
  author!: Rel<Author>;

}

----------------------------------------

TITLE: Fetching Entities with EntityManager in MikroORM
DESCRIPTION: Shows various ways to fetch entities using the EntityManager in MikroORM, including find, findOne, and population of relations.

LANGUAGE: typescript
CODE:
const author = await em.findOne(Author, 123);
const books = await em.find(Book, {});

for (const author of authors) {
  console.log(author.name); // Jon Snow

  for (const book of author.books) {
    console.log(book.title); // initialized
    console.log(book.author.isInitialized()); // true
    console.log(book.author.id);
    console.log(book.author.name); // Jon Snow
    console.log(book.publisher); // just reference
    console.log(book.publisher.isInitialized()); // false
    console.log(book.publisher.id);
    console.log(book.publisher.name); // undefined
  }
}

LANGUAGE: typescript
CODE:
const books = await em.findAll(Book, {
  where: { publisher: { $ne: null } }, // optional
});

LANGUAGE: typescript
CODE:
const books = await em.findAll(Book, {
  where: { publisher: { $ne: null } },
  // highlight-next-line
  populate: ['author.friends'],
});

----------------------------------------

TITLE: User Entity Definition
DESCRIPTION: First entity class definition with basic user properties using decorators

LANGUAGE: typescript
CODE:
import { Entity, PrimaryKey, Property } from '@mikro-orm/core';

@Entity()
export class User {

   @PrimaryKey()
   id!: number;

   @Property()
   fullName!: string;

   @Property()
   email!: string;

   @Property()
   password!: string;

   @Property({ type: 'text' })
   bio = '';

}

----------------------------------------

TITLE: Implementing ManyToMany Relationships - Inverse Side
DESCRIPTION: Demonstrates defining the inverse side of ManyToMany relationships using mappedBy and Collections.

LANGUAGE: typescript
CODE:
@Entity()
export class BookTag {

  @ManyToMany(() => Book, book => book.tags)
  books = new Collection<Book>(this);

}

----------------------------------------

TITLE: Persisting and Flushing Entities in MikroORM
DESCRIPTION: Demonstrates how to persist and flush entities using the EntityManager in MikroORM. It shows the difference between persist() and flush() methods.

LANGUAGE: typescript
CODE:
const book = await em.findOne(Book, 1);
book.title = 'How to persist things...';

// no need to persist `book` as its already managed by the EM
await em.flush();

----------------------------------------

TITLE: Basic Entity Persistence in MikroORM
DESCRIPTION: Demonstrates how to persist and flush entity changes using EntityManager. Shows that entities fetched from database are automatically managed.

LANGUAGE: typescript
CODE:
const book = await em.findOne(Book, 1);
book.title = 'How to persist things...';

// no need to persist `book` as its already managed by the EM
await em.flush();

----------------------------------------

TITLE: Defining MikroORM Configuration
DESCRIPTION: Example of defining MikroORM configuration using the defineConfig helper for better type inference.

LANGUAGE: typescript
CODE:
import { defineConfig } from '@mikro-orm/sqlite';

export default defineConfig({
  entities: [Author, Book, BookTag],
  dbName: 'my-db-name',
  // this is inferred as you import `defineConfig` from sqlite package
  // driver: SqliteDriver,
});

----------------------------------------

TITLE: Using Rel Type for ESM Projects in MikroORM with TypeScript
DESCRIPTION: This snippet shows how to use the Rel mapped type to avoid circular dependency issues in ESM projects when using MikroORM with TypeScript and reflect-metadata.

LANGUAGE: typescript
CODE:
import { Rel } from '@mikro-orm/core';

@Entity()
export class Book {

  @ManyToOne(() => Author)
  author!: Rel<Author>;

}

----------------------------------------

TITLE: Defining OneToMany Relationships in MikroORM (TypeScript)
DESCRIPTION: This snippet shows different ways to define a OneToMany relationship in MikroORM using TypeScript decorators. It demonstrates various syntax options for specifying the related entity type and mapping.

LANGUAGE: typescript
CODE:
@Entity()
export class Author {

  @OneToMany(() => Book, book => book.author)
  books1 = new Collection<Book>(this);

  @OneToMany('Book', 'author')
  books2 = new Collection<Book>(this);

  @OneToMany({ mappedBy: book => book.author }) // referenced entity type can be sniffer too
  books3 = new Collection<Book>(this);

  @OneToMany({ entity: () => Book, mappedBy: 'author', orphanRemoval: true })
  books4 = new Collection<Book>(this);

}

----------------------------------------

TITLE: Explicit Transaction Management using Callback
DESCRIPTION: Shows how to explicitly manage transactions using the transactional API with a callback function. This provides more control over transaction boundaries.

LANGUAGE: typescript
CODE:
await orm.em.transactional(em => {
  //... do some work
  const user = new User(...);
  user.name = 'George';
  em.persist(user);
});

----------------------------------------

TITLE: Reference Loading and Type Safety
DESCRIPTION: Demonstrates safe ways to load and access referenced entities using the Reference wrapper.

LANGUAGE: typescript
CODE:
const book1 = await em.findOne(Book, 1);
book.author instanceof Reference; // true
book1.author; // Ref<Author> (instance of `Reference` class)
book1.author.name; // type error, there is no `name` property
book1.author.unwrap().name; // unsafe sync access, undefined as author is not loaded
book1.author.isInitialized(); // false

const book2 = await em.findOne(Book, 1, { populate: ['author'] });
book2.author; // LoadedReference<Author> (instance of `Reference` class)
book2.author.$.name; // type-safe sync access

----------------------------------------

TITLE: Declarative Partial Loading of Collections in MikroORM
DESCRIPTION: This snippet shows how to define collections that represent only a subset of the target entities in MikroORM. It demonstrates this for both OneToMany and ManyToMany relationships.

LANGUAGE: typescript
CODE:
@Entity()
class Author {

  @OneToMany(() => Book, b => b.author)
  books = new Collection<Book>(this);

  @OneToMany(() => Book, b => b.author, { where: { favorite: true } })
  favoriteBooks = new Collection<Book>(this);

}

@Entity()
class Book {

  @ManyToMany(() => BookTag)
  tags = new Collection<BookTag>(this);

  @ManyToMany({
    entity: () => BookTag, 
    pivotTable: 'book_tags',
    where: { popular: true },
  })
  popularTags = new Collection<BookTag>(this);

}

----------------------------------------

TITLE: Configuring Custom Metadata Provider
DESCRIPTION: Shows how to configure MikroORM to use a custom metadata provider like TsMorphMetadataProvider.

LANGUAGE: typescript
CODE:
import { MikroORM } from '@mikro-orm/core';
import { TsMorphMetadataProvider } from '@mikro-orm/reflection';

MikroORM.init({
  metadataProvider: TsMorphMetadataProvider,
});

----------------------------------------

TITLE: Defining ManyToMany Relationships in MikroORM (TypeScript)
DESCRIPTION: This snippet illustrates how to define both owning and inverse sides of a ManyToMany relationship in MikroORM using TypeScript decorators. It includes examples of bidirectional and unidirectional relationships.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  // when none of `owner/inverseBy/mappedBy` is provided, it will be considered owning side
  @ManyToMany()
  tags1 = new Collection<BookTag>(this);

  @ManyToMany(() => BookTag, 'books', { owner: true })
  tags2 = new Collection<BookTag>(this);

  @ManyToMany(() => BookTag, 'books', { owner: true })
  tags3 = new Collection<BookTag>(this);

  @ManyToMany(() => BookTag, 'books', { owner: true })
  tags4 = new Collection<BookTag>(this);

  // to define uni-directional many to many, simply provide only
  @ManyToMany(() => Author)
  friends: Collection<Author> = new Collection<Author>(this);

}

@Entity()
export class BookTag {

  // inverse side has to point to the owning side via `mappedBy` attribute/parameter
  @ManyToMany(() => Book, book => book.tags)
  books = new Collection<Book>(this);

}

----------------------------------------

TITLE: Implementing OneToMany Relationships in TypeScript with MikroORM
DESCRIPTION: Shows various approaches to define OneToMany relationships using Collections. Includes examples of mappedBy parameter and orphanRemoval option.

LANGUAGE: typescript
CODE:
@Entity()
export class Author {

  @OneToMany(() => Book, book => book.author)
  books1 = new Collection<Book>(this);

  @OneToMany('Book', 'author')
  books2 = new Collection<Book>(this);

  @OneToMany({ mappedBy: book => book.author })
  books3 = new Collection<Book>(this);

  @OneToMany({ entity: () => Book, mappedBy: 'author', orphanRemoval: true })
  books4 = new Collection<Book>(this);

}

----------------------------------------

TITLE: Custom Repository Implementation in MikroORM
DESCRIPTION: Shows how to create a custom repository by extending EntityRepository class. Includes driver-specific import for correct typing.

LANGUAGE: typescript
CODE:
import { EntityRepository } from '@mikro-orm/mysql'; // or any other driver package

export class CustomAuthorRepository extends EntityRepository<Author> {

  // custom methods...
  public findAndUpdate(...) {
    // ...
  }

}

----------------------------------------

TITLE: Defining Entity-Level Filters in TypeScript with MikroORM
DESCRIPTION: Demonstrates how to define filters at the entity level using decorators. It shows various filter types including static conditions, dynamic conditions, and default filters.

LANGUAGE: typescript
CODE:
@Entity()
@Filter({ name: 'expensive', cond: { price: { $gt: 1000 } } })
@Filter({ name: 'long', cond: { 'length(text)': { $gt: 10000 } } })
@Filter({ name: 'hasAuthor', cond: { author: { $ne: null } }, default: true })
@Filter({ name: 'writtenBy', cond: args => ({ author: { name: args.name } }) })
export class Book {
  ...
}

const books1 = await orm.em.find(Book, {}, {
  filters: ['long', 'expensive'],
});
const books2 = await orm.em.find(Book, {}, {
  filters: { hasAuthor: false, long: true, writtenBy: { name: 'God' } },
});

----------------------------------------

TITLE: Basic Repository Usage with MikroORM
DESCRIPTION: Demonstrates basic usage of EntityRepository for querying entities with various options like populate, limit, offset, and ordering.

LANGUAGE: typescript
CODE:
const booksRepository = em.getRepository(Book);

// same as `em.find(Book, { author: '...' }, { ... })`
const books = await booksRepository.find({ author: '...' }, {
  populate: ['author'],
  limit: 1,
  offset: 2,
  orderBy: { title: QueryOrder.DESC },
});

console.log(books); // Book[]

----------------------------------------

TITLE: Defining OneToOne Relationships in MikroORM with TypeScript
DESCRIPTION: This snippet demonstrates how to define OneToOne relationships in MikroORM, including both owning and inverse sides. It shows self-referencing relationships and the use of the orphanRemoval option.

LANGUAGE: typescript
CODE:
@Entity()
export class User {

  // when none of `owner/inverseBy/mappedBy` is provided, it will be considered owning side
  @OneToOne()
  bestFriend1!: User;

  // side with `inversedBy` is the owning one, to define inverse side use `mappedBy`
  @OneToOne({ inversedBy: 'bestFriend1' })
  bestFriend2!: User;

  // when defining it like this, you need to specifically mark the owning side with `owner: true`
  @OneToOne(() => User, user => user.bestFriend2, { owner: true })
  bestFriend3!: User;

}

@Entity()
export class User {

  @OneToOne({ mappedBy: 'bestFriend1', orphanRemoval: true })
  bestFriend1!: User;

  @OneToOne(() => User, user => user.bestFriend2, { orphanRemoval: true })
  bestFriend2!: User;

}

----------------------------------------

TITLE: Defining a Book Entity
DESCRIPTION: TypeScript code showing how to define a Book entity using decorators in MikroORM.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @PrimaryKey()
  id: bigint;

  @Property()
  title: string;

  @ManyToOne(() => Author)
  author: Author;

  @ManyToMany(() => BookTag)
  tags = new Collection<BookTag>(this);

  constructor(title: string, author: Author) {
    this.title = title;
    this.author = author;
  }

}

----------------------------------------

TITLE: Complex Query with Multiple Conditions in MikroORM TypeScript
DESCRIPTION: Demonstrates how to construct complex queries using multiple comparison operators with $and condition in MikroORM.

LANGUAGE: typescript
CODE:
const res = await orm.em.find(Author, { $and: [
  { id: { $in: [1, 2, 7] }, },
  { id: { $nin: [3, 4] }, },
  { id: { $gt: 5 }, },
  { id: { $lt: 10 }, },
  { id: { $gte: 7 }, },
  { id: { $lte: 8 }, },
  { id: { $ne: 9 }, },
] });

----------------------------------------

TITLE: Implicit Transactions in MikroORM (TypeScript)
DESCRIPTION: This example demonstrates how MikroORM handles implicit transactions when persisting and flushing changes to multiple entities.

LANGUAGE: typescript
CODE:
const user = await em.findOne(User, 1);
user.email = 'foo@bar.com';
const car = new Car();
user.cars.add(car);

// thanks to bi-directional cascading we only need to persist user entity
// flushing will create a transaction, insert new car and update user with new email
await em.persist(user).flush();

----------------------------------------

TITLE: Defining Book Entity with MikroORM's BaseEntity
DESCRIPTION: Example of defining a Book entity extending MikroORM's BaseEntity class, which provides additional methods like init and isInitialized.

LANGUAGE: typescript
CODE:
import { BaseEntity } from '@mikro-orm/core';

@Entity()
export class Book extends BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property()
  title!: string;

  @ManyToOne()
  author!: Author;

}

const book = new Book();
console.log(book.isInitialized()); // true

----------------------------------------

TITLE: Defining a Basic Entity in TypeScript
DESCRIPTION: Example of defining a basic Book entity with relationships using TypeScript decorators.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @PrimaryKey()
  id: bigint;

  @Property()
  title: string;

  @ManyToOne(() => Author)
  author: Author;

  @ManyToMany(() => BookTag)
  tags = new Collection<BookTag>(this);

  constructor(title: string, author: Author) {
    this.title = title;
    this.author = author;
  }

}

----------------------------------------

TITLE: Defining Article Entity with Relationships
DESCRIPTION: Creates Article entity with ManyToOne relationship to User and various property configurations

LANGUAGE: typescript
CODE:
import { Entity, ManyToOne, Property, t } from '@mikro-orm/core';
import { BaseEntity } from '../common/base.entity.js';
import { User } from '../user/user.entity.js';

@Entity()
export class Article extends BaseEntity {

  @Property({ unique: true })
  slug!: string;

  @Property({ index: true })
  title!: string;

  @Property({ length: 1000 })
  description!: string;

  @Property({ type: t.text, lazy: true })
  text!: string;

  @ManyToOne()
  author!: User;

}

----------------------------------------

TITLE: Configuring Driver Options in MikroORM
DESCRIPTION: Shows how to configure database driver options and timezone settings for MySQL connections.

LANGUAGE: typescript
CODE:
import { MySqlDriver } from '@mikro-orm/mysql';

MikroORM.init({
  driver: MySqlDriver,
  driverOptions: { connection: { timezone: '+02:00' } },
});

----------------------------------------

TITLE: Defining OneToMany Relationships in MikroORM with TypeScript
DESCRIPTION: This snippet shows different ways to define a OneToMany relationship in MikroORM using TypeScript decorators. It demonstrates various syntax options for specifying the related entity type and mapping.

LANGUAGE: typescript
CODE:
@Entity()
export class Author {

  @OneToMany(() => Book, book => book.author)
  books1 = new Collection<Book>(this);

  @OneToMany('Book', 'author')
  books2 = new Collection<Book>(this);

  @OneToMany({ mappedBy: book => book.author }) // referenced entity type can be sniffer too
  books3 = new Collection<Book>(this);

  @OneToMany({ entity: () => Book, mappedBy: 'author', orphanRemoval: true })
  books4 = new Collection<Book>(this);

}

----------------------------------------

TITLE: Fetching Entities with EntityManager in MikroORM
DESCRIPTION: Demonstrates various ways to fetch entities from the database using EntityManager in MikroORM.

LANGUAGE: typescript
CODE:
const author = await em.findOne(Author, 123);
const books = await em.find(Book, {});

for (const author of authors) {
  console.log(author.name); // Jon Snow

  for (const book of author.books) {
    console.log(book.title); // initialized
    console.log(book.author.isInitialized()); // true
    console.log(book.author.id);
    console.log(book.author.name); // Jon Snow
    console.log(book.publisher); // just reference
    console.log(book.publisher.isInitialized()); // false
    console.log(book.publisher.id);
    console.log(book.publisher.name); // undefined
  }
}

----------------------------------------

TITLE: Atomic Updates with raw() Helper in MikroORM
DESCRIPTION: Demonstrates how to perform atomic updates using the raw() helper function in MikroORM.

LANGUAGE: typescript
CODE:
const ref = em.getReference(Author, 123);
ref.age = raw(`age * 2`);

await em.flush();
console.log(ref.age); // real value is available after flush

----------------------------------------

TITLE: Using CreateRequestContext Decorator in MikroORM with TypeScript
DESCRIPTION: This snippet demonstrates how to use the @CreateRequestContext() decorator to create a new request context for methods outside of regular HTTP request handlers.

LANGUAGE: typescript
CODE:
export class MyService {

  constructor(private readonly orm: MikroORM) { }

  @CreateRequestContext()
  async doSomething() {
    // this will be executed in a separate context
  }

}

----------------------------------------

TITLE: Nested Populate Query in MikroORM (TypeScript)
DESCRIPTION: Demonstrates how to use nested populate while querying BookTags, including relations to Books, Publishers, Tests, and Authors. The snippet shows the TypeScript code and explains the sequence of database operations that occur in the background.

LANGUAGE: typescript
CODE:
const tags = await em.find(BookTag, {}, {
  populate: ['books.publisher.tests', 'books.author'],
});
console.log(tags[0].books[0].publisher.tests[0].name); // prints name of nested test
console.log(tags[0].books[0].author.name); // prints name of nested author

----------------------------------------

TITLE: Implementing GraphQL Resolver with MikroORM in NestJS
DESCRIPTION: Example of implementing a GraphQL resolver using MikroORM's dataloader support in NestJS.

LANGUAGE: typescript
CODE:
@Resolver(() => Book)
class BookResolver {

  @ResolveField(() => Author)
  async author(@Parent() book: Book) {
    return book.author.load({ dataloader: true }); // can be also enabled globally
  }

}

----------------------------------------

TITLE: Defining Enums
DESCRIPTION: Examples of defining enum properties in entities using different approaches.

LANGUAGE: typescript
CODE:
// reflect-metadata and ts-morph
@Enum(() => UserRole)
role!: UserRole;

@Enum(() => UserStatus)
status!: UserStatus;

@Enum(() => OutsideEnum)
outside!: OutsideEnum;

@Enum({ items: () => OutsideNullableEnum, nullable: true })
outsideNullable?: OutsideNullableEnum;

// EntitySchema
properties: {
  role: { enum: true, items: () => UserRole },
  status: { enum: true, items: () => UserStatus },
  outside: { enum: true, items: () => OutsideEnum },
  outsideNullable: { enum: true, items: () => OutsideNullableEnum, nullable: true },
},

----------------------------------------

TITLE: MikroORM Configuration File
DESCRIPTION: Example configuration file using defineConfig helper with TypeScript support.

LANGUAGE: typescript
CODE:
import { defineConfig } from '@mikro-orm/sqlite';

export default defineConfig({
  entities: [Author, Book, BookTag],
  dbName: 'my-db-name',
});

----------------------------------------

TITLE: Defining a MongoDB Entity in TypeScript
DESCRIPTION: This snippet shows how to define an entity for MongoDB, including the use of ObjectId and SerializedPrimaryKey.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @PrimaryKey()
  _id!: ObjectId;

  @SerializedPrimaryKey()
  id!: string;

  @Property()
  title!: string;

  @ManyToOne(() => Author)
  author!: Author;

}

----------------------------------------

TITLE: Defining ManyToOne Relationships in TypeScript with MikroORM
DESCRIPTION: Demonstrates different ways to define ManyToOne relationships using decorators. Shows how to specify entity types through reflection, callbacks, strings, or option objects.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @ManyToOne() // plain decorator is enough, type will be sniffer via reflection!
  author1!: Author;

  @ManyToOne(() => Author) // you can specify type manually as a callback
  author2!: Author;

  @ManyToOne('Author') // or as a string
  author3!: Author;

  @ManyToOne({ entity: () => Author }) // or use options object
  author4!: Author;

}

----------------------------------------

TITLE: Configuring MikroORM in NestJS AppModule
DESCRIPTION: TypeScript code snippet demonstrating how to import and configure MikroOrmModule in the top-level NestJS module (AppModule). It shows the use of forRoot() method to set up MikroORM with various options.

LANGUAGE: typescript
CODE:
@Module({
  imports: [
    MikroOrmModule.forRoot({
      entitiesDirs: ['dist/entities'],
      entitiesDirsTs: ['src/entities'],
      dbName: 'my-db-name.sqlite3',
      type: 'sqlite',
      autoFlush: false, // read more here: https://mikro-orm.io/unit-of-work/
    }),
    // ... your feature modules
  ],
})
export class AppModule {}

----------------------------------------

TITLE: Defining CacheAdapter Interface for Custom Cache Adapters in MikroORM (TypeScript)
DESCRIPTION: This code defines the CacheAdapter interface that must be implemented by custom cache adapters in MikroORM. It includes methods for getting, setting, and clearing cache items, as well as an optional close method.

LANGUAGE: typescript
CODE:
export interface CacheAdapter {

  /**
   * Gets the items under `name` key from the cache.
   */
  get(name: string): Promise<any>;

  /**
   * Sets the item to the cache. `origin` is used for cache invalidation and should reflect the change in data.
   */
  set(name: string, data: any, origin: string, expiration?: number): Promise<void>;

  /**
   * Clears all items stored in the cache.
   */
  clear(): Promise<void>;

  /**
   * Called inside `MikroORM.close()` Allows graceful shutdowns (e.g. for redis).
   */
  close?(): Promise<void>;

}

----------------------------------------

TITLE: Creating a Custom Repository in TypeScript with MikroORM
DESCRIPTION: Shows how to create a custom repository by extending EntityRepository<T> class. This allows adding custom methods to the repository.

LANGUAGE: typescript
CODE:
import { EntityRepository } from '@mikro-orm/mysql'; // or any other driver package

export class CustomAuthorRepository extends EntityRepository<Author> {

  // custom methods...
  public findAndUpdate(...) {
    // ...
  }

}

----------------------------------------

TITLE: Running MikroORM Migration CLI Commands
DESCRIPTION: This bash snippet shows various CLI commands for creating, running, and managing migrations in MikroORM.

LANGUAGE: bash
CODE:
npx mikro-orm migration:create   # Create new migration with current schema diff
npx mikro-orm migration:up       # Migrate up to the latest version
npx mikro-orm migration:down     # Migrate one step down
npx mikro-orm migration:list     # List all executed migrations
npx mikro-orm migration:check    # Check if schema is up to date
npx mikro-orm migration:pending  # List all pending migrations
npx mikro-orm migration:fresh    # Drop the database and migrate up to the latest version

----------------------------------------

TITLE: Defining Book Entity with UUID Primary Key
DESCRIPTION: Example of defining a Book entity using UUID as the primary key.

LANGUAGE: typescript
CODE:
import { v4 } from 'uuid';

@Entity()
export class Book {

  @PrimaryKey()
  uuid = v4();

  @Property()
  title!: string;

  @ManyToOne(() => Author)
  author!: Author;

}

----------------------------------------

TITLE: Creating Custom SchemaHelper for MikroORM in TypeScript
DESCRIPTION: This code demonstrates how to implement a custom SchemaHelper class by extending the base SchemaHelper from MikroORM. It includes methods for schema-related operations and database-specific syntax.

LANGUAGE: typescript
CODE:
import { SchemaHelper } from '@mikro-orm/core';

export class MyCustomSchemaHelper extends SchemaHelper {

  // here you can override default settings
  getIdentifierQuoteCharacter(): string;
  getSchemaBeginning(): string;
  getSchemaEnd(): string;
  getSchemaTableEnd(): string;
  getAutoIncrementStatement(meta: EntityMetadata): string;
  getPrimaryKeySubtype(meta: EntityMetadata): string;
  getTypeDefinition(prop: EntityProperty, types?: Record<string, string>, lengths?: Record<string, number>): string;
  getUnsignedSuffix(prop: EntityProperty): string;
  supportsSchemaConstraints(): boolean;
  supportsSchemaMultiAlter(): boolean;
  supportsSequences(): boolean;
  quoteIdentifier(field: string): string;
  dropTable(meta: EntityMetadata): string;
  indexForeignKeys(): boolean;

}

----------------------------------------

TITLE: RequestContext Middleware Setup
DESCRIPTION: Implementation of RequestContext middleware to isolate entity manager instances per request using AsyncLocalStorage.

LANGUAGE: typescript
CODE:
app.use((req, res, next) => {
  // calls `orm.em.fork()` and attaches it to the async context
  RequestContext.create(orm.em, next);
});

app.get('/', async (req, res) => {
  // uses fork from the async context automatically
  const authors = await orm.em.find(Book, {});
  res.json(authors);
});

----------------------------------------

TITLE: Creating and Executing a Query with QueryBuilder in MikroORM
DESCRIPTION: Shows how to create a QueryBuilder instance, construct an update query, and execute it using MikroORM.

LANGUAGE: typescript
CODE:
const qb = em.createQueryBuilder(Author);
qb.update({ name: 'test 123', type: PublisherType.GLOBAL }).where({ id: 123, type: PublisherType.LOCAL });

console.log(qb.getQuery());
// update `publisher2` set `name` = ?, `type` = ? where `id` = ? and `type` = ?

console.log(qb.getParams());
// ['test 123', PublisherType.GLOBAL, 123, PublisherType.LOCAL]

// run the query
const res1 = await qb.execute();

----------------------------------------

TITLE: Creating Base Entity Class with Common Properties
DESCRIPTION: Implements an abstract base entity class with shared properties for ID and timestamps.

LANGUAGE: typescript
CODE:
import { PrimaryKey, Property } from '@mikro-orm/core';

export abstract class BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property()
  createdAt = new Date();

  @Property({ onUpdate: () => new Date() })
  updatedAt = new Date();

}

----------------------------------------

TITLE: Configuring MikroORM Migrations
DESCRIPTION: Basic configuration setup for enabling migrations in MikroORM. Requires installing @mikro-orm/migrations package and registering the Migrator extension.

LANGUAGE: typescript
CODE:
import { Migrator } from '@mikro-orm/migrations';

export default defineConfig({
  // ...
  extensions: [Migrator],
})

----------------------------------------

TITLE: Defining Entity Properties with @Property Decorator in TypeScript
DESCRIPTION: Examples of using the @Property decorator to define various entity properties with different options.

LANGUAGE: typescript
CODE:
@Property({ length: 50, fieldName: 'first_name' })
name!: string;

@Property({ type: 'date', fieldName: 'born_date' })
born?: string;

@Property({ columnType: 'tinyint' })
age?: number;

@Property({ onUpdate: () => new Date() })
updatedAt = new Date();

@Property()
registered = false;

----------------------------------------

TITLE: Using EntityRepository in TypeScript with MikroORM
DESCRIPTION: Demonstrates how to use the EntityRepository to find books with specific criteria. It shows the equivalence between using the repository and the EntityManager directly.

LANGUAGE: typescript
CODE:
const booksRepository = em.getRepository(Book);

// same as `em.find(Book, { author: '...' }, { ... })`
const books = await booksRepository.find({ author: '...' }, {
  populate: ['author'],
  limit: 1,
  offset: 2,
  orderBy: { title: QueryOrder.DESC },
});

console.log(books); // Book[]

----------------------------------------

TITLE: Defining ManyToOne Relationships in MikroORM with TypeScript
DESCRIPTION: This snippet demonstrates various ways to define a ManyToOne relationship in MikroORM using TypeScript decorators. It shows different syntax options for specifying the related entity type.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @ManyToOne() // plain decorator is enough, type will be sniffer via reflection!
  author1!: Author;

  @ManyToOne(() => Author) // you can specify type manually as a callback
  author2!: Author;

  @ManyToOne('Author') // or as a string
  author3!: Author;

  @ManyToOne({ entity: () => Author }) // or use options object
  author4!: Author;

}

----------------------------------------

TITLE: Using CreateRequestContext Decorator in NestJS
DESCRIPTION: Shows how to use the @CreateRequestContext decorator to ensure a clean request context in queue handlers or scheduled tasks.

LANGUAGE: typescript
CODE:
@Controller()
export class MyService {

  constructor(private readonly orm: MikroORM) { }

  @CreateRequestContext()
  async doSomething() {
    // this will be executed in a separate context
  }

}

----------------------------------------

TITLE: Configuring Metadata Provider in MikroORM
DESCRIPTION: Demonstrates how to configure and use the TsMorphMetadataProvider for analyzing entity source files.

LANGUAGE: typescript
CODE:
import { MikroORM } from '@mikro-orm/core';
import { TsMorphMetadataProvider } from '@mikro-orm/reflection';

MikroORM.init({
  metadataProvider: TsMorphMetadataProvider,
});

----------------------------------------

TITLE: Setting Transaction Isolation Level in MikroORM
DESCRIPTION: Demonstrates how to set the transaction isolation level when using the transactional method in MikroORM.

LANGUAGE: typescript
CODE:
await orm.em.transactional(async em => {
  // ...
}, { isolationLevel: IsolationLevel.READ_UNCOMMITTED });

----------------------------------------

TITLE: Automatic Flushing for Entities without Primary Keys in MikroORM (TypeScript)
DESCRIPTION: This snippet shows how MikroORM handles entities without primary keys, triggering an automatic flush when queried.

LANGUAGE: typescript
CODE:
// primary key value not provided
const jon = em.create(Author, {
  name: 'Jon',
  email: 'foo@bar.com',
});

// this will trigger auto flush and insert the entity, then query for it
const jon2 = await em.findOne(Author, 1);
console.log(jon === jon2); // true
await em.flush(); // this is a no-op

----------------------------------------

TITLE: Using Read Replica Connections in MikroORM Queries
DESCRIPTION: Shows various ways to work with read and write connections in MikroORM, including explicit connection selection, transaction handling, and query builder usage. Demonstrates how the preferReadReplicas configuration affects connection selection.

LANGUAGE: typescript
CODE:
const connection = em.getConnection(); // write connection
const readConnection = em.getConnection('read'); // random read connection

const qb1 = em.createQueryBuilder(Author);
const res1 = await qb1.select('*').execute(); // random read connection

const qb2 = em.createQueryBuilder(Author, 'a', 'write');
const res2 = await qb2.select('*').execute(); // write connection

const qb3 = em.createQueryBuilder(Author);
const res3 = await qb3.update(...).where(...).execute(); // write connection

const res4 = await em.findOne(Author, 1, { connectionType: 'write' }); // explicit write connection

// all queries inside a transaction will use write connection
await em.transactional(async em => {
    const a = await em.findOne(Author, 1); // write connection
    const b = await em.findOne(Author, 1, { connectionType: 'read' }); // still a write connection - we are in a transaction
    a.name = 'test'; // will trigger update on write connection once flushed
});

// given a configuration where preferReadReplicas: false
const res5 = await em.findOne(Author, 1); // write connection - even for a read operation
const res6 = await em.findOne(Author, 1, { connectionType: 'read' }); // unless explicitly asking for a read replica

----------------------------------------

TITLE: Complex AND Query Conditions in MikroORM TypeScript
DESCRIPTION: Demonstrates how to create complex AND query conditions using an array of filters with various comparison operators.

LANGUAGE: typescript
CODE:
const res = await orm.em.find(Author, { $and: [
  { id: { $in: [1, 2, 7] }, },
  { id: { $nin: [3, 4] }, },
  { id: { $gt: 5 }, },
  { id: { $lt: 10 }, },
  { id: { $gte: 7 }, },
  { id: { $lte: 8 }, },
  { id: { $ne: 9 }, },
] });

----------------------------------------

TITLE: Basic Query Builder Usage
DESCRIPTION: Example of creating and executing a basic query using QueryBuilder to update data

LANGUAGE: typescript
CODE:
const qb = em.createQueryBuilder(Author);
qb.update({ name: 'test 123', type: PublisherType.GLOBAL }).where({ id: 123, type: PublisherType.LOCAL });

console.log(qb.getQuery());
// update `publisher2` set `name` = ?, `type` = ? where `id` = ? and `type` = ?

console.log(qb.getParams());
// ['test 123', PublisherType.GLOBAL, 123, PublisherType.LOCAL]

// run the query
const res1 = await qb.execute();

----------------------------------------

TITLE: ManyToMany Relationship Setup in MikroORM
DESCRIPTION: Demonstrates configuration of unidirectional and bidirectional ManyToMany relationships with custom pivot tables.

LANGUAGE: typescript
CODE:
@ManyToMany(() => Book)
books1 = new Collection<Book>(this);

// or mark it as owner explicitly via options object
@ManyToMany({ entity: () => Book, owner: true })
books2 = new Collection<Book>(this);

// Bidirectional example
@ManyToMany(() => BookTag, tag => tag.books, { owner: true })
tags = new Collection<BookTag>(this);

// inversed side
@ManyToMany(() => Book, book => book.tags)
books = new Collection<Book>(this);

----------------------------------------

TITLE: Defining Entity with @Entity Decorator in TypeScript
DESCRIPTION: Example of using the @Entity decorator to define an Author entity with a custom table name.

LANGUAGE: typescript
CODE:
@Entity({ tableName: 'authors' })
export class Author { ... }

----------------------------------------

TITLE: Configuring MikroORM Module in NestJS
DESCRIPTION: Example of importing and configuring MikroORM in the root AppModule with entity paths and database settings.

LANGUAGE: typescript
CODE:
@Module({
  imports: [
    MikroOrmModule.forRoot({
      entities: ['./dist/entities'],
      entitiesTs: ['./src/entities'],
      dbName: 'my-db-name.sqlite3',
    }),
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}

----------------------------------------

TITLE: Configuring Cascade Operations in MikroORM TypeScript
DESCRIPTION: Demonstrates different ways to configure cascade operations on entity relationships using decorators. Shows various cascade options including default persist, cascade remove, no cascade, and cascade all.

LANGUAGE: typescript
CODE:
// cascade persist is default value
@OneToMany({ entity: () => Book, mappedBy: 'author' })
books = new Collection<Book>(this);

// same as previous definition
@OneToMany({ entity: () => Book, mappedBy: 'author', cascade: [Cascade.PERSIST] })
books = new Collection<Book>(this);

// only cascade remove
@OneToMany({ entity: () => Book, mappedBy: 'author', cascade: [Cascade.REMOVE] })
books = new Collection<Book>(this);

// no cascade
@OneToMany({ entity: () => Book, mappedBy: 'author', cascade: [] })
books = new Collection<Book>(this);

// cascade all (persist and remove)
@OneToMany({ entity: () => Book, mappedBy: 'author', cascade: [Cascade.ALL] })
books = new Collection<Book>(this);

// same as previous definition
@OneToMany({ entity: () => Book, mappedBy: 'author', cascade: [Cascade.PERSIST, Cascade.REMOVE] })
books = new Collection<Book>(this);

----------------------------------------

TITLE: Abstract Entity with discriminatorValue in Single Table Inheritance
DESCRIPTION: This snippet shows how to use discriminatorValue with abstract entities in Single Table Inheritance. It defines an abstract base class and concrete subclasses with explicit discriminator values.

LANGUAGE: typescript
CODE:
@Entity({
  discriminatorColumn: 'type',
  abstract: true,
})
export abstract class BasePerson {

  @Enum()
  type!: 'person' | 'employee';

}

@Entity({ discriminatorValue: 'person' })
export class Person extends BasePerson {
  // ...
}

@Entity({ discriminatorValue: 'employee' })
export class Employee extends Person {
  // ...
}

----------------------------------------

TITLE: Configuring Cascade Options in MikroORM TypeScript
DESCRIPTION: Demonstrates various ways to configure cascade options for OneToMany relationships in MikroORM using TypeScript decorators. Shows default behavior and how to specify different cascade types.

LANGUAGE: typescript
CODE:
@OneToMany({ entity: () => Book, mappedBy: 'author' })
books = new Collection<Book>(this);

@OneToMany({ entity: () => Book, mappedBy: 'author', cascade: [Cascade.PERSIST] })
books = new Collection<Book>(this);

@OneToMany({ entity: () => Book, mappedBy: 'author', cascade: [Cascade.REMOVE] })
books = new Collection<Book>(this);

@OneToMany({ entity: () => Book, mappedBy: 'author', cascade: [] })
books = new Collection<Book>(this);

@OneToMany({ entity: () => Book, mappedBy: 'author', cascade: [Cascade.ALL] })
books = new Collection<Book>(this);

@OneToMany({ entity: () => Book, mappedBy: 'author', cascade: [Cascade.PERSIST, Cascade.REMOVE] })
books = new Collection<Book>(this);

----------------------------------------

TITLE: Forking EntityManager in MikroORM (TypeScript)
DESCRIPTION: This snippet shows how to create a new EntityManager instance with its own context and identity map using the fork() method.

LANGUAGE: typescript
CODE:
const em = orm.em.fork();

----------------------------------------

TITLE: Defining Optional Properties
DESCRIPTION: Examples of defining optional properties in entities using different approaches.

LANGUAGE: typescript
CODE:
// reflect-metadata
@ManyToOne(() => Book, { nullable: true })
favouriteBook?: Book;

// ts-morph
@ManyToOne()
favouriteBook?: Book;

// EntitySchema
properties: {
  favouriteBook: { kind: 'm:1', entity: () => Book, nullable: true },
},

----------------------------------------

TITLE: Defining OneToMany and ManyToMany Relationships in TypeScript
DESCRIPTION: Shows how to define OneToMany and ManyToMany relationships using decorators in MikroORM entities.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {
  @PrimaryKey()
  _id!: ObjectId;

  @ManyToOne()
  author!: Author;
}

@Entity()
export class Author {
  @PrimaryKey()
  _id!: ObjectId;

  @OneToMany(() => Book, book => book.author)
  books1 = new Collection<Book>(this);

  @OneToMany({ entity: () => Book, mappedBy: 'author' })
  books2 = new Collection<Book>(this);
}

@ManyToMany(() => Book)
books1 = new Collection<Book>(this);

@ManyToMany({ entity: () => Book, owner: true })
books2 = new Collection<Book>(this);

@ManyToMany(() => BookTag, tag => tag.books, { owner: true })
tags = new Collection<BookTag>(this);

@ManyToMany({ entity: () => BookTag, inversedBy: 'books' })
tags = new Collection<BookTag>(this);

@ManyToMany(() => Book, book => book.tags)
books = new Collection<Book>(this);

@ManyToMany({ entity: () => Book, mappedBy: 'tags' })
books = new Collection<Book>(this);

----------------------------------------

TITLE: Configuring MikroORM Migrations
DESCRIPTION: Basic configuration setup for enabling migrations in MikroORM. Requires installing @mikro-orm/migrations package and registering the Migrator extension.

LANGUAGE: typescript
CODE:
import { Migrator } from '@mikro-orm/migrations';

export default defineConfig({
  // ...
  extensions: [Migrator],
})

----------------------------------------

TITLE: Configuring Connection Options in MikroORM
DESCRIPTION: Shows how to configure database connection options including read replicas and dynamic password handling.

LANGUAGE: typescript
CODE:
MikroORM.init({
  dbName: 'my_db_name',
  user: 'write-user',
  host: 'master.db.example.com',
  port: 3306,
  replicas: [
    { user: 'read-user-1', host: 'read-1.db.example.com', port: 3307 },
    { user: 'read-user-2', host: 'read-2.db.example.com', port: 3308 },
    { user: 'read-user-3', host: 'read-3.db.example.com', port: 3309 },
  ],
});

----------------------------------------

TITLE: Using @ManyToOne Decorator for Relationships in TypeScript
DESCRIPTION: Examples of using the @ManyToOne decorator to define many-to-one relationships between entities.

LANGUAGE: typescript
CODE:
@ManyToOne()
author1?: Author; // type taken via reflection (TsMorphMetadataProvider)

@ManyToOne(() => Author) // explicit type
author2?: Author;

@ManyToOne({ entity: () => Author, cascade: [Cascade.ALL] }) // options object
author3?: Author;

----------------------------------------

TITLE: Configuring Cascade Options in MikroORM Decorators
DESCRIPTION: Demonstrates various ways to configure cascade options for OneToMany relationships in MikroORM using TypeScript decorators. It shows default behavior and how to specify different cascade types.

LANGUAGE: typescript
CODE:
@OneToMany({ entity: () => Book, mappedBy: 'author' })
books = new Collection<Book>(this);

@OneToMany({ entity: () => Book, mappedBy: 'author', cascade: [Cascade.PERSIST] })
books = new Collection<Book>(this);

@OneToMany({ entity: () => Book, mappedBy: 'author', cascade: [Cascade.REMOVE] })
books = new Collection<Book>(this);

@OneToMany({ entity: () => Book, mappedBy: 'author', cascade: [] })
books = new Collection<Book>(this);

@OneToMany({ entity: () => Book, mappedBy: 'author', cascade: [Cascade.ALL] })
books = new Collection<Book>(this);

@OneToMany({ entity: () => Book, mappedBy: 'author', cascade: [Cascade.PERSIST, Cascade.REMOVE] })
books = new Collection<Book>(this);

----------------------------------------

TITLE: Custom BigInt Type Mapping Configuration
DESCRIPTION: Demonstrates how to explicitly map BigInt primary keys to different target types (bigint, string, or number) using the BigIntType configuration options. Includes warning about JavaScript number type limitations.

LANGUAGE: typescript
CODE:
@PrimaryKey({ type: new BigIntType('bigint') })
id1: bigint;

@PrimaryKey({ type: new BigIntType('string') })
id2: string;

@PrimaryKey({ type: new BigIntType('number') })
id3: number;

----------------------------------------

TITLE: Inferring Custom Repository Type in TypeScript with MikroORM
DESCRIPTION: Shows how to use the EntityRepositoryType symbol to infer the correct custom repository type when using em.getRepository(). This ensures type safety when working with custom repositories.

LANGUAGE: typescript
CODE:
@Entity({ repository: () => AuthorRepository })
export class Author {

  [EntityRepositoryType]?: AuthorRepository;

}

const repo = em.getRepository(Author); // repo has type AuthorRepository

----------------------------------------

TITLE: Using rel() Helper for Entity References in TypeScript
DESCRIPTION: This snippet demonstrates the use of the rel() helper function to convert primary keys to entity references in constructors. It shows how to define a ManyToOne relationship using Rel<Author> type.

LANGUAGE: typescript
CODE:
@ManyToOne({ entity: () => Author })
author: Rel<Author>;

constructor(dto: { title: string; author: number }) {
  this.title = dto.title;
  this.author = rel(Author, dto.author);
}

----------------------------------------

TITLE: Configuring Connection Options in MikroORM
DESCRIPTION: Shows how to configure database connection options including read replicas and dynamic password handling.

LANGUAGE: typescript
CODE:
MikroORM.init({
  dbName: 'my_db_name',
  user: 'write-user',
  host: 'master.db.example.com',
  port: 3306,
  replicas: [
    { user: 'read-user-1', host: 'read-1.db.example.com', port: 3307 },
    { user: 'read-user-2', host: 'read-2.db.example.com', port: 3308 },
    { user: 'read-user-3', host: 'read-3.db.example.com', port: 3309 },
  ],
});

----------------------------------------

TITLE: Explicit Transaction Handling with Begin/Commit/Rollback in MikroORM (TypeScript)
DESCRIPTION: Demonstrates explicit transaction handling using begin, commit, and rollback methods. This approach offers the most granular control over transactions.

LANGUAGE: typescript
CODE:
const em = orm.em.fork();
await em.begin();

try {
  //... do some work
  const user = new User(...);
  user.name = 'George';
  em.persist(user);
  await em.commit(); // will flush before making the actual commit query
} catch (e) {
  await em.rollback();
  throw e;
}

----------------------------------------

TITLE: Adding Timestamp Properties to User Entity
DESCRIPTION: Adds created and updated timestamp properties to track entity changes automatically.

LANGUAGE: typescript
CODE:
@Property()
createdAt = new Date();

@Property({ onUpdate: () => new Date() })
updatedAt = new Date();

----------------------------------------

TITLE: Persisting and Flushing Entities in MikroORM
DESCRIPTION: Demonstrates how to persist and flush entities using the EntityManager. It shows how to update an existing entity and how to persist new entities with cascading relationships.

LANGUAGE: typescript
CODE:
const book = await orm.em.findOne(Book, 1);
book.title = 'How to persist things...';

// no need to persist `book` as its already managed by the EM
await orm.em.flush();

LANGUAGE: typescript
CODE:
// use constructors in your entities for required parameters
const author = new Author('Jon Snow', 'snow@wall.st');
author.born = new Date();

const publisher = new Publisher('7K publisher');

const book1 = new Book('My Life on The Wall, part 1', author);
book1.publisher = publisher;
const book2 = new Book('My Life on The Wall, part 2', author);
book2.publisher = publisher;
const book3 = new Book('My Life on The Wall, part 3', author);
book3.publisher = publisher;

// just persist books, author and publisher will be automatically cascade persisted
await orm.em.persistAndFlush([book1, book2, book3]);

// or one by one
orm.em.persistLater(book1);
orm.em.persistLater(book2);
orm.em.persistLater(book3);
await orm.em.flush(); // flush everything to database at once

----------------------------------------

TITLE: Identity Map Basic Usage in TypeScript
DESCRIPTION: Demonstrates how MikroORM's Identity Map pattern works when fetching entities by ID, showing that the same instance is returned for multiple queries of the same entity.

LANGUAGE: typescript
CODE:
const jon1 = await em.findOne(Author, 1);
const jon2 = await em.findOne(Author, 1);

// identity map in action
console.log(jon1 === jon2); // true

----------------------------------------

TITLE: Working with Entity References in MikroORM
DESCRIPTION: Explains the concept of entity references in MikroORM. It shows how to create and use references without fully loading the entity, which is useful for setting relations or removing entities by reference.

LANGUAGE: typescript
CODE:
const userRef = em.getReference(User, 1);
console.log(userRef);

// setting relation properties
author.favouriteBook = em.getReference(Book, 1);

// removing entity by reference
em.remove(em.getReference(Book, 2));

// adding entity to collection by reference
author.books.add(em.getReference(Book, 3));

----------------------------------------

TITLE: Transactional Decorator Usage in MikroORM
DESCRIPTION: Shows how to use the @Transactional decorator to wrap methods in transaction boundaries.

LANGUAGE: typescript
CODE:
import { EntityManager, MikroORM, Transactional } from '@mikro-orm/core';

export class MyService {

  constructor(private readonly em: EntityManager) { }

  @Transactional()
  async doSomething() {
    //... do some work
    const user = new User(...);
    user.name = 'George';
    em.persist(user); 
  }

}

----------------------------------------

TITLE: Defining ManyToMany Collections in TypeScript with MikroORM
DESCRIPTION: This snippet demonstrates how to define unidirectional and bidirectional ManyToMany collections in MikroORM. It shows the usage of the @ManyToMany decorator and the Collection class for both owning and inverse sides of the relationship.

LANGUAGE: typescript
CODE:
// Unidirectional
@ManyToMany(() => Book)
books1 = new Collection<Book>(this);

// or mark it as owner explicitly via options object
@ManyToMany({ entity: () => Book, owner: true })
books2 = new Collection<Book>(this);

// Bidirectional - owning side
@ManyToMany(() => BookTag, tag => tag.books, { owner: true })
tags = new Collection<BookTag>(this);

// or via options object
@ManyToMany({ entity: () => BookTag, inversedBy: 'books' })
tags = new Collection<BookTag>(this);

// Bidirectional - inverse side
@ManyToMany(() => Book, book => book.tags)
books = new Collection<Book>(this);

// or via options object
@ManyToMany({ entity: () => Book, mappedBy: 'tags' })
books = new Collection<Book>(this);

----------------------------------------

TITLE: Creating Entity with Forked EntityManager
DESCRIPTION: Demonstrates entity creation using forked EntityManager with default schema.

LANGUAGE: typescript
CODE:
const fork = em.fork({ schema: 'client-123' });
const user = new User();
user.email = 'foo@bar.com';
await fork.persist(user).flush();

----------------------------------------

TITLE: Defining Enum Property in Entity
DESCRIPTION: Example of defining an enum property in an entity using the @Enum decorator.

LANGUAGE: TypeScript
CODE:
@Entity()
export class User {

  @Enum(() => UserRole)
  role!: UserRole; // string enum

  @Enum(() => UserStatus)
  status!: UserStatus; // numeric/const enum

  @Enum(() => OutsideEnum)
  outside!: OutsideEnum; // string enum defined outside of this file

  @Enum({ items: () => OutsideNullableEnum, nullable: true })
  outsideNullable?: OutsideNullableEnum; // string enum defined outside of this file, may be null

}

export enum UserRole {
  ADMIN = 'admin',
  MODERATOR = 'moderator',
  USER = 'user',
}

export const enum UserStatus {
  DISABLED,
  ACTIVE,
}

----------------------------------------

TITLE: Programmatic Migration Usage
DESCRIPTION: Example of how to programmatically initialize and use the Migrator through a script.

LANGUAGE: typescript
CODE:
import { MikroORM } from '@mikro-orm/core';
import { Migrator } from '@mikro-orm/migrations';

(async () => {
  const orm = await MikroORM.init({
    extensions: [Migrator],
    dbName: 'your-db-name',
    // ...
  });

  const migrator = orm.getMigrator();
  await migrator.createMigration();
  await migrator.up();
  await migrator.up('name');
  await migrator.up({ to: 'up-to-name' });
  await migrator.down();
  await migrator.down('name');
  await migrator.down({ to: 'down-to-name' });
  await migrator.down({ to: 0 });

  await orm.close(true);
})()

----------------------------------------

TITLE: API Endpoints for Optimistic Locking in MikroORM
DESCRIPTION: Shows how to implement API endpoints that support optimistic locking using MikroORM.

LANGUAGE: typescript
CODE:
// GET /book/:id
async findOne(req, res) {
  const book = await this.em.findOne(Book, +req.query.id);
  res.json(book);
}

// PUT /book/:id
async update(req, res) {
  const book = await this.em.findOne(Book, +req.query.id, { lockMode: LockMode.OPTIMISTIC, lockVersion: req.body.version });
  wrap(book).assign(req.body);
  await this.em.flush();

  res.json(book);
}

----------------------------------------

TITLE: Defining MongoDB Entity Schema in TypeScript
DESCRIPTION: This example shows how to define an entity schema for MongoDB, including ObjectId primary key and serialized primary key.

LANGUAGE: typescript
CODE:
export class BookTag {
  _id!: ObjectId;
  id!: string;
  name: string;
  books = new Collection<Book>(this);

  constructor(name: string) {
    this.name = name;
  }
}

export const schema = new EntitySchema<BookTag>({
  class: BookTag,
  properties: {
    _id: { type: 'ObjectId', primary: true },
    id: { type: 'string', serializedPrimaryKey: true },
    name: { type: 'string' },
    books: { kind: 'm:n', entity: () => Book, mappedBy: book => book.tags },
  },
});

----------------------------------------

TITLE: Atomic Updates with raw() Helper in MikroORM
DESCRIPTION: Demonstrates how to perform atomic updates using the raw() helper in MikroORM, allowing for complex update queries.

LANGUAGE: typescript
CODE:
const ref = em.getReference(Author, 123);
ref.age = raw(`age * 2`);

await em.flush();
console.log(ref.age); // real value is available after flush

----------------------------------------

TITLE: Setting Up OneToOne Relationships (Inverse Side) in MikroORM
DESCRIPTION: Shows how to define the inverse side of OneToOne relationships with mappedBy property and orphan removal support.

LANGUAGE: typescript
CODE:
@Entity()
export class User {

  @OneToOne({ mappedBy: 'bestFriend1', orphanRemoval: true })
  bestFriend1!: User;

  @OneToOne(() => User, user => user.bestFriend2, { orphanRemoval: true })
  bestFriend2!: User;

}

----------------------------------------

TITLE: Persisting Managed Entities in MikroORM with TypeScript
DESCRIPTION: This example demonstrates how MikroORM automatically tracks changes to managed entities without explicit persist calls.

LANGUAGE: typescript
CODE:
const jon = await em.findOne(Author, 1);
jon.email = 'foo@bar.com';
await em.flush();

----------------------------------------

TITLE: Initializing and Accessing Collection Items in TypeScript
DESCRIPTION: Demonstrates how to initialize a Collection, iterate through it, and access its items using various methods in MikroORM.

LANGUAGE: typescript
CODE:
const author = em.findOne(Author, '...', { populate: ['books'] });

for (const book of author.books) {
  console.log(book.title);
  console.log(book.author.isInitialized());
  console.log(book.author.id);
  console.log(book.author.name);
  console.log(book.publisher);
  console.log(book.publisher.isInitialized());
  console.log(book.publisher.id);
  console.log(book.publisher.name);
}

author.books.add(book);
console.log(author.books.contains(book));
console.log(author.books.exists(item => item === book));
console.log(author.books.find(item => item === book));
console.log(author.books.map(item => item.title));
console.log(author.books.filter(item => item.title.startsWith('Foo')));
author.books.remove(book);
console.log(author.books.contains(book));
author.books.add(book);
console.log(author.books.count());
console.log(author.books.slice(0, 1));
console.log(author.books.slice());
console.log(author.books.slice().length);
author.books.removeAll();
console.log(author.books.isEmpty());
console.log(author.books.contains(book));
console.log(author.books.count());
console.log(author.books.getItems());
console.log(author.books.getIdentifiers());
console.log(author.books.getIdentifiers('_id'));

console.log(author.books[1]);
console.log(author.books[12345]);

console.log(author.books.getItems());

console.log(author.books.toArray());

const author = em.findOne(Author, '...');
const count = await author.books.loadCount();
console.log(author.books.getItems());
console.log(await author.books.loadItems());

----------------------------------------

TITLE: Basic Collection Operations in TypeScript with MikroORM
DESCRIPTION: Demonstrates core Collection operations including iteration, initialization, and item manipulation. Shows how to work with populated collections and access collection items.

LANGUAGE: typescript
CODE:
const author = em.findOne(Author, '...', { populate: ['books'] });

// or we could lazy load books collection later via `init()` method
await author.books.init();

for (const book of author.books) {
  console.log(book.title); // initialized
  console.log(book.author.isInitialized()); // true
  console.log(book.author.id);
  console.log(book.author.name); // Jon Snow
  console.log(book.publisher); // just reference
  console.log(book.publisher.isInitialized()); // false
  console.log(book.publisher.id);
  console.log(book.publisher.name); // undefined
}

----------------------------------------

TITLE: Demonstrating Identity Map in MikroORM (TypeScript)
DESCRIPTION: This snippet shows how the Identity Map ensures that the same entity instance is returned across multiple queries within the same context.

LANGUAGE: typescript
CODE:
const authorRepository = em.getRepository(Author);
const jon = await authorRepository.findOne({ name: 'Jon Snow' }, { populate: ['books'] });
const authors = await authorRepository.findAll({ populate: ['books'] });

// identity map in action
console.log(jon === authors[0]); // true

----------------------------------------

TITLE: Persisting Managed Entities in MikroORM (TypeScript)
DESCRIPTION: This example demonstrates how MikroORM automatically tracks changes to managed entities, allowing updates without explicit persist() calls.

LANGUAGE: typescript
CODE:
const jon = await em.findOne(Author, 1);
jon.email = 'foo@bar.com';
await em.flush();

----------------------------------------

TITLE: Defining Virtual Entity with QueryBuilder Callback in TypeScript
DESCRIPTION: Implements a virtual entity using a callback function that constructs the query using MikroORM's QueryBuilder. The callback provides more flexibility in query construction compared to raw SQL strings.

LANGUAGE: typescript
CODE:
@Entity({
  expression: (em: EntityManager) => {
    return em.createQueryBuilder(Book, 'b')
      .select(['b.title', 'a.name as author_name', 'group_concat(t.name) as tags'])
      .join('b.author', 'a')
      .join('b.tags', 't')
      .groupBy('b.id');
  },
})
export class BookWithAuthor {

  @Property()
  title!: string;

  @Property()
  authorName!: string;

  @Property()
  tags!: string[];

}

----------------------------------------

TITLE: Entity Definition with Entity Schema
DESCRIPTION: Alternative approach to define entities using EntitySchema helper with explicit type definitions.

LANGUAGE: typescript
CODE:
export interface IBook extends CustomBaseEntity {
  title: string;
  author: Author;
  publisher?: Ref<Publisher>;
  tags: Collection<BookTag>;
}

export const Book = new EntitySchema<IBook, CustomBaseEntity>({
  name: 'Book',
  extends: 'CustomBaseEntity',
  properties: {
    title: { type: 'string' },
    author: { kind: 'm:1', entity: 'Author' },
    publisher: { kind: 'm:1', entity: 'Publisher', ref: true, nullable: true },
    tags: { kind: 'm:n', entity: 'BookTag', fixedOrder: true },
  },
});

----------------------------------------

TITLE: Defining OneToMany Collections in TypeScript with MikroORM
DESCRIPTION: This snippet shows how to define OneToMany collections in MikroORM, which are the inverse side of ManyToOne references. It demonstrates the usage of the @OneToMany decorator and the Collection class.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @PrimaryKey()
  _id!: ObjectId;

  @ManyToOne()
  author!: Author;

}

@Entity()
export class Author {

  @PrimaryKey()
  _id!: ObjectId;

  @OneToMany(() => Book, book => book.author)
  books1 = new Collection<Book>(this);

  // or via options object
  @OneToMany({ entity: () => Book, mappedBy: 'author' })
  books2 = new Collection<Book>(this);

}

----------------------------------------

TITLE: Implementing Custom Repository Pattern
DESCRIPTION: Example showing how to create and use custom repositories with entity definitions and repository injection.

LANGUAGE: typescript
CODE:
@Entity({ repository: () => AuthorRepository })
export class Author {
  [EntityRepositoryType]?: AuthorRepository;
}

export class AuthorRepository extends EntityRepository<Author> {
  // custom methods
}

----------------------------------------

TITLE: Setting Transaction Isolation Level in MikroORM
DESCRIPTION: Shows how to set the transaction isolation level when using the transactional() method in MikroORM. This example sets the isolation level to READ_UNCOMMITTED.

LANGUAGE: typescript
CODE:
await orm.em.transactional(async em => {
  // ...
}, { isolationLevel: IsolationLevel.READ_UNCOMMITTED });

----------------------------------------

TITLE: Initializing MikroORM with Read Replicas in TypeScript
DESCRIPTION: Demonstrates how to initialize MikroORM with multiple read replica connections. Shows configuration of master and replica connections with different hosts and users.

LANGUAGE: typescript
CODE:
const orm = await MikroORM.init({
  entities: [Author, ...],
  dbName: `my_database`,
  user: 'master_user',
  host: 'master_host',
  preferReadReplicas: true, // optional property, defaults to true
  replicas: [
    { name: 'read-1', host: 'read_host_1', user: 'read_user' },
    { name: 'read-2', host: 'read_host_2' }, // user omitted, will be taken from master connection
  ],
});

----------------------------------------

TITLE: Implementing Article Routes Registration with MikroORM
DESCRIPTION: Sets up route registration for articles with database connectivity and pagination support

LANGUAGE: typescript
CODE:
import { FastifyInstance } from 'fastify';
import { initORM } from '../../db.js';

export async function registerArticleRoutes(app: FastifyInstance) {
  const db = await initORM();

  app.get('/', async request => {
    const { limit, offset } = request.query as { limit?: number; offset?: number };
    const [items, total] = await db.article.findAndCount({}, {
      limit, offset,
    });

    return { items, total };
  });
}

----------------------------------------

TITLE: Persisting and Flushing Entities in MikroORM
DESCRIPTION: Demonstrates basic entity persistence using em.persist() and em.flush() to save changes to the database. Shows how managed entities are automatically tracked for changes.

LANGUAGE: typescript
CODE:
const book = await em.findOne(Book, 1);
book.title = 'How to persist things...';

// no need to persist `book` as its already managed by the EM
await em.flush();

----------------------------------------

TITLE: Loading Entities with Default Joined Strategy
DESCRIPTION: Example of loading an Author entity with its books relation using the default joined strategy.

LANGUAGE: typescript
CODE:
const author = await orm.em.findOne(Author, 1, {
  populate: ['books'],
});

----------------------------------------

TITLE: Creating Base Entity with Common Properties
DESCRIPTION: Defines an abstract base entity class with id and timestamp fields that other entities can extend.

LANGUAGE: typescript
CODE:
import { PrimaryKey, Property } from '@mikro-orm/core';

export abstract class BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property()
  createdAt = new Date();

  @Property({ onUpdate: () => new Date() })
  updatedAt = new Date();

}

----------------------------------------

TITLE: Handling Circular Dependencies in Entity Relations
DESCRIPTION: Example of defining entity relations with circular dependencies using explicit type definitions.

LANGUAGE: typescript
CODE:
@ManyToOne({ entity: () => Author })
author: Author;

----------------------------------------

TITLE: Explicit Transaction Handling with Begin/Commit/Rollback in MikroORM
DESCRIPTION: Demonstrates explicit transaction control using begin, commit, and rollback methods in MikroORM.

LANGUAGE: typescript
CODE:
const em = orm.em.fork();
await em.begin();

try {
  //... do some work
  const user = new User(...);
  user.name = 'George';
  em.persist(user);
  await em.commit(); // will flush before making the actual commit query
} catch (e) {
  await em.rollback();
  throw e;
}

----------------------------------------

TITLE: Defining Entity-Level Filters in TypeScript with MikroORM
DESCRIPTION: This snippet demonstrates how to define filters at the entity level using decorators. It shows various filter types including static conditions, dynamic conditions, and default filters.

LANGUAGE: typescript
CODE:
@Entity()
@Filter({ name: 'expensive', cond: { price: { $gt: 1000 } } })
@Filter({ name: 'long', cond: { 'length(text)': { $gt: 10000 } } })
@Filter({ name: 'hasAuthor', cond: { author: { $ne: null } }, default: true })
@Filter({ name: 'writtenBy', cond: args => ({ author: { name: args.name } }) })
export class Book {
  ...
}

const books1 = await orm.em.find(Book, {}, {
  filters: ['long', 'expensive'],
});
const books2 = await orm.em.find(Book, {}, {
  filters: { hasAuthor: false, long: true, writtenBy: { name: 'God' } },
});

----------------------------------------

TITLE: Implementing QueryBuilder for Article Listing
DESCRIPTION: Creates a complex query using QueryBuilder to fetch articles with related data

LANGUAGE: typescript
CODE:
listArticlesQuery() {
  const totalComments = this.em.createQueryBuilder(Comment)
    .count()
    .where({ article: sql.ref('a.id') })
    .as('totalComments');

  const usedTags = this.em.createQueryBuilder(Article, 'aa')
    .select(sql`group_concat(distinct t.name)`)
    .join('aa.tags', 't')
    .where({ 'aa.id': sql.ref('a.id') })
    .groupBy('aa.author')
    .as('tags');

  return this.createQueryBuilder('a')
    .select(['slug', 'title', 'description', 'author'])
    .addSelect(sql.ref('u.full_name').as('authorName'))
    .join('author', 'u')
    .addSelect([totalComments, usedTags]);
}

----------------------------------------

TITLE: Defining ManyToOne Relationships in MikroORM with TypeScript
DESCRIPTION: This snippet demonstrates various ways to define a ManyToOne relationship in MikroORM using TypeScript decorators. It shows different syntax options for specifying the related entity type.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @ManyToOne() // plain decorator is enough, type will be sniffer via reflection!
  author1!: Author;

  @ManyToOne(() => Author) // you can specify type manually as a callback
  author2!: Author;

  @ManyToOne('Author') // or as a string
  author3!: Author;

  @ManyToOne({ entity: () => Author }) // or use options object
  author4!: Author;

}

----------------------------------------

TITLE: MikroORM Configuration
DESCRIPTION: Configuration setup for MikroORM using SQLite driver and TypeScript reflection.

LANGUAGE: typescript
CODE:
import { Options, SqliteDriver } from '@mikro-orm/sqlite';
import { TsMorphMetadataProvider } from '@mikro-orm/reflection';

const config: Options = {
  driver: SqliteDriver,
  dbName: 'sqlite.db',
  entities: ['dist/**/*.entity.js'],
  entitiesTs: ['src/**/*.entity.ts'],
  metadataProvider: TsMorphMetadataProvider,
  debug: true,
};

export default config;

----------------------------------------

TITLE: Complex AND Query Conditions in MikroORM TypeScript
DESCRIPTION: Demonstrates how to create complex AND query conditions using an array of filter objects. Shows multiple comparison operators like $in, $nin, $gt, $lt, $gte, $lte, and $ne.

LANGUAGE: typescript
CODE:
const res = await orm.em.find(Author, { $and: [
  { id: { $in: [1, 2, 7] }, },
  { id: { $nin: [3, 4] }, },
  { id: { $gt: 5 }, },
  { id: { $lt: 10 }, },
  { id: { $gte: 7 }, },
  { id: { $lte: 8 }, },
  { id: { $ne: 9 }, },
] });

----------------------------------------

TITLE: Configuring Cascade Options in MikroORM TypeScript
DESCRIPTION: Demonstrates various ways to configure cascade options for OneToMany relationships in MikroORM using TypeScript decorators. It shows default behavior and how to specify different cascade options.

LANGUAGE: typescript
CODE:
@OneToMany({ entity: () => Book, mappedBy: 'author' })
books = new Collection<Book>(this);

@OneToMany({ entity: () => Book, mappedBy: 'author', cascade: [Cascade.PERSIST] })
books = new Collection<Book>(this);

@OneToMany({ entity: () => Book, mappedBy: 'author', cascade: [Cascade.REMOVE] })
books = new Collection<Book>(this);

@OneToMany({ entity: () => Book, mappedBy: 'author', cascade: [] })
books = new Collection<Book>(this);

@OneToMany({ entity: () => Book, mappedBy: 'author', cascade: [Cascade.ALL] })
books = new Collection<Book>(this);

@OneToMany({ entity: () => Book, mappedBy: 'author', cascade: [Cascade.PERSIST, Cascade.REMOVE] })
books = new Collection<Book>(this);

----------------------------------------

TITLE: Initializing MikroORM with Read Replicas Configuration
DESCRIPTION: Example showing how to initialize MikroORM with multiple read replica connections. Demonstrates setting up master and replica connection parameters with the preferReadReplicas option.

LANGUAGE: typescript
CODE:
const orm = await MikroORM.init({
  entities: [Author, ...],
  dbName: `my_database`,
  user: 'master_user',
  host: 'master_host',
  preferReadReplicas: true, // optional property, defaults to true
  replicas: [
    { name: 'read-1', host: 'read_host_1', user: 'read_user' },
    { name: 'read-2', host: 'read_host_2' }, // user omitted, will be taken from master connection
  ],
});

----------------------------------------

TITLE: Configuring Global Custom EntityRepository in MikroORM
DESCRIPTION: Shows how to specify a custom EntityRepository as the global default in MikroORM configuration. This applies the custom repository to all entities that don't have a specific repository defined.

LANGUAGE: typescript
CODE:
MikroORM.init({
   entityRepository: ExtendedEntityRepository,
})

----------------------------------------

TITLE: Running Migrations Programmatically in TypeScript
DESCRIPTION: This example shows how to initialize MikroORM and use the Migrator programmatically to create and run migrations in a TypeScript environment.

LANGUAGE: typescript
CODE:
import { MikroORM } from '@mikro-orm/core';
import { Migrator } from '@mikro-orm/migrations';

(async () => {
  const orm = await MikroORM.init({
    extensions: [Migrator],
    dbName: 'your-db-name',
    // ...
  });

  const migrator = orm.getMigrator();
  await migrator.createMigration(); // creates file Migration20191019195930.ts
  await migrator.up(); // runs migrations up to the latest
  await migrator.up('name'); // runs only given migration, up
  await migrator.up({ to: 'up-to-name' }); // runs migrations up to given version
  await migrator.down(); // migrates one step down
  await migrator.down('name'); // runs only given migration, down
  await migrator.down({ to: 'down-to-name' }); // runs migrations down to given version
  await migrator.down({ to: 0 }); // migrates down to the first version

  await orm.close(true);
})();

----------------------------------------

TITLE: Defining Book Entity with BigInt Primary Key
DESCRIPTION: Example of defining a Book entity using BigInt as the primary key for MySQL and PostgreSQL.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @PrimaryKey()
  id: bigint;

}

----------------------------------------

TITLE: Initializing MikroORM with MongoDB Transactions
DESCRIPTION: Shows how to initialize MikroORM with MongoDB transactions enabled, including setting up a replica set and creating the schema.

LANGUAGE: typescript
CODE:
import { MikroORM } from '@mikro-orm/mongodb';

const orm = await MikroORM.init({
  entities: [Author, Book, ...],
  clientUrl: 'mongodb://localhost:27017,localhost:27018,localhost:27019/my-db-name?replicaSet=rs0',
  implicitTransactions: true, // defaults to false
});

await orm.schema.createSchema();

----------------------------------------

TITLE: Programmatic SchemaGenerator Usage
DESCRIPTION: Complete example of using SchemaGenerator programmatically, including initialization, schema operations, and database management functions.

LANGUAGE: typescript
CODE:
import { MikroORM } from '@mikro-orm/core';

(async () => {
  const orm = await MikroORM.init({
    entities: [Author, Book, ...],
    dbName: 'your-db-name',
    // ...
  });
  const generator = orm.schema;

  const dropDump = await generator.getDropSchemaSQL();
  console.log(dropDump);

  const createDump = await generator.getCreateSchemaSQL();
  console.log(createDump);

  const updateDump = await generator.getUpdateSchemaSQL();
  console.log(updateDump);

  // there is also `generate()` method that returns drop + create queries
  const dropAndCreateDump = await generator.generate();
  console.log(dropAndCreateDump);

  // or you can run those queries directly, but be sure to check them first!
  await generator.dropSchema();
  await generator.createSchema();
  await generator.updateSchema();

  // in tests it can be handy to use those:
  await generator.refreshDatabase(); // ensure db exists and is fresh
  await generator.clearDatabase(); // removes all data

  await orm.close(true);
})();

----------------------------------------

TITLE: Implementing QueryBuilder for Article Listing
DESCRIPTION: Creates a complex query using QueryBuilder to fetch articles with related data

LANGUAGE: typescript
CODE:
listArticlesQuery() {
  const totalComments = this.em.createQueryBuilder(Comment)
    .count()
    .where({ article: sql.ref('a.id') })
    .as('totalComments');

  const usedTags = this.em.createQueryBuilder(Article, 'aa')
    .select(sql`group_concat(distinct t.name)`)
    .join('aa.tags', 't')
    .where({ 'aa.id': sql.ref('a.id') })
    .groupBy('aa.author')
    .as('tags');

  return this.createQueryBuilder('a')
    .select(['slug', 'title', 'description', 'author'])
    .addSelect(sql.ref('u.full_name').as('authorName'))
    .join('author', 'u')
    .addSelect([totalComments, usedTags]);
}

----------------------------------------

TITLE: Persisting and Flushing Entities in MikroORM
DESCRIPTION: Demonstrates how to persist new entities and flush changes to the database using EntityManager in MikroORM.

LANGUAGE: typescript
CODE:
const book = await em.findOne(Book, 1);
book.title = 'How to persist things...';

// no need to persist `book` as its already managed by the EM
await em.flush();

----------------------------------------

TITLE: Simple Query Builder Usage
DESCRIPTION: Basic example of using QueryBuilder to construct and execute an update query

LANGUAGE: typescript
CODE:
const qb = em.createQueryBuilder(Author);
qb.update({ name: 'test 123', type: PublisherType.GLOBAL }).where({ id: 123, type: PublisherType.LOCAL });

console.log(qb.getQuery());
// update `publisher2` set `name` = ?, `type` = ? where `id` = ? and `type` = ?

console.log(qb.getParams());
// ['test 123', PublisherType.GLOBAL, 123, PublisherType.LOCAL]

// run the query
const res1 = await qb.execute();

----------------------------------------

TITLE: Demonstrating Bidirectional Relation Propagation in MikroORM
DESCRIPTION: This snippet shows how changes made to one side of a bidirectional relation are automatically propagated to the other side in MikroORM. It creates an author and a book, assigns the author to the book, and then checks if the book is contained in the author's books collection.

LANGUAGE: typescript
CODE:
const author = new Author(...);
const book = new Book(...);
book.author = author;
console.log(author.books.contains(book)); // true

----------------------------------------

TITLE: Implementing RequestContext Middleware in Express with MikroORM
DESCRIPTION: Demonstrates how to set up request context middleware in Express to ensure each request has its own EntityManager instance.

LANGUAGE: typescript
CODE:
app.use((req, res, next) => {
  // calls `orm.em.fork()` and attaches it to the async context
  RequestContext.create(orm.em, next);
});

app.get('/', async (req, res) => {
  // uses fork from the async context automatically
  const authors = await orm.em.find(Book, {});
  res.json(authors);
});

----------------------------------------

TITLE: Defining Entity Constructor with Required Parameters
DESCRIPTION: Example of a Book entity definition with required title and author parameters in the constructor. Shows property decorators and relationship definitions using MikroORM.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @PrimaryKey()
  id!: number;

  @Property()
  title: string;

  @Property()
  foo!: number;

  @ManyToOne()
  author: Author;

  @ManyToOne()
  publisher?: Publisher;

  @ManyToMany({ entity: () => BookTag, inversedBy: 'books' })
  tags = new Collection<BookTag>(this);

  constructor(title: string, author: Author) {
    this.title = title;
    this.author = author;
  }

}

----------------------------------------

TITLE: Primary Key Definition with @PrimaryKey
DESCRIPTION: Examples showing different ways to define primary keys using @PrimaryKey decorator including auto-increment and UUID configurations.

LANGUAGE: typescript
CODE:
@PrimaryKey()
id!: number; // auto increment PK in SQL drivers

@PrimaryKey({ autoincrement: false })
id!: number; // numeric PK without auto increment

@PrimaryKey()
uuid: string = uuid.v4(); // uuid PK in SQL drivers

@PrimaryKey()
_id!: ObjectId; // ObjectId PK in mongodb driver

----------------------------------------

TITLE: Disabling Change Tracking for Specific Properties in MikroORM (TypeScript)
DESCRIPTION: This snippet shows how to disable change tracking for specific properties to improve performance in certain scenarios.

LANGUAGE: typescript
CODE:
@Property({ trackChanges: false })
code!: string;

----------------------------------------

TITLE: Generated SQL for Typed JSON Index in MySQL
DESCRIPTION: This SQL snippet shows the generated query for creating a typed index on a JSON property in MySQL. It demonstrates how MikroORM translates the TypeScript decorator with options into a SQL alter table statement.

LANGUAGE: sql
CODE:
alter table `book`
  add index `book_meta_data_foo_index`((json_value(`meta_data`, '$.foo' returning char(200))));

----------------------------------------

TITLE: Defining ManyToMany Collections in TypeScript
DESCRIPTION: Demonstrates how to define unidirectional and bidirectional ManyToMany collections in MikroORM using TypeScript decorators.

LANGUAGE: typescript
CODE:
// Unidirectional
@ManyToMany(() => Book)
books1 = new Collection<Book>(this);

// or mark it as owner explicitly via options object
@ManyToMany({ entity: () => Book, owner: true })
books2 = new Collection<Book>(this);

// Bidirectional
@ManyToMany(() => BookTag, tag => tag.books, { owner: true })
tags = new Collection<BookTag>(this);

// or via options object
@ManyToMany({ entity: () => BookTag, inversedBy: 'books' })
tags = new Collection<BookTag>(this);

// And on the inversed side
@ManyToMany(() => Book, book => book.tags)
books = new Collection<Book>(this);

// or via options object
@ManyToMany({ entity: () => Book, mappedBy: 'tags' })
books = new Collection<Book>(this);

----------------------------------------

TITLE: Using Reference Helpers with Entity Constructors
DESCRIPTION: Examples of using rel() and ref() helpers to handle entity references in constructors, supporting both primary keys and entity instances.

LANGUAGE: typescript
CODE:
@ManyToOne({ entity: () => Author })
author: Rel<Author>;

constructor(dto: { title: string; author: number }) {
  this.title = dto.title;
  this.author = rel(Author, dto.author);
}

LANGUAGE: typescript
CODE:
@ManyToOne({ entity: () => Author, ref: true })
author: Ref<Author>;

constructor(dto: { title: string; author: number }) {
  this.title = dto.title;
  this.author = ref(Author, dto.author);
}

LANGUAGE: typescript
CODE:
book.author = ref(Author, null);
book.author = ref(Author, undefined);
book.author = ref(null);
book.author = ref(undefined);
book.author = ref(Author, 1);
book.author = ref(Author, author);
book.author = ref(author);

----------------------------------------

TITLE: Configuring Discovery Options in MikroORM
DESCRIPTION: Shows how to adjust the entity discovery process options including warnings and property analysis settings.

LANGUAGE: typescript
CODE:
MikroORM.init({
  discovery: {
    warnWhenNoEntities: false, // by default, discovery throws when no entity is processed
    requireEntitiesArray: true, // force usage of class references in `entities` instead of paths
    alwaysAnalyseProperties: false, // do not analyse properties when not needed (with ts-morph)
  },
});

----------------------------------------

TITLE: Identity Map with Non-Primary Key Queries
DESCRIPTION: Shows how Identity Map works when querying entities by properties other than primary key, demonstrating that multiple database calls are made but the same instance is maintained.

LANGUAGE: typescript
CODE:
const jon1 = await em.findOne(Author, { name: 'Jon Snow' });
const jon2 = await em.findOne(Author, { name: 'Jon Snow' });

// identity map in action
console.log(jon1 === jon2); // true

----------------------------------------

TITLE: Defining ManyToMany Collections in TypeScript
DESCRIPTION: Demonstrates how to define unidirectional and bidirectional ManyToMany collections in MikroORM using TypeScript decorators.

LANGUAGE: typescript
CODE:
// Unidirectional
@ManyToMany(() => Book)
books1 = new Collection<Book>(this);

// or mark it as owner explicitly via options object
@ManyToMany({ entity: () => Book, owner: true })
books2 = new Collection<Book>(this);

// Bidirectional
@ManyToMany(() => BookTag, tag => tag.books, { owner: true })
tags = new Collection<BookTag>(this);

// or via options object
@ManyToMany({ entity: () => BookTag, inversedBy: 'books' })
tags = new Collection<BookTag>(this);

// And on the inversed side
@ManyToMany(() => Book, book => book.tags)
books = new Collection<Book>(this);

// or via options object
@ManyToMany({ entity: () => Book, mappedBy: 'tags' })
books = new Collection<Book>(this);

----------------------------------------

TITLE: Defining Entity Constructor with Required Properties
DESCRIPTION: Example of a Book entity definition with required title and author properties in the constructor. Shows how to use decorators for defining entity properties and relationships.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @PrimaryKey()
  id!: number;

  @Property()
  title: string;

  @Property()
  foo!: number;

  @ManyToOne()
  author: Author;

  @ManyToOne()
  publisher?: Publisher;

  @ManyToMany({ entity: () => BookTag, inversedBy: 'books' })
  tags = new Collection<BookTag>(this);

  constructor(title: string, author: Author) {
    this.title = title;
    this.author = author;
  }

}

----------------------------------------

TITLE: Configuring MikroORM Migrations
DESCRIPTION: This code snippet demonstrates the various configuration options available for MikroORM migrations, including file paths, transaction settings, and generation modes.

LANGUAGE: typescript
CODE:
await MikroORM.init({
  // default values:
  migrations: {
    tableName: 'mikro_orm_migrations', // name of database table with log of executed transactions
    path: './migrations', // path to the folder with migrations
    pathTs: undefined, // path to the folder with TS migrations (if used, you should put path to compiled files in `path`)
    glob: '!(*.d).{js,ts}', // how to match migration files (all .js and .ts files, but not .d.ts)
    transactional: true, // wrap each migration in a transaction
    disableForeignKeys: true, // wrap statements with `set foreign_key_checks = 0` or equivalent
    allOrNothing: true, // wrap all migrations in master transaction
    dropTables: true, // allow to disable table dropping
    safe: false, // allow to disable table and column dropping
    snapshot: true, // save snapshot when creating new migrations
    emit: 'ts', // migration generation mode
    generator: TSMigrationGenerator, // migration generator, e.g. to allow custom formatting
  },
})

----------------------------------------

TITLE: Cascading Persistence in MikroORM
DESCRIPTION: Shows how to persist multiple related entities with automatic cascading in MikroORM.

LANGUAGE: typescript
CODE:
const author = new Author('Jon Snow', 'snow@wall.st');
author.born = new Date();

const publisher = new Publisher('7K publisher');

const book1 = new Book('My Life on The Wall, part 1', author);
book1.publisher = publisher;
const book2 = new Book('My Life on The Wall, part 2', author);
book2.publisher = publisher;
const book3 = new Book('My Life on The Wall, part 3', author);
book3.publisher = publisher;

// just persist books, author and publisher will be automatically cascade persisted
await em.persist([book1, book2, book3]).flush();

// or one by one
em.persist(book1);
em.persist(book2);
em.persist(book3);
await em.flush(); // flush everything to database at once

----------------------------------------

TITLE: Defining SQL Virtual Entity with QueryBuilder in TypeScript
DESCRIPTION: Implements a virtual entity using QueryBuilder to construct the SQL query programmatically. The entity maps book titles, author names and concatenated tags.

LANGUAGE: typescript
CODE:
@Entity({
  expression: (em: EntityManager) => {
    return em.createQueryBuilder(Book, 'b')
      .select(['b.title', 'a.name as author_name', 'group_concat(t.name) as tags'])
      .join('b.author', 'a')
      .join('b.tags', 't')
      .groupBy('b.id');
  },
})
export class BookWithAuthor {

  @Property()
  title!: string;

  @Property()
  authorName!: string;

  @Property()
  tags!: string[];

}

----------------------------------------

TITLE: MySQL-specific JSON Index with Type Casting
DESCRIPTION: Example of creating a typed JSON property index specific to MySQL with explicit type casting.

LANGUAGE: typescript
CODE:
@Entity()
@Index({ properties: 'metaData.foo', options: { returning: 'char(200)' } })
export class Book {

  @Property({ type: 'json', nullable: true })
  metaData?: { foo: string; bar: number };

}

----------------------------------------

TITLE: Using Result Cache with QueryBuilder in TypeScript
DESCRIPTION: Shows how to enable result caching when using QueryBuilder to fetch results.

LANGUAGE: typescript
CODE:
const res = await em.createQueryBuilder(Book)
  .where({ author: { name: 'Jon Snow' } })
  .cache()
  .getResultList();

----------------------------------------

TITLE: Setting up RequestContext Middleware in Express
DESCRIPTION: Example of setting up RequestContext middleware in an Express application to manage entity manager instances per request.

LANGUAGE: typescript
CODE:
const app = express();

app.use((req, res, next) => {
  RequestContext.create(orm.em, next);
});

----------------------------------------

TITLE: Defining Custom Repository for MikroORM Entity
DESCRIPTION: Demonstrates how to create a custom repository for a MikroORM entity in NestJS.

LANGUAGE: typescript
CODE:
@Entity({ repository: () => AuthorRepository })
export class Author {

  // to allow inference in `em.getRepository()`
  [EntityRepositoryType]?: AuthorRepository;

}

LANGUAGE: typescript
CODE:
import { EntityRepository } from '@mikro-orm/mysql'; // Import EntityManager from your driver package or `@mikro-orm/knex`

export class AuthorRepository extends EntityRepository<Author> {

  // your custom methods...

}

----------------------------------------

TITLE: Creating a Migration Class in MikroORM
DESCRIPTION: This example demonstrates how to create a migration class in MikroORM. It extends the Migration abstract class and implements the 'up' method to define the migration steps.

LANGUAGE: typescript
CODE:
import { Migration } from '@mikro-orm/migrations';

export class Migration20191019195930 extends Migration {

  async up(): Promise<void> {
    this.addSql('select 1 + 1');
  }

}

----------------------------------------

TITLE: Implementing Custom Platform Class in TypeScript
DESCRIPTION: Platform class implementation that defines database features and capabilities. This class extends the base Platform class and provides methods for handling database-specific functionality like transactions, naming strategies, and primary key handling.

LANGUAGE: typescript
CODE:
import { Platform } from '@mikro-orm/core';

export class MyCustomPlatform extends Platform {

  protected abstract schemaHelper: MyCustomSchemaHelper;

  // here you can override default settings
  usesPivotTable(): boolean;
  supportsTransactions(): boolean;
  supportsSavePoints(): boolean;
  getNamingStrategy(): { new (): NamingStrategy; };
  getIdentifierQuoteCharacter(): string;
  getParameterPlaceholder(index?: number): string;
  usesReturningStatement(): boolean;
  normalizePrimaryKey<T = number | string>(data: IPrimaryKey): T;
  denormalizePrimaryKey(data: IPrimaryKey): IPrimaryKey;
  getSerializedPrimaryKeyField(field: string): string;

}

----------------------------------------

TITLE: Implementing ManyToMany Relationships (Inverse Side) in MikroORM
DESCRIPTION: Shows how to define the inverse side of ManyToMany relationships using mappedBy parameter.

LANGUAGE: typescript
CODE:
@Entity()
export class BookTag {

  @ManyToMany(() => Book, book => book.tags)
  books = new Collection<Book>(this);

}

----------------------------------------

TITLE: Implicit Transaction Handling in MikroORM
DESCRIPTION: Demonstrates the basic implicit transaction handling where MikroORM automatically manages transaction boundaries during flush operations.

LANGUAGE: typescript
CODE:
const user = new User(...);
user.name = 'George';
await orm.em.persist(user).flush();

----------------------------------------

TITLE: Initializing TsMorphMetadataProvider in MikroORM
DESCRIPTION: Configuration for using TsMorphMetadataProvider, which uses ts-morph to read TypeScript source files for type detection. Requires @mikro-orm/reflection package.

LANGUAGE: typescript
CODE:
import { TsMorphMetadataProvider } from '@mikro-orm/reflection';

await MikroORM.init({
  metadataProvider: TsMorphMetadataProvider,
  // ...
});

----------------------------------------

TITLE: Optimistic Locking with DateTime Version in MikroORM
DESCRIPTION: Demonstrates how to use a datetime field for version control in optimistic locking with MikroORM.

LANGUAGE: typescript
CODE:
export class User {
  // ...
  @Property({ version: true })
  version!: Date;
  // ...
}

----------------------------------------

TITLE: Storing Embeddables as Objects in MikroORM
DESCRIPTION: This code demonstrates how to store an embeddable as a JSON object instead of inlining its properties, using the 'object' option in the @Embedded decorator.

LANGUAGE: typescript
CODE:
@Entity()
export class User {

  @Embedded({ entity: () => Address, object: true })
  address!: Address;

}

----------------------------------------

TITLE: Using Result Cache with EntityManager in TypeScript
DESCRIPTION: Demonstrates how to use result caching with the EntityManager's find method. It shows options for setting custom expiration times and cache keys.

LANGUAGE: typescript
CODE:
const res = await em.find(Book, { author: { name: 'Jon Snow' } }, {
  populate: ['author', 'tags'],
  cache: 50, // set expiration to 50ms
  // cache: ['cache-key', 50], // set custom cache key and expiration
  // cache: true, // use default cache key and expiration
});

----------------------------------------

TITLE: Using Dataloader with Reference Properties (TypeScript)
DESCRIPTION: This example demonstrates how to use a dataloader with Reference properties in MikroORM. It shows both the direct method and an alternative using the wrap function to create a reference instance dynamically.

LANGUAGE: typescript
CODE:
book.author.load({ dataloader: true }); // can be also enabled globally
wrap(book.author).toReference().load({ dataloader: true });

----------------------------------------

TITLE: Querying Entities with EntityRepository
DESCRIPTION: Example of using EntityRepository for more convenient entity querying with sorting and pagination

LANGUAGE: typescript
CODE:
const booksRepository = orm.em.getRepository(Book);

// with sorting, limit and offset parameters, populating author references
const books = await booksRepository.find({ author: '...' }, ['author'], { title: QueryOrder.DESC }, 2, 1);

// or with options object
const books = await booksRepository.find({ author: '...' }, {
  populate: ['author'],
  limit: 1,
  offset: 2,
  orderBy: { title: QueryOrder.DESC },
});

console.log(books); // Book[]

----------------------------------------

TITLE: Polymorphic Embeddables Implementation
DESCRIPTION: Demonstrates implementation of polymorphic embeddables using discriminator columns and inheritance with Animal, Cat, and Dog classes.

LANGUAGE: typescript
CODE:
import { Embeddable, Embedded, Entity, Enum, PrimaryKey, Property } from '@mikro-orm/core';

export enum AnimalType {
  CAT,
  DOG,
}

@Embeddable({ abstract: true, discriminatorColumn: 'type' })
export abstract class Animal {

  @Enum(() => AnimalType)
  type!: AnimalType;

  @Property()
  name!: string;

}

@Embeddable({ discriminatorValue: AnimalType.CAT })
export class Cat extends Animal {

  @Property({ nullable: true })
  canMeow?: boolean = true;

  constructor(name: string) {
    super();
    this.type = AnimalType.CAT;
    this.name = name;
  }

}

@Embeddable({ discriminatorValue: AnimalType.DOG })
export class Dog extends Animal {

  @Property({ nullable: true })
  canBark?: boolean = true;

  constructor(name: string) {
    super();
    this.type = AnimalType.DOG;
    this.name = name;
  }

}

@Entity()
export class Owner {

  @PrimaryKey()
  id!: number;

  @Property()
  name!: string;

  @Embedded(() => [Cat, Dog])
  pet!: Cat | Dog;

}

----------------------------------------

TITLE: Implementing OneToMany Relationships in MikroORM
DESCRIPTION: Shows various approaches to define OneToMany relationships, including using Collections and different ways to specify mappings and entity types.

LANGUAGE: typescript
CODE:
@Entity()
export class Author {

  @OneToMany(() => Book, book => book.author)
  books1 = new Collection<Book>(this);

  @OneToMany('Book', 'author')
  books2 = new Collection<Book>(this);

  @OneToMany({ mappedBy: book => book.author })
  books3 = new Collection<Book>(this);

  @OneToMany({ entity: () => Book, mappedBy: 'author', orphanRemoval: true })
  books4 = new Collection<Book>(this);

}

----------------------------------------

TITLE: Implementing Custom Connection Class for MikroORM
DESCRIPTION: This code snippet demonstrates how to create a custom Connection class by extending the base Connection class. It includes methods for managing database connections and executing queries.

LANGUAGE: typescript
CODE:
import { Connection } from '@mikro-orm/core';

export class MyCustomConnection extends Connection {

  // implement abstract methods
  connect(): Promise<void>;
  isConnected(): Promise<boolean>;
  close(force?: boolean): Promise<void>;
  getDefaultClientUrl(): string;
  execute(query: string, params?: any[], method?: 'all' | 'get' | 'run'): Promise<QueryResult | any | any[]>;

}

----------------------------------------

TITLE: Defining Entity Filters in TypeScript with MikroORM
DESCRIPTION: Example of defining filters at the entity level using decorators. Shows different filter types including static conditions, length checks, null checks, and parameterized filters.

LANGUAGE: typescript
CODE:
@Entity()
@Filter({ name: 'expensive', cond: { price: { $gt: 1000 } } })
@Filter({ name: 'long', cond: { 'length(text)': { $gt: 10000 } } })
@Filter({ name: 'hasAuthor', cond: { author: { $ne: null } }, default: true })
@Filter({ name: 'writtenBy', cond: args => ({ author: { name: args.name } }) })
export class Book {
  ...
}

const books1 = await orm.em.find(Book, {}, {
  filters: ['long', 'expensive'],
});
const books2 = await orm.em.find(Book, {}, {
  filters: { hasAuthor: false, long: true, writtenBy: { name: 'God' } },
});

----------------------------------------

TITLE: Defining Collection Properties and Identified References
DESCRIPTION: Demonstrates how to define collection properties and identified references when using ReflectMetadataProvider. Target entity types must be provided explicitly.

LANGUAGE: typescript
CODE:
@OneToMany(() => Book, b => b.author)
books = new Collection<Book>(this);

@ManyToOne(() => Publisher, { ref: true })
publisher!: Ref<Publisher>;

----------------------------------------

TITLE: Defining Entity-Level Filters in TypeScript with MikroORM
DESCRIPTION: Demonstrates how to define filters at the entity level using decorators. Shows basic filter conditions, default filters, and parameterized filters.

LANGUAGE: typescript
CODE:
@Entity()
@Filter({ name: 'expensive', cond: { price: { $gt: 1000 } } })
@Filter({ name: 'long', cond: { 'length(text)': { $gt: 10000 } } })
@Filter({ name: 'hasAuthor', cond: { author: { $ne: null } }, default: true })
@Filter({ name: 'writtenBy', cond: args => ({ author: { name: args.name } }) })
export class Book {
  ...
}

const books1 = await orm.em.find(Book, {}, {
  filters: ['long', 'expensive'],
});
const books2 = await orm.em.find(Book, {}, {
  filters: { hasAuthor: false, long: true, writtenBy: { name: 'God' } },
});

----------------------------------------

TITLE: Initializing TsMorphMetadataProvider in MikroORM
DESCRIPTION: Configuration for using TsMorphMetadataProvider, which uses ts-morph to read TypeScript source files for type detection. Requires @mikro-orm/reflection package.

LANGUAGE: typescript
CODE:
import { TsMorphMetadataProvider } from '@mikro-orm/reflection';

await MikroORM.init({
  metadataProvider: TsMorphMetadataProvider,
  // ...
});

----------------------------------------

TITLE: Configuring Referential Integrity in MikroORM
DESCRIPTION: Example of setting up database-level referential integrity actions using updateRule and deleteRule options in entity relationships.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @ManyToOne({ updateRule: 'set null', deleteRule: 'cascade' })
  author?: Author;

}

----------------------------------------

TITLE: Implementing Single Table Inheritance in TypeScript with MikroORM
DESCRIPTION: This example demonstrates how to set up Single Table Inheritance using TypeScript and MikroORM. It defines a Person base class with discriminator options and an Employee subclass.

LANGUAGE: typescript
CODE:
@Entity({
  discriminatorColumn: 'discr',
  discriminatorMap: { person: 'Person', employee: 'Employee' },
})
export class Person {
  // ...
}

@Entity()
export class Employee extends Person {
  // ...
}

----------------------------------------

TITLE: Implementing Custom Repository Pattern
DESCRIPTION: Example of creating and using custom repositories with MikroORM and NestJS dependency injection.

LANGUAGE: typescript
CODE:
@Entity({ repository: () => AuthorRepository })
export class Author {
  [EntityRepositoryType]?: AuthorRepository;
}

export class AuthorRepository extends EntityRepository<Author> {
  // custom methods
}

@Injectable()
export class MyService {
  constructor(private readonly repo: AuthorRepository) { }
}

----------------------------------------

TITLE: Defining JSON Properties in TypeScript with MikroORM
DESCRIPTION: Demonstrates how to define an entity with a JSON property using MikroORM's @Property decorator and JsonType.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @Property({ type: 'json', nullable: true })
  meta?: { foo: string; bar: number };

}

----------------------------------------

TITLE: Entity Property Type Definition Examples
DESCRIPTION: Examples of properly defining entity properties with explicit types and decorators when using ReflectMetadataProvider.

LANGUAGE: typescript
CODE:
@Property()
createdAt: Date = new Date();

@OneToMany(() => Book, b => b.author)
books = new Collection<Book>(this);

@ManyToOne(() => Publisher, { ref: true })
publisher!: Ref<Publisher>;

@Property({ nullable: true })
prop?: string;

----------------------------------------

TITLE: Configuring Migrator Extension in MikroORM
DESCRIPTION: This snippet shows how to import and register the Migrator extension in the MikroORM configuration file.

LANGUAGE: typescript
CODE:
import { Migrator } from '@mikro-orm/migrations'; // or `@mikro-orm/migrations-mongodb`

export default defineConfig({
  // ...
  extensions: [Migrator],
})

----------------------------------------

TITLE: Implementing Optimistic Locking with Version Field in MikroORM
DESCRIPTION: Shows how to implement optimistic locking using a version field in an entity class with MikroORM.

LANGUAGE: typescript
CODE:
export class User {
  // ...
  @Property({ version: true })
  version!: number;
  // ...
}

----------------------------------------

TITLE: Populating All Relations in MikroORM (TypeScript)
DESCRIPTION: Shows how to populate all relationships using the '*' wildcard. This approach uses the select-in strategy to handle possible cycles.

LANGUAGE: typescript
CODE:
const tags = await em.find(BookTag, {}, {
  populate: ['*'],
});

----------------------------------------

TITLE: Defining ManyToOne Reference with Dataloader Support
DESCRIPTION: Demonstrates how to define a ManyToOne relationship using the Reference wrapper to enable dataloader support.

LANGUAGE: typescript
CODE:
@ManyToOne(() => Book, { ref: true })
book!: Ref<Book>;

----------------------------------------

TITLE: Demonstrating Cascade Persist in MikroORM with TypeScript
DESCRIPTION: This example shows how cascade persist works in MikroORM. It demonstrates updating related entities and persisting changes through the main entity.

LANGUAGE: typescript
CODE:
const book = await orm.em.findOne(Book, 'id', ['author', 'tags']);
book.author.name = 'Foo Bar';
book.tags[0].name = 'new name 1';
book.tags[1].name = 'new name 2';
await orm.em.persistAndFlush(book); // all book tags and author will be persisted too

----------------------------------------

TITLE: Configuring Folder-based Entity Discovery
DESCRIPTION: TypeScript code showing how to configure MikroORM to discover entities using folder patterns.

LANGUAGE: typescript
CODE:
const orm = await MikroORM.init({
  entities: ['./dist/app/**/*.entity.js'],
  entitiesTs: ['./src/app/**/*.entity.ts'],
  // ...
});

----------------------------------------

TITLE: Primary Key Definition using @PrimaryKey
DESCRIPTION: Shows different ways to define primary keys using @PrimaryKey decorator with auto-increment and UUID options.

LANGUAGE: typescript
CODE:
@PrimaryKey()
id!: number; // auto increment PK in SQL drivers

@PrimaryKey({ autoincrement: false })
id!: number; // numeric PK without auto increment

@PrimaryKey()
uuid: string = uuid.v4(); // uuid PK in SQL drivers

@PrimaryKey()
_id!: ObjectId; // ObjectId PK in mongodb driver

----------------------------------------

TITLE: Managing Global Filters in MikroORM
DESCRIPTION: Shows how to register and configure global filters using EntityManager API and ORM configuration.

LANGUAGE: typescript
CODE:
// bound to entity, enabled by default
em.addFilter('writtenBy', args => ({ author: args.id }), Book);

// global, enabled by default, for all entities
em.addFilter('tenant', args => { ... });

// global, enabled by default, for only specified entities
em.addFilter('tenant', args => { ... }, [Author, Book]);
...

// set params (probably in some middleware)
em.setFilterParams('tenant', { tenantId: 123 });
em.setFilterParams('writtenBy', { id: 321 });

----------------------------------------

TITLE: Defining Entities in Multiple Schemas with MikroORM
DESCRIPTION: This snippet demonstrates how to define entities in different schemas using the @Entity decorator. It shows two approaches: using the 'schema' option and specifying the schema in the 'tableName' option.

LANGUAGE: typescript
CODE:
@Entity({ schema: 'first_schema' })
export class Foo { ... }

// or alternatively we can specify it inside custom table name
@Entity({ tableName: 'second_schema.bar' })
export class Bar { ... }

----------------------------------------

TITLE: Custom BigInt Type Mapping in MikroORM
DESCRIPTION: Examples of mapping bigint primary keys to different TypeScript types (bigint, string, and number) using explicit type declarations. Note that mapping to number type has limitations with values larger than Number.MAX_SAFE_INTEGER.

LANGUAGE: typescript
CODE:
@PrimaryKey({ type: new BigIntType('bigint') })
id1: bigint;

@PrimaryKey({ type: new BigIntType('string') })
id2: string;

@PrimaryKey({ type: new BigIntType('number') })
id3: number;

----------------------------------------

TITLE: Entity Relationships in MikroORM
DESCRIPTION: Examples of defining various types of entity relationships using MikroORM decorators including OneToOne, OneToMany, ManyToOne and ManyToMany

LANGUAGE: typescript
CODE:
@ManyToOne()
author1?: Author;

@OneToOne({ inversedBy: 'bestFriend1', orphanRemoval: true })
bestFriend2!: User;

@OneToMany(() => Book, book => book.author)
books1 = new Collection<Book>(this);

@ManyToMany({ entity: () => BookTag, cascade: [], fixedOrderColumn: 'order' })
tags = new Collection<BookTag>(this);

----------------------------------------

TITLE: Importing reflect-metadata for ReflectMetadataProvider
DESCRIPTION: This code shows how to import the reflect-metadata module, which is required when using the ReflectMetadataProvider.

LANGUAGE: typescript
CODE:
import 'reflect-metadata';

----------------------------------------

TITLE: Implementing Complete EventSubscriber Interface
DESCRIPTION: Comprehensive example showing all possible event subscriber methods including entity lifecycle, flush, and transaction events.

LANGUAGE: typescript
CODE:
import { EventArgs, TransactionEventArgs, EventSubscriber } from '@mikro-orm/core';

export class EverythingSubscriber implements EventSubscriber {

  // entity life cycle events
  onInit<T>(args: EventArgs<T>): void { ... }
  async onLoad<T>(args: EventArgs<T>): Promise<void> { ... }
  async beforeCreate<T>(args: EventArgs<T>): Promise<void> { ... }
  async afterCreate<T>(args: EventArgs<T>): Promise<void> { ... }
  async beforeUpdate<T>(args: EventArgs<T>): Promise<void> { ... }
  async afterUpdate<T>(args: EventArgs<T>): Promise<void> { ... }
  async beforeUpsert<T>(args: EventArgs<T>): Promise<void> { ... }
  async afterUpsert<T>(args: EventArgs<T>): Promise<void> { ... }
  async beforeDelete<T>(args: EventArgs<T>): Promise<void> { ... }
  async afterDelete<T>(args: EventArgs<T>): Promise<void> { ... }

  // flush events
  async beforeFlush<T>(args: FlushEventArgs): Promise<void> { ... }
  async onFlush<T>(args: FlushEventArgs): Promise<void> { ... }
  async afterFlush<T>(args: FlushEventArgs): Promise<void> { ... }

  // transaction events
  async beforeTransactionStart(args: TransactionEventArgs): Promise<void> { ... }
  async afterTransactionStart(args: TransactionEventArgs): Promise<void> { ... }
  async beforeTransactionCommit(args: TransactionEventArgs): Promise<void> { ... }
  async afterTransactionCommit(args: TransactionEventArgs): Promise<void> { ... }
  async beforeTransactionRollback(args: TransactionEventArgs): Promise<void> { ... }
  async afterTransactionRollback(args: TransactionEventArgs): Promise<void> { ... }

}

----------------------------------------

TITLE: Repository Type Inference in MikroORM
DESCRIPTION: Shows how to properly type custom repositories using EntityRepositoryType symbol for better type inference.

LANGUAGE: typescript
CODE:
@Entity({ repository: () => AuthorRepository })
export class Author {

  [EntityRepositoryType]?: AuthorRepository;

}

const repo = em.getRepository(Author); // repo has type AuthorRepository

----------------------------------------

TITLE: Defining Entities with Relationships in TypeScript using MikroORM
DESCRIPTION: This snippet demonstrates how to define Author and Book entities with a one-to-many relationship using MikroORM decorators.

LANGUAGE: typescript
CODE:
import { Entity, LoadStrategy, OneToMany, ManyToOne, PrimaryKey } from '@mikro-orm/core';

@Entity()
export class Author {

  @PrimaryKey()
  id!: number;

  @OneToMany(() => Book, b => b.author)
  books = new Collection<Book>(this);

}

@Entity()
export class Book {

  @PrimaryKey()
  id!: number;

  @ManyToOne()
  author: Author;

}

----------------------------------------

TITLE: Working with Entity References
DESCRIPTION: Demonstrates working with entity references for handling relationships without loading full entities. Shows reference creation and common operations.

LANGUAGE: typescript
CODE:
const userRef = em.getReference(User, 1);
console.log(userRef);

// setting relation properties
author.favouriteBook = em.getReference(Book, 1);

// removing entity by reference
em.remove(em.getReference(Book, 2));

// adding entity to collection by reference
author.books.add(em.getReference(Book, 3));

----------------------------------------

TITLE: Disabling Metadata Cache in MikroORM Configuration
DESCRIPTION: This snippet demonstrates how to disable metadata caching when initializing MikroORM. It sets the 'enabled' property of the 'metadataCache' option to false.

LANGUAGE: typescript
CODE:
await MikroORM.init({
  metadataCache: { enabled: false },
  // ...
});

----------------------------------------

TITLE: Using MikroORM CLI for Schema Operations
DESCRIPTION: CLI commands for creating, updating, and dropping database schemas using MikroORM. These commands can dump SQL or execute queries directly.

LANGUAGE: shell
CODE:
npx mikro-orm schema:create --dump   # Dumps create schema SQL
npx mikro-orm schema:update --dump   # Dumps update schema SQL
npx mikro-orm schema:drop --dump     # Dumps drop schema SQL

----------------------------------------

TITLE: Using Dataloader with Reference Properties (TypeScript)
DESCRIPTION: This example demonstrates how to use a dataloader with Reference properties. It shows both the direct method and an alternative using the wrap function to create a reference instance dynamically.

LANGUAGE: typescript
CODE:
book.author.load({ dataloader: true }); // can be also enabled globally
wrap(book.author).toReference().load({ dataloader: true });

----------------------------------------

TITLE: Defining Book Entity with EntitySchema
DESCRIPTION: Example of defining a Book entity using EntitySchema

LANGUAGE: typescript
CODE:
export interface IBook extends CustomBaseEntity {
  title: string;
  author: Author;
  publisher?: Ref<Publisher>;
  tags: Collection<BookTag>;
}

export const Book = new EntitySchema<IBook, CustomBaseEntity>({
  name: 'Book',
  extends: 'CustomBaseEntity',
  properties: {
    title: { type: 'string' },
    author: { kind: 'm:1', entity: 'Author' },
    publisher: { kind: 'm:1', entity: 'Publisher', ref: true, nullable: true },
    tags: { kind: 'm:n', entity: 'BookTag', fixedOrder: true },
  },
});

----------------------------------------

TITLE: Basic Migration Class Implementation
DESCRIPTION: Example of a basic migration class extending the Migration abstract class. Shows implementation of the up() method for schema changes.

LANGUAGE: typescript
CODE:
import { Migration } from '@mikro-orm/migrations';

export class Migration20191019195930 extends Migration {

  async up(): Promise<void> {
    this.addSql('select 1 + 1');
  }

}

----------------------------------------

TITLE: Configuring MikroORM Migrations Extension
DESCRIPTION: Basic configuration setup for enabling migrations in MikroORM by importing and registering the Migrator extension.

LANGUAGE: typescript
CODE:
import { Migrator } from '@mikro-orm/migrations'; // or `@mikro-orm/migrations-mongodb`

export default defineConfig({
  // ...
  extensions: [Migrator],
})

----------------------------------------

TITLE: Querying MongoDB Entities with ObjectId and String ID in TypeScript
DESCRIPTION: Demonstrates how to query MongoDB entities using both ObjectId and string ID formats.

LANGUAGE: typescript
CODE:
const author = orm.em.getReference('...id...');
console.log(author.id);  // returns '...id...'
console.log(author._id); // returns ObjectId('...id...')

// all of those will return the same results
const article = '...article id...'; // string id
const book = '...book id...'; // string id
const repo = orm.em.getRepository(Author);
const foo1 = await repo.find({ id: { $in: [article] }, favouriteBook: book });
const bar1 = await repo.find({ id: { $in: [new ObjectId(article)] }, favouriteBook: new ObjectId(book) });
const foo2 = await repo.find({ _id: { $in: [article] }, favouriteBook: book });
const bar2 = await repo.find({ _id: { $in: [new ObjectId(article)] }, favouriteBook: new ObjectId(book) });

----------------------------------------

TITLE: Using SQL Tagged Templates in MikroORM
DESCRIPTION: Shows how to use sql tagged template function for raw SQL fragments, supporting string interpolation and various usage patterns.

LANGUAGE: typescript
CODE:
// as a value
await em.find(User, { time: sql`now()` });

// as a key
await em.find(User, { [sql`lower(name)`]: name.toLowerCase() });

// value can be empty array
await em.find(User, { [sql`(select ${1} = ${1})`]: [] });

----------------------------------------

TITLE: Defining Nullable Property with Explicit Null in MikroORM
DESCRIPTION: This example shows how to define a nullable property with an explicit null value. The property type is set to 'string | null', and a default value of null is provided.

LANGUAGE: typescript
CODE:
@Property({ type: 'string', nullable: true })
name: string | null = null;

----------------------------------------

TITLE: Using QueryBuilder with Composite Keys in MikroORM
DESCRIPTION: This snippet demonstrates how to use QueryBuilder with entities that have composite primary keys in MikroORM, showing different ways to construct queries.

LANGUAGE: typescript
CODE:
const qb1 = em.createQueryBuilder(CarOwner);
qb1.select('*').where({ car: { name: 'Audi A8', year: 2010 } });
console.log(qb1.getQuery());  // select `e0`.* from `car_owner` as `e0` where `e0`.`name` = ? and `e0`.`year` = ?

const qb2 = em.createQueryBuilder(CarOwner);
qb2.select('*').where({ car: ['Audi A8', 2010] });
console.log(qb2.getQuery());  // 'select `e0`.* from `car_owner` as `e0` where (`e0`.`car_name`, `e0`.`car_year`) = (?, ?)'

const qb3 = em.createQueryBuilder(CarOwner);
qb3.select('*').where({ car: [['Audi A8', 2010]] });
console.log(qb3.getQuery());  // 'select `e0`.* from `car_owner` as `e0` where (`e0`.`car_name`, `e0`.`car_year`) in ((?, ?))'

const ref = em.getReference(Car, ['Audi A8', 2010]);
console.log(ref instanceof Car); // true

----------------------------------------

TITLE: Initializing MikroORM with PostgreSQL Driver
DESCRIPTION: Example of initializing MikroORM with the PostgreSQL driver, specifying entities and database name.

LANGUAGE: typescript
CODE:
import { MikroORM } from '@mikro-orm/postgresql'; // or any other SQL driver package

const orm = await MikroORM.init({
  entities: ['./dist/entities'], // path to your JS entities (dist), relative to `baseDir`
  dbName: 'my-db-name',
});
console.log(orm.em); // access EntityManager via `em` property

----------------------------------------

TITLE: Demonstrating Cascade Persist in MikroORM
DESCRIPTION: This example shows how cascade persist works in MikroORM. It demonstrates that changes to related entities (author and tags) are automatically persisted when the main entity (book) is persisted.

LANGUAGE: typescript
CODE:
const book = await orm.em.findOne(Book, 'id', { populate: ['author', 'tags'] });
book.author.name = 'Foo Bar';
book.tags[0].name = 'new name 1';
book.tags[1].name = 'new name 2';
await orm.em.persist(book).flush(); // all book tags and author will be persisted too

----------------------------------------

TITLE: Entity Property Type Definitions with ReflectMetadataProvider
DESCRIPTION: Examples of proper type definitions when using ReflectMetadataProvider, including collections, references, optional properties, and enums.

LANGUAGE: typescript
CODE:
@Property()
createdAt: Date = new Date();

@OneToMany(() => Book, b => b.author)
books = new Collection<Book>(this);

@ManyToOne(() => Publisher, { ref: true })
publisher!: Ref<Publisher>;

@Property({ nullable: true })
prop?: string;

@Enum(() => UserRole)
role: UserRole;

@Enum({ type: 'UserRole' })
role: UserRole;

@Enum({ items: ['a', 'b', 'c'] })
role: UserRole;

@ManyToOne({ entity: () => Author })
author: Author;

----------------------------------------

TITLE: Configuring Orphan Removal in MikroORM Entity Relationships
DESCRIPTION: This example demonstrates how to configure orphan removal for a OneToMany relationship in MikroORM. Orphan removal is a more aggressive form of remove cascading that removes entities when they are disconnected from the collection.

LANGUAGE: typescript
CODE:
@Entity()
export class Author {

  @OneToMany({ entity: () => Book, mappedBy: 'author', orphanRemoval: true })
  books = new Collection<Book>(this);

}

----------------------------------------

TITLE: Configuring MikroORM CLI in package.json
DESCRIPTION: JSON configuration for MikroORM CLI in package.json, specifying config file paths.

LANGUAGE: json
CODE:
{
  "name": "your-app",
  "dependencies": { ... },
  "mikro-orm": {
    "configPaths": [
      "./src/mikro-orm.config.ts",
      "./dist/mikro-orm.config.js"
    ]
  }
}

----------------------------------------

TITLE: Implementing Custom Logger Class in MikroORM (TypeScript)
DESCRIPTION: Shows how to create a custom logger class by extending DefaultLogger and using it in MikroORM configuration.

LANGUAGE: typescript
CODE:
class CustomLogger extends DefaultLogger {
  log(namespace: LoggerNamespace, message: string, context?: LogContext) {
    // Create your own implementation for output:
    console.log(`[${namespace}] (${context.label}) ${message}`);

    // OR Utilize DefaultLogger's implementation:
    super.log(namespace, message, context)
  }
}

return MikroORM.init({
  debug: true,
  loggerFactory: (options) => new CustomLogger(options),
});

----------------------------------------

TITLE: Basic Migration Class Implementation
DESCRIPTION: Example of a basic migration class extending the Migration abstract class. Shows implementation of the up() method for schema changes.

LANGUAGE: typescript
CODE:
import { Migration } from '@mikro-orm/migrations';

export class Migration20191019195930 extends Migration {

  async up(): Promise<void> {
    this.addSql('select 1 + 1');
  }

}

----------------------------------------

TITLE: Demonstrating Cascade Remove in MikroORM
DESCRIPTION: Illustrates how cascade remove works in MikroORM, showing that related entities can be removed when the main entity is removed.

LANGUAGE: typescript
CODE:
await orm.em.remove(book).flush(); // this will also remove book.publisher

----------------------------------------

TITLE: Inferring Populate Hint from Filter in MikroORM (TypeScript)
DESCRIPTION: Demonstrates how to automatically select all relations that are part of the filter query using '$infer'. This feature is not available in the MongoDB driver.

LANGUAGE: typescript
CODE:
const tags = await em.find(BookTag, {
  books: { author: { name: '...' } },
}, {
  populate: ['$infer'],
});

----------------------------------------

TITLE: Locking Support in QueryBuilder with MikroORM
DESCRIPTION: This example shows how to use locking support in QueryBuilder. It demonstrates setting a pessimistic read lock on a query, which is useful for ensuring data consistency in concurrent operations.

LANGUAGE: typescript
CODE:
const qb = orm.em.createQueryBuilder(Test);
qb.select('*').where({ name: 'Lol 321' }).setLockMode(LockMode.PESSIMISTIC_READ);

console.log(qb.getQuery()); // for MySQL
// select `e0`.* from `test` as `e0` where `e0`.`name` = ? lock in share mode

----------------------------------------

TITLE: Forking Entity Manager in MikroORM (TypeScript)
DESCRIPTION: This snippet shows how to create a new entity manager with its own context and identity map using the fork() method. This is useful for isolating operations within a specific context.

LANGUAGE: typescript
CODE:
const em = orm.em.fork();

----------------------------------------

TITLE: Refreshing and Seeding Database Schema in MikroORM
DESCRIPTION: Commands for dropping and recreating the database schema, with an option to seed the database afterward. Allows specifying a custom seeder.

LANGUAGE: sh
CODE:
npx mikro-orm schema:fresh --run     # !WARNING! Drops the database schema and recreates it

LANGUAGE: sh
CODE:
npx mikro-orm schema:fresh --run --seed              # seed the database with the default database seeder
npx mikro-orm schema:fresh --run --seed=UsersSeeder  # seed the database with the UsersSeeder

----------------------------------------

TITLE: Creating Parameterless Filters in MikroORM
DESCRIPTION: This snippet shows how to create a filter without parameters but with access to the operation type. It uses the 'args: false' option to indicate no arguments are required.

LANGUAGE: typescript
CODE:
@Filter({
  name: 'withoutParams',
  cond(_, type) {
    return { ... };
  },
  args: false,
  default: true,
})

----------------------------------------

TITLE: Overriding Populate Behavior per Query in MikroORM (TypeScript)
DESCRIPTION: Illustrates how to override the global populate behavior on a per-query basis using the 'populateWhere' option. This allows for fine-grained control over how relations are populated.

LANGUAGE: typescript
CODE:
const books = await em.find(Book, { tags: { name: 'Fiction' } }, {
  populate: ['tags'],
  populateWhere: PopulateHint.INFER,
});

----------------------------------------

TITLE: Configuring Migrator Extension in MikroORM
DESCRIPTION: This snippet shows how to configure the Migrator extension in the MikroORM configuration file. It demonstrates importing the Migrator from the appropriate package and adding it to the extensions array.

LANGUAGE: typescript
CODE:
import { Migrator } from '@mikro-orm/migrations'; // or `@mikro-orm/migrations-mongodb`

export default defineConfig({
  // ...
  extensions: [Migrator],
})

----------------------------------------

TITLE: Initializing TsMorphMetadataProvider in MikroORM
DESCRIPTION: Configuration example showing how to use TsMorphMetadataProvider for TypeScript type discovery using ts-morph. Requires @mikro-orm/reflection package.

LANGUAGE: typescript
CODE:
import { TsMorphMetadataProvider } from '@mikro-orm/reflection';

await MikroORM.init({
  metadataProvider: TsMorphMetadataProvider,
  // ...
});

----------------------------------------

TITLE: Implicit Transaction Handling in TypeScript
DESCRIPTION: Demonstrates MikroORM's automatic transaction management when persisting and flushing changes.

LANGUAGE: typescript
CODE:
const user = await em.findOne(User, 1);
user.email = 'foo@bar.com';
const car = new Car();
user.cars.add(car);

// thanks to bi-directional cascading we only need to persist user entity
// flushing will create a transaction, insert new car and update user with new email
await em.persist(user).flush();

----------------------------------------

TITLE: Enabling Dataloaders Globally in MikroORM (TypeScript)
DESCRIPTION: This snippet demonstrates how to enable dataloaders globally in MikroORM initialization. It uses the DataloaderType enum to specify which types of relations should use dataloaders.

LANGUAGE: typescript
CODE:
import { DataloaderType } from '@mikro-orm/core';

MikroORM.init({
  dataloader: DataloaderType.ALL,
});

----------------------------------------

TITLE: Using Migrator Programmatically in MikroORM
DESCRIPTION: This code snippet demonstrates how to use the Migrator programmatically in MikroORM. It shows initialization of MikroORM with the Migrator extension and various migration operations.

LANGUAGE: typescript
CODE:
import { MikroORM } from '@mikro-orm/core';
import { Migrator } from '@mikro-orm/migrations';

(async () => {
  const orm = await MikroORM.init({
    extensions: [Migrator],
    dbName: 'your-db-name',
    // ...
  });

  const migrator = orm.getMigrator();
  await migrator.createMigration(); // creates file Migration20191019195930.ts
  await migrator.up(); // runs migrations up to the latest
  await migrator.up('name'); // runs only given migration, up
  await migrator.up({ to: 'up-to-name' }); // runs migrations up to given version
  await migrator.down(); // migrates one step down
  await migrator.down('name'); // runs only given migration, down
  await migrator.down({ to: 'down-to-name' }); // runs migrations down to given version
  await migrator.down({ to: 0 }); // migrates down to the first version

  await orm.close(true);
})();

----------------------------------------

TITLE: Folder-based Entity Discovery Configuration
DESCRIPTION: Demonstrates how to configure entity discovery using file paths with support for both compiled JS and TypeScript source files.

LANGUAGE: typescript
CODE:
MikroORM.init({
  entities: ['./dist/modules/users/entities', './dist/modules/projects/entities'],
  entitiesTs: ['./src/modules/users/entities', './src/modules/projects/entities'],
  // optionally you can override the base directory (defaults to `process.cwd()`)
  baseDir: process.cwd(),
});

----------------------------------------

TITLE: Working with Collections in TypeScript using MikroORM
DESCRIPTION: This snippet demonstrates various operations on Collections including initialization, iteration, adding/removing items, and using helper methods like contains, exists, find, map, and filter.

LANGUAGE: typescript
CODE:
const author = em.findOne(Author, '...', { populate: ['books'] }); // populating books collection

// or we could lazy load books collection later via `init()` method
await author.books.init();

for (const book of author.books) {
  console.log(book.title); // initialized
  console.log(book.author.isInitialized()); // true
  console.log(book.author.id);
  console.log(book.author.name); // Jon Snow
  console.log(book.publisher); // just reference
  console.log(book.publisher.isInitialized()); // false
  console.log(book.publisher.id);
  console.log(book.publisher.name); // undefined
}

// collection needs to be initialized before we can work with it
author.books.add(book);
console.log(author.books.contains(book)); // true
console.log(author.books.exists(item => item === book)); // true
console.log(author.books.find(item => item === book)); // book
console.log(author.books.map(item => item.title)); // array of book titles
console.log(author.books.filter(item => item.title.startsWith('Foo'))); // array of books matching the callback
author.books.remove(book);
console.log(author.books.contains(book)); // false
author.books.add(book);
console.log(author.books.count()); // 1
console.log(author.books.slice(0, 1)); // Book[]
console.log(author.books.slice()); // Book[]
console.log(author.books.slice().length); // 1
author.books.removeAll();
console.log(author.books.isEmpty()); // true
console.log(author.books.contains(book)); // false
console.log(author.books.count()); // 0
console.log(author.books.getItems()); // Book[]
console.log(author.books.getIdentifiers()); // array of string | number
console.log(author.books.getIdentifiers('_id')); // array of ObjectId

// array access works as well
console.log(author.books[1]); // Book
console.log(author.books[12345]); // undefined, even if the collection is not initialized

// getting array of the items
console.log(author.books.getItems()); // Book[]

// serializing the collection
console.log(author.books.toArray()); // EntityDTO<Book>[]

const author = em.findOne(Author, '...'); // books collection has not been populated
const count = await author.books.loadCount(); // gets the count of collection items from database instead of counting loaded items
console.log(author.books.getItems()); // throws because the collection has not been initialized
// initialize collection if not already loaded and return its items as array
console.log(await author.books.loadItems()); // Book[]

----------------------------------------

TITLE: Using @CreateRequestContext Decorator in MikroORM (TypeScript)
DESCRIPTION: This code demonstrates how to use the @CreateRequestContext decorator to ensure a method is executed within a new request context.

LANGUAGE: typescript
CODE:
export class MyService {

  constructor(private readonly orm: MikroORM) { }

  @CreateRequestContext()
  async doSomething() {
    // this will be executed in a separate context
  }

}

----------------------------------------

TITLE: Defining Basic Embeddables in TypeScript with MikroORM
DESCRIPTION: Shows how to define a basic Address embeddable and use it in a User entity using TypeScript decorators with MikroORM.

LANGUAGE: typescript
CODE:
import { Embeddable, Embedded, Entity, PrimaryKey, Property } from '@mikro-orm/core';

@Embeddable()
export class Address {

  @Property()
  street!: string;

  @Property()
  postalCode!: string;

  @Property()
  city!: string;

  @Property()
  country!: string;

}

@Entity()
export class User {

  @PrimaryKey()
  id!: number;

  @Embedded(() => Address)
  address!: Address;

}

----------------------------------------

TITLE: Accessing Reference Properties in MikroORM
DESCRIPTION: Demonstrates how to access properties of a Reference wrapper and load the underlying entity in MikroORM.

LANGUAGE: typescript
CODE:
const book1 = await em.findOne(Book, 1);
book.author instanceof Reference; // true
book1.author; // Ref<Author> (instance of `Reference` class)
book1.author.name; // type error, there is no `name` property
book1.author.unwrap().name; // unsafe sync access, undefined as author is not loaded
book1.author.isInitialized(); // false

const book2 = await em.findOne(Book, 1, { populate: ['author'] });
book2.author; // LoadedReference<Author> (instance of `Reference` class)
book2.author.$.name; // type-safe sync access

----------------------------------------

TITLE: Cascading Persist Operations in MikroORM
DESCRIPTION: Shows how to persist multiple related entities with automatic cascading. The example creates an author, publisher, and multiple books, demonstrating that persisting the books automatically cascades to the related entities.

LANGUAGE: typescript
CODE:
const author = new Author('Jon Snow', 'snow@wall.st');
author.born = new Date();

const publisher = new Publisher('7K publisher');

const book1 = new Book('My Life on The Wall, part 1', author);
book1.publisher = publisher;
const book2 = new Book('My Life on The Wall, part 2', author);
book2.publisher = publisher;
const book3 = new Book('My Life on The Wall, part 3', author);
book3.publisher = publisher;

// just persist books, author and publisher will be automatically cascade persisted
await em.persist([book1, book2, book3]).flush();

// or one by one
em.persist(book1);
em.persist(book2);
em.persist(book3);
await em.flush(); // flush everything to database at once

----------------------------------------

TITLE: Filtering and Ordering MikroORM Collections in TypeScript
DESCRIPTION: Demonstrates how to filter and order items when initializing a collection in MikroORM. Shows the usage of 'where' and 'orderBy' options during collection initialization.

LANGUAGE: typescript
CODE:
await book.tags.init({ where: { active: true }, orderBy: { name: QueryOrder.DESC } });

----------------------------------------

TITLE: Using @CreateRequestContext Decorator in MikroORM (TypeScript)
DESCRIPTION: This code demonstrates how to use the @CreateRequestContext decorator to ensure a method is executed within a new request context.

LANGUAGE: typescript
CODE:
export class MyService {

  constructor(private readonly orm: MikroORM) { }

  @CreateRequestContext()
  async doSomething() {
    // this will be executed in a separate context
  }

}

----------------------------------------

TITLE: Basic Entity Persistence in MikroORM
DESCRIPTION: Demonstrates how to persist and update entities using EntityManager's persist() and flush() methods. Shows handling of both new and existing entities.

LANGUAGE: typescript
CODE:
const book = await em.findOne(Book, 1);
book.title = 'How to persist things...';

// no need to persist `book` as its already managed by the EM
await em.flush();

----------------------------------------

TITLE: Querying Entities with EntityRepository
DESCRIPTION: Example of querying entities using MikroORM's EntityRepository, including advanced query options like population, pagination, and ordering.

LANGUAGE: typescript
CODE:
const booksRepository = em.getRepository(Book);

const books = await booksRepository.find({ author: '...' }, {
  populate: ['author'],
  limit: 1,
  offset: 2,
  orderBy: { title: QueryOrder.DESC },
});

console.log(books); // Book[]

----------------------------------------

TITLE: Dynamic Attributes Implementation with Composite Keys
DESCRIPTION: Demonstrates how to implement dynamic attributes for an Article entity using composite keys. Shows relationship between Article and ArticleAttribute entities where the primary key is composed of the article reference and attribute name.

LANGUAGE: typescript
CODE:
@Entity()
export class Article {

  @PrimaryKey()
  id!: number;

  @Property()
  title!: string;

  @OneToMany(() => ArticleAttribute, attr => attr.article, { cascade: Cascade.ALL })
  attributes = new Collection<ArticleAttribute>(this);

}

@Entity()
export class ArticleAttribute {

  @ManyToOne({ primary: true })
  article: Article;

  @PrimaryKey()
  attribute: string;

  @Property()
  value!: string;

  [PrimaryKeyProp]?: ['article', 'attribute'];

  constructor(name: string, value: string, article: Article) {
    this.attribute = name;
    this.value = value;
    this.article = article;
  }

}

----------------------------------------

TITLE: Implementing Concurrency Checks in MikroORM
DESCRIPTION: Shows how to implement concurrency checks on specific properties of an entity in MikroORM.

LANGUAGE: typescript
CODE:
@Entity()
export class ConcurrencyCheckUser {

  // all primary keys are by default part of the concurrency check
  @PrimaryKey({ length: 100 })
  firstName: string;

  // all primary keys are by default part of the concurrency check
  @PrimaryKey({ length: 100 })
  lastName: string;

  @Property({ concurrencyCheck: true })
  age: number;

  @Property({ nullable: true })
  other?: string;

}

----------------------------------------

TITLE: Implementing PointType for Spatial Data in MikroORM
DESCRIPTION: This advanced example demonstrates creating a custom PointType for handling spatial data. It includes methods for converting between database and JavaScript representations, as well as SQL conversion methods.

LANGUAGE: typescript
CODE:
export class PointType extends Type<Point | undefined, string | undefined> {

  convertToDatabaseValue(value: Point | undefined): string | undefined {
    if (!value) {
      return value;
    }

    return `point(${value.latitude} ${value.longitude})`;
  }

  convertToJSValue(value: string | undefined): Point | undefined {
    const m = value?.match(/point\((-?\d+(\.\d+)?) (-?\d+(\.\d+)?)\)/i);

    if (!m) {
      return undefined;
    }

    return new Point(+m[1], +m[3]);
  }

  convertToJSValueSQL(key: string) {
    return `ST_AsText(${key})`;
  }

  convertToDatabaseValueSQL(key: string) {
    return `ST_PointFromText(${key})`;
  }

  getColumnType(): string {
    return 'point';
  }

}

----------------------------------------

TITLE: Defining Custom Repository for NestJS Entity
DESCRIPTION: Example of defining a custom repository for a NestJS entity and using it without @InjectRepository() decorator.

LANGUAGE: typescript
CODE:
// author.entity.ts
@Entity({ repository: () => AuthorRepository })
export class Author {

  // to allow inference in `em.getRepository()`
  [EntityRepositoryType]?: AuthorRepository;

}

// author.repository.ts
import { EntityRepository } from '@mikro-orm/mysql'; // Import EntityManager from your driver package or `@mikro-orm/knex`

export class AuthorRepository extends EntityRepository<Author> {

  // your custom methods...

}

// service using custom repository
@Injectable()
export class MyService {

  constructor(private readonly repo: AuthorRepository) { }

}

----------------------------------------

TITLE: Pessimistic Locking in MikroORM
DESCRIPTION: Demonstrates how to use pessimistic locking with table aliases in MikroORM. This example shows a find operation with a pessimistic read lock on a specific table alias.

LANGUAGE: typescript
CODE:
const res = await em.find(User, { name: 'Jon' }, {
  populate: ['identities'],
  strategy: LoadStrategy.JOINED,
  lockMode: LockMode.PESSIMISTIC_READ,
  lockTableAliases: ['u0'],
});

----------------------------------------

TITLE: Enabling Dataloaders Globally in MikroORM (TypeScript)
DESCRIPTION: This snippet demonstrates how to enable dataloaders globally in MikroORM initialization. It uses the DataloaderType enum to specify which types of relations should use dataloaders.

LANGUAGE: typescript
CODE:
import { DataloaderType } from '@mikro-orm/core';

MikroORM.init({
  dataloader: DataloaderType.ALL,
});

----------------------------------------

TITLE: Entity Factory Implementation
DESCRIPTION: Example of creating an entity factory for generating test data using faker library.

LANGUAGE: typescript
CODE:
import { Factory } from '@mikro-orm/seeder';
import { faker } from '@faker-js/faker';
import { Author } from './entities/author.entity';

export class AuthorFactory extends Factory<Author> {
  model = Author;

  definition(): Partial<Author> {
    return {
      name: faker.person.findName(),
      email: faker.internet.email(),
      age: faker.random.number(18, 99),
    };
  }
}

----------------------------------------

TITLE: Implicit Transaction Handling in MikroORM
DESCRIPTION: Demonstrates implicit transaction handling using MikroORM's EntityManager. The flush() method automatically begins and commits/rollbacks a transaction.

LANGUAGE: typescript
CODE:
const user = new User(...);
user.name = 'George';
await orm.em.persist(user).flush();

----------------------------------------

TITLE: Configuring MikroORM Seeders for Production
DESCRIPTION: Shows how to configure MikroORM to use compiled seeder files in production environments.

LANGUAGE: typescript
CODE:
import { MikroORM, Utils } from '@mikro-orm/core';

await MikroORM.init({
  seeder: {
    path: 'dist/seeders',
    pathTs: 'src/seeders',
  },
  // or alternatively
  // seeder: {
  //   path: Utils.detectTsNode() ? 'src/seeders' : 'dist/seeders',
  // },
  // ...
});

----------------------------------------

TITLE: Using @CreateRequestContext Decorator in MikroORM (TypeScript)
DESCRIPTION: This code demonstrates how to use the @CreateRequestContext decorator to ensure a method is executed within a new request context.

LANGUAGE: typescript
CODE:
export class MyService {

  constructor(private readonly orm: MikroORM) { }

  @CreateRequestContext()
  async doSomething() {
    // this will be executed in a separate context
  }

}

----------------------------------------

TITLE: Using SQLite Extensions in MikroORM
DESCRIPTION: Example of loading SQLite extensions like sqlean in MikroORM by providing a pool.afterCreate handler in the initialization options.

LANGUAGE: typescript
CODE:
const orm = await MikroORM.init({
  // ...
  pool: {
    afterCreate: (conn: any, done: any) => {
      conn.loadExtension('/.../sqlean-macos-arm64/sqlean');
      done(null, conn);
    },
  },
});

----------------------------------------

TITLE: Configuring MikroORM Migrations
DESCRIPTION: This snippet shows the default configuration options for MikroORM migrations. It includes settings for table names, file paths, transaction handling, and more.

LANGUAGE: typescript
CODE:
await MikroORM.init({
  // default values:
  migrations: {
    tableName: 'mikro_orm_migrations', // name of database table with log of executed transactions
    path: './migrations', // path to the folder with migrations
    pathTs: undefined, // path to the folder with TS migrations (if used, you should put path to compiled files in `path`)
    glob: '!(*.d).{js,ts}', // how to match migration files (all .js and .ts files, but not .d.ts)
    transactional: true, // wrap each migration in a transaction
    disableForeignKeys: true, // wrap statements with `set foreign_key_checks = 0` or equivalent
    allOrNothing: true, // wrap all migrations in master transaction
    dropTables: true, // allow to disable table dropping
    safe: false, // allow to disable table and column dropping
    snapshot: true, // save snapshot when creating new migrations
    emit: 'ts', // migration generation mode
    generator: TSMigrationGenerator, // migration generator, e.g. to allow custom formatting
  },
})

----------------------------------------

TITLE: Configuring OneToOne Relationships (Owning Side) in MikroORM
DESCRIPTION: Demonstrates how to define the owning side of OneToOne relationships, including self-referencing relationships and explicit owner marking.

LANGUAGE: typescript
CODE:
@Entity()
export class User {

  @OneToOne()
  bestFriend1!: User;

  @OneToOne({ inversedBy: 'bestFriend1' })
  bestFriend2!: User;

  @OneToOne(() => User, user => user.bestFriend2, { owner: true })
  bestFriend3!: User;

}

----------------------------------------

TITLE: Using Entity Factories in MikroORM Seeders
DESCRIPTION: Demonstrates how to use entity factories within a seeder to generate multiple entities efficiently.

LANGUAGE: typescript
CODE:
import { EntityManager } from '@mikro-orm/core';
import { Seeder } from '@mikro-orm/seeder';
import { AuthorFactory } from '../factories/author.factory'

export class DatabaseSeeder extends Seeder {

  async run(em: EntityManager): Promise<void> {
    new AuthorFactory(em).make(10);
  }
}

----------------------------------------

TITLE: Connection Configuration with Read Replicas
DESCRIPTION: Demonstrates how to configure master and read replica database connections.

LANGUAGE: typescript
CODE:
MikroORM.init({
  dbName: 'my_db_name',
  user: 'write-user',
  host: 'master.db.example.com',
  port: 3306,
  replicas: [
    { user: 'read-user-1', host: 'read-1.db.example.com', port: 3307 },
    { user: 'read-user-2', host: 'read-2.db.example.com', port: 3308 },
    { user: 'read-user-3', host: 'read-3.db.example.com', port: 3309 },
  ],
});

----------------------------------------

TITLE: Demonstrating Identity Map in MikroORM with TypeScript
DESCRIPTION: This snippet shows how MikroORM's Identity Map optimizes database queries by returning the same instance for repeated requests of an entity with the same ID.

LANGUAGE: typescript
CODE:
const authorRepository = orm.em.getRepository(Author);
const jon1 = await authorRepository.findOne(1);
const jon2 = await authorRepository.findOne(1);

// identity map in action
console.log(jon1 === jon2); // true

----------------------------------------

TITLE: Registering EventSubscribers in MikroORM Configuration
DESCRIPTION: Example of how to register EventSubscriber instances in the MikroORM configuration during initialization.

LANGUAGE: typescript
CODE:
MikroORM.init({
  subscribers: [new AuthorSubscriber()],
});

----------------------------------------

TITLE: Using assign() on Unmanaged Entities in TypeScript
DESCRIPTION: Demonstrates how to use assign() on entities not managed by EntityManager by providing the EM instance explicitly.

LANGUAGE: typescript
CODE:
import { wrap } from '@mikro-orm/core';

const book = new Book();
wrap(book).assign({
  title: 'Better Book 1',
  author: '...id...',
}, { em });

----------------------------------------

TITLE: Setting up ReflectMetadataProvider with reflect-metadata
DESCRIPTION: Example showing how to import reflect-metadata and initialize MikroORM with ReflectMetadataProvider for type metadata handling.

LANGUAGE: typescript
CODE:
import 'reflect-metadata';

await MikroORM.init({
  metadataProvider: ReflectMetadataProvider,
  // ...
});

----------------------------------------

TITLE: Using assign() Helper in MikroORM
DESCRIPTION: Shows how to use the assign() helper method to update entity properties including references.

LANGUAGE: typescript
CODE:
import { wrap } from '@mikro-orm/core';

wrap(book).assign({
  title: 'Better Book 1',
  author: '...id...',
});
console.log(book.title); // 'Better Book 1'
console.log(book.author); // instance of Author with id: '...id...'
console.log(book.author.id); // '...id...'

----------------------------------------

TITLE: Basic Entity Configuration
DESCRIPTION: Demonstrates how to configure MikroORM with explicit entity registration using an array of entity classes.

LANGUAGE: typescript
CODE:
MikroORM.init({
  entities: [Author, Book, Publisher, BookTag],
});

----------------------------------------

TITLE: MikroORM Configuration File Setup
DESCRIPTION: TypeScript configuration file setup for MikroORM CLI and application initialization.

LANGUAGE: typescript
CODE:
import { Options } from '@mikro-orm/core';

const config: Options = {
  entities: [Author, Book, BookTag],
  dbName: 'my-db-name',
  type: 'mongo',
};

export default config;

----------------------------------------

TITLE: Implementing Custom Date Type in TypeScript
DESCRIPTION: This snippet demonstrates how to create a custom date type that maps SQL date columns to JavaScript Date objects. It includes methods for converting between database and JavaScript values, as well as handling column type definition.

LANGUAGE: typescript
CODE:
import { Type, Platform, EntityProperty, ValidationError } from '@mikro-orm/core';

/**
 * A custom type that maps SQL date column to JS Date objects.
 * Note that the ORM DateType maps to string instead of Date.
 */
export class MyDateType extends Type<Date, string> {

  convertToDatabaseValue(value: Date | string | undefined, platform: Platform): string {
    if (value instanceof Date) {
      return value.toISOString().substr(0, 10);
    }

    if (!value || value.toString().match(/^\d{4}-\d{2}-\d{2}$/)) {
      return value as string;
    }

    throw ValidationError.invalidType(MyDateType, value, 'JS');
  }

  convertToJSValue(value: Date | string | undefined, platform: Platform): Date {
    if (!value || value instanceof Date) {
      return value as Date;
    }

    const date = new Date(value);

    if (date.toString() === 'Invalid Date') {
      throw ValidationError.invalidType(MyDateType, value, 'database');
    }

    return date;
  }

  getColumnType(prop: EntityProperty, platform: Platform) {
    return `date(${prop.length})`;
  }

}

----------------------------------------

TITLE: Implementing Async Filter Conditions in MikroORM
DESCRIPTION: Shows how to implement asynchronous filter conditions with access to EntityManager and operation type. Includes type-specific filtering logic.

LANGUAGE: typescript
CODE:
import type { EntityManager } from '@mikro-orm/mysql';

@Entity()
@Filter({ name: 'writtenBy', cond: async (args, type, em: EntityManager) => {
  if (type === 'update') {
    return {}; // do not apply when updating
  }

  return {
    author: { name: args.name },
    publishedAt: { $lte: raw('now()') },
  };
} })
export class Book {
  ...
}

----------------------------------------

TITLE: Using persist() and remove() Methods in MikroORM v4
DESCRIPTION: Demonstrates the updated usage of persist() and remove() methods, which now require explicit flushing and no longer accept a flush parameter.

LANGUAGE: typescript
CODE:
// after
await em.persist(jon).flush();
await em.remove(jon).flush();

----------------------------------------

TITLE: Custom Author Entity Class Definition
DESCRIPTION: Example of defining a custom Author entity class with various property types and relationships, including collection management.

LANGUAGE: typescript
CODE:
export class Author extends CustomBaseEntity {
  name: string;
  email: string;
  age?: number;
  termsAccepted?: boolean;
  identities?: string[];
  born?: string;
  books = new Collection<Book>(this);
  favouriteBook?: Book;
  version?: number;

  constructor(name: string, email: string) {
    super();
    this.name = name;
    this.email = email;
  }
}

export const schema = new EntitySchema<Author, CustomBaseEntity>({
  class: Author,
  extends: CustomBaseEntitySchema,
  properties: {
    name: { type: 'string' },
    email: { type: 'string', unique: true },
    age: { type: 'number', nullable: true },
    termsAccepted: { type: 'boolean', default: 0, onCreate: () => false },
    identities: { type: 'string[]', nullable: true },
    born: { type: DateType, nullable: true, length: 3 },
    books: { kind: '1:m', entity: () => 'Book', mappedBy: book => book.author },
    favouriteBook: { kind: 'm:1', type: 'Book' },
    version: { type: 'number', persist: false },
  },
});

----------------------------------------

TITLE: MongoDB Entity Schema Example
DESCRIPTION: Demonstrates how to define an entity schema specifically for MongoDB with ObjectId and string ID.

LANGUAGE: typescript
CODE:
export class BookTag {
  _id!: ObjectId;
  id!: string;
  name: string;
  books = new Collection<Book>(this);

  constructor(name: string) {
    this.name = name;
  }
}

export const schema = new EntitySchema<BookTag>({
  class: BookTag,
  properties: {
    _id: { type: 'ObjectId', primary: true },
    id: { type: 'string', serializedPrimaryKey: true },
    name: { type: 'string' },
    books: { kind: 'm:n', entity: () => Book, mappedBy: book => book.tags },
  },
});

----------------------------------------

TITLE: Atomic Updates with raw() Helper in MikroORM
DESCRIPTION: Demonstrates how to perform atomic updates using the raw() helper in MikroORM.

LANGUAGE: typescript
CODE:
const ref = em.getReference(Author, 123);
ref.age = raw(`age * 2`);

await em.flush();
console.log(ref.age); // real value is available after flush

----------------------------------------

TITLE: Implementing Cascade Persist in MikroORM
DESCRIPTION: Example showing how cascade persist works when updating related entities. Changes to the book's author and tags are automatically persisted when the book entity is persisted.

LANGUAGE: typescript
CODE:
const book = await orm.em.findOne(Book, 'id', { populate: ['author', 'tags'] });
book.author.name = 'Foo Bar';
book.tags[0].name = 'new name 1';
book.tags[1].name = 'new name 2';
await orm.em.persist(book).flush(); // all book tags and author will be persisted too

----------------------------------------

TITLE: Configuring Result Cache with EntityManager in TypeScript
DESCRIPTION: Demonstrates how to use result caching with EntityManager's find method. Shows different ways to specify cache expiration and custom cache keys.

LANGUAGE: typescript
CODE:
const res = await em.find(Book, { author: { name: 'Jon Snow' } }, {
  populate: ['author', 'tags'],
  cache: 50, // set expiration to 50ms
  // cache: ['cache-key', 50], // set custom cache key and expiration
  // cache: true, // use default cache key and expiration
});

----------------------------------------

TITLE: Book Entity with Reference Implementation
DESCRIPTION: Shows three different approaches to implementing a Book entity with references using reflect-metadata, ts-morph, and EntitySchema.

LANGUAGE: typescript
CODE:
import { Entity, Ref, ManyToOne, PrimaryKey, ref } from '@mikro-orm/core';

@Entity()
export class Book {

  @PrimaryKey()
  id!: number;

  @ManyToOne(() => Author, { ref: true })
  author: Ref<Author>;

  constructor(author: Author) {
    this.author = ref(author);
  }

}

----------------------------------------

TITLE: Mapping Query Results to Entity Instances in MikroORM
DESCRIPTION: Demonstrates how to get entity instances from QueryBuilder results using getResult() and getSingleResult() methods.

LANGUAGE: typescript
CODE:
const book = await em.createQueryBuilder(Book).select('*').where({ id: 1 }).getSingleResult();
console.log(book instanceof Book); // true
const books = await em.createQueryBuilder(Book).select('*').getResult();
console.log(books[0] instanceof Book); // true

----------------------------------------

TITLE: Using @CreateRequestContext Decorator in NestJS
DESCRIPTION: Example of using the @CreateRequestContext decorator to create a separate context for a method in NestJS.

LANGUAGE: typescript
CODE:
@Controller()
export class MyService {

  constructor(private readonly orm: MikroORM) { }

  @CreateRequestContext()
  async doSomething() {
    // this will be executed in a separate context
  }

}

----------------------------------------

TITLE: Configuring Global Extended Repository
DESCRIPTION: Shows how to configure the extended repository globally in MikroORM initialization.

LANGUAGE: typescript
CODE:
MikroORM.init({
   entityRepository: ExtendedEntityRepository,
})

----------------------------------------

TITLE: Customizing Population Conditions in MikroORM Queries
DESCRIPTION: This snippet shows how to customize the population conditions for related entities using the 'populateWhere' option in MikroORM queries.

LANGUAGE: typescript
CODE:
await em.find(Author, { ... }, {
  populate: ['books'],
  populateWhere: 'infer', // defaults to `all`

  // or specify custom query, will be used via `join on` conditions
  // populateWhere: { age: { $gte: 18 } },
});

----------------------------------------

TITLE: Creating an Entity Factory in MikroORM
DESCRIPTION: Demonstrates how to create an entity factory for an Author entity using the Factory class and Faker library for generating random data.

LANGUAGE: typescript
CODE:
import { Factory } from '@mikro-orm/seeder';
import { faker } from '@faker-js/faker';
import { Author } from './entities/author.entity';

export class AuthorFactory extends Factory<Author> {
  model = Author;

  definition(): Partial<Author> {
    return {
      name: faker.person.findName(),
      email: faker.internet.email(),
      age: faker.random.number(18, 99),
    };
  }
}

----------------------------------------

TITLE: Implementing Nested Embeddables in MikroORM
DESCRIPTION: Shows how to nest embeddables within other embeddables, supporting both inline and object modes.

LANGUAGE: typescript
CODE:
import { Embeddable, Embedded, Entity, PrimaryKey, Property } from '@mikro-orm/core';

@Entity()
export class User {

  @PrimaryKey()
  id!: number;

  @Property()
  name!: string;

  @Embedded(() => Profile, { object: true, nullable: true })
  profile?: Profile;

}

@Embeddable()
export class Profile {

  @Property()
  username: string;

  @Embedded(() => Identity)
  identity: Identity;

  constructor(username: string, identity: Identity) {
    this.username = username;
    this.identity = identity;
  }

}

@Embeddable()
export class Identity {

  @Property()
  email: string;

  constructor(email: string) {
    this.email = email;
  }

}

----------------------------------------

TITLE: Defining OneToMany Collections in TypeScript
DESCRIPTION: Shows how to define OneToMany collections in MikroORM using TypeScript decorators. Demonstrates the relationship between Book and Author entities.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @PrimaryKey()
  _id!: ObjectId;

  @ManyToOne()
  author!: Author;

}

@Entity()
export class Author {

  @PrimaryKey()
  _id!: ObjectId;

  @OneToMany(() => Book, book => book.author)
  books1 = new Collection<Book>(this);

  // or via options object
  @OneToMany({ entity: () => Book, mappedBy: 'author' })
  books2 = new Collection<Book>(this);

}

----------------------------------------

TITLE: Implementing Custom Date Type in TypeScript with MikroORM
DESCRIPTION: Custom implementation of a date type that maps SQL date columns to JavaScript Date objects. Includes validation and conversion methods between database and JS representations.

LANGUAGE: typescript
CODE:
import { Type, Platform, EntityProperty, ValidationError } from '@mikro-orm/core';

export class MyDateType extends Type<Date, string> {

  convertToDatabaseValue(value: Date | string | undefined, platform: Platform): string {
    if (value instanceof Date) {
      return value.toISOString().substr(0, 10);
    }

    if (!value || value.toString().match(/^\d{4}-\d{2}-\d{2}$/)) {
      return value as string;
    }

    throw ValidationError.invalidType(MyDateType, value, 'JS');
  }

  convertToJSValue(value: Date | string | undefined, platform: Platform): Date {
    if (!value || value instanceof Date) {
      return value as Date;
    }

    const date = new Date(value);

    if (date.toString() === 'Invalid Date') {
      throw ValidationError.invalidType(MyDateType, value, 'database');
    }

    return date;
  }

  getColumnType(prop: EntityProperty, platform: Platform) {
    return `date(${prop.length})`;
  }

}

----------------------------------------

TITLE: Defining ManyToOne Relation with Reference Wrapper (TypeScript)
DESCRIPTION: This code snippet shows how to define a ManyToOne relation using the Reference wrapper in a MikroORM entity. The 'ref: true' option enables the use of the Reference wrapper for the 'book' property.

LANGUAGE: typescript
CODE:
@ManyToOne(() => Book, { ref: true })
book!: Ref<Book>;

----------------------------------------

TITLE: Advanced EntityGenerator Configuration
DESCRIPTION: Example showing advanced configuration options for entity generation

LANGUAGE: typescript
CODE:
const dump = await orm.entityGenerator.generate({
  entitySchema: true,
  bidirectionalRelations: true,
  identifiedReferences: true,
  esmImport: true,
  save: true,
  path: process.cwd() + '/my-entities',
  skipTables: ['book', 'author'],
  skipColumns: {
    'public.user': ['email', 'middle_name'],
  },
});

----------------------------------------

TITLE: Defining Entities in Multiple Schemas with MikroORM
DESCRIPTION: This snippet demonstrates how to define entities in different schemas using the @Entity decorator in MikroORM. It shows two approaches: using the 'schema' option and specifying the schema in the 'tableName' option.

LANGUAGE: typescript
CODE:
@Entity({ schema: 'first_schema' })
export class Foo { ... }

// or alternatively we can specify it inside custom table name
@Entity({ tableName: 'second_schema.bar' })
export class Bar { ... }

----------------------------------------

TITLE: Defining Entities with Schema Options in TypeScript
DESCRIPTION: Demonstrates how to define entities in different schemas using the @Entity decorator with schema and tableName options

LANGUAGE: typescript
CODE:
@Entity({ schema: 'first_schema' })
export class Foo { ... }

// or alternatively we can specify it inside custom table name
@Entity({ tableName: 'second_schema.bar' })
export class Bar { ... }

----------------------------------------

TITLE: Configuring Babel plugins for MikroORM decorator support
DESCRIPTION: This configuration sets up the necessary Babel plugins to handle TypeScript decorators correctly for MikroORM. It includes the typescript metadata transform plugin and configures decorators and class properties plugins.

LANGUAGE: json
CODE:
{
  "plugins": [
    "babel-plugin-transform-typescript-metadata",
    ["@babel/plugin-proposal-decorators", { "legacy": true }],
    ["@babel/plugin-proposal-class-properties", { "loose": true  }]
  ]
}

----------------------------------------

TITLE: Simplified Single Field AND Conditions in MikroORM
DESCRIPTION: Shows a simplified syntax for AND conditions when working with a single field, combining multiple operators in a single object.

LANGUAGE: typescript
CODE:
const res = await orm.em.find(Author, {
  id: {
    $in: [1, 2, 7],
    $nin: [3, 4],
    $gt: 5,
    $lt: 10,
    $gte: 7,
    $lte: 8,
    $ne: 9,
  },
});

----------------------------------------

TITLE: Clearing Cached Results in MikroORM
DESCRIPTION: Demonstrates how to set a custom cache key when caching results and how to clear the cache for a specific key using the EntityManager.

LANGUAGE: typescript
CODE:
// set the cache key to 'book-cache-key', with expiration of 60s
const res = await em.find(Book, { ... }, { cache: ['book-cache-key', 60_000] });

// clear the cache key by name
await em.clearCache('book-cache-key');

----------------------------------------

TITLE: Dynamic Attributes Implementation with Composite Keys
DESCRIPTION: Example demonstrating how to implement dynamic attributes for an Article entity using composite keys with a foreign key relationship.

LANGUAGE: typescript
CODE:
@Entity()
export class Article {

  @PrimaryKey()
  id!: number;

  @Property()
  title!: string;

  @OneToMany(() => ArticleAttribute, attr => attr.article, { cascade: Cascade.ALL })
  attributes = new Collection<ArticleAttribute>(this);

}

@Entity()
export class ArticleAttribute {

  @ManyToOne({ primary: true })
  article: Article;

  @PrimaryKey()
  attribute: string;

  @Property()
  value!: string;

  [PrimaryKeyProp]?: ['article', 'attribute'];

  constructor(name: string, value: string, article: Article) {
    this.attribute = name;
    this.value = value;
    this.article = article;
  }

}

----------------------------------------

TITLE: Using rel() Helper for Entity References in TypeScript
DESCRIPTION: This snippet demonstrates how to use the rel() helper function to create entity references from primary keys, which is useful when working with DTOs in constructors.

LANGUAGE: typescript
CODE:
@ManyToOne({ entity: () => Author })
author: Rel<Author>;

constructor(dto: { title: string; author: number }) {
  this.title = dto.title;
  this.author = rel(Author, dto.author);
}

----------------------------------------

TITLE: SQL Reference Function Usage
DESCRIPTION: Shows how to use the sql.ref() function for column references.

LANGUAGE: typescript
CODE:
await em.find(User, { foo: sql`bar` });

----------------------------------------

TITLE: TypeScript Configuration for Decorators
DESCRIPTION: Required TypeScript configuration settings to enable decorator support and ES module interop.

LANGUAGE: json
CODE:
"experimentalDecorators": true,
"emitDecoratorMetadata": true,
"esModuleInterop": true

----------------------------------------

TITLE: Explicit Serialization Examples
DESCRIPTION: Examples of using the explicit serialization helper with various configuration options.

LANGUAGE: typescript
CODE:
const dto = serialize(author, {
  populate: ['books.author', 'books.publisher', 'favouriteBook'], // populate some relations
  exclude: ['books.author.email'], // skip property of some relation
  forceObject: true, // not populated or not initialized relations will result in object, e.g. `{ author: { id: 1 } }`
  skipNull: true, // properties with `null` value won't be part of the result
});

----------------------------------------

TITLE: Executing Transactions in MikroORM
DESCRIPTION: Example of using MikroORM's transactional method to execute database operations within a transaction.

LANGUAGE: typescript
CODE:
// if an error occurs inside the callback, all db queries from inside the callback will be rolled back
await orm.em.transactional(async (em: EntityManager) => {
  const god = new Author('God', 'hello@heaven.god');
  await em.persist(god).flush();
});

----------------------------------------

TITLE: Using Loaded Type in MikroORM Queries
DESCRIPTION: This code demonstrates the use of the Loaded type in MikroORM queries. It shows how the type system ensures that only populated relations can be accessed synchronously.

LANGUAGE: typescript
CODE:
// res is of type `Loaded<User, 'identity'>`
const user = await em.findOneOrFail(User, 1, { populate: ['identity'] });

// instead of the async `await user.identity.load()` call that would ensure the relation is loaded
// you can use the dynamically added `$` symbol for synchronous and type-safe access to it:
console.log(user.identity.$.email);

----------------------------------------

TITLE: Implementing Custom Naming Strategy in TypeScript
DESCRIPTION: Example of creating and configuring a custom naming strategy by implementing the NamingStrategy interface when initializing MikroORM.

LANGUAGE: typescript
CODE:
class MyCustomNamingStrategy implements NamingStrategy {
  ...
}

const orm = await MikroORM.init({
  ...
  namingStrategy: MyCustomNamingStrategy,
  ...
});

----------------------------------------

TITLE: Defining a Migration Class in TypeScript
DESCRIPTION: Example of creating a Migration class that extends the Migration abstract class. It includes an 'up' method for applying changes.

LANGUAGE: typescript
CODE:
import { Migration } from '@mikro-orm/migrations';

export class Migration20191019195930 extends Migration {

  async up(): Promise<void> {
    this.addSql('select 1 + 1');
  }

}

----------------------------------------

TITLE: Explicit Null Property Definition in MikroORM
DESCRIPTION: Demonstrates how to define a property that explicitly allows null values with type specification and initialization.

LANGUAGE: typescript
CODE:
@Property({ type: 'string', nullable: true })
name: string | null = null;

----------------------------------------

TITLE: Creating a Basic Seeder Class in MikroORM
DESCRIPTION: Shows an example of a basic seeder class that creates an Author entity. The EntityManager in seeders has persistOnCreate enabled by default.

LANGUAGE: typescript
CODE:
import { EntityManager } from '@mikro-orm/core';
import { Seeder } from '@mikro-orm/seeder';
import { Author } from './author'

export class DatabaseSeeder extends Seeder {

  async run(em: EntityManager): Promise<void> {
    // will get persisted automatically
    const author = em.create(Author, {
      name: 'John Snow',
      email: 'snow@wall.st'
    });

    // but if we would do `const author = new Author()` instead,
    // we would need to call `em.persist(author)` explicitly.
  }
}

----------------------------------------

TITLE: Configuring TypeScript for MikroORM
DESCRIPTION: TypeScript configuration options required for MikroORM, including decorator support and module interop.

LANGUAGE: json
CODE:
"experimentalDecorators": true,
"emitDecoratorMetadata": true,
"esModuleInterop": true

----------------------------------------

TITLE: Using Entity Factories in MikroORM Seeders
DESCRIPTION: Demonstrates how to use entity factories within a seeder to generate multiple entities.

LANGUAGE: typescript
CODE:
import { EntityManager } from '@mikro-orm/core';
import { Seeder } from '@mikro-orm/seeder';
import { AuthorFactory } from '../factories/author.factory'

export class DatabaseSeeder extends Seeder {

  async run(em: EntityManager): Promise<void> {
    new AuthorFactory(em).make(10);
  }
}

----------------------------------------

TITLE: Using Custom Entity Class in TypeScript
DESCRIPTION: This snippet shows how to use a custom entity class with EntitySchema when creating and persisting entities.

LANGUAGE: typescript
CODE:
const author = new Author('name', 'email');
await em.persist(author).flush();

----------------------------------------

TITLE: Primary Key and Serialized Primary Key Definition
DESCRIPTION: Examples of defining primary keys using @PrimaryKey and @SerializedPrimaryKey decorators with different types and auto-increment configurations.

LANGUAGE: typescript
CODE:
@PrimaryKey()
id!: number; // auto increment PK in SQL drivers

@PrimaryKey()
uuid = uuid.v4(); // uuid PK in SQL drivers

@PrimaryKey()
_id!: ObjectId; // ObjectId PK in mongodb driver

----------------------------------------

TITLE: Implementing Custom toJSON Method in MikroORM
DESCRIPTION: This snippet demonstrates how to implement a custom toJSON method for a MikroORM entity. It uses the toObject method for initial serialization and allows for additional customization.

LANGUAGE: typescript
CODE:
@Entity()
class Book {

  // ...

  toJSON(strict = true, strip = ['id', 'email'], ...args: any[]): { [p: string]: any } {
    const o = wrap(this, true).toObject(...args); // do not forget to pass rest params here

    if (strict) {
      strip.forEach(k => delete o[k]);
    }

    return o;
  }

}

----------------------------------------

TITLE: Optional Property with Default Value in MikroORM
DESCRIPTION: Shows how to define an optional property with a default value using the optional operator.

LANGUAGE: typescript
CODE:
@Property({ default: 1 })
level?: number = 1;

----------------------------------------

TITLE: Basic Collection Operations in TypeScript
DESCRIPTION: Demonstrates common operations on Collections including iteration, item access, and collection manipulation methods.

LANGUAGE: typescript
CODE:
const author = em.findOne(Author, '...', { populate: ['books'] });

for (const book of author.books) {
  console.log(book.title);
  console.log(book.author.isInitialized());
  console.log(book.author.id);
  console.log(book.author.name);
  console.log(book.publisher);
  console.log(book.publisher.isInitialized());
  console.log(book.publisher.id);
  console.log(book.publisher.name);
}

author.books.add(book);
console.log(author.books.contains(book));
console.log(author.books.exists(item => item === book));
console.log(author.books.find(item => item === book));
console.log(author.books.map(item => item.title));
console.log(author.books.filter(item => item.title.startsWith('Foo')));
author.books.remove(book);
console.log(author.books.contains(book));

----------------------------------------

TITLE: Using Custom AsyncLocalStorage in MikroORM (TypeScript)
DESCRIPTION: This snippet shows how to use a custom AsyncLocalStorage instance with MikroORM. It allows for more control over the context storage and can be useful in advanced scenarios or when integrating with other libraries.

LANGUAGE: typescript
CODE:
const storage = new AsyncLocalStorage<EntityManager>();

const orm = await MikroORM.init({
  context: () => storage.getStore(),
  // ...
});

app.use((req, res, next) => {
  storage.run(orm.em.fork({ useContext: true }), next);
});

----------------------------------------

TITLE: Querying Entities in Specific Schemas with MikroORM
DESCRIPTION: Shows how to query for an entity in a specific schema using EntityManager, EntityRepository, or QueryBuilder.

LANGUAGE: typescript
CODE:
const user = await em.findOne(User, { ... }, { schema: 'client-123' });

----------------------------------------

TITLE: Customizing Population Ordering in MikroORM Queries
DESCRIPTION: This example demonstrates how to customize the ordering of populated entities using the 'populateOrderBy' option in MikroORM queries.

LANGUAGE: typescript
CODE:
await em.find(Author, { ... }, {
  populate: ['books'],
  populateOrderBy: { books: { publishedAt: 'desc' } },
});

----------------------------------------

TITLE: Configuring ReflectMetadataProvider with reflect-metadata
DESCRIPTION: Setup for ReflectMetadataProvider which uses reflect-metadata module to read type information from decorator metadata. Requires reflect-metadata package and emitDecoratorMetadata flag in tsconfig.json.

LANGUAGE: typescript
CODE:
import 'reflect-metadata';

LANGUAGE: typescript
CODE:
await MikroORM.init({
  metadataProvider: ReflectMetadataProvider,
  // ...
});

----------------------------------------

TITLE: Defining JSON Property in TypeScript Entity for MikroORM
DESCRIPTION: This snippet demonstrates how to define a JSON property in a MikroORM entity using the @Property decorator with the 'json' type. It shows a Book entity with a nullable 'meta' property of type JSON.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @Property({ type: 'json', nullable: true })
  meta?: { foo: string; bar: number };

}

----------------------------------------

TITLE: Book Entity with Reference Implementation
DESCRIPTION: Example of implementing a Book entity with type-safe references using different metadata providers.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @PrimaryKey()
  id!: number;

  @ManyToOne(() => Author, { ref: true })
  author: Ref<Author>;

  constructor(author: Author) {
    this.author = ref(author);
  }

}

----------------------------------------

TITLE: Deep Object Property Merging with assign()
DESCRIPTION: Shows how to merge object properties recursively using the mergeObjectProperties flag.

LANGUAGE: typescript
CODE:
import { wrap } from '@mikro-orm/core';

book.meta = { foo: 1, bar: 2 };

wrap(book).assign({ meta: { foo: 3 } }, { mergeObjectProperties: true });
console.log(book.meta); // { foo: 3, bar: 2 }

wrap(book).assign({ meta: { foo: 4 } });
console.log(book.meta); // { foo: 4 }

----------------------------------------

TITLE: Using Read and Write Connections in MikroORM with TypeScript
DESCRIPTION: This snippet illustrates various ways to use read and write connections in MikroORM. It shows how to explicitly specify connection types, use query builders, and handle transactions. It also demonstrates the behavior when 'preferReadReplicas' is set to false.

LANGUAGE: typescript
CODE:
const connection = em.getConnection(); // write connection
const readConnection = em.getConnection('read'); // random read connection

const qb1 = em.createQueryBuilder(Author);
const res1 = await qb1.select('*').execute(); // random read connection

const qb2 = em.createQueryBuilder(Author, 'a', 'write');
const res2 = await qb2.select('*').execute(); // write connection

const qb3 = em.createQueryBuilder(Author);
const res3 = await qb3.update(...).where(...).execute(); // write connection

const res4 = await em.findOne(Author, 1, { connectionType: 'write' }); // explicit write connection

// all queries inside a transaction will use write connection
await em.transactional(async em => {
    const a = await em.findOne(Author, 1); // write connection
    const b = await em.findOne(Author, 1, { connectionType: 'read' }); // still a write connection - we are in a transaction
    a.name = 'test'; // will trigger update on write connection once flushed
});

// given a configuration where preferReadReplicas: false
const res5 = await em.findOne(Author, 1); // write connection - even for a read operation
const res6 = await em.findOne(Author, 1, { connectionType: 'read' }); // unless explicitly asking for a read replica

----------------------------------------

TITLE: Configuring Loading Strategy at Entity Level in MikroORM
DESCRIPTION: This snippet shows how to configure the loading strategy at the entity level by specifying it in the OneToMany decorator options.

LANGUAGE: typescript
CODE:
import { Entity, LoadStrategy, OneToMany } from '@mikro-orm/core';

@Entity()
export class Author {

  // ...

  @OneToMany({
    entity: () => Book,
    mappedBy: b => b.author,
    strategy: 'select-in', // force select-in strategy for this relation
  })
  books = new Collection<Book>(this);

}

----------------------------------------

TITLE: Defining Composite Primary Key Entity in TypeScript with MikroORM
DESCRIPTION: This snippet demonstrates how to create an entity with a composite primary key using primitive types (string and number) in MikroORM.

LANGUAGE: typescript
CODE:
@Entity()
export class Car {

  @PrimaryKey()
  name: string;

  @PrimaryKey()
  year: number;

  // this is needed for proper type checks in `FilterQuery`
  [PrimaryKeyProp]?: ['name', 'year'];

  constructor(name: string, year: number) {
    this.name = name;
    this.year = year;
  }

}

----------------------------------------

TITLE: Using Entity Factories in MikroORM Seeders
DESCRIPTION: Demonstrates how to use entity factories within a seeder to generate multiple entities.

LANGUAGE: typescript
CODE:
import { EntityManager } from '@mikro-orm/core';
import { Seeder } from '@mikro-orm/seeder';
import { AuthorFactory } from '../factories/author.factory'

export class DatabaseSeeder extends Seeder {

  async run(em: EntityManager): Promise<void> {
    new AuthorFactory(em).make(10);
  }
}

----------------------------------------

TITLE: Defining Virtual Entity with QueryBuilder Callback in TypeScript
DESCRIPTION: Shows how to create a virtual entity using a callback function that returns a QueryBuilder instance. The callback provides more flexibility in constructing the query programmatically.

LANGUAGE: typescript
CODE:
@Entity({
  expression: (em: EntityManager) => {
    return em.createQueryBuilder(Book, 'b')
      .select(['b.title', 'a.name as author_name', 'group_concat(t.name) as tags'])
      .join('b.author', 'a')
      .join('b.tags', 't')
      .groupBy('b.id');
  },
})
export class BookWithAuthor {

  @Property()
  title!: string;

  @Property()
  authorName!: string;

  @Property()
  tags!: string[];

}

----------------------------------------

TITLE: Implementing Custom Platform Class in TypeScript for MikroORM
DESCRIPTION: Platform class implementation that defines database-specific features and behaviors. This class handles primary key formatting, naming strategies, and transaction support configuration.

LANGUAGE: typescript
CODE:
import { Platform } from 'mikro-orm';

export class MyCustomPlatform extends Platform {

  protected abstract schemaHelper: MyCustomSchemaHelper;

  // here you can override default settings
  usesPivotTable(): boolean;
  supportsTransactions(): boolean;
  supportsSavePoints(): boolean;
  getNamingStrategy(): { new (): NamingStrategy; };
  getIdentifierQuoteCharacter(): string;
  getParameterPlaceholder(index?: number): string;
  usesReturningStatement(): boolean;
  normalizePrimaryKey<T = number | string>(data: IPrimaryKey): T;
  denormalizePrimaryKey(data: IPrimaryKey): IPrimaryKey;
  getSerializedPrimaryKeyField(field: string): string;

}

----------------------------------------

TITLE: Defining Author Entity with EntitySchema in JavaScript
DESCRIPTION: Shows how to create an Author entity class with EntitySchema configuration including property definitions, relationships, and necessary exports. Demonstrates property types, collection handling, and entity relationships.

LANGUAGE: javascript
CODE:
const { Collection, EntitySchema } = require('@mikro-orm/core');
const { Book } = require('./Book');
const { BaseEntity } = require('./BaseEntity');

/**
 * @property {number} id
 * @property {Date} createdAt
 * @property {Date} updatedAt
 * @property {string} name
 * @property {string} email
 * @property {number} age
 * @property {boolean} termsAccepted
 * @property {string[]} identities
 * @property {Date} born
 * @property {Collection<Book>} books
 * @property {Book} favouriteBook
 * @property {number} version
 * @property {string} versionAsString
 */
class Author extends BaseEntity {

  /**
   * @param {string} name
   * @param {string} email
   */
  constructor(name, email) {
    super();
    this.name = name;
    this.email = email;
    this.books = new Collection(this);
    this.createdAt = new Date();
    this.updatedAt = new Date();
    this.termsAccepted = false;
  }

}

export const schema = new EntitySchema({
  class: Author,
  properties: {
    name: { type: 'string' },
    email: { type: 'string', unique: true },
    age: { type: 'number', nullable: true },
    termsAccepted: { type: 'boolean', default: 0, onCreate: () => false },
    identities: { type: 'string[]', nullable: true },
    born: { type: DateType, nullable: true, length: 3 },
    books: { kind: '1:m', entity: () => 'Book', mappedBy: book => book.author },
    favouriteBook: { kind: 'm:1', type: 'Book' },
    version: { type: 'number', persist: false },
  },
});

module.exports.Author = Author;
module.exports.entity = Author;
module.exports.schema = schema;

----------------------------------------

TITLE: Implementing Async Filter Conditions in MikroORM
DESCRIPTION: Example of implementing asynchronous filter conditions with type checking and conditional logic based on operation type.

LANGUAGE: typescript
CODE:
import type { EntityManager } from '@mikro-orm/mysql';

@Entity()
@Filter({ name: 'writtenBy', cond: async (args, type, em: EntityManager) => {
  if (type === 'update') {
    return {}; // do not apply when updating
  }

  return {
    author: { name: args.name },
    publishedAt: { $lte: raw('now()') },
  };
} })
export class Book {
  ...
}

----------------------------------------

TITLE: Using Native Collection Methods in MikroORM
DESCRIPTION: Examples of using native collection methods like insert, nativeUpdate, and nativeDelete in MikroORM.

LANGUAGE: typescript
CODE:
em.insert<T extends AnyEntity>(entityName: string, data: any): Promise<IPrimaryKey>;
em.nativeUpdate<T extends AnyEntity>(entityName: string, where: FilterQuery<T>, data: any): Promise<number>;
em.nativeDelete<T extends AnyEntity>(entityName: string, where: FilterQuery<T> | any): Promise<number>;

----------------------------------------

TITLE: Installing AdminJS Core and MikroORM Adapter
DESCRIPTION: Commands for installing AdminJS core and MikroORM adapter packages using yarn. Includes options for different database drivers.

LANGUAGE: bash
CODE:
$ yarn add adminjs
$ yarn add @adminjs/mikroorm
# A MikroORM driver and core package, choose the one which suits you:
$ yarn add @mikro-orm/core @mikro-orm/mongodb     # for mongo
$ yarn add @mikro-orm/core @mikro-orm/mysql       # for mysql
$ yarn add @mikro-orm/core @mikro-orm/mariadb     # for mariadb
$ yarn add @mikro-orm/core @mikro-orm/postgresql  # for postgresql
$ yarn add @mikro-orm/core @mikro-orm/sqlite      # for sqlite

----------------------------------------

TITLE: Disabling Change Tracking for Performance in MikroORM (TypeScript)
DESCRIPTION: This snippet shows how to disable change tracking for specific properties in MikroORM to improve performance when frequently accessing those properties.

LANGUAGE: typescript
CODE:
@Property({ trackChanges: false })
code!: string;

----------------------------------------

TITLE: Creating Custom Driver Class for MikroORM
DESCRIPTION: This snippet shows how to implement a custom Driver class by extending the DatabaseDriver class. It includes methods for performing database operations like find, insert, update, and delete.

LANGUAGE: typescript
CODE:
import { DatabaseDriver } from '@mikro-orm/core';

export class MyCustomDriver extends DatabaseDriver {

  // initialize connection and platform
  protected readonly connection = new MyCustomConnection(this.config);
  protected readonly platform = new MyCustomPlatform;

  // and implement abstract methods
  find<T extends AnyEntity>(entityName: string, where: FilterQuery<T>, populate?: string[], orderBy?: Record<string, QueryOrder>, limit?: number, offset?: number): Promise<T[]>;
  findOne<T extends AnyEntity>(entityName: string, where: FilterQuery<T> | string, populate: string[]): Promise<T | null>;
  nativeInsert<T extends AnyEntityType<T>>(entityName: string, data: EntityData<T>): Promise<QueryResult>;
  nativeUpdate<T extends AnyEntity>(entityName: string, where: FilterQuery<T> | IPrimaryKey, data: EntityData<T>): Promise<QueryResult>;
  nativeDelete<T extends AnyEntity>(entityName: string, where: FilterQuery<T> | IPrimaryKey): Promise<QueryResult>;
  count<T extends AnyEntity>(entityName: string, where: FilterQuery<T>): Promise<number>;

}

----------------------------------------

TITLE: Defining JSON Property in MikroORM Entity
DESCRIPTION: Demonstrates how to define a JSON property in a MikroORM entity using the @Property decorator with type 'json'. Shows optional typing for the JSON structure.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @Property({ type: 'json', nullable: true })
  meta?: { foo: string; bar: number };

}

----------------------------------------

TITLE: Defining JSON Property in TypeScript with MikroORM
DESCRIPTION: Demonstrates how to define a JSON property in a MikroORM entity using the @Property decorator with the 'json' type. The example shows a nullable JSON field named 'meta' with a specific structure.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @Property({ type: 'json', nullable: true })
  meta?: { foo: string; bar: number };

}

----------------------------------------

TITLE: Optimistic Locking with Version Check in MikroORM (TypeScript)
DESCRIPTION: Demonstrates how to use optimistic locking with a version check when finding an entity. This helps prevent conflicts in concurrent operations.

LANGUAGE: typescript
CODE:
const theEntityId = 1;
const expectedVersion = 184;

try {
  const entity = await orm.em.findOne(User, theEntityId, { lockMode: LockMode.OPTIMISTIC, lockVersion: expectedVersion });

  // do the work

  await orm.em.flush();
} catch (e) {
  console.log('Sorry, but someone else has already changed this entity. Please apply the changes again!');
}

----------------------------------------

TITLE: Implementing User Sign-up Route
DESCRIPTION: Handles user registration with email validation and password hashing

LANGUAGE: typescript
CODE:
export async function registerUserRoutes(app: FastifyInstance) {
  const db = await initORM();

  app.post('/sign-up', async request => {
    const body = request.body as EntityData<User>;

    if (!body.email || !body.fullName || !body.password) {
      throw new Error('One of required fields is missing: email, fullName, password');
    }

    if ((await db.user.count({ email: body.email })) > 0) {
      throw new Error('This email is already registered, maybe you want to sign in?');
    }

    const user = new User(body.fullName, body.email, body.password);
    user.bio = body.bio ?? '';
    await db.em.persist(user).flush();

    console.log(`User ${user.id} created`);

    return user;
  });
}

----------------------------------------

TITLE: Lifecycle Hook Decorators
DESCRIPTION: Examples of lifecycle hook decorators that run code at different stages of entity persistence, including initialization, loading, creation, updates and deletion.

LANGUAGE: typescript
CODE:
@OnInit()
doStuffOnInit(args: EventArgs<this>) {
  this.fullName = `${this.firstName} - ${this.lastName}`;
}

@BeforeCreate()
async doStuffBeforeCreate(args: EventArgs<this>) {
  // ...
}

@AfterCreate()
async doStuffAfterCreate(args: EventArgs<this>) {
  // ...
}

----------------------------------------

TITLE: Initializing MikroORM with PostgreSQL
DESCRIPTION: Example of initializing MikroORM with PostgreSQL driver and basic configuration options.

LANGUAGE: typescript
CODE:
import { MikroORM } from '@mikro-orm/postgresql'; // or any other SQL driver package

const orm = await MikroORM.init({
  entities: ['./dist/entities'], // path to your JS entities (dist), relative to `baseDir`
  dbName: 'my-db-name',
});
console.log(orm.em); // access EntityManager via `em` property

----------------------------------------

TITLE: Array Shorthand for $in Operator in MikroORM
DESCRIPTION: Demonstrates the shorthand syntax for the $in operator where an array value is automatically converted to an $in condition.

LANGUAGE: typescript
CODE:
const res = await orm.em.find(Author, { favouriteBook: [1, 2, 7] });

----------------------------------------

TITLE: Defining Hidden Properties in TypeScript with MikroORM
DESCRIPTION: This snippet demonstrates how to mark properties as hidden in a MikroORM entity using the @Property decorator and HiddenProps symbol. Hidden properties are omitted from serialized results.

LANGUAGE: typescript
CODE:
@Entity()
class Book {

  // we use the `HiddenProps` symbol to define hidden properties on type level
  [HiddenProps]?: 'hiddenField' | 'otherHiddenField';

  @Property({ hidden: true })
  hiddenField = Date.now();

  @Property({ hidden: true, nullable: true })
  otherHiddenField?: string;

}

const book = new Book(...);
console.log(wrap(book).toObject().hiddenField); // undefined

// @ts-expect-error accessing `hiddenField` will fail to compile thanks to the `HiddenProps` symbol
console.log(wrap(book).toJSON().hiddenField); // undefined

----------------------------------------

TITLE: Defining Complex Entity Schema with Various Properties in TypeScript
DESCRIPTION: This snippet showcases a more complex entity schema definition with various property types, indexes, unique constraints, and a custom repository.

LANGUAGE: typescript
CODE:
export enum MyEnum {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export const schema = new EntitySchema<FooBar>({
  name: 'FooBar',
  tableName: 'tbl_foo_bar',
  indexes: [{ name: 'idx1', properties: 'name' }],
  uniques: [{ name: 'unq1', properties: ['name', 'email'] }],
  customRepository: () => FooBarRepository,
  properties: {
    id: { type: 'number', primary: true },
    name: { type: 'string' },
    baz: { reference: '1:1', entity: 'FooBaz', orphanRemoval: true, nullable: true },
    fooBar: { reference: '1:1', entity: 'FooBar', nullable: true },
    publisher: { reference: 'm:1', entity: 'Publisher', inversedBy: 'books' },
    books: { reference: '1:m', entity: () => 'Book', mappedBy: book => book.author },
    tags: { reference: 'm:n', entity: 'BookTag', inversedBy: 'books', fixedOrder: true },
    version: { type: 'Date', version: true, length: 0 },
    type: { enum: true, items: () => MyEnum, default: MyEnum.LOCAL },
  },
});

----------------------------------------

TITLE: Defining Entity with @Entity Decorator in TypeScript
DESCRIPTION: Example of using the @Entity decorator to define an Author entity with a custom table name.

LANGUAGE: typescript
CODE:
@Entity({ tableName: 'authors' })
export class Author { ... }

----------------------------------------

TITLE: Configuring Fake Timers for PostgreSQL with MikroORM
DESCRIPTION: Sets up fake timer mocks for PostgreSQL when used with MikroORM, focusing on connection pool handling.

LANGUAGE: typescript
CODE:
import Pool from 'pg-pool';
import { fakeTimersHooks, wrappedSpy } from './nextTickFixer';

export function enableFakeTimersWithMikroOrm() {
  return {
    mocks: [
      wrappedSpy(Pool.prototype, 'connect', executeHooks),
    ],
    mockRestore: function () {
      let mock: jest.SpyInstance | undefined;
      while (mock = this.mocks.pop()) {
        mock.mockRestore();
      }
    }
  };
}

----------------------------------------

TITLE: Creating Extended EntityRepository with Persistence Methods in TypeScript
DESCRIPTION: Demonstrates how to create a custom base repository that includes persistence methods removed from EntityRepository in v6. This allows maintaining the previous API if desired.

LANGUAGE: typescript
CODE:
import { EntityManager, EntityRepository, AnyEntity } from '@mikro-orm/mysql';

export class ExtendedEntityRepository<T extends object> extends EntityRepository<T> {

  persist(entity: AnyEntity | AnyEntity[]): EntityManager {
    return this.em.persist(entity);
  }

  async persistAndFlush(entity: AnyEntity | AnyEntity[]): Promise<void> {
    await this.em.persistAndFlush(entity);
  }

  remove(entity: AnyEntity): EntityManager {
    return this.em.remove(entity);
  }

  async removeAndFlush(entity: AnyEntity): Promise<void> {
    await this.em.removeAndFlush(entity);
  }

  async flush(): Promise<void> {
    return this.em.flush();
  }

}

----------------------------------------

TITLE: Creating Entities with Forked EntityManager and Default Schema in MikroORM
DESCRIPTION: Shows how to create entities using a forked EntityManager with a default schema.

LANGUAGE: typescript
CODE:
const fork = em.fork({ schema: 'client-123' });
const user = new User();
user.email = 'foo@bar.com';
await fork.persist(user).flush();

// Will yield the same result as
const qb = em.createQueryBuilder(User);
await qb.insert({ email: 'foo@bar.com' }).withSchema('client-123');

----------------------------------------

TITLE: Implicit Transactions in MikroORM with TypeScript
DESCRIPTION: This example demonstrates how MikroORM handles implicit transactions when persisting and flushing changes to multiple entities.

LANGUAGE: typescript
CODE:
const user = await em.findOne(User, 1);
user.email = 'foo@bar.com';
const car = new Car();
user.cars.add(car);

// thanks to bi-directional cascading we only need to persist user entity
// flushing will create a transaction, insert new car and update user with new email
await em.persist(user).flush();

----------------------------------------

TITLE: Disabling Change Tracking for Performance in MikroORM
DESCRIPTION: This snippet shows how to disable change tracking on a property level to improve performance for frequently accessed properties.

LANGUAGE: typescript
CODE:
@Property({ trackChanges: false })
code!: string;

----------------------------------------

TITLE: Database Services Container Implementation
DESCRIPTION: Simple Dependency Injection container for MikroORM services including EntityManager and repositories

LANGUAGE: typescript
CODE:
import { EntityManager, EntityRepository, MikroORM, Options } from '@mikro-orm/sqlite';

export interface Services {
  orm: MikroORM;
  em: EntityManager;
  article: EntityRepository<Article>;
  user: EntityRepository<User>;
  tag: EntityRepository<Tag>;
}

let cache: Services;

export async function initORM(options?: Options): Promise<Services> {
  if (cache) {
    return cache;
  }

  const orm = await MikroORM.init(options);

  return cache = {
    orm,
    em: orm.em,
    article: orm.em.getRepository(Article),
    user: orm.em.getRepository(User),
    tag: orm.em.getRepository(Tag),
  };
}

----------------------------------------

TITLE: Custom OnFlush Event Handler Implementation
DESCRIPTION: Example of implementing an onFlush event subscriber that automatically creates and links entities during the flush operation.

LANGUAGE: typescript
CODE:
export class FooBarSubscriber implements EventSubscriber {

  async onFlush(args: FlushEventArgs): Promise<void> {
    const changeSets = args.uow.getChangeSets();
    const cs = changeSets.find(cs => cs.type === ChangeSetType.CREATE && cs.entity instanceof FooBar);

    if (cs) {
      const baz = new FooBaz();
      baz.name = 'dynamic';
      cs.entity.baz = baz;
      args.uow.computeChangeSet(baz);
      args.uow.recomputeSingleChangeSet(cs.entity);
    }
  }

}

const bar = new FooBar();
bar.name = 'bar';
await em.persist(bar).flush();

----------------------------------------

TITLE: Configuring Population Where Condition in MikroORM Query
DESCRIPTION: This snippet shows how to use the 'populateWhere' option to control the conditions applied to populated relations.

LANGUAGE: typescript
CODE:
await em.find(Author, { ... }, {
  populate: ['books'],
  populateWhere: 'infer', // defaults to `all`

  // or specify custom query, will be used via `join on` conditions
  // populateWhere: { age: { $gte: 18 } },
});

----------------------------------------

TITLE: Defining Lifecycle Hooks with Decorators in TypeScript
DESCRIPTION: Examples of using lifecycle hook decorators to define methods that run at specific points in an entity's lifecycle.

LANGUAGE: typescript
CODE:
@OnInit()
doStuffOnInit() {
  this.fullName = `${this.firstName} - ${this.lastName}`; // initialize shadow property
}

@BeforeCreate()
async doStuffBeforeCreate() {
  // ...
}

@AfterUpdate()
async doStuffAfterUpdate() {
  // ...
}

----------------------------------------

TITLE: Programmatic Migration Usage with MikroORM
DESCRIPTION: Example of using the Migrator programmatically to create and run migrations through TypeScript code.

LANGUAGE: typescript
CODE:
import { MikroORM } from '@mikro-orm/core';

(async () => {
  const orm = await MikroORM.init({
    dbName: 'your-db-name',
    // ...
  });

  const migrator = orm.getMigrator();
  await migrator.createMigration(); // creates file Migration20191019195930.ts
  await migrator.up(); // runs migrations up to the latest
  await migrator.up('name'); // runs only given migration, up
  await migrator.up({ to: 'up-to-name' }); // runs migrations up to given version
  await migrator.down(); // migrates one step down
  await migrator.down('name'); // runs only given migration, down
  await migrator.down({ to: 'down-to-name' }); // runs migrations down to given version
  await migrator.down({ to: 0 }); // migrates down to the first version

  await orm.close(true);
})()

----------------------------------------

TITLE: Setting Population Order By Clause in MikroORM Query
DESCRIPTION: This example demonstrates how to set a custom order by clause for populated relations when querying entities with MikroORM.

LANGUAGE: typescript
CODE:
await em.find(Author, { ... }, {
  populate: ['books'],
  populateOrderBy: { books: { publishedAt: 'desc' } },
});

----------------------------------------

TITLE: Optimistic Locking with Version Check in MikroORM (TypeScript)
DESCRIPTION: Demonstrates how to use optimistic locking with a version check when finding an entity. This helps prevent conflicts in concurrent operations.

LANGUAGE: typescript
CODE:
const theEntityId = 1;
const expectedVersion = 184;

try {
  const entity = await orm.em.findOne(User, theEntityId, { lockMode: LockMode.OPTIMISTIC, lockVersion: expectedVersion });

  // do the work

  await orm.em.flush();
} catch (e) {
  console.log('Sorry, but someone else has already changed this entity. Please apply the changes again!');
}

----------------------------------------

TITLE: Clearing Identity Map Cache in MikroORM (TypeScript)
DESCRIPTION: This snippet demonstrates how to clear the identity map cache using the em.clear() method. This can be useful when you need to reset the in-memory state of entities.

LANGUAGE: typescript
CODE:
orm.em.clear();

----------------------------------------

TITLE: Using RequestContext Middleware in MikroORM (TypeScript)
DESCRIPTION: This snippet demonstrates how to use the RequestContext helper as middleware to create a new request context for each incoming request. It ensures that each request has its own isolated entity manager instance.

LANGUAGE: typescript
CODE:
app.use((req, res, next) => {
  // calls `orm.em.fork()` and attaches it to the async context
  RequestContext.create(orm.em, next);
});

app.get('/', async (req, res) => {
  // uses fork from the async context automatically
  const authors = await orm.em.find(Book, {});
  res.json(authors);
});

----------------------------------------

TITLE: Configuring MikroORM Cache Settings in TypeScript
DESCRIPTION: Demonstrates how to initialize MikroORM with custom cache configuration including adapter selection, expiration time, and global cache settings.

LANGUAGE: typescript
CODE:
const orm = await MikroORM.init({
  resultCache: {
    // following options are the defaults
    adapter: MemoryCacheAdapter,
    expiration: 1000, // 1s
    options: {},
    // cache can be also enabled globally
    // global: 50, // 50ms
  },
  // ...
});

----------------------------------------

TITLE: Creating Event Subscriber in NestJS with MikroORM
DESCRIPTION: Shows how to create and register an event subscriber for MikroORM entities in a NestJS application.

LANGUAGE: typescript
CODE:
import { Injectable } from '@nestjs/common';
import { EntityName, EventArgs, EventSubscriber } from '@mikro-orm/core';

@Injectable()
export class AuthorSubscriber implements EventSubscriber<Author> {

  constructor(em: EntityManager) {
    em.getEventManager().registerSubscriber(this);
  }

  getSubscribedEntities(): EntityName<Author>[] {
    return [Author];
  }

  async afterCreate(args: EventArgs<Author>): Promise<void> {
    // ...
  }

  async afterUpdate(args: EventArgs<Author>): Promise<void> {
    // ...
  }

}

----------------------------------------

TITLE: Demonstrating Identity Map in MikroORM (TypeScript)
DESCRIPTION: This snippet shows how the identity map ensures the same instance of an entity is returned across multiple queries. It retrieves an author and then all authors, demonstrating that the same object is returned for matching entities.

LANGUAGE: typescript
CODE:
const authorRepository = em.getRepository(Author);
const jon = await authorRepository.findOne({ name: 'Jon Snow' }, { populate: ['books'] });
const authors = await authorRepository.findAll({ populate: ['books'] });

// identity map in action
console.log(jon === authors[0]); // true

----------------------------------------

TITLE: Configuring SeedManager in MikroORM
DESCRIPTION: Shows how to register the SeedManager extension in the MikroORM configuration file.

LANGUAGE: typescript
CODE:
import { SeedManager } from '@mikro-orm/seeder';

export default defineConfig({
  // ...
  extensions: [SeedManager],
})

----------------------------------------

TITLE: Raw Fragments in MikroORM Filters
DESCRIPTION: Example of using raw query fragments within MikroORM filters, specifically using a callback to create new raw instances for filter usage.

LANGUAGE: typescript
CODE:
@Filter({ name: 'long', cond: () => ({ [raw('length(perex)')]: { $gt: 10000 } }) })

----------------------------------------

TITLE: Using MikroORM Schema Generator CLI Commands
DESCRIPTION: CLI commands for creating, updating, and dropping database schemas using MikroORM's schema generator. Includes options for dumping SQL and executing queries.

LANGUAGE: sh
CODE:
npx mikro-orm schema:create --dump   # Dumps create schema SQL
npx mikro-orm schema:update --dump   # Dumps update schema SQL
npx mikro-orm schema:drop --dump     # Dumps drop schema SQL

----------------------------------------

TITLE: Implementing ManyToMany Relationships - Owning Side
DESCRIPTION: Shows different ways to define the owning side of ManyToMany relationships using Collections and various configuration options.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @ManyToMany()
  tags1 = new Collection<BookTag>(this);

  @ManyToMany(() => BookTag, 'books', { owner: true })
  tags2 = new Collection<BookTag>(this);

  @ManyToMany(() => BookTag, 'books', { owner: true })
  tags3 = new Collection<BookTag>(this);

  @ManyToMany(() => BookTag, 'books', { owner: true })
  tags4 = new Collection<BookTag>(this);

  @ManyToMany(() => Author)
  friends: Collection<Author> = new Collection<Author>(this);

}

----------------------------------------

TITLE: MikroORM CLI Schema Commands
DESCRIPTION: Basic CLI commands for schema management using MikroORM's SchemaGenerator. These commands allow dumping and executing schema creation, update, and drop operations.

LANGUAGE: shell
CODE:
npx mikro-orm schema:create --dump   # Dumps create schema SQL
npx mikro-orm schema:update --dump   # Dumps update schema SQL
npx mikro-orm schema:drop --dump     # Dumps drop schema SQL

----------------------------------------

TITLE: Executing Queries with Different Result Types in MikroORM
DESCRIPTION: Demonstrates different ways to execute a query and control the form of the result using the 'execute' method in MikroORM.

LANGUAGE: typescript
CODE:
const res1 = await qb.execute('all'); // returns array of objects, default behavior
const res2 = await qb.execute('get'); // returns single object
const res3 = await qb.execute('run'); // returns object like `{ affectedRows: number, insertId: number, row: any }`

----------------------------------------

TITLE: Configuring Loading Strategy at Entity Level in MikroORM
DESCRIPTION: This snippet shows how to set the loading strategy for a specific relationship at the entity level using MikroORM decorators.

LANGUAGE: typescript
CODE:
import { Entity, LoadStrategy, OneToMany } from '@mikro-orm/core';

@Entity()
export class Author {

  // ...

  @OneToMany({
    entity: () => Book,
    mappedBy: b => b.author,
    strategy: 'select-in', // force select-in strategy for this relation
  })
  books = new Collection<Book>(this);

}

----------------------------------------

TITLE: Implementing PointType for MySQL Spatial Extension in MikroORM
DESCRIPTION: This advanced example demonstrates how to implement a custom PointType for handling MySQL's Point type, including conversion methods for database and JavaScript values.

LANGUAGE: typescript
CODE:
export class Point {

  constructor(
    public latitude: number,
    public longitude: number,
  ) {
  }

}

export class PointType extends Type<Point | undefined, string | undefined> {

  convertToDatabaseValue(value: Point | undefined): string | undefined {
    if (!value) {
      return value;
    }

    return `point(${value.latitude} ${value.longitude})`;
  }

  convertToJSValue(value: string | undefined): Point | undefined {
    const m = value?.match(/point\((-?\d+(\.\d+)?) (-?\d+(\.\d+)?)\)/i);

    if (!m) {
      return undefined;
    }

    return new Point(+m[1], +m[3]);
  }

  convertToJSValueSQL(key: string) {
    return `ST_AsText(${key})`;
  }

  convertToDatabaseValueSQL(key: string) {
    return `ST_PointFromText(${key})`;
  }

  getColumnType(): string {
    return 'point';
  }

}

----------------------------------------

TITLE: Defining a Book Entity with Reflect Metadata
DESCRIPTION: Example of defining a Book entity using the @Entity decorator and reflect-metadata approach.

LANGUAGE: typescript
CODE:
@Entity()
export class Book extends CustomBaseEntity {

  @Property()
  title!: string;

  @ManyToOne(() => Author)
  author!: Author;

  @ManyToOne(() => Publisher, { ref: true, nullable: true })
  publisher?: Ref<Publisher>;

  @ManyToMany({ entity: 'BookTag', fixedOrder: true })
  tags = new Collection<BookTag>(this);

}

----------------------------------------

TITLE: Complex Query Building with Joins
DESCRIPTION: Example of building complex queries with joins and multiple conditions.

LANGUAGE: typescript
CODE:
const qb = em.createQueryBuilder(BookTag, 't');
qb.select(['b.*', 't.*'])
  .leftJoin('t.books', 'b')
  .where('b.title = ? or b.title = ?', ['test 123', 'lol 321'])
  .andWhere('1 = 1')
  .orWhere('1 = 2')
  .limit(2, 1);

----------------------------------------

TITLE: Complete Event Subscriber Implementation
DESCRIPTION: Comprehensive example of an event subscriber implementing all available lifecycle, flush, and transaction event handlers.

LANGUAGE: typescript
CODE:
import { EventArgs, TransactionEventArgs, EventSubscriber } from '@mikro-orm/core';

export class EverythingSubscriber implements EventSubscriber {

  // entity life cycle events
  onInit<T>(args: EventArgs<T>): void { ... }
  async onLoad<T>(args: EventArgs<T>): Promise<void> { ... }
  async beforeCreate<T>(args: EventArgs<T>): Promise<void> { ... }
  async afterCreate<T>(args: EventArgs<T>): Promise<void> { ... }
  async beforeUpdate<T>(args: EventArgs<T>): Promise<void> { ... }
  async afterUpdate<T>(args: EventArgs<T>): Promise<void> { ... }
  async beforeUpsert<T>(args: EventArgs<T>): Promise<void> { ... }
  async afterUpsert<T>(args: EventArgs<T>): Promise<void> { ... }
  async beforeDelete<T>(args: EventArgs<T>): Promise<void> { ... }
  async afterDelete<T>(args: EventArgs<T>): Promise<void> { ... }

  // flush events
  async beforeFlush<T>(args: FlushEventArgs): Promise<void> { ... }
  async onFlush<T>(args: FlushEventArgs): Promise<void> { ... }
  async afterFlush<T>(args: FlushEventArgs): Promise<void> { ... }

  // transaction events
  async beforeTransactionStart(args: TransactionEventArgs): Promise<void> { ... }
  async afterTransactionStart(args: TransactionEventArgs): Promise<void> { ... }
  async beforeTransactionCommit(args: TransactionEventArgs): Promise<void> { ... }
  async afterTransactionCommit(args: TransactionEventArgs): Promise<void> { ... }
  async beforeTransactionRollback(args: TransactionEventArgs): Promise<void> { ... }
  async afterTransactionRollback(args: TransactionEventArgs): Promise<void> { ... }

}

----------------------------------------

TITLE: Custom Pivot Table Entity for ManyToMany in TypeScript with MikroORM
DESCRIPTION: Shows how to define a custom pivot table entity for ManyToMany relationships in MikroORM. It includes examples of both unidirectional and bidirectional relationships.

LANGUAGE: typescript
CODE:
@Entity()
export class Order {

  @ManyToMany({ entity: () => Product, pivotEntity: () => OrderItem })
  products = new Collection<Product>(this);

}

@Entity()
export class Product {

  @ManyToMany({ entity: () => Order, mappedBy: o => o.products })
  orders = new Collection<Order>(this);

}

@Entity()
export class OrderItem {

  @ManyToOne({ primary: true })
  order: Order;

  @ManyToOne({ primary: true })
  product: Product;

  @Property({ default: 1 })
  amount!: number;

}

// create new item
const item = em.create(OrderItem, {
  order: 123,
  product: 321,
  amount: 999,
});
await em.persist(item).flush();

// or remove an item via delete query
const em.nativeDelete(OrderItem, { order: 123, product: 321 });

----------------------------------------

TITLE: Defining Parameter-less Filters in MikroORM
DESCRIPTION: Demonstrates how to create filters without parameters while still accessing the operation type parameter.

LANGUAGE: typescript
CODE:
@Filter({
  name: 'withoutParams',
  cond(_, type) {
    return { ... };
  },
  args: false,
  default: true,
})

----------------------------------------

TITLE: Defining a ManyToOne Relation with Reference Wrapper (TypeScript)
DESCRIPTION: This code snippet shows how to define a ManyToOne relation using the Reference wrapper in a MikroORM entity. The 'ref: true' option enables the use of the Reference wrapper for this relation.

LANGUAGE: typescript
CODE:
@ManyToOne(() => Book, { ref: true })
book!: Ref<Book>;

----------------------------------------

TITLE: Defining Entity-Level Filters in TypeScript with MikroORM
DESCRIPTION: Demonstrates how to define filters at the entity level using decorators. Shows examples of different filter types including conditional filters, default filters, and filters with dynamic conditions.

LANGUAGE: typescript
CODE:
@Entity()
@Filter({ name: 'expensive', cond: { price: { $gt: 1000 } } })
@Filter({ name: 'long', cond: { 'length(text)': { $gt: 10000 } } })
@Filter({ name: 'hasAuthor', cond: { author: { $ne: null } }, default: true })
@Filter({ name: 'writtenBy', cond: args => ({ author: { name: args.name } }) })
export class Book {
  ...
}

const books1 = await orm.em.find(Book, {}, {
  filters: ['long', 'expensive'],
});
const books2 = await orm.em.find(Book, {}, {
  filters: { hasAuthor: false, long: true, writtenBy: { name: 'God' } },
});

----------------------------------------

TITLE: Configuring Loading Strategy in Entity Definition in TypeScript
DESCRIPTION: This snippet shows how to set a specific loading strategy ('select-in') for a relationship at the entity level.

LANGUAGE: typescript
CODE:
import { Entity, LoadStrategy, OneToMany } from '@mikro-orm/core';

@Entity()
export class Author {

  // ...

  @OneToMany({
    entity: () => Book,
    mappedBy: b => b.author,
    strategy: 'select-in', // force select-in strategy for this relation
  })
  books = new Collection<Book>(this);

}

----------------------------------------

TITLE: Implementing Custom Connection Class for MikroORM in TypeScript
DESCRIPTION: This snippet shows how to create a custom Connection class by extending the base Connection class from MikroORM. It includes methods for database connection management and query execution.

LANGUAGE: typescript
CODE:
import { Connection } from '@mikro-orm/core';

export class MyCustomConnection extends Connection {

  // implement abstract methods
  connect(): Promise<void>;
  isConnected(): Promise<boolean>;
  close(force?: boolean): Promise<void>;
  getDefaultClientUrl(): string;
  execute(query: string, params?: any[], method?: 'all' | 'get' | 'run'): Promise<QueryResult | any | any[]>;

}

----------------------------------------

TITLE: Implementing Custom Naming Strategy in TypeScript for MikroORM
DESCRIPTION: Demonstrates how to create and use a custom naming strategy by implementing the NamingStrategy interface and providing it during ORM initialization.

LANGUAGE: typescript
CODE:
class MyCustomNamingStrategy implements NamingStrategy {
  ...
}

const orm = await MikroORM.init({
  ...
  namingStrategy: MyCustomNamingStrategy,
  ...
});

----------------------------------------

TITLE: Atomic Updates with raw() Helper in MikroORM
DESCRIPTION: Shows how to perform atomic updates using the raw() helper function. This allows for issuing atomic update queries during the flush operation.

LANGUAGE: typescript
CODE:
const ref = em.getReference(Author, 123);
ref.age = raw(`age * 2`);

await em.flush();
console.log(ref.age); // real value is available after flush

----------------------------------------

TITLE: Defining Entity-Level Filters in TypeScript with MikroORM
DESCRIPTION: Shows how to define filters at the entity level using decorators. Demonstrates basic filter conditions, default filters, and parameterized filters.

LANGUAGE: typescript
CODE:
@Entity()
@Filter({ name: 'expensive', cond: { price: { $gt: 1000 } } })
@Filter({ name: 'long', cond: { 'length(text)': { $gt: 10000 } } })
@Filter({ name: 'hasAuthor', cond: { author: { $ne: null } }, default: true })
@Filter({ name: 'writtenBy', cond: args => ({ author: { name: args.name } }) })
export class Book {
  ...
}

const books1 = await orm.em.find(Book, {}, {
  filters: ['long', 'expensive'],
});
const books2 = await orm.em.find(Book, {}, {
  filters: { hasAuthor: false, long: true, writtenBy: { name: 'God' } },
});

----------------------------------------

TITLE: Query Execution Methods
DESCRIPTION: Shows different methods for executing queries and controlling the result format

LANGUAGE: typescript
CODE:
const res1 = await qb.execute('all'); // returns array of objects, default behavior
const res2 = await qb.execute('get'); // returns single object
const res3 = await qb.execute('run'); // returns object like `{ affectedRows: number, insertId: number, row: any }`

----------------------------------------

TITLE: Creating Indexes on JSON Properties in TypeScript with MikroORM
DESCRIPTION: This snippet demonstrates how to create indexes on JSON properties using MikroORM decorators in TypeScript. It shows both single and compound indexes using @Index and @Unique decorators.

LANGUAGE: typescript
CODE:
@Entity()
@Index({ properties: 'metaData.foo' })
@Index({ properties: ['metaData.foo', 'metaData.bar'] }) // compound index
@Unique({ properties: 'metaData.foo' })
@Unique({ properties: ['metaData.foo', 'metaData.bar'] }) // compound unique index
export class Book {

  @Property({ type: 'json', nullable: true })
  metaData?: { foo: string; bar: number };

}

----------------------------------------

TITLE: Complete Event Subscriber Implementation
DESCRIPTION: Comprehensive example of an event subscriber implementing all available lifecycle, flush, and transaction event handlers.

LANGUAGE: typescript
CODE:
import { EventArgs, TransactionEventArgs, EventSubscriber } from '@mikro-orm/core';

export class EverythingSubscriber implements EventSubscriber {

  // entity life cycle events
  onInit<T>(args: EventArgs<T>): void { ... }
  async onLoad<T>(args: EventArgs<T>): Promise<void> { ... }
  async beforeCreate<T>(args: EventArgs<T>): Promise<void> { ... }
  async afterCreate<T>(args: EventArgs<T>): Promise<void> { ... }
  async beforeUpdate<T>(args: EventArgs<T>): Promise<void> { ... }
  async afterUpdate<T>(args: EventArgs<T>): Promise<void> { ... }
  async beforeUpsert<T>(args: EventArgs<T>): Promise<void> { ... }
  async afterUpsert<T>(args: EventArgs<T>): Promise<void> { ... }
  async beforeDelete<T>(args: EventArgs<T>): Promise<void> { ... }
  async afterDelete<T>(args: EventArgs<T>): Promise<void> { ... }

  // flush events
  async beforeFlush<T>(args: FlushEventArgs): Promise<void> { ... }
  async onFlush<T>(args: FlushEventArgs): Promise<void> { ... }
  async afterFlush<T>(args: FlushEventArgs): Promise<void> { ... }

  // transaction events
  async beforeTransactionStart(args: TransactionEventArgs): Promise<void> { ... }
  async afterTransactionStart(args: TransactionEventArgs): Promise<void> { ... }
  async beforeTransactionCommit(args: TransactionEventArgs): Promise<void> { ... }
  async afterTransactionCommit(args: TransactionEventArgs): Promise<void> { ... }
  async beforeTransactionRollback(args: TransactionEventArgs): Promise<void> { ... }
  async afterTransactionRollback(args: TransactionEventArgs): Promise<void> { ... }

}

----------------------------------------

TITLE: Using Property Serializers in Entity with TypeScript
DESCRIPTION: This snippet shows how to use property serializers to customize the serialization of specific properties in an entity.

LANGUAGE: typescript
CODE:
@Entity()
class Book {

  @ManyToOne({ serializer: value => value.name, serializedName: 'authorName' })
  author: Author;

}

const author = new Author('God')
const book = new Book(author);
console.log(wrap(book).toJSON().authorName); // 'God'

----------------------------------------

TITLE: Webpack Configuration for MikroORM
DESCRIPTION: Complete Webpack configuration for bundling MikroORM applications with proper entity handling and optimization settings

LANGUAGE: javascript
CODE:
const path = require('path');
const { EnvironmentPlugin, IgnorePlugin } = require('webpack');
const TerserPlugin = require('terser-webpack-plugin');

const { devDependencies } = require('./package.json');
const externals = {};

for (const devDependency of Object.keys(devDependencies)) {
  externals[devDependency] = `commonjs ${devDependency}`;
}

const optionalModules = new Set([
  ...Object.keys(require('knex/package.json').browser),
  ...Object.keys(require('@mikro-orm/core/package.json').peerDependencies),
  ...Object.keys(require('@mikro-orm/core/package.json').devDependencies || {})
]);

module.exports = {
  entry: path.resolve('app', 'server.ts'),
  mode: 'production',
  optimization: {
    minimizer: [
      new TerserPlugin({
        terserOptions: {
          mangle: false,
          compress: {
            keep_classnames: true,
            keep_fnames: true,
          },
        }
      })
    ]
  },
  target: 'node',
  module: {
    rules: [
      {
        test: /\.ts$/,
        exclude: /node_modules/,
        loader: 'ts-loader',
      },
      {
        test: /\.node$/,
        use: 'node-loader',
      },
      {
        test: /\.mjs$/,
        include: /node_modules/,
        type: 'javascript/auto',
      },
    ],
  },
  externals,
  resolve: {
    extensions: ['.ts', '.js']
  },
  plugins: [
    new EnvironmentPlugin({ WEBPACK: true }),
    new IgnorePlugin({
      checkResource: resource => {
        const baseResource = resource.split('/', resource[0] === '@' ? 2 : 1).join('/');
        if (optionalModules.has(baseResource)) {
          try {
            require.resolve(resource);
            return false;
          } catch {
            return true;
          }
        }
        return false;
      },
    }),
  ],
  output: {
    filename: 'server.js',
    libraryTarget: 'commonjs',
    path: path.resolve(__dirname, '..', 'output'),
  },
};

----------------------------------------

TITLE: Using EntityManager in Migrations
DESCRIPTION: Example showing how to use EntityManager within migrations to modify data, though this approach is discouraged in favor of raw queries.

LANGUAGE: typescript
CODE:
import { Migration } from '@mikro-orm/migrations';
import { User } from '../entities/User';

export class Migration20191019195930 extends Migration {

  async up(): Promise<void> {
    const em = this.getEntityManager();
    em.create(User, { ... });
    await em.flush();
  }

}

----------------------------------------

TITLE: Using QueryBuilder for Native SQL Queries
DESCRIPTION: Demonstration of using QueryBuilder to construct and execute native SQL queries with parameter binding and different query types.

LANGUAGE: typescript
CODE:
const qb = orm.em.createQueryBuilder(Author);
qb.update({ name: 'test 123', type: PublisherType.GLOBAL }).where({ id: 123, type: PublisherType.LOCAL });

console.log(qb.getQuery());
console.log(qb.getParams());

const res1 = await qb.execute();

const driver = orm.em.getDriver();
const res2 = await driver.execute('SELECT ? + ?', [1, 2]);

----------------------------------------

TITLE: Injecting EntityManager in NestJS Service
DESCRIPTION: Example of injecting MikroORM and EntityManager into a NestJS service for database operations.

LANGUAGE: typescript
CODE:
import { MikroORM } from '@mikro-orm/core';
import { EntityManager } from '@mikro-orm/mysql'; // Import EntityManager from your driver package or `@mikro-orm/knex`

@Injectable()
export class MyService {

  constructor(private readonly orm: MikroORM,
              private readonly em: EntityManager) {
  }

}

----------------------------------------

TITLE: Defining Author Entity with EntitySchema in JavaScript
DESCRIPTION: Example showing how to define an Author entity using EntitySchema with properties, relationships, and constructor. Includes JSDoc type annotations and extends BaseEntity class.

LANGUAGE: javascript
CODE:
import { Collection, EntitySchema } from '@mikro-orm/core';
import { Book } from './Book.js';
import { BaseEntity } from './BaseEntity.js';

/**
 * @property {number} id
 * @property {Date} createdAt
 * @property {Date} updatedAt
 * @property {string} name
 * @property {string} email
 * @property {number} age
 * @property {boolean} termsAccepted
 * @property {string[]} identities
 * @property {Date} born
 * @property {Collection<Book>} books
 * @property {Book} favouriteBook
 * @property {number} version
 * @property {string} versionAsString
 */
export class Author extends BaseEntity {

  /**
   * @param {string} name
   * @param {string} email
   */
  constructor(name, email) {
    super();
    this.name = name;
    this.email = email;
    this.books = new Collection(this);
    this.createdAt = new Date();
    this.updatedAt = new Date();
    this.termsAccepted = false;
  }

}

export const schema = new EntitySchema({
  class: Author,
  properties: {
    name: { type: 'string' },
    email: { type: 'string', unique: true },
    age: { type: 'number', nullable: true },
    termsAccepted: { type: 'boolean', default: 0, onCreate: () => false },
    identities: { type: 'string[]', nullable: true },
    born: { type: DateType, nullable: true, length: 3 },
    books: { kind: '1:m', entity: () => 'Book', mappedBy: book => book.author },
    favouriteBook: { kind: 'm:1', type: 'Book' },
    version: { type: 'number', persist: false },
  },
});

----------------------------------------

TITLE: Implicit Transaction Handling in MikroORM
DESCRIPTION: Demonstrates how MikroORM handles transactions implicitly when persisting and flushing changes to an entity.

LANGUAGE: typescript
CODE:
const user = new User(...);
user.name = 'George';
await orm.em.persist(user).flush();

----------------------------------------

TITLE: Custom Pivot Table Entity Configuration
DESCRIPTION: Shows how to implement custom pivot table entities for ManyToMany relationships with additional properties.

LANGUAGE: typescript
CODE:
@Entity()
export class Order {
  @ManyToMany({ entity: () => Product, pivotEntity: () => OrderItem })
  products = new Collection<Product>(this);
}

@Entity()
export class OrderItem {
  @ManyToOne({ primary: true })
  order: Order;

  @ManyToOne({ primary: true })
  product: Product;

  @Property({ default: 1 })
  amount!: number;
}

----------------------------------------

TITLE: MongoDB ObjectId and String ID Usage
DESCRIPTION: Demonstrates the dual nature of MongoDB IDs using both ObjectId and string formats in queries and references.

LANGUAGE: typescript
CODE:
const author = orm.em.getReference('...id...');
console.log(author.id);  // returns '...id...'
console.log(author._id); // returns ObjectId('...id...')

// all of those will return the same results
const article = '...article id...'; // string id
const book = '...book id...'; // string id
const repo = orm.em.getRepository(Author);
const foo1 = await repo.find({ id: { $in: [article] }, favouriteBook: book });
const bar1 = await repo.find({ id: { $in: [new ObjectId(article)] }, favouriteBook: new ObjectId(book) });
const foo2 = await repo.find({ _id: { $in: [article] }, favouriteBook: book });
const bar2 = await repo.find({ _id: { $in: [new ObjectId(article)] }, favouriteBook: new ObjectId(book) });

----------------------------------------

TITLE: Populating All Relations in MikroORM with TypeScript
DESCRIPTION: This snippet shows how to populate all relationships in MikroORM using the '*' wildcard. The result will be strictly typed, respecting the star hint.

LANGUAGE: typescript
CODE:
const tags = await em.find(BookTag, {}, {
  populate: ['*'],
});

----------------------------------------

TITLE: MikroORM Configuration File
DESCRIPTION: Configuration for MikroORM including database settings and entity discovery options

LANGUAGE: typescript
CODE:
import { Options, SqliteDriver } from '@mikro-orm/sqlite';
import { TsMorphMetadataProvider } from '@mikro-orm/reflection';

const config: Options = {
  driver: SqliteDriver,
  dbName: 'sqlite.db',
  entities: ['dist/**/*.entity.js'],
  entitiesTs: ['src/**/*.entity.ts'],
  metadataProvider: TsMorphMetadataProvider,
  debug: true,
};

export default config;

----------------------------------------

TITLE: Configuring Custom Cache Adapter in MikroORM (TypeScript)
DESCRIPTION: This code demonstrates how to configure a custom cache adapter (RedisCacheAdapter in this case) when initializing MikroORM. It uses the 'adapter' property in the cache configuration.

LANGUAGE: typescript
CODE:
await MikroORM.init({
  cache: { adapter: RedisCacheAdapter, options: { ... } },
  // ...
});

----------------------------------------

TITLE: Creating Entity Instances with EntitySchema in TypeScript
DESCRIPTION: This snippet demonstrates how to create new entity instances when using EntitySchema. It uses the em.create() method to create an instance of an internally created class.

LANGUAGE: typescript
CODE:
const repo = em.getRepository<Author>('Author');
const author = repo.create('Author', { name: 'name', email: 'email' }); // instance of internal Author class
await repo.persistAndFlush(author);

----------------------------------------

TITLE: Initializing and Checking Entity References in MikroORM
DESCRIPTION: This code demonstrates how to check if an entity is initialized and how to initialize it using the wrap helper function. It shows the difference between accessing properties before and after initialization.

LANGUAGE: typescript
CODE:
const author = em.getReference(Author, 123);
console.log(author.id); // accessing the id will not trigger any db call
console.log(wrap(author).isInitialized()); // false
console.log(author.name); // undefined

await wrap(author).init(); // this will trigger db call
console.log(wrap(author).isInitialized()); // true
console.log(author.name); // defined

----------------------------------------

TITLE: Basic Embeddable Implementation with Address Class
DESCRIPTION: Demonstrates basic implementation of an embeddable Address class and its usage in a User entity using reflect-metadata decorators.

LANGUAGE: typescript
CODE:
import { Embeddable, Embedded, Entity, PrimaryKey, Property } from '@mikro-orm/core';

@Embeddable()
export class Address {

  @Property()
  street!: string;

  @Property()
  postalCode!: string;

  @Property()
  city!: string;

  @Property()
  country!: string;

}

@Entity()
export class User {

  @PrimaryKey()
  id!: number;

  @Embedded(() => Address)
  address!: Address;

}

----------------------------------------

TITLE: Configuring MikroORM Migrations
DESCRIPTION: This code snippet demonstrates the configuration options available for migrations in MikroORM, including file paths, naming conventions, and execution settings.

LANGUAGE: typescript
CODE:
await MikroORM.init({
  // default values:
  migrations: {
    tableName: 'mikro_orm_migrations', // name of database table with log of executed transactions
    path: './migrations', // path to the folder with migrations
    pathTs: undefined, // path to the folder with TS migrations (if used, you should put path to compiled files in `path`)
    glob: '!(*.d).{js,ts}', // how to match migration files (all .js and .ts files, but not .d.ts)
    transactional: true, // wrap each migration in a transaction
    disableForeignKeys: true, // wrap statements with `set foreign_key_checks = 0` or equivalent
    allOrNothing: true, // wrap all migrations in master transaction
    dropTables: true, // allow to disable table dropping
    safe: false, // allow to disable table and column dropping
    snapshot: true, // save snapshot when creating new migrations
    emit: 'ts', // migration generation mode
    generator: TSMigrationGenerator, // migration generator, e.g. to allow custom formatting
  },
})

----------------------------------------

TITLE: Injecting Repository in NestJS Service
DESCRIPTION: Example of injecting an entity repository into a NestJS service using the @InjectRepository() decorator.

LANGUAGE: typescript
CODE:
@Injectable()
export class PhotoService {
  constructor(
    @InjectRepository(Photo)
    private readonly photoRepository: EntityRepository<Photo>
  ) {}

  // ...
}

----------------------------------------

TITLE: Defining Entity with UUID Primary Key
DESCRIPTION: Example of defining an entity with a UUID primary key using MikroORM decorators and the uuid library.

LANGUAGE: typescript
CODE:
import { v4 } from 'uuid';

@Entity()
export class UuidBook {

  @PrimaryKey()
  uuid = v4();

}

----------------------------------------

TITLE: Defining Indexes
DESCRIPTION: Examples of defining indexes for entities using different approaches.

LANGUAGE: typescript
CODE:
// reflect-metadata and ts-morph
@Entity()
@Index({ properties: ['name', 'age'] })
@Index({ name: 'custom_idx_name', properties: ['name'] })
@Unique({ properties: ['name', 'email'] })
export class Author {

  @Property()
  @Unique()
  email!: string;

  @Property()
  @Index()
  age?: number;

  @Index({ name: 'born_index' })
  @Property()
  born?: Date;

  @Index({ name: 'custom_index_expr', expression: 'alter table `author` add index `custom_index_expr`(`title`)' })
  @Property()
  title!: string;

}

// EntitySchema
export const AuthorSchema = new EntitySchema<Author, CustomBaseEntity>({
  class: Author,
  indexes: [
    { properties: ['name', 'age'] },
    { name: 'custom_idx_name', properties: ['name'] },
    { name: 'custom_index_expr', expression: 'alter table `author` add index `custom_index_expr`(`title`)' },
  ],
  uniques: [
    { properties: ['name', 'email'] },
  ],
  properties: {
    email: { type: 'string', unique: true },
    age: { type: 'number', nullable: true, index: true },
    born: { type: Date, nullable: true, index: 'born_index' },
    title: { type: 'string' },
  },
});

----------------------------------------

TITLE: Programmatic Migration Execution
DESCRIPTION: Example of how to programmatically initialize MikroORM and execute migrations using the Migrator API.

LANGUAGE: typescript
CODE:
import { MikroORM } from '@mikro-orm/core';
import { Migrator } from '@mikro-orm/migrations';

(async () => {
  const orm = await MikroORM.init({
    extensions: [Migrator],
    dbName: 'your-db-name',
    // ...
  });

  const migrator = orm.getMigrator();
  await migrator.createMigration();
  await migrator.up();
  await migrator.up('name');
  await migrator.up({ to: 'up-to-name' });
  await migrator.down();
  await migrator.down('name');
  await migrator.down({ to: 'down-to-name' });
  await migrator.down({ to: 0 });

  await orm.close(true);
})()

----------------------------------------

TITLE: Importing MikroORM QueryBuilder Dependencies
DESCRIPTION: Initial setup for using QueryBuilder by importing required types from MikroORM driver package.

LANGUAGE: typescript
CODE:
import { EntityManager, EntityRepository } from '@mikro-orm/mysql'; // or any other driver package

----------------------------------------

TITLE: Using Seeders in Tests with MikroORM
DESCRIPTION: Demonstrates how to use seeders in test setup to prepare the database with sample data before running tests.

LANGUAGE: typescript
CODE:
let orm: MikroORM;

beforeAll(async () => {
  // Initialize the ORM
  orm = await MikroORM.init({ ... });
  
  // Refresh the database to start clean
  await orm.schema.refreshDatabase();

  // And run the seeder afterwards
  await orm.seeder.seed(DatabaseSeeder);
});

test(() => {
  // Do tests
});

afterAll(async () => {
  // Close connection
  await orm.close();
});

----------------------------------------

TITLE: Configuring Global Filters in MikroORM Initialization
DESCRIPTION: Demonstrates how to register global filters during MikroORM initialization through the configuration object.

LANGUAGE: typescript
CODE:
MikroORM.init({
  filters: { tenant: { cond: args => ({ tenant: args.tenant }), entity: ['Author', 'User'] } },
  ...
})

----------------------------------------

TITLE: Using raw() Helper with MikroORM Queries
DESCRIPTION: Demonstrates how to use the raw() helper function to include raw SQL fragments in MikroORM queries. Shows usage as both value and key in query conditions.

LANGUAGE: typescript
CODE:
// as a value
await em.find(User, { time: raw('now()') });

// as a key
await em.find(User, { [raw('lower(name)')]: name.toLowerCase() });

// value can be empty array
await em.find(User, { [raw('(select 1 = 1)')]: [] });

----------------------------------------

TITLE: Simplified AND Query Conditions in MikroORM
DESCRIPTION: Shows a simplified way to write AND conditions when all conditions apply to the same field. This approach reduces nesting and improves readability.

LANGUAGE: typescript
CODE:
const res = await orm.em.find(Author, {
  id: {
    $in: [1, 2, 7],
    $nin: [3, 4],
    $gt: 5,
    $lt: 10,
    $gte: 7,
    $lte: 8,
    $ne: 9,
  },
});

----------------------------------------

TITLE: Initializing MikroORM with Read Replica Connections in TypeScript
DESCRIPTION: This snippet demonstrates how to initialize MikroORM with multiple read replica connections. It shows the configuration of master and read replica connections, including the 'preferReadReplicas' option.

LANGUAGE: typescript
CODE:
const orm = await MikroORM.init({
  entities: [Author, ...],
  dbName: `my_database`,
  user: 'master_user',
  host: 'master_host',
  preferReadReplicas: true, // optional property, defaults to true
  replicas: [
    { name: 'read-1', host: 'read_host_1', user: 'read_user' },
    { name: 'read-2', host: 'read_host_2' }, // user omitted, will be taken from master connection
  ],
});

----------------------------------------

TITLE: Defining Virtual Entity with MongoDB Aggregation in TypeScript
DESCRIPTION: This snippet demonstrates how to define a virtual entity using a MongoDB aggregation pipeline. It includes handling for where clauses, sorting, limit, and offset.

LANGUAGE: typescript
CODE:
@Entity({
  expression: (em: EntityManager, where, options) => {
    const $sort = { ...options.orderBy } as Dictionary;
    $sort._id = 1;
    const pipeline: Dictionary[] = [
      { $project: { _id: 0, title: 1, author: 1 } },
      { $sort },
      { $match: where ?? {} },
      { $lookup: { from: 'author', localField: 'author', foreignField: '_id', as: 'author', pipeline: [{ $project: { name: 1 } }] } },
      { $unwind: '$author' },
      { $set: { authorName: '$author.name' } },
      { $unset: ['author'] },
    ];

    if (options.offset != null) {
      pipeline.push({ $skip: options.offset });
    }

    if (options.limit != null) {
      pipeline.push({ $limit: options.limit });
    }

    return em.aggregate(Book, pipeline);
  },
})
export class BookWithAuthor {

  @Property()
  title!: string;

  @Property()
  authorName!: string;

}

----------------------------------------

TITLE: Programmatic Migration Execution
DESCRIPTION: Example of how to programmatically initialize MikroORM and execute migrations using the Migrator API.

LANGUAGE: typescript
CODE:
import { MikroORM } from '@mikro-orm/core';
import { Migrator } from '@mikro-orm/migrations';

(async () => {
  const orm = await MikroORM.init({
    extensions: [Migrator],
    dbName: 'your-db-name',
    // ...
  });

  const migrator = orm.getMigrator();
  await migrator.createMigration();
  await migrator.up();
  await migrator.up('name');
  await migrator.up({ to: 'up-to-name' });
  await migrator.down();
  await migrator.down('name');
  await migrator.down({ to: 'down-to-name' });
  await migrator.down({ to: 0 });

  await orm.close(true);
})()

----------------------------------------

TITLE: Clearing Identity Map Cache in MikroORM
DESCRIPTION: Demonstrates how to clear the identity map cache using the EntityManager clear method.

LANGUAGE: typescript
CODE:
orm.em.clear();

----------------------------------------

TITLE: Basic Entity Construction
DESCRIPTION: Simple example of creating a new Book entity instance using the constructor.

LANGUAGE: typescript
CODE:
const author = new Author();
const book = new Book('Foo', author);

----------------------------------------

TITLE: Defining Virtual Entity with SQL Expression in TypeScript
DESCRIPTION: Creates a virtual entity using a SQL query expression that joins books with authors and aggregates tags. The entity maps book titles, author names, and concatenated tags into a read-only entity structure.

LANGUAGE: typescript
CODE:
@Entity({
  expression: `
    select b.title, a.name as author_name,
    (
      select group_concat(distinct t.name)
      from book b 
      join tags_ordered bt on bt.book_id = b.id
      join book_tag t on t.id = bt.book_tag_id
      where b.author_id = a.id
      group by b.author_id
    ) as tags
    from author a
    group by a.id
  `
})
export class BookWithAuthor {

  @Property()
  title!: string;

  @Property()
  authorName!: string;

  @Property()
  tags!: string[];

}

----------------------------------------

TITLE: Fresh Schema with Seeding Commands
DESCRIPTION: Commands for recreating the database schema from scratch with optional seeding functionality.

LANGUAGE: shell
CODE:
npx mikro-orm schema:fresh --run --seed              # seed the database with the default database seeder
npx mikro-orm schema:fresh --run --seed=UsersSeeder  # seed the database with the UsersSeeder

----------------------------------------

TITLE: Using rel() Helper for Entity References in TypeScript
DESCRIPTION: This snippet demonstrates the use of the 'rel()' helper function to convert primary keys to entity references in constructors, allowing for more flexible entity creation.

LANGUAGE: typescript
CODE:
@ManyToOne({ entity: () => Author })
author: Rel<Author>;

constructor(dto: { title: string; author: number }) {
  this.title = dto.title;
  this.author = rel(Author, dto.author);
}

----------------------------------------

TITLE: Using TsMorphMetadataProvider in MikroORM
DESCRIPTION: Demonstrates how to configure the TsMorphMetadataProvider for analyzing entity source files and type definitions.

LANGUAGE: typescript
CODE:
import { MikroORM } from '@mikro-orm/core';
import { TsMorphMetadataProvider } from '@mikro-orm/reflection';

MikroORM.init({
  metadataProvider: TsMorphMetadataProvider,
});

----------------------------------------

TITLE: Importing SQL EntityManager in TypeScript
DESCRIPTION: This snippet demonstrates how to import the SQL flavor of EntityManager from a specific driver package to access the createQueryBuilder() method.

LANGUAGE: ts
CODE:
import { EntityManager } from '@mikro-orm/mysql'; // or any other SQL driver package

const em = orm.em as EntityManager;
const qb = await em.createQueryBuilder(...);

----------------------------------------

TITLE: Adding Authentication to AdminJS with Express
DESCRIPTION: TypeScript code snippet showing how to add authentication to AdminJS when using Express. Uses buildAuthenticatedRouter instead of buildRouter.

LANGUAGE: typescript
CODE:
const ADMIN_EMAIL = 'example@test.com';
const ADMIN_PASSWORD = 'password';

const router = AdminJSExpress.buildAuthenticatedRouter(admin, {
  authenticate: async (email, password) => {
    /* Your code for verifying email & password goes here */
    return email === ADMIN_EMAIL && password === ADMIN_PASSWORD
      ? { email } // the function should return an object containing user's data if authenticated successfully
      : null;
  },
  cookiePassword: process.env.COOKIE_PASSWORD ?? 'makesurepasswordissecure',
});

----------------------------------------

TITLE: Implementing EventSubscriber with Decorator in TypeScript
DESCRIPTION: Example of creating an EventSubscriber using the @Subscriber decorator. This subscriber hooks into the afterCreate and afterUpdate events for the Author entity.

LANGUAGE: typescript
CODE:
import { EntityName, EventArgs, EventSubscriber, Subscriber } from '@mikro-orm/core';

@Subscriber()
export class AuthorSubscriber implements EventSubscriber<Author> {

  getSubscribedEntities(): EntityName<Author>[] {
    return [Author];
  }

  async afterCreate(args: EventArgs<Author>): Promise<void> {
    // ...
  }

  async afterUpdate(args: EventArgs<Author>): Promise<void> {
    // ...
  }

}

----------------------------------------

TITLE: Complex EntitySchema Configuration in TypeScript
DESCRIPTION: This snippet demonstrates a more complex EntitySchema configuration, including enums, indexes, unique constraints, custom repository, and various property types and relationships.

LANGUAGE: typescript
CODE:
export enum MyEnum {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export const schema = new EntitySchema<FooBar>({
  name: 'FooBar',
  tableName: 'tbl_foo_bar',
  indexes: [{ name: 'idx1', properties: 'name' }],
  uniques: [{ name: 'unq1', properties: ['name', 'email'] }],
  customRepository: () => FooBarRepository,
  properties: {
    id: { type: 'number', primary: true },
    name: { type: 'string' },
    baz: { reference: '1:1', entity: 'FooBaz', orphanRemoval: true, nullable: true },
    fooBar: { reference: '1:1', entity: 'FooBar', nullable: true },
    publisher: { reference: 'm:1', entity: 'Publisher', inversedBy: 'books' },
    books: { reference: '1:m', entity: () => 'Book', mappedBy: book => book.author },
    tags: { reference: 'm:n', entity: 'BookTag', inversedBy: 'books', fixedOrder: true },
    version: { type: 'Date', version: true, length: 0 },
    type: { enum: true, items: () => MyEnum, default: MyEnum.LOCAL },
  },
});

----------------------------------------

TITLE: Using sql Tagged Templates in MikroORM Queries (TypeScript)
DESCRIPTION: Illustrates the use of sql tagged templates for incorporating raw SQL fragments in MikroORM queries, including examples as values and keys.

LANGUAGE: typescript
CODE:
// as a value
await em.find(User, { time: sql`now()` });

// as a key
await em.find(User, { [sql`lower(name)`]: name.toLowerCase() });

// value can be empty array
await em.find(User, { [sql`(select ${1} = ${1})`]: [] });

----------------------------------------

TITLE: Defining a Book Entity with Reference Wrapper in MikroORM
DESCRIPTION: This snippet shows how to define a Book entity using the Reference wrapper for the author relation. It demonstrates three different ways to define the entity: using reflect-metadata, ts-morph, and EntitySchema.

LANGUAGE: typescript
CODE:
import { Entity, Ref, ManyToOne, PrimaryKey, ref } from '@mikro-orm/core';

@Entity()
export class Book {

  @PrimaryKey()
  id!: number;

  @ManyToOne(() => Author, { ref: true })
  author: Ref<Author>;

  constructor(author: Author) {
    this.author = ref(author);
  }

}

----------------------------------------

TITLE: Complex EntitySchema Configuration in TypeScript
DESCRIPTION: This snippet demonstrates a more complex EntitySchema configuration, including enums, indexes, unique constraints, custom repository, and various property types and relationships.

LANGUAGE: typescript
CODE:
export enum MyEnum {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export const schema = new EntitySchema<FooBar>({
  name: 'FooBar',
  tableName: 'tbl_foo_bar',
  indexes: [{ name: 'idx1', properties: 'name' }],
  uniques: [{ name: 'unq1', properties: ['name', 'email'] }],
  customRepository: () => FooBarRepository,
  properties: {
    id: { type: 'number', primary: true },
    name: { type: 'string' },
    baz: { reference: '1:1', entity: 'FooBaz', orphanRemoval: true, nullable: true },
    fooBar: { reference: '1:1', entity: 'FooBar', nullable: true },
    publisher: { reference: 'm:1', entity: 'Publisher', inversedBy: 'books' },
    books: { reference: '1:m', entity: () => 'Book', mappedBy: book => book.author },
    tags: { reference: 'm:n', entity: 'BookTag', inversedBy: 'books', fixedOrder: true },
    version: { type: 'Date', version: true, length: 0 },
    type: { enum: true, items: () => MyEnum, default: MyEnum.LOCAL },
  },
});

----------------------------------------

TITLE: Populating Already Loaded Entities in MikroORM (TypeScript)
DESCRIPTION: Demonstrates how to populate relations on entities that have already been loaded using the 'em.populate()' method. This allows for lazy loading of relations after the initial query.

LANGUAGE: typescript
CODE:
const authors = await em.createQueryBuilder(Author).select('*').getResult();
await em.populate(authors, ['books.tags']);

// now your Author entities will have `books` collections populated,
// as well as they will have their `tags` collections populated.
console.log(authors[0].books[0].tags[0]); // initialized BookTag

----------------------------------------

TITLE: Initializing TsMorphMetadataProvider in MikroORM
DESCRIPTION: Configuration code to set up TsMorphMetadataProvider which uses ts-morph to read TypeScript entity source files for type detection.

LANGUAGE: typescript
CODE:
import { TsMorphMetadataProvider } from '@mikro-orm/reflection';

await MikroORM.init({
  metadataProvider: TsMorphMetadataProvider,
  // ...
});

----------------------------------------

TITLE: Querying Entities with Population Hints
DESCRIPTION: Examples showing how to use population hints and where conditions when querying entities with relationships.

LANGUAGE: typescript
CODE:
const a = await em.find(Author, { books: [1, 2, 3] }, { populate: ['books'] });

await em.find(Author, { ... }, {
  populateWhere: PopulateHint.INFER,
});

----------------------------------------

TITLE: Defining Author Entity with EntitySchema in JavaScript
DESCRIPTION: Example of defining an Author entity using EntitySchema in vanilla JavaScript. Includes class definition with JSDoc comments for type hints and schema configuration with various property types and relationships.

LANGUAGE: javascript
CODE:
const { Collection, EntitySchema } = require('@mikro-orm/core');
const { Book } = require('./Book');
const { BaseEntity } = require('./BaseEntity');

/**
 * @property {number} id
 * @property {Date} createdAt
 * @property {Date} updatedAt
 * @property {string} name
 * @property {string} email
 * @property {number} age
 * @property {boolean} termsAccepted
 * @property {string[]} identities
 * @property {Date} born
 * @property {Collection<Book>} books
 * @property {Book} favouriteBook
 * @property {number} version
 * @property {string} versionAsString
 */
class Author extends BaseEntity {

  /**
   * @param {string} name
   * @param {string} email
   */
  constructor(name, email) {
    super();
    this.name = name;
    this.email = email;
    this.books = new Collection(this);
    this.createdAt = new Date();
    this.updatedAt = new Date();
    this.termsAccepted = false;
  }

}

export const schema = new EntitySchema({
  class: Author,
  properties: {
    name: { type: 'string' },
    email: { type: 'string', unique: true },
    age: { type: 'number', nullable: true },
    termsAccepted: { type: 'boolean', default: 0, onCreate: () => false },
    identities: { type: 'string[]', nullable: true },
    born: { type: DateType, nullable: true, length: 3 },
    books: { kind: '1:m', entity: () => 'Book', mappedBy: book => book.author },
    favouriteBook: { kind: 'm:1', type: 'Book' },
    version: { type: 'number', persist: false },
  },
});

module.exports.Author = Author;
module.exports.entity = Author;
module.exports.schema = schema;

----------------------------------------

TITLE: Reference Kind Enum Definition in TypeScript
DESCRIPTION: Enumeration of possible reference kinds for entity relationships in MikroORM, including scalar and various relationship types.

LANGUAGE: typescript
CODE:
export enum ReferenceKind {
  SCALAR = 'scalar',
  ONE_TO_ONE = '1:1',
  MANY_TO_ONE = 'm:1',
  ONE_TO_MANY = '1:m',
  MANY_TO_MANY = 'm:n',
  EMBEDDED = 'embedded',
}

----------------------------------------

TITLE: Defining Virtual Entity with SQL Expression in TypeScript
DESCRIPTION: This snippet demonstrates how to define a virtual entity using an SQL expression in TypeScript. It includes examples for reflect-metadata, ts-morph, and EntitySchema approaches.

LANGUAGE: typescript
CODE:
@Entity({
  expression: 'select name, age, ' +
    '(select count(*) from book b where b.author_id = a.id) as total_books, ' +
    '(select group_concat(distinct t.name) from book b ' +
      'join tags_ordered bt on bt.book_id = b.id ' +
      'join book_tag t on t.id = bt.book_tag_id ' +
      'where b.author_id = a.id ' +
      'group by b.author_id) as used_tags ' +
    'from author a group by a.id',
})
export class BookWithAuthor {

  @Property()
  title!: string;

  @Property()
  authorName!: string;

  @Property()
  tags!: string[];

}

----------------------------------------

TITLE: Configuring Loading Strategy at Entity Property Level in MikroORM
DESCRIPTION: This snippet shows how to configure the loading strategy for a specific relationship at the entity property level using MikroORM decorators.

LANGUAGE: typescript
CODE:
import { Entity, LoadStrategy, OneToMany } from '@mikro-orm/core';

@Entity()
export class Author {

  // ...

  @OneToMany({
    entity: () => Book,
    mappedBy: b => b.author,
    strategy: 'select-in', // force select-in strategy for this relation
  })
  books = new Collection<Book>(this);

}

----------------------------------------

TITLE: Running MikroORM Migrations Programmatically
DESCRIPTION: This example shows how to initialize MikroORM and use the Migrator programmatically to create and run migrations in a TypeScript script.

LANGUAGE: typescript
CODE:
import { MikroORM } from '@mikro-orm/core';
import { Migrator } from '@mikro-orm/migrations';

(async () => {
  const orm = await MikroORM.init({
    extensions: [Migrator],
    dbName: 'your-db-name',
    // ...
  });

  const migrator = orm.getMigrator();
  await migrator.createMigration(); // creates file Migration20191019195930.ts
  await migrator.up(); // runs migrations up to the latest
  await migrator.up('name'); // runs only given migration, up
  await migrator.up({ to: 'up-to-name' }); // runs migrations up to given version
  await migrator.down(); // migrates one step down
  await migrator.down('name'); // runs only given migration, down
  await migrator.down({ to: 'down-to-name' }); // runs migrations down to given version
  await migrator.down({ to: 0 }); // migrates down to the first version

  await orm.close(true);
})();

----------------------------------------

TITLE: Custom Pivot Table Entity in ManyToMany Relations
DESCRIPTION: Shows how to use a custom pivot table entity in ManyToMany relations, including the definition of the pivot entity and how to work with it.

LANGUAGE: typescript
CODE:
@Entity()
export class Order {

  @ManyToMany({ entity: () => Product, pivotEntity: () => OrderItem })
  products = new Collection<Product>(this);

}

@Entity()
export class Product {

  @ManyToMany({ entity: () => Order, mappedBy: o => o.products })
  orders = new Collection<Order>(this);

}

@Entity()
export class OrderItem {

  @ManyToOne({ primary: true })
  order: Order;

  @ManyToOne({ primary: true })
  product: Product;

  @Property({ default: 1 })
  amount!: number;

}

// create new item
const item = em.create(OrderItem, {
  order: 123,
  product: 321,
  amount: 999,
});
await em.persist(item).flush();

// or remove an item via delete query
const em.nativeDelete(OrderItem, { order: 123, product: 321 });

----------------------------------------

TITLE: Configuring MikroORM in NestJS Root Module
DESCRIPTION: Configuration of MikroORM in the root AppModule using forRoot() method with explicit configuration options.

LANGUAGE: typescript
CODE:
@Module({
  imports: [
    MikroOrmModule.forRoot({
      entities: ['./dist/entities'],
      entitiesTs: ['./src/entities'],
      dbName: 'my-db-name.sqlite3',
      type: 'sqlite',
    }),
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}

----------------------------------------

TITLE: Simple Derived Identity with OneToOne Relationship
DESCRIPTION: Shows how to implement a one-to-one relationship where the dependent entity (Address) reuses the primary key of its parent entity (User).

LANGUAGE: typescript
CODE:
@Entity()
export class User {

  @PrimaryKey()
  id!: number;

  @OneToOne(() => Address, address => address.user, { cascade: [Cascade.ALL] })
  address?: Address;

}

@Entity()
export class Address {

  @OneToOne({ primary: true })
  user!: User;

  [PrimaryKeyProp]?: 'user';

}

----------------------------------------

TITLE: Optimistic Locking Configuration
DESCRIPTION: Shows how to implement optimistic locking using version field annotations in entity definitions.

LANGUAGE: typescript
CODE:
export class User {
  // ...
  @Property({ version: true })
  version!: number;
  // ...
}

LANGUAGE: typescript
CODE:
export class User {
  // ...
  @Property({ version: true })
  version!: Date;
  // ...
}

----------------------------------------

TITLE: Entity Reference Initialization Example
DESCRIPTION: Shows how to work with entity references, including checking initialization status and lazy loading.

LANGUAGE: typescript
CODE:
const author = em.getReference(Author, 123);
console.log(author.id); // accessing the id will not trigger any db call
console.log(wrap(author).isInitialized()); // false
console.log(author.name); // undefined

await wrap(author).init(); // this will trigger db call
console.log(wrap(author).isInitialized()); // true
console.log(author.name); // defined

----------------------------------------

TITLE: Persisting and Querying Entities with Composite Primary Keys in MikroORM
DESCRIPTION: This snippet shows how to persist a new entity with a composite primary key and how to query for entities using both object and array notation for the primary key values.

LANGUAGE: typescript
CODE:
const car = new Car('Audi A8', 2010);
await em.persist(car).flush();

const audi1 = await em.findOneOrFail(Car, { name: 'Audi A8', year: 2010 });
const audi2 = await em.findOneOrFail(Car, ['Audi A8', 2010]);

----------------------------------------

TITLE: Configuring Advanced Options in MikroORM
DESCRIPTION: Demonstrates how to set various advanced options in MikroORM, including auto-joining, propagation, timezone forcing, and null value mapping.

LANGUAGE: typescript
CODE:
MikroORM.init({
  autoJoinOneToOneOwner: false,
  propagateToOneOwner: false,
  forceUtcTimezone: true,
  forceUndefined: true,
});

----------------------------------------

TITLE: Custom Base Entity Implementation
DESCRIPTION: Defines a custom base entity with common fields like id, createdAt, and updatedAt.

LANGUAGE: typescript
CODE:
export interface CustomBaseEntity {
  id: number;
  createdAt: Date;
  updatedAt: Date;
}

export const schema = new EntitySchema<CustomBaseEntity>({
  name: 'CustomBaseEntity',
  abstract: true,
  properties: {
    id: { type: 'number', primary: true },
    createdAt: { type: 'Date', onCreate: () => new Date(), nullable: true },
    updatedAt: { type: 'Date', onCreate: () => new Date(), onUpdate: () => new Date(), nullable: true },
  },
});

----------------------------------------

TITLE: Configuring Default Cache Settings in MikroORM
DESCRIPTION: Illustrates how to configure global cache settings when initializing MikroORM. It shows how to set the default adapter, expiration time, and enable global caching.

LANGUAGE: typescript
CODE:
const orm = await MikroORM.init({
  resultCache: {
    // following options are the defaults
    adapter: MemoryCacheAdapter,
    expiration: 1000, // 1s
    options: {},
    // cache can be also enabled globally
    // global: 50, // 50ms
  },
  // ...
});

----------------------------------------

TITLE: Configuring Generated Cache Adapter
DESCRIPTION: TypeScript configuration for using the generated cache bundle in production

LANGUAGE: typescript
CODE:
import { GeneratedCacheAdapter, MikroORM } from '@mikro-orm/core';

await MikroORM.init({
  metadataCache: {
    enabled: true,
    adapter: GeneratedCacheAdapter,
    options: { data: require('./temp/metadata.json') },
  },
  // ...
});

----------------------------------------

TITLE: Parameterless Filters in MikroORM
DESCRIPTION: Shows how to define filters that don't require parameters but need access to operation type.

LANGUAGE: typescript
CODE:
@Filter({
  name: 'withoutParams',
  cond(_, type) {
    return { ... };
  },
  args: false,
  default: true,
})

----------------------------------------

TITLE: Using Opt Type for Optional Properties in MikroORM
DESCRIPTION: This example demonstrates the use of the Opt type to define optional properties with default values in MikroORM, providing an alternative to the OptionalProps symbol approach.

LANGUAGE: typescript
CODE:
import { Opt, Entity, PrimaryKey, Property } from '@mikro-orm/core';

@Entity()
class User {

  @PrimaryKey()
  id!: number;

  @Property()
  firstName!: string;

  @Property()
  middleName: string & Opt = '';

  @Property()
  lastName!: string;

  @Property({ persist: false })
  get fullName(): Opt<string> {
    return `${this.firstName} ${this.middleName} ${this.lastName}`;
  }

}

----------------------------------------

TITLE: Initializing Entity Reference in MikroORM
DESCRIPTION: This code demonstrates how to work with entity references in MikroORM, including checking initialization status and lazy loading of entities.

LANGUAGE: typescript
CODE:
const user = em.getReference(User, 123);
console.log(user.id); // prints `123`, accessing the id will not trigger any db call
console.log(wrap(user).isInitialized()); // false, it's just a reference
console.log(user.name); // undefined

await wrap(user).init(); // this will trigger db call
console.log(wrap(user).isInitialized()); // true
console.log(user.name); // defined

----------------------------------------

TITLE: Using EntityManager Fork with Default Schema
DESCRIPTION: Examples of using EntityManager fork to set default schema for operations

LANGUAGE: typescript
CODE:
const fork = em.fork({ schema: 'client-123' });
await fork.findOne(User, { ... });

// Will yield the same result as
const user = await em.findOne(User, { ... }, { schema: 'client-123' });

----------------------------------------

TITLE: Embeddable Initialization in MikroORM
DESCRIPTION: Shows how to initialize embeddable properties with default values to avoid null values when all fields are nullable.

LANGUAGE: typescript
CODE:
@Embedded(() => Address)
address = new Address();

----------------------------------------

TITLE: Implementing Custom Naming Strategy in MikroORM (TypeScript)
DESCRIPTION: This snippet demonstrates how to create a custom naming strategy by implementing the NamingStrategy interface and providing it when initializing the ORM. It shows the basic structure for creating and using a custom naming strategy.

LANGUAGE: typescript
CODE:
class MyCustomNamingStrategy implements NamingStrategy {
  ...
}

const orm = await MikroORM.init({
  ...
  namingStrategy: MyCustomNamingStrategy,
  ...
});

----------------------------------------

TITLE: Defining a Car Entity with Composite Primary Key in TypeScript
DESCRIPTION: This snippet demonstrates how to create an entity with a composite primary key using primitive types (string and number) in MikroORM. It also shows the usage of the PrimaryKeyProp symbol for proper type checks in FilterQuery.

LANGUAGE: typescript
CODE:
@Entity()
export class Car {

  @PrimaryKey()
  name: string;

  @PrimaryKey()
  year: number;

  // this is needed for proper type checks in `FilterQuery`
  [PrimaryKeyProp]?: ['name', 'year'];

  constructor(name: string, year: number) {
    this.name = name;
    this.year = year;
  }

}

----------------------------------------

TITLE: Initializing MikroORM with MongoDB Driver
DESCRIPTION: Demonstrates how to initialize MikroORM with the MongoDB driver, specifying entities and database connection details.

LANGUAGE: typescript
CODE:
import { MikroORM } from '@mikro-orm/mongodb'; // or any other driver package

const orm = await MikroORM.init({
  entities: [Author, Book, ...],
  dbName: 'my-db-name',
  clientUrl: '...',
});
console.log(orm.em); // access EntityManager via `em` property

----------------------------------------

TITLE: Setting Transaction Isolation Level in MikroORM (TypeScript)
DESCRIPTION: Demonstrates how to set a specific isolation level for a transaction in MikroORM. This allows for fine-tuning of transaction behavior.

LANGUAGE: typescript
CODE:
await orm.em.transactional(async em => {
  // ...
}, { isolationLevel: IsolationLevel.READ_UNCOMMITTED });

----------------------------------------

TITLE: Adding Authentication to AdminJS with Hapi
DESCRIPTION: TypeScript code snippet showing how to add authentication to AdminJS when using Hapi. Adds an auth property to the AdminJS options.

LANGUAGE: typescript
CODE:
const ADMIN_EMAIL = 'example@test.com';
const ADMIN_PASSWORD = 'password';

const adminOptions = {
  databases: [orm],
  auth: {
    authenticate: async (email, password) => {
      /* Your code for verifying email & password goes here */
      return email === ADMIN_EMAIL && password === ADMIN_PASSWORD
        ? { email } // the function should return an object containing user's data if authenticated successfully
        : null;
    },
    strategy: 'session',
    cookiePassword: process.env.COOKIE_PASSWORD ?? 'makesurepasswordissecure',
    isSecure: false, // only https requests
  },
};

----------------------------------------

TITLE: TypeScript Configuration for MikroORM
DESCRIPTION: TypeScript compiler configuration settings required for MikroORM with ESM support

LANGUAGE: json
CODE:
{
  "compilerOptions": {
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "target": "ES2022",
    "strict": true,
    "outDir": "dist",
    "declaration": true,
    "experimentalDecorators": true
  },
  "include": [
    "./src/**/*.ts"
  ]
}

----------------------------------------

TITLE: Implementing Custom RedisCacheAdapter in TypeScript
DESCRIPTION: This snippet shows a skeleton implementation of a custom RedisCacheAdapter class that implements the CacheAdapter interface, potentially for using Redis as a cache storage.

LANGUAGE: typescript
CODE:
export class RedisCacheAdapter implements CacheAdapter { ... }

----------------------------------------

TITLE: Using em.create() to Create Entity Graph in TypeScript with MikroORM
DESCRIPTION: Demonstrates how to use EntityManager's create method to instantiate an Article entity with related User data. Shows how to persist the created entity to the database.

LANGUAGE: TypeScript
CODE:
const article = em.create(Article, {
  title: 'Foo is Bar',
  text: 'Lorem impsum dolor sit amet',
  author: user.id,
});

await em.persist(article).flush();
console.log(article);

----------------------------------------

TITLE: Initializing TsMorphMetadataProvider in TypeScript
DESCRIPTION: Demonstrates how to initialize MikroORM with TsMorphMetadataProvider, which uses ts-morph to read TypeScript source files for type detection.

LANGUAGE: typescript
CODE:
import { TsMorphMetadataProvider } from '@mikro-orm/reflection';

await MikroORM.init({
  metadataProvider: TsMorphMetadataProvider,
  // ...
});

----------------------------------------

TITLE: Creating Indexes on JSON Properties in MikroORM
DESCRIPTION: Demonstrates how to create single and compound indexes on JSON properties using @Index and @Unique decorators.

LANGUAGE: typescript
CODE:
@Entity()
@Index({ properties: 'metaData.foo' })
@Index({ properties: ['metaData.foo', 'metaData.bar'] }) // compound index
export class Book {

  @Property({ type: 'json', nullable: true })
  metaData?: { foo: string; bar: number };

}

----------------------------------------

TITLE: Setting Global Loading Strategy in MikroORM Configuration
DESCRIPTION: This example demonstrates how to set a global default loading strategy in the MikroORM configuration.

LANGUAGE: typescript
CODE:
MikroORM.init({
  // ...
  populate: ['books'],
  loadStrategy: 'select-in', // 'joined' is the default for SQL drivers
});

----------------------------------------

TITLE: Entity Reference Initialization Example
DESCRIPTION: Shows how to work with entity references, including checking initialization status and lazy loading.

LANGUAGE: typescript
CODE:
const author = em.getReference(Author, 123);
console.log(author.id); // accessing the id will not trigger any db call
console.log(wrap(author).isInitialized()); // false
console.log(author.name); // undefined

await wrap(author).init(); // this will trigger db call
console.log(wrap(author).isInitialized()); // true
console.log(author.name); // defined

----------------------------------------

TITLE: Implementing Composite Primary Keys with Primitive Types in TypeScript
DESCRIPTION: Demonstrates how to create an entity with composite primary keys using primitive types (string and number) in MikroORM. Includes type definition for proper FilterQuery checks.

LANGUAGE: typescript
CODE:
@Entity()
export class Car {

  @PrimaryKey()
  name: string;

  @PrimaryKey()
  year: number;

  [PrimaryKeyType]: [string, number]; // this is needed for proper type checks in `FilterQuery`

  constructor(name: string, year: number) {
    this.name = name;
    this.year = year;
  }

}

----------------------------------------

TITLE: Implicit Transaction Handling in MikroORM (TypeScript)
DESCRIPTION: Demonstrates implicit transaction handling using MikroORM's EntityManager. The transaction is automatically managed when persisting and flushing a new User entity.

LANGUAGE: typescript
CODE:
const user = new User(...);
user.name = 'George';
await orm.em.persistAndFlush(user);

----------------------------------------

TITLE: Clearing Identity Map Cache
DESCRIPTION: Shows how to clear the identity map cache using the EntityManager clear method.

LANGUAGE: typescript
CODE:
orm.em.clear();

----------------------------------------

TITLE: Configuring Specific Logger Namespaces in MikroORM (TypeScript)
DESCRIPTION: Shows how to configure MikroORM to log only specific namespaces, in this case, only queries will be logged.

LANGUAGE: typescript
CODE:
return MikroORM.init({
  debug: ['query'], // now only queries will be logged
});

----------------------------------------

TITLE: Defining MongoDB Entity Structure
DESCRIPTION: Example of defining a MongoDB entity with primary key configuration using ObjectId and SerializedPrimaryKey decorators.

LANGUAGE: typescript
CODE:
@PrimaryKey()
_id: ObjectId;

@SerializedPrimaryKey()
id!: string; // won't be saved in the database

----------------------------------------

TITLE: Using MikroORM Migrator Programmatically in TypeScript
DESCRIPTION: Example of how to use the MikroORM Migrator programmatically in a TypeScript script, including initialization and various migration operations.

LANGUAGE: typescript
CODE:
import { MikroORM } from 'mikro-orm';

(async () => {
  const orm = await MikroORM.init({
    dbName: 'your-db-name',
    // ...
  });

  const migrator = orm.getMigrator();
  await migrator.createMigration(); // creates file Migration20191019195930.ts
  await migrator.up(); // runs migrations up to the latest
  await migrator.up('name'); // runs only given migration, up
  await migrator.up({ to: 'up-to-name' }); // runs migrations up to given version
  await migrator.down(); // migrates one step down
  await migrator.down('name'); // runs only given migration, down
  await migrator.down({ to: 'down-to-name' }); // runs migrations down to given version
  await migrator.down({ to: 0 }); // migrates down to the first version

  await orm.close(true);
})();

----------------------------------------

TITLE: Basic Entity Reference Update in TypeScript
DESCRIPTION: Demonstrates the traditional way of updating entity references using em.getReference()

LANGUAGE: typescript
CODE:
const jon = new Author('Jon Snow', 'snow@wall.st');
const book = new Book('Book', jon);
book.author = em.getReference(Author, '...id...');

----------------------------------------

TITLE: Implementing Custom DateType in TypeScript
DESCRIPTION: Example of implementing a custom DateType class that extends the Type abstract class to handle date conversions between JavaScript Date objects and database string representations.

LANGUAGE: typescript
CODE:
import { Type, Platform, EntityProperty, ValidationError } from '@mikro-orm/core';

export class DateType extends Type<Date, string> {

  convertToDatabaseValue(value: Date | string | undefined, platform: Platform): string {
    if (value instanceof Date) {
      return value.toISOString().substr(0, 10);
    }

    if (!value || value.toString().match(/^\d{4}-\d{2}-\d{2}$/)) {
      return value as string;
    }

    throw ValidationError.invalidType(DateType, value, 'JS');
  }

  convertToJSValue(value: Date | string | undefined, platform: Platform): Date {
    if (!value || value instanceof Date) {
      return value as Date;
    }

    const date = new Date(value);

    if (date.toString() === 'Invalid Date') {
      throw ValidationError.invalidType(DateType, value, 'database');
    }

    return date;
  }

  getColumnType(prop: EntityProperty, platform: Platform) {
    return `date(${prop.length})`;
  }

}

----------------------------------------

TITLE: Defining OneToOne Relationships (Owning Side) in TypeScript with MikroORM
DESCRIPTION: This snippet demonstrates how to define the owning side of a OneToOne relationship in MikroORM using TypeScript. It shows different ways to specify the owning side, including using the `inversedBy` attribute and the `owner: true` option.

LANGUAGE: typescript
CODE:
@Entity()
export class User {

  // when none of `owner/inverseBy/mappedBy` is provided, it will be considered owning side
  @OneToOne()
  bestFriend1!: User;

  // side with `inversedBy` is the owning one, to define inverse side use `mappedBy`
  @OneToOne({ inversedBy: 'bestFriend1' })
  bestFriend2!: User;

  // when defining it like this, you need to specifically mark the owning side with `owner: true`
  @OneToOne(() => User, user => user.bestFriend2, { owner: true })
  bestFriend3!: User;

}

----------------------------------------

TITLE: Implementing Custom Naming Strategy in TypeScript
DESCRIPTION: Example showing how to implement and configure a custom naming strategy by implementing the NamingStrategy interface and initializing it with MikroORM.

LANGUAGE: typescript
CODE:
class MyCustomNamingStrategy implements NamingStrategy {
  ...
}

const orm = await MikroORM.init({
  ...
  namingStrategy: MyCustomNamingStrategy,
  ...
});

----------------------------------------

TITLE: Implementing Nested Embeddables in MikroORM
DESCRIPTION: This complex example demonstrates how to use nested embeddables in both inline and object modes, including a User entity with a Profile embeddable containing an Identity embeddable.

LANGUAGE: typescript
CODE:
@Entity()
class User {

  @PrimaryKey()
  id!: number;

  @Property()
  name!: string;

  @Embedded(() => Profile, { object: true, nullable: true })
  profile?: Profile;

}

@Embeddable()
class Profile {

  @Property()
  username: string;

  @Embedded(() => Identity)
  identity: Identity;

  constructor(username: string, identity: Identity) {
    this.username = username;
    this.identity = identity;
  }

}

@Embeddable()
class Identity {

  @Property()
  email: string;

  constructor(email: string) {
    this.email = email;
  }

}

----------------------------------------

TITLE: Using Dataloader with Promise.all for Multiple Entities (TypeScript)
DESCRIPTION: These snippets show how to use dataloaders with Promise.all to efficiently load related entities. The first example loads books for multiple authors, while the second loads authors for multiple books.

LANGUAGE: typescript
CODE:
const authors = await orm.em.find(Author, [1, 2, 3]);
await Promise.all(authors.map(author => author.books.load({ dataloader: true })));

LANGUAGE: typescript
CODE:
const books = await orm.em.find(Book, [1, 2, 3]);
await Promise.all(books.map(book => book.author.load({ dataloader: true })));

----------------------------------------

TITLE: Custom Logger Implementation
DESCRIPTION: Demonstrates how to create a custom logger by extending the DefaultLogger class with custom logging behavior.

LANGUAGE: typescript
CODE:
class CustomLogger extends DefaultLogger {
  log(namespace: LoggerNamespace, message: string, context?: LogContext) {
    // Create your own implementation for output:
    console.log(`[${namespace}] (${context.label}) ${message}`);

    // OR Utilize DefaultLogger's implementation:
    super.log(namespace, message, context)
  }
}

return MikroORM.init({
  debug: true,
  loggerFactory: (options) => new CustomLogger(options),
});

----------------------------------------

TITLE: Upsert Operations in MikroORM
DESCRIPTION: Shows how to perform upsert operations (insert or update) using EntityManager in MikroORM.

LANGUAGE: typescript
CODE:
const author = await em.upsert(Author, { email: 'foo@bar.com', age: 33 });

const [author1, author2, author3] = await em.upsertMany(Author, [
  { email: 'a1', age: 41 },
  { email: 'a2', age: 42 },
  { email: 'a3', age: 43 },
]);

----------------------------------------

TITLE: Implementing Custom Platform Class in TypeScript
DESCRIPTION: Platform class that defines database feature capabilities and settings. Extends the base Platform class from MikroORM core and provides methods for handling database-specific features and configurations.

LANGUAGE: typescript
CODE:
import { Platform } from '@mikro-orm/core';

export class MyCustomPlatform extends Platform {

  protected abstract schemaHelper: MyCustomSchemaHelper;

  // here you can override default settings
  usesPivotTable(): boolean;
  supportsTransactions(): boolean;
  supportsSavePoints(): boolean;
  getNamingStrategy(): { new (): NamingStrategy; };
  getIdentifierQuoteCharacter(): string;
  getParameterPlaceholder(index?: number): string;
  usesReturningStatement(): boolean;
  normalizePrimaryKey<T = number | string>(data: IPrimaryKey): T;
  denormalizePrimaryKey(data: IPrimaryKey): IPrimaryKey;
  getSerializedPrimaryKeyField(field: string): string;

}

----------------------------------------

TITLE: Disabling Metadata Cache in MikroORM TypeScript
DESCRIPTION: Configuration snippet showing how to disable metadata caching in MikroORM initialization.

LANGUAGE: typescript
CODE:
await MikroORM.init({
  metadataCache: { enabled: false },
  // ...
});

----------------------------------------

TITLE: Implementing Custom Date Type in TypeScript with MikroORM
DESCRIPTION: Custom implementation of a date type that maps SQL date columns to JS Date objects. Includes conversion methods for database and JavaScript values, and column type definition.

LANGUAGE: typescript
CODE:
import { Type, Platform, EntityProperty, ValidationError } from '@mikro-orm/core';

export class MyDateType extends Type<Date, string> {

  convertToDatabaseValue(value: Date | string | undefined, platform: Platform): string {
    if (value instanceof Date) {
      return value.toISOString().substr(0, 10);
    }

    if (!value || value.toString().match(/^\d{4}-\d{2}-\d{2}$/)) {
      return value as string;
    }

    throw ValidationError.invalidType(MyDateType, value, 'JS');
  }

  convertToJSValue(value: Date | string | undefined, platform: Platform): Date {
    if (!value || value instanceof Date) {
      return value as Date;
    }

    const date = new Date(value);

    if (date.toString() === 'Invalid Date') {
      throw ValidationError.invalidType(MyDateType, value, 'database');
    }

    return date;
  }

  getColumnType(prop: EntityProperty, platform: Platform) {
    return `date(${prop.length})`;
  }

}

----------------------------------------

TITLE: Concurrency Check Implementation in MikroORM
DESCRIPTION: Demonstrates how to implement concurrency checks using property decorators.

LANGUAGE: typescript
CODE:
@Entity()
export class ConcurrencyCheckUser {
  @PrimaryKey({ length: 100 })
  firstName: string;

  @PrimaryKey({ length: 100 })
  lastName: string;

  @Property({ concurrencyCheck: true })
  age: number;

  @Property({ nullable: true })
  other?: string;
}

----------------------------------------

TITLE: Defining JSON Property in MikroORM Entity (TypeScript)
DESCRIPTION: Demonstrates how to define a JSON property in a MikroORM entity using the @Property decorator with the 'json' type. The example shows a nullable JSON property 'meta' with a specific structure.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @Property({ type: 'json', nullable: true })
  meta?: { foo: string; bar: number };

}

----------------------------------------

TITLE: CacheAdapter Interface Definition
DESCRIPTION: Interface definition for implementing custom cache adapters in MikroORM, including required methods for getting, setting, removing, and clearing cached items.

LANGUAGE: typescript
CODE:
export interface CacheAdapter {

  /**
   * Gets the items under `name` key from the cache.
   */
  get(name: string): Promise<any>;

  /**
   * Sets the item to the cache. `origin` is used for cache invalidation and should reflect the change in data.
   */
  set(name: string, data: any, origin: string, expiration?: number): Promise<void>;

  /**
   * Removes the item from cache.
   */
  remove(name: string): Promise<void>;

  /**
   * Clears all items stored in the cache.
   */
  clear(): Promise<void>;

  /**
   * Called inside `MikroORM.close()` Allows graceful shutdowns (e.g. for redis).
   */
  close?(): Promise<void>;

}

----------------------------------------

TITLE: Custom Author Entity Class Definition
DESCRIPTION: Example of defining a custom Author entity class with various property types and relationships.

LANGUAGE: typescript
CODE:
export class Author extends CustomBaseEntity {
  name: string;
  email: string;
  age?: number;
  termsAccepted?: boolean;
  identities?: string[];
  born?: Date;
  books = new Collection<Book>(this);
  favouriteBook?: Book;
  version?: number;

  constructor(name: string, email: string) {
    super();
    this.name = name;
    this.email = email;
  }
}

export const schema = new EntitySchema<Author, CustomBaseEntity>({
  class: Author,
  extends: CustomBaseEntitySchema,
  properties: {
    name: { type: 'string' },
    email: { type: 'string', unique: true },
    age: { type: 'number', nullable: true },
    termsAccepted: { type: 'boolean', default: 0, onCreate: () => false },
    identities: { type: 'string[]', nullable: true },
    born: { type: DateType, nullable: true, length: 3 },
    books: { kind: '1:m', entity: () => 'Book', mappedBy: book => book.author },
    favouriteBook: { kind: 'm:1', type: 'Book' },
    version: { type: 'number', persist: false },
  },
});

----------------------------------------

TITLE: Implementing Custom Date Type in TypeScript for MikroORM
DESCRIPTION: This snippet demonstrates how to create a custom date type by extending the Type abstract class. It includes methods for converting between database and JavaScript representations, as well as defining the column type.

LANGUAGE: typescript
CODE:
import { Type, Platform, EntityProperty, ValidationError } from '@mikro-orm/core';

/**
 * A custom type that maps SQL date column to JS Date objects.
 * Note that the ORM DateType maps to string instead of Date.
 */
export class MyDateType extends Type<Date, string> {

  convertToDatabaseValue(value: Date | string | undefined, platform: Platform): string {
    if (value instanceof Date) {
      return value.toISOString().substr(0, 10);
    }

    if (!value || value.toString().match(/^\d{4}-\d{2}-\d{2}$/)) {
      return value as string;
    }

    throw ValidationError.invalidType(MyDateType, value, 'JS');
  }

  convertToJSValue(value: Date | string | undefined, platform: Platform): Date {
    if (!value || value instanceof Date) {
      return value as Date;
    }

    const date = new Date(value);

    if (date.toString() === 'Invalid Date') {
      throw ValidationError.invalidType(MyDateType, value, 'database');
    }

    return date;
  }

  getColumnType(prop: EntityProperty, platform: Platform) {
    return `date(${prop.length})`;
  }

}

----------------------------------------

TITLE: Enabling Pretty Printing for Metadata Cache in MikroORM
DESCRIPTION: Configuration to enable pretty printing of cached metadata JSON instead of single-line format.

LANGUAGE: typescript
CODE:
await MikroORM.init({
  metadataCache: { pretty: true },
  // ...
});

----------------------------------------

TITLE: Querying JSON Object Properties in TypeScript with MikroORM
DESCRIPTION: Shows how to query JSON object properties using MikroORM's EntityManager. The example demonstrates querying nested JSON structures with various data types.

LANGUAGE: typescript
CODE:
const b = await em.findOne(Book, {
  meta: {
    valid: true,
    nested: {
      foo: '123',
      bar: 321,
      deep: {
        baz: 59,
        qux: false,
      },
    },
  },
});

----------------------------------------

TITLE: Clearing Identity Map Cache in MikroORM with TypeScript
DESCRIPTION: This snippet demonstrates how to clear the Identity Map cache using the em.clear() method.

LANGUAGE: typescript
CODE:
orm.em.clear();

----------------------------------------

TITLE: Using raw() Helper in MikroORM Filters (TypeScript)
DESCRIPTION: Demonstrates how to use the raw() helper in MikroORM filters. It uses a callback signature to create a new raw instance for every filter usage, which is necessary when using the fragment as an object key.

LANGUAGE: typescript
CODE:
@Filter({ name: 'long', cond: () => ({ [raw('length(perex)')]: { $gt: 10000 } }) })

----------------------------------------

TITLE: Custom Logger Implementation
DESCRIPTION: Demonstrates how to create a custom logger by extending the DefaultLogger class with custom logging behavior.

LANGUAGE: typescript
CODE:
class CustomLogger extends DefaultLogger {
  log(namespace: LoggerNamespace, message: string, context?: LogContext) {
    // Create your own implementation for output:
    console.log(`[${namespace}] (${context.label}) ${message}`);

    // OR Utilize DefaultLogger's implementation:
    super.log(namespace, message, context)
  }
}

return MikroORM.init({
  debug: true,
  loggerFactory: (options) => new CustomLogger(options),
});

----------------------------------------

TITLE: Entity Update Using assign() Helper
DESCRIPTION: Shows how to update entity values using the assign() helper method with direct ID references

LANGUAGE: typescript
CODE:
import { wrap } from '@mikro-orm/core';

wrap(book).assign({
  title: 'Better Book 1',
  author: '...id...',
});
console.log(book.title); // 'Better Book 1'
console.log(book.author); // instance of Author with id: '...id...'
console.log(book.author.id); // '...id...'

----------------------------------------

TITLE: Persisting Changes to Managed Entities in MikroORM with TypeScript
DESCRIPTION: This code snippet illustrates how MikroORM automatically tracks changes to managed entities. It shows that modifying a fetched entity and calling flush() will update the database without explicitly calling persist().

LANGUAGE: typescript
CODE:
const authorRepository = orm.em.getRepository(Author);
const jon = await authorRepository.findOne(1);
jon.email = 'foo@bar.com';
await authorRepository.flush(); // calling orm.em.flush() has same effect

----------------------------------------

TITLE: Initializing MikroORM Dataloaders Configuration
DESCRIPTION: Shows how to enable dataloaders globally in MikroORM initialization. Supports options for REFERENCE, COLLECTION, or ALL types of dataloaders.

LANGUAGE: typescript
CODE:
import { Dataloader } from '@mikro-orm/core';

MikroORM.init({
  dataloader: Dataloader.ALL,
});

----------------------------------------

TITLE: OneToMany Relationship Configuration in MikroORM
DESCRIPTION: Shows how to configure OneToMany relationships between entities using decorators. Includes both direct and options object approaches.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @PrimaryKey()
  _id!: ObjectId;

  @ManyToOne()
  author!: Author;

}

@Entity()
export class Author {

  @PrimaryKey()
  _id!: ObjectId;

  @OneToMany(() => Book, book => book.author)
  books1 = new Collection<Book>(this);

  // or via options object
  @OneToMany({ entity: () => Book, mappedBy: 'author' })
  books2 = new Collection<Book>(this);

}

----------------------------------------

TITLE: Initializing MikroORM with Read Replicas in TypeScript
DESCRIPTION: This snippet shows how to initialize MikroORM with multiple read replica connections. It demonstrates specifying different hosts and users for read replicas, with unspecified fields being inherited from the master connection.

LANGUAGE: typescript
CODE:
const orm = await MikroORM.init({
  entities: [Author, ...],
  dbName: `my_database`,
  type: 'mysql',
  user: 'master_user',
  host: 'master_host',
  replicas: [
    { name: 'read-1', host: 'read_host_1', user: 'read_user' },
    { name: 'read-2', host: 'read_host_2' }, // user omitted, will be taken from master connection
  ],
});

----------------------------------------

TITLE: Basic Entity Definition with @Entity Decorator
DESCRIPTION: Shows how to define a basic entity class using the @Entity decorator with table name configuration.

LANGUAGE: typescript
CODE:
@Entity({ tableName: 'authors' })
export class Author { ... }

----------------------------------------

TITLE: Using EntityManager Fork with Default Schema
DESCRIPTION: Examples of using EntityManager fork to set default schema for operations.

LANGUAGE: typescript
CODE:
const fork = em.fork({ schema: 'client-123' });
await fork.findOne(User, { ... });

// Will yield the same result as
const user = await em.findOne(User, { ... }, { schema: 'client-123' });

----------------------------------------

TITLE: Implementing Global EventSubscriber
DESCRIPTION: Implementation of an EventSubscriber that listens to all entity events across the application.

LANGUAGE: typescript
CODE:
import { EventArgs, EventSubscriber, Subscriber } from '@mikro-orm/core';

@Subscriber()
export class EverythingSubscriber implements EventSubscriber {

  async beforeCreate<T>(args: EventArgs<T>): Promise<void> { ... }
  async afterCreate<T>(args: EventArgs<T>): Promise<void> { ... }
  async beforeUpdate<T>(args: EventArgs<T>): Promise<void> { ... }
  async afterUpdate<T>(args: EventArgs<T>): Promise<void> { ... }
  async beforeDelete<T>(args: EventArgs<T>): Promise<void> { ... }
  async afterDelete<T>(args: EventArgs<T>): Promise<void> { ... }
  async beforeFlush<T>(args: EventArgs<T>): Promise<void> { ... }
  async onFlush<T>(args: EventArgs<T>): Promise<void> { ... }
  async afterFlush<T>(args: EventArgs<T>): Promise<void> { ... }
  onInit<T>(args: EventArgs<T>): void { ... }

}

----------------------------------------

TITLE: Implementing Comprehensive EventSubscriber in TypeScript
DESCRIPTION: Example of an EventSubscriber that hooks into all possible events for all entities. This includes entity lifecycle events, flush events, and transaction events.

LANGUAGE: typescript
CODE:
import { EventArgs, TransactionEventArgs, EventSubscriber } from '@mikro-orm/core';

export class EverythingSubscriber implements EventSubscriber {

  // entity life cycle events
  onInit<T>(args: EventArgs<T>): void { ... }
  async onLoad<T>(args: EventArgs<T>): Promise<void> { ... }
  async beforeCreate<T>(args: EventArgs<T>): Promise<void> { ... }
  async afterCreate<T>(args: EventArgs<T>): Promise<void> { ... }
  async beforeUpdate<T>(args: EventArgs<T>): Promise<void> { ... }
  async afterUpdate<T>(args: EventArgs<T>): Promise<void> { ... }
  async beforeUpsert<T>(args: EventArgs<T>): Promise<void> { ... }
  async afterUpsert<T>(args: EventArgs<T>): Promise<void> { ... }
  async beforeDelete<T>(args: EventArgs<T>): Promise<void> { ... }
  async afterDelete<T>(args: EventArgs<T>): Promise<void> { ... }

  // flush events
  async beforeFlush<T>(args: FlushEventArgs): Promise<void> { ... }
  async onFlush<T>(args: FlushEventArgs): Promise<void> { ... }
  async afterFlush<T>(args: FlushEventArgs): Promise<void> { ... }

  // transaction events
  async beforeTransactionStart(args: TransactionEventArgs): Promise<void> { ... }
  async afterTransactionStart(args: TransactionEventArgs): Promise<void> { ... }
  async beforeTransactionCommit(args: TransactionEventArgs): Promise<void> { ... }
  async afterTransactionCommit(args: TransactionEventArgs): Promise<void> { ... }
  async beforeTransactionRollback(args: TransactionEventArgs): Promise<void> { ... }
  async afterTransactionRollback(args: TransactionEventArgs): Promise<void> { ... }

}

----------------------------------------

TITLE: Configuring Custom Cache Adapter
DESCRIPTION: Configuration snippet demonstrating how to use a custom cache adapter implementation in MikroORM initialization.

LANGUAGE: typescript
CODE:
await MikroORM.init({
  cache: { adapter: RedisCacheAdapter, options: { ... } },
  // ...
});

----------------------------------------

TITLE: Implementing Explicit Discriminator Column in Single Table Inheritance
DESCRIPTION: This snippet demonstrates how to explicitly define a discriminator column in Single Table Inheritance. It allows for querying by type and includes the column in serialized responses. It also shows how to use an abstract class as the root entity.

LANGUAGE: typescript
CODE:
@Entity({
  discriminatorColumn: 'type',
  discriminatorMap: { person: 'Person', employee: 'Employee' },
})
export abstract class BasePerson {

  @Enum()
  type!: 'person' | 'employee';

}

@Entity()
export class Person extends BasePerson {
  // ...
}

@Entity()
export class Employee extends Person {
  // ...
}

----------------------------------------

TITLE: Using raw() Helper for SQL Fragments in MikroORM Queries (TypeScript)
DESCRIPTION: Demonstrates how to use the raw() helper function to include raw SQL fragments in MikroORM queries. It shows usage as both values and keys, and includes an example with a callback function.

LANGUAGE: typescript
CODE:
// as a value
await em.find(User, { time: raw('now()') });

// as a key
await em.find(User, { [raw('lower(name)')]: name.toLowerCase() });

// value can be empty array
await em.find(User, { [raw('(select 1 = 1)')]: [] });

// with callback
await em.find(User, { [raw(alias => `lower(${alias}.name)`)]: name.toLowerCase() });

----------------------------------------

TITLE: Defining Nullable Property in MikroORM
DESCRIPTION: This snippet demonstrates how to define a nullable property in MikroORM using the @Property decorator with the nullable option set to true.

LANGUAGE: typescript
CODE:
@Property({ nullable: true })
name?: string;

----------------------------------------

TITLE: Checking Database Connection Status in MikroORM
DESCRIPTION: Demonstrates two methods to check the database connection status in MikroORM: isConnected() for a boolean result and checkConnection() for a more detailed status object.

LANGUAGE: ts
CODE:
// boolean
const isConnected = await orm.isConnected();
// object with `ok`, `reason` and `error` keys
const check = await orm.checkConnection();

console.log(check.ok, check.reason);

----------------------------------------

TITLE: Disabling Metadata Cache in MikroORM TypeScript
DESCRIPTION: Configuration snippet showing how to disable metadata caching when initializing MikroORM.

LANGUAGE: typescript
CODE:
await MikroORM.init({
  metadataCache: { enabled: false },
  // ...
});

----------------------------------------

TITLE: Using MikroORM Seeders in Tests
DESCRIPTION: Demonstrates how to use seeders in test setups, including refreshing the database and running a seeder before tests.

LANGUAGE: typescript
CODE:
beforeAll(async () => {
  // Get seeder from MikroORM
  const seeder = orm.getSeeder();

  // Refresh the database to start clean (work in mongo too since v5)
  await orm.schema.refreshDatabase();

  // Seed using a seeder defined by you
  await seeder.seed(DatabaseSeeder);
});

test(() => {
  // Do tests
});

afterAll(async () => {
  // Close connection
  await orm.close();
});

----------------------------------------

TITLE: Manually Defining Entities for MikroORM Initialization in TypeScript
DESCRIPTION: This code snippet shows how to manually define entities when initializing MikroORM. It disables dynamic file access and explicitly lists the entity classes to be used.

LANGUAGE: typescript
CODE:
import { Author, Book, BookTag, Publisher, Test } from '../entities';

await MikroORM.init({
  ...
  entities: [Author, Book, BookTag, Publisher, Test],
  discovery: { disableDynamicFileAccess: true },
  ...
});

----------------------------------------

TITLE: Using raw() Helper for SQL Fragments in MikroORM Queries (TypeScript)
DESCRIPTION: Demonstrates how to use the raw() helper to include raw SQL fragments in MikroORM queries. It shows usage as values, keys, with operators, and with empty arrays. The raw() helper is required since v6 for using raw SQL fragments in queries.

LANGUAGE: typescript
CODE:
// as a value
await em.find(User, { time: raw('now()') });

// as a key
await em.find(User, { [raw('lower(name)')]: name.toLowerCase() });

// with operators
await em.find(User, { [raw('lower(name)')]: { $like: name.toLowerCase() } });

// value can be empty array to skip operator
await em.find(User, { [raw('(select 1 = 1)')]: [] });

----------------------------------------

TITLE: Configuring Custom Cache Adapter in MikroORM
DESCRIPTION: Configuration example showing how to use a custom cache adapter implementation in MikroORM initialization.

LANGUAGE: typescript
CODE:
await MikroORM.init({
  metadataCache: { adapter: RedisCacheAdapter, options: { ... } },
  // ...
});

----------------------------------------

TITLE: Forking Entity Manager
DESCRIPTION: Example of creating a new EntityManager instance with its own context and identity map.

LANGUAGE: typescript
CODE:
const em = orm.em.fork();

----------------------------------------

TITLE: Configuring MikroORM Seeder Options
DESCRIPTION: Configuration options for MikroORM seeder including path settings, default seeder class, and file naming conventions.

LANGUAGE: typescript
CODE:
MikroORM.init({
  seeder: {
    path: './seeders', // path to the folder with seeders
    pathTs: undefined, // path to the folder with TS seeders (if used, we should put path to compiled files in `path`)
    defaultSeeder: 'DatabaseSeeder', // default seeder class name
    glob: '!(*.d).{js,ts}', // how to match seeder files (all .js and .ts files, but not .d.ts)
    emit: 'ts', // seeder generation mode
    fileName: (className: string) => className, // seeder file naming convention
  },
});

----------------------------------------

TITLE: Configuring Jest Fake Timers for MikroORM
DESCRIPTION: Basic configuration to prevent Jest from mocking process.nextTick() while still allowing other timer mocks.

LANGUAGE: typescript
CODE:
jest.useFakeTimers({ doNotFake: ['nextTick'] });

----------------------------------------

TITLE: Defining Parameter-less Filters in MikroORM
DESCRIPTION: Demonstrates how to create filters that don't require parameters but need access to the operation type parameter.

LANGUAGE: typescript
CODE:
@Filter({
  name: 'withoutParams',
  cond(_, type) {
    return { ... };
  },
  args: false,
  default: true,
})

----------------------------------------

TITLE: Configuring Custom AsyncLocalStorage in MikroORM
DESCRIPTION: Shows how to set up a custom AsyncLocalStorage instance for managing request context in MikroORM.

LANGUAGE: typescript
CODE:
const storage = new AsyncLocalStorage<EntityManager>();

const orm = await MikroORM.init({
  context: () => storage.getStore(),
  // ...
});

app.use((req, res, next) => {
  storage.run(orm.em.fork({ useContext: true }), next);
});

----------------------------------------

TITLE: Defining Entity with Generated Columns
DESCRIPTION: Example of defining an entity with SQL generated columns

LANGUAGE: typescript
CODE:
@Entity()
export class User {

  @PrimaryKey()
  id!: number;

  @Property({ length: 50 })
  firstName!: string;

  @Property({ length: 50 })
  lastName!: string;

  @Property<User>({ length: 100, generated: cols => `(concat(${cols.firstName}, ' ', ${cols.lastName})) stored` })
  fullName!: string & Opt;

  @Property({ columnType: `varchar(100) generated always as (concat(first_name, ' ', last_name)) virtual` })
  fullName2!: string & Opt;

}

----------------------------------------

TITLE: Defining Entity with Generated Columns
DESCRIPTION: Example of defining an entity with SQL generated columns

LANGUAGE: typescript
CODE:
@Entity()
export class User {

  @PrimaryKey()
  id!: number;

  @Property({ length: 50 })
  firstName!: string;

  @Property({ length: 50 })
  lastName!: string;

  @Property<User>({ length: 100, generated: cols => `(concat(${cols.firstName}, ' ', ${cols.lastName})) stored` })
  fullName!: string & Opt;

  @Property({ columnType: `varchar(100) generated always as (concat(first_name, ' ', last_name)) virtual` })
  fullName2!: string & Opt;

}

----------------------------------------

TITLE: Configuring Custom Cache Adapter in MikroORM
DESCRIPTION: Configuration example showing how to use a custom cache adapter implementation in MikroORM initialization.

LANGUAGE: typescript
CODE:
await MikroORM.init({
  metadataCache: { adapter: RedisCacheAdapter, options: { ... } },
  // ...
});

----------------------------------------

TITLE: Forking Entity Manager
DESCRIPTION: Example of creating a new EntityManager instance with its own context and identity map.

LANGUAGE: typescript
CODE:
const em = orm.em.fork();

----------------------------------------

TITLE: Enabling Debug Mode in MikroORM Initialization (TypeScript)
DESCRIPTION: Demonstrates how to enable debug mode when initializing MikroORM. This will cause all queries to be logged using console.log().

LANGUAGE: typescript
CODE:
return MikroORM.init({
  debug: true,
});

----------------------------------------

TITLE: Installing Dependencies for MikroORM Project
DESCRIPTION: Commands to install the necessary dependencies for a MikroORM project with SQLite and TypeScript support.

LANGUAGE: bash
CODE:
npm install @mikro-orm/core \
            @mikro-orm/sqlite \
            @mikro-orm/reflection \
            fastify

npm install --save-dev @mikro-orm/cli \
                       typescript \
                       ts-node \
                       @types/node \
                       vitest

----------------------------------------

TITLE: Querying JSON Object Properties in MikroORM (TypeScript)
DESCRIPTION: Shows how to query JSON object properties in MikroORM using nested object notation. The example demonstrates querying multiple levels of nested properties with different data types.

LANGUAGE: typescript
CODE:
const b = await em.findOne(Book, {
  meta: {
    valid: true,
    nested: {
      foo: '123',
      bar: 321,
      deep: {
        baz: 59,
        qux: false,
      },
    },
  },
});

----------------------------------------

TITLE: Initializing MikroORM with Event Subscribers
DESCRIPTION: Example of registering an event subscriber during MikroORM initialization. Shows how to add custom subscribers to the ORM configuration.

LANGUAGE: typescript
CODE:
MikroORM.init({
  subscribers: [new AuthorSubscriber()],
});

----------------------------------------

TITLE: Initializing MikroORM Dataloaders in TypeScript
DESCRIPTION: Configuration code to enable dataloaders globally in MikroORM. Shows how to import and initialize with different dataloader options.

LANGUAGE: typescript
CODE:
import { Dataloader } from '@mikro-orm/core';

MikroORM.init({
  dataloader: Dataloader.ALL,
});

----------------------------------------

TITLE: Implementing NextTick Fixer for MikroORM and Jest
DESCRIPTION: Defines utility functions to wrap Jest spies and manage fake timers for MikroORM operations, allowing controlled execution of process.nextTick().

LANGUAGE: typescript
CODE:
export function wrappedSpy<const T extends {}, const M extends jest.FunctionPropertyNames<Required<T>>>(
  object: T,
  method: T[M] extends jest.Func ? M : never,
  hooks: Readonly<{
    beforeOriginal?: (...args: jest.ArgsType<jest.FunctionProperties<Required<T>>[T[M] extends jest.Func ? M : never]>) => void,
    afterOriginal?: (result: ReturnType<T[M] extends jest.Func ? T[M] : never> extends Promise<infer R> ? R : ReturnType<T[M] extends jest.Func ? T[M] : never>) => void,
    errorOriginal?: (error?: unknown) => void,
  }>
) {
  const originalSpy = jest.spyOn(object, method);
  const mockImpl: Parameters<typeof originalSpy.mockImplementationOnce>[0] = (...args) => {
    hooks.beforeOriginal?.(...args);
    try {
      const result = (object[method] as Function).apply(originalSpy.mock.contexts.at(-1), args);
      if (result instanceof Promise) {
        result.then((v) => {
          hooks.afterOriginal?.(v);
          return v;
        }).catch((e) => {
          hooks.errorOriginal?.(e);
        }).finally(() => {
          originalSpy.mockImplementationOnce(mockImpl!);
        });
      } else {
        hooks.afterOriginal?.(result);
        originalSpy.mockImplementationOnce(mockImpl!);
      }
      return result;
    } catch (e) {
      hooks.errorOriginal?.(e);
      originalSpy.mockImplementationOnce(mockImpl!);
      throw e;
    }
  };
  originalSpy.mockImplementationOnce(mockImpl);
  return originalSpy;
}

const finallyHook = () => {
  jest.useFakeTimers({ doNotFake: [], now: jest.now() });
};

export const fakeTimersHooks = {
  beforeOriginal: () => {
    jest.useFakeTimers({ doNotFake: ['nextTick'], now: jest.now() });
  },
  afterOriginal: finallyHook,
  errorOriginal: finallyHook,
} as const satisfies Parameters<typeof wrappedSpy>[2];

----------------------------------------

TITLE: Fresh Schema Commands with Seeding - Shell
DESCRIPTION: Commands for recreating the database schema from scratch with optional seeding functionality.

LANGUAGE: shell
CODE:
npx mikro-orm schema:fresh --run     # !WARNING! Drops the database schema and recreates it
npx mikro-orm schema:fresh --run --seed              # seed the database with the default database seeder
npx mikro-orm schema:fresh --run --seed=UsersSeeder  # seed the database with the UsersSeeder

----------------------------------------

TITLE: Defining Entity with Constructor in MikroORM (TypeScript)
DESCRIPTION: This snippet demonstrates how to define a Book entity with a constructor that requires title and author. It shows the use of decorators for defining properties and relationships.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @PrimaryKey()
  id!: number;

  @Property()
  title: string;

  @Property()
  foo!: number;

  @ManyToOne()
  author: Author;

  @ManyToOne()
  publisher?: Publisher;

  @ManyToMany({ entity: () => BookTag, inversedBy: 'books' })
  tags = new Collection<BookTag>(this);

  constructor(title: string, author: Author) {
    this.title = title;
    this.author = author;
  }

}

----------------------------------------

TITLE: Setting Population Order in MikroORM Queries
DESCRIPTION: This example demonstrates how to use the 'populateOrderBy' option to control the ordering of populated related entities in MikroORM queries.

LANGUAGE: typescript
CODE:
await em.find(Author, { ... }, {
  populate: ['books'],
  populateOrderBy: { books: { publishedAt: 'desc' } },
});

----------------------------------------

TITLE: Using Read and Write Connections in MikroORM with TypeScript
DESCRIPTION: This snippet demonstrates how to manually specify connection types (read or write) and shows the default behavior for various query types. It also illustrates how transactions always use the write connection for all queries.

LANGUAGE: typescript
CODE:
const connection = orm.em.getConnection(); // write connection
const readConnection = orm.em.getConnection('read'); // random read connection

const qb1 = orm.em.createQueryBuilder(Author);
const res1 = await qb1.select('*').execute(); // random read connection

const qb2 = orm.em.createQueryBuilder(Author, 'a', 'write');
const res2 = await qb2.select('*').execute(); // write connection

const qb3 = orm.em.createQueryBuilder(Author);
const res3 = await qb3.update(...).where(...).execute(); // write connection

// all queries inside a transaction will use write connection
await orm.em.transactional(async em => {
  const a = await em.findOne(Author, 1); // write connection
  a.name = 'test'; // will trigger update on write connection once flushed
});

----------------------------------------

TITLE: Using Native MongoDB Collection Methods with MikroORM
DESCRIPTION: Shows how to use native MongoDB collection methods like insert, update, and delete through MikroORM's EntityManager and EntityRepository interfaces.

LANGUAGE: typescript
CODE:
em.insert<T extends AnyEntity>(entityName: string, data: any): Promise<IPrimaryKey>;
em.nativeUpdate<T extends AnyEntity>(entityName: string, where: FilterQuery<T>, data: any): Promise<number>;
em.nativeDelete<T extends AnyEntity>(entityName: string, where: FilterQuery<T> | any): Promise<number>;

EntityRepository.insert(data: any): Promise<IPrimaryKey>;
EntityRepository.nativeUpdate(where: FilterQuery<T>, data: any): Promise<number>;
EntityRepository.nativeDelete(where: FilterQuery<T> | any): Promise<number>;

em.aggregate(entityName: string, pipeline: any[]): Promise<any[]>;
EntityRepository.aggregate(pipeline: any[]): Promise<any[]>;

----------------------------------------

TITLE: Custom AsyncLocalStorage Configuration
DESCRIPTION: Shows how to configure MikroORM with a custom AsyncLocalStorage instance for context management.

LANGUAGE: typescript
CODE:
const storage = new AsyncLocalStorage<EntityManager>();

const orm = await MikroORM.init({
  context: () => storage.getStore(),
  // ...
});

app.use((req, res, next) => {
  storage.run(orm.em.fork({ useContext: true }), next);
});

----------------------------------------

TITLE: Creating Custom Repository in MikroORM
DESCRIPTION: Shows how to create a custom repository by extending EntityRepository class with additional methods.

LANGUAGE: typescript
CODE:
import { EntityRepository } from '@mikro-orm/mysql'; // or any other driver package

export class CustomAuthorRepository extends EntityRepository<Author> {

  // custom methods...
  public findAndUpdate(...) {
    // ...
  }

}

----------------------------------------

TITLE: Initializing TsMorphMetadataProvider in MikroORM
DESCRIPTION: Configuration example for using TsMorphMetadataProvider which uses ts-morph to read TypeScript source files for type detection.

LANGUAGE: typescript
CODE:
import { TsMorphMetadataProvider } from '@mikro-orm/reflection';

await MikroORM.init({
  metadataProvider: TsMorphMetadataProvider,
  // ...
});

----------------------------------------

TITLE: Using EntityManager in Migrations
DESCRIPTION: Example of using EntityManager within a migration to create and persist entities. Note that this approach is discouraged due to potential issues with metadata changes over time.

LANGUAGE: typescript
CODE:
import { Migration } from '@mikro-orm/migrations';
import { User } from '../entities/User';

export class Migration20191019195930 extends Migration {

    async up(): Promise<void> {
        const em = this.getEntityManager();
        em.create(User, { ... });
        await em.flush();
    }

}

----------------------------------------

TITLE: Registering Entity Repositories in NestJS Module
DESCRIPTION: Shows how to use MikroOrmModule.forFeature() to register entity repositories in a NestJS module.

LANGUAGE: typescript
CODE:
// photo.module.ts

@Module({
  imports: [MikroOrmModule.forFeature([Photo])],
  providers: [PhotoService],
  controllers: [PhotoController],
})
export class PhotoModule {}

----------------------------------------

TITLE: Setting Custom Cache Directory in MikroORM (TypeScript)
DESCRIPTION: This snippet illustrates how to set a custom cache directory when initializing MikroORM. It uses the 'options.cacheDir' property in the cache configuration.

LANGUAGE: typescript
CODE:
await MikroORM.init({
  // defaults to `./temp`
  cache: { options: { cacheDir: '...' } },
  // ...
});

----------------------------------------

TITLE: Initializing MikroORM with MongoDB
DESCRIPTION: Basic configuration for connecting MikroORM to a MongoDB database. Requires the @mikro-orm/mongodb dependency and uses clientUrl for connection.

LANGUAGE: typescript
CODE:
const orm = await MikroORM.init({
  entities: [Author, Book, ...],
  dbName: 'my-db-name',
  clientUrl: '...',
  type: 'mongo',
});

----------------------------------------

TITLE: Defining JSON Property in MikroORM Entity (TypeScript)
DESCRIPTION: Demonstrates how to define a JSON property in a MikroORM entity using the @Property decorator with the 'json' type. The example shows a nullable JSON property 'meta' with a specific structure.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @Property({ type: 'json', nullable: true })
  meta?: { foo: string; bar: number };

}

----------------------------------------

TITLE: Defining Timestamps on User Entity in TypeScript with MikroORM
DESCRIPTION: Adds createdAt and updatedAt timestamp properties to the User entity using MikroORM decorators. The updatedAt property uses an onUpdate callback to set the current date when updated.

LANGUAGE: TypeScript
CODE:
@Property()
createdAt = new Date();

@Property({ onUpdate: () => new Date() })
updatedAt = new Date();

----------------------------------------

TITLE: Setting and Clearing Schema in MikroORM EntityManager
DESCRIPTION: This code demonstrates how to set and clear the schema on the EntityManager. It shows that the schema can be set directly on the EntityManager or when forking, and can also be cleared by setting it to null.

LANGUAGE: typescript
CODE:
em.schema = 'client-123';
const fork = em.fork({ schema: 'client-1234' });
fork.schema = null;

----------------------------------------

TITLE: Defining JSON Property in MikroORM Entity (TypeScript)
DESCRIPTION: Demonstrates how to define a JSON property in a MikroORM entity using the @Property decorator with the 'json' type. The example shows a nullable JSON property 'meta' with a specific structure.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @Property({ type: 'json', nullable: true })
  meta?: { foo: string; bar: number };

}

----------------------------------------

TITLE: Implementing Custom Connection Class in TypeScript for MikroORM
DESCRIPTION: Extends the Connection class to handle database connection and querying. Implements methods for connecting, checking connection status, and executing queries.

LANGUAGE: typescript
CODE:
import { Connection } from '@mikro-orm/core';

export class MyCustomConnection extends Connection {

  // implement abstract methods
  connect(): Promise<void>;
  isConnected(): Promise<boolean>;
  close(force?: boolean): Promise<void>;
  getDefaultClientUrl(): string;
  execute(query: string, params?: any[], method?: 'all' | 'get' | 'run'): Promise<QueryResult | any | any[]>;

}

----------------------------------------

TITLE: Using Filters in MikroORM Queries
DESCRIPTION: Shows various ways to apply filters in MikroORM queries, including enabling specific filters, disabling default filters, and disabling all filters.

LANGUAGE: typescript
CODE:
em.find(Book, {}); // same as `{ tenantId: 123 }`
em.find(Book, {}, { filters: ['writtenBy'] }); // same as `{ author: 321, tenantId: 123 }`
em.find(Book, {}, { filters: { tenant: false } }); // disabled tenant filter, so truly `{}`
em.find(Book, {}, { filters: false }); // disabled all filters, so truly `{}`

----------------------------------------

TITLE: Collection Filtering and Ordering in MikroORM
DESCRIPTION: Shows how to filter and order collection items during initialization and using the matching method, including options for storing filtered results.

LANGUAGE: typescript
CODE:
await book.tags.init({ where: { active: true }, orderBy: { name: QueryOrder.DESC } });

const a = await em.findOneOrFail(Author, 1);

const books = await a.books.matching({ limit: 3, offset: 10, orderBy: { title: 'asc' } });

const tags = await books[0].tags.matching({
  limit: 3,
  offset: 5,
  orderBy: { name: 'asc' },
  store: true,
});

----------------------------------------

TITLE: MikroORM Global Cache Configuration
DESCRIPTION: Demonstrates how to configure global cache settings including adapter selection, default expiration, and options during ORM initialization.

LANGUAGE: typescript
CODE:
const orm = await MikroORM.init({
  resultCache: {
    // following options are the defaults
    adapter: MemoryCacheAdapter,
    expiration: 1000, // 1s
    options: {},
    // cache can be also enabled globally
    // global: 50, // 50ms
  },
  // ...
});

----------------------------------------

TITLE: Aliasing Raw SQL Fragments in MikroORM Queries (TypeScript)
DESCRIPTION: Shows how to alias a raw SQL fragment when selecting it in a MikroORM query using the .as() method with sql tagged templates.

LANGUAGE: typescript
CODE:
sql`(select 1 + 1)`.as('<alias>')

----------------------------------------

TITLE: Executing Native SQL Queries
DESCRIPTION: Shows how to execute raw SQL queries using the underlying database connection.

LANGUAGE: typescript
CODE:
const connection = orm.em.getConnection();
const res = await connection.execute('SELECT 1 as count');
console.log(res); // res is array of objects: `[ { count: 1 } ]`

----------------------------------------

TITLE: Extended Entity Repository Implementation
DESCRIPTION: Example of creating an extended repository class that restores removed v6 methods by forwarding calls to EntityManager.

LANGUAGE: typescript
CODE:
import { EntityManager, EntityRepository, AnyEntity } from '@mikro-orm/mysql';

export class ExtendedEntityRepository<T extends object> extends EntityRepository<T> {

  persist(entity: AnyEntity | AnyEntity[]): EntityManager {
    return this.em.persist(entity);
  }

  async persistAndFlush(entity: AnyEntity | AnyEntity[]): Promise<void> {
    await this.em.persistAndFlush(entity);
  }

  remove(entity: AnyEntity): EntityManager {
    return this.em.remove(entity);
  }

  async removeAndFlush(entity: AnyEntity): Promise<void> {
    await this.em.removeAndFlush(entity);
  }

  async flush(): Promise<void> {
    return this.em.flush();
  }

}

----------------------------------------

TITLE: Creating Typed JSON Property Index in MySQL (TypeScript)
DESCRIPTION: Illustrates how to create a typed index on a JSON property in MySQL using MikroORM. The example shows the use of the 'options' parameter to specify the return type of the indexed JSON value.

LANGUAGE: typescript
CODE:
@Entity()
@Index({ properties: 'metaData.foo', options: { returning: 'char(200)' } })
export class Book {

  @Property({ type: 'json', nullable: true })
  metaData?: { foo: string; bar: number };

}

----------------------------------------

TITLE: Populating All Relations in MikroORM (TypeScript)
DESCRIPTION: Shows how to populate all relationships in a single query using the '*' wildcard. This approach uses the select-in strategy to handle possible cycles in the relations.

LANGUAGE: typescript
CODE:
const tags = await em.find(BookTag, {}, {
  populate: ['*'],
});

----------------------------------------

TITLE: Custom Base Entity Implementation
DESCRIPTION: Demonstrates how to create a custom base entity with common fields like id, createdAt, and updatedAt using EntitySchema.

LANGUAGE: typescript
CODE:
export interface CustomBaseEntity {
  id: number;
  createdAt: Date;
  updatedAt: Date;
}

export const schema = new EntitySchema<CustomBaseEntity>({
  name: 'CustomBaseEntity',
  abstract: true,
  properties: {
    id: { type: 'number', primary: true },
    createdAt: { type: 'Date', onCreate: () => new Date(), nullable: true },
    updatedAt: { type: 'Date', onCreate: () => new Date(), onUpdate: () => new Date(), nullable: true },
  },
});

----------------------------------------

TITLE: Entity Instance Creation with EntityManager
DESCRIPTION: Shows how to create new entity instances using EntityManager's create method.

LANGUAGE: typescript
CODE:
const author = em.create<Author>('Author', { name: 'name', email: 'email' });
await em.flush();

----------------------------------------

TITLE: SQL Tagged Templates in MikroORM
DESCRIPTION: Demonstrates the use of sql tagged template function for raw SQL fragments, including value interpolation.

LANGUAGE: typescript
CODE:
// as a value
await em.find(User, { time: sql`now()` });

// as a key
await em.find(User, { [sql`lower(name)`]: name.toLowerCase() });

// value can be empty array
await em.find(User, { [sql`(select ${1} = ${1})`]: [] });

----------------------------------------

TITLE: Nested Embeddables Configuration
DESCRIPTION: Shows how to implement nested embeddable classes with Profile containing Identity. Demonstrates multiple levels of embedding with both object and inline storage modes.

LANGUAGE: typescript
CODE:
import { Embeddable, Embedded, Entity, PrimaryKey, Property } from '@mikro-orm/core';

@Entity()
export class User {

  @PrimaryKey()
  id!: number;

  @Property()
  name!: string;

  @Embedded(() => Profile, { object: true, nullable: true })
  profile?: Profile;

}

@Embeddable()
export class Profile {

  @Property()
  username: string;

  @Embedded(() => Identity)
  identity: Identity;

  constructor(username: string, identity: Identity) {
    this.username = username;
    this.identity = identity;
  }

}

@Embeddable()
export class Identity {

  @Property()
  email: string;

  constructor(email: string) {
    this.email = email;
  }

}

----------------------------------------

TITLE: Basic Bidirectional Relation Propagation in MikroORM
DESCRIPTION: Demonstrates how changes to one side of a bidirectional relation are automatically propagated to the other side. Shows automatic synchronization when setting an author for a book.

LANGUAGE: typescript
CODE:
const author = new Author(...);
const book = new Book(...);
book.author = author;
console.log(author.books.contains(book)); // true

----------------------------------------

TITLE: Demonstrating Cascade Persist in MikroORM with TypeScript
DESCRIPTION: Shows an example of how cascade persist works in MikroORM. It updates related entities and persists changes automatically through the cascade option.

LANGUAGE: typescript
CODE:
const book = await orm.em.findOne(Book, 'id', { populate: ['author', 'tags'] });
book.author.name = 'Foo Bar';
book.tags[0].name = 'new name 1';
book.tags[1].name = 'new name 2';
await orm.em.persist(book).flush(); // all book tags and author will be persisted too

----------------------------------------

TITLE: Reference Loading and Type-Safe Access
DESCRIPTION: Examples of loading references and accessing their properties in a type-safe manner.

LANGUAGE: typescript
CODE:
const article1 = await em.findOne(Article, 1);
article.author instanceof Reference; // true
article1.author; // Ref<User> (instance of `Reference` class)
article1.author.name; // type error, there is no `name` property
article1.author.unwrap().name; // unsafe sync access, undefined as author is not loaded
article1.author.isInitialized(); // false

const article2 = await em.findOne(Article, 1, { populate: ['author'] });
article2.author; // LoadedReference<User> (instance of `Reference` class)
article2.author.$.name; // type-safe sync access

----------------------------------------

TITLE: Importing EntityManager and EntityRepository in MikroORM
DESCRIPTION: Shows how to import EntityManager and EntityRepository from the appropriate driver package in MikroORM v4+.

LANGUAGE: typescript
CODE:
import { EntityManager, EntityRepository } from '@mikro-orm/mysql'; // or any other driver package

----------------------------------------

TITLE: Entity Definition with Manual Types
DESCRIPTION: Example of explicitly defining types and relationships in an entity class to avoid runtime type discovery

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @PrimaryKey({ type: 'number' })
  id!: number;

  @Property({ type: 'string' })
  title!: string;

  @Enum(() => BookStatus)
  status?: BookStatus;

  @ManyToOne(() => Author)
  author1!: Author;

  @ManyToOne({ type: 'Author' })
  author2!: Author;

  @ManyToOne({ entity: () => Author })
  author3!: Author;

}

export enum BookStatus {
  SOLD_OUT = 'sold',
  ACTIVE = 'active',
  UPCOMING = 'upcoming',
}

----------------------------------------

TITLE: MongoDB Entity Primary Key Definition
DESCRIPTION: Demonstrates how to properly define primary keys for MongoDB entities using ObjectId and SerializedPrimaryKey decorators.

LANGUAGE: typescript
CODE:
@PrimaryKey()
_id: ObjectId;

@SerializedPrimaryKey()
id!: string; // won't be saved in the database

----------------------------------------

TITLE: Configuring PopulateHint Globally in MikroORM with TypeScript
DESCRIPTION: This snippet shows how to configure the PopulateHint globally in MikroORM initialization to respect the outer filter passed in a where condition.

LANGUAGE: typescript
CODE:
const orm = await MikroORM.init({
    // We want our populate fetches to respect the outer filter passed in a where condition.
    populateWhere: PopulateHint.INFER,
});

----------------------------------------

TITLE: Injecting Multiple Database Connections in NestJS Service
DESCRIPTION: Shows how to inject and use multiple MikroORM database connections in a NestJS service.

LANGUAGE: typescript
CODE:
@Injectable()
export class MyService {

  constructor(@InjectMikroORM('db1') private readonly orm1: MikroORM,
              @InjectMikroORM('db2') private readonly orm2: MikroORM,
              @InjectEntityManager('db1') private readonly em1: EntityManager,
              @InjectEntityManager('db2') private readonly em2: EntityManager) { }

}

----------------------------------------

TITLE: CreateRequestContext Decorator Usage
DESCRIPTION: Examples of using the CreateRequestContext decorator to manage request context in service methods.

LANGUAGE: typescript
CODE:
@Injectable()
export class MyService {

  constructor(private readonly orm: MikroORM) { }

  @CreateRequestContext()
  async doSomething() {
    // this will be executed in a separate context
  }

}

----------------------------------------

TITLE: Entity Reference Initialization Check
DESCRIPTION: Demonstrates how to check and initialize entity references, showing both the uninitialized and initialized states.

LANGUAGE: typescript
CODE:
const author = em.getReference(Author, 123);
console.log(author.id); // accessing the id will not trigger any db call
console.log(wrap(author).isInitialized()); // false
console.log(author.name); // undefined

await wrap(author).init(); // this will trigger db call
console.log(wrap(author).isInitialized()); // true
console.log(author.name); // defined

----------------------------------------

TITLE: Defining ManyToOne Relationship with Reference Wrapper
DESCRIPTION: Demonstrates how to define a ManyToOne relationship using the Reference wrapper to enable dataloader functionality.

LANGUAGE: typescript
CODE:
@ManyToOne(() => Book, { ref: true })
book!: Ref<Book>;

----------------------------------------

TITLE: Entity Instance Creation Example
DESCRIPTION: Shows how to create new entity instances using EntityManager's create method.

LANGUAGE: typescript
CODE:
const author = em.create<Author>('Author', { name: 'name', email: 'email' });
await em.flush();

----------------------------------------

TITLE: Creating Indexes on JSON Properties in TypeScript with MikroORM
DESCRIPTION: Demonstrates how to create indexes on JSON properties using the @Index decorator in MikroORM. It shows both single and compound indexes on JSON fields.

LANGUAGE: typescript
CODE:
@Entity()
@Index({ properties: 'metaData.foo' })
@Index({ properties: ['metaData.foo', 'metaData.bar'] }) // compound index
export class Book {

  @Property({ type: 'json', nullable: true })
  metaData?: { foo: string; bar: number };

}

----------------------------------------

TITLE: Defining Hidden Properties in Entity using TypeScript
DESCRIPTION: This snippet shows how to mark properties as hidden in an entity using the @Property decorator and the HiddenProps symbol.

LANGUAGE: typescript
CODE:
@Entity()
class Book {

  // we use the `HiddenProps` symbol to define hidden properties on type level
  [HiddenProps]?: 'hiddenField' | 'otherHiddenField';

  @Property({ hidden: true })
  hiddenField = Date.now();

  @Property({ hidden: true, nullable: true })
  otherHiddenField?: string;

}

const book = new Book(...);
console.log(wrap(book).toObject().hiddenField); // undefined

// @ts-expect-error accessing `hiddenField` will fail to compile thanks to the `HiddenProps` symbol
console.log(wrap(book).toJSON().hiddenField); // undefined

----------------------------------------

TITLE: Defining Hidden Properties in Entity using TypeScript
DESCRIPTION: This snippet shows how to mark properties as hidden in an entity using the @Property decorator and the HiddenProps symbol.

LANGUAGE: typescript
CODE:
@Entity()
class Book {

  // we use the `HiddenProps` symbol to define hidden properties on type level
  [HiddenProps]?: 'hiddenField' | 'otherHiddenField';

  @Property({ hidden: true })
  hiddenField = Date.now();

  @Property({ hidden: true, nullable: true })
  otherHiddenField?: string;

}

const book = new Book(...);
console.log(wrap(book).toObject().hiddenField); // undefined

// @ts-expect-error accessing `hiddenField` will fail to compile thanks to the `HiddenProps` symbol
console.log(wrap(book).toJSON().hiddenField); // undefined

----------------------------------------

TITLE: Shortcut for $in Operator in MikroORM
DESCRIPTION: Demonstrates a shortcut for the $in operator in MikroORM. By providing an array as the value, it is automatically converted to an $in condition.

LANGUAGE: typescript
CODE:
const res = await orm.em.find(Author, { favouriteBook: [1, 2, 7] });

----------------------------------------

TITLE: Implementing Custom Platform Class for MikroORM
DESCRIPTION: This code snippet demonstrates how to create a custom Platform class by extending the base Platform class from MikroORM. It includes methods for defining database-specific features and behaviors.

LANGUAGE: typescript
CODE:
import { Platform } from '@mikro-orm/core';

export class MyCustomPlatform extends Platform {

  protected abstract schemaHelper: MyCustomSchemaHelper;

  // here you can override default settings
  usesPivotTable(): boolean;
  supportsTransactions(): boolean;
  supportsSavePoints(): boolean;
  getNamingStrategy(): { new (): NamingStrategy; };
  getIdentifierQuoteCharacter(): string;
  getParameterPlaceholder(index?: number): string;
  usesReturningStatement(): boolean;
  normalizePrimaryKey<T = number | string>(data: IPrimaryKey): T;
  denormalizePrimaryKey(data: IPrimaryKey): IPrimaryKey;
  getSerializedPrimaryKeyField(field: string): string;

}

----------------------------------------

TITLE: Implementing PointType for MySQL Spatial Extension
DESCRIPTION: This advanced example demonstrates how to create a custom PointType that works with MySQL's Spatial extension. It includes methods for converting between database and JavaScript values, as well as SQL conversion methods.

LANGUAGE: typescript
CODE:
export class PointType extends Type<Point | undefined, string | undefined> {

  convertToDatabaseValue(value: Point | undefined): string | undefined {
    if (!value) {
      return value;
    }

    return `point(${value.latitude} ${value.longitude})`;
  }

  convertToJSValue(value: string | undefined): Point | undefined {
    const m = value?.match(/point\((-?\d+(\.\d+)?) (-?\d+(\.\d+)?)\)/i);

    if (!m) {
      return undefined;
    }

    return new Point(+m[1], +m[3]);
  }

  convertToJSValueSQL(key: string) {
    return `ST_AsText(${key})`;
  }

  convertToDatabaseValueSQL(key: string) {
    return `ST_PointFromText(${key})`;
  }

  getColumnType(): string {
    return 'point';
  }

}

----------------------------------------

TITLE: Injecting EntityManager in NestJS Service
DESCRIPTION: Demonstrates how to inject and use the EntityManager in a NestJS service class.

LANGUAGE: typescript
CODE:
import { MikroORM } from '@mikro-orm/core';
import { EntityManager } from '@mikro-orm/mysql'; // Import EntityManager from your driver package or `@mikro-orm/knex`

@Injectable()
export class MyService {

  constructor(private readonly orm: MikroORM,
              private readonly em: EntityManager) {
  }

}

----------------------------------------

TITLE: Using Identity Map in MikroORM
DESCRIPTION: Demonstrates how MikroORM's identity map ensures the same entity instance is returned across multiple queries. Shows comparison of entities retrieved through different methods pointing to the same instance.

LANGUAGE: typescript
CODE:
const authorRepository = orm.em.getRepository(Author);
const jon = await authorRepository.findOne({ name: 'Jon Snow' }, ['books']);
const authors = await authorRepository.findAll(['books']);

// identity map in action
console.log(jon === authors[0]); // true

----------------------------------------

TITLE: Accessing Driver-Specific Methods in MikroORM
DESCRIPTION: Example of importing and casting EntityManager to use driver-specific methods like createQueryBuilder().

LANGUAGE: typescript
CODE:
import { EntityManager } from '@mikro-orm/postgresql';
const em = orm.em as EntityManager;
const qb = em.createQueryBuilder(...);

----------------------------------------

TITLE: Configuring SWC for MikroORM decorator and class name support
DESCRIPTION: This SWC configuration enables decorator metadata extraction and class name preservation for MikroORM. It sets the appropriate parser options, enables decorator transformations, and targets the most modern JavaScript version.

LANGUAGE: json
CODE:
{
  "jsc": {
    "parser": {
      "syntax": "typescript",
      "decorators": true
    },
    "transform": {
      "decoratorMetadata": true,
      "legacyDecorator": true
    },
    "target": "esnext",
    "minify": false
  }
}

----------------------------------------

TITLE: Inferring Custom Repository Type in TypeScript with MikroORM
DESCRIPTION: Shows how to use the EntityRepositoryType symbol to infer the correct custom repository type when using em.getRepository(). This ensures type safety when working with custom repositories.

LANGUAGE: typescript
CODE:
@Entity({ repository: () => AuthorRepository })
export class Author {

  [EntityRepositoryType]?: AuthorRepository;

}

const repo = em.getRepository(Author); // repo has type AuthorRepository

----------------------------------------

TITLE: Using Identity Map in MikroORM
DESCRIPTION: Demonstrates how MikroORM's identity map ensures the same entity instance is returned across multiple queries. Shows comparison of entities retrieved through different methods pointing to the same instance.

LANGUAGE: typescript
CODE:
const authorRepository = orm.em.getRepository(Author);
const jon = await authorRepository.findOne({ name: 'Jon Snow' }, ['books']);
const authors = await authorRepository.findAll(['books']);

// identity map in action
console.log(jon === authors[0]); // true

----------------------------------------

TITLE: Using @Property Decorator for Entity Properties in TypeScript
DESCRIPTION: Examples of using the @Property decorator to define various entity properties with different options.

LANGUAGE: typescript
CODE:
@Property({ length: 50, fieldName: 'first_name' })
name!: string;

@Property({ type: 'date', fieldName: 'born_date' })
born?: string;

@Property({ columnType: 'tinyint' })
age?: number;

@Property({ onUpdate: () => new Date() })
updatedAt = new Date();

@Property()
registered = false;

----------------------------------------

TITLE: Entity Discovery Configuration Options
DESCRIPTION: Configuration options for controlling entity discovery behavior including warnings and property analysis.

LANGUAGE: typescript
CODE:
MikroORM.init({
  discovery: {
    warnWhenNoEntities: false, // by default, discovery throws when no entity is processed
    requireEntitiesArray: true, // force usage of class references in `entities` instead of paths
    alwaysAnalyseProperties: false, // do not analyse properties when not needed (with ts-morph)
  },
});

----------------------------------------

TITLE: Configuring Feature Module with Repository
DESCRIPTION: Setup of a feature module using MikroOrmModule.forFeature() to register entity repositories.

LANGUAGE: typescript
CODE:
@Module({
  imports: [MikroOrmModule.forFeature([Photo])],
  providers: [PhotoService],
  controllers: [PhotoController],
})
export class PhotoModule {}

----------------------------------------

TITLE: Using Reference Wrapper for Type-Safe Relations in MikroORM
DESCRIPTION: Shows how to use the Reference wrapper to define type-safe relations and access them safely in MikroORM.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @PrimaryKey()
  id!: number;

  @ManyToOne(() => Author, { ref: true })
  author: Ref<Author>;

  constructor(author: Author) {
    this.author = ref(author);
  }

}

----------------------------------------

TITLE: Using Read and Write Connections in MikroORM with TypeScript
DESCRIPTION: This snippet illustrates various ways to specify and use read and write connections in MikroORM. It covers explicit connection type selection, query builder usage, and transaction handling with respect to connection types.

LANGUAGE: typescript
CODE:
const connection = em.getConnection(); // write connection
const readConnection = em.getConnection('read'); // random read connection

const qb1 = em.createQueryBuilder(Author);
const res1 = await qb1.select('*').execute(); // random read connection

const qb2 = em.createQueryBuilder(Author, 'a', 'write');
const res2 = await qb2.select('*').execute(); // write connection

const qb3 = em.createQueryBuilder(Author);
const res3 = await qb3.update(...).where(...).execute(); // write connection

const res4 = await em.findOne(Author, 1, { connectionType: 'write' }); // explicit write connection

// all queries inside a transaction will use write connection
await em.transactional(async em => {
    const a = await em.findOne(Author, 1); // write connection
    const b = await em.findOne(Author, 1, { connectionType: 'read' }); // still a write connection - we are in a transaction
    a.name = 'test'; // will trigger update on write connection once flushed
});

// given a configuration where preferReadReplicas: false
const res5 = await em.findOne(Author, 1); // write connection - even for a read operation
const res6 = await em.findOne(Author, 1, { connectionType: 'read' }); // unless explicitly asking for a read replica

----------------------------------------

TITLE: Querying Entities in Specific Schemas with MikroORM
DESCRIPTION: This code shows how to query for an entity in a specific schema using EntityManager, EntityRepository, or QueryBuilder. It demonstrates the use of the 'schema' option in the find method.

LANGUAGE: typescript
CODE:
const user = await em.findOne(User, { ... }, { schema: 'client-123' });

----------------------------------------

TITLE: Using Loaded Type for Type-Safe Access in MikroORM
DESCRIPTION: Explains how to use the Loaded type to ensure type-safe access to populated relations in MikroORM.

LANGUAGE: typescript
CODE:
// res is of type `Loaded<User, 'identity'>`
const user = await em.findOneOrFail(User, 1, { populate: ['identity'] });

// instead of the async `await user.identity.load()` call that would ensure the relation is loaded
// you can use the dynamically added `$` symbol for synchronous and type-safe access to it:
console.log(user.identity.$.email);

----------------------------------------

TITLE: Using @Property Decorator for Entity Properties in TypeScript
DESCRIPTION: Examples of using the @Property decorator to define various entity properties with different options.

LANGUAGE: typescript
CODE:
@Property({ length: 50, fieldName: 'first_name' })
name!: string;

@Property({ type: 'date', fieldName: 'born_date' })
born?: string;

@Property({ columnType: 'tinyint' })
age?: number;

@Property({ onUpdate: () => new Date() })
updatedAt = new Date();

@Property()
registered = false;

----------------------------------------

TITLE: Configuring MikroORM for Schema-First Approach
DESCRIPTION: Configuration file for MikroORM, including settings for entity generation, migrations, and database connection.

LANGUAGE: typescript
CODE:
import { defineConfig } from '@mikro-orm/mysql';
import { EntityGenerator } from '@mikro-orm/entity-generator';
import { Migrator } from '@mikro-orm/migrations';

export default defineConfig({
    multipleStatements: true,
    extensions: [EntityGenerator, Migrator],
    discovery: {
        // we need to disable validation for no entities, due to the entity generation
        warnWhenNoEntities: false,
    },
    entities: ['dist/**/*.entity.js'],
    entitiesTs: ['src/**/*.entity.ts'],
    host: 'localhost',
    user: 'root',
    password: '',
    dbName: 'blog',
    // enable debug mode to log SQL queries and discovery information
    debug: true,
    migrations: {
        path: 'dist/migrations',
        pathTs: 'src/migrations',
    },
    entityGenerator: {
        save: true,
        path: 'src/modules',
        esmImport: true,
        readOnlyPivotTables: true,
        outputPurePivotTables: true,
        bidirectionalRelations: true,
        customBaseEntityName: 'Base',
        useCoreBaseEntity: true,
    },
});

----------------------------------------

TITLE: Implementing Cascade Remove in MikroORM with TypeScript
DESCRIPTION: Demonstrates how cascade remove works in MikroORM, showing that related entities are also removed when the main entity is removed, based on the cascade configuration.

LANGUAGE: typescript
CODE:
await orm.em.remove(book).flush(); // this will also remove book.publisher

----------------------------------------

TITLE: Using assign() for Entity Updates
DESCRIPTION: Shows how to use the assign() method to update entity properties including references

LANGUAGE: typescript
CODE:
import { wrap } from '@mikro-orm/core';

wrap(book).assign({
  title: 'Better Book 1',
  author: '...id...',
});
console.log(book.title); // 'Better Book 1'
console.log(book.author); // instance of Author with id: '...id...'
console.log(book.author.id); // '...id...'

----------------------------------------

TITLE: MikroORM Built-in Types Definition
DESCRIPTION: Definition of built-in types provided by MikroORM for common data type mappings.

LANGUAGE: typescript
CODE:
export const types = {
  date: DateType,
  time: TimeType,
  datetime: DateTimeType,
  bigint: BigIntType,
  blob: BlobType,
  uint8array: Uint8ArrayType,
  array: ArrayType,
  enumArray: EnumArrayType,
  enum: EnumType,
  json: JsonType,
  integer: IntegerType,
  smallint: SmallIntType,
  tinyint: TinyIntType,
  mediumint: MediumIntType,
  float: FloatType,
  double: DoubleType,
  boolean: BooleanType,
  decimal: DecimalType,
  string: StringType,
  uuid: UuidType,
  text: TextType,
};

----------------------------------------

TITLE: Initializing ORM and Bootstrapping Application
DESCRIPTION: Functions to initialize the ORM, set up Fastify server, and bootstrap the application with routes and plugins.

LANGUAGE: typescript
CODE:
import { fastify } from 'fastify';
import fastifyJWT from '@fastify/jwt';
import { initORM } from './db.js';
import hooks from './modules/common/hooks.js';
import userRoutes from './modules/user/user.routes.js';
import articleRoutes from './modules/article/article.routes.js';

export async function bootstrap(port = 3001, migrate = true) {
  const db = await initORM(migrate ? { multipleStatements: true, ensureDatabase: { create: false } } : {});

  if (migrate) {
    // sync the schema
    await db.orm.migrator.up();
    await db.orm.reconnect({ multipleStatements: false });
  }

  const app = fastify();

  // register JWT plugin
  await app.register(fastifyJWT, {
    secret: process.env.JWT_SECRET ?? '12345678', // fallback for testing
  });

  await app.register(hooks, { db });

  // register routes here
  app.register(articleRoutes, { db, prefix: 'article' });
  app.register(userRoutes, { db, prefix: 'user' });

  const url = await app.listen({ port });

  return { app, url };
}

----------------------------------------

TITLE: Using Loaded Type with Populate in MikroORM
DESCRIPTION: This snippet demonstrates the use of the Loaded type in combination with populate hints. It shows how to achieve type-safe synchronous access to populated relations using the $ symbol.

LANGUAGE: typescript
CODE:
// res is of type `Loaded<User, 'identity'>`
const user = await em.findOneOrFail(User, 1, { populate: ['identity'] });

// instead of the async `await user.identity.load()` call that would ensure the relation is loaded
// you can use the dynamically added `$` symbol for synchronous and type-safe access to it:
console.log(user.identity.$.email);

----------------------------------------

TITLE: Using Custom Driver in MikroORM
DESCRIPTION: Example of how to use a custom database driver with MikroORM by providing the driver class in the configuration.

LANGUAGE: typescript
CODE:
import { MyCustomDriver } from './MyCustomDriver.ts';

const orm = await MikroORM.init({
  entities: [Author, Book, ...],
  dbName: 'my-db-name',
  driver: MyCustomDriver, // provide the class, not just its name
});

----------------------------------------

TITLE: Implicit Transaction Handling in MikroORM
DESCRIPTION: Demonstrates basic implicit transaction handling using EntityManager's flush operation. This approach is suitable when all data manipulation happens through the ORM.

LANGUAGE: typescript
CODE:
const user = new User(...);
user.name = 'George';
await orm.em.persist(user).flush();

----------------------------------------

TITLE: Configuring Orphan Removal in MikroORM
DESCRIPTION: Shows how to configure and use orphan removal, a more aggressive form of cascade remove that automatically removes entities when they are disconnected from their parent.

LANGUAGE: typescript
CODE:
@Entity()
export class Author {

  @OneToMany({ entity: () => Book, mappedBy: 'author', orphanRemoval: true })
  books = new Collection<Book>(this);

}

----------------------------------------

TITLE: Regular Expression Usage in MikroORM
DESCRIPTION: Shows how to use regular expressions in MikroORM queries. This example demonstrates using a RegExp object directly on the field name for case-insensitive matching.

LANGUAGE: typescript
CODE:
const res = await em.find(Painter, {
  lastName: /m[oa]net/i, // or `new RegExp('m[oa]net', 'i')`
});

----------------------------------------

TITLE: Defining ManyToOne Relationship with Circular Dependency
DESCRIPTION: Demonstrates how to define a ManyToOne relationship when there's a circular dependency between entities.

LANGUAGE: typescript
CODE:
@ManyToOne({ entity: () => Author })
author: Author;

----------------------------------------

TITLE: Initializing MikroORM with PostgreSQL
DESCRIPTION: Example of initializing MikroORM with PostgreSQL driver, including entity configuration and database connection setup.

LANGUAGE: typescript
CODE:
import { MikroORM } from '@mikro-orm/postgresql';

const orm = await MikroORM.init({
  entities: ['./dist/entities'],
  dbName: 'my-db-name',
});
console.log(orm.em);

----------------------------------------

TITLE: Creating MikroORM Configuration File
DESCRIPTION: Example of a MikroORM configuration file (mikro-orm.config.ts) with basic settings for entities, database name, and type.

LANGUAGE: typescript
CODE:
export default {
  entities: [Author, Book, BookTag],
  dbName: 'my-db-name',
  type: 'mongo', // one of `mongo` | `mysql` | `mariadb` | `postgresql` | `sqlite`
};

----------------------------------------

TITLE: Defining Entity Relationships in TypeScript with MikroORM
DESCRIPTION: Example showing how to define entity relationships between Author and Book entities using TypeScript decorators in MikroORM.

LANGUAGE: typescript
CODE:
import { Entity, LoadStrategy, OneToMany, ManyToOne, PrimaryKey } from '@mikro-orm/core';

@Entity()
export class Author {

  @PrimaryKey()
  id!: number;

  @OneToMany(() => Book, b => b.author)
  books = new Collection<Book>(this);

}

@Entity()
export class Book {

  @PrimaryKey()
  id!: number;

  @ManyToOne()
  author: Author;

}

----------------------------------------

TITLE: Running Seeders via MikroORM CLI
DESCRIPTION: Shows various CLI commands for running seeders, including options for specifying seeder classes and combining with migration commands.

LANGUAGE: shell
CODE:
npx mikro-orm seeder:run

npx mikro-orm seeder:run --class=BookSeeder

npx mikro-orm migration:fresh --seed

npx mikro-orm schema:fresh --seed

----------------------------------------

TITLE: MikroORM Hapi Integration Setup
DESCRIPTION: Complete setup example showing how to integrate MikroORM with AdminJS using Hapi framework, including database initialization and plugin registration.

LANGUAGE: typescript
CODE:
import AdminJS from 'adminjs';
import { Database, Resource } from '@adminjs/mikroorm';
import AdminJSHapi from '@adminjs/hapi';
import { MikroORM } from '@mikro-orm/postgresql';
import { validate } from 'class-validator'; // optional

const PORT = process.env.PORT ?? 3000;

const run = async () => {
  /* Initialize MikroORM like you would do normally, you can also import your MikroORM instance from a separate file */
  const orm = await MikroORM.init({
    entities: [User, Car, Seller], // use your own entities
    dbName: process.env.DATABASE_NAME,
    clientUrl: process.env.DATABASE_URL,
  });

  /* Optional: if you're using class-validator, assign it to Resource */
  Resource.validate = validate;
  /* Tell AdminJS which adapter to use */
  AdminJS.registerAdapter({ Database, Resource });

  const server = Hapi.server({ port: PORT })

  /* Configure AdminJS */
  const adminOptions = {
    databases: [orm],
  };

  /* Register AdminJS as a Hapi server's plugin */
  await server.register({
    plugin: AdminJSHapi,
    options: adminOptions,
  });

  await server.start();
  console.log(`App listening at ${server.info.uri}`);
}

run();

----------------------------------------

TITLE: Defining Concurrency Check Fields in MikroORM (TypeScript)
DESCRIPTION: Shows how to define fields for concurrency checks in an entity. This allows for more granular control over which fields should be checked for concurrent modifications.

LANGUAGE: typescript
CODE:
@Entity()
export class ConcurrencyCheckUser {

  // all primary keys are by default part of the concurrency check
  @PrimaryKey({ length: 100 })
  firstName: string;

  // all primary keys are by default part of the concurrency check
  @PrimaryKey({ length: 100 })
  lastName: string;

  @Property({ concurrencyCheck: true })
  age: number;

  @Property({ nullable: true })
  other?: string;

}

----------------------------------------

TITLE: Defining BigInt Primary Key in MikroORM (TypeScript)
DESCRIPTION: Demonstrates how to define a primary key of type bigint in MikroORM using TypeScript. Since version 6, bigints are represented by the native BigInt type and don't require explicit type specification in decorator options.

LANGUAGE: typescript
CODE:
@PrimaryKey()
id: bigint;

----------------------------------------

TITLE: Defining Entity Properties with Explicit Types
DESCRIPTION: Shows how to define entity properties with explicit types when using ReflectMetadataProvider. This is necessary as type inference is not supported.

LANGUAGE: typescript
CODE:
@Property()
createdAt: Date = new Date();

----------------------------------------

TITLE: Querying Entities by Non-Primary Key in MikroORM
DESCRIPTION: This example demonstrates that while MikroORM's Identity Map works with non-primary key queries, it still requires separate database calls for each query.

LANGUAGE: typescript
CODE:
const authorRepository = orm.em.getRepository(Author);
const jon1 = await authorRepository.findOne({ name: 'Jon Snow' });
const jon2 = await authorRepository.findOne({ name: 'Jon Snow' });

// identity map in action
console.log(jon1 === jon2); // true

----------------------------------------

TITLE: Implementing Article Routes with CRUD Operations
DESCRIPTION: Article-related routes including listing, creation, updating, and deletion with authentication checks.

LANGUAGE: typescript
CODE:
import { type FastifyPluginAsync } from 'fastify';
import { type Services } from '../../db.js';
import { DisallowedError } from '../common/disallowed.error.js';
import { wrap } from '@mikro-orm/mysql';
import { z } from 'zod';
import { getUserFromToken } from '../common/utils.js';
import { pagingParams } from '../common/validators.js';

const articleBySlugParams = z.object({
  slug: z.string().min(1),
});

const articleCommentPayload = z.object({
  text: z.string().min(1),
});

const newArticlePayload = z.object({
  title: z.string().min(1),
  text: z.string().min(1),
  description: z.string().min(1).optional(),
});

const articleByIdParams = z.object({
  id: z.coerce.number().int().positive()
});

const updateArticlePayload = newArticlePayload.partial().extend({
  slug: z.string().min(1).optional(),
});

export default (async (app, { db }) => {
  app.get('/', async (request) => {
    const { limit, offset } = pagingParams.parse(request.query);
    const [items, total] = await db.article.findAndCount(
      {},
      {
        populate: ['commentsCount'],
        limit,
        offset,
      }
    );

    return { items, total };
  });

  app.get('/:slug', async request => {
    const { slug } = articleBySlugParams.parse(request.params);
    return db.article.findOneOrFail({ slug }, {
      populate: ['author', 'commentCollection.author', 'text'],
    });
  });

  app.post('/:slug/comment', async request => {
    const { slug } = articleBySlugParams.parse(request.params);
    const { text } = articleCommentPayload.parse(request.body);
    const author = getUserFromToken(request);
    const article = await db.article.findOneOrFail({ slug });
    const comment = db.comment.create({ author, article, text });
  
    article.commentCollection.add(comment);
  
    await db.em.flush();
  
    return comment;
  });

  app.post('/', async request => {
    const { title, text, description } = newArticlePayload.parse(request.body);
    const author = getUserFromToken(request);
    const article = db.article.create({
      title,
      text,
      author,
      description,
    });
  
    await db.em.flush();
  
    return article;
  });

  app.patch('/:id', async request => {
    const user = getUserFromToken(request);
    const { id } = articleByIdParams.parse(request.params);
    const article = await db.article.findOneOrFail(id);
    if (article.author !== user) {
      throw new DisallowedError('Only the author of an article is allowed to update it');
    }

    wrap(article).assign(updateArticlePayload.parse(request.body));
    await db.em.flush();
  
    return article;
  });

  app.delete('/:id', async request => {
    const user = getUserFromToken(request);
    const { id } = articleByIdParams.parse(request.params);
    const article = await db.article.findOneOrFail(id);
    if (article.author !== user) {
      throw new DisallowedError('Only the author of an article is allowed to delete it');
    }

    await db.em.remove(article).flush();
  
    return { success: true };
  });
}) as FastifyPluginAsync<{ db: Services }>;

----------------------------------------

TITLE: Defining Concurrency Check Fields in MikroORM (TypeScript)
DESCRIPTION: Shows how to define fields for concurrency checks in an entity. This allows for more granular control over which fields should be checked for concurrent modifications.

LANGUAGE: typescript
CODE:
@Entity()
export class ConcurrencyCheckUser {

  // all primary keys are by default part of the concurrency check
  @PrimaryKey({ length: 100 })
  firstName: string;

  // all primary keys are by default part of the concurrency check
  @PrimaryKey({ length: 100 })
  lastName: string;

  @Property({ concurrencyCheck: true })
  age: number;

  @Property({ nullable: true })
  other?: string;

}

----------------------------------------

TITLE: Updating Deep Entity Graph
DESCRIPTION: Examples of updating nested entity properties and handling primary keys in deep updates.

LANGUAGE: typescript
CODE:
const book = await em.findOneOrFail(Book, 1, { populate: ['author'] });

// update existing book's author's name
wrap(book).assign({
  author: {
    id: book.author.id,
    name: 'New name...',
  },
});

----------------------------------------

TITLE: Configuring Result Cache with EntityManager in TypeScript
DESCRIPTION: Demonstrates how to use result caching with EntityManager's find method. Shows different ways to specify cache expiration and custom cache keys.

LANGUAGE: typescript
CODE:
const res = await em.find(Book, { author: { name: 'Jon Snow' } }, {
  populate: ['author', 'tags'],
  cache: 50, // set expiration to 50ms
  // cache: ['cache-key', 50], // set custom cache key and expiration
  // cache: true, // use default cache key and expiration
});

----------------------------------------

TITLE: Loading SQLite Extensions in MikroORM
DESCRIPTION: Example of loading SQLite extensions like sqlean in MikroORM initialization options.

LANGUAGE: typescript
CODE:
const orm = await MikroORM.init({
  // ...
  pool: {
    afterCreate: (conn: any, done: any) => {
      conn.loadExtension('/.../sqlean-macos-arm64/sqlean');
      done(null, conn);
    },
  },
});

----------------------------------------

TITLE: Configuring Multiple Database Connections in NestJS
DESCRIPTION: Demonstrates how to set up and use multiple database connections in a NestJS application using MikroORM.

LANGUAGE: typescript
CODE:
@Module({
  imports: [
    MikroOrmModule.forRoot({
      contextName: 'db1',
      registerRequestContext: false, // disable automatatic middleware
      ...
    }),
    MikroOrmModule.forRoot({
      contextName: 'db2',
      registerRequestContext: false, // disable automatatic middleware
      ...
    }),
    MikroOrmModule.forMiddleware()
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}

----------------------------------------

TITLE: Entity Querying by Non-Primary Key in TypeScript
DESCRIPTION: Shows how MikroORM handles queries by non-primary key properties. While multiple database calls are made, the Identity Map ensures the same entity instance is returned.

LANGUAGE: typescript
CODE:
const jon1 = await em.findOne(Author, { name: 'Jon Snow' });
const jon2 = await em.findOne(Author, { name: 'Jon Snow' });

// identity map in action
console.log(jon1 === jon2); // true

----------------------------------------

TITLE: Implementing Custom Driver Class in TypeScript
DESCRIPTION: Database driver class that handles database operations using the connection. Extends DatabaseDriver and implements methods for CRUD operations and query execution.

LANGUAGE: typescript
CODE:
import { DatabaseDriver } from '@mikro-orm/core';

export class MyCustomSchemaHelper extends DatabaseDriver {

  // initialize connection and platform
  protected readonly connection = new MyCustomConnection(this.config);
  protected readonly platform = new MyCustomPlatform;

  // and implement abstract methods
  find<T extends AnyEntity>(entityName: string, where: FilterQuery<T>, populate?: string[], orderBy?: Record<string, QueryOrder>, limit?: number, offset?: number): Promise<T[]>;
  findOne<T extends AnyEntity>(entityName: string, where: FilterQuery<T> | string, populate: string[]): Promise<T | null>;
  nativeInsert<T extends AnyEntityType<T>>(entityName: string, data: EntityData<T>): Promise<QueryResult>;
  nativeUpdate<T extends AnyEntity>(entityName: string, where: FilterQuery<T> | IPrimaryKey, data: EntityData<T>): Promise<QueryResult>;
  nativeDelete<T extends AnyEntity>(entityName: string, where: FilterQuery<T> | IPrimaryKey): Promise<QueryResult>;
  count<T extends AnyEntity>(entityName: string, where: FilterQuery<T>): Promise<number>;

}

----------------------------------------

TITLE: Entity Creation without Primary Key
DESCRIPTION: Demonstrates automatic flushing behavior when querying an entity that was created without a primary key.

LANGUAGE: typescript
CODE:
const jon = em.create(Author, {
  name: 'Jon',
  email: 'foo@bar.com',
});

// this will trigger auto flush and insert the entity, then query for it
const jon2 = await em.findOne(Author, 1);
console.log(jon === jon2); // true
await em.flush(); // this is a no-op

----------------------------------------

TITLE: Initializing MikroORM with Read Replicas in TypeScript
DESCRIPTION: This snippet demonstrates how to initialize MikroORM with multiple read replica connections. It shows the configuration of master and read replica connections, including the optional 'preferReadReplicas' setting.

LANGUAGE: typescript
CODE:
const orm = await MikroORM.init({
  entities: [Author, ...],
  dbName: `my_database`,
  type: 'mysql',
  user: 'master_user',
  host: 'master_host',
  preferReadReplicas: true, // optional property, defaults to true
  replicas: [
    { name: 'read-1', host: 'read_host_1', user: 'read_user' },
    { name: 'read-2', host: 'read_host_2' }, // user omitted, will be taken from master connection
  ],
});

----------------------------------------

TITLE: Entity Definition with Manual Types
DESCRIPTION: Example of an entity class with manually specified types to avoid discovery process

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @PrimaryKey({ type: 'number' })
  id!: number;

  @Property({ type: 'string' })
  title!: string;

  @Enum(() => BookStatus)
  status?: BookStatus;

  @ManyToOne(() => Author) // or `@ManyToOne({ type: 'Author' })` or `@ManyToOne({ entity: () => Author })`
  author1!: Author;

  // or
  @ManyToOne({ type: 'Author' })
  author2!: Author;

  // or
  @ManyToOne({ entity: () => Author })
  author3!: Author;

}

export enum BookStatus {
  SOLD_OUT = 'sold',
  ACTIVE = 'active',
  UPCOMING = 'upcoming',
}

----------------------------------------

TITLE: Demonstrating Bidirectional Propagation in Many-to-Many Relations (TypeScript)
DESCRIPTION: This snippet illustrates how Collection.add() works bidirectionally for many-to-many relations in MikroORM. It shows that adding a book to a tag's collection or a tag to a book's collection results in the change being reflected on both sides.

LANGUAGE: typescript
CODE:
// many to many works both from owning side and from inverse side
const book = new Book(...);
const tag = new BookTag(...);

book.tags.add(tag);
console.log(tag.books.contains(book)); // true

tag.books.add(book);
console.log(book.tags.contains(tag)); // true

----------------------------------------

TITLE: Creating Custom SchemaHelper for MikroORM
DESCRIPTION: This code demonstrates how to implement a custom SchemaHelper class by extending the base SchemaHelper. It includes methods for managing database schema operations and definitions.

LANGUAGE: typescript
CODE:
import { SchemaHelper } from '@mikro-orm/core';

export class MyCustomSchemaHelper extends SchemaHelper {

  // here you can override default settings
  getIdentifierQuoteCharacter(): string;
  getSchemaBeginning(): string;
  getSchemaEnd(): string;
  getSchemaTableEnd(): string;
  getAutoIncrementStatement(meta: EntityMetadata): string;
  getPrimaryKeySubtype(meta: EntityMetadata): string;
  getTypeDefinition(prop: EntityProperty, types?: Record<string, string>, lengths?: Record<string, number>): string;
  getUnsignedSuffix(prop: EntityProperty): string;
  supportsSchemaConstraints(): boolean;
  supportsSchemaMultiAlter(): boolean;
  supportsSequences(): boolean;
  quoteIdentifier(field: string): string;
  dropTable(meta: EntityMetadata): string;
  indexForeignKeys(): boolean;

}

----------------------------------------

TITLE: OneToMany Collection Definition
DESCRIPTION: Shows how to define OneToMany relationships using Collections with different configuration options.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {
  @PrimaryKey()
  _id!: ObjectId;

  @ManyToOne()
  author!: Author;
}

@Entity()
export class Author {
  @PrimaryKey()
  _id!: ObjectId;

  @OneToMany(() => Book, book => book.author)
  books1 = new Collection<Book>(this);

  @OneToMany({ entity: () => Book, mappedBy: 'author' })
  books2 = new Collection<Book>(this);
}

----------------------------------------

TITLE: Initializing MikroORM with MongoDB Driver
DESCRIPTION: Configuration setup for connecting MikroORM to MongoDB database. Demonstrates type-safe initialization with MongoDriver and essential connection parameters.

LANGUAGE: typescript
CODE:
import type { MongoDriver } from '@mikro-orm/mongodb';

const orm = await MikroORM.init<MongoDriver>({
  entities: [Author, Book, ...],
  dbName: 'my-db-name',
  clientUrl: '...',
  type: 'mongo',
});
console.log(orm.em);

----------------------------------------

TITLE: Using MikroORM Repositories in NestJS Module
DESCRIPTION: Demonstrates how to use MikroORM repositories in a NestJS module and inject them into services.

LANGUAGE: typescript
CODE:
// photo.module.ts

@Module({
  imports: [MikroOrmModule.forFeature([Photo])],
  providers: [PhotoService],
  controllers: [PhotoController],
})
export class PhotoModule {}

// In PhotoService
@Injectable()
export class PhotoService {
  constructor(
    @InjectRepository(Photo)
    private readonly photoRepository: EntityRepository<Photo>
  ) {}

  // ...
}

----------------------------------------

TITLE: Configuring EntityGenerator Extension
DESCRIPTION: Example of registering the EntityGenerator extension in MikroORM config

LANGUAGE: typescript
CODE:
import { defineConfig } from '@mikro-orm/postgresql';
import { EntityGenerator } from '@mikro-orm/entity-generator';

export default defineConfig({
  dbName: 'test',
  extensions: [EntityGenerator],
});

----------------------------------------

TITLE: Defining Custom Base Entity Schema in TypeScript
DESCRIPTION: This example demonstrates how to create a custom base entity schema with common properties like id, createdAt, and updatedAt.

LANGUAGE: typescript
CODE:
export interface CustomBaseEntity {
  id: number;
  createdAt: Date;
  updatedAt: Date;
}

export const schema = new EntitySchema<CustomBaseEntity>({
  name: 'CustomBaseEntity',
  abstract: true,
  properties: {
    id: { type: 'number', primary: true },
    createdAt: { type: 'Date', onCreate: () => new Date(), nullable: true },
    updatedAt: { type: 'Date', onCreate: () => new Date(), onUpdate: () => new Date(), nullable: true },
  },
});

----------------------------------------

TITLE: Entity Reference Initialization Example
DESCRIPTION: Demonstrates how to work with entity references, check initialization status, and lazy load entity data.

LANGUAGE: typescript
CODE:
const user = em.getReference(User, 123);
console.log(user.id); // prints `123`, accessing the id will not trigger any db call
console.log(wrap(user).isInitialized()); // false, it's just a reference
console.log(user.name); // undefined

await wrap(user).init(); // this will trigger db call
console.log(wrap(user).isInitialized()); // true
console.log(user.name); // defined

----------------------------------------

TITLE: Setting and Clearing Schema on EntityManager
DESCRIPTION: Shows how to set and clear schema on EntityManager instances.

LANGUAGE: typescript
CODE:
em.schema = 'client-123';
const fork = em.fork({ schema: 'client-1234' });
fork.schema = null;

----------------------------------------

TITLE: Programmatic Entity Generation with TypeScript
DESCRIPTION: TypeScript script that initializes MikroORM and uses EntityGenerator to programmatically generate entity classes from database schema. Includes configuration for output directory and console logging.

LANGUAGE: typescript
CODE:
import { MikroORM } from 'mikro-orm';

(async () => {
  const orm = await MikroORM.init({
    dbName: 'your-db-name',
    // ...
  });
  const generator = orm.getEntityGenerator();
  const dump = await generator.generate({
    save: true,
    baseDir: process.cwd() + '/my-entities',
  });
  console.log(dump);
  await orm.close(true);
})();

----------------------------------------

TITLE: Configuring MongoDB Indexes
DESCRIPTION: Demonstrates various ways to configure and create indexes in MongoDB with MikroORM.

LANGUAGE: typescript
CODE:
const orm = await MikroORM.init({
  entities: [Author, Book, ...],
  dbName: 'my-db-name',
  ensureIndexes: true,
});

----------------------------------------

TITLE: Inferring Populate Hint from Filter in MikroORM (TypeScript)
DESCRIPTION: Demonstrates how to automatically select all relations that are part of the filter query using '$infer' in the populate option. This feature is not available in MongoDB driver.

LANGUAGE: typescript
CODE:
const tags = await em.find(BookTag, {
  books: { author: { name: '...' } },
}, {
  populate: ['$infer'],
});

----------------------------------------

TITLE: Entity Property Type Definitions with ReflectMetadataProvider
DESCRIPTION: Examples of properly defining entity properties when using ReflectMetadataProvider, including collections, references, and enums.

LANGUAGE: typescript
CODE:
@Property()
createdAt: Date = new Date();

@OneToMany(() => Book, b => b.author)
books = new Collection<Book>(this);

@ManyToOne(() => Publisher, { ref: true })
publisher!: Ref<Publisher>;

@Property({ nullable: true })
prop?: string;

@Enum(() => UserRole)
role: UserRole;

@ManyToOne({ entity: () => Author })
author: Author;

----------------------------------------

TITLE: Configuring Custom Cache Adapter in MikroORM
DESCRIPTION: This snippet demonstrates how to configure a custom cache adapter (RedisCacheAdapter) when initializing MikroORM. It sets the 'adapter' property of the 'cache' option to the custom adapter class.

LANGUAGE: typescript
CODE:
await MikroORM.init({
  cache: { adapter: RedisCacheAdapter, options: { ... } },
  // ...
});

----------------------------------------

TITLE: Entity Creation with Explicit Primary Key
DESCRIPTION: Shows how entities created with explicit primary keys are handled by the Identity Map and subsequent queries.

LANGUAGE: typescript
CODE:
const jon = em.create(Author, {
  id: 1,
  name: 'Jon',
  email: 'foo@bar.com',
});

// this will not query the database
const jon2 = await em.findOne(Author, 1);
console.log(jon === jon2); // true
await em.flush(); // this inserts the entity

----------------------------------------

TITLE: Filtering Collections with matching() Method in TypeScript
DESCRIPTION: Demonstrates how to use the matching() method to filter and slice data from collections, with options to store the results.

LANGUAGE: typescript
CODE:
const a = await em.findOneOrFail(Author, 1);

// only loading the list of items
const books = await a.books.matching({ limit: 3, offset: 10, orderBy: { title: 'asc' } });
console.log(books); // [Book, Book, Book]
console.log(a.books.isInitialized()); // false

// storing the items in collection
const tags = await books[0].tags.matching({
  limit: 3,
  offset: 5,
  orderBy: { name: 'asc' },
  store: true,
});
console.log(tags); // [BookTag, BookTag, BookTag]
console.log(books[0].tags.isInitialized()); // true
console.log(books[0].tags.getItems()); // [BookTag, BookTag, BookTag]

----------------------------------------

TITLE: Using SqlEntityManager in MikroORM v4
DESCRIPTION: Demonstrates how to import and use the SqlEntityManager (aliased as EntityManager) from a specific SQL driver package to access the createQueryBuilder() method in MikroORM v4.

LANGUAGE: typescript
CODE:
import { EntityManager } from '@mikro-orm/mysql'; // or any other SQL driver package

const em: EntityManager;
const qb = await em.createQueryBuilder(...);

----------------------------------------

TITLE: Registering Custom Repository via Entity Decorator
DESCRIPTION: Alternative approach to register a custom repository using the @Entity decorator instead of @Repository decorator.

LANGUAGE: typescript
CODE:
@Entity({ customRepository: () => CustomAuthorRepository })
export class Author {
  // ...
}

----------------------------------------

TITLE: Setting Up RequestContext Middleware for Express
DESCRIPTION: Example of creating a middleware to fork the EntityManager for each request using RequestContext in an Express application.

LANGUAGE: typescript
CODE:
const app = express();

app.use((req, res, next) => {
  RequestContext.create(orm.em, next);
});

----------------------------------------

TITLE: MikroORM Article Endpoint Test in TypeScript
DESCRIPTION: Implements a test case for the article listing endpoint using Vitest and Fastify's inject method.

LANGUAGE: TypeScript
CODE:
import { afterAll, beforeAll, expect, test } from 'vitest';
import { FastifyInstance } from 'fastify';
import { initTestApp } from './utils.js';

let app: FastifyInstance;

beforeAll(async () => {
  app = await initTestApp(30001);
});

afterAll(async () => {
  await app.close();
});

test('list all articles', async () => {
  const res = await app.inject({
    method: 'get',
    url: '/article',
  });

  expect(res.statusCode).toBe(200);

  expect(res.json()).toMatchObject({
    items: [],
    total: 0,
  });
});

----------------------------------------

TITLE: Defining ManyToMany Relations with Custom Pivot Table
DESCRIPTION: TypeScript examples of defining ManyToMany relations with custom pivot table names using MikroORM decorators.

LANGUAGE: typescript
CODE:
// for unidirectional
@ManyToMany({ entity: () => Test, owner: true, pivotTable: 'publisher2test' })
tests = new Collection<Test>(this);

// for bidirectional
@ManyToMany({ entity: () => BookTag, inversedBy: 'books', pivotTable: 'book2tag' })
tags = new Collection<BookTag>(this);

----------------------------------------

TITLE: Configuring Result Cache in MikroORM EntityManager (TypeScript)
DESCRIPTION: Demonstrates how to use result caching with the EntityManager's find method. It shows different ways to set cache expiration and custom cache IDs.

LANGUAGE: typescript
CODE:
const res = await em.find(Book, { author: { name: 'Jon Snow' } }, {
  populate: ['author', 'tags'],
  cache: 50, // set expiration to 50ms
  // cache: ['cache-id', 50], // set custom cache id and expiration
  // cache: true, // use default cache id and expiration
});

----------------------------------------

TITLE: Applying Filters in MikroORM Queries
DESCRIPTION: This example demonstrates various ways to apply filters in MikroORM queries. It shows how to enable specific filters, disable default filters, and disable all filters for a query.

LANGUAGE: typescript
CODE:
em.find(Book, {}); // same as `{ tenantId: 123 }`
em.find(Book, {}, { filters: ['writtenBy'] }); // same as `{ author: 321, tenantId: 123 }`
em.find(Book, {}, { filters: { tenant: false } }); // disabled tenant filter, so truly `{}`
em.find(Book, {}, { filters: false }); // disabled all filters, so truly `{}`

----------------------------------------

TITLE: Using EntityGenerator via CLI in MikroORM
DESCRIPTION: CLI commands to generate entities using MikroORM's EntityGenerator. It shows how to dump all generated entities or save them to a specific directory.

LANGUAGE: sh
CODE:
npx mikro-orm generate-entities --dump  # Dumps all generated entities
npx mikro-orm generate-entities --save --path=./my-entities  # Saves entities into given directory

----------------------------------------

TITLE: Custom Database Driver Implementation
DESCRIPTION: Example of using a custom database driver with MikroORM initialization.

LANGUAGE: typescript
CODE:
import { MyCustomDriver } from './MyCustomDriver.ts';

const orm = await MikroORM.init({
  entities: [Author, Book, ...],
  dbName: 'my-db-name',
  driver: MyCustomDriver, // provide the class, not just its name
});

----------------------------------------

TITLE: Implementing Global Filters in MikroORM
DESCRIPTION: Demonstrates how to register and configure global filters that apply to multiple entities.

LANGUAGE: typescript
CODE:
// bound to entity, enabled by default
em.addFilter('writtenBy', args => ({ author: args.id }), Book);

// global, enabled by default, for all entities
em.addFilter('tenant', args => { ... });

// global, enabled by default, for only specified entities
em.addFilter('tenant', args => { ... }, [Author, Book]);
...

// set params (probably in some middleware)
em.setFilterParams('tenant', { tenantId: 123 });
em.setFilterParams('writtenBy', { id: 321 });

----------------------------------------

TITLE: Configuring Repository Mocking for NestJS Testing
DESCRIPTION: Example of mocking repositories for unit testing in NestJS modules using MikroORM.

LANGUAGE: typescript
CODE:
@Module({
  providers: [
    PhotoService,
    // required for `@InjectRepository` decorator
    {
      provide: getRepositoryToken(Photo),
      useValue: mockedRepository,
    },

    // required for custom repositories if we don't want to use `@InjectRepository`
    {
      provide: PhotoRepository,
      useValue: mockedRepository,
    },
  ],
})
export class PhotoModule {}

----------------------------------------

TITLE: Implementing Custom SchemaHelper Class in TypeScript
DESCRIPTION: SchemaHelper class implementation that provides methods for schema manipulation and definition. This class handles database schema operations including table creation, type definitions, and constraint management.

LANGUAGE: typescript
CODE:
import { SchemaHelper } from '@mikro-orm/core';

export class MyCustomSchemaHelper extends SchemaHelper {

  // here you can override default settings
  getIdentifierQuoteCharacter(): string;
  getSchemaBeginning(): string;
  getSchemaEnd(): string;
  getSchemaTableEnd(): string;
  getAutoIncrementStatement(meta: EntityMetadata): string;
  getPrimaryKeySubtype(meta: EntityMetadata): string;
  getTypeDefinition(prop: EntityProperty, types?: Record<string, string>, lengths?: Record<string, number>): string;
  getUnsignedSuffix(prop: EntityProperty): string;
  supportsSchemaConstraints(): boolean;
  supportsSchemaMultiAlter(): boolean;
  supportsSequences(): boolean;
  quoteIdentifier(field: string): string;
  dropTable(meta: EntityMetadata): string;
  indexForeignKeys(): boolean;

}

----------------------------------------

TITLE: Join Table with Metadata Implementation
DESCRIPTION: Complex example showing how to implement a join table with additional metadata using composite keys in an order-product relationship.

LANGUAGE: typescript
CODE:
@Entity()
export class Order {

  @PrimaryKey()
  id!: number;

  @ManyToOne()
  customer: Customer;

  @OneToMany(() => OrderItem, item => item.order)
  items = new Collection<OrderItem>(this);

  @Property()
  paid = false;

  @Property()
  shipped = false;

  @Property()
  created = new Date();

  constructor(customer: Customer) {
    this.customer = customer;
  }

}

@Entity()
export class Product {

  @PrimaryKey()
  id!: number;

  @Property()
  name!: string;

  @Property()
  currentPrice!: number;

}

@Entity()
export class OrderItem {

  @ManyToOne({ primary: true })
  order: Order;

  @ManyToOne({ primary: true })
  product: Product;

  @Property()
  amount = 1;

  @Property()
  offeredPrice: number;

  [PrimaryKeyProp]?: ['order', 'product'];

  constructor(order: Order, product: Product, amount = 1) {
    this.order = order;
    this.product = product;
    this.offeredPrice = product.currentPrice;
  }

}

----------------------------------------

TITLE: Complex Join Table Implementation with Metadata
DESCRIPTION: Shows implementation of a complex order management system with join tables containing additional metadata, demonstrating relationships between Order, Product, and OrderItem entities.

LANGUAGE: typescript
CODE:
@Entity()
export class Order {

  @PrimaryKey()
  id!: number;

  @ManyToOne()
  customer: Customer;

  @OneToMany(() => OrderItem, item => item.order)
  items = new Collection<OrderItem>(this);

  @Property()
  paid = false;

  @Property()
  shipped = false;

  @Property()
  created = new Date();

  constructor(customer: Customer) {
    this.customer = customer;
  }

}

@Entity()
export class Product {

  @PrimaryKey()
  id!: number;

  @Property()
  name!: string;

  @Property()
  currentPrice!: number;

}

@Entity()
export class OrderItem {

  @ManyToOne({ primary: true })
  order: Order;

  @ManyToOne({ primary: true })
  product: Product;

  @Property()
  amount = 1;

  @Property()
  offeredPrice: number;

  [PrimaryKeyType]: [number, number];

  constructor(order: Order, product: Product, amount = 1) {
    this.order = order;
    this.product = product;
    this.offeredPrice = product.currentPrice;
  }

}

----------------------------------------

TITLE: Defining Nullable Properties in MikroORM Entity
DESCRIPTION: Shows how to define nullable properties in MikroORM entities using the @Property decorator with nullable option.

LANGUAGE: typescript
CODE:
@Property({ nullable: true })
name?: string;

----------------------------------------

TITLE: Constructing Entities in TypeScript
DESCRIPTION: This snippet shows how to construct entities using the 'new' operator and the 'em.create()' method, demonstrating how constructor parameters are handled.

LANGUAGE: typescript
CODE:
const author = new Author();
const book = new Book('Foo', author);

const author = new Author();
const book = em.create(Book, { title: 'Foo', author, foo: 123 });

----------------------------------------

TITLE: Defining MongoDB Entity with Primary Key in TypeScript
DESCRIPTION: This snippet shows how to define an entity with a primary key for MongoDB. It uses the @PrimaryKey and @SerializedPrimaryKey decorators to set up both ObjectId and string representations of the ID.

LANGUAGE: typescript
CODE:
@PrimaryKey()
_id: ObjectId;

@SerializedPrimaryKey()
id!: string; // won't be saved in the database

----------------------------------------

TITLE: Defining Parameterless Filters in MikroORM
DESCRIPTION: Demonstrates how to create a filter without parameters but with access to the operation type. The 'args: false' option is used to avoid errors due to missing parameters.

LANGUAGE: typescript
CODE:
@Filter({
  name: 'withoutParams',
  cond(_, type) {
    return { ... };
  },
  args: false,
  default: true,
})

----------------------------------------

TITLE: Using @CreateRequestContext Decorator in MikroORM with TypeScript
DESCRIPTION: This snippet demonstrates the usage of the @CreateRequestContext decorator to create a new request context for a method. It's useful for ensuring a separate context in scenarios like queue handlers or scheduled tasks.

LANGUAGE: typescript
CODE:
export class MyService {

  constructor(private readonly orm: MikroORM) { }

  @CreateRequestContext()
  async doSomething() {
    // this will be executed in a separate context
  }

}

----------------------------------------

TITLE: Updating Entities without Primary Key in TypeScript
DESCRIPTION: Shows how to update entities without providing the primary key by using the updateByPrimaryKey option.

LANGUAGE: typescript
CODE:
const book = await em.findOneOrFail(Book, 1, { populate: ['author'] });

// update existing book's author's name
wrap(book).assign({
  author: {
    name: 'New name...',
  },
}, { updateByPrimaryKey: false });

----------------------------------------

TITLE: Working with Entity References
DESCRIPTION: Shows how to work with entity references - lightweight entities containing only primary key that can be used without loading full entity data.

LANGUAGE: typescript
CODE:
const userRef = em.getReference(User, 1);
console.log(userRef);

// setting relation properties
author.favouriteBook = em.getReference(Book, 1);

// removing entity by reference
em.remove(em.getReference(Book, 2));

// adding entity to collection by reference
author.books.add(em.getReference(Book, 3));

----------------------------------------

TITLE: Using Reference<T> Wrapper Methods in MikroORM
DESCRIPTION: This snippet demonstrates how to use various methods of the Reference<T> wrapper, including load(), unwrap(), and getProperty().

LANGUAGE: typescript
CODE:
const book = await orm.em.findOne(Book, 1);
console.log(book.author instanceof Reference); // true
console.log(book.author.isInitialized()); // false
console.log(book.author.name); // type error, there is no `name` property
console.log(book.author.unwrap().name); // undefined as author is not loaded
console.log((await book.author.load('name'))); // ok, loading the author first
console.log((await book.author.load()).name); // ok, author already loaded
console.log(book.author.unwrap().name); // ok, author already loaded

----------------------------------------

TITLE: Setting Metadata Provider in MikroORM
DESCRIPTION: Shows how to set a custom metadata provider in MikroORM, specifically using the TsMorphMetadataProvider.

LANGUAGE: typescript
CODE:
import { MikroORM } from '@mikro-orm/core';
import { TsMorphMetadataProvider } from '@mikro-orm/reflection';

MikroORM.init({
  metadataProvider: TsMorphMetadataProvider,
});

----------------------------------------

TITLE: Article Entity with Reference Wrapper
DESCRIPTION: Shows how to use the Reference wrapper for better type-safety in entity relations.

LANGUAGE: typescript
CODE:
import { Entity, Ref, ManyToOne, PrimaryKey, Reference } from '@mikro-orm/core';

@Entity()
export class Article {

  @PrimaryKey()
  id!: number;

  @ManyToOne()
  author: Ref<User>;

  constructor(author: User) {
    this.author = ref(author);
  }

}

----------------------------------------

TITLE: Defining Virtual Entity with Callback Expression in TypeScript
DESCRIPTION: This snippet shows how to define a virtual entity using a callback function that returns a QueryBuilder instance. It includes examples for reflect-metadata, ts-morph, and EntitySchema approaches.

LANGUAGE: typescript
CODE:
@Entity({
  expression: (em: EntityManager) => {
    return em.createQueryBuilder(Book, 'b')
      .select(['b.title', 'a.name as author_name', 'group_concat(t.name) as tags'])
      .join('b.author', 'a')
      .join('b.tags', 't')
      .groupBy('b.id');
  },
})
export class BookWithAuthor {

  @Property()
  title!: string;

  @Property()
  authorName!: string;

  @Property()
  tags!: string[];

}

----------------------------------------

TITLE: Using Specialized SQL Functions in MikroORM (TypeScript)
DESCRIPTION: Demonstrates the usage of specialized SQL functions in MikroORM, including sql.ref() for column references, sql.now() for default datetime values, and sql.lower() and sql.upper() for case conversion.

LANGUAGE: typescript
CODE:
await em.find(User, { foo: sql.ref('bar') });

@Property({ default: sql.now() })
createdAt: Date & Opt;

const books = await orm.em.find(Book, {
  [sql.upper('title')]: 'TITLE',
});

----------------------------------------

TITLE: Registering Article Routes with MikroORM
DESCRIPTION: Sets up article route registration with MikroORM entity manager and basic listing endpoint

LANGUAGE: typescript
CODE:
export async function registerArticleRoutes(app: FastifyInstance) {
  const db = await initORM();

  app.get('/', async request => {
    const { limit, offset } = request.query as { limit?: number; offset?: number };
    const [items, total] = await db.article.findAndCount({}, {
      limit, offset,
    });

    return { items, total };
  });
}

----------------------------------------

TITLE: Configuring Caching in MikroORM
DESCRIPTION: Demonstrates how to configure caching options in MikroORM.

LANGUAGE: typescript
CODE:
MikroORM.init({
  cache: {
    enabled: true,
    pretty: false,
    adapter: FileCacheAdapter,
    options: { cacheDir: process.cwd() + '/temp' },
  },
});

----------------------------------------

TITLE: Using QueryBuilder for Native SQL Queries
DESCRIPTION: Example of using MikroORM's QueryBuilder to construct and execute native SQL queries.

LANGUAGE: typescript
CODE:
const qb = orm.em.createQueryBuilder(Author);
qb.update({ name: 'test 123', type: PublisherType.GLOBAL }).where({ id: 123, type: PublisherType.LOCAL });

console.log(qb.getQuery());
// 'UPDATE `publisher2` SET `name` = ?, `type` = ? WHERE `id` = ? AND `type` = ?'

console.log(qb.getParams());
// ['test 123', PublisherType.GLOBAL, 123, PublisherType.LOCAL]

// run the query
const res1 = await qb.execute();

// or run query without using QueryBuilder
const driver = orm.em.getDriver();
const res2 = await driver.execute('SELECT ? + ?', [1, 2]);

----------------------------------------

TITLE: Overriding Loading Strategy when Finding Entities in MikroORM
DESCRIPTION: This example demonstrates how to override the default loading strategy to 'select-in' when finding an Author entity and populating its books.

LANGUAGE: typescript
CODE:
const author = await orm.em.findOne(Author, 1, {
  populate: ['books'],
  strategy: 'select-in',
});

----------------------------------------

TITLE: Using discriminatorValue with Abstract Entities in Single Table Inheritance
DESCRIPTION: This example shows how to use discriminatorValue with abstract entities in Single Table Inheritance. It demonstrates marking the entity as abstract to exclude it from the discriminator map.

LANGUAGE: typescript
CODE:
@Entity({
  discriminatorColumn: 'type',
  abstract: true,
})
export abstract class BasePerson {

  @Enum()
  type!: 'person' | 'employee';

}

@Entity({ discriminatorValue: 'person' })
export class Person extends BasePerson {
  // ...
}

@Entity({ discriminatorValue: 'employee' })
export class Employee extends Person {
  // ...
}

----------------------------------------

TITLE: Installing MikroORM and Database Drivers with Yarn
DESCRIPTION: Commands to install MikroORM core and database-specific drivers using Yarn package manager.

LANGUAGE: sh
CODE:
yarn add @mikro-orm/core @mikro-orm/mongodb     # for mongo
yarn add @mikro-orm/core @mikro-orm/mysql       # for mysql/mariadb
yarn add @mikro-orm/core @mikro-orm/mariadb     # for mysql/mariadb
yarn add @mikro-orm/core @mikro-orm/postgresql  # for postgresql
yarn add @mikro-orm/core @mikro-orm/sqlite      # for sqlite

----------------------------------------

TITLE: Lifecycle Hooks in MikroORM
DESCRIPTION: Examples of using lifecycle hook decorators to execute code at different stages of entity lifecycle

LANGUAGE: typescript
CODE:
@OnInit()
doStuffOnInit() {
  this.fullName = `${this.firstName} - ${this.lastName}`;
}

@BeforeCreate()
async doStuffBeforeCreate() {
  // ...
}

@AfterCreate()
async doStuffAfterCreate() {
  // ...
}

----------------------------------------

TITLE: Configuring AsyncLocalStorage in MikroORM
DESCRIPTION: Demonstrates how to set up AsyncLocalStorage for managing EntityManager context in MikroORM. This approach requires a recent Node.js version and replaces the default domain API usage in RequestContext helper.

LANGUAGE: typescript
CODE:
const storage = new AsyncLocalStorage<EntityManager>();

const orm = await MikroORM.init({
  context: () => storage.getStore(),
  // ...
});

app.use((req, res, next) => {
  storage.run(orm.em.fork(true, true), next);
});

----------------------------------------

TITLE: Simplified Single Field AND Conditions in MikroORM
DESCRIPTION: Shows a more concise way to write AND conditions when all conditions apply to the same field. Combines multiple operators in a single object.

LANGUAGE: typescript
CODE:
const res = await orm.em.find(Author, {
  id: {
    $in: [1, 2, 7],
    $nin: [3, 4],
    $gt: 5,
    $lt: 10,
    $gte: 7,
    $lte: 8,
    $ne: 9,
  },
});

----------------------------------------

TITLE: Checking Database Connection Status in MikroORM
DESCRIPTION: This TypeScript code demonstrates how to check the database connection status using MikroORM's isConnected() and checkConnection() methods.

LANGUAGE: ts
CODE:
// boolean
const isConnected = await orm.isConnected();
// object with `ok`, `reason` and `error` keys
const check = await orm.checkConnection();

console.log(check.ok, check.reason);

----------------------------------------

TITLE: Using Native Delete in TypeScript
DESCRIPTION: Shows how to use the new nativeDelete() method for executing direct delete queries, replacing the previous behavior of remove() with conditions.

LANGUAGE: typescript
CODE:
// after
await em.nativeDelete(Author, 1);

----------------------------------------

TITLE: Defining Book Entity with Relations in TypeScript
DESCRIPTION: Example of defining a Book entity with various property types and relationships including ManyToOne and ManyToMany. Shows usage of @Entity, @Property, and relationship decorators with MongoDB ObjectID as primary key.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @PrimaryKey()
  _id: ObjectID;

  @Property()
  createdAt = new Date();

  @Property({ onUpdate: () => new Date() })
  updatedAt = new Date();

  @Property()
  title: string;

  @ManyToOne()
  author: Author;

  @ManyToOne({ entity: () => Publisher })
  publisher: Publisher;

  @ManyToMany({ entity: () => BookTag, inversedBy: 'books' })
  tags = new Collection<BookTag>(this);

  constructor(title: string, author: Author) {
    this.title = title;
    this.author = author;
  }

}

export interface Book extends IEntity<string> { }

----------------------------------------

TITLE: Defining Custom Author Entity Class with EntitySchema in TypeScript
DESCRIPTION: This example demonstrates how to use a custom class for entity instances along with EntitySchema. It includes various property types and relationships.

LANGUAGE: typescript
CODE:
export class Author extends CustomBaseEntity {
  name: string;
  email: string;
  age?: number;
  termsAccepted?: boolean;
  identities?: string[];
  born?: Date;
  books = new Collection<Book>(this);
  favouriteBook?: Book;
  version?: number;

  constructor(name: string, email: string) {
    super();
    this.name = name;
    this.email = email;
  }
}

export const schema = new EntitySchema<Author, CustomBaseEntity>({
  class: Author,
  extends: 'CustomBaseEntity',
  properties: {
    name: { type: 'string' },
    email: { type: 'string', unique: true },
    age: { type: 'number', nullable: true },
    termsAccepted: { type: 'boolean', default: 0, onCreate: () => false },
    identities: { type: 'string[]', nullable: true },
    born: { type: DateType, nullable: true, length: 3 },
    books: { reference: '1:m', entity: () => 'Book', mappedBy: book => book.author },
    favouriteBook: { reference: 'm:1', type: 'Book' },
    version: { type: 'number', persist: false },
  },
});

----------------------------------------

TITLE: Declarative Partial Loading of Collections in TypeScript
DESCRIPTION: Shows how to define collections that represent only a subset of target entities using declarative partial loading.

LANGUAGE: typescript
CODE:
@Entity()
class Author {

  @OneToMany(() => Book, b => b.author)
  books = new Collection<Book>(this);

  @OneToMany(() => Book, b => b.author, { where: { favorite: true } })
  favoriteBooks = new Collection<Book>(this);

}

@Entity()
class Book {

  @ManyToMany(() => BookTag)
  tags = new Collection<BookTag>(this);

  @ManyToMany({
    entity: () => BookTag, 
    pivotTable: 'book_tags',
    where: { popular: true },
  })
  popularTags = new Collection<BookTag>(this);

}

----------------------------------------

TITLE: Implementing Custom Naming Strategy in TypeScript
DESCRIPTION: Example showing how to implement and initialize a custom naming strategy by implementing the NamingStrategy interface and configuring it in MikroORM initialization.

LANGUAGE: typescript
CODE:
class MyCustomNamingStrategy implements NamingStrategy {
  ...
}

const orm = await MikroORM.init({
  ...
  namingStrategy: MyCustomNamingStrategy,
  ...
});

----------------------------------------

TITLE: Installing MikroORM Database Drivers
DESCRIPTION: Commands for installing MikroORM core and specific database drivers for different SQL databases including MongoDB, MySQL, PostgreSQL, SQLite and others.

LANGUAGE: bash
CODE:
npm install @mikro-orm/core @mikro-orm/mongodb
npm install @mikro-orm/core @mikro-orm/mysql
npm install @mikro-orm/core @mikro-orm/mariadb
npm install @mikro-orm/core @mikro-orm/postgresql
npm install @mikro-orm/core @mikro-orm/sqlite
npm install @mikro-orm/core @mikro-orm/better-sqlite
npm install @mikro-orm/core @mikro-orm/libsql
npm install @mikro-orm/core @mikro-orm/mssql

----------------------------------------

TITLE: Forking EntityManager for Request Isolation
DESCRIPTION: Shows how to create a new EntityManager instance with its own context and identity map

LANGUAGE: typescript
CODE:
const em = orm.em.fork();

----------------------------------------

TITLE: Executing Raw SQL Queries with QueryBuilder
DESCRIPTION: Example of creating and executing raw SQL queries using QueryBuilder in MikroORM.

LANGUAGE: typescript
CODE:
const qb = em.createQueryBuilder('Author');
qb.select('*').where({ id: { $in: [...] } });
const res = await em.getDriver().execute(qb);
console.log(res); // unprocessed result of underlying database driver

----------------------------------------

TITLE: Configuring MikroORM for Schema First Approach
DESCRIPTION: Configuration setup for MikroORM including entity generation, migrations and naming strategy settings

LANGUAGE: typescript
CODE:
import { defineConfig } from '@mikro-orm/mysql';
import { EntityGenerator } from '@mikro-orm/entity-generator';
import { Migrator } from '@mikro-orm/migrations';

export default defineConfig({
    multipleStatements: true,
    extensions: [EntityGenerator, Migrator],
    discovery: {
        warnWhenNoEntities: false,
    },
    entities: ['dist/**/*.entity.js'],
    entitiesTs: ['src/**/*.entity.ts'],
    host: 'localhost',
    user: 'root',
    password: '',
    dbName: 'blog',
    debug: true,
    migrations: {
        path: 'dist/migrations',
        pathTs: 'src/migrations',
    },
    entityGenerator: {
        save: true,
        path: 'src/modules',
        esmImport: true,
        readOnlyPivotTables: true,
        outputPurePivotTables: true,
        bidirectionalRelations: true,
        customBaseEntityName: 'Base',
        useCoreBaseEntity: true,
    },
});

----------------------------------------

TITLE: Batching Queries with Promise.all and Dataloaders (TypeScript)
DESCRIPTION: These snippets show how to use Promise.all with dataloaders to batch multiple queries. The first example loads books for multiple authors, while the second loads authors for multiple books.

LANGUAGE: typescript
CODE:
const authors = await orm.em.find(Author, [1, 2, 3]);
await Promise.all(authors.map(author => author.books.load({ dataloader: true })));

LANGUAGE: typescript
CODE:
const books = await orm.em.find(Book, [1, 2, 3]);
await Promise.all(books.map(book => book.author.load({ dataloader: true })));

----------------------------------------

TITLE: Using discriminatorValue with Abstract Entities in MikroORM
DESCRIPTION: Demonstrates how to implement Single Table Inheritance using discriminatorValue with abstract base classes and explicit type definitions.

LANGUAGE: typescript
CODE:
@Entity({
  discriminatorColumn: 'type',
  abstract: true,
})
export abstract class BasePerson {

  @Enum()
  type!: 'person' | 'employee';

}

@Entity({ discriminatorValue: 'person' })
export class Person extends BasePerson {
  // ...
}

@Entity({ discriminatorValue: 'employee' })
export class Employee extends Person {
  // ...
}

----------------------------------------

TITLE: Using ref() Helper for Entity References in TypeScript
DESCRIPTION: This snippet shows how to use the 'ref()' helper function with the Reference wrapper for creating entity references in constructors.

LANGUAGE: typescript
CODE:
@ManyToOne({ entity: () => Author, ref: true })
author: Ref<Author>;

constructor(dto: { title: string; author: number }) {
  this.title = dto.title;
  this.author = ref(Author, dto.author);
}

----------------------------------------

TITLE: Defining Custom Entity Class with Schema
DESCRIPTION: Example of defining a custom Author entity class with its corresponding schema definition

LANGUAGE: typescript
CODE:
export class Author extends CustomBaseEntity {
  name: string;
  email: string;
  age?: number;
  termsAccepted?: boolean;
  identities?: string[];
  born?: Date;
  books = new Collection<Book>(this);
  favouriteBook?: Book;
  version?: number;

  constructor(name: string, email: string) {
    super();
    this.name = name;
    this.email = email;
  }
}

export const schema = new EntitySchema<Author, CustomBaseEntity>({
  class: Author,
  extends: CustomBaseEntitySchema,
  properties: {
    name: { type: 'string' },
    email: { type: 'string', unique: true },
    age: { type: 'number', nullable: true },
    termsAccepted: { type: 'boolean', default: 0, onCreate: () => false },
    identities: { type: 'string[]', nullable: true },
    born: { type: DateType, nullable: true, length: 3 },
    books: { kind: '1:m', entity: () => 'Book', mappedBy: book => book.author },
    favouriteBook: { kind: 'm:1', type: 'Book' },
    version: { type: 'number', persist: false },
  },
});

----------------------------------------

TITLE: Defining ManyToOne Relationships in MikroORM (TypeScript)
DESCRIPTION: This snippet demonstrates various ways to define a ManyToOne relationship in MikroORM using TypeScript decorators. It shows different syntax options for specifying the related entity type.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @ManyToOne() // plain decorator is enough, type will be sniffer via reflection!
  author1!: Author;

  @ManyToOne(() => Author) // you can specify type manually as a callback
  author2!: Author;

  @ManyToOne('Author') // or as a string
  author3!: Author;

  @ManyToOne({ entity: () => Author }) // or use options object
  author4!: Author;

}

----------------------------------------

TITLE: Defining ManyToOne Relationships in MikroORM (TypeScript)
DESCRIPTION: This snippet demonstrates various ways to define a ManyToOne relationship in MikroORM using TypeScript decorators. It shows different syntax options for specifying the related entity type.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @ManyToOne() // plain decorator is enough, type will be sniffer via reflection!
  author1!: Author;

  @ManyToOne(() => Author) // you can specify type manually as a callback
  author2!: Author;

  @ManyToOne('Author') // or as a string
  author3!: Author;

  @ManyToOne({ entity: () => Author }) // or use options object
  author4!: Author;

}

----------------------------------------

TITLE: Using Built-in Types from MikroORM
DESCRIPTION: This snippet demonstrates how to use built-in types provided by MikroORM, such as BigIntType and ArrayType. It shows how to apply these types to entity properties using the @Property decorator.

LANGUAGE: typescript
CODE:
import { Property, types } from '@mikro-orm/core';

@Property({ type: types.bigint, nullable: true })
largeNumber?: string; // bigints are mapped to strings so we don't loose precision

@Property({ type: ArrayType, nullable: true })
stringArray?: string[];

@Property({ type: new ArrayType(i => +i), nullable: true })
numericArray?: number[];

----------------------------------------

TITLE: Implementing Custom Platform Class for MikroORM
DESCRIPTION: This snippet shows how to create a custom Platform class by extending the base Platform class from MikroORM. It includes methods for defining database-specific features and behaviors.

LANGUAGE: typescript
CODE:
import { Platform } from '@mikro-orm/core';

export class MyCustomPlatform extends Platform {

  protected abstract schemaHelper: MyCustomSchemaHelper;

  // here you can override default settings
  usesPivotTable(): boolean;
  supportsTransactions(): boolean;
  supportsSavePoints(): boolean;
  getNamingStrategy(): { new (): NamingStrategy; };
  getIdentifierQuoteCharacter(): string;
  getParameterPlaceholder(index?: number): string;
  usesReturningStatement(): boolean;
  normalizePrimaryKey<T = number | string>(data: IPrimaryKey): T;
  denormalizePrimaryKey(data: IPrimaryKey): IPrimaryKey;
  getSerializedPrimaryKeyField(field: string): string;

}

----------------------------------------

TITLE: Loading Multiple Authors and Their Books with Promise.all
DESCRIPTION: Example showing how to efficiently load multiple authors and their associated books using dataloaders and Promise.all.

LANGUAGE: typescript
CODE:
const authors = await orm.em.find(Author, [1, 2, 3]);
await Promise.all(authors.map(author => author.books.load({ dataloader: true })));

----------------------------------------

TITLE: Installing MikroORM and Database Drivers with NPM
DESCRIPTION: Commands to install MikroORM core and database-specific drivers using NPM package manager.

LANGUAGE: sh
CODE:
npm i -s @mikro-orm/core @mikro-orm/mongodb     # for mongo
npm i -s @mikro-orm/core @mikro-orm/mysql       # for mysql/mariadb
npm i -s @mikro-orm/core @mikro-orm/mariadb     # for mysql/mariadb
npm i -s @mikro-orm/core @mikro-orm/postgresql  # for postgresql
npm i -s @mikro-orm/core @mikro-orm/sqlite      # for sqlite

----------------------------------------

TITLE: Enabling Pretty Printing for Cached Metadata in MikroORM
DESCRIPTION: This snippet demonstrates how to enable pretty printing for cached metadata in MikroORM. It sets the 'pretty' property of the 'cache' option to true during initialization.

LANGUAGE: typescript
CODE:
await MikroORM.init({
  cache: { pretty: true },
  // ...
});

----------------------------------------

TITLE: Entity Hooks Implementation
DESCRIPTION: Shows different ways to implement entity lifecycle hooks using EntitySchema, including instance methods, normal functions, and arrow functions.

LANGUAGE: typescript
CODE:
export class BookTag {
  _id!: ObjectId;
  id!: string;
  name: string;
  books = new Collection<Book>(this);

  constructor(name: string) {
    this.name = name;
  }

  beforeCreate() {
    this.version = 1;
  }

  beforeUpdate() {
    this.version++;
  }
}

function beforeUpdate() {
  this.version++;
}

const beforeUpdate2 = (args: EventArgs) => args.entity.version++;

export const schema = new EntitySchema({
  class: BookTag,
  hooks: {
    beforeCreate: ['beforeCreate'],
    beforeUpdate: ['beforeUpdate', beforeUpdate, beforeUpdate2]
  },
  properties: {
    _id: { type: 'ObjectId', primary: true },
    id: { type: 'string', serializedPrimaryKey: true },
    name: { type: 'string' },
    books: { kind: 'm:n', entity: () => Book, mappedBy: book => book.tags },
  },
});

----------------------------------------

TITLE: Using Custom Logger Function in MikroORM (TypeScript)
DESCRIPTION: This example demonstrates how to provide a custom logger function to MikroORM, allowing for integration with custom logging systems.

LANGUAGE: typescript
CODE:
return MikroORM.init({
  debug: true,
  logger: msg => myCustomLogger.log(msg),
});

----------------------------------------

TITLE: Defining Virtual Entity with SQL Expression in TypeScript
DESCRIPTION: Demonstrates creating a virtual entity using a SQL query string to select book and author data. The entity maps results from a complex SQL query joining books, authors and tags tables.

LANGUAGE: typescript
CODE:
@Entity({
  expression: 'select name, age, ' +
    '(select count(*) from book b where b.author_id = a.id) as total_books, ' +
    '(select group_concat(distinct t.name) from book b ' +
      'join tags_ordered bt on bt.book_id = b.id ' +
      'join book_tag t on t.id = bt.book_tag_id ' +
      'where b.author_id = a.id ' +
      'group by b.author_id) as used_tags ' +
    'from author a group by a.id',
})
export class BookWithAuthor {

  @Property()
  title!: string;

  @Property()
  authorName!: string;

  @Property()
  tags!: string[];

}

----------------------------------------

TITLE: Entity Hooks Implementation
DESCRIPTION: Shows different ways to implement entity lifecycle hooks using EntitySchema, including instance methods, normal functions, and arrow functions.

LANGUAGE: typescript
CODE:
export class BookTag {
  _id!: ObjectId;
  id!: string;
  name: string;
  books = new Collection<Book>(this);

  constructor(name: string) {
    this.name = name;
  }

  beforeCreate() {
    this.version = 1;
  }

  beforeUpdate() {
    this.version++;
  }
}

function beforeUpdate() {
  this.version++;
}

const beforeUpdate2 = (args: EventArgs) => args.entity.version++;

export const schema = new EntitySchema({
  class: BookTag,
  hooks: {
    beforeCreate: ['beforeCreate'],
    beforeUpdate: ['beforeUpdate', beforeUpdate, beforeUpdate2]
  },
  properties: {
    _id: { type: 'ObjectId', primary: true },
    id: { type: 'string', serializedPrimaryKey: true },
    name: { type: 'string' },
    books: { kind: 'm:n', entity: () => Book, mappedBy: book => book.tags },
  },
});

----------------------------------------

TITLE: Using discriminatorValue with Abstract Entities in MikroORM
DESCRIPTION: Demonstrates how to implement Single Table Inheritance using discriminatorValue with abstract entities and explicit type discrimination.

LANGUAGE: typescript
CODE:
@Entity({
  discriminatorColumn: 'type',
  abstract: true,
})
export abstract class BasePerson {

  @Enum()
  type!: 'person' | 'employee';

}

@Entity({ discriminatorValue: 'person' })
export class Person extends BasePerson {
  // ...
}

@Entity({ discriminatorValue: 'employee' })
export class Employee extends Person {
  // ...
}

----------------------------------------

TITLE: Defining Entity Relationships with Basic Loading Strategy
DESCRIPTION: Example showing how to define basic entity relationships between Author and Book entities using TypeScript decorators in MikroORM.

LANGUAGE: typescript
CODE:
import { Entity, LoadStrategy, OneToMany, ManyToOne } from '@mikro-orm/core';

@Entity()
export class Author {
  @OneToMany(() => Book, b => b.author)
  books = new Collection<Book>(this);
}

@Entity()
export class Book {
  @ManyToOne()
  author: Author;
}

----------------------------------------

TITLE: Using Custom Author Entity Class in TypeScript
DESCRIPTION: This snippet shows how to use a custom entity class with a repository after defining it with EntitySchema.

LANGUAGE: typescript
CODE:
const repo = em.getRepository(Author);
const author = new Author('name', 'email');
await repo.persistAndFlush(author);

----------------------------------------

TITLE: Basic Bidirectional Relation Propagation in TypeScript
DESCRIPTION: Demonstrates basic bidirectional relation propagation between Author and Book entities. Shows how setting a relation on one side automatically updates the other side.

LANGUAGE: typescript
CODE:
const author = new Author(...);
const book = new Book(...);
book.author = author;
console.log(author.books.contains(book)); // true

----------------------------------------

TITLE: Initializing MikroORM with MongoDB Transactions Support in TypeScript
DESCRIPTION: Shows how to initialize MikroORM with MongoDB transactions support, including replica set configuration and schema creation.

LANGUAGE: typescript
CODE:
// make sure to import from the MongoDriver package
import { MikroORM } from '@mikro-orm/mongodb';

const orm = await MikroORM.init({
  entities: [Author, Book, ...],
  clientUrl: 'mongodb://localhost:27017,localhost:27018,localhost:27019/my-db-name?replicaSet=rs0',
  implicitTransactions: true, // defaults to false
});

await orm.schema.createSchema();

----------------------------------------

TITLE: Implicit Joining in QueryBuilder with MikroORM
DESCRIPTION: This snippet showcases automatic joining based on entity metadata in QueryBuilder. It demonstrates how to create complex queries with nested relationships without explicitly defining joins.

LANGUAGE: typescript
CODE:
const qb = orm.em.createQueryBuilder(Author);
qb.select('*')
  .where({ books: { tags: { name: 'Cool' } } })
  .orderBy({ books: { tags: { createdBy: QueryOrder.DESC } } });

console.log(qb.getQuery());
// select `e0`.*
// from `author` as `e0`
// left join `book2` as `e1` on `e0`.`id` = `e1`.`author_id`
// left join `book2_to_book_tag2` as `e3` on `e1`.`uuid_pk` = `e3`.`book2_uuid_pk`
// left join `book_tag2` as `e2` on `e3`.`book_tag2_id` = `e2`.`id`
// where `e2`.`name` = ?
// order by `e1`.`tags` asc

----------------------------------------

TITLE: Extended Entity Repository Implementation
DESCRIPTION: Implementation of an extended entity repository that restores removed persistence methods from v6.

LANGUAGE: typescript
CODE:
import { EntityManager, EntityRepository, AnyEntity } from '@mikro-orm/mysql';

export class ExtendedEntityRepository<T extends object> extends EntityRepository<T> {

  persist(entity: AnyEntity | AnyEntity[]): EntityManager {
    return this.em.persist(entity);
  }

  async persistAndFlush(entity: AnyEntity | AnyEntity[]): Promise<void> {
    await this.em.persistAndFlush(entity);
  }

  remove(entity: AnyEntity): EntityManager {
    return this.em.remove(entity);
  }

  async removeAndFlush(entity: AnyEntity): Promise<void> {
    await this.em.removeAndFlush(entity);
  }

  async flush(): Promise<void> {
    return this.em.flush();
  }

}

----------------------------------------

TITLE: Cache Clearing in MikroORM
DESCRIPTION: Shows how to set explicit cache keys and clear cached results using the EntityManager clearCache method.

LANGUAGE: typescript
CODE:
// set the cache key to 'book-cache-key', with expiration of 60s
const res = await em.find(Book, { ... }, { cache: ['book-cache-key', 60_000] });

// clear the cache key by name
await em.clearCache('book-cache-key');

----------------------------------------

TITLE: Knex Type Definition for esbuild
DESCRIPTION: Type definition file to enable Knex compatibility with esbuild bundling

LANGUAGE: typescript
CODE:
declare module 'knex/lib/dialects/postgres' {
  import { Knex } from 'esbuild-support/knex';
  const client: Knex.Client;
  export = client;
}

----------------------------------------

TITLE: Working with Entity References in MikroORM
DESCRIPTION: Explains how to use entity references for efficient operations without loading full entities in MikroORM.

LANGUAGE: typescript
CODE:
const userRef = em.getReference(User, 1);
console.log(userRef);

// setting relation properties
author.favouriteBook = em.getReference(Book, 1);

// removing entity by reference
em.remove(em.getReference(Book, 2));

// adding entity to collection by reference
author.books.add(em.getReference(Book, 3));

----------------------------------------

TITLE: Demonstrating Identity Map in MikroORM with TypeScript
DESCRIPTION: This snippet shows how MikroORM's identity map ensures the same instance of an entity is returned across different queries. It retrieves an author and then compares it with the first author from a separate query to demonstrate identity.

LANGUAGE: typescript
CODE:
const authorRepository = orm.em.getRepository(Author);
const jon = await authorRepository.findOne({ name: 'Jon Snow' }, ['books']);
const authors = await authorRepository.findAll(['books']);

// identity map in action
console.log(jon === authors[0]); // true

----------------------------------------

TITLE: Knex Type Definition for esbuild
DESCRIPTION: Type definition file to enable Knex compatibility with esbuild bundling

LANGUAGE: typescript
CODE:
declare module 'knex/lib/dialects/postgres' {
  import { Knex } from 'esbuild-support/knex';
  const client: Knex.Client;
  export = client;
}

----------------------------------------

TITLE: Using Custom Type in Entity Definition
DESCRIPTION: Example of using a custom type in an entity class definition with MikroORM decorators.

LANGUAGE: typescript
CODE:
@Entity()
export class FooBar {

  @PrimaryKey()
  id!: number;

  @Property()
  name!: string;

  @Property({ type: DateType, length: 3 })
  born?: Date;

}

----------------------------------------

TITLE: Creating Entity Instances
DESCRIPTION: Examples of creating entity instances using both direct constructor and EntityManager.create() method.

LANGUAGE: typescript
CODE:
const author = new Author();
const book = new Book('Foo', author);

LANGUAGE: typescript
CODE:
const author = new Author();
const book = em.create(Book, { title: 'Foo', author, foo: 123 });

----------------------------------------

TITLE: Configuring TypeScript for Proper Entity Initialization
DESCRIPTION: This JSON configuration disables the useDefineForClassFields option in TypeScript to prevent unexpected behavior with entity property initialization.

LANGUAGE: json
CODE:
{
  "compilerOptions": {
    "useDefineForClassFields": false
  }
}

----------------------------------------

TITLE: Creating Entity Instances
DESCRIPTION: Examples of creating entity instances using both direct constructor and EntityManager.create() method.

LANGUAGE: typescript
CODE:
const author = new Author();
const book = new Book('Foo', author);

LANGUAGE: typescript
CODE:
const author = new Author();
const book = em.create(Book, { title: 'Foo', author, foo: 123 });

----------------------------------------

TITLE: Creating Entity Instances
DESCRIPTION: Examples of creating entity instances using both direct constructor and EntityManager.create() method.

LANGUAGE: typescript
CODE:
const author = new Author();
const book = new Book('Foo', author);

LANGUAGE: typescript
CODE:
const author = new Author();
const book = em.create(Book, { title: 'Foo', author, foo: 123 });

----------------------------------------

TITLE: Demonstrating Strict Property Type Validation in MikroORM
DESCRIPTION: This code snippet shows various scenarios of strict property type validation in MikroORM. It includes examples of assigning incorrect types, auto-correction of valid formats, and throwing errors for invalid assignments.

LANGUAGE: typescript
CODE:
// number instead of string will throw
const author = new Author('test', 'test');
wrap(author).assign({ name: 111, email: 222 });
await orm.em.persistAndFlush(author); // throws "Validation error: trying to set Author.name of type 'string' to '111' of type 'number'"

// string date with unknown format will throw
wrap(author).assign(author, { name: '333', email: '444', born: 'asd' });
await orm.em.persistAndFlush(author); // throws "Validation error: trying to set Author.born of type 'date' to 'asd' of type 'string'"

// string date with correct format will be auto-corrected
wrap(author).assign({ name: '333', email: '444', born: '2018-01-01' });
await orm.em.persistAndFlush(author);
console.log(author.born).toBe(true); // instance of Date

// Date object will be ok
wrap(author).assign({ born: new Date() });
await orm.em.persistAndFlush(author);
console.log(author.born).toBe(true); // instance of Date

// null will be ok
wrap(author).assign({ born: null });
await orm.em.persistAndFlush(author);
console.log(author.born); // null

// string number with correct format will be auto-corrected
wrap(author).assign({ age: '21' });
await orm.em.persistAndFlush(author);
console.log(author.age); // number 21

// string instead of number with will throw
wrap(author).assign({ age: 'asd' });
await orm.em.persistAndFlush(author); // throws "Validation error: trying to set Author.age of type 'number' to 'asd' of type 'string'"
wrap(author).assign({ age: new Date() });
await orm.em.persistAndFlush(author); // throws "Validation error: trying to set Author.age of type 'number' to '2019-01-17T21:14:23.875Z' of type 'date'"
wrap(author).assign({ age: false });
await orm.em.persistAndFlush(author); // throws "Validation error: trying to set Author.age of type 'number' to 'false' of type 'boolean'"

----------------------------------------

TITLE: Configuring TypeScript for Proper Entity Initialization in MikroORM
DESCRIPTION: Shows how to configure TypeScript to avoid unexpected behavior when initializing new entity instances. This involves disabling the useDefineForClassFields option in tsconfig.

LANGUAGE: json
CODE:
{
  "compilerOptions": {
    "useDefineForClassFields": false
  }
}

----------------------------------------

TITLE: Using raw() Helper Function in TypeScript with MikroORM
DESCRIPTION: Demonstrates how to use the raw() helper function to incorporate raw SQL fragments in MikroORM queries. Shows usage as both value and key in find operations.

LANGUAGE: typescript
CODE:
// as a value
await em.find(User, { time: raw('now()') });

// as a key
await em.find(User, { [raw('lower(name)')]: name.toLowerCase() });

// value can be empty array
await em.find(User, { [raw('(select 1 = 1)')]: [] });

----------------------------------------

TITLE: Implementing Async Filter Conditions with MikroORM in TypeScript
DESCRIPTION: This example shows how to define a filter with an asynchronous condition callback. The callback receives arguments including user-provided parameters, operation type, and the EntityManager instance, allowing for complex and dynamic filter logic.

LANGUAGE: typescript
CODE:
import type { EntityManager } from '@mikro-orm/mysql';

@Entity()
@Filter({ name: 'writtenBy', cond: async (args, type, em: EntityManager) => {
  if (type === 'update') {
    return {}; // do not apply when updating
  }

  return {
    author: { name: args.name },
    publishedAt: { $lte: raw('now()') },
  };
} })
export class Book {
  ...
}

const books = await orm.em.find(Book, {}, {
  filters: { writtenBy: { name: 'God' } },
});

----------------------------------------

TITLE: Mathematical Symbol Operators Query
DESCRIPTION: Shows how to use mathematical symbols as operators for comparison operations. Note that this syntax requires casting to 'any' in TypeScript.

LANGUAGE: typescript
CODE:
const res = await orm.em.find(Author, { $and: [
  { 'id >': 5 },
  { 'id <': 10 },
  { 'id >=': 7 },
  { 'id <=': 8 },
  { 'id !=': 9 },
] });

----------------------------------------

TITLE: Custom Redis Cache Adapter Implementation Template
DESCRIPTION: Example class declaration for implementing a Redis-based cache adapter.

LANGUAGE: typescript
CODE:
export class RedisCacheAdapter implements CacheAdapter { ... }

----------------------------------------

TITLE: Configuring EntitySchema with Advanced Options in TypeScript
DESCRIPTION: This snippet showcases various configuration options for EntitySchema, including indexes, uniques, repository, and complex property definitions.

LANGUAGE: typescript
CODE:
export enum MyEnum {
  LOCAL = 'local',
  GLOBAL = 'global',
}

export const schema = new EntitySchema<FooBar>({
  name: 'FooBar',
  tableName: 'tbl_foo_bar',
  indexes: [{ name: 'idx1', properties: 'name' }],
  uniques: [{ name: 'unq1', properties: ['name', 'email'] }],
  repository: () => FooBarRepository,
  properties: {
    id: { type: 'number', primary: true },
    name: { type: 'string' },
    baz: { kind: '1:1', entity: 'FooBaz', orphanRemoval: true, nullable: true },
    fooBar: { kind: '1:1', entity: 'FooBar', nullable: true },
    publisher: { kind: 'm:1', entity: 'Publisher', inversedBy: 'books' },
    books: { kind: '1:m', entity: () => 'Book', mappedBy: book => book.author },
    tags: { kind: 'm:n', entity: 'BookTag', inversedBy: 'books', fixedOrder: true },
    version: { type: 'Date', version: true, length: 0 },
    type: { enum: true, items: () => MyEnum, default: MyEnum.LOCAL },
  },
});

----------------------------------------

TITLE: Disabling Transactions in MikroORM
DESCRIPTION: Demonstrates how to disable transactions locally when using the transactional() method or when creating a new EntityManager fork in MikroORM.

LANGUAGE: typescript
CODE:
// only the outer transaction will be opened
await orm.em.transactional(async em => {
  // but the inner calls to both em.transactional and em.begin will be no-op
  await em.transactional(...);
}, { disableTransactions: true });

LANGUAGE: typescript
CODE:
const em = await orm.em.fork({ disableTransactions: true });
await em.transactional(...); // no-op
await em.begin(...); // no-op
await em.commit(...); // commit still calls `flush`

----------------------------------------

TITLE: Disabling Transactions in MikroORM
DESCRIPTION: Demonstrates how to disable transactions locally when using the transactional() method or when creating a new EntityManager fork in MikroORM.

LANGUAGE: typescript
CODE:
// only the outer transaction will be opened
await orm.em.transactional(async em => {
  // but the inner calls to both em.transactional and em.begin will be no-op
  await em.transactional(...);
}, { disableTransactions: true });

LANGUAGE: typescript
CODE:
const em = await orm.em.fork({ disableTransactions: true });
await em.transactional(...); // no-op
await em.begin(...); // no-op
await em.commit(...); // commit still calls `flush`

----------------------------------------

TITLE: Importing SqlEntityManager for QueryBuilder in MikroORM
DESCRIPTION: This snippet demonstrates how to import and use the SQL-specific EntityManager to access the createQueryBuilder() method in MikroORM v4.

LANGUAGE: ts
CODE:
import { EntityManager } from '@mikro-orm/mysql'; // or any other SQL driver package

const em = orm.em as EntityManager;
const qb = await em.createQueryBuilder(...);

----------------------------------------

TITLE: Unmanaged Entity Update with assign()
DESCRIPTION: Demonstrates how to use assign() with unmanaged entities by providing EntityManager instance

LANGUAGE: typescript
CODE:
import { wrap } from '@mikro-orm/core';

const book = new Book();
wrap(book).assign({
  title: 'Better Book 1',
  author: '...id...',
}, { em });

----------------------------------------

TITLE: Handling Entities with Explicit Primary Keys in MikroORM (TypeScript)
DESCRIPTION: This snippet shows how MikroORM handles entities with explicit primary keys, adding them to the identity map without querying the database.

LANGUAGE: typescript
CODE:
// primary key value provided, will be added to the identity map
const jon = em.create(Author, {
  id: 1,
  name: 'Jon',
  email: 'foo@bar.com',
});

// this will not query the database
const jon2 = await em.findOne(Author, 1);
console.log(jon === jon2); // true
await em.flush(); // this inserts the entity

----------------------------------------

TITLE: Handling Entities with Explicit Primary Keys in MikroORM (TypeScript)
DESCRIPTION: This snippet shows how MikroORM handles entities with explicit primary keys, adding them to the identity map without querying the database.

LANGUAGE: typescript
CODE:
// primary key value provided, will be added to the identity map
const jon = em.create(Author, {
  id: 1,
  name: 'Jon',
  email: 'foo@bar.com',
});

// this will not query the database
const jon2 = await em.findOne(Author, 1);
console.log(jon === jon2); // true
await em.flush(); // this inserts the entity

----------------------------------------

TITLE: Implementing Cascade Remove in MikroORM
DESCRIPTION: Example of cascade remove functionality and its potential risks when used with ManyToOne relationships.

LANGUAGE: typescript
CODE:
await orm.em.removeEntity(book); // this will also remove book.publisher

----------------------------------------

TITLE: Using Custom Date Type in Entity Definition with MikroORM
DESCRIPTION: This snippet shows how to use the custom MyDateType in an entity definition. It demonstrates applying the custom type to a property using the @Property decorator.

LANGUAGE: typescript
CODE:
@Entity()
export class FooBar {

  @PrimaryKey()
  id!: number;

  @Property()
  name!: string;

  @Property({ type: MyDateType, length: 3 })
  born?: Date;

}

----------------------------------------

TITLE: Setting Global Loading Strategy in MikroORM Configuration
DESCRIPTION: This example demonstrates how to set a global default loading strategy in the MikroORM initialization configuration.

LANGUAGE: typescript
CODE:
MikroORM.init({
  // ...
  populate: ['books'],
  loadStrategy: 'select-in', // 'joined' is the default for SQL drivers
});

----------------------------------------

TITLE: Defining Article Entity with Relationships in TypeScript for MikroORM
DESCRIPTION: Creates an Article entity with various properties including a ManyToOne relationship to the User entity. Uses decorators to specify property types and relationship metadata.

LANGUAGE: TypeScript
CODE:
import { Entity, ManyToOne, Property, t } from '@mikro-orm/core';
import { BaseEntity } from '../common/base.entity.js';
import { User } from '../user/user.entity.js';

@Entity()
export class Article extends BaseEntity {

  @Property({ unique: true })
  slug!: string;

  @Property({ index: true })
  title!: string;

  @Property({ length: 1000 })
  description!: string;

  @Property({ type: t.text, lazy: true })
  text!: string;

  @ManyToOne()
  author!: User;

}

----------------------------------------

TITLE: Nested Population of Entities in MikroORM with TypeScript
DESCRIPTION: This snippet demonstrates how to use nested populate in MikroORM to efficiently load related entities. It shows loading BookTags with their related Books, Publishers, Tests, and Authors in a single query.

LANGUAGE: typescript
CODE:
const tags = await orm.em.findAll(BookTag, ['books.publisher.tests', 'books.author']);
console.log(tags[0].books[0].publisher.tests[0].name); // prints name of nested test
console.log(tags[0].books[0].author.name); // prints name of nested author

----------------------------------------

TITLE: Configuring TypeScript for MikroORM
DESCRIPTION: TypeScript configuration options required for MikroORM, including decorator support and ES module interop.

LANGUAGE: json
CODE:
"experimentalDecorators": true,
"esModuleInterop": true

----------------------------------------

TITLE: Defining Entities in Multiple Schemas with MikroORM
DESCRIPTION: Demonstrates how to define entities in different schemas using the @Entity decorator with 'schema' or 'tableName' options.

LANGUAGE: typescript
CODE:
@Entity({ schema: 'first_schema' })
export class Foo { ... }

// or alternatively we can specify it inside custom table name
@Entity({ tableName: 'second_schema.bar' })
export class Bar { ... }

----------------------------------------

TITLE: Test Application Initialization Helper
DESCRIPTION: Helper function to initialize test environment with in-memory database and seeding support.

LANGUAGE: typescript
CODE:
import { bootstrap } from '../src/app.js';
import { initORM } from '../src/db.js';

export async function initTestApp(port: number) {
  const { orm } = await initORM({
    debug: false,
    dbName: ':memory:',
  });

  await orm.schema.createSchema();
  await orm.seeder.seed(TestSeeder);

  const { app } = await bootstrap(port, false);

  return app;
}

----------------------------------------

TITLE: Defining Wildcard Schema Entity
DESCRIPTION: Example of defining an entity that can exist in multiple schemas using wildcard schema

LANGUAGE: typescript
CODE:
@Entity({ schema: '*' })
export class Book {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  name?: string;

  @ManyToOne(() => Author, { nullable: true, deleteRule: 'cascade' })
  author?: Author;

  @ManyToOne(() => Book, { nullable: true })
  basedOn?: Book;

}

----------------------------------------

TITLE: Installing MikroORM and Database Drivers
DESCRIPTION: Commands to install MikroORM core and specific database drivers using npm.

LANGUAGE: bash
CODE:
# for mongodb
npm install @mikro-orm/core @mikro-orm/mongodb

# for mysql (works with mariadb too)
npm install @mikro-orm/core @mikro-orm/mysql

# for mariadb (works with mysql too)
npm install @mikro-orm/core @mikro-orm/mariadb

# for postgresql (works with cockroachdb too)
npm install @mikro-orm/core @mikro-orm/postgresql

# for sqlite
npm install @mikro-orm/core @mikro-orm/sqlite

# for better-sqlite
npm install @mikro-orm/core @mikro-orm/better-sqlite

# for libsql/turso
npm install @mikro-orm/core @mikro-orm/libsql

# for mssql
npm install @mikro-orm/core @mikro-orm/mssql

----------------------------------------

TITLE: Configuring Entity Discovery in MikroORM
DESCRIPTION: This snippet demonstrates how to configure entity discovery in MikroORM, either by providing an array of entity instances or using folder-based discovery with glob patterns.

LANGUAGE: typescript
CODE:
MikroORM.init({
  entities: [Author, Book, Publisher, BookTag],
});

MikroORM.init({
  entities: ['./dist/modules/users/entities', './dist/modules/projects/entities'],
  entitiesTs: ['./src/modules/users/entities', './src/modules/projects/entities'],
  baseDir: process.cwd(),
});

----------------------------------------

TITLE: Implementing Mapped Superclass in TypeScript with MikroORM
DESCRIPTION: Demonstrates how to create a mapped superclass and its entity subclass using TypeScript decorators in MikroORM. The example includes a Person superclass and an Employee entity with their respective properties and relationships.

LANGUAGE: typescript
CODE:
// do not use @Entity decorator on base classes (mapped superclasses)
// we can also use @Entity({ abstract: true })
export abstract class Person {

  @Property()
  mapped1!: number;

  @Property()
  mapped2!: string;

  @OneToOne()
  toothbrush!: Toothbrush;

  // ... more fields and methods
}

@Entity()
export class Employee extends Person {

  @PrimaryKey()
  id!: number;

  @Property()
  name!: string;

  // ... more fields and methods

}

@Entity()
export class Toothbrush {

  @PrimaryKey()
  id!: number;

  // ... more fields and methods

}

----------------------------------------

TITLE: Generating MikroORM Cache Bundle
DESCRIPTION: Command to generate a production cache bundle into a single JSON file using the MikroORM CLI.

LANGUAGE: bash
CODE:
npx mikro-orm cache:generate --combined

----------------------------------------

TITLE: Generated SQL for JSON Property Query in PostgreSQL
DESCRIPTION: Example of the SQL query generated by MikroORM when querying JSON properties in PostgreSQL, showing type casting and nested property access.

LANGUAGE: sql
CODE:
select "e0".*
from "book" as "e0"
where ("meta"->>'valid')::bool = true
  and "meta"->'nested'->>'foo' = '123'
  and ("meta"->'nested'->>'bar')::float8 = 321
  and ("meta"->'nested'->'deep'->>'baz')::float8 = 59
  and ("meta"->'nested'->'deep'->>'qux')::bool = false
limit 1

----------------------------------------

TITLE: Entity Relationships in MikroORM
DESCRIPTION: Demonstrates various relationship decorators including @ManyToOne, @OneToOne, @OneToMany, and @ManyToMany with their configuration options.

LANGUAGE: typescript
CODE:
@ManyToOne()
author1?: Author;

@OneToOne({ inversedBy: 'bestFriend1', orphanRemoval: true })
bestFriend2!: User;

@OneToMany(() => Book, book => book.author)
books1 = new Collection<Book>(this);

----------------------------------------

TITLE: Using raw() Helper in MikroORM Filters (TypeScript)
DESCRIPTION: Shows how to use the raw() helper in MikroORM filters, demonstrating the need for a callback signature when using the fragment as an object key.

LANGUAGE: typescript
CODE:
@Filter({ name: 'long', cond: () => ({ [raw('length(perex)')]: { $gt: 10000 } }) })

----------------------------------------

TITLE: Using sql.now() for Default Datetime Values in MikroORM (TypeScript)
DESCRIPTION: Shows how to use the sql.now() function to define a default value for a datetime column in MikroORM entity definitions.

LANGUAGE: typescript
CODE:
@Property({ default: sql.now() })
createdAt: Date & Opt;

----------------------------------------

TITLE: Accessing EntityManager in Lifecycle Hooks
DESCRIPTION: Shows how to access the internal EntityManager instance within a lifecycle hook. Note that this is not recommended for public usage.

LANGUAGE: typescript
CODE:
wrap(this).__em

----------------------------------------

TITLE: Specifying BigInt Target Types in MikroORM (TypeScript)
DESCRIPTION: Shows how to specify different target types for BigInt primary keys in MikroORM using TypeScript. This allows mapping bigints to different JavaScript types like bigint, string, or number, using the BigIntType with explicit type options.

LANGUAGE: typescript
CODE:
@PrimaryKey({ type: new BigIntType('bigint') })
id1: bigint;

@PrimaryKey({ type: new BigIntType('string') })
id2: string;

@PrimaryKey({ type: new BigIntType('number') })
id3: number;

----------------------------------------

TITLE: Using Custom Logger Function in MikroORM Configuration (TypeScript)
DESCRIPTION: Demonstrates how to provide a custom logger function when initializing MikroORM for more control over logging output.

LANGUAGE: typescript
CODE:
return MikroORM.init({
  debug: true,
  logger: msg => myCustomLogger.log(msg),
});

----------------------------------------

TITLE: Implementing Mapped Superclass in TypeScript with MikroORM
DESCRIPTION: Demonstrates how to create a mapped superclass and its entity subclasses. Shows the relationship between Person (superclass), Employee (entity), and Toothbrush (related entity). Includes property decorators and inheritance structure.

LANGUAGE: typescript
CODE:
export abstract class Person {

  @Property()
  mapped1!: number;

  @Property()
  mapped2!: string;

  @OneToOne()
  toothbrush!: Toothbrush;

  // ... more fields and methods
}

@Entity()
export class Employee extends Person {

  @PrimaryKey()
  id!: number;

  @Property()
  name!: string;

  // ... more fields and methods

}

@Entity()
export class Toothbrush {

  @PrimaryKey()
  id!: number;

  // ... more fields and methods

}

----------------------------------------

TITLE: Initializing Debug Mode in MikroORM
DESCRIPTION: Basic configuration to enable debug mode logging in MikroORM which will log all queries to console.log

LANGUAGE: typescript
CODE:
return MikroORM.init({
  debug: true,
});

----------------------------------------

TITLE: Defining a Version Field for Optimistic Locking in MikroORM
DESCRIPTION: Shows how to define a version field in an entity for optimistic locking. This can be either a number or a datetime field, with numbers being preferred for better concurrency handling.

LANGUAGE: typescript
CODE:
export class User {
  // ...
  @Property({ version: true })
  version!: number;
  // ...
}

----------------------------------------

TITLE: Defining MongoDB Entity Class
DESCRIPTION: Example of defining an entity class for MongoDB with decorators for primary key, properties, and relationships

LANGUAGE: typescript
CODE:
@Entity()
export class MongoBook {

  @PrimaryKey()
  _id: ObjectID;

  @SerializedPrimaryKey()
  id: string;

  @Property()
  title: string;

  @ManyToOne()
  author: Author;

  @ManyToMany()
  tags = new Collection<BookTag>(this);

  constructor(title: string, author: Author) {
    this.title = title;
    this.author = author;
  }

}

----------------------------------------

TITLE: Optimistic Locking with DateTime Version in MikroORM
DESCRIPTION: Shows implementation of optimistic locking using a datetime version field in an entity class.

LANGUAGE: typescript
CODE:
export class User {
  // ...
  @Property({ version: true })
  version!: Date;
  // ...
}

----------------------------------------

TITLE: Installing AdminJS Dependencies with NPM/Yarn
DESCRIPTION: Commands for installing core AdminJS packages, MikroORM adapter, and database drivers.

LANGUAGE: bash
CODE:
$ yarn add adminjs
$ yarn add @adminjs/mikroorm
# A MikroORM driver and core package, choose the one which suits you:
$ yarn add @mikro-orm/core @mikro-orm/mongodb     # for mongo
$ yarn add @mikro-orm/core @mikro-orm/mysql       # for mysql
$ yarn add @mikro-orm/core @mikro-orm/mariadb     # for mariadb
$ yarn add @mikro-orm/core @mikro-orm/postgresql  # for postgresql
$ yarn add @mikro-orm/core @mikro-orm/sqlite      # for sqlite

----------------------------------------

TITLE: Injecting Repository in NestJS Service
DESCRIPTION: Example of injecting an entity repository into a NestJS service using the @InjectRepository decorator.

LANGUAGE: typescript
CODE:
@Injectable()
export class PhotoService {
  constructor(
    @InjectRepository(Photo)
    private readonly photoRepository: EntityRepository<Photo>
  ) {}

  // ...
}

----------------------------------------

TITLE: Configuring Jest Fake Timers for MikroORM Compatibility
DESCRIPTION: This snippet shows how to configure Jest's fake timers to work with MikroORM by excluding the 'nextTick' function from being faked. This allows for better compatibility with MikroORM's dependencies that rely on process.nextTick().

LANGUAGE: typescript
CODE:
jest.useFakeTimers({ doNotFake: ['nextTick'] });

----------------------------------------

TITLE: Populating All Relations in MikroORM
DESCRIPTION: Shows how to populate all relationships using the wildcard operator and automatic population inference from filters.

LANGUAGE: typescript
CODE:
const tags = await em.find(BookTag, {}, {
  populate: ['*'],
});

LANGUAGE: typescript
CODE:
const tags = await em.find(BookTag, {
  books: { author: { name: '...' } },
}, {
  populate: ['$infer'],
});

----------------------------------------

TITLE: Using Custom MyDateType in MikroORM Entity
DESCRIPTION: This snippet shows how to use the custom MyDateType when defining entity properties in MikroORM.

LANGUAGE: typescript
CODE:
@Entity()
export class FooBar {

  @PrimaryKey()
  id!: number;

  @Property()
  name!: string;

  @Property({ type: MyDateType, length: 3 })
  born?: Date;

}

----------------------------------------

TITLE: Deep Object Merging with assign()
DESCRIPTION: Shows how to enable deep merging of object properties using mergeObjectProperties flag

LANGUAGE: typescript
CODE:
import { wrap } from '@mikro-orm/core';

book.meta = { foo: 1, bar: 2 };

wrap(book).assign({ meta: { foo: 3 } }, { mergeObjectProperties: true });
console.log(book.meta); // { foo: 3, bar: 2 }

wrap(book).assign({ meta: { foo: 4 } });
console.log(book.meta); // { foo: 4 }

----------------------------------------

TITLE: Basic Entity Cache Configuration in MikroORM
DESCRIPTION: Demonstrates how to use result caching with EntityManager's find method. Shows different ways to specify cache expiration and custom cache keys.

LANGUAGE: typescript
CODE:
const res = await em.find(Book, { author: { name: 'Jon Snow' } }, {
  populate: ['author', 'tags'],
  cache: 50, // set expiration to 50ms
  // cache: ['cache-key', 50], // set custom cache key and expiration
  // cache: true, // use default cache key and expiration
});

----------------------------------------

TITLE: Defining OneToMany Relationships in MikroORM with TypeScript
DESCRIPTION: This snippet shows different ways to define a OneToMany relationship in MikroORM using TypeScript decorators. It includes examples of specifying the inverse side of the relationship and using the Collection type.

LANGUAGE: typescript
CODE:
@Entity()
export class Author {

  @OneToMany(() => Book, book => book.author)
  books1 = new Collection<Book>(this);

  @OneToMany('Book', 'author')
  books2 = new Collection<Book>(this);

  @OneToMany({ mappedBy: book => book.author }) // referenced entity type can be sniffer too
  books3 = new Collection<Book>(this);

  @OneToMany({ entity: () => Book, mappedBy: 'author', orphanRemoval: true })
  books4 = new Collection<Book>(this);

}

----------------------------------------

TITLE: Using SQL Helper Functions in MikroORM
DESCRIPTION: Demonstrates various SQL helper functions including sql.ref(), sql.now(), sql.lower(), and sql.upper() for common SQL operations.

LANGUAGE: typescript
CODE:
await em.find(User, { foo: sql`bar` });

@Property({ default: sql.now() })
createdAt: Date & Opt;

const books = await orm.em.find(Book, {
  [sql.upper('title')]: 'TITLE',
});

----------------------------------------

TITLE: Extended Entity Repository Implementation
DESCRIPTION: Implementation of an extended entity repository that restores removed persistence methods from v6.

LANGUAGE: typescript
CODE:
import { EntityManager, EntityRepository, AnyEntity } from '@mikro-orm/mysql';

export class ExtendedEntityRepository<T extends object> extends EntityRepository<T> {

  persist(entity: AnyEntity | AnyEntity[]): EntityManager {
    return this.em.persist(entity);
  }

  async persistAndFlush(entity: AnyEntity | AnyEntity[]): Promise<void> {
    await this.em.persistAndFlush(entity);
  }

  remove(entity: AnyEntity): EntityManager {
    return this.em.remove(entity);
  }

  async removeAndFlush(entity: AnyEntity): Promise<void> {
    await this.em.removeAndFlush(entity);
  }

  async flush(): Promise<void> {
    return this.em.flush();
  }

}

----------------------------------------

TITLE: Implementing ManyToMany Relationships (Inverse Side) in MikroORM TypeScript
DESCRIPTION: Shows how to implement the inverse side of ManyToMany relationships in MikroORM using Collections and the mappedBy property.

LANGUAGE: typescript
CODE:
@Entity()
export class BookTag {

  @ManyToMany(() => Book, book => book.tags)
  books = new Collection<Book>(this);

}

----------------------------------------

TITLE: MikroORM Entity Directory Configuration
DESCRIPTION: Configuration for specifying entity directories using globbing patterns.

LANGUAGE: typescript
CODE:
const orm = await MikroORM.init({
  entitiesDirs: ['./dist/app/**/entities'],
  // ...
});

----------------------------------------

TITLE: Optional Property with Default Value
DESCRIPTION: Shows how to define an optional property with a default value in MikroORM entity.

LANGUAGE: typescript
CODE:
@Property({ default: 1 })
level?: number = 1;

----------------------------------------

TITLE: Registering Event Subscribers in MikroORM Configuration
DESCRIPTION: Example showing how to register an event subscriber in MikroORM initialization configuration.

LANGUAGE: typescript
CODE:
MikroORM.init({
  subscribers: [new AuthorSubscriber()],
});

----------------------------------------

TITLE: MikroORM with Express Setup
DESCRIPTION: Complete setup example for integrating MikroORM with AdminJS using Express framework, including database initialization and router configuration.

LANGUAGE: typescript
CODE:
import AdminJS from 'adminjs';
import { Database, Resource } from '@adminjs/mikroorm';
import AdminJSExpress from '@adminjs/express';
import { MikroORM } from '@mikro-orm/postgresql';
import { validate } from 'class-validator'; // optional

const PORT = process.env.PORT ?? 3000;

const run = async () => {
  /* Initialize MikroORM like you would do normally, you can also import your MikroORM instance from a separate file */
  const orm = await MikroORM.init({
    entities: [User, Car, Seller], // use your own entities
    dbName: process.env.DATABASE_NAME,
    clientUrl: process.env.DATABASE_URL,
  });

  /* Optional: if you're using class-validator, assign it to Resource */
  Resource.validate = validate;
  /* Tell AdminJS which adapter to use */
  AdminJS.registerAdapter({ Database, Resource });

  const app = express();

  /* Create AdminJS instance */
  const admin = new AdminJS({
    databases: [orm],
  });

  const router = AdminJSExpress.buildRouter(admin);

  app.use(admin.options.rootPath, router);

  app.listen(PORT, () => {
    console.log(`App listening at http://localhost:${PORT}`);
  });
}

run();

----------------------------------------

TITLE: MikroORM with Express Setup
DESCRIPTION: Complete setup example for integrating MikroORM with AdminJS using Express framework, including database initialization and router configuration.

LANGUAGE: typescript
CODE:
import AdminJS from 'adminjs';
import { Database, Resource } from '@adminjs/mikroorm';
import AdminJSExpress from '@adminjs/express';
import { MikroORM } from '@mikro-orm/postgresql';
import { validate } from 'class-validator'; // optional

const PORT = process.env.PORT ?? 3000;

const run = async () => {
  /* Initialize MikroORM like you would do normally, you can also import your MikroORM instance from a separate file */
  const orm = await MikroORM.init({
    entities: [User, Car, Seller], // use your own entities
    dbName: process.env.DATABASE_NAME,
    clientUrl: process.env.DATABASE_URL,
  });

  /* Optional: if you're using class-validator, assign it to Resource */
  Resource.validate = validate;
  /* Tell AdminJS which adapter to use */
  AdminJS.registerAdapter({ Database, Resource });

  const app = express();

  /* Create AdminJS instance */
  const admin = new AdminJS({
    databases: [orm],
  });

  const router = AdminJSExpress.buildRouter(admin);

  app.use(admin.options.rootPath, router);

  app.listen(PORT, () => {
    console.log(`App listening at http://localhost:${PORT}`);
  });
}

run();

----------------------------------------

TITLE: Article Entity with Reference Implementation
DESCRIPTION: Shows how to implement an Article entity with type-safe reference handling using the Reference wrapper.

LANGUAGE: typescript
CODE:
import { Entity, Ref, ManyToOne, PrimaryKey, Reference } from '@mikro-orm/core';

@Entity()
export class Article {

  @PrimaryKey()
  id!: number;

  // This guide is using `ts-morph` metadata provider, so this is enough.
  @ManyToOne()
  author: Ref<User>;

  constructor(author: User) {
    this.author = ref(author);
  }

}

----------------------------------------

TITLE: Configuring Orphan Removal in MikroORM Entity Relationships
DESCRIPTION: This example shows how to configure orphan removal for OneToMany relationships in MikroORM. It demonstrates the usage of the orphanRemoval flag.

LANGUAGE: typescript
CODE:
@Entity()
export class Author {

  @OneToMany({ entity: () => Book, mappedBy: 'author', orphanRemoval: true })
  books = new Collection<Book>(this);

}

----------------------------------------

TITLE: MongoDB Entity Schema Example
DESCRIPTION: Demonstrates how to define an entity schema for MongoDB with ObjectId and string id fields

LANGUAGE: typescript
CODE:
export class BookTag {
  _id!: ObjectId;
  id!: string;
  name: string;
  books = new Collection<Book>(this);

  constructor(name: string) {
    this.name = name;
  }
}

export const schema = new EntitySchema<BookTag>({
  class: BookTag,
  properties: {
    _id: { type: 'ObjectId', primary: true },
    id: { type: 'string', serializedPrimaryKey: true },
    name: { type: 'string' },
    books: { kind: 'm:n', entity: () => Book, mappedBy: book => book.tags },
  },
});

----------------------------------------

TITLE: Creating Custom SchemaHelper for MikroORM
DESCRIPTION: This snippet shows how to implement a custom SchemaHelper class by extending the base SchemaHelper. It includes methods for defining schema-related operations and database-specific syntax.

LANGUAGE: typescript
CODE:
import { SchemaHelper } from '@mikro-orm/core';

export class MyCustomSchemaHelper extends SchemaHelper {

  // here you can override default settings
  getIdentifierQuoteCharacter(): string;
  getSchemaBeginning(): string;
  getSchemaEnd(): string;
  getSchemaTableEnd(): string;
  getAutoIncrementStatement(meta: EntityMetadata): string;
  getPrimaryKeySubtype(meta: EntityMetadata): string;
  getTypeDefinition(prop: EntityProperty, types?: Record<string, string>, lengths?: Record<string, number>): string;
  getUnsignedSuffix(prop: EntityProperty): string;
  supportsSchemaConstraints(): boolean;
  supportsSchemaMultiAlter(): boolean;
  supportsSequences(): boolean;
  quoteIdentifier(field: string): string;
  dropTable(meta: EntityMetadata): string;
  indexForeignKeys(): boolean;

}

----------------------------------------

TITLE: Optimistic Locking with Integer Version in MikroORM
DESCRIPTION: Demonstrates how to implement optimistic locking using an integer version field in an entity class.

LANGUAGE: typescript
CODE:
export class User {
  // ...
  @Property({ version: true })
  version!: number;
  // ...
}

----------------------------------------

TITLE: Generic Base Entity with OptionalProps
DESCRIPTION: Shows how to implement OptionalProps in a base entity class using generics for extensibility.

LANGUAGE: typescript
CODE:
@Entity()
class MyBaseEntity<Entity extends object, Optional extends keyof Entity = never> {

  [OptionalProps]?: 'foo' | 'bar' | Optional;

  @PrimaryKey()
  id!: number;

  @Property({ default: 1 })
  foo: number = 1;

  @Property({ default: 2 })
  bar: number = 2;

}

@Entity()
class User extends MyBaseEntity<User, 'baz'> {

  @Property({ default: 3 })
  baz: number = 3;

}

----------------------------------------

TITLE: Overriding Loading Strategy in Query
DESCRIPTION: Example showing how to override the default loading strategy to select-in when querying entities.

LANGUAGE: typescript
CODE:
const author = await orm.em.findOne(Author, 1, {
  populate: ['books'],
  strategy: 'select-in',
});

----------------------------------------

TITLE: Setting Up MongoDB Replica Set
DESCRIPTION: Command to create a MongoDB replica set using run-rs for transaction support.

LANGUAGE: sh
CODE:
# first create replica set
$ run-rs -v 4.2.3

----------------------------------------

TITLE: Creating Entity Instances in TypeScript
DESCRIPTION: Examples of creating entity instances using both direct constructor and EntityManager.create() method.

LANGUAGE: typescript
CODE:
const author = new Author();
const book = new Book('Foo', author);

LANGUAGE: typescript
CODE:
const author = new Author();
const book = em.create(Book, { title: 'Foo', author, foo: 123 });

----------------------------------------

TITLE: Generated SQL for JSON Property Index in PostgreSQL
DESCRIPTION: Shows the SQL query generated by MikroORM to create an index on a JSON property in PostgreSQL. The query uses the '->' operator to access the JSON field.

LANGUAGE: sql
CODE:
create index "book_meta_data_foo_index" on "book" (("meta_data"->>'foo'));

----------------------------------------

TITLE: Querying JSON Object Properties in TypeScript with MikroORM
DESCRIPTION: This snippet shows how to query JSON object properties using MikroORM's EntityManager. It demonstrates querying nested JSON properties with various data types.

LANGUAGE: typescript
CODE:
const b = await em.findOne(Book, {
  meta: {
    valid: true,
    nested: {
      foo: '123',
      bar: 321,
      deep: {
        baz: 59,
        qux: false,
      },
    },
  },
});

----------------------------------------

TITLE: Configuring Global Result Cache Settings in MikroORM (TypeScript)
DESCRIPTION: Illustrates how to set up global result cache settings when initializing MikroORM. This includes specifying the cache adapter, default expiration time, and additional options.

LANGUAGE: typescript
CODE:
const orm = await MikroORM.init({
  resultCache: {
    adapter: MemoryCacheAdapter,
    expiration: 1000, // 1s
    options: {},
  },
  // ...
});

----------------------------------------

TITLE: Generating MikroORM Cache Bundle
DESCRIPTION: CLI command to generate a production cache bundle into a single JSON file.

LANGUAGE: bash
CODE:
npx mikro-orm cache:generate --combined

----------------------------------------

TITLE: Defining SQL Entity with Numeric Primary Key
DESCRIPTION: Example of defining an entity class for SQL databases using a numeric primary key

LANGUAGE: typescript
CODE:
@Entity()
export class SqlBook {

  @PrimaryKey()
  id: number;

}

----------------------------------------

TITLE: Configuring Population Order By Clause
DESCRIPTION: Example showing how to configure ordering for populated relationships.

LANGUAGE: typescript
CODE:
await em.find(Author, { ... }, {
  populate: ['books'],
  populateOrderBy: { books: { publishedAt: 'desc' } },
});

----------------------------------------

TITLE: Frontend Optimistic Locking Example
DESCRIPTION: Demonstrates how to handle optimistic locking in frontend code, including version tracking in API requests.

LANGUAGE: typescript
CODE:
const res = await fetch('api.example.com/book/123');
const book = res.json();
console.log(book.version); // prints the current version

// user does some changes and calls the PUT handler
const changes = { title: 'new title' };
await fetch('api.example.com/book/123', {
  method: 'PUT',
  body: {
    ...changes,
    version: book.version,
  },
});

----------------------------------------

TITLE: Creating Project Structure with NPM
DESCRIPTION: Shell commands to create the initial project folder structure and install dependencies

LANGUAGE: bash
CODE:
mkdir blog-api && cd blog-api
mkdir -p src/modules/{user,article,common}

----------------------------------------

TITLE: Defining a Version Field for Optimistic Locking in MikroORM (TypeScript)
DESCRIPTION: Shows how to define a version field in an entity for optimistic locking. This can be either a number or a Date type.

LANGUAGE: typescript
CODE:
export class User {
  // ...
  @Property({ version: true })
  version!: number;
  // ...
}

----------------------------------------

TITLE: API Implementation with Optimistic Locking
DESCRIPTION: Shows implementation of API endpoints with optimistic locking for both GET and PUT operations.

LANGUAGE: typescript
CODE:
// GET /book/:id
async findOne(req, res) {
  const book = await this.em.findOne(Book, +req.query.id);
  res.json(book);
}

// PUT /book/:id
async update(req, res) {
  const book = await this.em.findOne(Book, +req.query.id, { lockMode: LockMode.OPTIMISTIC, lockVersion: req.body.version });
  wrap(book).assign(req.body);
  await this.em.flush();

  res.json(book);
}

----------------------------------------

TITLE: Defining Entity with UUID as Primary Key
DESCRIPTION: Example of defining an entity using UUID as the primary key

LANGUAGE: typescript
CODE:
import { v4 } from 'uuid';

@Entity()
export class Book {

  @PrimaryKey()
  uuid = v4();

  @Property()
  title!: string;

  @ManyToOne(() => Author)
  author!: Author;

}

----------------------------------------

TITLE: Filtering and Ordering Collection Items in MikroORM
DESCRIPTION: This snippet demonstrates how to filter and order collection items when initializing them using the init() method in MikroORM. It shows how to use the where and orderBy options.

LANGUAGE: typescript
CODE:
await book.tags.init({
  where: { active: true },
  orderBy: { name: QueryOrder.DESC },
});

----------------------------------------

TITLE: Generated SQL Schema for Mapped Superclass
DESCRIPTION: Shows the resulting SQL DDL schema generated for the mapped superclass implementation, demonstrating how all properties are consolidated into a single table.

LANGUAGE: sql
CODE:
create table `employee` (
  `id` int unsigned not null auto_increment primary key,
  `name` varchar(255) not null, `mapped1` integer not null,
  `mapped2` varchar(255) not null,
  `toothbrush_id` integer not null
);

----------------------------------------

TITLE: Defining Formulas
DESCRIPTION: Examples of defining formula properties in entities using different approaches.

LANGUAGE: typescript
CODE:
// reflect-metadata and ts-morph
@Formula('obj_length * obj_height * obj_width')
objectVolume?: number;

@Formula(alias => `${alias}.obj_length * ${alias}.obj_height * ${alias}.obj_width`)
objectVolume?: number;

// EntitySchema
properties: {
  objectVolume: { formula: 'obj_length * obj_height * obj_width' },
  objectVolume: { formula: alias => `${alias}.obj_length * ${alias}.obj_height * ${alias}.obj_width` },
},

----------------------------------------

TITLE: Implementing an onFlush EventSubscriber in TypeScript
DESCRIPTION: Example of an EventSubscriber that uses the onFlush event to automatically create and link a new FooBaz entity when a FooBar entity is created.

LANGUAGE: typescript
CODE:
export class FooBarSubscriber implements EventSubscriber {

  async onFlush(args: FlushEventArgs): Promise<void> {
    const changeSets = args.uow.getChangeSets();
    const cs = changeSets.find(cs => cs.type === ChangeSetType.CREATE && cs.entity instanceof FooBar);

    if (cs) {
      const baz = new FooBaz();
      baz.name = 'dynamic';
      cs.entity.baz = baz;
      args.uow.computeChangeSet(baz);
      args.uow.recomputeSingleChangeSet(cs.entity);
    }
  }

}

const bar = new FooBar();
bar.name = 'bar';
await em.persist(bar).flush();

----------------------------------------

TITLE: Hidden Properties Implementation
DESCRIPTION: Demonstration of marking properties as hidden using decorators and HiddenProps symbol.

LANGUAGE: typescript
CODE:
@Entity()
class Book {

  // we use the `HiddenProps` symbol to define hidden properties on type level
  [HiddenProps]?: 'hiddenField' | 'otherHiddenField';

  @Property({ hidden: true })
  hiddenField = Date.now();

  @Property({ hidden: true, nullable: true })
  otherHiddenField?: string;

}

----------------------------------------

TITLE: Implementing QueryBuilder Operations
DESCRIPTION: Advanced query building for article listing with joins and subqueries

LANGUAGE: typescript
CODE:
listArticlesQuery() {
  const totalComments = this.em.createQueryBuilder(Comment)
    .count()
    .where({ article: sql.ref('a.id') })
    .as('totalComments');

  return this.createQueryBuilder('a')
    .select(['slug', 'title', 'description', 'author'])
    .addSelect(sql.ref('u.full_name').as('authorName'))
    .join('author', 'u')
    .addSelect([totalComments]);
}

----------------------------------------

TITLE: Repository Registration with Entity Decorator
DESCRIPTION: Demonstrates how to register a custom repository using the @Entity decorator with the repository property.

LANGUAGE: typescript
CODE:
@Entity({ repository: () => CustomAuthorRepository })
export class Author {
  // ...
}

----------------------------------------

TITLE: Installing AdminJS Core and MikroORM Adapter
DESCRIPTION: Commands for installing AdminJS core package and MikroORM adapter along with necessary database drivers.

LANGUAGE: bash
CODE:
$ yarn add adminjs
$ yarn add @adminjs/mikroorm
# A MikroORM driver and core package, choose the one which suits you:
$ yarn add @mikro-orm/core @mikro-orm/mongodb     # for mongo
$ yarn add @mikro-orm/core @mikro-orm/mysql       # for mysql
$ yarn add @mikro-orm/core @mikro-orm/mariadb     # for mariadb
$ yarn add @mikro-orm/core @mikro-orm/postgresql  # for postgresql
$ yarn add @mikro-orm/core @mikro-orm/sqlite      # for sqlite

----------------------------------------

TITLE: Article Entity with Reference Wrapper
DESCRIPTION: Implementation of Article entity using Reference wrapper for type-safe relation handling.

LANGUAGE: typescript
CODE:
import { Entity, Ref, ManyToOne, PrimaryKey, Reference } from '@mikro-orm/core';

@Entity()
export class Article {

  @PrimaryKey()
  id!: number;

  @ManyToOne()
  author: Ref<User>;

  constructor(author: User) {
    this.author = ref(author);
  }

}

----------------------------------------

TITLE: Lifecycle Hooks Implementation
DESCRIPTION: Shows implementation of various lifecycle hooks like @OnInit, @BeforeCreate, @AfterCreate etc. for entity lifecycle management.

LANGUAGE: typescript
CODE:
@OnInit()
doStuffOnInit() {
  this.fullName = `${this.firstName} - ${this.lastName}`;
}

@BeforeCreate()
async doStuffBeforeCreate() {
  // ...
}

----------------------------------------

TITLE: MySQL Table Creation with Underscore Naming Strategy
DESCRIPTION: Example of how the UnderscoreNamingStrategy generates SQL table structure with lowercase and underscore-separated column names.

LANGUAGE: sql
CODE:
CREATE TABLE `author` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `created_at` datetime(3) DEFAULT NULL,
  `updated_at` datetime(3) DEFAULT NULL,
  `terms_accepted` tinyint(1) DEFAULT NULL,
  `name` varchar(255) DEFAULT NULL,
  `email` varchar(255) DEFAULT NULL,
  `born` datetime DEFAULT NULL,
  `favourite_book_id` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

----------------------------------------

TITLE: Creating Entity Instances with EntityManager in TypeScript
DESCRIPTION: This snippet shows how to create new entity instances using the EntityManager's create method when working with EntitySchema.

LANGUAGE: typescript
CODE:
const author = em.create<Author>('Author', { name: 'name', email: 'email' });
await em.flush();

----------------------------------------

TITLE: Mapping Query Results to Entity Instances in MikroORM
DESCRIPTION: Shows how to get entity instances from QueryBuilder results using 'getResult()' and 'getSingleResult()' methods in MikroORM.

LANGUAGE: typescript
CODE:
const book = await em.createQueryBuilder(Book).select('*').where({ id: 1 }).getSingleResult();
console.log(book instanceof Book); // true
const books = await em.createQueryBuilder(Book).select('*').getResult();
console.log(books[0] instanceof Book); // true

----------------------------------------

TITLE: Configuring TypeScript for Correct Entity Property Initialization
DESCRIPTION: This JSON snippet shows the TypeScript configuration needed to prevent unexpected behavior with entity property initialization in MikroORM.

LANGUAGE: json
CODE:
{
  "compilerOptions": {
    "useDefineForClassFields": false
  }
}

----------------------------------------

TITLE: Defining MongoDB Virtual Entity with Aggregation
DESCRIPTION: Implementation of a virtual entity using MongoDB aggregation pipeline. Demonstrates how to create virtual entities in MongoDB with support for filtering, sorting, and pagination.

LANGUAGE: typescript
CODE:
@Entity({
  expression: (em: EntityManager, where, options) => {
    const $sort = { ...options.orderBy } as Dictionary;
    $sort._id = 1;
    const pipeline: Dictionary[] = [
      { $project: { _id: 0, title: 1, author: 1 } },
      { $sort },
      { $match: where ?? {} },
      { $lookup: { from: 'author', localField: 'author', foreignField: '_id', as: 'author', pipeline: [{ $project: { name: 1 } }] } },
      { $unwind: '$author' },
      { $set: { authorName: '$author.name' } },
      { $unset: ['author'] },
    ];

    if (options.offset != null) {
      pipeline.push({ $skip: options.offset });
    }

    if (options.limit != null) {
      pipeline.push({ $limit: options.limit });
    }

    return em.aggregate(Book, pipeline);
  },
})
export class BookWithAuthor {

  @Property()
  title!: string;

  @Property()
  authorName!: string;

}

----------------------------------------

TITLE: Defining Embeddable Entities in TypeScript with MikroORM
DESCRIPTION: This snippet demonstrates how to define an embeddable 'Address' class and embed it within a 'User' entity using MikroORM decorators.

LANGUAGE: typescript
CODE:
@Entity()
export class User {

  @Embedded()
  address!: Address;

}

@Embeddable()
export class Address {

  @Property()
  street!: string;

  @Property()
  postalCode!: string;

  @Property()
  city!: string;

  @Property()
  country!: string;

}

----------------------------------------

TITLE: Entity Assignment Using wrap() Helper in MikroORM
DESCRIPTION: Shows how to use the wrap().assign() method to update entity properties including references

LANGUAGE: typescript
CODE:
import { wrap } from '@mikro-orm/core';

wrap(book).assign({
  title: 'Better Book 1',
  author: '...id...',
});
console.log(book.title); // 'Better Book 1'
console.log(book.author); // instance of Author with id: '...id...'
console.log(book.author.id); // '...id...'

----------------------------------------

TITLE: Explicit Joining in QueryBuilder with MikroORM
DESCRIPTION: This example shows how to manually specify joins using the join() and leftJoin() methods in QueryBuilder. It demonstrates creating a complex query with multiple joins and conditions.

LANGUAGE: typescript
CODE:
const qb = orm.em.createQueryBuilder(BookTag, 't');
qb.select(['b.uuid', 'b.*', 't.*'], true)
  .join('t.books', 'b')
  .where({ 'b.title': 'test 123' })
  .limit(2, 1);

console.log(qb.getQuery());
// select distinct `b`.`uuid_pk`, `b`.*, `t`.*, `e1`.`book_tag_id`, `e1`.`book_uuid_pk` from `book_tag` as `t`
// join `book_to_book_tag` as `e1` ON `t`.`id` = `e1`.`book_tag_id`
// join `book` as `b` ON `e1`.`book_uuid_pk` = `b`.`uuid_pk`
// where `b`.`title` = ?
// limit ? offset ?

----------------------------------------

TITLE: Defining MikroORM Entity with Serialization Options
DESCRIPTION: Example of a MikroORM entity with serialization options for controlling data exposure and transformation.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {
  @Property({ hidden: true })   // --> Equivalent of class-transformer's `@Exclude`
  hiddenField: number = Date.now();

  @Property({ persist: false }) // --> Will only exist in memory (and will be serialized). Similar to class-transformer's `@Expose()`
  count?: number;

  @ManyToOne({ serializer: value => value.name, serializedName: 'authorName' })   // Equivalent of class-transformer's `@Transform()`
  author: Author;
}

----------------------------------------

TITLE: Creating ManyToMany Pivot Table
DESCRIPTION: SQL definition for creating a pivot table to handle ManyToMany relations in MySQL databases. Includes primary key and foreign key columns.

LANGUAGE: sql
CODE:
CREATE TABLE `publisher_to_test` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `publisher_id` int(11) DEFAULT NULL,
  `test_id` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

----------------------------------------

TITLE: Using ref() Helper with Reference Wrapper
DESCRIPTION: Shows how to use the ref() helper with Reference wrapper for safer entity references.

LANGUAGE: typescript
CODE:
@ManyToOne({ entity: () => Author, ref: true })
author: Ref<Author>;

constructor(dto: { title: string; author: number }) {
  this.title = dto.title;
  this.author = ref(Author, dto.author);
}

----------------------------------------

TITLE: Using Rel Type for ESM Projects in MikroORM
DESCRIPTION: Shows how to handle circular dependencies in ESM projects using the Rel mapped type to avoid initialization issues.

LANGUAGE: typescript
CODE:
import { Rel } from '@mikro-orm/core';

@Entity()
export class Book {

  @ManyToOne(() => Author)
  author!: Rel<Author>;

}

----------------------------------------

TITLE: Creating a Custom Repository in MikroORM with TypeScript
DESCRIPTION: Shows how to create a custom repository by extending EntityRepository<T> and using the @Repository decorator. It also mentions the alternative of registering the repository in the @Entity decorator.

LANGUAGE: typescript
CODE:
import { EntityRepository } from '@mikro-orm/mysql'; // or any other driver package

@Repository(Author)
export class CustomAuthorRepository extends EntityRepository<Author> {

  // your custom methods...
  public findAndUpdate(...) {
    // ...
  }

}

----------------------------------------

TITLE: Enabling Debug Mode in MikroORM
DESCRIPTION: Demonstrates how to enable basic debug logging in MikroORM initialization.

LANGUAGE: typescript
CODE:
return MikroORM.init({
  debug: true,
});

----------------------------------------

TITLE: Setting up MikroORM with AdminJS in Express
DESCRIPTION: TypeScript code for configuring MikroORM with AdminJS in an Express application. Includes database initialization, AdminJS setup, and server configuration.

LANGUAGE: typescript
CODE:
import AdminJS from 'adminjs';
import { Database, Resource } from '@adminjs/mikroorm';
import AdminJSExpress from '@adminjs/express';
import { MikroORM } from '@mikro-orm/postgresql';
import { validate } from 'class-validator'; // optional

const PORT = process.env.PORT ?? 3000;

const run = async () => {
  /* Initialize MikroORM like you would do normally, you can also import your MikroORM instance from a separate file */
  const orm = await MikroORM.init({
    entities: [User, Car, Seller], // use your own entities
    dbName: process.env.DATABASE_NAME,
    clientUrl: process.env.DATABASE_URL,
  });

  /* Optional: if you're using class-validator, assign it to Resource */
  Resource.validate = validate;
  /* Tell AdminJS which adapter to use */
  AdminJS.registerAdapter({ Database, Resource });

  const app = express();

  /* Create AdminJS instance */
  const admin = new AdminJS({
    databases: [orm],
  });

  const router = AdminJSExpress.buildRouter(admin);

  app.use(admin.options.rootPath, router);

  app.listen(PORT, () => {
    console.log(`App listening at http://localhost:${PORT}`);
  });
}

run();

----------------------------------------

TITLE: Configuring Populate Behavior in MikroORM v5
DESCRIPTION: Demonstration of how to configure the populate behavior in MikroORM v5 using the new populateWhere option. This example shows how to revert to the old behavior of inferring the where condition.

LANGUAGE: typescript
CODE:
const a = await em.find(Author, { books: [1, 2, 3] }, {
  populate: ['books'],
  populateWhere: PopulateHint.INFER,
});

----------------------------------------

TITLE: SQL EntityManager Query Builder Usage
DESCRIPTION: Example demonstrating how to import and use SqlEntityManager for creating query builders in SQL drivers.

LANGUAGE: typescript
CODE:
import { EntityManager } from '@mikro-orm/mysql'; // or any other SQL driver package

const em: EntityManager;
const qb = await em.createQueryBuilder(...);

----------------------------------------

TITLE: Configuring MikroORM CLI in package.json
DESCRIPTION: Example of configuring MikroORM CLI options in package.json, including TypeScript support and config file paths.

LANGUAGE: json
CODE:
{
  "name": "your-app",
  "dependencies": { ... },
  "mikro-orm": {
    "useTsNode": true,
    "configPaths": [
      "./src/mikro-orm.config.ts",
      "./dist/mikro-orm.config.js"
    ]
  }
}

----------------------------------------

TITLE: Setting Custom Cache Directory in MikroORM (TypeScript)
DESCRIPTION: This snippet shows how to set a custom directory for storing the metadata cache in MikroORM. It uses the 'options.cacheDir' property of the 'cache' option during initialization.

LANGUAGE: typescript
CODE:
await MikroORM.init({
  cache: { options: { cacheDir: '...' } },
  // ...
});

----------------------------------------

TITLE: Creating Basic Migration Class in TypeScript
DESCRIPTION: Example of creating a basic migration class that extends the Migration abstract class. Shows implementation of the up() method for executing SQL commands.

LANGUAGE: typescript
CODE:
import { Migration } from '@mikro-orm/migrations';

export class Migration20191019195930 extends Migration {

  async up(): Promise<void> {
    this.addSql('select 1 + 1');
  }

}

----------------------------------------

TITLE: Implementing Concurrency Checks
DESCRIPTION: Demonstrates how to implement concurrency checks using property decorators and primary keys.

LANGUAGE: typescript
CODE:
@Entity()
export class ConcurrencyCheckUser {
  @PrimaryKey({ length: 100 })
  firstName: string;

  @PrimaryKey({ length: 100 })
  lastName: string;

  @Property({ concurrencyCheck: true })
  age: number;

  @Property({ nullable: true })
  other?: string;
}

----------------------------------------

TITLE: Registering Global Filters in MikroORM
DESCRIPTION: Shows how to register global filters using the EntityManager API. Demonstrates entity-bound and global filters, as well as setting filter parameters.

LANGUAGE: typescript
CODE:
// bound to entity, enabled by default
em.addFilter('writtenBy', args => ({ author: args.id }), Book);

// global, enabled by default, for all entities
em.addFilter('tenant', args => { ... });

// global, enabled by default, for only specified entities
em.addFilter('tenant', args => { ... }, [Author, Book]);
...

// set params (probably in some middleware)
em.setFilterParams('tenant', { tenantId: 123 });
em.setFilterParams('writtenBy', { id: 321 });

----------------------------------------

TITLE: Configuring MikroORM EventSubscriber
DESCRIPTION: Example of manually registering an EventSubscriber in MikroORM configuration.

LANGUAGE: typescript
CODE:
MikroORM.init({
  subscribers: [new AuthorSubscriber()],
});

----------------------------------------

TITLE: Registering Global Filters in MikroORM
DESCRIPTION: Shows how to register global filters using the EntityManager API. Demonstrates entity-bound and global filters, as well as setting filter parameters.

LANGUAGE: typescript
CODE:
// bound to entity, enabled by default
em.addFilter('writtenBy', args => ({ author: args.id }), Book);

// global, enabled by default, for all entities
em.addFilter('tenant', args => { ... });

// global, enabled by default, for only specified entities
em.addFilter('tenant', args => { ... }, [Author, Book]);
...

// set params (probably in some middleware)
em.setFilterParams('tenant', { tenantId: 123 });
em.setFilterParams('writtenBy', { id: 321 });

----------------------------------------

TITLE: Mapping Collection Items with indexBy() in TypeScript
DESCRIPTION: Shows how to use the indexBy() method to convert a collection to a key-value dictionary.

LANGUAGE: typescript
CODE:
// given `user.settings` is `Collection<Option>`
const settingsDictionary = user.settings.indexBy('key');
// `settingsDictionary` is `Record<string, Option>`

const settingsDictionary = user.settings.indexBy('key', 'value');
// `settingsDictionary` is `Record<string, string>`

----------------------------------------

TITLE: Custom Entity Serialization Implementation
DESCRIPTION: Example of implementing custom toJSON method in an entity class with property stripping functionality.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  // ...

  toJSON(strict = true, strip = ['id', 'email'], ...args: any[]): { [p: string]: any } {
    const o = wrap(this, true).toObject(...args); // do not forget to pass rest params here

    if (strict) {
      strip.forEach(k => delete o[k]);
    }

    return o;
  }

}

----------------------------------------

TITLE: Basic Query Builder Usage
DESCRIPTION: Demonstrates basic usage of QueryBuilder to construct and execute an update query with parameters

LANGUAGE: typescript
CODE:
// since v5 we can also use `em.qb()` shortcut
const qb = em.createQueryBuilder(Author);
qb.update({ name: 'test 123', type: PublisherType.GLOBAL }).where({ id: 123, type: PublisherType.LOCAL });

console.log(qb.getQuery());
// update `publisher2` set `name` = ?, `type` = ? where `id` = ? and `type` = ?

console.log(qb.getParams());
// ['test 123', PublisherType.GLOBAL, 123, PublisherType.LOCAL]

// run the query
const res1 = await qb.execute();

----------------------------------------

TITLE: Mapping Collection Items in MikroORM
DESCRIPTION: This snippet shows how to use the indexBy method to convert a collection to a simple key-value dictionary in MikroORM. It demonstrates mapping to both entity instances and property values.

LANGUAGE: typescript
CODE:
// given `user.settings` is `Collection<Option>`
const settingsDictionary = user.settings.indexBy('key');
// `settingsDictionary` is `Record<string, Option>`

const settingsDictionary = user.settings.indexBy('key', 'value');
// `settingsDictionary` is `Record<string, string>`

----------------------------------------

TITLE: Implementing onFlush Event with Dynamic Entity Creation in TypeScript
DESCRIPTION: Example of using the onFlush event to dynamically create and link entities. This subscriber creates a new FooBaz entity and links it to a FooBar entity when a new FooBar is being created.

LANGUAGE: typescript
CODE:
export class FooBarSubscriber implements EventSubscriber {

  async onFlush(args: FlushEventArgs): Promise<void> {
    const changeSets = args.uow.getChangeSets();
    const cs = changeSets.find(cs => cs.type === ChangeSetType.CREATE && cs.entity instanceof FooBar);

    if (cs) {
      const baz = new FooBaz();
      baz.name = 'dynamic';
      cs.entity.baz = baz;
      args.uow.computeChangeSet(baz);
      args.uow.recomputeSingleChangeSet(cs.entity);
    }
  }

}

const bar = new FooBar();
bar.name = 'bar';
await em.persistAndFlush(bar);

----------------------------------------

TITLE: Simplified Single Field AND Condition in MikroORM
DESCRIPTION: Shows a simplified way to write AND conditions for a single field by combining multiple operators in one object.

LANGUAGE: typescript
CODE:
const res = await orm.em.find(Author, {
  id: {
    $in: [1, 2, 7],
    $nin: [3, 4],
    $gt: 5,
    $lt: 10,
    $gte: 7,
    $lte: 8,
    $ne: 9,
  },
});

----------------------------------------

TITLE: Defining a ManyToOne Relation in TypeScript
DESCRIPTION: Example of defining a ManyToOne relation to an Author entity using TypeScript decorators in MikroORM.

LANGUAGE: typescript
CODE:
@ManyToOne(() => Author)
author!: Author; // the value is always instance of the `Author` entity

----------------------------------------

TITLE: Defining a ManyToOne Relation in TypeScript
DESCRIPTION: Example of defining a ManyToOne relation to an Author entity using TypeScript decorators in MikroORM.

LANGUAGE: typescript
CODE:
@ManyToOne(() => Author)
author!: Author; // the value is always instance of the `Author` entity

----------------------------------------

TITLE: MongoDB Entity Schema Example
DESCRIPTION: Shows how to define an entity schema specifically for MongoDB, including ObjectId handling and relationships.

LANGUAGE: typescript
CODE:
export class BookTag {
  _id!: ObjectId;
  id!: string;
  name: string;
  books = new Collection<Book>(this);

  constructor(name: string) {
    this.name = name;
  }
}

export const schema = new EntitySchema<BookTag>({
  class: BookTag,
  properties: {
    _id: { type: 'ObjectId', primary: true },
    id: { type: 'string', serializedPrimaryKey: true },
    name: { type: 'string' },
    books: { kind: 'm:n', entity: () => Book, mappedBy: book => book.tags },
  },
});

----------------------------------------

TITLE: SQL Table Creation with UnderscoreNamingStrategy in MySQL
DESCRIPTION: Shows an example of how the UnderscoreNamingStrategy (default for SQL drivers) translates entity properties into database table structure using lowercase and underscores.

LANGUAGE: sql
CODE:
CREATE TABLE `author` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `created_at` datetime(3) DEFAULT NULL,
  `updated_at` datetime(3) DEFAULT NULL,
  `terms_accepted` tinyint(1) DEFAULT NULL,
  `name` varchar(255) DEFAULT NULL,
  `email` varchar(255) DEFAULT NULL,
  `born` datetime DEFAULT NULL,
  `favourite_book_id` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

----------------------------------------

TITLE: Configuring MikroORM in NestJS AppModule
DESCRIPTION: Example of importing and configuring MikroOrmModule in the root AppModule of a NestJS application.

LANGUAGE: typescript
CODE:
@Module({
  imports: [
    MikroOrmModule.forRoot({
      entities: ['./dist/entities'],
      entitiesTs: ['./src/entities'],
      dbName: 'my-db-name.sqlite3',
    }),
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}

----------------------------------------

TITLE: Defining Custom Entity Class with EntitySchema in TypeScript
DESCRIPTION: This snippet shows how to use a custom class for entity instances with EntitySchema. It defines an Author class with various properties and relationships, then creates the corresponding schema.

LANGUAGE: typescript
CODE:
export class Author extends BaseEntity {
  name: string;
  email: string;
  age?: number;
  termsAccepted?: boolean;
  identities?: string[];
  born?: Date;
  books = new Collection<Book>(this);
  favouriteBook?: Book;
  version?: number;

  constructor(name: string, email: string) {
    this.name = name;
    this.email = email;
  }
}

export const schema = new EntitySchema<Author, BaseEntity>({
  class: Author,
  properties: {
    name: { type: 'string' },
    email: { type: 'string', unique: true },
    age: { type: 'number', nullable: true },
    termsAccepted: { type: 'boolean', default: 0, onCreate: () => false },
    identities: { type: 'string[]', nullable: true },
    born: { type: DateType, nullable: true, length: 3 },
    books: { reference: '1:m', entity: () => 'Book', mappedBy: book => book.author },
    favouriteBook: { reference: 'm:1', type: 'Book' },
    version: { type: 'number', persist: false },
  },
});

----------------------------------------

TITLE: Creating Custom Repository Class in TypeScript
DESCRIPTION: Shows how to create a custom repository by extending EntityRepository<T> class with custom methods.

LANGUAGE: typescript
CODE:
export class CustomAuthorRepository extends EntityRepository<Author> {

  // your custom methods...
  public findAndUpdate(...) {
    // ...
  }

}

----------------------------------------

TITLE: Basic Query Builder Usage
DESCRIPTION: Demonstrates basic usage of QueryBuilder to construct and execute an update query with parameters

LANGUAGE: typescript
CODE:
// since v5 we can also use `em.qb()` shortcut
const qb = em.createQueryBuilder(Author);
qb.update({ name: 'test 123', type: PublisherType.GLOBAL }).where({ id: 123, type: PublisherType.LOCAL });

console.log(qb.getQuery());
// update `publisher2` set `name` = ?, `type` = ? where `id` = ? and `type` = ?

console.log(qb.getParams());
// ['test 123', PublisherType.GLOBAL, 123, PublisherType.LOCAL]

// run the query
const res1 = await qb.execute();

----------------------------------------

TITLE: Working with Entity References in MikroORM
DESCRIPTION: Demonstrates how to use entity references in MikroORM, which represent entities with only their primary key available without querying the database.

LANGUAGE: typescript
CODE:
const userRef = em.getReference(User, 1);
console.log(userRef);

LANGUAGE: typescript
CODE:
// setting relation properties
author.favouriteBook = em.getReference(Book, 1);

// removing entity by reference
em.remove(em.getReference(Book, 2));

// adding entity to collection by reference
author.books.add(em.getReference(Book, 3));

----------------------------------------

TITLE: Using MikroORM CLI for Seeding
DESCRIPTION: Shows various CLI commands for running seeders, including options for specifying seeder classes and combining with migration or schema commands.

LANGUAGE: shell
CODE:
npx mikro-orm seeder:run

npx mikro-orm seeder:run --class=BookSeeder

npx mikro-orm migration:fresh --seed    # will drop the database, run all migrations and the DatabaseSeeder class

npx mikro-orm schema:fresh --seed       # will recreate the database and run the DatabaseSeeder class

----------------------------------------

TITLE: Configuring Populate Behavior in MikroORM (TypeScript)
DESCRIPTION: Shows how to configure the 'populateWhere' option globally or per query to control whether populated collections respect the outer filter or fetch all possible members.

LANGUAGE: typescript
CODE:
const orm = await MikroORM.init({
    populateWhere: PopulateHint.INFER,
});

LANGUAGE: typescript
CODE:
const books = await em.find(Book, { tags: { name: 'Fiction' } }, {
  populate: ['tags'],
  populateWhere: PopulateHint.INFER,
});

----------------------------------------

TITLE: Using rel() Helper for Entity References in MikroORM (TypeScript)
DESCRIPTION: This snippet demonstrates the use of the rel() helper to convert primary keys to entity references in constructors. It also shows how to use the Rel<T> type for better type safety.

LANGUAGE: typescript
CODE:
@ManyToOne({ entity: () => Author })
author: Rel<Author>;

constructor(dto: { title: string; author: number }) {
  this.title = dto.title;
  this.author = rel(Author, dto.author);
}

----------------------------------------

TITLE: Configuring Entity Discovery in MikroORM
DESCRIPTION: Examples of configuring entity discovery using directory paths or globbing patterns for both JavaScript and TypeScript entities.

LANGUAGE: typescript
CODE:
const orm = await MikroORM.init({
  entitiesDirs: ['./dist/app/**/entities'],
  // ...
});

LANGUAGE: typescript
CODE:
import globby from 'globby';

const orm = await MikroORM.init({
  entities: await (globby('./dist/app/**/entities/*.js')).map(require),
  // ...
});

----------------------------------------

TITLE: Optional Properties with Default Values
DESCRIPTION: Example of defining optional properties with default values in MikroORM entities.

LANGUAGE: typescript
CODE:
@Property({ default: 1 })
level?: number = 1;

----------------------------------------

TITLE: Using OptionalProps Symbol for Properties with Default Values in MikroORM
DESCRIPTION: This example demonstrates the use of the OptionalProps symbol to mark properties with default values as optional in MikroORM, improving type inference.

LANGUAGE: typescript
CODE:
import { OptionalProps, Entity, PrimaryKey, Property } from '@mikro-orm/core';

@Entity()
class User {

  [OptionalProps]?: 'foo' | 'bar' | 'fooBar';

  @PrimaryKey()
  id!: number;

  @Property({ default: 1 })
  foo: number = 1;

  @Property({ default: 2 })
  bar: number = 2;

  @Property({ persist: false })
  get fooBar() {
    return foo + bar;
  }

}

----------------------------------------

TITLE: Initializing MikroORM with SQL Database
DESCRIPTION: Demonstrates how to initialize MikroORM with different SQL database types. Requires appropriate database driver package (mysql2, sqlite, or pg) to be installed.

LANGUAGE: typescript
CODE:
const orm = await MikroORM.init({
  entitiesDirs: ['entities'], // relative to `baseDir`
  dbName: 'my-db-name',
  type: 'mysql', // or 'sqlite' or 'postgresql'
});

----------------------------------------

TITLE: Updating Managed Entities in MikroORM
DESCRIPTION: This code snippet shows how MikroORM automatically detects and persists changes to managed entities without explicit calls to persistLater().

LANGUAGE: typescript
CODE:
const authorRepository = orm.em.getRepository(Author);
const jon = await authorRepository.findOne(1);
jon.email = 'foo@bar.com';
await authorRepository.flush(); // calling orm.em.flush() has same effect

----------------------------------------

TITLE: Configuring Custom Cache Directory in MikroORM
DESCRIPTION: Setting a custom directory for storing metadata cache files instead of the default ./temp folder.

LANGUAGE: typescript
CODE:
await MikroORM.init({
  // defaults to `./temp`
  metadataCache: { options: { cacheDir: '...' } },
  // ...
});

----------------------------------------

TITLE: Property Serializer Configuration
DESCRIPTION: Demonstration of using property serializers to customize how specific properties are serialized.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @ManyToOne({ serializer: value => value.name, serializedName: 'authorName' })
  author: Author;

}

----------------------------------------

TITLE: Destructuring Populated Entity in MikroORM v5
DESCRIPTION: Example of using destructuring to handle the new behavior of em.populate() in MikroORM v5, which always returns an array of entities.

LANGUAGE: typescript
CODE:
const [loadedAuthor] = await em.populate(author, ...);

----------------------------------------

TITLE: Configuring EntityGenerator in MikroORM
DESCRIPTION: TypeScript code to register the EntityGenerator extension in the ORM configuration.

LANGUAGE: typescript
CODE:
import { defineConfig } from '@mikro-orm/postgresql';
import { EntityGenerator } from '@mikro-orm/entity-generator';

export default defineConfig({
  dbName: 'test',
  extensions: [EntityGenerator],
});

----------------------------------------

TITLE: Initializing Fastify App with MikroORM in TypeScript
DESCRIPTION: Sets up a Fastify application with MikroORM, including request context handling and a sample endpoint for fetching articles.

LANGUAGE: TypeScript
CODE:
import { RequestContext } from '@mikro-orm/core';
import { fastify } from 'fastify';
import { initORM } from './db.js';

export async function bootstrap(port = 3001) {
  const db = await initORM();
  const app = fastify();

  app.addHook('onRequest', (request, reply, done) => {
    RequestContext.create(db.em, done);
  });

  app.addHook('onClose', async () => {
    await db.orm.close();
  });

  app.get('/article', async request => {
    const { limit, offset } = request.query as { limit?: number; offset?: number };
    const [items, total] = await db.article.findAndCount({}, {
      limit, offset,
    });

    return { items, total };
  });

  const url = await app.listen({ port });

  return { app, url };
}

----------------------------------------

TITLE: Mapping Raw Results to Entities in MikroORM with TypeScript
DESCRIPTION: This example demonstrates how to map raw query results to entity instances using the EntityManager's map method. It's useful when working with third-party query builders or custom SQL queries.

LANGUAGE: typescript
CODE:
const results = await knex.select('*').from('users').where(knex.raw('id = ?', [id]));
const users = results.map(user => orm.em.map(User, user));

// or use EntityRepository.map()
const repo = orm.em.getRepository(User);
const users = results.map(user => repo.map(user));

----------------------------------------

TITLE: Extended Entity Repository Implementation
DESCRIPTION: Shows how to create a custom base repository that maintains removed EntityRepository methods.

LANGUAGE: typescript
CODE:
import { EntityManager, EntityRepository, AnyEntity } from '@mikro-orm/mysql';

export class ExtendedEntityRepository<T extends object> extends EntityRepository<T> {

  persist(entity: AnyEntity | AnyEntity[]): EntityManager {
    return this.em.persist(entity);
  }

  async persistAndFlush(entity: AnyEntity | AnyEntity[]): Promise<void> {
    await this.em.persistAndFlush(entity);
  }

  remove(entity: AnyEntity): EntityManager {
    return this.em.remove(entity);
  }

  async removeAndFlush(entity: AnyEntity): Promise<void> {
    await this.em.removeAndFlush(entity);
  }

  async flush(): Promise<void> {
    return this.em.flush();
  }

}

----------------------------------------

TITLE: Configuring Multiple ORM Instances in TypeScript
DESCRIPTION: Shows how to configure multiple ORM instances using a single config file. This approach allows for different configurations based on context names, useful for multitenant setups or different database access levels.

LANGUAGE: typescript
CODE:
import { defineConfig } from '@mikro-orm/postgresql';

export default [
  defineConfig({
    contextName: 'default',
    entities: [Author, Book, BookTag],
    dbName: 'my-db-name',
    user: 'app',
    // other credentials and settings
  }),
  defineConfig({
    contextName: 'super',
    entities: [Author, Book, BookTag],
    dbName: 'my-db-name',
    user: 'admin',
    // other credentials and settings
  }),
];

----------------------------------------

TITLE: Creating Entities in Specific Schema
DESCRIPTION: Demonstrates entity creation in a specific schema using QueryBuilder

LANGUAGE: typescript
CODE:
const qb = em.createQueryBuilder(User);
await qb.insert({ email: 'foo@bar.com' }).withSchema('client-123');

----------------------------------------

TITLE: Enabling Pretty Printing for Metadata Cache in MikroORM
DESCRIPTION: This code snippet shows how to enable pretty printing for the cached metadata when initializing MikroORM. It sets the 'pretty' property of the 'metadataCache' option to true.

LANGUAGE: typescript
CODE:
await MikroORM.init({
  metadataCache: { pretty: true },
  // ...
});

----------------------------------------

TITLE: Transactional Wrapper Method in MikroORM
DESCRIPTION: Demonstrates using the transactional wrapper method for more convenient transaction handling with automatic rollback on failure.

LANGUAGE: typescript
CODE:
orm.em.transactional(_em => {
  //... do some work
  const user = new User(...);
  user.name = 'George';
  _em.persistLater(user);
});

----------------------------------------

TITLE: Implicit Transaction Handling
DESCRIPTION: Shows how Unit of Work handles implicit transactions when persisting and updating entities with relationships.

LANGUAGE: typescript
CODE:
const user = await em.findOne(User, 1);
user.email = 'foo@bar.com';
const car = new Car();
user.cars.add(car);

// thanks to bi-directional cascading we only need to persist user entity
// flushing will create a transaction, insert new car and update user with new email
await em.persist(user).flush();

----------------------------------------

TITLE: Defining Nullable Properties in MikroORM
DESCRIPTION: Shows how to make entity properties nullable using the @Property decorator with nullable option.

LANGUAGE: typescript
CODE:
@Property({ nullable: true })
name?: string;

----------------------------------------

TITLE: Defining MongoDB Entity with Primary Key
DESCRIPTION: Shows how to define a MongoDB entity with a primary key using ObjectId and a serialized string id.

LANGUAGE: typescript
CODE:
@PrimaryKey()
_id: ObjectId;

@SerializedPrimaryKey()
id!: string; // won't be saved in the database

----------------------------------------

TITLE: Configuring TsMorphMetadataProvider in MikroORM v4
DESCRIPTION: Shows how to explicitly enable the TsMorphMetadataProvider in the ORM configuration. This is necessary if you want to use ts-morph instead of the new default ReflectMetadataProvider.

LANGUAGE: typescript
CODE:
import { TsMorphMetadataProvider } from '@mikro-orm/reflection';

await MikroORM.init({
  metadataProvider: TsMorphMetadataProvider,
  // ...
});

----------------------------------------

TITLE: Configuring Auto-Flush in MikroORM
DESCRIPTION: This snippet shows how to configure the auto-flush option when initializing MikroORM, which affects the default behavior of the persist() method.

LANGUAGE: typescript
CODE:
const orm = await MikroORM.init({
  autoFlush: false, // defaults to false in v3, was true in v2
  // ...
});
orm.em.persist(new Entity()); // no auto-flushing now
await orm.em.flush();
await orm.em.persist(new Entity(), true); // you can still use second parameter to auto-flush

----------------------------------------

TITLE: Demonstrating Bidirectional Relation Propagation in MikroORM (TypeScript)
DESCRIPTION: This snippet shows how changes in one side of a bidirectional relation are automatically propagated to the other side in MikroORM. It creates an author and a book, assigns the author to the book, and then checks if the book is in the author's collection.

LANGUAGE: typescript
CODE:
const author = new Author(...);
const book = new Book(...);
book.author = author;
console.log(author.books.contains(book)); // true

----------------------------------------

TITLE: Basic QueryBuilder Usage
DESCRIPTION: Demonstrates basic usage of QueryBuilder to construct and execute an update query with conditions.

LANGUAGE: typescript
CODE:
const qb = orm.em.createQueryBuilder(Author);
qb.update({ name: 'test 123', type: PublisherType.GLOBAL }).where({ id: 123, type: PublisherType.LOCAL });

console.log(qb.getQuery());
// update `publisher2` set `name` = ?, `type` = ? where `id` = ? and `type` = ?

console.log(qb.getParams());
// ['test 123', PublisherType.GLOBAL, 123, PublisherType.LOCAL]

// run the query
const res1 = await qb.execute();

----------------------------------------

TITLE: Disabling Transactions for EntityManager Fork in MikroORM
DESCRIPTION: Demonstrates how to disable transactions when creating a new EntityManager fork in MikroORM.

LANGUAGE: typescript
CODE:
const em = await orm.em.fork({ disableTransactions: true });
await em.transactional(...); // no-op
await em.begin(...); // no-op
await em.commit(...); // commit still calls `flush`

----------------------------------------

TITLE: Defining Wildcard Schema Entity
DESCRIPTION: Demonstrates how to define an entity that can exist in multiple schemas using wildcard schema configuration.

LANGUAGE: typescript
CODE:
@Entity({ schema: '*' })
export class Book {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  name?: string;

  @ManyToOne(() => Author, { nullable: true, deleteRule: 'cascade' })
  author?: Author;

  @ManyToOne(() => Book, { nullable: true })
  basedOn?: Book;

}

----------------------------------------

TITLE: Configuring SeedManager in MikroORM
DESCRIPTION: Shows how to install and register the SeedManager extension in the MikroORM configuration file.

LANGUAGE: typescript
CODE:
import { SeedManager } from '@mikro-orm/seeder';

export default defineConfig({
  // ...
  extensions: [SeedManager],
})

----------------------------------------

TITLE: Configuring TsMorphMetadataProvider in MikroORM v4
DESCRIPTION: Example of how to explicitly enable the TsMorphMetadataProvider in MikroORM v4 configuration. This is necessary if you want to use ts-morph for metadata processing.

LANGUAGE: typescript
CODE:
import { TsMorphMetadataProvider } from '@mikro-orm/reflection';

await MikroORM.init({
  metadataProvider: TsMorphMetadataProvider,
  // ...
});

----------------------------------------

TITLE: Using Reference Wrapper in MikroORM Queries
DESCRIPTION: This code demonstrates how to use the Reference wrapper when querying entities in MikroORM. It shows the difference between initialized and uninitialized references.

LANGUAGE: typescript
CODE:
const article1 = await em.findOne(Article, 1);
article.author instanceof Reference; // true
article1.author; // Ref<User> (instance of `Reference` class)
article1.author.name; // type error, there is no `name` property
article1.author.unwrap().name; // unsafe sync access, undefined as author is not loaded
article1.author.isInitialized(); // false

const article2 = await em.findOne(Article, 1, { populate: ['author'] });
article2.author; // LoadedReference<User> (instance of `Reference` class)
article2.author.$.name; // type-safe sync access

----------------------------------------

TITLE: Ignoring Deprecation Warnings in MikroORM Configuration (TypeScript)
DESCRIPTION: Demonstrates how to ignore all deprecation warnings or specific ones by their labels when initializing MikroORM.

LANGUAGE: typescript
CODE:
return MikroORM.init({
  ignoreDeprecations: true, // now no deprecations will be logged, though you may be surprised when upgrading
});

LANGUAGE: typescript
CODE:
return MikroORM.init({
  ignoreDeprecations: ['D0001'], // ignore deprecation with label "D0001", but show others if they pop up
});

----------------------------------------

TITLE: Express Authentication Configuration
DESCRIPTION: Configuration example for adding authentication to AdminJS with Express, including email and password verification.

LANGUAGE: typescript
CODE:
const ADMIN_EMAIL = 'example@test.com';
const ADMIN_PASSWORD = 'password';

const router = AdminJSExpress.buildAuthenticatedRouter(admin, {
  authenticate: async (email, password) => {
    /* Your code for verifying email & password goes here */
    return email === ADMIN_EMAIL && password === ADMIN_PASSWORD
      ? { email } // the function should return an object containing user's data if authenticated successfully
      : null;
  },
  cookiePassword: process.env.COOKIE_PASSWORD ?? 'makesurepasswordissecure',
});

----------------------------------------

TITLE: Defining BaseEntity with EntitySchema in TypeScript
DESCRIPTION: This snippet shows how to define a BaseEntity using EntitySchema. It includes common fields like id, createdAt, and updatedAt, which can be extended by other entities.

LANGUAGE: typescript
CODE:
export interface BaseEntity {
  id: number;
  createdAt: Date;
  updatedAt: Date;
}

export const schema = new EntitySchema<BaseEntity>({
  name: 'BaseEntity',
  abstract: true,
  properties: {
    id: { type: 'number', primary: true },
    createdAt: { type: 'Date', onCreate: () => new Date(), nullable: true },
    updatedAt: { type: 'Date', onCreate: () => new Date(), onUpdate: () => new Date(), nullable: true },
  },
});

----------------------------------------

TITLE: Raw Fragments in Filter Decorators - TypeScript
DESCRIPTION: Example of using raw SQL fragments within MikroORM filter decorators, demonstrating the callback signature for proper fragment serialization.

LANGUAGE: typescript
CODE:
@Filter({ name: 'long', cond: () => ({ [raw('length(perex)')]: { $gt: 10000 } }) })

----------------------------------------

TITLE: Importing QueryBuilder Dependencies
DESCRIPTION: Shows how to import the required EntityManager and EntityRepository types for using QueryBuilder in MikroORM v4+

LANGUAGE: typescript
CODE:
import { EntityManager, EntityRepository } from '@mikro-orm/mysql'; // or any other driver package

----------------------------------------

TITLE: Demonstrating Collection.add() Propagation in One-to-Many Relation (TypeScript)
DESCRIPTION: This code demonstrates how using Collection.add() on a one-to-many relation automatically propagates the change to the other side. It creates an author and a book, adds the book to the author's collection, and then checks if the author is set on the book.

LANGUAGE: typescript
CODE:
// one to many
const author = new Author(...);
const book = new Book(...);

author.books.add(book);
console.log(book.author); // author will be set thanks to the propagation

----------------------------------------

TITLE: Article Entity with ManyToOne Relation
DESCRIPTION: Example of an Article entity with a ManyToOne relation to User, demonstrating potential type-safety issues without Reference wrapper.

LANGUAGE: typescript
CODE:
@Entity()
export class Article {

  @PrimaryKey()
  id!: number;

  @ManyToOne()
  author!: User;

  constructor(author: User) {
    this.author = author;
  }

}

----------------------------------------

TITLE: Defining Entity Relationships in TypeScript with MikroORM
DESCRIPTION: This snippet demonstrates how to define entity relationships using MikroORM decorators in TypeScript. It shows a one-to-many relationship between Author and Book entities.

LANGUAGE: typescript
CODE:
import { Entity, LoadStrategy, OneToMany, ManyToOne, PrimaryKey } from '@mikro-orm/core';

@Entity()
export class Author {

  @PrimaryKey()
  id!: number;

  @OneToMany(() => Book, b => b.author)
  books = new Collection<Book>(this);

}

@Entity()
export class Book {

  @PrimaryKey()
  id!: number;

  @ManyToOne()
  author: Author;

}

----------------------------------------

TITLE: Registering an Event Subscriber with @Subscriber Decorator in TypeScript
DESCRIPTION: Example of using the @Subscriber decorator to register an event subscriber for entities.

LANGUAGE: typescript
CODE:
@Subscriber()
export class AuthorSubscriber implements EventSubscriber<Author> {
  // ...
}

----------------------------------------

TITLE: Defining OneToMany Relationships in MikroORM with TypeScript
DESCRIPTION: This snippet shows different ways to define a OneToMany relationship in MikroORM using TypeScript decorators. It demonstrates various syntaxes for specifying the related entity and mapping options.

LANGUAGE: typescript
CODE:
@Entity()
export class Author {

  @OneToMany(() => Book, book => book.author)
  books1 = new Collection<Book>(this);

  @OneToMany('Book', 'author')
  books2 = new Collection<Book>(this);

  @OneToMany({ mappedBy: book => book.author }) // referenced entity type can be sniffer too
  books3 = new Collection<Book>(this);

  @OneToMany({ entity: () => Book, mappedBy: 'author', orphanRemoval: true })
  books4 = new Collection<Book>(this);

}

----------------------------------------

TITLE: Enabling Pretty Printing for Metadata Cache in MikroORM
DESCRIPTION: This code snippet shows how to enable pretty printing for the cached metadata when initializing MikroORM. It sets the 'pretty' property of the 'metadataCache' option to true.

LANGUAGE: typescript
CODE:
await MikroORM.init({
  metadataCache: { pretty: true },
  // ...
});

----------------------------------------

TITLE: Entity Property Type Definitions with ReflectMetadataProvider
DESCRIPTION: Examples of proper type definitions when using ReflectMetadataProvider, including collections, references, and enums.

LANGUAGE: typescript
CODE:
@Property()
createdAt: Date = new Date();

LANGUAGE: typescript
CODE:
@OneToMany(() => Book, b => b.author)
books = new Collection<Book>(this);

@ManyToOne(() => Publisher, { wrappedReference: true })
publisher!: IdentifiedReference<Publisher>;

LANGUAGE: typescript
CODE:
@Property({ nullable: true })
prop?: string;

LANGUAGE: typescript
CODE:
@Enum(() => UserRole)
role: UserRole;

@Enum({ type: 'UserRole' })
role: UserRole;

@Enum({ items: ['a', 'b', 'c'] })
role: UserRole;

LANGUAGE: typescript
CODE:
@ManyToOne({ entity: () => Author })
author: Author;

----------------------------------------

TITLE: Implementing Custom Database Driver
DESCRIPTION: Shows how to configure MikroORM to use a custom database driver implementation. The driver class must be provided via the driver configuration option.

LANGUAGE: typescript
CODE:
import { MyCustomDriver } from './MyCustomDriver.ts';

const orm = await MikroORM.init({
  entitiesDirs: ['entities'], // relative to `baseDir`
  dbName: 'my-db-name',
  driver: MyCustomDriver, // provide the class, not just its name
});

----------------------------------------

TITLE: Initializing MikroORM with MongoDB Transactions in TypeScript
DESCRIPTION: This code shows how to initialize MikroORM with MongoDB transactions enabled. It includes setting up a replica set, enabling implicit transactions, and creating collections.

LANGUAGE: typescript
CODE:
import { MikroORM } from 'mikro-orm';
import { MongoDriver } from 'mikro-orm/dist/drivers/MongoDriver';

// make sure to provide the MongoDriver type hint
const orm = await MikroORM.init<MongoDriver>({
  entitiesDirs: ['entities'], // relative to `baseDir`
  clientUrl: 'mongodb://localhost:27017,localhost:27018,localhost:27019/my-db-name?replicaSet=rs0',
  type: 'mongo',
  implicitTransactions: true, // defaults to false
});

await orm.em.getDriver().createCollections();

----------------------------------------

TITLE: Configuring Auto-Flush in MikroORM
DESCRIPTION: This snippet shows how to configure the auto-flush option when initializing MikroORM, which affects the default behavior of the persist() method.

LANGUAGE: typescript
CODE:
const orm = await MikroORM.init({
  autoFlush: false, // defaults to false in v3, was true in v2
  // ...
});
orm.em.persist(new Entity()); // no auto-flushing now
await orm.em.flush();
await orm.em.persist(new Entity(), true); // you can still use second parameter to auto-flush

----------------------------------------

TITLE: Explicit Transaction Using Callback in MikroORM
DESCRIPTION: Shows how to explicitly manage transactions using the transactional callback approach.

LANGUAGE: typescript
CODE:
await orm.em.transactional(em => {
  //... do some work
  const user = new User(...);
  user.name = 'George';
  em.persist(user);
});

----------------------------------------

TITLE: Explicit Transaction Using Callback in MikroORM
DESCRIPTION: Shows how to explicitly manage transactions using the transactional callback approach.

LANGUAGE: typescript
CODE:
await orm.em.transactional(em => {
  //... do some work
  const user = new User(...);
  user.name = 'George';
  em.persist(user);
});

----------------------------------------

TITLE: Explicit Transaction Using Callback in MikroORM
DESCRIPTION: Shows how to explicitly manage transactions using the transactional callback approach.

LANGUAGE: typescript
CODE:
await orm.em.transactional(em => {
  //... do some work
  const user = new User(...);
  user.name = 'George';
  em.persist(user);
});

----------------------------------------

TITLE: Creating Entities with Forked EntityManager
DESCRIPTION: Shows how to create and persist entities using forked EntityManager with default schema

LANGUAGE: typescript
CODE:
const fork = em.fork({ schema: 'client-123' });
const user = new User();
user.email = 'foo@bar.com';
await fork.persist(user).flush();

----------------------------------------

TITLE: Various Ways of Using ref() Helper in TypeScript
DESCRIPTION: This snippet demonstrates different ways to use the 'ref()' helper function, including handling null values, undefined, primary keys, and entity instances.

LANGUAGE: typescript
CODE:
book.author = ref(Author, null);
book.author = ref(Author, undefined);
book.author = ref(null);
book.author = ref(undefined);
book.author = ref(Author, 1);
book.author = ref(Author, author);
book.author = ref(author);

----------------------------------------

TITLE: Defining Entities with WrappedEntity Interface in TypeScript
DESCRIPTION: Shows how to define an entity class and extend it with the WrappedEntity interface to maintain all public methods that were part of the IEntity interface in v2.

LANGUAGE: typescript
CODE:
@Entity()
export class Book { ... }
export interface Book extends WrappedEntity<Book, 'id'> { }

----------------------------------------

TITLE: Configuring Entity Manager Cache in TypeScript
DESCRIPTION: Demonstrates how to use result caching with EntityManager's find method. Shows different ways to specify cache expiration and custom cache keys.

LANGUAGE: typescript
CODE:
const res = await em.find(Book, { author: { name: 'Jon Snow' } }, {
  populate: ['author', 'tags'],
  cache: 50, // set expiration to 50ms
  // cache: ['cache-key', 50], // set custom cache key and expiration
  // cache: true, // use default cache key and expiration
});

----------------------------------------

TITLE: Explicit Transaction Management using Callback API
DESCRIPTION: Shows how to use the transactional callback API for explicit transaction control.

LANGUAGE: typescript
CODE:
await orm.em.transactional(em => {
  //... do some work
  const user = new User(...);
  user.name = 'George';
  em.persist(user);
});

----------------------------------------

TITLE: Implicit Transaction Handling in MikroORM
DESCRIPTION: Example of how MikroORM handles transactions implicitly when persisting changes to entities with relationships.

LANGUAGE: typescript
CODE:
const user = await em.findOne(User, 1);
user.email = 'foo@bar.com';
const car = new Car();
user.cars.add(car);

// thanks to bi-directional cascading we only need to persist user entity
// flushing will create a transaction, insert new car and update user with new email
await em.persistAndFlush(user);

----------------------------------------

TITLE: Explicit Transaction Management using Callback API
DESCRIPTION: Shows how to use the transactional callback API for explicit transaction control.

LANGUAGE: typescript
CODE:
await orm.em.transactional(em => {
  //... do some work
  const user = new User(...);
  user.name = 'George';
  em.persist(user);
});

----------------------------------------

TITLE: Using @Transactional() Decorator in TypeScript
DESCRIPTION: Demonstrates how to use the new @Transactional() decorator to wrap a method in an explicit transaction. The decorator automatically calls flush on the EntityManager fork before the method resolves.

LANGUAGE: typescript
CODE:
import { EntityManager, MikroORM, Transactional } from '@mikro-orm/core';

export class MyService {

  constructor(private readonly em: EntityManager) { }

  @Transactional()
  async doSomething() {
    //... do some work
    const user = new User();
    user.name = 'George';
    em.persist(user); 
  }

}

----------------------------------------

TITLE: Optimistic Lock Verification
DESCRIPTION: Demonstrates how to verify entity versions during requests using findOne with optimistic locking.

LANGUAGE: typescript
CODE:
const theEntityId = 1;
const expectedVersion = 184;

try {
  const entity = await orm.em.findOne(User, theEntityId, { lockMode: LockMode.OPTIMISTIC, lockVersion: expectedVersion });

  // do the work

  await orm.em.flush();
} catch (e) {
  console.log('Sorry, but someone else has already changed this entity. Please apply the changes again!');
}

----------------------------------------

TITLE: Entity Directory Configuration
DESCRIPTION: Example of the new entities configuration format replacing the old entitiesDirs option.

LANGUAGE: typescript
CODE:
MikroORM.init({
  entities: ['dist/**/entities', 'dist/**/*.entity.js', FooBar, FooBaz],
  entitiesTs: ['src/**/entities', 'src/**/*.entity.ts', FooBar, FooBaz],
});

----------------------------------------

TITLE: Configuring Custom Cache Adapter in MikroORM Initialization (TypeScript)
DESCRIPTION: This code demonstrates how to configure a custom cache adapter (RedisCacheAdapter in this case) when initializing MikroORM. It uses the 'adapter' property of the 'metadataCache' option.

LANGUAGE: typescript
CODE:
await MikroORM.init({
  metadataCache: { adapter: RedisCacheAdapter, options: { ... } },
  // ...
});

----------------------------------------

TITLE: Hidden Properties Implementation
DESCRIPTION: Demonstrates how to mark entity properties as hidden using decorators and HiddenProps symbol.

LANGUAGE: typescript
CODE:
@Entity()
class Book {

  // we use the `HiddenProps` symbol to define hidden properties on type level
  [HiddenProps]?: 'hiddenField' | 'otherHiddenField';

  @Property({ hidden: true })
  hiddenField = Date.now();

  @Property({ hidden: true, nullable: true })
  otherHiddenField?: string;

}

----------------------------------------

TITLE: Setting Population Order By Clause in MikroORM Query
DESCRIPTION: This example demonstrates how to use the 'populateOrderBy' option to control the ordering of populated relations.

LANGUAGE: typescript
CODE:
await em.find(Author, { ... }, {
  populate: ['books'],
  populateOrderBy: { books: { publishedAt: 'desc' } },
});

----------------------------------------

TITLE: Implementing Asynchronous Filter Conditions in MikroORM
DESCRIPTION: Shows how to define an asynchronous filter condition with access to EntityManager. The filter demonstrates different behavior based on the operation type (read, update, delete).

LANGUAGE: typescript
CODE:
import type { EntityManager } from '@mikro-orm/mysql';

@Entity()
@Filter({ name: 'writtenBy', cond: async (args, type, em: EntityManager) => {
  if (type === 'update') {
    return {}; // do not apply when updating
  }

  return {
    author: { name: args.name },
    publishedAt: { $lte: raw('now()') },
  };
} })
export class Book {
  ...
}

const books = await orm.em.find(Book, {}, {
  filters: { writtenBy: { name: 'God' } },
});

----------------------------------------

TITLE: Defining Wildcard Schema Entities in MikroORM
DESCRIPTION: This code demonstrates how to define an entity that can exist in multiple schemas using a wildcard schema in MikroORM. It uses the '*' wildcard in the schema option of the @Entity decorator.

LANGUAGE: typescript
CODE:
@Entity({ schema: '*' })
export class Book {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  name?: string;

  @ManyToOne(() => Author, { nullable: true, deleteRule: 'cascade' })
  author?: Author;

  @ManyToOne(() => Book, { nullable: true })
  basedOn?: Book;

}

----------------------------------------

TITLE: Using assign() for Entity Updates in MikroORM
DESCRIPTION: Shows how to use the assign() method to update entity properties and references in a more concise way.

LANGUAGE: typescript
CODE:
import { wrap } from '@mikro-orm/core';

wrap(book).assign({
  title: 'Better Book 1',
  author: '...id...',
});
console.log(book.title); // 'Better Book 1'
console.log(book.author); // instance of Author with id: '...id...'
console.log(book.author.id); // '...id...'

----------------------------------------

TITLE: Enabling Pretty Printing for Metadata Cache in MikroORM
DESCRIPTION: Configuration snippet for enabling pretty printing of cached metadata JSON output.

LANGUAGE: typescript
CODE:
await MikroORM.init({
  metadataCache: { pretty: true },
  // ...
});

----------------------------------------

TITLE: MongoDB Aggregate Operations Setup
DESCRIPTION: Example of setting up MongoDB EntityManager for aggregate operations

LANGUAGE: typescript
CODE:
import { EntityManager } from '@mikro-orm/mongodb';

const em = orm.em as EntityManager;
const ret = await em.aggregate(...);

----------------------------------------

TITLE: Using Arrays of Embeddables in MikroORM
DESCRIPTION: Demonstrates how to use an array of embeddables, which are always stored as JSON.

LANGUAGE: typescript
CODE:
@Embedded(() => Address, { array: true })
addresses: Address[] = [];

----------------------------------------

TITLE: Using RequestContext Decorator
DESCRIPTION: Demonstrates how to use the @UseRequestContext decorator for request-scoped methods outside HTTP handlers

LANGUAGE: typescript
CODE:
@Injectable()
export class MyService {

  constructor(private readonly orm: MikroORM) { }

  @UseRequestContext()
  async doSomething() {
    // this will be executed in a separate context
  }

}

----------------------------------------

TITLE: Querying MongoDB with ObjectId and String ID in TypeScript
DESCRIPTION: This snippet demonstrates how to query MongoDB using both ObjectId and string IDs. It shows various ways to perform the same query using different ID formats.

LANGUAGE: typescript
CODE:
const author = orm.em.getReference('...id...');
console.log(author.id);  // returns '...id...'
console.log(author._id); // returns ObjectId('...id...')

// all of those will return the same results
const article = '...article id...'; // string id
const book = '...book id...'; // string id
const repo = orm.em.getRepository(Author);
const foo1 = await repo.find({ id: { $in: [article] }, favouriteBook: book });
const bar1 = await repo.find({ id: { $in: [new ObjectId(article)] }, favouriteBook: new ObjectId(book) });
const foo2 = await repo.find({ _id: { $in: [article] }, favouriteBook: book });
const bar2 = await repo.find({ _id: { $in: [new ObjectId(article)] }, favouriteBook: new ObjectId(book) });

----------------------------------------

TITLE: Disabling Metadata Cache in MikroORM
DESCRIPTION: Configuration snippet showing how to disable metadata caching when initializing MikroORM.

LANGUAGE: typescript
CODE:
await MikroORM.init({
  metadataCache: { enabled: false },
  // ...
});

----------------------------------------

TITLE: Implementing Custom toJSON Method for Entity in TypeScript
DESCRIPTION: This example demonstrates how to implement a custom toJSON method for an entity, which can modify the serialization output.

LANGUAGE: typescript
CODE:
@Entity()
class Book {

  // ...

  toJSON(strict = true, strip = ['id', 'email'], ...args: any[]): { [p: string]: any } {
    const o = wrap(this, true).toObject(...args); // do not forget to pass rest params here

    if (strict) {
      strip.forEach(k => delete o[k]);
    }

    return o;
  }

}

----------------------------------------

TITLE: Regular Expression Query in MikroORM
DESCRIPTION: Demonstrates how to use regular expressions in queries using both string and RegExp object approaches.

LANGUAGE: typescript
CODE:
const res = await em.find(Painter, {
  lastName: /m[oa]net/i, // or `new RegExp('m[oa]net', 'i')`
});

----------------------------------------

TITLE: Implementing GeneratedCacheAdapter Configuration
DESCRIPTION: Configuration setup for using pre-generated metadata cache in production environment.

LANGUAGE: typescript
CODE:
import { GeneratedCacheAdapter, MikroORM } from '@mikro-orm/core';

await MikroORM.init({
  metadataCache: {
    enabled: true,
    adapter: GeneratedCacheAdapter,
    options: { data: require('./temp/metadata.json') },
  },
  // ...
});

----------------------------------------

TITLE: Defining Parameterless Filters in MikroORM
DESCRIPTION: Shows how to create filters that don't require parameters but need access to operation type.

LANGUAGE: typescript
CODE:
@Filter({
  name: 'withoutParams',
  cond(_, type) {
    return { ... };
  },
  args: false,
  default: true,
})

----------------------------------------

TITLE: Setting Up MongoDB Transactions
DESCRIPTION: Shows how to configure and use transactions with MongoDB including replica set setup.

LANGUAGE: shell
CODE:
# first create replica set
$ run-rs -v 4.2.3

LANGUAGE: typescript
CODE:
import { MikroORM } from '@mikro-orm/mongodb';

const orm = await MikroORM.init({
  entities: [Author, Book, ...],
  clientUrl: 'mongodb://localhost:27017,localhost:27018,localhost:27019/my-db-name?replicaSet=rs0',
  implicitTransactions: true,
});

await orm.schema.createSchema();

----------------------------------------

TITLE: Using Promise.all with Collection Dataloaders
DESCRIPTION: Demonstrates how to load multiple authors and their books using dataloaders with Promise.all to optimize queries.

LANGUAGE: typescript
CODE:
const authors = await orm.em.find(Author, [1, 2, 3]);
await Promise.all(authors.map(author => author.books.load({ dataloader: true })));

----------------------------------------

TITLE: Implementing Asynchronous Filter Conditions in MikroORM
DESCRIPTION: Shows how to define an asynchronous filter condition with access to EntityManager. The filter demonstrates different behavior based on the operation type (read, update, delete).

LANGUAGE: typescript
CODE:
import type { EntityManager } from '@mikro-orm/mysql';

@Entity()
@Filter({ name: 'writtenBy', cond: async (args, type, em: EntityManager) => {
  if (type === 'update') {
    return {}; // do not apply when updating
  }

  return {
    author: { name: args.name },
    publishedAt: { $lte: raw('now()') },
  };
} })
export class Book {
  ...
}

const books = await orm.em.find(Book, {}, {
  filters: { writtenBy: { name: 'God' } },
});

----------------------------------------

TITLE: Entity Creation with Forked EntityManager
DESCRIPTION: Demonstrates entity creation using a forked EntityManager with a default schema and compares it with QueryBuilder approach.

LANGUAGE: typescript
CODE:
const fork = em.fork({ schema: 'client-123' });
const user = new User();
user.email = 'foo@bar.com';
await fork.persist(user).flush();

// Will yield the same result as
const qb = em.createQueryBuilder(User);
await qb.insert({ email: 'foo@bar.com' }).withSchema('client-123');

----------------------------------------

TITLE: Configuring ManyToMany Relations
DESCRIPTION: TypeScript decorators for configuring ManyToMany relations with custom pivot table names. Shows both unidirectional and bidirectional relation configurations.

LANGUAGE: typescript
CODE:
// for unidirectional
@ManyToMany({ entity: () => Test, owner: true, pivotTable: 'publisher2test' })
tests = new Collection<Test>(this);

// for bidirectional
@ManyToMany({ entity: () => BookTag, inversedBy: 'books', pivotTable: 'book2tag' })
tags = new Collection<BookTag>(this);

----------------------------------------

TITLE: Repository Type Inference Setup
DESCRIPTION: Shows how to set up type inference for custom repositories using EntityRepositoryType symbol.

LANGUAGE: typescript
CODE:
@Entity({ repository: () => AuthorRepository })
export class Author {

  [EntityRepositoryType]?: AuthorRepository;

}

const repo = em.getRepository(Author); // repo has type AuthorRepository

----------------------------------------

TITLE: SQL Table Creation with UnderscoreNamingStrategy (SQL)
DESCRIPTION: Shows an example of how the UnderscoreNamingStrategy (default for SQL drivers) translates entity properties into database table structure.

LANGUAGE: sql
CODE:
CREATE TABLE `author` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `created_at` datetime(3) DEFAULT NULL,
  `updated_at` datetime(3) DEFAULT NULL,
  `terms_accepted` tinyint(1) DEFAULT NULL,
  `name` varchar(255) DEFAULT NULL,
  `email` varchar(255) DEFAULT NULL,
  `born` datetime DEFAULT NULL,
  `favourite_book_id` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

----------------------------------------

TITLE: Inserting Entities in Specific Schema with MikroORM QueryBuilder
DESCRIPTION: This snippet demonstrates how to create an entity in a specific schema using QueryBuilder. The withSchema method is used to specify the target schema for the insert operation.

LANGUAGE: typescript
CODE:
const qb = em.createQueryBuilder(User);
await qb.insert({ email: 'foo@bar.com' }).withSchema('client-123');

----------------------------------------

TITLE: Extending EntityManager in MikroORM
DESCRIPTION: Shows how to extend the EntityManager with custom methods using the entityManager ORM option.

LANGUAGE: typescript
CODE:
import { MikroORM, EntityManager } from '@mikro-orm/sqlite';

class MyEntityManager extends EntityManager {

  myCustomMethod(base: number): number {
    return base * Math.random();
  }

}

const orm = await MikroORM.init({
  entities: [...],
  dbName: ':memory:',
  entityManager: MyEntityManager,
});
console.log(orm.em instanceof MyEntityManager); // true
const res = orm.em.myCustomMethod(123);

----------------------------------------

TITLE: Initializing and Iterating Collections in TypeScript
DESCRIPTION: Demonstrates how to initialize a Collection, iterate through it using a for...of loop, and access items using bracket notation. Also shows how to get all entities from a Collection using getItems() and toArray() methods.

LANGUAGE: typescript
CODE:
const author = em.findOne(Author, '...', { populate: ['books'] }); // populating books collection

// or we could lazy load books collection later via `init()` method
await author.books.init();

for (const book of author.books) {
  console.log(book.title); // initialized
  console.log(book.author.isInitialized()); // true
  console.log(book.author.id);
  console.log(book.author.name); // Jon Snow
  console.log(book.publisher); // just reference
  console.log(book.publisher.isInitialized()); // false
  console.log(book.publisher.id);
  console.log(book.publisher.name); // undefined
}

// collection needs to be initialized before we can work with it
author.books.add(book);
console.log(author.books.contains(book)); // true
console.log(author.books.exists(item => item === book)); // true
console.log(author.books.find(item => item === book)); // book
console.log(author.books.map(item => item.title)); // array of book titles
console.log(author.books.filter(item => item.title.startsWith('Foo'))); // array of books matching the callback
author.books.remove(book);
console.log(author.books.contains(book)); // false
author.books.add(book);
console.log(author.books.count()); // 1
console.log(author.books.slice(0, 1)); // Book[]
console.log(author.books.slice()); // Book[]
console.log(author.books.slice().length); // 1
author.books.removeAll();
console.log(author.books.isEmpty()); // true
console.log(author.books.contains(book)); // false
console.log(author.books.count()); // 0
console.log(author.books.getItems()); // Book[]
console.log(author.books.getIdentifiers()); // array of string | number
console.log(author.books.getIdentifiers('_id')); // array of ObjectId

// array access works as well
console.log(author.books[1]); // Book
console.log(author.books[12345]); // undefined, even if the collection is not initialized

// getting array of the items
console.log(author.books.getItems()); // Book[]

// serializing the collection
console.log(author.books.toArray()); // EntityDTO<Book>[]

const author = em.findOne(Author, '...'); // books collection has not been populated
const count = await author.books.loadCount(); // gets the count of collection items from database instead of counting loaded items
console.log(author.books.getItems()); // throws because the collection has not been initialized
// initialize collection if not already loaded and return its items as array
console.log(await author.books.loadItems()); // Book[]

----------------------------------------

TITLE: Loading Multiple References with Dataloaders
DESCRIPTION: Shows how to load multiple book authors using dataloaders to batch references into a single query.

LANGUAGE: typescript
CODE:
const books = await orm.em.find(Book, [1, 2, 3]);
await Promise.all(books.map(book => book.author.load({ dataloader: true })));

----------------------------------------

TITLE: Defining ManyToMany Relationships (Owning Side) in TypeScript with MikroORM
DESCRIPTION: This snippet demonstrates how to define the owning side of a ManyToMany relationship in MikroORM using TypeScript. It shows various ways to specify the relationship, including unidirectional and bidirectional configurations.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  // when none of `owner/inverseBy/mappedBy` is provided, it will be considered owning side
  @ManyToMany()
  tags1 = new Collection<BookTag>(this);

  @ManyToMany(() => BookTag, 'books', { owner: true })
  tags2 = new Collection<BookTag>(this);

  @ManyToMany(() => BookTag, 'books', { owner: true })
  tags3 = new Collection<BookTag>(this);

  @ManyToMany(() => BookTag, 'books', { owner: true })
  tags4 = new Collection<BookTag>(this);

  // to define uni-directional many to many, simply provide only
  @ManyToMany(() => Author)
  friends: Collection<Author> = new Collection<Author>(this);

}

----------------------------------------

TITLE: Defining ManyToMany Relationships (Owning Side) in TypeScript with MikroORM
DESCRIPTION: This snippet demonstrates how to define the owning side of a ManyToMany relationship in MikroORM using TypeScript. It shows various ways to specify the relationship, including unidirectional and bidirectional configurations.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  // when none of `owner/inverseBy/mappedBy` is provided, it will be considered owning side
  @ManyToMany()
  tags1 = new Collection<BookTag>(this);

  @ManyToMany(() => BookTag, 'books', { owner: true })
  tags2 = new Collection<BookTag>(this);

  @ManyToMany(() => BookTag, 'books', { owner: true })
  tags3 = new Collection<BookTag>(this);

  @ManyToMany(() => BookTag, 'books', { owner: true })
  tags4 = new Collection<BookTag>(this);

  // to define uni-directional many to many, simply provide only
  @ManyToMany(() => Author)
  friends: Collection<Author> = new Collection<Author>(this);

}

----------------------------------------

TITLE: Loading Multiple References with Dataloaders
DESCRIPTION: Shows how to load multiple book authors using dataloaders to batch references into a single query.

LANGUAGE: typescript
CODE:
const books = await orm.em.find(Book, [1, 2, 3]);
await Promise.all(books.map(book => book.author.load({ dataloader: true })));

----------------------------------------

TITLE: Entity Discovery via Folders
DESCRIPTION: Shows how to configure MikroORM to discover entities from specified directory paths, including TypeScript source files.

LANGUAGE: typescript
CODE:
MikroORM.init({
  entities: ['./dist/modules/users/entities', './dist/modules/projects/entities'],
  entitiesTs: ['./src/modules/users/entities', './src/modules/projects/entities'],
  baseDir: process.cwd(),
});

----------------------------------------

TITLE: Configuring MikroORM with Turso Database in TypeScript
DESCRIPTION: Example of setting up MikroORM configuration for Turso database using environment variables for database URL and authentication token.

LANGUAGE: typescript
CODE:
import { defineConfig } from '@mikro-orm/libsql';

export default defineConfig({
  dbName: process.env.LIBSQL_URL,
  password: process.env.LIBSQL_AUTH_TOKEN,
});

----------------------------------------

TITLE: GraphQL Query for Nested Data (GraphQL)
DESCRIPTION: This GraphQL query demonstrates how to request nested data (authors and their books) in a single query. When used with MikroORM's dataloaders, this query will automatically batch the database requests to optimize performance.

LANGUAGE: graphql
CODE:
{
  authors {
    name
    books {
      title
    }
  }
}

----------------------------------------

TITLE: Implementing Cascade Persist in MikroORM
DESCRIPTION: Shows how to use cascade persist functionality to automatically persist related entities when the parent entity is persisted.

LANGUAGE: typescript
CODE:
const book = await orm.em.findOne(Book, 'id', { populate: ['author', 'tags'] });
book.author.name = 'Foo Bar';
book.tags[0].name = 'new name 1';
book.tags[1].name = 'new name 2';
await orm.em.persistAndFlush(book); // all book tags and author will be persisted too

----------------------------------------

TITLE: Complex Query with Multiple Conditions in MikroORM
DESCRIPTION: Demonstrates how to create a complex query with multiple AND conditions using MikroORM's find method. The query uses various comparison operators to filter authors based on their ID.

LANGUAGE: typescript
CODE:
const res = await orm.em.find(Author, { $and: [
  { id: { $in: [1, 2, 7] }, },
  { id: { $nin: [3, 4] }, },
  { id: { $gt: 5 }, },
  { id: { $lt: 10 }, },
  { id: { $gte: 7 }, },
  { id: { $lte: 8 }, },
  { id: { $ne: 9 }, },
] });

----------------------------------------

TITLE: Persisting Managed Entities
DESCRIPTION: Demonstrates how changes to managed entities are automatically tracked and persisted without explicit persist() calls when using flush().

LANGUAGE: typescript
CODE:
const jon = await em.findOne(Author, 1);
jon.email = 'foo@bar.com';
await em.flush();

----------------------------------------

TITLE: Using Raw SQL Fragments in MikroORM v6
DESCRIPTION: This snippet demonstrates the new way of using raw SQL fragments in MikroORM v6 with the 'raw' helper function.

LANGUAGE: typescript
CODE:
const users = await em.find(User, {
-  [expr('lower(email)')]: 'foo@bar.baz',
+  [raw('lower(email)')]: 'foo@bar.baz',
});

----------------------------------------

TITLE: Using Read and Write Connections in MikroORM Queries in TypeScript
DESCRIPTION: This snippet illustrates various scenarios of using read and write connections in MikroORM queries. It shows how to explicitly specify connection types, handle transactions, and demonstrates the behavior with different 'preferReadReplicas' settings.

LANGUAGE: typescript
CODE:
const connection = em.getConnection(); // write connection
const readConnection = em.getConnection('read'); // random read connection

const qb1 = em.createQueryBuilder(Author);
const res1 = await qb1.select('*').execute(); // random read connection

const qb2 = em.createQueryBuilder(Author, 'a', 'write');
const res2 = await qb2.select('*').execute(); // write connection

const qb3 = em.createQueryBuilder(Author);
const res3 = await qb3.update(...).where(...).execute(); // write connection

const res4 = await em.findOne(Author, 1, { connectionType: 'write' }); // explicit write connection

// all queries inside a transaction will use write connection
await em.transactional(async em => {
    const a = await em.findOne(Author, 1); // write connection
    const b = await em.findOne(Author, 1, { connectionType: 'read' }); // still a write connection - we are in a transaction
    a.name = 'test'; // will trigger update on write connection once flushed
});

// given a configuration where preferReadReplicas: false
const res5 = await em.findOne(Author, 1); // write connection - even for a read operation
const res6 = await em.findOne(Author, 1, { connectionType: 'read' }); // unless explicitly asking for a read replica

----------------------------------------

TITLE: Configuring Extended Repository Globally
DESCRIPTION: Shows how to configure an extended repository as the default repository for all entities.

LANGUAGE: typescript
CODE:
MikroORM.init({
   entityRepository: ExtendedEntityRepository,
})

----------------------------------------

TITLE: Defining Wildcard Schema Entities in MikroORM
DESCRIPTION: Shows how to define entities that can exist in multiple schemas using wildcard schema.

LANGUAGE: typescript
CODE:
@Entity({ schema: '*' })
export class Book {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  name?: string;

  @ManyToOne(() => Author, { nullable: true, deleteRule: 'cascade' })
  author?: Author;

  @ManyToOne(() => Book, { nullable: true })
  basedOn?: Book;

}

----------------------------------------

TITLE: MikroORM Configuration Setup
DESCRIPTION: Setting up MikroORM configuration with SQLite driver and TypeScript support

LANGUAGE: typescript
CODE:
import { Options, SqliteDriver } from '@mikro-orm/sqlite';
import { TsMorphMetadataProvider } from '@mikro-orm/reflection';

const config: Options = {
  driver: SqliteDriver,
  dbName: 'sqlite.db',
  entities: ['dist/**/*.entity.js'],
  entitiesTs: ['src/**/*.entity.ts'],
  metadataProvider: TsMorphMetadataProvider,
  debug: true,
};

export default config;

----------------------------------------

TITLE: MongoDB ObjectId and String ID Usage
DESCRIPTION: Examples of using both ObjectId and string IDs for querying entities in MongoDB through MikroORM.

LANGUAGE: typescript
CODE:
const author = orm.em.getReference('...id...');
console.log(author.id);  // returns '...id...'
console.log(author._id); // returns ObjectId('...id...')

// all of those will return the same results
const article = '...article id...'; // string id
const book = '...book id...'; // string id
const repo = orm.em.getRepository(Author);
const foo1 = await repo.find({ id: { $in: [article] }, favouriteBook: book });
const bar1 = await repo.find({ id: { $in: [new ObjectId(article)] }, favouriteBook: new ObjectId(book) });
const foo2 = await repo.find({ _id: { $in: [article] }, favouriteBook: book });
const bar2 = await repo.find({ _id: { $in: [new ObjectId(article)] }, favouriteBook: new ObjectId(book) });

----------------------------------------

TITLE: Creating a Join Table with Metadata using Composite Primary Keys in MikroORM
DESCRIPTION: This example demonstrates how to create a join table (OrderItem) with additional metadata using composite primary keys in MikroORM.

LANGUAGE: typescript
CODE:
@Entity()
export class Order {

  @PrimaryKey()
  id!: number;

  @ManyToOne()
  customer: Customer;

  @OneToMany(() => OrderItem, item => item.order)
  items = new Collection<OrderItem>(this);

  @Property()
  paid = false;

  @Property()
  shipped = false;

  @Property()
  created = new Date();

  constructor(customer: Customer) {
    this.customer = customer;
  }

}

@Entity()
export class Product {

  @PrimaryKey()
  id!: number;

  @Property()
  name!: string;

  @Property()
  currentPrice!: number;

}

@Entity()
export class OrderItem {

  @ManyToOne({ primary: true })
  order: Order;

  @ManyToOne({ primary: true })
  product: Product;

  @Property()
  amount = 1;

  @Property()
  offeredPrice: number;

  [PrimaryKeyProp]?: ['order', 'product'];

  constructor(order: Order, product: Product, amount = 1) {
    this.order = order;
    this.product = product;
    this.offeredPrice = product.currentPrice;
  }

}

----------------------------------------

TITLE: Initializing MikroORM with Proper Types
DESCRIPTION: Shows correct import and initialization of MikroORM with proper EntityManager typing

LANGUAGE: typescript
CODE:
import { MikroORM } from '@mikro-orm/mysql'; // or any other SQL driver package

const orm = await MikroORM.init({
  // ...
});
console.log(orm.em); // access EntityManager via `em` property

----------------------------------------

TITLE: Implementing Composite Primary Keys with Primitive Types in TypeScript
DESCRIPTION: Demonstrates how to create an entity with composite primary keys using primitive types (string and number) in MikroORM. Includes type definition for proper FilterQuery checks.

LANGUAGE: typescript
CODE:
@Entity()
export class Car {

  @PrimaryKey()
  name: string;

  @PrimaryKey()
  year: number;

  [PrimaryKeyType]?: [string, number]; // this is needed for proper type checks in `FilterQuery`

  constructor(name: string, year: number) {
    this.name = name;
    this.year = year;
  }

}

----------------------------------------

TITLE: Defining Custom Cache Adapter Interface
DESCRIPTION: Interface definition for implementing custom cache adapters in MikroORM, specifying required methods for get and set operations.

LANGUAGE: typescript
CODE:
export interface CacheAdapter {

  get(name: string): any;

  set(name: string, data: any, origin: string): void;

}

----------------------------------------

TITLE: Reference Loading and Type-Safe Access
DESCRIPTION: Demonstrates type-safe access patterns and loading of referenced entities using the Reference wrapper.

LANGUAGE: typescript
CODE:
const article1 = await em.findOne(Article, 1);
article.author instanceof Reference; // true
article1.author; // Ref<User> (instance of `Reference` class)
article1.author.name; // type error, there is no `name` property
article1.author.unwrap().name; // unsafe sync access, undefined as author is not loaded
article1.author.isInitialized(); // false

const article2 = await em.findOne(Article, 1, { populate: ['author'] });
article2.author; // LoadedReference<User> (instance of `Reference` class)
article2.author.$.name; // type-safe sync access

----------------------------------------

TITLE: Simplified AND Condition for Single Field in MikroORM
DESCRIPTION: Shows a more concise way to write AND conditions for a single field in MikroORM. This query is equivalent to the previous complex query but uses a more compact syntax.

LANGUAGE: typescript
CODE:
const res = await orm.em.find(Author, {
  id: {
    $in: [1, 2, 7],
    $nin: [3, 4],
    $gt: 5,
    $lt: 10,
    $gte: 7,
    $lte: 8,
    $ne: 9,
  },
});

----------------------------------------

TITLE: Defining SQL Virtual Entity with QueryBuilder
DESCRIPTION: Creates a virtual entity using a callback function that builds the SQL query using QueryBuilder. This approach provides more flexibility and type safety compared to raw SQL strings.

LANGUAGE: typescript
CODE:
@Entity({
  expression: (em: EntityManager) => {
    return em.createQueryBuilder(Book, 'b')
      .select(['b.title', 'a.name as author_name', 'group_concat(t.name) as tags'])
      .join('b.author', 'a')
      .join('b.tags', 't')
      .groupBy('b.id');
  },
})
export class BookWithAuthor {

  @Property()
  title!: string;

  @Property()
  authorName!: string;

  @Property()
  tags!: string[];

}

----------------------------------------

TITLE: Configuring MikroORM Seeder Extension
DESCRIPTION: Initial setup for enabling the seeder functionality by installing @mikro-orm/seeder and registering the SeedManager extension.

LANGUAGE: typescript
CODE:
import { SeedManager } from '@mikro-orm/seeder';

export default defineConfig({
  // ...
  extensions: [SeedManager],
})

----------------------------------------

TITLE: Adding Authentication to AdminJS with Hapi
DESCRIPTION: TypeScript code snippet showing how to add authentication to AdminJS when using the Hapi plugin. Adds an auth property to the AdminJS options.

LANGUAGE: typescript
CODE:
const ADMIN_EMAIL = 'example@test.com';
const ADMIN_PASSWORD = 'password';

const adminOptions = {
  databases: [orm],
  auth: {
    authenticate: async (email, password) => {
      /* Your code for verifying email & password goes here */
      return email === ADMIN_EMAIL && password === ADMIN_PASSWORD
        ? { email } // the function should return an object containing user's data if authenticated successfully
        : null;
    },
    strategy: 'session',
    cookiePassword: process.env.COOKIE_PASSWORD ?? 'makesurepasswordissecure',
    isSecure: false, // only https requests
  },
};

----------------------------------------

TITLE: Customizing Column Prefixes for Embeddables
DESCRIPTION: This example demonstrates how to customize the column prefix for an embedded Address in the User entity using the prefix option.

LANGUAGE: typescript
CODE:
@Entity()
export class User {

  @Embedded(() => Address, { prefix: 'myPrefix_' })
  address!: Address;

}

----------------------------------------

TITLE: Dynamic Attributes Implementation with Composite Keys
DESCRIPTION: Shows how to implement dynamic attributes for an Article entity using composite keys. Includes relationship between Article and ArticleAttribute entities with composite primary key implementation.

LANGUAGE: typescript
CODE:
@Entity()
export class Article {

  @PrimaryKey()
  id!: number;

  @Property()
  title!: string;

  @OneToMany(() => ArticleAttribute, attr => attr.article, { cascade: Cascade.ALL })
  attributes = new Collection<ArticleAttribute>(this);

}

@Entity()
export class ArticleAttribute {

  @ManyToOne({ primary: true })
  article: Article;

  @PrimaryKey()
  attribute: string;

  @Property()
  value!: string;

  [PrimaryKeyProp]?: ['article', 'attribute'];

  constructor(name: string, value: string, article: Article) {
    this.attribute = name;
    this.value = value;
    this.article = article;
  }

}

----------------------------------------

TITLE: Using QueryBuilder for Native SQL
DESCRIPTION: Examples of using QueryBuilder to construct and execute native SQL queries. Demonstrates query building, parameter handling, and direct query execution.

LANGUAGE: typescript
CODE:
const qb = orm.em.createQueryBuilder(Author);
qb.update({ name: 'test 123', type: PublisherType.GLOBAL }).where({ id: 123, type: PublisherType.LOCAL });

console.log(qb.getQuery());
// 'UPDATE `publisher2` SET `name` = ?, `type` = ? WHERE `id` = ? AND `type` = ?'

console.log(qb.getParams());
// ['test 123', PublisherType.GLOBAL, 123, PublisherType.LOCAL]

// run the query
const res1 = await qb.execute();

// or run query without using QueryBuilder
const driver = orm.em.getDriver<MySqlDriver>();
const res2 = await driver.execute('SELECT ? + ?', [1, 2]);

----------------------------------------

TITLE: Loading Multiple Books' Authors with Dataloader
DESCRIPTION: Example demonstrating how to load multiple books' authors using dataloader batching with Promise.all().

LANGUAGE: typescript
CODE:
const books = await orm.em.find(Book, [1, 2, 3]);
await Promise.all(books.map(book => book.author.load({ dataloader: true })));

----------------------------------------

TITLE: Entity Population with Type Safety
DESCRIPTION: Demonstrates the new populate method usage which always returns an array and requires destructuring for single entity results.

LANGUAGE: typescript
CODE:
const [loadedAuthor] = await em.populate(author, ...);

----------------------------------------

TITLE: Defining Default Values
DESCRIPTION: Examples of defining default values for entity properties using different approaches.

LANGUAGE: typescript
CODE:
// Runtime default values
@Property()
foo: number & Opt = 1;

@Property()
bar: string & Opt = 'abc';

@Property()
baz: Date & Opt = new Date();

// Database default values
@Property({ default: 1 })
foo!: number & Opt;

@Property({ default: 'abc' })
bar!: string & Opt;

@Property({ defaultRaw: 'now' })
baz!: Date & Opt;

----------------------------------------

TITLE: Async Filter Parameters in MikroORM
DESCRIPTION: Demonstrates how to implement an async filter with dynamic conditions based on operation type and custom parameters.

LANGUAGE: typescript
CODE:
import type { EntityManager } from '@mikro-orm/mysql';

@Entity()
@Filter({ name: 'writtenBy', cond: async (args, type, em: EntityManager) => {
  if (type === 'update') {
    return {}; // do not apply when updating
  }

  return {
    author: { name: args.name },
    publishedAt: { $lte: raw('now()') },
  };
} })
export class Book {
  ...
}

----------------------------------------

TITLE: Configuring MongoDB EntityManager in MikroORM
DESCRIPTION: Shows how to properly import and use MongoDB EntityManager for aggregation operations.

LANGUAGE: typescript
CODE:
import { EntityManager } from '@mikro-orm/mongodb';

const em = orm.em as EntityManager;
const ret = await em.aggregate(...);

----------------------------------------

TITLE: Configuring MikroORM v6 with Driver Exports
DESCRIPTION: This snippet shows how to configure MikroORM v6 using the new driver exports approach instead of the removed 'type' option.

LANGUAGE: typescript
CODE:
import { defineConfig } from '@mikro-orm/mysql';

export default defineConfig({ ... });

----------------------------------------

TITLE: Upsert Operations in MikroORM
DESCRIPTION: Demonstrates how to use the upsert method to create or update entities based on whether they already exist in the database. It also shows how to use upsertMany for batch operations.

LANGUAGE: typescript
CODE:
const author = await em.upsert(Author, { email: 'foo@bar.com', age: 33 });

const [author1, author2, author3] = await em.upsertMany(Author, [
  { email: 'a1', age: 41 },
  { email: 'a2', age: 42 },
  { email: 'a3', age: 43 },
]);

----------------------------------------

TITLE: Creating Entity Instances with EntityManager
DESCRIPTION: Demonstrates how to create new entity instances using the EntityManager's create method when working with EntitySchema.

LANGUAGE: typescript
CODE:
const author = em.create<Author>('Author', { name: 'name', email: 'email' });
await em.flush();

----------------------------------------

TITLE: Using Conditions Object in MikroORM Queries
DESCRIPTION: Demonstrates various ways to use the conditions object (FilterQuery<T>) when querying entities, including searching by properties, references, and complex conditions with operators.

LANGUAGE: typescript
CODE:
// search by entity properties
const users = await orm.em.find(User, { firstName: 'John' });

// for searching by reference you can use primary key directly
const id = 1;
const users = await orm.em.find(User, { organization: id });

// or pass unpopulated reference (including `Reference` wrapper)
const ref = await orm.em.getReference(Organization, id);
const users = await orm.em.find(User, { organization: ref });

// fully populated entities as also supported
const ent = await orm.em.findOne(Organization, id);
const users = await orm.em.find(User, { organization: ent });

// complex queries with operators
const users = await orm.em.find(User, { $and: [{ id: { $nin: [3, 4] } }, { id: { $gt: 2 } }] });

// you can also search for array of primary keys directly
const users = await orm.em.find(User, [1, 2, 3, 4, 5]);

// and in findOne all of this works, plus you can search by single primary key
const user1 = await orm.em.findOne(User, 1);

----------------------------------------

TITLE: Demonstrating Identity Map in MikroORM
DESCRIPTION: Shows how MikroORM's identity map ensures the same entity instance is returned across multiple queries

LANGUAGE: typescript
CODE:
const authorRepository = em.getRepository(Author);
const jon = await authorRepository.findOne({ name: 'Jon Snow' }, { populate: ['books'] });
const authors = await authorRepository.findAll({ populate: ['books'] });

// identity map in action
console.log(jon === authors[0]); // true

----------------------------------------

TITLE: Upserting Multiple Books with MikroORM in TypeScript
DESCRIPTION: Demonstrates how to use em.upsertMany() to insert or update multiple Book entities, including cases with and without specified IDs.

LANGUAGE: typescript
CODE:
const books = await em.upsertMany(Book, [
  { id: 123, title: 'foo 1' },
  { title: 'foo 2' },
  { title: 'foo 3' },
]);

----------------------------------------

TITLE: Reference Kind Enum Definition in TypeScript
DESCRIPTION: Defines the available reference types for entity relationships in MikroORM, including scalar, one-to-one, many-to-one, one-to-many, many-to-many, and embedded relationships.

LANGUAGE: typescript
CODE:
enum ReferenceKind {
  SCALAR = 'scalar',
  ONE_TO_ONE = '1:1',
  MANY_TO_ONE = 'm:1',
  ONE_TO_MANY = '1:m',
  MANY_TO_MANY = 'm:n',
  EMBEDDED = 'embedded',
}

----------------------------------------

TITLE: Implementing Custom Connection Class in TypeScript
DESCRIPTION: Connection class implementation that handles database connectivity and query execution. This class manages database connections and provides methods for executing queries with different result types.

LANGUAGE: typescript
CODE:
import { Connection } from '@mikro-orm/core';

export class MyCustomConnection extends Connection {

  // implement abstract methods
  connect(): Promise<void>;
  isConnected(): Promise<boolean>;
  close(force?: boolean): Promise<void>;
  getDefaultClientUrl(): string;
  execute(query: string, params?: any[], method?: 'all' | 'get' | 'run'): Promise<QueryResult | any | any[]>;

}

----------------------------------------

TITLE: Creating Indexes on JSON Properties in MikroORM (TypeScript)
DESCRIPTION: Demonstrates how to create indexes on JSON properties using the @Index and @Unique decorators in MikroORM entities. The example shows both single and compound indexes on JSON fields.

LANGUAGE: typescript
CODE:
@Entity()
@Index({ properties: 'metaData.foo' })
@Index({ properties: ['metaData.foo', 'metaData.bar'] }) // compound index
@Unique({ properties: 'metaData.foo' })
@Unique({ properties: ['metaData.foo', 'metaData.bar'] }) // compound unique index
export class Book {

  @Property({ type: 'json', nullable: true })
  metaData?: { foo: string; bar: number };

}

----------------------------------------

TITLE: Express Authentication Configuration
DESCRIPTION: Configuration for adding authentication to AdminJS with Express, including email and password verification.

LANGUAGE: typescript
CODE:
const ADMIN_EMAIL = 'example@test.com';
const ADMIN_PASSWORD = 'password';

const router = AdminJSExpress.buildAuthenticatedRouter(admin, {
  authenticate: async (email, password) => {
    /* Your code for verifying email & password goes here */
    return email === ADMIN_EMAIL && password === ADMIN_PASSWORD
      ? { email } // the function should return an object containing user's data if authenticated successfully
      : null;
  },
  cookiePassword: process.env.COOKIE_PASSWORD ?? 'makesurepasswordissecure',
});

----------------------------------------

TITLE: CacheAdapter Interface Definition for MikroORM
DESCRIPTION: Interface definition for implementing custom cache adapters in MikroORM, including required methods for cache management.

LANGUAGE: typescript
CODE:
export interface CacheAdapter {

  /**
   * Gets the items under `name` key from the cache.
   */
  get(name: string): Promise<any>;

  /**
   * Sets the item to the cache. `origin` is used for cache invalidation and should reflect the change in data.
   */
  set(name: string, data: any, origin: string, expiration?: number): Promise<void>;

  /**
   * Clears all items stored in the cache.
   */
  clear(): Promise<void>;

  /**
   * Called inside `MikroORM.close()` Allows graceful shutdowns (e.g. for redis).
   */
  close?(): Promise<void>;

}

----------------------------------------

TITLE: Defining Entities in Multiple Schemas with MikroORM
DESCRIPTION: This snippet demonstrates how to define entities in different schemas using the @Entity decorator. It shows two methods: using the 'schema' option and specifying the schema in the 'tableName' option.

LANGUAGE: typescript
CODE:
@Entity({ schema: 'first_schema' })
export class Foo { ... }

// or alternatively we can specify it inside custom table name
@Entity({ tableName: 'second_schema.bar' })
export class Bar { ... }

----------------------------------------

TITLE: Using @Enum Decorator for Entity Enum Properties in TypeScript
DESCRIPTION: Examples of using the @Enum decorator to define enum properties in entities with different configurations.

LANGUAGE: typescript
CODE:
@Enum() // with ts-morph metadata provider we do not need to specify anything
enum0 = MyEnum1.VALUE_1;

@Enum(() => MyEnum1) // or @Enum({ items: () => MyEnum1 })
enum1 = MyEnum1.VALUE_1;

@Enum({ type: 'MyEnum2', nullable: true })
enum2?: MyEnum2; // MyEnum2 needs to be defined in current file (can be re-exported)

@Enum({ items: [1, 2, 3] })
enum3 = 3;

@Enum({ items: ['a', 'b', 'c'] })
enum4 = 'a';

----------------------------------------

TITLE: Using @Transactional Decorator in MikroORM with TypeScript
DESCRIPTION: This snippet shows how to use the @Transactional decorator to ensure a method runs within a transaction scope. It automatically handles transaction management, including commit and flush operations.

LANGUAGE: typescript
CODE:
export class MyService {

  @Transactional()
  async performTransactionalOperation() {
    // This method will run within a transaction scope
  }

}

----------------------------------------

TITLE: Defining SQL Virtual Entity with reflect-metadata
DESCRIPTION: Implementation of a virtual entity using SQL query expression with reflect-metadata decorator approach. Maps a complex SQL query that joins books with authors and tags to a virtual entity structure.

LANGUAGE: typescript
CODE:
@Entity({
  expression: 'select name, age, ' +
    '(select count(*) from book b where b.author_id = a.id) as total_books, ' +
    '(select group_concat(distinct t.name) from book b ' +
      'join tags_ordered bt on bt.book_id = b.id ' +
      'join book_tag t on t.id = bt.book_tag_id ' +
      'where b.author_id = a.id ' +
      'group by b.author_id) as used_tags ' +
    'from author a group by a.id',
})
export class BookWithAuthor {

  @Property()
  title!: string;

  @Property()
  authorName!: string;

  @Property()
  tags!: string[];

}

----------------------------------------

TITLE: Implementing Custom Date Type in TypeScript with MikroORM
DESCRIPTION: Implementation of a custom DateType class extending Type abstract class to handle date conversions between JavaScript Date objects and database string representations.

LANGUAGE: typescript
CODE:
import { Type, Platform, EntityProperty, ValidationError } from '@mikro-orm/core';

export class DateType extends Type<Date, string> {

  convertToDatabaseValue(value: Date | string | undefined, platform: Platform): string {
    if (value instanceof Date) {
      return value.toISOString().substr(0, 10);
    }

    if (!value || value.toString().match(/^\d{4}-\d{2}-\d{2}$/)) {
      return value as string;
    }

    throw ValidationError.invalidType(DateType, value, 'JS');
  }

  convertToJSValue(value: Date | string | undefined, platform: Platform): Date {
    if (!value || value instanceof Date) {
      return value as Date;
    }

    const date = new Date(value);

    if (date.toString() === 'Invalid Date') {
      throw ValidationError.invalidType(DateType, value, 'database');
    }

    return date;
  }

  getColumnType(prop: EntityProperty, platform: Platform) {
    return `date(${prop.length})`;
  }

}

----------------------------------------

TITLE: Deep Merging Object Properties with IEntity.assign() in TypeScript
DESCRIPTION: This snippet demonstrates how to enable deep merging of object properties when using IEntity.assign() by setting the mergeObjects flag.

LANGUAGE: typescript
CODE:
book.meta = { foo: 1, bar: 2 };

book.assign({ meta: { foo: 3 } }, { mergeObjects: true });
console.log(book.meta); // { foo: 3, bar: 2 }

book.assign({ meta: { foo: 4 } });
console.log(book.meta); // { foo: 4 }

----------------------------------------

TITLE: Processing Generated Metadata
DESCRIPTION: Example of using onInitialMetadata and onProcessedMetadata hooks to customize generated entities.

LANGUAGE: typescript
CODE:
import { ReferenceKind, MikroORM } from '@mikro-orm/core';

const orm = await MikroORM.init({
  // ORM config
});

await orm.entityGenerator.generate({
  onInitialMetadata: (metadata, platform) => {
    metadata.forEach(meta => {
      meta.props.forEach(prop => {
        if (prop.name === 'password') {
          prop.hidden = true;
          prop.lazy = true;
        }
      });
    });
  },
  onProcessedMetadata: (metadata, platform) => {
    metadata.forEach(meta => {
      meta.props.forEach(prop => {
        if (prop.kind === ReferenceKind.MANY_TO_MANY) {
          prop.hidden = true;
        }
      });
    });
  },
});

----------------------------------------

TITLE: Demonstrating Identity Map in MikroORM
DESCRIPTION: Shows how MikroORM's identity map ensures the same entity instance is returned across multiple queries

LANGUAGE: typescript
CODE:
const authorRepository = em.getRepository(Author);
const jon = await authorRepository.findOne({ name: 'Jon Snow' }, { populate: ['books'] });
const authors = await authorRepository.findAll({ populate: ['books'] });

// identity map in action
console.log(jon === authors[0]); // true

----------------------------------------

TITLE: Querying Entities with Default Joined Strategy in MikroORM
DESCRIPTION: This snippet shows how to query an Author entity and populate its books relation using the default 'joined' strategy in MikroORM.

LANGUAGE: typescript
CODE:
const author = await orm.em.findOne(Author, 1, {
  populate: ['books'],
});

----------------------------------------

TITLE: Creating Base Entity Class
DESCRIPTION: Implements an abstract base entity class with common properties for reuse across entities.

LANGUAGE: typescript
CODE:
import { PrimaryKey, Property } from '@mikro-orm/core';

export abstract class BaseEntity {

  @PrimaryKey()
  id!: number;

  @Property()
  createdAt = new Date();

  @Property({ onUpdate: () => new Date() })
  updatedAt = new Date();

}

----------------------------------------

TITLE: Generated SQL for Typed JSON Property Index (MySQL)
DESCRIPTION: Displays the SQL query generated to create a typed index on a JSON property in MySQL. The example shows how the JSON_VALUE function is used with a specified return type.

LANGUAGE: sql
CODE:
alter table `book`
  add index `book_meta_data_foo_index`((json_value(`meta_data`, '$.foo' returning char(200))));

----------------------------------------

TITLE: Installing MikroORM Dependencies for SQL Databases
DESCRIPTION: Commands for installing MikroORM core and database-specific packages using yarn or npm.

LANGUAGE: shell
CODE:
yarn add @mikro-orm/core @mikro-orm/mongodb     # for mongo
yarn add @mikro-orm/core @mikro-orm/mysql       # for mysql/mariadb
yarn add @mikro-orm/core @mikro-orm/mariadb     # for mysql/mariadb
yarn add @mikro-orm/core @mikro-orm/postgresql  # for postgresql
yarn add @mikro-orm/core @mikro-orm/sqlite      # for sqlite

LANGUAGE: shell
CODE:
npm i -s @mikro-orm/core @mikro-orm/mongodb     # for mongo
npm i -s @mikro-orm/core @mikro-orm/mysql       # for mysql/mariadb
npm i -s @mikro-orm/core @mikro-orm/mariadb     # for mysql/mariadb
npm i -s @mikro-orm/core @mikro-orm/postgresql  # for postgresql
npm i -s @mikro-orm/core @mikro-orm/sqlite      # for sqlite

----------------------------------------

TITLE: Configuring Entity Discovery in MikroORM v4
DESCRIPTION: Illustrates the new way of configuring entity discovery using the 'entities' and 'entitiesTs' options, which can include a mixture of paths, globs, and entity references.

LANGUAGE: typescript
CODE:
MikroORM.init({
  entities: ['dist/**/entities', 'dist/**/*.entity.js', FooBar, FooBaz],
  entitiesTs: ['src/**/entities', 'src/**/*.entity.ts', FooBar, FooBaz],
});

----------------------------------------

TITLE: Custom Entity Class Definition with Schema
DESCRIPTION: Shows how to define a custom Author entity class with its corresponding schema configuration, including various property types and relationships.

LANGUAGE: typescript
CODE:
export class Author extends CustomBaseEntity {
  name: string;
  email: string;
  age?: number;
  termsAccepted?: boolean;
  identities?: string[];
  born?: string;
  books = new Collection<Book>(this);
  favouriteBook?: Book;
  version?: number;

  constructor(name: string, email: string) {
    super();
    this.name = name;
    this.email = email;
  }
}

export const schema = new EntitySchema<Author, CustomBaseEntity>({
  class: Author,
  extends: CustomBaseEntitySchema,
  properties: {
    name: { type: 'string' },
    email: { type: 'string', unique: true },
    age: { type: 'number', nullable: true },
    termsAccepted: { type: 'boolean', default: 0, onCreate: () => false },
    identities: { type: 'string[]', nullable: true },
    born: { type: DateType, nullable: true, length: 3 },
    books: { kind: '1:m', entity: () => 'Book', mappedBy: book => book.author },
    favouriteBook: { kind: 'm:1', type: 'Book' },
    version: { type: 'number', persist: false },
  },
});

----------------------------------------

TITLE: Installing MikroORM Dependencies for SQL Databases
DESCRIPTION: Commands for installing MikroORM core and database-specific packages using yarn or npm.

LANGUAGE: shell
CODE:
yarn add @mikro-orm/core @mikro-orm/mongodb     # for mongo
yarn add @mikro-orm/core @mikro-orm/mysql       # for mysql/mariadb
yarn add @mikro-orm/core @mikro-orm/mariadb     # for mysql/mariadb
yarn add @mikro-orm/core @mikro-orm/postgresql  # for postgresql
yarn add @mikro-orm/core @mikro-orm/sqlite      # for sqlite

LANGUAGE: shell
CODE:
npm i -s @mikro-orm/core @mikro-orm/mongodb     # for mongo
npm i -s @mikro-orm/core @mikro-orm/mysql       # for mysql/mariadb
npm i -s @mikro-orm/core @mikro-orm/mariadb     # for mysql/mariadb
npm i -s @mikro-orm/core @mikro-orm/postgresql  # for postgresql
npm i -s @mikro-orm/core @mikro-orm/sqlite      # for sqlite

----------------------------------------

TITLE: Implementing MongoDB Migration in TypeScript
DESCRIPTION: Example of creating a migration class for MongoDB using @mikro-orm/migrations-mongodb package.

LANGUAGE: typescript
CODE:
import { Migration } from '@mikro-orm/migrations-mongodb';

export class MigrationTest1 extends Migration {

  async up(): Promise<void> {
    // use `this.getCollection()` to work with the mongodb collection directly
    await this.getCollection('Book').updateMany({}, { $set: { updatedAt: new Date() } }, { session: this.ctx });

    // or use `this.driver` to work with the `MongoDriver` API instead
    await this.driver.nativeDelete('Book', { foo: true }, { ctx: this.ctx });
  }

}

----------------------------------------

TITLE: Configuring Custom Cache Directory
DESCRIPTION: Shows how to specify a custom directory for storing MikroORM's metadata cache files.

LANGUAGE: typescript
CODE:
await MikroORM.init({
  cache: { options: { cacheDir: '...' } },
  // ...
});

----------------------------------------

TITLE: Creating Initial MySQL Schema for Blog Application
DESCRIPTION: SQL script to create the initial database schema for the blog application, including tables for users, articles, comments, and tags.

LANGUAGE: sql
CODE:
-- MySQL Workbench Forward Engineering

SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0;
SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0;
SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION';

-- -----------------------------------------------------
-- Schema blog
-- -----------------------------------------------------

-- -----------------------------------------------------
-- Schema blog
-- -----------------------------------------------------
CREATE SCHEMA IF NOT EXISTS `blog` DEFAULT CHARACTER SET utf8 ;
USE `blog` ;

-- -----------------------------------------------------
-- Table `user`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `user` (
  `id` INT UNSIGNED NOT NULL AUTO_INCREMENT,
  `created_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  `full_name` VARCHAR(255) NOT NULL,
  `email` VARCHAR(255) NOT NULL,
  `password` VARCHAR(255) NOT NULL,
  `bio` TEXT NOT NULL,
  PRIMARY KEY (`id`))
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `article`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `article` (
  `id` INT UNSIGNED NOT NULL AUTO_INCREMENT,
  `created_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  `slug` VARCHAR(255) NOT NULL,
  `title` VARCHAR(255) NOT NULL,
  `description` VARCHAR(1000) NOT NULL,
  `text` TEXT NOT NULL,
  `author` INT UNSIGNED NOT NULL,
  PRIMARY KEY (`id`),
  UNIQUE INDEX `slug_UNIQUE` (`slug` ASC) VISIBLE,
  INDEX `fk_article_user1_idx` (`author` ASC) VISIBLE,
  CONSTRAINT `fk_article_user1`
    FOREIGN KEY (`author`)
    REFERENCES `user` (`id`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `comment`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `comment` (
  `id` INT UNSIGNED NOT NULL AUTO_INCREMENT,
  `created_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  `text` VARCHAR(1000) NOT NULL,
  `article` INT UNSIGNED NOT NULL,
  `author` INT UNSIGNED NOT NULL,
  PRIMARY KEY (`id`),
  INDEX `fk_comment_article1_idx` (`article` ASC) VISIBLE,
  INDEX `fk_comment_user1_idx` (`author` ASC) VISIBLE,
  CONSTRAINT `fk_comment_article1`
    FOREIGN KEY (`article`)
    REFERENCES `article` (`id`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_comment_user1`
    FOREIGN KEY (`author`)
    REFERENCES `user` (`id`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `tag`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `tag` (
  `id` INT UNSIGNED NOT NULL AUTO_INCREMENT,
  `created_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  `name` VARCHAR(20) NOT NULL,
  PRIMARY KEY (`id`))
ENGINE = InnoDB;


-- -----------------------------------------------------
-- Table `article_tag`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `article_tag` (
  `article_id` INT UNSIGNED NOT NULL,
  `tag_id` INT UNSIGNED NOT NULL,
  PRIMARY KEY (`article_id`, `tag_id`),
  INDEX `fk_article_tag_tag1_idx` (`tag_id` ASC) VISIBLE,
  CONSTRAINT `fk_article_tag_article1`
    FOREIGN KEY (`article_id`)
    REFERENCES `article` (`id`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION,
  CONSTRAINT `fk_article_tag_tag1`
    FOREIGN KEY (`tag_id`)
    REFERENCES `tag` (`id`)
    ON DELETE NO ACTION
    ON UPDATE NO ACTION)
ENGINE = InnoDB;


SET SQL_MODE=@OLD_SQL_MODE;
SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS;
SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS;

----------------------------------------

TITLE: Custom AsyncLocalStorage with MikroORM (TypeScript)
DESCRIPTION: This snippet shows how to use a custom AsyncLocalStorage instance with MikroORM for managing request contexts.

LANGUAGE: typescript
CODE:
const storage = new AsyncLocalStorage<EntityManager>();

const orm = await MikroORM.init({
  context: () => storage.getStore(),
  // ...
});

app.use((req, res, next) => {
  storage.run(orm.em.fork({ useContext: true }), next);
});

----------------------------------------

TITLE: Defining OneToMany Relationships in MikroORM with TypeScript
DESCRIPTION: Shows how to define OneToMany relationships in MikroORM using TypeScript decorators. Demonstrates the connection between ManyToOne and OneToMany relationships and different ways to specify the relationship.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @PrimaryKey()
  _id!: ObjectId;

  @ManyToOne()
  author!: Author;

}

@Entity()
export class Author {

  @PrimaryKey()
  _id!: ObjectId;

  @OneToMany(() => Book, book => book.author)
  books1 = new Collection<Book>(this);

  // or via options object
  @OneToMany({ entity: () => Book, mappedBy: 'author' })
  books2 = new Collection<Book>(this);

}

----------------------------------------

TITLE: SQL Now Function for DateTime Defaults
DESCRIPTION: Demonstrates using sql.now() function for setting default values on datetime columns.

LANGUAGE: typescript
CODE:
@Property({ default: sql.now() })
createdAt: Date & Opt;

----------------------------------------

TITLE: Defining Entity using Decorators in TypeScript
DESCRIPTION: Example of defining a Book entity using class decorators with various property types and relationships.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @PrimaryKey()
  id!: number;

  @Property()
  createdAt = new Date();

  @Property({ onUpdate: () => new Date() })
  updatedAt = new Date();

  @Property()
  title!: string;

  @ManyToOne()
  author!: Author;

  @ManyToOne(() => Publisher)
  publisher?: Publisher;

  @ManyToMany()
  tags = new Collection<BookTag>(this);

  constructor(title: string, author: Author) {
    this.title = title;
    this.author = author;
  }

}

----------------------------------------

TITLE: Initializing MikroORM with Read Replica Connections in TypeScript
DESCRIPTION: This snippet demonstrates how to initialize MikroORM with multiple read replica connections. It shows the configuration of master and read replica connections, including the optional 'preferReadReplicas' property.

LANGUAGE: typescript
CODE:
const orm = await MikroORM.init({
  entities: [Author, ...],
  dbName: `my_database`,
  user: 'master_user',
  host: 'master_host',
  preferReadReplicas: true, // optional property, defaults to true
  replicas: [
    { name: 'read-1', host: 'read_host_1', user: 'read_user' },
    { name: 'read-2', host: 'read_host_2' }, // user omitted, will be taken from master connection
  ],
});

----------------------------------------

TITLE: Registering Global Filters in MikroORM
DESCRIPTION: Shows how to register global filters using the EntityManager API. Demonstrates entity-bound and global filters, as well as setting filter parameters.

LANGUAGE: typescript
CODE:
// bound to entity, enabled by default
em.addFilter('writtenBy', args => ({ author: args.id }), Book);

// global, enabled by default, for all entities
em.addFilter('tenant', args => { ... });

// global, enabled by default, for only specified entities
em.addFilter('tenant', args => { ... }, [Author, Book]);
...

// set params (probably in some middleware)
em.setFilterParams('tenant', { tenantId: 123 });
em.setFilterParams('writtenBy', { id: 321 });

----------------------------------------

TITLE: Polymorphic Embeddables with Animal Types
DESCRIPTION: Implements polymorphic embeddables using discriminator columns to handle different animal types (Cat and Dog) within an Owner entity.

LANGUAGE: typescript
CODE:
import { Embeddable, Embedded, Entity, Enum, PrimaryKey, Property } from '@mikro-orm/core';

export enum AnimalType {
  CAT,
  DOG,
}

@Embeddable({ abstract: true, discriminatorColumn: 'type' })
export abstract class Animal {

  @Enum(() => AnimalType)
  type!: AnimalType;

  @Property()
  name!: string;

}

@Embeddable({ discriminatorValue: AnimalType.CAT })
export class Cat extends Animal {

  @Property({ nullable: true })
  canMeow?: boolean = true;

  constructor(name: string) {
    super();
    this.type = AnimalType.CAT;
    this.name = name;
  }

}

@Embeddable({ discriminatorValue: AnimalType.DOG })
export class Dog extends Animal {

  @Property({ nullable: true })
  canBark?: boolean = true;

  constructor(name: string) {
    super();
    this.type = AnimalType.DOG;
    this.name = name;
  }

}

@Entity()
export class Owner {

  @PrimaryKey()
  id!: number;

  @Property()
  name!: string;

  @Embedded(() => [Cat, Dog])
  pet!: Cat | Dog;

}

----------------------------------------

TITLE: SQL Query for Upserting Books
DESCRIPTION: SQL representation of the upsert operation for books, demonstrating the use of 'default' for unspecified IDs and conflict resolution.

LANGUAGE: sql
CODE:
insert into "book" ("id", "title")
values
  (123, 'foo 1'),
  (default, 'foo 2'),
  (default, 'foo 3') 
on conflict ("id") 
  do update set "title" = excluded."title" 
returning "id"

----------------------------------------

TITLE: Installing MikroORM Database Drivers
DESCRIPTION: Commands for installing MikroORM core and specific database drivers including MongoDB, MySQL, PostgreSQL, SQLite and others.

LANGUAGE: bash
CODE:
npm install @mikro-orm/core @mikro-orm/mongodb
npm install @mikro-orm/core @mikro-orm/mysql
npm install @mikro-orm/core @mikro-orm/mariadb
npm install @mikro-orm/core @mikro-orm/postgresql
npm install @mikro-orm/core @mikro-orm/sqlite
npm install @mikro-orm/core @mikro-orm/better-sqlite
npm install @mikro-orm/core @mikro-orm/libsql
npm install @mikro-orm/core @mikro-orm/mssql

----------------------------------------

TITLE: Defining Explicitly Null Property in MikroORM
DESCRIPTION: This code shows how to define a property that can be explicitly null in MikroORM. It uses the @Property decorator with type specification and initializes the property to null.

LANGUAGE: typescript
CODE:
@Property({ type: 'string', nullable: true })
name: string | null = null;

----------------------------------------

TITLE: Importing Migrations Statically in TypeScript
DESCRIPTION: Example of importing migrations statically and configuring MikroORM to use the imported migrations.

LANGUAGE: typescript
CODE:
import { MikroORM } from '@mikro-orm/core';
import { Migration20191019195930 } from '../migrations/Migration20191019195930.ts';

await MikroORM.init({
  migrations: {
    migrationsList: [
      {
        name: 'Migration20191019195930.ts',
        class: Migration20191019195930,
      },
    ],
  },
});

----------------------------------------

TITLE: Shadow Properties Implementation
DESCRIPTION: Example of implementing non-persisted shadow properties using persist: false option.

LANGUAGE: typescript
CODE:
@Entity()
class Book {

  @Property({ persist: false })
  count?: number;

}

----------------------------------------

TITLE: Implementing User Authentication Routes
DESCRIPTION: Implementation of user sign-up and sign-in routes with JWT authentication and password validation

LANGUAGE: typescript
CODE:
export async function registerUserRoutes(app: FastifyInstance) {
  const db = await initORM();

  app.post('/sign-up', async request => {
    const body = request.body as EntityData<User>;
    if (!body.email || !body.fullName || !body.password) {
      throw new Error('One of required fields is missing');
    }
    const user = new User(body.fullName, body.email, body.password);
    await db.em.persist(user).flush();
    return user;
  });

  app.post('/sign-in', async request => {
    const { email, password } = request.body as { email: string; password: string };
    const user = await db.user.login(email, password);
    return user;
  });
}

----------------------------------------

TITLE: Installing EntityGenerator Package
DESCRIPTION: Command to install the EntityGenerator package via npm/yarn

LANGUAGE: bash
CODE:
npm install @mikro-orm/entity-generator

----------------------------------------

TITLE: Hapi Authentication Configuration
DESCRIPTION: Configuration example for adding authentication to AdminJS with Hapi, including authentication strategy and cookie settings.

LANGUAGE: typescript
CODE:
const ADMIN_EMAIL = 'example@test.com';
const ADMIN_PASSWORD = 'password';

const adminOptions = {
  databases: [orm],
  auth: {
    authenticate: async (email, password) => {
      /* Your code for verifying email & password goes here */
      return email === ADMIN_EMAIL && password === ADMIN_PASSWORD
        ? { email } // the function should return an object containing user's data if authenticated successfully
        : null;
    },
    strategy: 'session',
    cookiePassword: process.env.COOKIE_PASSWORD ?? 'makesurepasswordissecure',
    isSecure: false, // only https requests
  },
};

----------------------------------------

TITLE: Implementing Article Routes Registration
DESCRIPTION: Factory function for registering article routes with pagination support using MikroORM's findAndCount method

LANGUAGE: typescript
CODE:
export async function registerArticleRoutes(app: FastifyInstance) {
  const db = await initORM();

  app.get('/', async request => {
    const { limit, offset } = request.query as { limit?: number; offset?: number };
    const [items, total] = await db.article.findAndCount({}, {
      limit, offset,
    });

    return { items, total };
  });
}

----------------------------------------

TITLE: Registering Event Subscribers in MikroORM Configuration
DESCRIPTION: Example showing how to register event subscribers in MikroORM initialization configuration.

LANGUAGE: typescript
CODE:
MikroORM.init({
  subscribers: [new AuthorSubscriber()],
});

----------------------------------------

TITLE: Order Management System with Composite Keys
DESCRIPTION: Implements a complex order management system using composite keys. Shows relationships between Order, Product, and OrderItem entities with metadata in the join table.

LANGUAGE: typescript
CODE:
@Entity()
export class Order {

  @PrimaryKey()
  id!: number;

  @ManyToOne()
  customer: Customer;

  @OneToMany(() => OrderItem, item => item.order)
  items = new Collection<OrderItem>(this);

  @Property()
  paid = false;

  @Property()
  shipped = false;

  @Property()
  created = new Date();

  constructor(customer: Customer) {
    this.customer = customer;
  }

}

@Entity()
export class Product {

  @PrimaryKey()
  id!: number;

  @Property()
  name!: string;

  @Property()
  currentPrice!: number;

}

@Entity()
export class OrderItem {

  @ManyToOne({ primary: true })
  order: Order;

  @ManyToOne({ primary: true })
  product: Product;

  @Property()
  amount = 1;

  @Property()
  offeredPrice: number;

  [PrimaryKeyProp]?: ['order', 'product'];

  constructor(order: Order, product: Product, amount = 1) {
    this.order = order;
    this.product = product;
    this.offeredPrice = product.currentPrice;
  }

}

----------------------------------------

TITLE: Implementing Custom Connection Class in TypeScript
DESCRIPTION: Connection class that handles database connectivity and query execution. It manages database connection lifecycle and provides methods for executing queries.

LANGUAGE: typescript
CODE:
import { Connection } from '@mikro-orm/core';

export class MyCustomConnection extends Connection {

  // implement abstract methods
  connect(): Promise<void>;
  isConnected(): Promise<boolean>;
  close(force?: boolean): Promise<void>;
  getDefaultClientUrl(): string;
  execute(query: string, params?: any[], method?: 'all' | 'get' | 'run'): Promise<QueryResult | any | any[]>;

}

----------------------------------------

TITLE: Installing MikroORM SQL Driver Packages
DESCRIPTION: Commands to install MikroORM core and specific SQL driver packages for different databases.

LANGUAGE: bash
CODE:
# for mongodb
npm install @mikro-orm/core @mikro-orm/mongodb

# for mysql (works with mariadb too)
npm install @mikro-orm/core @mikro-orm/mysql

# for mariadb (works with mysql too)
npm install @mikro-orm/core @mikro-orm/mariadb

# for postgresql (works with cockroachdb too)
npm install @mikro-orm/core @mikro-orm/postgresql

# for sqlite
npm install @mikro-orm/core @mikro-orm/sqlite

# for better-sqlite
npm install @mikro-orm/core @mikro-orm/better-sqlite

# for libsql/turso
npm install @mikro-orm/core @mikro-orm/libsql

# for mssql
npm install @mikro-orm/core @mikro-orm/mssql

----------------------------------------

TITLE: Using discriminatorValue in Single Table Inheritance with MikroORM
DESCRIPTION: This example shows how to use the discriminatorValue property instead of discriminatorMap in Single Table Inheritance. It allows for more control over the tokens used in the automatically generated discriminator map.

LANGUAGE: typescript
CODE:
@Entity({
  discriminatorColumn: 'discr',
  discriminatorValue: 'person',
})
export class Person {
  // ...
}

@Entity({
  discriminatorValue: 'employee',
})
export class Employee extends Person {
  // ...
}

----------------------------------------

TITLE: Explicit Discriminator Column for Single Table Inheritance in TypeScript
DESCRIPTION: This example demonstrates how to define an explicit discriminator column for Single Table Inheritance. It uses an abstract base class and defines the discriminator as an enum property.

LANGUAGE: typescript
CODE:
@Entity({
  discriminatorColumn: 'type',
  discriminatorMap: { person: 'Person', employee: 'Employee' },
})
export abstract class BasePerson {

  @Enum()
  type!: 'person' | 'employee';

}

@Entity()
export class Person extends BasePerson {
  // ...
}

@Entity()
export class Employee extends Person {
  // ...
}

----------------------------------------

TITLE: Initializing MikroORM with PostgreSQL Driver
DESCRIPTION: Example of initializing MikroORM with PostgreSQL driver, specifying entities and database name.

LANGUAGE: typescript
CODE:
import type { PostgreSqlDriver } from '@mikro-orm/postgresql'; // or any other SQL driver package

const orm = await MikroORM.init<PostgreSqlDriver>({
  entities: ['./dist/entities'], // path to your JS entities (dist), relative to `baseDir`
  dbName: 'my-db-name',
  type: 'postgresql',
});
console.log(orm.em); // access EntityManager via `em` property

----------------------------------------

TITLE: Creating Indexes on JSON Properties in MikroORM Entity
DESCRIPTION: This snippet demonstrates how to create indexes on JSON properties in a MikroORM entity. It shows both single and compound indexes using the @Index decorator, as well as unique indexes using the @Unique decorator.

LANGUAGE: typescript
CODE:
@Entity()
@Index({ properties: 'metaData.foo' })
@Index({ properties: ['metaData.foo', 'metaData.bar'] }) // compound index
@Unique({ properties: 'metaData.foo' })
@Unique({ properties: ['metaData.foo', 'metaData.bar'] }) // compound unique index
export class Book {

  @Property({ type: 'json', nullable: true })
  metaData?: { foo: string; bar: number };

}

----------------------------------------

TITLE: Configuring Global assign() Options in TypeScript
DESCRIPTION: Demonstrates how to configure global options for the assign() method in MikroORM initialization.

LANGUAGE: typescript
CODE:
await MikroORM.init({
  // default values:
  assign: {
    updateNestedEntities: true,
    updateByPrimaryKey: true,
    mergeObjectProperties: false,
    mergeEmbeddedProperties: true,
  },
});

----------------------------------------

TITLE: Implementing Custom Platform Class in TypeScript
DESCRIPTION: Platform class that defines database feature capabilities and configuration. It handles primary key normalization, naming strategies, and other database-specific features.

LANGUAGE: typescript
CODE:
import { Platform } from '@mikro-orm/core';

export class MyCustomPlatform extends Platform {

  protected abstract schemaHelper: MyCustomSchemaHelper;

  // here you can override default settings
  usesPivotTable(): boolean;
  supportsTransactions(): boolean;
  supportsSavePoints(): boolean;
  getNamingStrategy(): { new (): NamingStrategy; };
  getIdentifierQuoteCharacter(): string;
  getParameterPlaceholder(index?: number): string;
  usesReturningStatement(): boolean;
  normalizePrimaryKey<T = number | string>(data: IPrimaryKey): T;
  denormalizePrimaryKey(data: IPrimaryKey): IPrimaryKey;
  getSerializedPrimaryKeyField(field: string): string;

}

----------------------------------------

TITLE: Installing EntityGenerator Package for MikroORM
DESCRIPTION: Command to install the EntityGenerator package for MikroORM. The version should align with @mikro-orm/core and the database driver package.

LANGUAGE: bash
CODE:
npm install @mikro-orm/entity-generator

----------------------------------------

TITLE: Generating Entities using MikroORM Script
DESCRIPTION: TypeScript script to initialize MikroORM and use EntityGenerator to generate and save entities programmatically.

LANGUAGE: typescript
CODE:
import { MikroORM } from '@mikro-orm/core';
import { EntityGenerator } from '@mikro-orm/entity-generator';

(async () => {
  const orm = await MikroORM.init({
    discovery: {
      // we need to disable validation for no entities
      warnWhenNoEntities: false,
      extensions: [EntityGenerator],
    },
    dbName: 'your-db-name',
    // ...
  });
  const dump = await orm.entityGenerator.generate({
    save: true,
    path: process.cwd() + '/my-entities',
  });
  console.log(dump);
  await orm.close(true);
})();

----------------------------------------

TITLE: Accessing QueryBuilder in MikroORM with TypeScript
DESCRIPTION: This snippet demonstrates how to properly import and use the EntityManager to access the createQueryBuilder method in a TypeScript environment.

LANGUAGE: ts
CODE:
import { EntityManager } from '@mikro-orm/mysql'; // or any other SQL driver package

const em = orm.em as EntityManager;
const qb = await em.createQueryBuilder(...);

----------------------------------------

TITLE: Applying Filters to Multiple Entities in MikroORM
DESCRIPTION: Shows how filters with the same name on different entities are controlled via a single toggle in FindOptions, affecting multiple entities in a single query.

LANGUAGE: typescript
CODE:
@Entity()
@Filter({ name: 'tenant', cond: args => ({ tenant: args.tenant }) })
export class Author {
  ...
}

@Entity()
@Filter({ name: 'tenant', cond: args => ({ tenant: args.tenant }) })
export class Book {
  ...
}

// this will apply the tenant filter to both Author and Book entities (with SELECT_IN loading strategy)
const authors = await orm.em.find(Author, {}, {
  populate: ['books'],
  filters: { tenant: 123 },
});

----------------------------------------

TITLE: Creating Custom Driver Class for MikroORM in TypeScript
DESCRIPTION: This code demonstrates how to implement a custom Driver class by extending the DatabaseDriver class from MikroORM. It includes methods for database operations such as find, insert, update, and delete.

LANGUAGE: typescript
CODE:
import { DatabaseDriver } from '@mikro-orm/core';

export class MyCustomDriver extends DatabaseDriver {

  // initialize connection and platform
  protected readonly connection = new MyCustomConnection(this.config);
  protected readonly platform = new MyCustomPlatform;

  // and implement abstract methods
  find<T extends AnyEntity>(entityName: string, where: FilterQuery<T>, populate?: string[], orderBy?: Record<string, QueryOrder>, limit?: number, offset?: number): Promise<T[]>;
  findOne<T extends AnyEntity>(entityName: string, where: FilterQuery<T> | string, populate: string[]): Promise<T | null>;
  nativeInsert<T extends AnyEntityType<T>>(entityName: string, data: EntityData<T>): Promise<QueryResult>;
  nativeUpdate<T extends AnyEntity>(entityName: string, where: FilterQuery<T> | IPrimaryKey, data: EntityData<T>): Promise<QueryResult>;
  nativeDelete<T extends AnyEntity>(entityName: string, where: FilterQuery<T> | IPrimaryKey): Promise<QueryResult>;
  count<T extends AnyEntity>(entityName: string, where: FilterQuery<T>): Promise<number>;

}

----------------------------------------

TITLE: Demonstrating Collection.add() Propagation in One-to-Many Relation
DESCRIPTION: This snippet illustrates how using the Collection.add() method propagates changes in a one-to-many relation. It creates an author and a book, adds the book to the author's books collection, and then checks if the author is set on the book.

LANGUAGE: typescript
CODE:
// one to many
const author = new Author(...);
const book = new Book(...);

author.books.add(book);
console.log(book.author); // author will be set thanks to the propagation

----------------------------------------

TITLE: Configuring Auto-Flush Behavior in MikroORM
DESCRIPTION: Shows how to configure automatic flushing behavior when initializing MikroORM instance.

LANGUAGE: typescript
CODE:
const orm = await MikroORM.init({
  autoFlush: false,
  // ...
});
await orm.em.persist(new Entity()); // no auto-flushing now
await orm.em.flush();
await orm.em.persist(new Entity(), true); // you can still use second parameter to auto-flush

----------------------------------------

TITLE: Entity Definition with @Entity Decorator
DESCRIPTION: Example of defining an entity class using @Entity decorator to specify table name and other options

LANGUAGE: typescript
CODE:
@Entity({ tableName: 'authors' })
export class Author { ... }

----------------------------------------

TITLE: Implementing Shadow Properties in Entities
DESCRIPTION: Example of creating non-persisted shadow properties using persist: false flag, useful for temporary data storage.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @Property({ persist: false })
  count?: number;

}

const book = new Book(...);
book.assign({ count: 123 });
console.log(book.toObject().count); // 123
console.log(book.toJSON().count); // 123

----------------------------------------

TITLE: Using Optimistic Locking with findOne() in MikroORM
DESCRIPTION: Demonstrates how to use optimistic locking when fetching an entity with findOne() in MikroORM. This ensures that the entity hasn't been modified since it was last read.

LANGUAGE: typescript
CODE:
const theEntityId = 1;
const expectedVersion = 184;

try {
  const entity = await orm.em.findOne(User, theEntityId, { lockMode: LockMode.OPTIMISTIC, lockVersion: expectedVersion });

  // do the work

  await orm.em.flush();
} catch (e) {
  console.log('Sorry, but someone else has already changed this entity. Please apply the changes again!');
}

----------------------------------------

TITLE: Initializing and Querying Collections in TypeScript with MikroORM
DESCRIPTION: Demonstrates how to initialize, iterate, and query Collections in MikroORM. It shows various methods like getItems(), toArray(), and using array access syntax.

LANGUAGE: typescript
CODE:
const author = em.findOne(Author, '...', { populate: ['books'] }); // populating books collection

// or we could lazy load books collection later via `init()` method
await author.books.init();

for (const book of author.books) {
  console.log(book.title); // initialized
  console.log(book.author.isInitialized()); // true
  console.log(book.author.id);
  console.log(book.author.name); // Jon Snow
  console.log(book.publisher); // just reference
  console.log(book.publisher.isInitialized()); // false
  console.log(book.publisher.id);
  console.log(book.publisher.name); // undefined
}

// collection needs to be initialized before we can work with it
author.books.add(book);
console.log(author.books.contains(book)); // true
console.log(author.books.exists(item => item === book)); // true
console.log(author.books.find(item => item === book)); // book
console.log(author.books.map(item => item.title)); // array of book titles
console.log(author.books.filter(item => item.title.startsWith('Foo'))); // array of books matching the callback
author.books.remove(book);
console.log(author.books.contains(book)); // false
author.books.add(book);
console.log(author.books.count()); // 1
console.log(author.books.slice(0, 1)); // Book[]
console.log(author.books.slice()); // Book[]
console.log(author.books.slice().length); // 1
author.books.removeAll();
console.log(author.books.isEmpty()); // true
console.log(author.books.contains(book)); // false
console.log(author.books.count()); // 0
console.log(author.books.getItems()); // Book[]
console.log(author.books.getIdentifiers()); // array of string | number
console.log(author.books.getIdentifiers('_id')); // array of ObjectId

// array access works as well
console.log(author.books[1]); // Book
console.log(author.books[12345]); // undefined, even if the collection is not initialized

// getting array of the items
console.log(author.books.getItems()); // Book[]

// serializing the collection
console.log(author.books.toArray()); // EntityDTO<Book>[]

const author = em.findOne(Author, '...'); // books collection has not been populated
const count = await author.books.loadCount(); // gets the count of collection items from database instead of counting loaded items
console.log(author.books.getItems()); // throws because the collection has not been initialized
// initialize collection if not already loaded and return its items as array
console.log(await author.books.loadItems()); // Book[]

----------------------------------------

TITLE: Querying Entities with EntityManager
DESCRIPTION: Example of fetching entities and navigating relationships using EntityManager

LANGUAGE: typescript
CODE:
const authors = orm.em.find(Author, {});

for (const author of authors) {
  console.log(author); // instance of Author entity
  console.log(author.name); // Jon Snow

  for (const book of author.books) { // iterating books collection
    console.log(book); // instance of Book entity
    console.log(book.title); // My Life on The Wall, part 1/2/3
  }
}

----------------------------------------

TITLE: MongoDB Query Generation for Nested Population
DESCRIPTION: Demonstrates the MongoDB queries generated when populating nested relations without pivot tables.

LANGUAGE: typescript
CODE:
db.getCollection("book-tag").find({}).toArray();
db.getCollection("book").find({"tags":{"$in":[...]}}).toArray();
db.getCollection("publisher").find({"_id":{"$in":[...]}}).toArray();
db.getCollection("test").find({"_id":{"$in":[...]}}).toArray();
db.getCollection("author").find({"_id":{"$in":[...]}}).toArray();

----------------------------------------

TITLE: Configuring Hidden Properties in Entities
DESCRIPTION: Demonstration of using the hidden flag in Property decorator to omit properties from serialization.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @Property({ hidden: true })
  hiddenField = Date.now();

}

const book = new Book(...);
console.log(wrap(book).toObject().hiddenField); // undefined
console.log(wrap(book).toJSON().hiddenField); // undefined

----------------------------------------

TITLE: Implementing Timestamp Properties in User Entity
DESCRIPTION: Adds created and updated timestamp properties to track entity changes using MikroORM decorators.

LANGUAGE: typescript
CODE:
@Property()
createdAt = new Date();

@Property({ onUpdate: () => new Date() })
updatedAt = new Date();

----------------------------------------

TITLE: Generated SQL Query for JSON Property Filtering (PostgreSQL)
DESCRIPTION: Displays the SQL query generated by MikroORM when querying JSON properties in PostgreSQL. The query demonstrates how nested JSON properties are accessed and compared.

LANGUAGE: sql
CODE:
select "e0".*
from "book" as "e0"
where ("meta"->>'valid')::bool = true
  and "meta"->'nested'->>'foo' = '123'
  and ("meta"->'nested'->>'bar')::float8 = 321
  and ("meta"->'nested'->'deep'->>'baz')::float8 = 59
  and ("meta"->'nested'->'deep'->>'qux')::bool = false
limit 1

----------------------------------------

TITLE: Using Raw SQL Fragments in MikroORM 6 Queries
DESCRIPTION: This example shows how to use the new raw and sql helpers in MikroORM 6 to include raw SQL fragments in queries, including parametric queries and helper functions.

LANGUAGE: typescript
CODE:
const users = await em.find(User, {
  [raw('lower(email)')]: 'foo@bar.baz',
});

const users = await em.find(User, {
  books: {
    [raw(alias => `lower(${alias}.title)`)]: 'some title'
  },
});

const users = await em.find(User, {
  [raw('lower(??)', ['email'])]: 'foo@bar.baz',
});

const users = await em.find(User, { [sql`lower(email)`]: 'foo@bar.baz' });

----------------------------------------

TITLE: Updating Entity References with getReference() in TypeScript
DESCRIPTION: Demonstrates how to update entity relations using em.getReference() to create references from IDs.

LANGUAGE: typescript
CODE:
const jon = new Author('Jon Snow', 'snow@wall.st');
const book = new Book('Book', jon);
book.author = em.getReference(Author, '...id...');

----------------------------------------

TITLE: Generated SQL for JSON Property Index (PostgreSQL)
DESCRIPTION: Shows the SQL query generated to create an index on a JSON property in PostgreSQL. The query uses the JSON operator to access the property for indexing.

LANGUAGE: sql
CODE:
create index "book_meta_data_foo_index" on "book" (("meta_data"->>'foo'));

----------------------------------------

TITLE: Creating a Custom Repository in TypeScript for MikroORM
DESCRIPTION: This snippet shows how to create a custom repository by extending the EntityRepository class. It includes a placeholder for custom methods and demonstrates the correct import for driver-specific EntityRepository.

LANGUAGE: typescript
CODE:
import { EntityRepository } from '@mikro-orm/mysql'; // or any other driver package

export class CustomAuthorRepository extends EntityRepository<Author> {

  // custom methods...
  public findAndUpdate(...) {
    // ...
  }

}

----------------------------------------

TITLE: Defining OneToMany Relationships in TypeScript with MikroORM
DESCRIPTION: This snippet shows different ways to define a OneToMany relationship in MikroORM using TypeScript. It demonstrates the use of the @OneToMany decorator with various syntax options, including specifying the inverse side, using string references, and setting additional options like orphan removal.

LANGUAGE: typescript
CODE:
@Entity()
export class Author {

  @OneToMany(() => Book, book => book.author)
  books1 = new Collection<Book>(this);

  @OneToMany('Book', 'author')
  books2 = new Collection<Book>(this);

  @OneToMany({ mappedBy: book => book.author }) // referenced entity type can be sniffer too
  books3 = new Collection<Book>(this);

  @OneToMany({ entity: () => Book, mappedBy: 'author', orphanRemoval: true })
  books4 = new Collection<Book>(this);

}

----------------------------------------

TITLE: Initializing MikroORM with MongoDB Driver in TypeScript
DESCRIPTION: Demonstrates how to initialize MikroORM with MongoDB driver, specifying entities and database connection details.

LANGUAGE: typescript
CODE:
import { MikroORM } from '@mikro-orm/mongodb'; // or any other driver package

const orm = await MikroORM.init({
  entities: [Author, Book, ...],
  dbName: 'my-db-name',
  clientUrl: '...',
});
console.log(orm.em); // access EntityManager via `em` property

----------------------------------------

TITLE: Implementing Custom Logger Factory in MikroORM (TypeScript)
DESCRIPTION: This snippet shows how to create a custom logger by extending the DefaultLogger class and using it with MikroORM's loggerFactory option.

LANGUAGE: typescript
CODE:
class CustomLogger extends DefaultLogger {
  log(namespace: LoggerNamespace, message: string, context?: LogContext) {
    // Create your own implementation for output:
    console.log(`[${namespace}] (${context.label}) ${message}`);

    // OR Utilize DefaultLogger's implementation:
    super.log(namespace, message, context)
  }
}

return MikroORM.init({
  debug: true,
  loggerFactory: (options) => new CustomLogger(options),
});

----------------------------------------

TITLE: Implementing Custom Driver Class in TypeScript for MikroORM
DESCRIPTION: This snippet demonstrates how to create a custom Driver class by extending the DatabaseDriver class from MikroORM. It shows how to initialize the connection and platform, and lists the abstract methods that need to be implemented for database operations.

LANGUAGE: typescript
CODE:
import { DatabaseDriver } from '@mikro-orm/core';

export class MyCustomDriver extends DatabaseDriver {

  // initialize connection and platform
  protected readonly connection = new MyCustomConnection(this.config);
  protected readonly platform = new MyCustomPlatform;

  // and implement abstract methods
  find<T extends AnyEntity>(entityName: string, where: FilterQuery<T>, populate?: string[], orderBy?: Record<string, QueryOrder>, limit?: number, offset?: number): Promise<T[]>;
  findOne<T extends AnyEntity>(entityName: string, where: FilterQuery<T> | string, populate: string[]): Promise<T | null>;
  nativeInsert<T extends AnyEntityType<T>>(entityName: string, data: EntityData<T>): Promise<QueryResult>;
  nativeUpdate<T extends AnyEntity>(entityName: string, where: FilterQuery<T> | IPrimaryKey, data: EntityData<T>): Promise<QueryResult>;
  nativeDelete<T extends AnyEntity>(entityName: string, where: FilterQuery<T> | IPrimaryKey): Promise<QueryResult>;
  count<T extends AnyEntity>(entityName: string, where: FilterQuery<T>): Promise<number>;

}

----------------------------------------

TITLE: QueryBuilder Usage with Composite Keys
DESCRIPTION: Demonstrates different ways to use QueryBuilder with composite keys, showing various query patterns and their resulting SQL queries.

LANGUAGE: typescript
CODE:
const qb1 = em.createQueryBuilder(CarOwner);
qb1.select('*').where({ car: { name: 'Audi A8', year: 2010 } });
console.log(qb1.getQuery());

const qb2 = em.createQueryBuilder(CarOwner);
qb2.select('*').where({ car: ['Audi A8', 2010] });
console.log(qb2.getQuery());

const qb3 = em.createQueryBuilder(CarOwner);
qb3.select('*').where({ car: [['Audi A8', 2010]] });
console.log(qb3.getQuery());

----------------------------------------

TITLE: Disabling Metadata Cache in MikroORM
DESCRIPTION: This snippet shows how to disable metadata caching when initializing MikroORM. It sets the 'enabled' property of the 'cache' option to false.

LANGUAGE: typescript
CODE:
await MikroORM.init({
  cache: { enabled: false },
  // ...
});

----------------------------------------

TITLE: Defining MongoDB Entity with Primary Key in TypeScript
DESCRIPTION: Shows how to define a MongoDB entity with a primary key using ObjectId and a serialized string ID.

LANGUAGE: typescript
CODE:
@PrimaryKey()
_id: ObjectId;

@SerializedPrimaryKey()
id!: string; // won't be saved in the database

----------------------------------------

TITLE: Strict Property Type Validation Examples
DESCRIPTION: Shows various examples of property type validation and automatic type conversion in MikroORM.

LANGUAGE: typescript
CODE:
// number instead of string will throw
const author = new Author('test', 'test');
wrap(author).assign({ name: 111, email: 222 });
await orm.em.persist(author).flush();

// string date with unknown format will throw
wrap(author).assign(author, { name: '333', email: '444', born: 'asd' });
await orm.em.persist(author).flush();

// string date with correct format will be auto-corrected
wrap(author).assign({ name: '333', email: '444', born: '2018-01-01' });
await orm.em.persist(author).flush();
console.log(author.born).toBe(true);

// Date object will be ok
wrap(author).assign({ born: new Date() });
await orm.em.persist(author).flush();
console.log(author.born).toBe(true);

----------------------------------------

TITLE: Creating Entity Instances with EntityManager in TypeScript
DESCRIPTION: This snippet shows how to create new entity instances using the EntityManager's create() method when working with EntitySchema.

LANGUAGE: typescript
CODE:
const repo = em.getRepository<Author>('Author');
const author = repo.create('Author', { name: 'name', email: 'email' });
await repo.persistAndFlush(author);

----------------------------------------

TITLE: Configuring Entity Discovery with Arrays
DESCRIPTION: Shows how to configure MikroORM entity discovery by providing an array of entity classes directly.

LANGUAGE: typescript
CODE:
MikroORM.init({
  entities: [Author, Book, Publisher, BookTag],
});

----------------------------------------

TITLE: Updating Entity References with getReference() in TypeScript
DESCRIPTION: Demonstrates how to update entity relations using em.getReference() to create references from IDs.

LANGUAGE: typescript
CODE:
const jon = new Author('Jon Snow', 'snow@wall.st');
const book = new Book('Book', jon);
book.author = em.getReference(Author, '...id...');

----------------------------------------

TITLE: Using Transactions with MikroORM
DESCRIPTION: Example of using transactions with MikroORM's EntityManager for atomic operations.

LANGUAGE: typescript
CODE:
// if an error occurs inside the callback, all db queries from inside the callback will be rolled back
await orm.em.transactional(async (em: EntityManager) => {
  const god = new Author('God', 'hello@heaven.god');
  await em.persistAndFlush(god);
});

----------------------------------------

TITLE: Implementing Derived Identity with OneToOne Relationship in MikroORM
DESCRIPTION: This snippet shows how to implement a derived identity using a OneToOne relationship between User and Address entities in MikroORM.

LANGUAGE: typescript
CODE:
@Entity()
export class User {

  @PrimaryKey()
  id!: number;

  @OneToOne(() => Address, address => address.user, { cascade: [Cascade.ALL] })
  address?: Address;

}

@Entity()
export class Address {

  @OneToOne({ primary: true })
  user!: User;

  [PrimaryKeyProp]?: 'user';

}

----------------------------------------

TITLE: Configuring Result Cache in Entity Manager Queries
DESCRIPTION: Demonstrates how to use result caching with EntityManager find operations. Shows different ways to specify cache duration and custom cache keys.

LANGUAGE: typescript
CODE:
const res = await em.find(Book, { author: { name: 'Jon Snow' } }, {
  populate: ['author', 'tags'],
  cache: 50, // set expiration to 50ms
  // cache: ['cache-key', 50], // set custom cache key and expiration
  // cache: true, // use default cache key and expiration
});

----------------------------------------

TITLE: Initializing Fastify Server with MikroORM and JWT Authentication
DESCRIPTION: This function bootstraps a Fastify server with MikroORM integration. It sets up JWT authentication, creates a database connection, and registers necessary hooks and error handlers.

LANGUAGE: TypeScript
CODE:
export async function bootstrap(port = 3001, migrate = true) {
  const db = await initORM();

  if (migrate) {
    await db.orm.migrator.up();
  }

  const app = fastify();

  app.register(fastifyJWT, {
    secret: process.env.JWT_SECRET ?? "12345678",
  });

  // ... (hooks and error handler registration)

  app.register(registerArticleRoutes, { prefix: "article" });
  app.register(registerUserRoutes, { prefix: "user" });

  const url = await app.listen({ port });

  return { app, url, db };
}

----------------------------------------

TITLE: Configuring TypeScript for Decorators
DESCRIPTION: JSON configuration for enabling decorators and ES module interop in tsconfig.json.

LANGUAGE: json
CODE:
"experimentalDecorators": true,
"emitDecoratorMetadata": true,
"esModuleInterop": true

----------------------------------------

TITLE: Querying Entities with Default Joined Strategy in MikroORM (TypeScript)
DESCRIPTION: This snippet shows how to query an Author entity and populate its books relation using the default 'joined' strategy.

LANGUAGE: typescript
CODE:
const author = await orm.em.findOne(Author, 1, {
  populate: ['books'],
});

----------------------------------------

TITLE: Collection Operators Usage in MikroORM
DESCRIPTION: Examples of using collection operators ($some, $none, $every) for querying related collections.

LANGUAGE: typescript
CODE:
const res1 = await em.find(Author, {
  books: { $some: { title: 'Foo' } },
});

const res2 = await em.find(Author, {
  books: { $none: { title: 'Foo' } },
});

const res3 = await em.find(Author, {
  books: { $every: { title: 'Foo' } },
});

----------------------------------------

TITLE: Configuring Seeder Options in MikroORM
DESCRIPTION: Demonstrates how to set various seeder configuration options in the MikroORM initialization.

LANGUAGE: typescript
CODE:
MikroORM.init({
  seeder: {
    path: './seeders', // path to the folder with seeders
    pathTs: undefined, // path to the folder with TS seeders (if used, we should put path to compiled files in `path`)
    defaultSeeder: 'DatabaseSeeder', // default seeder class name
    glob: '!(*.d).{js,ts}', // how to match seeder files (all .js and .ts files, but not .d.ts)
    emit: 'ts', // seeder generation mode
    fileName: (className: string) => className, // seeder file naming convention
  },
});

----------------------------------------

TITLE: Configuring MikroORM Root Module in NestJS
DESCRIPTION: Implementation of MikroORM configuration in the root AppModule using forRoot() method. Demonstrates setting up entity directories, database connection, and auto-flush options.

LANGUAGE: typescript
CODE:
@Module({
  imports: [
    MikroOrmModule.forRoot({
      entitiesDirs: ['dist/entities'],
      entitiesDirsTs: ['src/entities'],
      dbName: 'my-db-name.sqlite3',
      type: 'sqlite',
      autoFlush: false, // read more here: https://mikro-orm.io/unit-of-work/
    }),
    // ... your feature modules
  ],
})
export class AppModule {}

----------------------------------------

TITLE: Deep Object Merging with MikroORM assign()
DESCRIPTION: Shows how to use mergeObjects flag for deep merging of object properties

LANGUAGE: typescript
CODE:
import { wrap } from '@mikro-orm/core';

book.meta = { foo: 1, bar: 2 };

wrap(book).assign({ meta: { foo: 3 } }, { mergeObjects: true });
console.log(book.meta); // { foo: 3, bar: 2 }

wrap(book).assign({ meta: { foo: 4 } });
console.log(book.meta); // { foo: 4 }

----------------------------------------

TITLE: Implementing Single Table Inheritance in TypeScript with MikroORM
DESCRIPTION: Demonstrates how to set up Single Table Inheritance using TypeScript decorators in MikroORM. The example includes a Person base class and an Employee subclass with discriminator column and map configurations.

LANGUAGE: typescript
CODE:
@Entity({
  discriminatorColumn: 'discr',
  discriminatorMap: { person: 'Person', employee: 'Employee' },
})
export class Person {
  // ...
}

@Entity()
export class Employee extends Person {
  // ...
}

----------------------------------------

TITLE: Basic ManyToOne Relation Definition
DESCRIPTION: Demonstrates how to define a basic ManyToOne relation to an Author entity using TypeScript decorators.

LANGUAGE: typescript
CODE:
@ManyToOne(() => Author)
author!: Author;

----------------------------------------

TITLE: Handling Entities with Explicit Primary Keys in MikroORM (TypeScript)
DESCRIPTION: This example demonstrates how entities with explicit primary keys are added to the identity map and handled in subsequent queries.

LANGUAGE: typescript
CODE:
// primary key value provided, will be added to the identity map
const jon = em.create(Author, {
  id: 1,
  name: 'Jon',
  email: 'foo@bar.com',
});

// this will not query the database
const jon2 = await em.findOne(Author, 1);
console.log(jon === jon2); // true
await em.flush(); // this inserts the entity

----------------------------------------

TITLE: Using SQLite Extensions in MikroORM
DESCRIPTION: Example of adding SQLite extensions like sqlean to MikroORM by configuring the pool.afterCreate handler in the initialization options.

LANGUAGE: typescript
CODE:
const orm = await MikroORM.init({
  // ...
  pool: {
    afterCreate: (conn: any, done: any) => {
      conn.loadExtension('/.../sqlean-macos-arm64/sqlean');
      done(null, conn);
    },
  },
});

----------------------------------------

TITLE: Redis Cache Adapter Implementation Declaration
DESCRIPTION: Declaration of a Redis-based cache adapter implementation.

LANGUAGE: typescript
CODE:
export class RedisCacheAdapter implements CacheAdapter { ... }

----------------------------------------

TITLE: Redis Cache Adapter Implementation Declaration
DESCRIPTION: Declaration of a Redis-based cache adapter implementation.

LANGUAGE: typescript
CODE:
export class RedisCacheAdapter implements CacheAdapter { ... }

----------------------------------------

TITLE: Demonstrating Identity Map in MikroORM with TypeScript
DESCRIPTION: This snippet shows how the Identity Map works in MikroORM, ensuring that the same entity instance is returned for multiple queries.

LANGUAGE: typescript
CODE:
const authorRepository = orm.em.getRepository(Author);
const jon = await authorRepository.findOne({ name: 'Jon Snow' }, ['books']);
const authors = await authorRepository.findAll(['books']);

// identity map in action
console.log(jon === authors[0]); // true

----------------------------------------

TITLE: Cursor-based Pagination in MikroORM 6
DESCRIPTION: This code snippet illustrates how to use the new cursor-based pagination feature in MikroORM 6, including fetching the initial page and subsequent pages.

LANGUAGE: typescript
CODE:
const currentCursor = await em.findByCursor(User, {}, {
  first: 10,
  after: previousCursor, // cursor instance
  orderBy: { id: 'desc' },
});

// to fetch next page
const nextCursor = await em.findByCursor(User, {}, {
  first: 10,
  after: currentCursor.endCursor, // opaque string
  orderBy: { id: 'desc' },
});

// to fetch next page
const nextCursor2 = await em.findByCursor(User, {}, {
  first: 10,
  after: { id: lastSeenId }, // entity-like POJO
  orderBy: { id: 'desc' },
});

----------------------------------------

TITLE: Querying Entities in Specific Schemas with MikroORM
DESCRIPTION: This code shows how to query for an entity in a specific schema using EntityManager, EntityRepository, or QueryBuilder. It demonstrates using the 'schema' option in the findOne method.

LANGUAGE: typescript
CODE:
const user = await em.findOne(User, { ... }, { schema: 'client-123' });

----------------------------------------

TITLE: Creating Typed JSON Index in MySQL with MikroORM
DESCRIPTION: This snippet shows how to create a typed index on a JSON property in MySQL using MikroORM. It demonstrates the use of the 'options' parameter in the @Index decorator to specify the return type.

LANGUAGE: typescript
CODE:
@Entity()
@Index({ properties: 'metaData.foo', options: { returning: 'char(200)' } })
export class Book {

  @Property({ type: 'json', nullable: true })
  metaData?: { foo: string; bar: number };

}

----------------------------------------

TITLE: Configuring MikroORM with Generated Cache Adapter
DESCRIPTION: This snippet demonstrates how to configure MikroORM to use the GeneratedCacheAdapter with a pre-built cache file for production deployment.

LANGUAGE: typescript
CODE:
import { GeneratedCacheAdapter, MikroORM } from '@mikro-orm/core';

await MikroORM.init({
  metadataCache: {
    enabled: true,
    adapter: GeneratedCacheAdapter,
    options: { data: require('./temp/metadata.json') },
  },
  // ...
});

----------------------------------------

TITLE: Updating Managed Entities in MikroORM with TypeScript
DESCRIPTION: This snippet illustrates how MikroORM automatically tracks changes to managed entities. It shows that calling flush() will update the database with changes made to the entity, even without explicitly calling persist().

LANGUAGE: typescript
CODE:
const authorRepository = em.getRepository(Author);
const jon = await authorRepository.findOne(1);
jon.email = 'foo@bar.com';
await authorRepository.flush(); // calling em.flush() has same effect

----------------------------------------

TITLE: Installing MikroORM and Database Drivers
DESCRIPTION: Commands to install MikroORM core and database-specific drivers using npm. Includes options for MongoDB, MySQL, MariaDB, PostgreSQL, SQLite, and others.

LANGUAGE: bash
CODE:
# for mongodb
npm install @mikro-orm/core @mikro-orm/mongodb

# for mysql (works with mariadb too)
npm install @mikro-orm/core @mikro-orm/mysql

# for mariadb (works with mysql too)
npm install @mikro-orm/core @mikro-orm/mariadb

# for postgresql (works with cockroachdb too)
npm install @mikro-orm/core @mikro-orm/postgresql

# for sqlite
npm install @mikro-orm/core @mikro-orm/sqlite

# for better-sqlite
npm install @mikro-orm/core @mikro-orm/better-sqlite

# for libsql/turso
npm install @mikro-orm/core @mikro-orm/libsql

# for mssql
npm install @mikro-orm/core @mikro-orm/mssql

----------------------------------------

TITLE: Implementing Complete EventSubscriber Interface
DESCRIPTION: Comprehensive example implementing all possible event subscriber methods including entity lifecycle, flush, and transaction events.

LANGUAGE: typescript
CODE:
import { EventArgs, TransactionEventArgs, EventSubscriber } from '@mikro-orm/core';

export class EverythingSubscriber implements EventSubscriber {

  // entity life cycle events
  onInit<T>(args: EventArgs<T>): void { ... }
  async onLoad<T>(args: EventArgs<T>): Promise<void> { ... }
  async beforeCreate<T>(args: EventArgs<T>): Promise<void> { ... }
  async afterCreate<T>(args: EventArgs<T>): Promise<void> { ... }
  async beforeUpdate<T>(args: EventArgs<T>): Promise<void> { ... }
  async afterUpdate<T>(args: EventArgs<T>): Promise<void> { ... }
  async beforeUpsert<T>(args: EventArgs<T>): Promise<void> { ... }
  async afterUpsert<T>(args: EventArgs<T>): Promise<void> { ... }
  async beforeDelete<T>(args: EventArgs<T>): Promise<void> { ... }
  async afterDelete<T>(args: EventArgs<T>): Promise<void> { ... }

  // flush events
  async beforeFlush<T>(args: FlushEventArgs): Promise<void> { ... }
  async onFlush<T>(args: FlushEventArgs): Promise<void> { ... }
  async afterFlush<T>(args: FlushEventArgs): Promise<void> { ... }

  // transaction events
  async beforeTransactionStart(args: TransactionEventArgs): Promise<void> { ... }
  async afterTransactionStart(args: TransactionEventArgs): Promise<void> { ... }
  async beforeTransactionCommit(args: TransactionEventArgs): Promise<void> { ... }
  async afterTransactionCommit(args: TransactionEventArgs): Promise<void> { ... }
  async beforeTransactionRollback(args: TransactionEventArgs): Promise<void> { ... }
  async afterTransactionRollback(args: TransactionEventArgs): Promise<void> { ... }

}

----------------------------------------

TITLE: Enabling Debug Mode in MikroORM (TypeScript)
DESCRIPTION: This snippet shows how to enable debug mode in MikroORM, which will cause all queries to be logged using console.log().

LANGUAGE: typescript
CODE:
return MikroORM.init({
  debug: true,
});

----------------------------------------

TITLE: Entity Factory Definition Example
DESCRIPTION: Example of creating an entity factory for generating test data using Faker library.

LANGUAGE: typescript
CODE:
import { Factory } from '@mikro-orm/seeder';
import { faker } from '@faker-js/faker';
import { Author } from './entities/author.entity';

export class AuthorFactory extends Factory<Author> {
  model = Author;

  definition(): Partial<Author> {
    return {
      name: faker.person.findName(),
      email: faker.internet.email(),
      age: faker.random.number(18, 99),
    };
  }
}

----------------------------------------

TITLE: Creating Indexes on JSON Properties in MikroORM (TypeScript)
DESCRIPTION: Demonstrates how to create indexes on JSON properties using the @Index and @Unique decorators in MikroORM. The example shows both single and compound indexes on JSON properties.

LANGUAGE: typescript
CODE:
@Entity()
@Index({ properties: 'metaData.foo' })
@Index({ properties: ['metaData.foo', 'metaData.bar'] }) // compound index
@Unique({ properties: 'metaData.foo' })
@Unique({ properties: ['metaData.foo', 'metaData.bar'] }) // compound unique index
export class Book {

  @Property({ type: 'json', nullable: true })
  metaData?: { foo: string; bar: number };

}

----------------------------------------

TITLE: Injecting EntityManager in NestJS Service
DESCRIPTION: Example of injecting MikroORM and EntityManager instances into a NestJS service class

LANGUAGE: typescript
CODE:
import { MikroORM } from '@mikro-orm/core';
import { EntityManager } from '@mikro-orm/mysql';

@Injectable()
export class MyService {
  constructor(private readonly orm: MikroORM,
              private readonly em: EntityManager) {
  }
}

----------------------------------------

TITLE: Implementing Async Filter Conditions in MikroORM
DESCRIPTION: Shows how to implement asynchronous filter conditions with type-specific behavior. The filter can respond differently based on the operation type (read, update, delete).

LANGUAGE: typescript
CODE:
@Entity()
@Filter({ name: 'writtenBy', cond: async (args, type) => {
  if (type === 'update') {
    return {}; // do not apply when updating
  }

  return { author: { name: args.name } };
} })
export class Book {
  ...
}

----------------------------------------

TITLE: Querying Entities with EntityManager in MikroORM
DESCRIPTION: Demonstrates various ways to query entities using the EntityManager in MikroORM, including find(), findOne(), and complex queries with operators.

LANGUAGE: typescript
CODE:
const author = await em.findOne(Author, 123);
const books = await em.find(Book, {});

// complex queries with operators
const users = await em.find(User, { $and: [{ id: { $nin: [3, 4] } }, { id: { $gt: 2 } }] });

// searching by array of primary keys
const users = await em.find(User, [1, 2, 3, 4, 5]);

// findOne with single primary key
const user1 = await em.findOne(User, 1);

----------------------------------------

TITLE: Empty Collection Conditions in MikroORM
DESCRIPTION: Shows how to query for existence or absence of related records using empty collection conditions.

LANGUAGE: typescript
CODE:
const res1 = await em.find(Author, {
  books: { $some: {} },
});

const res2 = await em.find(Author, {
  books: { $none: {} },
});

----------------------------------------

TITLE: Accessing QueryBuilder in SQL EntityManager
DESCRIPTION: Demonstrates how to properly import and type SQL EntityManager to access QueryBuilder functionality

LANGUAGE: typescript
CODE:
import { EntityManager } from '@mikro-orm/mysql'; // or any other SQL driver package

const em = orm.em as EntityManager;
const qb = await em.createQueryBuilder(...);

----------------------------------------

TITLE: Implementing Mapped Superclasses in TypeScript with MikroORM
DESCRIPTION: This snippet demonstrates how to create a mapped superclass and its subclass entities using TypeScript and MikroORM decorators. It includes an abstract Person class and concrete Employee and Toothbrush entities.

LANGUAGE: typescript
CODE:
// do not use @Entity decorator on base classes (mapped superclasses)
// we can also use @Entity({ abstract: true })
export abstract class Person {

  @Property()
  mapped1!: number;

  @Property()
  mapped2!: string;

  @OneToOne()
  toothbrush!: Toothbrush;

  // ... more fields and methods
}

@Entity()
export class Employee extends Person {

  @PrimaryKey()
  id!: number;

  @Property()
  name!: string;

  // ... more fields and methods

}

@Entity()
export class Toothbrush {

  @PrimaryKey()
  id!: number;

  // ... more fields and methods

}

----------------------------------------

TITLE: Implementing Custom SchemaHelper Class in TypeScript
DESCRIPTION: SchemaHelper class that provides methods for database schema operations. Extends the base SchemaHelper class and handles schema-related operations like table creation, constraints, and field definitions.

LANGUAGE: typescript
CODE:
import { SchemaHelper } from '@mikro-orm/core';

export class MyCustomSchemaHelper extends SchemaHelper {

  // here you can override default settings
  getIdentifierQuoteCharacter(): string;
  getSchemaBeginning(): string;
  getSchemaEnd(): string;
  getSchemaTableEnd(): string;
  getAutoIncrementStatement(meta: EntityMetadata): string;
  getPrimaryKeySubtype(meta: EntityMetadata): string;
  getTypeDefinition(prop: EntityProperty, types?: Record<string, string>, lengths?: Record<string, number>): string;
  getUnsignedSuffix(prop: EntityProperty): string;
  supportsSchemaConstraints(): boolean;
  supportsSchemaMultiAlter(): boolean;
  supportsSequences(): boolean;
  quoteIdentifier(field: string): string;
  dropTable(meta: EntityMetadata): string;
  indexForeignKeys(): boolean;

}

----------------------------------------

TITLE: Schema Management Operations
DESCRIPTION: Shows different ways to set and clear schema settings on EntityManager instances.

LANGUAGE: typescript
CODE:
em.schema = 'client-123';
const fork = em.fork({ schema: 'client-1234' });
fork.schema = null;

----------------------------------------

TITLE: Setting Declarative Referential Integrity in MikroORM TypeScript
DESCRIPTION: Shows how to define database-level referential integrity actions in MikroORM using TypeScript. It demonstrates setting custom update and delete rules for relationships.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @ManyToOne({ updateRule: 'set null', deleteRule: 'cascade' })
  author?: Author;

}

----------------------------------------

TITLE: Complex Order Management System with Composite Keys
DESCRIPTION: Implements a complex order management system using composite keys for OrderItems linking Orders and Products with additional metadata.

LANGUAGE: typescript
CODE:
@Entity()
export class Order {

  @PrimaryKey()
  id!: number;

  @ManyToOne()
  customer: Customer;

  @OneToMany(() => OrderItem, item => item.order)
  items = new Collection<OrderItem>(this);

  @Property()
  paid = false;

  @Property()
  shipped = false;

  @Property()
  created = new Date();

  constructor(customer: Customer) {
    this.customer = customer;
  }

}

@Entity()
export class Product {

  @PrimaryKey()
  id!: number;

  @Property()
  name!: string;

  @Property()
  currentPrice!: number;

}

@Entity()
export class OrderItem {

  @ManyToOne({ primary: true })
  order: Order;

  @ManyToOne({ primary: true })
  product: Product;

  @Property()
  amount = 1;

  @Property()
  offeredPrice: number;

  [PrimaryKeyType]?: [number, number];

  constructor(order: Order, product: Product, amount = 1) {
    this.order = order;
    this.product = product;
    this.offeredPrice = product.currentPrice;
  }

}

----------------------------------------

TITLE: Custom Cache Adapter Implementation in MikroORM
DESCRIPTION: Example showing how to implement and configure a custom Redis cache adapter.

LANGUAGE: typescript
CODE:
export class RedisCacheAdapter implements CacheAdapter { ... }

LANGUAGE: typescript
CODE:
await MikroORM.init({
  metadataCache: { adapter: RedisCacheAdapter, options: { ... } },
  // ...
});

----------------------------------------

TITLE: Deep Object Merging with assign() in MikroORM
DESCRIPTION: Shows how to use the mergeObjectProperties flag for deep merging of object properties.

LANGUAGE: typescript
CODE:
import { wrap } from '@mikro-orm/core';

book.meta = { foo: 1, bar: 2 };

wrap(book).assign({ meta: { foo: 3 } }, { mergeObjectProperties: true });
console.log(book.meta); // { foo: 3, bar: 2 }

wrap(book).assign({ meta: { foo: 4 } });
console.log(book.meta); // { foo: 4 }

----------------------------------------

TITLE: Repository Native Operations
DESCRIPTION: EntityRepository shortcuts for native collection operations in MongoDB.

LANGUAGE: typescript
CODE:
EntityRepository.nativeInsert(data: any): Promise<IPrimaryKey>;
EntityRepository.nativeUpdate(where: FilterQuery<T>, data: any): Promise<number>;
EntityRepository.nativeDelete(where: FilterQuery<T> | any): Promise<number>;

----------------------------------------

TITLE: Configuring MikroORM Migrations
DESCRIPTION: Basic configuration setup for enabling migrations in MikroORM by registering the Migrator extension.

LANGUAGE: typescript
CODE:
import { Migrator } from '@mikro-orm/migrations';

export default defineConfig({
  // ...
  extensions: [Migrator],
})

----------------------------------------

TITLE: Checking Database Connection Status with MikroORM
DESCRIPTION: These methods demonstrate how to check the database connection status using MikroORM's isConnected() and checkConnection() methods.

LANGUAGE: ts
CODE:
// boolean
const isConnected = await orm.isConnected();
// object with `ok`, `reason` and `error` keys
const check = await orm.checkConnection();

console.log(check.ok, check.reason);

----------------------------------------

TITLE: Empty Collection Conditions in MikroORM
DESCRIPTION: Shows how to query for existence or absence of related records using empty collection conditions.

LANGUAGE: typescript
CODE:
const res1 = await em.find(Author, {
  books: { $some: {} },
});

const res2 = await em.find(Author, {
  books: { $none: {} },
});

----------------------------------------

TITLE: MongoDB Aggregation Methods
DESCRIPTION: Definitions for MongoDB aggregation pipeline operations through EntityManager and EntityRepository.

LANGUAGE: typescript
CODE:
EntityManager.aggregate(entityName: string, pipeline: any[]): Promise<any[]>;
EntityRepository.aggregate(pipeline: any[]): Promise<any[]>;

----------------------------------------

TITLE: ManyToMany Collection Configuration in MikroORM
DESCRIPTION: Demonstrates configuration of unidirectional and bidirectional ManyToMany relationships, including owner side definition and inverse mappings.

LANGUAGE: typescript
CODE:
@ManyToMany(() => BookTag, tag => tag.books, { owner: true })
tags = new Collection<BookTag>(this);

@ManyToMany({ entity: () => BookTag, inversedBy: 'books' })
tags = new Collection<BookTag>(this);

@ManyToMany(() => Book, book => book.tags)
books = new Collection<Book>(this);

@ManyToMany({ entity: () => Book, mappedBy: 'tags' })
books = new Collection<Book>(this);

----------------------------------------

TITLE: Installing EntityGenerator Package
DESCRIPTION: Command to install the @mikro-orm/entity-generator package using npm or yarn.

LANGUAGE: bash
CODE:
npm install @mikro-orm/entity-generator

----------------------------------------

TITLE: Using EntityGenerator via CLI
DESCRIPTION: Commands to generate entities using the MikroORM CLI with EntityGenerator.

LANGUAGE: bash
CODE:
npx mikro-orm generate-entities --dump  # Dumps all generated entities
npx mikro-orm generate-entities --save --path=./my-entities  # Saves entities into given directory

----------------------------------------

TITLE: Populating Already Loaded Entities in MikroORM (TypeScript)
DESCRIPTION: Demonstrates how to populate existing entities using em.populate() method in MikroORM.

LANGUAGE: typescript
CODE:
const authors = await em.createQueryBuilder(Author).select('*').getResult();
await em.populate(authors, ['books.tags']);

// now your Author entities will have `books` collections populated,
// as well as they will have their `tags` collections populated.
console.log(authors[0].books[0].tags[0]); // initialized BookTag

----------------------------------------

TITLE: Creating Custom Repository in MikroORM
DESCRIPTION: Shows how to create a custom repository by extending EntityRepository class and using the @Repository decorator.

LANGUAGE: typescript
CODE:
@Repository(Author)
export class CustomAuthorRepository extends EntityRepository<Author> {

  // your custom methods...
  public findAndUpdate(...) {
    // ...
  }

}

----------------------------------------

TITLE: Generating MikroORM Cache Bundle with CLI
DESCRIPTION: This command generates a production cache bundle into a single JSON file using the MikroORM CLI.

LANGUAGE: bash
CODE:
npx mikro-orm cache:generate --combined

----------------------------------------

TITLE: SQL Table Creation with UnderscoreNamingStrategy (SQL)
DESCRIPTION: This SQL snippet shows how tables and columns are named using the UnderscoreNamingStrategy in SQL drivers. It demonstrates the lowercase and underscore-separated naming convention for database elements.

LANGUAGE: sql
CODE:
CREATE TABLE `author` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `created_at` datetime(3) DEFAULT NULL,
  `updated_at` datetime(3) DEFAULT NULL,
  `terms_accepted` tinyint(1) DEFAULT NULL,
  `name` varchar(255) DEFAULT NULL,
  `email` varchar(255) DEFAULT NULL,
  `born` datetime DEFAULT NULL,
  `favourite_book_id` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

----------------------------------------

TITLE: Defining Entities with Schema Options in TypeScript
DESCRIPTION: Demonstrates how to define entities with different schema configurations using decorator options. Shows two approaches: using the schema option directly or including it in the tableName.

LANGUAGE: typescript
CODE:
@Entity({ schema: 'first_schema' })
export class Foo { ... }

// or alternatively we can specify it inside custom table name
@Entity({ tableName: 'second_schema.bar' })
export class Bar { ... }

----------------------------------------

TITLE: Using Opt Type in MikroORM Entity
DESCRIPTION: This example demonstrates the use of the Opt type in a MikroORM entity to mark properties as optional. It shows both generic and intersection approaches for using Opt.

LANGUAGE: typescript
CODE:
import { Opt, Entity, PrimaryKey, Property } from '@mikro-orm/core';

@Entity()
class User {

  @PrimaryKey()
  id!: number;

  @Property()
  firstName!: string;

  @Property()
  middleName: string & Opt = '';

  @Property()
  lastName!: string;

  @Property({ persist: false })
  get fullName(): Opt<string> {
    return `${this.firstName} ${this.middleName} ${this.lastName}`;
  }

}

----------------------------------------

TITLE: Using the Opt Type for Optional Properties in MikroORM 6 Entities
DESCRIPTION: This example demonstrates how to use the new Opt type in MikroORM 6 to mark properties as optional with runtime defaults in entity definitions.

LANGUAGE: typescript
CODE:
import { Opt, Entity, PrimaryKey, Property } from '@mikro-orm/core';

@Entity()
class User {

  @PrimaryKey()
  id!: number;

  @Property()
  firstName!: string;

  @Property()
  middleName: string & Opt = '';

  @Property()
  lastName!: string;

}

----------------------------------------

TITLE: Defining Entity with Constructor in TypeScript
DESCRIPTION: Example of a Book entity definition with a constructor that requires title and author parameters. Shows proper decorator usage and relationship definitions.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @PrimaryKey()
  id!: number;

  @Property()
  title: string;

  @Property()
  foo!: number;

  @ManyToOne()
  author: Author;

  @ManyToOne()
  publisher?: Publisher;

  @ManyToMany({ entity: () => BookTag, inversedBy: 'books' })
  tags = new Collection<BookTag>(this);

  constructor(title: string, author: Author) {
    this.title = title;
    this.author = author;
  }

}

----------------------------------------

TITLE: Importing SQL EntityManager for QueryBuilder in MikroORM
DESCRIPTION: This snippet demonstrates how to import the SQL-specific EntityManager to access the createQueryBuilder() method in MikroORM v4.

LANGUAGE: typescript
CODE:
import { EntityManager } from '@mikro-orm/mysql'; // or any other SQL driver package

const em: EntityManager;
const qb = await em.createQueryBuilder(...);

----------------------------------------

TITLE: PostgreSQL Full-Text Search Entity Definition in MikroORM
DESCRIPTION: Shows how to define an entity with full-text search capabilities in PostgreSQL using a dedicated column.

LANGUAGE: typescript
CODE:
import { FullTextType } from '@mikro-orm/postgresql';

@Entity()
export class Book {

  @Property()
  title!: string;

  @Index({ type: 'fulltext' })
  @Property({ type: FullTextType, onUpdate: (book) => book.title })
  searchableTitle!: string;

}

----------------------------------------

TITLE: Configuring Automatic Entity Loading in NestJS
DESCRIPTION: Example of enabling automatic entity loading in the MikroOrmModule configuration.

LANGUAGE: typescript
CODE:
@Module({
  imports: [
    MikroOrmModule.forRoot({
      // ...
      autoLoadEntities: true,
    }),
  ],
})
export class AppModule {}

----------------------------------------

TITLE: Configuring Auto-Flush in MikroORM
DESCRIPTION: Shows how to configure auto-flushing behavior globally when initializing MikroORM and how to override it per operation.

LANGUAGE: typescript
CODE:
const orm = await MikroORM.init({
  autoFlush: false,
  // ...
});
await orm.em.persist(new Entity()); // no auto-flushing now
await orm.em.flush();
await orm.em.persist(new Entity(), true); // you can still use second parameter to auto-flush

----------------------------------------

TITLE: Configuring Migrator Extension in MikroORM
DESCRIPTION: This snippet shows how to import and register the Migrator extension in the MikroORM configuration file.

LANGUAGE: typescript
CODE:
import { Migrator } from '@mikro-orm/migrations'; // or `@mikro-orm/migrations-mongodb`

export default defineConfig({
  // ...
  extensions: [Migrator],
})

----------------------------------------

TITLE: Demonstrating Cascade Persist in MikroORM TypeScript
DESCRIPTION: Shows an example of how cascade persist works in MikroORM. It demonstrates updating related entities and persisting changes through the main entity.

LANGUAGE: typescript
CODE:
const book = await orm.em.findOne(Book, 'id', { populate: ['author', 'tags'] });
book.author.name = 'Foo Bar';
book.tags[0].name = 'new name 1';
book.tags[1].name = 'new name 2';
await orm.em.persist(book).flush(); // all book tags and author will be persisted too

----------------------------------------

TITLE: Querying JSON Object Properties in MikroORM (TypeScript)
DESCRIPTION: Shows how to query a MikroORM entity by its JSON object properties, including nested properties. This example demonstrates querying multiple levels of nesting with various data types.

LANGUAGE: typescript
CODE:
const b = await em.findOne(Book, {
  meta: {
    valid: true,
    nested: {
      foo: '123',
      bar: 321,
      deep: {
        baz: 59,
        qux: false,
      },
    },
  },
});

----------------------------------------

TITLE: Handling Implicit Transactions in MikroORM with TypeScript
DESCRIPTION: This example demonstrates MikroORM's implicit transaction handling. It shows how persisting and flushing a user entity with associated changes (including a new related entity) are all executed within a single transaction.

LANGUAGE: typescript
CODE:
const user = await em.findOne(User, 1);
user.email = 'foo@bar.com';
const car = new Car();
user.cars.add(car);

// thanks to bi-directional cascading we only need to persist user entity
// flushing will create a transaction, insert new car and update user with new email
await em.persistAndFlush(user);

----------------------------------------

TITLE: Defining MongoDB Entity
DESCRIPTION: Example of defining an entity for MongoDB

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @PrimaryKey()
  _id!: ObjectId;

  @SerializedPrimaryKey()
  id!: string; // string variant of PK, will be handled automatically

  @Property()
  title!: string;

  @ManyToOne(() => Author)
  author!: Author;

}

----------------------------------------

TITLE: Implementing Custom MyDateType in TypeScript for MikroORM
DESCRIPTION: This snippet demonstrates how to create a custom MyDateType by extending the Type abstract class. It includes methods for converting between database and JavaScript values, as well as specifying the column type.

LANGUAGE: typescript
CODE:
import { Type, Platform, EntityProperty, ValidationError } from '@mikro-orm/core';

export class MyDateType extends Type<Date, string> {

  convertToDatabaseValue(value: Date | string | undefined, platform: Platform): string {
    if (value instanceof Date) {
      return value.toISOString().substr(0, 10);
    }

    if (!value || value.toString().match(/^\d{4}-\d{2}-\d{2}$/)) {
      return value as string;
    }

    throw ValidationError.invalidType(MyDateType, value, 'JS');
  }

  convertToJSValue(value: Date | string | undefined, platform: Platform): Date {
    if (!value || value instanceof Date) {
      return value as Date;
    }

    const date = new Date(value);

    if (date.toString() === 'Invalid Date') {
      throw ValidationError.invalidType(MyDateType, value, 'database');
    }

    return date;
  }

  getColumnType(prop: EntityProperty, platform: Platform) {
    return `date(${prop.length})`;
  }

}

----------------------------------------

TITLE: Defining a Book Entity with Constructor in TypeScript for MikroORM
DESCRIPTION: This code snippet demonstrates how to define a Book entity using TypeScript decorators for MikroORM. It includes a constructor that requires setting the title and author, while making the publisher optional. The entity also has a many-to-many relationship with BookTag.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @PrimaryKey()
  id!: number;

  @Property()
  title!: string;

  @ManyToOne()
  author!: Author;

  @ManyToOne()
  publisher?: Publisher;

  @ManyToMany({ entity: () => BookTag, inversedBy: 'books' })
  tags = new Collection<BookTag>(this);

  constructor(title: string, author: Author) {
    this.title = title;
    this.author = author;
  }

}

----------------------------------------

TITLE: Configuring MikroORM for Turso Database
DESCRIPTION: Example of configuring MikroORM to connect to a remote Turso database using the libsql driver and setting additional options.

LANGUAGE: typescript
CODE:
import { defineConfig } from '@mikro-orm/libsql';

export default defineConfig({
  dbName: process.env.LIBSQL_URL,
  password: process.env.LIBSQL_AUTH_TOKEN,
  driverOptions: {
    connection: {
      syncUrl: process.env.LIBSQL_URL,
      syncPeriod: 0.5, // 500ms
    },
  },
});

----------------------------------------

TITLE: Generated SQL for Advanced Upsert Operations
DESCRIPTION: Shows the SQL query generated by the upsert operation, demonstrating how conflict resolution and field exclusion are handled at the database level.

LANGUAGE: sql
CODE:
insert into "author" 
  ("id", "current_age", "email", "foo")
  values
    (1, 41, 'a1', true),
    (2, 42, 'a2', true),
    (5, 43, 'a3', true)
  on conflict ("email") 
  do update set
    "current_age" = excluded."current_age",
    "foo" = excluded."foo" 
  returning "_id", "current_age", "foo", "bar"

----------------------------------------

TITLE: Installing MikroORM Core and Database Drivers
DESCRIPTION: Commands for installing MikroORM core package and specific database drivers using yarn or npm. Supports MongoDB, MySQL/MariaDB, PostgreSQL, and SQLite.

LANGUAGE: sh
CODE:
yarn add @mikro-orm/core @mikro-orm/mongodb     # for mongo
yarn add @mikro-orm/core @mikro-orm/mysql       # for mysql/mariadb
yarn add @mikro-orm/core @mikro-orm/mariadb     # for mysql/mariadb
yarn add @mikro-orm/core @mikro-orm/postgresql  # for postgresql
yarn add @mikro-orm/core @mikro-orm/sqlite      # for sqlite

LANGUAGE: sh
CODE:
npm i -s @mikro-orm/core @mikro-orm/mongodb     # for mongo
npm i -s @mikro-orm/core @mikro-orm/mysql       # for mysql/mariadb
npm i -s @mikro-orm/core @mikro-orm/mariadb     # for mysql/mariadb
npm i -s @mikro-orm/core @mikro-orm/postgresql  # for postgresql
npm i -s @mikro-orm/core @mikro-orm/sqlite      # for sqlite

----------------------------------------

TITLE: Generated SQL for Typed JSON Property Index (MySQL)
DESCRIPTION: Displays the SQL query generated to create a typed index on a JSON property in MySQL. The query uses the JSON_VALUE function with a specified return type.

LANGUAGE: sql
CODE:
alter table `book`
  add index `book_meta_data_foo_index`((json_value(`meta_data`, '$.foo' returning char(200))));

----------------------------------------

TITLE: Defining Embeddable and Entity Classes with reflect-metadata
DESCRIPTION: This snippet demonstrates how to define an Address embeddable class and a User entity class using the reflect-metadata approach in MikroORM.

LANGUAGE: typescript
CODE:
import { Embeddable, Embedded, Entity, PrimaryKey, Property } from '@mikro-orm/core';

@Embeddable()
export class Address {

  @Property()
  street!: string;

  @Property()
  postalCode!: string;

  @Property()
  city!: string;

  @Property()
  country!: string;

}

@Entity()
export class User {

  @PrimaryKey()
  id!: number;

  @Embedded(() => Address)
  address!: Address;

}

----------------------------------------

TITLE: Basic ManyToOne Relation Definition
DESCRIPTION: Shows how to define a basic ManyToOne relation to an Author entity using TypeScript decorators.

LANGUAGE: typescript
CODE:
@ManyToOne(() => Author)
author!: Author; // the value is always instance of the `Author` entity

----------------------------------------

TITLE: Many-to-Many Collection Propagation in TypeScript with MikroORM
DESCRIPTION: Illustrates bi-directional propagation in many-to-many relationships, showing how changes are synchronized when adding entities from either the owning or inverse side.

LANGUAGE: typescript
CODE:
// many to many works both from owning side and from inverse side
const book = new Book(...);
const tag = new BookTag(...);

book.tags.add(tag);
console.log(tag.books.contains(book)); // true

tag.books.add(book);
console.log(book.tags.contains(tag)); // true

----------------------------------------

TITLE: Initializing Nullable Properties with Explicit Null in MikroORM
DESCRIPTION: This code shows how to initialize a nullable property with an explicit null value in a MikroORM entity. It uses the @Property decorator with type and nullable options.

LANGUAGE: typescript
CODE:
@Property({ type: 'string', nullable: true })
name: string | null = null;

----------------------------------------

TITLE: Initializing MikroORM with MongoDB
DESCRIPTION: Basic configuration for connecting MikroORM to a MongoDB database. Specifies the entities directory, database name, and connection URL.

LANGUAGE: typescript
CODE:
const orm = await MikroORM.init({
  entitiesDirs: ['entities'], // relative to `baseDir`
  dbName: 'my-db-name',
  clientUrl: '...',
});

----------------------------------------

TITLE: Configuring MikroORM Repository for Testing in NestJS
DESCRIPTION: Demonstrates how to set up a mocked repository for testing MikroORM integration in NestJS.

LANGUAGE: typescript
CODE:
@Module({
  providers: [
    PhotoService,
    // required for `@InjectRepository` decorator
    {
      provide: getRepositoryToken(Photo),
      useValue: mockedRepository,
    },

    // required for custom repositories if we don't want to use `@InjectRepository`
    {
      provide: PhotoRepository,
      useValue: mockedRepository,
    },
  ],
})
export class PhotoModule {}

----------------------------------------

TITLE: Implementing Shadow Properties
DESCRIPTION: Example of defining non-persisted shadow properties that exist only in memory using persist: false flag.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @Property({ persist: false })
  count: number;

}

----------------------------------------

TITLE: Configuring TsMorphMetadataProvider in MikroORM v4
DESCRIPTION: Example of how to explicitly enable the TsMorphMetadataProvider in MikroORM v4 configuration. This is required if you want to use ts-morph instead of the new default ReflectMetadataProvider.

LANGUAGE: typescript
CODE:
import { TsMorphMetadataProvider } from '@mikro-orm/reflection';

await MikroORM.init({
  metadataProvider: TsMorphMetadataProvider,
  // ...
});

----------------------------------------

TITLE: Using Rel Type for Relations in ESM Projects with MikroORM
DESCRIPTION: This snippet demonstrates how to use the Rel mapped type in ESM projects to avoid circular dependency issues when using reflect-metadata. It shows how to define a ManyToOne relationship using Rel to disable problematic inference.

LANGUAGE: typescript
CODE:
import { Rel } from '@mikro-orm/core';

@Entity()
export class Book {

  @ManyToOne(() => Author)
  author!: Rel<Author>;

}

----------------------------------------

TITLE: Point Class Definition for Spatial Data
DESCRIPTION: Definition of a Point class for representing geographic coordinates in a spatial data implementation.

LANGUAGE: typescript
CODE:
export class Point {

  constructor(public latitude: number,
              public longitude: number) { }

}

----------------------------------------

TITLE: Forking EntityManager in MikroORM
DESCRIPTION: Shows how to create a new EntityManager instance with its own identity map context using the fork method.

LANGUAGE: typescript
CODE:
const em = orm.em.fork();

----------------------------------------

TITLE: Using CreateRequestContext with Callback in MikroORM (TypeScript)
DESCRIPTION: This snippet shows how to use the @CreateRequestContext() decorator with a callback function. It allows for more flexibility in obtaining the ORM instance or entity manager for context creation.

LANGUAGE: typescript
CODE:
import { DI } from '..';

export class MyService {

  @CreateRequestContext(() => DI.em)
  async doSomething() {
    // this will be executed in a separate context
  }

}

----------------------------------------

TITLE: Initializing MikroORM with PostgreSQL Driver
DESCRIPTION: Example of initializing MikroORM with PostgreSQL driver and accessing EntityManager

LANGUAGE: typescript
CODE:
import { MikroORM } from '@mikro-orm/postgresql';

const orm = await MikroORM.init({
  entities: ['./dist/entities'],
  dbName: 'my-db-name',
});
console.log(orm.em);

----------------------------------------

TITLE: Using OptionalProps with Generics in Base Entity Class in MikroORM
DESCRIPTION: This snippet shows how to use OptionalProps with generics in a base entity class to allow extending classes to add more optional properties.

LANGUAGE: typescript
CODE:
@Entity()
class MyBaseEntity<Entity extends object, Optional extends keyof Entity = never> {

  [OptionalProps]?: 'foo' | 'bar' | Optional;

  @PrimaryKey()
  id!: number;

  @Property({ default: 1 })
  foo: number = 1;

  @Property({ default: 2 })
  bar: number = 2;

}

@Entity()
class User extends MyBaseEntity<User, 'baz'> {

  @Property({ default: 3 })
  baz: number = 3;

}

----------------------------------------

TITLE: Running MikroORM Schema Generator Script
DESCRIPTION: Shell command to run the TypeScript script for schema generation using ts-node.

LANGUAGE: shell
CODE:
$ ts-node create-schema

----------------------------------------

TITLE: Configuring Optional Properties for Entity Creation in MikroORM 5
DESCRIPTION: This example shows how to use the OptionalProps symbol to specify which properties should be considered optional when creating entities, even if they are defined as required in the entity definition. This is useful for properties with default values or database-generated values.

LANGUAGE: typescript
CODE:
@Entity()
export class Author {

  // only `name` will be considered as required for `em.create()`
  [OptionalProps]?: 'createdAt' | 'updatedAt';

  @PrimaryKey()
  id!: number;

  @Property({ defaultRaw: 'current_timestamp()' })
  createdAt!: Date;

  @Property({ onUpdate: () => new Date(), length: 3, defaultRaw: 'current_timestamp(3)' })
  updatedAt!: Date;

  @Property()
  name!: string;

}

----------------------------------------

TITLE: Defining Entity Serialization Interface in TypeScript
DESCRIPTION: Base interface definition for entity serialization methods that are monkey-patched onto all entities by default.

LANGUAGE: typescript
CODE:
export interface AnyEntity<K = number | string> {
  toObject(parent?: AnyEntity, isCollection?: boolean): Record<string, any>;
  toJSON(...args: any[]): Record<string, any>;
  // ...
}

----------------------------------------

TITLE: Executing Queries with Different Result Types in MikroORM
DESCRIPTION: Shows how to execute queries with different result types using the execute method's parameters.

LANGUAGE: typescript
CODE:
const res1 = await qb.execute('all'); // returns array of objects, default behavior
const res2 = await qb.execute('get'); // returns single object
const res3 = await qb.execute('run'); // returns object like `{ affectedRows: number, insertId: number, row: any }`

----------------------------------------

TITLE: Disabling Metadata Cache in MikroORM (TypeScript)
DESCRIPTION: This snippet demonstrates how to disable metadata caching when initializing MikroORM. It sets the 'enabled' property of the 'metadataCache' option to false.

LANGUAGE: typescript
CODE:
await MikroORM.init({
  metadataCache: { enabled: false },
  // ...
});

----------------------------------------

TITLE: Assigning References to Entity Properties in MikroORM
DESCRIPTION: This code shows how to assign Reference instances to entity properties and create references without EntityManager.

LANGUAGE: typescript
CODE:
import { ref } from '@mikro-orm/core';

const book = await em.findOne(Book, 1);
const repo = em.getRepository(Author);

book.author = repo.getReference(2, { wrapped: true });

// same as:
book.author = ref(repo.getReference(2));
await em.flush();

----------------------------------------

TITLE: MySQL Table Creation with UnderscoreNamingStrategy in SQL
DESCRIPTION: This SQL snippet shows how the UnderscoreNamingStrategy affects table and column naming in MySQL. It creates an 'author' table with various fields, demonstrating the lowercase and underscore-separated naming convention.

LANGUAGE: sql
CODE:
CREATE TABLE `author` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `created_at` datetime(3) DEFAULT NULL,
  `updated_at` datetime(3) DEFAULT NULL,
  `terms_accepted` tinyint(1) DEFAULT NULL,
  `name` varchar(255) DEFAULT NULL,
  `email` varchar(255) DEFAULT NULL,
  `born` datetime DEFAULT NULL,
  `favourite_book_id` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

----------------------------------------

TITLE: Defining Indexes in Entity
DESCRIPTION: Example of defining indexes in an entity using @Index and @Unique decorators.

LANGUAGE: TypeScript
CODE:
@Entity()
@Index({ properties: ['name', 'age'] }) // compound index, with generated name
@Index({ name: 'custom_idx_name', properties: ['name'] }) // simple index, with custom name
@Unique({ properties: ['name', 'email'] })
export class Author {

  @Property()
  @Unique()
  email!: string;

  @Property()
  @Index() // generated name
  age?: number;

  @Index({ name: 'born_index' })
  @Property()
  born?: Date;

  @Index({ name: 'custom_index_expr', expression: 'alter table `author` add index `custom_index_expr`(`title`)' })
  @Property()
  title!: string;

}

----------------------------------------

TITLE: MySQL Table Creation with Underscore Naming Strategy
DESCRIPTION: Example of how the UnderscoreNamingStrategy transforms entity properties into database column names using MySQL syntax, showing lowercase and underscore-separated naming convention.

LANGUAGE: sql
CODE:
CREATE TABLE `author` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `created_at` datetime(3) DEFAULT NULL,
  `updated_at` datetime(3) DEFAULT NULL,
  `terms_accepted` tinyint(1) DEFAULT NULL,
  `name` varchar(255) DEFAULT NULL,
  `email` varchar(255) DEFAULT NULL,
  `born` datetime DEFAULT NULL,
  `favourite_book_id` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

----------------------------------------

TITLE: Loading Multiple Book References with Promise.all
DESCRIPTION: Example demonstrating how to load multiple book references efficiently using dataloaders.

LANGUAGE: typescript
CODE:
const books = await orm.em.find(Book, [1, 2, 3]);
await Promise.all(books.map(book => book.author.load({ dataloader: true })));

----------------------------------------

TITLE: Array Shorthand for $in Operator in MikroORM
DESCRIPTION: Demonstrates the shorthand syntax for the $in operator using a direct array value.

LANGUAGE: typescript
CODE:
const res = await orm.em.find(Author, { favouriteBook: [1, 2, 7] });

----------------------------------------

TITLE: Explicit Serialization with Options in TypeScript
DESCRIPTION: This example demonstrates how to use explicit serialization with various options to control the shape of the serialized response.

LANGUAGE: typescript
CODE:
import { wrap } from '@mikro-orm/core';

const dto = wrap(author).serialize({
  populate: ['books.author', 'books.publisher', 'favouriteBook'], // populate some relations
  exclude: ['books.author.email'], // skip property of some relation
  forceObject: true, // not populated or not initialized relations will result in object, e.g. `{ author: { id: 1 } }`
  skipNull: true, // properties with `null` value won't be part of the result
});

----------------------------------------

TITLE: Configuring Orphan Removal in MikroORM
DESCRIPTION: Example showing how to configure and use orphan removal in entity relationships.

LANGUAGE: typescript
CODE:
@Entity()
export class Author {

  @OneToMany({ entity: () => Book, mappedBy: 'author', orphanRemoval: true })
  books = new Collection<Book>(this);

}

----------------------------------------

TITLE: Transaction Context Management in Migrations
DESCRIPTION: Example of controlling transaction context manually in migrations.

LANGUAGE: typescript
CODE:
await orm.em.transactional(async em => {
  await migrator.up({ transaction: em.getTransactionContext() });
})

----------------------------------------

TITLE: Polymorphic Embeddables Implementation
DESCRIPTION: Illustrates how to create polymorphic embeddables using discriminator columns. Shows inheritance between Animal base class and Cat/Dog implementations with type-specific properties.

LANGUAGE: typescript
CODE:
import { Embeddable, Embedded, Entity, Enum, PrimaryKey, Property } from '@mikro-orm/core';

export enum AnimalType {
  CAT,
  DOG,
}

@Embeddable({ abstract: true, discriminatorColumn: 'type' })
export abstract class Animal {

  @Enum(() => AnimalType)
  type!: AnimalType;

  @Property()
  name!: string;

}

@Embeddable({ discriminatorValue: AnimalType.CAT })
export class Cat extends Animal {

  @Property({ nullable: true })
  canMeow?: boolean = true;

  constructor(name: string) {
    super();
    this.type = AnimalType.CAT;
    this.name = name;
  }

}

@Embeddable({ discriminatorValue: AnimalType.DOG })
export class Dog extends Animal {

  @Property({ nullable: true })
  canBark?: boolean = true;

  constructor(name: string) {
    super();
    this.type = AnimalType.DOG;
    this.name = name;
  }

}

@Entity()
export class Owner {

  @PrimaryKey()
  id!: number;

  @Property()
  name!: string;

  @Embedded(() => [Cat, Dog])
  pet!: Cat | Dog;

}

----------------------------------------

TITLE: Various Ways to Use ref() Helper in TypeScript
DESCRIPTION: This snippet demonstrates different ways to use the ref() helper function with null, undefined, primary keys, and entity instances.

LANGUAGE: typescript
CODE:
book.author = ref(Author, null);
book.author = ref(Author, undefined);
book.author = ref(null);
book.author = ref(undefined);
book.author = ref(Author, 1);
book.author = ref(Author, author);
book.author = ref(author);

----------------------------------------

TITLE: Initializing MikroORM with MongoDB Transactions in TypeScript
DESCRIPTION: This snippet demonstrates how to initialize MikroORM with MongoDB transactions enabled. It includes setting up a replica set, enabling implicit transactions, and creating the schema.

LANGUAGE: typescript
CODE:
import { MikroORM } from '@mikro-orm/mongodb';

const orm = await MikroORM.init({
  entities: [Author, Book, ...],
  clientUrl: 'mongodb://localhost:27017,localhost:27018,localhost:27019/my-db-name?replicaSet=rs0',
  implicitTransactions: true, // defaults to false
});

await orm.schema.createSchema();

----------------------------------------

TITLE: Importing EntityManager Types in TypeScript
DESCRIPTION: Shows how to import the correct EntityManager and EntityRepository types from the driver package to use QueryBuilder.

LANGUAGE: typescript
CODE:
import { EntityManager, EntityRepository } from '@mikro-orm/mysql'; // or any other driver package

----------------------------------------

TITLE: Using QueryBuilder for Native SQL Queries
DESCRIPTION: Example of using QueryBuilder to construct and execute native SQL queries, including updating records and executing raw SQL.

LANGUAGE: typescript
CODE:
const qb = orm.em.createQueryBuilder(Author);
qb.update({ name: 'test 123', type: PublisherType.GLOBAL }).where({ id: 123, type: PublisherType.LOCAL });

console.log(qb.getQuery());
// 'UPDATE `publisher2` SET `name` = ?, `type` = ? WHERE `id` = ? AND `type` = ?'

console.log(qb.getParams());
// ['test 123', PublisherType.GLOBAL, 123, PublisherType.LOCAL]

// run the query
const res1 = await qb.execute();

// or run query without using QueryBuilder
const driver = orm.em.getDriver();
const res2 = await driver.execute('SELECT ? + ?', [1, 2]);

----------------------------------------

TITLE: Batch Inserting Users with MikroORM in TypeScript
DESCRIPTION: Demonstrates how MikroORM 4.1 batches multiple user inserts into a single SQL query, improving performance when persisting multiple entities.

LANGUAGE: typescript
CODE:
for (let i = 1; i <= 5; i++) {
  const u = new User(`Peter ${i}`, `peter+${i}@foo.bar`);
  em.persist(u);
}

await em.flush();

// insert into `user` (`name`, `email`) values
//   ('Peter 1', 'peter+1@foo.bar'),
//   ('Peter 2', 'peter+2@foo.bar'),
//   ('Peter 3', 'peter+3@foo.bar'),
//   ('Peter 4', 'peter+4@foo.bar'),
//   ('Peter 5', 'peter+5@foo.bar');

----------------------------------------

TITLE: Using Mathematical Symbols in MikroORM TypeScript Queries
DESCRIPTION: This snippet shows how to use mathematical symbols as comparison operators in MikroORM queries. Note that this may cause TypeScript errors and require casting to 'any'.

LANGUAGE: typescript
CODE:
const res = await orm.em.find(Author, { $and: [
  { 'id >': 5 },
  { 'id <': 10 },
  { 'id >=': 7 },
  { 'id <=': 8 },
  { 'id !=': 9 },
] });

----------------------------------------

TITLE: Generated SQL for Typed JSON Property Index in MySQL
DESCRIPTION: Shows the SQL query generated by MikroORM to create a typed index on a JSON property in MySQL. The query uses the JSON_VALUE function with a specified return type.

LANGUAGE: sql
CODE:
alter table `book`
  add index `book_meta_data_foo_index`((json_value(`meta_data`, '$.foo' returning char(200))));

----------------------------------------

TITLE: Demonstrating autoFlush behavior in MikroORM v3
DESCRIPTION: This snippet shows how the default autoFlush behavior has changed in v3. By default, changes are not automatically persisted to the database, requiring manual flushing.

LANGUAGE: typescript
CODE:
orm.em.persist(new Entity()); // no auto-flushing by default
await orm.em.flush();
await orm.em.persist(new Entity(), true); // you can still use second parameter to auto-flush

----------------------------------------

TITLE: Managing Read/Write Connections in MikroORM
DESCRIPTION: Shows various ways to work with read and write connections, including explicit connection type specification, transaction handling, and query builder usage. Demonstrates how the preferReadReplicas setting affects connection resolution.

LANGUAGE: typescript
CODE:
const connection = em.getConnection(); // write connection
const readConnection = em.getConnection('read'); // random read connection

const qb1 = em.createQueryBuilder(Author);
const res1 = await qb1.select('*').execute(); // random read connection

const qb2 = em.createQueryBuilder(Author, 'a', 'write');
const res2 = await qb2.select('*').execute(); // write connection

const qb3 = em.createQueryBuilder(Author);
const res3 = await qb3.update(...).where(...).execute(); // write connection

const res4 = await em.findOne(Author, 1, { connectionType: 'write' }); // explicit write connection

// all queries inside a transaction will use write connection
await em.transactional(async em => {
    const a = await em.findOne(Author, 1); // write connection
    const b = await em.findOne(Author, 1, { connectionType: 'read' }); // still a write connection - we are in a transaction
    a.name = 'test'; // will trigger update on write connection once flushed
});

// given a configuration where preferReadReplicas: false
const res5 = await em.findOne(Author, 1); // write connection - even for a read operation
const res6 = await em.findOne(Author, 1, { connectionType: 'read' }); // unless explicitly asking for a read replica

----------------------------------------

TITLE: Implementing Embeddable Entity for JSON Column
DESCRIPTION: Creating an embeddable entity to represent a JSON column for storing social media accounts.

LANGUAGE: typescript
CODE:
import { Embeddable, Property, type Opt } from "@mikro-orm/mysql";

@Embeddable()
export class Social {

  @Property({ type: 'string' })
  twitter!: string & Opt;

  @Property({ type: 'string' })
  facebook!: string & Opt;

  @Property({ type: 'string' })
  linkedin!: string & Opt;

}

----------------------------------------

TITLE: Using raw() Helper Function in MikroORM Queries - TypeScript
DESCRIPTION: Demonstrates how to use the raw() helper function to include raw SQL fragments in MikroORM queries. Shows usage as both values and keys, with operator support and empty array values.

LANGUAGE: typescript
CODE:
// as a value
await em.find(User, { time: raw('now()') });

// as a key
await em.find(User, { [raw('lower(name)')]: name.toLowerCase() });

// with operators
await em.find(User, { [raw('lower(name)')]: { $like: name.toLowerCase() } });

// value can be empty array to skip operator
await em.find(User, { [raw('(select 1 = 1)')]: [] });

----------------------------------------

TITLE: Initializing MikroORM with MongoDB
DESCRIPTION: Demonstrates how to initialize MikroORM with MongoDB, including setting up the connection and accessing the EntityManager.

LANGUAGE: typescript
CODE:
import { MikroORM } from '@mikro-orm/mongodb'; // or any other driver package

const orm = await MikroORM.init({
  entities: [Author, Book, ...],
  dbName: 'my-db-name',
  clientUrl: '...',
});
console.log(orm.em); // access EntityManager via `em` property

----------------------------------------

TITLE: Array Shorthand for $in Operator in MikroORM
DESCRIPTION: Demonstrates the shorthand syntax for the $in operator using a direct array value.

LANGUAGE: typescript
CODE:
const res = await orm.em.find(Author, { favouriteBook: [1, 2, 7] });

----------------------------------------

TITLE: Configuring EntityGenerator in MikroORM
DESCRIPTION: Example of how to register the EntityGenerator extension in the MikroORM configuration.

LANGUAGE: typescript
CODE:
import { defineConfig } from '@mikro-orm/postgresql';
import { EntityGenerator } from '@mikro-orm/entity-generator';

export default defineConfig({
  dbName: 'test',
  extensions: [EntityGenerator],
});

----------------------------------------

TITLE: Advanced Configuration for EntityGenerator in MikroORM
DESCRIPTION: Example of advanced configuration options for EntityGenerator in MikroORM, including entity schema generation, bidirectional relations, and more.

LANGUAGE: typescript
CODE:
const dump = await orm.entityGenerator.generate({
  entitySchema: true,
  bidirectionalRelations: true,
  identifiedReferences: true,
  esmImport: true,
  save: true,
  path: process.cwd() + '/my-entities',
  skipTables: ['book', 'author'],
  skipColumns: {
    'public.user': ['email', 'middle_name'],
  },
});

----------------------------------------

TITLE: Implementing Redis Cache Adapter
DESCRIPTION: Example class declaration showing how to implement a custom Redis cache adapter for MikroORM.

LANGUAGE: typescript
CODE:
export class RedisCacheAdapter implements CacheAdapter { ... }

----------------------------------------

TITLE: Basic Book Entity Definition
DESCRIPTION: Example of defining a basic Book entity with title and relationships to Author and Publisher using decorated class approach with reflect-metadata provider

LANGUAGE: typescript
CODE:
@Entity()
export class Book extends CustomBaseEntity {

  @Property()
  title!: string;

  @ManyToOne(() => Author)
  author!: Author;

  @ManyToOne(() => Publisher, { ref: true, nullable: true })
  publisher?: Ref<Publisher>;

  @ManyToMany({ entity: 'BookTag', fixedOrder: true })
  tags = new Collection<BookTag>(this);

}

----------------------------------------

TITLE: Basic Book Entity Definition
DESCRIPTION: Example of defining a basic Book entity with title and relationships to Author and Publisher using decorated class approach with reflect-metadata provider

LANGUAGE: typescript
CODE:
@Entity()
export class Book extends CustomBaseEntity {

  @Property()
  title!: string;

  @ManyToOne(() => Author)
  author!: Author;

  @ManyToOne(() => Publisher, { ref: true, nullable: true })
  publisher?: Ref<Publisher>;

  @ManyToMany({ entity: 'BookTag', fixedOrder: true })
  tags = new Collection<BookTag>(this);

}

----------------------------------------

TITLE: Configuring Entity Discovery in MikroORM
DESCRIPTION: Updated configuration for entity discovery in MikroORM v4, showing how to use the new 'entities' and 'entitiesTs' options to specify entity locations and types.

LANGUAGE: typescript
CODE:
MikroORM.init({
  entities: ['dist/**/entities', 'dist/**/*.entity.js', FooBar, FooBaz],
  entitiesTs: ['src/**/entities', 'src/**/*.entity.ts', FooBar, FooBaz],
});

----------------------------------------

TITLE: Complex Query with Nested Conditions in MikroORM (TypeScript)
DESCRIPTION: Demonstrates a complex query using nested conditions with $and operator and various comparison operators like $in, $nin, $gt, $lt, $gte, $lte, and $ne.

LANGUAGE: typescript
CODE:
const res = await orm.em.find(Author, { $and: [
  { id: { $in: [1, 2, 7] }, },
  { id: { $nin: [3, 4] }, },
  { id: { $gt: 5 }, },
  { id: { $lt: 10 }, },
  { id: { $gte: 7 }, },
  { id: { $lte: 8 }, },
  { id: { $ne: 9 }, },
] });

----------------------------------------

TITLE: Configuring SWC for MikroORM compatibility
DESCRIPTION: This snippet demonstrates the SWC configuration required for proper decorator metadata extraction and class name preservation when using MikroORM. It sets the necessary parser options, enables decorator metadata transformation, and targets the most modern JavaScript version.

LANGUAGE: json
CODE:
{
  "jsc": {
    "parser": {
      "syntax": "typescript",
      "decorators": true
    },
    "transform": {
      "decoratorMetadata": true,
      "legacyDecorator": true
    },
    "target": "esnext",
    "minify": false
  }
}

----------------------------------------

TITLE: Full-Text Search Entity Definition in MikroORM (PostgreSQL)
DESCRIPTION: Demonstrates how to define an entity for full-text search in PostgreSQL using MikroORM. It shows different approaches including using a dedicated column and custom configurations.

LANGUAGE: typescript
CODE:
import { FullTextType, WeightedFullTextValue } from '@mikro-orm/postgresql';

@Entity()
export class Book {

  @Property()
  title!: string;

  // example when using default settings
  @Index({ type: 'fulltext' })
  @Property({ type: FullTextType, onUpdate: (book) => book.title })
  searchableTitle!: string;

  // example when using a custom regconfig
  @Index({ type: 'fulltext' })
  @Property({ type: new FullTextType('english'), onUpdate: (book) => book.title })
  searchableTitle!: string;

  // example when using weights
  @Index({ type: 'fulltext' })
  @Property({ type: FullTextType, onUpdate: (book) => ({ A: book.title, B: book.description }) })
  searchableTitle!: WeightedFullTextValue;
}

----------------------------------------

TITLE: Configuring MikroORM Seeder Extension
DESCRIPTION: Initial setup for the seeder extension in MikroORM configuration file. Requires installing @mikro-orm/seeder package and registering SeedManager.

LANGUAGE: typescript
CODE:
import { SeedManager } from '@mikro-orm/seeder';

export default defineConfig({
  // ...
  extensions: [SeedManager],
})

----------------------------------------

TITLE: Using Result Cache with MikroORM QueryBuilder (TypeScript)
DESCRIPTION: Shows how to enable result caching when using the QueryBuilder in MikroORM. This example uses the default cache settings.

LANGUAGE: typescript
CODE:
const res = await em.createQueryBuilder(Book)
  .where({ author: { name: 'Jon Snow' } })
  .cache()
  .getResultList();

----------------------------------------

TITLE: Implementing Entity Filters in MikroORM 4
DESCRIPTION: Demonstration of defining and using filters for entities to control data visibility and implement features like soft deletes or tenant conditions.

LANGUAGE: typescript
CODE:
@Entity()
@Filter({ name: 'expensive', cond: { price: { $gt: 1000 } } })
@Filter({ name: 'long', cond: { 'length(text)': { $gt: 10000 } } })
@Filter({ name: 'hasAuthor', cond: { author: { $ne: null } }, default: true })
@Filter({ name: 'writtenBy', cond: args => ({ author: { name: args.name } }) })
export class Book {
  ...
}

const books1 = await orm.em.find(Book, {}, {
  filters: ['long', 'expensive'],
});
const books2 = await orm.em.find(Book, {}, {
  filters: { hasAuthor: false, long: true, writtenBy: { name: 'God' } },
});

----------------------------------------

TITLE: Configuring Path-based Entity Discovery
DESCRIPTION: Demonstrates how to configure MikroORM to discover entities using file paths and globs for both compiled JS and TypeScript source files.

LANGUAGE: typescript
CODE:
MikroORM.init({
  entities: ['./dist/modules/users/entities', './dist/modules/projects/entities'],
  entitiesTs: ['./src/modules/users/entities', './src/modules/projects/entities'],
  baseDir: process.cwd(),
});

----------------------------------------

TITLE: Implementing Custom Naming Strategy in TypeScript
DESCRIPTION: Example of implementing a custom naming strategy by creating a class that implements the NamingStrategy interface and configuring it during ORM initialization.

LANGUAGE: typescript
CODE:
class YourCustomNamingStrategy implements NamingStrategy {
  ...
}

const orm = await MikroORM.init({
  ...
  namingStrategy: YourCustomNamingStrategy,
  ...
});

----------------------------------------

TITLE: Defining Entity with Reference Wrapper in MikroORM
DESCRIPTION: This snippet shows how to define an entity using the Reference wrapper for improved type safety in ManyToOne relations.

LANGUAGE: typescript
CODE:
import { Entity, Ref, ManyToOne, PrimaryKey, ref } from '@mikro-orm/core';

@Entity()
export class Book {

  @PrimaryKey()
  id!: number;

  @ManyToOne(() => Author, { ref: true })
  author: Ref<Author>;

  constructor(author: Author) {
    this.author = ref(author);
  }

}

----------------------------------------

TITLE: Defining and Using Entity-Level Filters in TypeScript with MikroORM
DESCRIPTION: This snippet demonstrates how to define filters at the entity level using decorators, and how to apply these filters when querying entities. It shows various filter conditions, including static conditions and dynamic callbacks.

LANGUAGE: typescript
CODE:
@Entity()
@Filter({ name: 'expensive', cond: { price: { $gt: 1000 } } })
@Filter({ name: 'long', cond: { 'length(text)': { $gt: 10000 } } })
@Filter({ name: 'hasAuthor', cond: { author: { $ne: null } }, default: true })
@Filter({ name: 'writtenBy', cond: args => ({ author: { name: args.name } }) })
export class Book {
  ...
}

const books1 = await orm.em.find(Book, {}, {
  filters: ['long', 'expensive'],
});
const books2 = await orm.em.find(Book, {}, {
  filters: { hasAuthor: false, long: true, writtenBy: { name: 'God' } },
});

----------------------------------------

TITLE: MySQL/MariaDB Full-Text Search Entity Definition in MikroORM
DESCRIPTION: Demonstrates how to define an entity with full-text search capabilities in MySQL or MariaDB.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @Index({ type: 'fulltext' })
  @Property()
  title!: string;

}

----------------------------------------

TITLE: Configuring Specific Logger Namespaces
DESCRIPTION: Shows how to enable logging for specific namespaces while omitting others. In this example, only queries will be logged.

LANGUAGE: typescript
CODE:
return MikroORM.init({
  debug: ['query'], // now only queries will be logged
});

----------------------------------------

TITLE: Optimistic Locking with Date Version in MikroORM (TypeScript)
DESCRIPTION: Shows how to implement optimistic locking using a Date version field in a User entity. The @Property decorator is used with the version option set to true.

LANGUAGE: typescript
CODE:
export class User {
  // ...
  @Property({ version: true })
  version!: Date;
  // ...
}

----------------------------------------

TITLE: Forking EntityManager in MikroORM with TypeScript
DESCRIPTION: This snippet shows how to create a clean EntityManager with its own context and identity map using the fork() method.

LANGUAGE: typescript
CODE:
const em = orm.em.fork();

----------------------------------------

TITLE: Forking EntityManager in MikroORM with TypeScript
DESCRIPTION: This snippet shows how to create a clean EntityManager with its own context and identity map using the fork() method.

LANGUAGE: typescript
CODE:
const em = orm.em.fork();

----------------------------------------

TITLE: Deep Merging Object Properties with assign() in TypeScript
DESCRIPTION: This snippet shows how to enable deep merging of object properties using the mergeObjectProperties flag in the assign() method.

LANGUAGE: typescript
CODE:
import { wrap } from '@mikro-orm/core';

book.meta = { foo: 1, bar: 2 };

wrap(book).assign({ meta: { foo: 3 } }, { mergeObjectProperties: true });
console.log(book.meta); // { foo: 3, bar: 2 }

wrap(book).assign({ meta: { foo: 4 } });
console.log(book.meta); // { foo: 4 }

----------------------------------------

TITLE: Creating Entity Instance with EntitySchema
DESCRIPTION: Shows how to create and persist a new entity instance using EntityManager when working with EntitySchema.

LANGUAGE: typescript
CODE:
const repo = em.getRepository<Author>('Author');
const author = repo.create('Author', { name: 'name', email: 'email' }); // instance of internal Author class
await repo.persistAndFlush(author);

----------------------------------------

TITLE: Test Setup Utility Function
DESCRIPTION: Helper function for initializing test environment with in-memory database.

LANGUAGE: typescript
CODE:
import { bootstrap } from '../src/app.js';
import { initORM } from '../src/db.js';
import config from '../src/mikro-orm.config.js';

export async function initTestApp(port: number) {
  const { orm } = await initORM({
    ...config,
    debug: false,
    dbName: ':memory:',
  });

  await orm.schema.createSchema();

  const { app } = await bootstrap(port);

  return app;
}

----------------------------------------

TITLE: MongoDB Driver Connection
DESCRIPTION: Added support for reusing MongoDB client via driver options configuration

LANGUAGE: typescript
CODE:
// Reuse existing MongoDB client
const orm = await MikroORM.init({
  clientUrl: 'mongodb://localhost:27017',
  driverOptions: {
    client: existingMongoClient 
  }
});

----------------------------------------

TITLE: IWrappedEntity Interface Definition in MikroORM
DESCRIPTION: Defines the interface for wrapped entity helper methods provided by MikroORM

LANGUAGE: typescript
CODE:
interface IWrappedEntity<T, PK extends keyof T> {
  isInitialized(): boolean;
  populated(populated?: boolean): void;
  init(populated?: boolean, lockMode?: LockMode): Promise<T>;
  toReference(): IdentifiedReference<T, PK>;
  toObject(ignoreFields?: string[]): Dictionary;
  toJSON(...args: any[]): Dictionary;
  assign(data: any, options?: AssignOptions | boolean): T;
}

----------------------------------------

TITLE: Advanced Configuration for EntityGenerator in MikroORM
DESCRIPTION: Example of advanced configuration options for the EntityGenerator, including setting entity schema, bidirectional relations, and skipping tables and columns.

LANGUAGE: typescript
CODE:
const dump = await orm.entityGenerator.generate({
  entitySchema: true,
  bidirectionalRelations: true,
  identifiedReferences: true,
  esmImport: true,
  save: true,
  path: process.cwd() + '/my-entities',
  skipTables: ['book', 'author'],
  skipColumns: {
    'public.user': ['email', 'middle_name'],
  },
});

----------------------------------------

TITLE: Reference Types in MikroORM
DESCRIPTION: Enumeration of available reference types for entity relationships in MikroORM including one-to-one, many-to-one, and many-to-many mappings.

LANGUAGE: typescript
CODE:
export enum ReferenceType {
  SCALAR = 'scalar',
  ONE_TO_ONE = '1:1',
  MANY_TO_ONE = 'm:1',
  ONE_TO_MANY = '1:m',
  MANY_TO_MANY = 'm:n',
  EMBEDDED = 'embedded',
}

----------------------------------------

TITLE: Initializing MikroORM with Read Replicas
DESCRIPTION: Demonstrates how to initialize MikroORM with multiple read replica connections. Shows configuration of master and replica connection properties with the preferReadReplicas option.

LANGUAGE: typescript
CODE:
const orm = await MikroORM.init({
  entities: [Author, ...],
  dbName: `my_database`,
  user: 'master_user',
  host: 'master_host',
  preferReadReplicas: true, // optional property, defaults to true
  replicas: [
    { name: 'read-1', host: 'read_host_1', user: 'read_user' },
    { name: 'read-2', host: 'read_host_2' }, // user omitted, will be taken from master connection
  ],
});

----------------------------------------

TITLE: Assigning Data to New Entities in MikroORM v3 (TypeScript)
DESCRIPTION: Demonstrates how to use the assign() method on new (not managed) entities in v3, which now requires providing the EntityManager as a parameter. This is necessary because new entities no longer have an internal reference to the root EntityManager.

LANGUAGE: typescript
CODE:
const book = new Book();
wrap(book).assign(data, { em: orm.em });

----------------------------------------

TITLE: Using Native MongoDB Collection Methods with MikroORM
DESCRIPTION: Shows how to use native MongoDB collection methods like insert, update, delete, and aggregate through MikroORM's EntityManager and EntityRepository.

LANGUAGE: typescript
CODE:
em.insert<T extends AnyEntity>(entityName: string, data: any): Promise<IPrimaryKey>;
em.nativeUpdate<T extends AnyEntity>(entityName: string, where: FilterQuery<T>, data: any): Promise<number>;
em.nativeDelete<T extends AnyEntity>(entityName: string, where: FilterQuery<T> | any): Promise<number>;

EntityRepository.insert(data: any): Promise<IPrimaryKey>;
EntityRepository.nativeUpdate(where: FilterQuery<T>, data: any): Promise<number>;
EntityRepository.nativeDelete(where: FilterQuery<T> | any): Promise<number>;

em.aggregate(entityName: string, pipeline: any[]): Promise<any[]>;
EntityRepository.aggregate(pipeline: any[]): Promise<any[]>;

----------------------------------------

TITLE: Deep Merging Object Properties with assign() in TypeScript
DESCRIPTION: Shows how to enable deep merging of object properties when using assign() by setting the mergeObjectProperties flag.

LANGUAGE: typescript
CODE:
import { wrap } from '@mikro-orm/core';

book.meta = { foo: 1, bar: 2 };

wrap(book).assign({ meta: { foo: 3 } }, { mergeObjectProperties: true });
console.log(book.meta); // { foo: 3, bar: 2 }

wrap(book).assign({ meta: { foo: 4 } });
console.log(book.meta); // { foo: 4 }

----------------------------------------

TITLE: Creating Typed JSON Property Index in MySQL with MikroORM
DESCRIPTION: Demonstrates how to create a typed index on a JSON property in MySQL using MikroORM. It uses the @Index decorator with additional options to specify the return type.

LANGUAGE: typescript
CODE:
@Entity()
@Index({ properties: 'metaData.foo', options: { returning: 'char(200)' } })
export class Book {

  @Property({ type: 'json', nullable: true })
  metaData?: { foo: string; bar: number };

}

----------------------------------------

TITLE: Executing Schema Generator Commands via CLI in MikroORM
DESCRIPTION: Demonstrates how to use the MikroORM CLI to generate, update, and drop database schemas. It includes options for dumping SQL and running queries directly.

LANGUAGE: shell
CODE:
npx mikro-orm schema:create --dump   # Dumps create schema SQL
npx mikro-orm schema:update --dump   # Dumps update schema SQL
npx mikro-orm schema:drop --dump     # Dumps drop schema SQL

----------------------------------------

TITLE: Demonstrating AutoFlush Changes in TypeScript
DESCRIPTION: Shows the new default autoFlush behavior where manual flushing is required, with an option to enable auto-flushing per operation.

LANGUAGE: typescript
CODE:
orm.em.persist(new Entity()); // no auto-flushing by default
await orm.em.flush();
await orm.em.persist(new Entity(), true); // you can still use second parameter to auto-flush

----------------------------------------

TITLE: Populating Entity Relations
DESCRIPTION: Shows different ways to populate entity relations, including using the populate parameter and em.populate() helper.

LANGUAGE: typescript
CODE:
const books = await orm.em.find(Book, { foo: 1 }, ['author.friends']);

const authors = await orm.em.createQueryBuilder(Author).select('*').getResult();
await em.populate(authors, ['books.tags']);

// now your Author entities will have `books` collections populated,
// as well as they will have their `tags` collections populated.
console.log(authors[0].books[0].tags[0]); // initialized BookTag

----------------------------------------

TITLE: Querying Entities with EntityManager
DESCRIPTION: Example of querying entities using MikroORM's EntityManager, including iterating through relationships.

LANGUAGE: typescript
CODE:
const authors = em.find(Author, {});

for (const author of authors) {
  console.log(author); // instance of Author entity
  console.log(author.name); // Jon Snow

  for (const book of author.books) { // iterating books collection
    console.log(book); // instance of Book entity
    console.log(book.title); // My Life on The Wall, part 1/2/3
  }
}

----------------------------------------

TITLE: MySQL/MariaDB Timer Mock Configuration
DESCRIPTION: Specific timer mock configuration for MySQL/MariaDB database drivers in MikroORM testing environment.

LANGUAGE: typescript
CODE:
import { resolve, dirname } from 'node:path';
import { fakeTimersHooks, wrappedSpy } from './nextTickFixer';

export function enableFakeTimersWithMikroOrm() {
  const mysqlDir = dirname(require.resolve('mysql2'));
  return {
    mocks: [
      wrappedSpy(require(resolve(mysqlDir, 'lib/commands/query.js')).prototype, 'done', executeHooks),
      wrappedSpy(require(resolve(mysqlDir, 'lib/commands/ping.js')).prototype, 'pingResponse', executeHooks),
      wrappedSpy(require(resolve(mysqlDir, 'lib/commands/register_slave.js')).prototype, 'registerResponse', executeHooks),
      wrappedSpy(require(resolve(mysqlDir, 'lib/pool.js')).prototype, 'getConnection', executeHooks),
      wrappedSpy(require(resolve(mysqlDir, 'lib/pool.js')).prototype, 'releaseConnection', executeHooks),
      wrappedSpy(require(resolve(mysqlDir, 'lib/pool_cluster.js')).prototype, 'end', executeHooks),
    ],
    mockRestore: function () {
      let mock: jest.SpyInstance | undefined;
      while (mock = this.mocks.pop()) {
        mock.mockRestore();
      }
    }
  };
}

----------------------------------------

TITLE: Fetching and Traversing Entity Relationships
DESCRIPTION: Example of fetching entities and accessing their relationships, demonstrating initialized vs uninitialized relationships.

LANGUAGE: typescript
CODE:
const author = await orm.em.findOne(Author, '...id...');
const books = await orm.em.find(Book, {});

for (const author of authors) {
  console.log(author.name); // Jon Snow

  for (const book of author.books) {
    console.log(book.title); // initialized
    console.log(book.author.isInitialized()); // true
    console.log(book.author.id);
    console.log(book.author.name); // Jon Snow
    console.log(book.publisher); // just reference
    console.log(book.publisher.isInitialized()); // false
    console.log(book.publisher.id);
    console.log(book.publisher.name); // undefined
  }
}

----------------------------------------

TITLE: Configuring Babel Plugins for MikroORM Decorators
DESCRIPTION: Babel configuration required for proper decorator metadata extraction in MikroORM. Includes typescript-metadata transform plugin and decorator plugins with specific settings. Requires installing babel-plugin-transform-typescript-metadata, @babel/plugin-proposal-decorators, and @babel/plugin-proposal-class-properties as dev dependencies.

LANGUAGE: json
CODE:
{
  "plugins": [
    "babel-plugin-transform-typescript-metadata",
    ["@babel/plugin-proposal-decorators", { "legacy": true }],
    ["@babel/plugin-proposal-class-properties", { "loose": true  }]
  ]
}

----------------------------------------

TITLE: Using Custom DateType in Entity Definition
DESCRIPTION: Example of using the custom DateType in an entity class definition with MikroORM decorators.

LANGUAGE: typescript
CODE:
@Entity()
export class FooBar {

  @PrimaryKey()
  id!: number;

  @Property()
  name!: string;

  @Property({ type: DateType, length: 3 })
  born?: Date;

}

----------------------------------------

TITLE: Implementing Event Subscribers in MikroORM 4
DESCRIPTION: Example of creating an event subscriber to handle entity lifecycle events without polluting entity classes.

LANGUAGE: typescript
CODE:
import { EntityName, EventArgs, EventSubscriber, Subscriber } from '@mikro-orm/core';

@Subscriber()
export class AuthorSubscriber implements EventSubscriber<Author> {

  getSubscribedEntities(): EntityName<Author>[] {
    return [Author];
  }

  async afterCreate(args: EventArgs<Author>): Promise<void> {
    // ...
  }

  async afterUpdate(args: EventArgs<Author>): Promise<void> {
    // ...
  }

}

----------------------------------------

TITLE: Assigning References in MikroORM
DESCRIPTION: This code shows different ways to assign references to entity properties in MikroORM, including using Reference.create() and em.getReference().

LANGUAGE: typescript
CODE:
const book = await orm.em.findOne(Book, 1);
const repo = orm.em.getRepository(Author);

book.author = repo.getReference(2, true);

// same as:
book.author = Reference.create(repo.getReference(2));
await orm.em.flush();

// Using wrap() helper
const author = new Author(...)
book.author = wrap(author).toReference();

// Re-assigning existing reference
book.author.set(new Author(...));

----------------------------------------

TITLE: Defining Book Entity with Constructor in TypeScript
DESCRIPTION: This snippet demonstrates how to define a Book entity with a constructor that requires title and author. It shows the use of decorators for defining properties and relationships.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @PrimaryKey()
  id!: number;

  @Property()
  title: string;

  @Property()
  foo!: number;

  @ManyToOne()
  author: Author;

  @ManyToOne()
  publisher?: Publisher;

  @ManyToMany({ entity: () => BookTag, inversedBy: 'books' })
  tags = new Collection<BookTag>(this);

  constructor(title: string, author: Author) {
    this.title = title;
    this.author = author;
  }

}

----------------------------------------

TITLE: MongoDB Entity Schema Example
DESCRIPTION: Demonstrates how to define an entity schema specifically for MongoDB with ObjectId primary key.

LANGUAGE: typescript
CODE:
export class BookTag {
  _id!: ObjectId;
  id!: string;
  name: string;
  books = new Collection<Book>(this);

  constructor(name: string) {
    this.name = name;
  }
}

export const schema = new EntitySchema<BookTag>({
  class: BookTag,
  properties: {
    _id: { type: 'ObjectId', primary: true },
    id: { type: 'string', serializedPrimaryKey: true },
    name: { type: 'string' },
    books: { kind: 'm:n', entity: () => Book, mappedBy: book => book.tags },
  },
});

----------------------------------------

TITLE: Registering a Custom Repository with Entity in TypeScript
DESCRIPTION: This snippet demonstrates how to register a custom repository with an entity using the @Entity decorator. It shows the correct syntax for specifying the custom repository and avoiding circular dependencies.

LANGUAGE: typescript
CODE:
@Entity({ customRepository: () => CustomAuthorRepository })
export class Author {
  // ...
}

----------------------------------------

TITLE: Installing Express Plugin for AdminJS
DESCRIPTION: Commands for installing the Express plugin for AdminJS and its peer dependencies.

LANGUAGE: bash
CODE:
$ yarn add @adminjs/express
# Peer dependencies
$ yarn add express express-formidable express-session

----------------------------------------

TITLE: Configuring Event Subscribers in MikroORM
DESCRIPTION: Example of registering event subscribers in MikroORM initialization configuration.

LANGUAGE: typescript
CODE:
MikroORM.init({
  subscribers: [new AuthorSubscriber()],
});

----------------------------------------

TITLE: Implementing Implicit Transaction Handling in MikroORM
DESCRIPTION: Demonstrates basic implicit transaction handling through EntityManager's persistAndFlush method.

LANGUAGE: typescript
CODE:
const user = new User(...);
user.name = 'George';
await orm.em.persistAndFlush(user);

----------------------------------------

TITLE: Clearing Identity Map Cache
DESCRIPTION: Demonstrates how to clear the identity map cache using the EntityManager

LANGUAGE: typescript
CODE:
orm.em.clear();

----------------------------------------

TITLE: Configuring Custom Logger in MikroORM (TypeScript)
DESCRIPTION: This code demonstrates how to set up a custom logger in MikroORM. It enables debug mode and provides a custom logging function that uses a hypothetical 'myCustomLogger' object.

LANGUAGE: typescript
CODE:
return MikroORM.init({
  debug: true,
  logger: msg => myCustomLogger.log(msg),
});

----------------------------------------

TITLE: Implementing Global Filters in MikroORM
DESCRIPTION: Shows how to register and configure global filters that apply to all or specific entities, including setting filter parameters.

LANGUAGE: typescript
CODE:
// bound to entity, enabled by default
em.addFilter('writtenBy', args => ({ author: args.id }), Book);

// global, enabled by default, for all entities
em.addFilter('tenant', args => { ... });

// global, enabled by default, for only specified entities
em.addFilter('tenant', args => { ... }, [Author, Book]);
...

// set params (probably in some middleware)
em.setFilterParams('tenant', { tenantId: 123 });
em.setFilterParams('writtenBy', { id: 321 });

----------------------------------------

TITLE: Environment Variables Configuration
DESCRIPTION: Example of configuring MikroORM using environment variables in a .env file

LANGUAGE: dotenv
CODE:
MIKRO_ORM_TYPE = sqlite
MIKRO_ORM_ENTITIES = ./dist/foo/*.entity.js, ./dist/bar/*.entity.js
MIKRO_ORM_ENTITIES_TS = ./src/foo/*.entity.ts, ./src/bar/*.entity.ts
MIKRO_ORM_DB_NAME = test.db
MIKRO_ORM_MIGRATIONS_PATH = ./dist/migrations
MIKRO_ORM_MIGRATIONS_PATH_TS = ./src/migrations
MIKRO_ORM_POPULATE_AFTER_FLUSH = true
MIKRO_ORM_FORCE_ENTITY_CONSTRUCTOR = true
MIKRO_ORM_FORCE_UNDEFINED = true

----------------------------------------

TITLE: Enabling Fake Timers with MikroORM for MySQL/MariaDB
DESCRIPTION: This function sets up mocks for MySQL/MariaDB-specific methods that use process.nextTick(). It's essential for using Jest's fake timers with MikroORM when working with MySQL or MariaDB databases.

LANGUAGE: typescript
CODE:
import { resolve, dirname } from 'node:path';
import { fakeTimersHooks, wrappedSpy } from './nextTickFixer';

export function enableFakeTimersWithMikroOrm() {
  const mysqlDir = dirname(require.resolve('mysql2'));
  return {
    mocks: [
      wrappedSpy(require(resolve(mysqlDir, 'lib/commands/query.js')).prototype, 'done', executeHooks),
      wrappedSpy(require(resolve(mysqlDir, 'lib/commands/ping.js')).prototype, 'pingResponse', executeHooks),
      wrappedSpy(require(resolve(mysqlDir, 'lib/commands/register_slave.js')).prototype, 'registerResponse', executeHooks),
      wrappedSpy(require(resolve(mysqlDir, 'lib/pool.js')).prototype, 'getConnection', executeHooks),
      wrappedSpy(require(resolve(mysqlDir, 'lib/pool.js')).prototype, 'releaseConnection', executeHooks),
      wrappedSpy(require(resolve(mysqlDir, 'lib/pool_cluster.js')).prototype, 'end', executeHooks),
    ],
    mockRestore: function () {
      let mock: jest.SpyInstance | undefined;
      while (mock = this.mocks.pop()) {
        mock.mockRestore();
      }
    }
  };
}

----------------------------------------

TITLE: Adding Authentication to Express AdminJS Setup
DESCRIPTION: Example of implementing authentication in Express-based AdminJS setup using buildAuthenticatedRouter.

LANGUAGE: typescript
CODE:
const ADMIN_EMAIL = 'example@test.com';
const ADMIN_PASSWORD = 'password';

const router = AdminJSExpress.buildAuthenticatedRouter(admin, {
  authenticate: async (email, password) => {
    /* Your code for verifying email & password goes here */
    return email === ADMIN_EMAIL && password === ADMIN_PASSWORD
      ? { email } // the function should return an object containing user's data if authenticated successfully
      : null;
  },
  cookiePassword: process.env.COOKIE_PASSWORD ?? 'makesurepasswordissecure',
});

----------------------------------------

TITLE: Building MikroORM Website Static Content
DESCRIPTION: This command generates static content for the MikroORM website into the 'build' directory, ready for deployment on any static content hosting service.

LANGUAGE: bash
CODE:
$ yarn build

----------------------------------------

TITLE: Using Custom Driver with MikroORM
DESCRIPTION: Example of how to use a custom database driver with MikroORM by providing the driver class in the configuration.

LANGUAGE: typescript
CODE:
import { MyCustomDriver } from './MyCustomDriver.ts';

const orm = await MikroORM.init({
  entities: [Author, Book, ...],
  dbName: 'my-db-name',
  driver: MyCustomDriver, // provide the class, not just its name
});

----------------------------------------

TITLE: Basic Collection Usage in TypeScript with MikroORM
DESCRIPTION: Demonstrates basic collection operations including initialization, iteration, adding/removing items, and accessing collection items. Shows both eager and lazy loading approaches.

LANGUAGE: typescript
CODE:
const author = em.findOne(Author, '...', ['books']);

await author.books.init();

for (const book of author.books) {
  console.log(book.title);
  console.log(book.author.isInitialized());
  console.log(book.author.id);
  console.log(book.author.name);
  console.log(book.publisher);
  console.log(book.publisher.isInitialized());
  console.log(book.publisher.id);
  console.log(book.publisher.name);
}

author.books.add(book);
console.log(author.books.contains(book));
author.books.remove(book);
console.log(author.books.contains(book));
author.books.add(book);
console.log(author.books.count());
author.books.removeAll();
console.log(author.books.contains(book));
console.log(author.books.count());
console.log(author.books.getItems());
console.log(author.books.getIdentifiers());
console.log(author.books.getIdentifiers('_id'));

----------------------------------------

TITLE: Processing Generated Metadata in MikroORM EntityGenerator
DESCRIPTION: Example of using onInitialMetadata and onProcessedMetadata hooks to modify generated metadata, such as making password columns lazy and hidden, and hiding all ManyToMany relations.

LANGUAGE: typescript
CODE:
import { ReferenceKind } from '@mikro-orm/core';

await orm.entityGenerator.generate({
  onInitialMetadata: (metadata, platform) => {
    metadata.forEach(meta => {
      meta.props.forEach(prop => {
        if (prop.name === 'password') {
          prop.hidden = true;
          prop.lazy = true;
        }
      });
    });
  },
  onProcessedMetadata: (metadata, platform) => {
    metadata.forEach(meta => {
      meta.props.forEach(prop => {
        if (prop.kind === ReferenceKind.MANY_TO_MANY) {
          prop.hidden = true;
        }
      });
    });
  },
});

----------------------------------------

TITLE: Defining Entity with Manual Type Attributes in TypeScript
DESCRIPTION: This snippet demonstrates how to manually define type attributes for a MikroORM entity, which can be useful when deploying without TypeScript source files.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @PrimaryKey({ type: 'number' })
  id!: number;

  @Property({ type: 'string' })
  title!: string;

  @Enum(() => BookStatus)
  status?: BookStatus;

  @ManyToOne(() => Author) // or `@ManyToOne({ type: 'Author' })` or `@ManyToOne({ entity: () => Author })`
  author1!: Author;

  // or
  @ManyToOne({ type: 'Author' })
  author2!: Author;

  // or
  @ManyToOne({ entity: () => Author })
  author3!: Author;

}

export enum BookStatus {
  SOLD_OUT = 'sold',
  ACTIVE = 'active',
  UPCOMING = 'upcoming',
 }

----------------------------------------

TITLE: User Sign-up Route Implementation
DESCRIPTION: POST endpoint handler for user registration with email validation and password hashing

LANGUAGE: typescript
CODE:
app.post('/sign-up', async request => {
  const body = request.body as EntityData<User>;

  if (!body.email || !body.fullName || !body.password) {
    throw new Error('One of required fields is missing: email, fullName, password');
  }

  if ((await db.user.count({ email: body.email })) === 0) {
    throw new Error('This email is already registered, maybe you want to sign in?');
  }

  const user = new User(body.fullName, body.email, body.password);
  user.bio = body.bio ?? '';
  await db.em.persist(user).flush();

  console.log(`User ${user.id} created`);

  return user;
});

----------------------------------------

TITLE: Applying and Controlling Filters in MikroORM Queries with TypeScript
DESCRIPTION: This example demonstrates various ways to control filter application in MikroORM queries. It shows how to enable specific filters, disable default filters, pass parameters to filters, and completely disable all filters for a particular query.

LANGUAGE: typescript
CODE:
em.find(Book, {}); // same as `{ tenantId: 123 }`
em.find(Book, {}, { filters: ['writtenBy'] }); // same as `{ author: 321, tenantId: 123 }`
em.find(Book, {}, { filters: { tenant: false } }); // disabled tenant filter, so truly `{}`
em.find(Book, {}, { filters: false }); // disabled all filters, so truly `{}`

----------------------------------------

TITLE: Interface Definition for SchemaGenerator
DESCRIPTION: TypeScript interface defining the methods available on the SchemaGenerator in v5.0.0

LANGUAGE: typescript
CODE:
interface SchemaGenerator {
  generate(): Promise<string>;
  createSchema(options?: { wrap?: boolean }): Promise<void>;
  ensureDatabase(): Promise<void>;
  getCreateSchemaSQL(options?: { wrap?: boolean }): Promise<string>;
  dropSchema(options?: { wrap?: boolean; dropMigrationsTable?: boolean; dropDb?: boolean }): Promise<void>;
  getDropSchemaSQL(options?: { wrap?: boolean; dropMigrationsTable?: boolean }): Promise<string>;
  updateSchema(options?: { wrap?: boolean; safe?: boolean; dropDb?: boolean; dropTables?: boolean }): Promise<void>;
  getUpdateSchemaSQL(options?: { wrap?: boolean; safe?: boolean; dropDb?: boolean; dropTables?: boolean }): Promise<string>;
  createDatabase(name: string): Promise<void>;
  dropDatabase(name: string): Promise<void>;
  execute(sql: string, options?: { wrap?: boolean }): Promise<void>;
}

----------------------------------------

TITLE: Installing MikroORM with NestJS Dependencies
DESCRIPTION: Commands to install MikroORM core, NestJS module and database-specific drivers using npm or yarn.

LANGUAGE: bash
CODE:
$ yarn add @mikro-orm/core @mikro-orm/nestjs @mikro-orm/mongodb     # for mongo
$ yarn add @mikro-orm/core @mikro-orm/nestjs @mikro-orm/mysql       # for mysql/mariadb
$ yarn add @mikro-orm/core @mikro-orm/nestjs @mikro-orm/mariadb     # for mysql/mariadb
$ yarn add @mikro-orm/core @mikro-orm/nestjs @mikro-orm/postgresql  # for postgresql
$ yarn add @mikro-orm/core @mikro-orm/nestjs @mikro-orm/sqlite      # for sqlite

----------------------------------------

TITLE: Discriminator Value Configuration in MikroORM
DESCRIPTION: Demonstrates alternative approach to STI using discriminatorValue instead of discriminatorMap for controlling inheritance mapping tokens.

LANGUAGE: typescript
CODE:
@Entity({
  discriminatorColumn: 'discr',
  discriminatorValue: 'person',
})
export class Person {
  // ...
}

@Entity({
  discriminatorValue: 'employee',
})
export class Employee extends Person {
  // ...
}

----------------------------------------

TITLE: Initializing MikroORM with JavaScript Entities
DESCRIPTION: Example of initializing MikroORM with JavaScript entities by registering them in the configuration object.

LANGUAGE: javascript
CODE:
const orm = await MikroORM.init({
  entities: [Author, Book, BookTag, BaseEntity],
  dbName: 'my-db-name',
});

----------------------------------------

TITLE: Setting Up Request Context and Authentication Hook
DESCRIPTION: This section adds hooks to create a request context for MikroORM and handle JWT authentication for each request.

LANGUAGE: TypeScript
CODE:
app.addHook("onRequest", (request, reply, done) => {
  RequestContext.create(db.em, done);
});

app.addHook("onRequest", async (request) => {
  try {
    const ret = await request.jwtVerify<{ id: number }>();
    request.user = await db.user.findOneOrFail(ret.id);
  } catch (e) {
    app.log.error(e);
  }
});

----------------------------------------

TITLE: Explicit Transaction Handling with Callback in MikroORM
DESCRIPTION: Shows how to use the transactional method with a callback function for explicit transaction control in MikroORM.

LANGUAGE: typescript
CODE:
await orm.em.transactional(em => {
  //... do some work
  const user = new User(...);
  user.name = 'George';
  em.persist(user);
});

----------------------------------------

TITLE: Reference Types in MikroORM
DESCRIPTION: Enumeration of available reference types for entity relationships in MikroORM, including scalar and various relationship types.

LANGUAGE: typescript
CODE:
export enum ReferenceType {
  SCALAR = 'scalar',
  MANY_TO_ONE = 'm:1',
  ONE_TO_MANY = '1:m',
  MANY_TO_MANY = 'm:n',
}

----------------------------------------

TITLE: Defining Basic Book Entity Schema in TypeScript
DESCRIPTION: Demonstrates how to define a Book entity schema with relationships to Author, Publisher and BookTags using EntitySchema helper.

LANGUAGE: typescript
CODE:
export interface Book extends BaseEntity {
  title: string;
  author: Author;
  publisher: Publisher;
  tags: Collection<BookTag>;
}

export const schema = new EntitySchema<Book, BaseEntity>({
  name: 'Book',
  extends: 'BaseEntity',
  properties: {
    title: { type: 'string' },
    author: { reference: 'm:1', entity: 'Author', inversedBy: 'books' },
    publisher: { reference: 'm:1', entity: 'Publisher', inversedBy: 'books' },
    tags: { reference: 'm:n', entity: 'BookTag', inversedBy: 'books', fixedOrder: true },
  },
});

----------------------------------------

TITLE: Implementing Authentication in Hapi with AdminJS
DESCRIPTION: TypeScript code snippet showing how to add authentication to an AdminJS Hapi setup by modifying the adminOptions object.

LANGUAGE: typescript
CODE:
const ADMIN_EMAIL = 'example@test.com';
const ADMIN_PASSWORD = 'password';

const adminOptions = {
  databases: [orm],
  auth: {
    authenticate: async (email, password) => {
      /* Your code for verifying email & password goes here */
      return email === ADMIN_EMAIL && password === ADMIN_PASSWORD
        ? { email } // the function should return an object containing user's data if authenticated successfully
        : null;
    },
    strategy: 'session',
    cookiePassword: process.env.COOKIE_PASSWORD ?? 'makesurepasswordissecure',
    isSecure: false, // only https requests
  },
};

----------------------------------------

TITLE: Type-Safe Entity Finder with EntitySchema
DESCRIPTION: Demonstration of how to use EntitySchema instances for type-safe entity finding, particularly useful when working with interfaces instead of classes.

LANGUAGE: typescript
CODE:
const author = await em.findOne(AuthorSchema, { ... }, ['books']);
console.log(author.books.get()); // `get()` is now inferred correctly

----------------------------------------

TITLE: Setting up MikroORM with Hapi and AdminJS
DESCRIPTION: Complete setup example showing MikroORM initialization, AdminJS configuration, and Hapi server setup

LANGUAGE: typescript
CODE:
import AdminJS from 'adminjs';
import { Database, Resource } from '@adminjs/mikroorm';
import AdminJSHapi from '@adminjs/hapi';
import { MikroORM } from '@mikro-orm/postgresql';
import { validate } from 'class-validator'; // optional

const PORT = process.env.PORT ?? 3000;

const run = async () => {
  /* Initialize MikroORM like you would do normally, you can also import your MikroORM instance from a separate file */
  const orm = await MikroORM.init({
    entities: [User, Car, Seller], // use your own entities
    dbName: process.env.DATABASE_NAME,
    clientUrl: process.env.DATABASE_URL,
  });

  /* Optional: if you're using class-validator, assign it to Resource */
  Resource.validate = validate;
  /* Tell AdminJS which adapter to use */
  AdminJS.registerAdapter({ Database, Resource });

  const server = Hapi.server({ port: PORT })

  /* Configure AdminJS */
  const adminOptions = {
    databases: [orm],
  };

  /* Register AdminJS as a Hapi server's plugin */
  await server.register({
    plugin: AdminJSHapi,
    options: adminOptions,
  });

  await server.start();
  console.log(`App listening at ${server.info.uri}`);
}

run();

----------------------------------------

TITLE: Pessimistic Lock Usage
DESCRIPTION: Shows how to implement pessimistic locking in database transactions for concurrent access control.

LANGUAGE: typescript
CODE:
await em.transactional(async _em => {
  await _em.findOne(Author, id, { lockMode: LockMode.PESSIMISTIC_WRITE });
});

----------------------------------------

TITLE: Configuring Basic Entity Discovery in MikroORM
DESCRIPTION: Shows how to configure entity discovery by providing an array of entity classes or using folder-based discovery with TypeScript support.

LANGUAGE: typescript
CODE:
MikroORM.init({
  entities: [Author, Book, Publisher, BookTag],
});

LANGUAGE: typescript
CODE:
MikroORM.init({
  entities: ['./dist/modules/users/entities', './dist/modules/projects/entities'],
  entitiesTs: ['./src/modules/users/entities', './src/modules/projects/entities'],
  baseDir: process.cwd(),
});

----------------------------------------

TITLE: Injecting Repository in NestJS Service
DESCRIPTION: Example of injecting a repository into a NestJS service using the @InjectRepository decorator.

LANGUAGE: typescript
CODE:
@Injectable()
export class PhotoService {
  constructor(
    @InjectRepository(Photo)
    private readonly photoRepository: EntityRepository<Photo>
  ) {}

  // ...
}

----------------------------------------

TITLE: Implementing FooBar Entity Subscriber with onFlush Event
DESCRIPTION: Example of an event subscriber that creates and links entities during the flush operation using UnitOfWork change sets.

LANGUAGE: typescript
CODE:
export class FooBarSubscriber implements EventSubscriber {

  async onFlush(args: FlushEventArgs): Promise<void> {
    const changeSets = args.uow.getChangeSets();
    const cs = changeSets.find(cs => cs.type === ChangeSetType.CREATE && cs.entity instanceof FooBar);

    if (cs) {
      const baz = new FooBaz();
      baz.name = 'dynamic';
      cs.entity.baz = baz;
      args.uow.computeChangeSet(baz);
      args.uow.recomputeSingleChangeSet(cs.entity);
    }
  }

}

const bar = new FooBar();
bar.name = 'bar';
await em.persist(bar).flush();

----------------------------------------

TITLE: Implementing Custom RedisCacheAdapter in MikroORM (TypeScript)
DESCRIPTION: This snippet shows a skeleton implementation of a custom RedisCacheAdapter class that implements the CacheAdapter interface for use with MikroORM.

LANGUAGE: typescript
CODE:
export class RedisCacheAdapter implements CacheAdapter { ... }

----------------------------------------

TITLE: Using Loaded Type with Populated Relations in MikroORM
DESCRIPTION: This snippet demonstrates how to use the Loaded type for type-safe access to populated relations in MikroORM.

LANGUAGE: typescript
CODE:
// res is of type `Loaded<User, 'identity'>`
const user = await em.findOneOrFail(User, 1, { populate: ['identity'] });

// instead of the async `await user.identity.load()` call that would ensure the relation is loaded
// you can use the dynamically added `$` symbol for synchronous and type-safe access to it:
console.log(user.identity.$.email);

----------------------------------------

TITLE: Initializing Entity Reference in MikroORM
DESCRIPTION: This code demonstrates how to check if an entity is initialized and how to initialize it using the wrap helper function.

LANGUAGE: typescript
CODE:
const author = em.getReference(123);
console.log(author.id); // accessing the id will not trigger any db call
console.log(wrap(author).isInitialized()); // false
console.log(author.name); // undefined

await wrap(author).init(); // this will trigger db call
console.log(wrap(author).isInitialized()); // true
console.log(author.name); // defined

----------------------------------------

TITLE: Sample Query Logs from MikroORM
DESCRIPTION: This snippet demonstrates the format of query logs produced by MikroORM when logging is enabled. It shows various database operations including SELECT, START TRANSACTION, INSERT, and COMMIT.

LANGUAGE: plaintext
CODE:
[query-logger] SELECT `e0`.* FROM `author` AS `e0` WHERE `e0`.`name` = ? LIMIT ? [took 2 ms]
[query-logger] START TRANSACTION [took 1 ms]
[query-logger] INSERT INTO `author` (`name`, `email`, `created_at`, `updated_at`, `terms_accepted`) VALUES (?, ?, ?, ?, ?) [took 2 ms]
[query-logger] COMMIT [took 2 ms]

----------------------------------------

TITLE: Registering Custom Repository in Entity Decorator with TypeScript
DESCRIPTION: Demonstrates how to register a custom repository using the @Entity decorator instead of the @Repository decorator on the repository class.

LANGUAGE: typescript
CODE:
@Entity({ customRepository: () => CustomAuthorRepository })
export class Author {
  // ...
}

----------------------------------------

TITLE: Installing AdminJS Core and MikroORM Adapter
DESCRIPTION: Commands for installing AdminJS core and MikroORM adapter packages using yarn. Includes options for different database drivers.

LANGUAGE: bash
CODE:
$ yarn add adminjs
$ yarn add @adminjs/mikroorm
# A MikroORM driver and core package, choose the one which suits you:
$ yarn add @mikro-orm/core @mikro-orm/mongodb     # for mongo
$ yarn add @mikro-orm/core @mikro-orm/mysql       # for mysql
$ yarn add @mikro-orm/core @mikro-orm/mariadb     # for mariadb
$ yarn add @mikro-orm/core @mikro-orm/postgresql  # for postgresql
$ yarn add @mikro-orm/core @mikro-orm/sqlite      # for sqlite

----------------------------------------

TITLE: Using Custom AsyncLocalStorage with MikroORM in TypeScript
DESCRIPTION: This snippet shows how to use a custom AsyncLocalStorage instance with MikroORM for request context management.

LANGUAGE: typescript
CODE:
const storage = new AsyncLocalStorage<EntityManager>();

const orm = await MikroORM.init({
  context: () => storage.getStore(),
  // ...
});

app.use((req, res, next) => {
  storage.run(orm.em.fork({ useContext: true }), next);
});

----------------------------------------

TITLE: Generated SQL Query for JSON Property (PostgreSQL)
DESCRIPTION: Displays the SQL query generated by MikroORM when querying JSON object properties in PostgreSQL. The query uses JSON operators to access nested properties and cast them to appropriate types.

LANGUAGE: sql
CODE:
select "e0".*
from "book" as "e0"
where ("meta"->>'valid')::bool = true
  and "meta"->>'nested'->>'foo' = '123'
  and ("meta"->>'nested'->>'bar')::float8 = 321
  and ("meta"->>'nested'->'deep'->>'baz')::float8 = 59
  and ("meta"->>'nested'->'deep'->>'qux')::bool = false
limit 1

----------------------------------------

TITLE: Explicit Discriminator Column Implementation in TypeScript
DESCRIPTION: Demonstrates how to implement an explicit discriminator column for Single Table Inheritance, allowing for type-based querying and serialization control.

LANGUAGE: typescript
CODE:
@Entity({
  discriminatorColumn: 'type',
  discriminatorMap: { person: 'Person', employee: 'Employee' },
})
export abstract class BasePerson {

  @Enum()
  type!: 'person' | 'employee';

}

@Entity()
export class Person extends BasePerson {
  // ...
}

@Entity()
export class Employee extends Person {
  // ...
}

----------------------------------------

TITLE: MS SQL Server Driver Addition
DESCRIPTION: Implementation of Microsoft SQL Server driver support

LANGUAGE: markdown
CODE:
* **mssql:** add MS SQL Server driver ([#1375](https://github.com/mikro-orm/mikro-orm/issues/1375)) ([eeaad45](https://github.com/mikro-orm/mikro-orm/commit/eeaad45a60b3ef4732d5ba9eafc8719998e52181)), closes [#771](https://github.com/mikro-orm/mikro-orm/issues/771)

----------------------------------------

TITLE: Using Type-Safe OrderBy Parameter in MikroORM v5
DESCRIPTION: Demonstration of the new type-safe orderBy parameter in MikroORM v5. This example shows how to use an array of objects to specify multiple ordering criteria for a query.

LANGUAGE: typescript
CODE:
const books = await em.find(Book, {}, {
  orderBy: [
    { title: 1 },
    { author: { name: -1 } },
  ],
});

----------------------------------------

TITLE: MongoDB Entity Schema Definition in TypeScript
DESCRIPTION: This snippet shows how to define an EntitySchema for MongoDB in MikroORM. It includes MongoDB-specific fields like _id (ObjectId) and a serialized string id.

LANGUAGE: typescript
CODE:
export class BookTag {
  _id!: ObjectId;
  id!: string;
  name: string;
  books = new Collection<Book>(this);

  constructor(name: string) {
    this.name = name;
  }
}

export const schema = new EntitySchema<BookTag>({
  class: BookTag,
  properties: {
    _id: { type: 'ObjectId', primary: true },
    id: { type: 'string', serializedPrimaryKey: true },
    name: { type: 'string' },
    books: { reference: 'm:n', entity: () => Book, mappedBy: book => book.tags },
  },
});

----------------------------------------

TITLE: Querying Entities in Specific Schemas with MikroORM
DESCRIPTION: This code snippet shows how to query for an entity in a specific schema using EntityManager in MikroORM. It demonstrates the use of the 'schema' option in the findOne method.

LANGUAGE: typescript
CODE:
const user = await em.findOne(User, { ... }, { schema: 'client-123' });

----------------------------------------

TITLE: Defining Entity Properties with ReflectMetadataProvider
DESCRIPTION: These code snippets showcase various ways to define entity properties when using ReflectMetadataProvider, including explicit types, collections, enums, and circular dependencies.

LANGUAGE: typescript
CODE:
@Property()
createdAt: Date = new Date();

@OneToMany(() => Book, b => b.author)
books = new Collection<Book>(this);

@ManyToOne(() => Publisher, { ref: true })
publisher!: Ref<Publisher>;

@Property({ nullable: true })
prop?: string;

@Enum(() => UserRole)
role: UserRole;

@Enum({ type: 'UserRole' })
role: UserRole;

@Enum({ items: ['a', 'b', 'c'] })
role: UserRole;

@ManyToOne({ entity: () => Author })
author: Author;

----------------------------------------

TITLE: Configuring Babel plugins for MikroORM decorator support
DESCRIPTION: This configuration enables proper handling of TypeScript decorators in Babel for use with MikroORM. It includes necessary plugins for metadata extraction and class properties.

LANGUAGE: json
CODE:
{
  "plugins": [
    "babel-plugin-transform-typescript-metadata",
    ["@babel/plugin-proposal-decorators", { "legacy": true }],
    ["@babel/plugin-proposal-class-properties", { "loose": true  }]
  ]
}

----------------------------------------

TITLE: Installing AdminJS Core and MikroORM Adapter
DESCRIPTION: Commands for installing AdminJS core and MikroORM adapter along with necessary database drivers.

LANGUAGE: bash
CODE:
$ yarn add adminjs
$ yarn add @adminjs/mikroorm
# A MikroORM driver and core package, choose the one which suits you:
$ yarn add @mikro-orm/core @mikro-orm/mongodb     # for mongo
$ yarn add @mikro-orm/core @mikro-orm/mysql       # for mysql
$ yarn add @mikro-orm/core @mikro-orm/mariadb     # for mariadb
$ yarn add @mikro-orm/core @mikro-orm/postgresql  # for postgresql
$ yarn add @mikro-orm/core @mikro-orm/sqlite      # for sqlite

----------------------------------------

TITLE: Injecting Repository in NestJS Service
DESCRIPTION: Example of injecting a repository into a NestJS service using the @InjectRepository decorator.

LANGUAGE: typescript
CODE:
@Injectable()
export class PhotoService {
  constructor(
    @InjectRepository(Photo)
    private readonly photoRepository: EntityRepository<Photo>
  ) {}

  // ...
}

----------------------------------------

TITLE: Reference Kind Enum Definition in TypeScript
DESCRIPTION: Enumeration of available reference kinds for entity relationships in MikroORM, including scalar, one-to-one, many-to-one, one-to-many, many-to-many, and embedded.

LANGUAGE: typescript
CODE:
enum ReferenceKind {
  SCALAR = 'scalar',
  ONE_TO_ONE = '1:1',
  MANY_TO_ONE = 'm:1',
  ONE_TO_MANY = '1:m',
  MANY_TO_MANY = 'm:n',
  EMBEDDED = 'embedded',
}

----------------------------------------

TITLE: Synchronizing Database Schema with MikroORM CLI
DESCRIPTION: This command uses the MikroORM CLI to update the database schema based on entity definitions.

LANGUAGE: sh
CODE:
npx mikro-orm schema:update --run

----------------------------------------

TITLE: Explicit Type Declaration for Property Initializers
DESCRIPTION: Demonstration of how to explicitly state the property type when using property initializers with ReflectMetadataProvider to ensure correct type inference.

LANGUAGE: typescript
CODE:
@Property()
createdAt: Date = new Date();

----------------------------------------

TITLE: Defining User Entity in MikroORM
DESCRIPTION: Example of defining a User entity using MikroORM decorators.

LANGUAGE: typescript
CODE:
import { Entity, PrimaryKey, Property } from '@mikro-orm/core';

@Entity()
export class User {

   @PrimaryKey()
   id!: number;

   @Property()
   fullName!: string;

   @Property()
   email!: string;

   @Property()
   password!: string;

   @Property({ type: 'text' })
   bio = '';

}

----------------------------------------

TITLE: Custom Entity Serialization Implementation
DESCRIPTION: Example of implementing custom toJSON method in a Book entity with property stripping functionality.

LANGUAGE: typescript
CODE:
@Entity()
class Book {

  // ...

  toJSON(strict = true, strip = ['id', 'email'], ...args: any[]): { [p: string]: any } {
    const o = wrap(this, true).toObject(...args); // do not forget to pass rest params here

    if (strict) {
      strip.forEach(k => delete o[k]);
    }

    return o;
  }

}

----------------------------------------

TITLE: Transactional Callback Pattern
DESCRIPTION: Shows the recommended approach for transaction handling using the transactional callback pattern.

LANGUAGE: typescript
CODE:
await orm.em.transactional(async _em => {
  //... do some work
  const user = new User(...);
  user.name = 'George';
  _em.persistLater(user);
});

----------------------------------------

TITLE: Query-Level Loading Strategy Configuration
DESCRIPTION: Examples demonstrating how to specify loading strategies at query time, including both single-level and nested relationship loading.

LANGUAGE: typescript
CODE:
// one level
const author = await orm.em.findOne(Author, 1, {
  populate: {
    books: LoadStrategy.JOINED,
  },
});

// two or more levels - use `FindOptions.strategy`
const author = await orm.em.findOne(Author, 1, {
  populate: {
    books: { publisher: true },
  },
  strategy: LoadStrategy.JOINED
});

----------------------------------------

TITLE: Fixing TypeScript Property Initialization in MikroORM Entities
DESCRIPTION: Shows how to properly initialize entity properties in TypeScript to avoid issues with type inference. This is particularly relevant when using the default ReflectMetadataProvider.

LANGUAGE: ts
CODE:
@Property()
foo: string = 'abc';

----------------------------------------

TITLE: Installing MikroORM with NestJS
DESCRIPTION: Commands to install MikroORM core, NestJS module, and database-specific drivers using yarn or npm.

LANGUAGE: bash
CODE:
$ yarn add @mikro-orm/core @mikro-orm/nestjs @mikro-orm/mongodb     # for mongo
$ yarn add @mikro-orm/core @mikro-orm/nestjs @mikro-orm/mysql       # for mysql/mariadb
$ yarn add @mikro-orm/core @mikro-orm/nestjs @mikro-orm/mariadb     # for mysql/mariadb
$ yarn add @mikro-orm/core @mikro-orm/nestjs @mikro-orm/postgresql  # for postgresql
$ yarn add @mikro-orm/core @mikro-orm/nestjs @mikro-orm/sqlite      # for sqlite

LANGUAGE: bash
CODE:
$ npm i -s @mikro-orm/core @mikro-orm/nestjs @mikro-orm/mongodb     # for mongo
$ npm i -s @mikro-orm/core @mikro-orm/nestjs @mikro-orm/mysql       # for mysql/mariadb
$ npm i -s @mikro-orm/core @mikro-orm/nestjs @mikro-orm/mariadb     # for mysql/mariadb
$ npm i -s @mikro-orm/core @mikro-orm/nestjs @mikro-orm/postgresql  # for postgresql
$ npm i -s @mikro-orm/core @mikro-orm/nestjs @mikro-orm/sqlite      # for sqlite

----------------------------------------

TITLE: Using Default Schema with EntityManager Fork in MikroORM
DESCRIPTION: This code demonstrates how to use a default schema by forking the EntityManager. It shows how to perform a find operation and create an entity using the forked EntityManager with a default schema.

LANGUAGE: typescript
CODE:
const fork = em.fork({ schema: 'client-123' });
await fork.findOne(User, { ... });

// Will yield the same result as 
const user = await em.findOne(User, { ... }, { schema: 'client-123' });

// When creating an entity
const fork = em.fork({ schema: 'client-123' });
const user = new User();
user.email = 'foo@bar.com';
await fork.persistAndFlush(user);

// Will yield the same result as
const qb = em.createQueryBuilder(User);
await qb.insert({ email: 'foo@bar.com' }).withSchema('client-123');

----------------------------------------

TITLE: Defining ManyToOne Relation in TypeScript with MikroORM
DESCRIPTION: This snippet shows how to define a ManyToOne relation using the @ManyToOne decorator in a TypeScript entity class.

LANGUAGE: typescript
CODE:
@ManyToOne(() => Author)
author!: Author; // the value is always instance of the `Author` entity

----------------------------------------

TITLE: Defining ManyToMany Relationships (Inverse Side) in TypeScript with MikroORM
DESCRIPTION: This snippet shows how to define the inverse side of a ManyToMany relationship in MikroORM using TypeScript. It demonstrates the use of the `mappedBy` attribute to point to the owning side of the relationship.

LANGUAGE: typescript
CODE:
@Entity()
export class BookTag {

  // inverse side has to point to the owning side via `mappedBy` attribute/parameter
  @ManyToMany(() => Book, book => book.tags)
  books = new Collection<Book>(this);

}

----------------------------------------

TITLE: Enabling Pretty Printing for Metadata Cache in MikroORM (TypeScript)
DESCRIPTION: This code shows how to enable pretty printing for cached metadata when initializing MikroORM. It sets the 'pretty' option to true in the cache configuration.

LANGUAGE: typescript
CODE:
await MikroORM.init({
  cache: { pretty: true },
  // ...
});

----------------------------------------

TITLE: Custom Cache Adapter Interface Definition
DESCRIPTION: Interface definition for implementing custom cache adapters with methods for getting, setting, clearing, and closing cache operations.

LANGUAGE: typescript
CODE:
export interface CacheAdapter {

  /**
   * Gets the items under `name` key from the cache.
   */
  get(name: string): Promise<any>;

  /**
   * Sets the item to the cache. `origin` is used for cache invalidation and should reflect the change in data.
   */
  set(name: string, data: any, origin: string, expiration?: number): Promise<void>;

  /**
   * Clears all items stored in the cache.
   */
  clear(): Promise<void>;

  /**
   * Called inside `MikroORM.close()` Allows graceful shutdowns (e.g. for redis).
   */
  close?(): Promise<void>;

}

----------------------------------------

TITLE: MySQL Table Creation with Underscore Naming Strategy
DESCRIPTION: SQL example demonstrating how the UnderscoreNamingStrategy transforms entity properties into database column names using lowercase and underscore separation.

LANGUAGE: sql
CODE:
CREATE TABLE `author` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `created_at` datetime(3) DEFAULT NULL,
  `updated_at` datetime(3) DEFAULT NULL,
  `terms_accepted` tinyint(1) DEFAULT NULL,
  `name` varchar(255) DEFAULT NULL,
  `email` varchar(255) DEFAULT NULL,
  `born` datetime DEFAULT NULL,
  `favourite_book_id` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

----------------------------------------

TITLE: Defining FindOptions Interface in TypeScript
DESCRIPTION: TypeScript interface that defines the available options for the find() method in EntityManager. Includes options for pagination, ordering, filtering, and population of relations.

LANGUAGE: typescript
CODE:
export interface FindOptions<T, P extends Populate<T> = Populate<T>> {
  populate?: P;
  orderBy?: QueryOrderMap;
  limit?: number;
  offset?: number;
  refresh?: boolean;
  convertCustomTypes?: boolean;
  fields?: string[];
  schema?: string;
  flags?: QueryFlag[];
  groupBy?: string | string[];
  having?: QBFilterQuery<T>;
  strategy?: LoadStrategy;
  filters?: Dictionary<boolean | Dictionary> | string[] | boolean;
}

----------------------------------------

TITLE: Defining Parameterless Filters in MikroORM
DESCRIPTION: Demonstrates how to create a filter without parameters while still accessing the operation type. The 'args: false' option is used to prevent errors due to missing parameters.

LANGUAGE: typescript
CODE:
@Filter({
  name: 'withoutParams',
  cond(_, type) {
    return { ... };
  },
  args: false,
  default: true,
})

----------------------------------------

TITLE: Generating MikroORM Cache Bundle
DESCRIPTION: CLI command to generate a production cache bundle into a single JSON file

LANGUAGE: bash
CODE:
npx mikro-orm cache:generate --combined

----------------------------------------

TITLE: Injecting EntityManager in NestJS Service
DESCRIPTION: Demonstrates how to inject and use the EntityManager in a NestJS service class.

LANGUAGE: typescript
CODE:
import { MikroORM } from '@mikro-orm/core';
import { EntityManager } from '@mikro-orm/mysql'; // Import EntityManager from your driver package or `@mikro-orm/knex`

@Injectable()
export class MyService {

  constructor(private readonly orm: MikroORM,
              private readonly em: EntityManager) {
  }

}

----------------------------------------

TITLE: Configuring Fake Timers for MySQL/MariaDB with MikroORM
DESCRIPTION: This code sets up fake timers specifically for MySQL/MariaDB when used with MikroORM in Jest tests.

LANGUAGE: typescript
CODE:
import { resolve, dirname } from 'node:path';
import { fakeTimersHooks, wrappedSpy } from './nextTickFixer';

export function enableFakeTimersWithMikroOrm() {
  const mysqlDir = dirname(require.resolve('mysql2'));
  return {
    mocks: [
      wrappedSpy(require(resolve(mysqlDir, 'lib/commands/query.js')).prototype, 'done', executeHooks),
      wrappedSpy(require(resolve(mysqlDir, 'lib/commands/ping.js')).prototype, 'pingResponse', executeHooks),
      wrappedSpy(require(resolve(mysqlDir, 'lib/commands/register_slave.js')).prototype, 'registerResponse', executeHooks),
      wrappedSpy(require(resolve(mysqlDir, 'lib/pool.js')).prototype, 'getConnection', executeHooks),
      wrappedSpy(require(resolve(mysqlDir, 'lib/pool.js')).prototype, 'releaseConnection', executeHooks),
      wrappedSpy(require(resolve(mysqlDir, 'lib/pool_cluster.js')).prototype, 'end', executeHooks),
    ],
    mockRestore: function () {
      let mock: jest.SpyInstance | undefined;
      while (mock = this.mocks.pop()) {
        mock.mockRestore();
      }
    }
  };
}

----------------------------------------

TITLE: Defining Wildcard Schema Entity
DESCRIPTION: Example of defining an entity that can exist in multiple schemas using wildcard schema.

LANGUAGE: typescript
CODE:
@Entity({ schema: '*' })
export class Book {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  name?: string;

  @ManyToOne(() => Author, { nullable: true, deleteRule: 'cascade' })
  author?: Author;

  @ManyToOne(() => Book, { nullable: true })
  basedOn?: Book;

}

----------------------------------------

TITLE: Configuring Logger Namespaces in MikroORM
DESCRIPTION: Sets up MikroORM to only log specific types of messages by configuring logger namespaces. Available namespaces include query, query-params, discovery, and info.

LANGUAGE: typescript
CODE:
return MikroORM.init({
  debug: ['query'], // now only queries will be logged
});

----------------------------------------

TITLE: Executing Native MongoDB Collection Methods with MikroORM in TypeScript
DESCRIPTION: Demonstrates how to use native MongoDB collection methods like insert, update, and delete through MikroORM's EntityManager and EntityRepository.

LANGUAGE: typescript
CODE:
em.insert<T extends AnyEntity>(entityName: string, data: any): Promise<IPrimaryKey>;
em.nativeUpdate<T extends AnyEntity>(entityName: string, where: FilterQuery<T>, data: any): Promise<number>;
em.nativeDelete<T extends AnyEntity>(entityName: string, where: FilterQuery<T> | any): Promise<number>;

EntityRepository.insert(data: any): Promise<IPrimaryKey>;
EntityRepository.nativeUpdate(where: FilterQuery<T>, data: any): Promise<number>;
EntityRepository.nativeDelete(where: FilterQuery<T> | any): Promise<number>;

em.aggregate(entityName: string, pipeline: any[]): Promise<any[]>;
EntityRepository.aggregate(pipeline: any[]): Promise<any[]>;

----------------------------------------

TITLE: MySQL Table Creation with Underscore Naming Strategy
DESCRIPTION: SQL example demonstrating how the UnderscoreNamingStrategy transforms entity properties into database column names using lowercase and underscore separation.

LANGUAGE: sql
CODE:
CREATE TABLE `author` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `created_at` datetime(3) DEFAULT NULL,
  `updated_at` datetime(3) DEFAULT NULL,
  `terms_accepted` tinyint(1) DEFAULT NULL,
  `name` varchar(255) DEFAULT NULL,
  `email` varchar(255) DEFAULT NULL,
  `born` datetime DEFAULT NULL,
  `favourite_book_id` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

----------------------------------------

TITLE: Defining Wildcard Schema Entities in MikroORM
DESCRIPTION: This code shows how to define an entity that can exist in multiple schemas using a wildcard schema. It demonstrates the use of the @Entity decorator with a wildcard schema and various property decorators.

LANGUAGE: typescript
CODE:
@Entity({ schema: '*' })
export class Book {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  name?: string;

  @ManyToOne(() => Author, { nullable: true, onDelete: 'cascade' })
  author?: Author;

  @ManyToOne(() => Book, { nullable: true })
  basedOn?: Book;

}

----------------------------------------

TITLE: TypeScript Entity Discovery Configuration
DESCRIPTION: Configuration for optimizing entity discovery in TypeScript projects by specifying source and distribution paths.

LANGUAGE: typescript
CODE:
const orm = await MikroORM.init({
  entitiesDirs: ['./dist/entities'], // path to your JS entities (dist), relative to `baseDir`
  entitiesDirsTs: ['./src/entities'], // path to your TS entities (source), relative to `baseDir`
  // ...
});

----------------------------------------

TITLE: Setting and Clearing Schema in MikroORM EntityManager
DESCRIPTION: This snippet shows how to set and clear the schema on the EntityManager and its forked instances. It demonstrates setting the schema directly and clearing it by setting it to null.

LANGUAGE: typescript
CODE:
em.schema = 'client-123';
const fork = em.fork({ schema: 'client-1234' });
fork.schema = null;

----------------------------------------

TITLE: Registering Global Filters in MikroORM
DESCRIPTION: This example demonstrates how to register global filters using the EntityManager API. It shows how to create entity-specific and global filters, as well as setting filter parameters.

LANGUAGE: typescript
CODE:
// bound to entity, enabled by default
em.addFilter('writtenBy', args => ({ author: args.id }), Book);

// global, enabled by default, for all entities
em.addFilter('tenant', args => { ... });

// global, enabled by default, for only specified entities
em.addFilter('tenant', args => { ... }, [Author, Book]);
...

// set params (probably in some middleware)
em.setFilterParams('tenant', { tenantId: 123 });
em.setFilterParams('writtenBy', { id: 321 });

----------------------------------------

TITLE: Updating Entity Values with assign() in TypeScript
DESCRIPTION: Shows how to use the assign() method from @mikro-orm/core to update entity values, including relations.

LANGUAGE: typescript
CODE:
import { wrap } from '@mikro-orm/core';

wrap(book).assign({
  title: 'Better Book 1',
  author: '...id...',
});
console.log(book.title); // 'Better Book 1'
console.log(book.author); // instance of Author with id: '...id...'
console.log(book.author.id); // '...id...'

----------------------------------------

TITLE: Configuring Seeder Options in MikroORM
DESCRIPTION: Demonstrates how to configure various seeder options in the MikroORM initialization, including paths, default seeder, and file naming conventions.

LANGUAGE: typescript
CODE:
MikroORM.init({
  seeder: {
    path: './seeders', // path to the folder with seeders
    pathTs: undefined, // path to the folder with TS seeders (if used, we should put path to compiled files in `path`)
    defaultSeeder: 'DatabaseSeeder', // default seeder class name
    glob: '!(*.d).{js,ts}', // how to match seeder files (all .js and .ts files, but not .d.ts)
    emit: 'ts', // seeder generation mode
    fileName: (className: string) => className, // seeder file naming convention
  },
});

----------------------------------------

TITLE: Global Loading Strategy Configuration
DESCRIPTION: Example showing how to configure a default loading strategy globally in the MikroORM initialization options.

LANGUAGE: typescript
CODE:
MikroORM.init({
  loadStrategy: LoadStrategy.JOINED,
});

----------------------------------------

TITLE: Primary Key Array Lookup in MikroORM
DESCRIPTION: Shows how to perform a direct lookup using an array of primary key values.

LANGUAGE: typescript
CODE:
const res = await orm.em.find(Author, [1, 2, 7]);

----------------------------------------

TITLE: Custom Entity Class Definition with Schema
DESCRIPTION: Example of defining a custom Author entity class with its corresponding schema configuration.

LANGUAGE: typescript
CODE:
export class Author extends CustomBaseEntity {
  name: string;
  email: string;
  age?: number;
  termsAccepted?: boolean;
  identities?: string[];
  born?: string;
  books = new Collection<Book>(this);
  favouriteBook?: Book;
  version?: number;

  constructor(name: string, email: string) {
    super();
    this.name = name;
    this.email = email;
  }
}

export const schema = new EntitySchema<Author, CustomBaseEntity>({
  class: Author,
  extends: CustomBaseEntitySchema,
  properties: {
    name: { type: 'string' },
    email: { type: 'string', unique: true },
    age: { type: 'number', nullable: true },
    termsAccepted: { type: 'boolean', default: 0, onCreate: () => false },
    identities: { type: 'string[]', nullable: true },
    born: { type: DateType, nullable: true, length: 3 },
    books: { kind: '1:m', entity: () => 'Book', mappedBy: book => book.author },
    favouriteBook: { kind: 'm:1', type: 'Book' },
    version: { type: 'number', persist: false },
  },
});

----------------------------------------

TITLE: Explicit Transaction Management
DESCRIPTION: Demonstrates explicit transaction control with try-catch block for proper error handling and rollback.

LANGUAGE: typescript
CODE:
await orm.em.beginTransaction();

try {
  //... do some work
  const user = new User(...);
  user.name = 'George';
  await orm.em.persistAndFlush(user);
  await orm.em.commit();
} catch (e) {
  await orm.em.rollback();
  throw e;
}

----------------------------------------

TITLE: Accessing QueryBuilder in MikroORM with TypeScript
DESCRIPTION: Demonstrates how to properly type and access the createQueryBuilder() method in MikroORM when using TypeScript. This approach is necessary due to how the core package is structured in v4.

LANGUAGE: ts
CODE:
import { EntityManager } from '@mikro-orm/mysql'; // or any other SQL driver package

const em = orm.em as EntityManager;
const qb = await em.createQueryBuilder(...);

----------------------------------------

TITLE: Implementing Custom Connection Class in TypeScript
DESCRIPTION: Connection class that handles database connectivity and query execution. Extends the base Connection class and implements methods for connecting to the database and executing queries.

LANGUAGE: typescript
CODE:
import { Connection } from '@mikro-orm/core';

export class MyCustomConnection extends Connection {

  // implement abstract methods
  connect(): Promise<void>;
  isConnected(): Promise<boolean>;
  close(force?: boolean): Promise<void>;
  getDefaultClientUrl(): string;
  execute(query: string, params?: any[], method?: 'all' | 'get' | 'run'): Promise<QueryResult | any | any[]>;

}

----------------------------------------

TITLE: Configuring Logger Namespaces in MikroORM
DESCRIPTION: Example of configuring specific logger namespaces to control which types of logs are output

LANGUAGE: typescript
CODE:
return MikroORM.init({
  debug: ['query'], // now only queries will be logged
});

----------------------------------------

TITLE: TypeScript Configuration for MikroORM
DESCRIPTION: Required TypeScript compiler options to enable decorator support and ES module interop functionality.

LANGUAGE: json
CODE:
"experimentalDecorators": true,
"emitDecoratorMetadata": true,
"esModuleInterop": true,

----------------------------------------

TITLE: Implementing Author-Specific EventSubscriber
DESCRIPTION: Implementation of an EventSubscriber that listens to Author entity events using the @Subscriber decorator.

LANGUAGE: typescript
CODE:
import { EntityName, EventArgs, EventSubscriber, Subscriber } from '@mikro-orm/core';

@Subscriber()
export class AuthorSubscriber implements EventSubscriber<Author> {

  getSubscribedEntities(): EntityName<Author>[] {
    return [Author];
  }

  async afterCreate(args: EventArgs<Author>): Promise<void> {
    // ...
  }

  async afterUpdate(args: EventArgs<Author>): Promise<void> {
    // ...
  }

}

----------------------------------------

TITLE: Enabling Pretty Printing for Metadata Cache
DESCRIPTION: Configuration to enable pretty printing of cached metadata JSON instead of single-line format.

LANGUAGE: typescript
CODE:
await MikroORM.init({
  metadataCache: { pretty: true },
  // ...
});

----------------------------------------

TITLE: Enabling Pretty Printing for Metadata Cache in MikroORM (TypeScript)
DESCRIPTION: This code demonstrates how to enable pretty printing for cached metadata in MikroORM. It sets the 'pretty' property of the 'cache' option to true during initialization.

LANGUAGE: typescript
CODE:
await MikroORM.init({
  cache: { pretty: true },
  // ...
});

----------------------------------------

TITLE: Setting Foreign Keys by Raw ID in MikroORM
DESCRIPTION: Demonstrates three different methods to set a foreign key using a raw ID in MikroORM: using references, using the assign helper, and using the create helper.

LANGUAGE: ts
CODE:
// Using references
const b = new Book();
b.author = em.getReference(Author, 1);

// Using assign helper
const b = new Book();
em.assign(b, { author: 1 });

// Using create helper
const b = em.create(Book, { author: 1 });

----------------------------------------

TITLE: Initializing MikroORM with MongoDB Driver
DESCRIPTION: Demonstrates how to initialize MikroORM with MongoDB driver by accessing driver-specific methods via type casting.

LANGUAGE: typescript
CODE:
import { EntityManager } from '@mikro-orm/mongodb';
const em = orm.em as EntityManager;
const qb = em.aggregate(...);

----------------------------------------

TITLE: Implementing Polymorphic Embeddables with Animal Types
DESCRIPTION: This example demonstrates how to use polymorphic embeddables with a base Animal class and derived Cat and Dog classes in an Owner entity.

LANGUAGE: typescript
CODE:
import { Embeddable, Embedded, Entity, Enum, PrimaryKey, Property } from '@mikro-orm/core';

export enum AnimalType {
  CAT,
  DOG,
}

@Embeddable({ abstract: true, discriminatorColumn: 'type' })
export abstract class Animal {

  @Enum(() => AnimalType)
  type!: AnimalType;

  @Property()
  name!: string;

}

@Embeddable({ discriminatorValue: AnimalType.CAT })
export class Cat extends Animal {

  @Property({ nullable: true })
  canMeow?: boolean = true;

  constructor(name: string) {
    super();
    this.type = AnimalType.CAT;
    this.name = name;
  }

}

@Embeddable({ discriminatorValue: AnimalType.DOG })
export class Dog extends Animal {

  @Property({ nullable: true })
  canBark?: boolean = true;

  constructor(name: string) {
    super();
    this.type = AnimalType.DOG;
    this.name = name;
  }

}

@Entity()
export class Owner {

  @PrimaryKey()
  id!: number;

  @Property()
  name!: string;

  @Embedded(() => [Cat, Dog])
  pet!: Cat | Dog;

}

----------------------------------------

TITLE: Implementing Mapped Superclass Pattern in TypeScript with MikroORM
DESCRIPTION: Demonstrates how to create a mapped superclass and inherit from it in entity classes. Shows the base Person class without @Entity decorator and concrete Employee entity extending it.

LANGUAGE: typescript
CODE:
// do not use @Entity decorator on base classes (mapped superclasses)
// we can also use @Entity({ abstract: true })
export abstract class Person {

  @Property()
  mapped1!: number;

  @Property()
  mapped2!: string;

  @OneToOne()
  toothbrush!: Toothbrush;

  // ... more fields and methods
}

@Entity()
export class Employee extends Person {

  @PrimaryKey()
  id!: number;

  @Property()
  name!: string;

  // ... more fields and methods

}

@Entity()
export class Toothbrush {

  @PrimaryKey()
  id!: number;

  // ... more fields and methods

}

----------------------------------------

TITLE: Implementing Custom Connection Class in TypeScript
DESCRIPTION: Connection class that handles database connectivity and query execution. Implements core methods for connecting, disconnecting, and executing queries.

LANGUAGE: typescript
CODE:
import { Connection } from 'mikro-orm';

export class MyCustomConnection extends Connection {

  // implement abstract methods
  connect(): Promise<void>;
  isConnected(): Promise<boolean>;
  close(force?: boolean): Promise<void>;
  getDefaultClientUrl(): string;
  execute(query: string, params?: any[], method?: 'all' | 'get' | 'run'): Promise<QueryResult | any | any[]>;

}

----------------------------------------

TITLE: Defining MongoDB Entity with Primary Key
DESCRIPTION: Shows how to define a MongoDB entity with a primary key using ObjectId and a serialized string ID.

LANGUAGE: typescript
CODE:
@PrimaryKey()
_id: ObjectId;

@SerializedPrimaryKey()
id!: string; // won't be saved in the database

----------------------------------------

TITLE: Using MongoDB Aggregate Method in MikroORM
DESCRIPTION: This example illustrates how to use the aggregate method with the MongoDB driver in MikroORM.

LANGUAGE: ts
CODE:
import { EntityManager } from '@mikro-orm/mongodb';

const em = orm.em as EntityManager;
const ret = await em.aggregate(...);

----------------------------------------

TITLE: Implementing Native BigInt Primary Key in MikroORM
DESCRIPTION: Custom implementation using NativeBigIntType to handle bigint values as native JavaScript BigInt instead of strings. This approach extends the base BigIntType and overrides the conversion method to use native BigInt.

LANGUAGE: typescript
CODE:
export class NativeBigIntType extends BigIntType {

  convertToJSValue(value: any): any {
    if (!value) {
      return value;
    }

    return BigInt(value);
  }

}

@Entity()
export class Book {

  @PrimaryKey({ type: NativeBigIntType })
  id: bigint;

}

----------------------------------------

TITLE: Running Schema Generator CLI Commands in MikroORM
DESCRIPTION: CLI commands for creating, updating, and dropping database schemas using MikroORM's SchemaGenerator. These commands can dump SQL or execute queries directly.

LANGUAGE: shell
CODE:
npx mikro-orm schema:create --dump   # Dumps create schema SQL
npx mikro-orm schema:update --dump   # Dumps update schema SQL
npx mikro-orm schema:drop --dump     # Dumps drop schema SQL

----------------------------------------

TITLE: Installing MikroORM and NestJS Module
DESCRIPTION: Commands for installing MikroORM core, NestJS module, and database-specific drivers using yarn or npm.

LANGUAGE: bash
CODE:
$ yarn add @mikro-orm/core @mikro-orm/nestjs @mikro-orm/mongodb     # for mongo
$ yarn add @mikro-orm/core @mikro-orm/nestjs @mikro-orm/mysql       # for mysql/mariadb
$ yarn add @mikro-orm/core @mikro-orm/nestjs @mikro-orm/mariadb     # for mysql/mariadb
$ yarn add @mikro-orm/core @mikro-orm/nestjs @mikro-orm/postgresql  # for postgresql
$ yarn add @mikro-orm/core @mikro-orm/nestjs @mikro-orm/sqlite      # for sqlite

LANGUAGE: bash
CODE:
$ npm i -s @mikro-orm/core @mikro-orm/nestjs @mikro-orm/mongodb     # for mongo
$ npm i -s @mikro-orm/core @mikro-orm/nestjs @mikro-orm/mysql       # for mysql/mariadb
$ npm i -s @mikro-orm/core @mikro-orm/nestjs @mikro-orm/mariadb     # for mysql/mariadb
$ npm i -s @mikro-orm/core @mikro-orm/nestjs @mikro-orm/postgresql  # for postgresql
$ npm i -s @mikro-orm/core @mikro-orm/nestjs @mikro-orm/sqlite      # for sqlite

----------------------------------------

TITLE: Using EntityManager in MikroORM Migrations
DESCRIPTION: This snippet shows how to use EntityManager within a migration to perform data modifications, although it's generally discouraged due to potential metadata inconsistencies.

LANGUAGE: typescript
CODE:
import { Migration } from '@mikro-orm/migrations';
import { User } from '../entities/User';

export class Migration20191019195930 extends Migration {

    async up(): Promise<void> {
        const em = this.getEntityManager();
        em.create(User, { ... });
        await em.flush();
    }

}

----------------------------------------

TITLE: Custom Repository Implementation
DESCRIPTION: Example of creating and using a custom repository with entity configuration and repository class definition

LANGUAGE: typescript
CODE:
@Entity({ repository: () => AuthorRepository })
export class Author {
  [EntityRepositoryType]?: AuthorRepository;
}

export class AuthorRepository extends EntityRepository<Author> {
  // custom methods
}

----------------------------------------

TITLE: Injecting EntityManager in NestJS Service
DESCRIPTION: Example of dependency injection for MikroORM's EntityManager in a NestJS service class.

LANGUAGE: typescript
CODE:
import { MikroORM } from '@mikro-orm/core';
import { EntityManager } from '@mikro-orm/mysql';

@Injectable()
export class MyService {
    constructor(private readonly orm: MikroORM,
                private readonly em: EntityManager) {
    }
}

----------------------------------------

TITLE: Logger Interface Definition in MikroORM
DESCRIPTION: TypeScript interface definition for the Logger, including methods and types for different logging contexts

LANGUAGE: typescript
CODE:
interface Logger {
  log(namespace: LoggerNamespace, message: string, context?: LogContext): void;
  error(namespace: LoggerNamespace, message: string, context?: LogContext): void;
  warn(namespace: LoggerNamespace, message: string, context?: LogContext): void;
  logQuery(context: LogContext): void;
  setDebugMode(debugMode: boolean | LoggerNamespace[]): void;
  isEnabled(namespace: LoggerNamespace): boolean;
}

type LoggerNamespace = 'query' | 'query-params' | 'discovery' | 'info';

interface LogContext {
  query?: string;
  params?: unknown[];
  took?: number;
  level?: 'info' | 'warning' | 'error';
  connection?: {
    type?: string;
    name?: string;
  };
}

----------------------------------------

TITLE: Configuring TypeScript for Proper Entity Initialization
DESCRIPTION: This JSON configuration disables the useDefineForClassFields option in TypeScript to prevent unexpected entity property initialization behavior.

LANGUAGE: json
CODE:
{
  "compilerOptions": {
    "useDefineForClassFields": false
  }
}

----------------------------------------

TITLE: Installing MikroORM Dependencies
DESCRIPTION: Terminal commands for installing MikroORM and its database drivers using yarn or npm package managers.

LANGUAGE: sh
CODE:
# using yarn
$ yarn add mikro-orm mongodb # for mongo
$ yarn add mikro-orm mysql2  # for mysql
$ yarn add mikro-orm pg      # for postgresql
$ yarn add mikro-orm sqlite  # for sqlite

# or npm
$ npm i -s mikro-orm mongodb # for mongo
$ npm i -s mikro-orm mysql2  # for mysql
$ npm i -s mikro-orm pg      # for postgresql
$ npm i -s mikro-orm sqlite  # for sqlite

----------------------------------------

TITLE: Implementing Custom Platform Class in TypeScript for MikroORM
DESCRIPTION: Extends the Platform class to provide information about available features of the custom driver. Includes methods for handling identifiers, parameters, and primary keys.

LANGUAGE: typescript
CODE:
import { Platform } from '@mikro-orm/core';

export class MyCustomPlatform extends Platform {

  protected abstract schemaHelper: MyCustomSchemaHelper;

  // here you can override default settings
  usesPivotTable(): boolean;
  supportsTransactions(): boolean;
  supportsSavePoints(): boolean;
  getNamingStrategy(): { new (): NamingStrategy; };
  getIdentifierQuoteCharacter(): string;
  getParameterPlaceholder(index?: number): string;
  usesReturningStatement(): boolean;
  normalizePrimaryKey<T = number | string>(data: IPrimaryKey): T;
  denormalizePrimaryKey(data: IPrimaryKey): IPrimaryKey;
  getSerializedPrimaryKeyField(field: string): string;

}

----------------------------------------

TITLE: Configuring Cascade Options for Entity Relationships in TypeScript
DESCRIPTION: This snippet demonstrates how to configure cascade options for various types of entity relationships in MikroORM using TypeScript decorators. It shows different cascade configurations for OneToMany relationships.

LANGUAGE: typescript
CODE:
// cascade persist is default value
@OneToMany({ entity: () => Book, mappedBy: 'author' })
books = new Collection<Book>(this);

// same as previous definition
@OneToMany({ entity: () => Book, mappedBy: 'author', cascade: [Cascade.PERSIST] })
books = new Collection<Book>(this);

// only cascade remove
@OneToMany({ entity: () => Book, mappedBy: 'author', cascade: [Cascade.REMOVE] })
books = new Collection<Book>(this);

// no cascade
@OneToMany({ entity: () => Book, mappedBy: 'author', cascade: [] })
books = new Collection<Book>(this);

// cascade all (persist and remove)
@OneToMany({ entity: () => Book, mappedBy: 'author', cascade: [Cascade.ALL] })
books = new Collection<Book>(this);

// same as previous definition
@OneToMany({ entity: () => Book, mappedBy: 'author', cascade: [Cascade.PERSIST, Cascade.REMOVE] })
books = new Collection<Book>(this);

----------------------------------------

TITLE: Assigning References to Properties
DESCRIPTION: Demonstrates different ways to assign references to entity properties.

LANGUAGE: typescript
CODE:
const book = await orm.em.findOne(Book, 1);
const repo = orm.em.getRepository(Author);

book.author = repo.getReference(2, true);

// same as:
book.author = Reference.create(repo.getReference(2));
await orm.em.flush();

----------------------------------------

TITLE: Defining ManyToMany Collections in TypeScript with MikroORM
DESCRIPTION: Demonstrates how to define unidirectional and bidirectional ManyToMany collections in MikroORM using TypeScript decorators. It shows both owning and inverse side definitions.

LANGUAGE: typescript
CODE:
@ManyToMany(() => Book)
books1 = new Collection<Book>(this);

// or mark it as owner explicitly via options object
@ManyToMany({ entity: () => Book, owner: true })
books2 = new Collection<Book>(this);

@ManyToMany(() => BookTag, tag => tag.books, { owner: true })
tags = new Collection<BookTag>(this);

// or via options object
@ManyToMany({ entity: () => BookTag, inversedBy: 'books' })
tags = new Collection<BookTag>(this);

@ManyToMany(() => Book, book => book.tags)
books = new Collection<Book>(this);

// or via options object
@ManyToMany({ entity: () => Book, mappedBy: 'tags' })
books = new Collection<Book>(this);

----------------------------------------

TITLE: Enabling Debug Mode in MikroORM (TypeScript)
DESCRIPTION: This snippet shows how to enable debug mode when initializing MikroORM. It sets the 'debug' option to true, which causes MikroORM to log all queries using console.log().

LANGUAGE: typescript
CODE:
return MikroORM.init({
  debug: true,
});

----------------------------------------

TITLE: Customizing Embeddable Column Prefixes in MikroORM
DESCRIPTION: These snippets demonstrate how to customize the column prefix for embeddables or remove it entirely using the 'prefix' option in the @Embedded decorator.

LANGUAGE: typescript
CODE:
@Entity()
export class User {

  @Embedded({ prefix: 'myPrefix_' })
  address!: Address;

}

LANGUAGE: typescript
CODE:
@Entity()
export class User {

  @Embedded({ entity: () => Address, prefix: false })
  address!: Address;

}

----------------------------------------

TITLE: Defining JSON Property in MikroORM Entity (TypeScript)
DESCRIPTION: Demonstrates how to define a JSON property in a MikroORM entity using the @Property decorator with type 'json'. The property is nullable and has a specific structure.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @Property({ type: 'json', nullable: true })
  meta?: { foo: string; bar: number };

}

----------------------------------------

TITLE: Using Read Replica Connections in MikroORM Queries in TypeScript
DESCRIPTION: This snippet shows various ways to use read replica connections in MikroORM queries. It demonstrates how to explicitly specify connection types, use query builders, and handle transactions with read replicas.

LANGUAGE: typescript
CODE:
const connection = em.getConnection(); // write connection
const readConnection = em.getConnection('read'); // random read connection

const qb1 = em.createQueryBuilder(Author);
const res1 = await qb1.select('*').execute(); // random read connection

const qb2 = em.createQueryBuilder(Author, 'a', 'write');
const res2 = await qb2.select('*').execute(); // write connection

const qb3 = em.createQueryBuilder(Author);
const res3 = await qb3.update(...).where(...).execute(); // write connection

const res4 = await em.findOne(Author, 1, { connectionType: 'write' }); // explicit write connection

// all queries inside a transaction will use write connection
await em.transactional(async em => {
    const a = await em.findOne(Author, 1); // write connection
    const b = await em.findOne(Author, 1, { connectionType: 'read' }); // still a write connection - we are in a transaction
    a.name = 'test'; // will trigger update on write connection once flushed
});

// given a configuration where preferReadReplicas: false
const res5 = await em.findOne(Author, 1); // write connection - even for a read operation
const res6 = await em.findOne(Author, 1, { connectionType: 'read' }); // unless explicitly asking for a read replica

----------------------------------------

TITLE: Using Read Replica Connections in MikroORM Queries in TypeScript
DESCRIPTION: This snippet shows various ways to use read replica connections in MikroORM queries. It demonstrates how to explicitly specify connection types, use query builders, and handle transactions with read replicas.

LANGUAGE: typescript
CODE:
const connection = em.getConnection(); // write connection
const readConnection = em.getConnection('read'); // random read connection

const qb1 = em.createQueryBuilder(Author);
const res1 = await qb1.select('*').execute(); // random read connection

const qb2 = em.createQueryBuilder(Author, 'a', 'write');
const res2 = await qb2.select('*').execute(); // write connection

const qb3 = em.createQueryBuilder(Author);
const res3 = await qb3.update(...).where(...).execute(); // write connection

const res4 = await em.findOne(Author, 1, { connectionType: 'write' }); // explicit write connection

// all queries inside a transaction will use write connection
await em.transactional(async em => {
    const a = await em.findOne(Author, 1); // write connection
    const b = await em.findOne(Author, 1, { connectionType: 'read' }); // still a write connection - we are in a transaction
    a.name = 'test'; // will trigger update on write connection once flushed
});

// given a configuration where preferReadReplicas: false
const res5 = await em.findOne(Author, 1); // write connection - even for a read operation
const res6 = await em.findOne(Author, 1, { connectionType: 'read' }); // unless explicitly asking for a read replica

----------------------------------------

TITLE: Demonstrating Property Validation in MikroORM with TypeScript
DESCRIPTION: Shows various scenarios of property validation in MikroORM, including type conversion, error handling for invalid types, and automatic date parsing. Demonstrates validation behavior for different data types including strings, numbers, dates, and null values.

LANGUAGE: typescript
CODE:
// number instead of string will throw
const author = new Author('test', 'test') as WrappedEntity<Author>;
author.assign({ name: 111, email: 222 });
await orm.em.persistAndFlush(author); // throws "Validation error: trying to set Author.name of type 'string' to '111' of type 'number'"

// string date with unknown format will throw
author.assign(author, { name: '333', email: '444', born: 'asd' });
await orm.em.persistAndFlush(author); // throws "Validation error: trying to set Author.born of type 'date' to 'asd' of type 'string'"

// string date with correct format will be auto-corrected
author.assign({ name: '333', email: '444', born: '2018-01-01' });
await orm.em.persistAndFlush(author);
console.log(author.born).toBe(true); // instance of Date

// Date object will be ok
author.assign({ born: new Date() });
await orm.em.persistAndFlush(author);
console.log(author.born).toBe(true); // instance of Date

// null will be ok
author.assign({ born: null });
await orm.em.persistAndFlush(author);
console.log(author.born); // null

// string number with correct format will be auto-corrected
author.assign({ age: '21' });
await orm.em.persistAndFlush(author);
console.log(author.age); // number 21

// string instead of number with will throw
author.assign({ age: 'asd' });
await orm.em.persistAndFlush(author); // throws "Validation error: trying to set Author.age of type 'number' to 'asd' of type 'string'"
author.assign({ age: new Date() });
await orm.em.persistAndFlush(author); // throws "Validation error: trying to set Author.age of type 'number' to '2019-01-17T21:14:23.875Z' of type 'date'"
author.assign({ age: false });
await orm.em.persistAndFlush(author); // throws "Validation error: trying to set Author.age of type 'number' to 'false' of type 'boolean'"

----------------------------------------

TITLE: SchemaGenerator Configuration in MikroORM
DESCRIPTION: TypeScript configuration for SchemaGenerator showing default values and options for foreign key handling and schema ignoring.

LANGUAGE: typescript
CODE:
const orm = await MikroORM.init({
  // default values:
  schemaGenerator: {
    disableForeignKeys: true, // wrap statements with `set foreign_key_checks = 0` or equivalent
    createForeignKeyConstraints: true, // whether to generate FK constraints
    ignoreSchema: [], // allows ignoring some schemas when diffing
  },
});

----------------------------------------

TITLE: SchemaGenerator Configuration in MikroORM
DESCRIPTION: TypeScript configuration for SchemaGenerator showing default values and options for foreign key handling and schema ignoring.

LANGUAGE: typescript
CODE:
const orm = await MikroORM.init({
  // default values:
  schemaGenerator: {
    disableForeignKeys: true, // wrap statements with `set foreign_key_checks = 0` or equivalent
    createForeignKeyConstraints: true, // whether to generate FK constraints
    ignoreSchema: [], // allows ignoring some schemas when diffing
  },
});

----------------------------------------

TITLE: Implementing Single Table Inheritance in TypeScript with MikroORM
DESCRIPTION: This snippet demonstrates how to set up Single Table Inheritance in MikroORM using TypeScript. It shows the use of discriminator columns and maps to distinguish between different entity types in a single table.

LANGUAGE: typescript
CODE:
@Entity({
  discriminatorColumn: 'discr',
  discriminatorMap: { person: 'Person', employee: 'Employee' },
})
export class Person {
  // ...
}

@Entity()
export class Employee extends Person {
  // ...
}

----------------------------------------

TITLE: Implementing Custom Platform Class in TypeScript for MikroORM
DESCRIPTION: Extends the Platform class to provide information about available features of the custom driver. Includes methods for handling identifiers, parameters, and primary keys.

LANGUAGE: typescript
CODE:
import { Platform } from '@mikro-orm/core';

export class MyCustomPlatform extends Platform {

  protected abstract schemaHelper: MyCustomSchemaHelper;

  // here you can override default settings
  usesPivotTable(): boolean;
  supportsTransactions(): boolean;
  supportsSavePoints(): boolean;
  getNamingStrategy(): { new (): NamingStrategy; };
  getIdentifierQuoteCharacter(): string;
  getParameterPlaceholder(index?: number): string;
  usesReturningStatement(): boolean;
  normalizePrimaryKey<T = number | string>(data: IPrimaryKey): T;
  denormalizePrimaryKey(data: IPrimaryKey): IPrimaryKey;
  getSerializedPrimaryKeyField(field: string): string;

}

----------------------------------------

TITLE: Using EntityGenerator via CLI
DESCRIPTION: CLI commands to generate entities using the EntityGenerator.

LANGUAGE: bash
CODE:
npx mikro-orm generate-entities --dump
npx mikro-orm generate-entities --save --path=./my-entities

----------------------------------------

TITLE: Defining MongoDB Entity with Complex Relations
DESCRIPTION: Shows how to define an Author entity for MongoDB with various property types and relationship mappings.

LANGUAGE: typescript
CODE:
@Entity()
export class Author {

  @PrimaryKey()
  _id!: ObjectId;

  @SerializedPrimaryKey()
  id!: string;

  @Property()
  createdAt = new Date();

  @Property({ onUpdate: () => new Date() })
  updatedAt = new Date();

  @Property()
  name!: string;

  @Property()
  email!: string;

  @Property()
  age?: number;

  @Property()
  termsAccepted = false;

  @Property()
  identities?: string[];

  @Property()
  born?: Date;

  @OneToMany(() => Book, book => book.author)
  books = new Collection<Book>(this);

  @ManyToMany()
  friends = new Collection<Author>(this);

  @ManyToOne()
  favouriteBook?: Book;

  @Property({ version: true })
  version!: number;

  constructor(name: string, email: string) {
    this.name = name;
    this.email = email;
  }

}

----------------------------------------

TITLE: Creating ManyToMany Pivot Table in SQL
DESCRIPTION: SQL example for creating a pivot table to handle ManyToMany relations in MySQL.

LANGUAGE: sql
CODE:
CREATE TABLE `publisher_to_test` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `publisher_id` int(11) DEFAULT NULL,
  `test_id` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

----------------------------------------

TITLE: Configuring Migrations in MikroORM
DESCRIPTION: Shows how to configure various options for migrations in MikroORM.

LANGUAGE: typescript
CODE:
MikroORM.init({
  migrations: {
    tableName: 'mikro_orm_migrations',
    path: process.cwd() + '/migrations',
    pattern: /^[\w-]+\d+\.ts$/,
    transactional: true,
    disableForeignKeys: true,
    allOrNothing: true,
    emit: 'ts',
  },
});

----------------------------------------

TITLE: Cascade Persistence in MikroORM
DESCRIPTION: Shows how to persist multiple related entities with automatic cascade persistence of relationships.

LANGUAGE: typescript
CODE:
const author = new Author('Jon Snow', 'snow@wall.st');
author.born = new Date();

const publisher = new Publisher('7K publisher');

const book1 = new Book('My Life on The Wall, part 1', author);
book1.publisher = publisher;
const book2 = new Book('My Life on The Wall, part 2', author);
book2.publisher = publisher;
const book3 = new Book('My Life on The Wall, part 3', author);
book3.publisher = publisher;

// just persist books, author and publisher will be automatically cascade persisted
await em.persistAndFlush([book1, book2, book3]);

----------------------------------------

TITLE: Setting up Request Context Middleware
DESCRIPTION: Express middleware setup to create isolated entity manager instances for each request

LANGUAGE: typescript
CODE:
const app = express();

app.use((req, res, next) => {
  RequestContext.create(orm.em, next);
});

----------------------------------------

TITLE: One-to-Many Collection Propagation in TypeScript with MikroORM
DESCRIPTION: Shows how using Collection.add() method on a one-to-many relationship automatically updates both the collection and the inverse side reference.

LANGUAGE: typescript
CODE:
// one to many
const author = new Author(...);
const book = new Book(...);

author.books.add(book);
console.log(book.author); // author will be set thanks to the propagation

----------------------------------------

TITLE: Configuring MikroORM in TypeScript
DESCRIPTION: This snippet shows how to configure MikroORM with various options including the database type, entities, and debug settings. It demonstrates the setup for a PostgreSQL database.

LANGUAGE: typescript
CODE:
import { Options } from '@mikro-orm/core';
import { PostgreSqlDriver } from '@mikro-orm/postgresql';

const config: Options = {
  entities: ['./dist/entities'],
  entitiesTs: ['./src/entities'],
  dbName: 'my_database_name',
  type: 'postgresql',
  debug: true,
};

----------------------------------------

TITLE: Accessing Internal Properties with wrap() in TypeScript
DESCRIPTION: This snippet shows how to access internal properties of an entity using the wrap() helper function with the second parameter set to true.

LANGUAGE: typescript
CODE:
@Entity()
export class Author { ... }

console.log(wrap(author, true).__meta);

----------------------------------------

TITLE: Configuring MikroORM CLI in package.json
DESCRIPTION: Configuration for MikroORM CLI in package.json, including TypeScript support and custom config file paths.

LANGUAGE: json
CODE:
{
  "name": "your-app",
  "dependencies": { ... },
  "mikro-orm": {
    "useTsNode": true,
    "configPaths": [
      "./src/mikro-orm.config.ts",
      "./dist/mikro-orm.config.js"
    ]
  }
}

----------------------------------------

TITLE: Creating Entities in Specific Schema with QueryBuilder
DESCRIPTION: Demonstrates how to create entities in a specific schema using QueryBuilder with the withSchema method.

LANGUAGE: typescript
CODE:
const qb = em.createQueryBuilder(User);
await qb.insert({ email: 'foo@bar.com' }).withSchema('client-123');

----------------------------------------

TITLE: Defining a Book Entity with EntitySchema
DESCRIPTION: Example of defining a Book entity using the EntitySchema approach.

LANGUAGE: typescript
CODE:
export interface IBook extends CustomBaseEntity {
  title: string;
  author: Author;
  publisher?: Ref<Publisher>;
  tags: Collection<BookTag>;
}

export const Book = new EntitySchema<IBook, CustomBaseEntity>({
  name: 'Book',
  extends: 'CustomBaseEntity',
  properties: {
    title: { type: 'string' },
    author: { kind: 'm:1', entity: 'Author' },
    publisher: { kind: 'm:1', entity: 'Publisher', ref: true, nullable: true },
    tags: { kind: 'm:n', entity: 'BookTag', fixedOrder: true },
  },
});

----------------------------------------

TITLE: Initializing MikroORM Instance
DESCRIPTION: Example of initializing MikroORM with configuration options including entities, database name and type

LANGUAGE: typescript
CODE:
const orm = await MikroORM.init({
  entities: [Author, Book, BookTag],
  dbName: 'my-db-name',
  clientUrl: '...', // defaults to 'mongodb://127.0.0.1:27017' for mongodb driver
  type: 'mongo', // one of 'mysql', 'postgresql', 'sqlite', defaults to 'mongo'
  autoFlush: false, // read more here: https://b4nan.github.io/mikro-orm/unit-of-work/
});

console.log(orm.em); // access EntityManager via `em` property

----------------------------------------

TITLE: Defining Author Entity with EntitySchema in JavaScript for MikroORM
DESCRIPTION: This snippet demonstrates how to define an Author entity using EntitySchema in vanilla JavaScript for MikroORM. It includes property definitions, a constructor, and the schema configuration.

LANGUAGE: javascript
CODE:
const { Collection, EntitySchema } = require('@mikro-orm/core');
const { Book } = require('./Book');
const { BaseEntity } = require('./BaseEntity');

/**
 * @property {number} id
 * @property {Date} createdAt
 * @property {Date} updatedAt
 * @property {string} name
 * @property {string} email
 * @property {number} age
 * @property {boolean} termsAccepted
 * @property {string[]} identities
 * @property {Date} born
 * @property {Collection<Book>} books
 * @property {Book} favouriteBook
 * @property {number} version
 * @property {string} versionAsString
 */
class Author extends BaseEntity {

  /**
   * @param {string} name
   * @param {string} email
   */
  constructor(name, email) {
    super();
    this.name = name;
    this.email = email;
    this.books = new Collection(this);
    this.createdAt = new Date();
    this.updatedAt = new Date();
    this.termsAccepted = false;
  }

}

export const schema = new EntitySchema({
  class: Author,
  properties: {
    name: { type: 'string' },
    email: { type: 'string', unique: true },
    age: { type: 'number', nullable: true },
    termsAccepted: { type: 'boolean', default: 0, onCreate: () => false },
    identities: { type: 'string[]', nullable: true },
    born: { type: DateType, nullable: true, length: 3 },
    books: { reference: '1:m', entity: () => 'Book', mappedBy: book => book.author },
    favouriteBook: { reference: 'm:1', type: 'Book' },
    version: { type: 'number', persist: false },
  },
});

module.exports.Author = Author;
module.exports.entity = Author;
module.exports.schema = schema;

----------------------------------------

TITLE: Using nativeDelete for Direct Delete Queries
DESCRIPTION: Example of how to use the new nativeDelete() method for firing direct delete queries, replacing the previous behavior of remove() with conditions.

LANGUAGE: typescript
CODE:
await em.nativeDelete(Author, 1);

----------------------------------------

TITLE: Using SchemaGenerator via CLI in MikroORM
DESCRIPTION: Commands for generating schema SQL using MikroORM's CLI. These commands allow dumping or running SQL for creating, updating, or dropping the schema.

LANGUAGE: sh
CODE:
npx mikro-orm schema:create --dump   # Dumps create schema SQL
npx mikro-orm schema:update --dump   # Dumps update schema SQL
npx mikro-orm schema:drop --dump     # Dumps drop schema SQL

----------------------------------------

TITLE: Using Knex.js with QueryBuilder
DESCRIPTION: Shows how to access and use the underlying Knex.js instance from QueryBuilder.

LANGUAGE: typescript
CODE:
const qb = orm.em.createQueryBuilder(Author);
qb.update({ name: 'test 123', type: PublisherType.GLOBAL }).where({ id: 123, type: PublisherType.LOCAL });
const knex = qb.getKnexQuery(); // instance of Knex' QueryBuilder

// do what ever you need with `knex`

const res = await orm.em.getConnection().execute(knex);
const entities = res.map(a => orm.em.map(Author, a));
console.log(entities); // Author[]

----------------------------------------

TITLE: Installing Hapi Plugin for AdminJS
DESCRIPTION: Commands for installing the Hapi plugin and its peer dependencies for use with AdminJS.

LANGUAGE: bash
CODE:
$ yarn add @adminjs/hapi
# Peer dependencies
$ yarn add @hapi/boom @hapi/cookie @hapi/hapi @hapi/inert

----------------------------------------

TITLE: Query Execution Methods
DESCRIPTION: Different methods for executing queries and controlling result format

LANGUAGE: typescript
CODE:
const res1 = await qb.execute('all'); // returns array of objects, default behavior
const res2 = await qb.execute('get'); // returns single object
const res3 = await qb.execute('run'); // returns object like `{ affectedRows: number, insertId: number, row: any }`

----------------------------------------

TITLE: Implementing Custom SchemaHelper Class in TypeScript
DESCRIPTION: SchemaHelper class that provides schema-related functionality including table creation, type definitions, and constraint handling.

LANGUAGE: typescript
CODE:
import { SchemaHelper } from 'mikro-orm';

export class MyCustomSchemaHelper extends SchemaHelper {

  // here you can override default settings
  getIdentifierQuoteCharacter(): string;
  getSchemaBeginning(): string;
  getSchemaEnd(): string;
  getSchemaTableEnd(): string;
  getAutoIncrementStatement(meta: EntityMetadata): string;
  getPrimaryKeySubtype(meta: EntityMetadata): string;
  getTypeDefinition(prop: EntityProperty, types?: Record<string, string>, lengths?: Record<string, number>): string;
  getUnsignedSuffix(prop: EntityProperty): string;
  supportsSchemaConstraints(): boolean;
  supportsSchemaMultiAlter(): boolean;
  supportsSequences(): boolean;
  quoteIdentifier(field: string): string;
  dropTable(meta: EntityMetadata): string;
  indexForeignKeys(): boolean;

}

----------------------------------------

TITLE: Configuring Population Where Condition in MikroORM Query (TypeScript)
DESCRIPTION: This snippet shows how to use the 'populateWhere' option to control the where condition for populated relations.

LANGUAGE: typescript
CODE:
await em.find(Author, { ... }, {
  populate: ['books'],
  populateWhere: 'infer', // defaults to `all`

  // or specify custom query, will be used via `join on` conditions
  // populateWhere: { age: { $gte: 18 } },
});

----------------------------------------

TITLE: Performing LIKE Queries with Regular Expressions
DESCRIPTION: Example of using regular expressions to perform LIKE queries in MikroORM with SQL databases.

LANGUAGE: typescript
CODE:
const author1 = new Author2('Author 1', 'a1@example.com');
const author2 = new Author2('Author 2', 'a2@example.com');
const author3 = new Author2('Author 3', 'a3@example.com');

await orm.em.persist([author1, author2, author3]).flush();

// finds authors with email like '%exa%le.c_m'
const authors = await orm.em.find(Author2, { email: /exa.*le\.c.m$/ });
console.log(authors); // all 3 authors found

----------------------------------------

TITLE: Entity Discovery Log in MikroORM
DESCRIPTION: This snippet shows the log output during the entity discovery process in MikroORM. It includes information about each processed entity and the time taken for discovery.

LANGUAGE: plaintext
CODE:
ORM entity discovery started
- processing entity Author
- using cached metadata for entity Author
- processing entity Book
- processing entity BookTag
- entity discovery finished after 13 ms

----------------------------------------

TITLE: Defining Lifecycle Hooks with Decorators in TypeScript
DESCRIPTION: Examples of using lifecycle hook decorators to define methods that are called at specific points in an entity's lifecycle.

LANGUAGE: typescript
CODE:
@OnInit()
doStuffOnInit(args: EventArgs<this>) {
  this.fullName = `${this.firstName} - ${this.lastName}`; // initialize shadow property
}

@BeforeCreate()
async doStuffBeforeCreate(args: EventArgs<this>) {
  // ...
}

@AfterUpdate()
async doStuffAfterUpdate(args: EventArgs<this>) {
  // ...
}

----------------------------------------

TITLE: Collection Operators Example in MikroORM
DESCRIPTION: Demonstrates the usage of collection operators ($some, $none, $every) for querying relationships between entities.

LANGUAGE: typescript
CODE:
const res1 = await em.find(Author, {
  books: { $some: { title: 'Foo' } },
});

const res2 = await em.find(Author, {
  books: { $none: { title: 'Foo' } },
});

const res3 = await em.find(Author, {
  books: { $every: { title: 'Foo' } },
});

----------------------------------------

TITLE: CLI Commands for Entity Generation
DESCRIPTION: Shell commands to generate entities using the MikroORM CLI, with options for dumping or saving to a directory.

LANGUAGE: sh
CODE:
npx mikro-orm generate-entities --dump  # Dumps all generated entities
npx mikro-orm generate-entities --save --path=./my-entities  # Saves entities into given directory

----------------------------------------

TITLE: Deprecated: Using Operator Keys in MikroORM TypeScript Queries
DESCRIPTION: This snippet demonstrates a deprecated method of including operators in query keys. This approach will be removed in future versions of MikroORM.

LANGUAGE: typescript
CODE:
const res = await orm.em.find(Author, { $and: [
  { 'id:in': [1, 2, 7] },
  { 'id:nin': [3, 4] },
  { 'id:gt': 5 },
  { 'id:lt': 10 },
  { 'id:gte': 7 },
  { 'id:lte': 8 },
  { 'id:ne': 9 },
] });

----------------------------------------

TITLE: Webpack Configuration for MikroORM Bundling
DESCRIPTION: This is a Webpack configuration file specifically tailored for bundling MikroORM applications, handling externals, optimization, and optional modules.

LANGUAGE: javascript
CODE:
const path = require('path');
const { EnvironmentPlugin, IgnorePlugin } = require('webpack');
const TerserPlugin = require('terser-webpack-plugin');

// Mark our dev dependencies as externals so they don't get included in the webpack bundle.
const { devDependencies } = require('./package.json');
const externals = {};

for (const devDependency of Object.keys(devDependencies)) {
  externals[devDependency] = `commonjs ${devDependency}`;
}

// And anything MikroORM's packaging can be ignored if it's not on disk.
// Later we check these dynamically and tell webpack to ignore the ones we don't have.
const optionalModules = new Set([
  ...Object.keys(require('knex/package.json').browser),
  ...Object.keys(require('@mikro-orm/core/package.json').peerDependencies),
  ...Object.keys(require('@mikro-orm/core/package.json').devDependencies || {})
]);

module.exports = {
  entry: path.resolve('app', 'server.ts'),

  // You can toggle development mode on to better see what's going on in the webpack bundle,
  // but for anything that is getting deployed, you should use 'production'.
  // mode: 'development',
  mode: 'production',

  optimization: {
    minimizer: [
      new TerserPlugin({
        terserOptions: {
          // We want to minify the bundle, but don't want Terser to change the names of our entity
          // classes. This can be controlled in a more granular way if needed, (see
          // https://terser.org/docs/api-reference.html#mangle-options) but the safest default
          // config is that we simply disable mangling altogether but allow minification to proceed.
          mangle: false,
          // Similarly, Terser's compression may at its own discretion change function and class names.
          // While it only rarely does so, it's safest to also disable changing their names here.
          // This can be controlled in a more granular way if needed (see
          // https://terser.org/docs/api-reference.html#compress-options).
          compress: {
            keep_classnames: true,
            keep_fnames: true,
          },
        }
      })
    ]
  },
  target: 'node',
  module: {
    rules: [
      // Bring in our typescript files.
      {
        test: /\.ts$/,
        exclude: /node_modules/,
        loader: 'ts-loader',
      },

      // Native modules can be bundled as well.
      {
        test: /\.node$/,
        use: 'node-loader',
      },

      // Some of MikroORM's dependencies use mjs files, so let's set them up here.
      {
        test: /\.mjs$/,
        include: /node_modules/,
        type: 'javascript/auto',
      },
    ],
  },

  // These are computed above.
  externals,

  resolve: {
    extensions: ['.ts', '.js']
  },

  plugins: [
    // Ignore any of our optional modules if they aren't installed. This ignores database drivers
    // that we aren't using for example.
    new EnvironmentPlugin({ WEBPACK: true }),
    new IgnorePlugin({
      checkResource: resource => {
        const baseResource = resource.split('/', resource[0] === '@' ? 2 : 1).join('/');

        if (optionalModules.has(baseResource)) {
          try {
            require.resolve(resource);
            return false;
          } catch {
            return true;
          }
        }

        return false;
      },
    }),
  ],

  output: {
    filename: 'server.js',
    libraryTarget: 'commonjs',
    path: path.resolve(__dirname, '..', 'output'),
  },
};

----------------------------------------

TITLE: Creating Typed JSON Property Index in MySQL (TypeScript)
DESCRIPTION: Illustrates how to create a typed index on a JSON property in MySQL using MikroORM. The example uses the @Index decorator with additional options to specify the return type.

LANGUAGE: typescript
CODE:
@Entity()
@Index({ properties: 'metaData.foo', options: { returning: 'char(200)' } })
export class Book {

  @Property({ type: 'json', nullable: true })
  metaData?: { foo: string; bar: number };

}

----------------------------------------

TITLE: Customizing Logger in MikroORM
DESCRIPTION: This snippet shows how to provide a custom logger function to MikroORM for customized logging output.

LANGUAGE: typescript
CODE:
return MikroORM.init({
  debug: true,
  logger: msg => myCustomLogger.log(msg),
});

----------------------------------------

TITLE: Defining Wildcard Schema Entities in MikroORM
DESCRIPTION: This snippet shows how to define an entity that can exist in multiple schemas using a wildcard schema. It demonstrates the use of the '*' wildcard in the schema option of the @Entity decorator.

LANGUAGE: typescript
CODE:
@Entity({ schema: '*' })
export class Book {

  @PrimaryKey()
  id!: number;

  @Property({ nullable: true })
  name?: string;

  @ManyToOne(() => Author, { nullable: true, deleteRule: 'cascade' })
  author?: Author;

  @ManyToOne(() => Book, { nullable: true })
  basedOn?: Book;

}

----------------------------------------

TITLE: Performing Database Operations with MikroORM in TypeScript
DESCRIPTION: This snippet demonstrates how to use MikroORM to perform common database operations such as creating entities, persisting changes, and querying data. It shows the usage of the EntityManager.

LANGUAGE: typescript
CODE:
import { MikroORM } from '@mikro-orm/core';
import { User } from './entities/User';

async function example() {
  const orm = await MikroORM.init(config);
  const em = orm.em;

  const user = new User();
  user.name = 'John Doe';
  user.email = 'john@example.com';

  await em.persistAndFlush(user);

  const users = await em.find(User, {});
  console.log(users);

  await orm.close();
}

----------------------------------------

TITLE: Defining Multiple ManyToMany Relationships with Custom Pivot Tables in MikroORM
DESCRIPTION: This snippet demonstrates how to define multiple ManyToMany relationships between the same entities in MikroORM, using custom pivot table names to avoid conflicts. It shows the syntax for specifying pivot table names on the owning side.

LANGUAGE: typescript
CODE:
@Entity()
export class Publisher {
  // just on owning side (no mapped by provided)
  @ManyToMany({ entity: () => Customer, pivotTable: "customer_publisher" })
  costumers = new Collection<Customer>(this);

  // just on owning side (no mapped by provided)
  @ManyToMany({ entity: () => Author, pivotTable: "publisher_author" })
  authors = new Collection<Author>(this);
}

----------------------------------------

TITLE: Creating Entity Instances with Repository
DESCRIPTION: Shows how to create new entity instances using the EntityManager's create method and repository.

LANGUAGE: typescript
CODE:
const repo = em.getRepository<Author>('Author');
const author = repo.create('Author', { name: 'name', email: 'email' }); // instance of internal Author class
await repo.persistAndFlush(author);

----------------------------------------

TITLE: EntityManager Usage in Migrations
DESCRIPTION: Example showing how to use EntityManager within migrations for data modifications, though this approach is discouraged in favor of raw queries.

LANGUAGE: typescript
CODE:
import { Migration } from '@mikro-orm/migrations';
import { User } from '../entities/User';

export class Migration20191019195930 extends Migration {

  async up(): Promise<void> {
    const em = this.getEntityManager();
    em.create(User, { ... });
    await em.flush();
  }

}

----------------------------------------

TITLE: EntityManager Usage in Migrations
DESCRIPTION: Example showing how to use EntityManager within migrations for data modifications, though this approach is discouraged in favor of raw queries.

LANGUAGE: typescript
CODE:
import { Migration } from '@mikro-orm/migrations';
import { User } from '../entities/User';

export class Migration20191019195930 extends Migration {

  async up(): Promise<void> {
    const em = this.getEntityManager();
    em.create(User, { ... });
    await em.flush();
  }

}

----------------------------------------

TITLE: Clearing Identity Map Cache in MikroORM with TypeScript
DESCRIPTION: This snippet demonstrates how to clear the Identity Map cache using the em.clear() method in MikroORM.

LANGUAGE: typescript
CODE:
orm.em.clear();

----------------------------------------

TITLE: Basic EntityRepository Usage in TypeScript with MikroORM
DESCRIPTION: Demonstrates how to use EntityRepository for fetching entities with sorting, pagination and population options.

LANGUAGE: typescript
CODE:
const booksRepository = orm.em.getRepository(Book);

// with sorting, limit and offset parameters, populating author references
const books = await booksRepository.find({ author: '...' }, ['author'], { title: QueryOrder.DESC }, 2, 1);

// or with options object
const books = await booksRepository.find({ author: '...' }, {
  populate: ['author'],
  limit: 1,
  offset: 2,
  sort: { title: QueryOrder.DESC },
});

console.log(books); // Book[]

----------------------------------------

TITLE: Implementing Composite Primary Keys with Primitive Types in TypeScript
DESCRIPTION: Demonstrates how to create an entity with composite primary keys using primitive types (string and number) in MikroORM. Shows implementation of a Car entity with name and year as primary keys.

LANGUAGE: typescript
CODE:
@Entity()
export class Car {

  @PrimaryKey()
  name: string;

  @PrimaryKey()
  year: number;

  // this is needed for proper type checks in `FilterQuery`
  [PrimaryKeyProp]?: ['name', 'year'];

  constructor(name: string, year: number) {
    this.name = name;
    this.year = year;
  }

}

----------------------------------------

TITLE: Querying by JSON Object Properties in MikroORM (TypeScript)
DESCRIPTION: Shows how to query entities by JSON object properties in MikroORM. The example demonstrates querying nested JSON structures with various data types.

LANGUAGE: typescript
CODE:
const b = await em.findOne(Book, {
  meta: {
    valid: true,
    nested: {
      foo: '123',
      bar: 321,
      deep: {
        baz: 59,
        qux: false,
      },
    },
  },
});

----------------------------------------

TITLE: Querying with Complex AND Conditions in MikroORM TypeScript
DESCRIPTION: This snippet demonstrates how to create a complex query using multiple AND conditions with various operators on the 'id' field of the Author entity.

LANGUAGE: typescript
CODE:
const res = await orm.em.find(Author, { $and: [
  { id: { $in: [1, 2, 7] }, },
  { id: { $nin: [3, 4] }, },
  { id: { $gt: 5 }, },
  { id: { $lt: 10 }, },
  { id: { $gte: 7 }, },
  { id: { $lte: 8 }, },
  { id: { $ne: 9 }, },
] });

----------------------------------------

TITLE: QueryBuilder Usage with Composite Keys in MikroORM
DESCRIPTION: Examples of using QueryBuilder with composite keys, showing different ways to construct queries with composite key conditions.

LANGUAGE: typescript
CODE:
const qb1 = em.createQueryBuilder(CarOwner);
qb1.select('*').where({ car: { name: 'Audi A8', year: 2010 } });
console.log(qb1.getQuery());

const qb2 = em.createQueryBuilder(CarOwner);
qb2.select('*').where({ car: ['Audi A8', 2010] });
console.log(qb2.getQuery());

const qb3 = em.createQueryBuilder(CarOwner);
qb3.select('*').where({ car: [['Audi A8', 2010]] });
console.log(qb3.getQuery());

----------------------------------------

TITLE: Implementing Custom Entity Serialization
DESCRIPTION: Example of implementing a custom toJSON method in an entity class with property stripping functionality.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  // ...

  toJSON(strict = true, strip = ['id', 'email'], ...args: any[]): { [p: string]: any } {
    const o = wrap(this, true).toObject(...args); // do not forget to pass rest params here

    if (strict) {
      strip.forEach(k => delete o[k]);
    }

    return o;
  }

}

----------------------------------------

TITLE: Basic QueryBuilder Usage
DESCRIPTION: Example of creating and executing a basic update query using QueryBuilder with parameter binding.

LANGUAGE: typescript
CODE:
const qb = em.createQueryBuilder(Author);
qb.update({ name: 'test 123', type: PublisherType.GLOBAL }).where({ id: 123, type: PublisherType.LOCAL });

console.log(qb.getQuery());
// update `publisher2` set `name` = ?, `type` = ? where `id` = ? and `type` = ?

console.log(qb.getParams());
// ['test 123', PublisherType.GLOBAL, 123, PublisherType.LOCAL]

// run the query
const res1 = await qb.execute();

----------------------------------------

TITLE: Implicit Transactions in MikroORM
DESCRIPTION: This example demonstrates how MikroORM handles implicit transactions when persisting and flushing changes, including cascading operations.

LANGUAGE: typescript
CODE:
const user = await em.findOne(User, 1);
user.email = 'foo@bar.com';
const car = new Car();
user.cars.add(car);

// thanks to bi-directional cascading we only need to persist user entity
// flushing will create a transaction, insert new car and update user with new email
await em.persistAndFlush(user);

----------------------------------------

TITLE: Defining Shadow Properties in MikroORM
DESCRIPTION: This snippet demonstrates how to create shadow properties in MikroORM entities. These properties are not persisted to the database but are part of the serialized result.

LANGUAGE: typescript
CODE:
@Entity()
class Book {

  @Property({ persist: false })
  count?: number;

}

const book = new Book(...);
wrap(book).assign({ count: 123 });
console.log(wrap(book).toObject().count); // 123
console.log(wrap(book).toJSON().count); // 123

----------------------------------------

TITLE: Point Class Implementation for Spatial Data
DESCRIPTION: Definition of a Point class for representing geographic coordinates in a spatial data implementation.

LANGUAGE: typescript
CODE:
export class Point {

  constructor(
    public latitude: number,
    public longitude: number,
  ) {
  }

}

----------------------------------------

TITLE: Querying Entities with EntityRepository in TypeScript
DESCRIPTION: Demonstrates how to use EntityRepository to fetch entities with sorting, pagination and population options. Shows both parameter-based and options object approaches.

LANGUAGE: typescript
CODE:
const booksRepository = orm.em.getRepository(Book);

// with sorting, limit and offset parameters, populating author references
const books = await booksRepository.find({ author: '...' }, ['author'], { title: QueryOrder.DESC }, 2, 1);

// or with options object
const books = await booksRepository.find({ author: '...' }, {
  populate: ['author'],
  limit: 1,
  offset: 2,
  sort: { title: QueryOrder.DESC },
});

console.log(books); // Book[]

----------------------------------------

TITLE: Implementing Cascade Remove in MikroORM
DESCRIPTION: This snippet illustrates how cascade remove operates in MikroORM. It shows that when an entity is removed, its related entities (in this case, the publisher) are also removed if cascade remove is set.

LANGUAGE: typescript
CODE:
await orm.em.remove(book).flush(); // this will also remove book.publisher

----------------------------------------

TITLE: Initializing Embeddables in User Entity
DESCRIPTION: This snippet shows how to initialize an embeddable property in the User entity to avoid getting null values when all fields are nullable.

LANGUAGE: typescript
CODE:
@Embedded(() => Address)
address = new Address();

----------------------------------------

TITLE: Nested Populate Query in MikroORM (TypeScript)
DESCRIPTION: Demonstrates how to perform a nested populate query in MikroORM, loading BookTags with their associated Books, Publishers, Tests, and Authors.

LANGUAGE: typescript
CODE:
const tags = await em.findAll(BookTag, { populate: ['books.publisher.tests', 'books.author'] });
console.log(tags[0].books[0].publisher.tests[0].name); // prints name of nested test
console.log(tags[0].books[0].author.name); // prints name of nested author

----------------------------------------

TITLE: Manual Entity Loading with EntityLoader in MikroORM
DESCRIPTION: This snippet shows how to manually use the EntityLoader in MikroORM to populate related entities when you already have a list of entities, such as those queried via QueryBuilder.

LANGUAGE: typescript
CODE:
import { EntityLoader } from 'mikro-orm';

const loader = new EntityLoader(orm.em);
const res = await orm.em.createQueryBuilder(Author).select('*').execute();
const authors = res.map(data => orm.em.merge(Author, data));
await loader.populate(Author, authors, ['books.tags']);

// now your Author entities will have `books` collections populated,
// as well as they will have their `tags` collections populated.
console.log(authors[0].books[0].tags[0]); // initialized BookTag

----------------------------------------

TITLE: Defining a ManyToOne Relation in TypeScript
DESCRIPTION: This snippet shows how to define a ManyToOne relation using TypeScript decorators in MikroORM. It demonstrates the use of the @ManyToOne decorator to create a reference to an Author entity.

LANGUAGE: typescript
CODE:
@ManyToOne(() => Author)
author!: Author; // the value is always instance of the `Author` entity

----------------------------------------

TITLE: Using Class-based Data with assign() in TypeScript
DESCRIPTION: This snippet demonstrates how to use class-based data with the assign() method by extending the PlainObject class for DTO validation.

LANGUAGE: typescript
CODE:
import { PlainObject } from '@mikro-orm/core';

class UpdateAuthorDTO extends PlainObject {

  @IsString()
  @IsNotEmpty()
  name!: string;

  @ValidateNested()
  @Type(() => UpdateBookDto)
  books!: UpdateBookDto[];

}

// dto is an instance of UpdateAuthorDto
em.assign(user, dto);

----------------------------------------

TITLE: Enum Property Definition Examples
DESCRIPTION: Different ways to define enum properties in entities with proper type information.

LANGUAGE: typescript
CODE:
@Enum(() => UserRole)
role: UserRole;

@Enum({ type: 'UserRole' })
role: UserRole;

@Enum({ items: ['a', 'b', 'c'] })
role: UserRole;

----------------------------------------

TITLE: Implementing Composite Primary Keys with Primitive Types in TypeScript
DESCRIPTION: Demonstrates how to create an entity with composite primary keys using primitive types (string and number) in MikroORM. Shows implementation of a Car entity with name and year as primary keys.

LANGUAGE: typescript
CODE:
@Entity()
export class Car {

  @PrimaryKey()
  name: string;

  @PrimaryKey()
  year: number;

  // this is needed for proper type checks in `FilterQuery`
  [PrimaryKeyProp]?: ['name', 'year'];

  constructor(name: string, year: number) {
    this.name = name;
    this.year = year;
  }

}

----------------------------------------

TITLE: Configuring Cascade Operations in MikroORM TypeScript Decorators
DESCRIPTION: Examples of different cascade configurations for OneToMany relationships in MikroORM. Shows various combinations of cascade options including persist, merge, remove, and all.

LANGUAGE: typescript
CODE:
// cascade persist & merge is default value
@OneToMany({ entity: () => Book, mappedBy: 'author' })
books = new Collection<Book>(this);

// same as previous definition
@OneToMany({ entity: () => Book, mappedBy: 'author', cascade: [Cascade.PERSIST, Cascade.MERGE] })
books = new Collection<Book>(this);

// only cascade remove
@OneToMany({ entity: () => Book, mappedBy: 'author', cascade: [Cascade.REMOVE] })
books = new Collection<Book>(this);

// cascade persist and remove (but not merge)
@OneToMany({ entity: () => Book, mappedBy: 'author', cascade: [Cascade.PERSIST, Cascade.REMOVE] })
books = new Collection<Book>(this);

// no cascade
@OneToMany({ entity: () => Book, mappedBy: 'author', cascade: [] })
books = new Collection<Book>(this);

// cascade all (persist, merge and remove)
@OneToMany({ entity: () => Book, mappedBy: 'author', cascade: [Cascade.ALL] })
books = new Collection<Book>(this);

// same as previous definition
@OneToMany({ entity: () => Book, mappedBy: 'author', cascade: [Cascade.PERSIST, Cascade.MERGE, Cascade.REMOVE] })
books = new Collection<Book>(this);

----------------------------------------

TITLE: Querying Entities in Specific Schema with MikroORM
DESCRIPTION: This code shows how to query for an entity in a specific schema using EntityManager. The 'schema' option is used in the findOne method to specify the target schema.

LANGUAGE: typescript
CODE:
const user = await em.findOne(User, { ... }, { schema: 'client-123' });

----------------------------------------

TITLE: Primary Key Array Lookup
DESCRIPTION: Shows how to perform a direct primary key lookup using an array of IDs.

LANGUAGE: typescript
CODE:
const res = await orm.em.find(Author, [1, 2, 7]);

----------------------------------------

TITLE: Implementing Advanced OnFlush EventSubscriber
DESCRIPTION: Example of an EventSubscriber using onFlush event to automatically create and link related entities during persistence.

LANGUAGE: typescript
CODE:
@Subscriber()
export class FooBarSubscriber implements EventSubscriber {

  async onFlush(args: FlushEventArgs): Promise<void> {
    const changeSets = args.uow.getChangeSets();
    const cs = changeSets.find(cs => cs.type === ChangeSetType.CREATE && cs.entity instanceof FooBar);

    if (cs) {
      const baz = new FooBaz();
      baz.name = 'dynamic';
      cs.entity.baz = baz;
      args.uow.computeChangeSet(baz);
      args.uow.recomputeSingleChangeSet(cs.entity);
    }
  }

}

const bar = new FooBar();
bar.name = 'bar';
await em.persistAndFlush(bar);

----------------------------------------

TITLE: Cloning MikroORM Guide Repository
DESCRIPTION: Command to clone the example project repository containing the complete guide implementation.

LANGUAGE: bash
CODE:
git clone https://github.com/mikro-orm/guide.git

----------------------------------------

TITLE: Using Custom Entity Class in TypeScript
DESCRIPTION: This snippet demonstrates how to use a custom entity class after defining it with EntitySchema. It creates a new Author instance and persists it to the database.

LANGUAGE: typescript
CODE:
const repo = em.getRepository(Author);
const author = new Author('name', 'email');
await repo.persistAndFlush(author);

----------------------------------------

TITLE: MongoDB Queries for Nested Population in MikroORM
DESCRIPTION: This snippet illustrates the MongoDB queries generated by MikroORM when performing nested population. It shows how MikroORM efficiently loads related entities in MongoDB without pivot tables.

LANGUAGE: typescript
CODE:
db.getCollection("book-tag").find({}).toArray();
db.getCollection("book").find({"tags":{"$in":[...]}}).toArray();
db.getCollection("publisher").find({"_id":{"$in":[...]}}).toArray();
db.getCollection("test").find({"_id":{"$in":[...]}}).toArray();
db.getCollection("author").find({"_id":{"$in":[...]}}).toArray();

----------------------------------------

TITLE: Running TypeScript Schema Generation Script with ts-node
DESCRIPTION: Command to execute the TypeScript schema generation script using ts-node, which allows running TypeScript files directly without compilation.

LANGUAGE: sh
CODE:
$ ts-node create-schema

----------------------------------------

TITLE: Implementing ManyToOne Relationships in MikroORM TypeScript
DESCRIPTION: Demonstrates different ways to define ManyToOne relationships in MikroORM entities using TypeScript decorators. Shows various syntax options including plain decorator, callback type specification, string type, and options object.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @ManyToOne() // plain decorator is enough, type will be sniffer via reflection!
  author1!: Author;

  @ManyToOne(() => Author) // you can specify type manually as a callback
  author2!: Author;

  @ManyToOne('Author') // or as a string
  author3!: Author;

  @ManyToOne({ entity: () => Author }) // or use options object
  author4!: Author;

}

----------------------------------------

TITLE: Entity Interface Extension with WrappedEntity in MikroORM
DESCRIPTION: Shows how to extend entity interfaces with WrappedEntity to include helper methods

LANGUAGE: typescript
CODE:
@Entity()
export class Book { ... }
export interface Book extends WrappedEntity<Book, 'id'> { }

----------------------------------------

TITLE: GraphQL Query Example for Authors and Books
DESCRIPTION: Sample GraphQL query structure that automatically utilizes dataloaders when fetching nested author and book data.

LANGUAGE: graphql
CODE:
{
  authors {
    name
    books {
      title
    }
  }
}

----------------------------------------

TITLE: Mapping Collection Items in TypeScript with MikroORM
DESCRIPTION: Shows how to use the indexBy method to convert a collection to a key-value dictionary. It demonstrates mapping to both entity objects and property values.

LANGUAGE: typescript
CODE:
// given `user.settings` is `Collection<Option>`
const settingsDictionary = user.settings.indexBy('key');
// `settingsDictionary` is `Record<string, Option>`

const settingsDictionary = user.settings.indexBy('key', 'value');
// `settingsDictionary` is `Record<string, string>`

----------------------------------------

TITLE: Initializing MikroORM with JavaScript Metadata Provider
DESCRIPTION: Configuration example for initializing MikroORM with JavaScript metadata provider, specifying entity directories and database connection settings.

LANGUAGE: javascript
CODE:
const orm = await MikroORM.init({
  entitiesDirs: ['entities'],
  dbName: '...',
  metadataProvider: JavaScriptMetadataProvider,
});

----------------------------------------

TITLE: Programmatic SchemaGenerator Usage - TypeScript
DESCRIPTION: Example script demonstrating programmatic usage of SchemaGenerator including initialization, schema operations, and database management.

LANGUAGE: typescript
CODE:
import { MikroORM } from '@mikro-orm/core';

(async () => {
  const orm = await MikroORM.init({
    entities: [Author, Book, ...],
    dbName: 'your-db-name',
    // ...
  });
  const generator = orm.schema;

  const dropDump = await generator.getDropSchemaSQL();
  console.log(dropDump);

  const createDump = await generator.getCreateSchemaSQL();
  console.log(createDump);

  const updateDump = await generator.getUpdateSchemaSQL();
  console.log(updateDump);

  // there is also `generate()` method that returns drop + create queries
  const dropAndCreateDump = await generator.generate();
  console.log(dropAndCreateDump);

  // or you can run those queries directly, but be sure to check them first!
  await generator.dropSchema();
  await generator.createSchema();
  await generator.updateSchema();

  // in tests it can be handy to use those:
  await generator.refreshDatabase(); // ensure db exists and is fresh
  await generator.clearDatabase(); // removes all data

  await orm.close(true);
})();

----------------------------------------

TITLE: Configuring Global Filters in MikroORM Initialization
DESCRIPTION: Demonstrates how to register global filters during MikroORM initialization using the configuration object.

LANGUAGE: typescript
CODE:
MikroORM.init({
  filters: { tenant: { cond: args => ({ tenant: args.tenant }), entity: ['Author', 'User'] } },
  ...
})

----------------------------------------

TITLE: Basic Entity Reference Updates in TypeScript
DESCRIPTION: Demonstrates the basic approach of updating entity references using em.getReference()

LANGUAGE: typescript
CODE:
const jon = new Author('Jon Snow', 'snow@wall.st');
const book = new Book('Book', jon);
book.author = em.getReference(Author, '...id...');

----------------------------------------

TITLE: Defining Entity Serialization Interface in TypeScript
DESCRIPTION: Interface definition for entity serialization methods toObject() and toJSON() that are monkey-patched onto all entities.

LANGUAGE: typescript
CODE:
export interface AnyEntity<K = number | string> {
  toObject(parent?: AnyEntity, isCollection?: boolean): Record<string, any>;
  toJSON(...args: any[]): Record<string, any>;
  // ...
}

----------------------------------------

TITLE: Implementing Shadow Properties in Entities
DESCRIPTION: Example of creating non-persisted properties using persist: false flag that exist only in memory.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @Property({ persist: false })
  count?: number;

}

const book = new Book(...);
wrap(book).assign({ count: 123 });
console.log(wrap(book).toObject().count); // 123
console.log(wrap(book).toJSON().count); // 123

----------------------------------------

TITLE: Updating Entity Values with assign() in TypeScript
DESCRIPTION: This snippet shows how to use the assign() method to update entity values, including relations, using string IDs.

LANGUAGE: typescript
CODE:
import { wrap } from '@mikro-orm/core';

wrap(book).assign({
  title: 'Better Book 1',
  author: '...id...',
});
console.log(book.title); // 'Better Book 1'
console.log(book.author); // instance of Author with id: '...id...'
console.log(book.author.id); // '...id...'

----------------------------------------

TITLE: Installing Hapi Plugin Dependencies
DESCRIPTION: Installation commands for Hapi-specific AdminJS plugin and its peer dependencies.

LANGUAGE: bash
CODE:
$ yarn add @adminjs/hapi
# Peer dependencies
$ yarn add @hapi/boom @hapi/cookie @hapi/hapi @hapi/inert

----------------------------------------

TITLE: Disabling Metadata Cache in MikroORM (TypeScript)
DESCRIPTION: This snippet demonstrates how to disable metadata caching when initializing MikroORM. It sets the 'enabled' option to false in the cache configuration.

LANGUAGE: typescript
CODE:
await MikroORM.init({
  cache: { enabled: false },
  // ...
});

----------------------------------------

TITLE: Configuring Custom Cache Directory in MikroORM
DESCRIPTION: Shows how to specify a custom directory for storing metadata cache files.

LANGUAGE: typescript
CODE:
await MikroORM.init({
  // defaults to `./temp`
  metadataCache: { options: { cacheDir: '...' } },
  // ...
});

----------------------------------------

TITLE: Defining OneToMany Collections in MikroORM
DESCRIPTION: Shows how to define OneToMany collections in MikroORM entities. It demonstrates the relationship between Book and Author entities, where an Author has a collection of Books.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @PrimaryKey()
  _id: ObjectID;

  @ManyToOne()
  author: Author;

}

@Entity()
export class Author {

  @PrimaryKey()
  _id: ObjectID;

  @OneToMany({ entity: () => Book, mappedBy: 'author' })
  books = new Collection<Book>(this);

}

----------------------------------------

TITLE: Implementing One-to-One Derived Identity Pattern
DESCRIPTION: Demonstrates how to implement a one-to-one relationship where the dependent class reuses the primary key of its parent, using User and Address entities as an example.

LANGUAGE: typescript
CODE:
@Entity()
export class User {

  @PrimaryKey()
  id!: number;

  @OneToOne(() => Address, address => address.user, { cascade: [Cascade.ALL] })
  address?: Address;

}

@Entity()
export class Address {

  @OneToOne({ primary: true })
  user!: User;

  [PrimaryKeyType]: number;

}

----------------------------------------

TITLE: Defining ManyToOne Relationships in MikroORM with TypeScript
DESCRIPTION: This snippet demonstrates various ways to define a ManyToOne relationship in MikroORM using TypeScript decorators. It shows different syntaxes for specifying the related entity type.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @ManyToOne() // plain decorator is enough, type will be sniffer via reflection!
  author1!: Author;

  @ManyToOne(() => Author) // you can specify type manually as a callback
  author2!: Author;

  @ManyToOne('Author') // or as a string
  author3!: Author;

  @ManyToOne({ entity: () => Author }) // or use options object
  author4!: Author;

}

----------------------------------------

TITLE: QueryBuilder Methods Interface Definition in TypeScript
DESCRIPTION: Complete interface definition of the QueryBuilder class showing all available methods for building and executing database queries. Includes methods for CRUD operations, joins, filtering, ordering, grouping and query execution.

LANGUAGE: typescript
CODE:
select(fields: Field<T> | Field<T>[], distinct?: boolean): QueryBuilder;
addSelect(fields: string | string[]): QueryBuilder;
insert(data: any): QueryBuilder;
update(data: any): QueryBuilder;
delete(cond?: QBFilterQuery): QueryBuilder;
truncate(): QueryBuilder;
count(field?: string | string[], distinct?: boolean): QueryBuilder;
join(field: string, alias: string, cond?: QBFilterQuery, type?: 'leftJoin' | 'innerJoin' | 'pivotJoin', path?: string): QueryBuilder;
leftJoin(field: string, alias: string, cond?: QBFilterQuery): QueryBuilder;
withSubQuery(subQuery: KnexQueryBuilder, alias: string): QueryBuilder;
where(cond: QBFilterQuery<T>, operator?: keyof typeof GroupOperator): QueryBuilder;
where(cond: string, params?: any[], operator?: keyof typeof GroupOperator): QueryBuilder;
andWhere(cond: QBFilterQuery<T>): QueryBuilder;
andWhere(cond: string, params?: any[]): QueryBuilder;
orWhere(cond: QBFilterQuery<T>): QueryBuilder;
orWhere(cond: string, params?: any[]): QueryBuilder;
orderBy(orderBy: QueryOrderMap): QueryBuilder;
groupBy(fields: (string | keyof T) | (string | keyof T)[]): QueryBuilder;
having(cond?: QBFilterQuery | string, params?: any[]): QueryBuilder;
raw(sql: string): Raw;
limit(limit?: number, offset?: number): QueryBuilder;
offset(offset?: number): QueryBuilder;
withSchema(schema?: string): QueryBuilder;
setLockMode(mode?: LockMode): QueryBuilder;
setFlag(flag: QueryFlag): QueryBuilder;
unsetFlag(flag: QueryFlag): QueryBuilder;
getKnexQuery(): KnexQueryBuilder;
getQuery(): string;
getParams(): readonly Value[];
getAliasForJoinPath(path: string): string | undefined;
getNextAlias(prefix?: string): string;
execute<U = any>(method?: 'all' | 'get' | 'run', mapResults?: boolean): Promise<U>;
getResult(): Promise<T[]>;
getResultList(): Promise<T[]>;
getSingleResult(): Promise<T | null>;
/**
 * Returns knex instance with sub-query aliased with given alias.
 * You can provide `EntityName.propName` as alias, then the field name will be used based on the metadata
 */
as(alias: string): KnexQueryBuilder;
clone(): QueryBuilder<T>;
getKnex(): KnexQueryBuilder;

----------------------------------------

TITLE: Propagating Collection Changes in MikroORM
DESCRIPTION: Demonstrates how changes to collections are propagated between related entities in MikroORM. It covers both OneToMany and ManyToMany relationships.

LANGUAGE: typescript
CODE:
// one to many
const author = new Author(...);
const book = new Book(...);

author.books.add(book);
console.log(book.author); // author will be set thanks to the propagation

// many to many works both from owning side and from inverse side
const book = new Book(...);
const tag = new BookTag(...);

book.tags.add(tag);
console.log(tag.books.contains(book)); // true

tag.books.add(book);
console.log(book.tags.contains(tag)); // true

----------------------------------------

TITLE: Configuring SWC for MikroORM decorator and class name support
DESCRIPTION: This SWC configuration enables decorator metadata extraction and class name preservation for MikroORM. It sets the parser to TypeScript, enables decorators, and configures the necessary transform options.

LANGUAGE: json
CODE:
{
  "jsc": {
    "parser": {
      "syntax": "typescript",
      "decorators": true
    },
    "transform": {
      "decoratorMetadata": true,
      "legacyDecorator": true
    },
    "target": "esnext",
    "minify": false
  }
}

----------------------------------------

TITLE: Configuring Custom Cache Directory
DESCRIPTION: Configuration to specify a custom directory for storing metadata cache files instead of the default './temp' folder.

LANGUAGE: typescript
CODE:
await MikroORM.init({
  // defaults to `./temp`
  metadataCache: { options: { cacheDir: '...' } },
  // ...
});

----------------------------------------

TITLE: Creating RequestContext Middleware in MikroORM with TypeScript
DESCRIPTION: This snippet demonstrates how to create a middleware that establishes a new request context using the RequestContext helper in MikroORM. This is useful for dependency injection containers to ensure a unique Identity Map per request.

LANGUAGE: typescript
CODE:
app.use((req, res, next) => {
  RequestContext.create(orm.em, next);
});

----------------------------------------

TITLE: Configuring Entity Discovery Options in MikroORM
DESCRIPTION: Demonstrates how to adjust the entity discovery process in MikroORM by setting various options.

LANGUAGE: typescript
CODE:
MikroORM.init({
  discovery: {
    warnWhenNoEntities: false,
    requireEntitiesArray: true,
    alwaysAnalyseProperties: false,
  },
});

----------------------------------------

TITLE: MongoDB Timer Fix Implementation
DESCRIPTION: Implementation of timer fixes specific to MongoDB driver, handling connection pools and topology

LANGUAGE: typescript
CODE:
import { Topology } from 'mongodb/lib/sdam/topology';
import { ConnectionPool } from 'mongodb/lib/cmap/connection_pool';
import { fakeTimersHooks, wrappedSpy } from './nextTickFixer';

function enableFakeTimersWithMikroOrm() {
  return {
    mocks: [
      wrappedSpy(ConnectionPool, 'constructor', fakeTimersHooks),
      wrappedSpy(ConnectionPool.prototype, 'checkIn', fakeTimersHooks),
      wrappedSpy(ConnectionPool.prototype, 'checkOut', fakeTimersHooks),
      wrappedSpy(ConnectionPool.prototype, 'clear', fakeTimersHooks),
      wrappedSpy(ConnectionPool.prototype, 'destroyConnection', fakeTimersHooks),
      wrappedSpy(ConnectionPool.prototype, 'ensureMinPoolSize', fakeTimersHooks),
      wrappedSpy(ConnectionPool.prototype, 'processWaitQueue', fakeTimersHooks),
      wrappedSpy(Topology.prototype, 'serverUpdateHandler', fakeTimersHooks),
      wrappedSpy(Topology.prototype, 'selectServer', fakeTimersHooks),
    ],
    mockRestore: function () {
      let mock: jest.SpyInstance | undefined;
      while (mock = this.mocks.pop()) {
        mock.mockRestore();
      }
    }
  };
}

----------------------------------------

TITLE: Defining BaseEntity Abstract Class in TypeScript
DESCRIPTION: Example of creating a base entity class with common properties like primary key and timestamps that can be extended by other entities.

LANGUAGE: typescript
CODE:
export abstract class BaseEntity {

  @PrimaryKey()
  _id: ObjectID;

  @Property()
  createdAt = new Date();

  @Property({ onUpdate: () => new Date() })
  updatedAt = new Date();

}

----------------------------------------

TITLE: Defining Formula Property in Entity
DESCRIPTION: Example of defining a formula property in an entity using the @Formula decorator.

LANGUAGE: TypeScript
CODE:
@Entity()
export class Box {

  @Formula('obj_length * obj_height * obj_width')
  objectVolume?: number;

}

----------------------------------------

TITLE: Basic Embeddable Implementation with TypeScript Decorators
DESCRIPTION: Demonstrates how to create a basic embeddable Address class and embed it in a User entity using reflect-metadata decorators. Shows the fundamental structure for embeddables with property definitions.

LANGUAGE: typescript
CODE:
import { Embeddable, Embedded, Entity, PrimaryKey, Property } from '@mikro-orm/core';

@Embeddable()
export class Address {

  @Property()
  street!: string;

  @Property()
  postalCode!: string;

  @Property()
  city!: string;

  @Property()
  country!: string;

}

@Entity()
export class User {

  @PrimaryKey()
  id!: number;

  @Embedded(() => Address)
  address!: Address;

}

----------------------------------------

TITLE: CLI Schema Management Commands - Shell
DESCRIPTION: Basic CLI commands for schema management including create, update, and drop operations. Requires @mikro-orm/cli package installation.

LANGUAGE: shell
CODE:
npx mikro-orm schema:create --dump   # Dumps create schema SQL
npx mikro-orm schema:update --dump   # Dumps update schema SQL
npx mikro-orm schema:drop --dump     # Dumps drop schema SQL

----------------------------------------

TITLE: Clearing Identity Map Cache in MikroORM with TypeScript
DESCRIPTION: This snippet demonstrates how to clear the Identity Map cache using the em.clear() method. This can be useful when you need to reset the state of the Identity Map.

LANGUAGE: typescript
CODE:
orm.em.clear();

----------------------------------------

TITLE: Using ref() Helper for Entity References in MikroORM (TypeScript)
DESCRIPTION: This snippet shows how to use the ref() helper with the Reference wrapper for entity references. It demonstrates various ways to use ref() with different input types.

LANGUAGE: typescript
CODE:
@ManyToOne({ entity: () => Author, ref: true })
author: Ref<Author>;

constructor(dto: { title: string; author: number }) {
  this.title = dto.title;
  this.author = ref(Author, dto.author);
}

LANGUAGE: typescript
CODE:
book.author = ref(Author, null);
book.author = ref(Author, undefined);
book.author = ref(null);
book.author = ref(undefined);
book.author = ref(Author, 1);
book.author = ref(Author, author);
book.author = ref(author);

----------------------------------------

TITLE: Running Native SQL Query in MikroORM with TypeScript
DESCRIPTION: This example demonstrates how to execute a native SQL query using the underlying database connection in MikroORM. It shows how to retrieve the results as an array of objects.

LANGUAGE: typescript
CODE:
const connection = orm.em.getConnection();
const res = await connection.execute('select 1 as count');
console.log(res); // res is array of objects: `[ { count: 1 } ]`

----------------------------------------

TITLE: Inferring Custom Repository Type in MikroORM with TypeScript
DESCRIPTION: Shows how to infer the custom repository type using the EntityRepositoryType symbol, allowing em.getRepository() to return the correctly typed custom repository.

LANGUAGE: typescript
CODE:
@Entity({ customRepository: () => AuthorRepository })
export class Author {

  [EntityRepositoryType]?: AuthorRepository;

}

const repo = em.getRepository(Author); // repo has type AuthorRepository

----------------------------------------

TITLE: ManyToMany Collection Configuration
DESCRIPTION: Demonstrates unidirectional and bidirectional ManyToMany relationship configurations using Collections.

LANGUAGE: typescript
CODE:
@ManyToMany(() => Book)
books1 = new Collection<Book>(this);

@ManyToMany({ entity: () => Book, owner: true })
books2 = new Collection<Book>(this);

@ManyToMany(() => BookTag, tag => tag.books, { owner: true })
tags = new Collection<BookTag>(this);

@ManyToMany({ entity: () => BookTag, inversedBy: 'books' })
tags = new Collection<BookTag>(this);

----------------------------------------

TITLE: MongoDB Queries Generated by MikroORM for Nested Populate
DESCRIPTION: This set of MongoDB queries illustrates how MikroORM optimizes database access for nested populate operations in a MongoDB environment.

LANGUAGE: typescript
CODE:
db.getCollection("book-tag").find({}).toArray();
db.getCollection("book").find({"tags":{"$in":[...]}}).toArray();
db.getCollection("publisher").find({"_id":{"$in":[...]}}).toArray();
db.getCollection("test").find({"_id":{"$in":[...]}}).toArray();
db.getCollection("author").find({"_id":{"$in":[...]}}).toArray();

----------------------------------------

TITLE: Implementing Custom Point Type for Spatial Data in MikroORM
DESCRIPTION: This example demonstrates a more advanced custom type for handling spatial data (Point type) in MikroORM. It includes methods for converting between database and JavaScript representations, as well as SQL conversion methods.

LANGUAGE: typescript
CODE:
export class Point {

  constructor(
    public latitude: number,
    public longitude: number,
  ) {
  }

}

export class PointType extends Type<Point | undefined, string | undefined> {

  convertToDatabaseValue(value: Point | undefined): string | undefined {
    if (!value) {
      return value;
    }

    return `point(${value.latitude} ${value.longitude})`;
  }

  convertToJSValue(value: string | undefined): Point | undefined {
    const m = value?.match(/point\((-?\d+(\.\d+)?) (-?\d+(\.\d+)?)\)/i);

    if (!m) {
      return undefined;
    }

    return new Point(+m[1], +m[3]);
  }

  convertToJSValueSQL(key: string) {
    return `ST_AsText(${key})`;
  }

  convertToDatabaseValueSQL(key: string) {
    return `ST_PointFromText(${key})`;
  }

  getColumnType(): string {
    return 'point';
  }

}

----------------------------------------

TITLE: CacheAdapter Interface Definition for MikroORM
DESCRIPTION: Interface definition for implementing custom cache adapters in MikroORM, including methods for getting, setting, and clearing cache items.

LANGUAGE: typescript
CODE:
export interface CacheAdapter {

  /**
   * Gets the items under `name` key from the cache.
   */
  get(name: string): Promise<any>;

  /**
   * Sets the item to the cache. `origin` is used for cache invalidation and should reflect the change in data.
   */
  set(name: string, data: any, origin: string, expiration?: number): Promise<void>;

  /**
   * Clears all items stored in the cache.
   */
  clear(): Promise<void>;

  /**
   * Called inside `MikroORM.close()` Allows graceful shutdowns (e.g. for redis).
   */
  close?(): Promise<void>;

}

----------------------------------------

TITLE: MongoDB Queries for Nested Population
DESCRIPTION: Demonstrates MongoDB queries executed by MikroORM for populating nested relations without pivot tables.

LANGUAGE: typescript
CODE:
db.getCollection("book-tag").find({}).toArray();
db.getCollection("book").find({"tags":{"$in":[...]}}).toArray();
db.getCollection("publisher").find({"_id":{"$in":[...]}}).toArray();
db.getCollection("test").find({"_id":{"$in":[...]}}).toArray();
db.getCollection("author").find({"_id":{"$in":[...]}}).toArray();

----------------------------------------

TITLE: Manual Entity Path Configuration with Globby
DESCRIPTION: Using globby to manually specify entity paths in MikroORM configuration.

LANGUAGE: typescript
CODE:
import { sync } from 'globby';

const orm = await MikroORM.init({
  entities: sync('./dist/app/**/entities/*.js').map(require),
  // ...
});

----------------------------------------

TITLE: Primary Key Array Lookup in MikroORM
DESCRIPTION: Shows how to perform direct primary key lookups using an array of IDs.

LANGUAGE: typescript
CODE:
const res = await orm.em.find(Author, [1, 2, 7]);

----------------------------------------

TITLE: Webpack Configuration for MikroORM Bundling in JavaScript
DESCRIPTION: This comprehensive Webpack configuration is tailored for bundling MikroORM applications. It includes settings for TypeScript compilation, handling of native modules, and optimization for production builds while preserving entity class names.

LANGUAGE: javascript
CODE:
const path = require('path');
const { EnvironmentPlugin, IgnorePlugin } = require('webpack');
const TerserPlugin = require('terser-webpack-plugin');

// Mark our dev dependencies as externals so they don't get included in the webpack bundle.
const { devDependencies } = require('./package.json');
const externals = {};

for (const devDependency of Object.keys(devDependencies)) {
  externals[devDependency] = `commonjs ${devDependency}`;
}

// And anything MikroORM's packaging can be ignored if it's not on disk.
// Later we check these dynamically and tell webpack to ignore the ones we don't have.
const optionalModules = new Set([
  ...Object.keys(require('knex/package.json').browser),
  ...Object.keys(require('@mikro-orm/core/package.json').peerDependencies),
  ...Object.keys(require('@mikro-orm/core/package.json').devDependencies || {})
]);

module.exports = {
  entry: path.resolve('app', 'server.ts'),

  // You can toggle development mode on to better see what's going on in the webpack bundle,
  // but for anything that is getting deployed, you should use 'production'.
  // mode: 'development',
  mode: 'production',

  optimization: {
    minimizer: [
      new TerserPlugin({
        terserOptions: {
          // We want to minify the bundle, but don't want Terser to change the names of our entity
          // classes. This can be controlled in a more granular way if needed, (see
          // https://terser.org/docs/api-reference.html#mangle-options) but the safest default
          // config is that we simply disable mangling altogether but allow minification to proceed.
          mangle: false,
          // Similarly, Terser's compression may at its own discretion change function and class names.
          // While it only rarely does so, it's safest to also disable changing their names here.
          // This can be controlled in a more granular way if needed (see
          // https://terser.org/docs/api-reference.html#compress-options).
          compress: {
            keep_classnames: true,
            keep_fnames: true,
          },
        }
      })
    ]
  },
  target: 'node',
  module: {
    rules: [
      // Bring in our typescript files.
      {
        test: /\.ts$/,
        exclude: /node_modules/,
        loader: 'ts-loader',
      },

      // Native modules can be bundled as well.
      {
        test: /\.node$/,
        use: 'node-loader',
      },

      // Some of MikroORM's dependencies use mjs files, so let's set them up here.
      {
        test: /\.mjs$/,
        include: /node_modules/,
        type: 'javascript/auto',
      },
    ],
  },

  // These are computed above.
  externals,

  resolve: {
    extensions: ['.ts', '.js']
  },

  plugins: [
    // Ignore any of our optional modules if they aren't installed. This ignores database drivers
    // that we aren't using for example.
    new EnvironmentPlugin({ WEBPACK: true }),
    new IgnorePlugin({
      checkResource: resource => {
        const baseResource = resource.split('/', resource[0] === '@' ? 2 : 1).join('/');

        if (optionalModules.has(baseResource)) {
          try {
            require.resolve(resource);
            return false;
          } catch {
            return true;
          }
        }

        return false;
      },
    }),
  ],

  output: {
    filename: 'server.js',
    libraryTarget: 'commonjs',
    path: path.resolve(__dirname, '..', 'output'),
  },
};

----------------------------------------

TITLE: Fetching Entities with EntityRepository in TypeScript
DESCRIPTION: Demonstrates how to use EntityRepository to fetch entities from the database with various options like sorting, limit, offset, and populating references.

LANGUAGE: typescript
CODE:
const booksRepository = orm.em.getRepository(Book);

// with sorting, limit and offset parameters, populating author references
const books = await booksRepository.find({ author: '...' }, ['author'], { title: QueryOrder.DESC }, 2, 1);

// or with options object
const books = await booksRepository.find({ author: '...' }, {
  populate: ['author'],
  limit: 1,
  offset: 2,
  orderBy: { title: QueryOrder.DESC },
});

console.log(books); // Book[]

----------------------------------------

TITLE: Basic Collection Operations in TypeScript with MikroORM
DESCRIPTION: Demonstrates basic operations with Collections including iteration, adding/removing items, and checking collection state. Shows how to work with populated and unpopulated collections.

LANGUAGE: typescript
CODE:
const author = em.findOne(Author, '...', { populate: ['books'] });

for (const book of author.books) {
  console.log(book.title);
  console.log(book.author.isInitialized());
  console.log(book.author.id);
  console.log(book.author.name);
  console.log(book.publisher);
  console.log(book.publisher.isInitialized());
  console.log(book.publisher.id);
  console.log(book.publisher.name);
}

author.books.add(book);
console.log(author.books.contains(book));
console.log(author.books.exists(item => item === book));
console.log(author.books.find(item => item === book));
console.log(author.books.map(item => item.title));

----------------------------------------

TITLE: Advanced Point Type Implementation for Geographic Coordinates
DESCRIPTION: Complex example implementing a custom Point type for storing geographic coordinates using MySQL's Spatial extension and WKT format.

LANGUAGE: typescript
CODE:
export class Point {

  constructor(
    public latitude: number,
    public longitude: number,
  ) {
  }

}

export class PointType extends Type<Point | undefined, string | undefined> {

  convertToDatabaseValue(value: Point | undefined): string | undefined {
    if (!value) {
      return value;
    }

    return `point(${value.latitude} ${value.longitude})`;
  }

  convertToJSValue(value: string | undefined): Point | undefined {
    const m = value?.match(/point\((-?\d+(\.\d+)?) (-?\d+(\.\d+)?)\)/i);

    if (!m) {
      return undefined;
    }

    return new Point(+m[1], +m[3]);
  }

  convertToJSValueSQL(key: string) {
    return `ST_AsText(${key})`;
  }

  convertToDatabaseValueSQL(key: string) {
    return `ST_PointFromText(${key})`;
  }

  getColumnType(): string {
    return 'point';
  }

}

----------------------------------------

TITLE: Custom PointType Implementation
DESCRIPTION: Implementation of a custom PointType for handling MySQL spatial data with WKT (Well-Known Text) conversion.

LANGUAGE: typescript
CODE:
export class PointType extends Type<Point | undefined, string | undefined> {

  convertToDatabaseValue(value: Point | undefined): string | undefined {
    if (!value) {
      return value;
    }

    return `point(${value.latitude} ${value.longitude})`;
  }

  convertToJSValue(value: string | undefined): Point | undefined {
    const m = value?.match(/point\((\d+(\.\d+)?) (\d+(\.\d+)?)\)/i);

    if (!m) {
      return undefined;
    }

    return new Point(+m[1], +m[3]);
  }

  convertToJSValueSQL(key: string) {
    return `ST_AsText(${key})`;
  }

  convertToDatabaseValueSQL(key: string) {
    return `ST_PointFromText(${key})`;
  }

  getColumnType(): string {
    return 'point';
  }

}

----------------------------------------

TITLE: Basic Entity Definition with reflect-metadata
DESCRIPTION: Example of defining a Book entity using TypeScript decorators and reflect-metadata provider

LANGUAGE: typescript
CODE:
@Entity()
export class Book extends BaseEntity {
  @Property()
  title!: string;

  @ManyToOne(() => Author)
  author!: Author;

  @ManyToOne(() => Publisher, { wrappedReference: true, nullable: true })
  publisher?: IdentifiedReference<Publisher>;

  @ManyToMany({ entity: 'BookTag', fixedOrder: true })
  tags = new Collection<BookTag>(this);
}

----------------------------------------

TITLE: Complex AND Query with Multiple Conditions
DESCRIPTION: Demonstrates how to create a complex query using multiple conditions with $and operator in array format. Shows various comparison operators like $in, $nin, $gt, $lt, $gte, $lte, and $ne.

LANGUAGE: typescript
CODE:
const res = await orm.em.find(Author, { $and: [
  { id: { $in: [1, 2, 7] }, },
  { id: { $nin: [3, 4] }, },
  { id: { $gt: 5 }, },
  { id: { $lt: 10 }, },
  { id: { $gte: 7 }, },
  { id: { $lte: 8 }, },
  { id: { $ne: 9 }, },
] });

----------------------------------------

TITLE: SQL for Creating Typed Index on JSON Property in MySQL
DESCRIPTION: This SQL snippet shows the resulting query for creating a typed index on a JSON property in MySQL. It demonstrates the use of json_value function with a returning clause to specify the data type of the indexed JSON field.

LANGUAGE: sql
CODE:
alter table `book`
  add index `book_meta_data_foo_index`((json_value(`meta_data`, '$.foo' returning char(200))));

----------------------------------------

TITLE: Configuring Orphan Removal in MikroORM
DESCRIPTION: Example showing how to configure and use orphan removal for more aggressive cascade remove operations on collections.

LANGUAGE: typescript
CODE:
export class Author {
  @OneToMany({ entity: () => Book, mappedBy: 'author', orphanRemoval: true })
  books = new Collection<Book>(this);
}

await author.books.set([book1, book2]); // replace whole collection
await author.books.remove(book1); // remove book from collection
await orm.em.persistAndFlush(author); // book1 will be removed, as well as all original items (before we called `set()`)

----------------------------------------

TITLE: Example Test Setup with Timer Fixes
DESCRIPTION: Example showing how to use the timer fix implementations in a test file

LANGUAGE: typescript
CODE:
import { initORM } from './db';
import { enableFakeTimersWithMikroOrm } from './fakeTimersFixer';

test(() => {
  const orm = initORM({
    //your test config
  });
  jest.useFakeTimers();
  const ormMock = enableFakeTimersWithMikroOrm();

  // write your tests normally

  ormMock.restoreMock();
  jest.useRealTimers();
});

----------------------------------------

TITLE: Entity Definition for MongoDB
DESCRIPTION: Example of defining MongoDB entity primary keys using ObjectId and SerializedPrimaryKey decorators.

LANGUAGE: typescript
CODE:
@PrimaryKey()
_id: ObjectId;

@SerializedPrimaryKey()
id!: string; // won't be saved in the database

----------------------------------------

TITLE: GraphQL Query Example for Batched Requests
DESCRIPTION: This GraphQL query demonstrates how MikroORM automatically batches requests when dataloaders are enabled. It retrieves authors with their books in a nested structure.

LANGUAGE: graphql
CODE:
{
  authors {
    name
    books {
      title
    }
  }
}

----------------------------------------

TITLE: Implementing Migration Class
DESCRIPTION: Example of creating a migration class that extends the Migration abstract class to perform schema changes.

LANGUAGE: typescript
CODE:
import { Migration } from '@mikro-orm/migrations';

export class Migration20191019195930 extends Migration {

  async up(): Promise<void> {
    this.addSql('select 1 + 1');
  }

}

----------------------------------------

TITLE: Custom PointType Implementation for MySQL Spatial Data
DESCRIPTION: Implementation of a custom PointType for handling MySQL spatial data with WKT (Well-Known Text) conversion.

LANGUAGE: typescript
CODE:
export class PointType extends Type<Point | undefined, string | undefined> {

  convertToDatabaseValue(value: Point | undefined): string | undefined {
    if (!value) {
      return value;
    }

    return `point(${value.latitude} ${value.longitude})`;
  }

  convertToJSValue(value: string | undefined): Point | undefined {
    const m = value?.match(/point\((-?\d+(\.\d+)?) (-?\d+(\.\d+)?)\)/i);

    if (!m) {
      return undefined;
    }

    return new Point(+m[1], +m[3]);
  }

  convertToJSValueSQL(key: string) {
    return `ST_AsText(${key})`;
  }

  convertToDatabaseValueSQL(key: string) {
    return `ST_PointFromText(${key})`;
  }

  getColumnType(): string {
    return 'point';
  }

}

----------------------------------------

TITLE: Initializing and Accessing MikroORM Collections in TypeScript
DESCRIPTION: Demonstrates how to initialize, iterate through, and manipulate Collection objects in MikroORM. Shows various methods for accessing and modifying collection items, including lazy loading and array-like access.

LANGUAGE: typescript
CODE:
const author = orm.em.findOne(Author, '...', ['books']); // populating books collection

// or we could lazy load books collection later via `init()` method
await author.books.init();

for (const book of author.books) {
  console.log(book.title); // initialized
  console.log(book.author.isInitialized()); // true
  console.log(book.author.id);
  console.log(book.author.name); // Jon Snow
  console.log(book.publisher); // just reference
  console.log(book.publisher.isInitialized()); // false
  console.log(book.publisher.id);
  console.log(book.publisher.name); // undefined
}

// collection needs to be initialized before you can work with it
author.books.add(book);
console.log(author.books.contains(book)); // true
author.books.remove(book);
console.log(author.books.contains(book)); // false
author.books.add(book);
console.log(author.books.count()); // 1
author.books.removeAll();
console.log(author.books.contains(book)); // false
console.log(author.books.count()); // 0
console.log(author.books.getItems()); // Book[]
console.log(author.books.getIdentifiers()); // array of string | number
console.log(author.books.getIdentifiers('_id')); // array of ObjectId

// array access works as well
console.log(author.books[1]); // Book
console.log(author.books[12345]); // undefined, even if the collection is not initialized

const author = orm.em.findOne(Author, '...'); // books collection has not been populated
console.log(author.books.getItems()); // throws because the collection has not been initialized
// initialize collection if not already loaded and return its items as array
console.log(await author.books.loadItems()); // Book[]

----------------------------------------

TITLE: Defining Entities in Multiple Schemas with MikroORM
DESCRIPTION: This snippet demonstrates how to define entities in different schemas using the @Entity decorator. The 'tableName' option is used to specify the schema and table name.

LANGUAGE: typescript
CODE:
@Entity({ tableName: 'first_schema.foo' })
export class Foo { ... }

@Entity({ tableName: 'second_schema.bar' })
export class Bar { ... }

----------------------------------------

TITLE: Using Property Serializers for Custom Serialization
DESCRIPTION: Shows how to use property serializers to customize the serialization of specific properties using callbacks.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @ManyToOne({ serializer: value => value.name, serializedName: 'authorName' })
  author: Author;

}

const author = new Author('God')
const book = new Book(author);
console.log(wrap(book).toJSON().authorName); // 'God'

----------------------------------------

TITLE: MongoDB Driver Bug Fix - Collection Creation
DESCRIPTION: Fix to prevent creating migrations collection by default in MongoDB driver

LANGUAGE: typescript
CODE:
// Before fix
await em.getDriver().ensureIndexes();

// After fix - migrations collection not created by default
await em.getDriver().ensureIndexes();

----------------------------------------

TITLE: Array Shorthand for $in Operator
DESCRIPTION: Demonstrates the shorthand syntax for the $in operator using direct array assignment.

LANGUAGE: typescript
CODE:
const res = await orm.em.find(Author, { favouriteBook: [1, 2, 7] });

----------------------------------------

TITLE: Derived Identity with One-to-One Relationship
DESCRIPTION: Example showing how to implement derived identity using a one-to-one relationship between User and Address entities where Address reuses User's primary key.

LANGUAGE: typescript
CODE:
@Entity()
export class User {

  @PrimaryKey()
  id!: number;

  @OneToOne(() => Address, address => address.user, { cascade: [Cascade.ALL] })
  address?: Address;

}

@Entity()
export class Address {

  @OneToOne({ primary: true })
  user!: User;

  [PrimaryKeyProp]?: 'user';

}

----------------------------------------

TITLE: Entity Creation from Query Results
DESCRIPTION: Demonstrates how to create entity instances from query builder results using the merge method.

LANGUAGE: typescript
CODE:
const res6 = await orm.em.createQueryBuilder(Book).select('*').execute();
const entities = res6.map(data => orm.em.merge(Book, data));
console.log(entities); // array of Book entities

----------------------------------------

TITLE: Configuring Loading Strategy in Entity Definition
DESCRIPTION: Example demonstrating how to configure the loading strategy at the entity property level using decorators.

LANGUAGE: typescript
CODE:
import { Entity, LoadStrategy, OneToMany } from '@mikro-orm/core';

@Entity()
export class Author {

  // ...

  @OneToMany({
    entity: () => Book,
    mappedBy: b => b.author,
    strategy: 'select-in', // force select-in strategy for this relation
  })
  books = new Collection<Book>(this);

}

----------------------------------------

TITLE: Configuring Database Connections with Replicas
DESCRIPTION: Demonstrates how to set up database connections including read replicas with specific connection parameters.

LANGUAGE: typescript
CODE:
MikroORM.init({
  type: 'mysql',
  dbName: 'my_db_name',
  user: 'write-user',
  host: 'master.db.example.com',
  port: 3306,
  replicas: [
    { user: 'read-user-1', host: 'read-1.db.example.com', port: 3307 },
    { user: 'read-user-2', host: 'read-2.db.example.com', port: 3308 },
    { user: 'read-user-3', host: 'read-3.db.example.com', port: 3309 },
  ],
});

----------------------------------------

TITLE: Using TsMorphMetadataProvider for Entity Discovery
DESCRIPTION: Configuration for using the TsMorphMetadataProvider to discover entities using TypeScript compiler API.

LANGUAGE: typescript
CODE:
import { TsMorphMetadataProvider } from '@mikro-orm/reflection';

const orm = await MikroORM.init({
  metadataProvider: TsMorphMetadataProvider,
  // ...
});

----------------------------------------

TITLE: Simplified AND Condition for Single Field in MikroORM (TypeScript)
DESCRIPTION: Shows a simplified way to write AND conditions for a single field, combining all comparison operators in a single object.

LANGUAGE: typescript
CODE:
const res = await orm.em.find(Author, {
  id: {
    $in: [1, 2, 7],
    $nin: [3, 4],
    $gt: 5,
    $lt: 10,
    $gte: 7,
    $lte: 8,
    $ne: 9,
  },
});

----------------------------------------

TITLE: Persisting Changes to Managed Entities in TypeScript
DESCRIPTION: Demonstrates how MikroORM automatically tracks changes to managed entities without requiring explicit persist() calls.

LANGUAGE: typescript
CODE:
const jon = await em.findOne(Author, 1);
jon.email = 'foo@bar.com';
await em.flush();

----------------------------------------

TITLE: Nested Embeddables Configuration
DESCRIPTION: Example of nested embeddable classes showing how to create complex object structures with Profile and Identity embedded within User entity.

LANGUAGE: typescript
CODE:
import { Embeddable, Embedded, Entity, PrimaryKey, Property } from '@mikro-orm/core';

@Entity()
export class User {
  @PrimaryKey()
  id!: number;

  @Property()
  name!: string;

  @Embedded(() => Profile, { object: true, nullable: true })
  profile?: Profile;
}

@Embeddable()
export class Profile {
  @Property()
  username: string;

  @Embedded(() => Identity)
  identity: Identity;

  constructor(username: string, identity: Identity) {
    this.username = username;
    this.identity = identity;
  }
}

@Embeddable()
export class Identity {
  @Property()
  email: string;

  constructor(email: string) {
    this.email = email;
  }
}

----------------------------------------

TITLE: SQL Tagged Templates in MikroORM
DESCRIPTION: Demonstrates the use of sql tagged template function for creating raw SQL fragments with string interpolation support.

LANGUAGE: typescript
CODE:
// as a value
await em.find(User, { time: sql`now()` });

// as a key
await em.find(User, { [sql`lower(name)`]: name.toLowerCase() });

// value can be empty array
await em.find(User, { [sql`(select ${1} = ${1})`]: [] });

----------------------------------------

TITLE: Creating and Executing a Query with QueryBuilder in TypeScript
DESCRIPTION: This snippet demonstrates how to create a QueryBuilder instance, construct an update query with conditions, and execute it. It also shows how to retrieve the generated SQL query and parameters.

LANGUAGE: typescript
CODE:
const qb = orm.em.createQueryBuilder(Author);
qb.update({ name: 'test 123', type: PublisherType.GLOBAL }).where({ id: 123, type: PublisherType.LOCAL });

console.log(qb.getQuery());
// update `publisher2` set `name` = ?, `type` = ? where `id` = ? and `type` = ?

console.log(qb.getParams());
// ['test 123', PublisherType.GLOBAL, 123, PublisherType.LOCAL]

// run the query
const res1 = await qb.execute();

----------------------------------------

TITLE: Nested Embeddables Configuration
DESCRIPTION: Example of nested embeddable classes showing how to create complex object structures with Profile and Identity embedded within User entity.

LANGUAGE: typescript
CODE:
import { Embeddable, Embedded, Entity, PrimaryKey, Property } from '@mikro-orm/core';

@Entity()
export class User {
  @PrimaryKey()
  id!: number;

  @Property()
  name!: string;

  @Embedded(() => Profile, { object: true, nullable: true })
  profile?: Profile;
}

@Embeddable()
export class Profile {
  @Property()
  username: string;

  @Embedded(() => Identity)
  identity: Identity;

  constructor(username: string, identity: Identity) {
    this.username = username;
    this.identity = identity;
  }
}

@Embeddable()
export class Identity {
  @Property()
  email: string;

  constructor(email: string) {
    this.email = email;
  }
}

----------------------------------------

TITLE: Direct Entity Method Usage in MikroORM
DESCRIPTION: Demonstrates direct usage of wrapped entity methods after interface extension

LANGUAGE: typescript
CODE:
book.meta = { foo: 1, bar: 2 };
book.assign({ meta: { foo: 3 } }, { mergeObjects: true });
console.log(book.meta); // { foo: 3, bar: 2 }

----------------------------------------

TITLE: Initializing MikroORM with JavaScriptMetadataProvider
DESCRIPTION: Shows how to initialize MikroORM using JavaScriptMetadataProvider for JavaScript projects.

LANGUAGE: typescript
CODE:
await MikroORM.init({
  metadataProvider: JavaScriptMetadataProvider,
  cache: { enabled: false },
  // ...
});

----------------------------------------

TITLE: SQL Queries Generated for Point Type Operations
DESCRIPTION: Example SQL queries generated when using the custom Point type for database operations.

LANGUAGE: sql
CODE:
begin
insert into `location` (`point`) values (ST_PointFromText('point(1.23 4.56)'))
commit

select `e0`.*, ST_AsText(`e0`.point) as point from `location` as `e0` where `e0`.`id` = ? limit ?

begin
update `location` set `point` = ST_PointFromText('point(2.34 9.87)') where `id` = ?
commit

----------------------------------------

TITLE: Defining CacheAdapter Interface in TypeScript
DESCRIPTION: Shows the interface definition for custom cache adapters in MikroORM. It includes methods for getting, setting, removing, and clearing cached items, as well as an optional close method for graceful shutdowns.

LANGUAGE: typescript
CODE:
export interface CacheAdapter {

  /**
   * Gets the items under `name` key from the cache.
   */
  get(name: string): Promise<any>;

  /**
   * Sets the item to the cache. `origin` is used for cache invalidation and should reflect the change in data.
   */
  set(name: string, data: any, origin: string, expiration?: number): Promise<void>;

  /**
   * Removes the item from cache.
   */
  remove(name: string): Promise<void>;

  /**
   * Clears all items stored in the cache.
   */
  clear(): Promise<void>;

  /**
   * Called inside `MikroORM.close()` Allows graceful shutdowns (e.g. for redis).
   */
  close?(): Promise<void>;

}

----------------------------------------

TITLE: Using Arrays of Embeddables in MikroORM
DESCRIPTION: This snippet shows how to use an array of embeddables, which are always stored as JSON in MikroORM.

LANGUAGE: typescript
CODE:
@Embedded(() => Address, { array: true })
addresses: Address[] = [];

----------------------------------------

TITLE: QueryBuilder Cache Configuration in MikroORM
DESCRIPTION: Shows how to enable caching when using QueryBuilder to fetch results.

LANGUAGE: typescript
CODE:
const res = await em.createQueryBuilder(Book)
  .where({ author: { name: 'Jon Snow' } })
  .cache()
  .getResultList();

----------------------------------------

TITLE: SQL Utility Functions in MikroORM - TypeScript
DESCRIPTION: Shows various SQL utility functions including sql.ref(), sql.now(), sql.lower(), and sql.upper() for common SQL operations.

LANGUAGE: typescript
CODE:
await em.find(User, { foo: sql.ref('bar') });

@Property({ default: sql.now() })
createdAt: Date & Opt;

const books = await orm.em.find(Book, {
  [sql.upper('title')]: 'TITLE',
});

----------------------------------------

TITLE: Manually Defining Entities for MikroORM Initialization
DESCRIPTION: This code shows how to manually define entities when initializing MikroORM, which is necessary when using Webpack bundling.

LANGUAGE: typescript
CODE:
import { Author, Book, BookTag, Publisher, Test } from '../entities';

await MikroORM.init({
  ...
  entities: [Author, Book, BookTag, Publisher, Test],
  discovery: { disableDynamicFileAccess: true },
  ...
});

----------------------------------------

TITLE: Basic Entity Reference Usage in TypeScript
DESCRIPTION: Demonstrates how to work with basic entity references including initialization and property access.

LANGUAGE: typescript
CODE:
const author = orm.em.getReference('...id...');
console.log(author.id); // accessing the id will not trigger any db call
console.log(author.isInitialized()); // false
console.log(author.name); // undefined

await author.init(); // this will trigger db call
console.log(author.isInitialized()); // true
console.log(author.name); // defined

----------------------------------------

TITLE: Defining CacheAdapter Interface in MikroORM (TypeScript)
DESCRIPTION: This code defines the CacheAdapter interface used in MikroORM for implementing custom cache adapters. It includes methods for getting and setting cache data.

LANGUAGE: typescript
CODE:
export interface CacheAdapter {

  get(name: string): any;

  set(name: string, data: any, origin: string): void;

}

----------------------------------------

TITLE: Configuring EntityGenerator Extension
DESCRIPTION: TypeScript configuration to register the EntityGenerator extension in MikroORM config.

LANGUAGE: typescript
CODE:
import { defineConfig } from '@mikro-orm/postgresql';
import { EntityGenerator } from '@mikro-orm/entity-generator';

export default defineConfig({
  dbName: 'test',
  extensions: [EntityGenerator],
});

----------------------------------------

TITLE: LibSQL Feature Commit Message
DESCRIPTION: Addition of remote Turso database connection support for LibSQL

LANGUAGE: markdown
CODE:
* **libsql:** support connecting to remote turso database ([#5764](https://github.com/mikro-orm/mikro-orm/issues/5764)) ([6255a33](https://github.com/mikro-orm/mikro-orm/commit/6255a3302890a02c501357426937d29e393c02f9))

----------------------------------------

TITLE: Defining OneToOne Relationships (Inverse Side) in MikroORM with TypeScript
DESCRIPTION: This snippet shows how to define the inverse side of a OneToOne relationship in MikroORM using TypeScript decorators. It demonstrates the use of the 'mappedBy' option to specify the inverse relationship.

LANGUAGE: typescript
CODE:
@Entity()
export class User {

  @OneToOne({ mappedBy: 'bestFriend1' })
  bestFriend1!: User;

  @OneToOne(() => User, user => user.bestFriend2)
  bestFriend2!: User;

}

----------------------------------------

TITLE: Managing Cache Keys in MikroORM
DESCRIPTION: Shows how to set explicit cache keys and clear cached results using the EntityManager's clearCache method.

LANGUAGE: typescript
CODE:
// set the cache key to 'book-cache-key', with expiration of 60s
const res = await em.find(Book, { ... }, { cache: ['book-cache-key', 60_000] });

// clear the cache key by name
await em.clearCache('book-cache-key');

----------------------------------------

TITLE: Generated SQL Query for JSON Property in PostgreSQL
DESCRIPTION: This SQL snippet shows the generated query for PostgreSQL when querying JSON object properties. It demonstrates how MikroORM translates the TypeScript query into SQL, including type casting for different data types.

LANGUAGE: sql
CODE:
select "e0".*
from "book" as "e0"
where ("meta"->>'valid')::bool = true
  and "meta"->'nested'->>'foo' = '123'
  and ("meta"->'nested'->>'bar')::float8 = 321
  and ("meta"->'nested'->'deep'->>'baz')::float8 = 59
  and ("meta"->'nested'->'deep'->>'qux')::bool = false
limit 1

----------------------------------------

TITLE: Query with Operator Inclusion in Keys in MikroORM (TypeScript)
DESCRIPTION: Illustrates how to include operators in the keys of the query object, providing a more concise syntax for complex conditions.

LANGUAGE: typescript
CODE:
const res = await orm.em.find(Author, { $and: [
  { 'id:in': [1, 2, 7] },
  { 'id:nin': [3, 4] },
  { 'id:gt': 5 },
  { 'id:lt': 10 },
  { 'id:gte': 7 },
  { 'id:lte': 8 },
  { 'id:ne': 9 },
] });

----------------------------------------

TITLE: Basic Entity Definition with @Entity Decorator
DESCRIPTION: Example showing how to define a basic entity class using the @Entity decorator with table name configuration.

LANGUAGE: typescript
CODE:
@Entity({ tableName: 'authors' })
export class Author { ... }

----------------------------------------

TITLE: Defining MongoDB Virtual Entity with Aggregation Pipeline in TypeScript
DESCRIPTION: Creates a virtual entity for MongoDB using an aggregation pipeline. The implementation handles filtering, sorting, and pagination through pipeline stages while joining book and author collections.

LANGUAGE: typescript
CODE:
@Entity({
  expression: (em: EntityManager, where, options) => {
    const $sort = { ...options.orderBy } as Dictionary;
    $sort._id = 1;
    const pipeline: Dictionary[] = [
      { $project: { _id: 0, title: 1, author: 1 } },
      { $sort },
      { $match: where ?? {} },
      { $lookup: { from: 'author', localField: 'author', foreignField: '_id', as: 'author', pipeline: [{ $project: { name: 1 } }] } },
      { $unwind: '$author' },
      { $set: { authorName: '$author.name' } },
      { $unset: ['author'] },
    ];

    if (options.offset != null) {
      pipeline.push({ $skip: options.offset });
    }

    if (options.limit != null) {
      pipeline.push({ $limit: options.limit });
    }

    return em.aggregate(Book, pipeline);
  },
})
export class BookWithAuthor {

  @Property()
  title!: string;

  @Property()
  authorName!: string;

}

----------------------------------------

TITLE: Primary Key Definition
DESCRIPTION: Examples of defining primary keys using @PrimaryKey decorator for different database types

LANGUAGE: typescript
CODE:
@PrimaryKey()
id!: number; // auto increment PK in SQL drivers

@PrimaryKey()
uuid = uuid.v4(); // uuid PK in SQL drivers

@PrimaryKey()
_id!: ObjectId; // ObjectId PK in mongodb driver

----------------------------------------

TITLE: Defining Explicitly Nullable Property with Default Value in MikroORM
DESCRIPTION: This example shows how to define an explicitly nullable property with a default value of null in MikroORM.

LANGUAGE: typescript
CODE:
@Property({ type: 'string', nullable: true })
name: string | null = null;

----------------------------------------

TITLE: Generating MikroORM Cache Bundle
DESCRIPTION: CLI command to generate a production cache bundle into a single JSON file

LANGUAGE: bash
CODE:
npx mikro-orm cache:generate --combined

----------------------------------------

TITLE: Using Knex.js with QueryBuilder in TypeScript
DESCRIPTION: This snippet shows how to access the underlying Knex.js instance from a QueryBuilder, allowing for more advanced query manipulation. It also demonstrates how to execute the Knex query and map the results to entities.

LANGUAGE: typescript
CODE:
const qb = orm.em.createQueryBuilder(Author);
qb.update({ name: 'test 123', type: PublisherType.GLOBAL }).where({ id: 123, type: PublisherType.LOCAL });
const knex = qb.getKnexQuery(); // instance of Knex' QueryBuilder

// do what ever you need with `knex`

const res = await orm.em.getConnection().execute(knex);
const entities = res.map(a => orm.em.map(Author, a));
console.log(entities); // Author[]

----------------------------------------

TITLE: Dynamic Attributes Implementation with Foreign Key Relations
DESCRIPTION: Shows how to implement dynamic attributes for an Article entity using composite keys with foreign entity relationships. Demonstrates one-to-many relationship pattern.

LANGUAGE: typescript
CODE:
@Entity()
export class Article {

  @PrimaryKey()
  id!: number;

  @Property()
  title!: string;

  @OneToMany(() => ArticleAttribute, attr => attr.article, { cascade: Cascade.ALL })
  attributes = new Collection<ArticleAttribute>(this);

}

@Entity()
export class ArticleAttribute {

  @ManyToOne({ primary: true })
  article: Article;

  @PrimaryKey()
  attribute: string;

  @Property()
  value!: string;

  [PrimaryKeyType]: [number, string];

  constructor(name: string, value: string, article: Article) {
    this.attribute = name;
    this.value = value;
    this.article = article;
  }

}

----------------------------------------

TITLE: Defining OneToMany and ManyToOne Relationships in TypeScript
DESCRIPTION: Demonstrates how to define OneToMany and ManyToOne relationships with explicit target entity types.

LANGUAGE: typescript
CODE:
@OneToMany(() => Book, b => b.author)
books = new Collection<Book>(this);

@ManyToOne(() => Publisher, { wrappedReference: true })
publisher!: IdentifiedReference<Publisher>;

----------------------------------------

TITLE: Adding Embedded Entities in MikroORM EntityGenerator
DESCRIPTION: Example of defining and adding an embedded entity with two properties to the generated metadata using the onInitialMetadata hook.

LANGUAGE: typescript
CODE:
import { ReferenceKind } from '@mikro-orm/core';

await orm.entityGenerator.generate({
  onInitialMetadata: (metadata, platform) => {
    const embeddableEntityMeta = new EntityMetadata({
      className: 'IdentitiesContainer',
      collection: platform.getConfig().getNamingStrategy().classToTableName('IdentitiesContainer'),
      embeddable: true,
    });
    embeddableEntityMeta.addProperty({
      name: 'github',
      type: 'string',
      nullable: true,
      fieldNames: ['github'],
      columnTypes: ['varchar(255)'],
    });
    embeddableEntityMeta.addProperty({
      name: 'local',
      type: 'number',
      nullable: true,
      fieldNames: ['local'],
      columnTypes: ['int'],
    });
    metadata.push(embeddableEntityMeta);

    const identitiesPropOnAuthor = metadata.find(meta => meta.className === 'Author')!.properties.identities;
    identitiesPropOnAuthor.kind = ReferenceKind.EMBEDDED;
    identitiesPropOnAuthor.object = true;
    identitiesPropOnAuthor.type = 'IdentitiesContainer';
  },
});

----------------------------------------

TITLE: Advanced EntityGenerator Configuration
DESCRIPTION: Example of advanced configuration options for EntityGenerator.

LANGUAGE: typescript
CODE:
const dump = await orm.entityGenerator.generate({
  entitySchema: true,
  bidirectionalRelations: true,
  identifiedReferences: true,
  esmImport: true,
  save: true,
  path: process.cwd() + '/my-entities',
  skipTables: ['book', 'author'],
  skipColumns: {
    'public.user': ['email', 'middle_name'],
  },
});

----------------------------------------

TITLE: Using raw() Helper with MikroORM Queries in TypeScript
DESCRIPTION: Demonstrates how to use the raw() helper to include raw SQL fragments in MikroORM queries. Shows usage as both value and key in query conditions.

LANGUAGE: typescript
CODE:
// as a value
await em.find(User, { time: raw('now()') });

// as a key
await em.find(User, { [raw('lower(name)')]: name.toLowerCase() });

// value can be empty array
await em.find(User, { [raw('(select 1 = 1)')]: [] });

----------------------------------------

TITLE: Cascading Entity Persistence
DESCRIPTION: Shows how to persist multiple related entities with automatic cascading. Demonstrates both batch persistence and individual entity persistence approaches.

LANGUAGE: typescript
CODE:
const author = new Author('Jon Snow', 'snow@wall.st');
author.born = new Date();

const publisher = new Publisher('7K publisher');

const book1 = new Book('My Life on The Wall, part 1', author);
book1.publisher = publisher;
const book2 = new Book('My Life on The Wall, part 2', author);
book2.publisher = publisher;
const book3 = new Book('My Life on The Wall, part 3', author);
book3.publisher = publisher;

// just persist books, author and publisher will be automatically cascade persisted
await orm.em.persistAndFlush([book1, book2, book3]);

// or one by one
orm.em.persist(book1);
orm.em.persist(book2);
orm.em.persist(book3);
await orm.em.flush(); // flush everything to database at once

----------------------------------------

TITLE: Defining Virtual Entity with MongoDB Aggregation in TypeScript
DESCRIPTION: Demonstrates creating a virtual entity using MongoDB aggregation pipeline. Includes handling of query parameters, sorting, limiting and offsetting results.

LANGUAGE: typescript
CODE:
@Entity({
  expression: (em: EntityManager, where, options) => {
    const $sort = { ...options.orderBy } as Dictionary;
    $sort._id = 1;
    const pipeline: Dictionary[] = [
      { $project: { _id: 0, title: 1, author: 1 } },
      { $sort },
      { $match: where ?? {} },
      { $lookup: { from: 'author', localField: 'author', foreignField: '_id', as: 'author', pipeline: [{ $project: { name: 1 } }] } },
      { $unwind: '$author' },
      { $set: { authorName: '$author.name' } },
      { $unset: ['author'] },
    ];

    if (options.offset != null) {
      pipeline.push({ $skip: options.offset });
    }

    if (options.limit != null) {
      pipeline.push({ $limit: options.limit });
    }

    return em.aggregate(Book, pipeline);
  },
})
export class BookWithAuthor {

  @Property()
  title!: string;

  @Property()
  authorName!: string;

}

----------------------------------------

TITLE: Basic Database Seeder Implementation
DESCRIPTION: Example of a basic seeder class implementation showing how to create and persist entities using EntityManager.

LANGUAGE: typescript
CODE:
import { EntityManager } from '@mikro-orm/core';
import { Seeder } from '@mikro-orm/seeder';
import { Author } from './author'

export class DatabaseSeeder extends Seeder {

  async run(em: EntityManager): Promise<void> {
    // will get persisted automatically
    const author = em.create(Author, {
      name: 'John Snow',
      email: 'snow@wall.st'
    });
  }
}

----------------------------------------

TITLE: Synchronizing Database Schema with MikroORM CLI
DESCRIPTION: This command uses the MikroORM CLI to update the database schema based on entity definitions.

LANGUAGE: sh
CODE:
npx mikro-orm schema:update --run

----------------------------------------

TITLE: Enabling Logging and Debug Mode in MikroORM
DESCRIPTION: This snippet shows how to initialize MikroORM with logging and debug mode enabled. It sets the logger to console.log and turns on the debug flag.

LANGUAGE: typescript
CODE:
return MikroORM.init({
  logger: console.log.bind(console),
  debug: true,
});

----------------------------------------

TITLE: Fetching Partial Entities in MikroORM
DESCRIPTION: Demonstrates how to fetch only specific fields of an entity using the fields option in findOne method.

LANGUAGE: typescript
CODE:
const author = await orm.em.findOne(Author, '...', { fields: ['name', 'born'] });
console.log(author.id); // PK is always selected
console.log(author.name); // Jon Snow
console.log(author.email); // undefined

----------------------------------------

TITLE: Configuring Entity Discovery for TypeScript and JavaScript
DESCRIPTION: Example of configuring MikroORM to discover both TypeScript source files and compiled JavaScript entities.

LANGUAGE: typescript
CODE:
const orm = await MikroORM.init({
  entities: ['./dist/entities/**/*.js'], // path to your JS entities (dist), relative to `baseDir`
  entitiesTs: ['./src/entities/**/*.ts'], // path to your TS entities (source), relative to `baseDir`
  // ...
});

----------------------------------------

TITLE: Generated SQL Query for JSON Properties (PostgreSQL)
DESCRIPTION: Displays the SQL query generated by MikroORM when querying JSON object properties in PostgreSQL. It shows how nested properties are accessed and how different data types are handled.

LANGUAGE: sql
CODE:
select "e0".*
from "book" as "e0"
where ("meta"->>'valid')::bool = true
  and "meta"->>'nested'->>'foo' = '123'
  and ("meta"->>'nested'->>'bar')::float8 = 321
  and ("meta"->>'nested'->'deep'->>'baz')::float8 = 59
  and ("meta"->>'nested'->'deep'->>'qux')::bool = false
limit 1

----------------------------------------

TITLE: Setting Up OneToOne Relationships (Owning Side) in MikroORM
DESCRIPTION: Demonstrates how to configure the owning side of OneToOne relationships, including self-referencing relationships and explicit owner marking.

LANGUAGE: typescript
CODE:
@Entity()
export class User {

  @OneToOne()
  bestFriend1!: User;

  @OneToOne({ inversedBy: 'bestFriend1' })
  bestFriend2!: User;

  @OneToOne(() => User, user => user.bestFriend2, { owner: true })
  bestFriend3!: User;

}

----------------------------------------

TITLE: Demonstrating Identity Map with Primary Key Lookup in MikroORM
DESCRIPTION: Shows how MikroORM's Identity Map pattern works when fetching entities by primary key, returning the same instance for multiple queries of the same ID.

LANGUAGE: typescript
CODE:
const authorRepository = orm.em.getRepository(Author);
const jon1 = await authorRepository.findOne(1);
const jon2 = await authorRepository.findOne(1);

// identity map in action
console.log(jon1 === jon2); // true

----------------------------------------

TITLE: Type-Safe Entity Finding in MikroORM v4
DESCRIPTION: This snippet shows how to use type-safe entity finding in MikroORM v4 with EntitySchema, allowing correct type inference for loaded properties.

LANGUAGE: typescript
CODE:
const author = await em.findOne(AuthorSchema, { ... }, ['books']);
console.log(author.books.get()); // `get()` is now inferred correctly

----------------------------------------

TITLE: Using Opt Type in MikroORM Entity
DESCRIPTION: Demonstrates the usage of Opt type for optional properties in different ways within an entity.

LANGUAGE: typescript
CODE:
import { Opt, Entity, PrimaryKey, Property } from '@mikro-orm/core';

@Entity()
class User {

  @PrimaryKey()
  id!: number;

  @Property()
  firstName!: string;

  @Property()
  middleName: string & Opt = '';

  @Property()
  lastName!: string;

  @Property({ persist: false })
  get fullName(): Opt<string> {
    return `${this.firstName} ${this.middleName} ${this.lastName}`;
  }

}

----------------------------------------

TITLE: Entity Definition using EntitySchema
DESCRIPTION: Example showing how to define entities programmatically using the EntitySchema helper

LANGUAGE: typescript
CODE:
export interface IBook extends BaseEntity {
  title: string;
  author: Author;
  publisher?: IdentifiedReference<Publisher>;
  tags: Collection<BookTag>;
}

export const Book = new EntitySchema<IBook, BaseEntity>({
  name: 'Book',
  extends: 'BaseEntity',
  properties: {
    title: { type: 'string' },
    author: { reference: 'm:1', entity: 'Author' },
    publisher: { reference: 'm:1', entity: 'Publisher', wrappedReference: true, nullable: true },
    tags: { reference: 'm:n', entity: 'BookTag', fixedOrder: true },
  },
});

----------------------------------------

TITLE: Defining MongoDB Primary Key
DESCRIPTION: Shows how to define a primary key for MongoDB entities using the @PrimaryKey decorator with ObjectID type.

LANGUAGE: typescript
CODE:
@PrimaryKey()
_id: ObjectID;

----------------------------------------

TITLE: Configuring Result Cache in MikroORM EntityManager Find Method
DESCRIPTION: Demonstrates how to use result caching with the EntityManager's find method, including options for custom expiration and cache keys.

LANGUAGE: typescript
CODE:
const res = await em.find(Book, { author: { name: 'Jon Snow' } }, {
  populate: ['author', 'tags'],
  cache: 50, // set expiration to 50ms
  // cache: ['cache-key', 50], // set custom cache key and expiration
  // cache: true, // use default cache key and expiration
});

----------------------------------------

TITLE: Processing Generated Metadata
DESCRIPTION: Example of using onInitialMetadata and onProcessedMetadata hooks to customize generated entities.

LANGUAGE: typescript
CODE:
import { ReferenceKind, MikroORM } from '@mikro-orm/core';

const orm = await MikroORM.init({
  // ORM config
});

await orm.entityGenerator.generate({
  onInitialMetadata: (metadata, platform) => {
    metadata.forEach(meta => {
      meta.props.forEach(prop => {
        if (prop.name === 'password') {
          prop.hidden = true;
          prop.lazy = true;
        }
      });
    });
  },
  onProcessedMetadata: (metadata, platform) => {
    metadata.forEach(meta => {
      meta.props.forEach(prop => {
        if (prop.kind === ReferenceKind.MANY_TO_MANY) {
          prop.hidden = true;
        }
      });
    });
  },
});

----------------------------------------

TITLE: Operator-in-Key Query Syntax
DESCRIPTION: Demonstrates an alternative syntax where operators are included in the key names using colon notation.

LANGUAGE: typescript
CODE:
const res = await orm.em.find(Author, { $and: [
  { 'id:in': [1, 2, 7] },
  { 'id:nin': [3, 4] },
  { 'id:gt': 5 },
  { 'id:lt': 10 },
  { 'id:gte': 7 },
  { 'id:lte': 8 },
  { 'id:ne': 9 },
] });

----------------------------------------

TITLE: Using SqlEntityManager in MikroORM v4
DESCRIPTION: This code shows how to import and use the SqlEntityManager (aliased as EntityManager) from a specific SQL driver package to access the createQueryBuilder() method.

LANGUAGE: typescript
CODE:
import { EntityManager } from '@mikro-orm/mysql'; // or any other SQL driver package

const em: EntityManager;
const qb = await em.createQueryBuilder(...);

----------------------------------------

TITLE: Shortcut for $in Operator in MikroORM (TypeScript)
DESCRIPTION: Shows a shortcut for the $in operator where providing an array as a value is automatically converted to an $in condition.

LANGUAGE: typescript
CODE:
const res = await orm.em.find(Author, { favouriteBook: [1, 2, 7] });

----------------------------------------

TITLE: Fetching Paginated Results in MikroORM
DESCRIPTION: Shows how to use findAndCount method to get paginated results along with the total count of entities.

LANGUAGE: typescript
CODE:
const [authors, count] = await orm.em.findAndCount(Author, { ... }, { limit: 10, offset: 50 });
console.log(authors.length); // based on limit parameter, e.g. 10
console.log(count); // total count, e.g. 1327

----------------------------------------

TITLE: Adding Embedded Entities in MikroORM EntityGenerator
DESCRIPTION: Example of defining and adding an embedded entity (IdentitiesContainer) to the generated metadata using the onInitialMetadata hook.

LANGUAGE: typescript
CODE:
import { ReferenceKind } from '@mikro-orm/core';

await orm.entityGenerator.generate({
  onInitialMetadata: (metadata, platform) => {
    const embeddableEntityMeta = new EntityMetadata({
      className: 'IdentitiesContainer',
      collection: platform.getConfig().getNamingStrategy().classToTableName('IdentitiesContainer'),
      embeddable: true,
    });
    embeddableEntityMeta.addProperty({
      name: 'github',
      type: 'string',
      nullable: true,
      fieldNames: ['github'],
      columnTypes: ['varchar(255)'],
    });
    embeddableEntityMeta.addProperty({
      name: 'local',
      type: 'number',
      nullable: true,
      fieldNames: ['local'],
      columnTypes: ['int'],
    });
    metadata.push(embeddableEntityMeta);

    const identitiesPropOnAuthor = metadata.find(meta => meta.className === 'Author')!.properties.identities;
    identitiesPropOnAuthor.kind = ReferenceKind.EMBEDDED;
    identitiesPropOnAuthor.object = true;
    identitiesPropOnAuthor.type = 'IdentitiesContainer';
  },
});

----------------------------------------

TITLE: Persisting Changes with Unit of Work
DESCRIPTION: Demonstrates how MikroORM automatically tracks and persists changes to managed entities without explicit persist calls.

LANGUAGE: typescript
CODE:
const jon = await em.findOne(Author, 1);
jon.email = 'foo@bar.com';
await em.flush();

----------------------------------------

TITLE: Configuring Entity Discovery
DESCRIPTION: TypeScript code showing how to configure MikroORM for folder-based entity discovery.

LANGUAGE: typescript
CODE:
const orm = await MikroORM.init({
  entities: ['./dist/app/**/*.entity.js'],
  entitiesTs: ['./src/app/**/*.entity.ts'],
  // ...
});

----------------------------------------

TITLE: Populating Existing Entities in MikroORM
DESCRIPTION: Demonstrates how to populate relations on already loaded entities using em.populate().

LANGUAGE: typescript
CODE:
const authors = await em.createQueryBuilder(Author).select('*').getResult();
await em.populate(authors, ['books.tags']);

// now your Author entities will have `books` collections populated,
// as well as they will have their `tags` collections populated.
console.log(authors[0].books[0].tags[0]); // initialized BookTag

----------------------------------------

TITLE: Setting Debugging and Logging Options in MikroORM
DESCRIPTION: Shows how to configure debugging and logging options in MikroORM.

LANGUAGE: typescript
CODE:
MikroORM.init({
  logger: (message: string) => myLogger.info(message),
  debug: true,
  highlight: false,
  highlightTheme: { ... },
});

----------------------------------------

TITLE: Installing Hapi Plugin Dependencies
DESCRIPTION: Installation commands for Hapi-specific AdminJS plugin and its peer dependencies

LANGUAGE: bash
CODE:
$ yarn add @adminjs/hapi
# Peer dependencies
$ yarn add @hapi/boom @hapi/cookie @hapi/hapi @hapi/inert

----------------------------------------

TITLE: Persisting Changes with Unit of Work
DESCRIPTION: Demonstrates how MikroORM automatically tracks and persists changes to managed entities without explicit persist calls.

LANGUAGE: typescript
CODE:
const jon = await em.findOne(Author, 1);
jon.email = 'foo@bar.com';
await em.flush();

----------------------------------------

TITLE: Implementing OneToMany Relationships in MikroORM TypeScript
DESCRIPTION: Shows various ways to define OneToMany relationships using Collections in MikroORM. Includes examples of different syntax options and demonstrates the usage of mappedBy and orphanRemoval options.

LANGUAGE: typescript
CODE:
@Entity()
export class Author {

  @OneToMany(() => Book, book => book.author)
  books1 = new Collection<Book>(this);

  @OneToMany('Book', 'author')
  books2 = new Collection<Book>(this);

  @OneToMany({ mappedBy: book => book.author })
  books3 = new Collection<Book>(this);

  @OneToMany({ entity: () => Book, mappedBy: 'author', orphanRemoval: true })
  books4 = new Collection<Book>(this);

}

----------------------------------------

TITLE: Entity Type Inference Examples
DESCRIPTION: Shows different ways to properly type entities when using find methods, with TypeScript type inference.

LANGUAGE: typescript
CODE:
const author1 = await orm.em.findOne<Author>(Author.name, '...id...');
const author2 = await orm.em.findOne<Author>('Author', '...id...');
const author3 = await orm.em.findOne(Author, '...id...');

----------------------------------------

TITLE: Entity Assignment Using wrap() Helper in MikroORM
DESCRIPTION: Shows how to use the wrap().assign() method to update entity values including references

LANGUAGE: typescript
CODE:
import { wrap } from 'mikro-orm';

wrap(book).assign({
  title: 'Better Book 1',
  author: '...id...',
});
console.log(book.title); // 'Better Book 1'
console.log(book.author); // instance of Author with id: '...id...'
console.log(book.author.id); // '...id...'

----------------------------------------

TITLE: MySQL Table Creation with UnderscoreNamingStrategy
DESCRIPTION: Example of how UnderscoreNamingStrategy transforms entity properties into database table schema with lowercase and underscore-separated naming convention.

LANGUAGE: sql
CODE:
CREATE TABLE `author` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `created_at` datetime(3) DEFAULT NULL,
  `updated_at` datetime(3) DEFAULT NULL,
  `terms_accepted` tinyint(1) DEFAULT NULL,
  `name` varchar(255) DEFAULT NULL,
  `email` varchar(255) DEFAULT NULL,
  `born` datetime DEFAULT NULL,
  `favourite_book_id` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

----------------------------------------

TITLE: Metadata Provider Configuration
DESCRIPTION: Example of configuring a custom metadata provider (TsMorphMetadataProvider) for entity analysis.

LANGUAGE: typescript
CODE:
import { MikroORM } from '@mikro-orm/core';
import { TsMorphMetadataProvider } from '@mikro-orm/reflection';

MikroORM.init({
  metadataProvider: TsMorphMetadataProvider,
});

----------------------------------------

TITLE: Installing Express Plugin for AdminJS
DESCRIPTION: Commands for installing the Express plugin for AdminJS and its peer dependencies.

LANGUAGE: bash
CODE:
$ yarn add @adminjs/express
# Peer dependencies
$ yarn add express express-formidable express-session

----------------------------------------

TITLE: Location Entity with PointType
DESCRIPTION: Entity definition using the custom PointType for storing spatial data.

LANGUAGE: typescript
CODE:
@Entity()
export class Location {

  @PrimaryKey()
  id!: number;

  @Property({ type: PointType })
  point?: Point;

}

----------------------------------------

TITLE: Using Transactions in MikroORM 3
DESCRIPTION: Demonstrates the new transactional API in MikroORM 3, which uses the em.transactional() method to wrap operations in a transaction.

LANGUAGE: typescript
CODE:
await orm.em.transactional(async _em => {
  //... do some work
  const user = new User(...);
  user.name = 'George';
  _em.persistLater(user);
});

----------------------------------------

TITLE: Implicit Transaction Handling
DESCRIPTION: Shows how Unit of Work handles transactions automatically when persisting and flushing changes.

LANGUAGE: typescript
CODE:
const user = await em.findOne(User, 1);
user.email = 'foo@bar.com';
const car = new Car();
user.cars.add(car);

// thanks to bi-directional cascading we only need to persist user entity
// flushing will create a transaction, insert new car and update user with new email
await em.persist(user).flush();

----------------------------------------

TITLE: BaseEntity Extension in MikroORM
DESCRIPTION: Shows how to extend BaseEntity to include helper methods directly in entity classes

LANGUAGE: typescript
CODE:
import { BaseEntity } from '@mikro-orm/core';

@Entity()
export class Book extends BaseEntity<Book, 'id'> { ... }

----------------------------------------

TITLE: Installing MikroORM Database Dependencies
DESCRIPTION: Package installation commands for different database drivers using yarn or npm.

LANGUAGE: sh
CODE:
yarn add @mikro-orm/core @mikro-orm/mongodb     # for mongo
yarn add @mikro-orm/core @mikro-orm/mysql       # for mysql/mariadb
yarn add @mikro-orm/core @mikro-orm/mariadb     # for mysql/mariadb
yarn add @mikro-orm/core @mikro-orm/postgresql  # for postgresql
yarn add @mikro-orm/core @mikro-orm/sqlite      # for sqlite

LANGUAGE: sh
CODE:
npm i -s @mikro-orm/core @mikro-orm/mongodb     # for mongo
npm i -s @mikro-orm/core @mikro-orm/mysql       # for mysql/mariadb
npm i -s @mikro-orm/core @mikro-orm/mariadb     # for mysql/mariadb
npm i -s @mikro-orm/core @mikro-orm/postgresql  # for postgresql
npm i -s @mikro-orm/core @mikro-orm/sqlite      # for sqlite

----------------------------------------

TITLE: Defining Nullable Property in MikroORM
DESCRIPTION: This snippet demonstrates how to define a nullable property in MikroORM using the @Property decorator. The 'nullable' option is set to true, and the property is marked as optional using the '?' syntax.

LANGUAGE: typescript
CODE:
@Property({ nullable: true })
name?: string;

----------------------------------------

TITLE: Initializing Embeddables in MikroORM
DESCRIPTION: Demonstrates how to initialize an embeddable property to avoid null values when all fields are nullable.

LANGUAGE: typescript
CODE:
@Embedded(() => Address)
address = new Address();

----------------------------------------

TITLE: Implementing Custom RedisCacheAdapter in MikroORM (TypeScript)
DESCRIPTION: This snippet demonstrates how to implement a custom cache adapter (RedisCacheAdapter) for MikroORM. The actual implementation is not provided in the code.

LANGUAGE: typescript
CODE:
export class RedisCacheAdapter implements CacheAdapter { ... }

----------------------------------------

TITLE: Optimistic Locking Version Field Definition
DESCRIPTION: Shows how to define version fields for optimistic locking using both number and date types.

LANGUAGE: typescript
CODE:
export class User {
  // ...
  @Property({ version: true })
  version: number;
  // ...
}

LANGUAGE: typescript
CODE:
export class User {
  // ...
  @Property({ version: true })
  version: Date;
  // ...
}

----------------------------------------

TITLE: Entity Definition with @Entity Decorator in TypeScript
DESCRIPTION: Demonstrates basic entity definition using @Entity decorator to mark model classes as entities with optional table name configuration.

LANGUAGE: typescript
CODE:
@Entity({ tableName: 'authors' })
export class Author { ... }

----------------------------------------

TITLE: Executing MikroORM Entity Generation via CLI
DESCRIPTION: CLI commands for generating entities from database schema, with options for dumping to console or saving to filesystem.

LANGUAGE: sh
CODE:
npx mikro-orm generate-entities --dump  # Dumps all generated entities
npx mikro-orm generate-entities --save --path=./my-entities  # Saves entities into given directory

----------------------------------------

TITLE: Defining Optional Properties with Default Values in MikroORM
DESCRIPTION: This snippet illustrates how to define an optional property with a default value in a MikroORM entity. It uses the @Property decorator with the default option.

LANGUAGE: typescript
CODE:
@Property({ default: 1 })
level?: number = 1;

----------------------------------------

TITLE: Using Cache with QueryBuilder
DESCRIPTION: Shows how to enable result caching when using QueryBuilder to construct database queries.

LANGUAGE: typescript
CODE:
const res = await em.createQueryBuilder(Book)
  .where({ author: { name: 'Jon Snow' } })
  .cache()
  .getResultList();

----------------------------------------

TITLE: Setting Driver and Connection Options in MikroORM
DESCRIPTION: Shows how to set the database driver and additional connection options in MikroORM configuration.

LANGUAGE: typescript
CODE:
import { MySqlDriver } from '@mikro-orm/mysql';

MikroORM.init({
  driver: MySqlDriver,
  driverOptions: { connection: { timezone: '+02:00' } },
});

LANGUAGE: typescript
CODE:
MikroORM.init({
  type: 'mysql',
  timezone: '+02:00',
});

----------------------------------------

TITLE: MikroORM Seeder Configuration Options
DESCRIPTION: Complete configuration options for the seeder including paths, naming conventions, and file matching patterns.

LANGUAGE: typescript
CODE:
MikroORM.init({
  seeder: {
    path: './seeders', // path to the folder with seeders
    pathTs: undefined, // path to the folder with TS seeders (if used, we should put path to compiled files in `path`)
    defaultSeeder: 'DatabaseSeeder', // default seeder class name
    glob: '!(*.d).{js,ts}', // how to match seeder files (all .js and .ts files, but not .d.ts)
    emit: 'ts', // seeder generation mode
    fileName: (className: string) => className, // seeder file naming convention
  },
});

----------------------------------------

TITLE: Initializing MikroORM with PostgreSQL
DESCRIPTION: Example of initializing MikroORM with PostgreSQL driver, specifying entities and database name.

LANGUAGE: typescript
CODE:
import { MikroORM } from '@mikro-orm/postgresql'; // or any other SQL driver package

const orm = await MikroORM.init({
  entities: ['./dist/entities'], // path to your JS entities (dist), relative to `baseDir`
  dbName: 'my-db-name',
});
console.log(orm.em); // access EntityManager via `em` property

----------------------------------------

TITLE: Optimistic Locking with Manual Version Check in MikroORM (TypeScript)
DESCRIPTION: Shows how to manually check the version of an entity using the lock method. It demonstrates error handling for version conflicts.

LANGUAGE: typescript
CODE:
const theEntityId = 1;
const expectedVersion = 184;
const entity = await orm.em.findOne(User, theEntityId);

try {
    // assert version
    await orm.em.lock(entity, LockMode.OPTIMISTIC, expectedVersion);
} catch (e) {
    console.log('Sorry, but someone else has already changed this entity. Please apply the changes again!');
}

----------------------------------------

TITLE: Result Mapping Configuration
DESCRIPTION: Shows how to control the mapping of database columns to entity properties when executing queries.

LANGUAGE: typescript
CODE:
const res4 = await orm.em.createQueryBuilder(Book).select('*').execute('get', true);
console.log(res4); // `createdAt` will be defined, while `created_at` will be missing
const res5 = await orm.em.createQueryBuilder(Book).select('*').execute('get', false);
console.log(res5); // `created_at` will be defined, while `createdAt` will be missing

----------------------------------------

TITLE: Implementing Cascade Remove in MikroORM
DESCRIPTION: Example of cascade remove operation and its potential implications with entity relationships.

LANGUAGE: typescript
CODE:
await orm.em.removeEntity(book); // this will also remove book.publisher

----------------------------------------

TITLE: Mapping BigInt Primary Keys to Different Types in MikroORM
DESCRIPTION: This snippet demonstrates how to specify target types for BigInt primary keys in MikroORM, including mapping to bigint, string, and number types. Note that mapping to number type has limitations for very large values.

LANGUAGE: typescript
CODE:
@PrimaryKey({ type: new BigIntType('bigint') })
id1: bigint;

@PrimaryKey({ type: new BigIntType('string') })
id2: string;

@PrimaryKey({ type: new BigIntType('number') })
id3: number;

----------------------------------------

TITLE: Implementing Mapped Superclass Pattern in TypeScript with MikroORM
DESCRIPTION: Demonstrates how to create a mapped superclass for sharing common entity state and mapping information across multiple entity classes. Shows implementation of an abstract Person class and concrete Employee entity with relationship to Toothbrush entity.

LANGUAGE: typescript
CODE:
export abstract class Person {

  @Property()
  mapped1!: number;

  @Property()
  mapped2!: string;

  @OneToOne()
  toothbrush!: Toothbrush;

  // ... more fields and methods
}

@Entity()
export class Employee extends Person {

  @PrimaryKey()
  id!: number;

  @Property()
  name!: string;

  // ... more fields and methods

}

@Entity()
export class Toothbrush {

  @PrimaryKey()
  id!: number;

  // ... more fields and methods

}

----------------------------------------

TITLE: MongoDB Queries for Nested Populate in MikroORM
DESCRIPTION: Illustrates the MongoDB queries executed by MikroORM when performing a nested populate operation. These queries are simpler than SQL equivalents as no pivot tables are involved.

LANGUAGE: typescript
CODE:
db.getCollection("book-tag").find({}).toArray();
db.getCollection("book").find({"tags":{"$in":[...]}}).toArray();
db.getCollection("publisher").find({"_id":{"$in":[...]}}).toArray();
db.getCollection("test").find({"_id":{"$in":[...]}}).toArray();
db.getCollection("author").find({"_id":{"$in":[...]}}).toArray();

----------------------------------------

TITLE: Extending EntityManager in MikroORM 6
DESCRIPTION: This code demonstrates how to extend the EntityManager class with custom methods in MikroORM 6, including type inference and usage.

LANGUAGE: typescript
CODE:
import { MikroORM, EntityManager } from '@mikro-orm/sqlite';

class MyEntityManager extends EntityManager {

  myCustomMethod(base: number): number {
    return base * Math.random();
  }

}

const orm = await MikroORM.init({
  entities: [...],
  dbName: ':memory:',
  entityManager: MyEntityManager,
});
console.log(orm.em instanceof MyEntityManager); // true
const res = orm.em.myCustomMethod(123);

----------------------------------------

TITLE: Entity Creation without Primary Key
DESCRIPTION: Demonstrates automatic flushing behavior when querying for an entity that was created without a primary key.

LANGUAGE: typescript
CODE:
const jon = em.create(Author, {
  name: 'Jon',
  email: 'foo@bar.com',
});

// this will trigger auto flush and insert the entity, then query for it
const jon2 = await em.findOne(Author, 1);
console.log(jon === jon2); // true
await em.flush(); // this is a no-op

----------------------------------------

TITLE: Loading Multiple Authors and Books with Promise.all
DESCRIPTION: Example showing how to efficiently load multiple authors and their related books using dataloaders and Promise.all.

LANGUAGE: typescript
CODE:
const authors = await orm.em.find(Author, [1, 2, 3]);
await Promise.all(authors.map(author => author.books.load({ dataloader: true })));

----------------------------------------

TITLE: Implementing String-based BigInt Primary Key in TypeScript with MikroORM
DESCRIPTION: Basic implementation of a string-based BigInt primary key using MikroORM's BigIntType. This approach stores the bigint value as a string representation.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @PrimaryKey({ type: BigIntType })
  id: string;

}

----------------------------------------

TITLE: Defining Custom Cache Adapter Interface in MikroORM
DESCRIPTION: Specifies the interface for implementing custom cache adapters in MikroORM, including methods for getting, setting, removing, and clearing cache items.

LANGUAGE: typescript
CODE:
export interface CacheAdapter {

  /**
   * Gets the items under `name` key from the cache.
   */
  get(name: string): Promise<any>;

  /**
   * Sets the item to the cache. `origin` is used for cache invalidation and should reflect the change in data.
   */
  set(name: string, data: any, origin: string, expiration?: number): Promise<void>;

  /**
   * Removes the item from cache.
   */
  remove(name: string): Promise<void>;

  /**
   * Clears all items stored in the cache.
   */
  clear(): Promise<void>;

  /**
   * Called inside `MikroORM.close()` Allows graceful shutdowns (e.g. for redis).
   */
  close?(): Promise<void>;

}

----------------------------------------

TITLE: Using EntityAssigner with New Entities in MikroORM v3 (TypeScript)
DESCRIPTION: Demonstrates how to use the assign() method on new (not managed) entities by providing the EntityManager parameter.

LANGUAGE: typescript
CODE:
const book = new Book();
wrap(book).assign(data, { em: orm.em });

----------------------------------------

TITLE: Collection Operators Usage in MikroORM
DESCRIPTION: Examples of using collection operators ($some, $none, $every) for querying related collections.

LANGUAGE: typescript
CODE:
const res1 = await em.find(Author, {
  books: { $some: { title: 'Foo' } },
});

const res2 = await em.find(Author, {
  books: { $none: { title: 'Foo' } },
});

const res3 = await em.find(Author, {
  books: { $every: { title: 'Foo' } },
});

----------------------------------------

TITLE: Implementing Cascade Persist in MikroORM
DESCRIPTION: Example demonstrating cascade persist functionality where changes to related entities are automatically persisted.

LANGUAGE: typescript
CODE:
const book = await orm.em.findOne(Book, 'id', ['author', 'tags']);
book.author.name = 'Foo Bar';
book.tags[0].name = 'new name 1';
book.tags[1].name = 'new name 2';
await orm.em.persistAndFlush(book); // all book tags and author will be persisted too

----------------------------------------

TITLE: Disabling Transactions Globally in MikroORM
DESCRIPTION: Shows how to disable transactions globally in MikroORM using the disableTransactions config option. This can be useful in certain scenarios where transaction management is not needed.

LANGUAGE: typescript
CODE:
// only the outer transaction will be opened
await orm.em.transactional(async em => {
  // but the inner calls to both em.transactional and em.begin will be no-op
  await em.transactional(...);
}, { disableTransactions: true });

----------------------------------------

TITLE: Entity Change Detection and Persistence in MikroORM
DESCRIPTION: Shows how MikroORM tracks and persists changes to managed entities without explicit persist calls.

LANGUAGE: typescript
CODE:
const authorRepository = orm.em.getRepository(Author);
const jon = await authorRepository.findOne(1);
jon.email = 'foo@bar.com';
await authorRepository.flush(); // calling orm.em.flush() has same effect

----------------------------------------

TITLE: Using discriminatorValue for Single Table Inheritance in TypeScript
DESCRIPTION: This snippet shows an alternative approach to Single Table Inheritance using the discriminatorValue option instead of discriminatorMap. It defines Person and Employee classes with explicit discriminator values.

LANGUAGE: typescript
CODE:
@Entity({
  discriminatorColumn: 'discr',
  discriminatorValue: 'person',
})
export class Person {
  // ...
}

@Entity({
  discriminatorValue: 'employee',
})
export class Employee extends Person {
  // ...
}

----------------------------------------

TITLE: Defining Nullable Properties in MikroORM
DESCRIPTION: This snippet demonstrates how to define a nullable property in a MikroORM entity. It shows the use of the @Property decorator with the nullable option set to true.

LANGUAGE: typescript
CODE:
@Property({ nullable: true })
name?: string;

----------------------------------------

TITLE: Generated SQL Schema for Mapped Superclass
DESCRIPTION: Shows the resulting SQL DDL schema generated for the Employee entity that extends the Person mapped superclass.

LANGUAGE: sql
CODE:
create table `employee` (
  `id` int unsigned not null auto_increment primary key,
  `name` varchar(255) not null, `mapped1` integer not null,
  `mapped2` varchar(255) not null,
  `toothbrush_id` integer not null
);

----------------------------------------

TITLE: Configuring Read Replicas in MikroORM TypeScript
DESCRIPTION: Shows how to initialize MikroORM with multiple read replica connections. Demonstrates configuration of master and replica connections with different hosts and users, where unspecified replica properties inherit from the master connection.

LANGUAGE: typescript
CODE:
const orm = await MikroORM.init({
  entities: [Author, ...],
  dbName: `my_database`,
  type: 'mysql',
  user: 'master_user',
  host: 'master_host',
  replicas: [
    { name: 'read-1', host: 'read_host_1', user: 'read_user' },
    { name: 'read-2', host: 'read_host_2' }, // user omitted, will be taken from master connection
  ],
});

----------------------------------------

TITLE: Registering Custom Repository with Entity
DESCRIPTION: Demonstrates how to register a custom repository for an entity using the @Entity decorator.

LANGUAGE: typescript
CODE:
@Entity({ repository: () => CustomAuthorRepository })
export class Author {
  // ...
}

----------------------------------------

TITLE: Schema Generator Interface Updates
DESCRIPTION: Updated interface for SchemaGenerator showing new options parameters

LANGUAGE: typescript
CODE:
interface SchemaGenerator {
  generate(): Promise<string>;
  createSchema(options?: { wrap?: boolean }): Promise<void>;
  ensureDatabase(): Promise<void>;
  getCreateSchemaSQL(options?: { wrap?: boolean }): Promise<string>;
  dropSchema(options?: { wrap?: boolean; dropMigrationsTable?: boolean; dropDb?: boolean }): Promise<void>;
  getDropSchemaSQL(options?: { wrap?: boolean; dropMigrationsTable?: boolean }): Promise<string>;
  updateSchema(options?: { wrap?: boolean; safe?: boolean; dropDb?: boolean; dropTables?: boolean }): Promise<void>;
  getUpdateSchemaSQL(options?: { wrap?: boolean; safe?: boolean; dropDb?: boolean; dropTables?: boolean }): Promise<string>;
  createDatabase(name: string): Promise<void>;
  dropDatabase(name: string): Promise<void>;
  execute(sql: string, options?: { wrap?: boolean }): Promise<void>;
}

----------------------------------------

TITLE: Frontend Optimistic Locking Example in MikroORM (TypeScript)
DESCRIPTION: Demonstrates how to implement optimistic locking on the frontend. It shows fetching an entity with its version, making changes, and sending the version back with the update request.

LANGUAGE: typescript
CODE:
const res = await fetch('api.example.com/book/123');
const book = res.json();
console.log(book.version); // prints the current version

// user does some changes and calls the PUT handler
const changes = { title: 'new title' };
await fetch('api.example.com/book/123', {
  method: 'PUT',
  body: {
    ...changes,
    version: book.version,
  },
});

----------------------------------------

TITLE: Initializing Article Routes with Fastify
DESCRIPTION: Basic setup of article routes using Fastify with MikroORM integration, implementing pagination via findAndCount

LANGUAGE: typescript
CODE:
export async function registerArticleRoutes(app: FastifyInstance) {
  const db = await initORM();

  app.get('/', async request => {
    const { limit, offset } = request.query as { limit?: number; offset?: number };
    const [items, total] = await db.article.findAndCount({}, {
      limit, offset,
    });

    return { items, total };
  });
}

----------------------------------------

TITLE: MikroORM Reference Types Enumeration
DESCRIPTION: Enumeration of available reference types for entity relationships in MikroORM, including scalar, many-to-one, one-to-many, and many-to-many relationships.

LANGUAGE: typescript
CODE:
export enum ReferenceType {
  SCALAR = 'scalar',
  MANY_TO_ONE = 'm:1',
  ONE_TO_MANY = '1:m',
  MANY_TO_MANY = 'm:n',
}

----------------------------------------

TITLE: Configuring Custom Highlighter in MikroORM TypeScript
DESCRIPTION: This code demonstrates how to configure a custom SQL highlighter in MikroORM v4. Highlighting is now disabled by default and requires installing and configuring an optional highlighter package.

LANGUAGE: typescript
CODE:
import { SqlHighlighter } from '@mikro-orm/sql-highlighter';

MikroORM.init({
  highlighter: new SqlHighlighter(),
  // ...
});

----------------------------------------

TITLE: Initializing MikroORM with JavaScript Entities
DESCRIPTION: Example of initializing MikroORM with JavaScript entities, showing how to register entities and configure the database connection.

LANGUAGE: javascript
CODE:
const orm = await MikroORM.init({
  entities: [Author, Book, BookTag, BaseEntity],
  dbName: 'my-db-name',
  type: 'mysql',
});

----------------------------------------

TITLE: Webpack Configuration for MikroORM
DESCRIPTION: Complete Webpack configuration for bundling MikroORM applications with proper entity handling and optimization settings.

LANGUAGE: javascript
CODE:
const path = require('path');
const { EnvironmentPlugin, IgnorePlugin } = require('webpack');
const TerserPlugin = require('terser-webpack-plugin');

const { devDependencies } = require('./package.json');
const externals = {};

for (const devDependency of Object.keys(devDependencies)) {
  externals[devDependency] = `commonjs ${devDependency}`;
}

const optionalModules = new Set([
  ...Object.keys(require('knex/package.json').browser),
  ...Object.keys(require('@mikro-orm/core/package.json').peerDependencies),
  ...Object.keys(require('@mikro-orm/core/package.json').devDependencies || {})
]);

module.exports = {
  entry: path.resolve('app', 'server.ts'),
  mode: 'production',
  optimization: {
    minimizer: [
      new TerserPlugin({
        terserOptions: {
          mangle: false,
          compress: {
            keep_classnames: true,
            keep_fnames: true,
          },
        }
      })
    ]
  },
  target: 'node',
  module: {
    rules: [
      {
        test: /\.ts$/,
        exclude: /node_modules/,
        loader: 'ts-loader',
      },
      {
        test: /\.node$/,
        use: 'node-loader',
      },
      {
        test: /\.mjs$/,
        include: /node_modules/,
        type: 'javascript/auto',
      },
    ],
  },
  externals,
  resolve: {
    extensions: ['.ts', '.js']
  },
  plugins: [
    new EnvironmentPlugin({ WEBPACK: true }),
    new IgnorePlugin({
      checkResource: resource => {
        const baseResource = resource.split('/', resource[0] === '@' ? 2 : 1).join('/');
        if (optionalModules.has(baseResource)) {
          try {
            require.resolve(resource);
            return false;
          } catch {
            return true;
          }
        }
        return false;
      },
    }),
  ],
  output: {
    filename: 'server.js',
    libraryTarget: 'commonjs',
    path: path.resolve(__dirname, '..', 'output'),
  },
};

----------------------------------------

TITLE: Defining Author Entity in JavaScript with MikroORM
DESCRIPTION: Example of defining an Author entity class with MikroORM in JavaScript, including property definitions, constructor, and schema configuration. The entity includes relationships to Book entities and various scalar properties.

LANGUAGE: javascript
CODE:
const { Collection } = require('mikro-orm');
const { Book } = require('./Book');
const { BaseEntity } = require('./BaseEntity');

/**
 * @property {number} id
 * @property {Date} createdAt
 * @property {Date} updatedAt
 * @property {string} name
 * @property {string} email
 * @property {number} age
 * @property {boolean} termsAccepted
 * @property {string[]} identities
 * @property {Date} born
 * @property {Collection<Book>} books
 * @property {Book} favouriteBook
 * @property {number} version
 * @property {string} versionAsString
 */
class Author extends BaseEntity {

  /**
   * @param {string} name
   * @param {string} email
   */
  constructor(name, email) {
    super();
    this.name = name;
    this.email = email;
    this.createdAt = new Date();
    this.updatedAt = new Date();
    this.termsAccepted = false;
  }

}

const schema = {
  name: 'Author',
  extends: 'BaseEntity',
  properties: {
    createdAt: 'Date',
    updatedAt: {
      type: 'Date',
      onUpdate: () => new Date(),
    },
    name: 'string',
    email: 'string',
    age: 'number',
    termsAccepted: 'boolean',
    identities: 'string[]',
    born: 'Date',
    books: {
      reference: '1:m',
      mappedBy: 'author',
      type: 'Book',
    },
    favouriteBook: {
      reference: 'm:1',
      type: 'Book',
    },
  },
  path: __filename,
};

module.exports.Author = Author;
module.exports.entity = Author;
module.exports.schema = schema;

----------------------------------------

TITLE: Using Custom Type in Entity Property Definition
DESCRIPTION: This snippet shows how to use a custom type when defining entity properties in MikroORM. It demonstrates applying the MyDateType to a 'born' property in the FooBar entity.

LANGUAGE: typescript
CODE:
@Entity()
export class FooBar {

  @PrimaryKey()
  id!: number;

  @Property()
  name!: string;

  @Property({ type: MyDateType, length: 3 })
  born?: Date;

}

----------------------------------------

TITLE: Implementing Hidden Properties in MikroORM Entity
DESCRIPTION: Demonstrates how to mark entity properties as hidden using the @Property decorator and HiddenProps symbol to exclude them from serialization results.

LANGUAGE: typescript
CODE:
@Entity()
class Book {

  // we use the `HiddenProps` symbol to define hidden properties on type level
  [HiddenProps]?: 'hiddenField' | 'otherHiddenField';

  @Property({ hidden: true })
  hiddenField = Date.now();

  @Property({ hidden: true, nullable: true })
  otherHiddenField?: string;

}

----------------------------------------

TITLE: Polymorphic Embeddables with Discriminator
DESCRIPTION: Demonstrates how to implement polymorphic embeddables using a discriminator column to determine the concrete type at runtime.

LANGUAGE: typescript
CODE:
import { Embeddable, Embedded, Entity, Enum, PrimaryKey, Property } from '@mikro-orm/core';

export enum AnimalType {
  CAT,
  DOG,
}

@Embeddable({ abstract: true, discriminatorColumn: 'type' })
export abstract class Animal {
  @Enum(() => AnimalType)
  type!: AnimalType;

  @Property()
  name!: string;
}

@Embeddable({ discriminatorValue: AnimalType.CAT })
export class Cat extends Animal {
  @Property({ nullable: true })
  canMeow?: boolean = true;

  constructor(name: string) {
    super();
    this.type = AnimalType.CAT;
    this.name = name;
  }
}

----------------------------------------

TITLE: Defining a Migration Class in TypeScript
DESCRIPTION: Example of creating a Migration class that extends the abstract Migration class. It implements the 'up' method to execute SQL statements for schema changes.

LANGUAGE: typescript
CODE:
export class Migration20191019195930 extends Migration {

  async up(): Promise<void> {
    this.addSql('select 1 + 1');
  }

}

----------------------------------------

TITLE: MongoDB ID Handling and Querying
DESCRIPTION: Demonstrates the duality of ObjectID and string IDs in MikroORM, showing various querying methods using both formats.

LANGUAGE: typescript
CODE:
const author = orm.em.getReference('...id...');
console.log(author.id);  // returns '...id...'
console.log(author._id); // returns ObjectID('...id...')

// all of those will return the same results
const article = '...article id...'; // string id
const book = '...book id...'; // string id
const repo = orm.em.getRepository(Author);
const foo1 = await repo.find({ id: { $in: [article] }, favouriteBook: book });
const bar1 = await repo.find({ id: { $in: [new ObjectID(article)] }, favouriteBook: new ObjectID(book) });
const foo2 = await repo.find({ _id: { $in: [article] }, favouriteBook: book });
const bar2 = await repo.find({ _id: { $in: [new ObjectID(article)] }, favouriteBook: new ObjectID(book) });

----------------------------------------

TITLE: Using Mathematical Symbols for Comparison in MikroORM (TypeScript)
DESCRIPTION: Demonstrates the use of mathematical symbols as shorthand for comparison operators in MikroORM queries.

LANGUAGE: typescript
CODE:
const res = await orm.em.find(Author, { $and: [
  { 'id >': 5 },
  { 'id <': 10 },
  { 'id >=': 7 },
  { 'id <=': 8 },
  { 'id !=': 9 },
] });

----------------------------------------

TITLE: Initializing SchemaGenerator with MikroORM in TypeScript
DESCRIPTION: Shows how to create a script that initializes MikroORM and uses SchemaGenerator to generate database schema from entity metadata. The script connects to the database, generates the schema, and properly closes the connection.

LANGUAGE: typescript
CODE:
import { MikroORM, SchemaGenerator } from 'mikro-orm';

(async () => {
  const orm = await MikroORM.init({
    entities: [Author, Book, ...],
    dbName: 'your-db-name',
    // ...
  });
  const generator = new SchemaGenerator(orm.em.getDriver(), orm.getMetadata());
  const dump = generator.generate();
  console.log(dump);
  await orm.close(true);
})();

----------------------------------------

TITLE: Single Table Inheritance with Discriminator Value
DESCRIPTION: Demonstrates an alternative approach to STI using discriminatorValue instead of discriminatorMap. Shows configuration for both parent and child entities.

LANGUAGE: typescript
CODE:
@Entity({
  discriminatorColumn: 'discr',
  discriminatorValue: 'person',
})
export class Person {
  // ...
}

@Entity({
  discriminatorValue: 'employee',
})
export class Employee extends Person {
  // ...
}

----------------------------------------

TITLE: Partial Loading of Entities in MikroORM
DESCRIPTION: Shows how to partially load entities by selecting specific fields or excluding certain properties.

LANGUAGE: typescript
CODE:
const author = await em.findOne(Author, '...', {
  fields: ['name', 'born'],
});
console.log(author.id); // PK is always selected
console.log(author.name); // Jon Snow
console.log(author.email); // undefined

// Excluding properties
const author = await em.findOne(Author, '...', {
  exclude: ['email', 'books.price'],
  populate: ['books'], // unlike with `fields`, you need to explicitly populate the relation here
});

----------------------------------------

TITLE: Defining BigInt Primary Key in TypeScript with MikroORM
DESCRIPTION: This snippet shows how to define a BigInt primary key in MikroORM v6 and later without specifying an explicit type in the decorator options.

LANGUAGE: typescript
CODE:
@PrimaryKey()
id: bigint;

----------------------------------------

TITLE: Defining Entity Relationships with Reference<T> Wrapper in MikroORM
DESCRIPTION: This code shows how to define entity relationships using the Reference<T> wrapper for better type safety in MikroORM. It includes examples for different metadata providers.

LANGUAGE: typescript
CODE:
import { Entity, IdentifiedReference, ManyToOne, PrimaryKey, Reference } from '@mikro-orm/core';

@Entity()
export class Book {

  @PrimaryKey()
  id!: number;

  @ManyToOne(() => Author, { wrappedReference: true })
  author: IdentifiedReference<Author>;

  constructor(author: Author) {
    this.author = Reference.create(author);
  }

}

----------------------------------------

TITLE: Implementing User Sign-up Route
DESCRIPTION: Shows implementation of user registration endpoint with input validation and error handling

LANGUAGE: typescript
CODE:
export async function registerUserRoutes(app: FastifyInstance) {
  const db = await initORM();

  app.post('/sign-up', async request => {
    const body = request.body as EntityData<User>;

    if (!body.email || !body.fullName || !body.password) {
      throw new Error('One of required fields is missing: email, fullName, password');
    }

    if ((await db.user.count({ email: body.email })) === 0) {
      throw new Error('This email is already registered, maybe you want to sign in?');
    }

    const user = new User(body.fullName, body.email, body.password);
    user.bio = body.bio ?? '';
    await db.em.persist(user).flush();

    console.log(`User ${user.id} created`);

    return user;
  });
}

----------------------------------------

TITLE: Demonstrating Strict Partial Loading in TypeScript with MikroORM 6
DESCRIPTION: This code snippet shows how MikroORM 6 handles strict partial loading of entities, including type inference and compile-time checks for accessed properties.

LANGUAGE: typescript
CODE:
const article = await em.findOneOrFail(Article, 1, { 
  fields: ['title', 'author.email'],
});

const id = article.id; // ok, PK is selected automatically
const title = article.title; // ok, title is selected
const publisher = article.publisher; // fail, not selected
const author = article.author.id; // ok, PK is selected automatically
const email = article.author.email; // ok, selected
const name = article.author.name; // fail, not selected

----------------------------------------

TITLE: Defining BaseEntity Schema
DESCRIPTION: Shows how to define a base entity schema with common properties like id, createdAt, and updatedAt timestamps.

LANGUAGE: typescript
CODE:
export interface BaseEntity {
  id: number;
  createdAt: Date;
  updatedAt: Date;
}

export const schema = new EntitySchema<BaseEntity>({
  name: 'BaseEntity',
  abstract: true,
  properties: {
    id: { type: 'number', primary: true },
    createdAt: { type: 'Date', onCreate: () => new Date(), nullable: true },
    updatedAt: { type: 'Date', onCreate: () => new Date(), onUpdate: () => new Date(), nullable: true },
  },
});

----------------------------------------

TITLE: Cascading Persistence in MikroORM
DESCRIPTION: Shows how to persist multiple related entities with cascading persistence in MikroORM.

LANGUAGE: typescript
CODE:
const author = new Author('Jon Snow', 'snow@wall.st');
author.born = new Date();

const publisher = new Publisher('7K publisher');

const book1 = new Book('My Life on The Wall, part 1', author);
book1.publisher = publisher;
const book2 = new Book('My Life on The Wall, part 2', author);
book2.publisher = publisher;
const book3 = new Book('My Life on The Wall, part 3', author);
book3.publisher = publisher;

// just persist books, author and publisher will be automatically cascade persisted
await em.persist([book1, book2, book3]).flush();

// or one by one
em.persist(book1);
em.persist(book2);
em.persist(book3);
await em.flush(); // flush everything to database at once

----------------------------------------

TITLE: Executing Schema Generation Script
DESCRIPTION: Command line instruction for running the schema generation script using ts-node.

LANGUAGE: bash
CODE:
$ ts-node create-schema

----------------------------------------

TITLE: MikroORM Seeder Configuration Options
DESCRIPTION: Default configuration options for the seeder including paths, naming conventions, and file matching patterns.

LANGUAGE: typescript
CODE:
MikroORM.init({
  seeder: {
    path: './seeders', // path to the folder with seeders
    pathTs: undefined, // path to the folder with TS seeders (if used, we should put path to compiled files in `path`)
    defaultSeeder: 'DatabaseSeeder', // default seeder class name
    glob: '!(*.d).{js,ts}', // how to match seeder files (all .js and .ts files, but not .d.ts)
    emit: 'ts', // seeder generation mode
    fileName: (className: string) => className, // seeder file naming convention
  },
});

----------------------------------------

TITLE: Collection Operator Query Examples
DESCRIPTION: Shows how to use collection operators ($some, $none, $every) for querying related collections.

LANGUAGE: typescript
CODE:
const res1 = await em.find(Author, {
  books: { $some: { title: 'Foo' } },
});

const res2 = await em.find(Author, {
  books: { $none: { title: 'Foo' } },
});

const res3 = await em.find(Author, {
  books: { $every: { title: 'Foo' } },
});

----------------------------------------

TITLE: Collection Operator Query Examples
DESCRIPTION: Shows how to use collection operators ($some, $none, $every) for querying related collections.

LANGUAGE: typescript
CODE:
const res1 = await em.find(Author, {
  books: { $some: { title: 'Foo' } },
});

const res2 = await em.find(Author, {
  books: { $none: { title: 'Foo' } },
});

const res3 = await em.find(Author, {
  books: { $every: { title: 'Foo' } },
});

----------------------------------------

TITLE: Configuring Seeder Paths for Production in MikroORM
DESCRIPTION: Demonstrates how to configure seeder paths for both development and production environments.

LANGUAGE: typescript
CODE:
import { MikroORM, Utils } from '@mikro-orm/core';

await MikroORM.init({
  seeder: {
    path: 'dist/seeders',
    pathTs: 'src/seeders',
  },
  // or alternatively
  // seeder: {
  //   path: Utils.detectTsNode() ? 'src/seeders' : 'dist/seeders',
  // },
  // ...
});

----------------------------------------

TITLE: Using Built-in Types in MikroORM
DESCRIPTION: This snippet demonstrates how to use built-in types provided by MikroORM, such as BigIntType. It shows how to import and apply these types to entity properties.

LANGUAGE: typescript
CODE:
import { Property, types } from '@mikro-orm/core';

@Property({ type: types.bigint, nullable: true })
largeNumber?: string; // bigints are mapped to strings so we don't loose precision

----------------------------------------

TITLE: Basic QueryBuilder Usage with Update Query
DESCRIPTION: Demonstrates basic usage of QueryBuilder to construct and execute an update query with where conditions.

LANGUAGE: typescript
CODE:
const qb = em.createQueryBuilder(Author);
qb.update({ name: 'test 123', type: PublisherType.GLOBAL }).where({ id: 123, type: PublisherType.LOCAL });

console.log(qb.getQuery());
// update `publisher2` set `name` = ?, `type` = ? where `id` = ? and `type` = ?

console.log(qb.getParams());
// ['test 123', PublisherType.GLOBAL, 123, PublisherType.LOCAL]

// run the query
const res1 = await qb.execute();

----------------------------------------

TITLE: Running Entity Generation Script with ts-node in MikroORM
DESCRIPTION: Command to execute the TypeScript entity generation script using ts-node. This allows running the script without compiling it to JavaScript first.

LANGUAGE: sh
CODE:
$ ts-node generate-entities

----------------------------------------

TITLE: Initializing MikroORM with SQL Database
DESCRIPTION: Configuration example for initializing MikroORM with different SQL database types. Requires appropriate database driver dependency to be installed.

LANGUAGE: typescript
CODE:
const orm = await MikroORM.init({
  entitiesDirs: ['entities'], // relative to `baseDir`
  dbName: 'my-db-name',
  type: 'mysql', // or 'sqlite' or 'postgresql' or 'mariadb'
});

----------------------------------------

TITLE: Polymorphic Embeddables with Animal Types
DESCRIPTION: Illustrates implementation of polymorphic embeddables using animal types with discriminator columns.

LANGUAGE: typescript
CODE:
import { Embeddable, Embedded, Entity, Enum, PrimaryKey, Property } from '@mikro-orm/core';

export enum AnimalType {
  CAT,
  DOG,
}

@Embeddable({ abstract: true, discriminatorColumn: 'type' })
export abstract class Animal {

  @Enum(() => AnimalType)
  type!: AnimalType;

  @Property()
  name!: string;

}

@Embeddable({ discriminatorValue: AnimalType.CAT })
export class Cat extends Animal {

  @Property({ nullable: true })
  canMeow?: boolean = true;

  constructor(name: string) {
    super();
    this.type = AnimalType.CAT;
    this.name = name;
  }

}

@Embeddable({ discriminatorValue: AnimalType.DOG })
export class Dog extends Animal {

  @Property({ nullable: true })
  canBark?: boolean = true;

  constructor(name: string) {
    super();
    this.type = AnimalType.DOG;
    this.name = name;
  }

}

----------------------------------------

TITLE: Implementing SQL Highlighter in MikroORM
DESCRIPTION: Configuration for adding SQL query highlighting using the optional SQL highlighter package

LANGUAGE: typescript
CODE:
import { SqlHighlighter } from '@mikro-orm/sql-highlighter';

MikroORM.init({
  highlighter: new SqlHighlighter(),
  // ...
});

----------------------------------------

TITLE: Accessing and Manipulating Collections in MikroORM
DESCRIPTION: Demonstrates how to access, iterate, and manipulate OneToMany and ManyToMany collections in MikroORM. It shows collection initialization, item access, adding/removing items, and checking collection state.

LANGUAGE: typescript
CODE:
const author = orm.em.findOne(Author, '...', ['books']); // populating books collection

// or we could lazy load books collection later via `init()` method
await author.books.init();

for (const book of author.books) {
  console.log(book.title); // initialized
  console.log(book.author.isInitialized()); // true
  console.log(book.author.id);
  console.log(book.author.name); // Jon Snow
  console.log(book.publisher); // just reference
  console.log(book.publisher.isInitialized()); // false
  console.log(book.publisher.id);
  console.log(book.publisher.name); // undefined
}

// collection needs to be initialized before you can work with it
author.books.add(book);
console.log(author.books.contains(book)); // true
author.books.remove(book);
console.log(author.books.contains(book)); // false
author.books.add(book);
console.log(author.books.count()); // 1
author.books.removeAll();
console.log(author.books.contains(book)); // false
console.log(author.books.count()); // 0
console.log(author.books.getItems()); // Book[]
console.log(author.books.getIdentifiers()); // array of string | number
console.log(author.books.getIdentifiers('_id')); // array of ObjectID

// array access works as well
console.log(author.books[1]); // Book
console.log(author.books[12345]); // undefined, even if the collection is not initialized

----------------------------------------

TITLE: Ignoring Specific Deprecation Warnings in MikroORM (TypeScript)
DESCRIPTION: This example demonstrates how to ignore specific deprecation warnings in MikroORM by listing their labels in the ignoreDeprecations array.

LANGUAGE: typescript
CODE:
return MikroORM.init({
  ignoreDeprecations: ['D0001'], // ignore deprecation with label "D0001", but show others if they pop up
});

----------------------------------------

TITLE: Implementing Custom Entity Serialization
DESCRIPTION: Example of custom toJSON implementation in a Book entity that allows stripping specific properties during serialization.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  // ...

  toJSON(strict = true, strip = ['id', 'email'], ...args: any[]): { [p: string]: any } {
    const o = this.toObject(...args); // do not forget to pass rest params here

    if (strict) {
      strip.forEach(k => delete o[k]);
    }

    return o;
  }

}

----------------------------------------

TITLE: Defining SQL Virtual Entity with String Expression in TypeScript
DESCRIPTION: Creates a virtual entity that maps a complex SQL query joining books, authors and tags tables. The entity includes title, author name and concatenated tags properties.

LANGUAGE: typescript
CODE:
@Entity({
  expression: `
    select b.title, a.name as author_name,
    (
      select group_concat(distinct t.name)
      from book b 
      join tags_ordered bt on bt.book_id = b.id
      join book_tag t on t.id = bt.book_tag_id
      where b.author_id = a.id
      group by b.author_id
    ) as tags
    from author a
    group by a.id
  `
})
export class BookWithAuthor {

  @Property()
  title!: string;

  @Property()
  authorName!: string;

  @Property()
  tags!: string[];

}

----------------------------------------

TITLE: Using Custom AsyncLocalStorage with MikroORM in TypeScript
DESCRIPTION: This snippet shows how to use a custom AsyncLocalStorage instance with MikroORM. It demonstrates setting up the ORM with a custom context and using it in middleware.

LANGUAGE: typescript
CODE:
const storage = new AsyncLocalStorage<EntityManager>();

const orm = await MikroORM.init({
  context: () => storage.getStore(),
  // ...
});

app.use((req, res, next) => {
  storage.run(orm.em.fork({ useContext: true }), next);
});

----------------------------------------

TITLE: Installing Hapi Plugin for AdminJS
DESCRIPTION: Commands for installing the Hapi plugin for AdminJS and its peer dependencies using yarn.

LANGUAGE: bash
CODE:
$ yarn add @adminjs/hapi
# Peer dependencies
$ yarn add @hapi/boom @hapi/cookie @hapi/hapi @hapi/inert

----------------------------------------

TITLE: Optimistic Locking with Integer Version in MikroORM (TypeScript)
DESCRIPTION: Demonstrates how to implement optimistic locking using an integer version field in a User entity. The @Property decorator is used with the version option set to true.

LANGUAGE: typescript
CODE:
export class User {
  // ...
  @Property({ version: true })
  version!: number;
  // ...
}

----------------------------------------

TITLE: Creating Entity Instances with EntityManager
DESCRIPTION: Shows how to create new entity instances using EntityManager's create method

LANGUAGE: typescript
CODE:
const author = em.create<Author>('Author', { name: 'name', email: 'email' });
await em.flush();

----------------------------------------

TITLE: Optimistic Locking Entity Definition
DESCRIPTION: Demonstrates how to define version-controlled entities for optimistic locking using property decorators.

LANGUAGE: typescript
CODE:
export class User {
  // ...
  @Property({ version: true })
  version: number;
  // ...
}

LANGUAGE: typescript
CODE:
export class Book {
  // ...
  @Property({ version: true })
  version: Date;
  // ...
}

----------------------------------------

TITLE: Setting Foreign Key by Raw ID in MikroORM
DESCRIPTION: This snippet illustrates three different ways to set a foreign key using a raw ID in MikroORM: using references, the assign helper, and the create helper.

LANGUAGE: typescript
CODE:
const b = new Book();
b.author = em.getReference(Author, 1);

const b = new Book();
em.assign(b, { author: 1 });

const b = em.create(Book, { author: 1 });

----------------------------------------

TITLE: Using Hidden Type in MikroORM Entity
DESCRIPTION: Shows alternative approaches to marking properties as hidden using the Hidden type with generics or intersections.

LANGUAGE: typescript
CODE:
@Entity()
class Book {

  @Property({ hidden: true })
  hiddenField: Hidden<Date> = Date.now();

  @Property({ hidden: true, nullable: true })
  otherHiddenField?: string & Hidden;

}

----------------------------------------

TITLE: Installing MikroORM with Database Drivers using Yarn
DESCRIPTION: Commands for installing MikroORM and its database drivers (MongoDB, MySQL, PostgreSQL, SQLite) using Yarn package manager.

LANGUAGE: bash
CODE:
$ yarn add mikro-orm mongodb # for mongo
$ yarn add mikro-orm mysql2  # for mysql
$ yarn add mikro-orm pg      # for postgresql
$ yarn add mikro-orm sqlite  # for sqlite

----------------------------------------

TITLE: Defining SQL Virtual Entity with Query Builder in TypeScript
DESCRIPTION: Implements a virtual entity using a callback function that returns a QueryBuilder expression. The callback provides more programmatic control over the query construction, joining books with authors and tags using the EntityManager.

LANGUAGE: typescript
CODE:
@Entity({
  expression: (em: EntityManager) => {
    return em.createQueryBuilder(Book, 'b')
      .select(['b.title', 'a.name as author_name', 'group_concat(t.name) as tags'])
      .join('b.author', 'a')
      .join('b.tags', 't')
      .groupBy('b.id');
  },
})
export class BookWithAuthor {

  @Property()
  title!: string;

  @Property()
  authorName!: string;

  @Property()
  tags!: string[];

}

----------------------------------------

TITLE: Custom Cache Adapter Interface in MikroORM
DESCRIPTION: Defines the interface that must be implemented by custom cache adapters, including methods for getting, setting, removing, and clearing cached items.

LANGUAGE: typescript
CODE:
export interface CacheAdapter {

  /**
   * Gets the items under `name` key from the cache.
   */
  get(name: string): Promise<any>;

  /**
   * Sets the item to the cache. `origin` is used for cache invalidation and should reflect the change in data.
   */
  set(name: string, data: any, origin: string, expiration?: number): Promise<void>;

  /**
   * Removes the item from cache.
   */
  remove(name: string): Promise<void>;

  /**
   * Clears all items stored in the cache.
   */
  clear(): Promise<void>;

  /**
   * Called inside `MikroORM.close()` Allows graceful shutdowns (e.g. for redis).
   */
  close?(): Promise<void>;

}

----------------------------------------

TITLE: Using rel() Helper for Entity References
DESCRIPTION: Demonstrates how to use the rel() helper to convert primary keys to entity references in constructors.

LANGUAGE: typescript
CODE:
@ManyToOne({ entity: () => Author })
author: Rel<Author>;

constructor(dto: { title: string; author: number }) {
  this.title = dto.title;
  this.author = rel(Author, dto.author);
}

----------------------------------------

TITLE: Implementing Custom Connection Class in TypeScript for MikroORM
DESCRIPTION: Connection class that handles database connectivity and query execution. Implements methods for connecting, disconnecting, and executing queries.

LANGUAGE: typescript
CODE:
import { Connection } from 'mikro-orm';

export class MyCustomConnection extends Connection {

  // implement abstract methods
  connect(): Promise<void>;
  isConnected(): Promise<boolean>;
  close(force?: boolean): Promise<void>;
  getDefaultClientUrl(): string;
  execute(query: string, params?: any[], method?: 'all' | 'get' | 'run'): Promise<QueryResult | any | any[]>;

}

----------------------------------------

TITLE: Defining Entities with Relationships in MikroORM (TypeScript)
DESCRIPTION: This snippet demonstrates how to define Author and Book entities with a one-to-many relationship using MikroORM decorators.

LANGUAGE: typescript
CODE:
import { Entity, LoadStrategy, OneToMany, ManyToOne, PrimaryKey } from '@mikro-orm/core';

@Entity()
export class Author {

  @PrimaryKey()
  id!: number;

  @OneToMany(() => Book, b => b.author)
  books = new Collection<Book>(this);

}

@Entity()
export class Book {

  @PrimaryKey()
  id!: number;

  @ManyToOne()
  author: Author;

}

----------------------------------------

TITLE: Specifying Logger Namespaces in MikroORM (TypeScript)
DESCRIPTION: This example demonstrates how to specify specific logger namespaces in MikroORM. In this case, only queries will be logged.

LANGUAGE: typescript
CODE:
return MikroORM.init({
  debug: ['query'], // now only queries will be logged
});

----------------------------------------

TITLE: Destructuring Populate Result in mikroorm v5 TypeScript
DESCRIPTION: This snippet demonstrates how to use destructuring to handle the new behavior of em.populate() in mikroorm v5, which now always returns an array of entities even for single entity inputs.

LANGUAGE: typescript
CODE:
const [loadedAuthor] = await em.populate(author, ...);

----------------------------------------

TITLE: Explicit Transaction Management in MikroORM
DESCRIPTION: Shows how to explicitly control transaction boundaries using the transactional API. This approach is required for custom DBAL operations or specific EntityManager API methods.

LANGUAGE: typescript
CODE:
await orm.em.transactional(_em => {
  //... do some work
  const user = new User(...);
  user.name = 'George';
  _em.persistLater(user);
});

----------------------------------------

TITLE: Configuring JWT Authentication
DESCRIPTION: Setup of JWT authentication plugin and request hooks for user validation

LANGUAGE: typescript
CODE:
app.register(fastifyJWT, {
  secret: process.env.JWT_SECRET ?? '12345678'
});

app.addHook('onRequest', async request => {
  try {
    const ret = await request.jwtVerify<{ id: number }>();
    request.user = await db.user.findOneOrFail(ret.id);
  } catch (e) {
    app.log.error(e);
  }
});

----------------------------------------

TITLE: Nested Embeddables Configuration
DESCRIPTION: Shows how to implement nested embeddables with Profile and Identity classes embedded within a User entity.

LANGUAGE: typescript
CODE:
import { Embeddable, Embedded, Entity, PrimaryKey, Property } from '@mikro-orm/core';

@Entity()
export class User {

  @PrimaryKey()
  id!: number;

  @Property()
  name!: string;

  @Embedded(() => Profile, { object: true, nullable: true })
  profile?: Profile;

}

@Embeddable()
export class Profile {

  @Property()
  username: string;

  @Embedded(() => Identity)
  identity: Identity;

  constructor(username: string, identity: Identity) {
    this.username = username;
    this.identity = identity;
  }

}

@Embeddable()
export class Identity {

  @Property()
  email: string;

  constructor(email: string) {
    this.email = email;
  }

}

----------------------------------------

TITLE: Implementing Cascade Merge in MikroORM
DESCRIPTION: Example showing cascade merge usage when handling large data imports while maintaining entity relationships and preventing duplicate inserts.

LANGUAGE: typescript
CODE:
const a1 = new Author(...);
a1.favouriteBook = new Book('the best', ...);
await orm.em.persistAndFlush(a1); // cascade persists favourite book as well

for (let i = 1; i < 1000; i++) {
  const book = new Book('...', a1);
  orm.em.persistLater(book);

  // persist every 100 records
  if (i % 100 === 0) {
    await orm.em.flush();
    orm.em.clear(); // this makes both a1 and his favourite book detached
    orm.em.merge(a1); // so we need to merge them to prevent cascade-inserts

    // without cascade merge, you would need to manually merge all his associations
    orm.em.merge(a1.favouriteBook); // not needed with Cascade.MERGE
  }
}

await orm.em.flush();

----------------------------------------

TITLE: Installing MikroORM with NestJS Dependencies
DESCRIPTION: Commands for installing MikroORM, nestjs-mikro-orm module, and database-specific drivers using either yarn or npm package managers.

LANGUAGE: bash
CODE:
$ yarn add mikro-orm nestjs-mikro-orm mongodb # for mongo
$ yarn add mikro-orm nestjs-mikro-orm mysql2  # for mysql
$ yarn add mikro-orm nestjs-mikro-orm pg      # for postgre
$ yarn add mikro-orm nestjs-mikro-orm sqlite  # for sqlite

LANGUAGE: bash
CODE:
$ npm i -s mikro-orm nestjs-mikro-orm mongodb # for mongo
$ npm i -s mikro-orm nestjs-mikro-orm mysql2  # for mysql
$ npm i -s mikro-orm nestjs-mikro-orm pg      # for postgre
$ npm i -s mikro-orm nestjs-mikro-orm sqlite  # for sqlite

----------------------------------------

TITLE: Configuring MikroORM Feature Module in NestJS
DESCRIPTION: Example of setting up a feature module with MikroORM entity repositories using forFeature() method. Shows integration with service and controller components.

LANGUAGE: typescript
CODE:
@Module({
  imports: [MikroOrmModule.forFeature([Photo])],
  providers: [PhotoService],
  controllers: [PhotoController],
})
export class PhotoModule {}

----------------------------------------

TITLE: SQL Queries for Populating Nested Relations in MikroORM
DESCRIPTION: This snippet shows the SQL queries generated by MikroORM when populating nested relations for SQL drivers with pivot tables. It includes queries for BookTags, Books, Publishers, Tests, and Authors.

LANGUAGE: sql
CODE:
SELECT `e0`.* FROM `book_tag` AS `e0`;

SELECT `e0`.*, `e1`.`book_id`, `e1`.`book_tag_id`
  FROM `book` AS `e0` LEFT JOIN `book_to_book_tag` AS `e1` ON `e0`.`id` = `e1`.`book_id`
  WHERE `e1`.`book_tag_id` IN (?, ?, ?, ?, ?)
  ORDER BY `e1`.`id` ASC;

SELECT `e0`.* FROM `publisher` AS `e0` WHERE `e0`.`id` IN (?, ?, ?);

SELECT `e0`.*, `e1`.`test_id`, `e1`.`publisher_id`
  FROM `test` AS `e0` LEFT JOIN `publisher_to_test` AS `e1` ON `e0`.`id` = `e1`.`test_id`
  WHERE `e1`.`publisher_id` IN (?, ?, ?)
  ORDER BY `e1`.`id` ASC;

SELECT `e0`.* FROM `author` AS `e0` WHERE `e0`.`id` IN (?);

----------------------------------------

TITLE: Creating DELETE ChangeSet in onFlush Event in TypeScript
DESCRIPTION: Example of how to create a DELETE changeset within an onFlush event subscriber. This snippet demonstrates using the second parameter of uow.computeChangeSet() to specify a delete operation.

LANGUAGE: typescript
CODE:
async onFlush(args: FlushEventArgs): Promise<void> {
  const changeSets = args.uow.getChangeSets();
  const cs = changeSets.find(cs => cs.type === ChangeSetType.UPDATE && cs.entity instanceof FooBar);

  if (cs) {
    args.uow.computeChangeSet(cs.entity, ChangeSetType.DELETE);
  }
}

----------------------------------------

TITLE: Manual Transaction Control with Begin/Commit/Rollback
DESCRIPTION: Demonstrates explicit transaction management using begin, commit, and rollback methods with proper error handling.

LANGUAGE: typescript
CODE:
const em = orm.em.fork();
await em.begin();

try {
  //... do some work
  const user = new User(...);
  user.name = 'George';
  em.persist(user);
  await em.commit(); // will flush before making the actual commit query
} catch (e) {
  await em.rollback();
  throw e;
}

----------------------------------------

TITLE: Querying Entities by Non-Primary Key in MikroORM with TypeScript
DESCRIPTION: This example demonstrates that querying entities by properties other than the primary key still utilizes the identity map, but requires separate database calls. It shows that the same reference is returned for identical queries.

LANGUAGE: typescript
CODE:
const authorRepository = orm.em.getRepository(Author);
const jon1 = await authorRepository.findOne({ name: 'Jon Snow' });
const jon2 = await authorRepository.findOne({ name: 'Jon Snow' });

// identity map in action
console.log(jon1 === jon2); // true

----------------------------------------

TITLE: Destructuring Populated Entity in MikroORM v5
DESCRIPTION: Example of how to handle the change in em.populate() return type, which now always returns an array of entities. This shows how to destructure the result to get a single entity.

LANGUAGE: typescript
CODE:
const [loadedAuthor] = await em.populate(author, ...);

----------------------------------------

TITLE: Configuring ManyToMany Relationships in MikroORM with TypeScript
DESCRIPTION: Explains how to set up unidirectional and bidirectional ManyToMany relationships in MikroORM using TypeScript. Covers both owning and inverse sides of the relationship and different ways to specify the relationship configuration.

LANGUAGE: typescript
CODE:
@ManyToMany(() => Book)
books1 = new Collection<Book>(this);

// or mark it as owner explicitly via options object
@ManyToMany({ entity: () => Book, owner: true })
books2 = new Collection<Book>(this);

@ManyToMany(() => BookTag, tag => tag.books, { owner: true })
tags = new Collection<BookTag>(this);

// or via options object
@ManyToMany({ entity: () => BookTag, inversedBy: 'books' })
tags = new Collection<BookTag>(this);

@ManyToMany(() => Book, book => book.tags)
books = new Collection<Book>(this);

// or via options object
@ManyToMany({ entity: () => Book, mappedBy: 'tags' })
books = new Collection<Book>(this);

----------------------------------------

TITLE: Configuring JWT Authentication
DESCRIPTION: Setup of JWT authentication plugin and request hooks for user validation

LANGUAGE: typescript
CODE:
app.register(fastifyJWT, {
  secret: process.env.JWT_SECRET ?? '12345678'
});

app.addHook('onRequest', async request => {
  try {
    const ret = await request.jwtVerify<{ id: number }>();
    request.user = await db.user.findOneOrFail(ret.id);
  } catch (e) {
    app.log.error(e);
  }
});

----------------------------------------

TITLE: Clearing Identity Map Cache in MikroORM with TypeScript
DESCRIPTION: This snippet demonstrates how to clear the identity map cache in MikroORM using the EntityManager's clear() method.

LANGUAGE: typescript
CODE:
orm.em.clear();

----------------------------------------

TITLE: Join Table with Metadata Using Composite Keys in MikroORM
DESCRIPTION: Implementation of a complex order-product relationship using composite keys with additional metadata in the join table.

LANGUAGE: typescript
CODE:
@Entity()
export class OrderItem {

  @ManyToOne({ primary: true })
  order: Order;

  @ManyToOne({ primary: true })
  product: Product;

  @Property()
  amount = 1;

  @Property()
  offeredPrice: number;

  [PrimaryKeyType]: [number, number];

  constructor(order: Order, product: Product, amount = 1) {
    this.order = order;
    this.product = product;
    this.offeredPrice = product.currentPrice;
  }

}

----------------------------------------

TITLE: Aliasing Raw SQL Fragments in MikroORM Queries (TypeScript)
DESCRIPTION: Demonstrates how to alias a raw SQL fragment when selecting it in a MikroORM query using the .as() method.

LANGUAGE: typescript
CODE:
sql`(select 1 + 1)`.as('<alias>')

----------------------------------------

TITLE: Defining Article Entity with Relations
DESCRIPTION: Shows how to create an Article entity with various property types and a ManyToOne relationship to User.

LANGUAGE: typescript
CODE:
import { Entity, ManyToOne, Property, t } from '@mikro-orm/core';
import { BaseEntity } from '../common/base.entity.js';
import { User } from '../user/user.entity.js';

@Entity()
export class Article extends BaseEntity {

  @Property({ unique: true })
  slug!: string;

  @Property({ index: true })
  title!: string;

  @Property({ length: 1000 })
  description!: string;

  @Property({ type: t.text, lazy: true })
  text!: string;

  @ManyToOne()
  author!: User;

}

----------------------------------------

TITLE: Using EntityManager in Migrations
DESCRIPTION: Example showing how to use EntityManager within migrations to modify data, though this approach is discouraged.

LANGUAGE: typescript
CODE:
import { Migration } from '@mikro-orm/migrations';
import { User } from '../entities/User';

export class Migration20191019195930 extends Migration {

  async up(): Promise<void> {
    const em = this.getEntityManager();
    em.create(User, { ... });
    await em.flush();
  }

}

----------------------------------------

TITLE: Creating Typed Index on JSON Property in MySQL with MikroORM
DESCRIPTION: This example shows how to create a typed index on a JSON property in MySQL using MikroORM. It demonstrates the use of the 'options' parameter in the @Index decorator to specify the return type of the JSON value.

LANGUAGE: typescript
CODE:
@Entity()
@Index({ properties: 'metaData.foo', options: { returning: 'char(200)' } })
export class Book {

  @Property({ type: 'json', nullable: true })
  metaData?: { foo: string; bar: number };

}

----------------------------------------

TITLE: Implementing Custom Platform Class in TypeScript
DESCRIPTION: Platform class implementation that defines database feature support and configuration. This class provides information about available features and handles primary key operations.

LANGUAGE: typescript
CODE:
import { Platform } from 'mikro-orm';

export class MyCustomPlatform extends Platform {

  protected readonly schemaHelper: MyCustomSchemaHelper;

  // here you can override default settings
  usesPivotTable(): boolean;
  supportsTransactions(): boolean;
  supportsSavePoints(): boolean;
  getNamingStrategy(): { new (): NamingStrategy; };
  getIdentifierQuoteCharacter(): string;
  getParameterPlaceholder(index?: number): string;
  usesReturningStatement(): boolean;
  normalizePrimaryKey<T = number | string>(data: IPrimaryKey): T;
  denormalizePrimaryKey(data: IPrimaryKey): IPrimaryKey;
  getSerializedPrimaryKeyField(field: string): string;

}

----------------------------------------

TITLE: Defining a Book Entity with Constructor in TypeScript for MikroORM
DESCRIPTION: This code snippet demonstrates how to define a Book entity using TypeScript decorators for MikroORM. The entity includes properties for id, title, author, publisher, and tags. The constructor requires title and author parameters, making them mandatory when creating a new Book instance.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @PrimaryKey()
  id!: number;

  @Property()
  title!: string;

  @ManyToOne()
  author!: Author;

  @ManyToOne()
  publisher?: Publisher;

  @ManyToMany({ entity: () => BookTag, inversedBy: 'books' })
  tags = new Collection<BookTag>(this);

  constructor(title: string, author: Author) {
    this.title = title;
    this.author = author;
  }

}

----------------------------------------

TITLE: Using EntityManager Fork with Default Schema
DESCRIPTION: Shows how to use EntityManager's fork method to set a default schema for operations and compare it with direct schema specification.

LANGUAGE: typescript
CODE:
const fork = em.fork({ schema: 'client-123' });
await fork.findOne(User, { ... });

// Will yield the same result as
const user = await em.findOne(User, { ... }, { schema: 'client-123' });

----------------------------------------

TITLE: Using RequestContext Middleware in Express with MikroORM and TypeScript
DESCRIPTION: This snippet demonstrates how to use the RequestContext helper as middleware in an Express application. It creates a new request context for each incoming request, ensuring proper isolation of the Entity Manager.

LANGUAGE: typescript
CODE:
app.use((req, res, next) => {
  // calls `orm.em.fork()` and attaches it to the async context
  RequestContext.create(orm.em, next);
});

app.get('/', async (req, res) => {
  // uses fork from the async context automatically
  const authors = await orm.em.find(Book, {});
  res.json(authors);
});

----------------------------------------

TITLE: Webpack Configuration for MikroORM
DESCRIPTION: Complete Webpack configuration for bundling MikroORM applications

LANGUAGE: javascript
CODE:
const path = require('path');
const { EnvironmentPlugin, IgnorePlugin } = require('webpack');
const TerserPlugin = require('terser-webpack-plugin');

const { devDependencies } = require('./package.json');
const externals = {};

for (const devDependency of Object.keys(devDependencies)) {
  externals[devDependency] = `commonjs ${devDependency}`;
}

const optionalModules = new Set([
  ...Object.keys(require('knex/package.json').browser),
  ...Object.keys(require('@mikro-orm/core/package.json').peerDependencies),
  ...Object.keys(require('@mikro-orm/core/package.json').devDependencies || {})
]);

module.exports = {
  entry: path.resolve('app', 'server.ts'),
  mode: 'production',
  optimization: {
    minimizer: [
      new TerserPlugin({
        terserOptions: {
          mangle: false,
          compress: {
            keep_classnames: true,
            keep_fnames: true,
          },
        }
      })
    ]
  },
  target: 'node',
  module: {
    rules: [
      {
        test: /\.ts$/,
        exclude: /node_modules/,
        loader: 'ts-loader',
      },
      {
        test: /\.node$/,
        use: 'node-loader',
      },
      {
        test: /\.mjs$/,
        include: /node_modules/,
        type: 'javascript/auto',
      },
    ],
  },
  externals,
  resolve: {
    extensions: ['.ts', '.js']
  },
  plugins: [
    new EnvironmentPlugin({ WEBPACK: true }),
    new IgnorePlugin({
      checkResource: resource => {
        const baseResource = resource.split('/', resource[0] === '@' ? 2 : 1).join('/');
        if (optionalModules.has(baseResource)) {
          try {
            require.resolve(resource);
            return false;
          } catch {
            return true;
          }
        }
        return false;
      },
    }),
  ],
  output: {
    filename: 'server.js',
    libraryTarget: 'commonjs',
    path: path.resolve(__dirname, '..', 'output'),
  },
};

----------------------------------------

TITLE: Registering a Custom Repository for an Entity in TypeScript with MikroORM
DESCRIPTION: Demonstrates how to register a custom repository for an entity using the @Entity decorator. This associates the custom repository with the specific entity type.

LANGUAGE: typescript
CODE:
@Entity({ repository: () => CustomAuthorRepository })
export class Author {
  // ...
}

----------------------------------------

TITLE: Defining OneToMany Collections in TypeScript with MikroORM
DESCRIPTION: Shows how to define OneToMany collections in MikroORM using TypeScript decorators. It demonstrates both the inline lambda syntax and the options object syntax.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @PrimaryKey()
  _id!: ObjectId;

  @ManyToOne()
  author!: Author;

}

@Entity()
export class Author {

  @PrimaryKey()
  _id!: ObjectId;

  @OneToMany(() => Book, book => book.author)
  books1 = new Collection<Book>(this);

  // or via options object
  @OneToMany({ entity: () => Book, mappedBy: 'author' })
  books2 = new Collection<Book>(this);

}

----------------------------------------

TITLE: Implementing EventSubscriber for All Entities in TypeScript
DESCRIPTION: Comprehensive example of an EventSubscriber that subscribes to all events for all entities. This subscriber implements methods for entity lifecycle events, flush events, and transaction events.

LANGUAGE: typescript
CODE:
import { EventArgs, TransactionEventArgs, EventSubscriber } from '@mikro-orm/core';

export class EverythingSubscriber implements EventSubscriber {

  // entity life cycle events
  onInit<T>(args: EventArgs<T>): void { ... }
  async onLoad<T>(args: EventArgs<T>): Promise<void> { ... }
  async beforeCreate<T>(args: EventArgs<T>): Promise<void> { ... }
  async afterCreate<T>(args: EventArgs<T>): Promise<void> { ... }
  async beforeUpdate<T>(args: EventArgs<T>): Promise<void> { ... }
  async afterUpdate<T>(args: EventArgs<T>): Promise<void> { ... }
  async beforeUpsert<T>(args: EventArgs<T>): Promise<void> { ... }
  async afterUpsert<T>(args: EventArgs<T>): Promise<void> { ... }
  async beforeDelete<T>(args: EventArgs<T>): Promise<void> { ... }
  async afterDelete<T>(args: EventArgs<T>): Promise<void> { ... }

  // flush events
  async beforeFlush<T>(args: FlushEventArgs): Promise<void> { ... }
  async onFlush<T>(args: FlushEventArgs): Promise<void> { ... }
  async afterFlush<T>(args: FlushEventArgs): Promise<void> { ... }

  // transaction events
  async beforeTransactionStart(args: TransactionEventArgs): Promise<void> { ... }
  async afterTransactionStart(args: TransactionEventArgs): Promise<void> { ... }
  async beforeTransactionCommit(args: TransactionEventArgs): Promise<void> { ... }
  async afterTransactionCommit(args: TransactionEventArgs): Promise<void> { ... }
  async beforeTransactionRollback(args: TransactionEventArgs): Promise<void> { ... }
  async afterTransactionRollback(args: TransactionEventArgs): Promise<void> { ... }

}

----------------------------------------

TITLE: Resulting SQL Query for JSON Property in PostgreSQL
DESCRIPTION: This SQL snippet shows the resulting query generated by MikroORM when querying JSON object properties in PostgreSQL. It demonstrates how nested JSON properties are accessed and compared in the WHERE clause.

LANGUAGE: sql
CODE:
select "e0".*
from "book" as "e0"
where ("meta"->>'valid')::bool = true
  and "meta"->>'nested'->>'foo' = '123'
  and ("meta"->>'nested'->>'bar')::float8 = 321
  and ("meta"->>'nested'->>'deep'->>'baz')::float8 = 59
  and ("meta"->>'nested'->>'deep'->>'qux')::bool = false
limit 1

----------------------------------------

TITLE: Populating All Relations in MikroORM (TypeScript)
DESCRIPTION: Shows how to populate all relationships in MikroORM using the wildcard '*' in the populate option. This approach uses select-in strategy to handle possible cycles.

LANGUAGE: typescript
CODE:
const tags = await em.find(BookTag, {}, {
  populate: ['*'],
});

----------------------------------------

TITLE: Using @Transactional Decorator for Transaction Management in MikroORM
DESCRIPTION: Illustrates the use of the @Transactional() decorator in MikroORM for declarative transaction management. This approach simplifies transaction handling in service methods.

LANGUAGE: typescript
CODE:
import { EntityManager, MikroORM, Transactional } from '@mikro-orm/core';

export class MyService {

  constructor(private readonly em: EntityManager) { }

  @Transactional()
  async doSomething() {
    //... do some work
    const user = new User(...);
    user.name = 'George';
    em.persist(user); 
  }

}

----------------------------------------

TITLE: Defining OneToMany Collections in TypeScript with MikroORM
DESCRIPTION: Shows how to define OneToMany collections in MikroORM using TypeScript decorators. It demonstrates both the inline lambda syntax and the options object syntax.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @PrimaryKey()
  _id!: ObjectId;

  @ManyToOne()
  author!: Author;

}

@Entity()
export class Author {

  @PrimaryKey()
  _id!: ObjectId;

  @OneToMany(() => Book, book => book.author)
  books1 = new Collection<Book>(this);

  // or via options object
  @OneToMany({ entity: () => Book, mappedBy: 'author' })
  books2 = new Collection<Book>(this);

}

----------------------------------------

TITLE: Implementing Custom DateType in TypeScript for MikroORM
DESCRIPTION: Implementation of a custom DateType class that extends the Type abstract class. This type handles conversion between JavaScript Date objects and database date strings, including validation and proper date formatting. It implements convertToDatabaseValue, convertToJSValue, and getColumnType methods.

LANGUAGE: typescript
CODE:
import { Type, Platform, EntityProperty, ValidationError } from 'mikro-orm';

export class DateType extends Type {

  convertToDatabaseValue(value: any, platform: Platform): any {
    if (value instanceof Date) {
      return value.toISOString().substr(0, 10);
    }

    if (!value || value.toString().match(/^\d{4}-\d{2}-\d{2}$/)) {
      return value;
    }

    throw ValidationError.invalidType(DateType, value, 'JS');
  }

  convertToJSValue(value: any, platform: Platform): any {
    if (!value || value instanceof Date) {
      return value;
    }

    const date = new Date(value);

    if (date.toString() === 'Invalid Date') {
      throw ValidationError.invalidType(DateType, value, 'database');
    }

    return date;
  }

  getColumnType(prop: EntityProperty, platform: Platform) {
    return `date(${prop.length})`;
  }

}

----------------------------------------

TITLE: Complex Where Conditions in QueryBuilder with MikroORM
DESCRIPTION: This snippet demonstrates various ways to construct complex query conditions using QueryBuilder. It shows how to use custom SQL, andWhere()/orWhere() methods, and condition objects.

LANGUAGE: typescript
CODE:
const qb = orm.em.createQueryBuilder(BookTag, 't');
qb.select(['b.*', 't.*'])
  .leftJoin('t.books', 'b')
  .where('b.title = ? or b.title = ?', ['test 123', 'lol 321'])
  .andWhere('1 = 1')
  .orWhere('1 = 2')
  .limit(2, 1);

console.log(qb.getQuery());
// select `b`.*, `t`.*, `e1`.`book_tag_id`, `e1`.`book_uuid_pk` from `book_tag` as `t`
// left join `book_to_book_tag` as `e1` ON `t`.`id` = `e1`.`book_tag_id`
// left join `book` as `b` ON `e1`.`book_uuid_pk` = `b`.`uuid_pk`
// where (((b.title = ? or b.title = ?) and (1 = 1)) or (1 = 2))
// limit ? offset ?

----------------------------------------

TITLE: Entity Creation with Explicit Primary Key
DESCRIPTION: Shows how entities with explicit primary keys are handled by the Identity Map and subsequent queries.

LANGUAGE: typescript
CODE:
const jon = em.create(Author, {
  id: 1,
  name: 'Jon',
  email: 'foo@bar.com',
});

// this will not query the database
const jon2 = await em.findOne(Author, 1);
console.log(jon === jon2); // true
await em.flush(); // this inserts the entity

----------------------------------------

TITLE: Initializing MikroORM with Proper EntityManager Typing
DESCRIPTION: Shows how to initialize MikroORM and access the EntityManager with correct TypeScript typing. This ensures that methods like createQueryBuilder() are properly recognized.

LANGUAGE: ts
CODE:
import { MikroORM } from '@mikro-orm/mysql'; // or any other SQL driver package

const orm = await MikroORM.init({
  // ...
});
console.log(orm.em); // access EntityManager via `em` property

----------------------------------------

TITLE: Setting Up Database Driver Configuration
DESCRIPTION: Shows how to configure database drivers with custom options and timezone settings.

LANGUAGE: typescript
CODE:
import { MySqlDriver } from 'mikro-orm/dist/drivers/MySqlDriver';

MikroORM.init({
  driver: MySqlDriver,
  driverOptions: { connection: { timezone: '+02:00' } },
});

----------------------------------------

TITLE: Defining MongoDB Virtual Entity with Aggregation
DESCRIPTION: Implements a virtual entity for MongoDB using aggregation pipeline. Handles pagination, sorting, and filtering through pipeline stages while joining book and author collections.

LANGUAGE: typescript
CODE:
@Entity({
  expression: (em: EntityManager, where, options) => {
    const $sort = { ...options.orderBy } as Dictionary;
    $sort._id = 1;
    const pipeline: Dictionary[] = [
      { $project: { _id: 0, title: 1, author: 1 } },
      { $sort },
      { $match: where ?? {} },
      { $lookup: { from: 'author', localField: 'author', foreignField: '_id', as: 'author', pipeline: [{ $project: { name: 1 } }] } },
      { $unwind: '$author' },
      { $set: { authorName: '$author.name' } },
      { $unset: ['author'] },
    ];

    if (options.offset != null) {
      pipeline.push({ $skip: options.offset });
    }

    if (options.limit != null) {
      pipeline.push({ $limit: options.limit });
    }

    return em.aggregate(Book, pipeline);
  },
})
export class BookWithAuthor {

  @Property()
  title!: string;

  @Property()
  authorName!: string;

}

----------------------------------------

TITLE: Configuring SWC for MikroORM compatibility
DESCRIPTION: This SWC configuration enables decorator metadata extraction and class name preservation, which are crucial for MikroORM functionality. It sets the appropriate parser options, enables decorator metadata transformation, and targets the most modern JavaScript version.

LANGUAGE: json
CODE:
{
  "jsc": {
    "parser": {
      "syntax": "typescript",
      "decorators": true
    },
    "transform": {
      "decoratorMetadata": true,
      "legacyDecorator": true
    },
    "target": "esnext",
    "minify": false
  }
}

----------------------------------------

TITLE: Using OptionalProps Symbol for Properties with Default Values in MikroORM
DESCRIPTION: This code demonstrates the use of the OptionalProps symbol to mark properties with default values as optional in TypeScript while maintaining their required status in MikroORM.

LANGUAGE: typescript
CODE:
import { OptionalProps, Entity, PrimaryKey, Property } from '@mikro-orm/core';

@Entity()
class User {

  [OptionalProps]?: 'foo' | 'bar' | 'fooBar';

  @PrimaryKey()
  id!: number;

  @Property({ default: 1 })
  foo: number = 1;

  @Property({ default: 2 })
  bar: number = 2;

  @Property({ persist: false })
  get fooBar() {
    return foo + bar;
  }

}

----------------------------------------

TITLE: Defining Lifecycle Hooks with Decorators in TypeScript
DESCRIPTION: Examples of using lifecycle hook decorators to define methods that are called at specific points in an entity's lifecycle.

LANGUAGE: typescript
CODE:
@OnInit()
doStuffOnInit(args: EventArgs<this>) {
  this.fullName = `${this.firstName} - ${this.lastName}`; // initialize shadow property
}

@OnLoad()
async doStuffOnLoad(args: EventArgs<this>) {
  // ...
}

@BeforeCreate()
async doStuffBeforeCreate(args: EventArgs<this>) {
  // ...
}

@AfterCreate()
async doStuffAfterCreate(args: EventArgs<this>) {
  // ...
}

@BeforeUpdate()
async doStuffBeforeUpdate(args: EventArgs<this>) {
  // ...
}

@AfterUpdate()
async doStuffAfterUpdate(args: EventArgs<this>) {
  // ...
}

@BeforeDelete()
async doStuffBeforeDelete(args: EventArgs<this>) {
  // ...
}

@AfterDelete()
async doStuffAfterDelete(args: EventArgs<this>) {
  // ...
}

----------------------------------------

TITLE: Demonstrating Cascade Remove in MikroORM TypeScript
DESCRIPTION: Illustrates how cascade remove works in MikroORM. Removes a book entity, which also removes its associated publisher due to the cascade remove setting.

LANGUAGE: typescript
CODE:
await orm.em.remove(book).flush(); // this will also remove book.publisher

----------------------------------------

TITLE: Implementing Custom Driver Class in TypeScript for MikroORM
DESCRIPTION: Database driver implementation that handles entity operations like find, insert, update, and delete. Integrates with Connection and Platform classes for database operations.

LANGUAGE: typescript
CODE:
import { DatabaseDriver } from 'mikro-orm';

export class MyCustomSchemaHelper extends DatabaseDriver {

  // initialize connection and platform
  protected readonly connection = new MyCustomConnection(this.config);
  protected readonly platform = new MyCustomPlatform;

  // and implement abstract methods
  find<T extends IEntity>(entityName: string, where: FilterQuery<T>, populate?: string[], orderBy?: Record<string, QueryOrder>, limit?: number, offset?: number): Promise<T[]>;
  findOne<T extends IEntity>(entityName: string, where: FilterQuery<T> | string, populate: string[]): Promise<T | null>;
  nativeInsert<T extends IEntityType<T>>(entityName: string, data: EntityData<T>): Promise<QueryResult>;
  nativeUpdate<T extends IEntity>(entityName: string, where: FilterQuery<IEntity> | IPrimaryKey, data: EntityData<T>): Promise<QueryResult>;
  nativeDelete<T extends IEntity>(entityName: string, where: FilterQuery<IEntity> | IPrimaryKey): Promise<QueryResult>;
  count<T extends IEntity>(entityName: string, where: FilterQuery<T>): Promise<number>;

}

----------------------------------------

TITLE: Configuring MikroORM CLI in package.json
DESCRIPTION: JSON configuration in package.json to set up MikroORM CLI with custom config paths.

LANGUAGE: json
CODE:
{
  "name": "your-app",
  "dependencies": { ... },
  "mikro-orm": {
    "configPaths": [
      "./src/mikro-orm.config.ts",
      "./dist/mikro-orm.config.js"
    ]
  }
}

----------------------------------------

TITLE: Using Raw SQL Fragments in MikroORM v6
DESCRIPTION: This code diff demonstrates the new way of using raw SQL fragments in MikroORM v6 queries using the raw helper function.

LANGUAGE: typescript
CODE:
const users = await em.find(User, {
-  [expr('lower(email)')]: 'foo@bar.baz',
+  [raw('lower(email)')]: 'foo@bar.baz',
});

----------------------------------------

TITLE: Importing SQL EntityManager in TypeScript
DESCRIPTION: This snippet demonstrates how to import the SQL-specific EntityManager from a driver package to access the createQueryBuilder() method.

LANGUAGE: ts
CODE:
import { EntityManager } from '@mikro-orm/mysql'; // or any other SQL driver package

const em = orm.em as EntityManager;
const qb = await em.createQueryBuilder(...);

----------------------------------------

TITLE: Querying JSON Object Properties in MikroORM with TypeScript
DESCRIPTION: This example shows how to query JSON object properties in MikroORM. It demonstrates a complex query on nested JSON properties of the 'meta' field in the Book entity.

LANGUAGE: typescript
CODE:
const b = await em.findOne(Book, {
  meta: {
    valid: true,
    nested: {
      foo: '123',
      bar: 321,
      deep: {
        baz: 59,
        qux: false,
      },
    },
  },
});

----------------------------------------

TITLE: Configuring Global Populate Behavior in MikroORM (TypeScript)
DESCRIPTION: Shows how to set the global populate behavior using the 'populateWhere' option during ORM initialization. This example sets it to respect the outer filter passed in a where condition.

LANGUAGE: typescript
CODE:
const orm = await MikroORM.init({
    // We want our populate fetches to respect the outer filter passed in a where condition.
    populateWhere: PopulateHint.INFER,
});

----------------------------------------

TITLE: Configuring Jest Fake Timers for MikroORM Compatibility
DESCRIPTION: This snippet shows how to configure Jest's fake timers to avoid conflicts with MikroORM's dependencies that use process.nextTick().

LANGUAGE: typescript
CODE:
jest.useFakeTimers({ doNotFake: ['nextTick'] });

----------------------------------------

TITLE: Defining ManyToOne Relationships in TypeScript with MikroORM
DESCRIPTION: This snippet demonstrates various ways to define a ManyToOne relationship in MikroORM using TypeScript. It shows how to use the @ManyToOne decorator with different syntax options, including type inference, manual type specification, and using an options object.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @ManyToOne() // plain decorator is enough, type will be sniffer via reflection!
  author1!: Author;

  @ManyToOne(() => Author) // you can specify type manually as a callback
  author2!: Author;

  @ManyToOne('Author') // or as a string
  author3!: Author;

  @ManyToOne({ entity: () => Author }) // or use options object
  author4!: Author;

}

----------------------------------------

TITLE: Using Reference<T> Wrapper for Type-safe Relations
DESCRIPTION: Demonstrates how to use the Reference<T> wrapper for better type safety in entity relationships.

LANGUAGE: typescript
CODE:
import { Entity, IdentifiedReference, ManyToOne, PrimaryKey, Reference } from 'mikro-orm';

@Entity()
export class Book {

  @PrimaryKey()
  id!: number;

  @ManyToOne()
  author!: IdentifiedReference<Author>;

  constructor(author: Author) {
    this.author = Reference.create(author);
  }

}

----------------------------------------

TITLE: Implementing Global Error Handler
DESCRIPTION: This function sets up a global error handler to manage authentication errors, not found errors, and general server errors.

LANGUAGE: TypeScript
CODE:
app.setErrorHandler((error, request, reply) => {
  if (error instanceof AuthError) {
    return reply.status(401).send({ error: error.message });
  }

  if (error instanceof NotFoundError) {
    return reply.status(404).send({ error: error.message });
  }

  app.log.error(error);
  reply.status(500).send({ error: error.message });
});

----------------------------------------

TITLE: Setting up Request Context for MikroORM in Express
DESCRIPTION: Example of setting up a request context middleware for MikroORM in an Express application to manage entity manager instances.

LANGUAGE: typescript
CODE:
const app = express();

app.use((req, res, next) => {
  RequestContext.create(orm.em, next);
});

----------------------------------------

TITLE: Creating Entities in Specific Schema
DESCRIPTION: Demonstrates entity creation in a specific schema using QueryBuilder with the withSchema method.

LANGUAGE: typescript
CODE:
const qb = em.createQueryBuilder(User);
await qb.insert({ email: 'foo@bar.com' }).withSchema('client-123');

----------------------------------------

TITLE: Demonstrating Identity Map in MikroORM with TypeScript
DESCRIPTION: This snippet shows how the Identity Map ensures the same entity instance is returned across multiple queries. It demonstrates querying for an author and then for all authors, showing that the same object reference is maintained.

LANGUAGE: typescript
CODE:
const authorRepository = em.getRepository(Author);
const jon = await authorRepository.findOne({ name: 'Jon Snow' }, { populate: ['books'] });
const authors = await authorRepository.findAll({ populate: ['books'] });

// identity map in action
console.log(jon === authors[0]); // true

----------------------------------------

TITLE: Complex AND Conditions Query in MikroORM TypeScript
DESCRIPTION: Demonstrates how to construct complex AND conditions using an array of comparison operators for querying Author entities. Shows the verbose syntax using $and operator with multiple conditions.

LANGUAGE: typescript
CODE:
const res = await orm.em.find(Author, { $and: [
  { id: { $in: [1, 2, 7] }, },
  { id: { $nin: [3, 4] }, },
  { id: { $gt: 5 }, },
  { id: { $lt: 10 }, },
  { id: { $gte: 7 }, },
  { id: { $lte: 8 }, },
  { id: { $ne: 9 }, },
] });

----------------------------------------

TITLE: Reference Kind Enum Definition in TypeScript
DESCRIPTION: Enumeration defining the possible types of entity relationships in MikroORM, including scalar, one-to-one, many-to-one, one-to-many, many-to-many, and embedded.

LANGUAGE: typescript
CODE:
enum ReferenceKind {
  SCALAR = 'scalar',
  ONE_TO_ONE = '1:1',
  MANY_TO_ONE = 'm:1',
  ONE_TO_MANY = '1:m',
  MANY_TO_MANY = 'm:n',
  EMBEDDED = 'embedded',
}

----------------------------------------

TITLE: Configuring MikroORM v6 with MySQL Driver
DESCRIPTION: This snippet shows how to configure MikroORM v6 using the MySQL driver, demonstrating the new way of specifying the database type.

LANGUAGE: typescript
CODE:
import { defineConfig } from '@mikro-orm/mysql';

export default defineConfig({ ... });

----------------------------------------

TITLE: Query Execution Methods
DESCRIPTION: Shows different methods for executing queries and controlling result format.

LANGUAGE: typescript
CODE:
const res1 = await qb.execute('all'); // returns array of objects, default behavior
const res2 = await qb.execute('get'); // returns single object
const res3 = await qb.execute('run'); // returns object like `{ affectedRows: number, insertId: number, row: any }`

----------------------------------------

TITLE: Book Entity Definition with MikroORM Decorators
DESCRIPTION: Example of defining a Book entity using TypeScript decorators for MongoDB with relationships

LANGUAGE: typescript
CODE:
import { ObjectID } from 'mongodb';
import { Collection, Entity, IEntity, ManyToMany, ManyToOne, PrimaryKey, Property } from 'mikro-orm';
import { Author, BookTag, Publisher } from '.';

@Entity()
export class Book {

  @PrimaryKey()
  _id: ObjectID;

  @Property()
  createdAt = new Date();

  @Property({ onUpdate: () => new Date() })
  updatedAt = new Date();

  @Property()
  title: string;

  @ManyToOne()
  author: Author;

  @ManyToOne()
  publisher: Publisher;

  @ManyToMany({ entity: () => BookTag, inversedBy: 'books' })
  tags = new Collection<BookTag>(this);

  constructor(title: string, author: Author) {
    this.title = title;
    this.author = author;
  }

}

export interface Book extends IEntity<string> { }

----------------------------------------

TITLE: Initializing MikroORM in TypeScript
DESCRIPTION: Example of initializing MikroORM with basic configuration options, including entity definitions and database connection details.

LANGUAGE: typescript
CODE:
const orm = await MikroORM.init({
  entities: [Author, Book, BookTag],
  dbName: 'my-db-name',
  type: 'mongo', // one of `mongo` | `mysql` | `mariadb` | `postgresql` | `sqlite`
  clientUrl: '...', // defaults to 'mongodb://localhost:27017' for mongodb driver
});
console.log(orm.em); // access EntityManager via `em` property

----------------------------------------

TITLE: Implementing RequestContext Middleware in MikroORM with TypeScript
DESCRIPTION: This snippet demonstrates how to use the RequestContext helper to create a request-specific entity manager in MikroORM. It's typically used as middleware in web applications to ensure each request has its own ORM context.

LANGUAGE: typescript
CODE:
app.use((req, res, next) => {
  RequestContext.create(orm.em, next);
});

----------------------------------------

TITLE: Creating Initial MySQL Schema for Blog Database
DESCRIPTION: SQL schema definition for creating the initial blog database structure including users, articles, comments, and tags tables with proper relationships and constraints.

LANGUAGE: sql
CODE:
-- MySQL Workbench Forward Engineering

SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0;
SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0;
SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION';

-- -----------------------------------------------------
-- Schema blog
-- -----------------------------------------------------
CREATE SCHEMA IF NOT EXISTS `blog` DEFAULT CHARACTER SET utf8;
USE `blog`;

-- -----------------------------------------------------
-- Table `user`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `user` (
  `id` INT UNSIGNED NOT NULL AUTO_INCREMENT,
  `created_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  `full_name` VARCHAR(255) NOT NULL,
  `email` VARCHAR(255) NOT NULL,
  `password` VARCHAR(255) NOT NULL,
  `bio` TEXT NOT NULL,
  PRIMARY KEY (`id`))
ENGINE = InnoDB;

----------------------------------------

TITLE: Implementing Declarative Referential Integrity in MikroORM
DESCRIPTION: Demonstrates how to configure database-level referential integrity actions using onUpdateIntegrity and onDelete options.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @ManyToOne({ onUpdateIntegrity: 'set null', onDelete: 'cascade' })
  author?: Author;

}

----------------------------------------

TITLE: Finding an Author with Populated Books using Default Strategy in MikroORM
DESCRIPTION: This code snippet shows how to find an Author entity and populate its books relationship using the default 'joined' strategy in MikroORM.

LANGUAGE: typescript
CODE:
const author = await orm.em.findOne(Author, 1, {
  populate: ['books'],
});

----------------------------------------

TITLE: Using Class-Based Data with assign() in TypeScript
DESCRIPTION: Shows how to use class-based data with assign() by extending the PlainObject class for DTO validation.

LANGUAGE: typescript
CODE:
import { PlainObject } from '@mikro-orm/core';

class UpdateAuthorDTO extends PlainObject {

  @IsString()
  @IsNotEmpty()
  name!: string;

  @ValidateNested()
  @Type(() => UpdateBookDto)
  books!: UpdateBookDto[];

}

// dto is an instance of UpdateAuthorDto
em.assign(user, dto);

----------------------------------------

TITLE: Using Type-Safe OrderBy Parameter in MikroORM v5
DESCRIPTION: Demonstration of the new type-safe orderBy parameter in MikroORM v5, which allows passing an array of objects for more complex sorting.

LANGUAGE: typescript
CODE:
const books = await em.find(Book, {}, {
  orderBy: [
    { title: 1 },
    { author: { name: -1 } },
  ],
});

----------------------------------------

TITLE: Querying Entities with Default Joined Strategy in TypeScript
DESCRIPTION: This snippet shows how to query an Author entity with its related books using the default 'joined' strategy.

LANGUAGE: typescript
CODE:
const author = await orm.em.findOne(Author, 1, {
  populate: ['books'],
});

----------------------------------------

TITLE: Using Collection.indexBy Helper Method in TypeScript
DESCRIPTION: Examples of using the new indexBy Collection helper to create maps of entities indexed by specific properties.

LANGUAGE: typescript
CODE:
const config = user.config.indexBy('key');

LANGUAGE: typescript
CODE:
const config = user.config.indexBy('key', 'value');

----------------------------------------

TITLE: Configuring Type Mapping in MikroORM
DESCRIPTION: This snippet demonstrates how to adjust the default type mapping in MikroORM using the discovery.getMappedType callback.

LANGUAGE: typescript
CODE:
import { MikroORM, Platform, Type } from '@mikro-orm/core';

const orm = await MikroORM.init({
  discovery: {
    getMappedType(type: string, platform: Platform) {
      if (type === 'string') {
        return Type.getType(TextType);
      }
      return platform.getDefaultMappedType(type);
    },
  },
});

----------------------------------------

TITLE: Implementing Native BigInt Primary Key in TypeScript with MikroORM
DESCRIPTION: Extended implementation that creates a custom type to handle native JavaScript BigInt values. This approach allows working directly with bigint type instead of string representations.

LANGUAGE: typescript
CODE:
export class NativeBigIntType extends BigIntType {

  convertToJSValue(value: any): any {
    return BigInt(value);
  }

}

@Entity()
export class Book {

  @PrimaryKey({ type: NativeBigIntType })
  id: bigint;

}

----------------------------------------

TITLE: Initializing MikroORM with Proper EntityManager Typing
DESCRIPTION: This code shows how to import MikroORM from a specific driver package to ensure proper typing of the EntityManager.

LANGUAGE: ts
CODE:
import { MikroORM } from '@mikro-orm/mysql'; // or any other SQL driver package

const orm = await MikroORM.init({
  // ...
});
console.log(orm.em); // access EntityManager via `em` property

----------------------------------------

TITLE: Implementing RequestContext Middleware in MikroORM
DESCRIPTION: Shows how to set up request context middleware to ensure proper isolation of entity manager instances per request. Should be registered after request processing middleware like queryParser or bodyParser.

LANGUAGE: typescript
CODE:
app.use((req, res, next) => {
  RequestContext.create(orm.em, next);
});

----------------------------------------

TITLE: Programmatic Entity Generation Script
DESCRIPTION: Script to programmatically generate entities using MikroORM

LANGUAGE: typescript
CODE:
import { MikroORM } from '@mikro-orm/core';
import { EntityGenerator } from '@mikro-orm/entity-generator';

(async () => {
  const orm = await MikroORM.init({
    discovery: {
      warnWhenNoEntities: false,
    },
    extensions: [EntityGenerator],
    dbName: 'your-db-name',
  });
  const dump = await orm.entityGenerator.generate({
    save: true,
    path: process.cwd() + '/my-entities',
  });
  console.log(dump);
  await orm.close(true);
})();

----------------------------------------

TITLE: Implementing SQL Query Highlighting
DESCRIPTION: Demonstrates how to configure SQL query highlighting using the SqlHighlighter package.

LANGUAGE: typescript
CODE:
import { SqlHighlighter } from '@mikro-orm/sql-highlighter';

MikroORM.init({
  highlighter: new SqlHighlighter(),
  // ...
});

----------------------------------------

TITLE: TypeScript Configuration for MikroORM
DESCRIPTION: TypeScript compiler options configuration with ESM support and decorator settings

LANGUAGE: json
CODE:
{
  "compilerOptions": {
    "module": "Node16",
    "target": "ES2022",
    "strict": true,
    "outDir": "dist",
    "declaration": true,
    "experimentalDecorators": true
  },
  "include": [
    "./src/**/*.ts"
  ],
  "ts-node": {
    "esm": true,
    "transpileOnly": true
  }
}

----------------------------------------

TITLE: Using Custom DateType in Entity Definition
DESCRIPTION: Example of how to use a custom DateType in an entity class definition using decorators. Shows property configuration with the custom type and additional parameters.

LANGUAGE: typescript
CODE:
@Entity()
export class FooBar {

  @PrimaryKey()
  id!: number;

  @Property()
  name!: string;

  @Property({ type: DateType, length: 3 })
  born?: Date;

}

----------------------------------------

TITLE: Explicit Transaction Handling with begin/commit/rollback in MikroORM
DESCRIPTION: Demonstrates explicit transaction handling using MikroORM's begin(), commit(), and rollback() methods. This approach provides full control over the transaction lifecycle.

LANGUAGE: typescript
CODE:
const em = orm.em.fork();
await em.begin();

try {
  //... do some work
  const user = new User(...);
  user.name = 'George';
  em.persist(user);
  await em.commit(); // will flush before making the actual commit query
} catch (e) {
  await em.rollback();
  throw e;
}

----------------------------------------

TITLE: Configuring Declarative Referential Integrity in MikroORM TypeScript
DESCRIPTION: Shows how to configure database-level referential integrity actions in MikroORM using TypeScript decorators. This is only supported in SQL drivers.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @ManyToOne({ updateRule: 'set null', deleteRule: 'cascade' })
  author?: Author;

}

----------------------------------------

TITLE: Basic Embeddable Implementation with reflect-metadata
DESCRIPTION: Demonstrates how to create a basic Address embeddable class and embed it in a User entity using reflect-metadata.

LANGUAGE: typescript
CODE:
import { Embeddable, Embedded, Entity, PrimaryKey, Property } from '@mikro-orm/core';

@Embeddable()
export class Address {

  @Property()
  street!: string;

  @Property()
  postalCode!: string;

  @Property()
  city!: string;

  @Property()
  country!: string;

}

@Entity()
export class User {

  @PrimaryKey()
  id!: number;

  @Embedded(() => Address)
  address!: Address;

}

----------------------------------------

TITLE: Defining Entity with BigIntType Primary Key in MikroORM
DESCRIPTION: This snippet shows how to define an entity with a BigIntType primary key, which represents the bigint as a string by default.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @PrimaryKey({ type: BigIntType })
  id: string;

}

----------------------------------------

TITLE: Defining CacheAdapter Interface in TypeScript
DESCRIPTION: This code defines the CacheAdapter interface in TypeScript, which includes methods for getting, setting, and clearing cache items, as well as an optional close method for graceful shutdowns.

LANGUAGE: typescript
CODE:
export interface CacheAdapter {

  /**
   * Gets the items under `name` key from the cache.
   */
  get(name: string): Promise<any>;

  /**
   * Sets the item to the cache. `origin` is used for cache invalidation and should reflect the change in data.
   */
  set(name: string, data: any, origin: string, expiration?: number): Promise<void>;

  /**
   * Clears all items stored in the cache.
   */
  clear(): Promise<void>;

  /**
   * Called inside `MikroORM.close()` Allows graceful shutdowns (e.g. for redis).
   */
  close?(): Promise<void>;

}

----------------------------------------

TITLE: Defining a Composite Primary Key Entity in TypeScript with MikroORM
DESCRIPTION: This code snippet demonstrates how to create an entity with a composite primary key using MikroORM decorators. It defines a Car entity with 'name' and 'year' as primary keys.

LANGUAGE: typescript
CODE:
@Entity()
export class Car {

  @PrimaryKey()
  name: string;

  @PrimaryKey()
  year: number;

  // this is needed for proper type checks in `FilterQuery`
  [PrimaryKeyProp]?: ['name', 'year'];

  constructor(name: string, year: number) {
    this.name = name;
    this.year = year;
  }

}

----------------------------------------

TITLE: Implementing Custom Naming Strategy for Table Aliasing in TypeScript
DESCRIPTION: Example of creating a custom naming strategy to maintain the old behavior of table aliasing in MikroORM v5. This strategy uses 'e' followed by an index for alias names.

LANGUAGE: typescript
CODE:
import { AbstractNamingStrategy } from '@mikro-orm/core';

class CustomNamingStrategy extends AbstractNamingStrategy {
  aliasName(entityName: string, index: number) {
    return 'e' + index;
  }
}

----------------------------------------

TITLE: Configuring JOINED Loading Strategy in Entity Definition
DESCRIPTION: Example showing how to configure the JOINED loading strategy directly in the entity mapping definition.

LANGUAGE: typescript
CODE:
import { Entity, LoadStrategy, OneToMany } from '@mikro-orm/core';

@Entity()
export class Author {
  @OneToMany({
    entity: () => Book,
    mappedBy: b => b.author,
    strategy: LoadStrategy.JOINED,
  })
  books = new Collection<Book>(this);
}

----------------------------------------

TITLE: Replacing EntityRepository Methods with EntityManager in MikroORM v6
DESCRIPTION: This code diff demonstrates how to replace removed EntityRepository methods with direct EntityManager methods in MikroORM v6.

LANGUAGE: typescript
CODE:
-userRepository.persist(user);
-await userRepository.flush();
+em.persist(user);
+await em.flush();

----------------------------------------

TITLE: EntityAssigner Usage with Entity Manager
DESCRIPTION: Shows how to use the EntityAssigner.assign() method with new entities, which now requires explicitly passing the EntityManager instance.

LANGUAGE: typescript
CODE:
const book = new Book();
wrap(book).assign(data, { em: orm.em });

----------------------------------------

TITLE: Custom Logger Configuration in MikroORM
DESCRIPTION: Configures MikroORM to use a custom logger function instead of the default console.log

LANGUAGE: typescript
CODE:
return MikroORM.init({
  debug: true,
  logger: msg => myCustomLogger.log(msg),
});

----------------------------------------

TITLE: Defining Book Entity Schema in TypeScript
DESCRIPTION: This snippet demonstrates how to define a Book entity using EntitySchema in MikroORM. It includes properties for title, author, publisher, and tags, with various relationship types.

LANGUAGE: typescript
CODE:
export interface Book extends CustomBaseEntity {
  title: string;
  author: Author;
  publisher: Publisher;
  tags: Collection<BookTag>;
}

export const schema = new EntitySchema<Book, CustomBaseEntity>({
  name: 'Book',
  extends: CustomBaseEntitySchema,
  properties: {
    title: { type: 'string' },
    author: { kind: 'm:1', entity: 'Author', inversedBy: 'books' },
    publisher: { kind: 'm:1', entity: 'Publisher', inversedBy: 'books' },
    tags: { kind: 'm:n', entity: 'BookTag', inversedBy: 'books', fixedOrder: true },
  },
});

----------------------------------------

TITLE: Defining Book Entity Schema in TypeScript
DESCRIPTION: This snippet demonstrates how to define a Book entity using EntitySchema in MikroORM. It includes properties for title, author, publisher, and tags, with various relationship types.

LANGUAGE: typescript
CODE:
export interface Book extends CustomBaseEntity {
  title: string;
  author: Author;
  publisher: Publisher;
  tags: Collection<BookTag>;
}

export const schema = new EntitySchema<Book, CustomBaseEntity>({
  name: 'Book',
  extends: CustomBaseEntitySchema,
  properties: {
    title: { type: 'string' },
    author: { kind: 'm:1', entity: 'Author', inversedBy: 'books' },
    publisher: { kind: 'm:1', entity: 'Publisher', inversedBy: 'books' },
    tags: { kind: 'm:n', entity: 'BookTag', inversedBy: 'books', fixedOrder: true },
  },
});

----------------------------------------

TITLE: Basic MikroORM Initialization
DESCRIPTION: Basic setup for initializing MikroORM with entity configuration and database connection settings.

LANGUAGE: typescript
CODE:
const orm = await MikroORM.init({
  entities: [Author, Book, BookTag],
  dbName: 'my-db-name',
  clientUrl: '...', // defaults to 'mongodb://localhost:27017' for mongodb driver
  autoFlush: false, // read more here: https://mikro-orm.io/unit-of-work/
});
console.log(orm.em); // access EntityManager via `em` property

----------------------------------------

TITLE: Enabling Debug Mode in MikroORM (TypeScript)
DESCRIPTION: This snippet shows how to enable debug mode in MikroORM, which will log all queries using console.log(). It's useful for development purposes.

LANGUAGE: typescript
CODE:
return MikroORM.init({
  debug: true,
});

----------------------------------------

TITLE: Implementing Asynchronous Filter Conditions in MikroORM
DESCRIPTION: Shows how to create a filter with an asynchronous condition callback. The callback receives arguments including user-provided parameters, operation type, and EntityManager instance.

LANGUAGE: typescript
CODE:
import type { EntityManager } from '@mikro-orm/mysql';

@Entity()
@Filter({ name: 'writtenBy', cond: async (args, type, em: EntityManager) => {
  if (type === 'update') {
    return {}; // do not apply when updating
  }

  return {
    author: { name: args.name },
    publishedAt: { $lte: raw('now()') },
  };
} })
export class Book {
  ...
}

const books = await orm.em.find(Book, {}, {
  filters: { writtenBy: { name: 'God' } },
});

----------------------------------------

TITLE: Configuring Authentication for Express AdminJS
DESCRIPTION: Example of adding authentication to AdminJS with Express using buildAuthenticatedRouter

LANGUAGE: typescript
CODE:
const ADMIN_EMAIL = 'example@test.com';
const ADMIN_PASSWORD = 'password';

const router = AdminJSExpress.buildAuthenticatedRouter(admin, {
  authenticate: async (email, password) => {
    /* Your code for verifying email & password goes here */
    return email === ADMIN_EMAIL && password === ADMIN_PASSWORD
      ? { email } // the function should return an object containing user's data if authenticated successfully
      : null;
  },
  cookiePassword: process.env.COOKIE_PASSWORD ?? 'makesurepasswordissecure',
});

----------------------------------------

TITLE: Dynamically Loading Entities for MikroORM with Webpack Support in TypeScript
DESCRIPTION: This function demonstrates how to dynamically load entity files for MikroORM initialization, with support for both Webpack and non-Webpack environments. It uses require.context for Webpack and fs.readdirSync for other environments.

LANGUAGE: typescript
CODE:
await MikroORM.init({
  // ...
  entities: await getEntities(),
  discovery: { disableDynamicFileAccess: true },
  // ...
});

async function getEntities(): Promise<any[]> {
  if (process.env.WEBPACK) {
    const modules = require.context('../entities', true, /\.ts$/);

    return modules
      .keys()
      .map(r => modules(r))
      .flatMap(mod => Object.keys(mod).map(className => mod[className]));
  }

  const promises = fs.readdirSync('../entities').map(file => import(`../entities/${file}`));
  const modules = await Promise.all(promises);

  return modules.flatMap(mod => Object.keys(mod).map(className => mod[className]));
}

----------------------------------------

TITLE: Querying JSON Properties in MikroORM
DESCRIPTION: Shows how to query nested JSON object properties using MikroORM's query interface. Includes example of deep nested object querying.

LANGUAGE: typescript
CODE:
const b = await em.findOne(Book, {
  meta: {
    valid: true,
    nested: {
      foo: '123',
      bar: 321,
      deep: {
        baz: 59,
        qux: false,
      },
    },
  },
});

----------------------------------------

TITLE: Updating MikroORM Development Environment
DESCRIPTION: Commands for refreshing the development environment including cleaning Docker containers, removing test artifacts, and reinstalling dependencies.

LANGUAGE: shell
CODE:
docker compose down --volumes --remove-orphans --rmi local
yarn clean-tests
yarn
docker compose up -d

----------------------------------------

TITLE: Initializing MikroORM in TypeScript
DESCRIPTION: Example of initializing MikroORM with basic configuration options including entities, database name, and database type.

LANGUAGE: typescript
CODE:
const orm = await MikroORM.init({
  entities: [Author, Book, BookTag],
  dbName: 'my-db-name',
  type: 'mongo', // one of `mongo` | `mysql` | `mariadb` | `postgresql` | `sqlite`
  clientUrl: '...', // defaults to 'mongodb://localhost:27017' for mongodb driver
});
console.log(orm.em); // access EntityManager via `em` property

----------------------------------------

TITLE: Setting Global Loading Strategy in MikroORM Configuration
DESCRIPTION: This example demonstrates how to set a global loading strategy in the MikroORM configuration options.

LANGUAGE: typescript
CODE:
MikroORM.init({
  // ...
  populate: ['books'],
  loadStrategy: 'select-in', // 'joined' is the default for SQL drivers
});

----------------------------------------

TITLE: MongoDB ID Querying Examples
DESCRIPTION: Demonstrates different ways to query entities using both ObjectId and string IDs in MongoDB.

LANGUAGE: typescript
CODE:
const author = orm.em.getReference('...id...');
console.log(author.id);
console.log(author._id);

const article = '...article id...';
const book = '...book id...';
const repo = orm.em.getRepository(Author);
const foo1 = await repo.find({ id: { $in: [article] }, favouriteBook: book });
const bar1 = await repo.find({ id: { $in: [new ObjectId(article)] }, favouriteBook: new ObjectId(book) });
const foo2 = await repo.find({ _id: { $in: [article] }, favouriteBook: book });
const bar2 = await repo.find({ _id: { $in: [new ObjectId(article)] }, favouriteBook: new ObjectId(book) });

----------------------------------------

TITLE: Configuring Orphan Removal in MikroORM
DESCRIPTION: Shows how to set up orphan removal for OneToOne and OneToMany relationships, which automatically removes entities when they are disconnected from their parent.

LANGUAGE: typescript
CODE:
@Entity()
export class Author {

  @OneToMany({ entity: () => Book, mappedBy: 'author', orphanRemoval: true })
  books = new Collection<Book>(this);

}

----------------------------------------

TITLE: Using Forked EntityManager with Default Schema in MikroORM
DESCRIPTION: Demonstrates how to use a forked EntityManager with a default schema for operations.

LANGUAGE: typescript
CODE:
const fork = em.fork({ schema: 'client-123' });
await fork.findOne(User, { ... });

// Will yield the same result as
const user = await em.findOne(User, { ... }, { schema: 'client-123' });

----------------------------------------

TITLE: Setting Transaction Isolation Level in MikroORM
DESCRIPTION: Demonstrates how to set the transaction isolation level when using MikroORM's transactional() method. This allows for fine-tuning of transaction behavior.

LANGUAGE: typescript
CODE:
await orm.em.transactional(async em => {
  // ...
}, { isolationLevel: IsolationLevel.READ_UNCOMMITTED });

----------------------------------------

TITLE: Using Reference Wrapper in MikroORM Entity Definition
DESCRIPTION: This snippet shows how to use the Reference wrapper in a MikroORM entity definition. It demonstrates how to define a ManyToOne relation using the Ref type and ref function for type-safe lazy loading.

LANGUAGE: typescript
CODE:
import { Entity, Ref, ManyToOne, PrimaryKey, ref } from '@mikro-orm/core';

@Entity()
export class Book {

  @PrimaryKey()
  id!: number;

  @ManyToOne(() => Author, { ref: true })
  author: Ref<Author>;

  constructor(author: Author) {
    this.author = ref(author);
  }

}

----------------------------------------

TITLE: Registering Custom Repository for an Entity in TypeScript
DESCRIPTION: Demonstrates how to register a custom repository for an entity using the @Entity decorator. This allows the ORM to use the custom repository for the specified entity type.

LANGUAGE: typescript
CODE:
@Entity({ repository: () => CustomAuthorRepository })
export class Author {
  // ...
}

----------------------------------------

TITLE: Using RequestContext Middleware with Express
DESCRIPTION: This snippet demonstrates how to use the RequestContext middleware with Express to fork the entity manager for each request, preventing identity map collisions.

LANGUAGE: typescript
CODE:
const app = express();

app.use((req, res, next) => {
  RequestContext.create(orm.em, next);
});

----------------------------------------

TITLE: Defining Entity Hooks with EntitySchema in TypeScript
DESCRIPTION: This snippet demonstrates how to define entity hooks using EntitySchema, including instance methods, normal functions, and arrow functions.

LANGUAGE: typescript
CODE:
export class BookTag {
  _id!: ObjectId;
  id!: string;
  name: string;
  books = new Collection<Book>(this);

  constructor(name: string) {
    this.name = name;
  }

  beforeCreate() {
    this.version = 1;
  }

  beforeUpdate() {
    this.version++;
  }
}

function beforeUpdate() {
  this.version++;
}

const beforeUpdate2 = (args: EventArgs) => args.entity.version++;

export const schema = new EntitySchema({
  class: BookTag,
  hooks: {
    beforeCreate: ['beforeCreate'],
    beforeUpdate: ['beforeUpdate', beforeUpdate, beforeUpdate2]
  },
  properties: {
    _id: { type: 'ObjectId', primary: true },
    id: { type: 'string', serializedPrimaryKey: true },
    name: { type: 'string' },
    books: { reference: 'm:n', entity: () => Book, mappedBy: book => book.tags },
  },
});

----------------------------------------

TITLE: Initializing MikroORM with JavaScript Entities
DESCRIPTION: Example of initializing MikroORM with JavaScript entities, showing how to register entities and configure the database connection.

LANGUAGE: javascript
CODE:
const orm = await MikroORM.init({
  entities: [Author, Book, BookTag, BaseEntity],
  dbName: 'my-db-name',
  type: 'mysql',
});

----------------------------------------

TITLE: Using Result Cache with QueryBuilder in TypeScript
DESCRIPTION: Shows how to enable result caching when using the QueryBuilder in MikroORM. This example uses the default cache settings.

LANGUAGE: typescript
CODE:
const res = await em.createQueryBuilder(Book)
  .where({ author: { name: 'Jon Snow' } })
  .cache()
  .getResultList();

----------------------------------------

TITLE: Disabling MikroORM Metadata Cache
DESCRIPTION: Configuration snippet showing how to disable the metadata cache functionality in MikroORM initialization.

LANGUAGE: typescript
CODE:
await MikroORM.init({
  cache: { enabled: false },
  // ...
});

----------------------------------------

TITLE: Defining an Entity in MikroORM with TypeScript
DESCRIPTION: This code defines a User entity using MikroORM decorators. It demonstrates how to set up primary keys, properties, and relationships between entities.

LANGUAGE: typescript
CODE:
import { Entity, PrimaryKey, Property, ManyToOne } from '@mikro-orm/core';
import { Book } from './Book';

@Entity()
export class User {
  @PrimaryKey()
  id!: number;

  @Property()
  name!: string;

  @Property()
  email!: string;

  @ManyToOne(() => Book)
  favoriteBook?: Book;
}

----------------------------------------

TITLE: MongoDB Entity Schema Configuration
DESCRIPTION: Demonstrates how to configure an entity schema specifically for MongoDB, including ObjectId handling and relationships.

LANGUAGE: typescript
CODE:
export class BookTag {
  _id!: ObjectId;
  id!: string;
  name: string;
  books = new Collection<Book>(this);

  constructor(name: string) {
    this.name = name;
  }
}

export const schema = new EntitySchema<BookTag>({
  class: BookTag,
  properties: {
    _id: { type: 'ObjectId', primary: true },
    id: { type: 'string', serializedPrimaryKey: true },
    name: { type: 'string' },
    books: { kind: 'm:n', entity: () => Book, mappedBy: book => book.tags },
  },
});

----------------------------------------

TITLE: Primary Key Lookup with Array in MikroORM
DESCRIPTION: Shows how to perform a primary key lookup by directly providing an array to the find method in MikroORM. This is a shortcut for querying entities by their primary keys.

LANGUAGE: typescript
CODE:
const res = await orm.em.find(Author, [1, 2, 7]);

----------------------------------------

TITLE: Using EntityGenerator in a Script
DESCRIPTION: Example script to initialize MikroORM and use EntityGenerator programmatically.

LANGUAGE: typescript
CODE:
import { MikroORM } from '@mikro-orm/core';
import { EntityGenerator } from '@mikro-orm/entity-generator';

(async () => {
  const orm = await MikroORM.init({
    discovery: {
      // we need to disable validation for no entities
      warnWhenNoEntities: false,
    },
    extensions: [EntityGenerator],
    dbName: 'your-db-name',
    // ...
  });
  const dump = await orm.entityGenerator.generate({
    save: true,
    path: process.cwd() + '/my-entities',
  });
  console.log(dump);
  await orm.close(true);
})();

----------------------------------------

TITLE: Using sql.ref() in MikroORM Queries (TypeScript)
DESCRIPTION: Demonstrates how to use the sql.ref() function to refer to a column in a MikroORM query.

LANGUAGE: typescript
CODE:
await em.find(User, { foo: sql`bar` });

----------------------------------------

TITLE: Refreshing and Seeding Database Schema with MikroORM CLI
DESCRIPTION: CLI commands for dropping and recreating the database schema, with options to seed the database after creation.

LANGUAGE: shell
CODE:
npx mikro-orm schema:fresh --run     # !WARNING! Drops the database schema and recreates it

LANGUAGE: shell
CODE:
npx mikro-orm schema:fresh --run --seed              # seed the database with the default database seeder
npx mikro-orm schema:fresh --run --seed=UsersSeeder  # seed the database with the UsersSeeder

----------------------------------------

TITLE: Configuring Babel plugins for MikroORM compatibility
DESCRIPTION: This snippet shows the required Babel plugin configuration to make metadata extraction from decorators work with MikroORM. It includes the necessary plugins for TypeScript metadata transformation and decorator handling.

LANGUAGE: json
CODE:
{
  "plugins": [
    "babel-plugin-transform-typescript-metadata",
    ["@babel/plugin-proposal-decorators", { "legacy": true }],
    ["@babel/plugin-proposal-class-properties", { "loose": true  }]
  ]
}

----------------------------------------

TITLE: Configuring SQL Highlighter in MikroORM (TypeScript)
DESCRIPTION: This code example demonstrates how to set up an SQL highlighter in MikroORM. It imports the SqlHighlighter from the '@mikro-orm/sql-highlighter' package and configures it during MikroORM initialization.

LANGUAGE: typescript
CODE:
import { SqlHighlighter } from '@mikro-orm/sql-highlighter';

MikroORM.init({
  highlighter: new SqlHighlighter(),
  // ...
});

----------------------------------------

TITLE: Registering Custom Repository with Entity
DESCRIPTION: Demonstrates how to register a custom repository for an entity using the @Entity decorator.

LANGUAGE: typescript
CODE:
@Entity({ repository: () => CustomAuthorRepository })
export class Author {
  // ...
}

----------------------------------------

TITLE: Many-to-Many Bidirectional Propagation in MikroORM
DESCRIPTION: Illustrates many-to-many relationship propagation between Book and BookTag entities. Shows how changes are propagated regardless of which side initiates the relationship change.

LANGUAGE: typescript
CODE:
// many to many works both from owning side and from inverse side
const book = new Book(...);
const tag = new BookTag(...);

book.tags.add(tag);
console.log(tag.books.contains(book)); // true

tag.books.add(book);
console.log(book.tags.contains(tag)); // true

----------------------------------------

TITLE: Batch Deleting Users with MikroORM in TypeScript
DESCRIPTION: Illustrates how MikroORM 4.1 batches multiple user deletions into a single SQL query, improving performance when removing multiple entities.

LANGUAGE: typescript
CODE:
em.remove(users);
await em.flush();

// delete from `user` where `id` in (1, 2, 3, 4, 5)

----------------------------------------

TITLE: Configuring TypeScript for Proper Entity Initialization
DESCRIPTION: This JSON configuration disables the useDefineForClassFields option in TypeScript to ensure proper initialization of entity properties.

LANGUAGE: json
CODE:
{
  "compilerOptions": {
    "useDefineForClassFields": false
  }
}

----------------------------------------

TITLE: Reference Loading and Access Patterns
DESCRIPTION: Demonstrates different ways to load and access referenced entities safely.

LANGUAGE: typescript
CODE:
const article1 = await em.findOne(Article, 1);
article.author instanceof Reference; // true
article1.author; // Ref<User> (instance of `Reference` class)
article1.author.name; // type error, there is no `name` property
article1.author.unwrap().name; // unsafe sync access, undefined as author is not loaded
article1.author.isInitialized(); // false

const article2 = await em.findOne(Article, 1, { populate: ['author'] });
article2.author; // LoadedReference<User> (instance of `Reference` class)
article2.author.$.name; // type-safe sync access

----------------------------------------

TITLE: Starting MikroORM Website Local Development Server
DESCRIPTION: This command launches a local development server for the MikroORM website and opens a browser window. It allows for live updates without server restarts.

LANGUAGE: bash
CODE:
$ yarn start

----------------------------------------

TITLE: MongoDB Transaction Configuration
DESCRIPTION: Configuration setup for enabling and using transactions with MongoDB driver in MikroORM.

LANGUAGE: typescript
CODE:
import { MikroORM } from '@mikro-orm/core';
import { MongoDriver } from '@mikro-orm/mongodb';

const orm = await MikroORM.init<MongoDriver>({
  entities: [Author, Book, ...],
  clientUrl: 'mongodb://localhost:27017,localhost:27018,localhost:27019/my-db-name?replicaSet=rs0',
  type: 'mongo',
  implicitTransactions: true, // defaults to false
});

await orm.getSchemaGenerator().createSchema();

----------------------------------------

TITLE: Defining Author Entity with EntitySchema in JavaScript
DESCRIPTION: Example of defining an Author entity class with properties and constructor, along with its corresponding EntitySchema configuration. Includes property definitions, relationships, and necessary exports.

LANGUAGE: javascript
CODE:
const { Collection, EntitySchema } = require('mikro-orm');
const { Book } = require('./Book');
const { BaseEntity } = require('./BaseEntity');

/**
 * @property {number} id
 * @property {Date} createdAt
 * @property {Date} updatedAt
 * @property {string} name
 * @property {string} email
 * @property {number} age
 * @property {boolean} termsAccepted
 * @property {string[]} identities
 * @property {Date} born
 * @property {Collection<Book>} books
 * @property {Book} favouriteBook
 * @property {number} version
 * @property {string} versionAsString
 */
class Author extends BaseEntity {

  /**
   * @param {string} name
   * @param {string} email
   */
  constructor(name, email) {
    super();
    this.name = name;
    this.email = email;
    this.books = new Collection(this);
    this.createdAt = new Date();
    this.updatedAt = new Date();
    this.termsAccepted = false;
  }

}

export const schema = new EntitySchema({
  class: Author,
  properties: {
    name: { type: 'string' },
    email: { type: 'string', unique: true },
    age: { type: 'number', nullable: true },
    termsAccepted: { type: 'boolean', default: 0, onCreate: () => false },
    identities: { type: 'string[]', nullable: true },
    born: { type: DateType, nullable: true, length: 3 },
    books: { reference: '1:m', entity: () => 'Book', mappedBy: book => book.author },
    favouriteBook: { reference: 'm:1', type: 'Book' },
    version: { type: 'number', persist: false },
  },
});

module.exports.Author = Author;
module.exports.entity = Author;
module.exports.schema = schema;

----------------------------------------

TITLE: Custom Table Aliasing Strategy Implementation in TypeScript
DESCRIPTION: Implementation of a custom naming strategy to maintain v4-style table aliasing behavior by overriding the aliasName method.

LANGUAGE: typescript
CODE:
import { AbstractNamingStrategy } from '@mikro-orm/core';

class CustomNamingStrategy extends AbstractNamingStrategy {
  aliasName(entityName: string, index: number) {
    return 'e' + index;
  }
}

----------------------------------------

TITLE: Implementing Custom SchemaHelper Class in TypeScript for MikroORM
DESCRIPTION: SchemaHelper class that provides methods for database schema manipulation including table creation, constraints, and type definitions.

LANGUAGE: typescript
CODE:
import { SchemaHelper } from 'mikro-orm';

export class MyCustomSchemaHelper extends SchemaHelper {

  // here you can override default settings
  getIdentifierQuoteCharacter(): string;
  getSchemaBeginning(): string;
  getSchemaEnd(): string;
  getSchemaTableEnd(): string;
  getAutoIncrementStatement(meta: EntityMetadata): string;
  getPrimaryKeySubtype(meta: EntityMetadata): string;
  getTypeDefinition(prop: EntityProperty, types?: Record<string, string>, lengths?: Record<string, number>): string;
  getUnsignedSuffix(prop: EntityProperty): string;
  supportsSchemaConstraints(): boolean;
  supportsSchemaMultiAlter(): boolean;
  supportsSequences(): boolean;
  quoteIdentifier(field: string): string;
  dropTable(meta: EntityMetadata): string;
  indexForeignKeys(): boolean;

}

----------------------------------------

TITLE: Configuring MongoDB Indexes with MikroORM
DESCRIPTION: Demonstrates how to enable automatic index creation and define various types of indexes including unique constraints and text indexes.

LANGUAGE: typescript
CODE:
const orm = await MikroORM.init({
  entities: [Author, Book, ...],
  dbName: 'my-db-name',
  ensureIndexes: true, // defaults to false
});

@Unique({ options: { partialFilterExpression: { name: { $exists: true } } }})

@Index({ properties: ['name', 'caption'], type: 'text' })

@Index({ options: { point: '2dsphere', title: -1 } })

@Index({ options: [
  { title: 'text', perex: 'text', key: 1 },
  { weights: { title: 10, perex: 5 } },
] })

----------------------------------------

TITLE: Custom Base Entity Definition
DESCRIPTION: Example of defining a custom base entity with common fields like id and timestamps that can be extended by other entities.

LANGUAGE: typescript
CODE:
export interface CustomBaseEntity {
  id: number;
  createdAt: Date;
  updatedAt: Date;
}

export const schema = new EntitySchema<CustomBaseEntity>({
  name: 'CustomBaseEntity',
  abstract: true,
  properties: {
    id: { type: 'number', primary: true },
    createdAt: { type: 'Date', onCreate: () => new Date(), nullable: true },
    updatedAt: { type: 'Date', onCreate: () => new Date(), onUpdate: () => new Date(), nullable: true },
  },
});

----------------------------------------

TITLE: MikroORM with Hapi Setup
DESCRIPTION: Complete setup example for integrating MikroORM with AdminJS using Hapi framework, including database initialization and server configuration.

LANGUAGE: typescript
CODE:
import AdminJS from 'adminjs';
import { Database, Resource } from '@adminjs/mikroorm';
import AdminJSHapi from '@adminjs/hapi';
import { MikroORM } from '@mikro-orm/postgresql';
import { validate } from 'class-validator'; // optional

const PORT = process.env.PORT ?? 3000;

const run = async () => {
  /* Initialize MikroORM like you would do normally, you can also import your MikroORM instance from a separate file */
  const orm = await MikroORM.init({
    entities: [User, Car, Seller], // use your own entities
    dbName: process.env.DATABASE_NAME,
    clientUrl: process.env.DATABASE_URL,
  });

  /* Optional: if you're using class-validator, assign it to Resource */
  Resource.validate = validate;
  /* Tell AdminJS which adapter to use */
  AdminJS.registerAdapter({ Database, Resource });

  const server = Hapi.server({ port: PORT })

  /* Configure AdminJS */
  const adminOptions = {
    databases: [orm],
  };

  /* Register AdminJS as a Hapi server's plugin */
  await server.register({
    plugin: AdminJSHapi,
    options: adminOptions,
  });

  await server.start();
  console.log(`App listening at ${server.info.uri}`);
}

run();

----------------------------------------

TITLE: Using Aggregate Method with MongoDB in MikroORM
DESCRIPTION: Demonstrates how to use the aggregate() method when working with MongoDB in MikroORM. This requires importing the EntityManager from the MongoDB driver package.

LANGUAGE: ts
CODE:
import { EntityManager } from '@mikro-orm/mongodb';

const em = orm.em as EntityManager;
const ret = await em.aggregate(...);

----------------------------------------

TITLE: Query Execution Methods
DESCRIPTION: Different methods for executing queries and controlling result format

LANGUAGE: typescript
CODE:
const res1 = await qb.execute('all'); // returns array of objects, default behavior
const res2 = await qb.execute('get'); // returns single object
const res3 = await qb.execute('run'); // returns object like `{ affectedRows: number, insertId: number, row: any }`

----------------------------------------

TITLE: Entity Definition with WrappedEntity Interface
DESCRIPTION: Demonstrates how to define an entity class with the new WrappedEntity interface to maintain v2 functionality while using the new entity definition pattern.

LANGUAGE: typescript
CODE:
@Entity()
export class Book { ... }
export interface Book extends WrappedEntity<Book, 'id'> { }

----------------------------------------

TITLE: Defining Basic Entity Schema in TypeScript
DESCRIPTION: Demonstrates how to define a Book entity schema with relationships to Author, Publisher and BookTags using EntitySchema helper.

LANGUAGE: typescript
CODE:
export interface Book extends CustomBaseEntity {
  title: string;
  author: Author;
  publisher: Publisher;
  tags: Collection<BookTag>;
}

export const schema = new EntitySchema<Book, CustomBaseEntity>({
  name: 'Book',
  extends: CustomBaseEntitySchema,
  properties: {
    title: { type: 'string' },
    author: { kind: 'm:1', entity: 'Author', inversedBy: 'books' },
    publisher: { kind: 'm:1', entity: 'Publisher', inversedBy: 'books' },
    tags: { kind: 'm:n', entity: 'BookTag', inversedBy: 'books', fixedOrder: true },
  },
});

----------------------------------------

TITLE: Implementing Custom Type with Type Safety in TypeScript
DESCRIPTION: Example of creating a custom type that maps between a class and its database representation, using IType for improved type safety.

LANGUAGE: typescript
CODE:
class MyClass {
  constructor(private value: string) {}
}

class MyType extends Type<MyClass, string> {

  convertToDatabaseValue(value: MyClass): string {
    return value.value;
  }

  convertToJSValue(value: string): MyClass {
    return new MyClass(value);
  }

}

----------------------------------------

TITLE: Enabling Debug Mode in MikroORM
DESCRIPTION: Basic configuration to enable debug logging in MikroORM which outputs queries to console.log

LANGUAGE: typescript
CODE:
return MikroORM.init({
  debug: true,
});

----------------------------------------

TITLE: Installing MikroORM Website Dependencies with Yarn
DESCRIPTION: This command installs all necessary dependencies for the MikroORM website project using Yarn package manager.

LANGUAGE: bash
CODE:
$ yarn

----------------------------------------

TITLE: Initializing MikroORM with Manual Entity List
DESCRIPTION: Shows how to initialize MikroORM with a manually specified list of entities and disabled dynamic file access. This is useful for bundling with tools like Webpack.

LANGUAGE: typescript
CODE:
import { Author, Book, BookTag, Publisher, Test } from '../entities';

await MikroORM.init({
  ...
  entities: [Author, Book, BookTag, Publisher, Test],
  discovery: { disableDynamicFileAccess: true },
  ...
});

----------------------------------------

TITLE: Test Utilities Setup for MikroORM
DESCRIPTION: Helper function to initialize MikroORM with test-specific configuration including in-memory database

LANGUAGE: typescript
CODE:
import { bootstrap } from '../src/app.js';
import { initORM } from '../src/db.js';
import config from '../src/mikro-orm.config.js';

export async function initTestApp(port: number) {
  const { orm } = await initORM({
    ...config,
    debug: false,
    dbName: ':memory:',
  });

  await orm.schema.createSchema();
  await orm.seeder.seed(TestSeeder);

  const { app } = await bootstrap(port, false);

  return app;
}

----------------------------------------

TITLE: Persisting Entities with Relationships
DESCRIPTION: Example of creating and persisting entities with relationships using MikroORM's EntityManager.

LANGUAGE: typescript
CODE:
const author = new Author('Jon Snow', 'snow@wall.st');
author.born = new Date();

const publisher = new Publisher('7K publisher');

const book1 = new Book('My Life on The Wall, part 1', author);
book1.publisher = publisher;
const book2 = new Book('My Life on The Wall, part 2', author);
book2.publisher = publisher;
const book3 = new Book('My Life on The Wall, part 3', author);
book3.publisher = publisher;

// just persist books, author and publisher will be automatically cascade persisted
await em.persistAndFlush([book1, book2, book3]);

----------------------------------------

TITLE: Deep Object Merging with wrap().assign() in MikroORM
DESCRIPTION: Shows how to enable deep merging of object properties using the mergeObjects flag

LANGUAGE: typescript
CODE:
import { wrap } from 'mikro-orm';

book.meta = { foo: 1, bar: 2 };

wrap(book).assign({ meta: { foo: 3 } }, { mergeObjects: true });
console.log(book.meta); // { foo: 3, bar: 2 }

wrap(book).assign({ meta: { foo: 4 } });
console.log(book.meta); // { foo: 4 }

----------------------------------------

TITLE: Defining Optional Property with Default Value in MikroORM
DESCRIPTION: This snippet illustrates how to define an optional property with a default value in MikroORM, using the TypeScript optional property syntax.

LANGUAGE: typescript
CODE:
@Property({ default: 1 })
level?: number = 1;

----------------------------------------

TITLE: Using Fixed Mocks in Jest Tests with MikroORM
DESCRIPTION: This example demonstrates how to use the enableFakeTimersWithMikroOrm function in a Jest test to ensure compatibility between MikroORM and Jest's fake timers.

LANGUAGE: typescript
CODE:
import { initORM } from './db';// See "Project Setup"
import { enableFakeTimersWithMikroOrm } from './fakeTimersFixer'; // different based on your driver; see above

test(() => {
  const orm = initORM({
    //your test config
  });
  jest.useFakeTimers();
  const ormMock = enableFakeTimersWithMikroOrm();

  // write your tests normally

  ormMock.restoreMock();
  jest.useRealTimers();
});

----------------------------------------

TITLE: Defining Nested Embeddables with Profile and Identity
DESCRIPTION: This snippet shows how to create nested embeddables using Profile and Identity classes within a User entity.

LANGUAGE: typescript
CODE:
import { Embeddable, Embedded, Entity, PrimaryKey, Property } from '@mikro-orm/core';

@Entity()
export class User {

  @PrimaryKey()
  id!: number;

  @Property()
  name!: string;

  @Embedded(() => Profile, { object: true, nullable: true })
  profile?: Profile;

}

@Embeddable()
export class Profile {

  @Property()
  username: string;

  @Embedded(() => Identity)
  identity: Identity;

  constructor(username: string, identity: Identity) {
    this.username = username;
    this.identity = identity;
  }

}

@Embeddable()
export class Identity {

  @Property()
  email: string;

  constructor(email: string) {
    this.email = email;
  }

}

----------------------------------------

TITLE: Using MongoDB-specific EntityManager in TypeScript
DESCRIPTION: This example shows how to import and use the MongoDB-specific EntityManager to access MongoDB-specific methods like aggregate().

LANGUAGE: ts
CODE:
import { EntityManager } from '@mikro-orm/mongodb';

const em = orm.em as EntityManager;
const ret = await em.aggregate(...);

----------------------------------------

TITLE: Property Validation Examples in MikroORM with TypeScript
DESCRIPTION: Comprehensive examples showing how MikroORM handles different data type scenarios during entity persistence. Demonstrates automatic type conversion for valid formats and error throwing for invalid data types, including handling of dates, numbers, and null values.

LANGUAGE: typescript
CODE:
// number instead of string will throw
const author = new Author('test', 'test');
author.assign({ name: 111, email: 222 });
await orm.em.persistAndFlush(author); // throws "Validation error: trying to set Author.name of type 'string' to '111' of type 'number'"

// string date with unknown format will throw
author.assign(author, { name: '333', email: '444', born: 'asd' });
await orm.em.persistAndFlush(author); // throws "Validation error: trying to set Author.born of type 'date' to 'asd' of type 'string'"

// string date with correct format will be auto-corrected
author.assign({ name: '333', email: '444', born: '2018-01-01' });
await orm.em.persistAndFlush(author);
console.log(author.born).toBe(true); // instance of Date

// Date object will be ok
author.assign({ born: new Date() });
await orm.em.persistAndFlush(author);
console.log(author.born).toBe(true); // instance of Date

// null will be ok
author.assign({ born: null });
await orm.em.persistAndFlush(author);
console.log(author.born); // null

// string number with correct format will be auto-corrected
author.assign({ age: '21' });
await orm.em.persistAndFlush(author);
console.log(author.age); // number 21

// string instead of number with will throw
author.assign({ age: 'asd' });
await orm.em.persistAndFlush(author); // throws "Validation error: trying to set Author.age of type 'number' to 'asd' of type 'string'"
author.assign({ age: new Date() });
await orm.em.persistAndFlush(author); // throws "Validation error: trying to set Author.age of type 'number' to '2019-01-17T21:14:23.875Z' of type 'date'"
author.assign({ age: false });
await orm.em.persistAndFlush(author); // throws "Validation error: trying to set Author.age of type 'number' to 'false' of type 'boolean'"

----------------------------------------

TITLE: Configuring Custom Cache Adapter in MikroORM
DESCRIPTION: This code demonstrates how to configure a custom cache adapter (RedisCacheAdapter in this case) when initializing MikroORM. It uses the 'adapter' property of the 'metadataCache' option.

LANGUAGE: typescript
CODE:
await MikroORM.init({
  metadataCache: { adapter: RedisCacheAdapter, options: { ... } },
  // ...
});

----------------------------------------

TITLE: Entity Definition with WrappedEntity Interface
DESCRIPTION: Demonstrates how to define an entity class with WrappedEntity interface to maintain v2 functionality while using the new v3 entity system.

LANGUAGE: typescript
CODE:
@Entity()
export class Book { ... }
export interface Book extends WrappedEntity<Book, 'id'> { }

----------------------------------------

TITLE: Configuring Specific Logger Namespaces
DESCRIPTION: Setting up MikroORM to log only specific namespaces like queries while ignoring other debug information

LANGUAGE: typescript
CODE:
return MikroORM.init({
  debug: ['query'], // now only queries will be logged
});

----------------------------------------

TITLE: SQL Helper Functions in MikroORM
DESCRIPTION: Collection of specialized SQL helper functions including sql.ref(), sql.now(), sql.lower(), and sql.upper() for common SQL operations.

LANGUAGE: typescript
CODE:
@Property({ default: sql.now() })
createdAt: Date & Opt;

const books = await orm.em.find(Book, {
  [sql.upper('title')]: 'TITLE',
});

----------------------------------------

TITLE: Basic Embeddable and Entity Definition with TypeScript
DESCRIPTION: Demonstrates how to create a basic embeddable Address class and embed it in a User entity using different metadata providers (reflect-metadata, ts-morph, and EntitySchema).

LANGUAGE: typescript
CODE:
import { Embeddable, Embedded, Entity, PrimaryKey, Property } from '@mikro-orm/core';

@Embeddable()
export class Address {
  @Property()
  street!: string;

  @Property()
  postalCode!: string;

  @Property()
  city!: string;

  @Property()
  country!: string;
}

@Entity()
export class User {
  @PrimaryKey()
  id!: number;

  @Embedded(() => Address)
  address!: Address;
}

----------------------------------------

TITLE: Configuring Custom Cache Adapter in MikroORM (TypeScript)
DESCRIPTION: This code shows how to configure MikroORM to use a custom cache adapter (RedisCacheAdapter) during initialization. It sets the 'adapter' property of the 'cache' option.

LANGUAGE: typescript
CODE:
await MikroORM.init({
  cache: { adapter: RedisCacheAdapter, options: { ... } },
  // ...
});

----------------------------------------

TITLE: Importing MongoEntityManager for Aggregation in TypeScript
DESCRIPTION: This snippet demonstrates how to import the MongoDB-specific EntityManager to use the aggregate() method. This change is due to the separation of MongoDB functionality in v4.

LANGUAGE: typescript
CODE:
import { EntityManager } from '@mikro-orm/mongodb';

const em: EntityManager;
const ret = await em.aggregate(...);

----------------------------------------

TITLE: Implementing Custom SchemaHelper Class in TypeScript for MikroORM
DESCRIPTION: Extends the SchemaHelper class to provide information about how to build the database schema. Includes methods for handling identifiers, schema structure, and data types.

LANGUAGE: typescript
CODE:
import { SchemaHelper } from '@mikro-orm/core';

export class MyCustomSchemaHelper extends SchemaHelper {

  // here you can override default settings
  getIdentifierQuoteCharacter(): string;
  getSchemaBeginning(): string;
  getSchemaEnd(): string;
  getSchemaTableEnd(): string;
  getAutoIncrementStatement(meta: EntityMetadata): string;
  getPrimaryKeySubtype(meta: EntityMetadata): string;
  getTypeDefinition(prop: EntityProperty, types?: Record<string, string>, lengths?: Record<string, number>): string;
  getUnsignedSuffix(prop: EntityProperty): string;
  supportsSchemaConstraints(): boolean;
  supportsSchemaMultiAlter(): boolean;
  supportsSequences(): boolean;
  quoteIdentifier(field: string): string;
  dropTable(meta: EntityMetadata): string;
  indexForeignKeys(): boolean;

}

----------------------------------------

TITLE: Basic Embeddable and Entity Definition with TypeScript
DESCRIPTION: Demonstrates how to create a basic embeddable Address class and embed it in a User entity using different metadata providers (reflect-metadata, ts-morph, and EntitySchema).

LANGUAGE: typescript
CODE:
import { Embeddable, Embedded, Entity, PrimaryKey, Property } from '@mikro-orm/core';

@Embeddable()
export class Address {
  @Property()
  street!: string;

  @Property()
  postalCode!: string;

  @Property()
  city!: string;

  @Property()
  country!: string;
}

@Entity()
export class User {
  @PrimaryKey()
  id!: number;

  @Embedded(() => Address)
  address!: Address;
}

----------------------------------------

TITLE: Performing LIKE Queries with Regular Expressions
DESCRIPTION: Example of using regular expressions to perform LIKE queries in SQL databases with MikroORM.

LANGUAGE: typescript
CODE:
const author1 = new Author2('Author 1', 'a1@example.com');
const author2 = new Author2('Author 2', 'a2@example.com');
const author3 = new Author2('Author 3', 'a3@example.com');
await orm.em.persistAndFlush([author1, author2, author3]);

// finds authors with email like '%exa%le.c_m'
const authors = await orm.em.find(Author2, { email: /exa.*le\.c.m$/ });
console.log(authors); // all 3 authors found

----------------------------------------

TITLE: Programmatic Schema Generation with MikroORM
DESCRIPTION: TypeScript example demonstrating how to programmatically generate, view, and execute schema changes using MikroORM's SchemaGenerator. Shows methods for getting SQL dumps and directly executing schema changes.

LANGUAGE: typescript
CODE:
import { MikroORM } from 'mikro-orm';

(async () => {
  const orm = await MikroORM.init({
    entities: [Author, Book, ...],
    dbName: 'your-db-name',
    // ...
  });
  const generator = orm.getSchemaGenerator();

  const dropDump = await generator.getDropSchemaSQL();
  console.log(dropDump);

  const createDump = await generator.getCreateSchemaSQL();
  console.log(createDump);

  const updateDump = await generator.getUpdateSchemaSQL();
  console.log(updateDump);

  // there is also `generate()` method that returns drop + create queries
  const dropAndCreateDump = await generator.generate();
  console.log(dropAndCreateDump);

  // or you can run those queries directly, but be sure to check them first!
  await generator.dropSchema();
  await generator.createSchema();
  await generator.updateSchema();

  await orm.close(true);
})();

----------------------------------------

TITLE: Custom User Repository Implementation
DESCRIPTION: Extended repository class with custom methods for user authentication and validation

LANGUAGE: typescript
CODE:
export class UserRepository extends EntityRepository<User> {

  async exists(email: string) {
    const count = await this.count({ email });
    return count > 0;
  }

  async login(email: string, password: string) {
    const err = new AuthError('Invalid combination of email and password');
    const user = await this.findOneOrFail({ email }, {
      populate: ['password'],
      failHandler: () => err,
    });

    if (await user.verifyPassword(password)) {
      return user;
    }

    throw err;
  }
}

----------------------------------------

TITLE: Accessing Driver-Specific Methods in MikroORM
DESCRIPTION: Example of how to access driver-specific methods like createQueryBuilder() by importing from the driver package or casting the EntityManager.

LANGUAGE: typescript
CODE:
import { EntityManager } from '@mikro-orm/postgresql';
const em = orm.em as EntityManager;
const qb = em.createQueryBuilder(...);

----------------------------------------

TITLE: Configuring Jest Fake Timers for MikroORM
DESCRIPTION: Sets up Jest fake timers to exclude process.nextTick() from being mocked, allowing MikroORM to function correctly with timer mocks.

LANGUAGE: typescript
CODE:
jest.useFakeTimers({ doNotFake: ['nextTick'] });

----------------------------------------

TITLE: SQLite Bug Fix Commit Message
DESCRIPTION: Fix for SQLite to prevent directory creation when dbName is ':memory:' or URL

LANGUAGE: markdown
CODE:
* **sqlite:** do not ensure directory exists when `dbName` is `:memory:` or URL ([b0f97ed](https://github.com/mikro-orm/mikro-orm/commit/b0f97ed9408d021046a0ee50fb5dbf9d98d72f3e)), closes [#6533](https://github.com/mikro-orm/mikro-orm/issues/6533)

----------------------------------------

TITLE: Shadow Properties Implementation
DESCRIPTION: Shows how to create non-persisted properties that only exist in memory using persist: false option.

LANGUAGE: typescript
CODE:
@Entity()
class Book {

  @Property({ persist: false })
  count?: number;

}

----------------------------------------

TITLE: MikroORM Lifecycle Hook Decorators
DESCRIPTION: Decorators for implementing entity lifecycle hooks in MikroORM. These hooks allow executing code before and after create, update, and delete operations. All hooks support asynchronous methods and can be applied to multiple methods within an entity.

LANGUAGE: typescript
CODE:
@BeforeCreate()
@BeforeUpdate()
@AfterCreate()
@AfterUpdate()
@BeforeDelete()
@AfterDelete()

----------------------------------------

TITLE: SQL Case Conversion Functions
DESCRIPTION: Examples of using sql.lower() and sql.upper() functions for case conversion in queries.

LANGUAGE: typescript
CODE:
const books = await orm.em.find(Book, {
  [sql.upper('title')]: 'TITLE',
});

----------------------------------------

TITLE: Implementing Declarative Referential Integrity in MikroORM
DESCRIPTION: This snippet shows how to define database-level referential integrity actions in MikroORM using the updateRule and deleteRule options. These control the on update and on delete behaviors at the database level.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @ManyToOne({ updateRule: 'set null', deleteRule: 'cascade' })
  author?: Author;

}

----------------------------------------

TITLE: Creating Entities with Default Schema in MikroORM
DESCRIPTION: This snippet shows how to create an entity using a forked EntityManager with a default schema. It demonstrates that the fork will automatically set the default schema when persisting new entities.

LANGUAGE: typescript
CODE:
const fork = em.fork({ schema: 'client-123' });
const user = new User();
user.email = 'foo@bar.com';
await fork.persist(user).flush();

// Will yield the same result as
const qb = em.createQueryBuilder(User);
await qb.insert({ email: 'foo@bar.com' }).withSchema('client-123');

----------------------------------------

TITLE: Defining Entity Interface with Serialization Methods
DESCRIPTION: Interface definition showing the default serialization methods added to all entities through monkey patching.

LANGUAGE: typescript
CODE:
export interface IEntity<K = number | string> {
  toObject(parent?: IEntity, isCollection?: boolean): Record<string, any>;
  toJSON(...args: any[]): Record<string, any>;
  // ...
}

----------------------------------------

TITLE: Implementing RequestContext Middleware
DESCRIPTION: Example of setting up RequestContext middleware for request-scoped EntityManager instances

LANGUAGE: typescript
CODE:
app.use((req, res, next) => {
  // calls `orm.em.fork()` and attaches it to the async context
  RequestContext.create(orm.em, next);
});

app.get('/', async (req, res) => {
  // uses fork from the async context automatically
  const authors = await orm.em.find(Book, {});
  res.json(authors);
});

----------------------------------------

TITLE: Using Result Cache with MikroORM QueryBuilder
DESCRIPTION: Shows how to enable result caching when using the QueryBuilder in MikroORM.

LANGUAGE: typescript
CODE:
const res = await em.createQueryBuilder(Book)
  .where({ author: { name: 'Jon Snow' } })
  .cache()
  .getResultList();

----------------------------------------

TITLE: Entity Property Type Definitions with ReflectMetadataProvider
DESCRIPTION: Examples of proper type definitions when using ReflectMetadataProvider, including collections, references, optional properties, and enums.

LANGUAGE: typescript
CODE:
@Property()
createdAt: Date = new Date();

@OneToMany(() => Book, b => b.author)
books = new Collection<Book>(this);

@ManyToOne(() => Publisher, { ref: true })
publisher!: Ref<Publisher>;

@Property({ nullable: true })
prop?: string;

@Enum(() => UserRole)
role: UserRole;

@Enum({ type: 'UserRole' })
role: UserRole;

@Enum({ items: ['a', 'b', 'c'] })
role: UserRole;

@ManyToOne({ entity: () => Author })
author: Author;

----------------------------------------

TITLE: Defining Relationships with @ManyToOne Decorator in TypeScript
DESCRIPTION: Examples of using the @ManyToOne decorator to define many-to-one relationships in entities.

LANGUAGE: typescript
CODE:
@ManyToOne()
author1?: Author; // type taken via reflection (TsMorphMetadataProvider)

@ManyToOne(() => Author) // explicit type
author2?: Author;

@ManyToOne({ entity: () => Author, cascade: [Cascade.ALL] }) // options object
author3?: Author;

----------------------------------------

TITLE: Configuring Cascade Options in TypeScript with MikroORM
DESCRIPTION: Examples of different cascade configurations for OneToMany relationships showing how to control persist, merge and remove operations.

LANGUAGE: typescript
CODE:
// cascade persist & merge is default value
@OneToMany({ entity: () => Book, mappedBy: 'author' })
books = new Collection<Book>(this);

// same as previous definition
@OneToMany({ entity: () => Book, mappedBy: 'author', cascade: [Cascade.PERSIST, Cascade.MERGE] })
books = new Collection<Book>(this);

// only cascade remove
@OneToMany({ entity: () => Book, mappedBy: 'author', cascade: [Cascade.REMOVE] })
books = new Collection<Book>(this);

// cascade persist and remove (but not merge)
@OneToMany({ entity: () => Book, mappedBy: 'author', cascade: [Cascade.PERSIST, Cascade.REMOVE] })
books = new Collection<Book>(this);

// no cascade
@OneToMany({ entity: () => Book, mappedBy: 'author', cascade: [] })
books = new Collection<Book>(this);

// cascade all (persist, merge and remove)
@OneToMany({ entity: () => Book, mappedBy: 'author', cascade: [Cascade.ALL] })
books = new Collection<Book>(this);

// same as previous definition
@OneToMany({ entity: () => Book, mappedBy: 'author', cascade: [Cascade.PERSIST, Cascade.MERGE, Cascade.REMOVE] })
books = new Collection<Book>(this);

----------------------------------------

TITLE: Advanced EntityGenerator Configuration
DESCRIPTION: Example showing advanced configuration options for EntityGenerator including schema settings and custom formatting options.

LANGUAGE: typescript
CODE:
const dump = await orm.entityGenerator.generate({
  entitySchema: true,
  bidirectionalRelations: true,
  identifiedReferences: true,
  esmImport: true,
  save: true,
  path: process.cwd() + '/my-entities',
  skipTables: ['book', 'author'],
  skipColumns: {
    'public.user': ['email', 'middle_name'],
  },
});

----------------------------------------

TITLE: Setting up MikroORM with Express and AdminJS
DESCRIPTION: TypeScript implementation for integrating MikroORM with Express and AdminJS, including database initialization and router setup.

LANGUAGE: typescript
CODE:
import AdminJS from 'adminjs';
import { Database, Resource } from '@adminjs/mikroorm';
import AdminJSExpress from '@adminjs/express';
import { MikroORM } from '@mikro-orm/postgresql';
import { validate } from 'class-validator'; // optional

const PORT = process.env.PORT ?? 3000;

const run = async () => {
  /* Initialize MikroORM like you would do normally, you can also import your MikroORM instance from a separate file */
  const orm = await MikroORM.init({
    entities: [User, Car, Seller], // use your own entities
    dbName: process.env.DATABASE_NAME,
    clientUrl: process.env.DATABASE_URL,
  });

  /* Optional: if you're using class-validator, assign it to Resource */
  Resource.validate = validate;
  /* Tell AdminJS which adapter to use */
  AdminJS.registerAdapter({ Database, Resource });

  const app = express();

  /* Create AdminJS instance */
  const admin = new AdminJS({
    databases: [orm],
  });

  const router = AdminJSExpress.buildRouter(admin);

  app.use(admin.options.rootPath, router);

  app.listen(PORT, () => {
    console.log(`App listening at http://localhost:${PORT}`);
  });
}

run();

----------------------------------------

TITLE: Defining ManyToOne Relationships in TypeScript with MikroORM
DESCRIPTION: Demonstrates different ways to define ManyToOne relationships using decorators. Shows how to specify entity types through reflection, callbacks, strings, or option objects.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @ManyToOne() // plain decorator is enough, type will be sniffer via reflection!
  author1!: Author;

  @ManyToOne(() => Author) // you can specify type manually as a callback
  author2!: Author;

  @ManyToOne('Author') // or as a string
  author3!: Author;

  @ManyToOne({ entity: () => Author }) // or use options object
  author4!: Author;

}

----------------------------------------

TITLE: Example Test Implementation
DESCRIPTION: Example showing how to use the timer mock configurations in a Jest test file.

LANGUAGE: typescript
CODE:
import { initORM } from './db';
import { enableFakeTimersWithMikroOrm } from './fakeTimersFixer';

test(() => {
  const orm = initORM({
    //your test config
  });
  jest.useFakeTimers();
  const ormMock = enableFakeTimersWithMikroOrm();

  // write your tests normally

  ormMock.restoreMock();
  jest.useRealTimers();
});

----------------------------------------

TITLE: Initializing MikroORM with MongoDB Driver
DESCRIPTION: Shows how to initialize MikroORM with MongoDB driver and access the EntityManager. Requires @mikro-orm/mongodb dependency.

LANGUAGE: typescript
CODE:
import { MikroORM } from '@mikro-orm/mongodb'; // or any other driver package

const orm = await MikroORM.init({
  entities: [Author, Book, ...],
  dbName: 'my-db-name',
  clientUrl: '...',
});
console.log(orm.em); // access EntityManager via `em` property

----------------------------------------

TITLE: Using Composite Primary Key Entity in MikroORM
DESCRIPTION: This snippet shows how to persist an entity with a composite primary key and how to query for it using MikroORM's EntityManager.

LANGUAGE: typescript
CODE:
const car = new Car('Audi A8', 2010);
await em.persist(car).flush();

const audi1 = await em.findOneOrFail(Car, { name: 'Audi A8', year: 2010 });
const audi2 = await em.findOneOrFail(Car, ['Audi A8', 2010]);

----------------------------------------

TITLE: Serialization Groups Implementation
DESCRIPTION: Example of using serialization groups to control property visibility during serialization.

LANGUAGE: typescript
CODE:
@Entity()
class User {

  @PrimaryKey()
  id!: number;

  @Property()
  username!: string;

  @Property({ groups: ['public', 'private'] })
  name!: string;

  @Property({ groups: ['private'] })
  email!: string;

}

----------------------------------------

TITLE: Disabling Metadata Cache in MikroORM (TypeScript)
DESCRIPTION: This snippet shows how to disable metadata caching when initializing MikroORM. It sets the 'enabled' property of the 'cache' option to false.

LANGUAGE: typescript
CODE:
await MikroORM.init({
  cache: { enabled: false },
  // ...
});

----------------------------------------

TITLE: Configuring Babel plugins for MikroORM compatibility
DESCRIPTION: This configuration enables proper handling of decorator metadata in Babel when used with MikroORM. It includes necessary plugins for TypeScript metadata transformation and decorator support.

LANGUAGE: json
CODE:
{
  "plugins": [
    "babel-plugin-transform-typescript-metadata",
    ["@babel/plugin-proposal-decorators", { "legacy": true }],
    ["@babel/plugin-proposal-class-properties", { "loose": true  }]
  ]
}

----------------------------------------

TITLE: Generating SQL Schema for Mapped Superclasses in SQLite
DESCRIPTION: This SQL snippet shows the DDL for creating the database schema corresponding to the mapped superclass example. It demonstrates how all mappings from the superclass are inherited by the subclass in a single table.

LANGUAGE: sql
CODE:
create table `employee` (
  `id` int unsigned not null auto_increment primary key,
  `name` varchar(255) not null, `mapped1` integer not null,
  `mapped2` varchar(255) not null,
  `toothbrush_id` integer not null
);

----------------------------------------

TITLE: Deep Merging Object Properties with assign() in TypeScript
DESCRIPTION: Shows how to enable deep merging of object properties using the mergeObjectProperties flag in assign().

LANGUAGE: typescript
CODE:
import { wrap } from '@mikro-orm/core';

book.meta = { foo: 1, bar: 2 };

wrap(book).assign({ meta: { foo: 3 } }, { mergeObjectProperties: true });
console.log(book.meta); // { foo: 3, bar: 2 }

wrap(book).assign({ meta: { foo: 4 } });
console.log(book.meta); // { foo: 4 }

----------------------------------------

TITLE: Inferring Populate Hint from Filter in MikroORM with TypeScript
DESCRIPTION: This snippet demonstrates how to automatically select all relations that are part of the filter query using '$infer'. It populates all books and their authors via a single query.

LANGUAGE: typescript
CODE:
const tags = await em.find(BookTag, {
  books: { author: { name: '...' } },
}, {
  populate: ['$infer'],
});

----------------------------------------

TITLE: Demonstrating Automatic Entity Refreshing in MikroORM 5
DESCRIPTION: This code snippet illustrates the new automatic refreshing behavior of loaded entities in MikroORM 5. It shows how entities are automatically updated when reloaded with additional fields or full population, without the need for explicit refresh options.

LANGUAGE: typescript
CODE:
// first partially load author with `id` and `email` only
const a1 = await em.findOneOrFail(Author, 123, { fields: ['id', 'email'] });
a1.email = 'lol'; // let's change the email

// reloading with same fields won't fire the query (as before)
const a2 = await em.findOneOrFail(Author, 123, { fields: ['email'] });
console.log(a1 === a2); // true, same entity instance, no query was fired

// reloading with additional fields will work without `refresh: true`
const a3 = await em.findOneOrFail(Author, 123, { fields: ['id', 'age'] });
console.log(a1 === a3); // true, same entity instance, but updated!
console.log(a1.age); // new values are loaded
a1.age = 1000; // let's override them

// reloading full entity will work without `refresh: true`
const a4 = await em.findOneOrFail(Author, 123, { populate: ['books'] });
console.log(a1 === a4); // true, same entity instance, but updated!
console.log(a1.termsAccepted); // new values are loaded

await em.flush(); // updates the author with new email and age

----------------------------------------

TITLE: Filtering and Ordering Collections in TypeScript with MikroORM
DESCRIPTION: Demonstrates how to filter and order collection items when initializing them. It also shows how to use the matching method for slicing data from a collection.

LANGUAGE: typescript
CODE:
await book.tags.init({ where: { active: true }, orderBy: { name: QueryOrder.DESC } });

const a = await em.findOneOrFail(Author, 1);

// only loading the list of items
const books = await a.books.matching({ limit: 3, offset: 10, orderBy: { title: 'asc' } });
console.log(books); // [Book, Book, Book]
console.log(a.books.isInitialized()); // false

// storing the items in collection
const tags = await books[0].tags.matching({
  limit: 3,
  offset: 5,
  orderBy: { name: 'asc' },
  store: true,
});
console.log(tags); // [BookTag, BookTag, BookTag]
console.log(books[0].tags.isInitialized()); // true
console.log(books[0].tags.getItems()); // [BookTag, BookTag, BookTag]

----------------------------------------

TITLE: One-to-Many Collection Addition Propagation in MikroORM
DESCRIPTION: Shows how adding a book to an author's collection automatically sets the reverse relationship. When a book is added to an author's collection, the book's author property is automatically set.

LANGUAGE: typescript
CODE:
// one to many
const author = new Author(...);
const book = new Book(...);

author.books.add(book);
console.log(book.author); // author will be set thanks to the propagation

----------------------------------------

TITLE: Initializing Entity References in TypeScript with MikroORM
DESCRIPTION: Demonstrates how to work with entity references in MikroORM, including checking initialization status and lazy loading of entity data. Shows how to access entity ID without triggering database calls and how to fully initialize an entity when needed.

LANGUAGE: typescript
CODE:
const author = orm.em.getReference('...id...');
console.log(author.id); // accessing the id will not trigger any db call
console.log(author.isInitialized()); // false
console.log(author.name); // undefined

await author.init(); // this will trigger db call
console.log(author.isInitialized()); // true
console.log(author.name); // defined

----------------------------------------

TITLE: Defining ManyToOne Reference with TypeScript Decorator
DESCRIPTION: Example of defining a ManyToOne relationship using the Reference wrapper in an entity class.

LANGUAGE: typescript
CODE:
@ManyToOne(() => Book, { ref: true })
book!: Ref<Book>;

----------------------------------------

TITLE: Using Reference Load Method in MikroORM
DESCRIPTION: This code demonstrates how to use the Reference.load() method to asynchronously load the full entity in MikroORM. It shows how to safely access properties of a lazily loaded entity.

LANGUAGE: typescript
CODE:
const book1 = await em.findOne(Book, 1);
(await book1.author.load()).name; // async safe access

const book2 = await em.findOne(Book, 2);
const author = await book2.author.load();
author.name;
await book2.author.load(); // no additional query, already loaded

----------------------------------------

TITLE: Creating Custom Repository Class
DESCRIPTION: Shows how to create a custom repository by extending EntityRepository with additional methods for specific entity types.

LANGUAGE: typescript
CODE:
import { EntityRepository } from '@mikro-orm/mysql'; // or any other driver package

export class CustomAuthorRepository extends EntityRepository<Author> {

  // custom methods...
  public findAndUpdate(...) {
    // ...
  }

}

----------------------------------------

TITLE: Defining Book Entity with EntitySchema
DESCRIPTION: Example of defining a Book entity using the EntitySchema helper. Shows how to define properties and relationships programmatically.

LANGUAGE: typescript
CODE:
export interface IBook extends CustomBaseEntity {
  title: string;
  author: Author;
  publisher?: Ref<Publisher>;
  tags: Collection<BookTag>;
}

export const Book = new EntitySchema<IBook, CustomBaseEntity>({
  name: 'Book',
  extends: 'CustomBaseEntity',
  properties: {
    title: { type: 'string' },
    author: { kind: 'm:1', entity: 'Author' },
    publisher: { kind: 'm:1', entity: 'Publisher', ref: true, nullable: true },
    tags: { kind: 'm:n', entity: 'BookTag', fixedOrder: true },
  },
});

----------------------------------------

TITLE: Defining Author Entity with Collections in TypeScript
DESCRIPTION: Example of defining an Author entity with various property types including arrays, dates, and OneToMany relationships. Demonstrates usage of Collections and standard property types.

LANGUAGE: typescript
CODE:
@Entity()
export class Author {

  @PrimaryKey()
  _id: ObjectID;

  @Property()
  createdAt = new Date();

  @Property({ onUpdate: () => new Date() })
  updatedAt = new Date();

  @Property()
  name: string;

  @Property()
  email: string;

  @Property()
  age: number;

  @Property()
  termsAccepted = false;

  @Property()
  identities: string[];

  @Property()
  born: Date;

  @OneToMany({ entity: () => Book, mappedBy: 'author' })
  books = new Collection<Book>(this);

  @ManyToOne()
  favouriteBook: Book;

  version: number;
  versionAsString: string;

  constructor(name: string, email: string) {
    this.name = name;
    this.email = email;
  }

}

export interface Author extends IEntity { }

----------------------------------------

TITLE: Filtered Populate Query with PopulateHint in MikroORM (TypeScript)
DESCRIPTION: Shows how to use PopulateHint to control the behavior of populate queries when filtering on populated entities.

LANGUAGE: typescript
CODE:
const books = await em.find(Book, { tags: { name: 'Fiction' } }, {
  populate: ['tags'],
  populateWhere: PopulateHint.INFER,
});

----------------------------------------

TITLE: Configuring Custom Logger Function
DESCRIPTION: Shows how to implement a custom logger function for MikroORM initialization.

LANGUAGE: typescript
CODE:
return MikroORM.init({
  debug: true,
  logger: msg => myCustomLogger.log(msg),
});

----------------------------------------

TITLE: Implicit Transaction Handling in MikroORM
DESCRIPTION: Demonstrates the basic implicit transaction handling where MikroORM automatically manages transaction boundaries during entity persistence operations.

LANGUAGE: typescript
CODE:
const user = new User(...);
user.name = 'George';
await orm.em.persistAndFlush(user);

----------------------------------------

TITLE: Implicit Transactions in MikroORM with TypeScript
DESCRIPTION: This example demonstrates MikroORM's implicit transaction handling. It shows how changes to entities, including new associations, are automatically handled within a transaction when flushing.

LANGUAGE: typescript
CODE:
const user = await em.findOne(User, 1);
user.email = 'foo@bar.com';
const car = new Car();
user.cars.add(car);

// thanks to bi-directional cascading we only need to persist user entity
// flushing will create a transaction, insert new car and update user with new email
await em.persistAndFlush(user);

----------------------------------------

TITLE: Creating a Basic Migration Class in TypeScript
DESCRIPTION: This example demonstrates how to create a simple migration class that extends the Migration abstract class and implements the 'up' method.

LANGUAGE: typescript
CODE:
import { Migration } from '@mikro-orm/migrations';

export class Migration20191019195930 extends Migration {

  async up(): Promise<void> {
    this.addSql('select 1 + 1');
  }

}

----------------------------------------

TITLE: Searching by Referenced Entity Fields in MikroORM
DESCRIPTION: Shows how to search entities by referenced entity properties, automatically joining the necessary relationships.

LANGUAGE: typescript
CODE:
// find author of a book that has tag specified by name
const author = await orm.em.findOne(Author, { books: { tags: { name: 'Tag name' } } });
console.log(author.books.isInitialized()); // false, as it only works for query and sort

const author = await orm.em.findOne(Author, { books: { tags: { name: 'Tag name' } } }, ['books.tags']);
console.log(author.books.isInitialized()); // true, because it was populated
console.log(author.books[0].tags.isInitialized()); // true, because it was populated
console.log(author.books[0].tags[0].isInitialized()); // true, because it was populated

----------------------------------------

TITLE: Using Nested Queries in MikroORM 3
DESCRIPTION: Demonstrates how to use nested where conditions in MikroORM 3, allowing querying by properties of related entities with automatic joining.

LANGUAGE: typescript
CODE:
const book = await orm.em.findOne(Book, {
  author: {
    name: 'Jon Snow',
    address: {
      street: 'Downing Street',
    },
  },
}, ['author.address']);

console.log(book.author.name); // 'Jon Snow'
console.log(book.author.address.street); // 'Downing Street'

----------------------------------------

TITLE: Basic Database Seeder Implementation
DESCRIPTION: Example of a basic seeder class implementation with EntityManager for creating database records.

LANGUAGE: typescript
CODE:
import { EntityManager } from '@mikro-orm/core';
import { Seeder } from '@mikro-orm/seeder';
import { Author } from './author'

export class DatabaseSeeder extends Seeder {

  async run(em: EntityManager): Promise<void> {
    // will get persisted automatically
    const author = em.create(Author, {
      name: 'John Snow',
      email: 'snow@wall.st'
    });
  }
}

----------------------------------------

TITLE: Assign with EntityManager for Unmanaged Entities
DESCRIPTION: Demonstrates using assign() with explicit EntityManager for unmanaged entities

LANGUAGE: typescript
CODE:
import { wrap } from '@mikro-orm/core';

const book = new Book();
wrap(book).assign({
  title: 'Better Book 1',
  author: '...id...',
}, { em });

----------------------------------------

TITLE: Querying Nested Relationships in MikroORM with TypeScript
DESCRIPTION: This snippet demonstrates how to use nested populate in MikroORM to efficiently load related entities across multiple levels of relationships.

LANGUAGE: typescript
CODE:
const tags = await orm.em.findAll(BookTag, ['books.publisher.tests', 'books.author']);
console.log(tags[0].books[0].publisher.tests[0].name); // prints name of nested test
console.log(tags[0].books[0].author.name); // prints name of nested author

----------------------------------------

TITLE: Using Car Entity with Composite Primary Key in TypeScript
DESCRIPTION: This snippet shows how to create a new Car entity instance and persist it to the database using MikroORM. It also demonstrates two ways of querying for a Car entity using its composite primary key.

LANGUAGE: typescript
CODE:
const car = new Car('Audi A8', 2010);
await em.persist(car).flush();

const audi1 = await em.findOneOrFail(Car, { name: 'Audi A8', year: 2010 });
const audi2 = await em.findOneOrFail(Car, ['Audi A8', 2010]);

----------------------------------------

TITLE: Using Loaded Type for Type-Safe Access in MikroORM
DESCRIPTION: This snippet demonstrates how to use the Loaded type in MikroORM for type-safe access to populated relations. It shows how to use the $ symbol for synchronous access to loaded properties.

LANGUAGE: typescript
CODE:
// res is of type `Loaded<User, 'identity'>`
const user = await em.findOneOrFail(User, 1, { populate: ['identity'] });

// instead of the async `await user.identity.load()` call that would ensure the relation is loaded
// you can use the dynamically added `$` symbol for synchronous and type-safe access to it:
console.log(user.identity.$.email);

----------------------------------------

TITLE: Using MongoEntityManager in MikroORM v4
DESCRIPTION: Shows how to import and use the MongoEntityManager (aliased as EntityManager) from the MongoDB driver package to access the aggregate() method in MikroORM v4.

LANGUAGE: typescript
CODE:
import { EntityManager } from '@mikro-orm/mongodb';

const em: EntityManager;
const ret = await em.aggregate(...);

----------------------------------------

TITLE: Custom Entity Serialization Implementation
DESCRIPTION: Example of implementing custom toJSON method in a Book entity with property stripping functionality.

LANGUAGE: typescript
CODE:
@Entity()
class Book {

  // ...

  toJSON(strict = true, strip = ['id', 'email'], ...args: any[]): { [p: string]: any } {
    const o = wrap(this, true).toObject(...args); // do not forget to pass rest params here

    if (strict) {
      strip.forEach(k => delete o[k]);
    }

    return o;
  }

}

----------------------------------------

TITLE: Using Hidden Type for Hidden Properties in MikroORM
DESCRIPTION: This snippet shows an alternative way to define hidden properties in a MikroORM entity using the Hidden type. It can be used with generics or intersections.

LANGUAGE: typescript
CODE:
@Entity()
class Book {

  @Property({ hidden: true })
  hiddenField: Hidden<Date> = Date.now();

  @Property({ hidden: true, nullable: true })
  otherHiddenField?: string & Hidden;

}

----------------------------------------

TITLE: Basic QueryBuilder Usage in TypeScript
DESCRIPTION: Demonstrates how to create and execute a basic update query using QueryBuilder with parameter binding and execution.

LANGUAGE: typescript
CODE:
const qb = orm.em.createQueryBuilder(Author);
qb.update({ name: 'test 123', type: PublisherType.GLOBAL }).where({ id: 123, type: PublisherType.LOCAL });

console.log(qb.getQuery());
// UPDATE `publisher2` SET `name` = ?, `type` = ? WHERE `id` = ? AND `type` = ?

console.log(qb.getParams());
// ['test 123', PublisherType.GLOBAL, 123, PublisherType.LOCAL]

// run the query
const res1 = await qb.execute();

----------------------------------------

TITLE: Default Entity Serialization Interface in TypeScript
DESCRIPTION: Defines the base interface for entity serialization methods that are monkey-patched onto all entities.

LANGUAGE: typescript
CODE:
interface AnyEntity<K = number | string> {
  toObject(parent?: AnyEntity, isCollection?: boolean): Record<string, any>;
  toJSON(...args: any[]): Record<string, any>;
  // ...
}

----------------------------------------

TITLE: Using MongoEntityManager in MikroORM v4
DESCRIPTION: Shows how to import and use the MongoEntityManager (aliased as EntityManager) from the MongoDB driver package to access the aggregate() method in MikroORM v4.

LANGUAGE: typescript
CODE:
import { EntityManager } from '@mikro-orm/mongodb';

const em: EntityManager;
const ret = await em.aggregate(...);

----------------------------------------

TITLE: Creating Entities in Specific Schemas with MikroORM QueryBuilder
DESCRIPTION: This snippet illustrates how to create an entity in a specific schema using QueryBuilder. It uses the withSchema method to specify the schema for the insert operation.

LANGUAGE: typescript
CODE:
const qb = em.createQueryBuilder(User);
await qb.insert({ email: 'foo@bar.com' }).withSchema('client-123');

----------------------------------------

TITLE: Configuring MikroORM Migrations
DESCRIPTION: Configuration options for MikroORM migrations, including table name, paths, glob pattern, and various behavioral flags.

LANGUAGE: typescript
CODE:
await MikroORM.init({
  // default values:
  migrations: {
    tableName: 'mikro_orm_migrations', // name of database table with log of executed transactions
    path: './migrations', // path to the folder with migrations
    pathTs: undefined, // path to the folder with TS migrations (if used, we should put path to compiled files in `path`)
    glob: '!(*.d).{js,ts}', // how to match migration files (all .js and .ts files, but not .d.ts)
    transactional: true, // wrap each migration in a transaction
    disableForeignKeys: true, // wrap statements with `set foreign_key_checks = 0` or equivalent
    allOrNothing: true, // wrap all migrations in master transaction
    dropTables: true, // allow to disable table dropping
    safe: false, // allow to disable table and column dropping
    snapshot: true, // save snapshot when creating new migrations
    emit: 'ts', // migration generation mode
    generator: TSMigrationGenerator, // migration generator, e.g. to allow custom formatting
  },
})

----------------------------------------

TITLE: Strict Property Validation Examples in MikroORM
DESCRIPTION: Shows various examples of property validation including type conversion and error cases during entity persistence.

LANGUAGE: typescript
CODE:
// number instead of string will throw
const author = new Author('test', 'test');
wrap(author).assign({ name: 111, email: 222 });
await orm.em.persist(author).flush(); // throws "Validation error: trying to set Author.name of type 'string' to '111' of type 'number'"

// string date with unknown format will throw
wrap(author).assign(author, { name: '333', email: '444', born: 'asd' });
await orm.em.persist(author).flush(); // throws "Validation error: trying to set Author.born of type 'date' to 'asd' of type 'string'"

// string date with correct format will be auto-corrected
wrap(author).assign({ name: '333', email: '444', born: '2018-01-01' });
await orm.em.persist(author).flush();
console.log(author.born).toBe(true); // instance of Date

// Date object will be ok
wrap(author).assign({ born: new Date() });
await orm.em.persist(author).flush();
console.log(author.born).toBe(true); // instance of Date

// null will be ok
wrap(author).assign({ born: null });
await orm.em.persist(author).flush();
console.log(author.born); // null

// string number with correct format will be auto-corrected
wrap(author).assign({ age: '21' });
await orm.em.persist(author).flush();
console.log(author.age); // number 21

// string instead of number with will throw
wrap(author).assign({ age: 'asd' });
await orm.em.persist(author).flush(); // throws "Validation error: trying to set Author.age of type 'number' to 'asd' of type 'string'"
wrap(author).assign({ age: new Date() });
await orm.em.persist(author).flush(); // throws "Validation error: trying to set Author.age of type 'number' to '2019-01-17T21:14:23.875Z' of type 'date'"
wrap(author).assign({ age: false });
await orm.em.persist(author).flush(); // throws "Validation error: trying to set Author.age of type 'number' to 'false' of type 'boolean'"

----------------------------------------

TITLE: Custom Base Entity Definition
DESCRIPTION: Example of creating a reusable base entity class with common properties like UUID and timestamps.

LANGUAGE: typescript
CODE:
import { v4 } from 'uuid';

export abstract class CustomBaseEntity {
  @PrimaryKey()
  uuid = v4();

  @Property()
  createdAt = new Date();

  @Property({ onUpdate: () => new Date() })
  updatedAt = new Date();
}

----------------------------------------

TITLE: Calling Multiple Seeders in MikroORM
DESCRIPTION: Shows how to call multiple seeder classes within a main seeder using the call method.

LANGUAGE: typescript
CODE:
import { EntityManager } from '@mikro-orm/core';
import { Seeder } from '@mikro-orm/seeder';
import { AuthorSeeder, BookSeeder } from '../seeders'

export class DatabaseSeeder extends Seeder {

  run(em: EntityManager): Promise<void> {
    return this.call(em, [
      AuthorSeeder,
      BookSeeder,
    ]);
  }
}

----------------------------------------

TITLE: Primary Key Lookup in MikroORM TypeScript
DESCRIPTION: This snippet shows how to perform a primary key lookup in MikroORM by providing an array directly to the em.find() method.

LANGUAGE: typescript
CODE:
const res = await orm.em.find(Author, [1, 2, 7]);

----------------------------------------

TITLE: Fetching Partial Entity Fields
DESCRIPTION: Demonstrates how to fetch only specific fields of an entity using the fields option.

LANGUAGE: typescript
CODE:
const author = await orm.em.findOne(Author, '...', { fields: ['name', 'born'] });
console.log(author.id); // PK is always selected
console.log(author.name); // Jon Snow
console.log(author.email); // undefined

----------------------------------------

TITLE: Setting up MikroORM with AdminJS and Hapi
DESCRIPTION: TypeScript code for setting up MikroORM with AdminJS using the Hapi plugin. Includes database initialization, AdminJS configuration, and server setup.

LANGUAGE: typescript
CODE:
import AdminJS from 'adminjs';
import { Database, Resource } from '@adminjs/mikroorm';
import AdminJSHapi from '@adminjs/hapi';
import { MikroORM } from '@mikro-orm/core';
import { validate } from 'class-validator'; // optional

const PORT = process.env.PORT ?? 3000;

const run = async () => {
  /* Initialize MikroORM like you would do normally, you can also import your MikroORM instance from a separate file */
  const orm = await MikroORM.init({
    entities: [User, Car, Seller], // use your own entities
    dbName: process.env.DATABASE_NAME,
    type: 'postgresql',
    clientUrl: process.env.DATABASE_URL,
  });

  /* Optional: if you're using class-validator, assign it to Resource */
  Resource.validate = validate;
  /* Tell AdminJS which adapter to use */
  AdminJS.registerAdapter({ Database, Resource });

  const server = Hapi.server({ port: PORT })

  /* Configure AdminJS */
  const adminOptions = {
    databases: [orm],
  };

  /* Register AdminJS as a Hapi server's plugin */
  await server.register({
    plugin: AdminJSHapi,
    options: adminOptions,
  });

  await server.start();
  console.log(`App listening at ${server.info.uri}`);
}

run();

----------------------------------------

TITLE: Implementing Mapped Superclass in TypeScript with MikroORM
DESCRIPTION: Demonstrates how to create a mapped superclass Person with common properties and relations, and an Employee entity that extends it. Shows proper decorator usage and relationship definitions.

LANGUAGE: typescript
CODE:
export abstract class Person {

  @Property()
  mapped1!: number;

  @Property()
  mapped2!: string;

  @OneToOne()
  toothbrush!: Toothbrush;

  // ... more fields and methods
}

@Entity()
export class Employee extends Person {

  @PrimaryKey()
  id!: number;

  @Property()
  name!: string;

  // ... more fields and methods

}

@Entity()
export class Toothbrush {

  @PrimaryKey()
  id!: number;

  // ... more fields and methods

}

----------------------------------------

TITLE: Property Serializers in MikroORM
DESCRIPTION: Demonstrates how to use custom property serializers to transform property values during serialization.

LANGUAGE: typescript
CODE:
@Entity()
class Book {

  @ManyToOne({ serializer: value => value.name, serializedName: 'authorName' })
  author: Author;

}

----------------------------------------

TITLE: Implementing Mapped Superclass in TypeScript with MikroORM
DESCRIPTION: Demonstrates how to create a mapped superclass Person with common properties and relations, and an Employee entity that extends it. Shows proper decorator usage and relationship definitions.

LANGUAGE: typescript
CODE:
export abstract class Person {

  @Property()
  mapped1!: number;

  @Property()
  mapped2!: string;

  @OneToOne()
  toothbrush!: Toothbrush;

  // ... more fields and methods
}

@Entity()
export class Employee extends Person {

  @PrimaryKey()
  id!: number;

  @Property()
  name!: string;

  // ... more fields and methods

}

@Entity()
export class Toothbrush {

  @PrimaryKey()
  id!: number;

  // ... more fields and methods

}

----------------------------------------

TITLE: Creating Entities with Default Schema in MikroORM
DESCRIPTION: This code example shows how to create entities using a forked EntityManager with a default schema in MikroORM. It demonstrates that the fork automatically sets the default schema when persisting new entities.

LANGUAGE: typescript
CODE:
const fork = em.fork({ schema: 'client-123' });
const user = new User();
user.email = 'foo@bar.com';
await fork.persist(user).flush();

// Will yield the same result as
const qb = em.createQueryBuilder(User);
await qb.insert({ email: 'foo@bar.com' }).withSchema('client-123');

----------------------------------------

TITLE: SQL Tagged Templates in MikroORM - TypeScript
DESCRIPTION: Demonstrates the use of sql tagged template literals for creating raw SQL fragments, supporting string interpolation and value/key usage.

LANGUAGE: typescript
CODE:
// as a value
await em.find(User, { time: sql`now()` });

// as a key
await em.find(User, { [sql`lower(name)`]: name.toLowerCase() });

// value can be empty array
await em.find(User, { [sql`(select ${1} = ${1})`]: [] });

----------------------------------------

TITLE: Strict Property Validation Examples in MikroORM
DESCRIPTION: Shows various examples of property validation including type conversion and error cases during entity persistence.

LANGUAGE: typescript
CODE:
// number instead of string will throw
const author = new Author('test', 'test');
wrap(author).assign({ name: 111, email: 222 });
await orm.em.persist(author).flush(); // throws "Validation error: trying to set Author.name of type 'string' to '111' of type 'number'"

// string date with unknown format will throw
wrap(author).assign(author, { name: '333', email: '444', born: 'asd' });
await orm.em.persist(author).flush(); // throws "Validation error: trying to set Author.born of type 'date' to 'asd' of type 'string'"

// string date with correct format will be auto-corrected
wrap(author).assign({ name: '333', email: '444', born: '2018-01-01' });
await orm.em.persist(author).flush();
console.log(author.born).toBe(true); // instance of Date

// Date object will be ok
wrap(author).assign({ born: new Date() });
await orm.em.persist(author).flush();
console.log(author.born).toBe(true); // instance of Date

// null will be ok
wrap(author).assign({ born: null });
await orm.em.persist(author).flush();
console.log(author.born); // null

// string number with correct format will be auto-corrected
wrap(author).assign({ age: '21' });
await orm.em.persist(author).flush();
console.log(author.age); // number 21

// string instead of number with will throw
wrap(author).assign({ age: 'asd' });
await orm.em.persist(author).flush(); // throws "Validation error: trying to set Author.age of type 'number' to 'asd' of type 'string'"
wrap(author).assign({ age: new Date() });
await orm.em.persist(author).flush(); // throws "Validation error: trying to set Author.age of type 'number' to '2019-01-17T21:14:23.875Z' of type 'date'"
wrap(author).assign({ age: false });
await orm.em.persist(author).flush(); // throws "Validation error: trying to set Author.age of type 'number' to 'false' of type 'boolean'"

----------------------------------------

TITLE: Explicit Discriminator Column Implementation
DESCRIPTION: Shows how to explicitly define a discriminator column with enum type and abstract base class. Includes configuration for both concrete and abstract entity implementations.

LANGUAGE: typescript
CODE:
@Entity({
  discriminatorColumn: 'type',
  abstract: true,
})
export abstract class BasePerson {

  @Enum()
  type!: 'person' | 'employee';

}

@Entity({ discriminatorValue: 'person' })
export class Person extends BasePerson {
  // ...
}

@Entity({ discriminatorValue: 'employee' })
export class Employee extends Person {
  // ...
}

----------------------------------------

TITLE: Strict Partial Loading in MikroORM
DESCRIPTION: This code demonstrates strict partial loading in MikroORM. It shows how the type system ensures that only selected fields can be accessed when using partial loading.

LANGUAGE: typescript
CODE:
// article is typed to `Selected<Article, 'author', 'title' | 'author.email'>`
const article = await em.findOneOrFail(Article, 1, {
  fields: ['title', 'author.email'],
  populate: ['author'],
});

const id = article.id; // ok, PK is selected automatically
const title = article.title; // ok, title is selected
const publisher = article.publisher; // fail, not selected
const author = article.author.id; // ok, PK is selected automatically
const email = article.author.email; // ok, selected
const name = article.author.name; // fail, not selected

----------------------------------------

TITLE: Setting Global Loading Strategy in MikroORM Configuration
DESCRIPTION: This code example demonstrates how to set a global loading strategy in the MikroORM configuration options.

LANGUAGE: typescript
CODE:
MikroORM.init({
  // ...
  populate: ['books'],
  loadStrategy: 'select-in', // 'joined' is the default for SQL drivers
});

----------------------------------------

TITLE: Configuring Seeder Options in MikroORM
DESCRIPTION: Demonstrates how to set various seeder configuration options in the MikroORM initialization.

LANGUAGE: typescript
CODE:
MikroORM.init({
  seeder: {
    path: './seeders', // path to the folder with seeders
    pathTs: undefined, // path to the folder with TS seeders (if used, you should put path to compiled files in `path`)
    defaultSeeder: 'DatabaseSeeder', // default seeder class name
    glob: '!(*.d).{js,ts}', // how to match seeder files (all .js and .ts files, but not .d.ts)
    emit: 'ts', // seeder generation mode
    fileName: (className: string) => className, // seeder file naming convention
  },
});

----------------------------------------

TITLE: Basic Entity Query with Default Loading Strategy
DESCRIPTION: Example of querying an Author entity with its books relationship using the default select-in loading strategy.

LANGUAGE: typescript
CODE:
const author = await orm.em.findOne(Author, 1, ['books']);

----------------------------------------

TITLE: Configuring SchemaGenerator in MikroORM
DESCRIPTION: Demonstrates how to configure the SchemaGenerator globally via the ORM configuration object. It includes options for disabling foreign keys and ignoring schemas.

LANGUAGE: typescript
CODE:
const orm = await MikroORM.init({
  // default values:
  schemaGenerator: {
    disableForeignKeys: true, // wrap statements with `set foreign_key_checks = 0` or equivalent
    createForeignKeyConstraints: true, // whether to generate FK constraints
    ignoreSchema: [], // allows ignoring some schemas when diffing
  },
});

----------------------------------------

TITLE: Using Custom Driver with MikroORM
DESCRIPTION: Example of initializing MikroORM with a custom database driver implementation.

LANGUAGE: typescript
CODE:
import { MyCustomDriver } from './MyCustomDriver.ts';

const orm = await MikroORM.init<MyCustomDriver>({
  entities: [Author, Book, ...],
  dbName: 'my-db-name',
  driver: MyCustomDriver, // provide the class, not just its name
});

----------------------------------------

TITLE: Custom toJSON Implementation in MikroORM
DESCRIPTION: Shows how to implement a custom toJSON method for an entity while utilizing the base toObject functionality.

LANGUAGE: typescript
CODE:
@Entity()
class Book {

  toJSON(strict = true, strip = ['id', 'email'], ...args: any[]): { [p: string]: any } {
    const o = wrap(this, true).toObject(...args);

    if (strict) {
      strip.forEach(k => delete o[k]);
    }

    return o;
  }

}

----------------------------------------

TITLE: Synchronizing Database Schema with MikroORM CLI
DESCRIPTION: This command uses the MikroORM CLI to update the database schema based on entity definitions.

LANGUAGE: sh
CODE:
npx mikro-orm schema:update --run

----------------------------------------

TITLE: Implementing Password Hashing with Lifecycle Hooks in TypeScript for MikroORM
DESCRIPTION: Adds password hashing to the User entity using argon2. Implements BeforeCreate and BeforeUpdate lifecycle hooks to automatically hash the password when it's set or changed.

LANGUAGE: TypeScript
CODE:
import { hash, verify } from 'argon2';

export class User extends BaseEntity<'bio'> {

  // ...

  @BeforeCreate()
  @BeforeUpdate()
  async hashPassword(args: EventArgs<User>) {
    const password = args.changeSet?.payload.password;

    if (password) {
      this.password = await hash(password);
    }
  }

  async verifyPassword(password: string) {
    return verify(this.password, password);
  }

}

----------------------------------------

TITLE: Using SQL Highlighter in MikroORM (TypeScript)
DESCRIPTION: This snippet shows how to use the SQL Highlighter in MikroORM for highlighting SQL queries in the CLI. The SqlHighlighter needs to be installed separately.

LANGUAGE: typescript
CODE:
import { SqlHighlighter } from '@mikro-orm/sql-highlighter';

MikroORM.init({
  highlighter: new SqlHighlighter(),
  // ...
});

----------------------------------------

TITLE: Setting Custom Temp Folder for MikroORM Cache
DESCRIPTION: This code shows how to set a custom temporary folder for MikroORM's cache. It uses the 'options.cacheDir' property within the 'cache' configuration to specify the directory path.

LANGUAGE: typescript
CODE:
await MikroORM.init({
  cache: { options: { cacheDir: '...' } },
  // ...
});

----------------------------------------

TITLE: Implementing Custom Naming Strategy for Table Aliasing in TypeScript
DESCRIPTION: Example of how to implement a custom naming strategy to restore the old behavior of table aliasing in MikroORM v5. This strategy uses 'e' followed by an index for alias names.

LANGUAGE: typescript
CODE:
import { AbstractNamingStrategy } from '@mikro-orm/core';

class CustomNamingStrategy extends AbstractNamingStrategy {
  aliasName(entityName: string, index: number) {
    return 'e' + index;
  }
}

----------------------------------------

TITLE: Initializing MikroORM with JavaScriptMetadataProvider
DESCRIPTION: This snippet shows how to initialize MikroORM using the deprecated JavaScriptMetadataProvider, which is used for non-TypeScript projects.

LANGUAGE: typescript
CODE:
await MikroORM.init({
  metadataProvider: JavaScriptMetadataProvider,
  // ...
});

----------------------------------------

TITLE: Custom Repository Implementation
DESCRIPTION: Implementation of a custom repository class with entity type definition and repository decoration.

LANGUAGE: typescript
CODE:
@Repository(Author)
export class AuthorRepository extends EntityRepository<Author> {
  // your custom methods...
}

----------------------------------------

TITLE: Implementing Single Table Inheritance in MikroORM
DESCRIPTION: Shows how to set up Single Table Inheritance using discriminator columns and maps to distinguish between different entity types in the hierarchy.

LANGUAGE: typescript
CODE:
@Entity({
  discriminatorColumn: 'discr',
  discriminatorMap: { person: 'Person', employee: 'Employee' },
})
export class Person {
  // ...
}

@Entity()
export class Employee extends Person {
  // ...
}

----------------------------------------

TITLE: Shadow Property Implementation
DESCRIPTION: Example of implementing non-persisted shadow properties using persist: false configuration.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @Property({ persist: false })
  count?: number;

}

----------------------------------------

TITLE: Configuring Read Replicas in MikroORM
DESCRIPTION: Demonstrates how to set up read replicas in MikroORM configuration for MySQL.

LANGUAGE: typescript
CODE:
MikroORM.init({
  type: 'mysql',
  dbName: 'my_db_name',
  user: 'write-user',
  host: 'master.db.example.com',
  port: 3306,
  replicas: [
    { user: 'read-user-1', host: 'read-1.db.example.com', port: 3307 },
    { user: 'read-user-2', host: 'read-2.db.example.com', port: 3308 },
    { user: 'read-user-3', host: 'read-3.db.example.com', port: 3309 },
  ],
});

----------------------------------------

TITLE: Explicit Transaction Handling using MikroORM's transactional() Method
DESCRIPTION: Shows how to use MikroORM's transactional() method for explicit transaction control. This approach allows for more granular control over transaction boundaries.

LANGUAGE: typescript
CODE:
await orm.em.transactional(em => {
  //... do some work
  const user = new User(...);
  user.name = 'George';
  em.persist(user);
});

----------------------------------------

TITLE: Configuring Discovery Options in MikroORM
DESCRIPTION: This snippet demonstrates how to adjust the entity discovery process in MikroORM by configuring various discovery options.

LANGUAGE: typescript
CODE:
MikroORM.init({
  discovery: {
    warnWhenNoEntities: false,
    requireEntitiesArray: true,
    alwaysAnalyseProperties: false,
  },
});

----------------------------------------

TITLE: Synchronizing Database Schema with MikroORM CLI
DESCRIPTION: This command uses the MikroORM CLI to update the database schema based on entity definitions.

LANGUAGE: sh
CODE:
npx mikro-orm schema:update --run

----------------------------------------

TITLE: Using PointType in MikroORM Entity
DESCRIPTION: This snippet demonstrates how to use the custom PointType in a MikroORM entity definition.

LANGUAGE: typescript
CODE:
@Entity()
export class Location {

  @PrimaryKey()
  id!: number;

  @Property({ type: PointType })
  point?: Point;

}

----------------------------------------

TITLE: Point Class Definition for Spatial Data
DESCRIPTION: Definition of a Point class for storing geographical coordinates.

LANGUAGE: typescript
CODE:
export class Point {

  constructor(
    public latitude: number,
    public longitude: number,
  ) {
  }

}

----------------------------------------

TITLE: Using QueryBuilder for Native SQL
DESCRIPTION: Examples of using QueryBuilder to construct and execute native SQL queries with parameter binding.

LANGUAGE: typescript
CODE:
const qb = orm.em.createQueryBuilder(Author);
qb.update({ name: 'test 123', type: PublisherType.GLOBAL }).where({ id: 123, type: PublisherType.LOCAL });

console.log(qb.getQuery());
console.log(qb.getParams());

const res1 = await qb.execute();

const driver = orm.em.getDriver();
const res2 = await driver.execute('SELECT ? + ?', [1, 2]);

----------------------------------------

TITLE: Using Read and Write Connections in MikroORM
DESCRIPTION: Comprehensive example demonstrating various ways to specify connection types for different operations including queries, transactions, and explicit connection type selection.

LANGUAGE: typescript
CODE:
const connection = em.getConnection(); // write connection
const readConnection = em.getConnection('read'); // random read connection

const qb1 = em.createQueryBuilder(Author);
const res1 = await qb1.select('*').execute(); // random read connection

const qb2 = em.createQueryBuilder(Author, 'a', 'write');
const res2 = await qb2.select('*').execute(); // write connection

const qb3 = em.createQueryBuilder(Author);
const res3 = await qb3.update(...).where(...).execute(); // write connection

const res4 = await em.findOne(Author, 1, { connectionType: 'write' }); // explicit write connection

// all queries inside a transaction will use write connection
await em.transactional(async em => {
    const a = await em.findOne(Author, 1); // write connection
    const b = await em.findOne(Author, 1, { connectionType: 'read' }); // still a write connection - we are in a transaction
    a.name = 'test'; // will trigger update on write connection once flushed
});

// given a configuration where preferReadReplicas: false
const res5 = await em.findOne(Author, 1); // write connection - even for a read operation
const res6 = await em.findOne(Author, 1, { connectionType: 'read' }); // unless explicitly asking for a read replica

----------------------------------------

TITLE: MongoDB EntityManager Aggregate Usage
DESCRIPTION: Example showing how to import and use MongoEntityManager for aggregation operations in MongoDB driver.

LANGUAGE: typescript
CODE:
import { EntityManager } from '@mikro-orm/mongodb';

const em: EntityManager;
const ret = await em.aggregate(...);

----------------------------------------

TITLE: Defining Custom Base Entity Schema in TypeScript
DESCRIPTION: This example demonstrates how to create a custom base entity schema with common properties like id, createdAt, and updatedAt.

LANGUAGE: typescript
CODE:
export interface CustomBaseEntity {
  id: number;
  createdAt: Date;
  updatedAt: Date;
}

export const schema = new EntitySchema<CustomBaseEntity>({
  name: 'CustomBaseEntity',
  abstract: true,
  properties: {
    id: { type: 'number', primary: true },
    createdAt: { type: 'Date', onCreate: () => new Date(), nullable: true },
    updatedAt: { type: 'Date', onCreate: () => new Date(), onUpdate: () => new Date(), nullable: true },
  },
});

----------------------------------------

TITLE: Setting up MikroORM with Express and AdminJS
DESCRIPTION: Complete setup example showing MikroORM initialization, AdminJS configuration, and Express server setup

LANGUAGE: typescript
CODE:
import AdminJS from 'adminjs';
import { Database, Resource } from '@adminjs/mikroorm';
import AdminJSExpress from '@adminjs/express';
import { MikroORM } from '@mikro-orm/postgresql';
import { validate } from 'class-validator'; // optional

const PORT = process.env.PORT ?? 3000;

const run = async () => {
  /* Initialize MikroORM like you would do normally, you can also import your MikroORM instance from a separate file */
  const orm = await MikroORM.init({
    entities: [User, Car, Seller], // use your own entities
    dbName: process.env.DATABASE_NAME,
    clientUrl: process.env.DATABASE_URL,
  });

  /* Optional: if you're using class-validator, assign it to Resource */
  Resource.validate = validate;
  /* Tell AdminJS which adapter to use */
  AdminJS.registerAdapter({ Database, Resource });

  const app = express();

  /* Create AdminJS instance */
  const admin = new AdminJS({
    databases: [orm],
  });

  const router = AdminJSExpress.buildRouter(admin);

  app.use(admin.options.rootPath, router);

  app.listen(PORT, () => {
    console.log(`App listening at http://localhost:${PORT}`);
  });
}

run();

----------------------------------------

TITLE: Production Migration Configuration
DESCRIPTION: Configuration for using compiled seeder files in production environment.

LANGUAGE: typescript
CODE:
import { MikroORM, Utils } from '@mikro-orm/core';

await MikroORM.init({
  seeder: {
    path: 'dist/seeders',
    pathTs: 'src/seeders',
  },
  // or alternatively
  // seeder: {
  //   path: Utils.detectTsNode() ? 'src/seeders' : 'dist/seeders',
  // },
  // ...
});

----------------------------------------

TITLE: Implementing Migration Class
DESCRIPTION: Example of a basic migration class extending the Migration abstract class with an up method for schema changes.

LANGUAGE: typescript
CODE:
import { Migration } from '@mikro-orm/migrations';

export class Migration20191019195930 extends Migration {

  async up(): Promise<void> {
    this.addSql('select 1 + 1');
  }

}

----------------------------------------

TITLE: Initializing MySQL Blog Schema
DESCRIPTION: SQL schema definition for blog database including users, articles, comments and tags tables with appropriate relationships and constraints.

LANGUAGE: sql
CODE:
-- MySQL Workbench Forward Engineering

SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0;
SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0;
SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION';

-- -----------------------------------------------------
-- Schema blog
-- -----------------------------------------------------
CREATE SCHEMA IF NOT EXISTS `blog` DEFAULT CHARACTER SET utf8;
USE `blog`;

-- -----------------------------------------------------
-- Table `user`
-- -----------------------------------------------------
CREATE TABLE IF NOT EXISTS `user` (
  `id` INT UNSIGNED NOT NULL AUTO_INCREMENT,
  `created_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `updated_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  `full_name` VARCHAR(255) NOT NULL,
  `email` VARCHAR(255) NOT NULL,
  `password` VARCHAR(255) NOT NULL,
  `bio` TEXT NOT NULL,
  PRIMARY KEY (`id`))
ENGINE = InnoDB;

----------------------------------------

TITLE: Manual Explicit Transaction Handling in MikroORM (TypeScript)
DESCRIPTION: Demonstrates manual explicit transaction demarcation using begin, commit, and rollback methods. It shows how to handle exceptions and rollback the transaction if needed.

LANGUAGE: typescript
CODE:
const em = orm.em.fork(false);
await em.begin();

try {
  //... do some work
  const user = new User(...);
  user.name = 'George';
  em.persist(user);
  await em.commit(); // will flush before making the actual commit query
} catch (e) {
  await em.rollback();
  throw e;
}

----------------------------------------

TITLE: Using Filters with QueryBuilder in MikroORM
DESCRIPTION: Demonstrates how to apply filters to a QueryBuilder instance using the applyFilters method.

LANGUAGE: typescript
CODE:
const qb = em.createQueryBuilder(Author);
await qb.applyFilters({ tenant: 123 });
const authors = await qb.getResult();

----------------------------------------

TITLE: Implementing Declarative Referential Integrity in MikroORM
DESCRIPTION: This snippet shows how to define database-level referential integrity actions in MikroORM using TypeScript decorators. It demonstrates setting onUpdateIntegrity and onDelete options.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @ManyToOne({ onUpdateIntegrity: 'set null', onDelete: 'cascade' })
  author?: Author;

}

----------------------------------------

TITLE: Specifying Property Type in MikroORM Entity
DESCRIPTION: This snippet demonstrates how to explicitly specify the type of a property in a MikroORM entity to avoid JSON type inference issues.

LANGUAGE: ts
CODE:
@Property()
foo: string = 'abc';

----------------------------------------

TITLE: Filtering and Ordering Collection Items in TypeScript
DESCRIPTION: Demonstrates how to filter and order collection items when initializing them using the init() method.

LANGUAGE: typescript
CODE:
await book.tags.init({
  where: { active: true },
  orderBy: { name: QueryOrder.DESC },
});

----------------------------------------

TITLE: Using SchemaGenerator Programmatically in MikroORM TypeScript
DESCRIPTION: TypeScript code demonstrating how to use the SchemaGenerator programmatically to generate and execute schema-related SQL queries.

LANGUAGE: typescript
CODE:
import { MikroORM } from '@mikro-orm/core';

(async () => {
  const orm = await MikroORM.init({
    entities: [Author, Book, ...],
    dbName: 'your-db-name',
    // ...
  });
  const generator = orm.schema;

  const dropDump = await generator.getDropSchemaSQL();
  console.log(dropDump);

  const createDump = await generator.getCreateSchemaSQL();
  console.log(createDump);

  const updateDump = await generator.getUpdateSchemaSQL();
  console.log(updateDump);

  // there is also `generate()` method that returns drop + create queries
  const dropAndCreateDump = await generator.generate();
  console.log(dropAndCreateDump);

  // or you can run those queries directly, but be sure to check them first!
  await generator.dropSchema();
  await generator.createSchema();
  await generator.updateSchema();

  // in tests it can be handy to use those:
  await generator.refreshDatabase(); // ensure db exists and is fresh
  await generator.clearDatabase(); // removes all data

  await orm.close(true);
})();

----------------------------------------

TITLE: Configuring ReflectMetadataProvider
DESCRIPTION: Shows how to set up ReflectMetadataProvider which uses reflect-metadata to read type information from decorator metadata.

LANGUAGE: typescript
CODE:
import 'reflect-metadata';

LANGUAGE: typescript
CODE:
await MikroORM.init({
  metadataProvider: ReflectMetadataProvider,
  // ...
});

----------------------------------------

TITLE: Implementing Migration Class
DESCRIPTION: Example of a basic migration class extending the Migration abstract class with an up method for schema changes.

LANGUAGE: typescript
CODE:
import { Migration } from '@mikro-orm/migrations';

export class Migration20191019195930 extends Migration {

  async up(): Promise<void> {
    this.addSql('select 1 + 1');
  }

}

----------------------------------------

TITLE: Defining Optional Property with Default Value in MikroORM
DESCRIPTION: This snippet illustrates how to define an optional property with a default value in MikroORM. It uses the @Property decorator and sets the property as optional with a default value.

LANGUAGE: typescript
CODE:
@Property({ default: 1 })
level?: number = 1;

----------------------------------------

TITLE: Demonstrating Improved Type Safety in MikroORM 5
DESCRIPTION: This snippet showcases the enhanced type safety features in MikroORM 5, including strict typing for entity creation, population, and querying. It demonstrates how to create entities with nested relations, use populate hints, and perform partial loading with strict typing.

LANGUAGE: typescript
CODE:
const god = em.create(Author, {
  name: 'God', // validates required properties
  email: 'god@heaven.io',
  books: [{
    title: 'Bible, part 1',
    tags: [{ name: 'old' }, { name: 'new' }],
  }],
}, { persist: true });
await em.flush();

// simulate new request
em.clear();

// `authors` is of type `Loaded<Author, 'books.tags'>[]`
const authors = await em.find(Author, {}, {
  populate: ['books.tags'], // populate hint can be inferred from `fields` if not explicitly provided
  fields: ['books.tags.name'], // strict partial loading with dot notation support
  orderBy: { name: 'asc', books: { tags: { name: 'asc' } } }, // strict order by with object nesting
});

// `books` and `tags` will be typed as `LoadedCollection` so we can use safe `$` accessor
console.log(authors[0].books.$[0].tags.$[0].name);
const dto = wrap(authors[0]).toObject();
console.log(dto.books[0].tags[0].name); // DTOs are also strictly typed

----------------------------------------

TITLE: Entity Class with Manual Type Definitions
DESCRIPTION: Example of an entity class with manually defined types and relationships, avoiding the need for type discovery.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @PrimaryKey({ type: 'number' })
  id!: number;

  @Property({ type: 'string' })
  title!: string;

  @Enum(() => BookStatus)
  status?: BookStatus;

  @ManyToOne(() => Author)
  author1!: Author;

  @ManyToOne({ type: 'Author' })
  author2!: Author;

  @ManyToOne({ entity: () => Author })
  author3!: Author;

}

export enum BookStatus {
  SOLD_OUT = 'sold',
  ACTIVE = 'active',
  UPCOMING = 'upcoming',
}

----------------------------------------

TITLE: Raw Helper with Property Alias Callback
DESCRIPTION: Shows how to use the raw() helper with a callback function that receives the current property alias.

LANGUAGE: typescript
CODE:
await em.find(User, { [raw(alias => `lower(${alias}.name)`)]: name.toLowerCase() });

----------------------------------------

TITLE: Accessing Internal Properties in MikroORM
DESCRIPTION: Demonstrates how to access internal prefixed properties using wrap helper

LANGUAGE: typescript
CODE:
@Entity()
export class Author { ... }

console.log(wrap(author, true).__meta);

----------------------------------------

TITLE: Implementing Shadow Properties in MikroORM
DESCRIPTION: Shows how to create non-persisted properties using persist: false option that exist only in memory but are included in serialization.

LANGUAGE: typescript
CODE:
@Entity()
class Book {

  @Property({ persist: false })
  count?: number;

}

----------------------------------------

TITLE: Implementing Cascade Remove in MikroORM with TypeScript
DESCRIPTION: This snippet demonstrates how cascade remove works in MikroORM, showing how related entities can be removed when the main entity is removed.

LANGUAGE: typescript
CODE:
await orm.em.remove(book).flush(); // this will also remove book.publisher

----------------------------------------

TITLE: Checking Database Connection in MikroORM
DESCRIPTION: This TypeScript code demonstrates how to check the database connection status using MikroORM's isConnected() and checkConnection() methods.

LANGUAGE: ts
CODE:
// boolean
const isConnected = await orm.isConnected();
// object with `ok`, `reason` and `error` keys
const check = await orm.checkConnection();

console.log(check.ok, check.reason);

----------------------------------------

TITLE: Setting up MikroORM with AdminJS and Express
DESCRIPTION: TypeScript code for setting up MikroORM with AdminJS using the Express plugin. Includes database initialization, AdminJS configuration, and server setup.

LANGUAGE: typescript
CODE:
import AdminJS from 'adminjs';
import { Database, Resource } from '@adminjs/mikroorm';
import AdminJSExpress from '@adminjs/express';
import { MikroORM } from '@mikro-orm/postgresql';
import { validate } from 'class-validator'; // optional

const PORT = process.env.PORT ?? 3000;

const run = async () => {
  /* Initialize MikroORM like you would do normally, you can also import your MikroORM instance from a separate file */
  const orm = await MikroORM.init({
    entities: [User, Car, Seller], // use your own entities
    dbName: process.env.DATABASE_NAME,
    clientUrl: process.env.DATABASE_URL,
  });

  /* Optional: if you're using class-validator, assign it to Resource */
  Resource.validate = validate;
  /* Tell AdminJS which adapter to use */
  AdminJS.registerAdapter({ Database, Resource });

  const app = express();

  /* Create AdminJS instance */
  const admin = new AdminJS({
    databases: [orm],
  });

  const router = AdminJSExpress.buildRouter(admin);

  app.use(admin.options.rootPath, router);

  app.listen(PORT, () => {
    console.log(`App listening at http://localhost:${PORT}`);
  });
}

run();

----------------------------------------

TITLE: Defining Entity Interface with Serialization Methods in TypeScript
DESCRIPTION: This snippet shows the default interface for entities in MikroORM, which includes toObject() and toJSON() methods for serialization.

LANGUAGE: typescript
CODE:
interface AnyEntity<K = number | string> {
  toObject(parent?: AnyEntity, isCollection?: boolean): Record<string, any>;
  toJSON(...args: any[]): Record<string, any>;
  // ...
}

----------------------------------------

TITLE: Creating MongoDB Indexes with MikroORM
DESCRIPTION: Demonstrates how to enable automatic index creation and create various types of indexes including unique constraints and text indexes.

LANGUAGE: typescript
CODE:
const orm = await MikroORM.init({
  entities: [Author, Book, ...],
  dbName: 'my-db-name',
  ensureIndexes: true, // defaults to false
});

@Unique({ options: { partialFilterExpression: { name: { $exists: true } } }})

@Index({ properties: ['name', 'caption'], type: 'text' })

@Index({ options: { point: '2dsphere', title: -1 } })

@Index({ options: [
  { title: 'text', perex: 'text', key: 1 },
  { weights: { title: 10, perex: 5 } },
] })

----------------------------------------

TITLE: Implementing Entity Hooks with EntitySchema in TypeScript
DESCRIPTION: This snippet demonstrates how to define and use entity hooks with EntitySchema, including instance methods, normal functions, and arrow functions.

LANGUAGE: typescript
CODE:
export class BookTag {
  _id!: ObjectId;
  id!: string;
  name: string;
  books = new Collection<Book>(this);

  constructor(name: string) {
    this.name = name;
  }

  beforeCreate() {
    this.version = 1;
  }

  beforeUpdate() {
    this.version++;
  }
}

function beforeUpdate() {
  this.version++;
}

const beforeUpdate2 = (args: EventArgs) => args.entity.version++;

export const schema = new EntitySchema({
  class: BookTag,
  hooks: {
    beforeCreate: ['beforeCreate'],
    beforeUpdate: ['beforeUpdate', beforeUpdate, beforeUpdate2]
  },
  properties: {
    _id: { type: 'ObjectId', primary: true },
    id: { type: 'string', serializedPrimaryKey: true },
    name: { type: 'string' },
    books: { kind: 'm:n', entity: () => Book, mappedBy: book => book.tags },
  },
});

----------------------------------------

TITLE: Implementing OneToOne Relationships (Inverse Side) in MikroORM TypeScript
DESCRIPTION: Shows how to implement the inverse side of OneToOne relationships in MikroORM using the mappedBy property.

LANGUAGE: typescript
CODE:
@Entity()
export class User {

  @OneToOne({ mappedBy: 'bestFriend1' })
  bestFriend1!: User;

  @OneToOne(() => User, user => user.bestFriend2)
  bestFriend2!: User;

}

----------------------------------------

TITLE: Defining Global Filters in MikroORM with TypeScript
DESCRIPTION: This snippet illustrates how to add global filters using the EntityManager API. It shows how to create entity-specific and global filters, set filter parameters, and apply them to queries. It also demonstrates how to register global filters via ORM configuration.

LANGUAGE: typescript
CODE:
// bound to entity, enabled by default
em.addFilter('writtenBy', args => ({ author: args.id }), Book);

// global, enabled by default, for all entities
em.addFilter('tenant', args => { ... });

// global, enabled by default, for only specified entities
em.addFilter('tenant', args => { ... }, [Author, Book]);
...

// set params (probably in some middleware)
em.setFilterParams('tenant', { tenantId: 123 });
em.setFilterParams('writtenBy', { id: 321 });

MikroORM.init({
  filters: { tenant: { cond: args => ({ tenant: args.tenant }), entity: ['Author', 'User'] } },
  ...
})

----------------------------------------

TITLE: Fresh Schema Creation with Seeding in MikroORM
DESCRIPTION: Commands for recreating database schema from scratch with optional seeding functionality.

LANGUAGE: shell
CODE:
npx mikro-orm schema:fresh --run --seed              # seed the database with the default database seeder
npx mikro-orm schema:fresh --run --seed=UsersSeeder  # seed the database with the UsersSeeder

----------------------------------------

TITLE: Entity Hooks Implementation Example
DESCRIPTION: Shows different ways to implement entity lifecycle hooks using EntitySchema

LANGUAGE: typescript
CODE:
export class BookTag {
  _id!: ObjectId;
  id!: string;
  name: string;
  books = new Collection<Book>(this);

  constructor(name: string) {
    this.name = name;
  }

  beforeCreate() {
    this.version = 1;
  }

  beforeUpdate() {
    this.version++;
  }
}

function beforeUpdate() {
  this.version++;
}

const beforeUpdate2 = (args: EventArgs) => args.entity.version++;

export const schema = new EntitySchema({
  class: BookTag,
  hooks: {
    beforeCreate: ['beforeCreate'],
    beforeUpdate: ['beforeUpdate', beforeUpdate, beforeUpdate2]
  },
  properties: {
    _id: { type: 'ObjectId', primary: true },
    id: { type: 'string', serializedPrimaryKey: true },
    name: { type: 'string' },
    books: { kind: 'm:n', entity: () => Book, mappedBy: book => book.tags },
  },
});

----------------------------------------

TITLE: IWrappedEntity Interface Definition in MikroORM
DESCRIPTION: Defines the interface for wrapped entities including helper methods and internal properties

LANGUAGE: typescript
CODE:
interface IWrappedEntity<T, PK extends keyof T> {
  isInitialized(): boolean;
  populated(populated?: boolean): void;
  init(populated?: boolean, lockMode?: LockMode): Promise<this>;
  toReference(): IdentifiedReference<T, PK>;
  toObject(ignoreFields?: string[]): Dictionary;
  toJSON(...args: any[]): Dictionary;
  assign(data: any, options?: AssignOptions | boolean): this;
  __uuid: string;
  __meta: EntityMetadata;
  __em: EntityManager;
  __initialized?: boolean;
  __populated: boolean;
  __lazyInitialized: boolean;
  __primaryKey: T[PK] & Primary<T>;
  __serializedPrimaryKey: string & keyof T;
}

----------------------------------------

TITLE: Working with Entity References in MikroORM
DESCRIPTION: Explains how to use entity references in MikroORM, which allow working with entities without fully loading them from the database.

LANGUAGE: typescript
CODE:
const userRef = em.getReference(User, 1);
console.log(userRef);

// setting relation properties
author.favouriteBook = em.getReference(Book, 1);

// removing entity by reference
em.remove(em.getReference(Book, 2));

// adding entity to collection by reference
author.books.add(em.getReference(Book, 3));

----------------------------------------

TITLE: Using EntityAssigner with New Entities in TypeScript
DESCRIPTION: Demonstrates how to use the assign() method on new (unmanaged) entities by providing the EntityManager parameter explicitly.

LANGUAGE: typescript
CODE:
const book = new Book();
wrap(book).assign(data, { em: orm.em });

----------------------------------------

TITLE: Breaking Change Documentation - em.create Behavior
DESCRIPTION: Documentation of breaking change in em.create() behavior requiring non-optional properties

LANGUAGE: markdown
CODE:
### BREAKING CHANGES

* **core:** `em.create()` will now require you to pass all non-optional properties. Some properties
might be defined as required for TS but we have a default value for them (either runtime,
or database one) - for such we can use `OptionalProps` symbol to specify which properties
should be considered as optional.

----------------------------------------

TITLE: Setting and Clearing Schema in MikroORM EntityManager
DESCRIPTION: This snippet illustrates how to set and clear the schema on an EntityManager instance in MikroORM. It shows that the schema can be set directly on the EntityManager or its fork, and can also be cleared by setting it to null.

LANGUAGE: typescript
CODE:
em.schema = 'client-123';
const fork = em.fork({ schema: 'client-1234' });
fork.schema = null;

----------------------------------------

TITLE: Nested Embeddables Configuration
DESCRIPTION: Shows how to implement nested embeddables with Profile and Identity classes within a User entity, demonstrating complex embedded relationships.

LANGUAGE: typescript
CODE:
import { Embeddable, Embedded, Entity, PrimaryKey, Property } from '@mikro-orm/core';

@Entity()
export class User {

  @PrimaryKey()
  id!: number;

  @Property()
  name!: string;

  @Embedded(() => Profile, { object: true, nullable: true })
  profile?: Profile;

}

@Embeddable()
export class Profile {

  @Property()
  username: string;

  @Embedded(() => Identity)
  identity: Identity;

  constructor(username: string, identity: Identity) {
    this.username = username;
    this.identity = identity;
  }

}

@Embeddable()
export class Identity {

  @Property()
  email: string;

  constructor(email: string) {
    this.email = email;
  }

}

----------------------------------------

TITLE: Nested Embeddables Configuration
DESCRIPTION: Shows how to implement nested embeddables with Profile and Identity classes within a User entity, demonstrating complex embedded relationships.

LANGUAGE: typescript
CODE:
import { Embeddable, Embedded, Entity, PrimaryKey, Property } from '@mikro-orm/core';

@Entity()
export class User {

  @PrimaryKey()
  id!: number;

  @Property()
  name!: string;

  @Embedded(() => Profile, { object: true, nullable: true })
  profile?: Profile;

}

@Embeddable()
export class Profile {

  @Property()
  username: string;

  @Embedded(() => Identity)
  identity: Identity;

  constructor(username: string, identity: Identity) {
    this.username = username;
    this.identity = identity;
  }

}

@Embeddable()
export class Identity {

  @Property()
  email: string;

  constructor(email: string) {
    this.email = email;
  }

}

----------------------------------------

TITLE: Ignoring Deprecation Warnings in MikroORM (TypeScript)
DESCRIPTION: This snippet shows how to ignore all deprecation warnings in MikroORM by setting the ignoreDeprecations option to true.

LANGUAGE: typescript
CODE:
return MikroORM.init({
  ignoreDeprecations: true, // now no deprecations will be logged, though you may be surprised when upgrading
});

----------------------------------------

TITLE: Using Custom Point Type in Location Entity
DESCRIPTION: Example of implementing the custom Point type in a Location entity class.

LANGUAGE: typescript
CODE:
@Entity()
export class Location {

  @PrimaryKey()
  id!: number;

  @Property({ type: PointType })
  point?: Point;

}

----------------------------------------

TITLE: ManyToMany Relationship SQL Schema
DESCRIPTION: SQL schema definition for creating pivot tables to handle ManyToMany relationships.

LANGUAGE: sql
CODE:
CREATE TABLE `publisher_to_test` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `publisher_id` int(11) DEFAULT NULL,
  `test_id` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

----------------------------------------

TITLE: Entity Hooks Implementation
DESCRIPTION: Shows how to implement lifecycle hooks in entity schemas using different approaches including instance methods and arrow functions.

LANGUAGE: typescript
CODE:
export class BookTag {
  _id!: ObjectId;
  id!: string;
  name: string;
  books = new Collection<Book>(this);

  constructor(name: string) {
    this.name = name;
  }

  beforeCreate() {
    this.version = 1;
  }

  beforeUpdate() {
    this.version++;
  }
}

function beforeUpdate() {
  this.version++;
}

const beforeUpdate2 = (args: EventArgs) => args.entity.version++;

export const schema = new EntitySchema({
  class: BookTag,
  hooks: {
    beforeCreate: ['beforeCreate'],
    beforeUpdate: ['beforeUpdate', beforeUpdate, beforeUpdate2]
  },
  properties: {
    _id: { type: 'ObjectId', primary: true },
    id: { type: 'string', serializedPrimaryKey: true },
    name: { type: 'string' },
    books: { kind: 'm:n', entity: () => Book, mappedBy: book => book.tags },
  },
});

----------------------------------------

TITLE: Using assign() on Unmanaged Entities in TypeScript
DESCRIPTION: Demonstrates how to use assign() on entities not managed by EntityManager by providing the EntityManager instance explicitly.

LANGUAGE: typescript
CODE:
import { wrap } from '@mikro-orm/core';

const book = new Book();
wrap(book).assign({
  title: 'Better Book 1',
  author: '...id...',
}, { em });

----------------------------------------

TITLE: Generic Base Entity with Optional Properties
DESCRIPTION: Shows how to implement a base entity class with generic optional properties that can be extended.

LANGUAGE: typescript
CODE:
@Entity()
class MyBaseEntity<Entity extends object, Optional extends keyof Entity = never> {

  [OptionalProps]?: 'foo' | 'bar' | Optional;

  @PrimaryKey()
  id!: number;

  @Property({ default: 1 })
  foo: number = 1;

  @Property({ default: 2 })
  bar: number = 2;

}

@Entity()
class User extends MyBaseEntity<User, 'baz'> {

  @Property({ default: 3 })
  baz: number = 3;

}

----------------------------------------

TITLE: Defining Book Entity Schema in TypeScript
DESCRIPTION: This snippet shows how to define a Book entity using EntitySchema in MikroORM. It includes properties for title, author, publisher, and tags, demonstrating various relationship types.

LANGUAGE: typescript
CODE:
export interface Book extends BaseEntity {
  title: string;
  author: Author;
  publisher: Publisher;
  tags: Collection<BookTag>;
}

export const schema = new EntitySchema<Book, BaseEntity>({
  name: 'Book',
  extends: 'BaseEntity',
  properties: {
    title: { type: 'string' },
    author: { reference: 'm:1', entity: 'Author', inversedBy: 'books' },
    publisher: { reference: 'm:1', entity: 'Publisher', inversedBy: 'books' },
    tags: { reference: 'm:n', entity: 'BookTag', inversedBy: 'books', fixedOrder: true },
  },
});

----------------------------------------

TITLE: Implementing Single Table Inheritance in TypeScript with MikroORM
DESCRIPTION: Shows how to implement Single Table Inheritance using discriminator columns and maps. Demonstrates the relationship between base and derived classes with type discrimination.

LANGUAGE: typescript
CODE:
@Entity({
  discriminatorColumn: 'discr',
  discriminatorMap: { person: 'Person', employee: 'Employee' },
})
export class Person {
  // ...
}

@Entity()
export class Employee extends Person {
  // ...
}

----------------------------------------

TITLE: Configuring OneToOne Relationships - Inverse Side
DESCRIPTION: Shows how to define the inverse side of OneToOne relationships with mappedBy and orphanRemoval options.

LANGUAGE: typescript
CODE:
@Entity()
export class User {

  @OneToOne({ mappedBy: 'bestFriend1', orphanRemoval: true })
  bestFriend1!: User;

  @OneToOne(() => User, user => user.bestFriend2, { orphanRemoval: true })
  bestFriend2!: User;

}

----------------------------------------

TITLE: Defining an Entity with @Entity Decorator in TypeScript
DESCRIPTION: Example of using the @Entity decorator to define an Author entity with a custom table name.

LANGUAGE: typescript
CODE:
@Entity({ tableName: 'authors' })
export class Author { ... }

----------------------------------------

TITLE: Generating Entities with TypeScript Script in MikroORM
DESCRIPTION: A TypeScript script that initializes MikroORM, uses the EntityGenerator to generate entities, and saves them to a specified directory. It demonstrates how to configure MikroORM and use the generator programmatically.

LANGUAGE: typescript
CODE:
import { MikroORM } from '@mikro-orm/core';

(async () => {
  const orm = await MikroORM.init({
    discovery: {
      // we need to disable validation for no entities
      warnWhenNoEntities: false,
    },
    dbName: 'your-db-name',
    // ...
  });
  const generator = orm.getEntityGenerator();
  const dump = await generator.generate({
    save: true,
    baseDir: process.cwd() + '/my-entities',
  });
  console.log(dump);
  await orm.close(true);
})();

----------------------------------------

TITLE: Implementing Custom Logger Function
DESCRIPTION: Example of implementing a custom logging function in MikroORM configuration

LANGUAGE: typescript
CODE:
return MikroORM.init({
  debug: true,
  logger: msg => myCustomLogger.log(msg),
});

----------------------------------------

TITLE: Using Opt Type for Optional Properties in MikroORM
DESCRIPTION: This code demonstrates the use of the Opt type to define optional properties in MikroORM entities. It shows both generic and intersection approaches.

LANGUAGE: typescript
CODE:
import { Opt, Entity, PrimaryKey, Property } from '@mikro-orm/core';

@Entity()
class User {

  @PrimaryKey()
  id!: number;

  @Property()
  firstName!: string;

  @Property()
  middleName: string & Opt = '';

  @Property()
  lastName!: string;

  @Property({ persist: false })
  get fullName(): Opt<string> {
    return `${this.firstName} ${this.middleName} ${this.lastName}`;
  }

}

----------------------------------------

TITLE: Configuring Extended Entity Repository in TypeScript for MikroORM
DESCRIPTION: Shows how to configure MikroORM to use the extended entity repository globally. This applies the custom repository to all entities that don't specify a specific repository.

LANGUAGE: typescript
CODE:
MikroORM.init({
   entityRepository: ExtendedEntityRepository,
})

----------------------------------------

TITLE: SchemaGenerator Configuration in MikroORM
DESCRIPTION: TypeScript configuration for SchemaGenerator including foreign key handling and schema ignoring options.

LANGUAGE: typescript
CODE:
const orm = await MikroORM.init({
  // default values:
  schemaGenerator: {
    disableForeignKeys: true, // wrap statements with `set foreign_key_checks = 0` or equivalent
    createForeignKeyConstraints: true, // whether to generate FK constraints
    ignoreSchema: [], // allows ignoring some schemas when diffing
  },
});

----------------------------------------

TITLE: Demonstrating Property Validation in MikroORM with TypeScript
DESCRIPTION: This code snippet illustrates various scenarios of property validation in MikroORM, including type mismatches, automatic conversions, and error handling. It shows how the ORM validates and converts data types before persisting entities.

LANGUAGE: typescript
CODE:
// number instead of string will throw
const author = new Author('test', 'test');
wrap(author).assign({ name: 111, email: 222 });
await orm.em.persistAndFlush(author); // throws "Validation error: trying to set Author.name of type 'string' to '111' of type 'number'"

// string date with unknown format will throw
wrap(author).assign(author, { name: '333', email: '444', born: 'asd' });
await orm.em.persistAndFlush(author); // throws "Validation error: trying to set Author.born of type 'date' to 'asd' of type 'string'"

// string date with correct format will be auto-corrected
wrap(author).assign({ name: '333', email: '444', born: '2018-01-01' });
await orm.em.persistAndFlush(author);
console.log(author.born).toBe(true); // instance of Date

// Date object will be ok
wrap(author).assign({ born: new Date() });
await orm.em.persistAndFlush(author);
console.log(author.born).toBe(true); // instance of Date

// null will be ok
wrap(author).assign({ born: null });
await orm.em.persistAndFlush(author);
console.log(author.born); // null

// string number with correct format will be auto-corrected
wrap(author).assign({ age: '21' });
await orm.em.persistAndFlush(author);
console.log(author.age); // number 21

// string instead of number with will throw
wrap(author).assign({ age: 'asd' });
await orm.em.persistAndFlush(author); // throws "Validation error: trying to set Author.age of type 'number' to 'asd' of type 'string'"
wrap(author).assign({ age: new Date() });
await orm.em.persistAndFlush(author); // throws "Validation error: trying to set Author.age of type 'number' to '2019-01-17T21:14:23.875Z' of type 'date'"
wrap(author).assign({ age: false });
await orm.em.persistAndFlush(author); // throws "Validation error: trying to set Author.age of type 'number' to 'false' of type 'boolean'"

----------------------------------------

TITLE: Installing MikroORM with Database Drivers (Yarn)
DESCRIPTION: Commands for installing MikroORM and corresponding database drivers using Yarn package manager.

LANGUAGE: sh
CODE:
$ yarn add mikro-orm mongodb # for mongo
$ yarn add mikro-orm mysql2  # for mysql/mariadb
$ yarn add mikro-orm mariadb # for mysql/mariadb
$ yarn add mikro-orm pg      # for postgresql
$ yarn add mikro-orm sqlite3 # for sqlite

----------------------------------------

TITLE: Defining Primary Keys with @PrimaryKey Decorator in TypeScript
DESCRIPTION: Examples of using the @PrimaryKey decorator to define different types of primary keys for entities.

LANGUAGE: typescript
CODE:
@PrimaryKey()
id!: number; // auto increment PK in SQL drivers

@PrimaryKey({ autoincrement: false })
id!: number; // numeric PK without auto increment

@PrimaryKey()
uuid: string = uuid.v4(); // uuid PK in SQL drivers

@PrimaryKey()
_id!: ObjectId; // ObjectId PK in mongodb driver

----------------------------------------

TITLE: MikroORM Test Setup Utility in TypeScript
DESCRIPTION: Defines a utility function for initializing a test environment with MikroORM, including in-memory database setup and schema creation.

LANGUAGE: TypeScript
CODE:
import { bootstrap } from '../src/app.js';
import { initORM } from '../src/db.js';

export async function initTestApp(port: number) {
  const { orm } = await initORM({
    debug: false,
    dbName: ':memory:',
  });

  await orm.schema.createSchema();

  const { app } = await bootstrap(port);

  return app;
}

----------------------------------------

TITLE: Author Entity with Complex Properties
DESCRIPTION: Example of Author entity with various property types including dates, collections, and version tracking

LANGUAGE: typescript
CODE:
@Entity()
export class Author {

  @PrimaryKey()
  _id!: ObjectId;

  @SerializedPrimaryKey()
  id!: string;

  @Property()
  createdAt: Date = new Date();

  @Property({ onUpdate: () => new Date() })
  updatedAt: Date = new Date();

  @Property()
  name!: string;

  @Property()
  email!: string;

  @Property({ nullable: true })
  age?: number;

  @Property()
  termsAccepted: boolean = false;

  @Property({ nullable: true })
  identities?: string[];

  @Property({ nullable: true })
  born?: Date;

  @OneToMany(() => Book, book => book.author)
  books = new Collection<Book>(this);

  @ManyToMany(() => Author)
  friends = new Collection<Author>(this);

  @ManyToOne(() => Book, { nullable: true })
  favouriteBook?: Book;

  @Property({ version: true })
  version!: number;

  constructor(name: string, email: string) {
    this.name = name;
    this.email = email;
  }

}

----------------------------------------

TITLE: SQL for Creating Index on JSON Property in PostgreSQL
DESCRIPTION: This SQL snippet shows the resulting query for creating an index on a JSON property in PostgreSQL. It demonstrates how to access a specific JSON field when creating the index.

LANGUAGE: sql
CODE:
create index "book_meta_data_foo_index" on "book" (("meta_data"->>'foo'));

----------------------------------------

TITLE: Using MongoDB Aggregate Method with MikroORM
DESCRIPTION: This example demonstrates how to use the aggregate() method with the MongoDB driver in MikroORM.

LANGUAGE: ts
CODE:
import { EntityManager } from '@mikro-orm/mongodb';

const em = orm.em as EntityManager;
const ret = await em.aggregate(...);

----------------------------------------

TITLE: Implementing Custom Naming Strategy in TypeScript
DESCRIPTION: Shows how to implement and configure a custom naming strategy by implementing the NamingStrategy interface when initializing MikroORM.

LANGUAGE: typescript
CODE:
class MyCustomNamingStrategy implements NamingStrategy {
  ...
}

const orm = await MikroORM.init({
  ...
  namingStrategy: MyCustomNamingStrategy,
  ...
});

----------------------------------------

TITLE: Implementing Single Table Inheritance in TypeScript with MikroORM
DESCRIPTION: Shows how to implement Single Table Inheritance using discriminator columns and maps in MikroORM entities.

LANGUAGE: typescript
CODE:
@Entity({
  discriminatorColumn: 'discr',
  discriminatorMap: { person: 'Person', employee: 'Employee' },
})
export class Person {
  // ...
}

@Entity()
export class Employee extends Person {
  // ...
}

----------------------------------------

TITLE: Defining SQL Virtual Entity with reflect-metadata
DESCRIPTION: Creates a virtual entity class BookWithAuthor that maps to a SQL query joining books with authors and tags. Uses the reflect-metadata approach with decorators to define the entity structure.

LANGUAGE: typescript
CODE:
@Entity({
  expression: 'select name, age, ' +
    '(select count(*) from book b where b.author_id = a.id) as total_books, ' +
    '(select group_concat(distinct t.name) from book b ' +
      'join tags_ordered bt on bt.book_id = b.id ' +
      'join book_tag t on t.id = bt.book_tag_id ' +
      'where b.author_id = a.id ' +
      'group by b.author_id) as used_tags ' +
    'from author a group by a.id',
})
export class BookWithAuthor {

  @Property()
  title!: string;

  @Property()
  authorName!: string;

  @Property()
  tags!: string[];

}

----------------------------------------

TITLE: Persisting Entities with Relationships
DESCRIPTION: Example of creating and persisting entities with relationships and cascade persistence

LANGUAGE: typescript
CODE:
const author = new Author('Jon Snow', 'snow@wall.st');
author.born = new Date();

const publisher = new Publisher('7K publisher');

const book1 = new Book('My Life on The Wall, part 1', author);
book1.publisher = publisher;
const book2 = new Book('My Life on The Wall, part 2', author);
book2.publisher = publisher;
const book3 = new Book('My Life on The Wall, part 3', author);
book3.publisher = publisher;

// just persist books, author and publisher will be automatically cascade persisted
await orm.em.persistAndFlush([book1, book2, book3]);

----------------------------------------

TITLE: Using Transactions in MikroORM
DESCRIPTION: Example of using transactions in MikroORM with the transactional method, which provides a forked EntityManager for isolated operations.

LANGUAGE: typescript
CODE:
// if an error occurs inside the callback, all db queries from inside the callback will be rolled back
await orm.em.transactional(async (em: EntityManager) => {
  const god = new Author('God', 'hello@heaven.god');
  await em.persist(god).flush();
});

----------------------------------------

TITLE: Defining Entity using EntitySchema in TypeScript
DESCRIPTION: Demonstrates how to define a Book entity using EntitySchema helper with relationships to Author, Publisher and BookTags.

LANGUAGE: typescript
CODE:
export interface Book extends BaseEntity {
  title: string;
  author: Author;
  publisher: Publisher;
  tags: Collection<BookTag>;
}

export const schema = new EntitySchema<Book, BaseEntity>({
  name: 'Book',
  extends: 'BaseEntity',
  properties: {
    title: { type: 'string' },
    author: { reference: 'm:1', entity: 'Author', inversedBy: 'books' },
    publisher: { reference: 'm:1', entity: 'Publisher', inversedBy: 'books' },
    tags: { reference: 'm:n', entity: 'BookTag', inversedBy: 'books', fixedOrder: true },
  },
});

----------------------------------------

TITLE: Handling Transactions in MikroORM
DESCRIPTION: Example of using the transactional method to run a callback within a database transaction, ensuring all operations are rolled back if an error occurs.

LANGUAGE: typescript
CODE:
// if an error occurs inside the callback, all db queries from inside the callback will be rolled back
await orm.em.transactional(async (em: EntityManager) => {
  const god = new Author('God', 'hello@heaven.god');
  await em.persist(god).flush();
});

----------------------------------------

TITLE: Initializing MikroORM with JavaScript Entities
DESCRIPTION: Example of initializing MikroORM with JavaScript entities, showing how to register entity classes in the ORM configuration.

LANGUAGE: javascript
CODE:
const orm = await MikroORM.init({
  entities: [Author, Book, BookTag, BaseEntity],
  dbName: 'my-db-name',
});

----------------------------------------

TITLE: Defining SQL Virtual Entity with reflect-metadata
DESCRIPTION: Creates a virtual entity class BookWithAuthor that maps to a SQL query joining books with authors and tags. Uses the reflect-metadata approach with decorators to define the entity structure.

LANGUAGE: typescript
CODE:
@Entity({
  expression: 'select name, age, ' +
    '(select count(*) from book b where b.author_id = a.id) as total_books, ' +
    '(select group_concat(distinct t.name) from book b ' +
      'join tags_ordered bt on bt.book_id = b.id ' +
      'join book_tag t on t.id = bt.book_tag_id ' +
      'where b.author_id = a.id ' +
      'group by b.author_id) as used_tags ' +
    'from author a group by a.id',
})
export class BookWithAuthor {

  @Property()
  title!: string;

  @Property()
  authorName!: string;

  @Property()
  tags!: string[];

}

----------------------------------------

TITLE: Demonstrating Bi-directional Propagation in Many-to-Many Relations with MikroORM
DESCRIPTION: This snippet illustrates how propagation works in many-to-many relations from both owning and inverse sides. It shows adding a tag to a book's collection and vice versa, demonstrating that the changes are reflected on both sides.

LANGUAGE: typescript
CODE:
// many to many works both from owning side and from inverse side
const book = new Book(...);
const tag = new BookTag(...);

book.tags.add(tag);
console.log(tag.books.contains(book)); // true

tag.books.add(book);
console.log(book.tags.contains(tag)); // true

----------------------------------------

TITLE: Defining ManyToOne Reference with Dataloader Support
DESCRIPTION: Example of defining a ManyToOne relationship using the Reference wrapper to enable dataloader support.

LANGUAGE: typescript
CODE:
@ManyToOne(() => Book, { ref: true })
book!: Ref<Book>;

----------------------------------------

TITLE: Initializing Dataloaders in MikroORM Configuration
DESCRIPTION: Shows how to enable dataloaders globally in MikroORM initialization. Supports different modes including REFERENCE, COLLECTION, and ALL.

LANGUAGE: typescript
CODE:
import { Dataloader } from '@mikro-orm/core';

MikroORM.init({
  dataloader: Dataloader.ALL,
});

----------------------------------------

TITLE: Using Custom Logger Function in MikroORM (TypeScript)
DESCRIPTION: This example demonstrates how to provide a custom logger function in MikroORM configuration. It allows for custom logging implementation.

LANGUAGE: typescript
CODE:
return MikroORM.init({
  debug: true,
  logger: msg => myCustomLogger.log(msg),
});

----------------------------------------

TITLE: Configuring Global Loading Strategy in MikroORM
DESCRIPTION: Example demonstrating how to set a default loading strategy globally in MikroORM configuration.

LANGUAGE: typescript
CODE:
MikroORM.init({
  loadStrategy: LoadStrategy.JOINED,
});

----------------------------------------

TITLE: Configuring MikroORM Migrations
DESCRIPTION: Configuration options for MikroORM migrations including table name, path, patterns, and transaction settings.

LANGUAGE: typescript
CODE:
await MikroORM.init({
  // default values:
  migrations: {
    tableName: 'mikro_orm_migrations', // name of database table with log of executed transactions
    path: './migrations', // path to the folder with migrations
    pattern: /^[\w-]+\d+\.ts$/, // regex pattern for the migration files
    transactional: true, // wrap each migration in a transaction
    disableForeignKeys: true, // wrap statements with `set foreign_key_checks = 0` or equivalent
    allOrNothing: true, // wrap all migrations in master transaction
    dropTables: true, // allow to disable table dropping
    safe: false, // allow to disable table and column dropping
    emit: 'ts', // migration generation mode
  },
})

----------------------------------------

TITLE: Handling Database Transactions
DESCRIPTION: Example of handling database transactions using MikroORM's transactional method with proper error handling and entity management.

LANGUAGE: typescript
CODE:
await orm.em.transactional(async (em: EntityManager) => {
  const god = new Author('God', 'hello@heaven.god');
  await em.persist(god).flush();
});

----------------------------------------

TITLE: Using Cascade Merge in MikroORM
DESCRIPTION: Example showing cascade merge usage when handling large data imports while maintaining entity relationships.

LANGUAGE: typescript
CODE:
const a1 = new Author(...);
a1.favouriteBook = new Book('the best', ...);
await orm.em.persistAndFlush(a1); // cascade persists favourite book as well

for (let i = 1; i < 1000; i++) {
  const book = new Book('...', a1);
  orm.em.persistLater(book);

  // persist every 100 records
  if (i % 100 === 0) {
    await orm.em.flush();
    orm.em.clear(); // this makes both a1 and his favourite book detached
    orm.em.merge(a1); // so we need to merge them to prevent cascade-inserts

    // without cascade merge, you would need to manually merge all his associations
    orm.em.merge(a1.favouriteBook); // not needed with Cascade.MERGE
  }
}

await orm.em.flush();

----------------------------------------

TITLE: Adding Authentication to Hapi AdminJS Setup
DESCRIPTION: Example of implementing authentication in Hapi-based AdminJS setup using auth configuration options.

LANGUAGE: typescript
CODE:
const ADMIN_EMAIL = 'example@test.com';
const ADMIN_PASSWORD = 'password';

const adminOptions = {
  databases: [orm],
  auth: {
    authenticate: async (email, password) => {
      /* Your code for verifying email & password goes here */
      return email === ADMIN_EMAIL && password === ADMIN_PASSWORD
        ? { email } // the function should return an object containing user's data if authenticated successfully
        : null;
    },
    strategy: 'session',
    cookiePassword: process.env.COOKIE_PASSWORD ?? 'makesurepasswordissecure',
    isSecure: false, // only https requests
  },
};

----------------------------------------

TITLE: Basic Query Builder Import
DESCRIPTION: Importing the required EntityManager and EntityRepository types for Query Builder access

LANGUAGE: typescript
CODE:
import { EntityManager, EntityRepository } from '@mikro-orm/mysql'; // or any other driver package

----------------------------------------

TITLE: Defining Shadow Properties in Entity using TypeScript
DESCRIPTION: This example demonstrates how to define shadow properties in an entity, which are not persisted to the database but are part of the serialized result.

LANGUAGE: typescript
CODE:
@Entity()
class Book {

  @Property({ persist: false })
  count?: number;

}

const book = new Book(...);
wrap(book).assign({ count: 123 });
console.log(wrap(book).toObject().count); // 123
console.log(wrap(book).toJSON().count); // 123

----------------------------------------

TITLE: Simplified Single Field AND Query
DESCRIPTION: Shows a more concise way to write AND conditions for a single field by combining all operators in one object.

LANGUAGE: typescript
CODE:
const res = await orm.em.find(Author, {
  id: {
    $in: [1, 2, 7],
    $nin: [3, 4],
    $gt: 5,
    $lt: 10,
    $gte: 7,
    $lte: 8,
    $ne: 9,
  },
});

----------------------------------------

TITLE: Defining Entity with Manual Type Specifications
DESCRIPTION: Illustrates how to define an entity with manual type specifications for properties and relationships. This approach allows skipping the discovery process in production.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @PrimaryKey({ type: 'number' })
  id!: number;

  @Property({ type: 'string' })
  title!: string;

  @Enum(() => BookStatus)
  status?: BookStatus;

  @ManyToOne(() => Author) // or `@ManyToOne({ type: 'Author' })` or `@ManyToOne({ entity: () => Author })`
  author1!: Author;

  // or
  @ManyToOne({ type: 'Author' })
  author2!: Author;

  // or
  @ManyToOne({ entity: () => Author })
  author3!: Author;

}

export enum BookStatus {
  SOLD_OUT = 'sold',
  ACTIVE = 'active',
  UPCOMING = 'upcoming',
 }

----------------------------------------

TITLE: Demonstrating Orphan Removal Behavior in MikroORM
DESCRIPTION: Shows how orphan removal behaves when manipulating collections in MikroORM, demonstrating that disconnected entities are removed.

LANGUAGE: typescript
CODE:
await author.books.set([book1, book2]); // replace whole collection
await author.books.remove(book1); // remove book from collection
await orm.em.persist(author).flush(); // book1 will be removed, as well as all original items (before we called `set()`)

----------------------------------------

TITLE: Entity Reference Initialization Example
DESCRIPTION: Demonstrates how to work with entity references, checking initialization status and lazy loading entity data.

LANGUAGE: typescript
CODE:
const user = em.getReference(User, 123);
console.log(user.id); // prints `123`, accessing the id will not trigger any db call
console.log(wrap(user).isInitialized()); // false, it's just a reference
console.log(user.name); // undefined

await wrap(user).init(); // this will trigger db call
console.log(wrap(user).isInitialized()); // true
console.log(user.name); // defined

----------------------------------------

TITLE: Initializing MikroORM with MongoDB Indexes in TypeScript
DESCRIPTION: This snippet shows how to initialize MikroORM with MongoDB indexes enabled. It includes setting the ensureIndexes option to automatically create new indexes when initializing the ORM.

LANGUAGE: typescript
CODE:
const orm = await MikroORM.init({
  entities: [Author, Book, ...],
  dbName: 'my-db-name',
  ensureIndexes: true, // defaults to false
});

----------------------------------------

TITLE: Using QueryBuilder for Native SQL Queries
DESCRIPTION: Examples of using QueryBuilder to construct and execute native SQL queries

LANGUAGE: typescript
CODE:
const qb = orm.em.createQueryBuilder(Author);
qb.update({ name: 'test 123', type: PublisherType.GLOBAL }).where({ id: 123, type: PublisherType.LOCAL });

console.log(qb.getQuery());
console.log(qb.getParams());

const res1 = await qb.execute();

const driver = orm.em.getDriver();
const res2 = await driver.execute('SELECT ? + ?', [1, 2]);

----------------------------------------

TITLE: Configuring Global Result Cache Settings in MikroORM
DESCRIPTION: Illustrates how to configure global result cache settings, including custom adapters and default expiration, during MikroORM initialization.

LANGUAGE: typescript
CODE:
const orm = await MikroORM.init({
  resultCache: {
    // following options are the defaults
    adapter: MemoryCacheAdapter,
    expiration: 1000, // 1s
    options: {},
    // cache can be also enabled globally
    // global: 50, // 50ms
  },
  // ...
});

----------------------------------------

TITLE: Implementing Cascade Remove in MikroORM TypeScript
DESCRIPTION: Illustrates how cascade remove works in MikroORM, showing that related entities can be removed when the main entity is removed if the cascade option is set appropriately.

LANGUAGE: typescript
CODE:
await orm.em.remove(book).flush(); // this will also remove book.publisher

----------------------------------------

TITLE: Initializing MikroORM with MongoDB in TypeScript
DESCRIPTION: This snippet demonstrates how to initialize MikroORM with MongoDB. It includes setting up entities, specifying the database name, and connecting using a client URL.

LANGUAGE: typescript
CODE:
import { MikroORM } from '@mikro-orm/mongodb'; // or any other driver package

const orm = await MikroORM.init({
  entities: [Author, Book, ...],
  dbName: 'my-db-name',
  clientUrl: '...',
});
console.log(orm.em); // access EntityManager via `em` property

----------------------------------------

TITLE: Overriding PopulateHint on a Query in MikroORM with TypeScript
DESCRIPTION: This snippet demonstrates how to override the PopulateHint on a specific query in MikroORM, instructing it to interpret the find as per the second interpretation.

LANGUAGE: typescript
CODE:
const books = await em.find(Book, { tags: { name: 'Fiction' } }, {
  populate: ['tags'],
  populateWhere: PopulateHint.INFER,
});

----------------------------------------

TITLE: Implementing Basic BigInt Primary Key in MikroORM
DESCRIPTION: Simple implementation of a bigint primary key using native BigInt type in MikroORM v6+. No explicit type declaration is required in decorator options.

LANGUAGE: typescript
CODE:
@PrimaryKey()
id: bigint;

----------------------------------------

TITLE: Initializing MikroORM Dataloaders Configuration
DESCRIPTION: Shows how to enable dataloaders globally in MikroORM configuration. Demonstrates using DataloaderType enum to enable loaders for references, collections, or both.

LANGUAGE: typescript
CODE:
import { DataloaderType } from '@mikro-orm/core';

MikroORM.init({
  dataloader: DataloaderType.ALL,
});

----------------------------------------

TITLE: Initializing Embeddables in TypeScript with MikroORM
DESCRIPTION: This code shows how to initialize an embeddable object to avoid null values when all fields are nullable.

LANGUAGE: typescript
CODE:
@Embedded()
address = new Address();

----------------------------------------

TITLE: Defining ManyToOne Relationship in TypeScript
DESCRIPTION: Example of defining a basic ManyToOne relationship using TypeScript decorators in MikroORM.

LANGUAGE: typescript
CODE:
@ManyToOne(() => User)
author!: User; // the value is always instance of the `User` entity

----------------------------------------

TITLE: Using Rel Type for Relations in ESM Projects with MikroORM (TypeScript)
DESCRIPTION: This snippet demonstrates how to use the Rel mapped type to avoid circular dependency issues in ESM projects using MikroORM with TypeScript. It shows how to define a ManyToOne relationship using Rel.

LANGUAGE: typescript
CODE:
import { Rel } from '@mikro-orm/core';

@Entity()
export class Book {

  @ManyToOne(() => Author)
  author!: Rel<Author>;

}

----------------------------------------

TITLE: Initializing MikroORM with SQL Database
DESCRIPTION: Configuration example for initializing MikroORM with a SQL database driver.

LANGUAGE: typescript
CODE:
const orm = await MikroORM.init({
  entities: [Author, Book, ...],
  dbName: 'my-db-name',
  type: 'mysql', // or 'sqlite' or 'postgresql' or 'mariadb'
});

----------------------------------------

TITLE: Query by Non-Primary Key Properties
DESCRIPTION: Shows how Identity Map works when querying entities by properties other than primary key, still maintaining reference equality but requiring database calls.

LANGUAGE: typescript
CODE:
const jon1 = await em.findOne(Author, { name: 'Jon Snow' });
const jon2 = await em.findOne(Author, { name: 'Jon Snow' });

// identity map in action
console.log(jon1 === jon2); // true

----------------------------------------

TITLE: Basic Entity Persistence in MikroORM
DESCRIPTION: Demonstrates basic entity persistence using implicit transaction handling. Creates and persists a new User entity.

LANGUAGE: typescript
CODE:
const user = new User();
user.name = 'George';
await orm.em.persistAndFlush(user);

----------------------------------------

TITLE: Defining ManyToOne Relation in TypeScript
DESCRIPTION: This snippet shows how to define a ManyToOne relation using TypeScript decorators in MikroORM. It demonstrates the basic syntax for creating a relation to an Author entity.

LANGUAGE: typescript
CODE:
@ManyToOne(() => Author)
author!: Author; // the value is always instance of the `Author` entity

----------------------------------------

TITLE: Basic CRUD Operations with MikroORM EntityManager
DESCRIPTION: Examples of creating, reading, updating, and deleting entities using MikroORM's EntityManager.

LANGUAGE: typescript
CODE:
// Creating a new user
const user = new User();
user.email = 'foo@bar.com';
user.fullName = 'Foo Bar';
user.password = '123456';

const em = orm.em.fork();
await em.persist(user).flush();

// Reading entities
const userById = await em.findOne(User, 1);
const userByEmail = await em.findOne(User, { email: 'foo@bar.com' });
const allUsers = await em.find(User, {});

// Updating an entity
user.bio = '...';
await em.flush();

// Deleting an entity
await em.remove(user).flush();

// Using entity references
const userRef = em.getReference(User, 1);
await em.remove(userRef).flush();

----------------------------------------

TITLE: Populating Nested Relations in MikroORM (TypeScript)
DESCRIPTION: Demonstrates how to populate nested relations in MikroORM using the find method with a populate option. This snippet shows how to load BookTags with their associated Books, Publishers, Tests, and Authors.

LANGUAGE: typescript
CODE:
const tags = await em.find(BookTag, {}, {
  populate: ['books.publisher.tests', 'books.author'],
});
console.log(tags[0].books[0].publisher.tests[0].name); // prints name of nested test
console.log(tags[0].books[0].author.name); // prints name of nested author

----------------------------------------

TITLE: Many-to-Many Bidirectional Collection Propagation
DESCRIPTION: Demonstrates how many-to-many relation propagation works from both owning and inverse sides when using collection operations.

LANGUAGE: typescript
CODE:
// many to many works both from owning side and from inverse side
const book = new Book(...);
const tag = new BookTag(...);

book.tags.add(tag);
console.log(tag.books.contains(book)); // true

tag.books.add(book);
console.log(book.tags.contains(tag)); // true

----------------------------------------

TITLE: Explicit Discriminator Column Implementation in MikroORM
DESCRIPTION: Shows how to explicitly define discriminator columns for type-based querying and serialization control in inheritance mapping.

LANGUAGE: typescript
CODE:
@Entity({
  discriminatorColumn: 'type',
  discriminatorMap: { person: 'Person', employee: 'Employee' },
})
export abstract class BasePerson {

  @Enum()
  type!: 'person' | 'employee';

}

@Entity()
export class Person extends BasePerson {
  // ...
}

@Entity()
export class Employee extends Person {
  // ...
}

----------------------------------------

TITLE: Upserting Entities in MikroORM
DESCRIPTION: Shows how to use the upsert() method to create or update entities based on their existence in the database.

LANGUAGE: typescript
CODE:
const author = await em.upsert(Author, { email: 'foo@bar.com', age: 33 });

// Using detached entity instance
const author = em.create(Author, { email: 'foo@bar.com', age: 33 });
await em.upsert(author);

// Upserting multiple entities
const [author1, author2, author3] = await em.upsertMany(Author, [
  { email: 'a1', age: 41 },
  { email: 'a2', age: 42 },
  { email: 'a3', age: 43 },
]);

----------------------------------------

TITLE: Creating a Basic Seeder in MikroORM
DESCRIPTION: Shows how to create a simple seeder class that creates an Author entity.

LANGUAGE: typescript
CODE:
import { EntityManager } from '@mikro-orm/core';
import { Seeder } from '@mikro-orm/seeder';
import { Author } from './author'

export class DatabaseSeeder extends Seeder {

  async run(em: EntityManager): Promise<void> {
    // will get persisted automatically
    const author = em.create(Author, {
      name: 'John Snow',
      email: 'snow@wall.st'
    });

    // but if we would do `const author = new Author()` instead,
    // we would need to call `em.persist(author)` explicitly.
  }
}

----------------------------------------

TITLE: Initializing Fastify App with MikroORM RequestContext
DESCRIPTION: Bootstrap function that initializes a Fastify application with MikroORM request context handling and basic article endpoint.

LANGUAGE: typescript
CODE:
import { MikroORM, RequestContext } from '@mikro-orm/core';
import { fastify } from 'fastify';

export async function bootstrap(port = 3001) {
  const orm = await MikroORM.init();
  const app = fastify();

  app.addHook('onRequest', (request, reply, done) => {
    RequestContext.create(orm.em, done);
  });

  app.addHook('onClose', async () => {
    await orm.close();
  });

  const url = await app.listen({ port });

  return { app, url };
}

----------------------------------------

TITLE: Defining MongoDB Entity with MikroORM
DESCRIPTION: This code defines a MongoDB entity (MongoBook) using MikroORM decorators. It includes primary key, properties, and relationships with other entities.

LANGUAGE: typescript
CODE:
@Entity()
export class MongoBook {

  @PrimaryKey()
  _id: ObjectID;

  @SerializedPrimaryKey()
  id: string;

  @Property()
  title: string;

  @ManyToOne(() => Author)
  author: Author;

  @ManyToMany(() => BookTag)
  tags = new Collection<BookTag>(this);

  constructor(title: string, author: Author) {
    this.title = title;
    this.author = author;
  }

}

----------------------------------------

TITLE: Entity Manager Fork Usage in Express
DESCRIPTION: Example of using EntityManager fork in Express middleware for request isolation

LANGUAGE: typescript
CODE:
const app = express();

app.use((req, res, next) => {
  req.em = orm.em.fork(); // save the fork to `req` object
});

app.get('/books', async (req, res) => {
  const books = await req.em.find(Book); // use the fork via `req.em`
});

----------------------------------------

TITLE: Using Rel Type for ESM Projects in MikroORM
DESCRIPTION: Demonstrates how to use the Rel mapped type to avoid circular dependency issues in ESM projects using reflect-metadata.

LANGUAGE: typescript
CODE:
import { Rel } from '@mikro-orm/core';

@Entity()
export class Book {

  @ManyToOne(() => Author)
  author!: Rel<Author>;

}

----------------------------------------

TITLE: Configuring SQL EntityManager in MikroORM
DESCRIPTION: Demonstrates how to properly import and type SQL EntityManager to access QueryBuilder functionality.

LANGUAGE: typescript
CODE:
import { EntityManager } from '@mikro-orm/mysql'; // or any other SQL driver package

const em = orm.em as EntityManager;
const qb = await em.createQueryBuilder(...);

LANGUAGE: typescript
CODE:
import { MikroORM } from '@mikro-orm/mysql'; // or any other SQL driver package

const orm = await MikroORM.init({
  // ...
});
console.log(orm.em); // access EntityManager via `em` property

----------------------------------------

TITLE: Initializing Fastify App with MikroORM RequestContext
DESCRIPTION: Bootstrap function that initializes a Fastify application with MikroORM request context handling and basic article endpoint.

LANGUAGE: typescript
CODE:
import { MikroORM, RequestContext } from '@mikro-orm/core';
import { fastify } from 'fastify';

export async function bootstrap(port = 3001) {
  const orm = await MikroORM.init();
  const app = fastify();

  app.addHook('onRequest', (request, reply, done) => {
    RequestContext.create(orm.em, done);
  });

  app.addHook('onClose', async () => {
    await orm.close();
  });

  const url = await app.listen({ port });

  return { app, url };
}

----------------------------------------

TITLE: Overriding PopulateHint for Specific Query in MikroORM (TypeScript)
DESCRIPTION: Demonstrates how to override the global populate hint for a specific query using the populateWhere option in the find method.

LANGUAGE: typescript
CODE:
const books = await em.find(Book, { tags: { name: 'Fiction' } }, {
  populate: ['tags'],
  populateWhere: PopulateHint.INFER,
});

----------------------------------------

TITLE: Entity Definition with ts-morph
DESCRIPTION: Example showing how to define entities using the ts-morph metadata provider for more concise type definitions

LANGUAGE: typescript
CODE:
@Entity()
export class Book extends BaseEntity {
  @Property()
  title!: string;

  @ManyToOne()
  author!: Author;

  @ManyToOne()
  publisher?: IdentifiedReference<Publisher>;

  @ManyToMany({ fixedOrder: true })
  tags = new Collection<BookTag>(this);
}

----------------------------------------

TITLE: Using Built-in Types in MikroORM
DESCRIPTION: This snippet shows how to use built-in types provided by MikroORM, such as ArrayType, BigIntType, and JsonType.

LANGUAGE: typescript
CODE:
import { Property, types } from '@mikro-orm/core';

@Property({ type: types.bigint, nullable: true })
largeNumber?: string;

@Property({ type: ArrayType, nullable: true })
stringArray?: string[];

@Property({ type: new ArrayType(i => +i), nullable: true })
numericArray?: number[];

@Property({ type: JsonType, nullable: true })
object?: { foo: string; bar: number };

----------------------------------------

TITLE: Configuring MongoDB Transactions
DESCRIPTION: Configuration for enabling MongoDB transactions with replica set support and collection creation.

LANGUAGE: typescript
CODE:
import { MikroORM } from '@mikro-orm/core';
import { MongoDriver } from '@mikro-orm/mongodb';

// make sure to provide the MongoDriver type hint
const orm = await MikroORM.init<MongoDriver>({
  entities: [Author, Book, ...],
  clientUrl: 'mongodb://localhost:27017,localhost:27018,localhost:27019/my-db-name?replicaSet=rs0',
  type: 'mongo',
  implicitTransactions: true, // defaults to false
});

await orm.em.getDriver().createCollections();

----------------------------------------

TITLE: Feature Documentation - makeEntity Method
DESCRIPTION: Documentation of new makeEntity method being exposed in Factory class that does not call em.persist()

LANGUAGE: markdown
CODE:
### Features

* **seeder:** expose `Factory.makeEntity` method that does not call `em.persist()` ([bb8f1b0](https://github.com/mikro-orm/mikro-orm/commit/bb8f1b03f7c25811f87311e997646bf793b52a13)), closes [#3932](https://github.com/mikro-orm/mikro-orm/issues/3932)

----------------------------------------

TITLE: Using Knex.js Query Builder in MikroORM 3
DESCRIPTION: Demonstrates how to access and use the Knex.js query builder instance from MikroORM's QueryBuilder. It shows creating a query, executing it, and mapping the results to entities.

LANGUAGE: typescript
CODE:
const qb = orm.em.createQueryBuilder(Author);
qb.update({ name: 'test 123', type: PublisherType.GLOBAL }).where({ id: 123, type: PublisherType.LOCAL });
const knex = qb.getKnexQuery(); // instance of Knex' QueryBuilder
// do what ever you need with `knex`
const res = await orm.em.getConnection().execute(knex);
const entities = res.map(a => orm.em.map(Author, a));
console.log(entities); // Author[]

----------------------------------------

TITLE: Defining Basic Entity Schema in TypeScript
DESCRIPTION: Example of defining a Book entity schema with relationships to Author, Publisher, and BookTag entities. Shows how to configure basic properties and relationships using EntitySchema.

LANGUAGE: typescript
CODE:
export interface Book extends CustomBaseEntity {
  title: string;
  author: Author;
  publisher: Publisher;
  tags: Collection<BookTag>;
}

export const schema = new EntitySchema<Book, CustomBaseEntity>({
  name: 'Book',
  extends: CustomBaseEntitySchema,
  properties: {
    title: { type: 'string' },
    author: { kind: 'm:1', entity: 'Author', inversedBy: 'books' },
    publisher: { kind: 'm:1', entity: 'Publisher', inversedBy: 'books' },
    tags: { kind: 'm:n', entity: 'BookTag', inversedBy: 'books', fixedOrder: true },
  },
});

----------------------------------------

TITLE: Creating ManyToMany Pivot Table in SQL
DESCRIPTION: SQL command to create a pivot table for handling ManyToMany relations in SQL databases.

LANGUAGE: sql
CODE:
CREATE TABLE `publisher_to_test` (
  `id` int(11) unsigned NOT NULL AUTO_INCREMENT,
  `publisher_id` int(11) DEFAULT NULL,
  `test_id` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

----------------------------------------

TITLE: Defining Article and ArticleAttribute Entities with Foreign Key as Primary Key in TypeScript
DESCRIPTION: This example demonstrates how to create entities with a foreign key as part of the primary key. The ArticleAttribute entity uses a combination of a foreign key (article) and a primitive type (attribute) as its composite primary key.

LANGUAGE: typescript
CODE:
@Entity()
export class Article {

  @PrimaryKey()
  id!: number;

  @Property()
  title!: string;

  @OneToMany(() => ArticleAttribute, attr => attr.article, { cascade: Cascade.ALL })
  attributes = new Collection<ArticleAttribute>(this);

}

@Entity()
export class ArticleAttribute {

  @ManyToOne({ primary: true })
  article: Article;

  @PrimaryKey()
  attribute: string;

  @Property()
  value!: string;

  [PrimaryKeyProp]?: ['article', 'attribute'];

  constructor(name: string, value: string, article: Article) {
    this.attribute = name;
    this.value = value;
    this.article = article;
  }

}

----------------------------------------

TITLE: Defining Basic Entity Schema in TypeScript
DESCRIPTION: Example of defining a Book entity schema with relationships to Author, Publisher, and BookTag entities. Shows how to configure basic properties and relationships using EntitySchema.

LANGUAGE: typescript
CODE:
export interface Book extends CustomBaseEntity {
  title: string;
  author: Author;
  publisher: Publisher;
  tags: Collection<BookTag>;
}

export const schema = new EntitySchema<Book, CustomBaseEntity>({
  name: 'Book',
  extends: CustomBaseEntitySchema,
  properties: {
    title: { type: 'string' },
    author: { kind: 'm:1', entity: 'Author', inversedBy: 'books' },
    publisher: { kind: 'm:1', entity: 'Publisher', inversedBy: 'books' },
    tags: { kind: 'm:n', entity: 'BookTag', inversedBy: 'books', fixedOrder: true },
  },
});

----------------------------------------

TITLE: MongoDB Schema Generator Feature
DESCRIPTION: Added support for schema generator in MongoDB driver, allowing schema validation and management

LANGUAGE: typescript
CODE:
// Using new schema generator support
const schemaGenerator = orm.getSchemaGenerator();
await schemaGenerator.ensureSchema(); // Creates collections and indexes
await schemaGenerator.updateSchema(); // Updates existing schema

----------------------------------------

TITLE: EntityAssigner Usage with EntityManager
DESCRIPTION: Demonstrates the new requirement to provide EntityManager when using assign() method on new entities that aren't yet managed by the ORM.

LANGUAGE: typescript
CODE:
const book = new Book();
wrap(book).assign(data, { em: orm.em });

----------------------------------------

TITLE: Adding Authentication to Express AdminJS Setup
DESCRIPTION: TypeScript code snippet showing how to add authentication to an Express-based AdminJS setup using buildAuthenticatedRouter.

LANGUAGE: typescript
CODE:
const ADMIN_EMAIL = 'example@test.com';
const ADMIN_PASSWORD = 'password';

const router = AdminJSExpress.buildAuthenticatedRouter(admin, {
  authenticate: async (email, password) => {
    /* Your code for verifying email & password goes here */
    return email === ADMIN_EMAIL && password === ADMIN_PASSWORD
      ? { email } // the function should return an object containing user's data if authenticated successfully
      : null;
  },
  cookiePassword: process.env.COOKIE_PASSWORD ?? 'makesurepasswordissecure',
});

----------------------------------------

TITLE: Implementing a Custom Type in MikroORM 3
DESCRIPTION: Shows how to create a custom mapping type in MikroORM 3 by extending the Type abstract class. This example implements a simplified DateType.

LANGUAGE: typescript
CODE:
import { Type, Platform, EntityProperty, ValidationError } from 'mikro-orm';

export class DateType extends Type {

  convertToDatabaseValue(value: any, platform: Platform): any {
    return value.toISOString().substr(0, 10);
  }

  convertToJSValue(value: any, platform: Platform): any {
    return new Date(value);
  }

  getColumnType(): string {
    return 'date';
  }

}

----------------------------------------

TITLE: Defining Virtual Entity with MongoDB Aggregation in TypeScript
DESCRIPTION: Creates a virtual entity using MongoDB aggregation pipeline. Handles sorting, filtering, and pagination while joining book and author collections to produce equivalent results to the SQL versions.

LANGUAGE: typescript
CODE:
@Entity({
  expression: (em: EntityManager, where, options) => {
    const $sort = { ...options.orderBy } as Dictionary;
    $sort._id = 1;
    const pipeline: Dictionary[] = [
      { $project: { _id: 0, title: 1, author: 1 } },
      { $sort },
      { $match: where ?? {} },
      { $lookup: { from: 'author', localField: 'author', foreignField: '_id', as: 'author', pipeline: [{ $project: { name: 1 } }] } },
      { $unwind: '$author' },
      { $set: { authorName: '$author.name' } },
      { $unset: ['author'] },
    ];

    if (options.offset != null) {
      pipeline.push({ $skip: options.offset });
    }

    if (options.limit != null) {
      pipeline.push({ $limit: options.limit });
    }

    return em.aggregate(Book, pipeline);
  },
})
export class BookWithAuthor {

  @Property()
  title!: string;

  @Property()
  authorName!: string;

}

----------------------------------------

TITLE: Demonstrating Cascade Persist in MikroORM TypeScript
DESCRIPTION: Shows an example of how cascade persist works in MikroORM. Modifies a book entity and its related entities, then persists the changes, which cascade to the related entities.

LANGUAGE: typescript
CODE:
const book = await orm.em.findOne(Book, 'id', { populate: ['author', 'tags'] });
book.author.name = 'Foo Bar';
book.tags[0].name = 'new name 1';
book.tags[1].name = 'new name 2';
await orm.em.persist(book).flush(); // all book tags and author will be persisted too

----------------------------------------

TITLE: Adding configurable migration logging
DESCRIPTION: Feature commit adding option to disable migration logging via migrations.silent config

LANGUAGE: markdown
CODE:
### Features
* **migrator:** allow disabling logging via `migrations.silent` ([#4182](https://github.com/mikro-orm/mikro-orm/issues/4182)) ([4b778bf](https://github.com/mikro-orm/mikro-orm/commit/4b778bf2db55bdc678a13c7dd6c27c3d72fde97d)), closes [#4124](https://github.com/mikro-orm/mikro-orm/issues/4124)

----------------------------------------

TITLE: Entity Relationship Without Reference Wrapper
DESCRIPTION: Shows the type-safety issues when using @ManyToOne relationships without the Reference wrapper.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @PrimaryKey()
  id!: number;

  @ManyToOne()
  author!: Author;

  constructor(author: Author) {
    this.author = author;
  }

}

----------------------------------------

TITLE: Implementing Dynamic Attributes with Composite Primary Keys in MikroORM
DESCRIPTION: This example demonstrates how to implement dynamic attributes for an Article entity using a composite primary key that includes a foreign key reference to the Article.

LANGUAGE: typescript
CODE:
@Entity()
export class Article {

  @PrimaryKey()
  id!: number;

  @Property()
  title!: string;

  @OneToMany(() => ArticleAttribute, attr => attr.article, { cascade: Cascade.ALL })
  attributes = new Collection<ArticleAttribute>(this);

}

@Entity()
export class ArticleAttribute {

  @ManyToOne({ primary: true })
  article: Article;

  @PrimaryKey()
  attribute: string;

  @Property()
  value!: string;

  [PrimaryKeyProp]?: ['article', 'attribute'];

  constructor(name: string, value: string, article: Article) {
    this.attribute = name;
    this.value = value;
    this.article = article;
  }

}

----------------------------------------

TITLE: SQL Queries for Nested Populate in MikroORM
DESCRIPTION: Shows the SQL queries executed by MikroORM when performing a nested populate operation for SQL drivers with pivot tables. Each query corresponds to loading a different entity type in the relation chain.

LANGUAGE: sql
CODE:
SELECT `e0`.* FROM `book_tag` AS `e0`;

SELECT `e0`.*, `e1`.`book_id`, `e1`.`book_tag_id`
  FROM `book` AS `e0` LEFT JOIN `book_to_book_tag` AS `e1` ON `e0`.`id` = `e1`.`book_id`
  WHERE `e1`.`book_tag_id` IN (?, ?, ?, ?, ?)
  ORDER BY `e1`.`id` ASC;

SELECT `e0`.* FROM `publisher` AS `e0` WHERE `e0`.`id` IN (?, ?, ?);

SELECT `e0`.*, `e1`.`test_id`, `e1`.`publisher_id`
  FROM `test` AS `e0` LEFT JOIN `publisher_to_test` AS `e1` ON `e0`.`id` = `e1`.`test_id`
  WHERE `e1`.`publisher_id` IN (?, ?, ?)
  ORDER BY `e1`.`id` ASC;

SELECT `e0`.* FROM `author` AS `e0` WHERE `e0`.`id` IN (?);

----------------------------------------

TITLE: Setting up MikroORM with Express for AdminJS
DESCRIPTION: TypeScript code for initializing MikroORM, configuring AdminJS with Express, and setting up the server. Includes optional class-validator integration.

LANGUAGE: typescript
CODE:
import AdminJS from 'adminjs';
import { Database, Resource } from '@adminjs/mikroorm';
import AdminJSExpress from '@adminjs/express';
import { MikroORM } from '@mikro-orm/core';
import { validate } from 'class-validator'; // optional

const PORT = process.env.PORT ?? 3000;

const run = async () => {
  /* Initialize MikroORM like you would do normally, you can also import your MikroORM instance from a separate file */
  const orm = await MikroORM.init({
    entities: [User, Car, Seller], // use your own entities
    dbName: process.env.DATABASE_NAME,
    type: 'postgresql',
    clientUrl: process.env.DATABASE_URL,
  });

  /* Optional: if you're using class-validator, assign it to Resource */
  Resource.validate = validate;
  /* Tell AdminJS which adapter to use */
  AdminJS.registerAdapter({ Database, Resource });

  const app = express();

  /* Create AdminJS instance */
  const admin = new AdminJS({
    databases: [orm],
  });

  const router = AdminJSExpress.buildRouter(admin);

  app.use(admin.options.rootPath, router);

  app.listen(PORT, () => {
    console.log(`App listening at http://localhost:${PORT}`);
  });
}

run();

----------------------------------------

TITLE: Configuring TypeScript for MikroORM Project
DESCRIPTION: TypeScript configuration file (tsconfig.json) settings for a MikroORM project with ESM support.

LANGUAGE: json
CODE:
{
  "compilerOptions": {
    "module": "Node16",
    "target": "ES2022",
    "strict": true,
    "outDir": "dist",
    "declaration": true,
    "experimentalDecorators": true
  },
  "include": [
    "./src/**/*.ts"
  ],
  "ts-node": {
    "esm": true,
    "transpileOnly": true
  }
}

----------------------------------------

TITLE: Defining Entity Relationships in TypeScript with MikroORM
DESCRIPTION: Basic entity setup showing Author and Book entities with one-to-many and many-to-one relationships using the default loading strategy.

LANGUAGE: typescript
CODE:
import { Entity, LoadStrategy, OneToMany, ManyToOne } from '@mikro-orm/core';

@Entity()
export class Author {
  @OneToMany(() => Book, b => b.author)
  books = new Collection<Book>(this);
}

@Entity()
export class Book {
  @ManyToOne()
  author: Author;
}

----------------------------------------

TITLE: Setting up MikroORM with Hapi and AdminJS
DESCRIPTION: TypeScript implementation for integrating MikroORM with Hapi and AdminJS, including database initialization and server plugin configuration.

LANGUAGE: typescript
CODE:
import AdminJS from 'adminjs';
import { Database, Resource } from '@adminjs/mikroorm';
import AdminJSHapi from '@adminjs/hapi';
import { MikroORM } from '@mikro-orm/postgresql';
import { validate } from 'class-validator'; // optional

const PORT = process.env.PORT ?? 3000;

const run = async () => {
  /* Initialize MikroORM like you would do normally, you can also import your MikroORM instance from a separate file */
  const orm = await MikroORM.init({
    entities: [User, Car, Seller], // use your own entities
    dbName: process.env.DATABASE_NAME,
    clientUrl: process.env.DATABASE_URL,
  });

  /* Optional: if you're using class-validator, assign it to Resource */
  Resource.validate = validate;
  /* Tell AdminJS which adapter to use */
  AdminJS.registerAdapter({ Database, Resource });

  const server = Hapi.server({ port: PORT })

  /* Configure AdminJS */
  const adminOptions = {
    databases: [orm],
  };

  /* Register AdminJS as a Hapi server's plugin */
  await server.register({
    plugin: AdminJSHapi,
    options: adminOptions,
  });

  await server.start();
  console.log(`App listening at ${server.info.uri}`);
}

run();

----------------------------------------

TITLE: SQL Queries Generated for Nested Populate
DESCRIPTION: Shows the actual SQL queries executed by MikroORM when performing nested population. Demonstrates how relationships are loaded efficiently using pivot tables and JOIN operations.

LANGUAGE: sql
CODE:
SELECT `e0`.* FROM `book_tag` AS `e0`;

SELECT `e0`.*, `e1`.`book_id`, `e1`.`book_tag_id`
  FROM `book` AS `e0` LEFT JOIN `book_to_book_tag` AS `e1` ON `e0`.`id` = `e1`.`book_id`
  WHERE `e1`.`book_tag_id` IN (?, ?, ?, ?, ?)
  ORDER BY `e1`.`id` ASC;

SELECT `e0`.* FROM `publisher` AS `e0` WHERE `e0`.`id` IN (?, ?, ?);

SELECT `e0`.*, `e1`.`test_id`, `e1`.`publisher_id`
  FROM `test` AS `e0` LEFT JOIN `publisher_to_test` AS `e1` ON `e0`.`id` = `e1`.`test_id`
  WHERE `e1`.`publisher_id` IN (?, ?, ?)
  ORDER BY `e1`.`id` ASC;

SELECT `e0`.* FROM `author` AS `e0` WHERE `e0`.`id` IN (?);

----------------------------------------

TITLE: Collection Filtering and Mapping in MikroORM
DESCRIPTION: Shows advanced collection operations including filtering, ordering, and mapping collection items to different formats.

LANGUAGE: typescript
CODE:
await book.tags.init({
  where: { active: true },
  orderBy: { name: QueryOrder.DESC },
});

const settingsDictionary = user.settings.indexBy('key');
const settingsDictionary = user.settings.indexBy('key', 'value');

----------------------------------------

TITLE: Using CreateRequestContext with Repository in MikroORM (TypeScript)
DESCRIPTION: This snippet demonstrates using the @CreateRequestContext() decorator with an entity repository. It shows how to link the context to a specific repository instance within a service class.

LANGUAGE: typescript
CODE:
export class MyService {

  constructor(private readonly userRepository: EntityRepository<User>) { }

  @CreateRequestContext<MyService>(t => t.userRepository)
  async doSomething() {
    // this will be executed in a separate context
  }

}

----------------------------------------

TITLE: Installing Express Plugin Dependencies
DESCRIPTION: Installation commands for Express-specific AdminJS plugin and its peer dependencies.

LANGUAGE: bash
CODE:
$ yarn add @adminjs/express
# Peer dependencies
$ yarn add express express-formidable express-session

----------------------------------------

TITLE: Executing Schema Update Command in MikroORM
DESCRIPTION: Command to synchronize database schema with entity definitions using MikroORM CLI.

LANGUAGE: sh
CODE:
npx mikro-orm schema:update --run

----------------------------------------

TITLE: Synchronizing Database Schema with MikroORM CLI
DESCRIPTION: This command uses the MikroORM CLI to update the database schema based on entity definitions.

LANGUAGE: sh
CODE:
npx mikro-orm schema:update --run

----------------------------------------

TITLE: Generated SQL Schema for Mapped Superclass in SQLite
DESCRIPTION: Shows the DDL (Data Definition Language) SQL statement generated for the Employee entity, which inherits from the Person mapped superclass. The schema includes all inherited properties in a single table.

LANGUAGE: sql
CODE:
create table `employee` (
  `id` int unsigned not null auto_increment primary key,
  `name` varchar(255) not null, `mapped1` integer not null,
  `mapped2` varchar(255) not null,
  `toothbrush_id` integer not null
);

----------------------------------------

TITLE: Strict Partial Loading Example in TypeScript
DESCRIPTION: Demonstrates the improved Loaded type for partial loading with fields option where only selected properties are accessible.

LANGUAGE: typescript
CODE:
const book = await em.findOneOrFail(Book, 1, {
  fields: ['title', 'author.email'],
  populate: ['author'],
});

const id = book.id; // ok, PK is selected automatically
const title = book.title; // ok, title is selected
const publisher = book.publisher; // fail, not selected
const author = book.author.id; // ok, PK is selected automatically
const email = book.author.email; // ok, selected
const name = book.author.name; // fail, not selected

----------------------------------------

TITLE: Implementing Custom Driver Class in TypeScript
DESCRIPTION: Main driver class that implements core database operations like find, insert, update, and delete. Extends DatabaseDriver and uses custom Connection and Platform implementations.

LANGUAGE: typescript
CODE:
import { DatabaseDriver } from 'mikro-orm';

export class MyCustomDriver extends DatabaseDriver {

  // initialize connection and platform
  protected readonly connection = new MyCustomConnection(this.config);
  protected readonly platform = new MyCustomPlatform;

  // and implement abstract methods
  find<T extends AnyEntity>(entityName: string, where: FilterQuery<T>, populate?: string[], orderBy?: Record<string, QueryOrder>, limit?: number, offset?: number): Promise<T[]>;
  findOne<T extends AnyEntity>(entityName: string, where: FilterQuery<T> | string, populate: string[]): Promise<T | null>;
  nativeInsert<T extends AnyEntityType<T>>(entityName: string, data: EntityData<T>): Promise<QueryResult>;
  nativeUpdate<T extends AnyEntity>(entityName: string, where: FilterQuery<T> | IPrimaryKey, data: EntityData<T>): Promise<QueryResult>;
  nativeDelete<T extends AnyEntity>(entityName: string, where: FilterQuery<T> | IPrimaryKey): Promise<QueryResult>;
  count<T extends AnyEntity>(entityName: string, where: FilterQuery<T>): Promise<number>;

}

----------------------------------------

TITLE: ManyToMany Relationship Configuration in MikroORM
DESCRIPTION: Demonstrates configuration of unidirectional and bidirectional ManyToMany relationships in MikroORM, including custom pivot table entities.

LANGUAGE: typescript
CODE:
@ManyToMany(() => Book)
books1 = new Collection<Book>(this);

@ManyToMany({ entity: () => Book, owner: true })
books2 = new Collection<Book>(this);

@ManyToMany(() => BookTag, tag => tag.books, { owner: true })
tags = new Collection<BookTag>(this);

@ManyToMany({ entity: () => BookTag, inversedBy: 'books' })
tags = new Collection<BookTag>(this);

----------------------------------------

TITLE: Composite Foreign Key with Shared Columns in TypeScript
DESCRIPTION: Demonstrates how to set up a composite foreign key with shared columns, reducing duplication and improving consistency in the database schema. This example shows a User entity with a self-referencing relation.

LANGUAGE: typescript
CODE:
@Entity()
class Organization {
  
  @PrimaryKey()
  id: number;
  
}

@Entity()
class User {
  
  @PrimaryKey()
  id: number;
  
  @ManyToOne(() => Organization, { primary: true })
  organization: Organization;

  @ManyToOne(() => User, {
    fieldNames: ['invited_by_id', 'organization_id'],
    nullable: true,
  })
  invitedBy?: User;

}

----------------------------------------

TITLE: Creating Custom NativeBigIntType for MikroORM
DESCRIPTION: This snippet demonstrates how to create a custom NativeBigIntType that extends BigIntType to support native BigInt values in JavaScript.

LANGUAGE: typescript
CODE:
export class NativeBigIntType extends BigIntType {

  convertToJSValue(value: any): any {
    if (!value) {
      return value;
    }

    return BigInt(value);
  }

}

@Entity()
export class Book {

  @PrimaryKey({ type: NativeBigIntType })
  id: bigint;

}

----------------------------------------

TITLE: Defining Entity with Manual Type Attributes
DESCRIPTION: This example shows how to manually define type attributes for an entity to avoid the need for runtime type discovery.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @PrimaryKey({ type: 'number' })
  id!: number;

  @Property({ type: 'string' })
  title!: string;

  @Enum(() => BookStatus)
  status?: BookStatus;

  @ManyToOne(() => Author) // or `@ManyToOne({ type: 'Author' })` or `@ManyToOne({ entity: () => Author })`
  author1!: Author;

  // or
  @ManyToOne({ type: 'Author' })
  author2!: Author;

  // or
  @ManyToOne({ entity: () => Author })
  author3!: Author;

}

export enum BookStatus {
  SOLD_OUT = 'sold',
  ACTIVE = 'active',
  UPCOMING = 'upcoming',
 }

----------------------------------------

TITLE: Using rel() Helper with Entity Constructors
DESCRIPTION: Demonstrates how to use the rel() helper to convert primary keys to entity references in constructors.

LANGUAGE: typescript
CODE:
@ManyToOne({ entity: () => Author })
author: Rel<Author>;

constructor(dto: { title: string; author: number }) {
  this.title = dto.title;
  this.author = rel(Author, dto.author);
}

----------------------------------------

TITLE: SQL Highlighter Configuration
DESCRIPTION: Shows how to configure the optional SQL query highlighter in v4.

LANGUAGE: typescript
CODE:
import { SqlHighlighter } from '@mikro-orm/sql-highlighter';

MikroORM.init({
  highlighter: new SqlHighlighter(),
  // ...
});

----------------------------------------

TITLE: Enabling Debug Mode in MikroORM
DESCRIPTION: Initializes MikroORM with debug mode enabled, which outputs all queries to console.log()

LANGUAGE: typescript
CODE:
return MikroORM.init({
  debug: true,
});

----------------------------------------

TITLE: Configuring Orphan Removal in MikroORM TypeScript
DESCRIPTION: Demonstrates how to set up orphan removal for OneToMany relationships in MikroORM. This aggressive remove cascading mode removes entities when they are disconnected from the collection.

LANGUAGE: typescript
CODE:
@Entity()
export class Author {

  @OneToMany({ entity: () => Book, mappedBy: 'author', orphanRemoval: true })
  books = new Collection<Book>(this);

}

----------------------------------------

TITLE: Using Reference.load() in MikroORM
DESCRIPTION: Demonstrates how to use the Reference.load() method to lazily load entity references in MikroORM.

LANGUAGE: typescript
CODE:
const article1 = await em.findOne(Article, 1);
(await article1.author.load()).name; // async safe access

const article2 = await em.findOne(Article, 2);
const author = await article2.author.load();
author.name;
await article2.author.load(); // no additional query, already loaded

----------------------------------------

TITLE: Initializing MikroORM with JavaScript Entities
DESCRIPTION: Shows how to initialize MikroORM with JavaScript entities by registering them in the configuration object.

LANGUAGE: javascript
CODE:
const orm = await MikroORM.init({
  entities: [Author, Book, BookTag, BaseEntity],
  dbName: 'my-db-name',
});

----------------------------------------

TITLE: Join Table with Metadata Implementation
DESCRIPTION: Complex example showing how to implement a join table with additional metadata using composite keys. Demonstrates relationships between Order, Product, and OrderItem entities.

LANGUAGE: typescript
CODE:
@Entity()
export class Order {

  @PrimaryKey()
  id!: number;

  @ManyToOne()
  customer: Customer;

  @OneToMany(() => OrderItem, item => item.order)
  items = new Collection<OrderItem>(this);

  @Property()
  paid = false;

  @Property()
  shipped = false;

  @Property()
  created = new Date();

  constructor(customer: Customer) {
    this.customer = customer;
  }

}

@Entity()
export class Product {

  @PrimaryKey()
  id!: number;

  @Property()
  name!: string;

  @Property()
  currentPrice!: number;

}

@Entity()
export class OrderItem {

  @ManyToOne({ primary: true })
  order: Order;

  @ManyToOne({ primary: true })
  product: Product;

  @Property()
  amount = 1;

  @Property()
  offeredPrice: number;

  [PrimaryKeyProp]?: ['order', 'product'];

  constructor(order: Order, product: Product, amount = 1) {
    this.order = order;
    this.product = product;
    this.offeredPrice = product.currentPrice;
  }

}

----------------------------------------

TITLE: Storing Embeddables as Objects in MikroORM
DESCRIPTION: Illustrates how to store an embeddable as a JSON object instead of inlining its properties.

LANGUAGE: typescript
CODE:
@Embedded({ entity: () => Address, object: true })
address!: Address;

----------------------------------------

TITLE: Managing Read/Write Connections in MikroORM Queries
DESCRIPTION: Illustrates different ways to handle read and write connections in MikroORM queries. Shows how to explicitly specify connection types, handle automatic connection selection, and manage transactions which always use write connections.

LANGUAGE: typescript
CODE:
const connection = orm.em.getConnection(); // write connection
const readConnection = orm.em.getConnection('read'); // random read connection

const qb1 = orm.em.createQueryBuilder(Author);
const res1 = await qb1.select('*').execute(); // random read connection

const qb2 = orm.em.createQueryBuilder(Author, 'a', 'write');
const res2 = await qb2.select('*').execute(); // write connection

const qb3 = orm.em.createQueryBuilder(Author);
const res3 = await qb3.update(...).where(...).execute(); // write connection

// all queries inside a transaction will use write connection
await orm.em.transactional(async em => {
  const a = await em.findOne(Author, 1); // write connection
  a.name = 'test'; // will trigger update on write connection once flushed
});

----------------------------------------

TITLE: Working with Entity References in TypeScript
DESCRIPTION: Illustrates how entity references now handle collections differently. Collections are undefined until the entity is initialized, after which they become instances of Collection but remain uninitialized.

LANGUAGE: typescript
CODE:
const book = em.getReference(Book, 1);
console.log(book.tags); // undefined
await book.init();
console.log(book.tags); // instance of Collection (not initialized)

----------------------------------------

TITLE: Setting up MikroORM Development Environment
DESCRIPTION: Commands for setting up the initial development environment including installing dependencies, starting Docker containers, and configuring host entries for MongoDB clusters.

LANGUAGE: shell
CODE:
corepack enable
yarn
docker compose up -d
echo '127.0.0.1 mongo1' | sudo tee -a /etc/hosts
echo '127.0.0.1 mongo2' | sudo tee -a /etc/hosts
echo '127.0.0.1 mongo3' | sudo tee -a /etc/hosts

----------------------------------------

TITLE: Defining Book Entity for MongoDB
DESCRIPTION: Example of defining a Book entity for MongoDB using ObjectId as the primary key and a serialized string ID.

LANGUAGE: typescript
CODE:
@Entity()
export class Book {

  @PrimaryKey()
  _id!: ObjectId;

  @SerializedPrimaryKey()
  id!: string; // string variant of PK, will be handled automatically

  @Property()
  title!: string;

  @ManyToOne(() => Author)
  author!: Author;

}

----------------------------------------

TITLE: Configuring Babel Plugins for MikroORM
DESCRIPTION: Configuration for Babel plugins required to handle TypeScript decorators and metadata correctly with MikroORM. Includes transform-typescript-metadata and proposal plugins for decorators and class properties.

LANGUAGE: json
CODE:
{
  "plugins": [
    "babel-plugin-transform-typescript-metadata",
    ["@babel/plugin-proposal-decorators", { "legacy": true }],
    ["@babel/plugin-proposal-class-properties", { "loose": true  }]
  ]
}

----------------------------------------

TITLE: Installing MikroORM and NestJS Dependencies
DESCRIPTION: Commands for installing MikroORM core, NestJS module, and database-specific drivers using yarn or npm.

LANGUAGE: bash
CODE:
$ yarn add @mikro-orm/core @mikro-orm/nestjs @mikro-orm/mongodb     # for mongo
$ yarn add @mikro-orm/core @mikro-orm/nestjs @mikro-orm/mysql       # for mysql/mariadb
$ yarn add @mikro-orm/core @mikro-orm/nestjs @mikro-orm/mariadb     # for mysql/mariadb
$ yarn add @mikro-orm/core @mikro-orm/nestjs @mikro-orm/postgresql  # for postgresql
$ yarn add @mikro-orm/core @mikro-orm/nestjs @mikro-orm/sqlite      # for sqlite

LANGUAGE: bash
CODE:
$ npm i -s @mikro-orm/core @mikro-orm/nestjs @mikro-orm/mongodb     # for mongo
$ npm i -s @mikro-orm/core @mikro-orm/nestjs @mikro-orm/mysql       # for mysql/mariadb
$ npm i -s @mikro-orm/core @mikro-orm/nestjs @mikro-orm/mariadb     # for mysql/mariadb
$ npm i -s @mikro-orm/core @mikro-orm/nestjs @mikro-orm/postgresql  # for postgresql
$ npm i -s @mikro-orm/core @mikro-orm/nestjs @mikro-orm/sqlite      # for sqlite

----------------------------------------

TITLE: Implementing RequestContext Middleware in MikroORM with TypeScript
DESCRIPTION: This snippet demonstrates how to use the RequestContext helper as middleware to create a request-specific EntityManager fork.

LANGUAGE: typescript
CODE:
app.use((req, res, next) => {
  // calls `orm.em.fork()` and attaches it to the async context
  RequestContext.create(orm.em, next);
});

app.get('/', async (req, res) => {
  // uses fork from the async context automatically
  const authors = await orm.em.find(Book, {});
  res.json(authors);
});

----------------------------------------

TITLE: Defining Entities with Schema Names in MikroORM
DESCRIPTION: Demonstrates how to define entities in different schemas using the @Entity decorator with tableName option that includes the schema name.

LANGUAGE: typescript
CODE:
@Entity({ tableName: 'first_schema.foo' })
export class Foo { ... }

@Entity({ tableName: 'second_schema.bar' })
export class Bar { ... }

----------------------------------------

TITLE: Change Header
DESCRIPTION: Standard change log header with link to commit guidelines

LANGUAGE: markdown
CODE:
# Change Log

All notable changes to this project will be documented in this file.
See [Conventional Commits](https://conventionalcommits.org) for commit guidelines.

----------------------------------------

TITLE: Running MikroORM Tests
DESCRIPTION: Command to run the test suite for MikroORM project verification.

LANGUAGE: shell
CODE:
yarn test

----------------------------------------

TITLE: Awaiting QueryBuilder in MikroORM v5
DESCRIPTION: Demonstrates how to await QueryBuilder instances in MikroORM v5, which automatically executes the query and returns the appropriate response based on the query type.

LANGUAGE: typescript
CODE:
const res1 = await em.qb(Publisher).insert({
  name: 'p1',
  type: PublisherType.GLOBAL,
});
// res1 is of type `QueryResult<Publisher>`
console.log(res1.insertId);

const res2 = await em.qb(Publisher)
  .select('*')
  .where({ name: 'p1' })
  .limit(5);
// res2 is Publisher[]
console.log(res2.map(p => p.name));

const res3 = await em.qb(Publisher).count().where({ name: 'p1' });
// res3 is number
console.log(res3 > 0); // true

const res4 = await em.qb(Publisher)
  .update({ type: PublisherType.LOCAL })
  .where({ name: 'p1' });
// res4 is QueryResult<Publisher>
console.log(res4.affectedRows > 0); // true

const res5 = await em.qb(Publisher).delete().where({ name: 'p1' });
// res5 is QueryResult<Publisher>
console.log(res5.affectedRows > 0); // true
expect(res5.affectedRows > 0).toBe(true); // test the type

----------------------------------------

TITLE: TypeScript Configuration for MikroORM
DESCRIPTION: Required TypeScript configuration settings in tsconfig.json to enable decorators and ES module interop.

LANGUAGE: json
CODE:
"experimentalDecorators": true,
"emitDecoratorMetadata": true,
"esModuleInterop": true

----------------------------------------

TITLE: Debug Output Example in MikroORM
DESCRIPTION: Example of the query logging output when debug mode is enabled, showing various database operations and their execution times

LANGUAGE: plaintext
CODE:
[query] select `e0`.* from `author` as `e0` where `e0`.`name` = ? limit ? [took 2 ms]
[query] begin [took 1 ms]
[query] insert into `author` (`name`, `email`, `created_at`, `updated_at`, `terms_accepted`) values (?, ?, ?, ?, ?) [took 2 ms]
[query] commit [took 2 ms]

----------------------------------------

TITLE: Database Schema for Mapped Superclass in SQLite
DESCRIPTION: SQL DDL showing the resulting database schema for the mapped superclass implementation, demonstrating how all mappings are inherited by the subclass.

LANGUAGE: sql
CODE:
create table `employee` (
  `id` int unsigned not null auto_increment primary key,
  `name` varchar(255) not null, `mapped1` integer not null,
  `mapped2` varchar(255) not null,
  `toothbrush_id` integer not null
);

----------------------------------------

TITLE: Configuring Custom Highlighter in MikroORM v4
DESCRIPTION: Shows how to configure a custom SQL highlighter for query logging in MikroORM v4. Highlighting is now disabled by default and requires explicit configuration.

LANGUAGE: typescript
CODE:
import { SqlHighlighter } from '@mikro-orm/sql-highlighter';

MikroORM.init({
  highlighter: new SqlHighlighter(),
  // ...
});

----------------------------------------

TITLE: Querying Entities with MikroORM EntityRepository
DESCRIPTION: This code demonstrates how to use EntityRepository to query entities from the database. It includes options for populating relations, limiting results, and ordering.

LANGUAGE: typescript
CODE:
const booksRepository = em.getRepository(Book);

const books = await booksRepository.find({ author: '...' }, { 
  populate: ['author'],
  limit: 1,
  offset: 2,
  orderBy: { title: QueryOrder.DESC },
});

console.log(books);

----------------------------------------

TITLE: Configuring MikroORM Seeder Extension
DESCRIPTION: Initial setup for enabling the seeder functionality by installing @mikro-orm/seeder and registering the SeedManager extension in the ORM configuration.

LANGUAGE: typescript
CODE:
import { SeedManager } from '@mikro-orm/seeder';

export default defineConfig({
  // ...
  extensions: [SeedManager],
})

----------------------------------------

TITLE: Defining Enums with @Enum Decorator in TypeScript
DESCRIPTION: Examples of using the @Enum decorator to define enum properties with different options.

LANGUAGE: typescript
CODE:
@Enum() // with ts-morph metadata provider we do not need to specify anything
enum0 = MyEnum1.VALUE_1;

@Enum(() => MyEnum1) // or @Enum({ items: () => MyEnum1 })
enum1 = MyEnum1.VALUE_1;

@Enum({ type: 'MyEnum2', nullable: true })
enum2?: MyEnum2; // MyEnum2 needs to be defined in current file (can be re-exported)

@Enum({ items: [1, 2, 3] })
enum3 = 3;

@Enum({ items: ['a', 'b', 'c'] })
enum4 = 'a';

----------------------------------------

TITLE: One-to-Many Collection Propagation in TypeScript
DESCRIPTION: Shows how using Collection.add() method propagates changes in a one-to-many relationship between Author and Book entities.

LANGUAGE: typescript
CODE:
// one to many
const author = new Author(...);
const book = new Book(...);

author.books.add(book);
console.log(book.author); // author will be set thanks to the propagation

----------------------------------------

TITLE: Property Decorators Usage in MikroORM
DESCRIPTION: Shows usage of @Property decorator for defining entity properties with various configurations like field names, types, and database column specifications.

LANGUAGE: typescript
CODE:
@Property({ length: 50, fieldName: 'first_name' })
name!: string;

@Property({ columnType: 'datetime', fieldName: 'born_date' })
born?: Date;

@Property({ columnType: 'tinyint' })
age?: number;

@Property({ onUpdate: () => new Date() })
updatedAt = new Date();

@Property()
registered = false;

----------------------------------------

TITLE: Defining CacheAdapter Interface for Custom Cache Adapters in MikroORM (TypeScript)
DESCRIPTION: This code defines the CacheAdapter interface, which must be implemented by custom cache adapters in MikroORM. It includes methods for getting, setting, and clearing cache items, as well as an optional close method.

LANGUAGE: typescript
CODE:
export interface CacheAdapter {

  /**
   * Gets the items under `name` key from the cache.
   */
  get(name: string): Promise<any>;

  /**
   * Sets the item to the cache. `origin` is used for cache invalidation and should reflect the change in data.
   */
  set(name: string, data: any, origin: string, expiration?: number): Promise<void>;

  /**
   * Clears all items stored in the cache.
   */
  clear(): Promise<void>;

  /**
   * Called inside `MikroORM.close()` Allows graceful shutdowns (e.g. for redis).
   */
  close?(): Promise<void>;

}

----------------------------------------

TITLE: Defining CacheAdapter Interface for Custom Cache Adapters in MikroORM (TypeScript)
DESCRIPTION: This code defines the CacheAdapter interface, which must be implemented by custom cache adapters in MikroORM. It includes methods for getting, setting, and clearing cache items, as well as an optional close method.

LANGUAGE: typescript
CODE:
export interface CacheAdapter {

  /**
   * Gets the items under `name` key from the cache.
   */
  get(name: string): Promise<any>;

  /**
   * Sets the item to the cache. `origin` is used for cache invalidation and should reflect the change in data.
   */
  set(name: string, data: any, origin: string, expiration?: number): Promise<void>;

  /**
   * Clears all items stored in the cache.
   */
  clear(): Promise<void>;

  /**
   * Called inside `MikroORM.close()` Allows graceful shutdowns (e.g. for redis).
   */
  close?(): Promise<void>;

}

----------------------------------------

TITLE: Configuring Connection Options in MikroORM
DESCRIPTION: This snippet shows how to configure connection options in MikroORM, including setting up read replicas and using short-lived tokens for authentication.

LANGUAGE: typescript
CODE:
MikroORM.init({
  type: 'mysql',
  dbName: 'my_db_name',
  user: 'write-user',
  host: 'master.db.example.com',
  port: 3306,
  replicas: [
    { user: 'read-user-1', host: 'read-1.db.example.com', port: 3307 },
    { user: 'read-user-2', host: 'read-2.db.example.com', port: 3308 },
    { user: 'read-user-3', host: 'read-3.db.example.com', port: 3309 },
  ],
});

MikroORM.init({
  type: 'mysql',
  dbName: 'my_db_name',
  password: async () => {
    const { token, tokenExpiration } = await someCallToGetTheToken();
    return { password: token, expirationChecker: () => tokenExpiration <= Date.now() }
  },
});

----------------------------------------

TITLE: Updating Entity Values with IEntity.assign() in TypeScript
DESCRIPTION: This snippet shows how to use IEntity.assign() to update entity values, including relations, using plain string IDs as input.

LANGUAGE: typescript
CODE:
book.assign({
  title: 'Better Book 1',
  author: '...id...',
});
console.log(book.title); // 'Better Book 1'
console.log(book.author); // instance of Author with id: '...id...'
console.log(book.author.id); // '...id...'

----------------------------------------

TITLE: Query Execution Methods
DESCRIPTION: Demonstrates different execution methods available in QueryBuilder with result mapping options.

LANGUAGE: typescript
CODE:
const res1 = await qb.execute('all'); // returns array of objects, default behavior
const res2 = await qb.execute('get'); // returns single object
const res3 = await qb.execute('run'); // returns object like `{ affectedRows: number, insertId: number, row: any }`

----------------------------------------

TITLE: SQL Queries for Nested Populate in MikroORM
DESCRIPTION: Shows the SQL queries generated by MikroORM for nested populate operations with pivot tables.

LANGUAGE: sql
CODE:
SELECT `e0`.* FROM `book_tag` AS `e0`;

SELECT `e0`.*, `e1`.`book_id`, `e1`.`book_tag_id`
  FROM `book` AS `e0` LEFT JOIN `book_to_book_tag` AS `e1` ON `e0`.`id` = `e1`.`book_id`
  WHERE `e1`.`book_tag_id` IN (?, ?, ?, ?, ?)
  ORDER BY `e1`.`id` ASC;

SELECT `e0`.* FROM `publisher` AS `e0` WHERE `e0`.`id` IN (?, ?, ?);

SELECT `e0`.*, `e1`.`test_id`, `e1`.`publisher_id`
  FROM `test` AS `e0` LEFT JOIN `publisher_to_test` AS `e1` ON `e0`.`id` = `e1`.`test_id`
  WHERE `e1`.`publisher_id` IN (?, ?, ?)
  ORDER BY `e1`.`id` ASC;

SELECT `e0`.* FROM `author` AS `e0` WHERE `e0`.`id` IN (?);

----------------------------------------

TITLE: Running Schema Update via CLI in MikroORM
DESCRIPTION: Command to synchronize database schema with entities using MikroORM CLI

LANGUAGE: shell
CODE:
npx mikro-orm schema:update --run

----------------------------------------

TITLE: Creating Custom Extended EntityRepository in MikroORM v6
DESCRIPTION: Shows how to create a custom base repository that extends EntityRepository to keep the removed persistence methods if needed.

LANGUAGE: typescript
CODE:
import { EntityManager, EntityRepository, AnyEntity } from '@mikro-orm/mysql';

export class ExtendedEntityRepository<T extends object> extends EntityRepository<T> {

  persist(entity: AnyEntity | AnyEntity[]): EntityManager {
    return this.em.persist(entity);
  }

  async persistAndFlush(entity: AnyEntity | AnyEntity[]): Promise<void> {
    await this.em.persistAndFlush(entity);
  }

  remove(entity: AnyEntity): EntityManager {
    return this.em.remove(entity);
  }

  async removeAndFlush(entity: AnyEntity): Promise<void> {
    await this.em.removeAndFlush(entity);
  }

  async flush(): Promise<void> {
    return this.em.flush();
  }

}

----------------------------------------

TITLE: Configuring TsMorphMetadataProvider in MikroORM v4
DESCRIPTION: This snippet demonstrates how to explicitly enable the TsMorphMetadataProvider in the MikroORM configuration. It requires installing the @mikro-orm/reflection package.

LANGUAGE: typescript
CODE:
import { TsMorphMetadataProvider } from '@mikro-orm/reflection';

await MikroORM.init({
  metadataProvider: TsMorphMetadataProvider,
  // ...
});

----------------------------------------

TITLE: Initializing Entity References in TypeScript with MikroORM
DESCRIPTION: This snippet demonstrates how to use entity references in MikroORM, including checking initialization status and accessing properties.

LANGUAGE: typescript
CODE:
const author = orm.em.getReference('...id...');
console.log(author.id); // accessing the id will not trigger any db call
console.log(author.isInitialized()); // false
console.log(author.name); // undefined

await wrap(author).init(); // this will trigger db call
console.log(author.isInitialized()); // true
console.log(author.name); // defined

----------------------------------------

TITLE: Batch Updating Users with MikroORM in TypeScript
DESCRIPTION: Shows how MikroORM 4.1 uses case statements to batch update multiple users in a single SQL query, significantly reducing the number of database operations.

LANGUAGE: typescript
CODE:
for (const user of users) {
  user.name += ' changed!';
}

await em.flush();

// update `user` set
//   `name` = case
//     when (`id` = 1) then 'Peter 1 changed!'
//     when (`id` = 2) then 'Peter 2 changed!'
//     when (`id` = 3) then 'Peter 3 changed!'
//     when (`id` = 4) then 'Peter 4 changed!'
//     when (`id` = 5) then 'Peter 5 changed!'
//     else `priority` end
//   where `id` in (1, 2, 3, 4, 5)

----------------------------------------

TITLE: Implementing Password Hashing with Lifecycle Hooks
DESCRIPTION: Uses argon2 for password hashing and adds BeforeCreate/BeforeUpdate hooks to automatically hash passwords.

LANGUAGE: typescript
CODE:
import { hash, verify } from 'argon2';

export class User extends BaseEntity<'bio'> {
  @BeforeCreate()
  @BeforeUpdate()
  async hashPassword(args: EventArgs<User>) {
    const password = args.changeSet?.payload.password;
    if (password) {
      this.password = await hash(password);
    }
  }

  async verifyPassword(password: string) {
    return verify(this.password, password);
  }
}

----------------------------------------

TITLE: Setting Population Order By Clause in MikroORM Query (TypeScript)
DESCRIPTION: This example demonstrates how to use the 'populateOrderBy' option to control the ordering of populated relations.

LANGUAGE: typescript
CODE:
await em.find(Author, { ... }, {
  populate: ['books'],
  populateOrderBy: { books: { publishedAt: 'desc' } },
});

----------------------------------------

TITLE: Setting Population Order By Clause in MikroORM Query (TypeScript)
DESCRIPTION: This example demonstrates how to use the 'populateOrderBy' option to control the ordering of populated relations.

LANGUAGE: typescript
CODE:
await em.find(Author, { ... }, {
  populate: ['books'],
  populateOrderBy: { books: { publishedAt: 'desc' } },
});

----------------------------------------

TITLE: Defining a Property with Explicit Type in TypeScript
DESCRIPTION: Illustrates how to define a property with an explicit type when using ReflectMetadataProvider.

LANGUAGE: typescript
CODE:
@Property()
createdAt: Date = new Date();

----------------------------------------

TITLE: Configuring Connection Pooling in MikroORM 3
DESCRIPTION: Shows how to configure connection pooling options when initializing MikroORM. This example sets the minimum and maximum number of connections in the pool.

LANGUAGE: typescript
CODE:
const orm = await MikroORM.init({
  entities: [Author, Book],
  dbName: 'my-db-name',
  pool: { min: 10, max: 20 }, // see https://github.com/vincit/tarn.js#usage for other pool options
});

----------------------------------------

TITLE: Creating Basic Project Structure
DESCRIPTION: Commands to create the initial folder structure for the blog API project with user, article and common modules

LANGUAGE: bash
CODE:
mkdir blog-api && cd blog-api
mkdir -p src/modules/{user,article,common}

----------------------------------------

TITLE: Configuring SchemaGenerator in MikroORM
DESCRIPTION: TypeScript code snippet demonstrating how to configure the SchemaGenerator globally via the ORM configuration. It shows options for disabling foreign keys and controlling constraint generation.

LANGUAGE: ts
CODE:
const orm = await MikroORM.init({
  // default values:
  schemaGenerator: {
    disableForeignKeys: true, // wrap statements with `set foreign_key_checks = 0` or equivalent
    createForeignKeyConstraints: true, // whether to generate FK constraints
    ignoreSchema: [], // allows ignoring some schemas when diffing
  },
});

----------------------------------------

TITLE: Complex Entity Relationship Updates
DESCRIPTION: Shows how to update multiple related entities within a single transaction, including books, tags, and publisher relationships.

LANGUAGE: typescript
CODE:
const author = await orm.em.findOne(Author, id, ['books.tags', 'books.publisher']);
author.books[0].title = 'New book name';
author.books[0].tags[0].name = 'old';
author.books[0].tags.add(new BookTag('sale'));
author.books[0].publisher.name = 'New publisher name';
await orm.em.flush();

----------------------------------------

TITLE: Importing reflect-metadata in TypeScript
DESCRIPTION: Demonstrates how to import the reflect-metadata module at the top of the bootstrap script when using ReflectMetadataProvider.

LANGUAGE: typescript
CODE:
import 'reflect-metadata';

----------------------------------------

TITLE: Entity Definition with WrappedEntity Interface
DESCRIPTION: Example showing how to define an entity class with WrappedEntity interface to maintain v2 functionality while using the new v3 entity definition pattern.

LANGUAGE: typescript
CODE:
@Entity()
export class Book { ... }
export interface Book extends WrappedEntity<Book, 'id'> { }

----------------------------------------

TITLE: Deep Entity Graph Updates
DESCRIPTION: Examples of updating deep entity relationships with different configuration options

LANGUAGE: typescript
CODE:
const book = await em.findOneOrFail(Book, 1, { populate: ['author'] });

// update existing book's author's name
wrap(book).assign({
  author: {
    id: book.author.id,
    name: 'New name...',
  },
});

----------------------------------------

TITLE: Entity Definition with WrappedEntity Interface
DESCRIPTION: Demonstrates how to define an entity class with the new WrappedEntity interface to maintain v2 functionality while using the new entity definition pattern.

LANGUAGE: typescript
CODE:
@Entity()
export class Book { ... }
export interface Book extends WrappedEntity<Book, 'id'> { }

----------------------------------------

TITLE: Implementing Cascade Persist in MikroORM
DESCRIPTION: Example demonstrating cascade persist functionality where changes to related entities are automatically persisted when the parent entity is persisted.

LANGUAGE: typescript
CODE:
const book = await orm.em.findOne(Book, 'id', ['author', 'tags']);
book.author.name = 'Foo Bar';
book.tags[0].name = 'new name 1';
book.tags[1].name = 'new name 2';
await orm.em.persistAndFlush(book); // all book tags and author will be persisted too

----------------------------------------

TITLE: EntityManager Import for MongoDB
DESCRIPTION: Shows the updated way to import EntityManager for MongoDB operations in v4.

LANGUAGE: typescript
CODE:
import { EntityManager } from '@mikro-orm/mongodb';

const em: EntityManager;
const ret = await em.aggregate(...);

----------------------------------------

TITLE: Defining MongoDB Entity Schema for BookTag in TypeScript
DESCRIPTION: This example shows how to define an entity schema for MongoDB, including ObjectId as the primary key and a serialized primary key.

LANGUAGE: typescript
CODE:
export class BookTag {
  _id!: ObjectId;
  id!: string;
  name: string;
  books = new Collection<Book>(this);

  constructor(name: string) {
    this.name = name;
  }
}

export const schema = new EntitySchema<BookTag>({
  class: BookTag,
  properties: {
    _id: { type: 'ObjectId', primary: true },
    id: { type: 'string', serializedPrimaryKey: true },
    name: { type: 'string' },
    books: { reference: 'm:n', entity: () => Book, mappedBy: book => book.tags },
  },
});

----------------------------------------

TITLE: Configuring TsMorphMetadataProvider in TypeScript
DESCRIPTION: Example of how to explicitly enable the TsMorphMetadataProvider in the MikroORM configuration. This is necessary if you want to use ts-morph instead of the new default ReflectMetadataProvider.

LANGUAGE: typescript
CODE:
import { TsMorphMetadataProvider } from '@mikro-orm/reflection';

await MikroORM.init({
  metadataProvider: TsMorphMetadataProvider,
  // ...
});

----------------------------------------

TITLE: Adding migration class name customization
DESCRIPTION: Bugfix commit resolving custom migration names in class name generation

LANGUAGE: markdown
CODE:
### Bug Fixes
* **migrations:** respect custom migration name in migration class names ([#4294](https://github.com/mikro-orm/mikro-orm/issues/4294)) ([c402a99](https://github.com/mikro-orm/mikro-orm/commit/c402a993b75a09a78f8fb9ea3de44f5298729689))