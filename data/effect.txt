TITLE: Using Effect.bind for Do Simulation in TypeScript
DESCRIPTION: This example demonstrates how to use Effect.bind and Effect.let within a do simulation scope to define variables and perform operations. It shows how to bind Effect values and simple values, then compute a result.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Effect, pipe } from "effect"

const result = pipe(
  Effect.Do,
  Effect.bind("x", () => Effect.succeed(2)),
  Effect.bind("y", () => Effect.succeed(3)),
  Effect.let("sum", ({ x, y }) => x + y)
)
assert.deepStrictEqual(Effect.runSync(result), { x: 2, y: 3, sum: 5 })

----------------------------------------

TITLE: Declaring Schema Types in TypeScript using Effect-TS
DESCRIPTION: The Schema.declare function is used to create custom schemas with type-safe parsing and encoding. It supports two overloads: one for simple type checks and another for more complex schemas with type parameters and custom decode/encode functions.

LANGUAGE: typescript
CODE:
declare const declare: {
  <A>(is: (input: unknown) => input is A, annotations?: Annotations.Schema<A>): declare<A>;
  <A, I, const P extends ReadonlyArray<Schema.All>>(typeParameters: P, options: {
    readonly decode: (...typeParameters: { readonly [K in keyof P]: Schema<Schema.Type<P[K]>, Schema.Encoded<P[K]>, never>; }) => (input: unknown, options: ParseOptions, ast: AST.Declaration) => Effect.Effect<A, ParseResult.ParseIssue, never>;
    readonly encode: (...typeParameters: { readonly [K in keyof P]: Schema<Schema.Type<P[K]>, Schema.Encoded<P[K]>, never>; }) => (input: unknown, options: ParseOptions, ast: AST.Declaration) => Effect.Effect<I, ParseResult.ParseIssue, never>;
  }, annotations?: Annotations.Schema<A, { readonly [K in keyof P]: Schema.Type<P[K]>; }>): declare<A, I, P>;
}

----------------------------------------

TITLE: Using matchCauseEffect for Error Handling in TypeScript
DESCRIPTION: Demonstrates how to use matchCauseEffect to handle different types of failures while performing side effects. The example shows handling of Die, Fail, and Interrupt cases with console logging.

LANGUAGE: typescript
CODE:
import { Effect, Console } from "effect"

const task: Effect.Effect<number, Error> = Effect.die("Uh oh!")

const program = Effect.matchCauseEffect(task, {
  onFailure: (cause) => {
    switch (cause._tag) {
      case "Fail":
        // Handle standard failure with a logged message
        return Console.log(`Fail: ${cause.error.message}`)
      case "Die":
        // Handle defects (unexpected errors) by logging the defect
        return Console.log(`Die: ${cause.defect}`)
      case "Interrupt":
        // Handle interruption and log the fiberId that was interrupted
        return Console.log(`${cause.fiberId} interrupted!`)
    }
    // Fallback for other causes
    return Console.log("failed due to other causes")
  },
  onSuccess: (value) =>
    // Log success if the task completes successfully
    Console.log(`succeeded with ${value} value`)
})

Effect.runPromise(program)
// Output: "Die: Uh oh!"

----------------------------------------

TITLE: Transforming Values with Effect.map in TypeScript
DESCRIPTION: Demonstrates how to use Effect.map to transform values inside effects. It includes multiple syntax options and explains that effects are immutable, returning new effects with updated values.

LANGUAGE: typescript
CODE:
const mappedEffect = pipe(myEffect, Effect.map(transformation))
// or
const mappedEffect = Effect.map(myEffect, transformation)
// or
const mappedEffect = myEffect.pipe(Effect.map(transformation))

----------------------------------------

TITLE: Implementing Left-to-Right Function Composition in TypeScript
DESCRIPTION: The `flow` function performs left-to-right function composition. It allows the first argument to have any arity, while the remaining arguments must be unary. This example demonstrates composing string length calculation with doubling the result.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { flow } from "effect/Function"

const len = (s: string): number => s.length
const double = (n: number): number => n * 2

const f = flow(len, double)

assert.strictEqual(f('aaa'), 6)

----------------------------------------

TITLE: Short-Circuiting Behavior Example - TypeScript Effect Library
DESCRIPTION: Shows how Effect.all handles errors by default, stopping execution on the first failure encountered.

LANGUAGE: typescript
CODE:
import { Effect, Console } from "effect"

const program = Effect.all([
  Effect.succeed("Task1").pipe(Effect.tap(Console.log)),
  Effect.fail("Task2: Oh no!").pipe(Effect.tap(Console.log)),
  Effect.succeed("Task3").pipe(Effect.tap(Console.log))
])

Effect.runPromiseExit(program).then(console.log)

----------------------------------------

TITLE: Declaring HashMap.get Function in TypeScript
DESCRIPTION: Defines the 'get' function for safely retrieving values from a HashMap using an internal hashing function. It supports both curried and non-curried usage patterns.

LANGUAGE: typescript
CODE:
declare const get: { <K1>(key: K1): <K, V>(self: HashMap<K, V>) => Option<V>; <K, V, K1>(self: HashMap<K, V>, key: K1): Option<V>; }

----------------------------------------

TITLE: Automatically Managing Resource Lifetime with Effect.acquireUseRelease in TypeScript
DESCRIPTION: This example demonstrates how to use Effect.acquireUseRelease to manage the lifecycle of a resource. It shows the acquisition, use, and release of a custom MyResource object, ensuring proper resource management even in case of errors.

LANGUAGE: typescript
CODE:
import { Effect, Console } from "effect"

// Define an interface for a resource
interface MyResource {
  readonly contents: string
  readonly close: () => Promise<void>
}

// Simulate resource acquisition
const getMyResource = (): Promise<MyResource> =>
  Promise.resolve({
    contents: "lorem ipsum",
    close: () =>
      new Promise((resolve) => {
        console.log("Resource released")
        resolve()
      })
  })

// Define how the resource is acquired
const acquire = Effect.tryPromise({
  try: () =>
    getMyResource().then((res) => {
      console.log("Resource acquired")
      return res
    }),
  catch: () => new Error("getMyResourceError")
})

// Define how the resource is released
const release = (res: MyResource) => Effect.promise(() => res.close())

const use = (res: MyResource) => Console.log(`content is ${res.contents}`)

//      ┌─── Effect<void, Error, never>
//      ▼
const program = Effect.acquireUseRelease(acquire, use, release)

Effect.runPromise(program)
// Output:
// Resource acquired
// content is lorem ipsum
// Resource released

----------------------------------------

TITLE: Filtering Duplicate Stream Elements - TypeScript Effect Library
DESCRIPTION: Demonstrates how to use Stream.changes to filter out consecutive duplicate elements from a stream. The example shows transformation of a stream with repeated values into one where only changes are preserved.

LANGUAGE: typescript
CODE:
import { Effect, Stream } from "effect"

const stream = Stream.make(1, 1, 1, 2, 2, 3, 4).pipe(Stream.changes)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 1, 2, 3, 4 ] }

LANGUAGE: typescript
CODE:
declare const changes: <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>

----------------------------------------

TITLE: Handling Multiple Tagged Error Types with Effect.catchTags in TypeScript
DESCRIPTION: This example demonstrates how to use Effect.catchTags to handle multiple error types (HttpError and ValidationError) in a single call. It shows the creation of a program that may fail with either error type, and how to recover from these errors using catchTags.

LANGUAGE: typescript
CODE:
import { Effect, Random } from "effect"

class HttpError {
  readonly _tag = "HttpError"
}

class ValidationError {
  readonly _tag = "ValidationError"
}

//      ┌─── Effect<string, HttpError | ValidationError, never>
//      ▼
const program = Effect.gen(function* () {
  const n1 = yield* Random.next
  const n2 = yield* Random.next
  if (n1 < 0.5) {
    yield* Effect.fail(new HttpError())
  }
  if (n2 < 0.5) {
    yield* Effect.fail(new ValidationError())
  }
  return "some result"
})

//      ┌─── Effect<string, never, never>
//      ▼
const recovered = program.pipe(
  Effect.catchTags({
    HttpError: (_HttpError) =>
      Effect.succeed(`Recovering from HttpError`),
    ValidationError: (_ValidationError) =>
      Effect.succeed(`Recovering from ValidationError`)
  })
)

----------------------------------------

TITLE: Extending Schemas in Effect Framework - TypeScript Example
DESCRIPTION: Demonstrates how to extend a base schema with additional fields and index signatures. Shows extending a struct schema with both additional fields and a record schema for index signatures.

LANGUAGE: typescript
CODE:
import * as Schema from "effect/Schema"

const schema = Schema.Struct({
  a: Schema.String,
  b: Schema.String
})

// const extended: Schema<
//   {
//     readonly a: string
//     readonly b: string
//   } & {
//     readonly c: string
//   } & {
//     readonly [x: string]: string
//   }
// >
const extended = Schema.asSchema(schema.pipe(
  Schema.extend(Schema.Struct({ c: Schema.String })), // <= you can add more fields
  Schema.extend(Schema.Record({ key: Schema.String, value: Schema.String })) // <= you can add index signatures
))

----------------------------------------

TITLE: Applying Effects to Iterable Elements with Effect.forEach in TypeScript
DESCRIPTION: This example demonstrates how to use Effect.forEach to apply effects to each element of an iterable, collecting the results into an array.

LANGUAGE: typescript
CODE:
import { Effect, Console } from "effect"

const result = Effect.forEach([1, 2, 3, 4, 5], (n, index) =>
  Console.log(`Currently at index ${index}`).pipe(Effect.as(n * 2))
)

Effect.runPromise(result).then(console.log)
// Output:
// Currently at index 0
// Currently at index 1
// Currently at index 2
// Currently at index 3
// Currently at index 4
// [ 2, 4, 6, 8, 10 ]

----------------------------------------

TITLE: Defining Effect Interface in TypeScript
DESCRIPTION: This code snippet defines the Effect interface, which represents a computation that can succeed with a value of type A, fail with an error of type E, or require an environment of type R. It extends Effect.Variance and Pipeable, and includes several type-level operations.

LANGUAGE: typescript
CODE:
export interface Effect<out A, out E = never, out R = never> extends Effect.Variance<A, E, R>, Pipeable {
  readonly [Unify.typeSymbol]?: unknown
  readonly [Unify.unifySymbol]?: EffectUnify<this>
  readonly [Unify.ignoreSymbol]?: EffectUnifyIgnore
  [Symbol.iterator](): EffectGenerator<Effect<A, E, R>>
}

----------------------------------------

TITLE: Implementing Resource Management with Effect.acquireRelease in TypeScript
DESCRIPTION: Demonstrates how to create a resource management workflow using Effect.acquireRelease. The example shows creation of a custom resource with acquisition and release logic, including proper error handling and Promise integration.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

// Define an interface for a resource
interface MyResource {
  readonly contents: string
  readonly close: () => Promise<void>
}

// Simulate resource acquisition
const getMyResource = (): Promise<MyResource> =>
  Promise.resolve({
    contents: "lorem ipsum",
    close: () =>
      new Promise((resolve) => {
        console.log("Resource released")
        resolve()
      })
  })

// Define how the resource is acquired
const acquire = Effect.tryPromise({
  try: () =>
    getMyResource().then((res) => {
      console.log("Resource acquired")
      return res
    }),
  catch: () => new Error("getMyResourceError")
})

// Define how the resource is released
const release = (res: MyResource) => Effect.promise(() => res.close())

// Create the resource management workflow
//
//      ┌─── Effect<MyResource, Error, Scope>
//      ▼
const resource = Effect.acquireRelease(acquire, release)

----------------------------------------

TITLE: Creating Services with Effect.Service in TypeScript
DESCRIPTION: Example demonstrating how to create services using Effect.Service. Shows creation of a Prefix service with static implementation and a Logger service with dynamic implementation and dependencies.

LANGUAGE: typescript
CODE:
import { Effect } from 'effect';

class Prefix extends Effect.Service<Prefix>()("Prefix", {
 sync: () => ({ prefix: "PRE" })
}) {}

class Logger extends Effect.Service<Logger>()("Logger", {
 accessors: true,
 effect: Effect.gen(function* () {
   const { prefix } = yield* Prefix
   return {
     info: (message: string) =>
       Effect.sync(() => {
         console.log(`[${prefix}][${message}]`)
       })
   }
 }),
 dependencies: [Prefix.Default]
}) {}

----------------------------------------

TITLE: Handling All Defects with Effect.catchAllDefect in TypeScript
DESCRIPTION: Demonstrates how to use Effect.catchAllDefect to recover from defects in an Effect. It simulates a runtime error and shows how to catch and log different types of defects.

LANGUAGE: typescript
CODE:
import { Effect, Cause, Console } from "effect"

// Simulating a runtime error
const task = Effect.dieMessage("Boom!")

const program = Effect.catchAllDefect(task, (defect) => {
  if (Cause.isRuntimeException(defect)) {
    return Console.log(
      `RuntimeException defect caught: ${defect.message}`
    )
  }
  return Console.log("Unknown defect caught.")
})

// We get an Exit.Success because we caught all defects
Effect.runPromiseExit(program).then(console.log)
// Output:
// RuntimeException defect caught: Boom!
// {
//   _id: "Exit",
//   _tag: "Success",
//   value: undefined
// }

----------------------------------------

TITLE: Using Effect.allWith for Concurrent Effect Execution in TypeScript
DESCRIPTION: Demonstrates how to use Effect.allWith to run multiple effects concurrently with custom execution options. The example shows two effects with different delays being executed with a concurrency level of 2, producing logged output and final results.

LANGUAGE: typescript
CODE:
import { Effect, pipe } from "effect"

const task1 = Effect.succeed(1).pipe(
  Effect.delay("200 millis"),
  Effect.tap(Effect.log("task1 done"))
)

const task2 = Effect.succeed("hello").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Effect.log("task2 done"))
)

const program = pipe(
  [task1, task2],
  // Run both effects concurrently using the concurrent option
  Effect.allWith({ concurrency: 2 })
)

Effect.runPromise(program).then(console.log)
// Output:
// timestamp=... level=INFO fiber=#3 message="task2 done"
// timestamp=... level=INFO fiber=#2 message="task1 done"
// [ 1, 'hello' ]

LANGUAGE: typescript
CODE:
declare const allWith: <O extends NoExcessProperties<{ readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly discard?: boolean | undefined; readonly mode?: "default" | "validate" | "either" | undefined; readonly concurrentFinalizers?: boolean | undefined; }, O>>(options?: O) => <const Arg extends Iterable<Effect<any, any, any>> | Record<string, Effect<any, any, any>>>(arg: Arg) => All.Return<Arg, O>

----------------------------------------

TITLE: Creating an Effect from a Callback API in TypeScript
DESCRIPTION: Demonstrates how to wrap a callback-style API (Node.js file reading) into an Effect using Effect.async. It handles both success and error cases, returning an Effect<Buffer, Error>.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"
import * as NodeFS from "node:fs"

const readFile = (filename: string) =>
  Effect.async<Buffer, Error>((resume) => {
    NodeFS.readFile(filename, (error, data) => {
      if (error) {
        // Resume with a failed Effect if an error occurs
        resume(Effect.fail(error))
      } else {
        // Resume with a succeeded Effect if successful
        resume(Effect.succeed(data))
      }
    })
  })

//      ┌─── Effect<Buffer, Error, never>
//      ▼
const program = readFile("example.txt")

----------------------------------------

TITLE: Creating Stream from Chunks in TypeScript using Effect
DESCRIPTION: Demonstrates how to create a Stream from multiple Chunks using the fromChunks method in the Effect library. The example shows combining two chunks of numbers into a single stream and collecting the results.

LANGUAGE: typescript
CODE:
import { Chunk, Effect, Stream } from "effect"

// Creating a stream with values from multiple Chunks
const stream = Stream.fromChunks(Chunk.make(1, 2, 3), Chunk.make(4, 5, 6))

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 1, 2, 3, 4, 5, 6 ] }

LANGUAGE: typescript
CODE:
declare const fromChunks: <A>(...chunks: Array<Chunk.Chunk<A>>) => Stream<A>

----------------------------------------

TITLE: Grouping and Counting Stream Elements by Initial Letter in TypeScript
DESCRIPTION: This example demonstrates how to use Stream.groupBy to group an array of names by their initial letter and count the occurrences. It uses the Effect library's Stream, Chunk, and GroupBy modules.

LANGUAGE: typescript
CODE:
import { Chunk, Effect, GroupBy, Stream } from "effect"

const groupByKeyResult = Stream.fromIterable([
  "Mary",
  "James",
  "Robert",
  "Patricia",
  "John",
  "Jennifer",
  "Rebecca",
  "Peter"
]).pipe(
  Stream.groupBy((name) => Effect.succeed([name.substring(0, 1), name]))
)

const stream = GroupBy.evaluate(groupByKeyResult, (key, stream) =>
  Stream.fromEffect(
    Stream.runCollect(stream).pipe(
      Effect.andThen((chunk) => [key, Chunk.size(chunk)] as const)
    )
  ))

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// {
//   _id: 'Chunk',
//   values: [ [ 'M', 1 ], [ 'J', 3 ], [ 'R', 2 ], [ 'P', 2 ] ]
// }

----------------------------------------

TITLE: Creating a Stream from an Effect in TypeScript
DESCRIPTION: Demonstrates how to use Stream.fromEffect to create a stream that emits the success value of an effect or terminates with its failure. The example uses a random integer effect.

LANGUAGE: typescript
CODE:
import { Effect, Random, Stream } from "effect"

const stream = Stream.fromEffect(Random.nextInt)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// Example Output: { _id: 'Chunk', values: [ 922694024 ] }

----------------------------------------

TITLE: Collecting Results with Either Mode - TypeScript Effect Library
DESCRIPTION: Demonstrates using Effect.all with 'either' mode to collect both successes and failures without short-circuiting.

LANGUAGE: typescript
CODE:
import { Effect, Console } from "effect"

const effects = [
  Effect.succeed("Task1").pipe(Effect.tap(Console.log)),
  Effect.fail("Task2: Oh no!").pipe(Effect.tap(Console.log)),
  Effect.succeed("Task3").pipe(Effect.tap(Console.log))
]

const program = Effect.all(effects, { mode: "either" })

Effect.runPromiseExit(program).then(console.log)

----------------------------------------

TITLE: Creating Delayed Message Effect with Promise in TypeScript
DESCRIPTION: Demonstrates how to create an Effect that wraps a Promise to handle a delayed message operation. The Promise resolves after 2 seconds with a success message, showing typical usage of Effect.promise for guaranteed-to-succeed async operations.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

const delay = (message: string) =>
  Effect.promise<string>(
    () =>
      new Promise((resolve) => {
        setTimeout(() => {
          resolve(message)
        }, 2000)
      })
  )

//      ┌─── Effect<string, never, never>
//      ▼
const program = delay("Async operation completed successfully!")

----------------------------------------

TITLE: Basic Effect.andThen Syntax
DESCRIPTION: Different syntactical ways to use the Effect.andThen operator for chaining actions.

LANGUAGE: typescript
CODE:
const transformedEffect = pipe(myEffect, Effect.andThen(anotherEffect))
// or
const transformedEffect = Effect.andThen(myEffect, anotherEffect)
// or
const transformedEffect = myEffect.pipe(Effect.andThen(anotherEffect))

----------------------------------------

TITLE: Stream.fromIterable Function Signature
DESCRIPTION: TypeScript type declaration for the fromIterable function that creates a Stream from an Iterable of type A.

LANGUAGE: typescript
CODE:
declare const fromIterable: <A>(iterable: Iterable<A>) => Stream<A>

----------------------------------------

TITLE: Using Effect.gen for Transaction Processing in TypeScript
DESCRIPTION: Demonstrates using Effect.gen to handle a transaction flow with discount calculations and service charges. Shows how to combine multiple effects using generator syntax with proper error handling and async operations.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

const addServiceCharge = (amount: number) => amount + 1

const applyDiscount = (
  total: number,
  discountRate: number
): Effect.Effect<number, Error> =>
  discountRate === 0
    ? Effect.fail(new Error("Discount rate cannot be zero"))
    : Effect.succeed(total - (total * discountRate) / 100)

const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))

const fetchDiscountRate = Effect.promise(() => Promise.resolve(5))

export const program = Effect.gen(function* () {
  const transactionAmount = yield* fetchTransactionAmount
  const discountRate = yield* fetchDiscountRate
  const discountedAmount = yield* applyDiscount(
    transactionAmount,
    discountRate
  )
  const finalAmount = addServiceCharge(discountedAmount)
  return `Final amount to charge: ${finalAmount}`
})

----------------------------------------

TITLE: Creating Case Classes with Effect Data.Class
DESCRIPTION: Example demonstrating how to create and use case classes using Effect's Data.Class. Shows class definition, instance creation, and equality comparison using the Equal utility.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Data, Equal } from "effect"

class Person extends Data.Class<{ readonly name: string }> {}

// Creating instances of Person
const mike1 = new Person({ name: "Mike" })
const mike2 = new Person({ name: "Mike" })
const john = new Person({ name: "John" })

// Checking equality
assert.deepStrictEqual(Equal.equals(mike1, mike2), true)
assert.deepStrictEqual(Equal.equals(mike1, john), false)

----------------------------------------

TITLE: TypeScript Function Signature for Flexible Function Composition
DESCRIPTION: This complex TypeScript signature defines the `flow` function, allowing for composition of up to 10 functions with flexible input and output types. It supports various arities and ensures type safety throughout the composition chain.

LANGUAGE: typescript
CODE:
declare const flow: { <A extends ReadonlyArray<unknown>, B = never>(ab: (...a: A) => B): (...a: A) => B; <A extends ReadonlyArray<unknown>, B = never, C = never>(ab: (...a: A) => B, bc: (b: B) => C): (...a: A) => C; <A extends ReadonlyArray<unknown>, B = never, C = never, D = never>(ab: (...a: A) => B, bc: (b: B) => C, cd: (c: C) => D): (...a: A) => D; <A extends ReadonlyArray<unknown>, B = never, C = never, D = never, E = never>(ab: (...a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E): (...a: A) => E; <A extends ReadonlyArray<unknown>, B = never, C = never, D = never, E = never, F = never>(ab: (...a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F): (...a: A) => F; <A extends ReadonlyArray<unknown>, B = never, C = never, D = never, E = never, F = never, G = never>(ab: (...a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G): (...a: A) => G; <A extends ReadonlyArray<unknown>, B = never, C = never, D = never, E = never, F = never, G = never, H = never>(ab: (...a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H): (...a: A) => H; <A extends ReadonlyArray<unknown>, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never>(ab: (...a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I): (...a: A) => I; <A extends ReadonlyArray<unknown>, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never, J = never>(ab: (...a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I, ij: (i: I) => J): (...a: A) => J; }

----------------------------------------

TITLE: Running a Cleanup Action on Interruption with Effect.onInterrupt in TypeScript
DESCRIPTION: This example demonstrates how to use Effect.onInterrupt to register a cleanup action that runs when an effect is interrupted. It shows three scenarios: successful completion, failure, and interruption.

LANGUAGE: typescript
CODE:
import { Console, Effect } from "effect"

// This handler is executed when the fiber is interrupted
const handler = Effect.onInterrupt((_fibers) => Console.log("Cleanup completed"))

const success = Console.log("Task completed").pipe(Effect.as("some result"), handler)

Effect.runFork(success)
// Output:
// Task completed

const failure = Console.log("Task failed").pipe(Effect.andThen(Effect.fail("some error")), handler)

Effect.runFork(failure)
// Output:
// Task failed

const interruption = Console.log("Task interrupted").pipe(Effect.andThen(Effect.interrupt), handler)

Effect.runFork(interruption)
// Output:
// Task interrupted
// Cleanup completed

----------------------------------------

TITLE: Using Effect.provide with Database Layer Example
DESCRIPTION: Demonstrates how to create and provide a database layer to an effect using Effect.provide. Shows creation of a Database context tag, implementation of a live database layer, and composition with an effect program.

LANGUAGE: typescript
CODE:
import { Context, Effect, Layer } from "effect"

class Database extends Context.Tag("Database")<
  Database,
  { readonly query: (sql: string) => Effect.Effect<Array<unknown>> }
>() {}

const DatabaseLive = Layer.succeed(
  Database,
  {
    // Simulate a database query
    query: (sql: string) => Effect.log(`Executing query: ${sql}`).pipe(Effect.as([]))
  }
)

//      ┌─── Effect<unknown[], never, Database>
//      ▼
const program = Effect.gen(function*() {
  const database = yield* Database
  const result = yield* database.query("SELECT * FROM users")
  return result
})

//      ┌─── Effect<unknown[], never, never>
//      ▼
const runnable = Effect.provide(program, DatabaseLive)

Effect.runPromise(runnable).then(console.log)
// Output:
// timestamp=... level=INFO fiber=#0 message="Executing query: SELECT * FROM users"
// []

----------------------------------------

TITLE: Chaining Effects with Effect.flatMap in TypeScript
DESCRIPTION: Illustrates a practical example of using Effect.flatMap to chain multiple effects. It includes fetching a transaction amount and applying a discount, demonstrating error handling and effect composition.

LANGUAGE: typescript
CODE:
import { pipe, Effect } from "effect"

// Function to apply a discount safely to a transaction amount
const applyDiscount = (
  total: number,
  discountRate: number
): Effect.Effect<number, Error> =>
  discountRate === 0
    ? Effect.fail(new Error("Discount rate cannot be zero"))
    : Effect.succeed(total - (total * discountRate) / 100)

// Simulated asynchronous task to fetch a transaction amount from database
const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))

// Chaining the fetch and discount application using `flatMap`
const finalAmount = pipe(
  fetchTransactionAmount,
  Effect.flatMap((amount) => applyDiscount(amount, 5))
)

Effect.runPromise(finalAmount).then(console.log)
// Output: 95

----------------------------------------

TITLE: Using Effect.match for Success/Failure Handling in TypeScript
DESCRIPTION: Demonstrates how to use Effect.match to handle both successful and failed effects. The example shows creating effects that succeed and fail, then using match to process their results with custom handlers for each case.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

const success: Effect.Effect<number, Error> = Effect.succeed(42)

const program1 = Effect.match(success, {
  onFailure: (error) => `failure: ${error.message}`,
  onSuccess: (value) => `success: ${value}`
})

// Run and log the result of the successful effect
Effect.runPromise(program1).then(console.log)
// Output: "success: 42"

const failure: Effect.Effect<number, Error> = Effect.fail(
  new Error("Uh oh!")
)

const program2 = Effect.match(failure, {
  onFailure: (error) => `failure: ${error.message}`,
  onSuccess: (value) => `success: ${value}`
})

// Run and log the result of the failed effect
Effect.runPromise(program2).then(console.log)
// Output: "failure: Uh oh!"

LANGUAGE: typescript
CODE:
declare const match: { <E, A2, A, A3>(options: { readonly onFailure: (error: E) => A2; readonly onSuccess: (value: A) => A3; }): <R>(self: Effect<A, E, R>) => Effect<A2 | A3, never, R>; <A, E, R, A2, A3>(self: Effect<A, E, R>, options: { readonly onFailure: (error: E) => A2; readonly onSuccess: (value: A) => A3; }): Effect<A2 | A3, never, R>; }

----------------------------------------

TITLE: Implementing Paginated Stream Generation in TypeScript with Effect
DESCRIPTION: The `paginateEffect` function creates a stream by unfolding a state and allowing emission of values to end one step further. It's particularly useful for implementing paginated APIs. The function takes an initial state and a function that produces effects containing tuples of values and optional next states.

LANGUAGE: typescript
CODE:
declare const paginateEffect: <S, A, E, R>(s: S, f: (s: S) => Effect.Effect<readonly [A, Option.Option<S>], E, R>) => Stream<A, E, R>

----------------------------------------

TITLE: Defining Cache Interface in TypeScript
DESCRIPTION: Defines a generic Cache interface that handles concurrent value lookup, caching, and refresh operations. The interface provides type-safe methods for getting, setting and refreshing cached values with error handling support.

LANGUAGE: typescript
CODE:
export interface Cache<in out Key, in out Value, out Error = never>
  extends ConsumerCache<Key, Value, Error>, Cache.Variance<Key, Value, Error>
{
  /**
   * Retrieves the value associated with the specified key if it exists.
   * Otherwise computes the value with the lookup function, puts it in the
   * cache, and returns it.
   */
  get(key: Key): Effect.Effect<Value, Error>

  /**
   * Retrieves the value associated with the specified key if it exists as a left.
   * Otherwise computes the value with the lookup function, puts it in the
   * cache, and returns it as a right.
   */
  getEither(key: Key): Effect.Effect<Either<Value, Value>, Error>

  /**
   * Computes the value associated with the specified key, with the lookup
   * function, and puts it in the cache. The difference between this and
   * `get` method is that `refresh` triggers (re)computation of the value
   * without invalidating it in the cache, so any request to the associated
   * key can still be served while the value is being re-computed/retrieved
   * by the lookup function. Additionally, `refresh` always triggers the
   * lookup function, disregarding the last `Error`.
   */
  refresh(key: Key): Effect.Effect<void, Error>

  /**
   * Associates the specified value with the specified key in the cache.
   */
  set(key: Key, value: Value): Effect.Effect<void>
}

----------------------------------------

TITLE: Creating and Using RateLimiter in TypeScript with Effect
DESCRIPTION: Demonstrates how to create and compose multiple rate limiters to enforce both per-minute and per-second request limits. The example shows rate limiting for logging effects with a limit of 30 calls per minute and 2 calls per second.

LANGUAGE: typescript
CODE:
import { Effect, RateLimiter } from "effect";
import { compose } from "effect/Function"

const program = Effect.scoped(
  Effect.gen(function* ($) {
    const perMinuteRL = yield* $(RateLimiter.make({ limit: 30, interval: "1 minutes" }))
    const perSecondRL = yield* $(RateLimiter.make({ limit: 2, interval: "1 seconds" }))

    // This rate limiter respects both the 30 calls per minute
    // and the 2 calls per second constraints.
     const rateLimit = compose(perMinuteRL, perSecondRL)

    // simulate repeated calls
    for (let n = 0; n < 100; n++) {
      // wrap the effect we want to limit with rateLimit
      yield* $(rateLimit(Effect.log("Calling RateLimited Effect")));
    }
  })
);

LANGUAGE: typescript
CODE:
declare const make: (options: RateLimiter.Options) => Effect<RateLimiter, never, Scope>

----------------------------------------

TITLE: Defining HttpApi Interface in TypeScript
DESCRIPTION: TypeScript interface definition for HttpApi that provides functionality for building HTTP APIs. Includes generic type parameters for ID, Groups, Errors, and Requirements. Supports methods for adding groups, other APIs, error handling, prefixing paths, middleware, and annotations.

LANGUAGE: typescript
CODE:
export interface HttpApi<
  out Id extends string,
  out Groups extends HttpApiGroup.HttpApiGroup.Any = never,
  in out E = never,
  out R = never
> extends Pipeable {
  new(_: never): {}
  readonly [TypeId]: TypeId
  readonly identifier: Id
  readonly groups: Record.ReadonlyRecord<string, Groups>
  readonly annotations: Context.Context<never>
  readonly errorSchema: Schema.Schema<E, unknown, R>
  readonly middlewares: ReadonlySet<HttpApiMiddleware.TagClassAny>

  /**
   * Add a `HttpApiGroup` to the `HttpApi`.
   */
  add<A extends HttpApiGroup.HttpApiGroup.Any>(group: A): HttpApi<Id, Groups | A, E, R>
  /**
   * Add another `HttpApi` to the `HttpApi`.
   */
  addHttpApi<Id2 extends string, Groups2 extends HttpApiGroup.HttpApiGroup.Any, E2, R2>(
    api: HttpApi<Id2, Groups2, E2, R2>
  ): HttpApi<
    Id,
    Groups | HttpApiGroup.HttpApiGroup.AddContext<Groups2, R2>,
    E | E2,
    R
  >
  /**
   * Add an global error to the `HttpApi`.
   */
  addError<A, I, RX>(
    schema: Schema.Schema<A, I, RX>,
    annotations?: {
      readonly status?: number | undefined
    }
  ): HttpApi<Id, Groups, E | A, R | RX>
  /**
   * Prefix all endpoints in the `HttpApi`.
   */
  prefix(prefix: HttpApiEndpoint.PathSegment): HttpApi<Id, Groups, E, R>
  /**
   * Add a middleware to a `HttpApi`. It will be applied to all endpoints in the
   * `HttpApi`.
   */
  middleware<I extends HttpApiMiddleware.HttpApiMiddleware.AnyId, S>(
    middleware: Context.Tag<I, S>
  ): HttpApi<
    Id,
    Groups,
    E | HttpApiMiddleware.HttpApiMiddleware.Error<I>,
    R | I | HttpApiMiddleware.HttpApiMiddleware.ErrorContext<I>
  >
  /**
   * Annotate the `HttpApi`.
   */
  annotate<I, S>(tag: Context.Tag<I, S>, value: S): HttpApi<Id, Groups, E, R>
  /**
   * Annotate the `HttpApi` with a Context.
   */
  annotateContext<I>(context: Context.Context<I>): HttpApi<Id, Groups, E, R>
}

----------------------------------------

TITLE: Forking Concurrent Effects in TypeScript using Effect.fork
DESCRIPTION: Demonstrates how to use Effect.fork to create a new fiber for concurrent execution of an effect. The example shows a recursive Fibonacci calculation implemented using Effect, which is then forked into a separate fiber.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

const fib = (n: number): Effect.Effect<number> =>
  n < 2
    ? Effect.succeed(n)
    : Effect.zipWith(fib(n - 1), fib(n - 2), (a, b) => a + b)

//      ┌─── Effect<RuntimeFiber<number, never>, never, never>
//      ▼
const fib10Fiber = Effect.fork(fib(10))

----------------------------------------

TITLE: Converting Callback Functions to Effect in TypeScript
DESCRIPTION: Complex TypeScript type definition that converts callback-based functions into functions that return Effect values. Handles up to 10 function overloads with different argument types and automatically converts the callback result type into an Effect return type.

LANGUAGE: typescript
CODE:
type Effectify<T, E> = T extends {
  (...args: ArgsWithCallback<infer Args1, infer _E1, infer A1>): infer _R1
  (...args: ArgsWithCallback<infer Args2, infer _E2, infer A2>): infer _R2
  (...args: ArgsWithCallback<infer Args3, infer _E3, infer A3>): infer _R3
  (...args: ArgsWithCallback<infer Args4, infer _E4, infer A4>): infer _R4
  (...args: ArgsWithCallback<infer Args5, infer _E5, infer A5>): infer _R5
  (...args: ArgsWithCallback<infer Args6, infer _E6, infer A6>): infer _R6
  (...args: ArgsWithCallback<infer Args7, infer _E7, infer A7>): infer _R7
  (...args: ArgsWithCallback<infer Args8, infer _E8, infer A8>): infer _R8
  (...args: ArgsWithCallback<infer Args9, infer _E9, infer A9>): infer _R9
  (...args: ArgsWithCallback<infer Args10, infer _E10, infer A10>): infer _R10
} ? {
    (...args: Args1): Effect.Effect<WithoutNull<A1>, E>
    (...args: Args2): Effect.Effect<WithoutNull<A2>, E>
    (...args: Args3): Effect.Effect<WithoutNull<A3>, E>
    (...args: Args4): Effect.Effect<WithoutNull<A4>, E>
    (...args: Args5): Effect.Effect<WithoutNull<A5>, E>
    (...args: Args6): Effect.Effect<WithoutNull<A6>, E>
    (...args: Args7): Effect.Effect<WithoutNull<A7>, E>
    (...args: Args8): Effect.Effect<WithoutNull<A8>, E>
    (...args: Args9): Effect.Effect<WithoutNull<A9>, E>
    (...args: Args10): Effect.Effect<WithoutNull<A10>, E>
  }
  : T extends {
    (...args: ArgsWithCallback<infer Args1, infer _E1, infer A1>): infer _R1
    (...args: ArgsWithCallback<infer Args2, infer _E2, infer A2>): infer _R2
    (...args: ArgsWithCallback<infer Args3, infer _E3, infer A3>): infer _R3
    (...args: ArgsWithCallback<infer Args4, infer _E4, infer A4>): infer _R4
    (...args: ArgsWithCallback<infer Args5, infer _E5, infer A5>): infer _R5
    (...args: ArgsWithCallback<infer Args6, infer _E6, infer A6>): infer _R6
    (...args: ArgsWithCallback<infer Args7, infer _E7, infer A7>): infer _R7
    (...args: ArgsWithCallback<infer Args8, infer _E8, infer A8>): infer _R8
    (...args: ArgsWithCallback<infer Args9, infer _E9, infer A9>): infer _R9
  } ? {
      (...args: Args1): Effect.Effect<WithoutNull<A1>, E>
      (...args: Args2): Effect.Effect<WithoutNull<A2>, E>
      (...args: Args3): Effect.Effect<WithoutNull<A3>, E>
      (...args: Args4): Effect.Effect<WithoutNull<A4>, E>
      (...args: Args5): Effect.Effect<WithoutNull<A5>, E>
      (...args: Args6): Effect.Effect<WithoutNull<A6>, E>
      (...args: Args7): Effect.Effect<WithoutNull<A7>, E>
      (...args: Args8): Effect.Effect<WithoutNull<A8>, E>
      (...args: Args9): Effect.Effect<WithoutNull<A9>, E>
    }
  : T extends {
    (...args: ArgsWithCallback<infer Args1, infer _E1, infer A1>): infer _R1
    (...args: ArgsWithCallback<infer Args2, infer _E2, infer A2>): infer _R2
    (...args: ArgsWithCallback<infer Args3, infer _E3, infer A3>): infer _R3
    (...args: ArgsWithCallback<infer Args4, infer _E4, infer A4>): infer _R4
    (...args: ArgsWithCallback<infer Args5, infer _E5, infer A5>): infer _R5
    (...args: ArgsWithCallback<infer Args6, infer _E6, infer A6>): infer _R6
    (...args: ArgsWithCallback<infer Args7, infer _E7, infer A7>): infer _R7
    (...args: ArgsWithCallback<infer Args8, infer _E8, infer A8>): infer _R8
  } ? {
      (...args: Args1): Effect.Effect<WithoutNull<A1>, E>
      (...args: Args2): Effect.Effect<WithoutNull<A2>, E>
      (...args: Args3): Effect.Effect<WithoutNull<A3>, E>
      (...args: Args4): Effect.Effect<WithoutNull<A4>, E>
      (...args: Args5): Effect.Effect<WithoutNull<A5>, E>
      (...args: Args6): Effect.Effect<WithoutNull<A6>, E>
      (...args: Args7): Effect.Effect<WithoutNull<A7>, E>
      (...args: Args8): Effect.Effect<WithoutNull<A8>, E>
    }
  : T extends {
    (...args: ArgsWithCallback<infer Args1, infer _E1, infer A1>): infer _R1
    (...args: ArgsWithCallback<infer Args2, infer _E2, infer A2>): infer _R2
    (...args: ArgsWithCallback<infer Args3, infer _E3, infer A3>): infer _R3
    (...args: ArgsWithCallback<infer Args4, infer _E4, infer A4>): infer _R4
    (...args: ArgsWithCallback<infer Args5, infer _E5, infer A5>): infer _R5
    (...args: ArgsWithCallback<infer Args6, infer _E6, infer A6>): infer _R6
    (...args: ArgsWithCallback<infer Args7, infer _E7, infer A7>): infer _R7
  } ? {
      (...args: Args1): Effect.Effect<WithoutNull<A1>, E>
      (...args: Args2): Effect.Effect<WithoutNull<A2>, E>
      (...args: Args3): Effect.Effect<WithoutNull<A3>, E>
      (...args: Args4): Effect.Effect<WithoutNull<A4>, E>
      (...args: Args5): Effect.Effect<WithoutNull<A5>, E>
      (...args: Args6): Effect.Effect<WithoutNull<A6>, E>
      (...args: Args7): Effect.Effect<WithoutNull<A7>, E>
    }
  : T extends {
    (...args: ArgsWithCallback<infer Args1, infer _E1, infer A1>): infer _R1
    (...args: ArgsWithCallback<infer Args2, infer _E2, infer A2>): infer _R2
    (...args: ArgsWithCallback<infer Args3, infer _E3, infer A3>): infer _R3
    (...args: ArgsWithCallback<infer Args4, infer _E4, infer A4>): infer _R4
    (...args: ArgsWithCallback<infer Args5, infer _E5, infer A5>): infer _R5
    (...args: ArgsWithCallback<infer Args6, infer _E6, infer A6>): infer _R6
  } ? {
      (...args: Args1): Effect.Effect<WithoutNull<A1>, E>
      (...args: Args2): Effect.Effect<WithoutNull<A2>, E>
      (...args: Args3): Effect.Effect<WithoutNull<A3>, E>
      (...args: Args4): Effect.Effect<WithoutNull<A4>, E>
      (...args: Args5): Effect.Effect<WithoutNull<A5>, E>
      (...args: Args6): Effect.Effect<WithoutNull<A6>, E>
    }
  : T extends {
    (...args: ArgsWithCallback<infer Args1, infer _E1, infer A1>): infer _R1
    (...args: ArgsWithCallback<infer Args2, infer _E2, infer A2>): infer _R2
    (...args: ArgsWithCallback<infer Args3, infer _E3, infer A3>): infer _R3
    (...args: ArgsWithCallback<infer Args4, infer _E4, infer A4>): infer _R4
    (...args: ArgsWithCallback<infer Args5, infer _E5, infer A5>): infer _R5
  } ? {
      (...args: Args1): Effect.Effect<WithoutNull<A1>, E>
      (...args: Args2): Effect.Effect<WithoutNull<A2>, E>
      (...args: Args3): Effect.Effect<WithoutNull<A3>, E>
      (...args: Args4): Effect.Effect<WithoutNull<A4>, E>
      (...args: Args5): Effect.Effect<WithoutNull<A5>, E>
    }
  : T extends {
    (...args: ArgsWithCallback<infer Args1, infer _E1, infer A1>): infer _R1
    (...args: ArgsWithCallback<infer Args2, infer _E2, infer A2>): infer _R2
    (...args: ArgsWithCallback<infer Args3, infer _E3, infer A3>): infer _R3
    (...args: ArgsWithCallback<infer Args4, infer _E4, infer A4>): infer _R4
  } ? {
      (...args: Args1): Effect.Effect<WithoutNull<A1>, E>
      (...args: Args2): Effect.Effect<WithoutNull<A2>, E>
      (...args: Args3): Effect.Effect<WithoutNull<A3>, E>
      (...args: Args4): Effect.Effect<WithoutNull<A4>, E>
    }
  : T extends {
    (...args: ArgsWithCallback<infer Args1, infer _E1, infer A1>): infer _R1
    (...args: ArgsWithCallback<infer Args2, infer _E2, infer A2>): infer _R2
    (...args: ArgsWithCallback<infer Args3, infer _E3, infer A3>): infer _R3
  } ? {
      (...args: Args1): Effect.Effect<WithoutNull<A1>, E>
      (...args: Args2): Effect.Effect<WithoutNull<A2>, E>
      (...args: Args3): Effect.Effect<WithoutNull<A3>, E>
    }
  : T extends {
    (...args: ArgsWithCallback<infer Args1, infer _E1, infer A1>): infer _R1
    (...args: ArgsWithCallback<infer Args2, infer _E2, infer A2>): infer _R2
  } ? {
      (...args: Args1): Effect.Effect<WithoutNull<A1>, E>
      (...args: Args2): Effect.Effect<WithoutNull<A2>, E>
    }
  : T extends {
    (...args: ArgsWithCallback<infer Args1, infer _E1, infer A1>): infer _R1
  } ? {
      (...args: Args1): Effect.Effect<WithoutNull<A1>, E>
    }
  : never

----------------------------------------

TITLE: Using Effect.ignore to Discard Values in TypeScript
DESCRIPTION: This snippet demonstrates how to use Effect.ignore to discard both success and failure values of an effect. It creates a task that fails with a string error and would return a number on success, then uses Effect.ignore to transform it into an effect that always succeeds with void.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

//      ┌─── Effect<number, string, never>
//      ▼
const task = Effect.fail("Uh oh!").pipe(Effect.as(5))

//      ┌─── Effect<void, never, never>
//      ▼
const program = Effect.ignore(task)

----------------------------------------

TITLE: Pattern Matching with Match.when in TypeScript
DESCRIPTION: Demonstrates how to use Match.when for pattern matching on objects with age properties. It shows matching against specific values, predicates, and fallback cases.

LANGUAGE: typescript
CODE:
import { Match } from "effect"

// Create a matcher for objects with an "age" property
const match = Match.type<{ age: number }>().pipe(
  // Match when age is greater than 18
  Match.when({ age: (age) => age > 18 }, (user) => `Age: ${user.age}`),
  // Match when age is exactly 18
  Match.when({ age: 18 }, () => "You can vote"),
  // Fallback case for all other ages
  Match.orElse((user) => `${user.age} is too young`)
)

console.log(match({ age: 20 }))
// Output: "Age: 20"

console.log(match({ age: 18 }))
// Output: "You can vote"

console.log(match({ age: 4 }))
// Output: "4 is too young"

----------------------------------------

TITLE: Creating Successful Effect in TypeScript
DESCRIPTION: Demonstrates how to create an Effect that always succeeds with a specific value using Effect.succeed. This function is useful when you need an effect that completes successfully without any errors or external dependencies.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

// Creating an effect that represents a successful scenario
//
//      ┌─── Effect<number, never, never>
//      ▼
const success = Effect.succeed(42)

----------------------------------------

TITLE: Creating a Stream from Values in TypeScript using Effect
DESCRIPTION: Demonstrates how to create a stream from a sequence of values using Stream.make and run it using Effect.runPromise. The example shows creating a stream of numbers and collecting the results.

LANGUAGE: typescript
CODE:
import { Effect, Stream } from "effect"

const stream = Stream.make(1, 2, 3)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 1, 2, 3 ] }

----------------------------------------

TITLE: Defining mapConcatChunk Function for Stream Manipulation in TypeScript
DESCRIPTION: This function maps each element of a stream to a chunk and flattens the chunks into the output stream. It can be used in two ways: as a standalone function or as a method on a Stream object.

LANGUAGE: typescript
CODE:
declare const mapConcatChunk: {
  <A, A2>(f: (a: A) => Chunk.Chunk<A2>): <E, R>(self: Stream<A, E, R>) => Stream<A2, E, R>;
  <A, E, R, A2>(self: Stream<A, E, R>, f: (a: A) => Chunk.Chunk<A2>): Stream<A2, E, R>;
}

----------------------------------------

TITLE: Defining tryMapPromise Function in TypeScript for Effect Module
DESCRIPTION: This code snippet defines the tryMapPromise function, which returns an effect that maps its success using a side-effecting try function. It converts promise rejections into typed failed effects using a catch function. The function also supports an optional AbortSignal for interrupting the wrapped Promise API.

LANGUAGE: typescript
CODE:
declare const tryMapPromise: { <A, B, E1>(options: { readonly try: (a: A, signal: AbortSignal) => PromiseLike<B>; readonly catch: (error: unknown) => E1; }): <E, R>(self: Effect<A, E, R>) => Effect<B, E1 | E, R>; <A, E, R, B, E1>(self: Effect<A, E, R>, options: { readonly try: (a: A, signal: AbortSignal) => PromiseLike<B>; readonly catch: (error: unknown) => E1; }): Effect<B, E | E1, R>; }

----------------------------------------

TITLE: Grouping Stream Elements by Key in TypeScript
DESCRIPTION: Example demonstrating how to group words by their first letter and process each group independently. Shows collecting the first 2 words for each starting letter from a stream of words.

LANGUAGE: typescript
CODE:
import { pipe, GroupBy, Stream } from "effect"

pipe(
  Stream.fromIterable(["hello", "world", "hi", "holla"]),
  Stream.groupByKey((word) => word[0]),
  GroupBy.evaluate((key, stream) =>
    pipe(
      stream,
      Stream.take(2),
      Stream.map((words) => [key, words] as const)
    )
  )
)

----------------------------------------

TITLE: Checking Effect Type in TypeScript
DESCRIPTION: The isEffect function checks if a given value is an Effect value. It's useful for type checking before operating on a value as an Effect. The function takes an unknown value and returns a boolean indicating if it's an Effect.

LANGUAGE: typescript
CODE:
declare const isEffect: (u: unknown) => u is Effect<unknown, unknown, unknown>

----------------------------------------

TITLE: Implementing Stream.Do with Bindings in TypeScript
DESCRIPTION: Demonstrates how to use Stream.Do to create a declarative stream operation that binds multiple values and computes a sum. Shows the usage of bind and let operations within a stream pipeline.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Chunk, Effect, pipe, Stream } from "effect"

const result = pipe(
  Stream.Do,
  Stream.bind("x", () => Stream.succeed(2)),
  Stream.bind("y", () => Stream.succeed(3)),
  Stream.let("sum", ({ x, y }) => x + y)
)
assert.deepStrictEqual(Effect.runSync(Stream.runCollect(result)), Chunk.of({ x: 2, y: 3, sum: 5 }))

LANGUAGE: typescript
CODE:
declare const Do: Stream<{}, never, never>

----------------------------------------

TITLE: Implementing Generic Array Sort with Order Comparator in TypeScript
DESCRIPTION: Defines a generic array sorting function that creates a new array with elements sorted in increasing order based on a provided Order comparator. The function maintains type safety by preserving non-empty array types and supports both regular arrays and iterables.

LANGUAGE: typescript
CODE:
declare const sort: { 
  <B>(O: Order.Order<B>): <A extends B, S extends Iterable<A>>(self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S>>; 
  <A extends B, B>(self: NonEmptyReadonlyArray<A>, O: Order.Order<B>): NonEmptyArray<A>; 
  <A extends B, B>(self: Iterable<A>, O: Order.Order<B>): Array<A>; 
}

----------------------------------------

TITLE: Declaring filterEffect Function for Stream Filtering in TypeScript
DESCRIPTION: Defines the filterEffect function which effectfully filters elements emitted by a stream. It takes a predicate function that returns an Effect, and applies it to each element of the stream.

LANGUAGE: typescript
CODE:
declare const filterEffect: { <A, E2, R2>(f: (a: NoInfer<A>) => Effect.Effect<boolean, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: Stream<A, E, R>, f: (a: A) => Effect.Effect<boolean, E2, R2>): Stream<A, E | E2, R | R2>; }

----------------------------------------

TITLE: Sequential Effect Combination with TypeScript Effect Library
DESCRIPTION: Demonstrates combining two effects sequentially using Effect.zip. The example creates two tasks with different delays and combines them into a single effect that produces a tuple of their results.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

const task1 = Effect.succeed(1).pipe(
  Effect.delay("200 millis"),
  Effect.tap(Effect.log("task1 done"))
)
const task2 = Effect.succeed("hello").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Effect.log("task2 done"))
)

// Combine the two effects together
//
//      ┌─── Effect<[number, string], never, never>
//      ▼
const program = Effect.zip(task1, task2)

Effect.runPromise(program).then(console.log)
// Output:
// timestamp=... level=INFO fiber=#0 message="task1 done"
// timestamp=... level=INFO fiber=#0 message="task2 done"
// [ 1, 'hello' ]

----------------------------------------

TITLE: Using dropUntil with Effect in TypeScript
DESCRIPTION: Demonstrates how to use the dropUntil function to filter an array of numbers, dropping elements until a number greater than 3 is encountered. The example shows how to create a predicate function and use it with Effect.dropUntil.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

const numbers = [1, 2, 3, 4, 5, 6]
const predicate = (n: number, i: number) => Effect.succeed(n > 3)

const program = Effect.gen(function*() {
  const result = yield* Effect.dropUntil(numbers, predicate)
  console.log(result)
})

Effect.runFork(program)
// Output: [5, 6]

----------------------------------------

TITLE: Using Stream.mapEffect with Random Effects in TypeScript
DESCRIPTION: Demonstrates how to use Stream.mapEffect to transform a stream of numbers using random number generation. The example creates a stream of numbers and maps each value to a random number between 0 and that value.

LANGUAGE: typescript
CODE:
import { Effect, Random, Stream } from "effect"

const stream = Stream.make(10, 20, 30).pipe(
  Stream.mapEffect((n) => Random.nextIntBetween(0, n))
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// Example Output: { _id: 'Chunk', values: [ 7, 19, 8 ] }

----------------------------------------

TITLE: Repeating Stream Values with Schedule - TypeScript Effect Library
DESCRIPTION: Demonstrates how to create an infinite stream that repeats a single value using Stream.repeat and Schedule.forever. The example shows collecting 5 iterations of the repeated value.

LANGUAGE: typescript
CODE:
import { Effect, Schedule, Stream } from "effect"

const stream = Stream.repeat(Stream.succeed(1), Schedule.forever)

Effect.runPromise(Stream.runCollect(stream.pipe(Stream.take(5)))).then(console.log)
// { _id: 'Chunk', values: [ 1, 1, 1, 1, 1 ] }

----------------------------------------

TITLE: Creating a Failed Effect using Effect.fail in TypeScript
DESCRIPTION: This snippet demonstrates how to create an Effect that represents a recoverable error using the Effect.fail function. It creates a failure Effect with a network error message.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

//      ┌─── Effect<never, Error, never>
//      ▼
const failure = Effect.fail(
  new Error("Operation failed due to network error")
)

----------------------------------------

TITLE: Grouping Array Elements by Key in TypeScript
DESCRIPTION: Demonstrates how to use Array.groupBy to split an array of objects into groups based on a common property. The function takes an iterable and a key-generating function, returning an object with arrays grouped by the generated keys.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const people = [
  { name: "Alice", group: "A" },
  { name: "Bob", group: "B" },
  { name: "Charlie", group: "A" }
]

const result = Array.groupBy(people, person => person.group)
console.log(result)
// {
//  A: [{ name: "Alice", group: "A" }, { name: "Charlie", group: "A" }],
//  B: [{ name: "Bob", group: "B" }]
// }

----------------------------------------

TITLE: Handling Interruption with AbortSignal in Effect.async
DESCRIPTION: Illustrates how to use Effect.async with an AbortSignal to handle interruption in a long-running task. The example shows how to set up a listener for the abort signal and clean up resources when interrupted.

LANGUAGE: typescript
CODE:
import { Effect, Fiber } from "effect"

// A task that supports interruption using AbortSignal
const interruptibleTask = Effect.async<void, Error>((resume, signal) => {
  // Handle interruption
  signal.addEventListener("abort", () => {
    console.log("Abort signal received")
    clearTimeout(timeoutId)
  })

  // Simulate a long-running task
  const timeoutId = setTimeout(() => {
    console.log("Operation completed")
    resume(Effect.void)
  }, 2000)
})

const program = Effect.gen(function* () {
  const fiber = yield* Effect.fork(interruptibleTask)
  // Simulate interrupting the fiber after 1 second
  yield* Effect.sleep("1 second")
  yield* Fiber.interrupt(fiber)
})

// Run the program
Effect.runPromise(program)
// Output:
// Abort signal received

----------------------------------------

TITLE: Effect.catchAll Function Signature in TypeScript
DESCRIPTION: Provides the type signature for the Effect.catchAll function, showing its polymorphic nature and how it can be used with different effect types.

LANGUAGE: typescript
CODE:
declare const catchAll: { <E, A2, E2, R2>(f: (e: E) => Effect<A2, E2, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, f: (e: E) => Effect<A2, E2, R2>): Effect<A2 | A, E2, R2 | R>; }

----------------------------------------

TITLE: Using withLogSpan for Performance Tracking in Effect
DESCRIPTION: Demonstrates how to wrap an Effect operation with a log span to track and log its execution duration. The example shows a program that sleeps for 1 second, logs a message, and includes timing information in the output.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

const program = Effect.gen(function*() {
  yield* Effect.sleep("1 second")
  yield* Effect.log("The job is finished!")
}).pipe(Effect.withLogSpan("myspan"))

Effect.runFork(program)
// timestamp=... level=INFO fiber=#0 message="The job is finished!" myspan=1011ms

----------------------------------------

TITLE: Resource Management with Effect.using in TypeScript
DESCRIPTION: Demonstrates how to use Effect.using to manage resource lifecycle, including acquisition, usage, and automatic cleanup. The example shows logging resource lifecycle events and proper resource cleanup regardless of operation outcome.

LANGUAGE: typescript
CODE:
import { Console, Effect } from "effect"

const acquire = Console.log("Acquiring resource").pipe(
  Effect.as(1),
  Effect.tap(Effect.addFinalizer(() => Console.log("Releasing resource")))
)
const use = (resource: number) => Console.log(`Using resource: ${resource}`)

const program = acquire.pipe(Effect.using(use))

Effect.runFork(program)
// Output:
// Acquiring resource
// Using resource: 1
// Releasing resource

LANGUAGE: typescript
CODE:
declare const using: { <A, A2, E2, R2>(use: (a: A) => Effect<A2, E2, R2>): <E, R>(self: Effect<A, E, R>) => Effect<A2, E2 | E, R2 | Exclude<R, Scope.Scope>>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, use: (a: A) => Effect<A2, E2, R2>): Effect<A2, E | E2, R2 | Exclude<R, Scope.Scope>>; }

----------------------------------------

TITLE: Initializing ScopedCache with TypeScript in Effect Library
DESCRIPTION: Constructs a new cache instance with configurable capacity, time-to-live duration, and lookup function. The cache is scoped and requires environment and scope parameters. Returns an Effect that manages the cache lifecycle.

LANGUAGE: typescript
CODE:
declare const make: <Key, Value, Error = never, Environment = never>(options: { readonly lookup: Lookup<Key, Value, Error, Environment>; readonly capacity: number; readonly timeToLive: Duration.DurationInput; }) => Effect.Effect<ScopedCache<Key, Value, Error>, never, Scope.Scope | Environment>

----------------------------------------

TITLE: Implementing Credit-Based Rate Limiting with RateLimiter.withCost in TypeScript
DESCRIPTION: Demonstrates how to use RateLimiter.withCost to implement credit-based rate limiting for different API endpoints. It creates a rate limiter with an hourly limit of 1000 credits, then applies different costs to query and mutation operations.

LANGUAGE: typescript
CODE:
import { Effect, RateLimiter } from "effect";
import { compose } from "effect/Function";

const program = Effect.scoped(
  Effect.gen(function* ($) {
    // Create a rate limiter that has an hourly limit of 1000 credits
    const rateLimiter = yield* $(RateLimiter.make({ limit: 1000, interval: "1 hours" }));
    // Query API costs 1 credit per call ( 1 is the default cost )
    const queryAPIRL = compose(rateLimiter, RateLimiter.withCost(1));
    // Mutation API costs 5 credits per call
    const mutationAPIRL = compose(rateLimiter, RateLimiter.withCost(5));

    // Use the pre-defined rate limiters
    yield* $(queryAPIRL(Effect.log("Sample Query")));
    yield* $(mutationAPIRL(Effect.log("Sample Mutation")));

    // Or set a cost on-the-fly
    yield* $(
      rateLimiter(Effect.log("Another query with a different cost")).pipe(
        RateLimiter.withCost(3)
      )
    );
  })
);

----------------------------------------

TITLE: Effect.ensuring Function Signature in TypeScript
DESCRIPTION: This snippet shows the TypeScript signature of the Effect.ensuring function. It demonstrates the function's overloads and type parameters, illustrating how it can be used with different effect types.

LANGUAGE: typescript
CODE:
declare const ensuring: { <X, R1>(finalizer: Effect<X, never, R1>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R1 | R>; <A, E, R, X, R1>(self: Effect<A, E, R>, finalizer: Effect<X, never, R1>): Effect<A, E, R1 | R>; }

----------------------------------------

TITLE: Implementing Stream.mapConcatChunkEffect in TypeScript
DESCRIPTION: Function that effectfully maps stream elements to chunks and flattens them. It takes a mapping function that produces Effect-wrapped Chunks and returns a new Stream with transformed elements. Supports both curried and uncurried calling styles.

LANGUAGE: typescript
CODE:
declare const mapConcatChunkEffect: {
  <A, A2, E2, R2>(f: (a: A) => Effect.Effect<Chunk.Chunk<A2>, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>;
  <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, f: (a: A) => Effect.Effect<Chunk.Chunk<A2>, E2, R2>): Stream<A2, E | E2, R | R2>;
}

----------------------------------------

TITLE: Implementing dropWhile Operation for Effect-TS Stream
DESCRIPTION: Defines a dropWhile function that removes elements from the beginning of a stream while they satisfy a given predicate. The function supports both curried and uncurried versions, operating on Stream<A, E, R> type.

LANGUAGE: typescript
CODE:
declare const dropWhile: { <A>(predicate: Predicate<NoInfer<A>>): <E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, predicate: Predicate<A>): Stream<A, E, R>; }

----------------------------------------

TITLE: Creating Infinite Stream with Stream.iterate in TypeScript
DESCRIPTION: Demonstrates how to create an infinite stream of numbers using Stream.iterate. The example shows creating a stream starting from 1 and incrementing each value, then taking the first 10 elements.

LANGUAGE: typescript
CODE:
import { Effect, Stream } from "effect"

// An infinite Stream of numbers starting from 1 and incrementing
const stream = Stream.iterate(1, (n) => n + 1)

Effect.runPromise(Stream.runCollect(stream.pipe(Stream.take(10)))).then(console.log)
// { _id: 'Chunk', values: [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 ] }

----------------------------------------

TITLE: Type Signature for Stream.fromEffect in TypeScript
DESCRIPTION: Provides the type signature for the fromEffect function in the Stream module. It takes an Effect as input and returns a Stream.

LANGUAGE: typescript
CODE:
declare const fromEffect: <A, E, R>(effect: Effect.Effect<A, E, R>) => Stream<A, E, R>

----------------------------------------

TITLE: Implementing Stream Cleanup with onDone in TypeScript
DESCRIPTION: Defines the onDone function that executes a cleanup effect when a stream terminates. The function is overloaded to support both curried and uncurried forms, allowing for flexible stream cleanup handling.

LANGUAGE: typescript
CODE:
declare const onDone: { <X, R2>(cleanup: () => Effect.Effect<X, never, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R2 | R>; <A, E, R, X, R2>(self: Stream<A, E, R>, cleanup: () => Effect.Effect<X, never, R2>): Stream<A, E, R | R2>; }

----------------------------------------

TITLE: Transforming Option Values with map in TypeScript
DESCRIPTION: Demonstrates how to use Option.map to transform values inside Some options and handle None cases. It shows examples of mapping over both Some and None values.

LANGUAGE: typescript
CODE:
import { Option } from "effect"

// Mapping over a `Some`
const someValue = Option.some(2)

console.log(Option.map(someValue, (n) => n * 2))
// Output: { _id: 'Option', _tag: 'Some', value: 4 }

// Mapping over a `None`
const noneValue = Option.none<number>()

console.log(Option.map(noneValue, (n) => n * 2))
// Output: { _id: 'Option', _tag: 'None' }

----------------------------------------

TITLE: Inserting Elements Between Stream Values using Stream.intersperse
DESCRIPTION: Demonstrates how to use Stream.intersperse to insert a specified element between each value in a stream. The example shows inserting 0 between numbers 1-5, resulting in a new stream with the separator element between original values.

LANGUAGE: typescript
CODE:
import { Effect, Stream } from "effect"

const stream = Stream.make(1, 2, 3, 4, 5).pipe(Stream.intersperse(0))

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// {
//   _id: 'Chunk',
//   values: [
//     1, 0, 2, 0, 3,
//     0, 4, 0, 5
//   ]
// }

LANGUAGE: typescript
CODE:
declare const intersperse: { <A2>(element: A2): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E, R>; <A, E, R, A2>(self: Stream<A, E, R>, element: A2): Stream<A | A2, E, R>; }

----------------------------------------

TITLE: Implementing Error Recovery in Layers with catchAll in TypeScript
DESCRIPTION: The catchAll function recovers from all errors in a Layer. It takes an error handler function and returns a new Layer that combines the original Layer with the error recovery logic.

LANGUAGE: typescript
CODE:
declare const catchAll: {
  <E, RIn2, E2, ROut2>(onError: (error: E) => Layer<ROut2, E2, RIn2>):
    <RIn, ROut>(self: Layer<ROut, E, RIn>) => Layer<ROut & ROut2, E2, RIn2 | RIn>;
  <RIn, E, ROut, RIn2, E2, ROut2>(
    self: Layer<ROut, E, RIn>,
    onError: (error: E) => Layer<ROut2, E2, RIn2>
  ): Layer<ROut & ROut2, E2, RIn | RIn2>;
}

----------------------------------------

TITLE: Combining Effects in Tuples - TypeScript Effect Library
DESCRIPTION: Demonstrates how to combine multiple effects in a tuple structure and execute them sequentially, returning results in a matching tuple order.

LANGUAGE: typescript
CODE:
import { Effect, Console } from "effect"

const tupleOfEffects = [
  Effect.succeed(42).pipe(Effect.tap(Console.log)),
  Effect.succeed("Hello").pipe(Effect.tap(Console.log))
] as const

const resultsAsTuple = Effect.all(tupleOfEffects)

Effect.runPromise(resultsAsTuple).then(console.log)

----------------------------------------

TITLE: Retrying Effect with Fixed Delay in TypeScript
DESCRIPTION: Demonstrates retrying a failing effect using a fixed delay schedule. The example simulates a task that fails 3 times before succeeding, with a 100ms delay between retries.

LANGUAGE: typescript
CODE:
import { Effect, Schedule } from "effect"

let count = 0

// Simulates an effect with possible failures
const task = Effect.async<string, Error>((resume) => {
  if (count <= 2) {
    count++
    console.log("failure")
    resume(Effect.fail(new Error()))
  } else {
    console.log("success")
    resume(Effect.succeed("yay!"))
  }
})

// Define a repetition policy using a fixed delay between retries
const policy = Schedule.fixed("100 millis")

const repeated = Effect.retry(task, policy)

Effect.runPromise(repeated).then(console.log)

----------------------------------------

TITLE: Using Effect.option to Handle Errors in TypeScript
DESCRIPTION: This example demonstrates how to use Effect.option to handle both successful and failed effects, wrapping the results in Option types. It also shows how unrecoverable errors (defects) are handled.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

const maybe1 = Effect.option(Effect.succeed(1))

Effect.runPromiseExit(maybe1).then(console.log)
// Output:
// {
//   _id: 'Exit',
//   _tag: 'Success',
//   value: { _id: 'Option', _tag: 'Some', value: 1 }
// }

const maybe2 = Effect.option(Effect.fail("Uh oh!"))

Effect.runPromiseExit(maybe2).then(console.log)
// Output:
// {
//   _id: 'Exit',
//   _tag: 'Success',
//   value: { _id: 'Option', _tag: 'None' }
// }

const maybe3 = Effect.option(Effect.die("Boom!"))

Effect.runPromiseExit(maybe3).then(console.log)
// Output:
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: { _id: 'Cause', _tag: 'Die', defect: 'Boom!' }
// }

----------------------------------------

TITLE: Implementing Custom Timeout Handling with Effect.timeoutFailCause in TypeScript
DESCRIPTION: This example demonstrates how to use Effect.timeoutFailCause to specify a custom defect when a timeout occurs. It creates a task that simulates a delay, then wraps it with a timeout that fails with a custom cause if the task doesn't complete within 1 second.

LANGUAGE: typescript
CODE:
import { Effect, Cause } from "effect"

const task = Effect.gen(function* () {
  console.log("Start processing...")
  yield* Effect.sleep("2 seconds") // Simulates a delay in processing
  console.log("Processing complete.")
  return "Result"
})

const program = task.pipe(
  Effect.timeoutFailCause({
    duration: "1 second",
    onTimeout: () => Cause.die("Timed out!") // Custom defect for timeout
  })
)

Effect.runPromiseExit(program).then(console.log)
// Output:
// Start processing...
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: { _id: 'Cause', _tag: 'Die', defect: 'Timed out!' }
// }

----------------------------------------

TITLE: Executing Synchronous Effects in TypeScript
DESCRIPTION: The runSync function executes an effect synchronously, returning the result directly. It is suitable for effects that do not fail or include asynchronous operations. The function will throw an error if the effect fails or involves async tasks.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

const program = Effect.sync(() => {
  console.log("Hello, World!")
  return 1
})

const result = Effect.runSync(program)
// Output: Hello, World!

console.log(result)
// Output: 1

----------------------------------------

TITLE: Constructing RequestResolver with make Function in TypeScript
DESCRIPTION: The make function constructs a data source with a specified identifier and method to run requests. It takes a runAll function as a parameter, which processes an array of request arrays and returns an Effect.

LANGUAGE: typescript
CODE:
declare const make: <A, R>(runAll: (requests: Array<Array<A>>) => Effect.Effect<void, never, R>) => RequestResolver<A, R>

----------------------------------------

TITLE: Retrying Effect with Conditional Stop in TypeScript
DESCRIPTION: Demonstrates retrying an effect until a specific condition is met. The example retries until a specific error message is encountered.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

let count = 0

// Define an effect that simulates varying error on each invocation
const action = Effect.failSync(() => {
  console.log(`Action called ${++count} time(s)`)
  return `Error ${count}`
})

// Retry the action until a specific condition is met
const program = Effect.retry(action, {
  until: (err) => err === "Error 3"
})

Effect.runPromiseExit(program).then(console.log)

----------------------------------------

TITLE: Demonstrating Stream Binding in Effect
DESCRIPTION: This example shows how to use Stream.Do, Stream.bind, and Stream.let to create a stream that combines multiple values. It demonstrates binding variables to Stream values and performing operations on them.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Chunk, Effect, pipe, Stream } from "effect"

const result = pipe(
  Stream.Do,
  Stream.bind("x", () => Stream.succeed(2)),
  Stream.bind("y", () => Stream.succeed(3)),
  Stream.let("sum", ({ x, y }) => x + y)
)
assert.deepStrictEqual(Effect.runSync(Stream.runCollect(result)), Chunk.of({ x: 2, y: 3, sum: 5 }))

----------------------------------------

TITLE: Creating Semaphore in Effect TypeScript
DESCRIPTION: Example showing how to create a semaphore with 3 permits using the Effect.makeSemaphore function. The semaphore can be used to control concurrent access to shared resources.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

// Create a semaphore with 3 permits
const mutex = Effect.makeSemaphore(3)

LANGUAGE: typescript
CODE:
declare const makeSemaphore: (permits: number) => Effect<Semaphore>

----------------------------------------

TITLE: Creating a Service Tag with Effect.Tag in TypeScript
DESCRIPTION: This snippet demonstrates how to use Effect.Tag to create a unique tag for a Notifications service. It shows how to define the service structure and create an effect that depends on this service.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

class Notifications extends Effect.Tag("Notifications")<
  Notifications,
  { readonly notify: (message: string) => Effect.Effect<void> }
>() {}

// Create an effect that depends on the Notifications service
const action = Notifications.notify("Hello, world!")

----------------------------------------

TITLE: Mapping Record Values with Effect/Record
DESCRIPTION: Demonstrates how to transform a record's values using the map function from Effect's Record module. Shows both simple value transformation and transformation using the key name. The function supports both curried and non-curried usage patterns.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { map } from "effect/Record"

const f = (n: number) => `-${n}`

assert.deepStrictEqual(map({ a: 3, b: 5 }, f), { a: "-3", b: "-5" })

const g = (n: number, key: string) => `${key.toUpperCase()}-${n}`

assert.deepStrictEqual(map({ a: 3, b: 5 }, g), { a: "A-3", b: "B-5" })

LANGUAGE: typescript
CODE:
declare const map: { <K extends string, A, B>(f: (a: A, key: NoInfer<K>) => B): (self: ReadonlyRecord<K, A>) => Record<K, B>; <K extends string, A, B>(self: ReadonlyRecord<K, A>, f: (a: A, key: NoInfer<K>) => B): Record<K, B>; }

----------------------------------------

TITLE: Executing Synchronous Effects in TypeScript
DESCRIPTION: The runSync function executes an effect synchronously, returning the result directly. It is suitable for effects that do not fail or include asynchronous operations. The function will throw an error if the effect fails or involves async tasks.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

const program = Effect.sync(() => {
  console.log("Hello, World!")
  return 1
})

const result = Effect.runSync(program)
// Output: Hello, World!

console.log(result)
// Output: 1

----------------------------------------

TITLE: Running a Finalizer in All Outcomes with Effect.ensuring in TypeScript
DESCRIPTION: This snippet demonstrates how to use Effect.ensuring to guarantee the execution of a finalizer in various scenarios: successful completion, failure, and interruption. It shows how the cleanup effect is always executed regardless of the outcome.

LANGUAGE: typescript
CODE:
import { Console, Effect } from "effect"

// Define a cleanup effect
const handler = Effect.ensuring(Console.log("Cleanup completed"))

// Define a successful effect
const success = Console.log("Task completed").pipe(
  Effect.as("some result"),
  handler
)

Effect.runFork(success)
// Output:
// Task completed
// Cleanup completed

// Define a failing effect
const failure = Console.log("Task failed").pipe(
  Effect.andThen(Effect.fail("some error")),
  handler
)

Effect.runFork(failure)
// Output:
// Task failed
// Cleanup completed

// Define an interrupted effect
const interruption = Console.log("Task interrupted").pipe(
  Effect.andThen(Effect.interrupt),
  handler
)

Effect.runFork(interruption)
// Output:
// Task interrupted
// Cleanup completed

----------------------------------------

TITLE: Using Effect.exists with Array Predicate in TypeScript
DESCRIPTION: Example demonstrating how to use Effect.exists to check if any number in an array is greater than 2. The function processes elements with an effectual predicate and returns a boolean result.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

const numbers = [1, 2, 3, 4]
const predicate = (n: number, i: number) => Effect.succeed(n > 2)

const program = Effect.gen(function*() {
  const hasLargeNumber = yield* Effect.exists(numbers, predicate)
  console.log(hasLargeNumber)
})

Effect.runFork(program)
// Output: true

----------------------------------------

TITLE: Effect.provide Type Signature
DESCRIPTION: Type signature showing the various overloads of Effect.provide for handling different types of dependency injection including layers, contexts, runtimes, and managed runtimes.

LANGUAGE: typescript
CODE:
declare const provide: { <const Layers extends [Layer.Layer.Any, ...Array<Layer.Layer.Any>]>(layers: Layers): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E | { [k in keyof Layers]: Layer.Layer.Error<Layers[k]>; }[number], { [k in keyof Layers]: Layer.Layer.Context<Layers[k]>; }[number] | Exclude<R, { [k in keyof Layers]: Layer.Layer.Success<Layers[k]>; }[number]>>; <ROut, E2, RIn>(layer: Layer.Layer<ROut, E2, RIn>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E | E2, RIn | Exclude<R, ROut>>; <R2>(context: Context.Context<R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, Exclude<R, R2>>; <R2>(runtime: Runtime.Runtime<R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, Exclude<R, R2>>; <E2, R2>(managedRuntime: ManagedRuntime.ManagedRuntime<R2, E2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E | E2, Exclude<R, R2>>; <A, E, R, const Layers extends [Layer.Layer.Any, ...Array<Layer.Layer.Any>]>(self: Effect<A, E, R>, layers: Layers): Effect<A, E | { [k in keyof Layers]: Layer.Layer.Error<Layers[k]>; }[number], { [k in keyof Layers]: Layer.Layer.Context<Layers[k]>; }[number] | Exclude<R, { [k in keyof Layers]: Layer.Layer.Success<Layers[k]>; }[number]>>; <A, E, R, ROut, E2, RIn>(self: Effect<A, E, R>, layer: Layer.Layer<ROut, E2, RIn>): Effect<A, E | E2, RIn | Exclude<R, ROut>>; <A, E, R, R2>(self: Effect<A, E, R>, context: Context.Context<R2>): Effect<A, E, Exclude<R, R2>>; <A, E, R, R2>(self: Effect<A, E, R>, runtime: Runtime.Runtime<R2>): Effect<A, E, Exclude<R, R2>>; <A, E, E2, R, R2>(self: Effect<A, E, R>, runtime: ManagedRuntime.ManagedRuntime<R2, E2>): Effect<A, E | E2, Exclude<R, R2>>; }

----------------------------------------

TITLE: Creating Traced Function with Span Name in TypeScript
DESCRIPTION: Demonstrates creating a traced function with a named span that includes error handling and span annotation. The function takes a numeric parameter, logs it, and simulates a failure with error tracking.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

const myfunc = Effect.fn("myspan")(function* <N extends number>(n: N) {
  yield* Effect.annotateCurrentSpan("n", n) // Attach metadata to the span
  console.log(`got: ${n}`)
  yield* Effect.fail(new Error("Boom!")) // Simulate failure
})

Effect.runFork(myfunc(100).pipe(Effect.catchAllCause(Effect.logError)))

----------------------------------------

TITLE: Racing Streams in TypeScript using effect Package
DESCRIPTION: Demonstrates how to use Stream.race to create a stream that mirrors the first upstream to emit an item. It showcases racing two streams with different schedules and taking the first 6 items.

LANGUAGE: typescript
CODE:
import { Stream, Schedule, Console, Effect } from "effect"

const stream = Stream.fromSchedule(Schedule.spaced('2 millis')).pipe(
  Stream.race(Stream.fromSchedule(Schedule.spaced('1 millis'))),
  Stream.take(6),
  Stream.tap(Console.log)
)

Effect.runPromise(Stream.runDrain(stream))
// Output each millisecond from the first stream, the rest streams are interrupted
// 0
// 1
// 2
// 3
// 4
// 5

----------------------------------------

TITLE: Constructing Service Layer in Effect Framework TypeScript
DESCRIPTION: Defines a function that creates a layer to access and return a specified service from the context. The layer takes a context tag as input and returns a Layer type that can access the service.

LANGUAGE: typescript
CODE:
declare const service: <I, S>(tag: Context.Tag<I, S>) => Layer<I, never, I>

----------------------------------------

TITLE: Using FiberMap.runtime with Effect
DESCRIPTION: Demonstrates how to capture a Runtime and use it to fork Effects, adding them to a FiberMap. The example shows creating a FiberMap, obtaining a runtime, and running multiple effects with unique keys. The fibers are automatically interrupted when the scope closes.

LANGUAGE: typescript
CODE:
import { Context, Effect, FiberMap } from "effect"

interface Users {
  readonly _: unique symbol
}
const Users = Context.GenericTag<Users, {
   getAll: Effect.Effect<Array<unknown>>
}>("Users")

Effect.gen(function*() {
  const map = yield* FiberMap.make<string>()
  const run = yield* FiberMap.runtime(map)<Users>()

  // run some effects and add the fibers to the map
  run("effect-a", Effect.andThen(Users, _ => _.getAll))
  run("effect-b", Effect.andThen(Users, _ => _.getAll))
}).pipe(
  Effect.scoped // The fibers will be interrupted when the scope is closed
)

----------------------------------------

TITLE: Using Effect.sleep for Delayed Execution in TypeScript
DESCRIPTION: Demonstrates how to use Effect.sleep to pause execution for a specified duration. The example shows logging messages before and after a 3-second sleep interval.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

const program = Effect.gen(function*() {
  console.log("Starting task...")
  yield* Effect.sleep("3 seconds") // Waits for 3 seconds
  console.log("Task completed!")
})

Effect.runFork(program)
// Output:
// Starting task...
// Task completed!

----------------------------------------

TITLE: Implementing Stream Interruption in TypeScript using Effect Library
DESCRIPTION: Defines an interruptWhen function that takes an effect and returns a function to interrupt a stream when the effect completes. The function handles both success and failure cases, with failures from the interrupting effect being propagated through the resulting stream.

LANGUAGE: typescript
CODE:
declare const interruptWhen: {
  <X, E2, R2>(effect: Effect.Effect<X, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>;
  <A, E, R, X, E2, R2>(self: Stream<A, E, R>, effect: Effect.Effect<X, E2, R2>): Stream<A, E | E2, R | R2>;
}

----------------------------------------

TITLE: Creating Cache Instance with Effect-TS
DESCRIPTION: Function signature for creating a new cache with configurable capacity, time-to-live duration, and lookup function. The cache supports generic key-value pairs with optional error handling and environment configuration.

LANGUAGE: typescript
CODE:
declare const make: <Key, Value, Error = never, Environment = never>(options: { readonly capacity: number; readonly timeToLive: Duration.DurationInput; readonly lookup: Lookup<Key, Value, Error, Environment>; }) => Effect.Effect<Cache<Key, Value, Error>, never, Environment>

----------------------------------------

TITLE: Conditional Effect Execution with Effect.when in TypeScript
DESCRIPTION: Demonstrates how to use Effect.when to conditionally execute an effect based on a boolean condition. The example validates a weight value, returning Some(weight) if non-negative, or None otherwise.

LANGUAGE: typescript
CODE:
import { Effect, Option } from "effect"

const validateWeightOption = (
  weight: number
): Effect.Effect<Option.Option<number>> =>
  // Conditionally execute the effect if the weight is non-negative
  Effect.succeed(weight).pipe(Effect.when(() => weight >= 0))

// Run with a valid weight
Effect.runPromise(validateWeightOption(100)).then(console.log)
// Output:
// {
//   _id: "Option",
//   _tag: "Some",
//   value: 100
// }

// Run with an invalid weight
Effect.runPromise(validateWeightOption(-5)).then(console.log)
// Output:
// {
//   _id: "Option",
//   _tag: "None"
// }

----------------------------------------

TITLE: Defining HttpApiGroup Interface in TypeScript
DESCRIPTION: A TypeScript interface definition for HttpApiGroup that enables grouping of HTTP API endpoints with shared error handling, middleware, and annotations. The interface includes methods for adding endpoints, error schemas, path prefixes, middleware, and annotations.

LANGUAGE: typescript
CODE:
export interface HttpApiGroup<
  out Id extends string,
  out Endpoints extends HttpApiEndpoint.HttpApiEndpoint.Any = never,
  in out Error = HttpApiDecodeError,
  out R = never,
  out TopLevel extends (true | false) = false
> extends Pipeable {
  new(_: never): {}
  readonly [TypeId]: TypeId
  readonly identifier: Id
  readonly topLevel: TopLevel
  readonly endpoints: Record.ReadonlyRecord<string, Endpoints>
  readonly errorSchema: Schema.Schema<Error, unknown, R>
  readonly annotations: Context.Context<never>
  readonly middlewares: ReadonlySet<HttpApiMiddleware.TagClassAny>

  add<A extends HttpApiEndpoint.HttpApiEndpoint.Any>(
    endpoint: A
  ): HttpApiGroup<Id, Endpoints | A, Error, R, TopLevel>

  addError<A, I, RX>(
    schema: Schema.Schema<A, I, RX>,
    annotations?: {
      readonly status?: number | undefined
    }
  ): HttpApiGroup<Id, Endpoints, Error | A, R | RX, TopLevel>

  prefix(prefix: HttpApiEndpoint.PathSegment): HttpApiGroup<Id, Endpoints, Error, R, TopLevel>

  middleware<I extends HttpApiMiddleware.HttpApiMiddleware.AnyId, S>(middleware: Context.Tag<I, S>): HttpApiGroup<
    Id,
    Endpoints,
    Error | HttpApiMiddleware.HttpApiMiddleware.Error<I>,
    R | I | HttpApiMiddleware.HttpApiMiddleware.ErrorContext<I>,
    TopLevel
  >

  middlewareEndpoints<I extends HttpApiMiddleware.HttpApiMiddleware.AnyId, S>(
    middleware: Context.Tag<I, S>
  ): HttpApiGroup<
    Id,
    HttpApiEndpoint.HttpApiEndpoint.AddContext<Endpoints, I>,
    Error,
    R,
    TopLevel
  >

  annotateContext<I>(context: Context.Context<I>): HttpApiGroup<Id, Endpoints, Error, R, TopLevel>

  annotate<I, S>(tag: Context.Tag<I, S>, value: S): HttpApiGroup<Id, Endpoints, Error, R, TopLevel>

  annotateEndpointsContext<I>(context: Context.Context<I>): HttpApiGroup<Id, Endpoints, Error, R, TopLevel>

  annotateEndpoints<I, S>(tag: Context.Tag<I, S>, value: S): HttpApiGroup<Id, Endpoints, Error, R, TopLevel>
}

----------------------------------------

TITLE: Using Array.findFirstIndex in TypeScript
DESCRIPTION: Demonstrates how to use the Array.findFirstIndex function to find the index of the first element in an array that satisfies a given condition. The function returns an Option type containing the index if found.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const result = Array.findFirstIndex([5, 3, 8, 9], x => x > 5)
console.log(result) // Option.some(2)

----------------------------------------

TITLE: Logging Messages and Error Causes with Effect.log in TypeScript
DESCRIPTION: Demonstrates how to use Effect.log to log messages and error causes. The function logs multiple items including strings and Cause instances at the INFO level, providing metadata like timestamp and fiber ID.

LANGUAGE: typescript
CODE:
import { Cause, Effect } from "effect"

const program = Effect.log(
  "message1",
  "message2",
  Cause.die("Oh no!"),
  Cause.die("Oh uh!")
)

Effect.runFork(program)
// Output:
// timestamp=... level=INFO fiber=#0 message=message1 message=message2 cause="Error: Oh no!
// Error: Oh uh!"

----------------------------------------

TITLE: Running Successful Effect as Promise in TypeScript
DESCRIPTION: Demonstrates how to execute a successful Effect and handle its result using Promise then() chain. The effect wraps a successful value that resolves through the promise.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

Effect.runPromise(Effect.succeed(1)).then(console.log)
// Output: 1

----------------------------------------

TITLE: Effect.log Function Signature in TypeScript
DESCRIPTION: Provides the TypeScript type signature for the Effect.log function. It accepts any number of arguments and returns an Effect that never fails and has no requirements.

LANGUAGE: typescript
CODE:
declare const log: (...message: ReadonlyArray<any>) => Effect<void, never, never>

----------------------------------------

TITLE: Enqueuing Stream Elements into Queue in TypeScript
DESCRIPTION: The runIntoQueue function enqueues elements of a stream into a queue. It also handles stream failure and ending signals. The function has two overloads: one that takes the queue as the first argument and returns a function that takes the stream, and another that takes both the stream and queue as arguments.

LANGUAGE: typescript
CODE:
declare const runIntoQueue: { <A, E>(queue: Queue.Enqueue<Take.Take<A, E>>): <R>(self: Stream<A, E, R>) => Effect.Effect<void, never, R>; <A, E, R>(self: Stream<A, E, R>, queue: Queue.Enqueue<Take.Take<A, E>>): Effect.Effect<void, never, R>; }

----------------------------------------

TITLE: TypeScript Function Signature for Effect.fork
DESCRIPTION: Provides the TypeScript function signature for the Effect.fork function. It shows the input parameters and return type, indicating that it takes an Effect and returns a new Effect containing a RuntimeFiber.

LANGUAGE: typescript
CODE:
declare const fork: <A, E, R>(self: Effect<A, E, R>) => Effect<Fiber.RuntimeFiber<A, E>, never, R>

----------------------------------------

TITLE: Defining Stream Interface in TypeScript
DESCRIPTION: Defines the core Stream interface with generic type parameters for values (A), errors (E), and context (R). The interface extends Stream.Variance and Pipeable, and includes type symbols for unification and type checking.

LANGUAGE: typescript
CODE:
export interface Stream<out A, out E = never, out R = never> extends Stream.Variance<A, E, R>, Pipeable {
  [Unify.typeSymbol]?: unknown
  [Unify.unifySymbol]?: StreamUnify<this>
  [Unify.ignoreSymbol]?: StreamUnifyIgnore
}

----------------------------------------

TITLE: Effect.runSyncExit Function Signature in TypeScript
DESCRIPTION: Provides the TypeScript signature for the Effect.runSyncExit function, showing its input and output types.

LANGUAGE: typescript
CODE:
declare const runSyncExit: <A, E>(effect: Effect<A, E>) => Exit.Exit<A, E>

----------------------------------------

TITLE: Implementing Structured Logging with Effect Logger
DESCRIPTION: Demonstrates how to use the structured logger to create detailed, annotated log outputs with spans and custom annotations. The logger produces JSON-structured output containing message content, log level, timestamp, annotations, spans, and fiber ID.

LANGUAGE: typescript
CODE:
import { Effect, Logger } from "effect"

const program = Effect.log("message1", "message2").pipe(
  Effect.annotateLogs({ key1: "value1", key2: "value2" }),
  Effect.withLogSpan("myspan")
)

Effect.runFork(program.pipe(Effect.provide(Logger.structured)))
// {
//   message: [ 'message1', 'message2' ],
//   logLevel: 'INFO',
//   timestamp: '2024-07-09T14:05:41.623Z',
//   cause: undefined,
//   annotations: { key2: 'value2', key1: 'value1' },
//   spans: { myspan: 0 },
//   fiberId: '#0'
// }

LANGUAGE: typescript
CODE:
declare const structured: Layer.Layer<never, never, never>

----------------------------------------

TITLE: Function Signature for Effect.allSuccesses in TypeScript
DESCRIPTION: This code snippet shows the TypeScript function signature for the Effect.allSuccesses function. It details the function's parameters, including the iterable of effects and optional configuration options for concurrency, batching, and finalizer behavior.

LANGUAGE: typescript
CODE:
declare const allSuccesses: <X extends Effect<any, any, any>>(elements: Iterable<X>, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined) => Effect<Array<Effect.Success<X>>, never, Effect.Context<X>>

----------------------------------------

TITLE: Implementing Stream Broadcast with Effect
DESCRIPTION: Demonstrates how to use Stream.broadcast to create multiple streams from a single source stream with controlled backpressure. The example shows splitting a number stream into two streams with different processing patterns - one calculating maximum value and another logging values on a schedule.

LANGUAGE: typescript
CODE:
import { Console, Effect, Fiber, Schedule, Stream } from "effect"

const numbers = Effect.scoped(
  Stream.range(1, 20).pipe(
    Stream.tap((n) => Console.log(`Emit ${n} element before broadcasting`)),
    Stream.broadcast(2, 5),
    Stream.flatMap(([first, second]) =>
      Effect.gen(function*() {
        const fiber1 = yield* Stream.runFold(first, 0, (acc, e) => Math.max(acc, e)).pipe(
          Effect.andThen((max) => Console.log(`Maximum: ${max}`)),
          Effect.fork
        )
        const fiber2 = yield* second.pipe(
          Stream.schedule(Schedule.spaced("1 second")),
          Stream.runForEach((n) => Console.log(`Logging to the Console: ${n}`)),
          Effect.fork
        )
        yield* Fiber.join(fiber1).pipe(
          Effect.zip(Fiber.join(fiber2), { concurrent: true })
        )
      })
    ),
    Stream.runCollect
  )
)

Effect.runPromise(numbers).then(console.log)

----------------------------------------

TITLE: Using Effect.withEarlyRelease in TypeScript
DESCRIPTION: Demonstrates how to use Effect.withEarlyRelease to acquire a resource, use it, and then release it manually. The function returns both the resource and a finalizer for controlled cleanup.

LANGUAGE: typescript
CODE:
import { Console, Effect } from "effect"

const acquire = Console.log("Acquiring resource").pipe(
  Effect.as(1),
  Effect.tap(Effect.addFinalizer(() => Console.log("Releasing resource")))
)
const program = Effect.gen(function*() {
  const [finalizer, resource] = yield* Effect.withEarlyRelease(acquire)
  console.log(`Using resource: ${resource}`)
  yield* Effect.sleep("1 second")
  yield* finalizer
})

Effect.runFork(program.pipe(Effect.scoped))
// Output:
// Acquiring resource
// Using resource: 1
// Releasing resource

----------------------------------------

TITLE: Replacing Effect Value with Constant in TypeScript
DESCRIPTION: This example demonstrates how to use the 'as' function to replace the value 5 produced by an effect with the constant string "new value".

LANGUAGE: typescript
CODE:
import { pipe, Effect } from "effect"

// Replaces the value 5 with the constant "new value"
const program = pipe(Effect.succeed(5), Effect.as("new value"))

Effect.runPromise(program).then(console.log)
// Output: "new value"

----------------------------------------

TITLE: Filtering Options with Predicates in TypeScript
DESCRIPTION: Demonstrates how to use Option.filter to filter an Option based on a predicate. It shows examples of filtering out empty strings and handling None cases.

LANGUAGE: typescript
CODE:
import { Option } from "effect"

const removeEmptyString = (input: Option.Option<string>) =>
  Option.filter(input, (value) => value !== "")

console.log(removeEmptyString(Option.none()))
// Output: { _id: 'Option', _tag: 'None' }

console.log(removeEmptyString(Option.some("")))
// Output: { _id: 'Option', _tag: 'None' }

console.log(removeEmptyString(Option.some("a")))
// Output: { _id: 'Option', _tag: 'Some', value: 'a' }

----------------------------------------

TITLE: Implementing Array.last in TypeScript with Effect-TS
DESCRIPTION: Function implementation for retrieving the last element of a readonly array. Returns an Option type that contains the last element if the array is not empty, or None if the array is empty.

LANGUAGE: typescript
CODE:
declare const last: <A>(self: ReadonlyArray<A>) => Option.Option<A>

----------------------------------------

TITLE: Using Array.match for Empty and Non-Empty Array Handling in TypeScript
DESCRIPTION: Demonstrates how to use the Array.match function to handle empty and non-empty arrays differently. It provides a concise way to apply specific logic based on the array's content.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const match = Array.match({
  onEmpty: () => "empty",
  onNonEmpty: ([head, ...tail]) => `head: ${head}, tail: ${tail.length}`
})
console.log(match([])) // "empty"
console.log(match([1, 2, 3])) // "head: 1, tail: 2"

----------------------------------------

TITLE: Defining OpenAPI 3.1.0 Specification Interface in TypeScript
DESCRIPTION: TypeScript interface that describes the structure of OpenAPI 3.1.0 specification. It includes required fields for API information, paths, components, security requirements and tags, with optional servers configuration.

LANGUAGE: typescript
CODE:
export interface OpenAPISpec {
  openapi: "3.1.0"
  info: OpenAPISpecInfo
  paths: OpenAPISpecPaths
  components: OpenAPIComponents
  security: Array<OpenAPISecurityRequirement>
  tags: Array<OpenAPISpecTag>
  servers?: Array<OpenAPISpecServer>
}

----------------------------------------

TITLE: Fetching a TODO Item with Effect.tryPromise in TypeScript
DESCRIPTION: Demonstrates how to use Effect.tryPromise to fetch a TODO item from an API. This example catches any errors and propagates them as UnknownException.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

const getTodo = (id: number) =>
  // Will catch any errors and propagate them as UnknownException
  Effect.tryPromise(() =>
    fetch(`https://jsonplaceholder.typicode.com/todos/${id}`)
  )

//      ┌─── Effect<Response, UnknownException, never>
//      ▼
const program = getTodo(1)

----------------------------------------

TITLE: Using matchCause for Error Handling in TypeScript Effect
DESCRIPTION: Demonstrates how to use the matchCause function to handle different types of failures including standard failures, defects, and interruptions. The example shows pattern matching on different failure causes and appropriate response handling.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

const task: Effect.Effect<number, Error> = Effect.die("Uh oh!")

const program = Effect.matchCause(task, {
  onFailure: (cause) => {
    switch (cause._tag) {
      case "Fail":
        // Handle standard failure
        return `Fail: ${cause.error.message}`
      case "Die":
        // Handle defects (unexpected errors)
        return `Die: ${cause.defect}`
      case "Interrupt":
        // Handle interruption
        return `${cause.fiberId} interrupted!`
    }
    // Fallback for other causes
    return "failed due to other causes"
  },
  onSuccess: (value) =>
    // task completes successfully
    `succeeded with ${value} value`
})

Effect.runPromise(program).then(console.log)
// Output: "Die: Uh oh!"

----------------------------------------

TITLE: Converting Layer to Runtime in TypeScript
DESCRIPTION: The toRuntime function converts a layer that requires no services into a scoped runtime. This runtime can be used to execute effects. It takes a Layer as input and returns an Effect that produces a Runtime.

LANGUAGE: typescript
CODE:
declare const toRuntime: <RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Effect.Effect<Runtime.Runtime<ROut>, E, Scope.Scope | RIn>

----------------------------------------

TITLE: Defining ConfigProvider Interface in TypeScript
DESCRIPTION: Defines the core ConfigProvider interface that extends ConfigProvider.Proto and Pipeable. It provides methods for loading configuration and flattening the provider structure.

LANGUAGE: typescript
CODE:
export interface ConfigProvider extends ConfigProvider.Proto, Pipeable {
  /**
   * Loads the specified configuration, or fails with a config error.
   */
  load<A>(config: Config.Config<A>): Effect.Effect<A, ConfigError.ConfigError>
  /**
   * Flattens this config provider into a simplified config provider that knows
   * only how to deal with flat (key/value) properties.
   */
  readonly flattened: ConfigProvider.Flat
}

----------------------------------------

TITLE: Executing Command with Line Output in TypeScript
DESCRIPTION: Function that runs a command and returns the output as an array of lines with optional encoding specification. Returns an Effect type that may produce an array of strings or a PlatformError.

LANGUAGE: typescript
CODE:
declare const lines: (command: Command, encoding?: string) => Effect<Array<string>, PlatformError, CommandExecutor>

----------------------------------------

TITLE: Retrieving Optional Services with Effect.serviceOption in TypeScript
DESCRIPTION: A function that retrieves an optional service from the context and wraps it in an Option type. Returns Some(service) if found or None if not available. Takes a Context.Tag parameter and returns an Effect containing an Option of the service type.

LANGUAGE: typescript
CODE:
declare const serviceOption: <I, S>(tag: Context.Tag<I, S>) => Effect<Option.Option<S>>

----------------------------------------

TITLE: Calculating Array Union with Custom Equivalence in TypeScript
DESCRIPTION: Demonstrates how to use the Array.unionWith function to calculate the union of two arrays using a custom equivalence relation. The function takes two arrays and a comparison function, returning a new array with unique elements.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const union = Array.unionWith([1, 2], [2, 3], (a, b) => a === b)
console.log(union) // [1, 2, 3]

----------------------------------------

TITLE: Using Effect.delay for Delayed Execution in TypeScript
DESCRIPTION: Demonstrates how to delay the execution of an Effect using the delay function. The example shows logging a message after a 2-second delay while using non-blocking execution.

LANGUAGE: typescript
CODE:
import { Console, Effect } from "effect"

const task = Console.log("Task executed")

const program = Console.log("start").pipe(
  Effect.andThen(
    // Delays the log message by 2 seconds
    task.pipe(Effect.delay("2 seconds"))
  )
)

Effect.runFork(program)
// Output:
// start
// Task executed

LANGUAGE: typescript
CODE:
declare const delay: { (duration: Duration.DurationInput): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, duration: Duration.DurationInput): Effect<A, E, R>; }

----------------------------------------

TITLE: Declaring Forever Method Signature in TypeScript
DESCRIPTION: Type declaration for the forever method that takes an Effect instance and returns a new Effect that repeats indefinitely. The method transforms an Effect<A, E, R> into Effect<never, E, R>, indicating that it never completes successfully unless an error occurs.

LANGUAGE: typescript
CODE:
declare const forever: <A, E, R>(self: Effect<A, E, R>) => Effect<never, E, R>

----------------------------------------

TITLE: Using Effect.timeout to Limit Task Duration in TypeScript
DESCRIPTION: Demonstrates how to use Effect.timeout to add a time limit to an effect. The example creates a task that simulates a delay and then applies a timeout. If the task exceeds the timeout duration, it fails with a TimeoutException.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

const task = Effect.gen(function* () {
  console.log("Start processing...")
  yield* Effect.sleep("2 seconds") // Simulates a delay in processing
  console.log("Processing complete.")
  return "Result"
})

// Output will show a TimeoutException as the task takes longer
// than the specified timeout duration
const timedEffect = task.pipe(Effect.timeout("1 second"))

Effect.runPromiseExit(timedEffect).then(console.log)
// Output:
// Start processing...
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: {
//     _id: 'Cause',
//     _tag: 'Fail',
//     failure: { _tag: 'TimeoutException' }
//   }
// }

----------------------------------------

TITLE: Repeating an Effect with Potential Failure in TypeScript
DESCRIPTION: This example shows how to use Effect.repeat with an effect that may fail. The effect succeeds twice and then fails on the third attempt. The repetition stops immediately upon failure, demonstrating the behavior of Effect.repeat with failing effects.

LANGUAGE: typescript
CODE:
import { Effect, Schedule } from "effect"

let count = 0

// Define an async effect that simulates an action with possible failures
const action = Effect.async<string, string>((resume) => {
  if (count > 1) {
    console.log("failure")
    resume(Effect.fail("Uh oh!"))
  } else {
    count++
    console.log("success")
    resume(Effect.succeed("yay!"))
  }
})

const policy = Schedule.addDelay(Schedule.recurs(2), () => "100 millis")
const program = Effect.repeat(action, policy)

Effect.runPromiseExit(program).then(console.log)

----------------------------------------

TITLE: Creating a Stream with Cleanup using acquireRelease in TypeScript
DESCRIPTION: Demonstrates how to use Stream.acquireRelease to create a stream from a file-like object, process its contents, and ensure proper cleanup. The example simulates file operations with opening, reading lines, and closing.

LANGUAGE: typescript
CODE:
import { Console, Effect, Stream } from "effect"

// Simulating File operations
const open = (filename: string) =>
  Effect.gen(function*() {
    yield* Console.log(`Opening ${filename}`)
    return {
      getLines: Effect.succeed(["Line 1", "Line 2", "Line 3"]),
      close: Console.log(`Closing ${filename}`)
    }
  })

const stream = Stream.acquireRelease(
  open("file.txt"),
  (file) => file.close
).pipe(Stream.flatMap((file) => file.getLines))

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// Opening file.txt
// Closing file.txt
// { _id: 'Chunk', values: [ [ 'Line 1', 'Line 2', 'Line 3' ] ] }

----------------------------------------

TITLE: Using Stream.buffer in TypeScript with Effect Library
DESCRIPTION: Demonstrates how to use Stream.buffer to create a buffered stream with a capacity of 4, applying additional operations like tapping and scheduling.

LANGUAGE: typescript
CODE:
import { Console, Effect, Schedule, Stream } from "effect"

const stream = Stream.range(1, 10).pipe(
  Stream.tap((n) => Console.log(`before buffering: ${n}`)),
  Stream.buffer({ capacity: 4 }),
  Stream.tap((n) => Console.log(`after buffering: ${n}`)),
  Stream.schedule(Schedule.spaced("5 seconds"))
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// before buffering: 1
// before buffering: 2
// before buffering: 3
// before buffering: 4
// before buffering: 5
// before buffering: 6
// after buffering: 1
// after buffering: 2
// before buffering: 7
// after buffering: 3
// before buffering: 8
// after buffering: 4
// before buffering: 9
// after buffering: 5
// before buffering: 10
// ...

----------------------------------------

TITLE: Defining String Configuration in TypeScript with Effect
DESCRIPTION: Creates a configuration for a string value. The function optionally takes a name parameter and returns a Config<string> object.

LANGUAGE: typescript
CODE:
declare const string: (name?: string) => Config<string>

----------------------------------------

TITLE: Effect.cachedWithTTL Type Definition
DESCRIPTION: TypeScript type signature for the cachedWithTTL function, showing its polymorphic nature and support for both curried and uncurried calling styles.

LANGUAGE: typescript
CODE:
declare const cachedWithTTL: { (timeToLive: Duration.DurationInput): <A, E, R>(self: Effect<A, E, R>) => Effect<Effect<A, E>, never, R>; <A, E, R>(self: Effect<A, E, R>, timeToLive: Duration.DurationInput): Effect<Effect<A, E>, never, R>; }

----------------------------------------

TITLE: Effect.cachedFunction Type Signature
DESCRIPTION: Type signature for the cachedFunction utility showing its generic parameters and return type. Takes a function that produces an Effect and optionally an Equivalence parameter for input comparison.

LANGUAGE: typescript
CODE:
declare const cachedFunction: <A, B, E, R>(f: (a: A) => Effect<B, E, R>, eq?: Equivalence<A>) => Effect<(a: A) => Effect<B, E, R>>

----------------------------------------

TITLE: Transforming Sink Results with map Function in TypeScript
DESCRIPTION: The map function transforms the result of a Sink. It takes a function f that transforms the result type A to A2, and returns a new Sink with the transformed result type. This function can be used in two ways: either by passing the Sink as the first argument, or by using it as a higher-order function.

LANGUAGE: typescript
CODE:
declare const map: { <A, A2>(f: (a: A) => A2): <In, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A2, In, L, E, R>; <A, In, L, E, R, A2>(self: Sink<A, In, L, E, R>, f: (a: A) => A2): Sink<A2, In, L, E, R>; }

----------------------------------------

TITLE: Pool Interface Definition in TypeScript
DESCRIPTION: Defines a generic Pool interface that manages items of type A with potential errors of type E. The pool provides methods for getting items in a scoped context and invalidating existing items. Items are managed within Effect's Scope system.

LANGUAGE: typescript
CODE:
export interface Pool<in out A, out E = never> extends Pool.Variance<A, E>, Effect.Effect<A, E, Scope.Scope>, Pipeable {
  /**
   * Retrieves an item from the pool in a scoped effect. Note that if
   * acquisition fails, then the returned effect will fail for that same reason.
   * Retrying a failed acquisition attempt will repeat the acquisition attempt.
   */
  readonly get: Effect.Effect<A, E, Scope.Scope>

  /**
   * Invalidates the specified item. This will cause the pool to eventually
   * reallocate the item, although this reallocation may occur lazily rather
   * than eagerly.
   */
  invalidate(item: A): Effect.Effect<void>

  readonly [Unify.typeSymbol]?: unknown
  readonly [Unify.unifySymbol]?: PoolUnify<this>
  readonly [Unify.ignoreSymbol]?: PoolUnifyIgnore
}

----------------------------------------

TITLE: Implementing Synchronous Side Effects with Effect.sync in TypeScript
DESCRIPTION: Demonstrates how to create a synchronous side effect using Effect.sync to log a message. The function creates an Effect that represents a side-effectful computation that cannot fail, returning Effect<void, never, never>.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

const log = (message: string) =>
  Effect.sync(() => {
    console.log(message) // side effect
  })

//      ┌─── Effect<void, never, never>
//      ▼
const program = log("Hello, World!")

LANGUAGE: typescript
CODE:
declare const sync: <A>(thunk: LazyArg<A>) => Effect<A>

----------------------------------------

TITLE: Pattern Matching with Option in TypeScript
DESCRIPTION: Demonstrates how to use Option.match to handle both Some and None cases of an Option type. The example shows creating an Option with a value and matching against it to produce different messages based on its state.

LANGUAGE: typescript
CODE:
import { Option } from "effect"

const foo = Option.some(1)

const message = Option.match(foo, {
  onNone: () => "Option is empty",
  onSome: (value) => `Option has a value: ${value}`
})

console.log(message)
// Output: "Option has a value: 1"

----------------------------------------

TITLE: TypeScript Signature of Effect.catchTags Function
DESCRIPTION: This code block shows the TypeScript signature of the Effect.catchTags function. It defines the function's type parameters and return types, illustrating how it handles different cases of tagged errors.

LANGUAGE: typescript
CODE:
declare const catchTags: { <E, Cases extends { [K in Extract<E, { _tag: string; }>["_tag"]]+?: ((error: Extract<E, { _tag: K; }>) => Effect<any, any, any>); } & (unknown extends E ? {} : { [K in Exclude<keyof Cases, Extract<E, { _tag: string; }>["_tag"]>]: never; })>(cases: Cases): <A, R>(self: Effect<A, E, R>) => Effect<A | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Effect<infer A, any, any> ? A : never; }[keyof Cases], Exclude<E, { _tag: keyof Cases; }> | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Effect<any, infer E, any> ? E : never; }[keyof Cases], R | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Effect<any, any, infer R> ? R : never; }[keyof Cases]>; <R, E, A, Cases extends { [K in Extract<E, { _tag: string; }>["_tag"]]+?: ((error: Extract<E, { _tag: K; }>) => Effect<any, any, any>); } & (unknown extends E ? {} : { [K in Exclude<keyof Cases, Extract<E, { _tag: string; }>["_tag"]>]: never; })>(self: Effect<A, E, R>, cases: Cases): Effect<A | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Effect<infer A, any, any> ? A : never; }[keyof Cases], Exclude<E, { _tag: keyof Cases; }> | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Effect<any, infer E, any> ? E : never; }[keyof Cases], R | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Effect<any, any, infer R> ? R : never; }[keyof Cases]>; }

----------------------------------------

TITLE: Defining STM Interface in TypeScript
DESCRIPTION: Defines the core STM interface that represents transactional effects. The interface extends Effect.Effect and includes variance handling and pipeable functionality. It supports operations that can fail with type E or succeed with type A, potentially requiring an environment R.

LANGUAGE: typescript
CODE:
export interface STM<out A, out E = never, out R = never>
  extends Effect.Effect<A, E, R>, STM.Variance<A, E, R>, Pipeable
{
  [Unify.typeSymbol]?: unknown
  [Unify.unifySymbol]?: STMUnify<this>
  [Unify.ignoreSymbol]?: STMUnifyIgnore
  [Symbol.iterator](): Effect.EffectGenerator<STM<A, E, R>>
}

----------------------------------------

TITLE: Transforming Stream Elements with Stream.map in TypeScript
DESCRIPTION: Demonstrates how to use Stream.map to transform each element of a stream by adding 1 to each number. The resulting stream is then collected and logged.

LANGUAGE: typescript
CODE:
import { Effect, Stream } from "effect"

const stream = Stream.make(1, 2, 3).pipe(Stream.map((n) => n + 1))

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 2, 3, 4 ] }

----------------------------------------

TITLE: Repeating an Effect with Potential Failure in TypeScript
DESCRIPTION: This example shows how to use Effect.repeat with an effect that may fail. The effect succeeds twice and then fails on the third attempt. The repetition stops immediately upon failure, demonstrating the behavior of Effect.repeat with failing effects.

LANGUAGE: typescript
CODE:
import { Effect, Schedule } from "effect"

let count = 0

// Define an async effect that simulates an action with possible failures
const action = Effect.async<string, string>((resume) => {
  if (count > 1) {
    console.log("failure")
    resume(Effect.fail("Uh oh!"))
  } else {
    count++
    console.log("success")
    resume(Effect.succeed("yay!"))
  }
})

const policy = Schedule.addDelay(Schedule.recurs(2), () => "100 millis")
const program = Effect.repeat(action, policy)

Effect.runPromiseExit(program).then(console.log)

----------------------------------------

TITLE: Demonstrating Layout.smart vs Layout.pretty Algorithm in TypeScript
DESCRIPTION: A comprehensive example comparing Layout.smart and Layout.pretty algorithms using a Python-style function nesting example. Shows how Layout.smart provides better line break decisions by looking ahead at indentation patterns.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import type * as DocStream from "@effect/printer/DocStream"
import * as Layout from "@effect/printer/Layout"
import * as PageWidth from "@effect/printer/PageWidth"
import { pipe } from "effect/Function"
import * as String from "effect/String"

// Consider the following python-ish document:
const fun = <A>(doc: Doc.Doc<A>): Doc.Doc<A> =>
  Doc.hcat([
    pipe(
      Doc.hcat([Doc.text("fun("), Doc.softLineBreak, doc]),
      Doc.hang(2)
    ),
    Doc.text(")")
  ])

const funs = <A>(doc: Doc.Doc<A>): Doc.Doc<A> =>
  pipe(doc, fun, fun, fun, fun, fun)

const doc = funs(Doc.align(Doc.list(Doc.words("abcdef ghijklm"))))

// The document will be rendered using the following pipeline, where the choice
// of layout algorithm has been left open:
const pageWidth = PageWidth.availablePerLine(26, 1)
const layoutOptions = Layout.options(pageWidth)
const dashes = Doc.text(Array.from({ length: 26 - 2 }, () => "-").join(""))
const hr = Doc.hcat([Doc.vbar, dashes, Doc.vbar])

const render = <A>(
  doc: Doc.Doc<A>
) =>
  (
    layoutAlgorithm: (options: Layout.Layout.Options) => (doc: Doc.Doc<A>) => DocStream.DocStream<A>
  ): string => pipe(Doc.vsep([hr, doc, hr]), layoutAlgorithm(layoutOptions), Doc.renderStream)

----------------------------------------

TITLE: Using mapInputContext with Multiple Services in TypeScript
DESCRIPTION: Demonstrates how to use mapInputContext to transform effect context requirements. Shows defining two services with different requirements and using mapInputContext to provide one service while leaving the other to be fulfilled later.

LANGUAGE: typescript
CODE:
import { Context, Effect } from "effect"

class Service1 extends Context.Tag("Service1")<Service1, { readonly port: number }>() {}
class Service2 extends Context.Tag("Service2")<Service2, { readonly connection: string }>() {}

const program = Effect.gen(function*() {
  const service1 = yield* Service1
  console.log(service1.port)
  const service2 = yield* Service2
  console.log(service2.connection)
  return "some result"
})

//      ┌─── Effect<string, never, Service2>
//      ▼
const programWithService1 = Effect.mapInputContext(
  program,
  (ctx: Context.Context<Service2>) => Context.add(ctx, Service1, { port: 3000 })
)

const runnable = programWithService1.pipe(
  Effect.provideService(Service2, { connection: "localhost" }),
  Effect.provideService(Service1, { port: 3001 })
)

Effect.runPromise(runnable)
// Output:
// 3000
// localhost

LANGUAGE: typescript
CODE:
declare const mapInputContext: { <R2, R>(f: (context: Context.Context<R2>) => Context.Context<R>): <A, E>(self: Effect<A, E, R>) => Effect<A, E, R2>; <A, E, R, R2>(self: Effect<A, E, R>, f: (context: Context.Context<R2>) => Context.Context<R>): Effect<A, E, R2>; }

----------------------------------------

TITLE: Effect.sandbox Function Signature in TypeScript
DESCRIPTION: This snippet shows the TypeScript function signature for Effect.sandbox. It takes an Effect as input and returns a new Effect with enhanced error handling using Cause.Cause<E>.

LANGUAGE: typescript
CODE:
declare const sandbox: <A, E, R>(self: Effect<A, E, R>) => Effect<A, Cause.Cause<E>, R>

----------------------------------------

TITLE: Arithmetic Operations with Pipe
DESCRIPTION: Complete example demonstrating pipe usage with arithmetic operations, showing function definitions and execution

LANGUAGE: typescript
CODE:
import { pipe } from "effect"

// Define simple arithmetic operations
const increment = (x: number) => x + 1
const double = (x: number) => x * 2
const subtractTen = (x: number) => x - 10

// Sequentially apply these operations using `pipe`
const result = pipe(5, increment, double, subtractTen)

console.log(result)
// Output: 2

----------------------------------------

TITLE: Implementing Stream.runLast in TypeScript
DESCRIPTION: A function that executes a stream to completion and returns an Effect containing an Option of the last emitted value. It discards all other elements in the stream. The function takes a Stream<A, E, R> as input and returns an Effect that may contain the last value.

LANGUAGE: typescript
CODE:
declare const runLast: <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<Option.Option<A>, E, R>

----------------------------------------

TITLE: Using bindAll with Effect in TypeScript
DESCRIPTION: Demonstrates how to use the bindAll function to concurrently run multiple effects and combine their results. The example shows binding a successful effect and a failing effect, with the results wrapped in Either.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Effect, Either, pipe } from "effect"

const result = pipe(
  Effect.Do,
  Effect.bind("x", () => Effect.succeed(2)),
  Effect.bindAll(({ x }) => ({
    a: Effect.succeed(x),
    b: Effect.fail("oops"),
  }), { concurrency: 2, mode: "either" })
)
assert.deepStrictEqual(Effect.runSync(result), { x: 2, a: Either.right(2), b: Either.left("oops") })

----------------------------------------

TITLE: Defining Effect.eventually Function Signature in TypeScript
DESCRIPTION: This snippet shows the TypeScript type signature for the Effect.eventually function. It takes an Effect<A, E, R> as input and returns an Effect<A, never, R>, indicating that it never fails (errors are ignored).

LANGUAGE: typescript
CODE:
declare const eventually: <A, E, R>(self: Effect<A, E, R>) => Effect<A, never, R>

----------------------------------------

TITLE: Using Option.getOrElse in TypeScript
DESCRIPTION: Demonstrates how to use Option.getOrElse to handle both Some and None cases in Option type. The function returns the contained value for Some or evaluates a fallback function for None.

LANGUAGE: typescript
CODE:
import { Option } from "effect"

console.log(Option.some(1).pipe(Option.getOrElse(() => 0)))
// Output: 1

console.log(Option.none().pipe(Option.getOrElse(() => 0)))
// Output: 0

LANGUAGE: typescript
CODE:
declare const getOrElse: { <B>(onNone: LazyArg<B>): <A>(self: Option<A>) => B | A; <A, B>(self: Option<A>, onNone: LazyArg<B>): A | B; }

----------------------------------------

TITLE: Stream.raceAll Type Signature in TypeScript
DESCRIPTION: The type signature for the Stream.raceAll function, which takes an array of streams and returns a new stream that emits values from the first stream to emit an item.

LANGUAGE: typescript
CODE:
declare const raceAll: <S extends ReadonlyArray<Stream<any, any, any>>>(...streams: S) => Stream<Stream.Success<S[number]>, Stream.Error<S[number]>, Stream.Context<S[number]>>

----------------------------------------

TITLE: Using Effect.every to Check Collection Elements in TypeScript
DESCRIPTION: Example demonstrating how to use Effect.every to verify that all numbers in an array are even. The function processes each element using an effectful predicate and returns a boolean result.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

const numbers = [2, 4, 6, 8]
const predicate = (n: number, i: number) => Effect.succeed(n % 2 === 0)

const program = Effect.gen(function*() {
  const allEven = yield* Effect.every(numbers, predicate)
  console.log(allEven)
})

Effect.runFork(program)
// Output: true

----------------------------------------

TITLE: Using Effect.flatMap in TypeScript
DESCRIPTION: Demonstrates various ways to use the Effect.flatMap function for chaining effects. It shows how to use pipe, direct function call, and method chaining syntax.

LANGUAGE: typescript
CODE:
const flatMappedEffect = pipe(myEffect, Effect.flatMap(transformation))
// or
const flatMappedEffect = Effect.flatMap(myEffect, transformation)
// or
const flatMappedEffect = myEffect.pipe(Effect.flatMap(transformation))

----------------------------------------

TITLE: Implementing Stream Timeout in TypeScript
DESCRIPTION: Defines a timeout function that takes a duration parameter and terminates a stream if it doesn't produce values within that timeframe. The function supports both curried and non-curried calling styles.

LANGUAGE: typescript
CODE:
declare const timeout: { 
  (duration: Duration.DurationInput): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; 
  <A, E, R>(self: Stream<A, E, R>, duration: Duration.DurationInput): Stream<A, E, R>; 
}

----------------------------------------

TITLE: Effect.validateAll Function Signature in TypeScript
DESCRIPTION: Provides the TypeScript signature for the Effect.validateAll function, showing its various overloads and type parameters.

LANGUAGE: typescript
CODE:
declare const validateAll: { <A, B, E, R>(f: (a: A, i: number) => Effect<B, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly discard?: false | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): (elements: Iterable<A>) => Effect<Array<B>, RA.NonEmptyArray<E>, R>; <A, B, E, R>(f: (a: A, i: number) => Effect<B, E, R>, options: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly discard: true; readonly concurrentFinalizers?: boolean | undefined; }): (elements: Iterable<A>) => Effect<void, RA.NonEmptyArray<E>, R>; <A, B, E, R>(elements: Iterable<A>, f: (a: A, i: number) => Effect<B, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly discard?: false | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): Effect<Array<B>, RA.NonEmptyArray<E>, R>; <A, B, E, R>(elements: Iterable<A>, f: (a: A, i: number) => Effect<B, E, R>, options: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly discard: true; readonly concurrentFinalizers?: boolean | undefined; }): Effect<void, RA.NonEmptyArray<E>, R>; }

----------------------------------------

TITLE: Combining Effects with Custom Function in TypeScript
DESCRIPTION: Demonstrates how to use Effect.zipWith to combine two effects and process their results with a custom function. The example shows sequential execution of tasks with delays and logging.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

const task1 = Effect.succeed(1).pipe(
  Effect.delay("200 millis"),
  Effect.tap(Effect.log("task1 done"))
)
const task2 = Effect.succeed("hello").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Effect.log("task2 done"))
)

const task3 = Effect.zipWith(
  task1,
  task2,
  // Combines results into a single value
  (number, string) => number + string.length
)

Effect.runPromise(task3).then(console.log)
// Output:
// timestamp=... level=INFO fiber=#3 message="task1 done"
// timestamp=... level=INFO fiber=#2 message="task2 done"
// 6

----------------------------------------

TITLE: Effect.timeout Function Signature in TypeScript
DESCRIPTION: The TypeScript signature for the Effect.timeout function. It shows the function's overloads and parameter types, including the use of Duration.DurationInput and Effect types.

LANGUAGE: typescript
CODE:
declare const timeout: { (duration: Duration.DurationInput): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E | Cause.TimeoutException, R>; <A, E, R>(self: Effect<A, E, R>, duration: Duration.DurationInput): Effect<A, Cause.TimeoutException | E, R>; }

----------------------------------------

TITLE: Declaring contextWithEffect Function in TypeScript
DESCRIPTION: This snippet declares the contextWithEffect function, which accesses the context and performs an effectful transformation. It takes a function that transforms the context and returns an Effect, allowing for asynchronous or effectful operations.

LANGUAGE: typescript
CODE:
declare const contextWithEffect: <R2, A, E, R>(f: (context: Context.Context<R2>) => Effect<A, E, R>) => Effect<A, E, R | R2>

----------------------------------------

TITLE: Retrying Effect with Maximum Attempts in TypeScript
DESCRIPTION: Shows how to retry a failing effect up to a maximum number of times (5 attempts). The example uses a simple retry options object instead of a Schedule.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

let count = 0

// Simulates an effect with possible failures
const task = Effect.async<string, Error>((resume) => {
  if (count <= 2) {
    count++
    console.log("failure")
    resume(Effect.fail(new Error()))
  } else {
    console.log("success")
    resume(Effect.succeed("yay!"))
  }
})

// Retry the task up to 5 times
Effect.runPromise(Effect.retry(task, { times: 5 })).then(console.log)

----------------------------------------

TITLE: Combining Effects in Records - TypeScript Effect Library
DESCRIPTION: Demonstrates using Effect.all with a record structure to combine effects with string keys.

LANGUAGE: typescript
CODE:
import { Effect, Console } from "effect"

const recordOfEffects: Record<string, Effect.Effect<number>> = {
  key1: Effect.succeed(1).pipe(Effect.tap(Console.log)),
  key2: Effect.succeed(2).pipe(Effect.tap(Console.log))
}

const resultsAsRecord = Effect.all(recordOfEffects)

Effect.runPromise(resultsAsRecord).then(console.log)

----------------------------------------

TITLE: Implementing Stream.fromEffectOption in TypeScript
DESCRIPTION: Creates a stream from an effect producing a value of type A or an empty Stream. It takes an effect that returns an Option of E and produces a Stream of A, E, or R.

LANGUAGE: typescript
CODE:
declare const fromEffectOption: <A, E, R>(effect: Effect.Effect<A, Option.Option<E>, R>) => Stream<A, E, R>

----------------------------------------

TITLE: Defining HttpClient.mapRequestEffect Function in TypeScript
DESCRIPTION: Defines a function that appends an effectful transformation to an HTTP client request before sending it. The function supports both curried and uncurried forms, allowing for flexible request modification with effect handling.

LANGUAGE: typescript
CODE:
declare const mapRequestEffect: {
  <E2, R2>(f: (a: ClientRequest.HttpClientRequest) => Effect.Effect<ClientRequest.HttpClientRequest, E2, R2>): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E | E2, R | R2>;
  <E, R, E2, R2>(self: HttpClient.With<E, R>, f: (a: ClientRequest.HttpClientRequest) => Effect.Effect<ClientRequest.HttpClientRequest, E2, R2>): HttpClient.With<E | E2, R | R2>;
}

----------------------------------------

TITLE: Implementing Cached Effects in TypeScript using Effect.cached
DESCRIPTION: This example demonstrates how to use Effect.cached to create and use a cached effect. It compares the behavior of a non-cached expensive task with its cached version, showing how subsequent calls to the cached effect return the same result without re-executing the expensive operation.

LANGUAGE: typescript
CODE:
import { Effect, Console } from "effect"

let i = 1
const expensiveTask = Effect.promise<string>(() => {
  console.log("expensive task...")
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(`result ${i++}`)
    }, 100)
  })
})

const program = Effect.gen(function* () {
  console.log("non-cached version:")
  yield* expensiveTask.pipe(Effect.andThen(Console.log))
  yield* expensiveTask.pipe(Effect.andThen(Console.log))
  console.log("cached version:")
  const cached = yield* Effect.cached(expensiveTask)
  yield* cached.pipe(Effect.andThen(Console.log))
  yield* cached.pipe(Effect.andThen(Console.log))
})

Effect.runFork(program)
// Output:
// non-cached version:
// expensive task...
// result 1
// expensive task...
// result 2
// cached version:
// expensive task...
// result 3
// result 3

----------------------------------------

TITLE: Using Effect.timed for Performance Measurement in TypeScript
DESCRIPTION: Example demonstrating how to wrap an Effect with timing functionality. Shows creating a task with a sleep delay, measuring its execution time, and logging the duration alongside the result.

LANGUAGE: typescript
CODE:
import { Duration, Effect } from "effect"

const task = Effect.gen(function*() {
  yield* Effect.sleep("2 seconds") // Simulates some work
  return "some result"
})

const timedTask = task.pipe(Effect.timed)

const program = Effect.gen(function*() {
  const [duration, result] = yield* timedTask
  console.log(`Task completed in ${Duration.toMillis(duration)} ms with result: ${result}`)
})

Effect.runFork(program)
// Output: Task completed in 2003.749125 ms with result: some result

LANGUAGE: typescript
CODE:
declare const timed: <A, E, R>(self: Effect<A, E, R>) => Effect<[duration: Duration.Duration, result: A], E, R>

----------------------------------------

TITLE: Handling Specific Errors with Effect.catchSome in TypeScript
DESCRIPTION: This example demonstrates how to use Effect.catchSome to selectively catch and handle errors of certain types. It creates a program that may fail with HttpError or ValidationError, then uses catchSome to recover only from HttpError instances.

LANGUAGE: typescript
CODE:
import { Effect, Random, Option } from "effect"

class HttpError {
  readonly _tag = "HttpError"
}

class ValidationError {
  readonly _tag = "ValidationError"
}

//      ┌─── Effect<string, HttpError | ValidationError, never>
//      ▼
const program = Effect.gen(function* () {
  const n1 = yield* Random.next
  const n2 = yield* Random.next
  if (n1 < 0.5) {
    yield* Effect.fail(new HttpError())
  }
  if (n2 < 0.5) {
    yield* Effect.fail(new ValidationError())
  }
  return "some result"
})

//      ┌─── Effect<string, HttpError | ValidationError, never>
//      ▼
const recovered = program.pipe(
  Effect.catchSome((error) => {
    // Only handle HttpError errors
    if (error._tag === "HttpError") {
      return Option.some(Effect.succeed("Recovering from HttpError"))
    } else {
      return Option.none()
    }
  })
)

----------------------------------------

TITLE: Effect.bind Function Signature in TypeScript
DESCRIPTION: This code snippet shows the TypeScript signature for the Effect.bind function. It defines the function's type parameters, arguments, and return types for different overloads.

LANGUAGE: typescript
CODE:
declare const bind: { <N extends string, A extends object, B, E2, R2>(name: Exclude<N, keyof A>, f: (a: NoInfer<A>) => Effect<B, E2, R2>): <E1, R1>(self: Effect<A, E1, R1>) => Effect<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }, E2 | E1, R2 | R1>; <A extends object, N extends string, E1, R1, B, E2, R2>(self: Effect<A, E1, R1>, name: Exclude<N, keyof A>, f: (a: NoInfer<A>) => Effect<B, E2, R2>): Effect<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }, E1 | E2, R1 | R2>; }

----------------------------------------

TITLE: Peeking at First Value in TPriorityQueue using STM in TypeScript
DESCRIPTION: Defines a function 'peek' that retrieves the first value from a TPriorityQueue without removing it. It uses STM (Software Transactional Memory) to handle concurrent access and retries until a value is available in the queue.

LANGUAGE: typescript
CODE:
declare const peek: <A>(self: TPriorityQueue<A>) => STM.STM<A>

----------------------------------------

TITLE: Error Handling with Effect.catchTag in TypeScript
DESCRIPTION: Demonstrates how to use Effect.catchTag to handle specific error types using their _tag field as a discriminator. Shows creation of tagged error classes and recovery from HttpError while letting ValidationError propagate.

LANGUAGE: typescript
CODE:
import { Effect, Random } from "effect"

class HttpError {
  readonly _tag = "HttpError"
}

class ValidationError {
  readonly _tag = "ValidationError"
}

//      ┌─── Effect<string, HttpError | ValidationError, never>
//      ▼
const program = Effect.gen(function* () {
  const n1 = yield* Random.next
  const n2 = yield* Random.next
  if (n1 < 0.5) {
    yield* Effect.fail(new HttpError())
  }
  if (n2 < 0.5) {
    yield* Effect.fail(new ValidationError())
  }
  return "some result"
})

//      ┌─── Effect<string, ValidationError, never>
//      ▼
const recovered = program.pipe(
  // Only handle HttpError errors
  Effect.catchTag("HttpError", (_HttpError) =>
    Effect.succeed("Recovering from HttpError")
  )
)

----------------------------------------

TITLE: Racing Two Successful Effects in TypeScript
DESCRIPTION: Demonstrates racing two effects that both succeed, with the faster one completing first and interrupting the slower one.

LANGUAGE: typescript
CODE:
import { Effect, Console } from "effect"

const task1 = Effect.succeed("task1").pipe(
  Effect.delay("200 millis"),
  Effect.tap(Console.log("task1 done")),
  Effect.onInterrupt(() => Console.log("task1 interrupted"))
)
const task2 = Effect.succeed("task2").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Console.log("task2 done")),
  Effect.onInterrupt(() => Console.log("task2 interrupted"))
)

const program = Effect.race(task1, task2)

Effect.runFork(program)
// Output:
// task1 done
// task2 interrupted

----------------------------------------

TITLE: Defining Resource Interface in TypeScript
DESCRIPTION: Defines the Resource interface, which extends Effect.Effect and includes internal properties for scoped reference and acquisition. It also includes type symbols for unification and ignoring.

LANGUAGE: typescript
CODE:
export interface Resource<in out A, in out E = never> extends Effect.Effect<A, E>, Resource.Variance<A, E> {
  /** @internal */
  readonly scopedRef: ScopedRef.ScopedRef<Exit.Exit<A, E>>
  /** @internal */
  readonly acquire: Effect.Effect<A, E, Scope.Scope>

  readonly [Unify.typeSymbol]?: unknown
  readonly [Unify.unifySymbol]?: ResourceUnify<this>
  readonly [Unify.ignoreSymbol]?: ResourceUnifyIgnore
}

----------------------------------------

TITLE: Implementing Queue Shutdown Awaiting in Effect TypeScript
DESCRIPTION: The awaitShutdown function waits until a queue is shutdown. It returns an Effect that doesn't resume until the queue has been shutdown. If the queue is already shutdown, the Effect resumes immediately. It works with both Dequeue and Enqueue types.

LANGUAGE: typescript
CODE:
declare const awaitShutdown: <A>(self: Dequeue<A> | Enqueue<A>) => Effect.Effect<void>

----------------------------------------

TITLE: Handling Specific Errors with Effect.catchSome in TypeScript
DESCRIPTION: This example demonstrates how to use Effect.catchSome to selectively catch and handle errors of certain types. It creates a program that may fail with HttpError or ValidationError, then uses catchSome to recover only from HttpError instances.

LANGUAGE: typescript
CODE:
import { Effect, Random, Option } from "effect"

class HttpError {
  readonly _tag = "HttpError"
}

class ValidationError {
  readonly _tag = "ValidationError"
}

//      ┌─── Effect<string, HttpError | ValidationError, never>
//      ▼
const program = Effect.gen(function* () {
  const n1 = yield* Random.next
  const n2 = yield* Random.next
  if (n1 < 0.5) {
    yield* Effect.fail(new HttpError())
  }
  if (n2 < 0.5) {
    yield* Effect.fail(new ValidationError())
  }
  return "some result"
})

//      ┌─── Effect<string, HttpError | ValidationError, never>
//      ▼
const recovered = program.pipe(
  Effect.catchSome((error) => {
    // Only handle HttpError errors
    if (error._tag === "HttpError") {
      return Option.some(Effect.succeed("Recovering from HttpError"))
    } else {
      return Option.none()
    }
  })
)

----------------------------------------

TITLE: Defining RedBlackTree Interface in TypeScript
DESCRIPTION: Defines the RedBlackTree interface which extends Iterable, Equal, Pipeable, and Inspectable. It includes type parameters for Key and Value, and a TypeId property with invariant Key and covariant Value types.

LANGUAGE: typescript
CODE:
export interface RedBlackTree<in out Key, out Value> extends Iterable<[Key, Value]>, Equal, Pipeable, Inspectable {
  readonly [TypeId]: {
    readonly _Key: Types.Invariant<Key>
    readonly _Value: Types.Covariant<Value>
  }
}

----------------------------------------

TITLE: Implementing Array.flatMap Function in TypeScript
DESCRIPTION: Defines the flatMap function for arrays, which applies a mapping function to each element and concatenates the results. It supports both readonly and mutable arrays, as well as non-empty array variants.

LANGUAGE: typescript
CODE:
declare const flatMap: { <S extends ReadonlyArray<any>, T extends ReadonlyArray<any>>(f: (a: ReadonlyArray.Infer<S>, i: number) => T): (self: S) => ReadonlyArray.AndNonEmpty<S, T, ReadonlyArray.Infer<T>>; <A, B>(self: NonEmptyReadonlyArray<A>, f: (a: A, i: number) => NonEmptyReadonlyArray<B>): NonEmptyArray<B>; <A, B>(self: ReadonlyArray<A>, f: (a: A, i: number) => ReadonlyArray<B>): Array<B>; }

----------------------------------------

TITLE: Implementing CRUD Repository in Effect-TS SQL
DESCRIPTION: Creates a type-safe CRUD repository with insert, update, delete, and find operations from a model definition. The repository provides both regular and void-returning versions of insert and update operations, along with findById and delete functionality. Requires a model definition and configuration options including table name, span prefix, and ID column.

LANGUAGE: typescript
CODE:
declare const makeRepository: <S extends Any, Id extends (keyof S["Type"]) & (keyof S["update"]["Type"]) & (keyof S["fields"])>(Model: S, options: { readonly tableName: string; readonly spanPrefix: string; readonly idColumn: Id; }) => Effect.Effect<{ readonly insert: (insert: S["insert"]["Type"]) => Effect.Effect<S["Type"], never, S["Context"] | S["insert"]["Context"]>; readonly insertVoid: (insert: S["insert"]["Type"]) => Effect.Effect<void, never, S["Context"] | S["insert"]["Context"]>; readonly update: (update: S["update"]["Type"]) => Effect.Effect<S["Type"], never, S["Context"] | S["update"]["Context"]>; readonly updateVoid: (update: S["update"]["Type"]) => Effect.Effect<void, never, S["Context"] | S["update"]["Context"]>; readonly findById: (id: Schema.Schema.Type<S["fields"][Id]>) => Effect.Effect<Option.Option<S["Type"]>, never, S["Context"] | Schema.Schema.Context<S["fields"][Id]>>; readonly delete: (id: Schema.Schema.Type<S["fields"][Id]>) => Effect.Effect<void, never, Schema.Schema.Context<S["fields"][Id]>>; }, never, SqlClient>

----------------------------------------

TITLE: Using logfmtLogger in TypeScript with Effect
DESCRIPTION: Demonstrates how to use the logfmtLogger function to output logs in a human-readable format. The example shows logging messages, annotating logs with key-value pairs, and using log spans.

LANGUAGE: typescript
CODE:
import { Effect, Logger } from "effect"

const program = Effect.log("message1", "message2").pipe(
  Effect.annotateLogs({ key1: "value1", key2: "value2" }),
  Effect.withLogSpan("myspan")
)

Effect.runFork(program.pipe(Effect.provide(Logger.logFmt)))
// timestamp=... level=INFO fiber=#0 message=message1 message=message2 myspan=0ms key2=value2 key1=value1

----------------------------------------

TITLE: Using Effect.exit for Error Handling in TypeScript
DESCRIPTION: Demonstrates how to use Effect.exit to handle both successful and failure outcomes, including runtime errors. The example shows error handling patterns with Exit type and Console logging.

LANGUAGE: typescript
CODE:
import { Effect, Cause, Console, Exit } from "effect"

// Simulating a runtime error
const task = Effect.dieMessage("Boom!")

const program = Effect.gen(function* () {
  const exit = yield* Effect.exit(task)
  if (Exit.isFailure(exit)) {
    const cause = exit.cause
    if (
      Cause.isDieType(cause) &&
      Cause.isRuntimeException(cause.defect)
    ) {
      yield* Console.log(
        `RuntimeException defect caught: ${cause.defect.message}`
      )
    } else {
      yield* Console.log("Unknown failure caught.")
    }
  }
})

// We get an Exit.Success because we caught all failures
Effect.runPromiseExit(program).then(console.log)
// Output:
// RuntimeException defect caught: Boom!
// {
//   _id: "Exit",
//   _tag: "Success",
//   value: undefined
// }

LANGUAGE: typescript
CODE:
declare const exit: <A, E, R>(self: Effect<A, E, R>) => Effect<Exit.Exit<A, E>, never, R>

----------------------------------------

TITLE: Using Either.match with Right and Left values in TypeScript
DESCRIPTION: Demonstrates how to use Either.match to handle both Right and Left cases of an Either type. The example shows processing a successful number value and an error string array using custom handler functions.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { pipe, Either } from "effect"

const onLeft  = (strings: ReadonlyArray<string>): string => `strings: ${strings.join(', ')}`

const onRight = (value: number): string => `Ok: ${value}`

assert.deepStrictEqual(pipe(Either.right(1), Either.match({ onLeft, onRight })), 'Ok: 1')
assert.deepStrictEqual(
  pipe(Either.left(['string 1', 'string 2']), Either.match({ onLeft, onRight })),
  'strings: string 1, string 2'
)

----------------------------------------

TITLE: Applying Discount with Logging in TypeScript using Effect.tap
DESCRIPTION: This example demonstrates how to use Effect.tap to log a step in a pipeline without modifying the main value. It applies a discount to a transaction amount while logging the original amount.

LANGUAGE: typescript
CODE:
import { Console, Effect, pipe } from "effect"

// Function to apply a discount safely to a transaction amount
const applyDiscount = (
  total: number,
  discountRate: number
): Effect.Effect<number, Error> =>
  discountRate === 0
    ? Effect.fail(new Error("Discount rate cannot be zero"))
    : Effect.succeed(total - (total * discountRate) / 100)

// Simulated asynchronous task to fetch a transaction amount from database
const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))

const finalAmount = pipe(
  fetchTransactionAmount,
  // Log the fetched transaction amount
  Effect.tap((amount) => Console.log(`Apply a discount to: ${amount}`)),
  // `amount` is still available!
  Effect.flatMap((amount) => applyDiscount(amount, 5))
)

Effect.runPromise(finalAmount).then(console.log)
// Output:
// Apply a discount to: 100
// 95

----------------------------------------

TITLE: Using Stream.take in TypeScript with Effect
DESCRIPTION: Demonstrates how to use the Stream.take function to limit the number of elements in a stream. It creates a stream of incrementing numbers and takes the first 5 elements.

LANGUAGE: typescript
CODE:
import { Effect, Stream } from "effect"

const stream = Stream.take(Stream.iterate(0, (n) => n + 1), 5)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 0, 1, 2, 3, 4 ] }

----------------------------------------

TITLE: Defining Stream.retry Function in TypeScript
DESCRIPTION: Declares the retry function for streams that can retry the entire stream when it fails, according to a given schedule. The schedule is reset when the first element passes through the stream again. It supports both curried and uncurried versions.

LANGUAGE: typescript
CODE:
declare const retry: {
  <E0 extends E, R2, E, X>(schedule: Schedule.Schedule<X, E0, R2>): <A, R>(self: Stream<A, E, R>) => Stream<A, E, R2 | R>;
  <A, E, R, X, E0 extends E, R2>(self: Stream<A, E, R>, schedule: Schedule.Schedule<X, E0, R2>): Stream<A, E, R | R2>;
}

----------------------------------------

TITLE: Declaring broadcastDynamic Function in TypeScript
DESCRIPTION: Defines the broadcastDynamic function for fanning out streams with dynamic control over lag and capacity. It allows creating multiple streams from a single source stream, with options for managing buffer capacity and replay functionality.

LANGUAGE: typescript
CODE:
declare const broadcastDynamic: { (maximumLag: number | { readonly capacity: "unbounded"; readonly replay?: number | undefined; } | { readonly capacity: number; readonly strategy?: "sliding" | "dropping" | "suspend" | undefined; readonly replay?: number | undefined; }): <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<Stream<A, E>, never, Scope.Scope | R>; <A, E, R>(self: Stream<A, E, R>, maximumLag: number | { readonly capacity: "unbounded"; readonly replay?: number | undefined; } | { readonly capacity: number; readonly strategy?: "sliding" | "dropping" | "suspend" | undefined; readonly replay?: number | undefined; }): Effect.Effect<Stream<A, E>, never, Scope.Scope | R>; }

----------------------------------------

TITLE: Transforming Effect Error Handling with Effect.sandbox in TypeScript
DESCRIPTION: This snippet demonstrates how to use Effect.sandbox to enhance error handling in an Effect. It shows the transformation of a simple Effect into a sandboxed version, handling different error types, and then restoring the original error handling.

LANGUAGE: typescript
CODE:
import { Effect, Console } from "effect"

//      ┌─── Effect<string, Error, never>
//      ▼
const task = Effect.fail(new Error("Oh uh!")).pipe(
  Effect.as("primary result")
)

//      ┌─── Effect<string, Cause<Error>, never>
//      ▼
const sandboxed = Effect.sandbox(task)

const program = Effect.catchTags(sandboxed, {
  Die: (cause) =>
    Console.log(`Caught a defect: ${cause.defect}`).pipe(
      Effect.as("fallback result on defect")
    ),
  Interrupt: (cause) =>
    Console.log(`Caught a defect: ${cause.fiberId}`).pipe(
      Effect.as("fallback result on fiber interruption")
    ),
  Fail: (cause) =>
    Console.log(`Caught a defect: ${cause.error}`).pipe(
      Effect.as("fallback result on failure")
    )
})

// Restore the original error handling with unsandbox
const main = Effect.unsandbox(program)

Effect.runPromise(main).then(console.log)
// Output:
// Caught a defect: Oh uh!
// fallback result on failure

----------------------------------------

TITLE: Creating Bounded Queue in TypeScript using Effect Package
DESCRIPTION: The bounded function creates a new bounded Queue. When the queue reaches its capacity, subsequent offer calls are suspended until space becomes available. For optimal performance, it's recommended to use power of 2 capacities.

LANGUAGE: typescript
CODE:
declare const bounded: <A>(requestedCapacity: number) => Effect.Effect<Queue<A>>

----------------------------------------

TITLE: Implementing HTTP Status Code Filtering in Effect Platform
DESCRIPTION: Defines a function that filters HTTP responses based on a predicate function applied to status codes. The function can be used both in curried and uncurried forms, returning an HttpClient instance that may produce ResponseError if the status code doesn't match the predicate.

LANGUAGE: typescript
CODE:
declare const filterStatus: { 
  (f: (status: number) => boolean): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E | Error.ResponseError, R>; 
  <E, R>(self: HttpClient.With<E, R>, f: (status: number) => boolean): HttpClient.With<E | Error.ResponseError, R>; 
}

----------------------------------------

TITLE: Defining TSubscriptionRef Interface in TypeScript
DESCRIPTION: Defines a TSubscriptionRef interface that extends TRef to provide subscription capabilities. It includes internal properties for ref and pubsub management, and methods for value modification and change tracking through a TDequeue.

LANGUAGE: typescript
CODE:
export interface TSubscriptionRef<in out A> extends TSubscriptionRef.Variance<A>, TRef.TRef<A> {
  /** @internal */
  readonly ref: TRef.TRef<A>
  /** @internal */
  readonly pubsub: TPubSub.TPubSub<A>
  /** @internal */
  modify<B>(f: (a: A) => readonly [B, A]): STM.STM<B>

  /**
   * A TDequeue containing the current value of the Ref as well as all changes
   * to that value.
   */
  readonly changes: STM.STM<TQueue.TDequeue<A>>
}

----------------------------------------

TITLE: Effect.succeed Function Signature in TypeScript
DESCRIPTION: Shows the TypeScript function signature for Effect.succeed. This function takes a value of type A and returns an Effect of type A.

LANGUAGE: typescript
CODE:
declare const succeed: <A>(value: A) => Effect<A>

----------------------------------------

TITLE: Filtering 2xx Status Codes in Effect HttpClient
DESCRIPTION: A TypeScript function that filters HTTP responses to only allow those with 2xx status codes. It takes an HttpClient instance and returns a new client that will error on non-2xx responses with a ResponseError.

LANGUAGE: typescript
CODE:
declare const filterStatusOk: <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E | Error.ResponseError, R>

----------------------------------------

TITLE: Defining timeoutOption Function in TypeScript for Effect Micro Module
DESCRIPTION: Declares the timeoutOption function, which returns an effect that will timeout another effect. It succeeds with None if the timeout elapses before the effect produces a value, and Some of the produced value otherwise. The function safely interrupts the running effect if the timeout elapses.

LANGUAGE: typescript
CODE:
declare const timeoutOption: { (millis: number): <A, E, R>(self: Micro<A, E, R>) => Micro<Option.Option<A>, E, R>; <A, E, R>(self: Micro<A, E, R>, millis: number): Micro<Option.Option<A>, E, R>; }

----------------------------------------

TITLE: Implementing Channel Layer Provision in TypeScript
DESCRIPTION: Defines a function provideLayer that provides a layer to a channel, enabling translation between different environment levels. The function supports both curried and uncurried forms, handling various generic type parameters for elements, errors, and environment types.

LANGUAGE: typescript
CODE:
declare const provideLayer: { 
  <Env, OutErr2, Env0>(layer: Layer.Layer<Env, OutErr2, Env0>): 
    <OutElem, InElem, OutErr, InErr, OutDone, InDone>
    (self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => 
    Channel<OutElem, InElem, OutErr2 | OutErr, InErr, OutDone, InDone, Env0>; 
  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutErr2, Env0>
  (self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, 
   layer: Layer.Layer<Env, OutErr2, Env0>): 
   Channel<OutElem, InElem, OutErr | OutErr2, InErr, OutDone, InDone, Env0>; 
}

----------------------------------------

TITLE: Creating Sliding Windows in Streams using Effect
DESCRIPTION: This snippet demonstrates how to use the Stream.sliding function to create overlapping windows of elements from a stream. It takes a window size as a parameter and returns a new stream of chunks, where each chunk represents a sliding window.

LANGUAGE: typescript
CODE:
import { pipe, Stream } from "effect"

pipe(
  Stream.make(1, 2, 3, 4),
  Stream.sliding(2),
  Stream.runCollect
)
// => Chunk(Chunk(1, 2), Chunk(2, 3), Chunk(3, 4))

----------------------------------------

TITLE: Creating a Dropping Queue in TypeScript
DESCRIPTION: This function creates a new bounded Queue with a dropping strategy. When the queue reaches its capacity, new elements are dropped while existing elements are retained. For optimal performance, it's recommended to use power of 2 capacities.

LANGUAGE: typescript
CODE:
declare const dropping: <A>(requestedCapacity: number) => Effect.Effect<Queue<A>>

----------------------------------------

TITLE: Providing a Single Service to a Stream in TypeScript
DESCRIPTION: The provideService function allows you to provide a single service that a stream requires. It takes a Context.Tag and a resource, and returns a new stream with the service provided. If multiple services are needed, Stream.provideContext should be used instead.

LANGUAGE: typescript
CODE:
declare const provideService: {
  <I, S>(tag: Context.Tag<I, S>, resource: NoInfer<S>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, Exclude<R, I>>;
  <A, E, R, I, S>(self: Stream<A, E, R>, tag: Context.Tag<I, S>, resource: NoInfer<S>): Stream<A, E, Exclude<R, I>>;
}

----------------------------------------

TITLE: Using dropWhile with Effect in TypeScript
DESCRIPTION: Demonstrates how to use Effect.dropWhile to filter a number array, dropping elements while they are less than or equal to 3. The example shows the usage of Effect.gen for generating the program and Effect.runFork for execution.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

const numbers = [1, 2, 3, 4, 5, 6]
const predicate = (n: number, i: number) => Effect.succeed(n <= 3)

const program = Effect.gen(function*() {
  const result = yield* Effect.dropWhile(numbers, predicate)
  console.log(result)
})

Effect.runFork(program)
// Output: [4, 5, 6]

LANGUAGE: typescript
CODE:
declare const dropWhile: { <A, E, R>(predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>): (elements: Iterable<A>) => Effect<Array<A>, E, R>; <A, E, R>(elements: Iterable<A>, predicate: (a: A, i: number) => Effect<boolean, E, R>): Effect<Array<A>, E, R>; }

----------------------------------------

TITLE: Creating Resource Pool with Effect Pool.make
DESCRIPTION: Creates a new resource pool with specified size and configuration options. Allows control over concurrent access through concurrency parameter and resource creation timing through targetUtilization. The pool is managed within a Scope that handles resource lifecycle.

LANGUAGE: typescript
CODE:
declare const make: <A, E, R>(
  options: {
    readonly acquire: Effect.Effect<A, E, R>;
    readonly size: number;
    readonly concurrency?: number | undefined;
    readonly targetUtilization?: number | undefined;
  }
) => Effect.Effect<Pool<A, E>, never, Scope.Scope | R>

----------------------------------------

TITLE: Implementing Retry Logic with Effect.eventually in TypeScript
DESCRIPTION: This snippet demonstrates how to use Effect.eventually to retry an operation until it succeeds. It creates an effect that fails the first two times and succeeds on the third attempt, showcasing the function's ability to ignore errors and continue retrying.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

let counter = 0

const effect = Effect.try(() => {
  counter++
  if (counter < 3) {
    console.log("running effect")
    throw new Error("error")
  } else {
    console.log("effect done")
    return "some result"
  }
})

const program = Effect.eventually(effect)

Effect.runPromise(program).then(console.log)
// Output:
// running effect
// running effect
// effect done
// some result

----------------------------------------

TITLE: Implementing zipAllSortedByKey Stream Operation in TypeScript
DESCRIPTION: Implements a function that zips two streams sorted by distinct keys into a new sorted stream. The operation combines values associated with each key into tuples, using specified default values for missing entries. Operates in constant space but requires pre-sorted input streams with distinct keys.

LANGUAGE: typescript
CODE:
declare const zipAllSortedByKey: { 
  <A2, E2, R2, A, K>(
    options: { 
      readonly other: Stream<readonly [K, A2], E2, R2>; 
      readonly defaultSelf: A; 
      readonly defaultOther: A2; 
      readonly order: Order.Order<K>; 
    }
  ): <E, R>(self: Stream<readonly [K, A], E, R>) => Stream<[K, [A, A2]], E2 | E, R2 | R>; 
  <K, A, E, R, A2, E2, R2>(
    self: Stream<readonly [K, A], E, R>, 
    options: { 
      readonly other: Stream<readonly [K, A2], E2, R2>; 
      readonly defaultSelf: A; 
      readonly defaultOther: A2; 
      readonly order: Order.Order<K>; 
    }
  ): Stream<[K, [A, A2]], E | E2, R | R2>; 
}

----------------------------------------

TITLE: Basic Usage of Effect.tapDefect
DESCRIPTION: Demonstrates how to use tapDefect to inspect and handle both recoverable errors and severe defects in Effect operations. Shows the difference in behavior between regular errors and defects.

LANGUAGE: typescript
CODE:
import { Effect, Console } from "effect"

// Simulate a task that fails with a recoverable error
const task1: Effect.Effect<number, string> = Effect.fail("NetworkError")

// tapDefect won't log anything because NetworkError is not a defect
const tapping1 = Effect.tapDefect(task1, (cause) =>
  Console.log(`defect: ${cause}`)
)

Effect.runFork(tapping1)
// No Output

// Simulate a severe failure in the system
const task2: Effect.Effect<number, string> = Effect.dieMessage(
  "Something went wrong"
)

// Log the defect using tapDefect
const tapping2 = Effect.tapDefect(task2, (cause) =>
  Console.log(`defect: ${cause}`)
)

Effect.runFork(tapping2)
// Output:
// defect: RuntimeException: Something went wrong
//   ... stack trace ...

----------------------------------------

TITLE: Using Effect.findFirst to Find First Element Meeting a Condition in TypeScript
DESCRIPTION: This example demonstrates how to use Effect.findFirst to find the first element in an array that satisfies an effectful predicate. It processes a collection of numbers and returns the first number greater than 3.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

const numbers = [1, 2, 3, 4, 5]
const predicate = (n: number, i: number) => Effect.succeed(n > 3)

const program = Effect.gen(function*() {
  const result = yield* Effect.findFirst(numbers, predicate)
  console.log(result)
})

Effect.runFork(program)
// Output: { _id: 'Option', _tag: 'Some', value: 4 }

----------------------------------------

TITLE: Declaring completeEffect Function in TypeScript
DESCRIPTION: Declares the completeEffect function, which completes a Request with a specified effectful computation. It handles both success and failure cases of the effect workflow.

LANGUAGE: typescript
CODE:
declare const completeEffect: { <A extends Request<any, any>, R>(effect: Effect.Effect<Request.Success<A>, Request.Error<A>, R>): (self: A) => Effect.Effect<void, never, R>; <A extends Request<any, any>, R>(self: A, effect: Effect.Effect<Request.Success<A>, Request.Error<A>, R>): Effect.Effect<void, never, R>; }

----------------------------------------

TITLE: Defining tapRequest Function for HttpClient in TypeScript
DESCRIPTION: Defines the tapRequest function, which allows performing an additional effect on an HTTP request before sending it. It can be used in two ways: as a higher-order function or directly on an HttpClient instance.

LANGUAGE: typescript
CODE:
declare const tapRequest: {
  <_, E2, R2>(f: (a: ClientRequest.HttpClientRequest) => Effect.Effect<_, E2, R2>): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E | E2, R | R2>;
  <E, R, _, E2, R2>(self: HttpClient.With<E, R>, f: (a: ClientRequest.HttpClientRequest) => Effect.Effect<_, E2, R2>): HttpClient.With<E | E2, R | R2>;
}

----------------------------------------

TITLE: Implementing List.flatMap Function in TypeScript
DESCRIPTION: Defines a flatMap function that transforms each element of a list using a mapping function and concatenates the results. The function supports both regular Lists and Cons (non-empty lists) with type safety preserved through conditional types.

LANGUAGE: typescript
CODE:
declare const flatMap: { 
  <S extends List<any>, T extends List<any>>(f: (a: List.Infer<S>, i: number) => T): (self: S) => List.AndNonEmpty<S, T, List.Infer<T>>; 
  <A, B>(self: Cons<A>, f: (a: A, i: number) => Cons<B>): Cons<B>; 
  <A, B>(self: List<A>, f: (a: A, i: number) => List<B>): List<B>; 
}

----------------------------------------

TITLE: Creating an Option with a Value using Option.some in TypeScript
DESCRIPTION: This snippet demonstrates how to use the Option.some function to wrap a value into an Option, representing its presence. It shows the creation of an Option holding the number 1 and logs the result.

LANGUAGE: typescript
CODE:
import { Option } from "effect"

// An Option holding the number 1
//
//      ┌─── Option<number>
//      ▼
const value = Option.some(1)

console.log(value)
// Output: { _id: 'Option', _tag: 'Some', value: 1 }

----------------------------------------

TITLE: Effect.timeoutTo Type Signature
DESCRIPTION: Type declaration for the timeoutTo function showing its parameter structure and return types. Demonstrates function overloading with both options-first and self-first variants.

LANGUAGE: typescript
CODE:
declare const timeoutTo: { <A, B, B1>(options: { readonly onTimeout: LazyArg<B1>; readonly onSuccess: (a: A) => B; readonly duration: Duration.DurationInput; }): <E, R>(self: Effect<A, E, R>) => Effect<B | B1, E, R>; <A, E, R, B1, B>(self: Effect<A, E, R>, options: { readonly onTimeout: LazyArg<B1>; readonly onSuccess: (a: A) => B; readonly duration: Duration.DurationInput; }): Effect<B1 | B, E, R>; }

----------------------------------------

TITLE: Combining Effects with Error Accumulation in TypeScript
DESCRIPTION: Demonstrates how to use Effect.validate to combine multiple effects, continuing execution even when some effects fail. It shows how to collect all errors into a Cause and includes all successes in the final result.

LANGUAGE: typescript
CODE:
import { Effect, Console } from "effect"

const task1 = Console.log("task1").pipe(Effect.as(1))
const task2 = Effect.fail("Oh uh!").pipe(Effect.as(2))
const task3 = Console.log("task2").pipe(Effect.as(3))
const task4 = Effect.fail("Oh no!").pipe(Effect.as(4))

const program = task1.pipe(
  Effect.validate(task2),
  Effect.validate(task3),
  Effect.validate(task4)
)

Effect.runPromiseExit(program).then(console.log)
// Output:
// task1
// task2
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: {
//     _id: 'Cause',
//     _tag: 'Sequential',
//     left: { _id: 'Cause', _tag: 'Fail', failure: 'Oh uh!' },
//     right: { _id: 'Cause', _tag: 'Fail', failure: 'Oh no!' }
//   }
// }

----------------------------------------

TITLE: Custom Error Handling with Effect.tryPromise in TypeScript
DESCRIPTION: Shows how to use Effect.tryPromise with custom error handling. This example remaps any errors to a custom Error type.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

const getTodo = (id: number) =>
  Effect.tryPromise({
    try: () => fetch(`https://jsonplaceholder.typicode.com/todos/${id}`),
    // remap the error
    catch: (unknown) => new Error(`something went wrong ${unknown}`)
  })

//      ┌─── Effect<Response, Error, never>
//      ▼
const program = getTodo(1)

----------------------------------------

TITLE: Using matchEffect with Success and Failure Cases in TypeScript
DESCRIPTION: Demonstrates how to use matchEffect to handle both successful and failed effects while performing side effects like logging. Shows examples with both success and failure scenarios using Effect.succeed and Effect.fail.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

const success: Effect.Effect<number, Error> = Effect.succeed(42)
const failure: Effect.Effect<number, Error> = Effect.fail(
  new Error("Uh oh!")
)

const program1 = Effect.matchEffect(success, {
  onFailure: (error) =>
    Effect.succeed(`failure: ${error.message}`).pipe(
      Effect.tap(Effect.log)
    ),
  onSuccess: (value) =>
    Effect.succeed(`success: ${value}`).pipe(Effect.tap(Effect.log))
})

console.log(Effect.runSync(program1))
// Output:
// timestamp=... level=INFO fiber=#0 message="success: 42"
// success: 42

const program2 = Effect.matchEffect(failure, {
  onFailure: (error) =>
    Effect.succeed(`failure: ${error.message}`).pipe(
      Effect.tap(Effect.log)
    ),
  onSuccess: (value) =>
    Effect.succeed(`success: ${value}`).pipe(Effect.tap(Effect.log))
})

console.log(Effect.runSync(program2))
// Output:
// timestamp=... level=INFO fiber=#1 message="failure: Uh oh!"
// failure: Uh oh!

----------------------------------------

TITLE: Defining Linear Schedule Function in TypeScript
DESCRIPTION: Declares a function that creates a schedule with linearly increasing delays. It takes a base duration as input and returns a Schedule of Duration type. The delay increases linearly with each recurrence, following the formula: delay = base * n, where n is the number of executions.

LANGUAGE: typescript
CODE:
declare const linear: (base: Duration.DurationInput) => Schedule<Duration.Duration>

----------------------------------------

TITLE: Creating a Daemon Fiber with Effect.forkDaemon in TypeScript
DESCRIPTION: This example demonstrates how to create a daemon fiber using Effect.forkDaemon. It creates a background task that logs a message every second, independent of its parent fiber's lifecycle.

LANGUAGE: typescript
CODE:
import { Effect, Console, Schedule } from "effect"

// Daemon fiber that logs a message repeatedly every second
const daemon = Effect.repeat(
  Console.log("daemon: still running!"),
  Schedule.fixed("1 second")
)

const parent = Effect.gen(function* () {
  console.log("parent: started!")
  // Daemon fiber running independently
  yield* Effect.forkDaemon(daemon)
  yield* Effect.sleep("3 seconds")
  console.log("parent: finished!")
})

Effect.runFork(parent)
// Output:
// parent: started!
// daemon: still running!
// daemon: still running!
// daemon: still running!
// parent: finished!
// daemon: still running!
// daemon: still running!
// daemon: still running!
// daemon: still running!
// daemon: still running!
// ...etc...

----------------------------------------

TITLE: Effect.validate Function Signature in TypeScript
DESCRIPTION: Provides the TypeScript function signature for Effect.validate, detailing its parameters and return types. It includes options for controlling concurrency and batching behavior.

LANGUAGE: typescript
CODE:
declare const validate: { <B, E1, R1>(that: Effect<B, E1, R1>, options?: { readonly concurrent?: boolean | undefined; readonly batching?: boolean | "inherit" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): <A, E, R>(self: Effect<A, E, R>) => Effect<[A, B], E1 | E, R1 | R>; <A, E, R, B, E1, R1>(self: Effect<A, E, R>, that: Effect<B, E1, R1>, options?: { readonly concurrent?: boolean | undefined; readonly batching?: boolean | "inherit" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): Effect<[A, B], E | E1, R | R1>; }

----------------------------------------

TITLE: Merging Streams with Scheduling in TypeScript using Effect Library
DESCRIPTION: Demonstrates how to merge two streams with different scheduling intervals. The example creates two streams with values 1-3 and 4-6, schedules them with different time intervals (100ms and 200ms), and merges them into a single stream.

LANGUAGE: typescript
CODE:
import { Effect, Schedule, Stream } from "effect"

const s1 = Stream.make(1, 2, 3).pipe(
  Stream.schedule(Schedule.spaced("100 millis"))
)
const s2 = Stream.make(4, 5, 6).pipe(
  Stream.schedule(Schedule.spaced("200 millis"))
)

const stream = Stream.merge(s1, s2)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 1, 4, 2, 3, 5, 6 ] }

LANGUAGE: typescript
CODE:
declare const merge: { <A2, E2, R2>(that: Stream<A2, E2, R2>, options?: { readonly haltStrategy?: HaltStrategy.HaltStrategyInput | undefined; } | undefined): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>, options?: { readonly haltStrategy?: HaltStrategy.HaltStrategyInput | undefined; } | undefined): Stream<A | A2, E | E2, R | R2>; }

----------------------------------------

TITLE: Monitoring Fiber Count with Effect.supervised in TypeScript
DESCRIPTION: This example demonstrates how to use Effect.supervised to monitor the number of active fibers during a Fibonacci number calculation. It showcases fiber supervision, scheduling, and concurrent execution in Effect.

LANGUAGE: typescript
CODE:
import { Effect, Supervisor, Schedule, Fiber, FiberStatus } from "effect"

// Main program that monitors fibers while calculating a Fibonacci number
const program = Effect.gen(function* () {
  // Create a supervisor to track child fibers
  const supervisor = yield* Supervisor.track

  // Start a Fibonacci calculation, supervised by the supervisor
  const fibFiber = yield* fib(20).pipe(
    Effect.supervised(supervisor),
    // Fork the Fibonacci effect into a fiber
    Effect.fork
  )

  // Define a schedule to periodically monitor the fiber count every 500ms
  const policy = Schedule.spaced("500 millis").pipe(
    Schedule.whileInputEffect((_) =>
      Fiber.status(fibFiber).pipe(
        // Continue while the Fibonacci fiber is not done
        Effect.andThen((status) => status !== FiberStatus.done)
      )
    )
  )

  // Start monitoring the fibers, using the supervisor to track the count
  const monitorFiber = yield* monitorFibers(supervisor).pipe(
    // Repeat the monitoring according to the schedule
    Effect.repeat(policy),
    // Fork the monitoring into its own fiber
    Effect.fork
  )

  // Join the monitor and Fibonacci fibers to ensure they complete
  yield* Fiber.join(monitorFiber)
  const result = yield* Fiber.join(fibFiber)

  console.log(`fibonacci result: ${result}`)
})

// Function to monitor and log the number of active fibers
const monitorFibers = (
  supervisor: Supervisor.Supervisor<Array<Fiber.RuntimeFiber<any, any>>>
): Effect.Effect<void> =>
  Effect.gen(function* () {
    const fibers = yield* supervisor.value // Get the current set of fibers
    console.log(`number of fibers: ${fibers.length}`)
  })

// Recursive Fibonacci calculation, spawning fibers for each recursive step
const fib = (n: number): Effect.Effect<number> =>
  Effect.gen(function* () {
    if (n <= 1) {
      return 1
    }
    yield* Effect.sleep("500 millis") // Simulate work by delaying

    // Fork two fibers for the recursive Fibonacci calls
    const fiber1 = yield* Effect.fork(fib(n - 2))
    const fiber2 = yield* Effect.fork(fib(n - 1))

    // Join the fibers to retrieve their results
    const v1 = yield* Fiber.join(fiber1)
    const v2 = yield* Fiber.join(fiber2)

    return v1 + v2 // Combine the results
  })

Effect.runPromise(program)
// Output:
// number of fibers: 0
// number of fibers: 2
// number of fibers: 6
// number of fibers: 14
// number of fibers: 30
// number of fibers: 62
// number of fibers: 126
// number of fibers: 254
// number of fibers: 510
// number of fibers: 1022
// number of fibers: 2034
// number of fibers: 3795
// number of fibers: 5810
// number of fibers: 6474
// number of fibers: 4942
// number of fibers: 2515
// number of fibers: 832
// number of fibers: 170
// number of fibers: 18
// number of fibers: 0
// fibonacci result: 10946

----------------------------------------

TITLE: Retrieving Runtime Flags in Effect TypeScript
DESCRIPTION: A function that returns an Effect containing the current runtime flags. Runtime flags govern the behavior and features of the Effect runtime system. The effect cannot fail (never) and has no requirements (never).

LANGUAGE: typescript
CODE:
declare const getRuntimeFlags: Effect<RuntimeFlags.RuntimeFlags, never, never>

----------------------------------------

TITLE: Implementing Array.containsWith in TypeScript with Effect Library
DESCRIPTION: Creates a function to check if an array contains a value using a custom equivalence function. It demonstrates how to use the containsWith function from the Effect library's Array module to create a predicate and apply it to an array.

LANGUAGE: typescript
CODE:
import { Array, pipe } from "effect"

const isEquivalent = (a: number, b: number) => a === b
const containsNumber = Array.containsWith(isEquivalent)
const result = pipe([1, 2, 3, 4], containsNumber(3))
console.log(result) // true

----------------------------------------

TITLE: Effect.partition Function Signature in TypeScript
DESCRIPTION: The type signature for the Effect.partition function, showing its polymorphic nature and support for various options including concurrency control and batching behavior.

LANGUAGE: typescript
CODE:
declare const partition: { <A, B, E, R>(f: (a: A, i: number) => Effect<B, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): (elements: Iterable<A>) => Effect<[excluded: Array<E>, satisfying: Array<B>], never, R>; <A, B, E, R>(elements: Iterable<A>, f: (a: A, i: number) => Effect<B, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): Effect<[excluded: Array<E>, satisfying: Array<B>], never, R>; }

----------------------------------------

TITLE: Declaring contextWith Function in TypeScript
DESCRIPTION: Defines the contextWith function which takes a transformation function and applies it to the effect's context. It returns the transformed result within the effect. This function is pure and does not allow for effectful transformations.

LANGUAGE: typescript
CODE:
declare const contextWith: <R, A>(f: (context: Context.Context<R>) => A) => Effect<A, never, R>

----------------------------------------

TITLE: Handling Interruption with Cleanup in Effect.async
DESCRIPTION: Shows how to use Effect.async to wrap a long-running file write operation with cleanup functionality. It demonstrates handling interruption by returning a cleanup effect that deletes the file if the operation is interrupted.

LANGUAGE: typescript
CODE:
import { Effect, Fiber } from "effect"
import * as NodeFS from "node:fs"

// Simulates a long-running operation to write to a file
const writeFileWithCleanup = (filename: string, data: string) =>
  Effect.async<void, Error>((resume) => {
    const writeStream = NodeFS.createWriteStream(filename)

    // Start writing data to the file
    writeStream.write(data)

    // When the stream is finished, resume with success
    writeStream.on("finish", () => resume(Effect.void))

    // In case of an error during writing, resume with failure
    writeStream.on("error", (err) => resume(Effect.fail(err)))

    // Handle interruption by returning a cleanup effect
    return Effect.sync(() => {
      console.log(`Cleaning up ${filename}`)
      NodeFS.unlinkSync(filename)
    })
  })

const program = Effect.gen(function* () {
  const fiber = yield* Effect.fork(
    writeFileWithCleanup("example.txt", "Some long data...")
  )
  // Simulate interrupting the fiber after 1 second
  yield* Effect.sleep("1 second")
  yield* Fiber.interrupt(fiber) // This will trigger the cleanup
})

// Run the program
Effect.runPromise(program)
// Output:
// Cleaning up example.txt

----------------------------------------

TITLE: Transforming TMap Values Using STM in TypeScript
DESCRIPTION: Defines a function that atomically updates all values in a TMap using a transactional function. The operation is performed within an STM transaction context, allowing for atomic updates across multiple values.

LANGUAGE: typescript
CODE:
declare const transformValuesSTM: { <V, R, E>(f: (value: V) => STM.STM<V, E, R>): <K>(self: TMap<K, V>) => STM.STM<void, E, R>; <K, V, R, E>(self: TMap<K, V>, f: (value: V) => STM.STM<V, E, R>): STM.STM<void, E, R>; }

----------------------------------------

TITLE: TypeScript Function Signature for Effect.orElse
DESCRIPTION: Provides the TypeScript function signature for the Effect.orElse method, showing its type parameters and return types for different use cases.

LANGUAGE: typescript
CODE:
declare const orElse: { <A2, E2, R2>(that: LazyArg<Effect<A2, E2, R2>>): <A, E, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, that: LazyArg<Effect<A2, E2, R2>>): Effect<A2 | A, E2, R2 | R>; }

----------------------------------------

TITLE: Effect.forkDaemon Function Signature in TypeScript
DESCRIPTION: This code snippet shows the TypeScript signature of the Effect.forkDaemon function. It takes an Effect as input and returns an Effect that produces a RuntimeFiber.

LANGUAGE: typescript
CODE:
declare const forkDaemon: <A, E, R>(self: Effect<A, E, R>) => Effect<Fiber.RuntimeFiber<A, E>, never, R>

----------------------------------------

TITLE: Defining Stream.find Function in TypeScript
DESCRIPTION: Declares the 'find' function for Stream operations. It takes a predicate or refinement and returns a function that processes a Stream to find the first matching element. The function supports both refinement and predicate operations on various stream types.

LANGUAGE: typescript
CODE:
declare const find: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): <E, R>(self: Stream<A, E, R>) => Stream<B, E, R>; <A>(predicate: Predicate<NoInfer<A>>): <E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R, B extends A>(self: Stream<A, E, R>, refinement: Refinement<A, B>): Stream<B, E, R>; <A, E, R>(self: Stream<A, E, R>, predicate: Predicate<A>): Stream<A, E, R>; }

----------------------------------------

TITLE: Defining Deferred Interface in TypeScript
DESCRIPTION: Defines the Deferred interface, which represents an asynchronous variable that can be set once. It extends Effect.Effect and includes internal state management and fiber coordination properties.

LANGUAGE: typescript
CODE:
export interface Deferred<in out A, in out E = never> extends Effect.Effect<A, E>, Deferred.Variance<A, E> {
  /** @internal */
  readonly state: MutableRef.MutableRef<internal.State<A, E>>
  /** @internal */
  readonly blockingOn: FiberId.FiberId
  readonly [Unify.typeSymbol]?: unknown
  readonly [Unify.unifySymbol]?: DeferredUnify<this>
  readonly [Unify.ignoreSymbol]?: DeferredUnifyIgnore
}

----------------------------------------

TITLE: Using Effect.validateAll in TypeScript
DESCRIPTION: Demonstrates how to use Effect.validateAll to process a collection of numbers, logging successful items and accumulating errors for items that don't meet a condition.

LANGUAGE: typescript
CODE:
import { Effect, Console } from "effect"

//      ┌─── Effect<number[], [string, ...string[]], never>
//      ▼
const program = Effect.validateAll([1, 2, 3, 4, 5], (n) => {
  if (n < 4) {
    return Console.log(`item ${n}`).pipe(Effect.as(n))
  } else {
    return Effect.fail(`${n} is not less that 4`)
  }
})

Effect.runPromiseExit(program).then(console.log)
// Output:
// item 1
// item 2
// item 3
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: {
//     _id: 'Cause',
//     _tag: 'Fail',
//     failure: [ '4 is not less that 4', '5 is not less that 4' ]
//   }
// }

----------------------------------------

TITLE: Demonstrating Array.bindTo Usage in TypeScript
DESCRIPTION: This example illustrates how to use Array.bindTo to create a new array by iterating over existing arrays and applying conditions and transformations. It also shows an equivalent implementation using nested loops for comparison.

LANGUAGE: typescript
CODE:
import { Array, pipe } from "effect"

const doResult = pipe(
  Array.Do,
  Array.bind("x", () => [1, 3, 5]),
  Array.bind("y", () => [2, 4, 6]),
  Array.filter(({ x, y }) => x < y), // condition
  Array.map(({ x, y }) => [x, y] as const) // transformation
)
console.log(doResult) // [[1, 2], [1, 4], [1, 6], [3, 4], [3, 6], [5, 6]]

// equivalent
const x = [1, 3, 5],
      y = [2, 4, 6],
      result = [];
for(let i = 0; i < x.length; i++) {
  for(let j = 0; j < y.length; j++) {
    const _x = x[i], _y = y[j];
    if(_x < _y) result.push([_x, _y] as const)
  }
}

----------------------------------------

TITLE: Declaring Effect.runtime Function in TypeScript
DESCRIPTION: This snippet declares the Effect.runtime function, which returns an effect that accesses the runtime. It can be used to execute tasks unsafely and is useful for integration with legacy code that must call back into Effect code.

LANGUAGE: typescript
CODE:
declare const runtime: <R = never>() => Effect<Runtime.Runtime<R>, never, R>

----------------------------------------

TITLE: Declaring Effect.forkAll Function in TypeScript
DESCRIPTION: Defines the forkAll function in the Effect module. This function forks multiple effects and returns a composite fiber that produces a list of their results in order. It supports options for discarding results and handles different input scenarios.

LANGUAGE: typescript
CODE:
declare const forkAll: { (options?: { readonly discard?: false | undefined; } | undefined): <Eff extends Effect<any, any, any>>(effects: Iterable<Eff>) => Effect<Fiber.Fiber<Array<Effect.Success<Eff>>, Effect.Error<Eff>>, never, Effect.Context<Eff>>; (options: { readonly discard: true; }): <Eff extends Effect<any, any, any>>(effects: Iterable<Eff>) => Effect<void, never, Effect.Context<Eff>>; <Eff extends Effect<any, any, any>>(effects: Iterable<Eff>, options?: { readonly discard?: false | undefined; } | undefined): Effect<Fiber.Fiber<Array<Effect.Success<Eff>>, Effect.Error<Eff>>, never, Effect.Context<Eff>>; <Eff extends Effect<any, any, any>>(effects: Iterable<Eff>, options: { readonly discard: true; }): Effect<void, never, Effect.Context<Eff>>; }

----------------------------------------

TITLE: Racing One Failing and One Successful Effect in TypeScript
DESCRIPTION: Shows racing two effects where one fails and the other succeeds, demonstrating that the successful effect completes.

LANGUAGE: typescript
CODE:
import { Effect, Console } from "effect"

const task1 = Effect.fail("task1").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Console.log("task1 done")),
  Effect.onInterrupt(() => Console.log("task1 interrupted"))
)
const task2 = Effect.succeed("task2").pipe(
  Effect.delay("200 millis"),
  Effect.tap(Console.log("task2 done")),
  Effect.onInterrupt(() => Console.log("task2 interrupted"))
)

const program = Effect.race(task1, task2)

Effect.runFork(program)
// Output:
// task2 done

----------------------------------------

TITLE: Serving HttpApp with HttpServer in TypeScript
DESCRIPTION: The 'serve' function builds an HttpApp from an HttpApi instance and serves it using an HttpServer. It allows for an optional middleware function to be applied to the HttpApp before serving. The function returns a Layer that includes HttpServer, HttpRouter, and other related services.

LANGUAGE: typescript
CODE:
declare const serve: <R = never>(middleware?: (httpApp: HttpApp.Default) => HttpApp.Default<never, R>) => Layer.Layer<never, never, HttpServer.HttpServer | HttpRouter.HttpRouter.DefaultServices | Exclude<R, Scope | HttpServerRequest.HttpServerRequest> | HttpApi.Api>

----------------------------------------

TITLE: Using Effect.takeUntil in TypeScript
DESCRIPTION: Demonstrates how to use the Effect.takeUntil function to take elements from an array until a condition is met. The example takes numbers from an array until a number greater than 3 is encountered.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

const numbers = [1, 2, 3, 4, 5, 6]
const predicate = (n: number, i: number) => Effect.succeed(n > 3)

const program = Effect.gen(function*() {
  const result = yield* Effect.takeUntil(numbers, predicate)
  console.log(result)
})

Effect.runFork(program)
// Output: [ 1, 2, 3, 4 ]

----------------------------------------

TITLE: Implementing Layer.scoped Function in TypeScript
DESCRIPTION: Defines a function that constructs a layer from a specified scoped effect. It supports two overloads - one taking just a context tag and returning a function, and another taking both a tag and effect directly. The function handles scope management for the created layer.

LANGUAGE: typescript
CODE:
declare const scoped: {
  <I, S>(tag: Context.Tag<I, S>): <E, R>(effect: Effect.Effect<Types.NoInfer<S>, E, R>) => Layer<I, E, Exclude<R, Scope.Scope>>;
  <I, S, E, R>(tag: Context.Tag<I, S>, effect: Effect.Effect<Types.NoInfer<S>, E, R>): Layer<I, E, Exclude<R, Scope.Scope>>;
}

----------------------------------------

TITLE: Using Effect.fromNullable for Null Safety in TypeScript
DESCRIPTION: Demonstrates how to use Effect.fromNullable to handle potentially null values in a type-safe way. Shows examples of both successful and failing cases when working with nullable values.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

//      ┌─── Effect<number, NoSuchElementException, never>
//      ▼
const maybe1 = Effect.fromNullable(1)

Effect.runPromiseExit(maybe1).then(console.log)
// Output:
// { _id: 'Exit', _tag: 'Success', value: 1 }

//      ┌─── Effect<number, NoSuchElementException, never>
//      ▼
const maybe2 = Effect.fromNullable(null as number | null)

Effect.runPromiseExit(maybe2).then(console.log)
// Output:
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: {
//     _id: 'Cause',
//     _tag: 'Fail',
//     failure: { _tag: 'NoSuchElementException' }
//   }
// }

LANGUAGE: typescript
CODE:
declare const fromNullable: <A>(value: A) => Effect<NonNullable<A>, Cause.NoSuchElementException>

----------------------------------------

TITLE: Declaring serviceFunctionEffect Function in TypeScript
DESCRIPTION: Defines a function that creates a service-based effect producer. It takes a service getter and a function that uses the service to create an effect-producing function. The resulting function combines the service retrieval with the effect production.

LANGUAGE: typescript
CODE:
declare const serviceFunctionEffect: <T extends Effect<any, any, any>, Args extends Array<any>, A, E, R>(getService: T, f: (_: Effect.Success<T>) => (...args: Args) => Effect<A, E, R>) => (...args: Args) => Effect<A, E | Effect.Error<T>, R | Effect.Context<T>>

----------------------------------------

TITLE: Using Effect.orElseSucceed in TypeScript
DESCRIPTION: Demonstrates how to use the Effect.orElseSucceed function to ensure an effect always succeeds by replacing failures with a default success value. The example shows a validation function that may fail, and how orElseSucceed is used to provide a fallback value.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

const validate = (age: number): Effect.Effect<number, string> => {
  if (age < 0) {
    return Effect.fail("NegativeAgeError")
  } else if (age < 18) {
    return Effect.fail("IllegalAgeError")
  } else {
    return Effect.succeed(age)
  }
}

const program = Effect.orElseSucceed(validate(-1), () => 18)

console.log(Effect.runSyncExit(program))
// Output:
// { _id: 'Exit', _tag: 'Success', value: 18 }

----------------------------------------

TITLE: Implementing Stream.zipAllSortedByKeyRight in TypeScript
DESCRIPTION: Defines a function that zips two sorted streams by distinct keys, keeping only values from the second stream and using a default value for missing entries. The operation maintains constant space complexity for potentially unbounded streams, requiring pre-sorted input streams with distinct keys.

LANGUAGE: typescript
CODE:
declare const zipAllSortedByKeyRight: {
  <K, A2, E2, R2>(options: {
    readonly other: Stream<readonly [K, A2], E2, R2>;
    readonly defaultOther: A2;
    readonly order: Order.Order<K>;
  }): <A, E, R>(self: Stream<readonly [K, A], E, R>) => Stream<[K, A2], E2 | E, R2 | R>;
  <A, E, R, K, A2, E2, R2>(
    self: Stream<readonly [K, A], E, R>,
    options: {
      readonly other: Stream<readonly [K, A2], E2, R2>;
      readonly defaultOther: A2;
      readonly order: Order.Order<K>;
    }
  ): Stream<[K, A2], E | E2, R | R2>;
}

----------------------------------------

TITLE: Adding Finalizer on Interruption in Effect
DESCRIPTION: Illustrates how to add a finalizer that executes when an effect is interrupted. The finalizer logs the exit status and the effect is explicitly interrupted.

LANGUAGE: typescript
CODE:
import { Effect, Console } from "effect"

//      ┌─── Effect<never, never, Scope>
//      ▼
const program = Effect.gen(function* () {
  yield* Effect.addFinalizer((exit) =>
    Console.log(`Finalizer executed. Exit status: ${exit._tag}`)
  )
  return yield* Effect.interrupt
})

// Wrapping the effect in a scope
//
//      ┌─── Effect<never, never, never>
//      ▼
const runnable = Effect.scoped(program)

Effect.runPromiseExit(runnable).then(console.log)

----------------------------------------

TITLE: Implementing Config.all Function in TypeScript
DESCRIPTION: Defines a function that constructs a config from either an iterable of configs or a record of configs. The function handles type inference for both array-like and record-like inputs, preserving the structure of the input in the resulting type.

LANGUAGE: typescript
CODE:
declare const all: <const Arg extends Iterable<Config<any>> | Record<string, Config<any>>>(arg: Arg) => Config<[Arg] extends [ReadonlyArray<Config<any>>] ? { -readonly [K in keyof Arg]: [Arg[K]] extends [Config<infer A>] ? A : never; } : [Arg] extends [Iterable<Config<infer A>>] ? Array<A> : [Arg] extends [Record<string, Config<any>>] ? { -readonly [K in keyof Arg]: [Arg[K]] extends [Config<infer A>] ? A : never; } : never>

----------------------------------------

TITLE: Implementing Cumulative Sum Using Stream.scan in TypeScript
DESCRIPTION: Demonstrates how to use Stream.scan to calculate running sum of numbers in a stream. The scan operation maintains a state (accumulator) and applies a function to each element, producing all intermediate results.

LANGUAGE: typescript
CODE:
import { Effect, Stream } from "effect"

const stream = Stream.range(1, 6).pipe(Stream.scan(0, (a, b) => a + b))

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 0,  1,  3, 6, 10, 15, 21 ] }

LANGUAGE: typescript
CODE:
declare const scan: { <S, A>(s: S, f: (s: S, a: A) => S): <E, R>(self: Stream<A, E, R>) => Stream<S, E, R>; <A, E, R, S>(self: Stream<A, E, R>, s: S, f: (s: S, a: A) => S): Stream<S, E, R>; }

----------------------------------------

TITLE: Using Array.cartesian with TypeScript in Effect Library
DESCRIPTION: Demonstrates how to use the Array.cartesian function to create a cross product of two arrays. The function combines each element of the first array with each element of the second array to create pairs.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const result = Array.cartesian([1, 2], ["a", "b"])
console.log(result) // [[1, "a"], [1, "b"], [2, "a"], [2, "b"]]

LANGUAGE: typescript
CODE:
declare const cartesian: { <B>(that: ReadonlyArray<B>): <A>(self: ReadonlyArray<A>) => Array<[A, B]>; <A, B>(self: ReadonlyArray<A>, that: ReadonlyArray<B>): Array<[A, B]>; }

----------------------------------------

TITLE: Providing Service to STM Effect in TypeScript
DESCRIPTION: The provideService function provides a single service to an STM effect. It takes a context tag and a resource, and returns a new STM effect with the provided service. For effects requiring multiple services, provideEnvironment should be used instead.

LANGUAGE: typescript
CODE:
declare const provideService: {
  <I, S>(tag: Context.Tag<I, S>, resource: NoInfer<S>): <A, E, R>(self: STM<A, E, R>) => STM<A, E, Exclude<R, I>>;
  <A, E, R, I, S>(self: STM<A, E, R>, tag: Context.Tag<I, S>, resource: NoInfer<S>): STM<A, E, Exclude<R, I>>;
}

----------------------------------------

TITLE: Defining Sink Interface in TypeScript
DESCRIPTION: Defines a generic Sink interface that consumes elements of type In, may fail with error type E, and produces a value of type A with potential leftovers of type L. The interface extends Sink.Variance and Pipeable.

LANGUAGE: typescript
CODE:
export interface Sink<out A, in In = unknown, out L = never, out E = never, out R = never>
  extends Sink.Variance<A, In, L, E, R>, Pipeable
{}

----------------------------------------

TITLE: Parsing JSON with Schema.parseJson in TypeScript
DESCRIPTION: Demonstrates usage of Schema.parseJson to convert JSON strings into unknown or typed objects. It shows basic usage and usage with a custom schema for type conversion.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import * as Schema from "effect/Schema"

assert.deepStrictEqual(Schema.decodeUnknownSync(Schema.parseJson())(`{"a":"1"}`), { a: "1" })
assert.deepStrictEqual(Schema.decodeUnknownSync(Schema.parseJson(Schema.Struct({ a: Schema.NumberFromString })))(`{"a":"1"}`), { a: 1 })

----------------------------------------

TITLE: Converting Channel to Stream in TypeScript
DESCRIPTION: The toStream function converts a Channel to a Stream. It takes a Channel that emits chunks of elements and converts it to a Stream of individual elements. The function preserves error and environment types.

LANGUAGE: typescript
CODE:
declare const toStream: <OutElem, OutErr, OutDone, Env>(self: Channel<Chunk.Chunk<OutElem>, unknown, OutErr, unknown, OutDone, unknown, Env>) => Stream.Stream<OutElem, OutErr, Env>

----------------------------------------

TITLE: Using Effect.onError for Error Handling in TypeScript
DESCRIPTION: Demonstrates how to use Effect.onError to handle different types of failures including regular errors, defects, and interruptions. The cleanup handler logs the failure cause and runs uninterruptibly when the effect fails.

LANGUAGE: typescript
CODE:
import { Console, Effect } from "effect"

// This handler logs the failure cause when the effect fails
const handler = Effect.onError((cause) =>
  Console.log(`Cleanup completed: ${cause}`)
)

// Define a successful effect
const success = Console.log("Task completed").pipe(
  Effect.as("some result"),
  handler
)

Effect.runFork(success)
// Output:
// Task completed

// Define a failing effect
const failure = Console.log("Task failed").pipe(
  Effect.andThen(Effect.fail("some error")),
  handler
)

Effect.runFork(failure)
// Output:
// Task failed
// Cleanup completed: Error: some error

// Define a failing effect
const defect = Console.log("Task failed with defect").pipe(
  Effect.andThen(Effect.die("Boom!")),
  handler
)

Effect.runFork(defect)
// Output:
// Task failed with defect
// Cleanup completed: Error: Boom!

// Define an interrupted effect
const interruption = Console.log("Task interrupted").pipe(
  Effect.andThen(Effect.interrupt),
  handler
)

Effect.runFork(interruption)
// Output:
// Task interrupted
// Cleanup completed: All fibers interrupted without errors.

----------------------------------------

TITLE: Stream.take Function Signature in TypeScript
DESCRIPTION: Provides the TypeScript function signature for the Stream.take function. It shows two overloads: one where the number of elements is passed first, and another where the stream is passed first.

LANGUAGE: typescript
CODE:
declare const take: { (n: number): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, n: number): Stream<A, E, R>; }

----------------------------------------

TITLE: Implementing MessagePack RPC Serialization Layer in TypeScript
DESCRIPTION: Defines a Layer for RPC serialization that uses MessagePack format. MessagePack provides a more compact binary format than JSON/NDJSON and has better support for binary data. This layer can be used for efficient data serialization in RPC communications.

LANGUAGE: typescript
CODE:
declare const layerMsgPack: Layer.Layer<RpcSerialization, never, never>

----------------------------------------

TITLE: Effect.either Type Signature
DESCRIPTION: Type signature for the Effect.either function showing its transformation of Effect<A, E, R> into Effect<Either<A, E>, never, R>.

LANGUAGE: typescript
CODE:
declare const either: <A, E, R>(self: Effect<A, E, R>) => Effect<Either.Either<A, E>, never, R>

----------------------------------------

TITLE: Implementing Fallback Configuration Using Effect.firstSuccessOf in TypeScript
DESCRIPTION: Demonstrates how to use firstSuccessOf to implement a fallback configuration system that tries multiple nodes sequentially until finding a successful configuration. The example shows configuration retrieval from multiple nodes with error handling and logging.

LANGUAGE: typescript
CODE:
import { Effect, Console } from "effect"

interface Config {
  host: string
  port: number
  apiKey: string
}

// Create a configuration object with sample values
const makeConfig = (name: string): Config => ({
  host: `${name}.example.com`,
  port: 8080,
  apiKey: "12345-abcde"
})

// Simulate retrieving configuration from a remote node
const remoteConfig = (name: string): Effect.Effect<Config, Error> =>
  Effect.gen(function* () {
    // Simulate node3 being the only one with available config
    if (name === "node3") {
      yield* Console.log(`Config for ${name} found`)
      return makeConfig(name)
    } else {
      yield* Console.log(`Unavailable config for ${name}`)
      return yield* Effect.fail(new Error(`Config not found for ${name}`))
    }
  })

// Define the master configuration and potential fallback nodes
const masterConfig = remoteConfig("master")
const nodeConfigs = ["node1", "node2", "node3", "node4"].map(remoteConfig)

// Attempt to find a working configuration,
// starting with the master and then falling back to other nodes
const config = Effect.firstSuccessOf([masterConfig, ...nodeConfigs])

// Run the effect to retrieve the configuration
const result = Effect.runSync(config)

----------------------------------------

TITLE: Demonstrating Stream.drain Usage in TypeScript
DESCRIPTION: This example shows how to use Stream.drain to create a stream that executes its effects but emits no elements. It creates a range stream, drains it, and then runs it, resulting in an empty collection.

LANGUAGE: typescript
CODE:
import { Effect, Stream } from "effect"

// We create a stream and immediately drain it.
const stream = Stream.range(1, 6).pipe(Stream.drain)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [] }

----------------------------------------

TITLE: Implementing Date Validation Filter in TypeScript using Effect Schema
DESCRIPTION: Defines a filter function that validates Date objects, rejecting invalid dates like 'new Date("Invalid Date")'. The filter takes optional annotations and returns a new schema that incorporates the date validation logic.

LANGUAGE: typescript
CODE:
declare const validDate: <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends Date>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>

----------------------------------------

TITLE: Creating Tupled Function in TypeScript
DESCRIPTION: Demonstrates how to use the tupled function to create a version of a function that accepts a single tuple argument instead of multiple arguments. The example shows creating a sumTupled function from a regular sum function.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { tupled } from "effect/Function"

const sumTupled = tupled((x: number, y: number): number => x + y)

assert.deepStrictEqual(sumTupled([1, 2]), 3)

----------------------------------------

TITLE: Implementing Stream Zipping with Custom Logic in TypeScript
DESCRIPTION: Demonstrates how to zip two streams together using a custom combining function. The example shows zipping a numeric stream with a string stream, creating pairs where the numeric value is offset by the string length.

LANGUAGE: typescript
CODE:
import { Effect, Stream } from "effect"

// We create two streams and zip them with custom logic.
const stream = Stream.zipWith(
  Stream.make(1, 2, 3, 4, 5, 6),
  Stream.make("a", "b", "c"),
  (n, s) => [n - s.length, s]
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ [ 0, 'a' ], [ 1, 'b' ], [ 2, 'c' ] ] }

----------------------------------------

TITLE: Using Effect.liftPredicate Example
DESCRIPTION: Demonstrates how to use Effect.liftPredicate to transform a simple number validation predicate into an Effect. Shows both success and failure cases when checking if a number is positive.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

const isPositive = (n: number): boolean => n > 0

// succeeds with `1`
Effect.liftPredicate(1, isPositive, n => `${n} is not positive`)

// fails with `"0 is not positive"`
Effect.liftPredicate(0, isPositive, n => `${n} is not positive`)

----------------------------------------

TITLE: Adding Finalizer on Failure in Effect
DESCRIPTION: Shows how to add a finalizer that executes when an effect fails. The finalizer logs the exit status and the effect intentionally fails with an error message.

LANGUAGE: typescript
CODE:
import { Effect, Console } from "effect"

//      ┌─── Effect<never, string, Scope>
//      ▼
const program = Effect.gen(function* () {
  yield* Effect.addFinalizer((exit) =>
    Console.log(`Finalizer executed. Exit status: ${exit._tag}`)
  )
  return yield* Effect.fail("Uh oh!")
})

// Wrapping the effect in a scope
//
//      ┌─── Effect<never, string, never>
//      ▼
const runnable = Effect.scoped(program)

Effect.runPromiseExit(runnable).then(console.log)

----------------------------------------

TITLE: Declaring filterOrDieMessage Function in TypeScript
DESCRIPTION: Declares the filterOrDieMessage function with multiple overloads to handle different use cases. It takes a predicate or refinement function and a message string, and returns a new STM action that either passes the original value or dies with a RuntimeException.

LANGUAGE: typescript
CODE:
declare const filterOrDieMessage: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>, message: string): <E, R>(self: STM<A, E, R>) => STM<B, E, R>; <A>(predicate: Predicate<NoInfer<A>>, message: string): <E, R>(self: STM<A, E, R>) => STM<A, E, R>; <A, E, R, B extends A>(self: STM<A, E, R>, refinement: Refinement<A, B>, message: string): STM<B, E, R>; <A, E, R>(self: STM<A, E, R>, predicate: Predicate<A>, message: string): STM<A, E, R>; }

----------------------------------------

TITLE: Calculating DateTime Distance using Effect Library
DESCRIPTION: Example demonstrating how to calculate the duration between two DateTime values using the distanceDuration function. The example shows creating a current timestamp and comparing it with a timestamp 1 minute later.

LANGUAGE: typescript
CODE:
import { DateTime, Effect } from "effect"

Effect.gen(function* () {
  const now = yield* DateTime.now
  const other = DateTime.add(now, { minutes: 1 })

  // returns Duration.minutes(1)
  DateTime.distanceDuration(now, other)
})

LANGUAGE: typescript
CODE:
declare const distanceDuration: { (other: DateTime): (self: DateTime) => Duration.Duration; (self: DateTime, other: DateTime): Duration.Duration; }

----------------------------------------

TITLE: Defining fromReadableStream Function in TypeScript
DESCRIPTION: Defines the fromReadableStream function which creates a Stream from a ReadableStream. It accepts options including an evaluation function, an error handler, and an optional flag to release the lock on end. It can also be called with just the evaluation function and error handler.

LANGUAGE: typescript
CODE:
declare const fromReadableStream: { <A, E>(options: { readonly evaluate: LazyArg<ReadableStream<A>>; readonly onError: (error: unknown) => E; readonly releaseLockOnEnd?: boolean | undefined; }): Stream<A, E>; <A, E>(evaluate: LazyArg<ReadableStream<A>>, onError: (error: unknown) => E): Stream<A, E>; }

----------------------------------------

TITLE: Implementing Effectful Loop with State Management in TypeScript
DESCRIPTION: Demonstrates the core logic of Effect.loop function, showing how it manages state, executes the body effect, and collects results.

LANGUAGE: typescript
CODE:
let state = initial
const result = []

while (options.while(state)) {
  result.push(options.body(state)) // Perform the effectful operation
  state = options.step(state) // Update the state
}

return result

----------------------------------------

TITLE: Using Effect.Do for Declarative Programming in TypeScript
DESCRIPTION: This example demonstrates how to use Effect.Do to create a declarative programming style. It defines variables using bind and let functions, and performs operations on them within the do simulation scope.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Effect, pipe } from "effect"

const result = pipe(
  Effect.Do,
  Effect.bind("x", () => Effect.succeed(2)),
  Effect.bind("y", () => Effect.succeed(3)),
  Effect.let("sum", ({ x, y }) => x + y)
)
assert.deepStrictEqual(Effect.runSync(result), { x: 2, y: 3, sum: 5 })

----------------------------------------

TITLE: Creating dotenv ConfigProvider in TypeScript using PlatformConfigProvider
DESCRIPTION: This function creates a dotenv ConfigProvider. It takes a string parameter 'paths' and returns an Effect that resolves to a ConfigProvider. The Effect may result in a PlatformError and requires a FileSystem dependency.

LANGUAGE: typescript
CODE:
declare const fromDotEnv: (paths: string) => Effect.Effect<ConfigProvider.ConfigProvider, PlatformError, FileSystem.FileSystem>

----------------------------------------

TITLE: Defining flatMap Function for STM Operations in TypeScript
DESCRIPTION: Declares the flatMap function for STM operations. It takes a function that transforms the result of an STM operation and returns a new STM operation. The function is overloaded to handle different parameter orders.

LANGUAGE: typescript
CODE:
declare const flatMap: { <A, A2, E1, R1>(f: (a: A) => STM<A2, E1, R1>): <E, R>(self: STM<A, E, R>) => STM<A2, E1 | E, R1 | R>; <A, E, R, A2, E1, R1>(self: STM<A, E, R>, f: (a: A) => STM<A2, E1, R1>): STM<A2, E | E1, R | R1>; }

----------------------------------------

TITLE: Repeating a Successful Effect with Delay in TypeScript
DESCRIPTION: This example demonstrates how to use Effect.repeat to execute a successful effect multiple times with a delay between repetitions. It uses a schedule that repeats twice with a 100-millisecond delay between each repetition.

LANGUAGE: typescript
CODE:
import { Effect, Schedule, Console } from "effect"

const action = Console.log("success")
const policy = Schedule.addDelay(Schedule.recurs(2), () => "100 millis")
const program = Effect.repeat(action, policy)

Effect.runPromise(program).then((n) => console.log(`repetitions: ${n}`))

----------------------------------------

TITLE: Implementing Error Fallback in TypeScript using Effect.orElse
DESCRIPTION: Demonstrates the usage of Effect.orElse to handle fallback scenarios when an effect fails. It shows examples of successful execution and fallback to an alternative effect.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

const success = Effect.succeed("success")
const failure = Effect.fail("failure")
const fallback = Effect.succeed("fallback")

// Try the success effect first, fallback is not used
const program1 = Effect.orElse(success, () => fallback)
console.log(Effect.runSync(program1))
// Output: "success"

// Try the failure effect first, fallback is used
const program2 = Effect.orElse(failure, () => fallback)
console.log(Effect.runSync(program2))
// Output: "fallback"

----------------------------------------

TITLE: Implementing Stream Error Handling with catchSome in TypeScript
DESCRIPTION: Defines a catchSome function that handles typed errors in streams by potentially switching to an alternative stream. The function takes a partial function that maps errors to optional alternative streams.

LANGUAGE: typescript
CODE:
declare const catchSome: { 
  <E, A2, E2, R2>(pf: (error: E) => Option.Option<Stream<A2, E2, R2>>): 
    <A, R>(self: Stream<A, E, R>) => Stream<A2 | A, E | E2, R2 | R>; 
  <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, 
    pf: (error: E) => Option.Option<Stream<A2, E2, R2>>): 
    Stream<A | A2, E | E2, R | R2>; 
}

----------------------------------------

TITLE: TypeScript Signature for Stream.zipLatestAll Function
DESCRIPTION: Provides the TypeScript signature for the zipLatestAll function in the Stream module. It shows the function's type definition, including its generic parameters and return type.

LANGUAGE: typescript
CODE:
declare const zipLatestAll: <T extends ReadonlyArray<Stream<any, any, any>>>(...streams: T) => Stream<[T[number]] extends [never] ? never : { [K in keyof T]: T[K] extends Stream<infer A, infer _E, infer _R> ? A : never; }, [T[number]] extends [never] ? never : T[number] extends Stream<infer _A, infer _E, infer _R> ? _E : never, [T[number]] extends [never] ? never : T[number] extends Stream<infer _A, infer _E, infer _R> ? _R : never>

----------------------------------------

TITLE: Using Effect.timeoutOption in TypeScript
DESCRIPTION: Demonstrates how to use Effect.timeoutOption to handle timeouts gracefully. The example shows two tasks with different timeout durations, illustrating successful completion and timeout scenarios.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

const task = Effect.gen(function* () {
  console.log("Start processing...")
  yield* Effect.sleep("2 seconds") // Simulates a delay in processing
  console.log("Processing complete.")
  return "Result"
})

const timedOutEffect = Effect.all([
  task.pipe(Effect.timeoutOption("3 seconds")),
  task.pipe(Effect.timeoutOption("1 second"))
])

Effect.runPromise(timedOutEffect).then(console.log)
// Output:
// Start processing...
// Processing complete.
// Start processing...
// [
//   { _id: 'Option', _tag: 'Some', value: 'Result' },
//   { _id: 'Option', _tag: 'None' }
// ]

----------------------------------------

TITLE: Combining Effects in Structs - TypeScript Effect Library
DESCRIPTION: Illustrates combining effects organized in a struct object format, maintaining the same structure in the results.

LANGUAGE: typescript
CODE:
import { Effect, Console } from "effect"

const structOfEffects = {
  a: Effect.succeed(42).pipe(Effect.tap(Console.log)),
  b: Effect.succeed("Hello").pipe(Effect.tap(Console.log))
}

const resultsAsStruct = Effect.all(structOfEffects)

Effect.runPromise(resultsAsStruct).then(console.log)

----------------------------------------

TITLE: TypeScript Signature of Option.tap Function
DESCRIPTION: This code block shows the TypeScript signature of the Option.tap function, including its overloaded versions for different parameter orders.

LANGUAGE: typescript
CODE:
declare const tap: { <A, X>(f: (a: A) => Option<X>): (self: Option<A>) => Option<A>; <A, X>(self: Option<A>, f: (a: A) => Option<X>): Option<A>; }

----------------------------------------

TITLE: Using scanRight Function in TypeScript with Effect Array Module
DESCRIPTION: Demonstrates how to use the scanRight function from the Effect Array module to accumulate values from right to left in an array, storing intermediate results.

LANGUAGE: typescript
CODE:
import { Array } from "effect";

const result = Array.scanRight([1, 2, 3, 4], 0, (acc, value) => acc + value)
console.log(result) // [10, 9, 7, 4, 0]

----------------------------------------

TITLE: Appending Elements to Arrays in TypeScript using Effect
DESCRIPTION: This snippet demonstrates how to use the Array.append function from the Effect package to add an element to the end of an array. It creates a new NonEmptyArray with the appended element.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const result = Array.append([1, 2, 3], 4);
console.log(result) // [1, 2, 3, 4]

LANGUAGE: typescript
CODE:
declare const append: { <B>(last: B): <A>(self: Iterable<A>) => NonEmptyArray<A | B>; <A, B>(self: Iterable<A>, last: B): NonEmptyArray<A | B>; }

----------------------------------------

TITLE: Creating Integer Stream Range in Effect
DESCRIPTION: Demonstrates how to create and use Stream.range to generate a sequence of numbers. The function accepts minimum and maximum values (inclusive) and an optional chunk size parameter, returning a Stream of numbers.

LANGUAGE: typescript
CODE:
import { Effect, Stream } from "effect"

// A Stream with a range of numbers from 1 to 5
const stream = Stream.range(1, 5)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 1, 2, 3, 4, 5 ] }

LANGUAGE: typescript
CODE:
declare const range: (min: number, max: number, chunkSize?: number) => Stream<number>

----------------------------------------

TITLE: Creating Tagged Enum for HTTP Errors in TypeScript
DESCRIPTION: Demonstrates how to use Data.taggedEnum to create a tagged union for HTTP error types. It defines BadRequest and NotFound error types with specific properties.

LANGUAGE: typescript
CODE:
import { Data } from "effect"

const { BadRequest, NotFound } = Data.taggedEnum<
  | { readonly _tag: "BadRequest"; readonly status: 400; readonly message: string }
  | { readonly _tag: "NotFound"; readonly status: 404; readonly message: string }
>()

const notFound = NotFound({ status: 404, message: "Not Found" })

----------------------------------------

TITLE: Creating Context Tag with Default Value in TypeScript
DESCRIPTION: Demonstrates how to create and use a context tag with a default value using Context.Reference. Shows basic implementation where the default value is automatically used when accessing the context.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Context, Effect } from "effect"

class SpecialNumber extends Context.Reference<SpecialNumber>()(
  "SpecialNumber",
  { defaultValue: () => 2048 }
) {}

//      ┌─── Effect<void, never, never>
//      ▼
const program = Effect.gen(function* () {
  const specialNumber = yield* SpecialNumber
  console.log(`The special number is ${specialNumber}`)
})

// No need to provide the SpecialNumber implementation
Effect.runPromise(program)
// Output: The special number is 2048

----------------------------------------

TITLE: Basic Pipe Usage in TypeScript
DESCRIPTION: Basic example showing how to use the pipe function to chain operations

LANGUAGE: typescript
CODE:
import { pipe } from "effect"

const result = pipe(input, func1, func2, ..., funcN)

----------------------------------------

TITLE: Using orDie to Handle Division Errors in TypeScript Effect
DESCRIPTION: Demonstrates how to use the orDie function to convert a potential division by zero error into a fiber termination. The example shows creating a divide function that returns an Effect, then using orDie to handle failure cases as defects.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

const divide = (a: number, b: number) =>
  b === 0
    ? Effect.fail(new Error("Cannot divide by zero"))
    : Effect.succeed(a / b)

//      ┌─── Effect<number, never, never>
//      ▼
const program = Effect.orDie(divide(1, 0))

Effect.runPromise(program).catch(console.error)
// Output:
// (FiberFailure) Error: Cannot divide by zero
//   ...stack trace...

----------------------------------------

TITLE: Defining Stream.flatten Function Signature in TypeScript
DESCRIPTION: Declares the type signature for the Stream.flatten function. It takes optional configuration parameters for concurrency and buffer size, and flattens a stream of streams into a single stream, preserving the order of elements.

LANGUAGE: typescript
CODE:
declare const flatten: { (options?: { readonly concurrency?: number | "unbounded" | undefined; readonly bufferSize?: number | undefined; } | undefined): <A, E2, R2, E, R>(self: Stream<Stream<A, E2, R2>, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E2, R2, E, R>(self: Stream<Stream<A, E2, R2>, E, R>, options?: { readonly concurrency?: number | "unbounded" | undefined; readonly bufferSize?: number | undefined; } | undefined): Stream<A, E2 | E, R2 | R>; }

----------------------------------------

TITLE: Concatenating Streams Using Effect Library
DESCRIPTION: Demonstrates how to concatenate two streams using Stream.concat. The example shows combining two numeric streams and collecting their results into a single chunk. The operation preserves the order of elements from both streams.

LANGUAGE: typescript
CODE:
import { Effect, Stream } from "effect"

const s1 = Stream.make(1, 2, 3)
const s2 = Stream.make(4, 5)

const stream = Stream.concat(s1, s2)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 1, 2, 3, 4, 5 ] }

LANGUAGE: typescript
CODE:
declare const concat: { <A2, E2, R2>(that: Stream<A2, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>): Stream<A | A2, E | E2, R | R2>; }

----------------------------------------

TITLE: Merging Effects with Effect.mergeAll in TypeScript
DESCRIPTION: Demonstrates how to use Effect.mergeAll to combine multiple effects into a single effect, summing their results. It shows the usage of the function with an array of effects, a zero value, and an accumulator function.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

const numbers = [Effect.succeed(1), Effect.succeed(2), Effect.succeed(3)]
const add = (sum: number, value: number, i: number) => sum + value
const zero = 0

const program = Effect.gen(function*() {
  const total = yield* Effect.mergeAll(numbers, zero, add)
  console.log(total)
})

Effect.runFork(program)
// Output: 6

----------------------------------------

TITLE: Implementing Service Function Creation in TypeScript using Effect Module
DESCRIPTION: Defines a function that creates service-based functions. It takes a service getter and a function that uses the service's success type to produce a function accepting arguments and returning an effect.

LANGUAGE: typescript
CODE:
declare const serviceFunction: <T extends Effect<any, any, any>, Args extends Array<any>, A>(getService: T, f: (_: Effect.Success<T>) => (...args: Args) => A) => (...args: Args) => Effect<A, Effect.Error<T>, Effect.Context<T>>

----------------------------------------

TITLE: Demonstrating Stream Binding in Effect
DESCRIPTION: Shows how to use Stream.Do, Stream.bind, and Stream.let to create a declarative stream pipeline that performs calculations with bound variables. The example demonstrates binding two values and computing their sum.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Chunk, Effect, pipe, Stream } from "effect"

const result = pipe(
  Stream.Do,
  Stream.bind("x", () => Stream.succeed(2)),
  Stream.bind("y", () => Stream.succeed(3)),
  Stream.let("sum", ({ x, y }) => x + y)
)
assert.deepStrictEqual(Effect.runSync(Stream.runCollect(result)), Chunk.of({ x: 2, y: 3, sum: 5 }))

----------------------------------------

TITLE: Creating HTTP API Endpoint Handler in TypeScript
DESCRIPTION: Creates a Handler for a single HTTP API endpoint with strong typing support. The handler function provides type safety for API identifiers, groups, errors, and response types through generic parameters.

LANGUAGE: typescript
CODE:
declare const handler: <ApiId extends string, Groups extends HttpApiGroup.HttpApiGroup.Any, ApiError, ApiR, const GroupName extends Groups["identifier"], const Name extends HttpApiGroup.HttpApiGroup.EndpointsWithName<Groups, GroupName>["name"], R>(_api: HttpApi.HttpApi<ApiId, Groups, ApiError, ApiR>, _groupName: GroupName, _name: Name, f: HttpApiEndpoint.HttpApiEndpoint.HandlerWithName<HttpApiGroup.HttpApiGroup.EndpointsWithName<Groups, GroupName>, Name, ApiError | HttpApiGroup.HttpApiGroup.ErrorWithName<Groups, GroupName>, R>) => HttpApiEndpoint.HttpApiEndpoint.HandlerWithName<HttpApiGroup.HttpApiGroup.EndpointsWithName<Groups, GroupName>, Name, ApiError | HttpApiGroup.HttpApiGroup.ErrorWithName<Groups, GroupName>, R>

----------------------------------------

TITLE: Using Pretty Logger in Effect
DESCRIPTION: Demonstrates how to use the pretty logger to create visually enhanced log outputs with color coding, timestamps, and structured annotations. The example shows logging multiple messages with annotations and span timing.

LANGUAGE: typescript
CODE:
import { Effect, Logger } from "effect"

const program = Effect.log("message1", "message2").pipe(
  Effect.annotateLogs({ key1: "value1", key2: "value2" }),
  Effect.withLogSpan("myspan")
)

Effect.runFork(program.pipe(Effect.provide(Logger.pretty)))
//         green --v                      v-- bold and cyan
// [07:51:54.434] INFO (#0) myspan=1ms: message1
//   message2
//    v-- bold
//   key2: value2
//   key1: value1

LANGUAGE: typescript
CODE:
declare const prettyLogger: (options?: { readonly colors?: "auto" | boolean | undefined; readonly stderr?: boolean | undefined; readonly formatDate?: ((date: Date) => string) | undefined; readonly mode?: "browser" | "tty" | "auto" | undefined; }) => Logger<unknown, void>

----------------------------------------

TITLE: Forking Child Scope in Effect.ts
DESCRIPTION: Creates a new child scope with a specified execution strategy. The child scope is automatically closed when the parent scope closes. This is part of the Effect.ts resource management system.

LANGUAGE: typescript
CODE:
declare const fork: (self: Scope, strategy: ExecutionStrategy.ExecutionStrategy) => Effect.Effect<CloseableScope>

----------------------------------------

TITLE: Using Effect.logDebug for Debug Level Logging in TypeScript
DESCRIPTION: Demonstrates how to use Effect.logDebug to output debug-level messages in an Effect-based application. The example shows setting the minimum log level to Debug to ensure debug messages are visible.

LANGUAGE: typescript
CODE:
import { Effect, Logger, LogLevel } from "effect"

const program = Effect.logDebug("message1").pipe(Logger.withMinimumLogLevel(LogLevel.Debug))

Effect.runFork(program)
// timestamp=... level=DEBUG fiber=#0 message=message1

LANGUAGE: typescript
CODE:
declare const logDebug: (...message: ReadonlyArray<any>) => Effect<void, never, never>

----------------------------------------

TITLE: Filtering Effects with Predicate in TypeScript
DESCRIPTION: Demonstrates how to use filterEffectOrElse to filter an Effect based on a predicate, with a fallback effect if the predicate fails. The example shows authentication handling where null users are filtered out.

LANGUAGE: typescript
CODE:
import { Effect, pipe } from "effect"

// Define a user interface
interface User {
  readonly name: string
}

// Simulate an asynchronous authentication function
declare const auth: () => Promise<User | null>

const program = pipe(
  Effect.promise(() => auth()),
  // Use filterEffectOrElse with an effectful predicate
  Effect.filterEffectOrElse({
    predicate: (user) => Effect.succeed(user !== null),
    orElse: (user) => Effect.fail(new Error(`Unauthorized user: ${user}`))
  }),
)

----------------------------------------

TITLE: Demonstrating Either.Do Usage with bind and let Operations in TypeScript
DESCRIPTION: Shows how to use Either.Do to create a chain of operations that bind values and compute results. The example demonstrates binding two values (x and y) and computing their sum using the let operation.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Either, pipe } from "effect"

const result = pipe(
  Either.Do,
  Either.bind("x", () => Either.right(2)),
  Either.bind("y", () => Either.right(3)),
  Either.let("sum", ({ x, y }) => x + y)
)
assert.deepStrictEqual(result, Either.right({ x: 2, y: 3, sum: 5 }))

LANGUAGE: typescript
CODE:
declare const Do: Either<{}, never>

----------------------------------------

TITLE: Using Effect.tapBoth for Logging in TypeScript
DESCRIPTION: Demonstrates how to use Effect.tapBoth to log both success and failure outcomes of a random number generation task without modifying the original effect's output.

LANGUAGE: typescript
CODE:
import { Effect, Random, Console } from "effect"

// Simulate a task that might fail
const task = Effect.filterOrFail(
  Random.nextRange(-1, 1),
  (n) => n >= 0,
  () => "random number is negative"
)

// Use tapBoth to log both success and failure outcomes
const tapping = Effect.tapBoth(task, {
  onFailure: (error) => Console.log(`failure: ${error}`),
  onSuccess: (randomNumber) =>
    Console.log(`random number: ${randomNumber}`)
})

Effect.runFork(tapping)
// Example Output:
// failure: random number is negative

----------------------------------------

TITLE: Creating a Deferred Object in TypeScript using Effect
DESCRIPTION: The make function creates a new Deferred object. It takes no parameters and returns an Effect that produces a Deferred<A, E>. The function allows for optional error type specification.

LANGUAGE: typescript
CODE:
declare const make: <A, E = never>() => Effect.Effect<Deferred<A, E>>

----------------------------------------

TITLE: Defining runForEachScoped Function in TypeScript for Effect Stream Module
DESCRIPTION: Declares the runForEachScoped function, which is similar to Stream.forEach but returns a scoped effect for controlled finalization order. It takes a function that processes each stream element and returns an Effect, and can be applied to a Stream.

LANGUAGE: typescript
CODE:
declare const runForEachScoped: { <A, X, E2, R2>(f: (a: A) => Effect.Effect<X, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect.Effect<void, E2 | E, Scope.Scope | R2 | R>; <A, E, R, X, E2, R2>(self: Stream<A, E, R>, f: (a: A) => Effect.Effect<X, E2, R2>): Effect.Effect<void, E | E2, Scope.Scope | R | R2>; }

----------------------------------------

TITLE: Creating Dual-Style Functions with Arity in TypeScript
DESCRIPTION: Demonstrates how to use the dual function to create a sum function that can be used in both data-first and data-last styles. The arity parameter is used to determine the function style.

LANGUAGE: typescript
CODE:
import { dual, pipe } from "effect/Function"

const sum = dual<
  (that: number) => (self: number) => number,
  (self: number, that: number) => number
>(2, (self, that) => self + that)

console.log(sum(2, 3)) // 5
console.log(pipe(2, sum(3))) // 5

----------------------------------------

TITLE: Defining Resource.auto Function in TypeScript
DESCRIPTION: Declares the Resource.auto function, which creates a new Resource value that is automatically refreshed based on a specified schedule. It takes an acquire effect and a policy schedule as parameters.

LANGUAGE: typescript
CODE:
declare const auto: <A, E, R, Out, R2>(acquire: Effect.Effect<A, E, R>, policy: Schedule.Schedule<Out, unknown, R2>) => Effect.Effect<Resource<A, E>, never, R | R2 | Scope.Scope>

----------------------------------------

TITLE: Running Background Effects with Effect.runFork in TypeScript
DESCRIPTION: Demonstrates how to use Effect.runFork to execute a repeating console log effect in the background using a fiber. The example shows creating a program that logs 'running...' every 200 milliseconds and then interrupts it after 500 milliseconds.

LANGUAGE: typescript
CODE:
import { Effect, Console, Schedule, Fiber } from "effect"

//      ┌─── Effect<number, never, never>
//      ▼
const program = Effect.repeat(
  Console.log("running..."),
  Schedule.spaced("200 millis")
)

//      ┌─── RuntimeFiber<number, never>
//      ▼
const fiber = Effect.runFork(program)

setTimeout(() => {
  Effect.runFork(Fiber.interrupt(fiber))
}, 500)

LANGUAGE: typescript
CODE:
declare const runFork: <A, E>(effect: Effect<A, E>, options?: Runtime.RunForkOptions) => Fiber.RuntimeFiber<A, E>

----------------------------------------

TITLE: Implementing Adjacent Grouping in Effect-TS Stream
DESCRIPTION: Function signature for groupAdjacentBy that groups stream elements based on adjacent keys. Takes a key function and returns a new stream of key-chunk pairs where chunks contain adjacent elements with the same key. Supports both curried and uncurried calling styles.

LANGUAGE: typescript
CODE:
declare const groupAdjacentBy: { <A, K>(f: (a: A) => K): <E, R>(self: Stream<A, E, R>) => Stream<[K, Chunk.NonEmptyChunk<A>], E, R>; <A, E, R, K>(self: Stream<A, E, R>, f: (a: A) => K): Stream<[K, Chunk.NonEmptyChunk<A>], E, R>; }

----------------------------------------

TITLE: Transforming Effect Errors with mapError in TypeScript
DESCRIPTION: Demonstrates how to use Effect.mapError to transform a string error into an Error object while maintaining the success value type. The example shows the type transformation from Effect<number, string, never> to Effect<number, Error, never>.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

//      ┌─── Effect<number, string, never>
//      ▼
const simulatedTask = Effect.fail("Oh no!").pipe(Effect.as(1))

//      ┌─── Effect<number, Error, never>
//      ▼
const mapped = Effect.mapError(
  simulatedTask,
  (message) => new Error(message)
)

----------------------------------------

TITLE: Implementing Stream.findEffect in TypeScript
DESCRIPTION: Function signature for findEffect that finds the first element in a stream satisfying an effectful predicate. The function is overloaded to support both curried and uncurried forms, handling effects, errors, and requirements in a type-safe manner.

LANGUAGE: typescript
CODE:
declare const findEffect: { <A, E2, R2>(predicate: (a: NoInfer<A>) => Effect.Effect<boolean, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: Stream<A, E, R>, predicate: (a: NoInfer<A>) => Effect.Effect<boolean, E2, R2>): Stream<A, E | E2, R | R2>; }

----------------------------------------

TITLE: Transforming Effect Errors with mapError in TypeScript
DESCRIPTION: Demonstrates how to use Effect.mapError to transform a string error into an Error object while maintaining the success value type. The example shows the type transformation from Effect<number, string, never> to Effect<number, Error, never>.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

//      ┌─── Effect<number, string, never>
//      ▼
const simulatedTask = Effect.fail("Oh no!").pipe(Effect.as(1))

//      ┌─── Effect<number, Error, never>
//      ▼
const mapped = Effect.mapError(
  simulatedTask,
  (message) => new Error(message)
)

----------------------------------------

TITLE: Implementing Effect Racing in TypeScript using Micro.raceFirst
DESCRIPTION: Defines a function that races two effects and returns the first one to either succeed or fail. When one effect completes, the other is immediately interrupted. This enables competitive execution of two parallel effects where only the fastest result is needed.

LANGUAGE: typescript
CODE:
declare const raceFirst: { 
  <A2, E2, R2>(that: Micro<A2, E2, R2>): 
    <A, E, R>(self: Micro<A, E, R>) => Micro<A | A2, E | E2, R | R2>; 
  <A, E, R, A2, E2, R2>(self: Micro<A, E, R>, that: Micro<A2, E2, R2>): 
    Micro<A | A2, E | E2, R | R2>; 
}

----------------------------------------

TITLE: Either.getOrElse Function Signature in TypeScript
DESCRIPTION: Provides the TypeScript function signature for Either.getOrElse. It shows the function's polymorphic nature, handling different types for Right and Left cases.

LANGUAGE: typescript
CODE:
declare const getOrElse: { <L, R2>(onLeft: (left: L) => R2): <R>(self: Either<R, L>) => R2 | R; <R, L, R2>(self: Either<R, L>, onLeft: (left: L) => R2): R | R2; }

----------------------------------------

TITLE: Effect.onInterrupt Function Signature in TypeScript
DESCRIPTION: This code snippet shows the TypeScript signature for the Effect.onInterrupt function. It defines the function's type and parameters.

LANGUAGE: typescript
CODE:
declare const onInterrupt: { <X, R2>(cleanup: (interruptors: HashSet.HashSet<FiberId.FiberId>) => Effect<X, never, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R2 | R>; <A, E, R, X, R2>(self: Effect<A, E, R>, cleanup: (interruptors: HashSet.HashSet<FiberId.FiberId>) => Effect<X, never, R2>): Effect<A, E, R | R2>; }

----------------------------------------

TITLE: Creating Config Values with Config.succeed in TypeScript
DESCRIPTION: A function that constructs a new configuration containing a specified value. It takes a generic value of type A and returns a Config<A> instance.

LANGUAGE: typescript
CODE:
declare const succeed: <A>(value: A) => Config<A>

----------------------------------------

TITLE: Creating Custom Logger with Effect Package in TypeScript
DESCRIPTION: Demonstrates how to create a custom logger using Logger.make function. The example shows creating a logger that formats messages with log levels, creating tasks with log messages, and running a program with the custom logger.

LANGUAGE: typescript
CODE:
import { Effect, Logger, LogLevel } from "effect"

const logger = Logger.make(({ logLevel, message }) => {
  globalThis.console.log(`[${logLevel.label}] ${message}`)
})

const task1 = Effect.logDebug("task1 done")
const task2 = Effect.logDebug("task2 done")

const program = Effect.gen(function*() {
  yield* Effect.log("start")
  yield* task1
  yield* task2
  yield* Effect.log("done")
}).pipe(
  Logger.withMinimumLogLevel(LogLevel.Debug),
  Effect.provide(Logger.replace(Logger.defaultLogger, logger))
)

Effect.runFork(program)
// [INFO] start
// [DEBUG] task1 done
// [DEBUG] task2 done
// [INFO] done

----------------------------------------

TITLE: Reducing an Array using Effect Library in TypeScript
DESCRIPTION: Demonstrates how to use the Array.reduce function from the Effect library to sum the elements of an array. The function takes an initial value and a reducer function to accumulate the result.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const result = Array.reduce([1, 2, 3], 0, (acc, n) => acc + n)
console.log(result) // 6

----------------------------------------

TITLE: Filtering Elements in a Stream using TypeScript
DESCRIPTION: Demonstrates how to use Stream.filter to emit only even numbers from a range of 1 to 11. The filtered stream is then collected and logged.

LANGUAGE: typescript
CODE:
import { Effect, Stream } from "effect"

const stream = Stream.range(1, 11).pipe(Stream.filter((n) => n % 2 === 0))

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 2, 4, 6, 8, 10 ] }

----------------------------------------

TITLE: Implementing Stream Halting with Duration - TypeScript
DESCRIPTION: Function signature for haltAfter, which takes a duration parameter and returns a modified stream that halts after the specified duration. The function maintains ongoing element pulls to completion when the duration expires.

LANGUAGE: typescript
CODE:
declare const haltAfter: { 
  (duration: Duration.DurationInput): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; 
  <A, E, R>(self: Stream<A, E, R>, duration: Duration.DurationInput): Stream<A, E, R>; 
}

----------------------------------------

TITLE: Defining Config.validate Function in TypeScript
DESCRIPTION: The validate function returns a config that describes the same structure as the original, but performs validation during loading. It supports both refinement and predicate-based validation.

LANGUAGE: typescript
CODE:
declare const validate: {
  <A, B extends A>(options: { readonly message: string; readonly validation: Refinement<A, B>; }): (self: Config<A>) => Config<B>;
  <A>(options: { readonly message: string; readonly validation: Predicate<A>; }): (self: Config<A>) => Config<A>;
  <A, B extends A>(self: Config<A>, options: { readonly message: string; readonly validation: Refinement<A, B>; }): Config<B>;
  <A>(self: Config<A>, options: { readonly message: string; readonly validation: Predicate<A>; }): Config<A>;
}

----------------------------------------

TITLE: Using Effect.suspend for Better Type Inference in TypeScript
DESCRIPTION: Illustrates how Effect.suspend helps TypeScript better infer types in scenarios with multiple possible effect types.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

//   Without suspend, TypeScript may struggle with type inference.
//   Inferred type:
//     (a: number, b: number) =>
//       Effect<never, Error, never> | Effect<number, never, never>
const withoutSuspend = (a: number, b: number) =>
  b === 0
    ? Effect.fail(new Error("Cannot divide by zero"))
    : Effect.succeed(a / b)

//   Using suspend to unify return types.
//   Inferred type:
//     (a: number, b: number) => Effect<number, Error, never>
const withSuspend = (a: number, b: number) =>
  Effect.suspend(() =>
    b === 0
      ? Effect.fail(new Error("Cannot divide by zero"))
      : Effect.succeed(a / b)
  )

----------------------------------------

TITLE: Subscribing to TPubSub with Scoped Effect in TypeScript
DESCRIPTION: The subscribeScoped function subscribes to a TPubSub instance, returning an Effect that can be evaluated multiple times within a scope to receive messages. It takes a TPubSub<A> as input and returns an Effect that produces a TDequeue<A>, requiring a Scope for proper resource management.

LANGUAGE: typescript
CODE:
declare const subscribeScoped: <A>(self: TPubSub<A>) => Effect.Effect<TQueue.TDequeue<A>, never, Scope.Scope>

----------------------------------------

TITLE: Conditional Effect Execution in TypeScript using Effect.whenEffect
DESCRIPTION: Demonstrates how to use Effect.whenEffect to conditionally execute an effect based on a random boolean value. The example generates a random integer only if a random boolean is true.

LANGUAGE: typescript
CODE:
import { Effect, Random } from "effect"

const randomIntOption = Random.nextInt.pipe(
  Effect.whenEffect(Random.nextBoolean)
)

console.log(Effect.runSync(randomIntOption))
// Example Output:
// { _id: 'Option', _tag: 'Some', value: 8609104974198840 }

----------------------------------------

TITLE: Declaring Effect.scope Type in TypeScript
DESCRIPTION: Type declaration for Effect.scope which provides access to the current scope in a scoped workflow. The type signature indicates it returns an Effect with Scope.Scope type parameter, never as error type, and Scope.Scope as success type.

LANGUAGE: typescript
CODE:
declare const scope: Effect<Scope.Scope, never, Scope.Scope>

----------------------------------------

TITLE: Concatenating Multiple Streams using Stream.concatAll in TypeScript
DESCRIPTION: Demonstrates how to concatenate multiple streams into a single stream using the Stream.concatAll function. The example shows combining three streams of numbers and collecting their values into a single chunk.

LANGUAGE: typescript
CODE:
import { Chunk, Effect, Stream } from "effect"

const s1 = Stream.make(1, 2, 3)
const s2 = Stream.make(4, 5)
const s3 = Stream.make(6, 7, 8)

const stream = Stream.concatAll(Chunk.make(s1, s2, s3))

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// {
//   _id: 'Chunk',
//   values: [
//     1, 2, 3, 4,
//     5, 6, 7, 8
//   ]
// }

LANGUAGE: typescript
CODE:
declare const concatAll: <A, E, R>(streams: Chunk.Chunk<Stream<A, E, R>>) => Stream<A, E, R>

----------------------------------------

TITLE: Using Effect.flip to Swap Success/Error Channels in TypeScript
DESCRIPTION: Demonstrates how to use Effect.flip to reverse the flow of an effect by converting success values to errors and error values to successes. The example shows transforming an Effect<number, string, never> into Effect<string, number, never>.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

//      ┌─── Effect<number, string, never>
//      ▼
const program = Effect.fail("Oh uh!").pipe(Effect.as(2))

//      ┌─── Effect<string, number, never>
//      ▼
const flipped = Effect.flip(program)

LANGUAGE: typescript
CODE:
declare const flip: <A, E, R>(self: Effect<A, E, R>) => Effect<E, A, R>

----------------------------------------

TITLE: Creating Sliding Bounded Queue in TypeScript using Effect TQueue
DESCRIPTION: Implements a function to create a bounded queue with a sliding strategy. The queue adds new values and drops old ones when at capacity. It's optimized for capacities that are powers of two.

LANGUAGE: typescript
CODE:
declare const sliding: <A>(requestedCapacity: number) => STM.STM<TQueue<A>>

----------------------------------------

TITLE: Implementing Stream Pagination with Effect Library in TypeScript
DESCRIPTION: Demonstrates how to use Stream.paginate to create a paginated stream that emits values based on a state and continuation function. The example shows pagination from 0 to 3, where each number is emitted and the state advances until reaching the terminal condition.

LANGUAGE: typescript
CODE:
import { Effect, Option, Stream } from "effect"

const stream = Stream.paginate(0, (n) => [
  n,
  n < 3 ? Option.some(n + 1) : Option.none()
])

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 0, 1, 2, 3 ] }

LANGUAGE: typescript
CODE:
declare const paginate: <S, A>(s: S, f: (s: S) => readonly [A, Option.Option<S>]) => Stream<A>

----------------------------------------

TITLE: Creating Scoped Stream with Resource Management in TypeScript
DESCRIPTION: Example showing how to create a single-valued stream from a scoped resource using Effect.acquireRelease. The example demonstrates resource acquisition, usage, and automatic release patterns.

LANGUAGE: typescript
CODE:
import { Console, Effect, Stream } from "effect"

// Creating a single-valued stream from a scoped resource
const stream = Stream.scoped(
 Effect.acquireRelease(
   Console.log("acquire"),
   () => Console.log("release")
 )
).pipe(
 Stream.flatMap(() => Console.log("use"))
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// acquire
// use
// release
// { _id: 'Chunk', values: [ undefined ] }

LANGUAGE: typescript
CODE:
declare const scoped: <A, E, R>(effect: Effect.Effect<A, E, R>) => Stream<A, E, Exclude<R, Scope.Scope>>

----------------------------------------

TITLE: Racing Concurrent Tasks with Effect.raceWith in TypeScript
DESCRIPTION: Demonstrates how to race two effects (task1 and task2) and handle their completion using onSelfDone and onOtherDone callbacks. The example shows task interruption and success handling.

LANGUAGE: typescript
CODE:
import { Effect, Console } from "effect"

const task1 = Effect.succeed("task1").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Console.log("task1 done")),
  Effect.onInterrupt(() =>
    Console.log("task1 interrupted").pipe(Effect.delay("100 millis"))
  )
)
const task2 = Effect.succeed("task2").pipe(
  Effect.delay("200 millis"),
  Effect.tap(Console.log("task2 done")),
  Effect.onInterrupt(() =>
    Console.log("task2 interrupted").pipe(Effect.delay("100 millis"))
  )
)

const program = Effect.raceWith(task1, task2, {
  onSelfDone: (exit) => Console.log(`task1 exited with ${exit}`),
  onOtherDone: (exit) => Console.log(`task2 exited with ${exit}`)
})

Effect.runFork(program)

----------------------------------------

TITLE: Stream.as Method Signature in TypeScript
DESCRIPTION: Provides the TypeScript signature for the Stream.as method. It shows two overloads: one for curried usage and another for direct application. The method takes a value of type B and returns a function that transforms a Stream<A, E, R> into a Stream<B, E, R>.

LANGUAGE: typescript
CODE:
declare const as: { <B>(value: B): <A, E, R>(self: Stream<A, E, R>) => Stream<B, E, R>; <A, E, R, B>(self: Stream<A, E, R>, value: B): Stream<B, E, R>; }

----------------------------------------

TITLE: Declaring serviceOptional Function in TypeScript
DESCRIPTION: Defines the serviceOptional function which retrieves a service from the context. It returns the service if available, or throws a NoSuchElementException if the service is missing. This function is useful for handling critical services in effect execution.

LANGUAGE: typescript
CODE:
declare const serviceOptional: <I, S>(tag: Context.Tag<I, S>) => Effect<S, Cause.NoSuchElementException>

----------------------------------------

TITLE: Executing Side Effect on Error in Effect Module (TypeScript)
DESCRIPTION: Demonstrates how to use the tapError function to execute a side effect when an Effect fails. The example shows logging an error message without modifying the original effect's behavior.

LANGUAGE: typescript
CODE:
import { Effect, Console } from "effect"

// Simulate a task that fails with an error
const task: Effect.Effect<number, string> = Effect.fail("NetworkError")

// Use tapError to log the error message when the task fails
const tapping = Effect.tapError(task, (error) =>
  Console.log(`expected error: ${error}`)
)

Effect.runFork(tapping)
// Output:
// expected error: NetworkError

----------------------------------------

TITLE: Combining Effects in Iterables - TypeScript Effect Library
DESCRIPTION: Shows how to combine effects from an iterable collection and process them as an array of effects.

LANGUAGE: typescript
CODE:
import { Effect, Console } from "effect"

const iterableOfEffects: Iterable<Effect.Effect<number>> = [1, 2, 3].map(
  (n) => Effect.succeed(n).pipe(Effect.tap(Console.log))
)

const resultsAsArray = Effect.all(iterableOfEffects)

Effect.runPromise(resultsAsArray).then(console.log)

----------------------------------------

TITLE: Creating Empty HashSet in TypeScript using Effect Library
DESCRIPTION: Demonstrates how to create and populate an empty HashSet using the Effect library. The example shows type specification, adding elements (including duplicates), and converting to values array. HashSet automatically handles duplicate values.

LANGUAGE: typescript
CODE:
import { HashSet, pipe } from "effect"

console.log(
  pipe(
    // Provide a type argument to create a HashSet of a specific type
    HashSet.empty<number>(),
    HashSet.add(1),
    HashSet.add(1), // Notice the duplicate
    HashSet.add(2),
    HashSet.toValues
  )
) // Output: [1, 2]

LANGUAGE: typescript
CODE:
declare const empty: <A = never>() => HashSet<A>

----------------------------------------

TITLE: Implementing Stream.flatMap in TypeScript
DESCRIPTION: Defines a flatMap operation that concatenates streams by mapping each element of the input stream to a new stream using the provided function. Supports optional configuration for concurrency, buffer size, and switch behavior.

LANGUAGE: typescript
CODE:
declare const flatMap: { <A, A2, E2, R2>(f: (a: A) => Stream<A2, E2, R2>, options?: { readonly concurrency?: number | "unbounded" | undefined; readonly bufferSize?: number | undefined; readonly switch?: boolean | undefined; } | undefined): <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, f: (a: A) => Stream<A2, E2, R2>, options?: { readonly concurrency?: number | "unbounded" | undefined; readonly bufferSize?: number | undefined; readonly switch?: boolean | undefined; } | undefined): Stream<A2, E | E2, R | R2>; }

----------------------------------------

TITLE: Logging with Level Controls in Effect TypeScript
DESCRIPTION: Demonstrates how to use Effect.logWithLevel to log messages and error causes with specified severity levels. The function accepts a LogLevel parameter and variable number of message arguments, producing formatted log output with timestamp, level, fiber ID, message and cause details.

LANGUAGE: typescript
CODE:
import { Cause, Effect, LogLevel } from "effect"

const program = Effect.logWithLevel(
  LogLevel.Error,
  "Critical error encountered",
  Cause.die("System failure!")
)

Effect.runFork(program)
// Output:
// timestamp=... level=ERROR fiber=#0 message=Critical error encountered cause="Error: System failure!"

LANGUAGE: typescript
CODE:
declare const logWithLevel: (level: LogLevel.LogLevel, ...message: ReadonlyArray<any>) => Effect<void>

----------------------------------------

TITLE: Declaring Effect.never in TypeScript
DESCRIPTION: Declares a constant 'never' of type Effect that never resolves. It's useful for long-running background tasks or simulating waiting behavior without consuming resources. This effect keeps the program alive or in a certain state without performing active work.

LANGUAGE: typescript
CODE:
declare const never: Effect<never, never, never>

----------------------------------------

TITLE: Defining slidingSize Function for Stream Operations in TypeScript
DESCRIPTION: The slidingSize function creates sliding windows of elements from a stream. It takes a chunkSize and stepSize as parameters, allowing for flexible windowing operations. The function can be used in two ways: curried or with all parameters at once.

LANGUAGE: typescript
CODE:
declare const slidingSize: {
  (chunkSize: number, stepSize: number): <A, E, R>(self: Stream<A, E, R>) => Stream<Chunk.Chunk<A>, E, R>;
  <A, E, R>(self: Stream<A, E, R>, chunkSize: number, stepSize: number): Stream<Chunk.Chunk<A>, E, R>;
}

----------------------------------------

TITLE: Implementing Array Concatenation in TypeScript Effect Library
DESCRIPTION: Declares a type-safe array concatenation function that handles both regular arrays and non-empty arrays. The function supports combining iterables while preserving type information about emptiness status of the arrays.

LANGUAGE: typescript
CODE:
declare const appendAll: { 
  <S extends Iterable<any>, T extends Iterable<any>>(that: T): 
    (self: S) => ReadonlyArray.OrNonEmpty<S, T, ReadonlyArray.Infer<S> | ReadonlyArray.Infer<T>>; 
  <A, B>(self: Iterable<A>, that: NonEmptyReadonlyArray<B>): NonEmptyArray<A | B>; 
  <A, B>(self: NonEmptyReadonlyArray<A>, that: Iterable<B>): NonEmptyArray<A | B>; 
  <A, B>(self: Iterable<A>, that: Iterable<B>): Array<A | B>; 
}

----------------------------------------

TITLE: Collecting Results with Validate Mode - TypeScript Effect Library
DESCRIPTION: Shows how to use Effect.all with 'validate' mode to collect results as Options, indicating success or failure.

LANGUAGE: typescript
CODE:
import { Effect, Console } from "effect"

const effects = [
  Effect.succeed("Task1").pipe(Effect.tap(Console.log)),
  Effect.fail("Task2: Oh no!").pipe(Effect.tap(Console.log)),
  Effect.succeed("Task3").pipe(Effect.tap(Console.log))
]

const program = Effect.all(effects, { mode: "validate" })

Effect.runPromiseExit(program).then((result) => console.log("%o", result))

----------------------------------------

TITLE: Declaring Scoped Metrics Tagging Function in TypeScript
DESCRIPTION: Function declaration for tagMetricsScoped that applies temporary tags to metrics within a scope. The function takes a key-value pair as input and returns an Effect that requires a Scope. When the scope closes, the tag is automatically removed.

LANGUAGE: typescript
CODE:
declare const tagMetricsScoped: (key: string, value: string) => Effect<void, never, Scope.Scope>

----------------------------------------

TITLE: Configuring JSON Logger in Effect Library
DESCRIPTION: This example demonstrates how to use the JSON logger in the Effect library. It shows how to create a program with logging, add annotations, and run it with the JSON logger configuration.

LANGUAGE: typescript
CODE:
import { Effect, Logger } from "effect"

const program = Effect.log("message1", "message2").pipe(
  Effect.annotateLogs({ key1: "value1", key2: "value2" }),
  Effect.withLogSpan("myspan")
)

Effect.runFork(program.pipe(Effect.provide(Logger.json)))
// {"message":["message1","message2"],"logLevel":"INFO","timestamp":"...","annotations":{"key2":"value2","key1":"value1"},"spans":{"myspan":0},"fiberId":"#0"}

----------------------------------------

TITLE: Executing Prompts with Prompt.run in TypeScript
DESCRIPTION: The run function executes a specified Prompt. It takes a Prompt<Output> as input and returns an Effect that resolves to the Output type, may throw a QuitException, and requires a Prompt.Environment.

LANGUAGE: typescript
CODE:
declare const run: <Output>(self: Prompt<Output>) => Effect<Output, QuitException, Prompt.Environment>

----------------------------------------

TITLE: Creating Web Handler from HttpApi in TypeScript
DESCRIPTION: Demonstrates how to construct an HTTP web handler from an HttpApi instance using HttpApiBuilder.toWebHandler. Shows setup of a custom API class with necessary layers and handler creation.

LANGUAGE: typescript
CODE:
import { HttpApi, HttpApiBuilder, HttpServer } from "@effect/platform"
import { Layer } from "effect"

class MyApi extends HttpApi.make("api") {}

const MyApiLive = HttpApiBuilder.api(MyApi)

const { dispose, handler } = HttpApiBuilder.toWebHandler(
  Layer.mergeAll(
    MyApiLive,
    // you could also use NodeHttpServer.layerContext, depending on your
    // server's platform
    HttpServer.layerContext
  )
)

LANGUAGE: typescript
CODE:
declare const toWebHandler: <LA, LE>(layer: Layer.Layer<LA | HttpApi.Api | HttpRouter.HttpRouter.DefaultServices, LE>, options?: { readonly middleware?: (httpApp: HttpApp.Default) => HttpApp.Default<never, HttpApi.Api | Router | HttpRouter.HttpRouter.DefaultServices>; readonly memoMap?: Layer.MemoMap; }) => { readonly handler: (request: Request, context?: Context.Context<never> | undefined) => Promise<Response>; readonly dispose: () => Promise<void>; }

----------------------------------------

TITLE: Collecting Stream Elements with runCollect in TypeScript
DESCRIPTION: Function that runs a stream and accumulates all of its elements into a Chunk. Takes a Stream<A, E, R> as input and returns an Effect containing a Chunk of collected elements.

LANGUAGE: typescript
CODE:
declare const runCollect: <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<Chunk.Chunk<A>, E, R>

----------------------------------------

TITLE: Merging Tagged Streams in TypeScript using effect/Stream
DESCRIPTION: Demonstrates how to merge a struct of streams into a single stream of tagged values using the Stream.mergeWithTag function. The example shows merging two streams with different value types into a single stream with tagged union types.

LANGUAGE: typescript
CODE:
import { Stream } from "effect"
// Stream.Stream<{ _tag: "a"; value: number; } | { _tag: "b"; value: string; }>
const res = Stream.mergeWithTag({
   a: Stream.make(0),
   b: Stream.make("")
}, { concurrency: "unbounded" })

----------------------------------------

TITLE: Using Option.getOrThrow in TypeScript
DESCRIPTION: Demonstrates how to use Option.getOrThrow to extract values from Option types, showing both successful extraction and error throwing cases

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Option } from "effect"

assert.deepStrictEqual(Option.getOrThrow(Option.some(1)), 1)
assert.throws(() => Option.getOrThrow(Option.none()))

----------------------------------------

TITLE: Using Effect.parallelErrors for Concurrent Error Handling in TypeScript
DESCRIPTION: Demonstrates how to use Effect.parallelErrors to combine multiple concurrent operation errors into a single error array. The example shows running multiple failing effects concurrently and capturing all their errors together.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

const fail1 = Effect.fail("Oh uh!")
const fail2 = Effect.fail("Oh no!")
const die = Effect.dieMessage("Boom!")

// Run all effects concurrently and capture all errors
const program = Effect.all([fail1, fail2, die], {
  concurrency: "unbounded"
}).pipe(Effect.asVoid, Effect.parallelErrors)

Effect.runPromiseExit(program).then(console.log)
// Output:
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: { _id: 'Cause', _tag: 'Fail', failure: [ 'Oh uh!', 'Oh no!' ] }
// }

LANGUAGE: typescript
CODE:
declare const parallelErrors: <A, E, R>(self: Effect<A, E, R>) => Effect<A, Array<E>, R>

----------------------------------------

TITLE: Defining contextWithStream Function in TypeScript for Effect Stream Module
DESCRIPTION: Declares the contextWithStream function, which accesses the context of the stream in the context of a stream. It takes a function that receives a Context and returns a Stream, and produces a Stream that combines the original and new contexts.

LANGUAGE: typescript
CODE:
declare const contextWithStream: <R0, A, E, R>(f: (env: Context.Context<R0>) => Stream<A, E, R>) => Stream<A, E, R0 | R>

----------------------------------------

TITLE: Joining Array Elements with Separator in TypeScript
DESCRIPTION: Demonstrates how to use the Array.join function from the Effect package to concatenate array elements with a specified separator. The function takes an array of strings and a separator string as input, returning a single joined string.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const strings = ["a", "b", "c"]
const joined = Array.join(strings, "-")
console.log(joined) // "a-b-c"

----------------------------------------

TITLE: Implementing Context Layer Division in TypeScript Streams
DESCRIPTION: Function signature for provideSomeLayer that splits stream context into two parts. It provides one part using a specified layer while leaving the remainder R0. The function supports both curried and uncurried forms for flexibility in usage.

LANGUAGE: typescript
CODE:
declare const provideSomeLayer: { 
  <RIn, E2, ROut>(layer: Layer.Layer<ROut, E2, RIn>): 
    <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, RIn | Exclude<R, ROut>>; 
  <A, E, R, RIn, E2, ROut>(self: Stream<A, E, R>, layer: Layer.Layer<ROut, E2, RIn>): 
    Stream<A, E | E2, RIn | Exclude<R, ROut>>; 
}

----------------------------------------

TITLE: Using Array.range in TypeScript with Effect Library
DESCRIPTION: Demonstrates how to use the range function to generate an array of sequential integers. The function takes start and end numbers as parameters and returns a NonEmptyArray containing all integers in that range, including both endpoints.

LANGUAGE: typescript
CODE:
import { range } from "effect/Array"

const result = range(1, 3)
console.log(result) // [1, 2, 3]

LANGUAGE: typescript
CODE:
declare const range: (start: number, end: number) => NonEmptyArray<number>

----------------------------------------

TITLE: Declaring mapErrorCause Function in TypeScript
DESCRIPTION: This snippet defines the mapErrorCause function, which takes a mapping function for error causes and returns a new Effect with the mapped error cause. It supports both curried and uncurried versions of the function.

LANGUAGE: typescript
CODE:
declare const mapErrorCause: {
  <E, E2>(f: (cause: Cause.Cause<E>) => Cause.Cause<E2>): <A, R>(self: Effect<A, E, R>) => Effect<A, E2, R>;
  <A, E, R, E2>(self: Effect<A, E, R>, f: (cause: Cause.Cause<E>) => Cause.Cause<E2>): Effect<A, E2, R>;
}

----------------------------------------

TITLE: Creating Stream from Queue in TypeScript
DESCRIPTION: The fromChunkQueue function creates a stream from a Queue of values. It takes a Queue.Dequeue of Chunk.Chunk<A> and optional options. The options include a 'shutdown' boolean flag which, if true, will shutdown the queue after the stream is evaluated (default is false).

LANGUAGE: typescript
CODE:
declare const fromChunkQueue: <A>(queue: Queue.Dequeue<Chunk.Chunk<A>>, options?: { readonly shutdown?: boolean | undefined; }) => Stream<A>

----------------------------------------

TITLE: Declaring Exponential Schedule Function in TypeScript
DESCRIPTION: Defines a function that creates a schedule with exponentially increasing delays. It takes a base duration and an optional multiplication factor (defaults to 2) to calculate subsequent delays using the formula base * factor^n.

LANGUAGE: typescript
CODE:
declare const exponential: (base: Duration.DurationInput, factor?: number) => Schedule<Duration.Duration>

----------------------------------------

TITLE: TypeScript Signature for intoDeferred Function
DESCRIPTION: Provides the TypeScript type signature for the intoDeferred function. It shows the function's polymorphic nature, accepting different combinations of Effect and Deferred arguments.

LANGUAGE: typescript
CODE:
declare const intoDeferred: { <A, E>(deferred: Deferred.Deferred<A, E>): <R>(self: Effect<A, E, R>) => Effect<boolean, never, R>; <A, E, R>(self: Effect<A, E, R>, deferred: Deferred.Deferred<A, E>): Effect<boolean, never, R>; }

----------------------------------------

TITLE: Implementing Option.ap Function in TypeScript
DESCRIPTION: Function signature for Option.ap that combines two Options - one containing a function and another containing a value. The function applies the wrapped function to the wrapped value if both Options are Some, returning None if either is None.

LANGUAGE: typescript
CODE:
declare const ap: { 
  <A>(that: Option<A>): <B>(self: Option<(a: A) => B>) => Option<B>; 
  <A, B>(self: Option<(a: A) => B>, that: Option<A>): Option<B>; 
}

----------------------------------------

TITLE: Using isNonEmptyArray Type Guard in TypeScript
DESCRIPTION: Demonstrates how to use the isNonEmptyArray function to check if an array is non-empty and narrow its type to NonEmptyArray<A>. The function returns true if the array contains at least one element, false otherwise.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

console.log(Array.isNonEmptyArray([])) // false
console.log(Array.isNonEmptyArray([1, 2, 3])) // true

LANGUAGE: typescript
CODE:
declare const isNonEmptyArray: <A>(self: Array<A>) => self is NonEmptyArray<A>

----------------------------------------

TITLE: Implementing Lazy Transaction Suspension in Effect-TS STM
DESCRIPTION: Defines a suspend function that takes a lazy evaluation function and returns an STM transaction. The function allows for lazy creation of STM transactions by deferring their evaluation until needed. It accepts a LazyArg parameter that produces an STM transaction when evaluated.

LANGUAGE: typescript
CODE:
declare const suspend: <A, E, R>(evaluate: LazyArg<STM<A, E, R>>) => STM<A, E, R>

----------------------------------------

TITLE: Pattern Matching Example using Effect Match Module
DESCRIPTION: Demonstrates basic pattern matching on a union type (string | number) using Effect's Match module. Shows how to create matchers, define patterns, and handle exhaustive matching.

LANGUAGE: typescript
CODE:
import { Match } from "effect"

// Simulated dynamic input that can be a string or a number
const input: string | number = "some input"

//      ┌─── string
//      ▼
const result = Match.value(input).pipe(
  // Match if the value is a number
  Match.when(Match.number, (n) => `number: ${n}`),
  // Match if the value is a string
  Match.when(Match.string, (s) => `string: ${s}`),
  // Ensure all possible cases are covered
  Match.exhaustive
)

console.log(result)
// Output: "string: some input"

----------------------------------------

TITLE: Scheduling Stream Output in TypeScript
DESCRIPTION: Defines a function to schedule the output of a stream using a provided schedule. It can be used in two ways: as a standalone function or as a method on a Stream instance.

LANGUAGE: typescript
CODE:
declare const schedule: {
  <X, A0 extends A, R2, A>(
    schedule: Schedule.Schedule<X, A0, R2>
  ): <E, R>(self: Stream<A, E, R>) => Stream<A, E, R2 | R>;
  <A, E, R, X, A0 extends A, R2>(
    self: Stream<A, E, R>,
    schedule: Schedule.Schedule<X, A0, R2>
  ): Stream<A, E, R | R2>;
}

----------------------------------------

TITLE: Retrieving Items from KeyedPool in TypeScript
DESCRIPTION: The `get` function retrieves an item from the pool associated with a given key in a scoped effect. It handles acquisition failures and allows for retrying failed attempts. The function is overloaded to accept arguments in different orders.

LANGUAGE: typescript
CODE:
declare const get: { <K>(key: K): <A, E>(self: KeyedPool<K, A, E>) => Effect.Effect<A, E, Scope.Scope>; <K, A, E>(self: KeyedPool<K, A, E>, key: K): Effect.Effect<A, E, Scope.Scope>; }

----------------------------------------

TITLE: Defining IllegalArgumentException Interface in TypeScript
DESCRIPTION: This code snippet defines the IllegalArgumentException interface. It extends YieldableError and includes a readonly _tag property set to "IllegalArgumentException". It also has a readonly property using computed property name syntax for the IllegalArgumentExceptionTypeId.

LANGUAGE: typescript
CODE:
export interface IllegalArgumentException extends YieldableError {
  readonly _tag: "IllegalArgumentException"
  readonly [IllegalArgumentExceptionTypeId]: IllegalArgumentExceptionTypeId
}

----------------------------------------

TITLE: Using Effect.partition with Array Processing in TypeScript
DESCRIPTION: Demonstrates how to use Effect.partition to process an array of numbers, separating even numbers (successes) from odd numbers (failures). The function continues processing all elements even when failures occur, collecting them separately.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

const program = Effect.partition([0, 1, 2, 3, 4], (n) => {
  if (n % 2 === 0) {
    return Effect.succeed(n)
  } else {
    return Effect.fail(`${n} is not even`)
  }
})

Effect.runPromise(program).then(console.log, console.error)
// Output:
// [ [ '1 is not even', '3 is not even' ], [ 0, 2, 4 ] ]

----------------------------------------

TITLE: Defining Doc Type in TypeScript
DESCRIPTION: Defines a discriminated union type Doc<A> that represents a prettified document with annotations. The type includes various cases for different document elements like empty documents, characters, text, lines, and nested structures.

LANGUAGE: typescript
CODE:
type Doc<A> = | Fail<A>
  | Empty<A>
  | Char<A>
  | Text<A>
  | Line<A>
  | FlatAlt<A>
  | Cat<A>
  | Nest<A>
  | Union<A>
  | Column<A>
  | WithPageWidth<A>
  | Nesting<A>
  | Annotated<A>

----------------------------------------

TITLE: Implementing Conditional STM Operation in TypeScript
DESCRIPTION: A function that evaluates a predicate and returns either a success value of type A or an error value of type E wrapped in an STM monad. The function takes lazy arguments to allow for deferred evaluation.

LANGUAGE: typescript
CODE:
declare const cond: <A, E>(predicate: LazyArg<boolean>, error: LazyArg<E>, result: LazyArg<A>) => STM<A, E>

----------------------------------------

TITLE: Combining Option Values with product Function in TypeScript
DESCRIPTION: Function that combines two Option values into a single Option containing a tuple of their values if both are Some. Returns None if either input is None. Used for ensuring both values are valid when combining multiple Option values.

LANGUAGE: typescript
CODE:
declare const product: <A, B>(self: Option<A>, that: Option<B>) => Option<[A, B]>

----------------------------------------

TITLE: Retrieving Item from Pool in Scoped Effect (TypeScript)
DESCRIPTION: The get function retrieves an item from the pool in a scoped effect. If acquisition fails, the returned effect will fail for the same reason. Retrying a failed acquisition attempt will repeat the acquisition process.

LANGUAGE: typescript
CODE:
declare const get: <A, E>(self: Pool<A, E>) => Effect.Effect<A, E, Scope.Scope>

----------------------------------------

TITLE: Using cachedWithTTL in TypeScript Effect Module
DESCRIPTION: Demonstrates caching an expensive task result for 150 milliseconds using Effect.cachedWithTTL. The example shows how repeated calls within the TTL return cached results while calls after TTL expiration trigger recomputation.

LANGUAGE: typescript
CODE:
import { Effect, Console } from "effect"

let i = 1
const expensiveTask = Effect.promise<string>(() => {
  console.log("expensive task...")
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(`result ${i++}`)
    }, 100)
  })
})

const program = Effect.gen(function* () {
  const cached = yield* Effect.cachedWithTTL(expensiveTask, "150 millis")
  yield* cached.pipe(Effect.andThen(Console.log))
  yield* cached.pipe(Effect.andThen(Console.log))
  yield* Effect.sleep("100 millis")
  yield* cached.pipe(Effect.andThen(Console.log))
})

Effect.runFork(program)

----------------------------------------

TITLE: Creating Stream from TQueue in TypeScript
DESCRIPTION: The fromTQueue function creates a stream from a TQueue of values. It takes a TDequeue<A> as input and returns a Stream<A>. This function is available since version 3.10.0 of the effect package.

LANGUAGE: typescript
CODE:
declare const fromTQueue: <A>(queue: TDequeue<A>) => Stream<A>

----------------------------------------

TITLE: Effect.gen Type Signature Definition
DESCRIPTION: Type declaration for the Effect.gen function showing its generic parameters and return types. Defines the structure for generator functions that can yield Effects.

LANGUAGE: typescript
CODE:
declare const gen: { <Eff extends YieldWrap<Effect<any, any, any>>, AEff>(f: (resume: Adapter) => Generator<Eff, AEff, never>): Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer E, infer _R>>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer _E, infer R>>] ? R : never>; <Self, Eff extends YieldWrap<Effect<any, any, any>>, AEff>(self: Self, f: (this: Self, resume: Adapter) => Generator<Eff, AEff, never>): Effect<AEff, [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer E, infer _R>>] ? E : never, [Eff] extends [never] ? never : [Eff] extends [YieldWrap<Effect<infer _A, infer _E, infer R>>] ? R : never>; }

----------------------------------------

TITLE: Creating Custom Delay Schedules in TypeScript with Effect
DESCRIPTION: Defines a function that creates a schedule with multiple sequential delays. The schedule executes once for each specified duration, stopping after all delays have been used. It provides more flexibility than fixed patterns like exponential backoff.

LANGUAGE: typescript
CODE:
declare const fromDelays: (delay: Duration.DurationInput, ...delays: Array<Duration.DurationInput>) => Schedule<Duration.Duration>

----------------------------------------

TITLE: Implementing Effect Racing in TypeScript
DESCRIPTION: Function signature for raceAllFirst that takes an Iterable of Micro effects and returns a new effect that completes with the first effect to succeed or fail. All other effects are interrupted when a winner is determined.

LANGUAGE: typescript
CODE:
declare const raceAllFirst: <Eff extends Micro<any, any, any>>(all: Iterable<Eff>) => Micro<Micro.Success<Eff>, Micro.Error<Eff>, Micro.Context<Eff>>

----------------------------------------

TITLE: Using Effect.cachedFunction for Memoization in TypeScript
DESCRIPTION: Demonstrates how to use Effect.cachedFunction to memoize a random number generator function. The example shows the difference between memoized and non-memoized versions, where the memoized version returns the same result for identical inputs.

LANGUAGE: typescript
CODE:
import { Effect, Random } from "effect"

const program = Effect.gen(function* () {
  const randomNumber = (n: number) => Random.nextIntBetween(1, n)
  console.log("non-memoized version:")
  console.log(yield* randomNumber(10))
  console.log(yield* randomNumber(10))

  console.log("memoized version:")
  const memoized = yield* Effect.cachedFunction(randomNumber)
  console.log(yield* memoized(10))
  console.log(yield* memoized(10))
})

Effect.runFork(program)

----------------------------------------

TITLE: Converting Nullable Values to Option Types in TypeScript
DESCRIPTION: The Option.fromNullable function converts null or undefined values into None, and wraps non-null values in Some. This provides a safe way to handle potentially nullable values in a functional programming style.

LANGUAGE: typescript
CODE:
import { Option } from "effect"

console.log(Option.fromNullable(undefined))
// Output: { _id: 'Option', _tag: 'None' }

console.log(Option.fromNullable(null))
// Output: { _id: 'Option', _tag: 'None' }

console.log(Option.fromNullable(1))
// Output: { _id: 'Option', _tag: 'Some', value: 1 }

LANGUAGE: typescript
CODE:
declare const fromNullable: <A>(nullableValue: A) => Option<NonNullable<A>>

----------------------------------------

TITLE: Implementing Right-to-Left Reduction with Effect in TypeScript
DESCRIPTION: Demonstrates how to use Effect.reduceRight to process a collection of orders sequentially from right to left, calculating total price while logging processing status. Each order is processed with a decreasing delay.

LANGUAGE: typescript
CODE:
import { Console, Effect } from "effect"

const processOrder = (id: number) =>
  Effect.succeed({ id, price: 100 * id })
    .pipe(Effect.tap(() => Console.log(`Order ${id} processed`)), Effect.delay(500 - (id * 100)))

const program = Effect.reduceRight(
  [1, 2, 3, 4],
  0,
  (id, acc, i) =>
    processOrder(id)
      .pipe(Effect.map((order) => acc + order.price))
)

Effect.runPromise(program).then(console.log)
// Output:
// Order 4 processed
// Order 3 processed
// Order 2 processed
// Order 1 processed
// 1000

----------------------------------------

TITLE: Using Function.compose in TypeScript
DESCRIPTION: Demonstrates how to compose two functions using the Effect library's compose utility. The example shows composing an increment function with a square function to create a new function that first increments a number and then squares the result.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { compose } from "effect/Function"

const increment = (n: number) => n + 1;
const square = (n: number) => n * n;

assert.strictEqual(compose(increment, square)(2), 9);

----------------------------------------

TITLE: Catching Specific Errors with Effect.catchIf in TypeScript
DESCRIPTION: Demonstrates how to use Effect.catchIf to recover from specific errors based on a predicate. The example shows handling HttpError while allowing ValidationError to propagate.

LANGUAGE: typescript
CODE:
import { Effect, Random } from "effect"

class HttpError {
  readonly _tag = "HttpError"
}

class ValidationError {
  readonly _tag = "ValidationError"
}

//      ┌─── Effect<string, HttpError | ValidationError, never>
//      ▼
const program = Effect.gen(function* () {
  const n1 = yield* Random.next
  const n2 = yield* Random.next
  if (n1 < 0.5) {
    yield* Effect.fail(new HttpError())
  }
  if (n2 < 0.5) {
    yield* Effect.fail(new ValidationError())
  }
  return "some result"
})

//      ┌─── Effect<string, ValidationError, never>
//      ▼
const recovered = program.pipe(
  Effect.catchIf(
    // Only handle HttpError errors
    (error) => error._tag === "HttpError",
    () => Effect.succeed("Recovering from HttpError")
  )
)

----------------------------------------

TITLE: Using replicateEffect with Effect Module
DESCRIPTION: Demonstrates how to use replicateEffect to execute an effect multiple times and collect results. The example shows a counter being incremented three times with logging.

LANGUAGE: typescript
CODE:
declare const replicateEffect: { (n: number, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly discard?: false | undefined; readonly concurrentFinalizers?: boolean | undefined; }): <A, E, R>(self: Effect<A, E, R>) => Effect<Array<A>, E, R>; (n: number, options: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly discard: true; readonly concurrentFinalizers?: boolean | undefined; }): <A, E, R>(self: Effect<A, E, R>) => Effect<void, E, R>; <A, E, R>(self: Effect<A, E, R>, n: number, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly discard?: false | undefined; readonly concurrentFinalizers?: boolean | undefined; }): Effect<Array<A>, E, R>; <A, E, R>(self: Effect<A, E, R>, n: number, options: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly discard: true; readonly concurrentFinalizers?: boolean | undefined; }): Effect<void, E, R>; }

----------------------------------------

TITLE: Implementing Synchronous Channel Creation in TypeScript
DESCRIPTION: Defines a function that creates a channel which immediately succeeds with a specified lazy value. The channel takes a lazy argument evaluation function and returns a Channel type with specific type parameters for handling various aspects of the channel operation.

LANGUAGE: typescript
CODE:
declare const sync: <OutDone>(evaluate: LazyArg<OutDone>) => Channel<never, unknown, never, unknown, OutDone, unknown>

----------------------------------------

TITLE: Implementing Option.Do with Bind and Let Operations in TypeScript
DESCRIPTION: Demonstrates how to use Option.Do to create a declarative pipeline using bind and let operations. The example shows binding two values, computing their sum, and filtering based on a condition.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Option, pipe } from "effect"

const result = pipe(
  Option.Do,
  Option.bind("x", () => Option.some(2)),
  Option.bind("y", () => Option.some(3)),
  Option.let("sum", ({ x, y }) => x + y),
  Option.filter(({ x, y }) => x * y > 5)
)
assert.deepStrictEqual(result, Option.some({ x: 2, y: 3, sum: 5 }))

LANGUAGE: typescript
CODE:
declare const Do: Option<{}>

----------------------------------------

TITLE: Creating Flat Config Provider in TypeScript using Effect
DESCRIPTION: The makeFlat function creates a new flat config provider. It takes an options object with load, enumerateChildren, and patch functions. The load function retrieves configuration values, enumerateChildren lists available config keys, and patch applies modifications to the config path.

LANGUAGE: typescript
CODE:
declare const makeFlat: (options: { readonly load: <A>(path: ReadonlyArray<string>, config: Config.Config.Primitive<A>, split: boolean) => Effect.Effect<Array<A>, ConfigError.ConfigError>; readonly enumerateChildren: (path: ReadonlyArray<string>) => Effect.Effect<HashSet.HashSet<string>, ConfigError.ConfigError>; readonly patch: PathPatch.PathPatch; }) => ConfigProvider.Flat

----------------------------------------

TITLE: Implementing Stream.tapBoth in TypeScript
DESCRIPTION: A function that returns a stream that can "peek" at both failure and success cases of the stream using effect handlers. It allows executing side effects on both success and failure outcomes without modifying the stream values.

LANGUAGE: typescript
CODE:
declare const tapBoth: {
  <E, X1, E2, R2, A, X2, E3, R3>(options: {
    readonly onFailure: (e: NoInfer<E>) => Effect.Effect<X1, E2, R2>;
    readonly onSuccess: (a: NoInfer<A>) => Effect.Effect<X2, E3, R3>;
  }): <R>(self: Stream<A, E, R>) => Stream<A, E | E2 | E3, R2 | R3 | R>;
  <A, E, R, X1, E2, R2, X2, E3, R3>(self: Stream<A, E, R>, options: {
    readonly onFailure: (e: NoInfer<E>) => Effect.Effect<X1, E2, R2>;
    readonly onSuccess: (a: NoInfer<A>) => Effect.Effect<X2, E3, R3>;
  }): Stream<A, E | E2 | E3, R | R2 | R3>;
}

----------------------------------------

TITLE: Defining HashMap.set Function Signature in TypeScript
DESCRIPTION: Declares the signature of the 'set' function in the HashMap module. This function sets a specified key to a specified value using an internal hashing function. It supports both curried and non-curried versions.

LANGUAGE: typescript
CODE:
declare const set: { <K, V>(key: K, value: V): (self: HashMap<K, V>) => HashMap<K, V>; <K, V>(self: HashMap<K, V>, key: K, value: V): HashMap<K, V>; }

----------------------------------------

TITLE: Constructing Right Value in Either Module (TypeScript)
DESCRIPTION: Defines the right function that constructs a new Either holding a Right value. This function is typically used to represent a successful value due to the right bias of the Either structure.

LANGUAGE: typescript
CODE:
declare const right: <R>(right: R) => Either<R>

----------------------------------------

TITLE: Demonstrating Do Simulation in TypeScript with Effect Module
DESCRIPTION: This example shows how to use the do simulation in Effect to perform operations in a declarative style. It demonstrates binding variables to Effect values and using let to define simple values.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Effect, pipe } from "effect"

const result = pipe(
  Effect.Do,
  Effect.bind("x", () => Effect.succeed(2)),
  Effect.bind("y", () => Effect.succeed(3)),
  Effect.let("sum", ({ x, y }) => x + y)
)
assert.deepStrictEqual(Effect.runSync(result), { x: 2, y: 3, sum: 5 })

----------------------------------------

TITLE: Creating HashMap from Key-Value Pairs in TypeScript
DESCRIPTION: Function signature for constructing a new HashMap from an array of key/value pairs. The function takes a variable number of tuple entries and returns a strongly-typed HashMap where key and value types are inferred from the input entries.

LANGUAGE: typescript
CODE:
declare const make: <Entries extends ReadonlyArray<readonly [any, any]>>(...entries: Entries) => HashMap<Entries[number] extends readonly [infer K, any] ? K : never, Entries[number] extends readonly [any, infer V] ? V : never>

----------------------------------------

TITLE: Implementing STM.tap Type Definition in TypeScript
DESCRIPTION: Type definition for the STM.tap function that enables inspection of successful transactional effects. The function takes a transformation function and returns a new STM that maintains the original value while potentially adding new error types and requirements.

LANGUAGE: typescript
CODE:
declare const tap: {
  <A, X, E2, R2>(f: (a: A) => STM<X, E2, R2>): <E, R>(self: STM<A, E, R>) => STM<A, E2 | E, R2 | R>;
  <A, E, R, X, E2, R2>(self: STM<A, E, R>, f: (a: A) => STM<X, E2, R2>): STM<A, E | E2, R | R2>;
}

----------------------------------------

TITLE: Creating Traced Function with Delay in TypeScript
DESCRIPTION: Illustrates creating a traced function with a delay modifier. The function demonstrates how to use Effect.fn as a pipe function and add post-processing to the effect.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

const myfunc = Effect.fn(
  function* (n: number) {
    console.log(`got: ${n}`)
    yield* Effect.fail(new Error("Boom!"))
  },
  // You can access both the created effect and the original arguments
  (effect, n) => Effect.delay(effect, `${n / 100} seconds`)
)

Effect.runFork(myfunc(100).pipe(Effect.catchAllCause(Effect.logError)))

----------------------------------------

TITLE: Type Signature for Array.findLast Function in TypeScript
DESCRIPTION: Provides the type signature for the Array.findLast function. It shows various overloads supporting different use cases, including predicate functions, refinements, and options.

LANGUAGE: typescript
CODE:
declare const findLast: { <A, B>(f: (a: NoInfer<A>, i: number) => Option.Option<B>): (self: Iterable<A>) => Option.Option<B>; <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => Option.Option<B>; <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Option.Option<A>; <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option.Option<B>): Option.Option<B>; <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): Option.Option<B>; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Option.Option<A>; }

----------------------------------------

TITLE: Using Array.window Function in TypeScript
DESCRIPTION: Demonstrates how to use the Array.window function to create sliding windows of a specified size from an iterable. The function returns an array of arrays, each representing a window of the specified size.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Array } from "effect"

const numbers = [1, 2, 3, 4, 5]
assert.deepStrictEqual(Array.window(numbers, 3), [[1, 2, 3], [2, 3, 4], [3, 4, 5]])
assert.deepStrictEqual(Array.window(numbers, 6), [])

----------------------------------------

TITLE: Using Stream.raceAll in TypeScript
DESCRIPTION: Demonstrates how to use Stream.raceAll to create a stream that emits values from the first upstream to emit an item. It races multiple streams created with different schedules and takes the first 6 items.

LANGUAGE: typescript
CODE:
import { Stream, Schedule, Console, Effect } from "effect"

const stream = Stream.raceAll(
  Stream.fromSchedule(Schedule.spaced('1 millis')),
  Stream.fromSchedule(Schedule.spaced('2 millis')),
  Stream.fromSchedule(Schedule.spaced('4 millis')),
).pipe(Stream.take(6), Stream.tap(Console.log))

Effect.runPromise(Stream.runDrain(stream))
// Output each millisecond from the first stream, the rest streams are interrupted
// 0
// 1
// 2
// 3
// 4
// 5

----------------------------------------

TITLE: Using Effect.replicate with Console Output in TypeScript
DESCRIPTION: Demonstrates how to use Effect.replicate to create multiple instances of an effect that outputs to console. The example creates 3 copies of a task that logs 'Hello, World!' and executes them sequentially.

LANGUAGE: typescript
CODE:
import { Console, Effect } from "effect"

const task = Effect.succeed("Hello, World!").pipe(
  Effect.tap(Console.log)
)

const program = Effect.gen(function*() {
  // Replicate the task 3 times
  const tasks = Effect.replicate(task, 3)
  for (const t of tasks) {
    // Run each task
    yield* t
  }
})

Effect.runFork(program)
// Output:
// Hello, World!
// Hello, World!
// Hello, World!

----------------------------------------

TITLE: Grouping Stream Elements with Effect
DESCRIPTION: Demonstrates how to use Stream.grouped to partition a stream of numbers into chunks of size 3. The example shows creating a range stream from 0 to 8 and grouping it into chunks, then collecting and logging the results.

LANGUAGE: typescript
CODE:
import { Effect, Stream } from "effect"

const stream = Stream.range(0, 8).pipe(Stream.grouped(3))

Effect.runPromise(Stream.runCollect(stream)).then((chunks) => console.log("%o", chunks))
// {
//   _id: 'Chunk',
//   values: [
//     { _id: 'Chunk', values: [ 0, 1, 2, [length]: 3 ] },
//     { _id: 'Chunk', values: [ 3, 4, 5, [length]: 3 ] },
//     { _id: 'Chunk', values: [ 6, 7, 8, [length]: 3 ] },
//     [length]: 3
//   ]
// }

----------------------------------------

TITLE: Defining mergeOutWith Function for Channel Merging in TypeScript
DESCRIPTION: Declares a function that merges multiple channels emitted by a parent channel. It uses a back pressuring merge strategy and a custom function to merge the result values of completed subchannels. The function is overloaded to accept parameters in different orders.

LANGUAGE: typescript
CODE:
declare const mergeOutWith: { <OutDone1>(n: number, f: (o1: OutDone1, o2: OutDone1) => OutDone1): <OutElem1, InElem1, OutErr1, InErr1, InDone1, Env1, InElem, OutErr, InErr, InDone, Env>(self: Channel<Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>, InElem, OutErr, InErr, OutDone1, InDone, Env>) => Channel<OutElem1, InElem & InElem1, OutErr1 | OutErr, InErr & InErr1, OutDone1, InDone & InDone1, Env1 | Env>; <OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1, InElem, OutErr, InErr, InDone, Env>(self: Channel<Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>, InElem, OutErr, InErr, OutDone1, InDone, Env>, n: number, f: (o1: OutDone1, o2: OutDone1) => OutDone1): Channel<OutElem1, InElem & InElem1, OutErr1 | OutErr, InErr & InErr1, OutDone1, InDone & InDone1, Env1 | Env>; }

----------------------------------------

TITLE: Filtering and Mapping Record Values in TypeScript using Effect
DESCRIPTION: Demonstrates how to use Record.filterMap to transform a record by applying a function to each key-value pair. The function returns an Option type, and only pairs that result in Some are included in the output record.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Record, Option } from "effect"

const x = { a: 1, b: 2, c: 3 }
const f = (a: number, key: string) => a > 2 ? Option.some(a * 2) : Option.none()
assert.deepStrictEqual(Record.filterMap(x, f), { c: 6 })

LANGUAGE: typescript
CODE:
declare const filterMap: { <K extends string, A, B>(f: (a: A, key: K) => Option.Option<B>): (self: ReadonlyRecord<K, A>) => Record<ReadonlyRecord.NonLiteralKey<K>, B>; <K extends string, A, B>(self: ReadonlyRecord<K, A>, f: (a: A, key: K) => Option.Option<B>): Record<ReadonlyRecord.NonLiteralKey<K>, B>; }

----------------------------------------

TITLE: Converting HttpApi to OpenAPI Specification in TypeScript
DESCRIPTION: This example demonstrates how to use the OpenApi.fromApi function to convert an HttpApi instance into an OpenAPI Specification. It creates a simple API with a single endpoint and generates the corresponding OpenAPI spec.

LANGUAGE: typescript
CODE:
import { HttpApi, HttpApiEndpoint, HttpApiGroup, OpenApi } from "@effect/platform"
import { Schema } from "effect"

const api = HttpApi.make("api").add(
  HttpApiGroup.make("group").add(
    HttpApiEndpoint.get("get", "/items")
      .addSuccess(Schema.Array(Schema.String))
  )
)

const spec = OpenApi.fromApi(api)

console.log(JSON.stringify(spec, null, 2))
// Output: OpenAPI specification in JSON format

----------------------------------------

TITLE: Providing Service Implementation for Effect in TypeScript
DESCRIPTION: This snippet demonstrates how to use Effect.provideService to provide an implementation for a random number generator service. It defines a service tag, creates a program that uses the service, and then provides a concrete implementation.

LANGUAGE: typescript
CODE:
import { Effect, Context } from "effect"

// Declaring a tag for a service that generates random numbers
class Random extends Context.Tag("MyRandomService")<
  Random,
  { readonly next: Effect.Effect<number> }
>() {}

// Using the service
const program = Effect.gen(function* () {
  const random = yield* Random
  const randomNumber = yield* random.next
  console.log(`random number: ${randomNumber}`)
})

// Providing the implementation
//
//      ┌─── Effect<void, never, never>
//      ▼
const runnable = Effect.provideService(program, Random, {
  next: Effect.sync(() => Math.random())
})

// Run successfully
Effect.runPromise(runnable)
// Example Output:
// random number: 0.8241872233134417

----------------------------------------

TITLE: TypeScript Function Signature for Effect.custom
DESCRIPTION: Provides the TypeScript function signature for Effect.custom, showing its polymorphic nature and the structure of the 'this' context available in the effect body.

LANGUAGE: typescript
CODE:
declare const custom: { <X, A, E, R>(i0: X, body: (this: { effect_instruction_i0: X; }) => Effect<A, E, R>): Effect<A, E, R>; <X, Y, A, E, R>(i0: X, i1: Y, body: (this: { effect_instruction_i0: X; effect_instruction_i1: Y; }) => Effect<A, E, R>): Effect<A, E, R>; <X, Y, Z, A, E, R>(i0: X, i1: Y, i2: Z, body: (this: { effect_instruction_i0: X; effect_instruction_i1: Y; effect_instruction_i2: Z; }) => Effect<A, E, R>): Effect<A, E, R>; }

----------------------------------------

TITLE: Combining Arrays with zipWith in TypeScript
DESCRIPTION: Demonstrates how to use Array.zipWith to combine elements from two arrays using a function. The function applies an operation to pairs of elements at matching indices, returning a new array with the results. If arrays have different lengths, excess elements are discarded.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const result = Array.zipWith([1, 2, 3], [4, 5, 6], (a, b) => a + b)
console.log(result) // [5, 7, 9]

LANGUAGE: typescript
CODE:
declare const zipWith: { 
  <B, A, C>(that: NonEmptyReadonlyArray<B>, f: (a: A, b: B) => C): (self: NonEmptyReadonlyArray<A>) => NonEmptyArray<C>; 
  <B, A, C>(that: Iterable<B>, f: (a: A, b: B) => C): (self: Iterable<A>) => Array<C>; 
  <A, B, C>(self: NonEmptyReadonlyArray<A>, that: NonEmptyReadonlyArray<B>, f: (a: A, b: B) => C): NonEmptyArray<C>; 
  <B, A, C>(self: Iterable<A>, that: Iterable<B>, f: (a: A, b: B) => C): Array<C>; 
}

----------------------------------------

TITLE: Using Array.findFirst in TypeScript with Effect Library
DESCRIPTION: Demonstrates how to use the Array.findFirst function to find the first element in an array that satisfies a given condition. The function returns an Option type containing the found element or None if no element is found.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const result = Array.findFirst([1, 2, 3, 4, 5], x => x > 3)
console.log(result) // Option.some(4)

----------------------------------------

TITLE: Implementing Pretty Logging in Effect TypeScript
DESCRIPTION: Demonstrates how to use the pretty logger to create visually enhanced log outputs with color coding and formatting. The example shows logging messages with annotations, spans, and custom key-value pairs.

LANGUAGE: typescript
CODE:
import { Effect, Logger } from "effect"

const program = Effect.log("message1", "message2").pipe(
  Effect.annotateLogs({ key1: "value1", key2: "value2" }),
  Effect.withLogSpan("myspan")
)

Effect.runFork(program.pipe(Effect.provide(Logger.pretty)))

LANGUAGE: typescript
CODE:
declare const pretty: Layer.Layer<never, never, never>

----------------------------------------

TITLE: Declaring isSuccess Function in TypeScript for Effect Module
DESCRIPTION: Defines the 'isSuccess' function that checks if an effect has succeeded. It takes an Effect as input and returns a new Effect containing a boolean result. The function preserves the context of the original effect but cannot fail.

LANGUAGE: typescript
CODE:
declare const isSuccess: <A, E, R>(self: Effect<A, E, R>) => Effect<boolean, never, R>

----------------------------------------

TITLE: Filtering an Array with Effect.filter in TypeScript
DESCRIPTION: This example demonstrates how to use Effect.filter to filter an array of numbers, keeping only the even numbers. It uses an effectful predicate and the Effect.gen function for program composition.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

const numbers = [1, 2, 3, 4, 5]
const predicate = (n: number, i: number) => Effect.succeed(n % 2 === 0)

const program = Effect.gen(function*() {
  const result = yield* Effect.filter(numbers, predicate)
  console.log(result)
})

Effect.runFork(program)
// Output: [2, 4]

----------------------------------------

TITLE: TypeScript Function Signature for runPromise
DESCRIPTION: The type declaration for the runPromise function, showing it accepts an Effect with generic types for success (A) and error (E) values, plus optional AbortSignal options.

LANGUAGE: typescript
CODE:
declare const runPromise: <A, E>(effect: Effect<A, E, never>, options?: { readonly signal?: AbortSignal; } | undefined) => Promise<A>

----------------------------------------

TITLE: Implementing Division with Error Termination in TypeScript using Effect
DESCRIPTION: Demonstrates how to use Effect.die to handle division by zero by terminating the fiber with a specified error. The example shows proper error handling for edge cases in arithmetic operations.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

const divide = (a: number, b: number) =>
  b === 0
    ? Effect.die(new Error("Cannot divide by zero"))
    : Effect.succeed(a / b)

//      ┌─── Effect<number, never, never>
//      ▼
const program = divide(1, 0)

Effect.runPromise(program).catch(console.error)
// Output:
// (FiberFailure) Error: Cannot divide by zero
//   ...stack trace...

LANGUAGE: typescript
CODE:
declare const die: (defect: unknown) => Effect<never>

----------------------------------------

TITLE: Using Effect.mapBoth to Transform Success and Error Channels in TypeScript
DESCRIPTION: This example demonstrates how to use Effect.mapBoth to modify both the error and success values of an effect. It transforms a string error into an Error object and a number success value into a boolean.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

//      ┌─── Effect<number, string, never>
//      ▼
const simulatedTask = Effect.fail("Oh no!").pipe(Effect.as(1))

//      ┌─── Effect<boolean, Error, never>
//      ▼
const modified = Effect.mapBoth(simulatedTask, {
  onFailure: (message) => new Error(message),
  onSuccess: (n) => n > 0
})

----------------------------------------

TITLE: Defining Schedule.dayOfWeek Function in TypeScript
DESCRIPTION: Declares a function that creates a schedule recurring on a specific day of the week. The function takes a day number (1-7, Monday-Sunday) and returns a Schedule that produces incrementing numbers starting from 0. The schedule triggers at midnight on the specified day.

LANGUAGE: typescript
CODE:
declare const dayOfWeek: (day: number) => Schedule<number>

----------------------------------------

TITLE: Using Effect.timeoutTo with Custom Success and Timeout Handlers
DESCRIPTION: Demonstrates how to use Effect.timeoutTo to handle both successful completion and timeout scenarios of an asynchronous operation. The example shows creating a task with a delay and handling its outcome using Either type.

LANGUAGE: typescript
CODE:
import { Effect, Either } from "effect"

const task = Effect.gen(function* () {
  console.log("Start processing...")
  yield* Effect.sleep("2 seconds") // Simulates a delay in processing
  console.log("Processing complete.")
  return "Result"
})

const program = task.pipe(
  Effect.timeoutTo({
    duration: "1 second",
    onSuccess: (result): Either.Either<string, string> =>
      Either.right(result),
    onTimeout: (): Either.Either<string, string> =>
      Either.left("Timed out!")
  })
)

Effect.runPromise(program).then(console.log)
// Output:
// Start processing...
// {
//   _id: "Either",
//   _tag: "Left",
//   left: "Timed out!"
// }

----------------------------------------

TITLE: Creating Fixed Interval Schedule in TypeScript
DESCRIPTION: The 'fixed' function creates a schedule that executes at regular, evenly spaced intervals. It returns the number of times it has run. If an action takes longer than the interval, the next execution happens immediately to prevent overlaps.

LANGUAGE: typescript
CODE:
declare const fixed: (interval: Duration.DurationInput) => Schedule<number>

----------------------------------------

TITLE: Defining Duration.between Function in TypeScript
DESCRIPTION: Declares a function 'between' that checks if a Duration is between a minimum and maximum value. It can be called with options first or with the Duration (self) first.

LANGUAGE: typescript
CODE:
declare const between: { (options: { minimum: DurationInput; maximum: DurationInput; }): (self: DurationInput) => boolean; (self: DurationInput, options: { minimum: DurationInput; maximum: DurationInput; }): boolean; }

----------------------------------------

TITLE: Filtering Defects in Cause - TypeScript
DESCRIPTION: A function that processes a Cause object to remove Fail and Interrupt nodes, preserving only Die (defect) nodes. Returns an Option type containing the filtered Cause if defects exist, or None if no defects remain. Useful for isolating unexpected failures from known errors.

LANGUAGE: typescript
CODE:
declare const keepDefects: <E>(self: Cause<E>) => Option.Option<Cause<never>>

----------------------------------------

TITLE: Creating Unbounded Queue in TypeScript using Effect
DESCRIPTION: The unbounded function creates a new unbounded Queue. It takes no parameters and returns an Effect that produces a Queue of type A.

LANGUAGE: typescript
CODE:
declare const unbounded: <A>() => Effect.Effect<Queue<A>>

----------------------------------------

TITLE: Creating Manual Resource in Effect-TS
DESCRIPTION: Creates a new Resource value that requires manual refresh calls. This constructor accepts an acquisition effect and doesn't perform automatic error retrying. Users need to apply retry policies to the acquisition effect before using this constructor if error retrying is desired.

LANGUAGE: typescript
CODE:
declare const manual: <A, E, R>(acquire: Effect.Effect<A, E, R>) => Effect.Effect<Resource<A, E>, never, Scope.Scope | R>

----------------------------------------

TITLE: Testing Number Type with isNumber Function in TypeScript
DESCRIPTION: This snippet demonstrates how to use the isNumber function from the Effect package's Predicate module to test if a value is a number. It shows examples of testing both a number and a string.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { isNumber } from "effect/Predicate"

assert.deepStrictEqual(isNumber(2), true)

assert.deepStrictEqual(isNumber("2"), false)

----------------------------------------

TITLE: Declaring filterOrDieMessage Function in TypeScript
DESCRIPTION: Type declaration for filterOrDieMessage function that filters Effect values and terminates with a custom message if the predicate fails. The function supports both refinement and predicate-based filtering with configurable error messages.

LANGUAGE: typescript
CODE:
declare const filterOrDieMessage: {
  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>, message: string): <E, R>(self: Effect<A, E, R>) => Effect<B, E, R>;
  <A>(predicate: Predicate<NoInfer<A>>, message: string): <E, R>(self: Effect<A, E, R>) => Effect<A, E, R>;
  <A, E, R, B extends A>(self: Effect<A, E, R>, refinement: Refinement<A, B>, message: string): Effect<B, E, R>;
  <A, E, R>(self: Effect<A, E, R>, predicate: Predicate<A>, message: string): Effect<A, E, R>;
}

----------------------------------------

TITLE: Flattening Commands in TypeScript
DESCRIPTION: The flatten function takes a Command object and returns a non-empty array of StandardCommand objects. For StandardCommand, it returns a single-element array. For PipedCommand, it extracts all commands in the pipe into an array from left to right.

LANGUAGE: typescript
CODE:
declare const flatten: (self: Command) => NonEmptyReadonlyArray<StandardCommand>

----------------------------------------

TITLE: Concatenating Chunks Using appendAll in TypeScript
DESCRIPTION: Demonstrates how to combine two chunks using the appendAll operation. The example shows concatenating a numeric chunk with a string chunk, illustrating type flexibility and array conversion.

LANGUAGE: typescript
CODE:
import { Chunk } from "effect"

const result = Chunk.make(1, 2).pipe(Chunk.appendAll(Chunk.make("a", "b")), Chunk.toArray)

console.log(result)
// [ 1, 2, "a", "b" ]

LANGUAGE: typescript
CODE:
declare const appendAll: { <S extends Chunk<any>, T extends Chunk<any>>(that: T): (self: S) => Chunk.OrNonEmpty<S, T, Chunk.Infer<S> | Chunk.Infer<T>>; <A, B>(self: Chunk<A>, that: NonEmptyChunk<B>): NonEmptyChunk<A | B>; <A, B>(self: NonEmptyChunk<A>, that: Chunk<B>): NonEmptyChunk<A | B>; <A, B>(self: Chunk<A>, that: Chunk<B>): Chunk<A | B>; }

----------------------------------------

TITLE: Transforming Schedule Input Types with Effects in TypeScript
DESCRIPTION: Defines a function that transforms a schedule's input type using an effectful function. It allows schedule inputs of type In2 to be converted to type In through an effect-producing transformation, useful for handling async operations like API calls or database queries.

LANGUAGE: typescript
CODE:
declare const mapInputEffect: { <In2, In, R2>(f: (in2: In2) => Effect.Effect<In, never, R2>): <Out, R>(self: Schedule<Out, In, R>) => Schedule<Out, In2, R2 | R>; <Out, In, R, In2, R2>(self: Schedule<Out, In, R>, f: (in2: In2) => Effect.Effect<In, never, R2>): Schedule<Out, In2, R | R2>; }

----------------------------------------

TITLE: Demonstrating untupled Function Usage in TypeScript
DESCRIPTION: This example shows how to use the untupled function from the Effect package to convert a function that takes a tuple as an argument into one that takes multiple arguments.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { untupled } from "effect/Function"

const getFirst = untupled(<A, B>(tuple: [A, B]): A => tuple[0])

assert.deepStrictEqual(getFirst(1, 2), 1)

----------------------------------------

TITLE: Implementing JSON Logging with Effect Logger
DESCRIPTION: Demonstrates how to use the jsonLogger to format log entries as JSON objects. The example shows logging messages with annotations and spans, which are then output in a structured JSON format.

LANGUAGE: typescript
CODE:
import { Effect, Logger } from "effect"

const program = Effect.log("message1", "message2").pipe(
  Effect.annotateLogs({ key1: "value1", key2: "value2" }),
  Effect.withLogSpan("myspan")
)

Effect.runFork(program.pipe(Effect.provide(Logger.json)))
// {"message":["message1","message2"],"logLevel":"INFO","timestamp":"...","annotations":{"key2":"value2","key1":"value1"},"spans":{"myspan":0},"fiberId":"#0"}

LANGUAGE: typescript
CODE:
declare const jsonLogger: Logger<unknown, string>

----------------------------------------

TITLE: Defining tapSink Function in TypeScript for Stream Module
DESCRIPTION: Declares the tapSink function, which sends all elements emitted by a stream to a specified sink in addition to emitting them. It supports both curried and uncurried forms, handling various type parameters for flexibility.

LANGUAGE: typescript
CODE:
declare const tapSink: { <A, E2, R2>(sink: Sink.Sink<unknown, A, unknown, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: Stream<A, E, R>, sink: Sink.Sink<unknown, A, unknown, E2, R2>): Stream<A, E | E2, R | R2>; }

----------------------------------------

TITLE: Handling Errors with Effect.catchAll in TypeScript
DESCRIPTION: Demonstrates how to use Effect.catchAll to handle recoverable errors in an effect, providing fallback logic for different error types.

LANGUAGE: typescript
CODE:
import { Effect, Random } from "effect"

class HttpError {
  readonly _tag = "HttpError"
}

class ValidationError {
  readonly _tag = "ValidationError"
}

//      ┌─── Effect<string, HttpError | ValidationError, never>
//      ▼
const program = Effect.gen(function* () {
  const n1 = yield* Random.next
  const n2 = yield* Random.next
  if (n1 < 0.5) {
    yield* Effect.fail(new HttpError())
  }
  if (n2 < 0.5) {
    yield* Effect.fail(new ValidationError())
  }
  return "some result"
})

//      ┌─── Effect<string, never, never>
//      ▼
const recovered = program.pipe(
  Effect.catchAll((error) =>
    Effect.succeed(`Recovering from ${error._tag}`)
  )
)

----------------------------------------

TITLE: Mapping STM Effects with Exception Handling in TypeScript
DESCRIPTION: Function signature for mapAttempt that transforms STM effects by applying a potentially throwing function to their values. It converts any thrown exceptions into typed failed effects while maintaining the STM context.

LANGUAGE: typescript
CODE:
declare const mapAttempt: { <A, B>(f: (a: A) => B): <E, R>(self: STM<A, E, R>) => STM<B, unknown, R>; <A, E, R, B>(self: STM<A, E, R>, f: (a: A) => B): STM<B, unknown, R>; }

----------------------------------------

TITLE: Demonstrating Array.differenceWith in TypeScript
DESCRIPTION: This snippet shows how to use the Array.differenceWith function to create an array of values not included in another iterable, using a custom equivalence function.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const array1 = [1, 2, 3]
const array2 = [2, 3, 4]
const difference = Array.differenceWith<number>((a, b) => a === b)(array1, array2)
console.log(difference) // [1]

----------------------------------------

TITLE: Implementing Transactional Iteration in TypeScript using STM.iterate
DESCRIPTION: The STM.iterate function provides a way to perform transactional iteration. It takes an initial value and options including a continuation predicate and a body function. It repeatedly applies the body function while the continuation predicate returns true.

LANGUAGE: typescript
CODE:
const s = initial

while (cont(s)) {
  s = body(s)
}

return s

LANGUAGE: typescript
CODE:
declare const iterate: <Z, E, R>(initial: Z, options: { readonly while: Predicate<Z>; readonly body: (z: Z) => STM<Z, E, R>; }) => STM<Z, E, R>

----------------------------------------

TITLE: Creating Array Union in TypeScript with Effect Library
DESCRIPTION: Demonstrates how to use the Array.union function from the Effect library to create a union of two arrays, removing duplicates. The function takes two arrays as input and returns a new array containing all unique elements from both input arrays.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const result = Array.union([1, 2], [2, 3])
console.log(result) // [1, 2, 3]

----------------------------------------

TITLE: Demonstrating Either.all Function Usage in TypeScript
DESCRIPTION: This code snippet demonstrates how to use the Either.all function with different input types, including arrays and objects. It shows how the function handles both successful (right) and error (left) cases.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Either } from "effect"

assert.deepStrictEqual(Either.all([Either.right(1), Either.right(2)]), Either.right([1, 2]))
assert.deepStrictEqual(Either.all({ right: Either.right(1), b: Either.right("hello") }), Either.right({ right: 1, b: "hello" }))
assert.deepStrictEqual(Either.all({ right: Either.right(1), b: Either.left("error") }), Either.left("error"))

----------------------------------------

TITLE: Using BigDecimal.max Function in TypeScript
DESCRIPTION: Demonstrates how to use the max function to compare two BigDecimal values and return the larger one. The example shows importing the necessary functions and comparing string-converted BigDecimal values.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { max, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(max(unsafeFromString("2"), unsafeFromString("3")), unsafeFromString("3"))

LANGUAGE: typescript
CODE:
declare const max: { (that: BigDecimal): (self: BigDecimal) => BigDecimal; (self: BigDecimal, that: BigDecimal): BigDecimal; }

----------------------------------------

TITLE: Implementing Safe Array Element Access in TypeScript
DESCRIPTION: The 'get' function provides a type-safe way to read a value at a specific index from a ReadonlyArray. It returns an Option type, ensuring null-safety when accessing array elements.

LANGUAGE: typescript
CODE:
declare const get: { (index: number): <A>(self: ReadonlyArray<A>) => Option.Option<A>; <A>(self: ReadonlyArray<A>, index: number): Option.Option<A>; }

----------------------------------------

TITLE: Creating Bounded Queue with Back Pressure in TypeScript
DESCRIPTION: Creates a bounded queue that implements back pressure strategy when at capacity. The queue holds values until they are taken and applies back pressure to offerors when full. For optimal performance, capacity values should be powers of two.

LANGUAGE: typescript
CODE:
declare const bounded: <A>(requestedCapacity: number) => STM.STM<TQueue<A>>

----------------------------------------

TITLE: Handling Failed Effect as Rejected Promise in TypeScript
DESCRIPTION: Shows how to handle a failing Effect using Promise catch() chain. The effect contains a failure that gets converted to a rejected promise.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

Effect.runPromise(Effect.fail("my error")).catch(console.error)
// Output:
// (FiberFailure) Error: my error

----------------------------------------

TITLE: Declaring mapInputEffect Function in TypeScript
DESCRIPTION: Defines the mapInputEffect function which transforms a sink's input elements using an effect. It has two overloads: one for curried usage and another for direct application.

LANGUAGE: typescript
CODE:
declare const mapInputEffect: { <In0, In, E2, R2>(f: (input: In0) => Effect.Effect<In, E2, R2>): <A, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In0, L, E2 | E, R2 | R>; <A, In, L, E, R, In0, E2, R2>(self: Sink<A, In, L, E, R>, f: (input: In0) => Effect.Effect<In, E2, R2>): Sink<A, In0, L, E | E2, R | R2>; }

----------------------------------------

TITLE: TypeScript Function Signature for HashSet.add in effect Package
DESCRIPTION: Provides the TypeScript function signature for the HashSet.add operation. It shows that the function can be used with both data-first and data-last calling conventions.

LANGUAGE: typescript
CODE:
declare const add: { <A>(value: A): (self: HashSet<A>) => HashSet<A>; <A>(self: HashSet<A>, value: A): HashSet<A>; }

----------------------------------------

TITLE: Retrieving First Element from Iterable using Effect.head in TypeScript
DESCRIPTION: This snippet demonstrates how to use the Effect.head function to retrieve the first element from an iterable. It handles potential empty collections by returning a NoSuchElementException if the collection is empty. The example shows an asynchronous operation simulated with a delay.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

// Simulate an async operation
const fetchNumbers = Effect.succeed([1, 2, 3]).pipe(Effect.delay("100 millis"))

const program = Effect.gen(function*() {
  const firstElement = yield* Effect.head(fetchNumbers)
  console.log(firstElement)
})

Effect.runFork(program)
// Output: 1

----------------------------------------

TITLE: Defining RequestAttributes Interface for GenAI Telemetry in TypeScript
DESCRIPTION: This code snippet defines the RequestAttributes interface, which specifies telemetry attributes for GenAI requests. It includes properties such as model name, temperature, sampling settings, token limits, and various penalties.

LANGUAGE: typescript
CODE:
export interface RequestAttributes {
    /**
     * The name of the GenAI model a request is being made to.
     */
    readonly model?: string | null | undefined
    /**
     * The temperature setting for the GenAI request.
     */
    readonly temperature?: number | null | undefined
    /**
     * The temperature setting for the GenAI request.
     */
    readonly topK?: number | null | undefined
    /**
     * The top_k sampling setting for the GenAI request.
     */
    readonly topP?: number | null | undefined
    /**
     * The top_p sampling setting for the GenAI request.
     */
    readonly maxTokens?: number | null | undefined
    /**
     * The encoding formats requested in an embeddings operation, if specified.
     */
    readonly encodingFormats?: ReadonlyArray<string> | null | undefined
    /**
     * List of sequences that the model will use to stop generating further
     * tokens.
     */
    readonly stopSequences?: ReadonlyArray<string> | null | undefined
    /**
     * The frequency penalty setting for the GenAI request.
     */
    readonly frequencyPenalty?: number | null | undefined
    /**
     * The presence penalty setting for the GenAI request.
     */
    readonly presencePenalty?: number | null | undefined
    /**
     * The seed setting for the GenAI request. Requests with same seed value
     * are more likely to return same result.
     */
    readonly seed?: number | null | undefined
  }

----------------------------------------

TITLE: Defining Chunk.contains Function in TypeScript
DESCRIPTION: Declares a function that checks if a Chunk contains a given value using the default Equivalence. It can be used in two ways: by passing the value first and the Chunk second, or vice versa.

LANGUAGE: typescript
CODE:
declare const contains: { <A>(a: A): (self: Chunk<A>) => boolean; <A>(self: Chunk<A>, a: A): boolean; }

----------------------------------------

TITLE: Implementing Exit.zip Function in TypeScript
DESCRIPTION: Defines a zip function that combines two Exit types, returning a tuple of their success values or the combined error causes. The function is overloaded to support both curried and uncurried calling styles.

LANGUAGE: typescript
CODE:
declare const zip: {
  <A2, E2>(that: Exit<A2, E2>): <A, E>(self: Exit<A, E>) => Exit<[A, A2], E2 | E>;
  <A, E, A2, E2>(self: Exit<A, E>, that: Exit<A2, E2>): Exit<[A, A2], E | E2>;
}

----------------------------------------

TITLE: Collecting Successful Results from Multiple Effects in TypeScript
DESCRIPTION: This code snippet demonstrates how to use the Effect.allSuccesses function to process an iterable of effects, collecting only the successful results while discarding failures. It showcases the function's ability to handle both successful and failed effects.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

const tasks = [
  Effect.succeed(1),
  Effect.fail("Error 1"),
  Effect.succeed(2),
  Effect.fail("Error 2")
]

const program = Effect.gen(function*() {
  const successfulResults = yield* Effect.allSuccesses(tasks)
  console.log(successfulResults)
})

Effect.runFork(program)
// Output: [1, 2]

----------------------------------------

TITLE: Creating Tagged Structures with Schema.tag in TypeScript
DESCRIPTION: Demonstrates how to use Schema.tag to create a tagged structure for a User type. The tag property is automatically added when using the make method, serving as a type discriminator.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Schema } from "effect"

const User = Schema.Struct({
  _tag: Schema.tag("User"),
  name: Schema.String,
  age: Schema.Number
})

assert.deepStrictEqual(User.make({ name: "John", age: 44 }), { _tag: "User", name: "John", age: 44 })

LANGUAGE: typescript
CODE:
declare const tag: <Tag extends AST.LiteralValue>(tag: Tag) => tag<Tag>

----------------------------------------

TITLE: Generating Random Integers with Effect-TS
DESCRIPTION: Function declaration for generating the next pseudo-random integer value. Returns an Effect that produces a number with no error channel and no environment requirements.

LANGUAGE: typescript
CODE:
declare const nextInt: Effect.Effect<number, never, never>

----------------------------------------

TITLE: Implementing Function Application Between Effects in TypeScript
DESCRIPTION: Defines a function that combines two effects by applying a function produced by one effect to a value produced by another effect. The function supports both curried and uncurried calling styles and handles effect composition with proper type inference.

LANGUAGE: typescript
CODE:
declare const ap: {
  <A, E2, R2>(that: Effect<A, E2, R2>): <B, R, E>(self: Effect<(a: A) => B, E, R>) => Effect<B, E | E2, R | R2>;
  <A, B, E, R, E2, R2>(self: Effect<(a: A) => B, E, R>, that: Effect<A, E2, R2>): Effect<B, E | E2, R | R2>;
}

----------------------------------------

TITLE: Splitting Stream Elements with Predicate in TypeScript
DESCRIPTION: Demonstrates how to split a stream of numbers into chunks based on a predicate function. The example shows splitting a range of numbers 1-10 into chunks where the splitting occurs when a number is divisible by 4.

LANGUAGE: typescript
CODE:
import { pipe, Stream } from "effect"

pipe(
  Stream.range(1, 10),
  Stream.split((n) => n % 4 === 0),
  Stream.runCollect
)
// => Chunk(Chunk(1, 2, 3), Chunk(5, 6, 7), Chunk(9))

LANGUAGE: typescript
CODE:
declare const split: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): <E, R>(self: Stream<A, E, R>) => Stream<Chunk.Chunk<Exclude<A, B>>, E, R>; <A>(predicate: Predicate<NoInfer<A>>): <E, R>(self: Stream<A, E, R>) => Stream<Chunk.Chunk<A>, E, R>; <A, E, R, B extends A>(self: Stream<A, E, R>, refinement: Refinement<A, B>): Stream<Chunk.Chunk<Exclude<A, B>>, E, R>; <A, E, R>(self: Stream<A, E, R>, predicate: Predicate<A>): Stream<Chunk.Chunk<A>, E, R>; }

----------------------------------------

TITLE: Converting DateTime to Period Start in TypeScript
DESCRIPTION: Demonstrates how to convert a DateTime object to the start of a specified time unit (e.g., day, week, month). Includes support for customizing week start day through the weekStartsOn option.

LANGUAGE: typescript
CODE:
import { DateTime } from "effect"

// returns "2024-01-01T00:00:00Z"
DateTime.unsafeMake("2024-01-01T12:00:00Z").pipe(
  DateTime.startOf("day"),
  DateTime.formatIso
)

LANGUAGE: typescript
CODE:
declare const startOf: { (part: DateTime.UnitSingular, options?: { readonly weekStartsOn?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | undefined; }): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, part: DateTime.UnitSingular, options?: { readonly weekStartsOn?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | undefined; }): A; }

----------------------------------------

TITLE: Implementing Partition Operation in STM Module
DESCRIPTION: Function that takes elements of type A and a transformation function returning an STM effect. It processes each element and returns a tuple containing arrays of failures and successes. The operation is transactional and can be used in STM contexts.

LANGUAGE: typescript
CODE:
declare const partition: {
  <A, A2, E, R>(f: (a: A) => STM<A2, E, R>): (elements: Iterable<A>) => STM<[excluded: Array<E>, satisfying: Array<A2>], never, R>;
  <A, A2, E, R>(elements: Iterable<A>, f: (a: A) => STM<A2, E, R>): STM<[excluded: Array<E>, satisfying: Array<A2>], never, R>;
}

----------------------------------------

TITLE: Combining Options using Option.all in TypeScript
DESCRIPTION: Demonstrates how to use Option.all to combine multiple Option instances into a single Option. Shows examples with both array/tuple and object/struct inputs, preserving the original structure in the output Option.

LANGUAGE: typescript
CODE:
import { Option } from "effect"

const maybeName: Option.Option<string> = Option.some("John")
const maybeAge: Option.Option<number> = Option.some(25)

//      ┌─── Option<[string, number]>
//      ▼
const tuple = Option.all([maybeName, maybeAge])
console.log(tuple)
// Output:
// { _id: 'Option', _tag: 'Some', value: [ 'John', 25 ] }

//      ┌─── Option<{ name: string; age: number; }>
//      ▼
const struct = Option.all({ name: maybeName, age: maybeAge })
console.log(struct)
// Output:
// { _id: 'Option', _tag: 'Some', value: { name: 'John', age: 25 } }

LANGUAGE: typescript
CODE:
declare const all: <const I extends Iterable<Option<any>> | Record<string, Option<any>>>(input: I) => [I] extends [ReadonlyArray<Option<any>>] ? Option<{ -readonly [K in keyof I]: [I[K]] extends [Option<infer A>] ? A : never; }> : [I] extends [Iterable<Option<infer A>>] ? Option<Array<A>> : Option<{ -readonly [K in keyof I]: [I[K]] extends [Option<infer A>] ? A : never; }>

----------------------------------------

TITLE: Flattening Iterables in Effect-TS Stream
DESCRIPTION: A function that takes a Stream containing Iterable elements and flattens them into a single Stream while preserving the error and resource types. This operation submerges the iterables carried by the stream into the stream's structure.

LANGUAGE: typescript
CODE:
declare const flattenIterables: <A, E, R>(self: Stream<Iterable<A>, E, R>) => Stream<A, E, R>

----------------------------------------

TITLE: String Splitting Schema Function in TypeScript
DESCRIPTION: Defines a function that creates a schema transformation from a string schema to an array of strings schema. The function takes a separator string parameter and returns a transform operation.

LANGUAGE: typescript
CODE:
declare const split: (separator: string) => transform<SchemaClass<string>, Array$<typeof String$>>

----------------------------------------

TITLE: Racing Multiple Successful Tasks with Effect.raceAll
DESCRIPTION: Demonstrates racing three successful tasks with different delays, showing how the first successful task completes while others are interrupted.

LANGUAGE: typescript
CODE:
import { Effect, Console } from "effect"

const task1 = Effect.succeed("task1").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Console.log("task1 done")),
  Effect.onInterrupt(() => Console.log("task1 interrupted"))
)
const task2 = Effect.succeed("task2").pipe(
  Effect.delay("200 millis"),
  Effect.tap(Console.log("task2 done")),
  Effect.onInterrupt(() => Console.log("task2 interrupted"))
)

const task3 = Effect.succeed("task3").pipe(
  Effect.delay("150 millis"),
  Effect.tap(Console.log("task3 done")),
  Effect.onInterrupt(() => Console.log("task3 interrupted"))
)

const program = Effect.raceAll([task1, task2, task3])

Effect.runFork(program)

----------------------------------------

TITLE: Implementing Random Service Access in Effect TypeScript
DESCRIPTION: A function that retrieves the Random service from the context and uses it to execute a specified effect. Takes a function parameter that receives the Random service and returns an Effect.

LANGUAGE: typescript
CODE:
declare const randomWith: <A, E, R>(f: (random: Random.Random) => Effect<A, E, R>) => Effect<A, E, R>

----------------------------------------

TITLE: Implementing Tagged Error Handling in Effect Streams
DESCRIPTION: Defines a function that handles stream errors by matching on error _tag properties. It allows switching to alternative streams based on specific error tags, providing type-safe error handling for tagged union types.

LANGUAGE: typescript
CODE:
declare const catchTags: { <E extends { _tag: string; }, Cases extends { [K in E["_tag"]]+?: (error: Extract<E, { _tag: K; }>) => Stream<any, any, any>; }>(cases: Cases): <A, R>(self: Stream<A, E, R>) => Stream<A | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Stream.Variance<infer A, infer _E, infer _R> ? A : never; }[keyof Cases], Exclude<E, { _tag: keyof Cases; }> | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Stream.Variance<infer _A, infer E, infer _R> ? E : never; }[keyof Cases], R | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Stream.Variance<infer _A, infer _E, infer R> ? R : never; }[keyof Cases]>; <A, E extends { _tag: string; }, R, Cases extends { [K in E["_tag"]]+?: (error: Extract<E, { _tag: K; }>) => Stream<any, any, any>; }>(self: Stream<A, E, R>, cases: Cases): Stream<A | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Stream.Variance<infer _R, infer _E, infer A> ? A : never; }[keyof Cases], Exclude<E, { _tag: keyof Cases; }> | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Stream.Variance<infer _R, infer E, infer _A> ? E : never; }[keyof Cases], R | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => Stream.Variance<infer R, infer _E, infer _A> ? R : never; }[keyof Cases]>; }

----------------------------------------

TITLE: Effect.option Function Signature in TypeScript
DESCRIPTION: This code snippet shows the TypeScript signature of the Effect.option function. It takes an Effect as input and returns a new Effect with the result wrapped in an Option type.

LANGUAGE: typescript
CODE:
declare const option: <A, E, R>(self: Effect<A, E, R>) => Effect<Option.Option<A>, never, R>

----------------------------------------

TITLE: Implementing Effect.ignoreLogged Function in TypeScript
DESCRIPTION: Function signature for ignoreLogged that takes an Effect and returns a new Effect that ignores the result but logs failures. The function transforms an Effect<A, E, R> into Effect<void, never, R>, meaning it voids the success type and never fails.

LANGUAGE: typescript
CODE:
declare const ignoreLogged: <A, E, R>(self: Effect<A, E, R>) => Effect<void, never, R>

----------------------------------------

TITLE: Implementing dropUntilEffect for Streams in TypeScript
DESCRIPTION: The `dropUntilEffect` function drops all elements of a stream until the specified effectful predicate evaluates to true. It takes a predicate function that returns an Effect, and applies it to a Stream, returning a new Stream with elements dropped until the predicate is satisfied.

LANGUAGE: typescript
CODE:
declare const dropUntilEffect: {
  <A, E2, R2>(predicate: (a: NoInfer<A>) => Effect.Effect<boolean, E2, R2>):
    <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>;
  <A, E, R, E2, R2>(self: Stream<A, E, R>, predicate: (a: NoInfer<A>) => Effect.Effect<boolean, E2, R2>):
    Stream<A, E | E2, R | R2>;
}

----------------------------------------

TITLE: Executing SQL Query with Schema Validation in TypeScript
DESCRIPTION: Defines a function 'findAll' that takes request and result schemas, along with an execution function. It returns a function that accepts a request, validates it, executes the query, and validates the result. The function uses Effect for handling asynchronous operations and potential errors.

LANGUAGE: typescript
CODE:
declare const findAll: <IR, II, IA, AR, AI, A, R, E>(options: { readonly Request: Schema.Schema<IA, II, IR>; readonly Result: Schema.Schema<A, AI, AR>; readonly execute: (request: II) => Effect.Effect<ReadonlyArray<unknown>, E, R>; }) => (request: IA) => Effect.Effect<ReadonlyArray<A>, E | ParseError, R | IR | AR>

----------------------------------------

TITLE: Using Effect.filterMap to Filter and Map Elements in TypeScript
DESCRIPTION: This example demonstrates how to use Effect.filterMap to process a list of tasks, keeping only the even-numbered tasks. It shows the sequential execution of tasks and the filtering process.

LANGUAGE: typescript
CODE:
import { Console, Effect, Option } from "effect"

const task = (n: number) =>
  Effect.succeed(n).pipe(
    Effect.delay(1000 - (n * 100)),
    Effect.tap(Console.log(`task${n} done`))
  )

const program = Effect.filterMap(
  [task(1), task(2), task(3), task(4)],
  (n) => n % 2 === 0 ? Option.some(n) : Option.none()
)

Effect.runPromise(program).then(console.log)
// Output:
// task1 done
// task2 done
// task3 done
// task4 done
// [ 2, 4 ]

----------------------------------------

TITLE: Implementing Fallback Sink Operation in TypeScript
DESCRIPTION: Defines a higher-order function that takes two Sinks and returns a new Sink that falls back to the second Sink if the first one fails. The function supports generic types for input, output, error, and result types, allowing for flexible type combinations between the original and fallback Sinks.

LANGUAGE: typescript
CODE:
declare const orElse: { <A2, In2, L2, E2, R2>(that: LazyArg<Sink<A2, In2, L2, E2, R2>>): <A, In, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A2 | A, In & In2, L2 | L, E2 | E, R2 | R>; <A, In, L, E, R, A2, In2, L2, E2, R2>(self: Sink<A, In, L, E, R>, that: LazyArg<Sink<A2, In2, L2, E2, R2>>): Sink<A | A2, In & In2, L | L2, E | E2, R | R2>; }

----------------------------------------

TITLE: Array.partitionMap Type Signature in TypeScript
DESCRIPTION: Type declaration for the partitionMap function showing its polymorphic nature and support for both curried and non-curried forms. The function accepts an iterable and a mapping function that produces Either values.

LANGUAGE: typescript
CODE:
declare const partitionMap: { <A, B, C>(f: (a: A, i: number) => Either.Either<C, B>): (self: Iterable<A>) => [left: Array<B>, right: Array<C>]; <A, B, C>(self: Iterable<A>, f: (a: A, i: number) => Either.Either<C, B>): [left: Array<B>, right: Array<C>]; }

----------------------------------------

TITLE: Implementing collectWhile Schedule Function in TypeScript
DESCRIPTION: Defines a function that creates a schedule to collect inputs into a Chunk while a predicate function returns true. The schedule stops collecting when the predicate function returns false.

LANGUAGE: typescript
CODE:
declare const collectWhile: <A>(f: Predicate<A>) => Schedule<Chunk.Chunk<A>, A>

----------------------------------------

TITLE: Type Signature for Identity Function in TypeScript
DESCRIPTION: Provides the TypeScript type signature for the identity function. It's a generic function that takes an argument of type A and returns the same type A, effectively preserving the input type.

LANGUAGE: typescript
CODE:
declare const identity: <A>(a: A) => A

----------------------------------------

TITLE: Defining ensuringChildren Function in Effect Module (TypeScript)
DESCRIPTION: Declares the ensuringChildren function which acts on the children of a fiber, ensuring a specified callback is invoked regardless of the effect's success. It takes a callback function for children fibers and returns a new effect.

LANGUAGE: typescript
CODE:
declare const ensuringChildren: { <X, R2>(children: (fibers: ReadonlyArray<Fiber.RuntimeFiber<any, any>>) => Effect<X, never, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R2 | R>; <A, E, R, X, R2>(self: Effect<A, E, R>, children: (fibers: ReadonlyArray<Fiber.RuntimeFiber<any, any>>) => Effect<X, never, R2>): Effect<A, E, R | R2>; }

----------------------------------------

TITLE: Implementing findLast Function in TypeScript for Chunk Module
DESCRIPTION: The findLast function is an overloaded function that searches for the last element in a Chunk that meets certain criteria. It can be used with either a refinement or a predicate, and can be called with the Chunk as the first argument or as a curried function.

LANGUAGE: typescript
CODE:
declare const findLast: {
  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: Chunk<A>) => Option<B>;
  <A>(predicate: Predicate<NoInfer<A>>): (self: Chunk<A>) => Option<A>;
  <A, B extends A>(self: Chunk<A>, refinement: Refinement<A, B>): Option<B>;
  <A>(self: Chunk<A>, predicate: Predicate<A>): Option<A>;
}

----------------------------------------

TITLE: Collecting Exit Values in TypeScript
DESCRIPTION: Function that collects multiple Exit values into a single Exit containing a List. Returns Some<Exit<List<A>, E>> if the iterable contains elements, or None if empty. Accepts an optional parallel execution parameter.

LANGUAGE: typescript
CODE:
declare const all: <A, E>(exits: Iterable<Exit<A, E>>, options?: { readonly parallel?: boolean | undefined; } | undefined) => Option.Option<Exit<Array<A>, E>>

----------------------------------------

TITLE: Creating Nominal Types with Brand.nominal in TypeScript
DESCRIPTION: Demonstrates how to create and use nominal types using Brand.nominal from the Effect library. This allows distinguishing between values of the same type but with different semantic meanings, without applying runtime checks.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Brand } from "effect"

type UserId = number & Brand.Brand<"UserId">

const UserId = Brand.nominal<UserId>()

console.log(UserId(1))
// 1

LANGUAGE: typescript
CODE:
declare const nominal: <A extends Brand<any>>() => Brand.Constructor<A>

----------------------------------------

TITLE: Racing Two Failing Effects in TypeScript
DESCRIPTION: Illustrates racing two effects that both fail, resulting in a Cause containing both failures.

LANGUAGE: typescript
CODE:
import { Effect, Console } from "effect"

const task1 = Effect.fail("task1").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Console.log("task1 done")),
  Effect.onInterrupt(() => Console.log("task1 interrupted"))
)
const task2 = Effect.fail("task2").pipe(
  Effect.delay("200 millis"),
  Effect.tap(Console.log("task2 done")),
  Effect.onInterrupt(() => Console.log("task2 interrupted"))
)

const program = Effect.race(task1, task2)

Effect.runPromiseExit(program).then(console.log)
// Output:
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: {
//     _id: 'Cause',
//     _tag: 'Parallel',
//     left: { _id: 'Cause', _tag: 'Fail', failure: 'task1' },
//     right: { _id: 'Cause', _tag: 'Fail', failure: 'task2' }
//   }
// }

----------------------------------------

TITLE: Implementing Discriminator Pattern Matching in TypeScript using Effect Match
DESCRIPTION: Demonstrates how to use Match.discriminator to perform pattern matching on objects with discriminated union structure. The example shows matching different object types based on a 'type' field discriminator.

LANGUAGE: typescript
CODE:
import { Match, pipe } from "effect"

const match = pipe(
  Match.type<{ type: "A"; a: string } | { type: "B"; b: number } | { type: "C"; c: boolean }>(),
  Match.discriminator("type")("A", "B", (_) => `A or B: ${_.type}`),
  Match.discriminator("type")("C", (_) => `C(${_.c})`),
  Match.exhaustive
)

LANGUAGE: typescript
CODE:
declare const discriminator: <D extends string>(field: D) => <R, P extends Types.Tags<D, R> & string, Ret, Fn extends (_: Extract<R, Record<D, P>>) => Ret>(...pattern: [first: P, ...values: Array<P>, f: Fn]) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr, Ret>) => Matcher<I, Types.AddWithout<F, Extract<R, Record<D, P>>>, Types.ApplyFilters<I, Types.AddWithout<F, Extract<R, Record<D, P>>>>, A | ReturnType<Fn>, Pr, Ret>

----------------------------------------

TITLE: Retrieving TestConfig Service in Effect (TypeScript)
DESCRIPTION: Defines a constant 'testConfig' that represents an Effect for retrieving the TestConfig service. This Effect has no requirements and cannot fail, always returning a TestConfig.TestConfig instance.

LANGUAGE: typescript
CODE:
declare const testConfig: Effect.Effect<TestConfig.TestConfig, never, never>

----------------------------------------

TITLE: Mapping HashMap Entries in TypeScript
DESCRIPTION: Defines a map function for transforming entries in a HashMap. It takes a function that operates on each value-key pair and returns a new HashMap with the transformed values. The function can be used in both curried and non-curried forms.

LANGUAGE: typescript
CODE:
declare const map: { <A, V, K>(f: (value: V, key: K) => A): (self: HashMap<K, V>) => HashMap<K, A>; <K, V, A>(self: HashMap<K, V>, f: (value: V, key: K) => A): HashMap<K, A>; }

----------------------------------------

TITLE: Converting Stream to Queue in Effect-TS
DESCRIPTION: The toQueue function converts a stream to a scoped queue of chunks. It supports various back pressure strategies and has a default capacity of 2. The function returns an Effect that produces a Dequeue of Take values.

LANGUAGE: TypeScript
CODE:
declare const toQueue: { (options?: { readonly strategy?: "dropping" | "sliding" | "suspend" | undefined; readonly capacity?: number | undefined; } | { readonly strategy: "unbounded"; } | undefined): <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<Queue.Dequeue<Take.Take<A, E>>, never, Scope.Scope | R>; <A, E, R>(self: Stream<A, E, R>, options?: { readonly strategy?: "dropping" | "sliding" | "suspend" | undefined; readonly capacity?: number | undefined; } | { readonly strategy: "unbounded"; } | undefined): Effect.Effect<Queue.Dequeue<Take.Take<A, E>>, never, Scope.Scope | R>; }

----------------------------------------

TITLE: Publishing Messages with PubSub in TypeScript
DESCRIPTION: Function signature for publishing messages to a PubSub instance. The function is overloaded to accept either curried or direct parameter passing styles, returning an Effect containing a boolean indicating publish success.

LANGUAGE: typescript
CODE:
declare const publish: { <A>(value: A): (self: PubSub<A>) => Effect.Effect<boolean>; <A>(self: PubSub<A>, value: A): Effect.Effect<boolean>; }

----------------------------------------

TITLE: Using filterEffectOrFail with Authentication Example
DESCRIPTION: Demonstrates how to use filterEffectOrFail to handle authentication by filtering nullable user results and converting failed cases to custom errors.

LANGUAGE: typescript
CODE:
import { Effect, pipe } from "effect"

// Define a user interface
interface User {
  readonly name: string
}

// Simulate an asynchronous authentication function
declare const auth: () => Promise<User | null>

const program = pipe(
  Effect.promise(() => auth()),
  // Use filterEffectOrFail with an effectful predicate
  Effect.filterEffectOrFail({
    predicate: (user) => Effect.succeed(user !== null),
    orFailWith: () => new Error("Unauthorized")
  }),
)

----------------------------------------

TITLE: Defining Schedule.identity Function in TypeScript
DESCRIPTION: Declares a generic function identity that creates a Schedule which passes input values directly as output. This schedule runs indefinitely, acting as a pass-through for each input value.

LANGUAGE: typescript
CODE:
declare const identity: <A>() => Schedule<A, A>

----------------------------------------

TITLE: Creating Bounded TPubSub with Back Pressure in TypeScript
DESCRIPTION: This function creates a bounded TPubSub that retains messages until taken by all subscribers. It applies back pressure to publishers when at capacity. The function takes a requested capacity as a parameter and returns an STM effect that produces a TPubSub.

LANGUAGE: typescript
CODE:
declare const bounded: <A>(requestedCapacity: number) => STM.STM<TPubSub<A>>

----------------------------------------

TITLE: Using Stream.toPull in TypeScript with Effect
DESCRIPTION: Demonstrates how to use Stream.toPull to convert a stream into a pull-based effect that retrieves chunks of data. The example creates a stream from an array, rechunks it into groups of 2, and continuously pulls chunks until the stream is exhausted.

LANGUAGE: typescript
CODE:
import { Effect, Stream } from "effect"

// Simulate a chunked stream
const stream = Stream.fromIterable([1, 2, 3, 4, 5]).pipe(Stream.rechunk(2))

const program = Effect.gen(function*() {
  // Create an effect to get data chunks from the stream
  const getChunk = yield* Stream.toPull(stream)

  // Continuously fetch and process chunks
  while (true) {
    const chunk = yield* getChunk
    console.log(chunk)
  }
})

Effect.runPromise(Effect.scoped(program)).then(console.log, console.error)
// { _id: 'Chunk', values: [ 1, 2 ] }
// { _id: 'Chunk', values: [ 3, 4 ] }
// { _id: 'Chunk', values: [ 5 ] }
// (FiberFailure) Error: {
//   "_id": "Option",
//   "_tag": "None"
// }

----------------------------------------

TITLE: Declaring toReadableStream Function in TypeScript
DESCRIPTION: Defines the toReadableStream function signature for converting a Stream to a ReadableStream. It includes options for specifying a queuing strategy and supports both curried and non-curried versions.

LANGUAGE: typescript
CODE:
declare const toReadableStream: { <A>(options?: { readonly strategy?: QueuingStrategy<A> | undefined; }): <E>(self: Stream<A, E>) => ReadableStream<A>; <A, E>(self: Stream<A, E>, options?: { readonly strategy?: QueuingStrategy<A> | undefined; }): ReadableStream<A>; }

----------------------------------------

TITLE: Implementing TQueue.seek Function in TypeScript
DESCRIPTION: Defines the 'seek' function for TQueue, which drops elements from the queue until finding one that satisfies a given predicate. It operates within an STM context and retries if no satisfying element is found.

LANGUAGE: typescript
CODE:
declare const seek: { <A>(predicate: Predicate<A>): (self: TDequeue<A>) => STM.STM<A>; <A>(self: TDequeue<A>, predicate: Predicate<A>): STM.STM<A>; }

----------------------------------------

TITLE: Implementing Array.tail Function in TypeScript for Effect-TS
DESCRIPTION: Defines the 'tail' function that returns all but the first element of an Iterable as a new Array, or None if the Iterable is empty. It operates on Iterable<A> and returns Option<Array<A>>.

LANGUAGE: typescript
CODE:
declare const tail: <A>(self: Iterable<A>) => Option.Option<Array<A>>

----------------------------------------

TITLE: Using Array.contains in TypeScript with Effect Library
DESCRIPTION: Demonstrates how to use the Array.contains function to check if an array includes a specific value. The function returns a boolean indicating whether the value is present in the array.

LANGUAGE: typescript
CODE:
import { Array, pipe } from "effect"

const result = pipe(['a', 'b', 'c', 'd'], Array.contains('c'))
console.log(result) // true

----------------------------------------

TITLE: Transforming Exit Error Types with mapError in TypeScript
DESCRIPTION: Function signature for mapError, which maps over the error contained in the Failure case of an Exit type. Supports both curried and uncurried calling styles for transforming error types from E to E2 while preserving the success type A.

LANGUAGE: typescript
CODE:
declare const mapError: { <E, E2>(f: (e: E) => E2): <A>(self: Exit<A, E>) => Exit<A, E2>; <A, E, E2>(self: Exit<A, E>, f: (e: E) => E2): Exit<A, E2>; }

----------------------------------------

TITLE: Defining interruptWhen Function in TypeScript for Effect Library
DESCRIPTION: This code snippet defines the interruptWhen function, which creates a new channel that can be interrupted when a specified effect completes. The function handles different scenarios of completion between the effect and the underlying channel.

LANGUAGE: typescript
CODE:
declare const interruptWhen: {
  <OutDone1, OutErr1, Env1>(effect: Effect.Effect<OutDone1, OutErr1, Env1>):
    <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>
    (self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) =>
      Channel<OutElem, InElem, OutErr1 | OutErr, InErr, OutDone1 | OutDone, InDone, Env1 | Env>;
  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutDone1, OutErr1, Env1>
  (self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,
   effect: Effect.Effect<OutDone1, OutErr1, Env1>):
     Channel<OutElem, InElem, OutErr | OutErr1, InErr, OutDone | OutDone1, InDone, Env | Env1>;
}

----------------------------------------

TITLE: Using Option.flatMap with TypeScript in Effect
DESCRIPTION: Demonstrates how to use Option.flatMap to chain computations on optional values, specifically extracting a nested optional street value from a user object.

LANGUAGE: typescript
CODE:
import { Option } from "effect"

interface Address {
  readonly city: string
  readonly street: Option.Option<string>
}

interface User {
  readonly id: number
  readonly username: string
  readonly email: Option.Option<string>
  readonly address: Option.Option<Address>
}

const user: User = {
  id: 1,
  username: "john_doe",
  email: Option.some("john.doe@example.com"),
  address: Option.some({
    city: "New York",
    street: Option.some("123 Main St")
  })
}

// Use flatMap to extract the street value
const street = user.address.pipe(
  Option.flatMap((address) => address.street)
)

console.log(street)
// Output: { _id: 'Option', _tag: 'Some', value: '123 Main St' }

----------------------------------------

TITLE: Effect orDie Type Signature
DESCRIPTION: Type declaration for the orDie function showing its generic parameters and return type. Takes an Effect with generic types for result (A), error (E), and environment (R), and returns an Effect with the error type set to never.

LANGUAGE: typescript
CODE:
declare const orDie: <A, E, R>(self: Effect<A, E, R>) => Effect<A, never, R>

----------------------------------------

TITLE: Implementing INFO Level Logging in Effect TypeScript
DESCRIPTION: Function signature for logging messages at INFO level in Effect. The function accepts variable arguments of any type and returns an Effect that never fails and has no requirements.

LANGUAGE: typescript
CODE:
declare const logInfo: (...message: ReadonlyArray<any>) => Effect<void, never, never>

----------------------------------------

TITLE: Defining Schema.transform Function in TypeScript
DESCRIPTION: This code snippet defines the signature of the Schema.transform function. It allows creating a new Schema by transforming the input and output of an existing Schema using decode and encode mapping functions. The function supports both strict and non-strict transformations.

LANGUAGE: typescript
CODE:
declare const transform: { <To extends Schema.Any, From extends Schema.Any>(to: To, options: { readonly decode: (fromA: Schema.Type<From>, fromI: Schema.Encoded<From>) => Schema.Encoded<To>; readonly encode: (toI: Schema.Encoded<To>, toA: Schema.Type<To>) => Schema.Type<From>; readonly strict?: true; } | { readonly decode: (fromA: Schema.Type<From>, fromI: Schema.Encoded<From>) => unknown; readonly encode: (toI: Schema.Encoded<To>, toA: Schema.Type<To>) => unknown; readonly strict: false; }): (from: From) => transform<From, To>; <To extends Schema.Any, From extends Schema.Any>(from: From, to: To, options: { readonly decode: (fromA: Schema.Type<From>, fromI: Schema.Encoded<From>) => Schema.Encoded<To>; readonly encode: (toI: Schema.Encoded<To>, toA: Schema.Type<To>) => Schema.Type<From>; readonly strict?: true; } | { readonly decode: (fromA: Schema.Type<From>, fromI: Schema.Encoded<From>) => unknown; readonly encode: (toI: Schema.Encoded<To>, toA: Schema.Type<To>) => unknown; readonly strict: false; }): transform<From, To>; }

----------------------------------------

TITLE: Reducing an Iterable with Effect.reduce in TypeScript
DESCRIPTION: This snippet demonstrates how to use Effect.reduce to process a collection of orders sequentially, accumulating the total price. It showcases the function's ability to handle asynchronous operations and maintain order.

LANGUAGE: typescript
CODE:
import { Console, Effect } from "effect"

const processOrder = (id: number) =>
  Effect.succeed({ id, price: 100 * id })
    .pipe(Effect.tap(() => Console.log(`Order ${id} processed`)), Effect.delay(500 - (id * 100)))

const program = Effect.reduce(
  [1, 2, 3, 4],
  0,
  (acc, id, i) =>
    processOrder(id)
      .pipe(Effect.map((order) => acc + order.price))
)

Effect.runPromise(program).then(console.log)
// Output:
// Order 1 processed
// Order 2 processed
// Order 3 processed
// Order 4 processed
// 1000

----------------------------------------

TITLE: Zipping Two Streams in TypeScript using Effect Library
DESCRIPTION: Demonstrates how to combine two streams into a single stream containing pairs of elements. The example shows zipping a numeric stream with a character stream, where the resulting stream ends when either input stream completes.

LANGUAGE: typescript
CODE:
import { Effect, Stream } from "effect"

// We create two streams and zip them together.
const stream = Stream.zip(
  Stream.make(1, 2, 3, 4, 5, 6),
  Stream.make("a", "b", "c")
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ [ 1, 'a' ], [ 2, 'b' ], [ 3, 'c' ] ] }

LANGUAGE: typescript
CODE:
declare const zip: { <A2, E2, R2>(that: Stream<A2, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<[A, A2], E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>): Stream<[A, A2], E | E2, R | R2>; }

----------------------------------------

TITLE: Creating HashMap from Iterable in TypeScript
DESCRIPTION: A function that creates a new HashMap from an iterable collection of key/value pairs. The function accepts an iterable of readonly tuples containing keys and values, and returns a new HashMap instance.

LANGUAGE: typescript
CODE:
declare const fromIterable: <K, V>(entries: Iterable<readonly [K, V]>) => HashMap<K, V>

----------------------------------------

TITLE: Modifying Array Elements Using Effect Array.modify
DESCRIPTION: Demonstrates how to use Array.modify to create a new array with a modified element at a specific index. The function takes an array, an index, and a transformation function that is applied to the element at that index.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const result = Array.modify([1, 2, 3, 4], 2, (n) => n * 2)
console.log(result) // [1, 2, 6, 4]

LANGUAGE: typescript
CODE:
declare const modify: { <A, B, S extends Iterable<A> = Iterable<A>>(i: number, f: (a: ReadonlyArray.Infer<S>) => B): (self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>; <A, B, S extends Iterable<A> = Iterable<A>>(self: S, i: number, f: (a: ReadonlyArray.Infer<S>) => B): ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>; }

----------------------------------------

TITLE: Parsing Strings to BigDecimal in TypeScript
DESCRIPTION: Demonstrates how to use BigDecimal.fromString to parse numerical strings into BigDecimal objects. The function returns an Option containing the parsed BigDecimal or None if parsing fails.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { BigDecimal, Option } from "effect"

assert.deepStrictEqual(BigDecimal.fromString("123"), Option.some(BigDecimal.make(123n, 0)))
assert.deepStrictEqual(BigDecimal.fromString("123.456"), Option.some(BigDecimal.make(123456n, 3)))
assert.deepStrictEqual(BigDecimal.fromString("123.abc"), Option.none())

----------------------------------------

TITLE: Implementing Scoped Fiber Management in TypeScript with Effect
DESCRIPTION: Demonstrates how to create and manage fibers within a local scope using Effect.forkScoped. The example shows a child fiber that continues running independently of its parent fiber until the scope ends. The child fiber logs messages every second while the parent fiber runs for 3 seconds, all within a 5-second scope.

LANGUAGE: typescript
CODE:
import { Effect, Console, Schedule } from "effect"

// Child fiber that logs a message repeatedly every second
const child = Effect.repeat(
  Console.log("child: still running!"),
  Schedule.fixed("1 second")
)

//      ┌─── Effect<void, never, Scope>
//      ▼
const parent = Effect.gen(function* () {
  console.log("parent: started!")
  // Child fiber attached to local scope
  yield* Effect.forkScoped(child)
  yield* Effect.sleep("3 seconds")
  console.log("parent: finished!")
})

// Program runs within a local scope
const program = Effect.scoped(
  Effect.gen(function* () {
    console.log("Local scope started!")
    yield* Effect.fork(parent)
    // Scope lasts for 5 seconds
    yield* Effect.sleep("5 seconds")
    console.log("Leaving the local scope!")
  })
)

Effect.runFork(program)

----------------------------------------

TITLE: Checking Array Type with Effect Library
DESCRIPTION: Demonstrates how to use Array.isArray function from the Effect library to determine if a value is an array. The function performs type checking and returns a boolean value. It supports both regular arrays and readonly arrays.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

console.log(Array.isArray(null)) // false
console.log(Array.isArray([1, 2, 3])) // true

LANGUAGE: typescript
CODE:
declare const isArray: { (self: unknown): self is Array<unknown>; <T>(self: T): self is Extract<T, ReadonlyArray<any>>; }

----------------------------------------

TITLE: Using Match.tags for Discriminated Unions in TypeScript
DESCRIPTION: Demonstrates how to use Match.tags to handle discriminated unions by mapping _tag values to specific functions. The example shows handling three different types with tags A, B, and C.

LANGUAGE: typescript
CODE:
import { Match, pipe } from "effect"

const match = pipe(
  Match.type<{ _tag: "A"; a: string } | { _tag: "B"; b: number } | { _tag: "C"; c: boolean }>(),
  Match.tags({
    A: (a) => a.a,
    B: (b) => b.b,
    C: (c) => c.c
  }),
  Match.exhaustive
)

----------------------------------------

TITLE: Lifting Nullable Function to Option in TypeScript
DESCRIPTION: Demonstrates how to use Option.liftNullable to transform a function that might return null or undefined into a function that returns an Option. It includes an example of parsing a string to a number.

LANGUAGE: typescript
CODE:
import { Option } from "effect"

const parse = (s: string): number | undefined => {
  const n = parseFloat(s)
  return isNaN(n) ? undefined : n
}

const parseOption = Option.liftNullable(parse)

console.log(parseOption("1"))
// Output: { _id: 'Option', _tag: 'Some', value: 1 }

console.log(parseOption("not a number"))
// Output: { _id: 'Option', _tag: 'None' }

----------------------------------------

TITLE: HashSet.map Function Signature in TypeScript
DESCRIPTION: Provides the TypeScript signature for the HashSet.map function, showing its overloaded nature to support both data-first and data-last calling styles.

LANGUAGE: typescript
CODE:
declare const map: { <A, B>(f: (a: A) => B): (self: HashSet<A>) => HashSet<B>; <A, B>(self: HashSet<A>, f: (a: A) => B): HashSet<B>; }

----------------------------------------

TITLE: Using Stream.ensuring for Stream Finalization in TypeScript
DESCRIPTION: Demonstrates how to use Stream.ensuring to execute finalizers after a stream's completion. The example shows logging during stream execution, stream finalization, and post-finalization steps.

LANGUAGE: typescript
CODE:
import { Console, Effect, Stream } from "effect"

const program = Stream.fromEffect(Console.log("Application Logic.")).pipe(
  Stream.concat(Stream.finalizer(Console.log("Finalizing the stream"))),
  Stream.ensuring(
    Console.log("Doing some other works after stream's finalization")
  )
)

Effect.runPromise(Stream.runCollect(program)).then(console.log)
// Application Logic.
// Finalizing the stream
// Doing some other works after stream's finalization
// { _id: 'Chunk', values: [ undefined, undefined ] }

LANGUAGE: typescript
CODE:
declare const ensuring: { <X, R2>(finalizer: Effect.Effect<X, never, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R2 | R>; <A, E, R, X, R2>(self: Stream<A, E, R>, finalizer: Effect.Effect<X, never, R2>): Stream<A, E, R | R2>; }

----------------------------------------

TITLE: Using functionWithSpan in Effect
DESCRIPTION: Demonstrates how to wrap an effect-returning function with a tracing span. The example shows creating a getTodo function that includes span metadata with a custom name and attributes.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

const getTodo = Effect.functionWithSpan({
  body: (id: number) => Effect.succeed(`Got todo ${id}!`),
  options: (id) => ({
    name: `getTodo-${id}`,
    attributes: { id }
  })
})

----------------------------------------

TITLE: Creating an Asynchronous Push-Based Stream in TypeScript
DESCRIPTION: Demonstrates how to use Stream.asyncPush to create a stream that emits 'tick' every second. It includes setup and teardown logic using Effect.acquireRelease.

LANGUAGE: typescript
CODE:
import { Effect, Stream } from "effect"

Stream.asyncPush<string>((emit) =>
  Effect.acquireRelease(
    Effect.gen(function*() {
      yield* Effect.log("subscribing")
      return setInterval(() => emit.single("tick"), 1000)
    }),
    (handle) =>
      Effect.gen(function*() {
        yield* Effect.log("unsubscribing")
        clearInterval(handle)
      })
  ), { bufferSize: 16, strategy: "dropping" })

----------------------------------------

TITLE: Parsing URLs with Error Handling in TypeScript
DESCRIPTION: Demonstrates how to use Url.fromString to safely parse both absolute and relative URLs, handling potential errors with Either type. It shows examples of parsing an absolute URL and a relative URL with a base.

LANGUAGE: typescript
CODE:
import { Url } from "@effect/platform"
import { Either } from "effect"

// Parse an absolute URL
//
//      ┌─── Either<URL, IllegalArgumentException>
//      ▼
const parsed = Url.fromString("https://example.com/path")

if (Either.isRight(parsed)) {
  console.log("Parsed URL:", parsed.right.toString())
} else {
  console.log("Error:", parsed.left.message)
}
// Output: Parsed URL: https://example.com/path

// Parse a relative URL with a base
const relativeParsed = Url.fromString("/relative-path", "https://example.com")

if (Either.isRight(relativeParsed)) {
  console.log("Parsed relative URL:", relativeParsed.right.toString())
} else {
  console.log("Error:", relativeParsed.left.message)
}
// Output: Parsed relative URL: https://example.com/relative-path

----------------------------------------

TITLE: Stream.map Function Signature in TypeScript
DESCRIPTION: Provides the TypeScript signature for the Stream.map function. It shows two overloads: one for curried usage and another for direct application to a stream.

LANGUAGE: typescript
CODE:
declare const map: { <A, B>(f: (a: A) => B): <E, R>(self: Stream<A, E, R>) => Stream<B, E, R>; <A, E, R, B>(self: Stream<A, E, R>, f: (a: A) => B): Stream<B, E, R>; }

----------------------------------------

TITLE: Using Structured Logger in TypeScript with Effect
DESCRIPTION: This example demonstrates how to use the structured logger in a TypeScript program using the Effect library. It shows how to log messages, annotate logs, and add log spans.

LANGUAGE: typescript
CODE:
import { Effect, Logger } from "effect"

const program = Effect.log("message1", "message2").pipe(
  Effect.annotateLogs({ key1: "value1", key2: "value2" }),
  Effect.withLogSpan("myspan")
)

Effect.runFork(program.pipe(Effect.provide(Logger.structured)))
// {
//   message: [ 'message1', 'message2' ],
//   logLevel: 'INFO',
//   timestamp: '2024-07-09T14:05:41.623Z',
//   cause: undefined,
//   annotations: { key2: 'value2', key1: 'value1' },
//   spans: { myspan: 0 },
//   fiberId: '#0'
// }

----------------------------------------

TITLE: Using Effect.disconnect with Timeout Example
DESCRIPTION: Demonstrates how to use Effect.disconnect with a long-running task to handle timeouts while allowing the task to complete in the background. The example shows a simulated heavy processing task with a timeout that triggers after 1 second while the task runs for 5 seconds.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

const longRunningTask = Effect.gen(function* () {
  console.log("Start heavy processing...")
  yield* Effect.sleep("5 seconds") // Simulate a long process
  console.log("Heavy processing done.")
  return "Data processed"
})

const timedEffect = longRunningTask.pipe(
  Effect.uninterruptible,
  // Allows the task to finish in the background if it times out
  Effect.disconnect,
  Effect.timeout("1 second")
)

Effect.runPromiseExit(timedEffect).then(console.log)
// Output:
// Start heavy processing...
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: {
//     _id: 'Cause',
//     _tag: 'Fail',
//     failure: { _tag: 'TimeoutException' }
//   }
// }
// Heavy processing done.

----------------------------------------

TITLE: Using Effect.runPromiseExit for Success and Failure Handling in TypeScript
DESCRIPTION: Examples demonstrating how to use Effect.runPromiseExit to handle both successful and failing effects. Shows the structure of Exit objects for both success and failure cases, including the detailed Cause information for failures.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

// Execute a successful effect and get the Exit result as a Promise
Effect.runPromiseExit(Effect.succeed(1)).then(console.log)
// Output:
// {
//   _id: "Exit",
//   _tag: "Success",
//   value: 1
// }

// Execute a failing effect and get the Exit result as a Promise
Effect.runPromiseExit(Effect.fail("my error")).then(console.log)
// Output:
// {
//   _id: "Exit",
//   _tag: "Failure",
//   cause: {
//     _id: "Cause",
//     _tag: "Fail",
//     failure: "my error"
//   }
// }

----------------------------------------

TITLE: Defining scopedWith Function in Effect Module (TypeScript)
DESCRIPTION: Declares the scopedWith function, which creates a Scope, passes it to a specified effectful function, and closes the scope when the effect completes. It handles success, failure, and interruption scenarios.

LANGUAGE: typescript
CODE:
declare const scopedWith: <A, E, R>(f: (scope: Scope.Scope) => Effect<A, E, R>) => Effect<A, E, R>

----------------------------------------

TITLE: Converting Channel to PubSub in TypeScript
DESCRIPTION: Function that converts a Channel to a PubSub type. Takes a PubSub instance handling Either<Elem, Exit<Done, Err>> as input and returns a Channel that never requires input, emits Elem elements, handles Err errors, and completes with Done.

LANGUAGE: typescript
CODE:
declare const toPubSub: <Done, Err, Elem>(pubsub: PubSub.PubSub<Either.Either<Elem, Exit.Exit<Done, Err>>>) => Channel<never, Elem, never, Err, unknown, Done>

----------------------------------------

TITLE: Constructing Successful Channel in TypeScript
DESCRIPTION: The succeed function creates a channel that immediately succeeds with the specified value. It takes a value of type A and returns a Channel with complex type parameters.

LANGUAGE: typescript
CODE:
declare const succeed: <A>(value: A) => Channel<never, unknown, never, unknown, A, unknown>

----------------------------------------

TITLE: Effect.iterate Function Signature in TypeScript
DESCRIPTION: The type signature of the Effect.iterate function, showing its polymorphic nature and the structure of its options parameter. It accepts an initial value and options for the while condition and body operation.

LANGUAGE: typescript
CODE:
declare const iterate: { <A, B extends A, R, E>(initial: A, options: { readonly while: Refinement<A, B>; readonly body: (b: B) => Effect<A, E, R>; }): Effect<A, E, R>; <A, R, E>(initial: A, options: { readonly while: Predicate<A>; readonly body: (a: A) => Effect<A, E, R>; }): Effect<A, E, R>; }

----------------------------------------

TITLE: Demonstrating Effect.once Usage with Console Logging
DESCRIPTION: Example showing how Effect.once prevents repeated execution of an effect. The example contrasts regular effect repetition with once-wrapped effect behavior.

LANGUAGE: typescript
CODE:
import { Effect, Console } from "effect"

const program = Effect.gen(function* () {
  const task1 = Console.log("task1")
  yield* Effect.repeatN(task1, 2)
  const task2 = yield* Effect.once(Console.log("task2"))
  yield* Effect.repeatN(task2, 2)
})

Effect.runFork(program)
// Output:
// task1
// task1
// task1
// task2

----------------------------------------

TITLE: Initializing Empty Layer in Effect TypeScript
DESCRIPTION: Defines a Layer constructor that creates an empty Context. The Layer takes no input parameters (never), produces no errors (never), and provides no output (never).

LANGUAGE: typescript
CODE:
declare const empty: Layer<never, never, never>

----------------------------------------

TITLE: Implementing Stream.drop Function in TypeScript
DESCRIPTION: Defines the 'drop' function that removes a specified number of elements from the beginning of a stream. It can be called with the number of elements to drop as the first argument, or with the stream as the first argument and the number as the second.

LANGUAGE: typescript
CODE:
declare const drop: { (n: number): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, n: number): Stream<A, E, R>; }

----------------------------------------

TITLE: Defining Serializable Interface in TypeScript
DESCRIPTION: Defines a generic interface called Serializable that allows objects to specify their own serialization schema through a symbol property. The interface takes three type parameters A, I, and R to define the serialization types.

LANGUAGE: typescript
CODE:
export interface Serializable<A, I, R> {
  readonly [symbolSerializable]: Schema<A, I, R>
}

----------------------------------------

TITLE: Demonstrating Stream.debounce in TypeScript
DESCRIPTION: This example demonstrates the usage of Stream.debounce to delay emission of values in a stream. It shows how debounce can be used to filter out rapid successive events and only emit values after a specified pause.

LANGUAGE: typescript
CODE:
import { Effect, Stream } from "effect"

let last = Date.now()
const log = (message: string) =>
  Effect.sync(() => {
    const end = Date.now()
    console.log(`${message} after ${end - last}ms`)
    last = end
  })

const stream = Stream.make(1, 2, 3).pipe(
  Stream.concat(
    Stream.fromEffect(Effect.sleep("200 millis").pipe(Effect.as(4))) // Emit 4 after 200 ms
  ),
  Stream.concat(Stream.make(5, 6)), // Continue with more rapid values
  Stream.concat(
    Stream.fromEffect(Effect.sleep("150 millis").pipe(Effect.as(7))) // Emit 7 after 150 ms
  ),
  Stream.concat(Stream.make(8)),
  Stream.tap((n) => log(`Received ${n}`)),
  Stream.debounce("100 millis"), // Only emit values after a pause of at least 100 milliseconds,
  Stream.tap((n) => log(`> Emitted ${n}`))
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// Received 1 after 5ms
// Received 2 after 2ms
// Received 3 after 0ms
// > Emitted 3 after 104ms
// Received 4 after 99ms
// Received 5 after 1ms
// Received 6 after 0ms
// > Emitted 6 after 101ms
// Received 7 after 50ms
// Received 8 after 1ms
// > Emitted 8 after 101ms
// { _id: 'Chunk', values: [ 3, 6, 8 ] }

----------------------------------------

TITLE: TypeScript Function Signature for Effect.isFailure
DESCRIPTION: This snippet shows the TypeScript function signature for the Effect.isFailure function. It takes an Effect as input and returns an Effect that resolves to a boolean.

LANGUAGE: typescript
CODE:
declare const isFailure: <A, E, R>(self: Effect<A, E, R>) => Effect<boolean, never, R>

----------------------------------------

TITLE: Implementing Schedule Reduction in TypeScript
DESCRIPTION: The 'reduce' function creates a new schedule that folds over the outputs of an existing schedule. It uses an initial value and a reducer function to accumulate values over time. This is useful for tracking statistics, aggregating results, or summarizing data across multiple executions.

LANGUAGE: typescript
CODE:
declare const reduce: { <Out, Z>(zero: Z, f: (z: Z, out: Out) => Z): <In, R>(self: Schedule<Out, In, R>) => Schedule<Z, In, R>; <Out, In, R, Z>(self: Schedule<Out, In, R>, zero: Z, f: (z: Z, out: Out) => Z): Schedule<Z, In, R>; }

----------------------------------------

TITLE: Constructing Layer from Effect in TypeScript
DESCRIPTION: The Layer.effect function creates a layer from a given effect. It can be used with either one or two arguments: a context tag, or a context tag and an effect. The function returns a Layer with the specified input, error, and environment types.

LANGUAGE: typescript
CODE:
declare const effect: {
  <I, S>(tag: Context.Tag<I, S>): <E, R>(effect: Effect.Effect<Types.NoInfer<S>, E, R>) => Layer<I, E, R>;
  <I, S, E, R>(tag: Context.Tag<I, S>, effect: Effect.Effect<Types.NoInfer<S>, E, R>): Layer<I, E, R>;
}

----------------------------------------

TITLE: Converting Channel to Queue in TypeScript
DESCRIPTION: The toQueue function converts a Channel to a Queue. It takes a Queue.Enqueue of Either<Elem, Exit<Done, Err>> and returns a Channel with specific type parameters.

LANGUAGE: typescript
CODE:
declare const toQueue: <Done, Err, Elem>(queue: Queue.Enqueue<Either.Either<Elem, Exit.Exit<Done, Err>>>) => Channel<never, Elem, never, Err, unknown, Done>

----------------------------------------

TITLE: Implementing takeBetween Function for TQueue in TypeScript
DESCRIPTION: Defines a function takeBetween that takes a minimum and maximum number of elements from a TDequeue. It retries until at least the minimum number of elements are collected if fewer are initially available.

LANGUAGE: typescript
CODE:
declare const takeBetween: { (min: number, max: number): <A>(self: TDequeue<A>) => STM.STM<Array<A>>; <A>(self: TDequeue<A>, min: number, max: number): STM.STM<Array<A>>; }

----------------------------------------

TITLE: Checking Queue Fullness in TypeScript using Effect
DESCRIPTION: The isFull function checks if a Queue (Dequeue or Enqueue) contains at least one element. It returns an Effect that resolves to a boolean value: true if the Queue is not empty, false otherwise.

LANGUAGE: typescript
CODE:
declare const isFull: <A>(self: Dequeue<A> | Enqueue<A>) => Effect.Effect<boolean>

----------------------------------------

TITLE: Checking Effect Failure Status in TypeScript
DESCRIPTION: This snippet demonstrates how to use the Effect.isFailure function to check if an effect has failed. It shows examples of checking a failed effect and a defective effect.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

const failure = Effect.fail("Uh oh!")

console.log(Effect.runSync(Effect.isFailure(failure)))
// Output: true

const defect = Effect.dieMessage("BOOM!")

Effect.runSync(Effect.isFailure(defect))
// throws: BOOM!

----------------------------------------

TITLE: Defining Effect.schedule Function Signature in TypeScript
DESCRIPTION: Type definition for the schedule function that enables repeated execution of effects according to a specified schedule. The function supports two overloads - one taking schedule first and effect second, and another taking effect first and schedule second.

LANGUAGE: typescript
CODE:
declare const schedule: {
  <A, R2, Out>(schedule: Schedule.Schedule<Out, NoInfer<A> | undefined, R2>): <E, R>(self: Effect<A, E, R>) => Effect<Out, E, R2 | R>;
  <A, E, R, R2, Out>(self: Effect<A, E, R>, schedule: Schedule.Schedule<Out, A | undefined, R2>): Effect<Out, E, R | R2>;
}

----------------------------------------

TITLE: Modifying HashMap Values in TypeScript
DESCRIPTION: The modify function updates the value of a specified key within a HashMap if it exists. It can be used in two ways: as a curried function or with all arguments provided at once.

LANGUAGE: typescript
CODE:
declare const modify: { <K, V>(key: K, f: (v: V) => V): (self: HashMap<K, V>) => HashMap<K, V>; <K, V>(self: HashMap<K, V>, key: K, f: (v: V) => V): HashMap<K, V>; }

----------------------------------------

TITLE: Removing Array Elements with Effect Library in TypeScript
DESCRIPTION: Demonstrates the usage of Array.remove function to delete an element at a specified index from an array. It creates a new array without modifying the original, and handles out-of-bounds indices by returning a copy of the input array.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const input = [1, 2, 3, 4]
const result = Array.remove(input, 2)
console.log(result) // [1, 2, 4]

const outOfBoundsResult = Array.remove(input, 5)
console.log(outOfBoundsResult) // [1, 2, 3, 4]

LANGUAGE: typescript
CODE:
declare const remove: { (i: number): <A>(self: Iterable<A>) => Array<A>; <A>(self: Iterable<A>, i: number): Array<A>; }

----------------------------------------

TITLE: Demonstrating unsafeCoerce Function Usage in TypeScript
DESCRIPTION: Shows how to use the unsafeCoerce function, which is equivalent to the identity function but allows type casting between any types A and B. The example demonstrates this equivalence using an assertion test.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { unsafeCoerce, identity } from "effect/Function"

assert.deepStrictEqual(unsafeCoerce, identity)

LANGUAGE: typescript
CODE:
declare const unsafeCoerce: <A, B>(a: A) => B

----------------------------------------

TITLE: Implementing Sink.splitWhere in TypeScript
DESCRIPTION: Function signature for splitWhere that splits a sink based on a predicate. The function takes a predicate and returns a new sink that consumes elements until an element after the first satisfies the predicate. Supports both curried and uncurried calling styles.

LANGUAGE: typescript
CODE:
declare const splitWhere: { <In>(f: Predicate<In>): <A, L extends In, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In, In, E, R>; <A, In, L extends In, E, R>(self: Sink<A, In, L, E, R>, f: Predicate<In>): Sink<A, In, In, E, R>; }

----------------------------------------

TITLE: Creating Stream from Iterable - TypeScript Example
DESCRIPTION: Demonstrates how to create a Stream from an array of numbers using Stream.fromIterable and collect the results using Effect.runPromise.

LANGUAGE: typescript
CODE:
import { Effect, Stream } from "effect"

const numbers = [1, 2, 3]

const stream = Stream.fromIterable(numbers)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 1, 2, 3 ] }

----------------------------------------

TITLE: Flattening Effect Values in Stream - TypeScript
DESCRIPTION: Function signature for flattenEffect operation that flattens Effect values into the stream structure. Supports optional configuration for concurrency and ordering control. Takes a Stream of Effect values and returns a Stream of the resolved values while preserving error and resource types.

LANGUAGE: typescript
CODE:
declare const flattenEffect: { 
  (options?: { readonly concurrency?: number | "unbounded" | undefined; readonly unordered?: boolean | undefined; } | undefined): <A, E2, R2, E, R>(self: Stream<Effect.Effect<A, E2, R2>, E, R>) => Stream<A, E2 | E, R2 | R>; 
  <A, E2, R2, E, R>(self: Stream<Effect.Effect<A, E2, R2>, E, R>, options?: { readonly concurrency?: number | "unbounded" | undefined; readonly unordered?: boolean | undefined; } | undefined): Stream<A, E2 | E, R2 | R>; 
}

----------------------------------------

TITLE: Using Stream.fail in TypeScript with Effect Package
DESCRIPTION: Demonstrates how to use the Stream.fail method to create a stream that terminates with a specified error. The example shows importing necessary modules, creating a failing stream, and running it to collect the result.

LANGUAGE: typescript
CODE:
import { Effect, Stream } from "effect"

const stream = Stream.fail("Uh oh!")

Effect.runPromiseExit(Stream.runCollect(stream)).then(console.log)
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: { _id: 'Cause', _tag: 'Fail', failure: 'Uh oh!' }
// }

----------------------------------------

TITLE: Extracting User Roles with Match.either in TypeScript
DESCRIPTION: Demonstrates how to use Match.either to extract user roles and handle matched and unmatched cases using Either. It creates a matcher for User objects and returns Either.Right for matched cases and Either.Left for unmatched cases.

LANGUAGE: typescript
CODE:
import { Match } from "effect"

type User = { readonly role: "admin" | "editor" | "viewer" }

// Create a matcher to extract user roles
const getRole = Match.type<User>().pipe(
  Match.when({ role: "admin" }, () => "Has full access"),
  Match.when({ role: "editor" }, () => "Can edit content"),
  Match.either // Wrap the result in an Either
)

console.log(getRole({ role: "admin" }))
// Output: { _id: 'Either', _tag: 'Right', right: 'Has full access' }

console.log(getRole({ role: "viewer" }))
// Output: { _id: 'Either', _tag: 'Left', left: { role: 'viewer' } }

----------------------------------------

TITLE: Merging Layers in Effect TypeScript
DESCRIPTION: Defines a merge operation that combines two layers concurrently, producing a new layer that combines their input and output types. The operation supports both curried and uncurried function signatures for flexibility in usage.

LANGUAGE: typescript
CODE:
declare const merge: { <RIn2, E2, ROut2>(that: Layer<ROut2, E2, RIn2>): <RIn, E1, ROut>(self: Layer<ROut, E1, RIn>) => Layer<ROut2 | ROut, E2 | E1, RIn2 | RIn>; <RIn, E1, ROut, RIn2, E2, ROut2>(self: Layer<ROut, E1, RIn>, that: Layer<ROut2, E2, RIn2>): Layer<ROut | ROut2, E1 | E2, RIn | RIn2>; }

----------------------------------------

TITLE: Using isIterable Type Guard in TypeScript
DESCRIPTION: Demonstrates how to use the isIterable predicate function to check if values are iterable. The function returns true for arrays and Sets, but false for null and plain objects.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { isIterable } from "effect/Predicate"

assert.deepStrictEqual(isIterable([]), true)
assert.deepStrictEqual(isIterable(new Set()), true)

assert.deepStrictEqual(isIterable(null), false)
assert.deepStrictEqual(isIterable({}), false)

LANGUAGE: typescript
CODE:
declare const isIterable: (input: unknown) => input is Iterable<unknown>

----------------------------------------

TITLE: Splitting Strings on Newlines in TypeScript Stream
DESCRIPTION: The `splitLines` function splits a stream of strings into individual lines. It handles both Windows (\r\n) and UNIX (\n) newline characters. This function operates on a Stream<string> and returns a new Stream<string> with each element representing a single line.

LANGUAGE: typescript
CODE:
declare const splitLines: <E, R>(self: Stream<string, E, R>) => Stream<string, E, R>

----------------------------------------

TITLE: Implementing Stream.zipAllRight in TypeScript
DESCRIPTION: Function signature for zipAllRight operation that combines two streams point-wise, keeping only elements from the second stream. Takes a default value parameter to handle cases where the first stream ends before the second.

LANGUAGE: typescript
CODE:
declare const zipAllRight: { <A2, E2, R2>(that: Stream<A2, E2, R2>, defaultRight: A2): <A, E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>, defaultRight: A2): Stream<A2, E | E2, R | R2>; }

----------------------------------------

TITLE: Comparing Optional Numbers Using Option.getEquivalence in TypeScript
DESCRIPTION: Example demonstrating how to use Option.getEquivalence to compare Option values containing numbers. Shows various comparison scenarios including None vs None, Some vs None, and Some vs Some comparisons.

LANGUAGE: typescript
CODE:
import { Number, Option } from "effect"

const isEquivalent = Option.getEquivalence(Number.Equivalence)

console.log(isEquivalent(Option.none(), Option.none()))
// Output: true

console.log(isEquivalent(Option.none(), Option.some(1)))
// Output: false

console.log(isEquivalent(Option.some(1), Option.none()))
// Output: false

console.log(isEquivalent(Option.some(1), Option.some(2)))
// Output: false

console.log(isEquivalent(Option.some(1), Option.some(1)))
// Output: true

----------------------------------------

TITLE: Creating HashSet from Array in TypeScript
DESCRIPTION: Demonstrates creating a HashSet from an array of numbers, automatically removing duplicates when converting to HashSet.

LANGUAGE: typescript
CODE:
import { HashSet, pipe } from "effect"

console.log(
  pipe(
    [1, 2, 3, 4, 5, 1, 2, 3], // Array<number> is an Iterable<number>;  Note the duplicates.
    HashSet.fromIterable,
    HashSet.toValues
  )
) // Output: [1, 2, 3, 4, 5]

----------------------------------------

TITLE: Pattern Matching with Match.tag in TypeScript
DESCRIPTION: Demonstrates how to use Match.tag for pattern matching on a discriminated union. The example defines an Event type with multiple variants and creates a matcher to handle different cases.

LANGUAGE: typescript
CODE:
import { Match } from "effect"

type Event =
  | { readonly _tag: "fetch" }
  | { readonly _tag: "success"; readonly data: string }
  | { readonly _tag: "error"; readonly error: Error }
  | { readonly _tag: "cancel" }

// Create a Matcher for Either<number, string>
const match = Match.type<Event>().pipe(
  // Match either "fetch" or "success"
  Match.tag("fetch", "success", () => `Ok!`),
  // Match "error" and extract the error message
  Match.tag("error", (event) => `Error: ${event.error.message}`),
  // Match "cancel"
  Match.tag("cancel", () => "Cancelled"),
  Match.exhaustive
)

console.log(match({ _tag: "success", data: "Hello" }))
// Output: "Ok!"

console.log(match({ _tag: "error", error: new Error("Oops!") }))
// Output: "Error: Oops!"

----------------------------------------

TITLE: Defining orElse Function for Either Type in TypeScript
DESCRIPTION: Declares the orElse function for the Either type. This function returns the original Either if it's a Right, or applies a provided function to the Left value to produce a new Either.

LANGUAGE: typescript
CODE:
declare const orElse: { <L, R2, L2>(that: (left: L) => Either<R2, L2>): <R>(self: Either<R, L>) => Either<R | R2, L2>; <R, L, R2, L2>(self: Either<R, L>, that: (left: L) => Either<R2, L2>): Either<R | R2, L2>; }

----------------------------------------

TITLE: Defining catchAllCause Function for Error Recovery in TypeScript Layers
DESCRIPTION: Declares a function catchAllCause that recovers from all errors in a Layer. It takes an error handler function and returns a new Layer that combines the original Layer with error recovery logic.

LANGUAGE: typescript
CODE:
declare const catchAllCause: { <E, RIn2, E2, ROut2>(onError: (cause: Cause.Cause<E>) => Layer<ROut2, E2, RIn2>): <RIn, ROut>(self: Layer<ROut, E, RIn>) => Layer<ROut & ROut2, E2, RIn2 | RIn>; <RIn, E, ROut, RIn2, E2, ROut22>(self: Layer<ROut, E, RIn>, onError: (cause: Cause.Cause<E>) => Layer<ROut22, E2, RIn2>): Layer<ROut & ROut22, E2, RIn | RIn2>; }

----------------------------------------

TITLE: Computing Set Difference with HashSet in TypeScript
DESCRIPTION: Demonstrates how to compute the set difference (A - B) between two HashSets using different syntax styles. The function has a time complexity of O(n) where n is the number of elements in the set. It's important to note that the hash and equal methods of the values in both sets must be compatible.

LANGUAGE: typescript
CODE:
// Syntax
import { HashSet, pipe } from "effect"

// with data-last, a.k.a. pipeable API
pipe(HashSet.make(1, 2, 3), HashSet.difference(HashSet.make(3, 4, 5)))

// or piped with the pipe function
HashSet.make(1, 2, 3).pipe(HashSet.difference(HashSet.make(3, 4, 5)))

// or with data-first API
HashSet.difference(HashSet.make(1, 2, 3), HashSet.make(3, 4, 5))

LANGUAGE: typescript
CODE:
declare const difference: { <A>(that: Iterable<A>): (self: HashSet<A>) => HashSet<A>; <A>(self: HashSet<A>, that: Iterable<A>): HashSet<A>; }

----------------------------------------

TITLE: Implementing List.map Function in TypeScript
DESCRIPTION: Defines a type-safe mapping function that transforms elements of a list. The function supports both curried and uncurried forms, allowing for flexible usage patterns. It takes a mapping function that receives both the current element and its index.

LANGUAGE: typescript
CODE:
declare const map: {
  <S extends List<any>, B>(f: (a: List.Infer<S>, i: number) => B): (self: S) => List.With<S, B>;
  <S extends List<any>, B>(self: S, f: (a: List.Infer<S>, i: number) => B): List.With<S, B>;
}

----------------------------------------

TITLE: Creating Channel from PubSub with Scoped Effect in TypeScript
DESCRIPTION: Function that constructs a Channel from a PubSub within a scoped effect. It takes a PubSub instance handling Either of elements or Exit types and returns an Effect wrapped Channel. The function operates within a Scope context.

LANGUAGE: typescript
CODE:
declare const fromPubSubScoped: <Done, Err, Elem>(pubsub: PubSub.PubSub<Either.Either<Elem, Exit.Exit<Done, Err>>>) => Effect.Effect<Channel<Elem, unknown, Err, unknown, Done, unknown>, never, Scope.Scope>

----------------------------------------

TITLE: Implementing BigInt Minimum Function in TypeScript
DESCRIPTION: Defines a 'min' function that returns the minimum of two BigInt values. The function is curried and can be called with one or two arguments.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { min } from "effect/BigInt"

assert.deepStrictEqual(min(2n, 3n), 2n)

LANGUAGE: typescript
CODE:
declare const min: { (that: bigint): (self: bigint) => bigint; (self: bigint, that: bigint): bigint; }

----------------------------------------

TITLE: Flattening Nested Micro Effects in TypeScript
DESCRIPTION: The flatten function takes a nested Micro effect and flattens it, combining the error and requirement types. It's useful for simplifying complex nested effect structures.

LANGUAGE: typescript
CODE:
declare const flatten: <A, E, R, E2, R2>(self: Micro<Micro<A, E, R>, E2, R2>) => Micro<A, E | E2, R | R2>

----------------------------------------

TITLE: Creating Boolean Arguments in Effect CLI
DESCRIPTION: The boolean function creates a boolean argument for the Effect CLI. It optionally accepts a configuration object to customize the argument. The function returns an Args<boolean> type.

LANGUAGE: typescript
CODE:
declare const boolean: (options?: Args.BaseArgsConfig) => Args<boolean>

----------------------------------------

TITLE: Using takeRight Method in TypeScript Array Module
DESCRIPTION: Demonstrates how to use the takeRight method to extract a specified number of elements from the end of an array. The method normalizes negative numbers and returns a new Array containing only the last n elements.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const result = Array.takeRight([1, 2, 3, 4, 5], 3)
console.log(result) // [3, 4, 5]

LANGUAGE: typescript
CODE:
declare const takeRight: { (n: number): <A>(self: Iterable<A>) => Array<A>; <A>(self: Iterable<A>, n: number): Array<A>; }

----------------------------------------

TITLE: Combining Sequential Causes in TypeScript Effect Package
DESCRIPTION: Defines a function that merges two Cause instances sequentially, typically used for combining a primary error with a subsequent finalization error. The function preserves both error information for complete failure tracking.

LANGUAGE: typescript
CODE:
declare const sequential: <E, E2>(left: Cause<E>, right: Cause<E2>) => Cause<E | E2>

----------------------------------------

TITLE: Demonstrating Either.fromNullable Usage in TypeScript
DESCRIPTION: This snippet demonstrates how to use the Either.fromNullable function to handle nullable values, converting them to Either.right for non-null values and Either.left for null values.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Either } from "effect"

assert.deepStrictEqual(Either.fromNullable(1, () => 'fallback'), Either.right(1))
assert.deepStrictEqual(Either.fromNullable(null, () => 'fallback'), Either.left('fallback'))

----------------------------------------

TITLE: Recovering from All Errors using Effect.catchAllCause in TypeScript
DESCRIPTION: This snippet demonstrates how to use Effect.catchAllCause to handle both recoverable and unrecoverable errors. It defines a program that may fail, then uses catchAllCause to recover from all types of errors by examining the cause.

LANGUAGE: typescript
CODE:
import { Cause, Effect } from "effect"

// Define an effect that may fail with a recoverable or unrecoverable error
const program = Effect.fail("Something went wrong!")

// Recover from all errors by examining the cause
const recovered = program.pipe(
  Effect.catchAllCause((cause) =>
    Cause.isFailType(cause)
      ? Effect.succeed("Recovered from a regular error")
      : Effect.succeed("Recovered from a defect")
  )
)

Effect.runPromise(recovered).then(console.log)
// Output: "Recovered from a regular error"

----------------------------------------

TITLE: Retrieving Context Values with Context.getOption in TypeScript
DESCRIPTION: Demonstrates how to use Context.getOption to retrieve values from a context using tags. It shows examples of successful retrieval and handling of missing tags.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Context, Option } from "effect"

const Port = Context.GenericTag<{ PORT: number }>("Port")
const Timeout = Context.GenericTag<{ TIMEOUT: number }>("Timeout")

const Services = Context.make(Port, { PORT: 8080 })

assert.deepStrictEqual(Context.getOption(Services, Port), Option.some({ PORT: 8080 }))
assert.deepStrictEqual(Context.getOption(Services, Timeout), Option.none())

----------------------------------------

TITLE: Using Stream.empty in TypeScript with Effect
DESCRIPTION: Demonstrates how to create an empty stream using Stream.empty and collect its results using Effect.runPromise and Stream.runCollect. The example shows that an empty stream results in an empty Chunk.

LANGUAGE: typescript
CODE:
import { Effect, Stream } from "effect"

const stream = Stream.empty

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [] }

----------------------------------------

TITLE: Using Stream.zipWithNext in TypeScript with Effect
DESCRIPTION: Demonstrates how to use Stream.zipWithNext to pair each element with its subsequent element in a stream. The example shows processing a stream of numbers where each element is paired with an Option containing the next value, with the last element paired with None.

LANGUAGE: typescript
CODE:
import { Chunk, Effect, Stream } from "effect"

const stream = Stream.zipWithNext(Stream.make(1, 2, 3, 4))

Effect.runPromise(Stream.runCollect(stream)).then((chunk) => console.log(Chunk.toArray(chunk)))
// [
//   [ 1, { _id: 'Option', _tag: 'Some', value: 2 } ],
//   [ 2, { _id: 'Option', _tag: 'Some', value: 3 } ],
//   [ 3, { _id: 'Option', _tag: 'Some', value: 4 } ],
//   [ 4, { _id: 'Option', _tag: 'None' } ]
// ]

LANGUAGE: typescript
CODE:
declare const zipWithNext: <A, E, R>(self: Stream<A, E, R>) => Stream<[A, Option.Option<A>], E, R>

----------------------------------------

TITLE: TypeScript Signature for bindAll Function
DESCRIPTION: Provides the complex TypeScript signature for the bindAll function, including its generic types and overloads. The signature shows the function's flexibility in handling different input types and options.

LANGUAGE: typescript
CODE:
declare const bindAll: { <A extends object, X extends Record<string, Effect<any, any, any>>, O extends NoExcessProperties<{ readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly mode?: "default" | "validate" | "either" | undefined; readonly concurrentFinalizers?: boolean | undefined; }, O>>(f: (a: NoInfer<A>) => [Extract<keyof X, keyof A>] extends [never] ? X : `Duplicate keys`, options?: undefined | O): <E1, R1>(self: Effect<A, E1, R1>) => [All.ReturnObject<X, false, All.ExtractMode<O>>] extends [Effect<infer Success, infer Error, infer Context>] ? Effect<{ [K in keyof A | keyof Success]: K extends keyof A ? A[K] : K extends keyof Success ? Success[K] : never; }, E1 | Error, R1 | Context> : never; <A extends object, X extends Record<string, Effect<any, any, any>>, O extends NoExcessProperties<{ readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly mode?: "default" | "validate" | "either" | undefined; readonly concurrentFinalizers?: boolean | undefined; }, O>, E1, R1>(self: Effect<A, E1, R1>, f: (a: NoInfer<A>) => [Extract<keyof X, keyof A>] extends [never] ? X : `Duplicate keys`, options?: undefined | { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly mode?: "default" | "validate" | "either" | undefined; readonly concurrentFinalizers?: boolean | undefined; }): [All.ReturnObject<X, false, All.ExtractMode<O>>] extends [Effect<infer Success, infer Error, infer Context>] ? Effect<{ [K in keyof A | keyof Success]: K extends keyof A ? A[K] : K extends keyof Success ? Success[K] : never; }, E1 | Error, R1 | Context> : never; }

----------------------------------------

TITLE: Reducing an Iterable with Early Termination in TypeScript
DESCRIPTION: Demonstrates how to use Effect.reduceWhile to process a list of orders, accumulating their prices until a threshold is reached. The function processes orders asynchronously and logs each processed order.

LANGUAGE: typescript
CODE:
import { Console, Effect } from "effect"

const processOrder = (id: number) =>
  Effect.succeed({ id, price: 100 * id })
    .pipe(Effect.tap(() => Console.log(`Order ${id} processed`)), Effect.delay(500 - (id * 100)))

const program = Effect.reduceWhile(
  [1, 2, 3, 4],
  0,
  {
    body: (acc, id, i) =>
      processOrder(id)
        .pipe(Effect.map((order) => acc + order.price)),
    while: (acc) => acc < 500
  }
)

Effect.runPromise(program).then(console.log)
// Output:
// Order 1 processed
// Order 2 processed
// Order 3 processed
// 600

----------------------------------------

TITLE: Implementing Stream.zipAllLeft in TypeScript
DESCRIPTION: Function signature for zipAllLeft operation that combines two streams while keeping only elements from the first stream. Takes a second stream and a default value to use when the second stream ends before the first. Returns a new stream containing elements from the first stream.

LANGUAGE: typescript
CODE:
declare const zipAllLeft: { <A2, E2, R2, A>(that: Stream<A2, E2, R2>, defaultLeft: A): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>, defaultLeft: A): Stream<A, E | E2, R | R2>; }

----------------------------------------

TITLE: Conditionally Executing Effects Based on Log Levels in TypeScript
DESCRIPTION: This snippet demonstrates how to use Effect.whenLogLevel to conditionally execute effects based on the current log level. It shows an example of logging messages at different levels and how they are affected by the minimum log level setting.

LANGUAGE: typescript
CODE:
import { Effect, Logger, LogLevel } from "effect"

const program = Effect.gen(function* () {
  yield* Effect.whenLogLevel(Effect.logTrace("message1"), LogLevel.Trace); // returns `None`
  yield* Effect.whenLogLevel(Effect.logDebug("message2"), LogLevel.Debug); // returns `Some`
}).pipe(Logger.withMinimumLogLevel(LogLevel.Debug));

Effect.runFork(program)
// timestamp=... level=DEBUG fiber=#0 message=message2

----------------------------------------

TITLE: Converting BigInt to Number with Safety Checks in TypeScript
DESCRIPTION: Demonstrates safe conversion of BigInt values to numbers using Option type, with bounds checking for JavaScript's safe integer range. Returns Option.none() if the value exceeds safe integer limits.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { BigInt as BI, Option } from "effect"

assert.deepStrictEqual(BI.toNumber(BigInt(42)), Option.some(42))
assert.deepStrictEqual(BI.toNumber(BigInt(Number.MAX_SAFE_INTEGER) + BigInt(1)), Option.none())
assert.deepStrictEqual(BI.toNumber(BigInt(Number.MIN_SAFE_INTEGER) - BigInt(1)), Option.none())

LANGUAGE: typescript
CODE:
declare const toNumber: (b: bigint) => Option.Option<number>

----------------------------------------

TITLE: Declaring Stream.prepend Function in TypeScript
DESCRIPTION: Defines the prepend function for Stream objects. It allows emitting a provided chunk of values before any other values in the stream. The function is overloaded to work with both curried and non-curried forms.

LANGUAGE: typescript
CODE:
declare const prepend: { <B>(values: Chunk.Chunk<B>): <A, E, R>(self: Stream<A, E, R>) => Stream<B | A, E, R>; <A, E, R, B>(self: Stream<A, E, R>, values: Chunk.Chunk<B>): Stream<A | B, E, R>; }

----------------------------------------

TITLE: Using Schema.NonEmptyTrimmedString for String Validation in TypeScript
DESCRIPTION: This snippet demonstrates how to use Schema.NonEmptyTrimmedString to validate strings. It shows examples of decoding empty strings, strings with whitespace, and valid non-empty trimmed strings.

LANGUAGE: typescript
CODE:
import { Schema } from "effect"

console.log(Schema.decodeOption(Schema.NonEmptyTrimmedString)("")) // Option.none()
console.log(Schema.decodeOption(Schema.NonEmptyTrimmedString)(" a ")) // Option.none()
console.log(Schema.decodeOption(Schema.NonEmptyTrimmedString)("a")) // Option.some("a")

----------------------------------------

TITLE: Effect.catchIf TypeScript Function Signature
DESCRIPTION: Provides the TypeScript function signature for Effect.catchIf, showing its type parameters and overloads for different use cases.

LANGUAGE: typescript
CODE:
declare const catchIf: { <E, EB extends E, A2, E2, R2>(refinement: Refinement<NoInfer<E>, EB>, f: (e: EB) => Effect<A2, E2, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2 | Exclude<E, EB>, R2 | R>; <E, A2, E2, R2>(predicate: Predicate<NoInfer<E>>, f: (e: NoInfer<E>) => Effect<A2, E2, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A2 | A, E | E2, R2 | R>; <A, E, R, EB extends E, A2, E2, R2>(self: Effect<A, E, R>, refinement: Refinement<E, EB>, f: (e: EB) => Effect<A2, E2, R2>): Effect<A | A2, E2 | Exclude<E, EB>, R | R2>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, predicate: Predicate<E>, f: (e: E) => Effect<A2, E2, R2>): Effect<A | A2, E | E2, R | R2>; }

----------------------------------------

TITLE: Finding Maximum Element in Array using Effect Library in TypeScript
DESCRIPTION: Demonstrates how to use the Array.max function from the Effect library to find the maximum element in an array. It uses a number comparator to determine the maximum value.

LANGUAGE: typescript
CODE:
import { Array, Order } from "effect"

const result = Array.max([3, 1, 2], Order.number)
console.log(result) // 3

----------------------------------------

TITLE: Implementing Conditional Stream Filtering with whenEffect in TypeScript
DESCRIPTION: Defines a function that takes an Effect producing a boolean and returns a function that filters a Stream based on that condition. If the effect resolves to true, returns the original stream, otherwise returns an empty stream. Supports both curried and uncurried calling styles.

LANGUAGE: typescript
CODE:
declare const whenEffect: {
  <E2, R2>(effect: Effect.Effect<boolean, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>;
  <A, E, R, E2, R2>(self: Stream<A, E, R>, effect: Effect.Effect<boolean, E2, R2>): Stream<A, E | E2, R | R2>;
}

----------------------------------------

TITLE: Implementing Stream Error Handler in TypeScript
DESCRIPTION: Function signature for onError method that handles stream failures by running a cleanup effect. The cleanup effect receives the error cause and can perform necessary cleanup operations. The function maintains the original stream's output type while potentially adding new resource requirements.

LANGUAGE: typescript
CODE:
declare const onError: {
  <E, X, R2>(cleanup: (cause: Cause.Cause<E>) => Effect.Effect<X, never, R2>): <A, R>(self: Stream<A, E, R>) => Stream<A, E, R2 | R>;
  <A, E, R, X, R2>(self: Stream<A, E, R>, cleanup: (cause: Cause.Cause<E>) => Effect.Effect<X, never, R2>): Stream<A, E, R | R2>;
}

----------------------------------------

TITLE: Using Stream.repeatValue in TypeScript
DESCRIPTION: Demonstrates how to create an infinite stream that repeats a single value, using Stream.repeatValue and collecting a finite number of elements using Stream.take.

LANGUAGE: typescript
CODE:
import { Effect, Stream } from "effect"

const stream = Stream.repeatValue(0)

Effect.runPromise(Stream.runCollect(stream.pipe(Stream.take(5)))).then(console.log)
// { _id: 'Chunk', values: [ 0, 0, 0, 0, 0 ] }

LANGUAGE: typescript
CODE:
declare const repeatValue: <A>(value: A) => Stream<A>

----------------------------------------

TITLE: Racing Multiple Failing Tasks
DESCRIPTION: Illustrates racing three failing tasks, showing how the function fails with the last encountered error when all tasks fail.

LANGUAGE: typescript
CODE:
import { Effect, Console } from "effect"

const task1 = Effect.fail("task1").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Console.log("task1 done")),
  Effect.onInterrupt(() => Console.log("task1 interrupted"))
)
const task2 = Effect.fail("task2").pipe(
  Effect.delay("200 millis"),
  Effect.tap(Console.log("task2 done")),
  Effect.onInterrupt(() => Console.log("task2 interrupted"))
)

const task3 = Effect.fail("task3").pipe(
  Effect.delay("150 millis"),
  Effect.tap(Console.log("task3 done")),
  Effect.onInterrupt(() => Console.log("task3 interrupted"))
)

const program = Effect.raceAll([task1, task2, task3])

Effect.runPromiseExit(program).then(console.log)

----------------------------------------

TITLE: Constructing URL Config in TypeScript for Effect Library
DESCRIPTION: This function creates a configuration object for URL values. It optionally takes a name parameter and returns a Config<URL> object. This is useful for setting up configurations that require URL inputs in Effect-based applications.

LANGUAGE: typescript
CODE:
declare const url: (name?: string) => Config<URL>

----------------------------------------

TITLE: Using Option.flatMapNullable with Nested Objects in TypeScript
DESCRIPTION: Demonstrates how to use Option.flatMapNullable to safely access deeply nested nullable properties in TypeScript objects. Shows examples with both existing and non-existing nested properties.

LANGUAGE: typescript
CODE:
import { Option } from "effect"

interface Employee {
  company?: {
    address?: {
      street?: {
        name?: string
      }
    }
  }
}

const employee1: Employee = { company: { address: { street: { name: "high street" } } } }

// Extracting a deeply nested property
console.log(
  Option.some(employee1)
    .pipe(Option.flatMapNullable((employee) => employee.company?.address?.street?.name))
)
// Output: { _id: 'Option', _tag: 'Some', value: 'high street' }

const employee2: Employee = { company: { address: { street: {} } } }

// Property does not exist
console.log(
  Option.some(employee2)
    .pipe(Option.flatMapNullable((employee) => employee.company?.address?.street?.name))
)
// Output: { _id: 'Option', _tag: 'None' }

----------------------------------------

TITLE: Using Record.collect to Transform Record Values in TypeScript
DESCRIPTION: Demonstrates how to use the collect function to transform a record's key-value pairs into an array. The function takes a record and a mapping function that receives both key and value, allowing custom transformations of record entries.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { collect } from "effect/Record"

const x = { a: 1, b: 2, c: 3 }
assert.deepStrictEqual(collect(x, (key, n) => [key, n]), [["a", 1], ["b", 2], ["c", 3]])

LANGUAGE: typescript
CODE:
declare const collect: { <K extends string, A, B>(f: (key: K, a: A) => B): (self: ReadonlyRecord<K, A>) => Array<B>; <K extends string, A, B>(self: ReadonlyRecord<K, A>, f: (key: K, a: A) => B): Array<B>; }

----------------------------------------

TITLE: Obtaining Read Lock in Scoped Context with TReentrantLock in TypeScript
DESCRIPTION: The readLock function obtains a read lock for a TReentrantLock instance within a scoped context. It returns an Effect that resolves to a number and requires a Scope.

LANGUAGE: typescript
CODE:
declare const readLock: (self: TReentrantLock) => Effect.Effect<number, never, Scope.Scope>

----------------------------------------

TITLE: Implementing HTTP Client Response Tap Operation in TypeScript
DESCRIPTION: Defines a tap operation that executes an additional effect after a successful HTTP client response. The function supports both curried and uncurried forms, allowing for flexible composition of HTTP client operations.

LANGUAGE: typescript
CODE:
declare const tap: {
  <_, E2, R2>(f: (response: ClientResponse.HttpClientResponse) => Effect.Effect<_, E2, R2>):
    <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E | E2, R | R2>;
  <E, R, _, E2, R2>(self: HttpClient.With<E, R>, f: (response: ClientResponse.HttpClientResponse) => Effect.Effect<_, E2, R2>):
    HttpClient.With<E | E2, R | R2>;
}

----------------------------------------

TITLE: Defining flatMap Function for HashMap in TypeScript
DESCRIPTION: Declares the flatMap function for HashMap, which chains over the entries of the HashMap using a specified function. The function requires that both input and output maps have the same hash and equal methods.

LANGUAGE: typescript
CODE:
declare const flatMap: { <A, K, B>(f: (value: A, key: K) => HashMap<K, B>): (self: HashMap<K, A>) => HashMap<K, B>; <K, A, B>(self: HashMap<K, A>, f: (value: A, key: K) => HashMap<K, B>): HashMap<K, B>; }

----------------------------------------

TITLE: Zipping Arrays with Array.zip in TypeScript
DESCRIPTION: Demonstrates how to use the Array.zip function to combine two iterables into an array of pairs. It handles cases where the input iterables have different lengths by discarding excess elements from the longer iterable.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const result = Array.zip([1, 2, 3], ['a', 'b'])
console.log(result) // [[1, 'a'], [2, 'b']]

LANGUAGE: typescript
CODE:
declare const zip: { <B>(that: NonEmptyReadonlyArray<B>): <A>(self: NonEmptyReadonlyArray<A>) => NonEmptyArray<[A, B]>; <B>(that: Iterable<B>): <A>(self: Iterable<A>) => Array<[A, B]>; <A, B>(self: NonEmptyReadonlyArray<A>, that: NonEmptyReadonlyArray<B>): NonEmptyArray<[A, B]>; <A, B>(self: Iterable<A>, that: Iterable<B>): Array<[A, B]>; }

----------------------------------------

TITLE: Implementing Either.mapLeft Function in TypeScript
DESCRIPTION: Function declaration for mapLeft that transforms the Left value of an Either type while preserving the Right value. It supports both curried and uncurried versions of the function.

LANGUAGE: typescript
CODE:
declare const mapLeft: { <L, L2>(f: (left: L) => L2): <R>(self: Either<R, L>) => Either<R, L2>; <R, L, L2>(self: Either<R, L>, f: (left: L) => L2): Either<R, L2>; }

----------------------------------------

TITLE: Partitioning Arrays Using Effect Library
DESCRIPTION: Demonstrates how to use Array.partition to separate array elements into two groups based on a boolean predicate. The example shows partitioning numbers into odd and even groups.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const result = Array.partition([1, 2, 3, 4], n => n % 2 === 0)
console.log(result) // [[1, 3], [2, 4]]

----------------------------------------

TITLE: Implementing STM Summarization in TypeScript
DESCRIPTION: Defines a function that summarizes an STM effect by computing values before and after execution. It takes a summary effect and a combining function as parameters, returning a new STM effect that produces both the summary and original result.

LANGUAGE: typescript
CODE:
declare const summarized: { 
  <A2, E2, R2, A3>(
    summary: STM<A2, E2, R2>, 
    f: (before: A2, after: A2) => A3
  ): <A, E, R>(self: STM<A, E, R>) => STM<[A3, A], E2 | E, R2 | R>; 
  <A, E, R, A2, E2, R2, A3>(
    self: STM<A, E, R>, 
    summary: STM<A2, E2, R2>, 
    f: (before: A2, after: A2) => A3
  ): STM<[A3, A], E | E2, R | R2>; 
}

----------------------------------------

TITLE: Implementing Array Comprehension with Array.Do in TypeScript
DESCRIPTION: This snippet demonstrates how to use Array.Do to create a new array by iterating over existing arrays, applying conditions and transformations. It shows the usage of bind, filter, and map functions within the Do simulation scope.

LANGUAGE: typescript
CODE:
import { Array, pipe } from "effect"

const doResult = pipe(
  Array.Do,
  Array.bind("x", () => [1, 3, 5]),
  Array.bind("y", () => [2, 4, 6]),
  Array.filter(({ x, y }) => x < y), // condition
  Array.map(({ x, y }) => [x, y] as const) // transformation
)
console.log(doResult) // [[1, 2], [1, 4], [1, 6], [3, 4], [3, 6], [5, 6]]

// equivalent
const x = [1, 3, 5],
      y = [2, 4, 6],
      result = [];
for(let i = 0; i < x.length; i++) {
  for(let j = 0; j < y.length; j++) {
    const _x = x[i], _y = y[j];
    if(_x < _y) result.push([_x, _y] as const)
  }
}

----------------------------------------

TITLE: Schema.brand Function Signature in TypeScript
DESCRIPTION: Provides the TypeScript signature for the Schema.brand function. It takes a schema, a brand identifier, and optional annotations, returning a branded schema.

LANGUAGE: typescript
CODE:
declare const brand: <S extends Schema.AnyNoContext, B extends string | symbol>(brand: B, annotations?: Annotations.Schema<Schema.Type<S> & Brand<B>>) => (self: S) => brand<S, B>

----------------------------------------

TITLE: Using annotateLogsScoped in TypeScript Effect
DESCRIPTION: Demonstrates how to use annotateLogsScoped to add temporary log annotations within a scoped context. The example shows how annotations are applied only within the scope and automatically removed afterwards.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

const program = Effect.gen(function*() {
  yield* Effect.log("no annotations")
  yield* Effect.annotateLogsScoped({ key: "value" })
  yield* Effect.log("message1") // Annotation is applied to this log
  yield* Effect.log("message2") // Annotation is applied to this log
}).pipe(Effect.scoped, Effect.andThen(Effect.log("no annotations again")))

Effect.runFork(program)
// timestamp=... level=INFO fiber=#0 message="no annotations"
// timestamp=... level=INFO fiber=#0 message=message1 key=value
// timestamp=... level=INFO fiber=#0 message=message2 key=value
// timestamp=... level=INFO fiber=#0 message="no annotations again"

LANGUAGE: typescript
CODE:
declare const annotateLogsScoped: { (key: string, value: unknown): Effect<void, never, Scope.Scope>; (values: Record<string, unknown>): Effect<void, never, Scope.Scope>; }

----------------------------------------

TITLE: Array.chunksOf Implementation Example in TypeScript
DESCRIPTION: Shows practical usage of the chunksOf function by splitting an array of numbers into chunks of size 2. Demonstrates how the function handles arrays with lengths not evenly divisible by the chunk size.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const result = Array.chunksOf([1, 2, 3, 4, 5], 2)
console.log(result) // [[1, 2], [3, 4], [5]]

----------------------------------------

TITLE: Parsing Strings to BigDecimal in TypeScript
DESCRIPTION: Demonstrates how to use the unsafeFromString function to parse numerical strings into BigDecimal values. The function accepts decimal and integer strings but throws an error for invalid number formats.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { unsafeFromString, make } from "effect/BigDecimal"

assert.deepStrictEqual(unsafeFromString("123"), make(123n, 0))
assert.deepStrictEqual(unsafeFromString("123.456"), make(123456n, 3))
assert.throws(() => unsafeFromString("123.abc"))

LANGUAGE: typescript
CODE:
declare const unsafeFromString: (s: string) => BigDecimal

----------------------------------------

TITLE: Retrying with Fallback using Effect.retryOrElse in TypeScript
DESCRIPTION: This example demonstrates how to use Effect.retryOrElse to retry a failing effect multiple times according to a schedule, and run a fallback effect if all retries fail. It simulates a task that fails three times before succeeding, using a retry policy with a delay between attempts.

LANGUAGE: typescript
CODE:
import { Effect, Schedule, Console } from "effect"

let count = 0

// Simulates an effect with possible failures
const task = Effect.async<string, Error>((resume) => {
  if (count <= 2) {
    count++
    console.log("failure")
    resume(Effect.fail(new Error()))
  } else {
    console.log("success")
    resume(Effect.succeed("yay!"))
  }
})

// Retry the task with a delay between retries and a maximum of 2 retries
const policy = Schedule.addDelay(Schedule.recurs(2), () => "100 millis")

// If all retries fail, run the fallback effect
const repeated = Effect.retryOrElse(
  task,
  policy,
  // fallback
  () => Console.log("orElse").pipe(Effect.as("default value"))
)

Effect.runPromise(repeated).then(console.log)
// Output:
// failure
// failure
// failure
// orElse
// default value

----------------------------------------

TITLE: Defining Config.map Function Signature in TypeScript
DESCRIPTION: Declares a function signature for Config.map that enables transforming a Config<A> into a Config<B> using a mapping function. Supports both curried and uncurried calling styles.

LANGUAGE: typescript
CODE:
declare const map: { <A, B>(f: (a: A) => B): (self: Config<A>) => Config<B>; <A, B>(self: Config<A>, f: (a: A) => B): Config<B>; }

----------------------------------------

TITLE: Converting Records to Key-Value Pairs in TypeScript using Effect
DESCRIPTION: Demonstrates how to convert a record object into an array of key-value tuples using the toEntries function from effect/Record. The function takes a readonly record with string keys and returns an array of tuples containing the keys and their corresponding values.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { toEntries } from "effect/Record"

const x = { a: 1, b: 2, c: 3 }
assert.deepStrictEqual(toEntries(x), [["a", 1], ["b", 2], ["c", 3]])

LANGUAGE: typescript
CODE:
declare const toEntries: <K extends string, A>(self: ReadonlyRecord<K, A>) => Array<[K, A]>

----------------------------------------

TITLE: Implementing Recursive Fibonacci using Effect.suspend in TypeScript
DESCRIPTION: Shows how Effect.suspend prevents stack overflow in recursive computations by demonstrating a fibonacci implementation with and without suspension.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

const blowsUp = (n: number): Effect.Effect<number> =>
  n < 2
    ? Effect.succeed(1)
    : Effect.zipWith(blowsUp(n - 1), blowsUp(n - 2), (a, b) => a + b)

console.log(Effect.runSync(blowsUp(32)))
// crash: JavaScript heap out of memory

const allGood = (n: number): Effect.Effect<number> =>
  n < 2
    ? Effect.succeed(1)
    : Effect.zipWith(
        Effect.suspend(() => allGood(n - 1)),
        Effect.suspend(() => allGood(n - 2)),
        (a, b) => a + b
      )

console.log(Effect.runSync(allGood(32)))
// Output: 3524578

----------------------------------------

TITLE: Defining OpenAI Response Format Types in TypeScript
DESCRIPTION: Defines the well-known response format types for OpenAI API requests. Includes 'json_object', 'json_schema', and 'text' as possible values that MUST be used when applicable. Custom values are allowed when these standard formats don't apply.

LANGUAGE: typescript
CODE:
type WellKnownResponseFormat = "json_object" | "json_schema" | "text"

----------------------------------------

TITLE: Defining List.filter Function in TypeScript
DESCRIPTION: Declares the filter function for List type with multiple overloads. It allows filtering a list using a predicate or refinement, supporting both curried and non-curried forms.

LANGUAGE: typescript
CODE:
declare const filter: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: List<A>) => List<B>; <A>(predicate: Predicate<NoInfer<A>>): (self: List<A>) => List<A>; <A, B extends A>(self: List<A>, refinement: Refinement<A, B>): List<B>; <A>(self: List<A>, predicate: Predicate<A>): List<A>; }

----------------------------------------

TITLE: Creating Unbounded PubSub in TypeScript
DESCRIPTION: Function signature for creating an unbounded PubSub instance. Takes optional replay configuration and returns an Effect containing a PubSub of type A. The replay option determines how many messages are replayed to new subscribers.

LANGUAGE: typescript
CODE:
declare const unbounded: <A>(options?: { readonly replay?: number | undefined; }) => Effect.Effect<PubSub<A>>

----------------------------------------

TITLE: Record Union Type Definition in TypeScript
DESCRIPTION: Type declaration for the union function that merges two records. It supports combining values from both records using a custom combine function and preserves type safety for keys and values.

LANGUAGE: typescript
CODE:
declare const union: { <K1 extends string, A, B, C>(that: ReadonlyRecord<K1, B>, combine: (selfValue: A, thatValue: B) => C): <K0 extends string>(self: ReadonlyRecord<K0, A>) => Record<K0 | K1, A | B | C>; <K0 extends string, A, K1 extends string, B, C>(self: ReadonlyRecord<K0, A>, that: ReadonlyRecord<K1, B>, combine: (selfValue: A, thatValue: B) => C): Record<K0 | K1, A | B | C>; }

----------------------------------------

TITLE: Implementing Input Transformation in Effect Sink - TypeScript
DESCRIPTION: Defines a function that transforms input elements of a Sink. The function takes a transformation function f and returns a new Sink that applies this transformation to its input elements before processing them.

LANGUAGE: typescript
CODE:
declare const mapInput: { <In0, In>(f: (input: In0) => In): <A, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In0, L, E, R>; <A, In, L, E, R, In0>(self: Sink<A, In, L, E, R>, f: (input: In0) => In): Sink<A, In0, L, E, R>; }

----------------------------------------

TITLE: Creating Directory Argument in Effect CLI (TypeScript)
DESCRIPTION: Defines a function to create a directory argument for command-line interfaces. It allows optional configuration and defaults to using 'directory' as the argument name.

LANGUAGE: typescript
CODE:
declare const directory: (config?: Args.PathArgsConfig) => Args<string>

----------------------------------------

TITLE: Declaring catchSome Function for Partial Error Recovery in STM Transactions (TypeScript)
DESCRIPTION: Defines the `catchSome` function which recovers from some or all error cases in STM transactions. It takes a partial function to handle specific error types and returns a new STM transaction that may recover from certain errors.

LANGUAGE: TypeScript
CODE:
declare const catchSome: { <E, A2, E2, R2>(pf: (error: E) => Option.Option<STM<A2, E2, R2>>): <A, R>(self: STM<A, E, R>) => STM<A2 | A, E | E2, R2 | R>; <A, E, R, A2, E2, R2>(self: STM<A, E, R>, pf: (error: E) => Option.Option<STM<A2, E2, R2>>): STM<A | A2, E | E2, R | R2>; }

----------------------------------------

TITLE: Using Either.liftPredicate in TypeScript
DESCRIPTION: Demonstrates how to use Either.liftPredicate to transform a predicate function into Either values. The example shows checking if a number is positive, returning Right for positive numbers and Left with an error message for non-positive numbers.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { pipe, Either } from "effect"

const isPositive = (n: number): boolean => n > 0

assert.deepStrictEqual(
  pipe(
    1,
    Either.liftPredicate(isPositive, n => `${n} is not positive`)
  ),
  Either.right(1)
)
assert.deepStrictEqual(
  pipe(
    0,
    Either.liftPredicate(isPositive, n => `${n} is not positive`)
  ),
  Either.left("0 is not positive")
)

----------------------------------------

TITLE: Implementing catchAllCause for Error Handling in Micro Effects (TypeScript)
DESCRIPTION: The catchAllCause function catches the full MicroCause object of a given Micro effect, allowing recovery from any type of cause. It takes a function that handles the cause and returns a new Micro effect.

LANGUAGE: typescript
CODE:
declare const catchAllCause: {
  <E, B, E2, R2>(f: (cause: NoInfer<MicroCause<E>>) => Micro<B, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A | B, E2, R | R2>;
  <A, E, R, B, E2, R2>(self: Micro<A, E, R>, f: (cause: NoInfer<MicroCause<E>>) => Micro<B, E2, R2>): Micro<A | B, E2, R | R2>;
}

----------------------------------------

TITLE: Using Effect.annotateLogs with Key-Value Pairs in TypeScript
DESCRIPTION: Demonstrates how to add custom annotations to log messages in an Effect program. The example shows adding a taskId annotation that appears in all log messages generated within the effect.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

const program = Effect.gen(function*() {
  yield* Effect.log("message1")
  yield* Effect.log("message2")
}).pipe(Effect.annotateLogs("taskId", "1234")) // Annotation as key/value pair

Effect.runFork(program)
// timestamp=... level=INFO fiber=#0 message=message1 taskId=1234
// timestamp=... level=INFO fiber=#0 message=message2 taskId=1234

----------------------------------------

TITLE: Implementing Discount Application with Effect.andThen
DESCRIPTION: Complete example showing how to use Effect.andThen for handling transaction amounts and applying discounts, demonstrating both Promise integration and error handling.

LANGUAGE: typescript
CODE:
import { pipe, Effect } from "effect"

// Function to apply a discount safely to a transaction amount
const applyDiscount = (
  total: number,
  discountRate: number
): Effect.Effect<number, Error> =>
  discountRate === 0
    ? Effect.fail(new Error("Discount rate cannot be zero"))
    : Effect.succeed(total - (total * discountRate) / 100)

// Simulated asynchronous task to fetch a transaction amount from database
const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))

// Using Effect.map and Effect.flatMap
const result1 = pipe(
  fetchTransactionAmount,
  Effect.map((amount) => amount * 2),
  Effect.flatMap((amount) => applyDiscount(amount, 5))
)

Effect.runPromise(result1).then(console.log)
// Output: 190

// Using Effect.andThen
const result2 = pipe(
  fetchTransactionAmount,
  Effect.andThen((amount) => amount * 2),
  Effect.andThen((amount) => applyDiscount(amount, 5))
)

Effect.runPromise(result2).then(console.log)
// Output: 190

----------------------------------------

TITLE: Effect.onError Type Signature
DESCRIPTION: TypeScript type signature for the onError function, showing its polymorphic nature and type parameters for effects, errors, and environments.

LANGUAGE: typescript
CODE:
declare const onError: { <E, X, R2>(cleanup: (cause: Cause.Cause<E>) => Effect<X, never, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A, E, R2 | R>; <A, E, R, X, R2>(self: Effect<A, E, R>, cleanup: (cause: Cause.Cause<E>) => Effect<X, never, R2>): Effect<A, E, R2 | R>; }

----------------------------------------

TITLE: Creating Single-Value Stream using Stream.succeed in TypeScript
DESCRIPTION: Demonstrates how to create a stream containing a single value using Stream.succeed. The example shows creating a stream with a single number and collecting its output using Effect.runPromise.

LANGUAGE: typescript
CODE:
import { Effect, Stream } from "effect"

// A Stream with a single number
const stream = Stream.succeed(3)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 3 ] }

LANGUAGE: typescript
CODE:
declare const succeed: <A>(value: A) => Stream<A>

----------------------------------------

TITLE: Implementing TMap.find in TypeScript
DESCRIPTION: Defines a find operation that searches for key/value pairs matching a predicate and extracts a value. The operation is transactional and returns an STM (Software Transactional Memory) computation that yields an Optional result.

LANGUAGE: typescript
CODE:
declare const find: {
  <K, V, A>(pf: (key: K, value: V) => Option.Option<A>): (self: TMap<K, V>) => STM.STM<Option.Option<A>>;
  <K, V, A>(self: TMap<K, V>, pf: (key: K, value: V) => Option.Option<A>): STM.STM<Option.Option<A>>;
}

----------------------------------------

TITLE: Implementing Layer Memoization in TypeScript using Effect-TS
DESCRIPTION: Function signature for memoizing a Layer component. Takes a Layer with generic type parameters for input requirements (RIn), error type (E), and output type (ROut). Returns a scoped Effect that lazily computes and caches the layer result.

LANGUAGE: typescript
CODE:
declare const memoize: <RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Effect.Effect<Layer<ROut, E, RIn>, never, Scope.Scope>

----------------------------------------

TITLE: Zipping Multiple Streams with Latest Values in TypeScript
DESCRIPTION: Demonstrates how to use Stream.zipLatestAll to combine multiple streams, emitting results when any stream updates with the latest values from other streams. The example uses three streams with different schedules and takes the first 6 results.

LANGUAGE: typescript
CODE:
import { Stream, Schedule, Console, Effect } from "effect"

const stream = Stream.zipLatestAll(
    Stream.fromSchedule(Schedule.spaced('1 millis')),
    Stream.fromSchedule(Schedule.spaced('2 millis')),
    Stream.fromSchedule(Schedule.spaced('4 millis')),
).pipe(Stream.take(6), Stream.tap(Console.log))

Effect.runPromise(Stream.runDrain(stream))
// Output:
// [ 0, 0, 0 ]
// [ 1, 0, 0 ]
// [ 1, 1, 0 ]
// [ 2, 1, 0 ]
// [ 3, 1, 0 ]
// [ 3, 1, 1 ]
// .....

----------------------------------------

TITLE: Declaring collectAll Sink Function in TypeScript
DESCRIPTION: Defines a sink function that collects all input elements into a Chunk. It takes no parameters and returns a Sink that transforms input of type In into a Chunk of In.

LANGUAGE: typescript
CODE:
declare const collectAll: <In>() => Sink<Chunk.Chunk<In>, In>

----------------------------------------

TITLE: Implementing Transactional Loops in TypeScript with STM.loop
DESCRIPTION: The STM.loop function provides a way to perform transactional loops, collecting results into a list. It takes an initial state, a continuation condition, a state increment function, and a body function that performs the main transactional operation. The function can either return an array of results or void, depending on the 'discard' option.

LANGUAGE: typescript
CODE:
declare const loop: { <Z, A, E, R>(initial: Z, options: { readonly while: (z: Z) => boolean; readonly step: (z: Z) => Z; readonly body: (z: Z) => STM<A, E, R>; readonly discard?: false | undefined; }): STM<Array<A>, E, R>; <Z, A, E, R>(initial: Z, options: { readonly while: (z: Z) => boolean; readonly step: (z: Z) => Z; readonly body: (z: Z) => STM<A, E, R>; readonly discard: true; }): STM<void, E, R>; }

----------------------------------------

TITLE: Implementing FilterMap Operation for Chunk in TypeScript
DESCRIPTION: Defines a filterMap function that combines filtering and mapping operations on a Chunk data structure. The function takes a transformation function that returns an Option<B> and applies it to each element, keeping only the Some values.

LANGUAGE: typescript
CODE:
declare const filterMap: {
  <A, B>(f: (a: A, i: number) => Option<B>): (self: Chunk<A>) => Chunk<B>;
  <A, B>(self: Chunk<A>, f: (a: A, i: number) => Option<B>): Chunk<B>;
}

----------------------------------------

TITLE: Creating HTTP API Groups in TypeScript with Effect
DESCRIPTION: Defines the make function for creating HttpApiGroup instances. This function allows grouping related HTTP endpoints together, with optional topLevel configuration. The group can be later implemented using HttpApiBuilder.group API.

LANGUAGE: typescript
CODE:
declare const make: <const Id extends string, const TopLevel extends (true | false) = false>(identifier: Id, options?: { readonly topLevel?: TopLevel | undefined; }) => HttpApiGroup<Id, never, never, never, TopLevel>

----------------------------------------

TITLE: Defining asyncScoped Function in TypeScript for Effect Library's Stream Module
DESCRIPTION: This snippet defines the asyncScoped function, which creates a stream from an asynchronous callback. It handles scoped resources and allows for optional error types to signal stream end. The function takes a register callback and an optional buffer size configuration.

LANGUAGE: typescript
CODE:
declare const asyncScoped: <A, E = never, R = never>(register: (emit: Emit.Emit<R, E, A, void>) => Effect.Effect<unknown, E, R | Scope.Scope>, bufferSize?: number | "unbounded" | { readonly bufferSize?: number | undefined; readonly strategy?: "dropping" | "sliding" | "suspend" | undefined; } | undefined) => Stream<A, E, Exclude<R, Scope.Scope>>

----------------------------------------

TITLE: Implementing Cleanup Functions with Effect.onExit in TypeScript
DESCRIPTION: Demonstrates how to use Effect.onExit to ensure cleanup operations are performed after an effect completes, regardless of success, failure, or interruption. It shows examples of successful, failing, and interrupted effects with their respective cleanup behaviors.

LANGUAGE: typescript
CODE:
import { Console, Effect, Exit } from "effect"

// Define a cleanup effect that logs the result
const handler = Effect.onExit((exit) =>
  Console.log(`Cleanup completed: ${Exit.getOrElse(exit, String)}`)
)

// Define a successful effect
const success = Console.log("Task completed").pipe(
  Effect.as("some result"),
  handler
)

Effect.runFork(success)
// Output:
// Task completed
// Cleanup completed: some result

// Define a failing effect
const failure = Console.log("Task failed").pipe(
  Effect.andThen(Effect.fail("some error")),
  handler
)

Effect.runFork(failure)
// Output:
// Task failed
// Cleanup completed: Error: some error

// Define an interrupted effect
const interruption = Console.log("Task interrupted").pipe(
  Effect.andThen(Effect.interrupt),
  handler
)

Effect.runFork(interruption)
// Output:
// Task interrupted
// Cleanup completed: All fibers interrupted without errors.

----------------------------------------

TITLE: Implementing Deferred.sync Function in TypeScript
DESCRIPTION: Function declaration for completing a Deferred with a lazily evaluated value. Returns an Effect that resolves to a boolean indicating completion status. Supports both curried and uncurried calling styles.

LANGUAGE: typescript
CODE:
declare const sync: {
  <A>(evaluate: LazyArg<A>): <E>(self: Deferred<A, E>) => Effect.Effect<boolean>;
  <A, E>(self: Deferred<A, E>, evaluate: LazyArg<A>): Effect.Effect<boolean>;
}

----------------------------------------

TITLE: Creating DateTime from Date in TypeScript
DESCRIPTION: The unsafeFromDate function creates a DateTime object of type Utc from a Date object. It throws an IllegalArgumentException if the provided Date is invalid. This function has been available since version 3.6.0 of the package.

LANGUAGE: typescript
CODE:
declare const unsafeFromDate: (date: Date) => Utc

----------------------------------------

TITLE: Creating Batch Embeddings Service - TypeScript Effect Implementation
DESCRIPTION: Defines a function that creates an Embeddings service capable of aggregating multiple embed requests into a single batch operation. The service processes requests within a specified time window and respects an optional maximum batch size limit.

LANGUAGE: typescript
CODE:
declare const makeDataLoader: (options: { readonly embedMany: (input: ReadonlyArray<string>) => Effect.Effect<Array<Embeddings.Result>, AiError>; readonly window: Duration.DurationInput; readonly maxBatchSize?: number; }) => Effect.Effect<Embeddings.Service, never, Scope>

----------------------------------------

TITLE: Implementing findFirst Function in TypeScript List Module
DESCRIPTION: A type declaration for the findFirst function that returns the first element satisfying a predicate or refinement condition. The function supports both direct predicate checking and type refinement operations on list elements, returning an Option type.

LANGUAGE: typescript
CODE:
declare const findFirst: { 
  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: List<A>) => Option.Option<B>; 
  <A>(predicate: Predicate<NoInfer<A>>): (self: List<A>) => Option.Option<A>; 
  <A, B extends A>(self: List<A>, refinement: Refinement<A, B>): Option.Option<B>; 
  <A>(self: List<A>, predicate: Predicate<A>): Option.Option<A>; 
}

----------------------------------------

TITLE: Effect.as Function Signature in TypeScript
DESCRIPTION: The type signature of the 'as' function, showing its overloaded versions for different use cases.

LANGUAGE: typescript
CODE:
declare const as: { <B>(value: B): <A, E, R>(self: Effect<A, E, R>) => Effect<B, E, R>; <A, E, R, B>(self: Effect<A, E, R>, value: B): Effect<B, E, R>; }

----------------------------------------

TITLE: Declaring ConfigProvider.fromEnv Function in TypeScript
DESCRIPTION: Defines the fromEnv function in the ConfigProvider module. This function creates a config provider that loads configuration from context variables. It accepts optional configuration options for path and sequence delimiters.

LANGUAGE: typescript
CODE:
declare const fromEnv: (options?: Partial<ConfigProvider.FromEnvConfig>) => ConfigProvider

----------------------------------------

TITLE: Using Prompt.all with Tuple and Record in TypeScript
DESCRIPTION: Demonstrates how to use Prompt.all function to run multiple prompts in sequence. It shows examples with both tuple and record formats, including text and password prompts with validation.

LANGUAGE: typescript
CODE:
import * as Prompt from "@effect/cli/Prompt"
import * as Effect from "effect/Effect"

const username = Prompt.text({
  message: "Enter your username: "
})

const password = Prompt.password({
  message: "Enter your password: ",
  validate: (value) =>
    value.length === 0
      ? Effect.fail("Password cannot be empty")
      : Effect.succeed(value)
})

const allWithTuple = Prompt.all([username, password])

const allWithRecord = Prompt.all({ username, password })

----------------------------------------

TITLE: Creating Gauge Metrics in Effect TypeScript
DESCRIPTION: Demonstrates how to create both number and bigint gauge metrics using the Metric.gauge constructor. Shows configuration of description and bigint options.

LANGUAGE: typescript
CODE:
import { Metric } from "effect"

const numberGauge = Metric.gauge("memory_usage", {
  description: "A gauge for memory usage"
});

const bigintGauge = Metric.gauge("cpu_load", {
  description: "A gauge for CPU load",
  bigint: true
});

LANGUAGE: typescript
CODE:
declare const gauge: { (name: string, options?: { readonly description?: string | undefined; readonly bigint?: false | undefined; }): Metric.Gauge<number>; (name: string, options: { readonly description?: string | undefined; readonly bigint: true; }): Metric.Gauge<bigint>; }

----------------------------------------

TITLE: Implementing Stream Interruption with Deferred Promise in TypeScript
DESCRIPTION: Defines a function that interrupts stream evaluation when a provided deferred promise resolves. The function handles both successful and failure cases of promise resolution, with failure cases being propagated to the stream output.

LANGUAGE: typescript
CODE:
declare const interruptWhenDeferred: { 
  <X, E2>(deferred: Deferred.Deferred<X, E2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R>; 
  <A, E, R, X, E2>(self: Stream<A, E, R>, deferred: Deferred.Deferred<X, E2>): Stream<A, E | E2, R>; 
}

----------------------------------------

TITLE: Doc.punctuate Function Signature in TypeScript
DESCRIPTION: The type signature of the punctuate function, showing its polymorphic nature and ability to work with different document types.

LANGUAGE: typescript
CODE:
declare const punctuate: { <A, B>(punctuator: Doc<A>): (docs: Iterable<Doc<B>>) => ReadonlyArray<Doc<A | B>>; <A, B>(docs: Iterable<Doc<B>>, punctuator: Doc<A>): ReadonlyArray<Doc<A | B>>; }

----------------------------------------

TITLE: Subscribing to PubSub Messages in TypeScript
DESCRIPTION: The subscribe function allows for subscribing to receive messages from a PubSub instance. It returns an Effect that can be evaluated multiple times within a scope to retrieve messages from the PubSub.

LANGUAGE: typescript
CODE:
declare const subscribe: <A>(self: PubSub<A>) => Effect.Effect<Queue.Dequeue<A>, never, Scope.Scope>

----------------------------------------

TITLE: Implementing Stream Share in TypeScript
DESCRIPTION: Defines a share operation that creates a new Stream that multicasts the original Stream. It includes configuration options for capacity management, replay functionality, and idle time management. The function maintains the stream as long as there is at least one consumer and finalizes it when all consumers exit.

LANGUAGE: typescript
CODE:
declare const share: {
  <A, E>(config: {
    readonly capacity: "unbounded";
    readonly replay?: number | undefined;
    readonly idleTimeToLive?: Duration.DurationInput | undefined;
  } | {
    readonly capacity: number;
    readonly strategy?: "sliding" | "dropping" | "suspend" | undefined;
    readonly replay?: number | undefined;
    readonly idleTimeToLive?: Duration.DurationInput | undefined;
  }): <R>(self: Stream<A, E, R>) => Effect.Effect<Stream<A, E>, never, R | Scope.Scope>;
  <A, E, R>(self: Stream<A, E, R>, config: {
    readonly capacity: "unbounded";
    readonly replay?: number | undefined;
    readonly idleTimeToLive?: Duration.DurationInput | undefined;
  } | {
    readonly capacity: number;
    readonly strategy?: "sliding" | "dropping" | "suspend" | undefined;
    readonly replay?: number | undefined;
    readonly idleTimeToLive?: Duration.DurationInput | undefined;
  }): Effect.Effect<Stream<A, E>, never, R | Scope.Scope>;
}

----------------------------------------

TITLE: Merging Multiple Layers Concurrently in TypeScript
DESCRIPTION: The mergeAll function combines all provided layers concurrently, creating a new layer with merged input, error, and output types. It takes an array of Layer objects as input and returns a new Layer object.

LANGUAGE: typescript
CODE:
declare const mergeAll: <Layers extends [Layer<never, any, any>, ...Array<Layer<never, any, any>>]>(...layers: Layers) => Layer<{ [k in keyof Layers]: Layer.Success<Layers[k]>; }[number], { [k in keyof Layers]: Layer.Error<Layers[k]>; }[number], { [k in keyof Layers]: Layer.Context<Layers[k]>; }[number]>

----------------------------------------

TITLE: Adding Elements to HashSet in TypeScript using effect Package
DESCRIPTION: Demonstrates various ways to add elements to a HashSet using the effect package. It shows data-last (pipeable) API, piping with the pipe function, and data-first API approaches. The function has an average time complexity of O(1).

LANGUAGE: typescript
CODE:
// Syntax
import { HashSet, pipe } from "effect"

// with data-last, a.k.a. pipeable API
pipe(HashSet.empty(), HashSet.add(0), HashSet.add(0))

// or piped with the pipe function
HashSet.empty().pipe(HashSet.add(0))

// or with data-first API
HashSet.add(HashSet.empty(), 0)

----------------------------------------

TITLE: TypeScript Signature for Effect.transposeOption
DESCRIPTION: Provides the TypeScript type signature for the Effect.transposeOption function. It shows that the function takes an Option of an Effect and returns an Effect of an Option, preserving the type parameters for the value, error, and environment.

LANGUAGE: typescript
CODE:
declare const transposeOption: <A = never, E = never, R = never>(self: Option.Option<Effect<A, E, R>>) => Effect<Option.Option<A>, E, R>

----------------------------------------

TITLE: Creating a Stream with Stream.unfold in TypeScript
DESCRIPTION: Demonstrates how to create a stream using Stream.unfold, which generates values by iteratively applying a function to an initial state. The example creates a stream of incrementing numbers and collects the first 5 values.

LANGUAGE: typescript
CODE:
import { Effect, Option, Stream } from "effect"

const stream = Stream.unfold(1, (n) => Option.some([n, n + 1]))

Effect.runPromise(Stream.runCollect(stream.pipe(Stream.take(5)))).then(console.log)
// { _id: 'Chunk', values: [ 1, 2, 3, 4, 5 ] }

----------------------------------------

TITLE: Effect.suspend Function Signature in TypeScript
DESCRIPTION: The type signature of the Effect.suspend function showing its generic parameters and return type.

LANGUAGE: typescript
CODE:
declare const suspend: <A, E, R>(effect: LazyArg<Effect<A, E, R>>) => Effect<A, E, R>

----------------------------------------

TITLE: Converting Option to Array using Array.fromOption in TypeScript
DESCRIPTION: Demonstrates how to convert an Option type to an array using the Array.fromOption function. When provided with Some(value), it returns a single-element array containing the value. When provided with None, it returns an empty array.

LANGUAGE: typescript
CODE:
import { Array, Option } from "effect"

console.log(Array.fromOption(Option.some(1))) // [1]
console.log(Array.fromOption(Option.none())) // []

LANGUAGE: typescript
CODE:
declare const fromOption: <A>(self: Option.Option<A>) => Array<A>

----------------------------------------

TITLE: Declaring Layer.sync Function in TypeScript
DESCRIPTION: This code snippet defines the signature of the Layer.sync function. It is a polymorphic function that can be used in two ways: either by providing a context tag and an evaluation function separately, or by providing them together.

LANGUAGE: typescript
CODE:
declare const sync: { <I, S>(tag: Context.Tag<I, S>): (evaluate: LazyArg<Types.NoInfer<S>>) => Layer<I>; <I, S>(tag: Context.Tag<I, S>, evaluate: LazyArg<Types.NoInfer<S>>): Layer<I>; }

----------------------------------------

TITLE: Transforming Chunk Elements with Chunk.map in TypeScript
DESCRIPTION: Demonstrates how to use the Chunk.map function to transform elements of a chunk. It takes a chunk of numbers and adds 1 to each element, resulting in a new chunk with the transformed values.

LANGUAGE: typescript
CODE:
import { Chunk } from "effect"

const result = Chunk.map(Chunk.make(1, 2), (n) => n + 1)

console.log(result)
// { _id: 'Chunk', values: [ 2, 3 ] }

----------------------------------------

TITLE: Using Either.isRight Type Guard in TypeScript
DESCRIPTION: Demonstrates how to use the Either.isRight function to check if an Either value is a Right instance. The function acts as a type guard, returning true for Right values and false for Left values.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Either } from "effect"

assert.deepStrictEqual(Either.isRight(Either.right(1)), true)
assert.deepStrictEqual(Either.isRight(Either.left("a")), false)

LANGUAGE: typescript
CODE:
declare const isRight: <R, L>(self: Either<R, L>) => self is Right<L, R>

----------------------------------------

TITLE: Array.make Function Signature in TypeScript
DESCRIPTION: The type declaration for the Array.make function. It accepts a variable number of elements of any type and returns a NonEmptyArray containing those elements.

LANGUAGE: typescript
CODE:
declare const make: <Elements extends NonEmptyArray<any>>(...elements: Elements) => NonEmptyArray<Elements[number]>

----------------------------------------

TITLE: Defining BaseQueue Interface in TypeScript
DESCRIPTION: Defines the base interface for Queue implementations with methods for capacity management, state queries, and shutdown operations. The interface includes methods for checking queue size, status, and controlling the lifecycle of the queue.

LANGUAGE: typescript
CODE:
export interface BaseQueue {
  /**
   * Returns the number of elements the queue can hold.
   */
  capacity(): number

  /**
   * Returns false if shutdown has been called.
   */
  isActive(): boolean

  /**
   * Retrieves the size of the queue, which is equal to the number of elements
   * in the queue. This may be negative if fibers are suspended waiting for
   * elements to be added to the queue.
   */
  readonly size: Effect.Effect<number>

  /**
   * Retrieves the size of the queue, which is equal to the number of elements
   * in the queue. This may be negative if fibers are suspended waiting for
   * elements to be added to the queue. Returns None if shutdown has been called
   */
  unsafeSize(): Option.Option<number>

  /**
   * Returns `true` if the `Queue` contains at least one element, `false`
   * otherwise.
   */
  readonly isFull: Effect.Effect<boolean>

  /**
   * Returns `true` if the `Queue` contains zero elements, `false` otherwise.
   */
  readonly isEmpty: Effect.Effect<boolean>

  /**
   * Interrupts any fibers that are suspended on `offer` or `take`. Future calls
   * to `offer*` and `take*` will be interrupted immediately.
   */
  readonly shutdown: Effect.Effect<void>

  /**
   * Returns `true` if `shutdown` has been called, otherwise returns `false`.
   */
  readonly isShutdown: Effect.Effect<boolean>

  /**
   * Waits until the queue is shutdown. The `Effect` returned by this method will
   * not resume until the queue has been shutdown. If the queue is already
   * shutdown, the `Effect` will resume right away.
   */
  readonly awaitShutdown: Effect.Effect<void>
}

----------------------------------------

TITLE: Updating Service Implementation in Effect TypeScript
DESCRIPTION: Function signature for updateService which allows modifying an existing service in the Effect context. It takes a context tag and transformation function to update the service implementation. The function can be used in two ways: either by providing the Effect as the first argument, or through curried application.

LANGUAGE: typescript
CODE:
declare const updateService: { <I, S>(tag: Context.Tag<I, S>, f: (service: NoInfer<S>) => NoInfer<S>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R | I>; <A, E, R, I, S>(self: Effect<A, E, R>, tag: Context.Tag<I, S>, f: (service: NoInfer<S>) => NoInfer<S>): Effect<A, E, R | I>; }

----------------------------------------

TITLE: Converting RuntimeFlags to ReadonlySet in TypeScript
DESCRIPTION: The toSet function converts a RuntimeFlags object into a ReadonlySet of RuntimeFlag numbers. It takes a RuntimeFlags object as input and returns a ReadonlySet<RuntimeFlag>.

LANGUAGE: typescript
CODE:
declare const toSet: (self: RuntimeFlags) => ReadonlySet<RuntimeFlag>

----------------------------------------

TITLE: Channel pipeToOrFail Function Definition
DESCRIPTION: Defines a function that creates a new channel by piping the output of one channel into another while preserving the original channel's failures. The function supports both curried and uncurried calling patterns and handles type parameters for proper type inference across the channel pipeline.

LANGUAGE: typescript
CODE:
declare const pipeToOrFail: { 
  <OutElem2, OutElem, OutErr2, OutDone2, OutDone, Env2>(
    that: Channel<OutElem2, OutElem, OutErr2, never, OutDone2, OutDone, Env2>
  ): <InElem, OutErr, InErr, InDone, Env>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>
  ) => Channel<OutElem2, InElem, OutErr2 | OutErr, InErr, OutDone2, InDone, Env2 | Env>; 
  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem2, OutErr2, OutDone2, Env2>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, 
    that: Channel<OutElem2, OutElem, OutErr2, never, OutDone2, OutDone, Env2>
  ): Channel<OutElem2, InElem, OutErr | OutErr2, InErr, OutDone2, InDone, Env | Env2>; 
}

----------------------------------------

TITLE: Creating Successful Micro Effect in TypeScript
DESCRIPTION: The succeed function creates a Micro effect that will succeed with the specified constant value. It takes a generic type A and returns a Micro<A>.

LANGUAGE: typescript
CODE:
declare const succeed: <A>(value: A) => Micro<A>

----------------------------------------

TITLE: Implementing Effectful Loops with Effect.iterate in TypeScript
DESCRIPTION: Effect.iterate repeatedly updates a state through an effectful operation until a condition is no longer met. It's useful for scenarios involving asynchronous or side-effectful operations, such as polling or iterative computations that depend on external factors.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

const result = Effect.iterate(
  // Initial result
  1,
  {
    // Condition to continue iterating
    while: (result) => result <= 5,
    // Operation to change the result
    body: (result) => Effect.succeed(result + 1)
  }
)

Effect.runPromise(result).then(console.log)
// Output: 6

----------------------------------------

TITLE: Using Array.replicate in TypeScript
DESCRIPTION: Demonstrates how to use the Array.replicate function to create a NonEmptyArray by repeating a value a specified number of times. The function normalizes the input count to an integer greater than or equal to 1.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const result = Array.replicate("a", 3)
console.log(result) // ["a", "a", "a"]

----------------------------------------

TITLE: Checking Key Existence in HashMap using TypeScript
DESCRIPTION: The 'has' function checks if a specified key has an entry in the HashMap. It can be used with both curried and uncurried syntax, allowing flexible usage patterns.

LANGUAGE: typescript
CODE:
declare const has: { <K1>(key: K1): <K, V>(self: HashMap<K, V>) => boolean; <K, V, K1>(self: HashMap<K, V>, key: K1): boolean; }

----------------------------------------

TITLE: Splitting Non-Empty Arrays with Effect Library - TypeScript Example
DESCRIPTION: Demonstrates how to split a non-empty array into two segments using the splitNonEmptyAt function. The function takes an array and a number n (>= 1) as parameters and returns a tuple containing two arrays: the first with maximum n elements and the second with the remaining elements.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const result = Array.splitNonEmptyAt(["a", "b", "c", "d", "e"], 3)
console.log(result) // [["a", "b", "c"], ["d", "e"]]

LANGUAGE: typescript
CODE:
declare const splitNonEmptyAt: { (n: number): <A>(self: NonEmptyReadonlyArray<A>) => [beforeIndex: NonEmptyArray<A>, fromIndex: Array<A>]; <A>(self: NonEmptyReadonlyArray<A>, n: number): [beforeIndex: NonEmptyArray<A>, fromIndex: Array<A>]; }

----------------------------------------

TITLE: Defining mergeAll Function for STM in TypeScript
DESCRIPTION: Declares the mergeAll function which merges an Iterable<STM> to a single STM, working sequentially. It takes a zero value, a combining function, and an iterable of STM values as input.

LANGUAGE: typescript
CODE:
declare const mergeAll: { <A2, A>(zero: A2, f: (a2: A2, a: A) => A2): <E, R>(iterable: Iterable<STM<A, E, R>>) => STM<A2, E, R>; <A, E, R, A2>(iterable: Iterable<STM<A, E, R>>, zero: A2, f: (a2: A2, a: A) => A2): STM<A2, E, R>; }

----------------------------------------

TITLE: HashSet.make Type Signature
DESCRIPTION: Type declaration for the HashSet.make constructor function that accepts variable number of elements and returns a HashSet.

LANGUAGE: typescript
CODE:
declare const make: <As extends ReadonlyArray<any>>(...elements: As) => HashSet<As[number]>

----------------------------------------

TITLE: Interrupting Deferred Fibers with FiberId in TypeScript
DESCRIPTION: The interruptWith function completes a Deferred with interruption, interrupting all fibers waiting on its value using a specified FiberId. It returns an Effect that resolves to a boolean.

LANGUAGE: typescript
CODE:
declare const interruptWith: { (fiberId: FiberId.FiberId): <A, E>(self: Deferred<A, E>) => Effect.Effect<boolean>; <A, E>(self: Deferred<A, E>, fiberId: FiberId.FiberId): Effect.Effect<boolean>; }

----------------------------------------

TITLE: Defining fromFiberEffect function in TypeScript
DESCRIPTION: Declares a function that creates an Effect value representing the exit value of a fiber obtained from an effect. It takes a fiber Effect as input and returns an Effect with the same type parameters.

LANGUAGE: typescript
CODE:
declare const fromFiberEffect: <A, E, R>(fiber: Effect<Fiber.Fiber<A, E>, E, R>) => Effect<A, E, R>

----------------------------------------

TITLE: Defining tapError Function for Layer Error Handling in TypeScript
DESCRIPTION: The tapError function allows performing a specified effect if a layer fails. It takes a function that handles the error and returns a new Layer with potentially modified error types and dependencies.

LANGUAGE: typescript
CODE:
declare const tapError: {
  <E, XE extends E, RIn2, E2, X>(f: (e: XE) => Effect.Effect<X, E2, RIn2>): <RIn, ROut>(self: Layer<ROut, E, RIn>) => Layer<ROut, E | E2, RIn2 | RIn>;
  <RIn, E, XE extends E, ROut, RIn2, E2, X>(self: Layer<ROut, E, RIn>, f: (e: XE) => Effect.Effect<X, E2, RIn2>): Layer<ROut, E | E2, RIn | RIn2>;
}

----------------------------------------

TITLE: Implementing Error Catching with Predicates in TypeScript
DESCRIPTION: The catchIf function allows for catching and handling expected errors that match a specified predicate or refinement. It provides overloaded implementations for different use cases, including refinement-based and predicate-based error catching.

LANGUAGE: typescript
CODE:
declare const catchIf: { <E, EB extends E, A2, E2, R2>(refinement: Refinement<NoInfer<E>, EB>, f: (e: EB) => Micro<A2, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A2 | A, E2 | Exclude<E, EB>, R2 | R>; <E, A2, E2, R2>(predicate: Predicate<NoInfer<E>>, f: (e: NoInfer<E>) => Micro<A2, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A2 | A, E | E2, R2 | R>; <A, E, R, EB extends E, A2, E2, R2>(self: Micro<A, E, R>, refinement: Refinement<E, EB>, f: (e: EB) => Micro<A2, E2, R2>): Micro<A | A2, E2 | Exclude<E, EB>, R | R2>; <A, E, R, A2, E2, R2>(self: Micro<A, E, R>, predicate: Predicate<E>, f: (e: E) => Micro<A2, E2, R2>): Micro<A | A2, E | E2, R | R2>; }

----------------------------------------

TITLE: Implementing dropWhileEffect Stream Operation in TypeScript
DESCRIPTION: Defines a function that drops stream elements while a predicate effect evaluates to true. The operation works with Effect.Effect predicates and supports both curried and uncurried function signatures.

LANGUAGE: typescript
CODE:
declare const dropWhileEffect: { 
  <A, E2, R2>(predicate: (a: NoInfer<A>) => Effect.Effect<boolean, E2, R2>): 
    <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; 
  <A, E, R, E2, R2>(self: Stream<A, E, R>, predicate: (a: A) => Effect.Effect<boolean, E2, R2>): 
    Stream<A, E | E2, R | R2>; 
}

----------------------------------------

TITLE: Defining RateLimiter Interface in TypeScript
DESCRIPTION: Defines a RateLimiter interface that wraps Effect tasks to limit their execution rate. The limiter controls the frequency of task initiation without restricting concurrent executions.

LANGUAGE: typescript
CODE:
export interface RateLimiter {
  <A, E, R>(task: Effect<A, E, R>): Effect<A, E, R>
}

----------------------------------------

TITLE: Defining STM.sync Function in TypeScript
DESCRIPTION: Declares the sync function that takes a lazily evaluated value and returns an STM effect. This function is part of the STM module in the Effect package.

LANGUAGE: typescript
CODE:
declare const sync: <A>(evaluate: () => A) => STM<A>

----------------------------------------

TITLE: Using Stream.takeUntil in TypeScript with Effect Package
DESCRIPTION: Demonstrates how to use the Stream.takeUntil function to take elements from a stream until a condition is met. It creates a stream of incrementing numbers and takes elements until the number 4 is reached.

LANGUAGE: typescript
CODE:
import { Effect, Stream } from "effect"

const stream = Stream.takeUntil(Stream.iterate(0, (n) => n + 1), (n) => n === 4)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 0, 1, 2, 3, 4 ] }

----------------------------------------

TITLE: Performing Unsafe Division in TypeScript using Effect Library
DESCRIPTION: The unsafeDivide function provides a division operation on numbers. It throws a RangeError if the divisor is 0. This function can be used in two ways: as a curried function or with both arguments at once.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { unsafeDivide } from "effect/Number"

assert.deepStrictEqual(unsafeDivide(6, 3), 2)

LANGUAGE: typescript
CODE:
declare const unsafeDivide: { (that: number): (self: number) => number; (self: number, that: number): number; }

----------------------------------------

TITLE: Implementing getOrElse Function for Exit Type in TypeScript
DESCRIPTION: The getOrElse function returns the success value A if the Exit is a Success, or computes an alternate value using the provided function if it's a Failure. It takes a function to handle the Failure case and returns a function that can be applied to an Exit instance.

LANGUAGE: typescript
CODE:
declare const getOrElse: {
  <E, A2>(orElse: (cause: Cause.Cause<E>) => A2): <A>(self: Exit<A, E>) => A2 | A;
  <A, E, A2>(self: Exit<A, E>, orElse: (cause: Cause.Cause<E>) => A2): A | A2;
}

----------------------------------------

TITLE: Committing STM Transaction in TypeScript
DESCRIPTION: Function signature for committing an STM transaction atomically. Takes an STM transaction as input and returns an Effect that represents the atomic execution of that transaction.

LANGUAGE: typescript
CODE:
declare const commit: <A, E, R>(self: STM<A, E, R>) => Effect.Effect<A, E, R>

----------------------------------------

TITLE: Formatting DateTime Using Intl.DateTimeFormat in TypeScript
DESCRIPTION: Function signature for formatIntl which provides two overloads for formatting DateTime objects using Intl.DateTimeFormat. Can be called either with format first and DateTime second, or DateTime first and format second.

LANGUAGE: typescript
CODE:
declare const formatIntl: { (format: Intl.DateTimeFormat): (self: DateTime) => string; (self: DateTime, format: Intl.DateTimeFormat): string; }

----------------------------------------

TITLE: Using Array.forEach in TypeScript with Effect Package
DESCRIPTION: Demonstrates how to use Array.forEach to perform side effects on each element of an iterable. The function takes an iterable and a callback function that executes for each element with access to both the element value and its index.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

Array.forEach([1, 2, 3], n => console.log(n)) // 1, 2, 3

LANGUAGE: typescript
CODE:
declare const forEach: { <A>(f: (a: A, i: number) => void): (self: Iterable<A>) => void; <A>(self: Iterable<A>, f: (a: A, i: number) => void): void; }

----------------------------------------

TITLE: Function Signature for Option.isSome - TypeScript
DESCRIPTION: Provides the TypeScript function signature for the Option.isSome function. It shows that the function takes an Option<A> and returns a boolean, with a type guard for Some<A>.

LANGUAGE: typescript
CODE:
declare const isSome: <A>(self: Option<A>) => self is Some<A>

----------------------------------------

TITLE: Option.map Function Signature in TypeScript
DESCRIPTION: Provides the TypeScript signature for the Option.map function. It shows two overloads: one for curried usage and another for direct application.

LANGUAGE: typescript
CODE:
declare const map: { <A, B>(f: (a: A) => B): (self: Option<A>) => Option<B>; <A, B>(self: Option<A>, f: (a: A) => B): Option<B>; }

----------------------------------------

TITLE: Creating API Key Security Scheme in TypeScript using Effect-TS
DESCRIPTION: The apiKey function creates an API key security scheme. It can be used with HttpApiBuilder.middlewareSecurity for implementation and HttpApiBuilder.securitySetCookie for setting cookies. The default value for the 'in' parameter is "header".

LANGUAGE: typescript
CODE:
declare const apiKey: (options: { readonly key: string; readonly in?: "header" | "query" | "cookie" | undefined; }) => ApiKey

----------------------------------------

TITLE: Defining Effect.whenRef Function in TypeScript
DESCRIPTION: Declares the whenRef function, which takes a Ref, a predicate, and an Effect, and returns a new Effect that conditionally executes based on the Ref value. The function has two overloads to support different parameter orders.

LANGUAGE: typescript
CODE:
declare const whenRef: {
  <S>(ref: Ref.Ref<S>, predicate: Predicate<S>): <A, E, R>(self: Effect<A, E, R>) => Effect<[S, Option.Option<A>], E, R>;
  <A, E, R, S>(self: Effect<A, E, R>, ref: Ref.Ref<S>, predicate: Predicate<S>): Effect<[S, Option.Option<A>], E, R>;
}

----------------------------------------

TITLE: Using unsafeRemainder Function in TypeScript for BigDecimal Operations
DESCRIPTION: Demonstrates how to use the unsafeRemainder function from the BigDecimal module to calculate the remainder of division operations on BigDecimal values. The function throws a RangeError if the divisor is 0.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { unsafeRemainder, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(unsafeRemainder(unsafeFromString("2"), unsafeFromString("2")), unsafeFromString("0"))
assert.deepStrictEqual(unsafeRemainder(unsafeFromString("3"), unsafeFromString("2")), unsafeFromString("1"))
assert.deepStrictEqual(unsafeRemainder(unsafeFromString("-4"), unsafeFromString("2")), unsafeFromString("0"))

----------------------------------------

TITLE: Filtering Collection with STM Predicate in TypeScript
DESCRIPTION: Implements a filtering operation that removes elements satisfying an effectual predicate from a collection. The function supports both curried and non-curried versions, operating within the STM monad.

LANGUAGE: typescript
CODE:
declare const filterNot: {
  <A, R, E>(predicate: (a: NoInfer<A>) => STM<boolean, E, R>): (iterable: Iterable<A>) => STM<Array<A>, E, R>;
  <A, R, E>(iterable: Iterable<A>, predicate: (a: A) => STM<boolean, E, R>): STM<Array<A>, E, R>;
}

----------------------------------------

TITLE: Demonstrating Doc.indent Usage in TypeScript
DESCRIPTION: This example shows how to use the `indent` function from the `@effect/printer` package to indent a document. It demonstrates the effect of indentation on text rendering with specified line width.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import { pipe } from "effect/Function"
import * as String from "effect/String"

const doc = Doc.hcat([
  Doc.text("prefix"),
  pipe(Doc.reflow("The indent function indents these words!"), Doc.indent(4))
])

assert.strictEqual(
  Doc.render(doc, {
    style: "pretty",
    options: { lineWidth: 24 }
  }),
  String.stripMargin(
    `|prefix    The indent
     |          function
     |          indents these
     |          words!`
  )
)

----------------------------------------

TITLE: Implementing STM.reduceRight Function in TypeScript
DESCRIPTION: Function signature for reduceRight operation that folds an Iterable<A> using an effectual function f, working sequentially from right to left. The function supports both curried and non-curried forms with generic type parameters for state (S), element type (A), result (R), and error (E).

LANGUAGE: typescript
CODE:
declare const reduceRight: { 
  <S, A, R, E>(zero: S, f: (s: S, a: A) => STM<S, E, R>): (iterable: Iterable<A>) => STM<S, E, R>; 
  <S, A, R, E>(iterable: Iterable<A>, zero: S, f: (s: S, a: A) => STM<S, E, R>): STM<S, E, R>; 
}

----------------------------------------

TITLE: Using HashSet.remove in TypeScript with Effect Library
DESCRIPTION: Demonstrates different ways to use the HashSet.remove function, including data-last (pipeable) API, piped with the pipe function, and data-first API. The function removes a specified value from a HashSet.

LANGUAGE: typescript
CODE:
// Syntax
import { HashSet, pipe } from "effect"

// with `data-last`, a.k.a. `pipeable` API
pipe(HashSet.make(0, 1, 2), HashSet.remove(0))

// or piped with the pipe function
HashSet.make(0, 1, 2).pipe(HashSet.remove(0))

// or with `data-first` API
HashSet.remove(HashSet.make(0, 1, 2), 0)

----------------------------------------

TITLE: Using Effect.reduceEffect with Order Processing Example
DESCRIPTION: Demonstrates how to use reduceEffect to process multiple orders concurrently and combine their prices. The example shows processing orders with delays and logging, reducing them to a total sum.

LANGUAGE: typescript
CODE:
import { Console, Effect } from "effect"

const processOrder = (id: number) =>
  Effect.succeed({ id, price: 100 * id })
    .pipe(Effect.tap(() => Console.log(`Order ${id} processed`)), Effect.delay(500 - (id * 100)))

const program = Effect.reduceEffect(
  [processOrder(1), processOrder(2), processOrder(3), processOrder(4)],
  Effect.succeed(0),
  (acc, order, i) => acc + order.price
)

Effect.runPromise(program).then(console.log)
// Output:
// Order 1 processed
// Order 2 processed
// Order 3 processed
// Order 4 processed
// 1000

----------------------------------------

TITLE: Implementing Lazy Evaluation with Side Effects in TypeScript using Effect.suspend
DESCRIPTION: Demonstrates how Effect.suspend enables proper lazy evaluation of side effects, showing the difference between immediate and suspended effect creation.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

let i = 0

const bad = Effect.succeed(i++)

const good = Effect.suspend(() => Effect.succeed(i++))

console.log(Effect.runSync(bad)) // Output: 0
console.log(Effect.runSync(bad)) // Output: 0

console.log(Effect.runSync(good)) // Output: 1
console.log(Effect.runSync(good)) // Output: 2

----------------------------------------

TITLE: Generating Random Numbers with Effect.Effect in TypeScript
DESCRIPTION: The nextRange function generates a random number between specified minimum and maximum values. It returns an Effect that produces a number when executed. The function is part of the Random module in the Effect package.

LANGUAGE: typescript
CODE:
declare const nextRange: (min: number, max: number) => Effect.Effect<number>

----------------------------------------

TITLE: Adding Service Charge with Effect.map in TypeScript
DESCRIPTION: Illustrates a practical example of using Effect.map to add a service charge to a transaction amount. It fetches a transaction amount asynchronously, then applies a transformation function.

LANGUAGE: typescript
CODE:
import { pipe, Effect } from "effect"

const addServiceCharge = (amount: number) => amount + 1

const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))

const finalAmount = pipe(
  fetchTransactionAmount,
  Effect.map(addServiceCharge)
)

Effect.runPromise(finalAmount).then(console.log)
// Output: 101

----------------------------------------

TITLE: Creating Constant Functions in TypeScript using Effect Package
DESCRIPTION: Demonstrates how to use the constant function from the effect/Function module to create a function that always returns the same value. This is useful for higher-order functions that require a function as an argument.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { constant } from "effect/Function"

const constNull = constant(null)

assert.deepStrictEqual(constNull(), null)
assert.deepStrictEqual(constNull(), null)

----------------------------------------

TITLE: Getting Current Time with DateTime.now in TypeScript
DESCRIPTION: Demonstrates how to get the current time using the DateTime.now effect. This operation uses the Clock service and returns a DateTime value wrapped in an Effect.

LANGUAGE: typescript
CODE:
import { DateTime, Effect } from "effect"

Effect.gen(function* () {
  const now = yield* DateTime.now
})

LANGUAGE: typescript
CODE:
declare const now: Effect.Effect<Utc, never, never>

----------------------------------------

TITLE: Using Either.isLeft Type Guard in TypeScript
DESCRIPTION: Demonstrates how to use the Either.isLeft function to check if an Either instance is a Left variant. The example shows type checking for both Right and Left variants.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Either } from "effect"

assert.deepStrictEqual(Either.isLeft(Either.right(1)), false)
assert.deepStrictEqual(Either.isLeft(Either.left("a")), true)

LANGUAGE: typescript
CODE:
declare const isLeft: <R, L>(self: Either<R, L>) => self is Left<L, R>

----------------------------------------

TITLE: Type Definition for BigDecimal Division
DESCRIPTION: TypeScript type signature for the unsafeDivide function, showing both curried and uncurried function forms for BigDecimal division operations.

LANGUAGE: typescript
CODE:
declare const unsafeDivide: { (that: BigDecimal): (self: BigDecimal) => BigDecimal; (self: BigDecimal, that: BigDecimal): BigDecimal; }

----------------------------------------

TITLE: Declaring STM.all Function Signature in TypeScript
DESCRIPTION: Declares the signature of the 'all' function in the STM module. This function runs all provided transactional effects in sequence, respecting the input structure. It supports multiple arguments, a single argument tuple/array, or record/struct.

LANGUAGE: typescript
CODE:
declare const all: All.Signature

----------------------------------------

TITLE: Defining Channel.never Type Signature in TypeScript
DESCRIPTION: Defines a constant 'never' with a Channel type that represents a channel that never completes. The type signature uses multiple 'never' and 'unknown' type parameters to indicate its behavior.

LANGUAGE: typescript
CODE:
declare const never: Channel<never, unknown, never, unknown, never, unknown, never>

----------------------------------------

TITLE: Retrieving Right Values from Eithers in TypeScript
DESCRIPTION: This snippet demonstrates how to use the Array.getRights function to extract Right values from an array of Either types. It filters out Left values and collects the Right values into a new array.

LANGUAGE: typescript
CODE:
import { Array, Either } from "effect"

const result = Array.getRights([Either.right(1), Either.left("err"), Either.right(2)])
console.log(result) // [1, 2]

----------------------------------------

TITLE: Filtering Record Values with Predicate in TypeScript
DESCRIPTION: Demonstrates how to use the filter function to select properties from a record whose values match a given predicate. The example shows filtering numbers greater than 2 from an object.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { filter } from "effect/Record"

const x = { a: 1, b: 2, c: 3, d: 4 }
assert.deepStrictEqual(filter(x, (n) => n > 2), { c: 3, d: 4 })

LANGUAGE: typescript
CODE:
declare const filter: { <K extends string, A, B extends A>(refinement: (a: NoInfer<A>, key: K) => a is B): (self: ReadonlyRecord<K, A>) => Record<ReadonlyRecord.NonLiteralKey<K>, B>; <K extends string, A>(predicate: (A: NoInfer<A>, key: K) => boolean): (self: ReadonlyRecord<K, A>) => Record<ReadonlyRecord.NonLiteralKey<K>, A>; <K extends string, A, B extends A>(self: ReadonlyRecord<K, A>, refinement: (a: A, key: K) => a is B): Record<ReadonlyRecord.NonLiteralKey<K>, B>; <K extends string, A>(self: ReadonlyRecord<K, A>, predicate: (a: A, key: K) => boolean): Record<ReadonlyRecord.NonLiteralKey<K>, A>; }

----------------------------------------

TITLE: Creating NonEmptyChunk in TypeScript using Chunk.make
DESCRIPTION: The make function builds a NonEmptyChunk from a non-empty collection of elements. It takes a variadic number of arguments and returns a NonEmptyChunk containing those elements. This function ensures type safety by requiring at least one element.

LANGUAGE: typescript
CODE:
declare const make: <As extends readonly [any, ...ReadonlyArray<any>]>(...as: As) => NonEmptyChunk<As[number]>

----------------------------------------

TITLE: Using Option.gen to Create a Combined Value in TypeScript
DESCRIPTION: This example demonstrates how to use Option.gen to combine multiple Option values into a single object. It shows how to yield from Option values and perform operations on the yielded values.

LANGUAGE: typescript
CODE:
import { Option } from "effect"

const maybeName: Option.Option<string> = Option.some("John")
const maybeAge: Option.Option<number> = Option.some(25)

const person = Option.gen(function* () {
  const name = (yield* maybeName).toUpperCase()
  const age = yield* maybeAge
  return { name, age }
})

console.log(person)
// Output:
// { _id: 'Option', _tag: 'Some', value: { name: 'JOHN', age: 25 } }

----------------------------------------

TITLE: Implementing Scheduled Effects in TypeScript
DESCRIPTION: Type declaration for scheduleFrom function that runs an effect repeatedly according to a schedule. It takes an initial value and a schedule configuration, returning an effect that completes when the schedule ends or the effect fails. The function supports two overloads for different parameter orderings.

LANGUAGE: typescript
CODE:
declare const scheduleFrom: { <R2, In, Out>(initial: In, schedule: Schedule.Schedule<Out, In, R2>): <E, R>(self: Effect<In, E, R>) => Effect<Out, E, R2 | R>; <In, E, R, R2, Out>(self: Effect<In, E, R>, initial: In, schedule: Schedule.Schedule<Out, In, R2>): Effect<Out, E, R | R2>; }

----------------------------------------

TITLE: Grouping Consecutive Elements in TypeScript Array
DESCRIPTION: Demonstrates the usage of Array.group function to group equal, consecutive elements of a NonEmptyReadonlyArray into NonEmptyArrays. The function takes a non-empty readonly array and returns a non-empty array of non-empty arrays.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const result = Array.group([1, 1, 2, 2, 2, 3, 1])
console.log(result) // [[1, 1], [2, 2, 2], [3], [1]]

----------------------------------------

TITLE: TypeScript Signature for Stream.onEnd Function
DESCRIPTION: Provides the TypeScript signature for the Stream.onEnd function. It shows the function's polymorphic nature, allowing it to be used with different stream types and effect combinations.

LANGUAGE: typescript
CODE:
declare const onEnd: { <_, E2, R2>(effect: Effect.Effect<_, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, _, E2, R2>(self: Stream<A, E, R>, effect: Effect.Effect<_, E2, R2>): Stream<A, E | E2, R | R2>; }

----------------------------------------

TITLE: Declaring Schema.DateTimeZoned Class in TypeScript
DESCRIPTION: This snippet declares the Schema.DateTimeZoned class, which is used to define a schema for converting strings to DateTime.Zoned instances. It's part of the Effect library's Schema module and has been available since version 3.10.0.

LANGUAGE: typescript
CODE:
declare class DateTimeZoned

----------------------------------------

TITLE: Declaring 'every' Function for List Module in TypeScript
DESCRIPTION: Defines the 'every' function which checks if a predicate holds true for every List element. It supports both refinement and predicate functions, and can be used with method-style or curried invocation.

LANGUAGE: typescript
CODE:
declare const every: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: List<A>) => self is List<B>; <A>(predicate: Predicate<A>): (self: List<A>) => boolean; <A, B extends A>(self: List<A>, refinement: Refinement<A, B>): self is List<B>; <A>(self: List<A>, predicate: Predicate<A>): boolean; }

----------------------------------------

TITLE: Grouping Array Elements with Custom Equivalence in TypeScript
DESCRIPTION: Demonstrates how to use Array.groupWith to group equal, consecutive elements of a NonEmptyReadonlyArray into NonEmptyArrays using a custom equivalence function. The function takes an array and a comparison function as input, returning an array of grouped elements.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const result = Array.groupWith(["a", "a", "b", "b", "b", "c", "a"], (x, y) => x === y)
console.log(result) // [["a", "a"], ["b", "b", "b"], ["c"], ["a"]]

----------------------------------------

TITLE: Concatenating Channels Sequentially in TypeScript
DESCRIPTION: The concatAll function is used to concatenate a channel of channels sequentially. It takes a Channel that produces other Channels as its output and combines them into a single Channel.

LANGUAGE: typescript
CODE:
declare const concatAll: <OutElem, InElem, OutErr, InErr, InDone, Env>(channels: Channel<Channel<OutElem, InElem, OutErr, InErr, any, InDone, Env>, InElem, OutErr, InErr, any, InDone, Env>) => Channel<OutElem, InElem, OutErr, InErr, any, InDone, Env>

----------------------------------------

TITLE: Converting Effect to Take - TypeScript
DESCRIPTION: Function that transforms an Effect<A, E, R> into an Effect<Take<A, E>, never, R>. The resulting effect cannot fail and wraps the original effect's success or failure into a Take instance. Used for handling effect outcomes in a stream-like context.

LANGUAGE: typescript
CODE:
declare const fromEffect: <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<Take<A, E>, never, R>

----------------------------------------

TITLE: Using Function.apply in Effect
DESCRIPTION: Demonstrates how to use the apply function to pass a value to a function in a pipeline. The example shows applying the length function to a string using pipe and apply.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { pipe, apply } from "effect/Function"
import { length } from "effect/String"

assert.deepStrictEqual(pipe(length, apply("hello")), 5)

----------------------------------------

TITLE: Creating Empty HashMap in TypeScript Effect Library
DESCRIPTION: Function signature for creating a new empty HashMap with optional generic type parameters K and V for key and value types. This is a foundational method available since version 2.0.0 of the Effect library.

LANGUAGE: typescript
CODE:
declare const empty: <K = never, V = never>() => HashMap<K, V>

----------------------------------------

TITLE: Implementing Error Refinement in STM Transactions - TypeScript
DESCRIPTION: Function signature for refineOrDieWith that allows filtering STM transaction errors. It takes a partial function to keep some errors (E2) and converts others to Throwable using a provided conversion function. The function operates on STM transactions returning type A with original error type E.

LANGUAGE: typescript
CODE:
declare const refineOrDieWith: {
  <E, E2>(pf: (error: E) => Option.Option<E2>, f: (error: E) => unknown): <A, R>(self: STM<A, E, R>) => STM<A, E2, R>;
  <A, E, R, E2>(self: STM<A, E, R>, pf: (error: E) => Option.Option<E2>, f: (error: E) => unknown): STM<A, E2, R>;
}

----------------------------------------

TITLE: Record.modify Example Usage in TypeScript
DESCRIPTION: Demonstrates how to use Record.modify to apply a transformation function to a specific key in a record. Shows both successful modification of existing keys and handling of non-existent keys.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Record as R } from "effect"

const f = (x: number) => x * 2

assert.deepStrictEqual(
 R.modify({ a: 3 }, 'a', f),
 { a: 6 }
)
assert.deepStrictEqual(
 R.modify({ a: 3 } as Record<string, number>, 'b', f),
 { a: 3 }
)

----------------------------------------

TITLE: Effect.acquireUseRelease Function Signature in TypeScript
DESCRIPTION: This code snippet shows the TypeScript signature of the Effect.acquireUseRelease function. It defines the function's type parameters and return types, illustrating how it manages resource acquisition, use, and release in a type-safe manner.

LANGUAGE: typescript
CODE:
declare const acquireUseRelease: { <A2, E2, R2, A, X, R3>(use: (a: A) => Effect<A2, E2, R2>, release: (a: A, exit: Exit.Exit<A2, E2>) => Effect<X, never, R3>): <E, R>(acquire: Effect<A, E, R>) => Effect<A2, E2 | E, R2 | R3 | R>; <A, E, R, A2, E2, R2, X, R3>(acquire: Effect<A, E, R>, use: (a: A) => Effect<A2, E2, R2>, release: (a: A, exit: Exit.Exit<A2, E2>) => Effect<X, never, R3>): Effect<A2, E | E2, R | R2 | R3>; }

----------------------------------------

TITLE: Setting Tracer in Effect Layer - TypeScript
DESCRIPTION: Creates a Layer that sets the current Tracer implementation. This function allows configuring a custom tracer for monitoring and debugging purposes within the Effect ecosystem. The Layer requires no input dependencies.

LANGUAGE: typescript
CODE:
declare const setTracer: (tracer: Tracer.Tracer) => Layer<never>

----------------------------------------

TITLE: Using Trie.entriesWithPrefix in TypeScript
DESCRIPTION: Demonstrates how to use the Trie.entriesWithPrefix function to retrieve entries with a specific prefix from a Trie data structure. The example creates a Trie with string keys and number values, then retrieves entries starting with 'she'.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Trie } from "effect"

const trie = Trie.empty<number>().pipe(
  Trie.insert("she", 0),
  Trie.insert("shells", 1),
  Trie.insert("sea", 2),
  Trie.insert("shore", 3)
)

const result = Array.from(Trie.entriesWithPrefix(trie, "she"))
assert.deepStrictEqual(result, [["she", 0], ["shells", 1]])

----------------------------------------

TITLE: Configuring WebSocket Protocol Layer for RPC Server in TypeScript
DESCRIPTION: Defines a Layer that implements WebSocket protocol for RPC communication. Takes configuration options including path and optional router tag for HTTP routing customization. Returns a Layer that provides Protocol implementation using RpcSerialization.

LANGUAGE: typescript
CODE:
declare const layerProtocolWebsocket: <I = HttpRouter.Default>(options: { readonly path: HttpRouter.PathInput; readonly routerTag?: HttpRouter.HttpRouter.TagClass<I, string, any, any>; }) => Layer.Layer<Protocol, never, RpcSerialization.RpcSerialization>

----------------------------------------

TITLE: Creating Single-Element Records with Record.singleton in TypeScript
DESCRIPTION: The singleton function creates a non-empty record from a single key-value pair. It takes a key of type string or symbol and a value of any type, returning a Record with that single entry.

LANGUAGE: typescript
CODE:
declare const singleton: <K extends string | symbol, A>(key: K, value: A) => Record<K, A>

----------------------------------------

TITLE: Implementing Scoped Span Tracing in TypeScript Effect Module
DESCRIPTION: Defines a function that wraps an effect with a new span for tracing purposes. The span is automatically ended when the associated Scope is finalized. Function supports both curried and standard parameter calling conventions.

LANGUAGE: typescript
CODE:
declare const withSpanScoped: {
  (name: string, options?: Tracer.SpanOptions): <A, E, R>
    (self: Effect<A, E, R>) => Effect<A, E, Exclude<R, Tracer.ParentSpan> | Scope.Scope>;
  <A, E, R>(self: Effect<A, E, R>, name: string, options?: Tracer.SpanOptions):
    Effect<A, E, Exclude<R, Tracer.ParentSpan> | Scope.Scope>;
}

----------------------------------------

TITLE: TypeScript Function Signature for makeZoned in Effect
DESCRIPTION: Provides the TypeScript function signature for the makeZoned function in the DateTime module. It shows the expected input parameters and return type, including options for time zone and adjustment.

LANGUAGE: typescript
CODE:
declare const makeZoned: (input: DateTime.Input, options?: { readonly timeZone?: number | string | TimeZone | undefined; readonly adjustForTimeZone?: boolean | undefined; }) => Option.Option<Zoned>

----------------------------------------

TITLE: Filtering Some Values from Option Record in TypeScript
DESCRIPTION: Demonstrates how to use Record.getSomes to extract values from a record containing Option types, returning a new record with only the Some values while preserving their original keys.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Record, Option } from "effect"

assert.deepStrictEqual(
  Record.getSomes({ a: Option.some(1), b: Option.none(), c: Option.some(2) }),
  { a: 1, c: 2 }
)

LANGUAGE: typescript
CODE:
declare const getSomes: <K extends string, A>(self: ReadonlyRecord<K, Option.Option<A>>) => Record<ReadonlyRecord.NonLiteralKey<K>, A>

----------------------------------------

TITLE: Declaring Effect.tryMap Function in TypeScript
DESCRIPTION: Function signature for tryMap that takes an effect and maps its success value using a try function while handling errors with a catch function. Supports both curried and non-curried variants.

LANGUAGE: typescript
CODE:
declare const tryMap: {
  <A, B, E1>(
    options: {
      readonly try: (a: A) => B;
      readonly catch: (error: unknown) => E1;
    }
  ): <E, R>(self: Effect<A, E, R>) => Effect<B, E1 | E, R>;
  <A, E, R, B, E1>(
    self: Effect<A, E, R>,
    options: {
      readonly try: (a: A) => B;
      readonly catch: (error: unknown) => E1;
    }
  ): Effect<B, E | E1, R>;
}

----------------------------------------

TITLE: Defining Schema.int Function in TypeScript
DESCRIPTION: Declares the int function in the Schema module. This function ensures that a provided value is an integer number, excluding NaN, +Infinity, and -Infinity. It takes optional annotations and returns a filtered schema.

LANGUAGE: typescript
CODE:
declare const int: <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>

----------------------------------------

TITLE: Modifying HashMap Values with Custom Hash in TypeScript
DESCRIPTION: Function that updates or inserts a value in a HashMap using a specified key, hash, and update function. The update function receives the current value or None if the key doesn't exist, and must return a new value to be stored.

LANGUAGE: typescript
CODE:
declare const modifyHash: { 
  <K, V>(key: K, hash: number, f: HashMap.UpdateFn<V>): (self: HashMap<K, V>) => HashMap<K, V>; 
  <K, V>(self: HashMap<K, V>, key: K, hash: number, f: HashMap.UpdateFn<V>): HashMap<K, V>; 
}

----------------------------------------

TITLE: Implementing Paginated Stream with Effect in TypeScript
DESCRIPTION: A function that creates a Stream by paginating chunks of data with effect handling. Similar to unfoldChunkEffect but allows emission of values to end one step after state unfolding. Particularly useful for implementing paginated APIs.

LANGUAGE: typescript
CODE:
declare const paginateChunkEffect: <S, A, E, R>(s: S, f: (s: S) => Effect.Effect<readonly [Chunk.Chunk<A>, Option.Option<S>], E, R>) => Stream<A, E, R>

----------------------------------------

TITLE: Defining Clock Interface in TypeScript
DESCRIPTION: Defines a Clock interface that provides methods for accessing current time in milliseconds and nanoseconds, both safely and unsafely, and implementing sleep functionality using Effect monad. The interface includes type-safe operations for time-based functionality.

LANGUAGE: typescript
CODE:
export interface Clock {
  readonly [ClockTypeId]: ClockTypeId
  /**
   * Unsafely returns the current time in milliseconds.
   */
  unsafeCurrentTimeMillis(): number
  /**
   * Returns the current time in milliseconds.
   */
  readonly currentTimeMillis: Effect.Effect<number>
  /**
   * Unsafely returns the current time in nanoseconds.
   */
  unsafeCurrentTimeNanos(): bigint
  /**
   * Returns the current time in nanoseconds.
   */
  readonly currentTimeNanos: Effect.Effect<bigint>
  /**
   * Asynchronously sleeps for the specified duration.
   */
  sleep(duration: Duration.Duration): Effect.Effect<void>
}

----------------------------------------

TITLE: Using HashSet.values Iterator in TypeScript
DESCRIPTION: Demonstrates how to use HashSet.values() to iterate over unique values in a HashSet. The example shows creating a HashSet with numbers, including duplicates, and iterating over the unique values using a for...of loop.

LANGUAGE: typescript
CODE:
import { HashSet, pipe } from "effect"

const numberIterable = pipe(
  HashSet.make(0, 1, 1, 2), // HashSet.HashSet<number>
  HashSet.values // takes an HashSet<A> and returns an IterableIterator<A>
)

for (const number of numberIterable) {
  console.log(number) // it will logs: 0, 1, 2
}

LANGUAGE: typescript
CODE:
declare const values: <A>(self: HashSet<A>) => IterableIterator<A>

----------------------------------------

TITLE: Type Signature of Record.getMonoidUnion in TypeScript
DESCRIPTION: This code snippet shows the type signature of the getMonoidUnion function. It takes a Monoid<A> as input and returns a Monoid for a readonly record with string keys and values of type A.

LANGUAGE: typescript
CODE:
declare const getMonoidUnion: <A>(value: monoid.Monoid<A>) => monoid.Monoid<Record.ReadonlyRecord<string, A>>

----------------------------------------

TITLE: Defining layerNoServerWebsocket Function in TypeScript
DESCRIPTION: This function creates a Layer for the ShardManager service without running a server. It takes options including runnerPath and optional runnerHttps. The Layer depends on various services like RpcSerialization, ShardStorage, RunnerHealth, and others.

LANGUAGE: TypeScript
CODE:
declare const layerNoServerWebsocket: (options: { readonly runnerPath: string; readonly runnerHttps?: boolean | undefined; }) => Layer.Layer<ShardManager.ShardManager, never, RpcSerialization.RpcSerialization | ShardStorage | RunnerHealth.RunnerHealth | Socket.WebSocketConstructor | ShardManager.Config | ShardingConfig>

----------------------------------------

TITLE: Demonstrating Doc.fillBreak Usage in TypeScript
DESCRIPTION: This example shows how to use Doc.fillBreak to format a list of function signatures. It demonstrates combining various Doc operations to create a formatted output.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import { pipe } from "effect/Function"
import * as String from "effect/String"

type Signature = [name: string, type: string]

const signatures: Array<Signature> = [
  ["empty", "Doc"],
  ["nest", "Int -> Doc -> Doc"],
  ["fillSep", "[Doc] -> Doc"]
]

const prettySignature = <A>([name, type]: Signature): Doc.Doc<A> =>
  Doc.hsep([
    pipe(Doc.text(name), Doc.fillBreak(5)),
    Doc.text("::"),
    Doc.text(type)
  ])

const doc = Doc.hsep([
  Doc.text("let"),
  Doc.align(Doc.vcat(signatures.map(prettySignature)))
])

assert.strictEqual(
  Doc.render(doc, { style: "pretty" }),
  String.stripMargin(
    `|let empty :: Doc
     |    nest  :: Int -> Doc -> Doc
     |    fillSep
     |          :: [Doc] -> Doc`
  )
)

----------------------------------------

TITLE: Implementing STM Transaction Replication in TypeScript
DESCRIPTION: Defines a function that executes an STM transaction a specified number of times and returns an array containing the results of each execution. Takes a number parameter n and an STM transaction, returning a new STM transaction that produces an array of results.

LANGUAGE: typescript
CODE:
declare const replicateSTM: { (n: number): <A, E, R>(self: STM<A, E, R>) => STM<Array<A>, E, R>; <A, E, R>(self: STM<A, E, R>, n: number): STM<Array<A>, E, R>; }

----------------------------------------

TITLE: Retrieving Oldest Value from TQueue in TypeScript
DESCRIPTION: The take function removes and returns the oldest value in a TDequeue. If the queue is empty, it returns a computation that resumes when an item is added to the queue. It's part of the TQueue module in the effect package.

LANGUAGE: typescript
CODE:
declare const take: <A>(self: TDequeue<A>) => STM.STM<A>

----------------------------------------

TITLE: Converting TSet to Array using STM in TypeScript
DESCRIPTION: Function signature for converting a TSet collection to an Array using Software Transactional Memory (STM). Takes a TSet of type A and returns an STM transaction that produces an Array of type A.

LANGUAGE: typescript
CODE:
declare const toArray: <A>(self: TSet<A>) => STM.STM<Array<A>>

----------------------------------------

TITLE: Using Effect.zipLeft in TypeScript
DESCRIPTION: Demonstrates how to use Effect.zipLeft to execute two effects sequentially, returning the result of the first effect and ignoring the result of the second. The example shows two tasks being executed with delays and logging.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

const task1 = Effect.succeed(1).pipe(
  Effect.delay("200 millis"),
  Effect.tap(Effect.log("task1 done"))
)
const task2 = Effect.succeed("hello").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Effect.log("task2 done"))
)

const program = Effect.zipLeft(task1, task2)

Effect.runPromise(program).then(console.log)
// Output:
// timestamp=... level=INFO fiber=#0 message="task1 done"
// timestamp=... level=INFO fiber=#0 message="task2 done"
// 1

----------------------------------------

TITLE: Adding Services to Context in TypeScript using Effect
DESCRIPTION: Demonstrates how to add services to a Context instance using Context.add. The example shows creating context tags for Port and Timeout services, then combining them into a single context with multiple services.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Context, pipe } from "effect"

const Port = Context.GenericTag<{ PORT: number }>("Port")
const Timeout = Context.GenericTag<{ TIMEOUT: number }>("Timeout")

const someContext = Context.make(Port, { PORT: 8080 })

const Services = pipe(
  someContext,
  Context.add(Timeout, { TIMEOUT: 5000 })
)

assert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })
assert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })

LANGUAGE: typescript
CODE:
declare const add: { <T extends Tag<any, any>>(tag: T, service: Tag.Service<T>): <Services>(self: Context<Services>) => Context<Services | Tag.Identifier<T>>; <Services, T extends Tag<any, any>>(self: Context<Services>, tag: T, service: Tag.Service<T>): Context<Services | Tag.Identifier<T>>; }

----------------------------------------

TITLE: Using Match.exhaustive for Type-Safe Pattern Matching in TypeScript
DESCRIPTION: Demonstrates how to use Match.exhaustive to create a type-safe pattern matcher that handles all cases of a union type. The example shows matching on string | number union type, with TypeScript enforcing complete case coverage.

LANGUAGE: typescript
CODE:
import { Match } from "effect"

// Create a matcher for string or number values
const match = Match.type<string | number>().pipe(
  // Match when the value is a number
  Match.when(Match.number, (n) => `number: ${n}`),
  // Mark the match as exhaustive, ensuring all cases are handled
  // TypeScript will throw an error if any case is missing
  // @ts-expect-error Type 'string' is not assignable to type 'never'
  Match.exhaustive
)

----------------------------------------

TITLE: Using Array.reduceRight in TypeScript with Effect Library
DESCRIPTION: Demonstrates how to use the reduceRight function to accumulate values from right to left in an array. The example shows summing numbers, starting with an initial value of 0.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const result = Array.reduceRight([1, 2, 3], 0, (acc, n) => acc + n)
console.log(result) // 6

LANGUAGE: typescript
CODE:
declare const reduceRight: { <B, A>(b: B, f: (b: B, a: A, i: number) => B): (self: Iterable<A>) => B; <A, B>(self: Iterable<A>, b: B, f: (b: B, a: A, i: number) => B): B; }

----------------------------------------

TITLE: Creating and Using Mailbox Queue in TypeScript
DESCRIPTION: Demonstrates how to create and use a Mailbox queue, including offering messages, taking messages, and handling completion/failure states. The example shows basic operations like offering single and multiple messages, checking queue status, and handling end/fail signals.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Effect, Mailbox } from "effect"

Effect.gen(function*() {
  const mailbox = yield* Mailbox.make<number, string>()

  // add messages to the mailbox
  yield* mailbox.offer(1)
  yield* mailbox.offer(2)
  yield* mailbox.offerAll([3, 4, 5])

  // take messages from the mailbox
  const [messages, done] = yield* mailbox.takeAll
  assert.deepStrictEqual(messages, [1, 2, 3, 4, 5])
  assert.strictEqual(done, false)

  // signal that the mailbox is done
  yield* mailbox.end
  const [messages2, done2] = yield* mailbox.takeAll
  assert.deepStrictEqual(messages2, [])
  assert.strictEqual(done2, true)

  // signal that the mailbox has failed
  yield* mailbox.fail("boom")
})

----------------------------------------

TITLE: Mapping Layer Contexts in TypeScript
DESCRIPTION: Defines a function that takes a Layer and transforms its output context using a mapping function. Supports both curried and uncurried versions for mapping Layer contexts from type A to type B while preserving error and requirement types.

LANGUAGE: typescript
CODE:
declare const map: {
  <A, B>(f: (context: Context.Context<A>) => Context.Context<B>): <E, R>(self: Layer<A, E, R>) => Layer<B, E, R>;
  <A, E, R, B>(self: Layer<A, E, R>, f: (context: Context.Context<A>) => Context.Context<B>): Layer<B, E, R>;
}

----------------------------------------

TITLE: Declaring Schedule.union Function in TypeScript
DESCRIPTION: Defines the union function for combining two schedules. It creates a new schedule that continues if either input schedule allows, using the shorter delay when both produce delays. The function is overloaded to handle different input types and return a schedule with combined output and input types.

LANGUAGE: TypeScript
CODE:
declare const union: { <Out2, In2, R2>(that: Schedule<Out2, In2, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<[Out, Out2], In & In2, R2 | R>; <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>): Schedule<[Out, Out2], In & In2, R | R2>; }

----------------------------------------

TITLE: Implementing List Reduction in TypeScript Effect-TS
DESCRIPTION: Defines a reduce function that folds over list elements using a specified function and initial value. The function supports both curried and uncurried forms for flexibility in usage patterns.

LANGUAGE: typescript
CODE:
declare const reduce: {
  <Z, A>(zero: Z, f: (b: Z, a: A) => Z): (self: List<A>) => Z;
  <A, Z>(self: List<A>, zero: Z, f: (b: Z, a: A) => Z): Z;
}

----------------------------------------

TITLE: Effect.catchTag Type Signature in TypeScript
DESCRIPTION: Type signature for the Effect.catchTag function showing its polymorphic nature and type constraints. The function requires errors to have a _tag field and allows handling specific error types.

LANGUAGE: typescript
CODE:
declare const catchTag: { <K extends E extends { _tag: string; } ? E["_tag"] : never, E, A1, E1, R1>(k: K, f: (e: NoInfer<Extract<E, { _tag: K; }>>) => Effect<A1, E1, R1>): <A, R>(self: Effect<A, E, R>) => Effect<A1 | A, E1 | Exclude<E, { _tag: K; }>, R1 | R>; <A, E, R, K extends E extends { _tag: string; } ? E["_tag"] : never, R1, E1, A1>(self: Effect<A, E, R>, k: K, f: (e: Extract<E, { _tag: K; }>) => Effect<A1, E1, R1>): Effect<A | A1, E1 | Exclude<E, { _tag: K; }>, R | R1>; }

----------------------------------------

TITLE: Defining retryUntil Function in TypeScript for STM Module
DESCRIPTION: Declares the retryUntil function with multiple overloads to handle different use cases. It filters values produced by STM effects and retries transactions until a predicate returns true for the value.

LANGUAGE: typescript
CODE:
declare const retryUntil: {
  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): <E, R>(self: STM<A, E, R>) => STM<B, E, R>;
  <A>(predicate: Predicate<A>): <E, R>(self: STM<A, E, R>) => STM<A, E, R>;
  <A, E, R, B extends A>(self: STM<A, E, R>, refinement: Refinement<A, B>): STM<B, E, R>;
  <A, E, R>(self: STM<A, E, R>, predicate: Predicate<A>): STM<A, E, R>;
}

----------------------------------------

TITLE: Implementing String Sink in TypeScript using Effect
DESCRIPTION: Creates a Sink that transforms input values into strings. The sink takes any input type and produces a string output, with never types for error, left, and done channels indicating no error handling or side channels.

LANGUAGE: typescript
CODE:
declare const mkString: Sink<string, unknown, never, never, never>

----------------------------------------

TITLE: Creating Single-Value Sink from Effect in TypeScript
DESCRIPTION: Function signature for creating a single-value sink from an Effect instance. The function takes an Effect with generic type parameters for value type A, error type E, and environment type R, returning a Sink that can consume values of type A.

LANGUAGE: typescript
CODE:
declare const fromEffect: <A, E, R>(effect: Effect.Effect<A, E, R>) => Sink<A, unknown, never, E, R>

----------------------------------------

TITLE: Effect.raceFirst Type Signature
DESCRIPTION: TypeScript type signature for the Effect.raceFirst function.

LANGUAGE: typescript
CODE:
declare const raceFirst: { <A2, E2, R2>(that: Effect<A2, E2, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, that: Effect<A2, E2, R2>): Effect<A | A2, E | E2, R | R2>; }

----------------------------------------

TITLE: Creating TPriorityQueue from Iterable in TypeScript
DESCRIPTION: The fromIterable function creates a new TPriorityQueue from an iterable collection of values. It takes an Order for the elements and returns a function that accepts an iterable and produces an STM (Software Transactional Memory) effect that results in a TPriorityQueue.

LANGUAGE: typescript
CODE:
declare const fromIterable: <A>(order: Order.Order<A>) => (iterable: Iterable<A>) => STM.STM<TPriorityQueue<A>>

----------------------------------------

TITLE: Creating Empty TMap in TypeScript using Effect Package
DESCRIPTION: The empty function creates an empty TMap. It takes no arguments and returns an STM (Software Transactional Memory) instance of TMap. The function is generic, allowing for any key and value types.

LANGUAGE: typescript
CODE:
declare const empty: <K, V>() => STM.STM<TMap<K, V>>

----------------------------------------

TITLE: Encoding Base64 String in TypeScript using Effect Library
DESCRIPTION: Function signature for encoding data into base64 format following RFC4648 standard. Accepts either a Uint8Array or string input and returns the base64 encoded string.

LANGUAGE: typescript
CODE:
declare const encodeBase64: (input: Uint8Array | string) => string

----------------------------------------

TITLE: Effect.tapErrorTag Type Signature
DESCRIPTION: Type signature for the tapErrorTag function showing its polymorphic implementation. Defines the function's type constraints and generic parameters for working with tagged error types in the Effect system.

LANGUAGE: typescript
CODE:
declare const tapErrorTag: { <K extends E extends { _tag: string; } ? E["_tag"] : never, E, A1, E1, R1>(k: K, f: (e: NoInfer<Extract<E, { _tag: K; }>>) => Effect<A1, E1, R1>): <A, R>(self: Effect<A, E, R>) => Effect<A, E | E1, R1 | R>; <A, E, R, K extends E extends { _tag: string; } ? E["_tag"] : never, A1, E1, R1>(self: Effect<A, E, R>, k: K, f: (e: Extract<E, { _tag: K; }>) => Effect<A1, E1, R1>): Effect<A, E | E1, R | R1>; }

----------------------------------------

TITLE: Using Array.unappend in TypeScript with Effect Library
DESCRIPTION: Demonstrates how to use the Array.unappend function to split a non-empty array into a tuple containing the array without its last element and the last element itself. The function operates on NonEmptyReadonlyArray type and returns a tuple with the modified array and the extracted element.

LANGUAGE: typescript
CODE:
import { Array } from "effect";

const result = Array.unappend([1, 2, 3, 4])
console.log(result) // [[1, 2, 3], 4]

LANGUAGE: typescript
CODE:
declare const unappend: <A>(self: NonEmptyReadonlyArray<A>) => [arrayWithoutLastElement: Array<A>, lastElement: A]

----------------------------------------

TITLE: Transforming Effect to Option using asSome in TypeScript
DESCRIPTION: Function that maps a successful Effect value to Some(value) in an Option type while preserving failure cases. Takes an Effect<A, E, R> and returns Effect<Option<A>, E, R>.

LANGUAGE: typescript
CODE:
declare const asSome: <A, E, R>(self: Effect<A, E, R>) => Effect<Option.Option<A>, E, R>

----------------------------------------

TITLE: Implementing HashMap Values Iterator in TypeScript
DESCRIPTION: Returns an IterableIterator that allows iteration over all values stored in a HashMap data structure. The method is type-safe and preserves the value type V from the original HashMap<K,V>.

LANGUAGE: typescript
CODE:
declare const values: <K, V>(self: HashMap<K, V>) => IterableIterator<V>

----------------------------------------

TITLE: Creating Summary Metric in Effect TypeScript
DESCRIPTION: Demonstrates how to create a Summary metric for measuring response times with customizable parameters including retention period, maximum observations, error tolerance, and quantile calculations.

LANGUAGE: typescript
CODE:
import { Metric, Chunk } from "effect"

const responseTimesSummary = Metric.summary({
  name: "response_times_summary",
  maxAge: "60 seconds", // Retain observations for 60 seconds.
  maxSize: 1000, // Keep a maximum of 1000 observations.
  error: 0.01, // Allow a 1% error when calculating quantiles.
  quantiles: [0.5, 0.9, 0.99], // Calculate 50th, 90th, and 99th percentiles.
  description: "Measures the distribution of response times."
});

LANGUAGE: typescript
CODE:
declare const summary: (options: { readonly name: string; readonly maxAge: Duration.DurationInput; readonly maxSize: number; readonly error: number; readonly quantiles: ReadonlyArray<number>; readonly description?: string | undefined; }) => Metric.Summary<number>

----------------------------------------

TITLE: Creating Bounded Queue with Dropping Strategy in TypeScript
DESCRIPTION: The 'dropping' function creates a bounded queue that drops new values when at capacity. It is recommended to use capacities that are powers of two for optimal performance. The function returns an STM (Software Transactional Memory) instance of TQueue.

LANGUAGE: typescript
CODE:
declare const dropping: <A>(requestedCapacity: number) => STM.STM<TQueue<A>>

----------------------------------------

TITLE: Formatting DateTime to ISO String in TypeScript
DESCRIPTION: Function signature for formatting a DateTime object into an ISO date string that includes timezone adjustments. Takes a DateTime object as input and returns a formatted string.

LANGUAGE: typescript
CODE:
declare const formatIsoDate: (self: DateTime) => string

----------------------------------------

TITLE: Array.contains Function Signature in TypeScript
DESCRIPTION: Defines the type signature for the Array.contains function. It can be used in two ways: either by passing the array and value separately, or by creating a function that checks for a specific value in any array.

LANGUAGE: typescript
CODE:
declare const contains: { <A>(a: A): (self: Iterable<A>) => boolean; <A>(self: Iterable<A>, a: A): boolean; }

----------------------------------------

TITLE: Merging Multiple Contexts using Context.mergeAll in TypeScript
DESCRIPTION: Demonstrates how to merge multiple Context instances containing different service configurations. The example shows combining three contexts with PORT, TIMEOUT, and HOST configurations into a single unified context, with type-safe access to all services.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Context } from "effect"

const Port = Context.GenericTag<{ PORT: number }>("Port")
const Timeout = Context.GenericTag<{ TIMEOUT: number }>("Timeout")
const Host = Context.GenericTag<{ HOST: string }>("Host")

const firstContext = Context.make(Port, { PORT: 8080 })
const secondContext = Context.make(Timeout, { TIMEOUT: 5000 })
const thirdContext = Context.make(Host, { HOST: "localhost" })

const Services = Context.mergeAll(firstContext, secondContext, thirdContext)

assert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })
assert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })
assert.deepStrictEqual(Context.get(Services, Host), { HOST: "localhost" })

LANGUAGE: typescript
CODE:
declare const mergeAll: <T extends Array<unknown>>(...ctxs: { [K in keyof T]: Context<T[K]>; }) => Context<T[number]>

----------------------------------------

TITLE: Defining Schedule Interface in TypeScript
DESCRIPTION: This snippet defines the Schedule interface, which represents a recurring schedule that consumes values of type In and produces values of type Out. It includes methods for initial state and step execution.

LANGUAGE: typescript
CODE:
export interface Schedule<out Out, in In = unknown, out R = never> extends Schedule.Variance<Out, In, R>, Pipeable {
  /**
   * Initial State
   */
  readonly initial: any
  /**
   * Schedule Step
   */
  step(
    now: number,
    input: In,
    state: any
  ): Effect.Effect<readonly [any, Out, ScheduleDecision.ScheduleDecision], never, R>
}

----------------------------------------

TITLE: Implementing Error Recovery in STM with TypeScript
DESCRIPTION: Defines the catchAll function signature that recovers from all errors in STM transactions. The function takes an error handler and returns a new STM transaction that can either succeed with the original value or the recovery value.

LANGUAGE: typescript
CODE:
declare const catchAll: { <E, B, E1, R1>(f: (e: E) => STM<B, E1, R1>): <A, R>(self: STM<A, E, R>) => STM<B | A, E1, R1 | R>; <A, E, R, B, E1, R1>(self: STM<A, E, R>, f: (e: E) => STM<B, E1, R1>): STM<A | B, E1, R | R1>; }

----------------------------------------

TITLE: Configuring Secret Values in Effect Config Module
DESCRIPTION: Function for constructing a configuration for secret values. Takes an optional name parameter and returns a Config object wrapped with Secret type.

LANGUAGE: typescript
CODE:
declare const secret: (name?: string) => Config<Secret.Secret>

----------------------------------------

TITLE: Using clockWith with Effect and Console
DESCRIPTION: Demonstrates how to use clockWith to access the current system time and log it to the console. The function retrieves the Clock service and uses it to get the current time in milliseconds.

LANGUAGE: typescript
CODE:
import { Console, Effect } from "effect"

const program = Effect.clockWith((clock) =>
  clock.currentTimeMillis.pipe(
    Effect.map((currentTime) => `Current time is: ${currentTime}`),
    Effect.tap(Console.log)
  )
)

Effect.runFork(program)
// Example Output:
// Current time is: 1735484929744

LANGUAGE: typescript
CODE:
declare const clockWith: <A, E, R>(f: (clock: Clock.Clock) => Effect<A, E, R>) => Effect<A, E, R>

----------------------------------------

TITLE: Retrieving Keys from HashMap in TypeScript
DESCRIPTION: The keys function returns an IterableIterator of the keys within the HashMap. It takes a HashMap<K, V> as input and produces an IterableIterator<K> as output.

LANGUAGE: typescript
CODE:
declare const keys: <K, V>(self: HashMap<K, V>) => IterableIterator<K>

----------------------------------------

TITLE: Implementing Effectful Fold Operation in TypeScript Stream
DESCRIPTION: Defines a function that executes an effectful fold over a stream of values. The function takes an initial state and a folding function that produces effects, accumulating results while handling errors and resource management through the Effect type system.

LANGUAGE: typescript
CODE:
declare const runFoldEffect: { 
  <S, A, E2, R2>(s: S, f: (s: S, a: A) => Effect.Effect<S, E2, R2>): 
    <E, R>(self: Stream<A, E, R>) => Effect.Effect<S, E2 | E, Exclude<R | R2, Scope.Scope>>; 
  <A, E, R, S, E2, R2>(self: Stream<A, E, R>, s: S, f: (s: S, a: A) => Effect.Effect<S, E2, R2>): 
    Effect.Effect<S, E | E2, Exclude<R | R2, Scope.Scope>>; 
}

----------------------------------------

TITLE: Retrieving Clock Service with Effect.clock in TypeScript
DESCRIPTION: This snippet demonstrates how to use Effect.clock to retrieve the Clock service and get the current time in milliseconds. It uses Effect.gen for creating a generator-based effect and Effect.runFork for execution.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

const program = Effect.gen(function*() {
  const clock = yield* Effect.clock
  const currentTime = yield* clock.currentTimeMillis
  console.log(`Current time in milliseconds: ${currentTime}`)
})

Effect.runFork(program)
// Example Output:
// Current time in milliseconds: 1735484796134

----------------------------------------

TITLE: Creating Tracing Spans with Effect.makeSpan in TypeScript
DESCRIPTION: The makeSpan function creates a new span for tracing. It takes a name parameter and optional span options, returning an Effect of Tracer.Span.

LANGUAGE: typescript
CODE:
declare const makeSpan: (name: string, options?: Tracer.SpanOptions) => Effect<Tracer.Span>

----------------------------------------

TITLE: Removing Key from Record in TypeScript using Effect Library
DESCRIPTION: Demonstrates how to remove a key from a record using the remove function from effect/Record. Returns a new record with the specified key removed while preserving type safety.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { remove } from "effect/Record"

assert.deepStrictEqual(remove({ a: 1, b: 2 }, "a"), { b: 2 })

LANGUAGE: typescript
CODE:
declare const remove: { <K extends string | symbol, X extends K>(key: X): <A>(self: ReadonlyRecord<K, A>) => Record<Exclude<K, X>, A>; <K extends string | symbol, A, X extends K>(self: ReadonlyRecord<K, A>, key: X): Record<Exclude<K, X>, A>; }

----------------------------------------

TITLE: Peeking Next Element in TQueue (TypeScript)
DESCRIPTION: Implements a function to view the next element in a TDequeue without removing it, retrying if the queue is empty. This operation is performed within an STM (Software Transactional Memory) context.

LANGUAGE: typescript
CODE:
declare const peek: <A>(self: TDequeue<A>) => STM.STM<A>

----------------------------------------

TITLE: Implementing Infinite Schedule Counter in TypeScript
DESCRIPTION: Defines a Schedule type that runs indefinitely and produces an incrementing count (0, 1, 2, ...) of repetitions. This schedule never terminates and can be used to track the number of executions.

LANGUAGE: typescript
CODE:
declare const forever: Schedule<number, unknown, never>

----------------------------------------

TITLE: Declaring failSync Function in TypeScript for Effect Module
DESCRIPTION: Defines the failSync function that creates an Effect which fails with a specified error. The error is evaluated lazily using a LazyArg. The function returns an Effect with never as the success type and E as the error type.

LANGUAGE: typescript
CODE:
declare const failSync: <E>(evaluate: LazyArg<E>) => Effect<never, E>

----------------------------------------

TITLE: Implementing Schedule Delay Modification in TypeScript
DESCRIPTION: Defines a function that transforms a schedule by modifying the delay between executions. It takes a transformation function that receives the schedule's output and original duration, returning a new adjusted delay duration.

LANGUAGE: typescript
CODE:
declare const modifyDelay: { 
  <Out>(f: (out: Out, duration: Duration.Duration) => Duration.DurationInput): 
    <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; 
  <Out, In, R>(self: Schedule<Out, In, R>, 
    f: (out: Out, duration: Duration.Duration) => Duration.DurationInput): 
    Schedule<Out, In, R>; 
}

----------------------------------------

TITLE: Creating Failing Sink with Lazy Cause Evaluation in TypeScript
DESCRIPTION: The failCauseSync function creates a sink that halts with a specified lazily evaluated Cause. It takes a LazyArg<Cause.Cause<E>> as input and returns a Sink that never succeeds, accepts any input, and fails with the specified cause.

LANGUAGE: typescript
CODE:
declare const failCauseSync: <E>(evaluate: LazyArg<Cause.Cause<E>>) => Sink<never, unknown, never, E>

----------------------------------------

TITLE: Declaring Doc.dot Constant in TypeScript
DESCRIPTION: Declares a constant named 'dot' of type Doc<never> representing a document containing a single '.' character. This constant is part of the Doc module in the @effect/printer package.

LANGUAGE: typescript
CODE:
declare const dot: Doc<never>

----------------------------------------

TITLE: Declaring Queue.offer Function in TypeScript
DESCRIPTION: Declares the offer function for the Queue module. This function takes a value and enqueues it, returning an Effect that resolves to a boolean indicating success.

LANGUAGE: typescript
CODE:
declare const offer: { <A>(value: A): (self: Enqueue<A>) => Effect.Effect<boolean>; <A>(self: Enqueue<A>, value: A): Effect.Effect<boolean>; }

----------------------------------------

TITLE: Declaring NumberFromString Schema Class - TypeScript
DESCRIPTION: TypeScript class declaration for NumberFromString schema that transforms string values into numbers. Handles special string values like "NaN", "Infinity", and "-Infinity". Returns an error for invalid numeric strings.

LANGUAGE: typescript
CODE:
declare class NumberFromString

----------------------------------------

TITLE: Dropping Elements from Array End in TypeScript using Effect
DESCRIPTION: Demonstrates how to use the Array.dropRight function to remove a specified number of elements from the end of an array. The function normalizes the input to a non-negative integer and returns a new array.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const result = Array.dropRight([1, 2, 3, 4, 5], 2)
console.log(result) // [1, 2, 3]

----------------------------------------

TITLE: Defining tapBoth Function for STM in TypeScript
DESCRIPTION: Declares the tapBoth function which allows peeking at both success and failure cases of a transactional effect. It takes options for handling both failure and success scenarios, returning a new STM instance.

LANGUAGE: typescript
CODE:
declare const tapBoth: { <XE extends E, A2, E2, R2, XA extends A, A3, E3, R3, A, E>(options: { readonly onFailure: (error: XE) => STM<A2, E2, R2>; readonly onSuccess: (value: XA) => STM<A3, E3, R3>; }): <R>(self: STM<A, E, R>) => STM<A, E | E2 | E3, R2 | R3 | R>; <A, E, R, XE extends E, A2, E2, R2, XA extends A, A3, E3, R3>(self: STM<A, E, R>, options: { readonly onFailure: (error: XE) => STM<A2, E2, R2>; readonly onSuccess: (value: XA) => STM<A3, E3, R3>; }): STM<A, E | E2 | E3, R | R2 | R3>; }

----------------------------------------

TITLE: Defining offerAll Function for TQueue in TypeScript
DESCRIPTION: Declares the offerAll function for TQueue, which offers multiple values to the queue. The behavior varies based on the queue type (Bounded, Unbounded, Sliding, or Dropping) and uses different strategies for handling capacity limits.

LANGUAGE: typescript
CODE:
declare const offerAll: { <A>(iterable: Iterable<A>): (self: TEnqueue<A>) => STM.STM<boolean>; <A>(self: TEnqueue<A>, iterable: Iterable<A>): STM.STM<boolean>; }

----------------------------------------

TITLE: Serializing Cookies Object to Cookie Header in TypeScript
DESCRIPTION: The toCookieHeader function takes a Cookies object as input and returns a string representation of the Cookie header. This function is part of the Cookies module in the @effect/platform package and has been available since version 1.0.0.

LANGUAGE: typescript
CODE:
declare const toCookieHeader: (self: Cookies) => string

----------------------------------------

TITLE: Using takeLeft Function in Effect String Module
DESCRIPTION: Demonstrates how to use the takeLeft function to extract characters from the start of a string. The function takes a number parameter specifying how many characters to keep and returns the truncated string. Handles edge cases like oversized lengths and non-positive numbers.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { String } from "effect"

assert.deepStrictEqual(String.takeLeft("Hello World", 5), "Hello")

LANGUAGE: typescript
CODE:
declare const takeLeft: { (n: number): (self: string) => string; (self: string, n: number): string; }

----------------------------------------

TITLE: Implementing Iterable Reduction with STM in TypeScript
DESCRIPTION: The STM.reduce function folds an Iterable<A> using an effectual function f, working sequentially from left to right. It takes an initial value, a reducer function, and an iterable, returning an STM effect.

LANGUAGE: typescript
CODE:
declare const reduce: {
  <S, A, E, R>(zero: S, f: (s: S, a: A) => STM<S, E, R>): (iterable: Iterable<A>) => STM<S, E, R>;
  <S, A, E, R>(iterable: Iterable<A>, zero: S, f: (s: S, a: A) => STM<S, E, R>): STM<S, E, R>;
}

----------------------------------------

TITLE: Creating and Using a Matcher with Match.value in TypeScript
DESCRIPTION: Demonstrates how to create a matcher from a specific object value and use it for pattern matching. The example matches an object by its 'name' property and returns a formatted string.

LANGUAGE: typescript
CODE:
import { Match } from "effect"

const input = { name: "John", age: 30 }

// Create a matcher for the specific object
const result = Match.value(input).pipe(
  // Match when the 'name' property is "John"
  Match.when(
    { name: "John" },
    (user) => `${user.name} is ${user.age} years old`
  ),
  // Provide a fallback if no match is found
  Match.orElse(() => "Oh, not John")
)

console.log(result)
// Output: "John is 30 years old"

----------------------------------------

TITLE: Implementing Stream.tapError Function in TypeScript
DESCRIPTION: Defines a tapError function that takes an error handling effect function and returns a modified stream that can perform side effects when errors occur. The function preserves the original error while allowing additional error types to be introduced through the error handling effect.

LANGUAGE: typescript
CODE:
declare const tapError: { 
  <E, X, E2, R2>(f: (error: NoInfer<E>) => Effect.Effect<X, E2, R2>): 
    <A, R>(self: Stream<A, E, R>) => Stream<A, E | E2, R2 | R>; 
  <A, E, R, X, E2, R2>(self: Stream<A, E, R>, f: (error: E) => Effect.Effect<X, E2, R2>): 
    Stream<A, E | E2, R | R2>; 
}

----------------------------------------

TITLE: Marking Effects as Interruptible in TypeScript
DESCRIPTION: A function that takes an Effect instance and returns a new Effect marked as interruptible. The function preserves the original type parameters A (value type), E (error type), and R (environment type).

LANGUAGE: typescript
CODE:
declare const interruptible: <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>

----------------------------------------

TITLE: Mixed Success/Failure Race Example
DESCRIPTION: Example showing race behavior when one task fails and one succeeds.

LANGUAGE: typescript
CODE:
import { Effect, Console } from "effect"

const task1 = Effect.fail("task1").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Console.log("task1 done")),
  Effect.onInterrupt(() =>
    Console.log("task1 interrupted").pipe(Effect.delay("100 millis"))
  )
)
const task2 = Effect.succeed("task2").pipe(
  Effect.delay("200 millis"),
  Effect.tap(Console.log("task2 done")),
  Effect.onInterrupt(() =>
    Console.log("task2 interrupted").pipe(Effect.delay("100 millis"))
  )
)

const program = Effect.raceFirst(task1, task2).pipe(
  Effect.tap(Console.log("more work..."))
)

Effect.runPromiseExit(program).then(console.log)

----------------------------------------

TITLE: Defining Layer.succeed Function in TypeScript
DESCRIPTION: This code snippet defines the Layer.succeed function, which constructs a layer from a specified value. It has two overloads: one that takes a tag and returns a function, and another that takes both a tag and a resource.

LANGUAGE: typescript
CODE:
declare const succeed: {
  <I, S>(tag: Context.Tag<I, S>): (resource: Types.NoInfer<S>) => Layer<I>;
  <I, S>(tag: Context.Tag<I, S>, resource: Types.NoInfer<S>): Layer<I>;
}

----------------------------------------

TITLE: Decoding Base64 Strings to Uint8Array in TypeScript
DESCRIPTION: This function decodes a base64 (RFC4648) encoded string into a Uint8Array. It returns an Either type, which can contain either the decoded Uint8Array or a DecodeException if the decoding fails.

LANGUAGE: typescript
CODE:
declare const decodeBase64: (str: string) => Either.Either<Uint8Array, DecodeException>

----------------------------------------

TITLE: Implementing Stream Finalizer with Effect Library in TypeScript
DESCRIPTION: Demonstrates how to use Stream.finalizer to execute cleanup logic after a stream completes. The example shows creating a stream that logs application logic and then executes a directory cleanup operation as a finalizer.

LANGUAGE: typescript
CODE:
import { Console, Effect, Stream } from "effect"

const application = Stream.fromEffect(Console.log("Application Logic."))

const deleteDir = (dir: string) => Console.log(`Deleting dir: ${dir}`)

const program = application.pipe(
  Stream.concat(
    Stream.finalizer(
      deleteDir("tmp").pipe(
        Effect.andThen(Console.log("Temporary directory was deleted."))
      )
    )
  )
)

Effect.runPromise(Stream.runCollect(program)).then(console.log)
// Application Logic.
// Deleting dir: tmp
// Temporary directory was deleted.
// { _id: 'Chunk', values: [ undefined, undefined ] }

----------------------------------------

TITLE: Converting ConfigProvider Names to Kebab Case in TypeScript
DESCRIPTION: A function that takes a ConfigProvider instance and returns a new ConfigProvider with all property names converted to kebab case format. This allows adapting configuration properties from camelCase to kebab-case naming convention.

LANGUAGE: typescript
CODE:
declare const kebabCase: (self: ConfigProvider) => ConfigProvider

----------------------------------------

TITLE: Declaring DateTime.unsafeNow Function in TypeScript
DESCRIPTION: Type declaration for the unsafeNow function that returns the current UTC time. The function is implemented as a lazy argument that returns a Utc value when evaluated.

LANGUAGE: typescript
CODE:
declare const unsafeNow: LazyArg<Utc>

----------------------------------------

TITLE: Implementing Number Range Validation in Effect Schema TypeScript
DESCRIPTION: A type-safe filter implementation that checks if a number value falls between specified minimum and maximum bounds. The filter can be applied to any Schema that handles numeric values and supports custom annotations.

LANGUAGE: typescript
CODE:
declare const between: <S extends Schema.Any>(minimum: number, maximum: number, annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>

----------------------------------------

TITLE: Converting Effect Failures with Custom Error Handling in TypeScript
DESCRIPTION: Demonstrates how to use orDieWith to handle division by zero errors by converting them into custom fiber terminations. The example shows how to transform a basic error into a more detailed defect message.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

const divide = (a: number, b: number) =>
  b === 0
    ? Effect.fail(new Error("Cannot divide by zero"))
    : Effect.succeed(a / b)

//      ┌─── Effect<number, never, never>
//      ▼
const program = Effect.orDieWith(
  divide(1, 0),
  (error) => new Error(`defect: ${error.message}`)
)

Effect.runPromise(program).catch(console.error)
// Output:
// (FiberFailure) Error: defect: Cannot divide by zero
//   ...stack trace...

LANGUAGE: typescript
CODE:
declare const orDieWith: { <E>(f: (error: E) => unknown): <A, R>(self: Effect<A, E, R>) => Effect<A, never, R>; <A, E, R>(self: Effect<A, E, R>, f: (error: E) => unknown): Effect<A, never, R>; }

----------------------------------------

TITLE: Channel.zip Type Definition in TypeScript
DESCRIPTION: Type definition for the zip function that composes two channels sequentially. The function returns a new channel that combines both input channels and terminates with a tuple containing both channels' terminal values. Supports optional concurrent execution via options parameter.

LANGUAGE: typescript
CODE:
declare const zip: { <OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(that: Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>, options?: { readonly concurrent?: boolean | undefined; } | undefined): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1 | OutElem, InElem & InElem1, OutErr1 | OutErr, InErr & InErr1, readonly [OutDone, OutDone1], InDone & InDone1, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, that: Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>, options?: { readonly concurrent?: boolean | undefined; } | undefined): Channel<OutElem | OutElem1, InElem & InElem1, OutErr | OutErr1, InErr & InErr1, readonly [OutDone, OutDone1], InDone & InDone1, Env | Env1>; }

----------------------------------------

TITLE: Retrieving Services Using Context.unsafeGet in TypeScript
DESCRIPTION: Demonstrates how to use Context.unsafeGet to retrieve services from a context using tags. Shows both successful retrieval and error cases when a tag is not found.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Context } from "effect"

const Port = Context.GenericTag<{ PORT: number }>("Port")
const Timeout = Context.GenericTag<{ TIMEOUT: number }>("Timeout")

const Services = Context.make(Port, { PORT: 8080 })

assert.deepStrictEqual(Context.unsafeGet(Services, Port), { PORT: 8080 })
assert.throws(() => Context.unsafeGet(Services, Timeout))

----------------------------------------

TITLE: Defining dieSync Function in TypeScript for Effect Module
DESCRIPTION: This snippet defines the dieSync function, which creates an effect that dies with a specified error. The error is evaluated lazily when the effect runs. It takes a LazyArg<unknown> as input and returns an Effect<never>.

LANGUAGE: typescript
CODE:
declare const dieSync: (evaluate: LazyArg<unknown>) => Effect<never>

----------------------------------------

TITLE: TypeScript Function Signature for catWithSpace in @effect/printer
DESCRIPTION: Provides the TypeScript function signature for the catWithSpace combinator. It shows two overloads: one for curried usage and another for direct application with two parameters.

LANGUAGE: typescript
CODE:
declare const catWithSpace: { <B>(that: Doc<B>): <A>(self: Doc<A>) => Doc<B | A>; <A, B>(self: Doc<A>, that: Doc<B>): Doc<A | B>; }

----------------------------------------

TITLE: Defining Scoped Effect Channel in TypeScript
DESCRIPTION: Declares a scoped function that takes an Effect and returns a Channel. It's used to emit an output element using a scoped effect. The function excludes Scope.Scope from the resulting Channel's environment type.

LANGUAGE: typescript
CODE:
declare const scoped: <A, E, R>(effect: Effect.Effect<A, E, R>) => Channel<A, unknown, E, unknown, unknown, unknown, Exclude<R, Scope.Scope>>

----------------------------------------

TITLE: Defining Doc.vbar Constant in TypeScript
DESCRIPTION: Declares a constant named 'vbar' of type Doc<never> representing a document containing a single '|' character. This is part of the @effect/printer package's Doc module.

LANGUAGE: typescript
CODE:
declare const vbar: Doc<never>

----------------------------------------

TITLE: Defining 'unless' Function in STM Module (TypeScript)
DESCRIPTION: Declares the 'unless' function, which is the moral equivalent of 'if (!p) exp'. It takes a predicate and returns a function that wraps an STM computation, or takes both the STM computation and predicate directly.

LANGUAGE: typescript
CODE:
declare const unless: { (predicate: LazyArg<boolean>): <A, E, R>(self: STM<A, E, R>) => STM<Option.Option<A>, E, R>; <A, E, R>(self: STM<A, E, R>, predicate: LazyArg<boolean>): STM<Option.Option<A>, E, R>; }

----------------------------------------

TITLE: Removing Elements from Transactional Set in TypeScript
DESCRIPTION: The remove function allows for the removal of a single element from a TSet. It can be used in two ways: either by passing the value to remove and then the set, or by passing the set and then the value to remove. The operation is performed within an STM (Software Transactional Memory) context.

LANGUAGE: typescript
CODE:
declare const remove: { <A>(value: A): (self: TSet<A>) => STM.STM<void>; <A>(self: TSet<A>, value: A): STM.STM<void>; }

----------------------------------------

TITLE: Using zipRight with Effect Module in TypeScript
DESCRIPTION: Demonstrates sequential execution of two effects using zipRight, where task1 has a 200ms delay and task2 has a 100ms delay. The example shows how the first effect's result is ignored while keeping its side effects.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

const task1 = Effect.succeed(1).pipe(
  Effect.delay("200 millis"),
  Effect.tap(Effect.log("task1 done"))
)
const task2 = Effect.succeed("hello").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Effect.log("task2 done"))
)

const program = Effect.zipRight(task1, task2)

Effect.runPromise(program).then(console.log)
// Output:
// timestamp=... level=INFO fiber=#0 message="task1 done"
// timestamp=... level=INFO fiber=#0 message="task2 done"
// hello

----------------------------------------

TITLE: Selecting Random Element from Array using Effect and Random in TypeScript
DESCRIPTION: This snippet demonstrates how to use the Random.choice function to select a random element from an array using the Effect library. It uses the Effect.gen generator function to handle the asynchronous operation.

LANGUAGE: typescript
CODE:
import { Effect, Random } from "effect"

Effect.gen(function* () {
  const randomItem = yield* Random.choice([1, 2, 3])
  console.log(randomItem)
})

----------------------------------------

TITLE: Creating Commands with Command.make in TypeScript
DESCRIPTION: Function signature for creating a command with a specified process name and optional arguments. Returns a Command object that represents the process to be executed.

LANGUAGE: typescript
CODE:
declare const make: (command: string, ...args: Array<string>) => Command

----------------------------------------

TITLE: Constructing Failing Layer in TypeScript
DESCRIPTION: The die function creates a Layer that immediately fails with a specified defect. It takes an unknown type as input and returns a Layer of unknown type. This is useful for creating layers that represent failure cases or for testing error handling.

LANGUAGE: typescript
CODE:
declare const die: (defect: unknown) => Layer<unknown>

----------------------------------------

TITLE: Creating Generic Tagged Enum for Result Type in TypeScript
DESCRIPTION: Shows how to create a generic tagged enum for a Result type with Failure and Success variants. It uses Data.TaggedEnum.WithGenerics to define generic parameters.

LANGUAGE: typescript
CODE:
import { Data } from "effect"

type MyResult<E, A> = Data.TaggedEnum<{
  Failure: { readonly error: E }
  Success: { readonly value: A }
}>
interface MyResultDefinition extends Data.TaggedEnum.WithGenerics<2> {
  readonly taggedEnum: MyResult<this["A"], this["B"]>
}
const { Failure, Success } = Data.taggedEnum<MyResultDefinition>()

const success = Success({ value: 1 })

----------------------------------------

TITLE: Filtering HashSet with Predicate in TypeScript
DESCRIPTION: Demonstrates filtering positive numbers from a HashSet using a predicate function. Shows three different syntax approaches: pipeable API, pipe method, and data-first API. Time complexity is O(n).

LANGUAGE: typescript
CODE:
import { HashSet, type Predicate, pipe } from "effect"

const filterPositiveNumbers: Predicate.Predicate<number> = (n) => n > 0

// with `data-last`, a.k.a. `pipeable` API
pipe(
  HashSet.make(-2, -1, 0, 1, 2),
  HashSet.filter(filterPositiveNumbers)
)

// or with the pipe method
HashSet.make(-2, -1, 0, 1, 2).pipe(HashSet.filter(filterPositiveNumbers))

// or with `data-first` API
HashSet.filter(HashSet.make(-2, -1, 0, 1, 2), filterPositiveNumbers)

----------------------------------------

TITLE: Array Chunking Property Example in TypeScript
DESCRIPTION: Demonstrates the mathematical property of the chunksOf function where chunking two arrays separately and concatenating them is equivalent to chunking their concatenation.

LANGUAGE: typescript
CODE:
chunksOf(n)(xs).concat(chunksOf(n)(ys)) == chunksOf(n)(xs.concat(ys)))

----------------------------------------

TITLE: Accessing Chunk Elements with get Function in TypeScript
DESCRIPTION: Function signature for safely retrieving elements from a Chunk data structure by index. Returns an Option type containing the element if it exists at the specified index. Supports both curried and uncurried calling styles.

LANGUAGE: typescript
CODE:
declare const get: { (index: number): <A>(self: Chunk<A>) => Option<A>; <A>(self: Chunk<A>, index: number): Option<A>; }

----------------------------------------

TITLE: Array.pad Function Signature in TypeScript
DESCRIPTION: Provides the TypeScript function signature for the Array.pad function. It shows the function's polymorphic nature, accepting arrays of any type and a fill value of potentially different type.

LANGUAGE: typescript
CODE:
declare const pad: { <A, T>(n: number, fill: T): (self: Array<A>) => Array<A | T>; <A, T>(self: Array<A>, n: number, fill: T): Array<A | T>; }

----------------------------------------

TITLE: Type Signature for tapError Function in Effect Module (TypeScript)
DESCRIPTION: Provides the type signature for the tapError function in the Effect module. It shows the function's polymorphic nature, allowing for different effect types and error handling.

LANGUAGE: typescript
CODE:
declare const tapError: { <E, X, E2, R2>(f: (e: NoInfer<E>) => Effect<X, E2, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A, E | E2, R2 | R>; <A, E, R, X, E2, R2>(self: Effect<A, E, R>, f: (e: E) => Effect<X, E2, R2>): Effect<A, E | E2, R | R2>; }

----------------------------------------

TITLE: Filtering HashSet with Predicate in TypeScript
DESCRIPTION: Demonstrates filtering positive numbers from a HashSet using a predicate function. Shows three different syntax approaches: pipeable API, pipe method, and data-first API. Time complexity is O(n).

LANGUAGE: typescript
CODE:
import { HashSet, type Predicate, pipe } from "effect"

const filterPositiveNumbers: Predicate.Predicate<number> = (n) => n > 0

// with `data-last`, a.k.a. `pipeable` API
pipe(
  HashSet.make(-2, -1, 0, 1, 2),
  HashSet.filter(filterPositiveNumbers)
)

// or with the pipe method
HashSet.make(-2, -1, 0, 1, 2).pipe(HashSet.filter(filterPositiveNumbers))

// or with `data-first` API
HashSet.filter(HashSet.make(-2, -1, 0, 1, 2), filterPositiveNumbers)

----------------------------------------

TITLE: Accumulating Values with Array.scan in TypeScript
DESCRIPTION: Demonstrates the usage of Array.scan to accumulate values from an Iterable, storing each intermediate result. It shows how to calculate cumulative sums of an array.

LANGUAGE: typescript
CODE:
import { Array } from "effect";

const result = Array.scan([1, 2, 3, 4], 0, (acc, value) => acc + value)
console.log(result) // [0, 1, 3, 6, 10]

// Explanation:
// This function starts with the initial value (0 in this case)
// and adds each element of the array to this accumulator one by one,
// keeping track of the cumulative sum after each addition.
// Each of these sums is captured in the resulting array.

----------------------------------------

TITLE: Implementing FiberHandle.awaitEmpty in TypeScript
DESCRIPTION: Function that waits for a fiber in a FiberHandle to complete. Returns an Effect that resolves to void or an error of type E.

LANGUAGE: typescript
CODE:
declare const awaitEmpty: <A, E>(self: FiberHandle<A, E>) => Effect.Effect<void, E>

----------------------------------------

TITLE: Constructing List<A> with List.make in TypeScript
DESCRIPTION: The List.make function constructs a new List<A> from specified values. It takes a variable number of elements and returns a Cons (non-empty list) of those elements.

LANGUAGE: typescript
CODE:
declare const make: <Elements extends readonly [any, ...Array<any>]>(...elements: Elements) => Cons<Elements[number]>

----------------------------------------

TITLE: Array.join Function Signature in TypeScript
DESCRIPTION: Provides the TypeScript function signature for the Array.join function. It shows two overloads: one that takes a separator first and returns a function, and another that takes the array and separator as arguments.

LANGUAGE: typescript
CODE:
declare const join: { (sep: string): (self: Iterable<string>) => string; (self: Iterable<string>, sep: string): string; }

----------------------------------------

TITLE: Filtering Effects with Type Guards in TypeScript
DESCRIPTION: Demonstrates how to use filterOrFail with a type guard to filter and narrow down the type of an Effect's success channel while handling authentication. Shows how to convert nullable user data into a strictly typed User object with custom error handling.

LANGUAGE: typescript
CODE:
import { Effect, pipe } from "effect"

// Define a user interface
interface User {
  readonly name: string
}

// Simulate an asynchronous authentication function
declare const auth: () => Promise<User | null>

const program = pipe(
  Effect.promise(() => auth()),
  // Use filterOrFail with a custom type guard to ensure user is not null
  Effect.filterOrFail(
    (user): user is User => user !== null, // Type guard
    () => new Error("Unauthorized")
  ),
  // 'user' now has the type `User` (not `User | null`)
  Effect.andThen((user) => user.name)
)

----------------------------------------

TITLE: Using Option.bind in a Do Simulation with TypeScript
DESCRIPTION: Demonstrates how to use Option.bind within a do simulation to define variables, perform operations, and chain multiple Option functions. It shows binding values, using let for simple assignments, and applying filter.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Option, pipe } from "effect"

const result = pipe(
  Option.Do,
  Option.bind("x", () => Option.some(2)),
  Option.bind("y", () => Option.some(3)),
  Option.let("sum", ({ x, y }) => x + y),
  Option.filter(({ x, y }) => x * y > 5)
)
assert.deepStrictEqual(result, Option.some({ x: 2, y: 3, sum: 5 }))

----------------------------------------

TITLE: Implementing Layer.zipWith in TypeScript for Effect Library
DESCRIPTION: Defines the zipWith function for combining two layers concurrently and transforming their outputs. It supports both curried and uncurried versions, allowing flexible usage patterns. The function handles merging of input types and combining of output types using a provided transformation function.

LANGUAGE: TypeScript
CODE:
declare const zipWith: {
  <B, E2, R2, A, C>(
    that: Layer<B, E2, R2>,
    f: (a: Context.Context<A>, b: Context.Context<B>) => Context.Context<C>
  ): <E, R>(self: Layer<A, E, R>) => Layer<C, E2 | E, R2 | R>;
  <A, E, R, B, E2, R2, C>(
    self: Layer<A, E, R>,
    that: Layer<B, E2, R2>,
    f: (a: Context.Context<A>, b: Context.Context<B>) => Context.Context<C>
  ): Layer<C, E | E2, R | R2>;
}

----------------------------------------

TITLE: Adding Elements to TSet in TypeScript
DESCRIPTION: Defines a function for adding new elements to a transactional set (TSet). The function supports both curried and non-curried versions, operating within the STM (Software Transactional Memory) context.

LANGUAGE: typescript
CODE:
declare const add: { <A>(value: A): (self: TSet<A>) => STM.STM<void>; <A>(self: TSet<A>, value: A): STM.STM<void>; }

----------------------------------------

TITLE: Creating a Sink from Push Function in TypeScript
DESCRIPTION: The fromPush function creates a sink from a chunk processing function. It takes an Effect that produces a function to process Option<Chunk<In>> and returns an Effect of void with Either and Chunk results.

LANGUAGE: typescript
CODE:
declare const fromPush: <In, L0, R0, L, R>(push: Effect.Effect<(_: Option.Option<Chunk.Chunk<In>>) => Effect.Effect<void, readonly [Either.Either<R0, L0>, Chunk.Chunk<L>], R>, never, R>) => Sink<R0, In, L, L0, Exclude<R, Scope.Scope>>

----------------------------------------

TITLE: Mapping Record Entries with TypeScript
DESCRIPTION: Demonstrates how to use mapEntries function to transform both keys and values of a ReadonlyRecord. The function takes a record and a mapping function that receives each value and key, returning a tuple of new key-value pairs.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { mapEntries } from "effect/Record"

assert.deepStrictEqual(mapEntries({ a: 3, b: 5 }, (a, key) => [key.toUpperCase(), a + 1]), { A: 4, B: 6 })

LANGUAGE: typescript
CODE:
declare const mapEntries: { <K extends string, A, K2 extends string, B>(f: (a: A, key: K) => readonly [K2, B]): (self: ReadonlyRecord<K, A>) => Record<K2, B>; <K extends string, A, K2 extends string, B>(self: ReadonlyRecord<K, A>, f: (a: A, key: K) => [K2, B]): Record<K2, B>; }

----------------------------------------

TITLE: Defining TSet.transform Function in TypeScript
DESCRIPTION: Declares the transform function for TSet, which takes a pure function and a TSet, and returns an STM (Software Transactional Memory) operation that updates all elements in the set. The function is overloaded to allow for curried and non-curried usage.

LANGUAGE: typescript
CODE:
declare const transform: { <A>(f: (a: A) => A): (self: TSet<A>) => STM.STM<void>; <A>(self: TSet<A>, f: (a: A) => A): STM.STM<void>; }

----------------------------------------

TITLE: Implementing zipWith Method for SemiApplicative TypeClass in TypeScript
DESCRIPTION: Defines a zipWith function that combines two values of type F using a provided combining function. The function is polymorphic over the type constructor F and handles various type parameters for error handling (E1, E2), output types (O1, O2), and input requirements (R1, R2).

LANGUAGE: typescript
CODE:
declare const zipWith: <F extends TypeLambda>(F: SemiApplicative<F>) => { 
  <R2, O2, E2, B, A, C>(that: Kind<F, R2, O2, E2, B>, f: (a: A, b: B) => C): 
    <R1, O1, E1>(self: Kind<F, R1, O1, E1, A>) => Kind<F, R1 & R2, O2 | O1, E2 | E1, C>; 
  <R1, O1, E1, A, R2, O2, E2, B, C>(self: Kind<F, R1, O1, E1, A>, that: Kind<F, R2, O2, E2, B>, f: (a: A, b: B) => C): 
    Kind<F, R1 & R2, O1 | O2, E1 | E2, C>; 
}

----------------------------------------

TITLE: Accessing Channel Context - TypeScript Type Definition
DESCRIPTION: Type definition for the context function that accesses the whole context of a channel. Returns a Channel type that provides access to the environment context.

LANGUAGE: typescript
CODE:
declare const context: <Env>() => Channel<never, unknown, never, unknown, Context.Context<Env>, unknown, Env>

----------------------------------------

TITLE: Implementing Chainable.tap in TypeScript
DESCRIPTION: Defines a tap function that allows effectful observation of a success value without modifying it. The function takes a Chainable instance and returns a higher-order function that can be used to peek at values in the effect chain while preserving the original value.

LANGUAGE: typescript
CODE:
declare const tap: <F extends TypeLambda>(F: Chainable<F>) => { <A, R2, O2, E2, _>(f: (a: A) => Kind<F, R2, O2, E2, _>): <R1, O1, E1>(self: Kind<F, R1, O1, E1, A>) => Kind<F, R1 & R2, O2 | O1, E2 | E1, A>; <R1, O1, E1, A, R2, O2, E2, _>(self: Kind<F, R1, O1, E1, A>, f: (a: A) => Kind<F, R2, O2, E2, _>): Kind<F, R1 & R2, O1 | O2, E1 | E2, A>; }

----------------------------------------

TITLE: Using Array.drop in TypeScript with Effect Library
DESCRIPTION: Demonstrates how to use Array.drop to remove a specified number of elements from the beginning of an array. The function takes an Iterable and a number parameter, normalizing the number to a non-negative integer, and returns a new Array with the remaining elements.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const result = Array.drop([1, 2, 3, 4, 5], 2)
console.log(result) // [3, 4, 5]

LANGUAGE: typescript
CODE:
declare const drop: { (n: number): <A>(self: Iterable<A>) => Array<A>; <A>(self: Iterable<A>, n: number): Array<A>; }

----------------------------------------

TITLE: Implementing STM-based Search in TMap - TypeScript
DESCRIPTION: Function signature for findSTM that searches a TMap for key/value pairs matching a predicate and applies an STM-based transformation. The function returns an optional result wrapped in an STM effect.

LANGUAGE: typescript
CODE:
declare const findSTM: { 
  <K, V, A, E, R>(f: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>): 
    (self: TMap<K, V>) => STM.STM<Option.Option<A>, E, R>; 
  <K, V, A, E, R>(self: TMap<K, V>, f: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>): 
    STM.STM<Option.Option<A>, E, R>; 
}

----------------------------------------

TITLE: Implementing removeIf Operation for TSet in TypeScript
DESCRIPTION: Defines the removeIf function for TSet, which removes entries satisfying a predicate. It can either return the removed entries or void, based on the discard option. The function is overloaded to handle different parameter combinations and return types.

LANGUAGE: typescript
CODE:
declare const removeIf: { <A>(predicate: Predicate<A>, options: { readonly discard: true; }): (self: TSet<A>) => STM.STM<void>; <A>(predicate: Predicate<A>, options?: { readonly discard: false; }): (self: TSet<A>) => STM.STM<Array<A>>; <A>(self: TSet<A>, predicate: Predicate<A>, options: { readonly discard: true; }): STM.STM<void>; <A>(self: TSet<A>, predicate: Predicate<A>, options?: { readonly discard: false; }): STM.STM<Array<A>>; }

----------------------------------------

TITLE: Using takeRight Function Example in TypeScript
DESCRIPTION: Demonstrates how to use the takeRight function to extract characters from the end of a string. The function takes two parameters: the input string and the number of characters to keep from the end.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { String } from "effect"

assert.deepStrictEqual(String.takeRight("Hello World", 5), "World")

----------------------------------------

TITLE: Lifting Option to STM in TypeScript
DESCRIPTION: The fromOption function converts an Option<A> to an STM<A, Option<never>>. It allows working with optional values in the context of Software Transactional Memory (STM) operations.

LANGUAGE: typescript
CODE:
declare const fromOption: <A>(option: Option.Option<A>) => STM<A, Option.Option<never>>

----------------------------------------

TITLE: Defining decodeText Function for Stream Decoding in TypeScript
DESCRIPTION: Declares the decodeText function which takes an optional encoding parameter and returns a function that transforms a Stream of Uint8Array into a Stream of strings. It can be used in two ways: as a curried function or with the stream as the first argument.

LANGUAGE: typescript
CODE:
declare const decodeText: { (encoding?: string | undefined): <E, R>(self: Stream<Uint8Array, E, R>) => Stream<string, E, R>; <E, R>(self: Stream<Uint8Array, E, R>, encoding?: string | undefined): Stream<string, E, R>; }

----------------------------------------

TITLE: Stream.fromIterableEffect Type Signature
DESCRIPTION: Type declaration for the fromIterableEffect function, showing its generic parameters and return type.

LANGUAGE: typescript
CODE:
declare const fromIterableEffect: <A, E, R>(effect: Effect.Effect<Iterable<A>, E, R>) => Stream<A, E, R>

----------------------------------------

TITLE: Implementing Channel.fail in TypeScript
DESCRIPTION: A function that constructs a channel which fails immediately with a provided error value. The channel type signature indicates it accepts any error type E and returns a Channel that never emits values and fails with the specified error.

LANGUAGE: typescript
CODE:
declare const fail: <E>(error: E) => Channel<never, unknown, E, unknown, never, unknown>

----------------------------------------

TITLE: Stream.groupBy Function Signature in TypeScript
DESCRIPTION: The type signature of the Stream.groupBy function in the Effect library. It shows the function's polymorphic nature and its ability to work with different types of streams and effects.

LANGUAGE: typescript
CODE:
declare const groupBy: { <A, K, V, E2, R2>(f: (a: A) => Effect.Effect<readonly [K, V], E2, R2>, options?: { readonly bufferSize?: number | undefined; } | undefined): <E, R>(self: Stream<A, E, R>) => GroupBy.GroupBy<K, V, E2 | E, R2 | R>; <A, E, R, K, V, E2, R2>(self: Stream<A, E, R>, f: (a: A) => Effect.Effect<readonly [K, V], E2, R2>, options?: { readonly bufferSize?: number | undefined; } | undefined): GroupBy.GroupBy<K, V, E | E2, R | R2>; }

----------------------------------------

TITLE: Declaring formatUtc Function for DateTime Formatting in TypeScript
DESCRIPTION: Defines the formatUtc function which formats a DateTime object as a string using the DateTimeFormat API. It forces the time zone to be UTC. The function can be called with optional formatting options and locale settings.

LANGUAGE: typescript
CODE:
declare const formatUtc: { (options?: (Intl.DateTimeFormatOptions & { readonly locale?: string | undefined; }) | undefined): (self: DateTime) => string; (self: DateTime, options?: (Intl.DateTimeFormatOptions & { readonly locale?: string | undefined; }) | undefined): string; }

----------------------------------------

TITLE: Converting Checked Errors to Unchecked in Effect Layer
DESCRIPTION: A function that transforms a Layer with potential error type E into one where failures result in fiber termination. This removes the error type from the Layer's type signature by making all errors unchecked.

LANGUAGE: typescript
CODE:
declare const orDie: <A, E, R>(self: Layer<A, E, R>) => Layer<A, never, R>

----------------------------------------

TITLE: Effect.runPromiseExit Function Signature in TypeScript
DESCRIPTION: Type declaration for the runPromiseExit function showing its parameters and return type. Takes an Effect instance and optional AbortSignal, returns a Promise of Exit type.

LANGUAGE: typescript
CODE:
declare const runPromiseExit: <A, E>(effect: Effect<A, E, never>, options?: { readonly signal?: AbortSignal; } | undefined) => Promise<Exit.Exit<A, E>>

----------------------------------------

TITLE: Using isTupleOfAtLeast Predicate in TypeScript
DESCRIPTION: Demonstrates how to use the isTupleOfAtLeast function to check if an array has at least N elements and leverage TypeScript type narrowing. The function returns true if the array length is at least N and narrows the type to TupleOfAtLeast<N, T>.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { isTupleOfAtLeast } from "effect/Predicate"

assert.deepStrictEqual(isTupleOfAtLeast([1, 2, 3], 3), true);
assert.deepStrictEqual(isTupleOfAtLeast([1, 2, 3], 2), true);
assert.deepStrictEqual(isTupleOfAtLeast([1, 2, 3], 4), false);

const arr: number[] = [1, 2, 3, 4];
if (isTupleOfAtLeast(arr, 3)) {
  console.log(arr);
  // ^? [number, number, number, ...number[]]
}

LANGUAGE: typescript
CODE:
declare const isTupleOfAtLeast: { <N extends number>(n: N): <T>(self: ReadonlyArray<T>) => self is TupleOfAtLeast<N, T>; <T, N extends number>(self: ReadonlyArray<T>, n: N): self is TupleOfAtLeast<N, T>; }

----------------------------------------

TITLE: Implementing Configuration Provider Access in TypeScript using Effect
DESCRIPTION: A function that allows working with the default configuration provider by accepting a function that receives the provider and returns an Effect. The function enables computations and configuration value retrieval within the Effect context.

LANGUAGE: typescript
CODE:
declare const configProviderWith: <A, E, R>(f: (provider: ConfigProvider) => Effect<A, E, R>) => Effect<A, E, R>

----------------------------------------

TITLE: Creating Unbounded TPubSub in TypeScript
DESCRIPTION: Function signature for creating an unbounded TPubSub instance. The function takes no parameters and returns an STM (Software Transactional Memory) effect that produces a TPubSub of type A.

LANGUAGE: typescript
CODE:
declare const unbounded: <A>() => STM.STM<TPubSub<A>>

----------------------------------------

TITLE: Stream.race Function Signature in TypeScript
DESCRIPTION: Provides the type signature for the Stream.race function, which takes two streams and returns a new stream that races them.

LANGUAGE: typescript
CODE:
declare const race: { <AR, ER, RR>(right: Stream<AR, ER, RR>): <AL, EL, RL>(left: Stream<AL, EL, RL>) => Stream<AL | AR, EL | ER, RL | RR>; <AL, EL, RL, AR, ER, RR>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>): Stream<AL | AR, EL | ER, RL | RR>; }

----------------------------------------

TITLE: Testing Schema Type in TypeScript
DESCRIPTION: Type guard function that tests if a given unknown value is a Schema instance. Part of the Effect library's Schema module validation utilities.

LANGUAGE: typescript
CODE:
declare const isSchema: (u: unknown) => u is Schema.Any

----------------------------------------

TITLE: Converting STM Failure Channel to Either in TypeScript
DESCRIPTION: Converts the failure channel of an STM transaction into an Either type, transforming the error channel E into Either<A, E>. This allows for more flexible error handling by converting potential failures into a type-safe Either representation.

LANGUAGE: typescript
CODE:
declare const either: <A, E, R>(self: STM<A, E, R>) => STM<Either.Either<A, E>, never, R>

----------------------------------------

TITLE: Defining streamLines Function in TypeScript for @effect/platform Command Module
DESCRIPTION: Declares the streamLines function that runs a command and returns the output as a stream of lines. It takes a Command object and an optional encoding parameter, returning a Stream of strings with potential PlatformError, using a CommandExecutor.

LANGUAGE: typescript
CODE:
declare const streamLines: (command: Command, encoding?: string) => Stream<string, PlatformError, CommandExecutor>

----------------------------------------

TITLE: Creating KeyValueStorage from Storage API in TypeScript
DESCRIPTION: The layerStorage function creates a KeyValueStorage from an instance of the Storage API. It takes a LazyArg<Storage> as input and returns a Layer.Layer<KeyValueStore>. This function is useful for integrating web storage capabilities into the Effect ecosystem.

LANGUAGE: typescript
CODE:
declare const layerStorage: (evaluate: LazyArg<Storage>) => Layer.Layer<KeyValueStore>

----------------------------------------

TITLE: Function Signature for constant in TypeScript
DESCRIPTION: Provides the TypeScript type signature for the constant function. It takes a value of type A and returns a lazy argument (function) that always returns that value.

LANGUAGE: typescript
CODE:
declare const constant: <A>(value: A) => LazyArg<A>

----------------------------------------

TITLE: Defining reduceSTM Function for Atomic Folding in TMap (TypeScript)
DESCRIPTION: Declares the reduceSTM function, which atomically folds over a TMap using a transactional function. It supports two overloads: one that takes the TMap as the first argument, and another that returns a function to be applied to a TMap.

LANGUAGE: typescript
CODE:
declare const reduceSTM: { <Z, V, K, R, E>(zero: Z, f: (acc: Z, value: V, key: K) => STM.STM<Z, E, R>): (self: TMap<K, V>) => STM.STM<Z, E, R>; <Z, V, K, R, E>(self: TMap<K, V>, zero: Z, f: (acc: Z, value: V, key: K) => STM.STM<Z, E, R>): STM.STM<Z, E, R>; }

----------------------------------------

TITLE: Removing a Fiber from FiberMap in TypeScript
DESCRIPTION: The remove function is used to remove a fiber from the FiberMap and interrupt it if it exists. It can be called with either the key first or the FiberMap first, providing flexibility in usage.

LANGUAGE: typescript
CODE:
declare const remove: { <K>(key: K): <A, E>(self: FiberMap<K, A, E>) => Effect.Effect<void>; <K, A, E>(self: FiberMap<K, A, E>, key: K): Effect.Effect<void>; }

----------------------------------------

TITLE: Defining FiberRefs Interface in TypeScript
DESCRIPTION: This code snippet defines the FiberRefs interface, which extends Pipeable and includes a symbol property and a map of FiberRef values. It's used to represent a collection of FiberRef values for safe propagation across fiber boundaries.

LANGUAGE: typescript
CODE:
export interface FiberRefs extends Pipeable {
  readonly [FiberRefsSym]: FiberRefsSym
  readonly locals: Map<FiberRef.FiberRef<any>, Arr.NonEmptyReadonlyArray<readonly [FiberId.Single, any]>>
}

----------------------------------------

TITLE: Converting Option<Effect> to Effect<Option> in TypeScript
DESCRIPTION: Demonstrates how to use Effect.transposeOption to convert an Option<Effect<number, never, never>> into an Effect<Option<number>, never, never>. The example shows creating an Option containing an Effect, then using transposeOption to transform it, and finally running the resulting Effect.

LANGUAGE: typescript
CODE:
import { Effect, Option } from "effect"

//      ┌─── Option<Effect<number, never, never>>
//      ▼
const maybe = Option.some(Effect.succeed(42))

//      ┌─── Effect<Option<number>, never, never>
//      ▼
const result = Effect.transposeOption(maybe)

console.log(Effect.runSync(result))
// Output: { _id: 'Option', _tag: 'Some', value: 42 }

----------------------------------------

TITLE: Using validateFirst with Effect in TypeScript
DESCRIPTION: Demonstrates how to use validateFirst to process an array of numbers, returning the first number greater than or equal to 4 while logging successful matches. The function stops processing after finding the first valid result.

LANGUAGE: typescript
CODE:
import { Effect, Console } from "effect"

//      ┌─── Effect<number, string[], never>
//      ▼
const program = Effect.validateFirst([1, 2, 3, 4, 5], (n) => {
  if (n < 4) {
    return Effect.fail(`${n} is not less that 4`)
  } else {
    return Console.log(`item ${n}`).pipe(Effect.as(n))
  }
})

Effect.runPromise(program).then(console.log, console.error)
// Output:
// item 4
// 4

----------------------------------------

TITLE: Match.type Function Signature in TypeScript
DESCRIPTION: TypeScript type signature for the Match.type function showing its generic type parameters and return type for creating matchers.

LANGUAGE: typescript
CODE:
declare const type: <I>() => Matcher<I, Types.Without<never>, I, never, never>

----------------------------------------

TITLE: Creating Single-Valued Pure Stream in TypeScript
DESCRIPTION: The sync function creates a single-valued pure stream. It takes a lazy argument of type A and returns a Stream of type A. This function is available since version 2.0.0 of the package.

LANGUAGE: typescript
CODE:
declare const sync: <A>(evaluate: LazyArg<A>) => Stream<A>

----------------------------------------

TITLE: Implementing STM.orDie Function in TypeScript
DESCRIPTION: Function signature for orDie that transforms an STM effect with possible failure type E into one where failures are unchecked. It takes an STM effect and returns a new STM effect where the error channel is set to 'never', indicating that failures are not type-checked.

LANGUAGE: typescript
CODE:
declare const orDie: <A, E, R>(self: STM<A, E, R>) => STM<A, never, R>

----------------------------------------

TITLE: Using Option.orElse with Effect Library
DESCRIPTION: Examples demonstrating different use cases of Option.orElse method for handling fallback scenarios with Option values. Shows behavior with None and Some values.

LANGUAGE: typescript
CODE:
import { Option } from "effect"

console.log(Option.none().pipe(Option.orElse(() => Option.none())))
// Output: { _id: 'Option', _tag: 'None' }

console.log(Option.some("a").pipe(Option.orElse(() => Option.none())))
// Output: { _id: 'Option', _tag: 'Some', value: 'a' }

console.log(Option.none().pipe(Option.orElse(() => Option.some("b"))))
// Output: { _id: 'Option', _tag: 'Some', value: 'b' }

console.log(Option.some("a").pipe(Option.orElse(() => Option.some("b"))))
// Output: { _id: 'Option', _tag: 'Some', value: 'a' }

----------------------------------------

TITLE: Creating Stream from Queue in TypeScript using Effect
DESCRIPTION: Function signature for creating a stream from a queue with optional configuration for chunk size and shutdown behavior. Takes a Queue.Dequeue<A> and returns a Stream<A>. Supports maxChunkSize for controlling elements per chunk and shutdown flag for queue management.

LANGUAGE: typescript
CODE:
declare const fromQueue: <A>(queue: Queue.Dequeue<A>, options?: { readonly maxChunkSize?: number | undefined; readonly shutdown?: boolean | undefined; }) => Stream<A>

----------------------------------------

TITLE: Using isReadonlyRecord Guard in TypeScript
DESCRIPTION: Demonstrates how to use the isReadonlyRecord function to check if a value is a readonly record. It shows examples of both successful and failed checks.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { isReadonlyRecord } from "effect/Predicate"

assert.deepStrictEqual(isReadonlyRecord({}), true)
assert.deepStrictEqual(isReadonlyRecord({ a: 1 }), true)

assert.deepStrictEqual(isReadonlyRecord([]), false)
assert.deepStrictEqual(isReadonlyRecord([1, 2, 3]), false)
assert.deepStrictEqual(isReadonlyRecord(null), false)
assert.deepStrictEqual(isReadonlyRecord(undefined), false)

----------------------------------------

TITLE: Collecting TMap Bindings into Chunk in TypeScript
DESCRIPTION: The toChunk function collects all key-value bindings from a TMap into a Chunk. It returns an STM effect that produces a Chunk of key-value pairs.

LANGUAGE: typescript
CODE:
declare const toChunk: <K, V>(self: TMap<K, V>) => STM.STM<Chunk.Chunk<[K, V]>>

----------------------------------------

TITLE: Implementing STM validateFirst Function in TypeScript
DESCRIPTION: Function declaration for validateFirst that processes elements through a validation function until finding first success or collecting all errors. Takes either a validation function followed by elements or elements followed by validation function.

LANGUAGE: typescript
CODE:
declare const validateFirst: { 
  <A, B, E, R>(f: (a: A) => STM<B, E, R>): (elements: Iterable<A>) => STM<B, Array<E>, R>; 
  <A, B, E, R>(elements: Iterable<A>, f: (a: A) => STM<B, E, R>): STM<B, Array<E>, R>; 
}

----------------------------------------

TITLE: Defining STM.succeed Function in TypeScript
DESCRIPTION: This snippet defines the signature of the STM.succeed function. It takes a value of type A and returns an STM effect that succeeds with that value.

LANGUAGE: typescript
CODE:
declare const succeed: <A>(value: A) => STM<A>

----------------------------------------

TITLE: Creating Empty Records with Record.empty in TypeScript
DESCRIPTION: The empty function creates a new, empty record. It uses generic types K and V to define the key and value types of the record respectively. The function returns a Record with keys of type ReadonlyRecord.NonLiteralKey<K> and values of type V.

LANGUAGE: typescript
CODE:
declare const empty: <K extends string | symbol = never, V = never>() => Record<ReadonlyRecord.NonLiteralKey<K>, V>

----------------------------------------

TITLE: Defining runDrain Function in TypeScript for Effect Channel Module
DESCRIPTION: Declares the runDrain function which runs a channel until the end is received. It takes a Channel as input and returns an Effect. The function is generic, allowing for various types of elements, errors, and environments.

LANGUAGE: typescript
CODE:
declare const runDrain: <OutElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, unknown, OutErr, InErr, OutDone, InDone, Env>) => Effect.Effect<OutDone, OutErr, Env>

----------------------------------------

TITLE: Declaring KeyedPool.makeWith Function in TypeScript
DESCRIPTION: Defines the makeWith function for creating a new KeyedPool. It takes options including an acquire function and a size function, both of which depend on a key. The function returns an Effect that produces a KeyedPool.

LANGUAGE: typescript
CODE:
declare const makeWith: <K, A, E, R>(options: { readonly acquire: (key: K) => Effect.Effect<A, E, R>; readonly size: (key: K) => number; }) => Effect.Effect<KeyedPool<K, A, E>, never, Scope.Scope | R>

----------------------------------------

TITLE: Implementing Atomic Reduction for TMap in TypeScript
DESCRIPTION: Defines a reduce function that atomically folds over TMap entries using a pure function. The function supports both curried and direct calling styles, taking an initial value and a reducer function that processes each key-value pair.

LANGUAGE: typescript
CODE:
declare const reduce: {
  <Z, K, V>(zero: Z, f: (acc: Z, value: V, key: K) => Z): (self: TMap<K, V>) => STM.STM<Z>;
  <K, V, Z>(self: TMap<K, V>, zero: Z, f: (acc: Z, value: V, key: K) => Z): STM.STM<Z>;
}

----------------------------------------

TITLE: Implementing Dynamic Queue Broadcasting in TypeScript Stream
DESCRIPTION: Defines a function that converts a stream into multiple dynamic queues with configurable lag and buffer settings. Each chunk is replicated to all queues, with back pressure applied based on the slowest queue's maximum lag capacity. Queues can be unsubscribed by shutting down.

LANGUAGE: typescript
CODE:
declare const broadcastedQueuesDynamic: { 
  (maximumLag: number | { readonly capacity: "unbounded"; readonly replay?: number | undefined; } | { readonly capacity: number; readonly strategy?: "sliding" | "dropping" | "suspend" | undefined; readonly replay?: number | undefined; }): <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<Effect.Effect<Queue.Dequeue<Take.Take<A, E>>, never, Scope.Scope>, never, Scope.Scope | R>; 
  <A, E, R>(self: Stream<A, E, R>, maximumLag: number | { readonly capacity: "unbounded"; readonly replay?: number | undefined; } | { readonly capacity: number; readonly strategy?: "sliding" | "dropping" | "suspend" | undefined; readonly replay?: number | undefined; }): Effect.Effect<Effect.Effect<Queue.Dequeue<Take.Take<A, E>>, never, Scope.Scope>, never, Scope.Scope | R>; 
}

----------------------------------------

TITLE: Declaring Queue.shutdown Function in TypeScript
DESCRIPTION: Defines the shutdown function for Queue objects. It interrupts any fibers suspended on offer or take operations and prevents future calls to these methods.

LANGUAGE: typescript
CODE:
declare const shutdown: <A>(self: Dequeue<A> | Enqueue<A>) => Effect.Effect<void>

----------------------------------------

TITLE: Replacing Array Elements with Array.replace in TypeScript
DESCRIPTION: Demonstrates how to replace an element at a specific index in an array using the Array.replace function from the Effect library. Returns a new array with the replaced element, maintaining immutability of the original array.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const result = Array.replace(['a', 'b', 'c', 'd'], 1, 'z')
console.log(result) // ['a', 'z', 'c', 'd']

LANGUAGE: typescript
CODE:
declare const replace: { <B>(i: number, b: B): <A, S extends Iterable<A> = Iterable<A>>(self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>; <A, B, S extends Iterable<A> = Iterable<A>>(self: S, i: number, b: B): ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>; }

----------------------------------------

TITLE: Declaring setTime Function in TestClock Module (TypeScript)
DESCRIPTION: Declares the setTime function which sets the clock time of a TestClock instance to a specified Instant or Date. It runs any scheduled actions up to the new time in order. The function takes a DateTime.DateTime.Input as a parameter and returns an Effect.Effect<void>.

LANGUAGE: typescript
CODE:
declare const setTime: (input: DateTime.DateTime.Input) => Effect.Effect<void>

----------------------------------------

TITLE: Flattening Nested Arrays using Effect Array Module
DESCRIPTION: Demonstrates how to use Array.flatten to combine multiple nested arrays into a single flat array. The function takes an array of arrays as input and returns a new array with all elements concatenated sequentially.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const result = Array.flatten([[1, 2], [], [3, 4], [], [5, 6]])
console.log(result) // [1, 2, 3, 4, 5, 6]

LANGUAGE: typescript
CODE:
declare const flatten: <S extends ReadonlyArray<ReadonlyArray<any>>>(self: S) => ReadonlyArray.Flatten<S>

----------------------------------------

TITLE: Implementing Dynamic Service Provider in TypeScript Effect Module
DESCRIPTION: Function signature for provideServiceEffect that enables dynamic service implementation through effects. Supports both curried and uncurried variants for providing service implementations that require asynchronous or resource-intensive initialization.

LANGUAGE: typescript
CODE:
declare const provideServiceEffect: { <I, S, E1, R1>(tag: Context.Tag<I, S>, effect: Effect<NoInfer<S>, E1, R1>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E | E1, R1 | Exclude<R, I>>; <A, E, R, I, S, E1, R1>(self: Effect<A, E, R>, tag: Context.Tag<I, S>, effect: Effect<NoInfer<S>, E1, R1>): Effect<A, E | E1, R1 | Exclude<R, I>>; }

----------------------------------------

TITLE: Effect.exists Function Signature in TypeScript
DESCRIPTION: Type declaration for the Effect.exists function showing its polymorphic nature and support for various options including concurrency and batching configurations.

LANGUAGE: typescript
CODE:
declare const exists: { <A, E, R>(predicate: (a: A, i: number) => Effect<boolean, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): (elements: Iterable<A>) => Effect<boolean, E, R>; <A, E, R>(elements: Iterable<A>, predicate: (a: A, i: number) => Effect<boolean, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): Effect<boolean, E, R>; }

----------------------------------------

TITLE: Getting HashMap Size in TypeScript
DESCRIPTION: A type definition for the size function that returns the number of entries in a HashMap. Takes a generic HashMap<K, V> as input and returns a number.

LANGUAGE: typescript
CODE:
declare const size: <K, V>(self: HashMap<K, V>) => number

----------------------------------------

TITLE: Asynchronous Operation Resulting in Die with Effect.runSyncExit in TypeScript
DESCRIPTION: Shows how Effect.runSyncExit handles asynchronous operations, resulting in a Failure with a Die cause, indicating that it cannot resolve the effect synchronously.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

console.log(Effect.runSyncExit(Effect.promise(() => Promise.resolve(1))))
// Output:
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: {
//     _id: 'Cause',
//     _tag: 'Die',
//     defect: [Fiber #0 cannot be resolved synchronously. This is caused by using runSync on an effect that performs async work] {
//       fiber: [FiberRuntime],
//       _tag: 'AsyncFiberException',
//       name: 'AsyncFiberException'
//     }
//   }
// }

----------------------------------------

TITLE: Implementing Conditional Recurrence with Effect-TS Schedule
DESCRIPTION: Defines a schedule that continues executing until an effectful predicate returns true. The function takes a predicate that returns an Effect of boolean and creates a Schedule that recurs until the predicate evaluates to true. Useful for scenarios requiring asynchronous or external state-dependent stopping conditions.

LANGUAGE: typescript
CODE:
declare const recurUntilEffect: <A, R>(f: (a: A) => Effect.Effect<boolean, never, R>) => Schedule<A, A, R>

----------------------------------------

TITLE: Effect.forEach Function Signature in TypeScript
DESCRIPTION: This code snippet shows the TypeScript signature for the Effect.forEach function, including its overloads and type parameters.

LANGUAGE: typescript
CODE:
declare const forEach: { <B, E, R, S extends Iterable<any>>(f: (a: RA.ReadonlyArray.Infer<S>, i: number) => Effect<B, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly discard?: false | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): (self: S) => Effect<RA.ReadonlyArray.With<S, B>, E, R>; <A, B, E, R>(f: (a: A, i: number) => Effect<B, E, R>, options: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly discard: true; readonly concurrentFinalizers?: boolean | undefined; }): (self: Iterable<A>) => Effect<void, E, R>; <B, E, R, S extends Iterable<any>>(self: S, f: (a: RA.ReadonlyArray.Infer<S>, i: number) => Effect<B, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly discard?: false | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): Effect<RA.ReadonlyArray.With<S, B>, E, R>; <A, B, E, R>(self: Iterable<A>, f: (a: A, i: number) => Effect<B, E, R>, options: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly discard: true; readonly concurrentFinalizers?: boolean | undefined; }): Effect<void, E, R>; }

----------------------------------------

TITLE: Effect.every Function Type Definition
DESCRIPTION: TypeScript type signature for the Effect.every function showing its polymorphic nature and support for effectful predicates.

LANGUAGE: typescript
CODE:
declare const every: { <A, E, R>(predicate: (a: A, i: number) => Effect<boolean, E, R>): (elements: Iterable<A>) => Effect<boolean, E, R>; <A, E, R>(elements: Iterable<A>, predicate: (a: A, i: number) => Effect<boolean, E, R>): Effect<boolean, E, R>; }

----------------------------------------

TITLE: Declaring Channel.as Method Type Signature in TypeScript
DESCRIPTION: Type declaration for the 'as' method that transforms a Channel by setting its terminal value. The method supports both curried and uncurried forms, allowing specification of a new terminal value while preserving other channel characteristics.

LANGUAGE: typescript
CODE:
declare const as: {
  <OutDone2>(value: OutDone2): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>
    (self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) =>
    Channel<OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env>;
  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutDone2>
    (self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, value: OutDone2):
    Channel<OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env>;
}

----------------------------------------

TITLE: Implementing HTTP Request Retry in TypeScript with Effect
DESCRIPTION: Defines the retry function for HttpClient, allowing requests to be retried based on a provided schedule or policy. It supports both options-based and policy-based retry configurations.

LANGUAGE: typescript
CODE:
declare const retry: {
  <E, O extends NoExcessProperties<Effect.Retry.Options<E>, O>>(options: O): <R>(self: HttpClient.With<E, R>) => Retry.Return<R, E, O>;
  <B, E, R1>(policy: Schedule.Schedule<B, NoInfer<E>, R1>): <R>(self: HttpClient.With<E, R>) => HttpClient.With<E, R1 | R>;
  <E, R, O extends NoExcessProperties<Effect.Retry.Options<E>, O>>(self: HttpClient.With<E, R>, options: O): Retry.Return<R, E, O>;
  <E, R, B, R1>(self: HttpClient.With<E, R>, policy: Schedule.Schedule<B, E, R1>): HttpClient.With<E, R1 | R>;
}

----------------------------------------

TITLE: Defining diffFiberRefs Function in TypeScript
DESCRIPTION: This code snippet defines the `diffFiberRefs` function in the Effect module. It takes an Effect workflow and returns a new workflow that captures changes in FiberRef values along with the original result.

LANGUAGE: typescript
CODE:
declare const diffFiberRefs: <A, E, R>(self: Effect<A, E, R>) => Effect<[FiberRefsPatch.FiberRefsPatch, A], E, R>

----------------------------------------

TITLE: TypeScript Signature for filterOrLeft Function in Either Module
DESCRIPTION: Provides the TypeScript signature for the filterOrLeft function, showing its overloaded variants for different use cases with refinements and predicates.

LANGUAGE: typescript
CODE:
declare const filterOrLeft: { <R, B extends R, L2>(refinement: Refinement<NoInfer<R>, B>, orLeftWith: (right: NoInfer<R>) => L2): <L>(self: Either<R, L>) => Either<B, L2 | L>; <R, L2>(predicate: Predicate<NoInfer<R>>, orLeftWith: (right: NoInfer<R>) => L2): <L>(self: Either<R, L>) => Either<R, L2 | L>; <R, L, B extends R, L2>(self: Either<R, L>, refinement: Refinement<R, B>, orLeftWith: (right: R) => L2): Either<B, L | L2>; <R, L, E2>(self: Either<R, L>, predicate: Predicate<R>, orLeftWith: (right: R) => E2): Either<R, L | E2>; }

----------------------------------------

TITLE: Effect.filterOrFail Type Signature Definition
DESCRIPTION: The complete type signature for the filterOrFail function, showing its polymorphic nature and support for different combinations of predicates, refinements, and error handling.

LANGUAGE: typescript
CODE:
declare const filterOrFail: { <A, B extends A, E2>(refinement: Refinement<NoInfer<A>, B>, orFailWith: (a: NoInfer<A>) => E2): <E, R>(self: Effect<A, E, R>) => Effect<B, E2 | E, R>; <A, E2>(predicate: Predicate<NoInfer<A>>, orFailWith: (a: NoInfer<A>) => E2): <E, R>(self: Effect<A, E, R>) => Effect<A, E2 | E, R>; <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): <E, R>(self: Effect<A, E, R>) => Effect<B, Cause.NoSuchElementException | E, R>; <A>(predicate: Predicate<NoInfer<A>>): <E, R>(self: Effect<A, E, R>) => Effect<A, Cause.NoSuchElementException | E, R>; <A, E, R, B extends A, E2>(self: Effect<A, E, R>, refinement: Refinement<A, B>, orFailWith: (a: A) => E2): Effect<B, E | E2, R>; <A, E, R, E2>(self: Effect<A, E, R>, predicate: Predicate<A>, orFailWith: (a: A) => E2): Effect<A, E | E2, R>; <A, E, R, B extends A>(self: Effect<A, E, R>, refinement: Refinement<A, B>): Effect<B, E | Cause.NoSuchElementException, R>; <A, E, R>(self: Effect<A, E, R>, predicate: Predicate<A>): Effect<A, E | Cause.NoSuchElementException, R>; }

----------------------------------------

TITLE: Creating Channel from AsyncInputConsumer in TypeScript
DESCRIPTION: Function declaration that creates a Channel instance from an AsyncInputConsumer. The function is generic over error type Err, element type Elem, and completion type Done. It converts an AsyncInputConsumer into a Channel that can process elements and handle errors.

LANGUAGE: typescript
CODE:
declare const fromInput: <Err, Elem, Done>(input: SingleProducerAsyncInput.AsyncInputConsumer<Err, Elem, Done>) => Channel<Elem, unknown, Err, unknown, Done, unknown>

----------------------------------------

TITLE: Creating Date Arguments in Effect CLI - TypeScript
DESCRIPTION: Function signature for creating a date argument in the Effect CLI framework. The function accepts an optional configuration object and returns an Args instance that handles Date values. The default argument name is 'date' if not specified in the config.

LANGUAGE: typescript
CODE:
declare const date: (config?: Args.BaseArgsConfig) => Args<globalThis.Date>

----------------------------------------

TITLE: Converting Numbers to BigInt with Safety Checks in TypeScript
DESCRIPTION: Demonstrates the usage of BigInt.fromNumber function which converts a number to an Option of bigint. The function ensures safe conversion by checking if the input number is within JavaScript's safe integer range before conversion.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { BigInt as BI, Option } from "effect"

assert.deepStrictEqual(BI.fromNumber(42), Option.some(BigInt(42)))
assert.deepStrictEqual(BI.fromNumber(Number.MAX_SAFE_INTEGER + 1), Option.none())
assert.deepStrictEqual(BI.fromNumber(Number.MIN_SAFE_INTEGER - 1), Option.none())

LANGUAGE: typescript
CODE:
declare const fromNumber: (n: number) => Option.Option<bigint>

----------------------------------------

TITLE: Splitting Arrays using Effect's Array.split in TypeScript
DESCRIPTION: Demonstrates how to use the Array.split function to divide an array into a specified number of equally sized subarrays. The function takes an iterable and the number of splits as parameters, returning an array of arrays.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const result = Array.split([1, 2, 3, 4, 5, 6, 7, 8], 3)
console.log(result) // [[1, 2, 3], [4, 5, 6], [7, 8]]

LANGUAGE: typescript
CODE:
declare const split: { (n: number): <A>(self: Iterable<A>) => Array<Array<A>>; <A>(self: Iterable<A>, n: number): Array<Array<A>>; }

----------------------------------------

TITLE: Implementing STM.exists Function in TypeScript
DESCRIPTION: Defines a function that determines whether any element in an Iterable satisfies an effectual predicate. The function supports both curried and non-curried forms and returns an STM effect that resolves to a boolean.

LANGUAGE: typescript
CODE:
declare const exists: { 
  <A, R, E>(predicate: (a: NoInfer<A>) => STM<boolean, E, R>): (iterable: Iterable<A>) => STM<boolean, E, R>; 
  <A, R, E>(iterable: Iterable<A>, predicate: (a: A) => STM<boolean, E, R>): STM<boolean, E, R>; 
}

----------------------------------------

TITLE: Retrieving TestClock Service for Workflow Testing in TypeScript
DESCRIPTION: The testClockWith function retrieves the TestClock service for a test and uses it to run a specified workflow. It takes a function that accepts a TestClock and returns an Effect, and it returns an Effect with the same type parameters.

LANGUAGE: typescript
CODE:
declare const testClockWith: <A, E, R>(f: (testClock: TestClock) => Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>

----------------------------------------

TITLE: SemigroupMin Type Definition in TypeScript
DESCRIPTION: Provides the type definition for the SemigroupMin constant. It is defined as a Semigroup of numbers, implementing the combine operation to find the minimum value.

LANGUAGE: typescript
CODE:
declare const SemigroupMin: semigroup.Semigroup<number>

----------------------------------------

TITLE: Defining Dual-Style Functions with Call Signatures in TypeScript
DESCRIPTION: Shows how to use call signatures to define overloads for a dual-style function created with the dual function.

LANGUAGE: typescript
CODE:
import { dual, pipe } from "effect/Function"

const sum: {
  (that: number): (self: number) => number
  (self: number, that: number): number
} = dual(2, (self: number, that: number): number => self + that)

console.log(sum(2, 3)) // 5
console.log(pipe(2, sum(3))) // 5

----------------------------------------

TITLE: Retrieving Queue Size in Effect TypeScript
DESCRIPTION: Function that returns the current size of a queue. Works with both Dequeue and Enqueue types. The size can be negative if fibers are suspended waiting for elements to be added to the queue. Returns an Effect containing the queue size as a number.

LANGUAGE: typescript
CODE:
declare const size: <A>(self: Dequeue<A> | Enqueue<A>) => Effect.Effect<number>

----------------------------------------

TITLE: Defining Empty Arguments in Effect-TS CLI - TypeScript
DESCRIPTION: Defines a constant none that creates an empty argument with void type. This is used when no command line arguments need to be processed.

LANGUAGE: typescript
CODE:
declare const none: Args<void>

----------------------------------------

TITLE: Converting Values to Arrays using Array.ensure in TypeScript
DESCRIPTION: Demonstrates the Array.ensure utility function that creates a new Array from either a single value or an existing array. This function ensures consistent array output regardless of input type.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

console.log(Array.ensure("a")) // ["a"]
console.log(Array.ensure(["a"])) // ["a"]
console.log(Array.ensure(["a", "b", "c"])) // ["a", "b", "c"]

LANGUAGE: typescript
CODE:
declare const ensure: <A>(self: ReadonlyArray<A> | A) => Array<A>

----------------------------------------

TITLE: Defining findLastIndex Function for TArray in TypeScript
DESCRIPTION: Declares a function to find the last index of a specific value in a TArray. It returns an STM (Software Transactional Memory) operation that results in an Option of a number, representing the found index or None if not found.

LANGUAGE: typescript
CODE:
declare const findLastIndex: { <A>(value: A): (self: TArray<A>) => STM.STM<Option.Option<number>>; <A>(self: TArray<A>, value: A): STM.STM<Option.Option<number>>; }

----------------------------------------

TITLE: Implementing BigInt Greater Than or Equal Comparison in TypeScript
DESCRIPTION: Demonstrates how to use the greaterThanOrEqualTo function to compare BigInt values. The function can be used both in curried and non-curried forms to check if one BigInt is greater than or equal to another.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { greaterThanOrEqualTo } from "effect/BigInt"

assert.deepStrictEqual(greaterThanOrEqualTo(2n, 3n), false)
assert.deepStrictEqual(greaterThanOrEqualTo(3n, 3n), true)
assert.deepStrictEqual(greaterThanOrEqualTo(4n, 3n), true)

LANGUAGE: typescript
CODE:
declare const greaterThanOrEqualTo: { (that: bigint): (self: bigint) => boolean; (self: bigint, that: bigint): boolean; }

----------------------------------------

TITLE: Implementing String Semigroup for Concatenation in TypeScript
DESCRIPTION: Defines a Semigroup instance for the string type that enables string concatenation operations. This implementation follows the algebraic Semigroup laws and is part of the @effect/typeclass package.

LANGUAGE: typescript
CODE:
declare const Semigroup: semigroup.Semigroup<string>

----------------------------------------

TITLE: Using Either.getOrThrowWith in TypeScript
DESCRIPTION: Demonstrates how to extract a value from an Either type, throwing a custom error if the Either is Left. The function accepts both the Either value and an error generation function.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Either } from "effect"

assert.deepStrictEqual(
  Either.getOrThrowWith(Either.right(1), () => new Error('Unexpected Left')),
  1
)
assert.throws(() => Either.getOrThrowWith(Either.left("error"), () => new Error('Unexpected Left')))

LANGUAGE: typescript
CODE:
declare const getOrThrowWith: { <L>(onLeft: (left: L) => unknown): <A>(self: Either<A, L>) => A; <R, L>(self: Either<R, L>, onLeft: (left: L) => unknown): R; }

----------------------------------------

TITLE: Implementing collectFirstSTM Function for TArray in TypeScript
DESCRIPTION: Defines the collectFirstSTM function for TArray, which applies a transactional partial function to find the first matching value. It returns an STM (Software Transactional Memory) operation that yields an Option of the result.

LANGUAGE: typescript
CODE:
declare const collectFirstSTM: { <A, B, E, R>(pf: (a: A) => Option.Option<STM.STM<B, E, R>>): (self: TArray<A>) => STM.STM<Option.Option<B>, E, R>; <A, B, E, R>(self: TArray<A>, pf: (a: A) => Option.Option<STM.STM<B, E, R>>): STM.STM<Option.Option<B>, E, R>; }

----------------------------------------

TITLE: Defining stripSomeDefects Function in TypeScript
DESCRIPTION: Declares the stripSomeDefects function, which removes matching defects from a Cause using a partial function. It takes a function to extract defects and returns a new function that operates on a Cause, potentially returning a modified Cause or None.

LANGUAGE: typescript
CODE:
declare const stripSomeDefects: { (pf: (defect: unknown) => Option.Option<unknown>): <E>(self: Cause<E>) => Option.Option<Cause<E>>; <E>(self: Cause<E>, pf: (defect: unknown) => Option.Option<unknown>): Option.Option<Cause<E>>; }

----------------------------------------

TITLE: Type Signature of Effect.repeat in TypeScript
DESCRIPTION: This code block provides the type signature for the Effect.repeat function. It shows the various overloads and type parameters used in the function, demonstrating its flexibility in handling different types of effects and schedules.

LANGUAGE: typescript
CODE:
declare const repeat: { <O extends NoExcessProperties<Repeat.Options<A>, O>, A>(options: O): <E, R>(self: Effect<A, E, R>) => Repeat.Return<R, E, A, O>; <B, A, R1>(schedule: Schedule.Schedule<B, A, R1>): <E, R>(self: Effect<A, E, R>) => Effect<B, E, R1 | R>; <A, E, R, O extends NoExcessProperties<Repeat.Options<A>, O>>(self: Effect<A, E, R>, options: O): Repeat.Return<R, E, A, O>; <A, E, R, B, R1>(self: Effect<A, E, R>, schedule: Schedule.Schedule<B, A, R1>): Effect<B, E, R | R1>; }

----------------------------------------

TITLE: Defining HttpApiBuilder Middleware Types in TypeScript
DESCRIPTION: Type declaration for creating HttpApi middleware layers with support for different configurations including context handling and error types. The middleware can be created either as a standalone function or with a specific HttpApi instance.

LANGUAGE: typescript
CODE:
declare const middleware: {
  <EX = never, RX = never>(
    middleware: MiddlewareFn<never> | Effect.Effect<MiddlewareFn<never>, EX, RX>,
    options?: { readonly withContext?: false | undefined; }
  ): Layer.Layer<never, EX, Exclude<RX, Scope>>;

  <R, EX = never, RX = never>(
    middleware: MiddlewareFn<never, R> | Effect.Effect<MiddlewareFn<never, R>, EX, RX>,
    options: { readonly withContext: true; }
  ): Layer.Layer<never, EX, Exclude<HttpRouter.HttpRouter.ExcludeProvided<R> | RX, Scope>>;

  <ApiId extends string, Groups extends HttpApiGroup.HttpApiGroup.Any, Error, ErrorR, EX = never, RX = never>(
    api: HttpApi.HttpApi<ApiId, Groups, Error, ErrorR>,
    middleware: MiddlewareFn<NoInfer<Error>> | Effect.Effect<MiddlewareFn<NoInfer<Error>>, EX, RX>,
    options?: { readonly withContext?: false | undefined; }
  ): Layer.Layer<never, EX, Exclude<RX, Scope>>;

  <ApiId extends string, Groups extends HttpApiGroup.HttpApiGroup.Any, Error, ErrorR, R, EX = never, RX = never>(
    api: HttpApi.HttpApi<ApiId, Groups, Error, ErrorR>,
    middleware: MiddlewareFn<NoInfer<Error>, R> | Effect.Effect<MiddlewareFn<NoInfer<Error>, R>, EX, RX>,
    options: { readonly withContext: true; }
  ): Layer.Layer<never, EX, Exclude<HttpRouter.HttpRouter.ExcludeProvided<R> | RX, Scope>>;
}

----------------------------------------

TITLE: Failing Transactional Effect with STM.die in TypeScript
DESCRIPTION: The 'die' function is used to fail a transactional effect with a specified defect. It takes an unknown defect as an argument and returns an STM that never succeeds.

LANGUAGE: typescript
CODE:
declare const die: (defect: unknown) => STM<never>

----------------------------------------

TITLE: Creating Empty TPriorityQueue in TypeScript
DESCRIPTION: This function constructs a new empty TPriorityQueue with a specified Order. It returns an STM (Software Transactional Memory) effect that produces the empty queue.

LANGUAGE: typescript
CODE:
declare const empty: <A>(order: Order.Order<A>) => STM.STM<TPriorityQueue<A>>

----------------------------------------

TITLE: Implementing TMap.takeSomeSTM Function in TypeScript
DESCRIPTION: Function signature for takeSomeSTM that takes a predicate function and a TMap, returning matching values through STM operations. The function retries until at least one matching value is found. It supports both curried and uncurried forms.

LANGUAGE: typescript
CODE:
declare const takeSomeSTM: { <K, V, A, E, R>(pf: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>): (self: TMap<K, V>) => STM.STM<[A, ...Array<A>], E, R>; <K, V, A, E, R>(self: TMap<K, V>, pf: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>): STM.STM<[A, ...Array<A>], E, R>; }

----------------------------------------

TITLE: TypeScript Function Signature for Doc.indent
DESCRIPTION: This code snippet shows the TypeScript function signature for the `indent` function in the `Doc` module. It describes the function's type and overloads.

LANGUAGE: typescript
CODE:
declare const indent: { (indent: number): <A>(self: Doc<A>) => Doc<A>; <A>(self: Doc<A>, indent: number): Doc<A>; }

----------------------------------------

TITLE: Implementing Lazy Layer Construction in TypeScript
DESCRIPTION: The suspend function lazily constructs a layer. It takes an evaluation function as an argument and returns a Layer. This is useful for avoiding infinite recursion when creating layers that refer to themselves.

LANGUAGE: typescript
CODE:
declare const suspend: <RIn, E, ROut>(evaluate: LazyArg<Layer<ROut, E, RIn>>) => Layer<ROut, E, RIn>

----------------------------------------

TITLE: Stream.zipLatest Type Signature in TypeScript
DESCRIPTION: Type declaration for the zipLatest method showing its polymorphic nature and type constraints. The method can be called with either curried or uncurried parameter styles.

LANGUAGE: typescript
CODE:
declare const zipLatest: { <AR, ER, RR>(right: Stream<AR, ER, RR>): <AL, EL, RL>(left: Stream<AL, EL, RL>) => Stream<[AL, AR], EL | ER, RL | RR>; <AL, EL, RL, AR, ER, RR>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>): Stream<[AL, AR], EL | ER, RL | RR>; }

----------------------------------------

TITLE: Defining catchTag Function for Tagged Error Recovery in STM (TypeScript)
DESCRIPTION: Declares the `catchTag` function, which recovers from specified tagged errors in STM operations. It takes a tag key and a recovery function, and returns a new STM that either succeeds with the original result or the result of the recovery function.

LANGUAGE: typescript
CODE:
declare const catchTag: { <K extends E["_tag"] & string, E extends { _tag: string; }, A1, E1, R1>(k: K, f: (e: Extract<E, { _tag: K; }>) => STM<A1, E1, R1>): <A, R>(self: STM<A, E, R>) => STM<A1 | A, E1 | Exclude<E, { _tag: K; }>, R1 | R>; <A, E extends { _tag: string; }, R, K extends E["_tag"] & string, A1, E1, R1>(self: STM<A, E, R>, k: K, f: (e: Extract<E, { _tag: K; }>) => STM<A1, E1, R1>): STM<A | A1, E1 | Exclude<E, { _tag: K; }>, R | R1>; }

----------------------------------------

TITLE: Array.groupBy Function Signature in TypeScript
DESCRIPTION: Provides the TypeScript signature for the Array.groupBy function. It shows two overloads: one that takes the key-generating function first, and another that takes the iterable first. The function returns a Record with non-empty arrays as values.

LANGUAGE: typescript
CODE:
declare const groupBy: { <A, K extends string | symbol>(f: (a: A) => K): (self: Iterable<A>) => Record<Record.ReadonlyRecord.NonLiteralKey<K>, NonEmptyArray<A>>; <A, K extends string | symbol>(self: Iterable<A>, f: (a: A) => K): Record<Record.ReadonlyRecord.NonLiteralKey<K>, NonEmptyArray<A>>; }

----------------------------------------

TITLE: Creating Counter Metrics in TypeScript with Effect
DESCRIPTION: Demonstrates how to create number and bigint counter metrics using the Metric.counter function from the Effect package. It shows the usage of different options like description and bigint.

LANGUAGE: typescript
CODE:
import { Metric } from "effect"

const numberCounter = Metric.counter("count", {
  description: "A number counter"
});

const bigintCounter = Metric.counter("count", {
  description: "A bigint counter",
  bigint: true
});

----------------------------------------

TITLE: Random.make Function Signature in TypeScript
DESCRIPTION: The type signature for the Random.make function, which takes a seed of any type A and returns a Random instance.

LANGUAGE: typescript
CODE:
declare const make: <A>(seed: A) => Random

----------------------------------------

TITLE: Creating Entity Instances with Entity.make in TypeScript
DESCRIPTION: The Entity.make function creates a new Entity of a specified type that accepts messages adhering to provided schemas. It takes a type string and an array of RPC protocols as arguments.

LANGUAGE: typescript
CODE:
declare const make: <Rpcs extends ReadonlyArray<Rpc.Any>>(type: string, protocol: Rpcs) => Entity<Rpcs[number]>

----------------------------------------

TITLE: Getting First Entry from RedBlackTree in TypeScript
DESCRIPTION: Function that returns the first (minimum) key-value pair in a RedBlackTree if it exists. Returns an Option type containing a tuple of key and value.

LANGUAGE: typescript
CODE:
declare const first: <K, V>(self: RedBlackTree<K, V>) => Option<[K, V]>

----------------------------------------

TITLE: Effect.disconnect Function Signature
DESCRIPTION: TypeScript type signature for the Effect.disconnect function, showing it takes an Effect<A, E, R> and returns an Effect<A, E, R>.

LANGUAGE: typescript
CODE:
declare const disconnect: <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>

----------------------------------------

TITLE: Creating Exit Failure - TypeScript Effect Package
DESCRIPTION: Function signature for creating a new Exit.Failure instance from a recoverable error of type E. Used for handling error cases in the Effect system.

LANGUAGE: typescript
CODE:
declare const fail: <E>(error: E) => Exit<never, E>

----------------------------------------

TITLE: Implementing Chunk Intersection in TypeScript
DESCRIPTION: Defines an intersection operation that creates a new Chunk containing unique values that exist in all given Chunks. The function supports both curried and uncurried forms, preserving type information through generic parameters.

LANGUAGE: typescript
CODE:
declare const intersection: { <A>(that: Chunk<A>): <B>(self: Chunk<B>) => Chunk<A & B>; <A, B>(self: Chunk<A>, that: Chunk<B>): Chunk<A & B>; }

----------------------------------------

TITLE: Successful Tasks Race Example
DESCRIPTION: Complete example demonstrating racing two successful tasks with logging and interruption handling.

LANGUAGE: typescript
CODE:
import { Effect, Console } from "effect"

const task1 = Effect.succeed("task1").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Console.log("task1 done")),
  Effect.onInterrupt(() =>
    Console.log("task1 interrupted").pipe(Effect.delay("100 millis"))
  )
)
const task2 = Effect.succeed("task2").pipe(
  Effect.delay("200 millis"),
  Effect.tap(Console.log("task2 done")),
  Effect.onInterrupt(() =>
    Console.log("task2 interrupted").pipe(Effect.delay("100 millis"))
  )
)

const program = Effect.raceFirst(task1, task2).pipe(
  Effect.tap(Console.log("more work..."))
)

Effect.runPromiseExit(program).then(console.log)

----------------------------------------

TITLE: Creating Seeded Random Number Generator in TypeScript with Effect
DESCRIPTION: Demonstrates how to use Random.make to create two identical random number generators with the same seed. This ensures predictable sequences of random values for specific use cases like UI testing or date-based randomness.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Effect, Random } from "effect"

const random1 = Random.make("myseed")
const random2 = Random.make("myseed")

assert.equal(Effect.runSync(random1.next), Effect.runSync(random2.next))

----------------------------------------

TITLE: Implementing Boolean Type Refinement in TypeScript
DESCRIPTION: A type predicate implementation that refines unknown values to boolean type. This is part of the Effect package's Match module for type refinement operations.

LANGUAGE: typescript
CODE:
declare const boolean: Predicate.Refinement<unknown, boolean>

----------------------------------------

TITLE: Converting DateTime to End of Time Unit in TypeScript
DESCRIPTION: The endOf function converts a DateTime object to the end of a specified time unit (e.g., day, week, month). It accepts options for customizing week start day when the unit is 'week'. The function returns a new DateTime object representing the end of the specified unit.

LANGUAGE: typescript
CODE:
import { DateTime } from "effect"

// returns "2024-01-01T23:59:59.999Z"
DateTime.unsafeMake("2024-01-01T12:00:00Z").pipe(
  DateTime.endOf("day"),
  DateTime.formatIso
)

LANGUAGE: typescript
CODE:
declare const endOf: { (part: DateTime.UnitSingular, options?: { readonly weekStartsOn?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | undefined; }): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, part: DateTime.UnitSingular, options?: { readonly weekStartsOn?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | undefined; }): A; }

----------------------------------------

TITLE: Effect.mergeAll Function Signature in TypeScript
DESCRIPTION: Provides the type signature for the Effect.mergeAll function. It shows the function's overloads, including options for customizing concurrency, batching, and finalizer behavior.

LANGUAGE: typescript
CODE:
declare const mergeAll: { <Z, Eff extends Effect<any, any, any>>(zero: Z, f: (z: Z, a: Effect.Success<Eff>, i: number) => Z, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): (elements: Iterable<Eff>) => Effect<Z, Effect.Error<Eff>, Effect.Context<Eff>>; <Eff extends Effect<any, any, any>, Z>(elements: Iterable<Eff>, zero: Z, f: (z: Z, a: Effect.Success<Eff>, i: number) => Z, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): Effect<Z, Effect.Error<Eff>, Effect.Context<Eff>>; }

----------------------------------------

TITLE: Declaring TArray.make Function in TypeScript
DESCRIPTION: Declares the make function for creating a new TArray initialized with specified values. It takes a variable number of elements and returns an STM of TArray containing those elements.

LANGUAGE: typescript
CODE:
declare const make: <Elements extends [any, ...Array<any>]>(...elements: Elements) => STM.STM<TArray<Elements[number]>>

----------------------------------------

TITLE: Implementing Stream Aggregation with Scheduling in TypeScript
DESCRIPTION: The aggregateWithinEither function aggregates stream elements using a provided sink until it completes or until a scheduled delay passes. It divides the stream into two asynchronous islands, with upstream and downstream operators running on separate fibers. The function returns a new stream with aggregated values or schedule outputs.

LANGUAGE: typescript
CODE:
declare const aggregateWithinEither: { <B, A, A2, E2, R2, C, R3>(sink: Sink.Sink<B, A | A2, A2, E2, R2>, schedule: Schedule.Schedule<C, Option.Option<B>, R3>): <E, R>(self: Stream<A, E, R>) => Stream<Either.Either<B, C>, E2 | E, R2 | R3 | R>; <A, E, R, B, A2, E2, R2, C, R3>(self: Stream<A, E, R>, sink: Sink.Sink<B, A | A2, A2, E2, R2>, schedule: Schedule.Schedule<C, Option.Option<B>, R3>): Stream<Either.Either<B, C>, E | E2, R | R2 | R3>; }

----------------------------------------

TITLE: Implementing collectFirst Function in TArray Module - TypeScript
DESCRIPTION: Function declaration for collectFirst that takes a partial function and applies it to find the first matching value in a TArray. It supports both curried and non-curried versions, returning a transactional STM result containing an Option of the transformed value.

LANGUAGE: typescript
CODE:
declare const collectFirst: { <A, B>(pf: (a: A) => Option.Option<B>): (self: TArray<A>) => STM.STM<Option.Option<B>>; <A, B>(self: TArray<A>, pf: (a: A) => Option.Option<B>): STM.STM<Option.Option<B>>; }

----------------------------------------

TITLE: Demonstrating HashSet Mutation Operations in TypeScript
DESCRIPTION: Example showing how to use HashSet.beginMutation to create a mutable version of a HashSet for efficient multiple operations. Demonstrates the difference between mutable and immutable operations, including adding elements and checking membership.

LANGUAGE: typescript
CODE:
import { HashSet } from "effect"
import assert from "node:assert/strict"

const UPPER_BOUND = 10_000

const immutableSet = HashSet.empty<number>().pipe(HashSet.add(0))

// Create a mutable version of the immutableSet
const mutableSet = HashSet.beginMutation(immutableSet)

for (let i = 1; i < UPPER_BOUND; i++) {
  // Operations now modify the set in place instead of creating new instances
  // This is more efficient when making multiple changes
  const pointerToMutableSet = HashSet.add(mutableSet, i)

  // the two sets have the same identity, hence `add` is mutating mutableSet and not returning a new HashSet instance
  assert(Object.is(mutableSet, pointerToMutableSet))
  assert.equal(HashSet.has(mutableSet, i), true) // `i` is in the mutableSet
  assert.equal(HashSet.has(immutableSet, i), false) // `i` is not in the immutableSet
}

const next = UPPER_BOUND + 1
// When done, mark the set as immutable again
HashSet.endMutation(mutableSet).pipe(
  HashSet.add(next) // since this returns a new HashSet, it will not be logged as part of the mutableSet
)
assert.equal(HashSet.has(mutableSet, next), false)

console.log(HashSet.toValues(immutableSet)) // [0]
console.log(HashSet.toValues(mutableSet).sort((a, b) => a - b)) // [0, 1, 2, 3, ...rest]

LANGUAGE: typescript
CODE:
declare const beginMutation: <A>(self: HashSet<A>) => HashSet<A>

----------------------------------------

TITLE: Defining Monoid.min Function in TypeScript
DESCRIPTION: This function creates a monoid where the combine operation returns the minimum value based on a provided bounded order. The empty value is set to the maxBound value of the bounded order.

LANGUAGE: typescript
CODE:
declare const min: <A>(B: Bounded<A>) => Monoid<A>

----------------------------------------

TITLE: Using Array.matchRight in TypeScript
DESCRIPTION: Demonstrates the usage of Array.matchRight function which matches array elements from the right, providing different handlers for empty and non-empty arrays. The function takes an options object with onEmpty and onNonEmpty handlers.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const matchRight = Array.matchRight({
  onEmpty: () => "empty",
  onNonEmpty: (init, last) => `init: ${init.length}, last: ${last}`
})
console.log(matchRight([])) // "empty"
console.log(matchRight([1, 2, 3])) // "init: 2, last: 3"

LANGUAGE: typescript
CODE:
declare const matchRight: { <B, A, C = B>(options: { readonly onEmpty: LazyArg<B>; readonly onNonEmpty: (init: Array<A>, last: A) => C; }): (self: ReadonlyArray<A>) => B | C; <A, B, C = B>(self: ReadonlyArray<A>, options: { readonly onEmpty: LazyArg<B>; readonly onNonEmpty: (init: Array<A>, last: A) => C; }): B | C; }

----------------------------------------

TITLE: Piping Commands in Shell
DESCRIPTION: Demonstrates the conceptual equivalent of the pipeTo function in shell commands.

LANGUAGE: sh
CODE:
command1 | command2

----------------------------------------

TITLE: Comparing Numbers with lessThanOrEqualTo in TypeScript
DESCRIPTION: The lessThanOrEqualTo function returns a boolean indicating whether a number is less than or equal to another. It can be used both as a curried function and with two arguments.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { lessThanOrEqualTo } from "effect/Number"

assert.deepStrictEqual(lessThanOrEqualTo(2, 3), true)
assert.deepStrictEqual(lessThanOrEqualTo(3, 3), true)
assert.deepStrictEqual(lessThanOrEqualTo(4, 3), false)

LANGUAGE: typescript
CODE:
declare const lessThanOrEqualTo: { (that: number): (self: number) => boolean; (self: number, that: number): boolean; }

----------------------------------------

TITLE: Implementing Timed Execution for Sinks in TypeScript
DESCRIPTION: The withDuration function takes a Sink and returns a new Sink that executes the original one while measuring its execution time. It adds a Duration to the output tuple alongside the original result.

LANGUAGE: typescript
CODE:
declare const withDuration: <A, In, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<[A, Duration.Duration], In, L, E, R>

----------------------------------------

TITLE: Sorting Arrays with Multiple Criteria in TypeScript using Effect
DESCRIPTION: Demonstrates how to sort an array of objects using multiple ordering criteria with Effect's Array.sortBy function. The example shows sorting users first by age and then by name when ages are equal.

LANGUAGE: typescript
CODE:
import { Array, Order, pipe } from "effect"

const users = [
  { name: "Alice", age: 30 },
  { name: "Bob", age: 25 },
  { name: "Charlie", age: 30 }
]

const result = pipe(
  users,
  Array.sortBy(
    Order.mapInput(Order.number, (user: (typeof users)[number]) => user.age),
    Order.mapInput(Order.string, (user: (typeof users)[number]) => user.name)
  )
)

LANGUAGE: typescript
CODE:
declare const sortBy: <S extends Iterable<any>>(...orders: ReadonlyArray<Order.Order<ReadonlyArray.Infer<S>>>) => (self: S) => S extends NonEmptyReadonlyArray<infer A> ? NonEmptyArray<A> : S extends Iterable<infer A> ? Array<A> : never

----------------------------------------

TITLE: Using Effect.checkInterruptible in TypeScript
DESCRIPTION: Demonstrates how to use the Effect.checkInterruptible function to handle logic based on whether the current operation can be interrupted. It includes examples of both interruptible and uninterruptible executions.

LANGUAGE: typescript
CODE:
import { Console, Effect } from "effect"

const program = Effect.gen(function*() {
  yield* Effect.checkInterruptible((isInterruptible) => {
    if (isInterruptible) {
      return Console.log("You can interrupt this operation.")
    } else {
      return Console.log("This operation cannot be interrupted.")
    }
  })
})

Effect.runPromise(program)
// Output: You can interrupt this operation.

Effect.runPromise(program.pipe(Effect.uninterruptible))
// Output: This operation cannot be interrupted.

----------------------------------------

TITLE: Implementing Stream Pagination with TypeScript in Effect Library
DESCRIPTION: Function signature for paginateChunk that takes an initial state S and a function that produces chunks of values A along with an optional next state. Used for implementing paginated data streams where each iteration can emit values before terminating.

LANGUAGE: typescript
CODE:
declare const paginateChunk: <S, A>(s: S, f: (s: S) => readonly [Chunk.Chunk<A>, Option.Option<S>]) => Stream<A>

----------------------------------------

TITLE: Implementing Schedule Driver Creation in TypeScript
DESCRIPTION: Function signature for creating a schedule driver that enables manual control over schedule execution. The driver allows stepping through schedules while handling delays and sleeping appropriately, providing fine-grained control over schedule progression.

LANGUAGE: typescript
CODE:
declare const driver: <Out, In, R>(self: Schedule<Out, In, R>) => Effect.Effect<ScheduleDriver<Out, In, R>>

----------------------------------------

TITLE: Using Stream.takeWhile in TypeScript with Effect Library
DESCRIPTION: Demonstrates how to use Stream.takeWhile to take elements from a stream while a condition is true. The example creates a stream of numbers and takes elements while they are less than 5.

LANGUAGE: typescript
CODE:
import { Effect, Stream } from "effect"

const stream = Stream.takeWhile(Stream.iterate(0, (n) => n + 1), (n) => n < 5)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 0, 1, 2, 3, 4 ] }

----------------------------------------

TITLE: Defining findFirst Function in Typescript for Iterable Module
DESCRIPTION: Declares the findFirst function, which returns the first element satisfying a specified predicate or None if no such element exists. It supports various overloads for different use cases, including refinements and predicates.

LANGUAGE: typescript
CODE:
declare const findFirst: { <A, B>(f: (a: NoInfer<A>, i: number) => Option<B>): (self: Iterable<A>) => Option<B>; <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => Option<B>; <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Option<A>; <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option<B>): Option<B>; <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): Option<B>; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Option<A>; }

----------------------------------------

TITLE: Partitioning Records with Effect Library in TypeScript
DESCRIPTION: Demonstrates how to use Record.partition to split a record into two separate records based on a predicate function. The function returns an array containing two records: one with entries that fail the predicate and one with entries that satisfy it.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { partition } from "effect/Record"

assert.deepStrictEqual(
  partition({ a: 1, b: 3 }, (n) => n > 2),
  [{ a: 1 }, { b: 3 }]
)

LANGUAGE: typescript
CODE:
declare const partition: { <K extends string, A, B extends A>(refinement: (a: NoInfer<A>, key: K) => a is B): (self: ReadonlyRecord<K, A>) => [excluded: Record<ReadonlyRecord.NonLiteralKey<K>, Exclude<A, B>>, satisfying: Record<ReadonlyRecord.NonLiteralKey<K>, B>]; <K extends string, A>(predicate: (a: NoInfer<A>, key: K) => boolean): (self: ReadonlyRecord<K, A>) => [excluded: Record<ReadonlyRecord.NonLiteralKey<K>, A>, satisfying: Record<ReadonlyRecord.NonLiteralKey<K>, A>]; <K extends string, A, B extends A>(self: ReadonlyRecord<K, A>, refinement: (a: A, key: K) => a is B): [excluded: Record<ReadonlyRecord.NonLiteralKey<K>, Exclude<A, B>>, satisfying: Record<ReadonlyRecord.NonLiteralKey<K>, B>]; <K extends string, A>(self: ReadonlyRecord<K, A>, predicate: (a: A, key: K) => boolean): [excluded: Record<ReadonlyRecord.NonLiteralKey<K>, A>, satisfying: Record<ReadonlyRecord.NonLiteralKey<K>, A>]; }

----------------------------------------

TITLE: Using SemigroupMin in TypeScript
DESCRIPTION: Demonstrates how to use the SemigroupMin from the @effect/typeclass package to find the minimum of two numbers. The combine method of SemigroupMin returns the smaller of the two input numbers.

LANGUAGE: typescript
CODE:
import { SemigroupMin } from "@effect/typeclass/data/Number"

console.log(SemigroupMin.combine(2, 3))
// 2

----------------------------------------

TITLE: Implementing DocStream.alterAnnotations in TypeScript
DESCRIPTION: Function definition for alterAnnotations that transforms document annotations. It accepts a transformation function that converts annotations from type A to Option<B> and returns a new DocStream with modified annotations.

LANGUAGE: typescript
CODE:
declare const alterAnnotations: { 
  <A, B>(f: (a: A) => Option<B>): (self: DocStream<A>) => DocStream<B>; 
  <A, B>(self: DocStream<A>, f: (a: A) => Option<B>): DocStream<B>; 
}

----------------------------------------

TITLE: Defining Date Primitive in TypeScript for @effect/cli
DESCRIPTION: Declares a constant 'date' of type Primitive<Date>. This primitive represents a date in ISO-8601 format, such as '2007-12-03T10:15:30'.

LANGUAGE: typescript
CODE:
declare const date: Primitive<Date>

----------------------------------------

TITLE: Array.extend Function Signature in TypeScript
DESCRIPTION: Type declaration for the Array.extend function showing its polymorphic nature. It can be used both in curried and uncurried forms, accepting a readonly array and a mapping function.

LANGUAGE: typescript
CODE:
declare const extend: { <A, B>(f: (as: ReadonlyArray<A>) => B): (self: ReadonlyArray<A>) => Array<B>; <A, B>(self: ReadonlyArray<A>, f: (as: ReadonlyArray<A>) => B): Array<B>; }

----------------------------------------

TITLE: Implementing zipWith Function for Exit Combination in TypeScript
DESCRIPTION: The zipWith function zips two Exit instances together using specified combination functions for success and failure cases. It handles both curried and uncurried versions of the function, allowing for flexible usage patterns.

LANGUAGE: typescript
CODE:
declare const zipWith: {
  <B, E2, A, C, E>(
    that: Exit<B, E2>,
    options: {
      readonly onSuccess: (a: A, b: B) => C;
      readonly onFailure: (cause: Cause.Cause<E>, cause2: Cause.Cause<E2>) => Cause.Cause<any>;
    }
  ): (self: Exit<A, E>) => Exit<C, any>;
  <A, E, B, E2, C>(
    self: Exit<A, E>,
    that: Exit<B, E2>,
    options: {
      readonly onSuccess: (a: A, b: B) => C;
      readonly onFailure: (cause: Cause.Cause<E>, cause2: Cause.Cause<E2>) => Cause.Cause<E | E2>;
    }
  ): Exit<C, E | E2>;
}

----------------------------------------

TITLE: Implementing Stateful Chunk Mapping in TypeScript
DESCRIPTION: Defines a mapAccum function that statefully maps over a chunk, producing new elements of type B while maintaining an accumulator of type S. The function can be used in both curried and uncurried forms.

LANGUAGE: typescript
CODE:
declare const mapAccum: {
  <S, A, B>(s: S, f: (s: S, a: A) => readonly [S, B]): (self: Chunk<A>) => [S, Chunk<B>];
  <S, A, B>(self: Chunk<A>, s: S, f: (s: S, a: A) => readonly [S, B]): [S, Chunk<B>];
}

----------------------------------------

TITLE: Using Array.takeWhile in TypeScript Effect Library
DESCRIPTION: Demonstrates how to use Array.takeWhile to create a new array containing elements that satisfy a predicate condition. The function processes elements until it encounters the first element that fails the predicate test.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const result = Array.takeWhile([1, 3, 2, 4, 1, 2], x => x < 4)
console.log(result) // [1, 3, 2]

LANGUAGE: typescript
CODE:
declare const takeWhile: { 
  <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => Array<B>; 
  <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Array<A>; 
  <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): Array<B>; 
  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Array<A>; 
}

----------------------------------------

TITLE: Generating Random Integers in a Range using Effect
DESCRIPTION: The nextIntBetween function generates a random integer within a specified range. It takes two parameters: min and max, representing the inclusive lower and upper bounds of the range. The function returns an Effect that, when executed, produces the random integer.

LANGUAGE: typescript
CODE:
declare const nextIntBetween: (min: number, max: number) => Effect.Effect<number>

----------------------------------------

TITLE: Defining Doc.flatten Function in TypeScript
DESCRIPTION: This code snippet defines the flatten function in the Doc module. It takes a Doc<A> as input and returns a flattened Doc<A>. The function flattens a document but does not report changes.

LANGUAGE: typescript
CODE:
declare const flatten: <A>(self: Doc<A>) => Doc<A>

----------------------------------------

TITLE: TypeScript Signature of Match.discriminators Function
DESCRIPTION: Provides the detailed TypeScript type signature for the Match.discriminators function. This signature defines the function's parameters and return type, showcasing its complex generic constraints for type-safe pattern matching.

LANGUAGE: typescript
CODE:
declare const discriminators: <D extends string>(field: D) => <R, Ret, P extends { readonly [Tag in Types.Tags<D, R> & string]?: ((_: Extract<R, Record<D, Tag>>) => Ret) | undefined; } & { readonly [Tag in Exclude<keyof P, Types.Tags<D, R>>]: never; }>(fields: P) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr, Ret>) => Matcher<I, Types.AddWithout<F, Extract<R, Record<D, keyof P>>>, Types.ApplyFilters<I, Types.AddWithout<F, Extract<R, Record<D, keyof P>>>>, A | ReturnType<P[keyof P] & {}>, Pr, Ret>

----------------------------------------

TITLE: Defining Left Parenthesis Document in TypeScript
DESCRIPTION: Defines a constant Doc type representing a single left parenthesis character '(' for use in document formatting. The Doc type parameter of never indicates this document contains no annotations.

LANGUAGE: typescript
CODE:
declare const lparen: Doc<never>

----------------------------------------

TITLE: Effect.reduce Function Signature in TypeScript
DESCRIPTION: This code block shows the TypeScript signature for the Effect.reduce function. It illustrates the function's overloaded nature, allowing for different parameter orders and types.

LANGUAGE: typescript
CODE:
declare const reduce: { <Z, A, E, R>(zero: Z, f: (z: Z, a: A, i: number) => Effect<Z, E, R>): (elements: Iterable<A>) => Effect<Z, E, R>; <A, Z, E, R>(elements: Iterable<A>, zero: Z, f: (z: Z, a: A, i: number) => Effect<Z, E, R>): Effect<Z, E, R>; }

----------------------------------------

TITLE: Implementing HashMap.findFirst in TypeScript
DESCRIPTION: A function that returns the first element and its key from a HashMap that satisfies a given predicate. It supports type refinement through type predicates and returns an Option type containing a key-value tuple. If no element satisfies the predicate, it returns None.

LANGUAGE: typescript
CODE:
declare const findFirst: {
  <K, A, B extends A>(predicate: (a: NoInfer<A>, k: K) => a is B): (self: HashMap<K, A>) => Option<[K, B]>;
  <K, A>(predicate: (a: NoInfer<A>, k: K) => boolean): (self: HashMap<K, A>) => Option<[K, A]>;
  <K, A, B extends A>(self: HashMap<K, A>, predicate: (a: A, k: K) => a is B): Option<[K, B]>;
  <K, A>(self: HashMap<K, A>, predicate: (a: A, k: K) => boolean): Option<[K, A]>;
}

----------------------------------------

TITLE: Adding Finalizer Function Definition in TypeScript
DESCRIPTION: Type definition for the addFinalizer function that adds a finalizer to the current MicroScope. The finalizer takes a MicroExit parameter and returns a Micro<void> instance.

LANGUAGE: typescript
CODE:
declare const addFinalizer: (finalizer: (exit: MicroExit<unknown, unknown>) => Micro<void>) => Micro<void, never, MicroScope>

----------------------------------------

TITLE: Implementing Stream Rechunking in TypeScript
DESCRIPTION: The rechunk function re-chunks the elements of a stream into chunks of 'n' elements each. The last chunk may contain fewer than 'n' elements. It can be called with the number of elements first, or with the stream as the first argument.

LANGUAGE: typescript
CODE:
declare const rechunk: { (n: number): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, n: number): Stream<A, E, R>; }

----------------------------------------

TITLE: Implementing Span Creation in Effect
DESCRIPTION: Function signature for creating and managing tracing spans. Provides two overloads - one taking just a name and evaluation function, and another accepting additional span options. The span is automatically closed when the effect completes.

LANGUAGE: typescript
CODE:
declare const useSpan: {
  <A, E, R>(name: string, evaluate: (span: Tracer.Span) => Effect<A, E, R>): Effect<A, E, R>;
  <A, E, R>(name: string, options: Tracer.SpanOptions, evaluate: (span: Tracer.Span) => Effect<A, E, R>): Effect<A, E, R>;
}

----------------------------------------

TITLE: Creating DateTime Objects in TypeScript using Effect's DateTime.make Function
DESCRIPTION: Demonstrates how to use the DateTime.make function to create DateTime objects from different input types such as Date instances, object literals with date parts, and date strings. The function returns an Option type, with None for invalid inputs.

LANGUAGE: typescript
CODE:
import { DateTime } from "effect"

// from Date
DateTime.make(new Date())

// from parts
DateTime.make({ year: 2024 })

// from string
DateTime.make("2024-01-01")

----------------------------------------

TITLE: Implementing Last Value Sink in TypeScript
DESCRIPTION: Function signature for creating a sink that maintains the last value received. Returns a Sink that wraps the last value in an Option type, allowing for the possibility of no value being present.

LANGUAGE: typescript
CODE:
declare const last: <In>() => Sink<Option.Option<In>, In, In>

----------------------------------------

TITLE: Converting Config Property Names to Constant Case - TypeScript
DESCRIPTION: Function that creates a new config provider which automatically converts all property names from camel case to constant case. This helps adapt configuration property naming conventions between different systems.

LANGUAGE: typescript
CODE:
declare const constantCase: (self: ConfigProvider) => ConfigProvider

----------------------------------------

TITLE: Declaring TypeScript Effect.tagMetrics Function Signature
DESCRIPTION: TypeScript type declaration for the tagMetrics function that supports tagging metrics with either single key-value pairs or multiple tag records. The function provides flexible overloads for different parameter combinations and preserves the effect's type parameters.

LANGUAGE: typescript
CODE:
declare const tagMetrics: { 
  (key: string, value: string): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; 
  (values: Record<string, string>): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; 
  <A, E, R>(effect: Effect<A, E, R>, key: string, value: string): Effect<A, E, R>; 
  <A, E, R>(effect: Effect<A, E, R>, values: Record<string, string>): Effect<A, E, R>; 
}

----------------------------------------

TITLE: Implementing Synchronous Failure Channel in TypeScript
DESCRIPTION: Creates a channel that fails immediately with a lazily evaluated error value. The function takes a lazy argument that produces the error value and returns a typed Channel instance.

LANGUAGE: typescript
CODE:
declare const failSync: <E>(evaluate: LazyArg<E>) => Channel<never, unknown, E, unknown, never, unknown>

----------------------------------------

TITLE: Cron.next Function Signature in TypeScript
DESCRIPTION: Provides the TypeScript function signature for the Cron.next function. It takes a Cron instance and an optional starting date as input, and returns a Date object representing the next run time.

LANGUAGE: typescript
CODE:
declare const next: (cron: Cron, startFrom?: DateTime.DateTime.Input) => Date

----------------------------------------

TITLE: Using valuesWithPrefix in TypeScript Trie
DESCRIPTION: Demonstrates how to use the valuesWithPrefix function to retrieve values from a Trie data structure that match a given prefix. The example shows creating a trie with string keys and number values, then retrieving values for keys starting with 'she'.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Trie } from "effect"

const trie = Trie.empty<number>().pipe(
  Trie.insert("she", 0),
  Trie.insert("shells", 1),
  Trie.insert("sea", 2),
  Trie.insert("shore", 3)
)

const result = Array.from(Trie.valuesWithPrefix(trie, "she"))

// 0: "she", 1: "shells"
assert.deepStrictEqual(result, [0, 1])

LANGUAGE: typescript
CODE:
declare const valuesWithPrefix: { (prefix: string): <V>(self: Trie<V>) => IterableIterator<V>; <V>(self: Trie<V>, prefix: string): IterableIterator<V>; }

----------------------------------------

TITLE: Effect.race Function Signature in TypeScript
DESCRIPTION: Provides the TypeScript function signature for the Effect.race function, showing its type parameters and return type.

LANGUAGE: typescript
CODE:
declare const race: { <A2, E2, R2>(that: Effect<A2, E2, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, that: Effect<A2, E2, R2>): Effect<A | A2, E | E2, R | R2>; }

----------------------------------------

TITLE: Using FiberHandle.runtime in TypeScript with Effect Package
DESCRIPTION: Demonstrates how to use FiberHandle.runtime to capture a Runtime and fork Effects, adding them to the FiberHandle. It shows context creation, effect generation, and fiber management.

LANGUAGE: typescript
CODE:
import { Context, Effect, FiberHandle } from "effect"

interface Users {
  readonly _: unique symbol
}
const Users = Context.GenericTag<Users, {
   getAll: Effect.Effect<Array<unknown>>
}>("Users")

Effect.gen(function*() {
  const handle = yield* FiberHandle.make()
  const run = yield* FiberHandle.runtime(handle)<Users>()

  // run an effect and set the fiber in the handle
  run(Effect.andThen(Users, _ => _.getAll))

  // this will interrupt the previous fiber
  run(Effect.andThen(Users, _ => _.getAll))
}).pipe(
  Effect.scoped // The fiber will be interrupted when the scope is closed
)

----------------------------------------

TITLE: Adding Multiple Cookies to Cookies Object in TypeScript
DESCRIPTION: The setAll function allows adding multiple cookies to a Cookies object. It accepts an iterable of cookie tuples and returns an Either type representing success or failure. The function can be used in two ways: as a standalone function or as a method on a Cookies object.

LANGUAGE: typescript
CODE:
declare const setAll: { (cookies: Iterable<readonly [name: string, value: string, options?: Cookie["options"]]>): (self: Cookies) => Either.Either<Cookies, CookiesError>; (self: Cookies, cookies: Iterable<readonly [name: string, value: string, options?: Cookie["options"]]>): Either.Either<Cookies, CookiesError>; }

----------------------------------------

TITLE: Using MonoidMax with Numbers in TypeScript
DESCRIPTION: Demonstrates how to use the MonoidMax Monoid to find the maximum between two numbers. The MonoidMax.empty value is Infinity, and combining numbers returns the larger value.

LANGUAGE: typescript
CODE:
import { MonoidMax } from "@effect/typeclass/data/Number"

console.log(MonoidMax.combine(2, 3))
// 3
console.log(MonoidMax.combine(2, MonoidMax.empty))
// 2

LANGUAGE: typescript
CODE:
declare const MonoidMax: monoid.Monoid<number>

----------------------------------------

TITLE: Effect.map Function Signature in TypeScript
DESCRIPTION: Provides the TypeScript signature for the Effect.map function, showing its polymorphic nature and how it can be used with different effect types.

LANGUAGE: typescript
CODE:
declare const map: { <A, B>(f: (a: A) => B): <E, R>(self: Effect<A, E, R>) => Effect<B, E, R>; <A, E, R, B>(self: Effect<A, E, R>, f: (a: A) => B): Effect<B, E, R>; }

----------------------------------------

TITLE: Creating Batched Logger in TypeScript with Effect
DESCRIPTION: Demonstrates how to create a batched logger that groups log messages and processes them in intervals. It replaces the default logger with a logfmt logger that batches messages every 500 milliseconds.

LANGUAGE: typescript
CODE:
import { Console, Effect, Logger } from "effect"

const LoggerLive = Logger.replaceScoped(
  Logger.defaultLogger,
  Logger.logfmtLogger.pipe(
    Logger.batched("500 millis", (messages) => Console.log("BATCH", `[\n${messages.join("\n")}\n]`))
  )
)

const program = Effect.gen(function*() {
  yield* Effect.log("one")
  yield* Effect.log("two")
  yield* Effect.log("three")
}).pipe(Effect.provide(LoggerLive))

Effect.runFork(program)
// BATCH [
// timestamp=... level=INFO fiber=#0 message=one
// timestamp=... level=INFO fiber=#0 message=two
// timestamp=... level=INFO fiber=#0 message=three
// ]

----------------------------------------

TITLE: Implementing Interruptible Resource Management in TypeScript
DESCRIPTION: Defines a function that creates a scoped resource with an interruptible acquire action. The function takes an acquire effect that can be interrupted and a release function that handles cleanup. The release function receives an Exit type parameter containing the execution outcome.

LANGUAGE: typescript
CODE:
declare const acquireReleaseInterruptible: {
  <X, R2>(release: (exit: Exit.Exit<unknown, unknown>) => Effect<X, never, R2>): <A, E, R>(acquire: Effect<A, E, R>) => Effect<A, E, Scope.Scope | R2 | R>;
  <A, E, R, X, R2>(acquire: Effect<A, E, R>, release: (exit: Exit.Exit<unknown, unknown>) => Effect<X, never, R2>): Effect<A, E, Scope.Scope | R | R2>;
}

----------------------------------------

TITLE: Demonstrating Either.bind Usage in TypeScript
DESCRIPTION: Shows how to use Either.bind and Either.let to chain operations and combine values in a declarative style. The example demonstrates binding multiple values and computing a sum using the Either monad.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Either, pipe } from "effect"

const result = pipe(
  Either.Do,
  Either.bind("x", () => Either.right(2)),
  Either.bind("y", () => Either.right(3)),
  Either.let("sum", ({ x, y }) => x + y)
)
assert.deepStrictEqual(result, Either.right({ x: 2, y: 3, sum: 5 }))

----------------------------------------

TITLE: Creating ConfigProvider with make Function in TypeScript
DESCRIPTION: The make function creates a new config provider. It takes an options object with a load function for loading configurations and a flattened ConfigProvider.Flat property.

LANGUAGE: typescript
CODE:
declare const make: (options: { readonly load: <A>(config: Config.Config<A>) => Effect.Effect<A, ConfigError.ConfigError>; readonly flattened: ConfigProvider.Flat; }) => ConfigProvider

----------------------------------------

TITLE: Implementing Random Service Access in TypeScript
DESCRIPTION: Function definition for randomWith that retrieves the Random service from context and executes a specified workflow. Takes a function parameter that receives the Random service and returns an Effect.

LANGUAGE: typescript
CODE:
declare const randomWith: <A, E, R>(f: (random: Random) => Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>

----------------------------------------

TITLE: Using JsonNumber Schema Validation in TypeScript
DESCRIPTION: Demonstrates how to use the JsonNumber schema to validate numeric values, specifically filtering out NaN and Infinity values. The example shows usage with the Schema.is() method to perform validation checks.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import * as Schema from "effect/Schema"

const is = Schema.is(S.JsonNumber)

assert.deepStrictEqual(is(42), true)
assert.deepStrictEqual(is(Number.NaN), false)
assert.deepStrictEqual(is(Number.POSITIVE_INFINITY), false)
assert.deepStrictEqual(is(Number.NEGATIVE_INFINITY), false)

LANGUAGE: typescript
CODE:
declare class JsonNumber

----------------------------------------

TITLE: Implementing Queue.poll Function in TypeScript for Effect Library
DESCRIPTION: Defines the poll function for the Queue module. This function returns the first value in the Queue as a Some<A>, or None if the queue is empty. It operates on a Dequeue<A> and returns an Effect that resolves to an Option<A>.

LANGUAGE: typescript
CODE:
declare const poll: <A>(self: Dequeue<A>) => Effect.Effect<Option.Option<A>>

----------------------------------------

TITLE: TypeScript Function Signature for tagsExhaustive in Match Module
DESCRIPTION: Provides the TypeScript function signature for the tagsExhaustive function in the Match module. This signature defines the input parameters and return type of the function, showcasing its complex type constraints and generic parameters.

LANGUAGE: typescript
CODE:
declare const tagsExhaustive: <R, Ret, P extends { readonly [Tag in Types.Tags<"_tag", R> & string]: (_: Extract<R, Record<"_tag", Tag>>) => Ret; } & { readonly [Tag in Exclude<keyof P, Types.Tags<"_tag", R>>]: never; }>(fields: P) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr, Ret>) => [Pr] extends [never] ? (u: I) => Unify<A | ReturnType<P[keyof P]>> : Unify<A | ReturnType<P[keyof P]>>

----------------------------------------

TITLE: Declaring awaitEmpty Function for FiberMap in TypeScript
DESCRIPTION: Defines the awaitEmpty function that waits for a FiberMap to become empty. It takes a FiberMap as input and returns an Effect that resolves to void or an error of type E.

LANGUAGE: typescript
CODE:
declare const awaitEmpty: <K, A, E>(self: FiberMap<K, A, E>) => Effect.Effect<void, E>

----------------------------------------

TITLE: Effect.once Type Signature Definition
DESCRIPTION: TypeScript type signature for the Effect.once function, showing its generic type parameters and return type.

LANGUAGE: typescript
CODE:
declare const once: <A, E, R>(self: Effect<A, E, R>) => Effect<Effect<void, E, R>>

----------------------------------------

TITLE: Using Match.withReturnType for Type Validation in TypeScript
DESCRIPTION: Demonstrates how to use Match.withReturnType to ensure consistent return types across pattern matching branches. The example shows both valid and invalid type assignments to illustrate TypeScript's type checking behavior.

LANGUAGE: typescript
CODE:
import { Match } from "effect"

const match = Match.type<{ a: number } | { b: string }>().pipe(
  // Ensure all branches return a string
  Match.withReturnType<string>(),
  // ❌ Type error: 'number' is not assignable to type 'string'
  // @ts-expect-error
  Match.when({ a: Match.number }, (_) => _.a),
  // ✅ Correct: returns a string
  Match.when({ b: Match.string }, (_) => _.b),
  Match.exhaustive
)

----------------------------------------

TITLE: Creating Empty TArray - TypeScript STM Implementation
DESCRIPTION: Function signature for creating an empty transactional array (TArray) using Software Transactional Memory (STM). Returns a new STM transaction that produces an empty TArray of type A.

LANGUAGE: typescript
CODE:
declare const empty: <A>() => STM.STM<TArray<A>>

----------------------------------------

TITLE: Effect.reduceWhile Function Signature in TypeScript
DESCRIPTION: The type signature of the Effect.reduceWhile function. It takes an initial value, an iterable, and options including a predicate and a body function to process each element.

LANGUAGE: typescript
CODE:
declare const reduceWhile: { <Z, A, E, R>(zero: Z, options: { readonly while: Predicate<Z>; readonly body: (s: Z, a: A, i: number) => Effect<Z, E, R>; }): (elements: Iterable<A>) => Effect<Z, E, R>; <A, Z, E, R>(elements: Iterable<A>, zero: Z, options: { readonly while: Predicate<Z>; readonly body: (s: Z, a: A, i: number) => Effect<Z, E, R>; }): Effect<Z, E, R>; }

----------------------------------------

TITLE: Type Signature for matchCauseEffect in TypeScript
DESCRIPTION: Shows the complete type signature for the matchCauseEffect function, defining its parameters and return types for both curried and uncurried versions.

LANGUAGE: typescript
CODE:
declare const matchCauseEffect: { <E, A2, E2, R2, A, A3, E3, R3>(options: { readonly onFailure: (cause: Cause.Cause<E>) => Effect<A2, E2, R2>; readonly onSuccess: (a: A) => Effect<A3, E3, R3>; }): <R>(self: Effect<A, E, R>) => Effect<A2 | A3, E2 | E3, R2 | R3 | R>; <A, E, R, A2, E2, R2, A3, E3, R3>(self: Effect<A, E, R>, options: { readonly onFailure: (cause: Cause.Cause<E>) => Effect<A2, E2, R2>; readonly onSuccess: (a: A) => Effect<A3, E3, R3>; }): Effect<A2 | A3, E2 | E3, R2 | R3 | R>; }

----------------------------------------

TITLE: Defining angleBracketed Function in TypeScript
DESCRIPTION: Function signature for angleBracketed that takes a Doc<A> parameter and returns a new Doc<A> with angle brackets around the content. This utility helps in formatting document content by wrapping it in angle brackets (<>).

LANGUAGE: typescript
CODE:
declare const angleBracketed: <A>(self: Doc<A>) => Doc<A>

----------------------------------------

TITLE: Queue.takeAll Operation Implementation in TypeScript
DESCRIPTION: TypeScript function declaration for taking all values from a queue and returning them as a Chunk. The operation works with any type A and returns an Effect containing a Chunk of type A. If the queue is empty, it returns an empty collection.

LANGUAGE: typescript
CODE:
declare const takeAll: <A>(self: Dequeue<A>) => Effect.Effect<Chunk.Chunk<A>>

----------------------------------------

TITLE: Implementing Layer.failCauseSync in TypeScript - Effect Package
DESCRIPTION: Function that constructs a layer that fails with a specified cause. Takes a lazy argument that evaluates to a Cause<E> and returns a Layer<unknown, E>. Used for creating failing layers in effect-based applications.

LANGUAGE: typescript
CODE:
declare const failCauseSync: <E>(evaluate: LazyArg<Cause.Cause<E>>) => Layer<unknown, E>

----------------------------------------

TITLE: Implementing Chunk.drop Function in TypeScript
DESCRIPTION: Defines the drop function for the Chunk module. This function removes up to n elements from the beginning of a chunk. It has two overloads: one that takes the number of elements to drop as the first argument, and another that takes the chunk as the first argument and the number of elements to drop as the second.

LANGUAGE: typescript
CODE:
declare const drop: { (n: number): <A>(self: Chunk<A>) => Chunk<A>; <A>(self: Chunk<A>, n: number): Chunk<A>; }

----------------------------------------

TITLE: Effect.annotateLogs Function Signature in TypeScript
DESCRIPTION: TypeScript function signature showing the various overloads of the annotateLogs function. Supports both key-value pair and record-based annotation methods.

LANGUAGE: typescript
CODE:
declare const annotateLogs: { (key: string, value: unknown): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; (values: Record<string, unknown>): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(effect: Effect<A, E, R>, key: string, value: unknown): Effect<A, E, R>; <A, E, R>(effect: Effect<A, E, R>, values: Record<string, unknown>): Effect<A, E, R>; }

----------------------------------------

TITLE: Converting Duration to Nanoseconds in TypeScript
DESCRIPTION: Function that converts a DurationInput to nanoseconds represented as a bigint. Throws an error if the duration is infinite. Part of the Effect package's Duration module.

LANGUAGE: typescript
CODE:
declare const unsafeToNanos: (self: DurationInput) => bigint

----------------------------------------

TITLE: Implementing Stream.mergeAll in TypeScript
DESCRIPTION: Defines a function that merges multiple streams with configurable concurrency and buffer size. The operation supports parallel stream consumption with a specified concurrency limit and output buffering capacity.

LANGUAGE: typescript
CODE:
declare const mergeAll: { 
  (options: { readonly concurrency: number | "unbounded"; readonly bufferSize?: number | undefined; }): 
    <A, E, R>(streams: Iterable<Stream<A, E, R>>) => Stream<A, E, R>; 
  <A, E, R>(streams: Iterable<Stream<A, E, R>>, 
    options: { readonly concurrency: number | "unbounded"; readonly bufferSize?: number | undefined; }): 
    Stream<A, E, R>; 
}

----------------------------------------

TITLE: Type Signature of Effect.loop Function in TypeScript
DESCRIPTION: Detailed type signature for the Effect.loop function, showing its polymorphic nature and various overloads to handle different use cases.

LANGUAGE: typescript
CODE:
declare const loop: { <A, B extends A, C, E, R>(initial: A, options: { readonly while: Refinement<A, B>; readonly step: (b: B) => A; readonly body: (b: B) => Effect<C, E, R>; readonly discard?: false | undefined; }): Effect<Array<C>, E, R>; <A, C, E, R>(initial: A, options: { readonly while: (a: A) => boolean; readonly step: (a: A) => A; readonly body: (a: A) => Effect<C, E, R>; readonly discard?: false | undefined; }): Effect<Array<C>, E, R>; <A, B extends A, C, E, R>(initial: A, options: { readonly while: Refinement<A, B>; readonly step: (b: B) => A; readonly body: (b: B) => Effect<C, E, R>; readonly discard: true; }): Effect<void, E, R>; <A, C, E, R>(initial: A, options: { readonly while: (a: A) => boolean; readonly step: (a: A) => A; readonly body: (a: A) => Effect<C, E, R>; readonly discard: true; }): Effect<void, E, R>; }

----------------------------------------

TITLE: Configuring WebSocket Layer for ShardManager in TypeScript
DESCRIPTION: Defines a Layer that sets up WebSocket functionality for the ShardManager server. It accepts configuration options for path routing, runner connectivity, and logging. The layer depends on various services including RpcSerialization, ShardStorage, RunnerHealth, HttpServer, and ShardManager configurations.

LANGUAGE: typescript
CODE:
declare const layerWebsocketOptions: <I = HttpRouter.Default>(options: { 
  readonly path: HttpRouter.PathInput; 
  readonly routerTag?: HttpRouter.HttpRouter.TagClass<I, string, any, any>; 
  readonly runnerPath: string; 
  readonly runnerHttps?: boolean | undefined; 
  readonly logAddress?: boolean | undefined; 
}) => Layer.Layer<ShardManager.ShardManager, never, RpcSerialization.RpcSerialization | ShardStorage | RunnerHealth.RunnerHealth | HttpServer.HttpServer | Socket.WebSocketConstructor | ShardManager.Config | ShardingConfig>

----------------------------------------

TITLE: Retrieving Console Service in Effect Module (TypeScript)
DESCRIPTION: Defines a constant 'console' that retrieves the Console service from the context. It returns an Effect with Console as the environment, never as the error type, and never as the value type.

LANGUAGE: typescript
CODE:
declare const console: Effect<Console, never, never>

----------------------------------------

TITLE: Demonstrating Effect.interrupt Usage in TypeScript
DESCRIPTION: This example shows how to use Effect.interrupt to stop a fiber's execution. It creates a program that logs a message, sleeps for 2 seconds, then interrupts itself before completion. The result is captured and logged using runPromiseExit.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

const program = Effect.gen(function* () {
  console.log("start")
  yield* Effect.sleep("2 seconds")
  yield* Effect.interrupt
  console.log("done")
  return "some result"
})

Effect.runPromiseExit(program).then(console.log)
// Output:
// start
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: {
//     _id: 'Cause',
//     _tag: 'Interrupt',
//     fiberId: {
//       _id: 'FiberId',
//       _tag: 'Runtime',
//       id: 0,
//       startTimeMillis: ...
//     }
//   }
// }

----------------------------------------

TITLE: Declaring Schema Assertion Function in TypeScript
DESCRIPTION: Defines a type assertion function that validates unknown values against a schema. The function takes a schema and optional parse options, returning an assertion function that throws ParseError if validation fails. Default option 'exact' is set to true.

LANGUAGE: typescript
CODE:
declare const asserts: <A, I, R>(schema: Schema.Schema<A, I, R>, options?: AST.ParseOptions) => (u: unknown, overrideOptions?: AST.ParseOptions) => asserts u is A

----------------------------------------

TITLE: Using Array.partitionMap for Even/Odd Number Separation in TypeScript
DESCRIPTION: Demonstrates how to use Array.partitionMap to separate numbers into even and odd collections using Either.right and Either.left. The function takes an array and a mapping function that returns Either values, producing a tuple of two arrays.

LANGUAGE: typescript
CODE:
import { Array, Either } from "effect";

const isEven = (x: number) => x % 2 === 0

const result = Array.partitionMap([1, 2, 3, 4, 5], x =>
  isEven(x) ? Either.right(x) : Either.left(x)
)
console.log(result)
// [
//   [1, 3, 5],
//   [2, 4]
// ]

----------------------------------------

TITLE: Stream.bind Function Signature in Effect
DESCRIPTION: This code snippet shows the TypeScript signature for the Stream.bind function. It details the function's parameters and return types, including generic type constraints and optional configuration options.

LANGUAGE: typescript
CODE:
declare const bind: { <N extends string, A, B, E2, R2>(tag: Exclude<N, keyof A>, f: (_: NoInfer<A>) => Stream<B, E2, R2>, options?: { readonly concurrency?: number | "unbounded" | undefined; readonly bufferSize?: number | undefined; } | undefined): <E, R>(self: Stream<A, E, R>) => Stream<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }, E2 | E, R2 | R>; <A, E, R, N extends string, B, E2, R2>(self: Stream<A, E, R>, tag: Exclude<N, keyof A>, f: (_: NoInfer<A>) => Stream<B, E2, R2>, options?: { readonly concurrency?: number | "unbounded" | undefined; readonly bufferSize?: number | undefined; } | undefined): Stream<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }, E | E2, R | R2>; }

----------------------------------------

TITLE: Implementing Dynamic Stream Distribution in TypeScript with Effect
DESCRIPTION: Defines a function for dynamic stream distribution that allows creating new queues with corresponding indices and supports custom decision logic for distribution. The function handles queue shutdown and backpressure management, with support for manual queue shutdown by downstream consumers.

LANGUAGE: typescript
CODE:
declare const distributedWithDynamic: {
  <A>(options: {
    readonly maximumLag: number;
    readonly decide: (a: A) => Effect.Effect<Predicate<number>, never, never>;
  }): <E, R>(
    self: Stream<A, E, R>
  ) => Effect.Effect<
    Effect.Effect<[number, Queue.Dequeue<Exit.Exit<A, Option.Option<E>>>], never, never>,
    never,
    Scope.Scope | R
  >;
  <A, E, R>(
    self: Stream<A, E, R>,
    options: {
      readonly maximumLag: number;
      readonly decide: (a: A) => Effect.Effect<Predicate<number>, never, never>;
    }
  ): Effect.Effect<
    Effect.Effect<[number, Queue.Dequeue<Exit.Exit<A, Option.Option<E>>>], never, never>,
    never,
    Scope.Scope | R
  >;
}

----------------------------------------

TITLE: Creating Infinite Stream from Effect in TypeScript
DESCRIPTION: The repeatEffectChunk function creates a stream that repeatedly produces chunks of values from an effect. It takes an effect that produces a Chunk of A values and returns a Stream that will repeat this effect indefinitely.

LANGUAGE: typescript
CODE:
declare const repeatEffectChunk: <A, E, R>(effect: Effect.Effect<Chunk.Chunk<A>, E, R>) => Stream<A, E, R>

----------------------------------------

TITLE: TypeScript Function Signature for BigInt Division in Effect Library
DESCRIPTION: This code snippet shows the TypeScript function signature for the unsafeDivide function in the Effect library's BigInt module. It defines the function as taking either two bigint parameters or using curried notation.

LANGUAGE: typescript
CODE:
declare const unsafeDivide: { (that: bigint): (self: bigint) => bigint; (self: bigint, that: bigint): bigint; }

----------------------------------------

TITLE: Declaring Stream.mapChunks Function in TypeScript
DESCRIPTION: Defines the mapChunks function that transforms chunks emitted by a stream. It can be used in two ways: either by passing the transformation function first, or by passing the stream first followed by the transformation function.

LANGUAGE: typescript
CODE:
declare const mapChunks: {
  <A, B>(f: (chunk: Chunk.Chunk<A>) => Chunk.Chunk<B>): <E, R>(self: Stream<A, E, R>) => Stream<B, E, R>;
  <A, E, R, B>(self: Stream<A, E, R>, f: (chunk: Chunk.Chunk<A>) => Chunk.Chunk<B>): Stream<B, E, R>;
}

----------------------------------------

TITLE: Zipping Fibers in TypeScript Effect Library
DESCRIPTION: Function signature for zipping two Fiber instances together. The zip operation combines two fibers and produces a new fiber containing a tuple of their results. Handles error types from both input fibers.

LANGUAGE: typescript
CODE:
declare const zip: { <A2, E2>(that: Fiber<A2, E2>): <A, E>(self: Fiber<A, E>) => Fiber<[A, A2], E2 | E>; <A, E, A2, E2>(self: Fiber<A, E>, that: Fiber<A2, E2>): Fiber<[A, A2], E | E2>; }

----------------------------------------

TITLE: Using Option.containsWith with Custom Equivalence - TypeScript
DESCRIPTION: Demonstrates how to use Option.containsWith with a Number.Equivalence function to check if an Option contains a specific numeric value. The function returns true if the Option is Some and contains an equivalent value, false otherwise.

LANGUAGE: typescript
CODE:
import { Number, Option } from "effect"

const contains = Option.containsWith(Number.Equivalence)

console.log(Option.some(2).pipe(contains(2)))
// Output: true

console.log(Option.some(1).pipe(contains(2)))
// Output: false

console.log(Option.none().pipe(contains(2)))
// Output: false

LANGUAGE: typescript
CODE:
declare const containsWith: <A>(isEquivalent: (self: A, that: A) => boolean) => { (a: A): (self: Option<A>) => boolean; (self: Option<A>, a: A): boolean; }

----------------------------------------

TITLE: Defining PopAnnotationStream Interface in TypeScript
DESCRIPTION: TypeScript interface definition for PopAnnotationStream that extends DocStream.Variance<A>. This interface represents the structure for removing a previously pushed annotation from a Doc, containing a tag identifier and a reference to the underlying stream.

LANGUAGE: typescript
CODE:
export interface PopAnnotationStream<A> extends DocStream.Variance<A> {
  readonly _tag: "PopAnnotationStream"
  readonly stream: DocStream<A>
}

----------------------------------------

TITLE: Setting Cookies in Effect Platform
DESCRIPTION: Function signature for adding a cookie to a Cookies object. Supports both curried and uncurried calling styles for flexibility in usage.

LANGUAGE: typescript
CODE:
declare const setCookie: { (cookie: Cookie): (self: Cookies) => Cookies; (self: Cookies, cookie: Cookie): Cookies; }

----------------------------------------

TITLE: Implementing forEach Function in Effect Micro Module - TypeScript
DESCRIPTION: Function signature for forEach that runs effects on iterable elements. Supports concurrent execution with configurable concurrency levels and optional result collection. Returns either an array of results or void based on the discard option.

LANGUAGE: typescript
CODE:
declare const forEach: { 
  <A, B, E, R>(
    iterable: Iterable<A>, 
    f: (a: A, index: number) => Micro<B, E, R>, 
    options?: { 
      readonly concurrency?: Concurrency | undefined; 
      readonly discard?: false | undefined; 
    }
  ): Micro<Array<B>, E, R>; 
  <A, B, E, R>(
    iterable: Iterable<A>, 
    f: (a: A, index: number) => Micro<B, E, R>, 
    options: { 
      readonly concurrency?: Concurrency | undefined; 
      readonly discard: true; 
    }
  ): Micro<void, E, R>; 
}

----------------------------------------

TITLE: Accessing Current Time in TestClock - TypeScript Effect Definition
DESCRIPTION: Defines an Effect that retrieves the current time in milliseconds from a TestClock instance. The Effect has no requirements (never) and cannot fail (never), returning a number value.

LANGUAGE: typescript
CODE:
declare const currentTimeMillis: Effect.Effect<number, never, never>

----------------------------------------

TITLE: Implementing Schedule Combination with Custom Interval Merging in TypeScript
DESCRIPTION: Defines a function that combines two schedules with a custom merge function for their intervals. The function continues execution while at least one schedule is active and produces tuple outputs containing both schedules' results. Supports generic typing for inputs, outputs, and requirements.

LANGUAGE: typescript
CODE:
declare const unionWith: { 
  <Out2, In2, R2>(that: Schedule<Out2, In2, R2>, f: (x: Intervals.Intervals, y: Intervals.Intervals) => Intervals.Intervals): 
    <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<[Out, Out2], In & In2, R2 | R>; 
  <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>, f: (x: Intervals.Intervals, y: Intervals.Intervals) => Intervals.Intervals): 
    Schedule<[Out, Out2], In & In2, R | R2>; 
}

----------------------------------------

TITLE: Effect.cause Function Signature in TypeScript
DESCRIPTION: Type signature for the Effect.cause function showing its generic type parameters and return type. The function transforms an Effect into another Effect containing the cause of any failure.

LANGUAGE: typescript
CODE:
declare const cause: <A, E, R>(self: Effect<A, E, R>) => Effect<Cause.Cause<E>, never, R>

----------------------------------------

TITLE: Merging Contexts Example - TypeScript
DESCRIPTION: Shows how to merge two Context objects containing different services (Port and Timeout) into a single Context. Demonstrates creation of generic tags, context initialization, and accessing merged context values.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Context } from "effect"

const Port = Context.GenericTag<{ PORT: number }>("Port")
const Timeout = Context.GenericTag<{ TIMEOUT: number }>("Timeout")

const firstContext = Context.make(Port, { PORT: 8080 })
const secondContext = Context.make(Timeout, { TIMEOUT: 5000 })

const Services = Context.merge(firstContext, secondContext)

assert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })
assert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })

LANGUAGE: typescript
CODE:
declare const merge: { <R1>(that: Context<R1>): <Services>(self: Context<Services>) => Context<R1 | Services>; <Services, R1>(self: Context<Services>, that: Context<R1>): Context<Services | R1>; }

----------------------------------------

TITLE: Implementing FiberMap Runtime Promise in TypeScript
DESCRIPTION: Type definition for runtimePromise function that captures a Runtime to fork Effects and add them to FiberMap. The function accepts a FiberMap and returns an Effect that can fork effects with specified keys, with optional configuration for execution behavior.

LANGUAGE: typescript
CODE:
declare const runtimePromise: <K, A, E>(self: FiberMap<K, A, E>) => <R = never>() => Effect.Effect<(<XE extends E, XA extends A>(key: K, effect: Effect.Effect<XA, XE, R>, options?: (Runtime.RunForkOptions & { readonly onlyIfMissing?: boolean | undefined; readonly propagateInterruption?: boolean | undefined; }) | undefined) => Promise<XA>), never, R>

----------------------------------------

TITLE: Array.findFirstIndex Function Signature in TypeScript
DESCRIPTION: Provides the TypeScript signature for the Array.findFirstIndex function. It shows two overloads: one that takes a predicate function and returns a function for later application, and another that directly applies the predicate to an iterable.

LANGUAGE: typescript
CODE:
declare const findFirstIndex: { <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Option.Option<number>; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Option.Option<number>; }

----------------------------------------

TITLE: Declaring unsafeSet Function for FiberMap in TypeScript
DESCRIPTION: Defines the unsafeSet function for adding a fiber to the FiberMap. It supports adding new fibers, potentially interrupting existing ones, and offers options for controlling the addition and interruption behavior.

LANGUAGE: typescript
CODE:
declare const unsafeSet: { <K, A, E, XE extends E, XA extends A>(key: K, fiber: Fiber.RuntimeFiber<XA, XE>, options?: { readonly interruptAs?: FiberId.FiberId | undefined; readonly onlyIfMissing?: boolean | undefined; readonly propagateInterruption?: boolean | undefined; } | undefined): (self: FiberMap<K, A, E>) => void; <K, A, E, XE extends E, XA extends A>(self: FiberMap<K, A, E>, key: K, fiber: Fiber.RuntimeFiber<XA, XE>, options?: { readonly interruptAs?: FiberId.FiberId | undefined; readonly onlyIfMissing?: boolean | undefined; readonly propagateInterruption?: boolean | undefined; } | undefined): void; }

----------------------------------------

TITLE: Annotating DocTree with Metadata in TypeScript
DESCRIPTION: The annotation function is used to add metadata of type A to a DocTree instance. It can be called in two ways: either by providing the annotation first and then the DocTree, or by providing the DocTree first and then the annotation.

LANGUAGE: typescript
CODE:
declare const annotation: { <A>(annotation: A): <B>(self: DocTree<B>) => DocTree<A | B>; <A, B>(self: DocTree<A>, annotation: B): DocTree<A | B>; }

----------------------------------------

TITLE: Implementing ANSI Beep Control Sequence in TypeScript
DESCRIPTION: Defines a constant 'beep' of type Ansi that represents the ANSI control sequence for playing a beeping sound in the terminal. This is part of the @effect/printer-ansi package's ANSI control sequence implementations.

LANGUAGE: typescript
CODE:
declare const beep: Ansi

----------------------------------------

TITLE: Wrapping Promise into Micro Effect in TypeScript
DESCRIPTION: The 'promise' function wraps a Promise into a Micro effect. It takes a function that receives an AbortSignal and returns a PromiseLike<A>. Any errors result in a Die variant of the MicroCause type, where the error is not tracked at the type level.

LANGUAGE: typescript
CODE:
declare const promise: <A>(evaluate: (signal: AbortSignal) => PromiseLike<A>) => Micro<A>

----------------------------------------

TITLE: Defining Chunk.every Function in TypeScript
DESCRIPTION: Declares the every function for the Chunk module. This function checks if a predicate holds true for every element in a Chunk. It supports both refinement and predicate functions, and can be used with both curried and non-curried forms.

LANGUAGE: typescript
CODE:
declare const every: {
  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: Chunk<A>) => self is Chunk<B>;
  <A>(predicate: Predicate<A>): (self: Chunk<A>) => boolean;
  <A, B extends A>(self: Chunk<A>, refinement: Refinement<A, B>): self is Chunk<B>;
  <A>(self: Chunk<A>, predicate: Predicate<A>): boolean;
}

----------------------------------------

TITLE: Defining 'take' Function for Iterables in TypeScript
DESCRIPTION: Declares a 'take' function that limits the number of elements in an Iterable. It can be used in two ways: either by passing the number first and then the Iterable, or by passing the Iterable first and then the number. The function normalizes the input number to a non-negative integer.

LANGUAGE: typescript
CODE:
declare const take: { (n: number): <A>(self: Iterable<A>) => Iterable<A>; <A>(self: Iterable<A>, n: number): Iterable<A>; }

----------------------------------------

TITLE: Deduplicating Adjacent Array Elements in TypeScript
DESCRIPTION: The dedupeAdjacent function removes adjacent duplicate elements from an array. It takes an iterable as input and returns a new array with adjacent duplicates removed.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const result = Array.dedupeAdjacent([1, 1, 2, 2, 3, 3])
console.log(result) // [1, 2, 3]

LANGUAGE: typescript
CODE:
declare const dedupeAdjacent: <A>(self: Iterable<A>) => Array<A>

----------------------------------------

TITLE: Effect.reduceEffect Type Signature
DESCRIPTION: Type declaration for the reduceEffect function showing its polymorphic nature and options for concurrency, batching, and finalizer handling.

LANGUAGE: typescript
CODE:
declare const reduceEffect: { <Z, E, R, Eff extends Effect<any, any, any>>(zero: Effect<Z, E, R>, f: (z: NoInfer<Z>, a: Effect.Success<Eff>, i: number) => Z, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): (elements: Iterable<Eff>) => Effect<Z, E | Effect.Error<Eff>, R | Effect.Context<Eff>>; <Eff extends Effect<any, any, any>, Z, E, R>(elements: Iterable<Eff>, zero: Effect<Z, E, R>, f: (z: NoInfer<Z>, a: Effect.Success<Eff>, i: number) => Z, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): Effect<Z, E | Effect.Error<Eff>, R | Effect.Context<Eff>>; }

----------------------------------------

TITLE: Creating Fixed-Length Arrays with Array.allocate in TypeScript
DESCRIPTION: Creates a new Array of a specified length with all elements initialized as undefined. The function is generic and can be typed to indicate the eventual type of array elements.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const result = Array.allocate<number>(3)
console.log(result) // [ <3 empty items> ]

LANGUAGE: typescript
CODE:
declare const allocate: <A = never>(n: number) => Array<A | undefined>

----------------------------------------

TITLE: Using every() Function for Boolean Collection Validation in TypeScript
DESCRIPTION: This snippet demonstrates the usage of the 'every' function from the Boolean module in the Effect package. It checks if all elements in an array of boolean values are true.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { every } from "effect/Boolean"

assert.deepStrictEqual(every([true, true, true]), true)
assert.deepStrictEqual(every([true, false, true]), false)

----------------------------------------

TITLE: Type Signature for Doc.hang in TypeScript
DESCRIPTION: Type declaration for the hang combinator showing its function signatures. It can be used both in curried and uncurried forms, taking an indent number and a Doc<A> as parameters.

LANGUAGE: typescript
CODE:
declare const hang: { (indent: number): <A>(self: Doc<A>) => Doc<A>; <A>(self: Doc<A>, indent: number): Doc<A>; }

----------------------------------------

TITLE: Implementing Range-Based Tree Traversal in TypeScript
DESCRIPTION: Function signature for traversing RedBlackTree nodes with keys in a specified range. Takes min and max bounds and a callback function to execute on each node's key-value pair. Supports both curried and direct invocation patterns.

LANGUAGE: typescript
CODE:
declare const forEachBetween: {
  <K, V>(options: {
    readonly min: K;
    readonly max: K;
    readonly body: (key: K, value: V) => void;
  }): (self: RedBlackTree<K, V>) => void;
  <K, V>(
    self: RedBlackTree<K, V>,
    options: {
      readonly min: K;
      readonly max: K;
      readonly body: (key: K, value: V) => void;
    }
  ): void;
}

----------------------------------------

TITLE: Defining failCauseSync Function in Effect Module (TypeScript)
DESCRIPTION: Creates an Effect that fails with a specified Cause, evaluated lazily. The function takes a LazyArg of Cause<E> and returns an Effect that never succeeds but may fail with error type E.

LANGUAGE: typescript
CODE:
declare const failCauseSync: <E>(evaluate: LazyArg<Cause.Cause<E>>) => Effect<never, E>

----------------------------------------

TITLE: Checking Interruption Status in Effect Cause Module
DESCRIPTION: A utility function that checks if a Cause contains any fiber interruptions. Takes a Cause<E> as input and returns a boolean indicating whether the cause includes interruptions.

LANGUAGE: typescript
CODE:
declare const isInterrupted: <E>(self: Cause<E>) => boolean

----------------------------------------

TITLE: Projecting Layer Services in TypeScript Effect Library
DESCRIPTION: Defines a function that projects services from one layer to another using transformation functions. Takes source and target context tags along with a transformation function to map between service types.

LANGUAGE: typescript
CODE:
declare const project: {
  <I1, S1, I2, S2>(
    tagA: Context.Tag<I1, S1>,
    tagB: Context.Tag<I2, S2>,
    f: (a: Types.NoInfer<S1>) => Types.NoInfer<S2>
  ): <RIn, E>(self: Layer<I1, E, RIn>) => Layer<I2, E, RIn>;
  <RIn, E, I1, S1, I2, S2>(
    self: Layer<I1, E, RIn>,
    tagA: Context.Tag<I1, S1>,
    tagB: Context.Tag<I2, S2>,
    f: (a: Types.NoInfer<S1>) => Types.NoInfer<S2>
  ): Layer<I2, E, RIn>;
}

----------------------------------------

TITLE: Converting Stream to Queue Elements in TypeScript
DESCRIPTION: Function that transforms a stream into a scoped queue of elements with optional capacity configuration. The queue stops producing values after the scope closes. Default capacity is 2.

LANGUAGE: typescript
CODE:
declare const toQueueOfElements: { 
  (options?: { readonly capacity?: number | undefined; } | undefined): 
    <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<Queue.Dequeue<Exit.Exit<A, Option.Option<E>>>, never, Scope.Scope | R>; 
  <A, E, R>(self: Stream<A, E, R>, options?: { readonly capacity?: number | undefined; } | undefined): 
    Effect.Effect<Queue.Dequeue<Exit.Exit<A, Option.Option<E>>>, never, Scope.Scope | R>; 
}

----------------------------------------

TITLE: Declaring Fiber.status Function in TypeScript
DESCRIPTION: Defines the status function that returns the FiberStatus of a RuntimeFiber. It takes a RuntimeFiber as input and returns an Effect containing the FiberStatus.

LANGUAGE: typescript
CODE:
declare const status: <A, E>(self: RuntimeFiber<A, E>) => Effect.Effect<FiberStatus.FiberStatus>

----------------------------------------

TITLE: Setting Fibers in FiberMap with TypeScript
DESCRIPTION: Adds a fiber to the FiberMap with automatic removal upon completion. Supports optional configuration for handling existing fibers and interruption propagation. Takes a key, fiber instance, and optional configuration object as parameters.

LANGUAGE: typescript
CODE:
declare const set: {
  <K, A, E, XE extends E, XA extends A>(
    key: K,
    fiber: Fiber.RuntimeFiber<XA, XE>,
    options?: {
      readonly onlyIfMissing?: boolean | undefined;
      readonly propagateInterruption?: boolean | undefined;
    } | undefined
  ): (self: FiberMap<K, A, E>) => Effect.Effect<void>;
  <K, A, E, XE extends E, XA extends A>(
    self: FiberMap<K, A, E>,
    key: K,
    fiber: Fiber.RuntimeFiber<XA, XE>,
    options?: {
      readonly onlyIfMissing?: boolean | undefined;
      readonly propagateInterruption?: boolean | undefined;
    } | undefined
  ): Effect.Effect<void>;
}

----------------------------------------

TITLE: Running Micro Effects with Delay Example
DESCRIPTION: Demonstrates how to execute a Micro effect with a delay and add an observer to handle the result. The example creates a successful effect with value 42, adds a 1 second delay, and logs the exit value.

LANGUAGE: typescript
CODE:
import * as Micro from "effect/Micro"

const handle = Micro.succeed(42).pipe(
  Micro.delay(1000),
  Micro.runFork
)

handle.addObserver((exit) => {
  console.log(exit)
})

----------------------------------------

TITLE: Adding dotenv ConfigProvider in TypeScript using @effect/platform
DESCRIPTION: The layerDotEnv function adds a dotenv ConfigProvider to the environment, replacing the current ConfigProvider. It takes a path string as an argument and returns a Layer that requires FileSystem and may result in a PlatformError.

LANGUAGE: typescript
CODE:
declare const layerDotEnv: (path: string) => Layer.Layer<never, PlatformError, FileSystem.FileSystem>

----------------------------------------

TITLE: Creating Custom Request Class with Effect Framework
DESCRIPTION: Example showing how to extend the Request.Class to create a custom request type with Success type as string, Error type as never, and an additional id property.

LANGUAGE: typescript
CODE:
import { Request } from "effect"

type Success = string
type Error = never

class MyRequest extends Request.Class<Success, Error, {
  readonly id: string
}> {}

----------------------------------------

TITLE: Effect.checkInterruptible Function Signature in TypeScript
DESCRIPTION: Provides the TypeScript signature for the Effect.checkInterruptible function, showing its parameter and return types.

LANGUAGE: typescript
CODE:
declare const checkInterruptible: <A, E, R>(f: (isInterruptible: boolean) => Effect<A, E, R>) => Effect<A, E, R>

----------------------------------------

TITLE: Retrieving Current Fiber in Effect TypeScript
DESCRIPTION: Function that returns an Option containing the currently executing RuntimeFiber if one exists. The fiber can contain any type of value or error as indicated by the generic type parameters.

LANGUAGE: typescript
CODE:
declare const getCurrentFiber: () => Option.Option<RuntimeFiber<any, any>>

----------------------------------------

TITLE: TypeScript Signature for Doc.nesting Function
DESCRIPTION: This code snippet shows the TypeScript signature of the Doc.nesting function. It takes a function that receives the current nesting level and returns a Doc<A>.

LANGUAGE: typescript
CODE:
declare const nesting: <A>(react: (level: number) => Doc<A>) => Doc<A>

----------------------------------------

TITLE: TypeScript Function Signature for Effect.whenEffect
DESCRIPTION: Provides the TypeScript function signature for Effect.whenEffect, showing its type parameters and return type. This signature represents the function's polymorphic nature and its ability to work with different effect types.

LANGUAGE: typescript
CODE:
declare const whenEffect: { <E, R>(condition: Effect<boolean, E, R>): <A, E2, R2>(effect: Effect<A, E2, R2>) => Effect<Option.Option<A>, E | E2, R | R2>; <A, E2, R2, E, R>(self: Effect<A, E2, R2>, condition: Effect<boolean, E, R>): Effect<Option.Option<A>, E2 | E, R2 | R>; }

----------------------------------------

TITLE: Implementing Custom Timeout Error Handling with Effect.timeoutFail
DESCRIPTION: Demonstrates how to use timeoutFail to implement custom timeout handling in an Effect operation. The example shows creating a task with a sleep delay and applying a custom timeout error if the task exceeds 1 second duration.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

const task = Effect.gen(function* () {
  console.log("Start processing...")
  yield* Effect.sleep("2 seconds") // Simulates a delay in processing
  console.log("Processing complete.")
  return "Result"
})

class MyTimeoutError {
  readonly _tag = "MyTimeoutError"
}

const program = task.pipe(
  Effect.timeoutFail({
    duration: "1 second",
    onTimeout: () => new MyTimeoutError() // Custom timeout error
  })
)

Effect.runPromiseExit(program).then(console.log)

----------------------------------------

TITLE: Using Stream.zipLatest with Scheduled Streams in TypeScript
DESCRIPTION: Demonstrates how to combine two streams using zipLatest, where elements are emitted at different intervals. The first stream emits numbers every second, while the second stream emits letters every 500 milliseconds. The result combines the latest values from both streams.

LANGUAGE: typescript
CODE:
import { Effect, Schedule, Stream } from "effect"

const s1 = Stream.make(1, 2, 3).pipe(
  Stream.schedule(Schedule.spaced("1 second"))
)

const s2 = Stream.make("a", "b", "c", "d").pipe(
  Stream.schedule(Schedule.spaced("500 millis"))
)

const stream = Stream.zipLatest(s1, s2)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: "Chunk", values: [ [ 1, "a" ], [ 1, "b" ], [ 2, "b" ], [ 2, "c" ], [ 2, "d" ], [ 3, "d" ] ] }

----------------------------------------

TITLE: Defining emitCollect Function for Channel in TypeScript
DESCRIPTION: This snippet defines the emitCollect function for the Channel module. It creates a new channel that collects the output and terminal value of an existing channel, then writes them as output of the returned channel.

LANGUAGE: typescript
CODE:
declare const emitCollect: <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<[Chunk.Chunk<OutElem>, OutDone], InElem, OutErr, InErr, void, InDone, Env>

----------------------------------------

TITLE: Effect.Do Signature in TypeScript
DESCRIPTION: The signature of the Effect.Do constant, which returns an Effect with an empty object type, never as the error type, and never as the value type.

LANGUAGE: typescript
CODE:
declare const Do: Effect<{}, never, never>

----------------------------------------

TITLE: Retrieving Random Service in Effect Module (TypeScript)
DESCRIPTION: This snippet defines the random constant in the Effect module. It retrieves the Random service from the context, returning an Effect with Random.Random as its environment and never for both error and value types.

LANGUAGE: typescript
CODE:
declare const random: Effect<Random.Random, never, never>

----------------------------------------

TITLE: Effect.forkScoped Type Definition
DESCRIPTION: TypeScript type signature for the forkScoped function, showing its generic parameters and return type. The function takes an Effect and returns a new Effect that produces a RuntimeFiber within a Scope context.

LANGUAGE: typescript
CODE:
declare const forkScoped: <A, E, R>(self: Effect<A, E, R>) => Effect<Fiber.RuntimeFiber<A, E>, never, Scope.Scope | R>

----------------------------------------

TITLE: Declaring Doc.equalSign Constant in TypeScript
DESCRIPTION: This snippet declares a constant named equalSign of type Doc<never>. It represents a document containing a single '=' character in the @effect/printer package.

LANGUAGE: typescript
CODE:
declare const equalSign: Doc<never>

----------------------------------------

TITLE: Defining Exit Type in TypeScript for Effect Workflows
DESCRIPTION: Defines a union type Exit<A,E> that represents the result of executing an Effect workflow. The type can either be Exit.Success containing a value of type A, or Exit.Failure containing a Cause of type E.

LANGUAGE: typescript
CODE:
type Exit<A, E> = Success<A, E> | Failure<A, E>

----------------------------------------

TITLE: Defining Invariant Type Helper in TypeScript
DESCRIPTION: Defines an Invariant type helper that takes a type parameter A and returns a function type that accepts and returns the same type. This is useful for type-level programming and ensuring type invariance.

LANGUAGE: typescript
CODE:
type Invariant<A> = (_: A) => A

----------------------------------------

TITLE: Implementing Error Transformation with Cause.flatMap in TypeScript
DESCRIPTION: The Cause.flatMap function transforms errors in a Cause into new causes. It applies a function to each Fail error, converting it into a new Cause. This is useful for merging or restructuring error types while preserving or combining cause information.

LANGUAGE: typescript
CODE:
declare const flatMap: { <E, E2>(f: (e: E) => Cause<E2>): (self: Cause<E>) => Cause<E2>; <E, E2>(self: Cause<E>, f: (e: E) => Cause<E2>): Cause<E2>; }

----------------------------------------

TITLE: Mapping Effect Success Value to Void in TypeScript
DESCRIPTION: A function that transforms an Effect<A, E, R> to Effect<void, E, R> by mapping the success value to void while maintaining the same error handling behavior. The function preserves the error type E and environment type R from the original Effect.

LANGUAGE: typescript
CODE:
declare const asVoid: <A, E, R>(self: Effect<A, E, R>) => Effect<void, E, R>

----------------------------------------

TITLE: Formatting DateTime Objects with DateTimeFormat API in TypeScript
DESCRIPTION: Implementation of a DateTime formatting function that uses Intl.DateTimeFormatOptions for string conversion. Handles timezone offsets and includes special behavior for Node versions below 22 where fixed 'Offset' zones default to 'UTC' with adjusted dates.

LANGUAGE: typescript
CODE:
declare const format: { 
  (options?: (Intl.DateTimeFormatOptions & { readonly locale?: string | undefined; }) | undefined): (self: DateTime) => string; 
  (self: DateTime, options?: (Intl.DateTimeFormatOptions & { readonly locale?: string | undefined; }) | undefined): string; 
}

----------------------------------------

TITLE: Creating Branded Integer Type with Validation in TypeScript
DESCRIPTION: Demonstrates how to use Brand.refined to create a branded integer type with validation. It includes an example of successful creation and an assertion to check for invalid input.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Brand } from "effect"

type Int = number & Brand.Brand<"Int">

const Int = Brand.refined<Int>(
  (n) => Number.isInteger(n),
  (n) => Brand.error(`Expected ${n} to be an integer`)
)

console.log(Int(1))
// 1

assert.throws(() => Int(1.1))

----------------------------------------

TITLE: Concurrent Effect Combination with TypeScript Effect Library
DESCRIPTION: Shows how to combine two effects concurrently using Effect.zip with the concurrent option. The example demonstrates improved performance when effects can be executed independently.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

const task1 = Effect.succeed(1).pipe(
  Effect.delay("200 millis"),
  Effect.tap(Effect.log("task1 done"))
)
const task2 = Effect.succeed("hello").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Effect.log("task2 done"))
)

// Run both effects concurrently using the concurrent option
const program = Effect.zip(task1, task2, { concurrent: true })

Effect.runPromise(program).then(console.log)
// Output:
// timestamp=... level=INFO fiber=#0 message="task2 done"
// timestamp=... level=INFO fiber=#0 message="task1 done"
// [ 1, 'hello' ]

----------------------------------------

TITLE: Implementing Cron Schedule in TypeScript
DESCRIPTION: Defines a function that creates a schedule recurring based on a cron expression. The schedule executes at intervals defined by the cron expression and produces timestamps for the start and end of each cron window. The cron expression validation is performed lazily during execution.

LANGUAGE: typescript
CODE:
declare const cron: { 
  (cron: Cron.Cron): Schedule<[number, number]>; 
  (expression: string, tz?: DateTime.TimeZone | string): Schedule<[number, number]>; 
}

----------------------------------------

TITLE: Creating an Empty Option in TypeScript using Effect
DESCRIPTION: Demonstrates how to create an Option with no value using Option.none() from the Effect package. The resulting Option<never> can be used in place of any Option<A> regardless of the type A.

LANGUAGE: typescript
CODE:
import { Option } from "effect"

// An Option holding no value
//
//      ┌─── Option<never>
//      ▼
const noValue = Option.none()

console.log(noValue)
// Output: { _id: 'Option', _tag: 'None' }

LANGUAGE: typescript
CODE:
declare const none: <A = never>() => Option<A>

----------------------------------------

TITLE: TypeScript Function Signature for Stream.interleave
DESCRIPTION: Provides the TypeScript function signature for the Stream.interleave function. It shows the function's polymorphic nature, accepting streams with different element types, error types, and environment requirements.

LANGUAGE: typescript
CODE:
declare const interleave: { <A2, E2, R2>(that: Stream<A2, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>): Stream<A | A2, E | E2, R | R2>; }

----------------------------------------

TITLE: Discarding Results with Effect.forEach in TypeScript
DESCRIPTION: This example shows how to use Effect.forEach with the discard option set to true, applying effects to each element of an iterable without collecting the results.

LANGUAGE: typescript
CODE:
import { Effect, Console } from "effect"

// Apply effects but discard the results
const result = Effect.forEach(
  [1, 2, 3, 4, 5],
  (n, index) =>
    Console.log(`Currently at index ${index}`).pipe(Effect.as(n * 2)),
  { discard: true }
)

Effect.runPromise(result).then(console.log)
// Output:
// Currently at index 0
// Currently at index 1
// Currently at index 2
// Currently at index 3
// Currently at index 4
// undefined

----------------------------------------

TITLE: Implementing Array.span Function in TypeScript
DESCRIPTION: Defines a span function that splits an Iterable into two parts based on a predicate or refinement function. The first array contains elements that satisfy the condition, while the second contains the remaining elements. The function supports both regular predicates and type refinements.

LANGUAGE: typescript
CODE:
declare const span: {
  <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => [init: Array<B>, rest: Array<Exclude<A, B>>];
  <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => [init: Array<A>, rest: Array<A>];
  <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): [init: Array<B>, rest: Array<Exclude<A, B>>];
  <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): [init: Array<A>, rest: Array<A>];
}

----------------------------------------

TITLE: Retrieving Console Service Using Effect.consoleWith
DESCRIPTION: A TypeScript function that retrieves the Console service from the context and provides it to a specified effectful function. The function is generic over the effect's success type A, error type E, and requirement type R.

LANGUAGE: typescript
CODE:
declare const consoleWith: <A, E, R>(f: (console: Console) => Effect<A, E, R>) => Effect<A, E, R>

----------------------------------------

TITLE: Defining StringFromHex Schema Type in TypeScript
DESCRIPTION: Defines a Schema type that handles conversion from hex-encoded strings to UTF-8 strings. The Schema type signature indicates it takes a string input (hex), produces a string output (UTF-8), and never produces runtime errors.

LANGUAGE: typescript
CODE:
declare const StringFromHex: Schema<string, string, never>

----------------------------------------

TITLE: Defining 'never' Sink in TypeScript for Effect Library
DESCRIPTION: Declares a constant 'never' of type Sink that represents a sink which never terminates. This sink has 'never' types for its error, input, and output, indicating it doesn't produce any values or errors.

LANGUAGE: typescript
CODE:
declare const never: Sink<never, unknown, never, never, never>

----------------------------------------

TITLE: Defining cursorPrevLine Function for Cursor Movement in TypeScript
DESCRIPTION: This function moves the cursor to the beginning of the line a specified number of rows up (default 1). It returns an AnsiDoc object, allowing for method chaining in ANSI terminal operations.

LANGUAGE: typescript
CODE:
declare const cursorPrevLine: (rows?: number) => AnsiDoc

----------------------------------------

TITLE: Using headNonEmpty Function in TypeScript with Effect Array Module
DESCRIPTION: This snippet demonstrates how to use the headNonEmpty function from the Array module in the Effect package. It retrieves the first element of a non-empty array.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const result = Array.headNonEmpty([1, 2, 3, 4])
console.log(result) // 1

----------------------------------------

TITLE: Converting Layer to Runtime with MemoMap in TypeScript
DESCRIPTION: The toRuntimeWithMemoMap function converts a layer that requires no services into a scoped runtime. This runtime can be used to execute effects. It takes a MemoMap as an argument and returns an Effect that produces a Runtime.

LANGUAGE: typescript
CODE:
declare const toRuntimeWithMemoMap: { (memoMap: MemoMap): <RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Effect.Effect<Runtime.Runtime<ROut>, E, Scope.Scope | RIn>; <RIn, E, ROut>(self: Layer<ROut, E, RIn>, memoMap: MemoMap): Effect.Effect<Runtime.Runtime<ROut>, E, Scope.Scope | RIn>; }

----------------------------------------

TITLE: Implementing Document Concatenation with Doc.cat in TypeScript
DESCRIPTION: The cat combinator function declaration that allows concatenating two Doc objects together without any separator between them. It supports both curried and uncurried calling styles with generic type parameters.

LANGUAGE: typescript
CODE:
declare const cat: { <B>(that: Doc<B>): <A>(self: Doc<A>) => Doc<B | A>; <A, B>(self: Doc<A>, that: Doc<B>): Doc<A | B>; }

----------------------------------------

TITLE: Using withConcurrency with Micro Effects in TypeScript
DESCRIPTION: Demonstrates how to control the concurrency level of a Micro effect that inherits concurrency settings. The example shows processing an array of numbers with a specified concurrency of 2.

LANGUAGE: typescript
CODE:
import * as Micro from "effect/Micro"

Micro.forEach([1, 2, 3], (n) => Micro.succeed(n), {
  concurrency: "inherit"
}).pipe(
  Micro.withConcurrency(2) // use a concurrency of 2
)

LANGUAGE: typescript
CODE:
declare const withConcurrency: { (concurrency: "unbounded" | number): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E, R>; <A, E, R>(self: Micro<A, E, R>, concurrency: "unbounded" | number): Micro<A, E, R>; }

----------------------------------------

TITLE: Implementing take Operation for Chunk in TypeScript
DESCRIPTION: Function signature for taking the first n elements from a Chunk. Supports both curried and non-curried function calls, allowing for flexible usage patterns when extracting elements from a Chunk data structure.

LANGUAGE: typescript
CODE:
declare const take: { (n: number): <A>(self: Chunk<A>) => Chunk<A>; <A>(self: Chunk<A>, n: number): Chunk<A>; }

----------------------------------------

TITLE: Checking FiberStatus Completion in TypeScript
DESCRIPTION: The isDone function is a type guard that determines if a given FiberStatus is in the Done state. It takes a FiberStatus object as input and returns a boolean indicating whether the status is Done. This function is useful for checking the completion status of fibers in effect-based applications.

LANGUAGE: typescript
CODE:
declare const isDone: (self: FiberStatus) => self is Done

----------------------------------------

TITLE: Implementing Channel Interruption with Deferred Values in TypeScript
DESCRIPTION: Defines a function that creates a new channel which can be interrupted based on a deferred value completion. The channel will either yield the deferred value if completed first, or the underlying channel's value if it completes before interruption.

LANGUAGE: typescript
CODE:
declare const interruptWhenDeferred: { 
  <OutDone1, OutErr1>(
    deferred: Deferred.Deferred<OutDone1, OutErr1>
  ): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>
  ) => Channel<OutElem, InElem, OutErr1 | OutErr, InErr, OutDone1 | OutDone, InDone, Env>; 
  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutDone1, OutErr1>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, 
    deferred: Deferred.Deferred<OutDone1, OutErr1>
  ): Channel<OutElem, InElem, OutErr | OutErr1, InErr, OutDone | OutDone1, InDone, Env>; 
}

----------------------------------------

TITLE: Type Signature of isDate Function in TypeScript
DESCRIPTION: Provides the TypeScript type signature for the isDate function, showing that it takes an unknown input and returns a type predicate indicating if the input is a Date.

LANGUAGE: typescript
CODE:
declare const isDate: (input: unknown) => input is Date

----------------------------------------

TITLE: Declaring Effect.none Function in TypeScript
DESCRIPTION: This code snippet declares the Effect.none function, which takes an Effect<Option<A>, E, R> and returns an Effect<void, E | Cause.NoSuchElementException, R>. It ensures the Option is None, returning void, or raises a NoSuchElementException if the Option contains a value.

LANGUAGE: typescript
CODE:
declare const none: <A, E, R>(self: Effect<Option.Option<A>, E, R>) => Effect<void, E | Cause.NoSuchElementException, R>

----------------------------------------

TITLE: Defining Doc.Text Interface in TypeScript for @effect/printer
DESCRIPTION: This code snippet defines the Doc.Text interface, which represents a document containing a string of text. It extends Doc.Variance<A> and includes a _tag property of 'Text' and a text property of type string. The interface has invariants specifying that the text cannot be less than two characters long and cannot contain a newline character.

LANGUAGE: typescript
CODE:
export interface Text<A> extends Doc.Variance<A> {
  readonly _tag: "Text"
  readonly text: string
}

----------------------------------------

TITLE: Defining Covariant Type in TypeScript
DESCRIPTION: Defines a Covariant helper type that takes a type parameter A and returns a function type from never to A. This is used for type-level covariance.

LANGUAGE: typescript
CODE:
type Covariant<A> = (_: never) => A

----------------------------------------

TITLE: Declaring succeedNone Function in TypeScript
DESCRIPTION: This code snippet declares the succeedNone function, which returns an effect that succeeds with None. It's used to represent the absence of a value, particularly when working with optional data.

LANGUAGE: typescript
CODE:
declare const succeedNone: Effect<Option.Option<never>, never, never>

----------------------------------------

TITLE: Creating Failing Take with Cause - TypeScript
DESCRIPTION: Function signature for creating a failing Take instance with a specified cause. The function takes a Cause parameter of type E and returns a Take that never succeeds but fails with error type E.

LANGUAGE: typescript
CODE:
declare const failCause: <E>(cause: Cause.Cause<E>) => Take<never, E>

----------------------------------------

TITLE: Demonstrating Array Binding in TypeScript using Effect Library
DESCRIPTION: This snippet shows how to use Array.bind to create a new array by iterating over existing arrays and applying conditions and transformations. It demonstrates the 'do simulation' technique and compares it to an equivalent nested loop approach.

LANGUAGE: typescript
CODE:
import { Array, pipe } from "effect"

const doResult = pipe(
  Array.Do,
  Array.bind("x", () => [1, 3, 5]),
  Array.bind("y", () => [2, 4, 6]),
  Array.filter(({ x, y }) => x < y), // condition
  Array.map(({ x, y }) => [x, y] as const) // transformation
)
console.log(doResult) // [[1, 2], [1, 4], [1, 6], [3, 4], [3, 6], [5, 6]]

// equivalent
const x = [1, 3, 5],
      y = [2, 4, 6],
      result = [];
for(let i = 0; i < x.length; i++) {
  for(let j = 0; j < y.length; j++) {
    const _x = x[i], _y = y[j];
    if(_x < _y) result.push([_x, _y] as const)
  }
}

----------------------------------------

TITLE: Partitioning a Stream with an Effectful Predicate in TypeScript
DESCRIPTION: This example demonstrates how to use Stream.partitionEither to divide a stream of numbers into even and odd substreams. It uses an effectful predicate to determine which substream each number belongs to, and then collects and logs the results.

LANGUAGE: typescript
CODE:
import { Effect, Either, Stream } from "effect"

const partition = Stream.range(1, 9).pipe(
  Stream.partitionEither(
    (n) => Effect.succeed(n % 2 === 0 ? Either.right(n) : Either.left(n)),
    { bufferSize: 5 }
  )
)

const program = Effect.scoped(
  Effect.gen(function*() {
    const [evens, odds] = yield* partition
    console.log(yield* Stream.runCollect(evens))
    console.log(yield* Stream.runCollect(odds))
  })
)

Effect.runPromise(program)
// { _id: 'Chunk', values: [ 1, 3, 5, 7, 9 ] }
// { _id: 'Chunk', values: [ 2, 4, 6, 8 ] }

----------------------------------------

TITLE: Checking for Nil List in TypeScript
DESCRIPTION: The isNil function determines if a given List<A> is of type Nil<A>. It returns true if the list is Nil, and false otherwise. This function is useful for type checking and handling empty lists.

LANGUAGE: typescript
CODE:
declare const isNil: <A>(self: List<A>) => self is Nil<A>

----------------------------------------

TITLE: Creating Spans in Effect Layer
DESCRIPTION: Function to create and add a span to the current span stack within the Effect Layer system. The span automatically ends when the Layer is released. Takes a name parameter and optional configuration including span options and an onEnd callback.

LANGUAGE: typescript
CODE:
declare const span: (name: string, options?: Tracer.SpanOptions & { readonly onEnd?: ((span: Tracer.Span, exit: Exit.Exit<unknown, unknown>) => Effect.Effect<void>) | undefined; }) => Layer<Tracer.ParentSpan>

----------------------------------------

TITLE: Implementing Retry Function for Micro Effects in TypeScript
DESCRIPTION: Defines a retry function that accepts options for controlling retry behavior including a predicate for continuation, number of attempts, and scheduling configuration. The function can be used either as a standalone operator or directly with a Micro effect instance.

LANGUAGE: typescript
CODE:
declare const retry: {
  <A, E>(options?: {
    while?: Predicate<E> | undefined;
    times?: number | undefined;
    schedule?: MicroSchedule | undefined;
  } | undefined): <R>(self: Micro<A, E, R>) => Micro<A, E, R>;
  <A, E, R>(self: Micro<A, E, R>, options?: {
    while?: Predicate<E> | undefined;
    times?: number | undefined;
    schedule?: MicroSchedule | undefined;
  } | undefined): Micro<A, E, R>;
}

----------------------------------------

TITLE: Defining getSemigroup Function for SemiApplicative in TypeScript
DESCRIPTION: This function lifts a Semigroup into a higher-kinded type F. It takes a SemiApplicative instance and returns a function that creates a Semigroup for the lifted type. The inner values are combined using the provided Semigroup.

LANGUAGE: typescript
CODE:
declare const getSemigroup: <F extends TypeLambda>(F: SemiApplicative<F>) => <A, R, O, E>(S: Semigroup<A>) => Semigroup<Kind<F, R, O, E, A>>

----------------------------------------

TITLE: Array.window Function Signature in TypeScript
DESCRIPTION: Provides the TypeScript signature for the Array.window function. It shows that the function can be called with the size parameter first or the iterable first, allowing for flexible usage.

LANGUAGE: typescript
CODE:
declare const window: { (n: number): <A>(self: Iterable<A>) => Array<Array<A>>; <A>(self: Iterable<A>, n: number): Array<Array<A>>; }

----------------------------------------

TITLE: Type Signature for Array.prependAll in TypeScript
DESCRIPTION: Provides the detailed type signature for the Array.prependAll function. It includes overloads for different combinations of input types, including Iterable, NonEmptyReadonlyArray, and their combinations.

LANGUAGE: typescript
CODE:
declare const prependAll: { <S extends Iterable<any>, T extends Iterable<any>>(that: T): (self: S) => ReadonlyArray.OrNonEmpty<S, T, ReadonlyArray.Infer<S> | ReadonlyArray.Infer<T>>; <A, B>(self: Iterable<A>, that: NonEmptyReadonlyArray<B>): NonEmptyArray<A | B>; <A, B>(self: NonEmptyReadonlyArray<A>, that: Iterable<B>): NonEmptyArray<A | B>; <A, B>(self: Iterable<A>, that: Iterable<B>): Array<A | B>; }

----------------------------------------

TITLE: Filtering Log Levels in Effect Logger Module (TypeScript)
DESCRIPTION: The filterLogLevel function returns a modified version of a logger that only logs messages when the log level satisfies a specified predicate. It can be used in two ways: as a higher-order function or with the logger as the first argument.

LANGUAGE: typescript
CODE:
declare const filterLogLevel: { (f: (logLevel: LogLevel.LogLevel) => boolean): <Message, Output>(self: Logger<Message, Output>) => Logger<Message, Option.Option<Output>>; <Message, Output>(self: Logger<Message, Output>, f: (logLevel: LogLevel.LogLevel) => boolean): Logger<Message, Option.Option<Output>>; }

----------------------------------------

TITLE: Using Doc.softLineBreak in TypeScript
DESCRIPTION: Demonstrates the usage of Doc.softLineBreak in different page width scenarios. It shows how softLineBreak behaves like 'empty' when the output doesn't fit the page, as opposed to 'space'.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import * as String from "effect/String"

const doc: Doc.Doc<never> = Doc.hcat([
  Doc.text("ThisText"),
  Doc.softLineBreak,
  Doc.text("IsWayTooLong")
])

// With enough space, we get direct concatenation of documents:
assert.strictEqual(
  Doc.render(doc, {
    style: "pretty",
    options: { lineWidth: 80 }
  }),
  "ThisTextIsWayTooLong"
)

// If the page width is narrowed to `10`, the layout algorithm will
// introduce a line break
assert.strictEqual(
  Doc.render(Doc.group(doc), {
    style: "pretty",
    options: { lineWidth: 10 }
  }),
  String.stripMargin(
    `|ThisText
     |IsWayTooLong`
  )
)

----------------------------------------

TITLE: Array.modifyNonEmptyHead Type Signature
DESCRIPTION: Type signature for the modifyNonEmptyHead function showing its polymorphic nature and support for both curried and uncurried calling styles. The function works with NonEmptyReadonlyArray type and returns a NonEmptyArray.

LANGUAGE: typescript
CODE:
declare const modifyNonEmptyHead: { <A, B>(f: (a: A) => B): (self: NonEmptyReadonlyArray<A>) => NonEmptyArray<A | B>; <A, B>(self: NonEmptyReadonlyArray<A>, f: (a: A) => B): NonEmptyArray<A | B>; }

----------------------------------------

TITLE: Implementing Custom Stack Tracing with Effect.custom in TypeScript
DESCRIPTION: Demonstrates how to use Effect.custom to create a custom effect with a throwing function. The custom effect wraps the throwing function in an Effect.succeed operation.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

const throwingFunction = () => { throw new Error() }
const blowUp = Effect.custom(throwingFunction, function() {
  return Effect.succeed(this.effect_instruction_i0())
})

----------------------------------------

TITLE: Retrieving Cached Value from Resource in TypeScript
DESCRIPTION: The Resource.get function retrieves the current value stored in the cache. It takes a Resource<A, E> as input and returns an Effect.Effect<A, E>.

LANGUAGE: typescript
CODE:
declare const get: <A, E>(self: Resource<A, E>) => Effect.Effect<A, E>

----------------------------------------

TITLE: Converting Numbers to BigDecimal in TypeScript
DESCRIPTION: Demonstrates how to convert JavaScript numbers to BigDecimal values using the unsafeFromNumber function. The function handles both integer and decimal values, automatically determining the appropriate scale for decimal numbers. Throws RangeError for non-finite numbers.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { unsafeFromNumber, make } from "effect/BigDecimal"

assert.deepStrictEqual(unsafeFromNumber(123), make(123n, 0))
assert.deepStrictEqual(unsafeFromNumber(123.456), make(123456n, 3))

LANGUAGE: typescript
CODE:
declare const unsafeFromNumber: (n: number) => BigDecimal

----------------------------------------

TITLE: Using transformLiteral in Effect Schema
DESCRIPTION: This example demonstrates how to use the transformLiteral function to create a Schema that transforms a literal value from 0 to 'a'. It includes importing necessary modules, creating the schema, and asserting the expected transformation result.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import * as S from "effect/Schema"

const schema = S.transformLiteral(0, "a")

assert.deepStrictEqual(S.decodeSync(schema)(0), "a")

----------------------------------------

TITLE: Dividing BigInts with Effect Library
DESCRIPTION: Demonstrates how to perform division operations on BigInt values using the Effect library's BigInt module. Returns Some(result) for valid divisions and None for division by zero.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { BigInt, Option } from "effect"

assert.deepStrictEqual(BigInt.divide(6n, 3n), Option.some(2n))
assert.deepStrictEqual(BigInt.divide(6n, 0n), Option.none())

LANGUAGE: typescript
CODE:
declare const divide: { (that: bigint): (self: bigint) => Option.Option<bigint>; (self: bigint, that: bigint): Option.Option<bigint>; }

----------------------------------------

TITLE: Defining findFirst Function in TypeScript for Chunk Module
DESCRIPTION: Declares the findFirst function which returns the first element satisfying a predicate or refinement in a Chunk. It supports both refinement and predicate operations, returning an Option type.

LANGUAGE: typescript
CODE:
declare const findFirst: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: Chunk<A>) => Option<B>; <A>(predicate: Predicate<NoInfer<A>>): (self: Chunk<A>) => Option<A>; <A, B extends A>(self: Chunk<A>, refinement: Refinement<A, B>): Option<B>; <A>(self: Chunk<A>, predicate: Predicate<A>): Option<A>; }

----------------------------------------

TITLE: Implementing Conditional Effect Execution in TypeScript
DESCRIPTION: Defines a function that conditionally executes an effect based on the result of another effect. Returns an Option type containing the result if the condition is false, otherwise returns None. Supports both curried and uncurried function signatures.

LANGUAGE: typescript
CODE:
declare const unlessEffect: {
  <E2, R2>(condition: Effect<boolean, E2, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<Option.Option<A>, E2 | E, R2 | R>;
  <A, E, R, E2, R2>(self: Effect<A, E, R>, condition: Effect<boolean, E2, R2>): Effect<Option.Option<A>, E | E2, R | R2>;
}

----------------------------------------

TITLE: Implementing Array Search with TArray.findFirst in TypeScript
DESCRIPTION: This snippet defines the findFirst function in the TArray module. It allows searching for the first element in an array that matches a specified predicate. The function returns an STM (Software Transactional Memory) operation that resolves to an Option containing the found element, if any.

LANGUAGE: typescript
CODE:
declare const findFirst: { <A>(predicate: Predicate<A>): (self: TArray<A>) => STM.STM<Option.Option<A>>; <A>(self: TArray<A>, predicate: Predicate<A>): STM.STM<Option.Option<A>>; }

----------------------------------------

TITLE: TypeScript Signature for Array.unzip in Effect Library
DESCRIPTION: Provides the TypeScript signature for the Array.unzip function. It shows the function's type constraints and return types based on the input Iterable.

LANGUAGE: typescript
CODE:
declare const unzip: <S extends Iterable<readonly [any, any]>>(self: S) => S extends NonEmptyReadonlyArray<readonly [infer A, infer B]> ? [NonEmptyArray<A>, NonEmptyArray<B>] : S extends Iterable<readonly [infer A, infer B]> ? [Array<A>, Array<B>] : never

----------------------------------------

TITLE: Combining Loggers with zip Function in TypeScript
DESCRIPTION: The zip function combines two loggers to create a new logger that logs to both. It takes two Logger instances and returns a new Logger that combines their message types and outputs.

LANGUAGE: typescript
CODE:
declare const zip: { <Message2, Output2>(that: Logger<Message2, Output2>): <Message, Output>(self: Logger<Message, Output>) => Logger<Message & Message2, [Output, Output2]>; <Message, Output, Message2, Output2>(self: Logger<Message, Output>, that: Logger<Message2, Output2>): Logger<Message & Message2, [Output, Output2]>; }

----------------------------------------

TITLE: Defining mapEffect Function for Sink Transformation in TypeScript
DESCRIPTION: Declares the mapEffect function which effectfully transforms a sink's result. It takes a transformation function and returns a new sink with the transformed result type. The function can be used in two ways: passing the sink as the first argument, or as a curried function.

LANGUAGE: typescript
CODE:
declare const mapEffect: { <A, A2, E2, R2>(f: (a: A) => Effect.Effect<A2, E2, R2>): <In, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A2, In, L, E2 | E, R2 | R>; <A, In, L, E, R, A2, E2, R2>(self: Sink<A, In, L, E, R>, f: (a: A) => Effect.Effect<A2, E2, R2>): Sink<A2, In, L, E | E2, R | R2>; }

----------------------------------------

TITLE: Converting Effect to Deferred Operation in TypeScript
DESCRIPTION: Demonstrates how to use the intoDeferred function to convert an Effect into an operation that completes a Deferred. The example shows creating a success effect, completing a Deferred with it, and then accessing the value.

LANGUAGE: typescript
CODE:
import { Deferred, Effect } from "effect"

// Define an effect that succeeds
const successEffect = Effect.succeed(42)

const program = Effect.gen(function*() {
  // Create a deferred
  const deferred = yield* Deferred.make<number, string>()

  // Complete the deferred using the successEffect
  const isCompleted = yield* Effect.intoDeferred(successEffect, deferred)

  // Access the value of the deferred
  const value = yield* Deferred.await(deferred)
  console.log(value)

  return isCompleted
})

Effect.runPromise(program).then(console.log)
// Output:
// 42
// true

----------------------------------------

TITLE: Defining and Using LazyArg in TypeScript
DESCRIPTION: This snippet demonstrates how to import and use the LazyArg type and constant function from the Effect package. It creates a constant function that returns null as a lazy argument.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { LazyArg, constant } from "effect/Function"

const constNull: LazyArg<null> = constant(null)

----------------------------------------

TITLE: Implementing Stream.zipLatestWith in TypeScript
DESCRIPTION: Function signature for zipLatestWith that combines two streams by pairing the latest values from each stream. When either stream emits a value, it combines with the most recent value from the other stream. The combination is done using a provided function f. Note that latest value tracking operates on a per-chunk basis.

LANGUAGE: typescript
CODE:
declare const zipLatestWith: { <AR, ER, RR, AL, A>(right: Stream<AR, ER, RR>, f: (left: AL, right: AR) => A): <EL, RL>(left: Stream<AL, EL, RL>) => Stream<A, EL | ER, RL | RR>; <AL, EL, RL, AR, ER, RR, A>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>, f: (left: AL, right: AR) => A): Stream<A, EL | ER, RL | RR>; }

----------------------------------------

TITLE: Executing Workflows with Test Annotations in TypeScript
DESCRIPTION: A function that executes a specified workflow with a custom implementation of the annotations service. It supports both curried and non-curried calling styles for flexible usage patterns.

LANGUAGE: typescript
CODE:
declare const withAnnotations: ((annotations: Annotations.TestAnnotations) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>) & (<A, E, R>(effect: Effect.Effect<A, E, R>, annotations: Annotations.TestAnnotations) => Effect.Effect<A, E, R>)

----------------------------------------

TITLE: Defining TextStream Interface in TypeScript
DESCRIPTION: Defines a TypeScript interface for representing a Doc containing a string of text. The interface extends DocStream.Variance and includes properties for the stream type tag, text content, and the document stream itself.

LANGUAGE: typescript
CODE:
export interface TextStream<A> extends DocStream.Variance<A> {
  readonly _tag: "TextStream"
  readonly text: string
  readonly stream: DocStream<A>
}

----------------------------------------

TITLE: Implementing filterMapEffect Function in TypeScript Stream Module
DESCRIPTION: Defines a function that combines filtering and mapping with effects in a single operation on a Stream. It takes a partial function that returns an Optional Effect and transforms a Stream of type A into a Stream of type A2, while handling errors and environmental requirements.

LANGUAGE: typescript
CODE:
declare const filterMapEffect: {
  <A, A2, E2, R2>(pf: (a: A) => Option.Option<Effect.Effect<A2, E2, R2>>): <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>;
  <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, pf: (a: A) => Option.Option<Effect.Effect<A2, E2, R2>>): Stream<A2, E | E2, R | R2>;
}

----------------------------------------

TITLE: TypeScript Function Signature for Effect.cached
DESCRIPTION: This code snippet shows the TypeScript function signature for the Effect.cached function. It takes an Effect as input and returns a new Effect that, when evaluated, produces a cached version of the original Effect.

LANGUAGE: typescript
CODE:
declare const cached: <A, E, R>(self: Effect<A, E, R>) => Effect<Effect<A, E, R>>

----------------------------------------

TITLE: Implementing Channel Finalizers in TypeScript using Effect
DESCRIPTION: Defines an overloaded function that attaches a finalizer Effect to a Channel. The finalizer is guaranteed to execute once the channel begins execution, regardless of completion status. The function supports both curried and non-curried parameter orders.

LANGUAGE: typescript
CODE:
declare const ensuring: {
  <Z, Env1>(finalizer: Effect.Effect<Z, never, Env1>): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env1 | Env>;
  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, Z, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, finalizer: Effect.Effect<Z, never, Env1>): Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env | Env1>;
}

----------------------------------------

TITLE: Setting Minimum Log Level in Effect TypeScript
DESCRIPTION: Demonstrates how to set a minimum log level for logging operations using the Logger.withMinimumLogLevel function. This function filters log messages based on their severity level, only displaying messages at or above the specified level.

LANGUAGE: typescript
CODE:
import { Effect, Logger, LogLevel } from "effect"

const program = Effect.logDebug("message1").pipe(Logger.withMinimumLogLevel(LogLevel.Debug))

Effect.runFork(program)
// timestamp=... level=DEBUG fiber=#0 message=message1

LANGUAGE: typescript
CODE:
declare const withMinimumLogLevel: { (level: LogLevel.LogLevel): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, level: LogLevel.LogLevel): Effect<A, E, R>; }

----------------------------------------

TITLE: Implementing Boolean Negation in Effect Type - TypeScript
DESCRIPTION: Defines a function that takes an Effect containing a boolean value and returns a new Effect with the boolean value negated. The function preserves the error type E and environment type R of the original Effect.

LANGUAGE: typescript
CODE:
declare const negate: <E, R>(self: Effect<boolean, E, R>) => Effect<boolean, E, R>

----------------------------------------

TITLE: Implementing Eventually Operation in TypeScript STM
DESCRIPTION: Defines a function that takes an STM effect and returns a new STM effect that will keep retrying until successful, ignoring any errors encountered during execution. The function is generic over the success type A, error type E, and environment type R.

LANGUAGE: typescript
CODE:
declare const eventually: <A, E, R>(self: STM<A, E, R>) => STM<A, E, R>

----------------------------------------

TITLE: Constructing Channel from PubSub in TypeScript
DESCRIPTION: The fromPubSub function creates a Channel from a PubSub. It takes a PubSub of Either<Elem, Exit<Done, Err>> and returns a Channel with specified type parameters. This function is available since version 2.0.0 of the package.

LANGUAGE: typescript
CODE:
declare const fromPubSub: <Done, Err, Elem>(pubsub: PubSub.PubSub<Either.Either<Elem, Exit.Exit<Done, Err>>>) => Channel<Elem, unknown, Err, unknown, Done, unknown>

----------------------------------------

TITLE: Implementing Iterable.contains Function in TypeScript
DESCRIPTION: Defines a function that checks if an Iterable contains a given value using the default Equivalence. It can be called with the value first or the Iterable first.

LANGUAGE: typescript
CODE:
declare const contains: { <A>(a: A): (self: Iterable<A>) => boolean; <A>(self: Iterable<A>, a: A): boolean; }

----------------------------------------

TITLE: Effect.interrupt Type Signature in TypeScript
DESCRIPTION: This code snippet shows the type signature of the Effect.interrupt constant. It is defined as an Effect that never requires any input, never produces an error, and never produces a value.

LANGUAGE: typescript
CODE:
declare const interrupt: Effect<never, never, never>

----------------------------------------

TITLE: Effect.tryPromise Function Signature in TypeScript
DESCRIPTION: Provides the TypeScript signature for the Effect.tryPromise function, showing its overloads and type parameters.

LANGUAGE: typescript
CODE:
declare const tryPromise: { <A, E>(options: { readonly try: (signal: AbortSignal) => PromiseLike<A>; readonly catch: (error: unknown) => E; }): Effect<A, E>; <A>(evaluate: (signal: AbortSignal) => PromiseLike<A>): Effect<A, Cause.UnknownException>; }

----------------------------------------

TITLE: TypeScript Signature of Stream.takeUntil Function
DESCRIPTION: Provides the TypeScript signature for the Stream.takeUntil function. It shows two overloads: one that takes a predicate and returns a function, and another that takes both a stream and a predicate.

LANGUAGE: typescript
CODE:
declare const takeUntil: { <A>(predicate: Predicate<NoInfer<A>>): <E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, predicate: Predicate<A>): Stream<A, E, R>; }

----------------------------------------

TITLE: Implementing Effect.withSpan for Tracing in TypeScript
DESCRIPTION: Defines the withSpan function that wraps an Effect with a new span for tracing. It can be used in two ways: either by passing the name and options first, or by passing the Effect first followed by the name and options. The function returns a new Effect with the Tracer.ParentSpan requirement excluded.

LANGUAGE: typescript
CODE:
declare const withSpan: {
  (name: string, options?: Tracer.SpanOptions | undefined): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, Exclude<R, Tracer.ParentSpan>>;
  <A, E, R>(self: Effect<A, E, R>, name: string, options?: Tracer.SpanOptions | undefined): Effect<A, E, Exclude<R, Tracer.ParentSpan>>;
}

----------------------------------------

TITLE: Implementing Schedule.mapEffect in TypeScript
DESCRIPTION: Defines a function that transforms a schedule's output using an effectful function. The function preserves the schedule's timing while allowing side effects or asynchronous transformations to be applied to output values. It supports both curried and uncurried calling patterns.

LANGUAGE: typescript
CODE:
declare const mapEffect: { 
  <Out, Out2, R2>(f: (out: Out) => Effect.Effect<Out2, never, R2>): 
    <In, R>(self: Schedule<Out, In, R>) => Schedule<Out2, In, R2 | R>; 
  <Out, In, R, Out2, R2>(self: Schedule<Out, In, R>, f: (out: Out) => Effect.Effect<Out2, never, R2>): 
    Schedule<Out2, In, R | R2>; 
}

----------------------------------------

TITLE: Unwrapping Configuration Example in TypeScript
DESCRIPTION: Demonstrates how to use Config.unwrap to construct a configuration object from a wrapped configuration type. Shows a practical example with an Options interface containing a key property.

LANGUAGE: typescript
CODE:
import { Config, unwrap } from "./Config"

interface Options { key: string }

const makeConfig = (config: Config.Wrap<Options>): Config<Options> => unwrap(config)

----------------------------------------

TITLE: Implementing Stream Changes with Effect in TypeScript
DESCRIPTION: Defines a function that returns a new stream that only emits elements that are not equal to the previous element, using an effectual comparison function. The comparison is performed using a provided effect-producing equality function.

LANGUAGE: typescript
CODE:
declare const changesWithEffect: { <A, E2, R2>(f: (x: A, y: A) => Effect.Effect<boolean, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: Stream<A, E, R>, f: (x: A, y: A) => Effect.Effect<boolean, E2, R2>): Stream<A, E | E2, R | R2>; }

----------------------------------------

TITLE: Using Stream.onStart with Effect Streams in TypeScript
DESCRIPTION: Demonstrates how to use Stream.onStart to execute an effect when stream processing begins. The example shows logging at stream start, mapping numbers, and collecting results.

LANGUAGE: typescript
CODE:
import { Console, Effect, Stream } from "effect"

const stream = Stream.make(1, 2, 3).pipe(
  Stream.onStart(Console.log("Stream started")),
  Stream.map((n) => n * 2),
  Stream.tap((n) => Console.log(`after mapping: ${n}`))
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// Stream started
// after mapping: 2
// after mapping: 4
// after mapping: 6
// { _id: 'Chunk', values: [ 2, 4, 6 ] }

LANGUAGE: typescript
CODE:
declare const onStart: { <_, E2, R2>(effect: Effect.Effect<_, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, _, E2, R2>(self: Stream<A, E, R>, effect: Effect.Effect<_, E2, R2>): Stream<A, E | E2, R | R2>; }

----------------------------------------

TITLE: Implementing Synchronous Failure Layer in Effect-TS
DESCRIPTION: Creates a Layer that synchronously fails with a specified error. Takes a lazy argument that evaluates to the error type E and returns a Layer that requires unknown input and can fail with error type E.

LANGUAGE: typescript
CODE:
declare const failSync: <E>(evaluate: LazyArg<E>) => Layer<unknown, E>

----------------------------------------

TITLE: Appending Elements to Lists in TypeScript using Effect-TS
DESCRIPTION: Implementation of a type-safe append operation that adds an element to the end of a List, creating a new Cons structure. The function is curried and supports both single-argument and two-argument calling styles.

LANGUAGE: typescript
CODE:
declare const append: { <B>(element: B): <A>(self: List<A>) => Cons<A | B>; <A, B>(self: List<A>, element: B): Cons<A | B>; }

----------------------------------------

TITLE: Initializing Array Without Last Element in TypeScript
DESCRIPTION: The Array.initNonEmpty function takes a non-empty array and returns a new array containing all elements except the last one. It's useful for operations that need to preserve most of an array while excluding its final element.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const result = Array.initNonEmpty([1, 2, 3, 4])
console.log(result) // [1, 2, 3]

LANGUAGE: typescript
CODE:
declare const initNonEmpty: <A>(self: NonEmptyReadonlyArray<A>) => Array<A>

----------------------------------------

TITLE: Defining LogLevel Type in TypeScript for Effect Package
DESCRIPTION: This code snippet defines the LogLevel type as a union of different log levels. It includes levels from All (most verbose) to None (least verbose), allowing fine-grained control over logging output.

LANGUAGE: typescript
CODE:
type LogLevel = All | Fatal | Error | Warning | Info | Debug | Trace | None

----------------------------------------

TITLE: Effect.onExit Function Signature in TypeScript
DESCRIPTION: Provides the type signature for the Effect.onExit function. It shows the function's polymorphic nature, allowing it to work with various effect types and cleanup functions.

LANGUAGE: typescript
CODE:
declare const onExit: { <A, E, X, R2>(cleanup: (exit: Exit.Exit<A, E>) => Effect<X, never, R2>): <R>(self: Effect<A, E, R>) => Effect<A, E, R2 | R>; <A, E, R, X, R2>(self: Effect<A, E, R>, cleanup: (exit: Exit.Exit<A, E>) => Effect<X, never, R2>): Effect<A, E, R | R2>; }

----------------------------------------

TITLE: Implementing Time-Limited MicroSchedule in TypeScript
DESCRIPTION: Function signature for transforming a MicroSchedule to stop repeating after a specified maximum elapsed time. The function supports both curried and uncurried calling styles.

LANGUAGE: typescript
CODE:
declare const scheduleWithMaxElapsed: { 
  (max: number): (self: MicroSchedule) => MicroSchedule; 
  (self: MicroSchedule, max: number): MicroSchedule; 
}

----------------------------------------

TITLE: Transforming Take<A, E> with map Function in TypeScript
DESCRIPTION: The map function transforms a Take<A, E> to Take<B, E> by applying a provided function f. It has two overloads: one for curried usage and another for direct application.

LANGUAGE: typescript
CODE:
declare const map: { <A, B>(f: (a: A) => B): <E>(self: Take<A, E>) => Take<B, E>; <A, E, B>(self: Take<A, E>, f: (a: A) => B): Take<B, E>; }

----------------------------------------

TITLE: Declaring SemigroupMultiply Type in TypeScript
DESCRIPTION: This snippet shows the type declaration for SemigroupMultiply. It is defined as a Semigroup for numbers, implementing the combine operation as multiplication.

LANGUAGE: typescript
CODE:
declare const SemigroupMultiply: semigroup.Semigroup<number>

----------------------------------------

TITLE: Type Signature for Doc.surround in TypeScript
DESCRIPTION: Provides the type signature for the Doc.surround function. It shows that the function can be used in two ways: either by passing the left and right documents first, or by passing the main document first followed by the left and right documents.

LANGUAGE: typescript
CODE:
declare const surround: { <A, B, C>(left: Doc<A>, right: Doc<B>): (self: Doc<C>) => Doc<A | B | C>; <A, B, C>(self: Doc<C>, left: Doc<A>, right: Doc<B>): Doc<A | B | C>; }

----------------------------------------

TITLE: Creating and Using a Latch in TypeScript with Effect
DESCRIPTION: This example demonstrates how to create a Latch using Effect.makeLatch, fork a fiber that waits for the latch to open, and then open the latch after a delay. It showcases the usage of Effect.gen, Effect.fork, and Effect.sleep.

LANGUAGE: typescript
CODE:
import { Console, Effect } from "effect"

const program = Effect.gen(function*() {
  // Create a latch, starting in the closed state
  const latch = yield* Effect.makeLatch(false)

  // Fork a fiber that logs "open sesame" when the latch is opened
  const fiber = yield* Console.log("open sesame").pipe(
    latch.whenOpen,
    Effect.fork
  )

  yield* Effect.sleep("1 second")

  // Open the latch
  yield* latch.open
  yield* fiber.await
})

Effect.runFork(program)
// Output: open sesame (after 1 second)

----------------------------------------

TITLE: Declaring TestAnnotation.tagged in TypeScript
DESCRIPTION: Declares a constant 'tagged' of type TestAnnotation with a generic parameter HashSet<string>. This annotation is used to tag tests with string values.

LANGUAGE: typescript
CODE:
declare const tagged: TestAnnotation<HashSet.HashSet<string>>

----------------------------------------

TITLE: Effect.findFirst Function Signature in TypeScript
DESCRIPTION: This code snippet shows the TypeScript signature for the Effect.findFirst function. It defines the function's type, including its parameters and return type.

LANGUAGE: typescript
CODE:
declare const findFirst: { <A, E, R>(predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>): (elements: Iterable<A>) => Effect<Option.Option<A>, E, R>; <A, E, R>(elements: Iterable<A>, predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>): Effect<Option.Option<A>, E, R>; }

----------------------------------------

TITLE: Creating Histogram Metric in Effect
DESCRIPTION: Demonstrates how to create a histogram metric for measuring value distributions. The example shows creating a latency histogram with linear boundaries starting at 0, with width of 10, and 11 count intervals.

LANGUAGE: typescript
CODE:
import { Metric, MetricBoundaries } from "effect"

const latencyHistogram = Metric.histogram("latency_histogram",
  MetricBoundaries.linear({ start: 0, width: 10, count: 11 }),
  "Measures the distribution of request latency."
);

LANGUAGE: typescript
CODE:
declare const histogram: (name: string, boundaries: MetricBoundaries.MetricBoundaries, description?: string) => Metric<MetricKeyType.MetricKeyType.Histogram, number, MetricState.MetricState.Histogram>

----------------------------------------

TITLE: Declaring JSON Text Field Type in TypeScript
DESCRIPTION: Defines a field type for handling JSON values stored as text in databases. It accepts a schema parameter that can be either a Schema.All or PropertySignature.All type and returns a JsonFromString type with the specified schema.

LANGUAGE: typescript
CODE:
declare const JsonFromString: <S extends Schema.Schema.All | Schema.PropertySignature.All>(schema: S) => JsonFromString<S>

----------------------------------------

TITLE: Doc.line Function Signature in TypeScript
DESCRIPTION: The signature of the Doc.line function, which is a constant of type Doc<never>.

LANGUAGE: typescript
CODE:
declare const line: Doc<never>

----------------------------------------

TITLE: Defining BigDecimalFromNumber Schema in TypeScript
DESCRIPTION: Declares a schema class that handles conversion between JavaScript number type and BigDecimal. Important note that encoding will produce incorrect results if the BigDecimal value exceeds the 64-bit number range.

LANGUAGE: typescript
CODE:
declare class BigDecimalFromNumber

----------------------------------------

TITLE: Setting FiberRef Values in Effect-TS
DESCRIPTION: The setAll function takes a FiberRefs object and sets each reference to either its specified value or its default value. Returns an Effect of void.

LANGUAGE: typescript
CODE:
declare const setAll: (self: FiberRefs) => Effect.Effect<void>

----------------------------------------

TITLE: Using List.prependAll in TypeScript
DESCRIPTION: Demonstrates how to prepend one list to another using the List.prependAll function. Shows combining string and number lists with type safety.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { List } from "effect"

assert.deepStrictEqual(
  List.make(1, 2).pipe(List.prependAll(List.make("a", "b")), List.toArray),
  ["a", "b", 1, 2]
)

----------------------------------------

TITLE: Combining Optional Values with Option.zipWith in TypeScript
DESCRIPTION: This example demonstrates how to use Option.zipWith to combine two optional values (name and age) into a single person object. It showcases the function's ability to handle Some and None cases while applying a transformation.

LANGUAGE: typescript
CODE:
import { Option } from "effect"

const maybeName: Option.Option<string> = Option.some("John")
const maybeAge: Option.Option<number> = Option.some(25)

// Combine the name and age into a person object
const person = Option.zipWith(maybeName, maybeAge, (name, age) => ({
  name: name.toUpperCase(),
  age
}))

console.log(person)
// Output:
// { _id: 'Option', _tag: 'Some', value: { name: 'JOHN', age: 25 } }

----------------------------------------

TITLE: Defining runForEachChunkScoped Function in TypeScript
DESCRIPTION: Declares the runForEachChunkScoped function, which is similar to Stream.runForEachChunk but returns a scoped effect for controlled finalization order. It takes a function that processes each chunk of the stream and returns an effect.

LANGUAGE: typescript
CODE:
declare const runForEachChunkScoped: { <A, X, E2, R2>(f: (a: Chunk.Chunk<A>) => Effect.Effect<X, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect.Effect<void, E2 | E, Scope.Scope | R2 | R>; <A, E, R, X, E2, R2>(self: Stream<A, E, R>, f: (a: Chunk.Chunk<A>) => Effect.Effect<X, E2, R2>): Effect.Effect<void, E | E2, Scope.Scope | R | R2>; }

----------------------------------------

TITLE: Demonstrating Record.pop Usage in TypeScript
DESCRIPTION: This example shows how to use the Record.pop function to retrieve a value from a record and remove it, returning an Option of a tuple with the value and the updated record.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Record as R, Option } from "effect"

assert.deepStrictEqual(R.pop({ a: 1, b: 2 }, "a"), Option.some([1, { b: 2 }]))
assert.deepStrictEqual(R.pop({ a: 1, b: 2 } as Record<string, number>, "c"), Option.none())

----------------------------------------

TITLE: Defining Either.andThen Function in TypeScript
DESCRIPTION: Declares the andThen function for the Either type, allowing sequential execution of Either operations. It supports various overloads for different input types and chaining behaviors.

LANGUAGE: typescript
CODE:
declare const andThen: { <R, R2, L2>(f: (right: R) => Either<R2, L2>): <L>(self: Either<R, L>) => Either<R2, L | L2>; <R2, L2>(f: Either<R2, L2>): <L, R1>(self: Either<R1, L>) => Either<R2, L | L2>; <R, R2>(f: (right: R) => R2): <L>(self: Either<R, L>) => Either<R2, L>; <R2>(right: NotFunction<R2>): <R1, L>(self: Either<R1, L>) => Either<R2, L>; <R, L, R2, L2>(self: Either<R, L>, f: (right: R) => Either<R2, L2>): Either<R2, L | L2>; <R, L, R2, L2>(self: Either<R, L>, f: Either<R2, L2>): Either<R2, L | L2>; <R, L, R2>(self: Either<R, L>, f: (right: R) => R2): Either<R2, L>; <R, L, R2>(self: Either<R, L>, f: NotFunction<R2>): Either<R2, L>; }

----------------------------------------

TITLE: Defining Flatten Type in TypeScript for @effect/printer
DESCRIPTION: This code snippet defines the Flatten type as a union of Flattened, AlreadyFlat, and NeverFlat types. It's designed to optimize document processing by avoiding unnecessary flattening operations that could lead to exponential complexity in deeply nested structures.

LANGUAGE: typescript
CODE:
type Flatten<A> = Flattened<A> | AlreadyFlat<A> | NeverFlat<A>

----------------------------------------

TITLE: FiberHandle.join Type Signature
DESCRIPTION: Type declaration for the join function showing it takes a FiberHandle with generic type parameters for success and error types and returns an Effect that may fail with the error type.

LANGUAGE: typescript
CODE:
declare const join: <A, E>(self: FiberHandle<A, E>) => Effect.Effect<void, E>

----------------------------------------

TITLE: TypeScript Function Signature for Effect.timeoutFailCause
DESCRIPTION: This code snippet shows the TypeScript function signature for the timeoutFailCause function in the Effect module. It defines the function's parameters and return types, illustrating how it can be used to create a new Effect with custom timeout behavior.

LANGUAGE: typescript
CODE:
declare const timeoutFailCause: { <E1>(options: { readonly onTimeout: LazyArg<Cause.Cause<E1>>; readonly duration: Duration.DurationInput; }): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E1 | E, R>; <A, E, R, E1>(self: Effect<A, E, R>, options: { readonly onTimeout: LazyArg<Cause.Cause<E1>>; readonly duration: Duration.DurationInput; }): Effect<A, E | E1, R>; }

----------------------------------------

TITLE: Array Partition Function Signature
DESCRIPTION: Type definition for the partition function, supporting both type refinement and boolean predicate variants. The function can be used in both curried and non-curried forms.

LANGUAGE: typescript
CODE:
declare const partition: { <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => [excluded: Array<Exclude<A, B>>, satisfying: Array<B>]; <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => [excluded: Array<A>, satisfying: Array<A>]; <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): [excluded: Array<Exclude<A, B>>, satisfying: Array<B>]; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): [excluded: Array<A>, satisfying: Array<A>]; }

----------------------------------------

TITLE: Effect.promise Function Signature in TypeScript
DESCRIPTION: TypeScript type declaration for the Effect.promise function. Shows the function signature that takes an evaluation function accepting an AbortSignal and returning a PromiseLike<A>, producing an Effect<A>.

LANGUAGE: typescript
CODE:
declare const promise: <A>(evaluate: (signal: AbortSignal) => PromiseLike<A>) => Effect<A>

----------------------------------------

TITLE: Signature of Prompt.all Function in TypeScript
DESCRIPTION: Provides the TypeScript signature for the Prompt.all function. It accepts an argument of type Iterable<Prompt<any>> or Record<string, Prompt<any>> and returns a type determined by the All.Return utility type.

LANGUAGE: typescript
CODE:
declare const all: <const Arg extends Iterable<Prompt<any>> | Record<string, Prompt<any>>>(arg: Arg) => All.Return<Arg>

----------------------------------------

TITLE: Effect.ignore Function Signature in TypeScript
DESCRIPTION: This snippet shows the TypeScript signature of the Effect.ignore function. It takes an Effect with generic types A, E, and R, and returns an Effect that always succeeds with void, preserving only the environment type R.

LANGUAGE: typescript
CODE:
declare const ignore: <A, E, R>(self: Effect<A, E, R>) => Effect<void, never, R>

----------------------------------------

TITLE: Reversing List Elements in Effect Library - TypeScript
DESCRIPTION: Function signature for reversing elements in a List data structure. Takes a List of type A as input and returns a new List of the same type with elements in reverse order.

LANGUAGE: typescript
CODE:
declare const reverse: <A>(self: List<A>) => List<A>

----------------------------------------

TITLE: Implementing Queue.takeN Operation in TypeScript with Effect-TS
DESCRIPTION: Function signature for taking N elements from a Dequeue. The function can be called with either curried or uncurried parameters, returning an Effect containing a Chunk of elements. If insufficient elements are available, the operation suspends until enough elements are present.

LANGUAGE: typescript
CODE:
declare const takeN: { 
  (n: number): <A>(self: Dequeue<A>) => Effect.Effect<Chunk.Chunk<A>>; 
  <A>(self: Dequeue<A>, n: number): Effect.Effect<Chunk.Chunk<A>>; 
}

----------------------------------------

TITLE: Declaring Channel.buffer Function in TypeScript
DESCRIPTION: Defines the buffer function that creates a channel backed by a buffer. It takes options including an empty value, an isEmpty predicate, and a Ref for the buffer. The function returns a Channel that passes through input as output when the buffer is empty, or passes the buffered value when non-empty.

LANGUAGE: typescript
CODE:
declare const buffer: <InElem, InErr, InDone>(options: { readonly empty: InElem; readonly isEmpty: Predicate<InElem>; readonly ref: Ref.Ref<InElem>; }) => Channel<InElem, InElem, InErr, InErr, InDone, InDone, never>

----------------------------------------

TITLE: Tuple.at Function Signature
DESCRIPTION: Type declaration for the Tuple.at function showing its polymorphic implementation. It supports both curried and uncurried calling styles with type parameters for the index and array type.

LANGUAGE: typescript
CODE:
declare const at: { <N extends number>(index: N): <A extends ReadonlyArray<unknown>>(self: A) => A[N]; <A extends ReadonlyArray<unknown>, N extends number>(self: A, index: N): A[N]; }

----------------------------------------

TITLE: isNull Function Signature in TypeScript
DESCRIPTION: Provides the TypeScript signature for the isNull function, which takes an unknown input and returns a boolean indicating if the input is null.

LANGUAGE: typescript
CODE:
declare const isNull: (input: unknown) => input is null

----------------------------------------

TITLE: Retrieving Metric Value in TypeScript
DESCRIPTION: The value function retrieves a snapshot of the metric's current value. It takes a Metric object as input and returns an Effect that resolves to the metric's output type.

LANGUAGE: typescript
CODE:
declare const value: <Type, In, Out>(self: Metric<Type, In, Out>) => Effect.Effect<Out>

----------------------------------------

TITLE: Declaring DateTimeInsertFromDate Field in TypeScript
DESCRIPTION: Declares a constant DateTimeInsertFromDate of type DateTimeInsertFromDate. This field represents a date-time value that is inserted as the current DateTime.Utc and serialized as a Date for the database. It is omitted from updates but available for selection.

LANGUAGE: typescript
CODE:
declare const DateTimeInsertFromDate: DateTimeInsertFromDate

----------------------------------------

TITLE: Declaring asSomeError Function in Effect Module
DESCRIPTION: Function signature for asSomeError, which transforms an Effect's error channel into an Option type. It maps error values to Some while preserving successful values. The function operates on Effect<A, E, R> and returns Effect<A, Option<E>, R>.

LANGUAGE: typescript
CODE:
declare const asSomeError: <A, E, R>(self: Effect<A, E, R>) => Effect<A, Option.Option<E>, R>

----------------------------------------

TITLE: Effect.retryOrElse Function Signature in TypeScript
DESCRIPTION: This code snippet shows the TypeScript signature of the Effect.retryOrElse function. It defines the function's type parameters and overloads, illustrating how it can be used with different argument combinations.

LANGUAGE: typescript
CODE:
declare const retryOrElse: { <A1, E, R1, A2, E2, R2>(policy: Schedule.Schedule<A1, NoInfer<E>, R1>, orElse: (e: NoInfer<E>, out: A1) => Effect<A2, E2, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2, R1 | R2 | R>; <A, E, R, A1, R1, A2, E2, R2>(self: Effect<A, E, R>, policy: Schedule.Schedule<A1, NoInfer<E>, R1>, orElse: (e: NoInfer<E>, out: A1) => Effect<A2, E2, R2>): Effect<A | A2, E2, R | R1 | R2>; }

----------------------------------------

TITLE: Using filterMap with Array in Effect TypeScript
DESCRIPTION: Demonstrates how to use the filterMap function to simultaneously filter and transform array elements. The function takes a predicate that returns an Option type, keeping only the Some values and transforming them.

LANGUAGE: typescript
CODE:
import { Array, Option } from "effect"

const evenSquares = (x: number) => x % 2 === 0 ? Option.some(x * x) : Option.none()

const result = Array.filterMap([1, 2, 3, 4, 5], evenSquares);
console.log(result) // [4, 16]

LANGUAGE: typescript
CODE:
declare const filterMap: { <A, B>(f: (a: A, i: number) => Option.Option<B>): (self: Iterable<A>) => Array<B>; <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option.Option<B>): Array<B>; }

----------------------------------------

TITLE: Stream.zipWith Type Signature Definition
DESCRIPTION: Provides the complete type signature for the zipWith operation, showing its polymorphic nature and type parameters for error handling and environment requirements.

LANGUAGE: typescript
CODE:
declare const zipWith: { <AR, ER, RR, AL, A>(right: Stream<AR, ER, RR>, f: (left: AL, right: AR) => A): <EL, RL>(left: Stream<AL, EL, RL>) => Stream<A, EL | ER, RL | RR>; <AL, EL, RL, AR, ER, RR, A>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>, f: (left: AL, right: AR) => A): Stream<A, EL | ER, RL | RR>; }

----------------------------------------

TITLE: Executing Asynchronous Effects with Callbacks in TypeScript
DESCRIPTION: Function signature for runCallback that executes an effect asynchronously and handles the result via a callback. The function takes an Effect instance and optional runtime options, returning a cancellation function. The callback receives either successful results or failure information.

LANGUAGE: typescript
CODE:
declare const runCallback: <A, E>(effect: Effect<A, E>, options?: Runtime.RunCallbackOptions<A, E> | undefined) => Runtime.Cancel<A, E>

----------------------------------------

TITLE: Implementing HashMap Reduction in TypeScript
DESCRIPTION: Defines a reduce function for HashMap that accumulates values across all entries. Takes an initial value and a reducer function that processes each key-value pair, returning a final accumulated result. Supports both curried and uncurried function signatures.

LANGUAGE: typescript
CODE:
declare const reduce: {
  <Z, V, K>(zero: Z, f: (accumulator: Z, value: V, key: K) => Z): (self: HashMap<K, V>) => Z;
  <K, V, Z>(self: HashMap<K, V>, zero: Z, f: (accumulator: Z, value: V, key: K) => Z): Z;
}

----------------------------------------

TITLE: Implementing getMonoid Function in TypeScript
DESCRIPTION: Function signature for getMonoid that lifts a Monoid into an applicative functor F. It combines inner values using the provided Monoid's combine operation and creates empty values using F.of(M.empty).

LANGUAGE: typescript
CODE:
declare const getMonoid: <F extends TypeLambda>(F: Applicative<F>) => <A, R, O, E>(M: Monoid<A>) => Monoid<Kind<F, R, O, E, A>>

----------------------------------------

TITLE: Type Definition for Doc.isFail in TypeScript
DESCRIPTION: Type signature for the isFail function that checks if a Doc<A> instance is specifically a Fail<A> type. Returns a boolean indicating if the doc is a Fail instance. Uses TypeScript's type predicate feature for type narrowing.

LANGUAGE: typescript
CODE:
declare const isFail: <A>(self: Doc<A>) => self is Fail<A>

----------------------------------------

TITLE: Building Layer into Scoped Value in TypeScript
DESCRIPTION: Function signature for building a layer into a scoped value. Takes a Layer with generic type parameters for input requirements (RIn), error type (E), and output type (ROut). Returns an Effect that produces a Context of ROut, may fail with error E, and requires Scope and RIn.

LANGUAGE: typescript
CODE:
declare const build: <RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Effect.Effect<Context.Context<ROut>, E, Scope.Scope | RIn>

----------------------------------------

TITLE: Creating Managed Runtime with Effect Layer
DESCRIPTION: Demonstrates how to create and use a ManagedRuntime by converting a Layer containing a Notifications service. Shows initialization, effect execution, and proper cleanup with dispose.

LANGUAGE: typescript
CODE:
import { Console, Effect, Layer, ManagedRuntime } from "effect"

class Notifications extends Effect.Tag("Notifications")<
  Notifications,
  { readonly notify: (message: string) => Effect.Effect<void> }
>() {
  static Live = Layer.succeed(this, { notify: (message) => Console.log(message) })
}

async function main() {
  const runtime = ManagedRuntime.make(Notifications.Live)
  await runtime.runPromise(Notifications.notify("Hello, world!"))
  await runtime.dispose()
}

main()

----------------------------------------

TITLE: Defining Channel Interface in TypeScript
DESCRIPTION: Defines the Channel interface with generic type parameters for input/output elements, errors, done values, and environment. It extends Channel.Variance and Pipeable, and includes type symbols for unification.

LANGUAGE: typescript
CODE:
export interface Channel<
  out OutElem,
  in InElem = unknown,
  out OutErr = never,
  in InErr = unknown,
  out OutDone = void,
  in InDone = unknown,
  out Env = never
> extends
  Channel.Variance<
    OutElem,
    InElem,
    OutErr,
    InErr,
    OutDone,
    InDone,
    Env
  >,
  Pipeable
{
  [Unify.typeSymbol]?: unknown
  [Unify.unifySymbol]?: ChannelUnify<this>
  [Unify.ignoreSymbol]?: ChannelUnifyIgnore
}

----------------------------------------

TITLE: Defining orElseEither Function for STM in TypeScript
DESCRIPTION: Declares a function that returns a transactional effect. It produces the value of the initial effect in the left side of an Either, or the value of a specified effect in the right side if the initial effect fails or retries. The function is overloaded to handle different parameter combinations.

LANGUAGE: typescript
CODE:
declare const orElseEither: { <A2, E2, R2>(that: LazyArg<STM<A2, E2, R2>>): <A, E, R>(self: STM<A, E, R>) => STM<Either.Either<A2, A>, E2, R2 | R>; <A, E, R, A2, E2, R2>(self: STM<A, E, R>, that: LazyArg<STM<A2, E2, R2>>): STM<Either.Either<A2, A>, E2, R | R2>; }

----------------------------------------

TITLE: Implementing Stream Throttling with Effect Library in TypeScript
DESCRIPTION: Demonstrates how to throttle a stream using token bucket algorithm with configurable bandwidth parameters. Shows timing-based example with logging to track emission delays.

LANGUAGE: typescript
CODE:
import { Chunk, Effect, Schedule, Stream } from "effect"

let last = Date.now()
const log = (message: string) =>
  Effect.sync(() => {
    const end = Date.now()
    console.log(`${message} after ${end - last}ms`)
    last = end
  })

const stream = Stream.fromSchedule(Schedule.spaced("50 millis")).pipe(
  Stream.take(6),
  Stream.tap((n) => log(`Received ${n}`)),
  Stream.throttle({
    cost: Chunk.size,
    duration: "100 millis",
    units: 1
  }),
  Stream.tap((n) => log(`> Emitted ${n}`))
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// Received 0 after 56ms
// > Emitted 0 after 0ms
// Received 1 after 52ms
// > Emitted 1 after 48ms
// Received 2 after 52ms
// > Emitted 2 after 49ms
// Received 3 after 52ms
// > Emitted 3 after 48ms
// Received 4 after 52ms
// > Emitted 4 after 47ms
// Received 5 after 52ms
// > Emitted 5 after 49ms
// { _id: 'Chunk', values: [ 0, 1, 2, 3, 4, 5 ] }

----------------------------------------

TITLE: TypeScript Function Signature for Boolean Implication in Effect Library
DESCRIPTION: This code snippet shows the TypeScript function signature for the 'implies' function from the Effect library's Boolean module. It demonstrates that the function can be called with one or two boolean arguments.

LANGUAGE: typescript
CODE:
declare const implies: { (that: boolean): (self: boolean) => boolean; (self: boolean, that: boolean): boolean; }

----------------------------------------

TITLE: Merging Streams with Custom Mapping in TypeScript
DESCRIPTION: This example demonstrates how to use the Stream.mergeWith function to combine two streams with different element types, applying custom mapping functions to each stream. It shows the merging of a string stream and a number stream, with type conversion and scheduling.

LANGUAGE: typescript
CODE:
import { Effect, Schedule, Stream } from "effect"

const s1 = Stream.make("1", "2", "3").pipe(
  Stream.schedule(Schedule.spaced("100 millis"))
)
const s2 = Stream.make(4.1, 5.3, 6.2).pipe(
  Stream.schedule(Schedule.spaced("200 millis"))
)

const stream = Stream.mergeWith(s1, s2, {
  onSelf: (s) => parseInt(s),
  onOther: (n) => Math.floor(n)
})

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 1, 4, 2, 3, 5, 6 ] }

----------------------------------------

TITLE: Stream.takeWhile Function Signature in TypeScript
DESCRIPTION: The type signature for the Stream.takeWhile function, showing its polymorphic nature and ability to work with refinements and predicates.

LANGUAGE: typescript
CODE:
declare const takeWhile: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): <E, R>(self: Stream<A, E, R>) => Stream<B, E, R>; <A>(predicate: Predicate<NoInfer<A>>): <E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R, B extends A>(self: Stream<A, E, R>, refinement: Refinement<A, B>): Stream<B, E, R>; <A, E, R>(self: Stream<A, E, R>, predicate: Predicate<A>): Stream<A, E, R>; }

----------------------------------------

TITLE: Using Effect.logTrace with Logger Configuration
DESCRIPTION: Demonstrates how to use Effect.logTrace to log messages at TRACE level and configure the minimum log level. The example shows how to make trace messages visible by adjusting the logger configuration.

LANGUAGE: typescript
CODE:
import { Effect, Logger, LogLevel } from "effect"

const program = Effect.logTrace("message1").pipe(Logger.withMinimumLogLevel(LogLevel.Trace))

Effect.runFork(program)
// timestamp=... level=TRACE fiber=#0 message=message1

----------------------------------------

TITLE: Checking Predicate for Every HashSet Element with Refinement in TypeScript
DESCRIPTION: Demonstrates how to use the 'every' function with a Refinement to check if all elements in a HashSet are strings. It shows data-last (pipeable), piped, and data-first API styles.

LANGUAGE: typescript
CODE:
import { HashSet, pipe, Predicate } from "effect"

const numberOrString = HashSet.make(1, "1", "one", "uno")

// with `data-last`, a.k.a. `pipeable` API and `Refinement`
pipe(
  numberOrString, // HashSet.HashSet<number | string>
  HashSet.every(Predicate.isString)
) // HashSet.HashSet<string>

// or piped with the pipe function and  `Refinement`
numberOrString // HashSet.HashSet<number | string>
  .pipe(HashSet.every(Predicate.isString)) // HashSet.HashSet<string>

// or with `data-first` API and `Refinement`
HashSet.every(
  numberOrString, // HashSet.HashSet<number | string>
  Predicate.isString
) // HashSet.HashSet<string>

----------------------------------------

TITLE: Implementing Option.getOrThrowWith in TypeScript
DESCRIPTION: Example demonstrating how to use getOrThrowWith to extract values from Option types with custom error handling. Shows both successful value extraction and error throwing scenarios.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Option } from "effect"

assert.deepStrictEqual(
  Option.getOrThrowWith(Option.some(1), () => new Error('Unexpected None')),
  1
)
assert.throws(() => Option.getOrThrowWith(Option.none(), () => new Error('Unexpected None')))

----------------------------------------

TITLE: TypeScript Function Signature for every() in Boolean Module
DESCRIPTION: This code block shows the TypeScript function signature for the 'every' function in the Boolean module. It takes an iterable of boolean values and returns a boolean.

LANGUAGE: typescript
CODE:
declare const every: (collection: Iterable<boolean>) => boolean

----------------------------------------

TITLE: Using catWithLineBreak in TypeScript
DESCRIPTION: Demonstrates how to use the catWithLineBreak function to concatenate two documents with a line break. It also shows the difference when the result is grouped.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import { pipe } from "effect/Function"
import * as String from "effect/String"

const doc: Doc.Doc<never> = pipe(
  Doc.char("a"),
  Doc.catWithLineBreak(Doc.char("b"))
)

assert.strictEqual(
  Doc.render(doc, { style: "pretty" }),
  String.stripMargin(
    `|a
     |b`
  )
)

assert.strictEqual(
  Doc.render(Doc.group(doc), { style: "pretty" }),
  "ab"
)

----------------------------------------

TITLE: Implementing Conditional Tracing Disabling for HTTP Client Requests in TypeScript
DESCRIPTION: Defines a function that disables tracing for HTTP client requests based on a predicate. It can be used in two ways: either by passing the predicate first and then the effect, or by passing the effect first and then the predicate.

LANGUAGE: typescript
CODE:
declare const withTracerDisabledWhen: {
  (predicate: Predicate.Predicate<ClientRequest.HttpClientRequest>): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>;
  <A, E, R>(effect: Effect.Effect<A, E, R>, predicate: Predicate.Predicate<ClientRequest.HttpClientRequest>): Effect.Effect<A, E, R>;
}

----------------------------------------

TITLE: Defining GenAI Operation Attributes Interface in TypeScript
DESCRIPTION: Defines an interface for telemetry attributes specific to GenAI operations. The interface includes an optional 'name' property that can be a string, a WellKnownOperationName, null, or undefined.

LANGUAGE: typescript
CODE:
export interface OperationAttributes {
    readonly name?: (string & {}) | WellKnownOperationName | null | undefined
  }

----------------------------------------

TITLE: Declaring Sized Service in TypeScript for Effect Testing
DESCRIPTION: Defines a constant 'sized' that represents an Effect for retrieving the Sized service in a test environment. It has no input requirements and no error type, returning a TestSized instance.

LANGUAGE: typescript
CODE:
declare const sized: Effect.Effect<Sized.TestSized, never, never>

----------------------------------------

TITLE: Effect.mapBoth Function Signature in TypeScript
DESCRIPTION: This code snippet shows the TypeScript signature for the Effect.mapBoth function. It demonstrates the function's overloads and type parameters.

LANGUAGE: typescript
CODE:
declare const mapBoth: { <E, E2, A, A2>(options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2; }): <R>(self: Effect<A, E, R>) => Effect<A2, E2, R>; <A, E, R, E2, A2>(self: Effect<A, E, R>, options: { readonly onFailure: (e: E) => E2; readonly onSuccess: (a: A) => A2; }): Effect<A2, E2, R>; }

----------------------------------------

TITLE: Creating Maximum Monoid in TypeScript
DESCRIPTION: The max function creates a monoid where the combine operation returns the maximum value based on a provided bounded order. The empty value is set to the minimum value of the bounded order.

LANGUAGE: typescript
CODE:
declare const max: <A>(B: Bounded<A>) => Monoid<A>

----------------------------------------

TITLE: Implementing Missing Error Class in TypeScript
DESCRIPTION: Defines a Missing error class that represents missing required keys or indices during parsing. Takes an AST type and optional error message as constructor parameters.

LANGUAGE: typescript
CODE:
declare class Missing { constructor(
    /**
     * @since 3.10.0
     */
    readonly ast: AST.Type,
    /**
     * @since 3.10.0
     */
    readonly message?: string
  ) }

----------------------------------------

TITLE: Defining Capitalize Schema Class in TypeScript
DESCRIPTION: Declares the Capitalize class in the Schema module of the Effect library. This schema is used to convert a string to its capitalized form.

LANGUAGE: typescript
CODE:
declare class Capitalize

----------------------------------------

TITLE: TypeScript Signature of Either.all Function
DESCRIPTION: This code snippet shows the TypeScript signature of the Either.all function. It demonstrates the complex type inference capabilities, handling various input types and their corresponding output types.

LANGUAGE: typescript
CODE:
declare const all: <const I extends Iterable<Either<any, any>> | Record<string, Either<any, any>>>(input: I) => [I] extends [ReadonlyArray<Either<any, any>>] ? Either<{ -readonly [K in keyof I]: [I[K]] extends [Either<infer R, any>] ? R : never; }, I[number] extends never ? never : [I[number]] extends [Either<any, infer L>] ? L : never> : [I] extends [Iterable<Either<infer R, infer L>>] ? Either<Array<R>, L> : Either<{ -readonly [K in keyof I]: [I[K]] extends [Either<infer R, any>] ? R : never; }, I[keyof I] extends never ? never : [I[keyof I]] extends [Either<any, infer L>] ? L : never>

----------------------------------------

TITLE: Implementing Value Clamping with Bounded Typeclass in TypeScript
DESCRIPTION: A function that constrains a value of type A within the bounds defined by a Bounded<A> instance. The function takes a Bounded instance and returns a function that clamps values between minBound and maxBound.

LANGUAGE: typescript
CODE:
declare const clamp: <A>(B: Bounded<A>) => (a: A) => A

----------------------------------------

TITLE: Demonstrating Struct.omit Usage in TypeScript
DESCRIPTION: This example shows how to use the Struct.omit function to create new objects by omitting specific properties from existing objects. It demonstrates both pipe and direct function call syntax.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { pipe, Struct } from "effect"

assert.deepStrictEqual(pipe({ a: "a", b: 1, c: true }, Struct.omit("c")), { a: "a", b: 1 })
assert.deepStrictEqual(Struct.omit({ a: "a", b: 1, c: true }, "c"), { a: "a", b: 1 })

----------------------------------------

TITLE: Function Signature for NOR Operation in TypeScript
DESCRIPTION: This code block shows the TypeScript function signature for the 'nor' function. It indicates that the function can be called with either one or two boolean arguments, returning a boolean result.

LANGUAGE: typescript
CODE:
declare const nor: { (that: boolean): (self: boolean) => boolean; (self: boolean, that: boolean): boolean; }

----------------------------------------

TITLE: Creating Stream from Channel in TypeScript
DESCRIPTION: The fromChannel function creates a Stream from a Channel. It takes a Channel that produces chunks of type A and potentially errors of type E, and returns a Stream of the same types. The function is part of the Stream module in the Effect package.

LANGUAGE: typescript
CODE:
declare const fromChannel: <A, E, R>(channel: Channel.Channel<Chunk.Chunk<A>, unknown, E, unknown, unknown, unknown, R>) => Stream<A, E, R>

----------------------------------------

TITLE: Implementing pretty Layout Algorithm in TypeScript
DESCRIPTION: Defines the pretty layout algorithm function signature which supports two calling patterns - one taking options first and returning a function, and another taking both document and options together. The algorithm commits to rendering based on next element fitting layout constraints.

LANGUAGE: typescript
CODE:
declare const pretty: { (options: Layout.Options): <A>(self: Doc<A>) => DocStream<A>; <A>(self: Doc<A>, options: Layout.Options): DocStream<A>; }

----------------------------------------

TITLE: Implementing List.take Operation in TypeScript
DESCRIPTION: Function signature for taking N elements from the beginning of a List. Supports both curried and uncurried calling styles, allowing either passing the count first or the list first with the count parameter.

LANGUAGE: typescript
CODE:
declare const take: { (n: number): <A>(self: List<A>) => List<A>; <A>(self: List<A>, n: number): List<A>; }

----------------------------------------

TITLE: Defining Schedule.ensuring Function in TypeScript
DESCRIPTION: Declares the `ensuring` function which attaches a finalizer to a schedule. The finalizer runs when the schedule completes. It returns a new schedule that executes the given finalizer upon completion. Unlike `Effect.ensuring`, it doesn't guarantee the finalizer will run in all cases.

LANGUAGE: typescript
CODE:
declare const ensuring: { <X>(finalizer: Effect.Effect<X, never, never>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R, X>(self: Schedule<Out, In, R>, finalizer: Effect.Effect<X, never, never>): Schedule<Out, In, R>; }

----------------------------------------

TITLE: Converting Option<Either> to Either<Option> in TypeScript
DESCRIPTION: Example demonstrating how to use Either.transposeOption to convert an Option containing an Either into an Either containing an Option. Shows conversion of Option.some(Either.right(42)) into a wrapped result.

LANGUAGE: typescript
CODE:
import { Effect, Either, Option } from "effect"

//      ┌─── Option<Either<number, never>>
//      ▼
const maybe = Option.some(Either.right(42))

//      ┌─── Either<Option<number>, never, never>
//      ▼
const result = Either.transposeOption(maybe)

console.log(Effect.runSync(result))
// Output: { _id: 'Option', _tag: 'Some', value: 42 }

----------------------------------------

TITLE: Defining mapRequest Function for HTTP Client Request Transformation in TypeScript
DESCRIPTION: This code snippet defines the mapRequest function, which allows for the transformation of an HTTP client request before it is sent. It can be used in two ways: as a higher-order function or as a method on an existing HttpClient instance.

LANGUAGE: typescript
CODE:
declare const mapRequest: {
  (f: (a: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E, R>;
  <E, R>(self: HttpClient.With<E, R>, f: (a: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest): HttpClient.With<E, R>;
}

----------------------------------------

TITLE: Adding Fixed Offset Time Zone to DateTime in TypeScript
DESCRIPTION: This snippet demonstrates how to use the setZoneOffset function from the DateTime module to add a fixed offset time zone to a DateTime object. The offset is specified in milliseconds.

LANGUAGE: typescript
CODE:
import { DateTime, Effect } from "effect"

Effect.gen(function* () {
  const now = yield* DateTime.now

  // set the offset time zone in milliseconds
  const zoned: DateTime.Zoned = DateTime.setZoneOffset(now, 3 * 60 * 60 * 1000)
})

----------------------------------------

TITLE: Defining scopedWith Function in TypeScript for Effect Channel Module
DESCRIPTION: Declares the scopedWith function, which takes a function that receives a Scope and returns an Effect to emit an output element. The output element will be the result of the returned effect if successful.

LANGUAGE: typescript
CODE:
declare const scopedWith: <A, E, R>(f: (scope: Scope.Scope) => Effect.Effect<A, E, R>) => Channel<A, unknown, E, unknown, unknown, unknown, R>

----------------------------------------

TITLE: Offering a Value to TQueue in TypeScript
DESCRIPTION: The offer function places one value in the queue. It can be called in two ways: either by passing the value first and then the queue, or by passing the queue first and then the value. It returns an STM.STM<void>.

LANGUAGE: typescript
CODE:
declare const offer: { <A>(value: A): (self: TEnqueue<A>) => STM.STM<void>; <A>(self: TEnqueue<A>, value: A): STM.STM<void>; }

----------------------------------------

TITLE: Zipping Streams with Custom Combiners in TypeScript
DESCRIPTION: Demonstrates how to zip two streams of different lengths using custom combination functions. The example shows combining a numeric stream with a string stream, handling both matched and unmatched elements with different transformation rules.

LANGUAGE: typescript
CODE:
import { Effect, Stream } from "effect"

const stream = Stream.zipAllWith(Stream.make(1, 2, 3, 4, 5, 6), {
  other: Stream.make("a", "b", "c"),
  onSelf: (n) => [n, "x"],
  onOther: (s) => [0, s],
  onBoth: (n, s) => [n - s.length, s]
})

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: "Chunk", values: [ [ 0, "a" ], [ 1, "b" ], [ 2, "c" ], [ 4, "x" ], [ 5, "x" ], [ 6, "x" ] ] }

LANGUAGE: typescript
CODE:
declare const zipAllWith: { <A2, E2, R2, A, A3>(options: { readonly other: Stream<A2, E2, R2>; readonly onSelf: (a: A) => A3; readonly onOther: (a2: A2) => A3; readonly onBoth: (a: A, a2: A2) => A3; }): <E, R>(self: Stream<A, E, R>) => Stream<A3, E2 | E, R2 | R>; <A, E, R, A2, E2, R2, A3>(self: Stream<A, E, R>, options: { readonly other: Stream<A2, E2, R2>; readonly onSelf: (a: A) => A3; readonly onOther: (a2: A2) => A3; readonly onBoth: (a: A, a2: A2) => A3; }): Stream<A3, E | E2, R | R2>; }

----------------------------------------

TITLE: Unwrapping Effect into Stream in TypeScript
DESCRIPTION: Function signature for unwrapping an Effect instance that produces a Stream into a Stream. Takes an Effect that produces a Stream of type A with error types E2 and E, and resource types R2 and R, returning a combined Stream.

LANGUAGE: typescript
CODE:
declare const unwrap: <A, E2, R2, E, R>(effect: Effect.Effect<Stream<A, E2, R2>, E, R>) => Stream<A, E | E2, R | R2>

----------------------------------------

TITLE: Modifying Non-Empty Array Head in TypeScript
DESCRIPTION: Example demonstrating how to use Array.modifyNonEmptyHead to apply a transformation function to the first element of a non-empty array. The function takes an array and a transformation function as arguments.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const result = Array.modifyNonEmptyHead([1, 2, 3], n => n * 10)
console.log(result) // [10, 2, 3]

----------------------------------------

TITLE: Defining isString Function Signature in TypeScript
DESCRIPTION: Provides the TypeScript type declaration for the isString function. It shows that the function takes an unknown input and returns a boolean indicating if the input is a string.

LANGUAGE: typescript
CODE:
declare const isString: (input: unknown) => input is string

----------------------------------------

TITLE: Defining Monoid Reverse Function in TypeScript
DESCRIPTION: Implementation of a higher-order function that takes a Monoid and returns its dual by reversing the combine operation. The function preserves the Monoid type structure while modifying its behavior.

LANGUAGE: typescript
CODE:
declare const reverse: <A>(M: Monoid<A>) => Monoid<A>

----------------------------------------

TITLE: Defining RequestResolver.around Function in TypeScript
DESCRIPTION: Defines the 'around' function, which is a data source aspect that executes requests between two effects, 'before' and 'after'. The result of 'before' can be used by 'after'. It provides two overloaded signatures for different use cases.

LANGUAGE: typescript
CODE:
declare const around: {
  <A2, R2, X, R3>(
    before: Effect.Effect<A2, never, R2>,
    after: (a: A2) => Effect.Effect<X, never, R3>
  ): <A, R>(self: RequestResolver<A, R>) => RequestResolver<A, R2 | R3 | R>;
  <A, R, A2, R2, X, R3>(
    self: RequestResolver<A, R>,
    before: Effect.Effect<A2, never, R2>,
    after: (a: A2) => Effect.Effect<X, never, R3>
  ): RequestResolver<A, R | R2 | R3>;
}

----------------------------------------

TITLE: Type Guard Function for WithPageWidth Doc Type in TypeScript
DESCRIPTION: A type guard function that checks if a given Doc<A> is specifically a WithPageWidth<A> instance. This function enables type narrowing in TypeScript when working with Doc types.

LANGUAGE: typescript
CODE:
declare const isWithPageWidth: <A>(self: Doc<A>) => self is WithPageWidth<A>

----------------------------------------

TITLE: Type Signature for Effect.zipWith in TypeScript
DESCRIPTION: Provides the type signature for the Effect.zipWith function. It shows the function's polymorphic nature, allowing for different effect types and result combinations.

LANGUAGE: typescript
CODE:
declare const zipWith: { <A2, E2, R2, A, B>(that: Effect<A2, E2, R2>, f: (a: A, b: A2) => B, options?: { readonly concurrent?: boolean | undefined; readonly batching?: boolean | "inherit" | undefined; readonly concurrentFinalizers?: boolean | undefined; }): <E, R>(self: Effect<A, E, R>) => Effect<B, E2 | E, R2 | R>; <A, E, R, A2, E2, R2, B>(self: Effect<A, E, R>, that: Effect<A2, E2, R2>, f: (a: A, b: A2) => B, options?: { readonly concurrent?: boolean | undefined; readonly batching?: boolean | "inherit" | undefined; readonly concurrentFinalizers?: boolean | undefined; }): Effect<B, E2 | E, R2 | R>; }

----------------------------------------

TITLE: Converting Duration to Human Readable String in TypeScript
DESCRIPTION: Demonstrates how to use Duration.format to convert Duration objects into human-readable strings. The function takes a DurationInput parameter and returns a formatted string showing time units like seconds and milliseconds.

LANGUAGE: typescript
CODE:
import { Duration } from "effect"

Duration.format(Duration.millis(1000)) // "1s"
Duration.format(Duration.millis(1001)) // "1s 1ms"

LANGUAGE: typescript
CODE:
declare const format: (self: DurationInput) => string

----------------------------------------

TITLE: Transforming Errors with Cause.map in TypeScript
DESCRIPTION: Function signature for mapping errors in a Cause object. Takes a transformation function and applies it to Fail errors while preserving other error types. Supports both curried and uncurried calling styles.

LANGUAGE: typescript
CODE:
declare const map: { <E, E2>(f: (e: E) => E2): (self: Cause<E>) => Cause<E2>; <E, E2>(self: Cause<E>, f: (e: E) => E2): Cause<E2>; }

----------------------------------------

TITLE: Doc.seps Type Definition
DESCRIPTION: Type signature for the seps combinator function that takes an iterable of Doc<A> and returns a Doc<A>.

LANGUAGE: typescript
CODE:
declare const seps: <A>(docs: Iterable<Doc<A>>) => Doc<A>

----------------------------------------

TITLE: Match.value Function Signature in TypeScript
DESCRIPTION: The type signature of the Match.value function, which creates a Matcher from a given value. It returns a Matcher with specific type parameters.

LANGUAGE: typescript
CODE:
declare const value: <const I>(i: I) => Matcher<I, Types.Without<never>, I, never, I>

----------------------------------------

TITLE: Implementing Left Constructor for Either Type in TypeScript
DESCRIPTION: Function signature for constructing a new Either instance holding a Left value. This constructor is used to represent failure cases due to Either's right-bias. The function takes a value of type L and returns an Either with a never right type and L left type.

LANGUAGE: typescript
CODE:
declare const left: <L>(left: L) => Either<never, L>

----------------------------------------

TITLE: Implementing Channel Fold Operation in TypeScript
DESCRIPTION: Defines a foldChannel function that enables folding over a channel's result with separate handlers for success and failure cases. The function provides type-safe transformations of channel outputs and maintains proper type relationships across the operation chain.

LANGUAGE: typescript
CODE:
declare const foldChannel: { <OutErr, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1, OutDone, OutElem2, InElem2, OutErr2, InErr2, OutDone2, InDone2, Env2>(options: { readonly onFailure: (error: OutErr) => Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>; readonly onSuccess: (done: OutDone) => Channel<OutElem2, InElem2, OutErr2, InErr2, OutDone2, InDone2, Env2>; }): <Env, InErr, InElem, InDone, OutElem>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1 | OutElem2 | OutElem, InElem & InElem1 & InElem2, OutErr1 | OutErr2, InErr & InErr1 & InErr2, OutDone1 | OutDone2, InDone & InDone1 & InDone2, Env1 | Env2 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1, OutElem2, InElem2, OutErr2, InErr2, OutDone2, InDone2, Env2>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, options: { readonly onFailure: (error: OutErr) => Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>; readonly onSuccess: (done: OutDone) => Channel<OutElem2, InElem2, OutErr2, InErr2, OutDone2, InDone2, Env2>; }): Channel<OutElem | OutElem1 | OutElem2, InElem & InElem1 & InElem2, OutErr1 | OutErr2, InErr & InErr1 & InErr2, OutDone1 | OutDone2, InDone & InDone1 & InDone2, Env | Env1 | Env2>; }

----------------------------------------

TITLE: Removing Key-Value Pairs from TMap in TypeScript
DESCRIPTION: Defines a function to remove a key-value binding from a TMap in a transactional context. The operation returns an STM (Software Transactional Memory) effect that completes with void.

LANGUAGE: typescript
CODE:
declare const remove: { <K>(key: K): <V>(self: TMap<K, V>) => STM.STM<void>; <K, V>(self: TMap<K, V>, key: K): STM.STM<void>; }

----------------------------------------

TITLE: Adding BigInt Values Using Effect Library in TypeScript
DESCRIPTION: Demonstrates how to use the 'sum' function from the Effect library's BigInt module to add two bigint values. The function is curried and can be used with either one or two arguments.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { sum } from "effect/BigInt"

assert.deepStrictEqual(sum(2n, 3n), 5n)

LANGUAGE: typescript
CODE:
declare const sum: { (that: bigint): (self: bigint) => bigint; (self: bigint, that: bigint): bigint; }

----------------------------------------

TITLE: Checking Queue Empty State in TypeScript Effect Library
DESCRIPTION: Type declaration for the isEmpty function that checks if a MutableQueue is empty. The function takes a MutableQueue of generic type A as input and returns a boolean indicating whether the queue contains any elements.

LANGUAGE: typescript
CODE:
declare const isEmpty: <A>(self: MutableQueue<A>) => boolean

----------------------------------------

TITLE: Retrieving Array Length in TypeScript using Effect Library
DESCRIPTION: This function returns the number of elements in a ReadonlyArray. It is part of the Array module in the Effect library and has been available since version 2.0.0.

LANGUAGE: typescript
CODE:
declare const length: <A>(self: ReadonlyArray<A>) => number

----------------------------------------

TITLE: Implementing Scoped Clock Service in Effect Module
DESCRIPTION: Function that sets a custom Clock service implementation for a scoped context and automatically restores the original implementation when the scope closes. Takes a Clock implementation as input and returns an Effect that requires a Scope and never fails.

LANGUAGE: typescript
CODE:
declare const withClockScoped: <C extends Clock.Clock>(clock: C) => Effect<void, never, Scope.Scope>

----------------------------------------

TITLE: TypeScript Function Signature for BigInt Comparison
DESCRIPTION: This code block shows the TypeScript function signature for the max function in the BigInt module. It defines two overloads: one that takes a single bigint parameter and returns a function, and another that takes two bigint parameters and returns a bigint.

LANGUAGE: typescript
CODE:
declare const max: { (that: bigint): (self: bigint) => bigint; (self: bigint, that: bigint): bigint; }

----------------------------------------

TITLE: Converting STM Failure to Option in TypeScript
DESCRIPTION: The 'option' function takes an STM computation and transforms its failure channel into an Option type. It returns a new STM computation that never fails but instead wraps the original result in an Option.

LANGUAGE: typescript
CODE:
declare const option: <A, E, R>(self: STM<A, E, R>) => STM<Option.Option<A>, never, R>

----------------------------------------

TITLE: Defining zipLeft Function for Fiber in TypeScript
DESCRIPTION: Declares the zipLeft function, which combines two Fibers and discards the output of the second Fiber. It handles different error types and preserves the output type of the first Fiber.

LANGUAGE: typescript
CODE:
declare const zipLeft: { <A2, E2>(that: Fiber<A2, E2>): <A, E>(self: Fiber<A, E>) => Fiber<A, E2 | E>; <A, E, A2, E2>(self: Fiber<A, E>, that: Fiber<A2, E2>): Fiber<A, E | E2>; }

----------------------------------------

TITLE: TypeScript Signature for HashSet forEach Method
DESCRIPTION: Provides the TypeScript type signature for the forEach method of the HashSet module. It shows the method's overloaded definitions for both data-last and data-first usage patterns.

LANGUAGE: typescript
CODE:
declare const forEach: { <A>(f: (value: A) => void): (self: HashSet<A>) => void; <A>(self: HashSet<A>, f: (value: A) => void): void; }

----------------------------------------

TITLE: Effect.andThen Type Signature
DESCRIPTION: Type definition for the Effect.andThen operator showing its polymorphic nature and type constraints.

LANGUAGE: typescript
CODE:
declare const andThen: { <A, X>(f: (a: NoInfer<A>) => X): <E, R>(self: Effect<A, E, R>) => [X] extends [Effect<infer A1, infer E1, infer R1>] ? Effect<A1, E | E1, R | R1> : [X] extends [PromiseLike<infer A1>] ? Effect<A1, E | Cause.UnknownException, R> : Effect<X, E, R>; <X>(f: NotFunction<X>): <A, E, R>(self: Effect<A, E, R>) => [X] extends [Effect<infer A1, infer E1, infer R1>] ? Effect<A1, E | E1, R | R1> : [X] extends [PromiseLike<infer A1>] ? Effect<A1, E | Cause.UnknownException, R> : Effect<X, E, R>; <A, E, R, X>(self: Effect<A, E, R>, f: (a: NoInfer<A>) => X): [X] extends [Effect<infer A1, infer E1, infer R1>] ? Effect<A1, E | E1, R | R1> : [X] extends [PromiseLike<infer A1>] ? Effect<A1, E | Cause.UnknownException, R> : Effect<X, E, R>; <A, E, R, X>(self: Effect<A, E, R>, f: NotFunction<X>): [X] extends [Effect<infer A1, infer E1, infer R1>] ? Effect<A1, E | E1, R | R1> : [X] extends [PromiseLike<infer A1>] ? Effect<A1, E | Cause.UnknownException, R> : Effect<X, E, R>; }

----------------------------------------

TITLE: Implementing Stream.either Type Definition in TypeScript
DESCRIPTION: Type definition for the either function that transforms a Stream<A, E, R> into a Stream<Either<A, E>, never, R>. This transformation exposes both successes and failures as Either values, making the resulting stream unable to fail.

LANGUAGE: typescript
CODE:
declare const either: <A, E, R>(self: Stream<A, E, R>) => Stream<Either.Either<A, E>, never, R>

----------------------------------------

TITLE: Retrieving Current Time in Current Time Zone using Effect in TypeScript
DESCRIPTION: This snippet demonstrates how to use the nowInCurrentZone function from the DateTime module in the effect package. It retrieves the current time as a DateTime.Zoned object using the CurrentTimeZone, specifically set to 'Europe/London' in this example.

LANGUAGE: typescript
CODE:
import { DateTime, Effect } from "effect"

Effect.gen(function* () {
  // will use the "Europe/London" time zone
  const now = yield* DateTime.nowInCurrentZone
}).pipe(DateTime.withCurrentZoneNamed("Europe/London"))

----------------------------------------

TITLE: Type Guard Implementation for MergeDecision in TypeScript
DESCRIPTION: A type guard function that checks if an unknown value is a MergeDecision instance. The function takes an unknown input and returns a type predicate indicating if the value is a MergeDecision with generic type parameters.

LANGUAGE: typescript
CODE:
declare const isMergeDecision: (u: unknown) => u is MergeDecision<unknown, unknown, unknown, unknown, unknown>

----------------------------------------

TITLE: Comparing BigInt Values in TypeScript using effect/BigInt
DESCRIPTION: This snippet demonstrates how to use the max function from the effect/BigInt module to find the maximum of two bigint values. It imports the necessary assertion library and the max function, then performs a comparison and asserts the result.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { max } from "effect/BigInt"

assert.deepStrictEqual(max(2n, 3n), 3n)

----------------------------------------

TITLE: Converting Effect Stream to ReadableStream with Runtime Configuration
DESCRIPTION: Function signature for converting an Effect Stream to a Web API ReadableStream using a provided runtime. Supports optional queuing strategy configuration and handles generic type parameters for stream elements, errors, and runtime requirements.

LANGUAGE: typescript
CODE:
declare const toReadableStreamRuntime: { 
  <A, XR>(
    runtime: Runtime<XR>, 
    options?: { readonly strategy?: QueuingStrategy<A> | undefined; }
  ): <E, R extends XR>(self: Stream<A, E, R>) => ReadableStream<A>; 
  <A, E, XR, R extends XR>(
    self: Stream<A, E, R>, 
    runtime: Runtime<XR>, 
    options?: { readonly strategy?: QueuingStrategy<A> | undefined; }
  ): ReadableStream<A>; 
}

----------------------------------------

TITLE: Defining Stream.combine Function in TypeScript
DESCRIPTION: Defines the Stream.combine function, which combines elements from two streams using a provided function. It allows for maintaining internal state during the combining process.

LANGUAGE: typescript
CODE:
declare const combine: { <A2, E2, R2, S, R3, E, A, R4, R5, A3>(that: Stream<A2, E2, R2>, s: S, f: (s: S, pullLeft: Effect.Effect<A, Option.Option<E>, R3>, pullRight: Effect.Effect<A2, Option.Option<E2>, R4>) => Effect.Effect<Exit.Exit<readonly [A3, S], Option.Option<E2 | E>>, never, R5>): <R>(self: Stream<A, E, R>) => Stream<A3, E2 | E, R2 | R3 | R4 | R5 | R>; <R, A2, E2, R2, S, R3, E, A, R4, R5, A3>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>, s: S, f: (s: S, pullLeft: Effect.Effect<A, Option.Option<E>, R3>, pullRight: Effect.Effect<A2, Option.Option<E2>, R4>) => Effect.Effect<Exit.Exit<readonly [A3, S], Option.Option<E2 | E>>, never, R5>): Stream<A3, E2 | E, R | R2 | R3 | R4 | R5>; }

----------------------------------------

TITLE: Creating FiberMap-backed Effect Run Function in TypeScript
DESCRIPTION: The makeRuntime function creates an Effect run function that is backed by a FiberMap. It takes generic type parameters for the environment (R), key (K), error (E), and value (A). The function returns an Effect that, when run, produces a function to fork effects with specific keys and options.

LANGUAGE: typescript
CODE:
declare const makeRuntime: <R, K, E = unknown, A = unknown>() => Effect.Effect<(<XE extends E, XA extends A>(key: K, effect: Effect.Effect<XA, XE, R>, options?: (Runtime.RunForkOptions & { readonly onlyIfMissing?: boolean | undefined; }) | undefined) => Fiber.RuntimeFiber<XA, XE>), never, Scope.Scope | R>

----------------------------------------

TITLE: Calculating Remainder with BigDecimal in TypeScript
DESCRIPTION: Demonstrates how to use the BigDecimal.remainder function to calculate the remainder of division operations. It handles various scenarios including division by zero, which returns None.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { BigDecimal, Option } from "effect"

assert.deepStrictEqual(BigDecimal.remainder(BigDecimal.unsafeFromString("2"), BigDecimal.unsafeFromString("2")), Option.some(BigDecimal.unsafeFromString("0")))
assert.deepStrictEqual(BigDecimal.remainder(BigDecimal.unsafeFromString("3"), BigDecimal.unsafeFromString("2")), Option.some(BigDecimal.unsafeFromString("1")))
assert.deepStrictEqual(BigDecimal.remainder(BigDecimal.unsafeFromString("-4"), BigDecimal.unsafeFromString("2")), Option.some(BigDecimal.unsafeFromString("0")))

----------------------------------------

TITLE: Stream Broadcast Type Definition
DESCRIPTION: Type signature for the broadcast function showing its parameters and return types. The function accepts a count of output streams, maximum lag configuration, and returns an Effect containing a tuple of streams.

LANGUAGE: typescript
CODE:
declare const broadcast: { <N extends number>(n: N, maximumLag: number | { readonly capacity: "unbounded"; readonly replay?: number | undefined; } | { readonly capacity: number; readonly strategy?: "sliding" | "dropping" | "suspend" | undefined; readonly replay?: number | undefined; }): <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<TupleOf<N, Stream<A, E>>, never, Scope.Scope | R>; <A, E, R, N extends number>(self: Stream<A, E, R>, n: N, maximumLag: number | { readonly capacity: "unbounded"; readonly replay?: number | undefined; } | { readonly capacity: number; readonly strategy?: "sliding" | "dropping" | "suspend" | undefined; readonly replay?: number | undefined; }): Effect.Effect<TupleOf<N, Stream<A, E>>, never, Scope.Scope | R>; }

----------------------------------------

TITLE: Implementing Duration Tracking in Effect TypeScript
DESCRIPTION: Defines a trackDuration function that creates an aspect to measure the execution time of effects. The function accepts a metric parameter that must have Duration as its input type and returns an enhanced Effect that tracks its execution time.

LANGUAGE: typescript
CODE:
declare const trackDuration: { 
  <Type, Out>(metric: Metric<Type, Duration.Duration, Out>): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; 
  <A, E, R, Type, Out>(self: Effect.Effect<A, E, R>, metric: Metric<Type, Duration.Duration, Out>): Effect.Effect<A, E, R>; 
}

----------------------------------------

TITLE: Joining Fibers in FiberMap with TypeScript and Effect
DESCRIPTION: Demonstrates how to use FiberMap.join to combine all fibers in a FiberMap. If any fiber fails, the effect terminates with the first failure encountered. This example shows setting a fiber that fails and then joining the map.

LANGUAGE: typescript
CODE:
import { Effect, FiberMap } from "effect";

Effect.gen(function* (_) {
  const map = yield* _(FiberMap.make());
  yield* _(FiberMap.set(map, "a", Effect.runFork(Effect.fail("error"))));

  // parent fiber will fail with "error"
  yield* _(FiberMap.join(map));
});

----------------------------------------

TITLE: Defining getOrder Function for Array Comparison in TypeScript
DESCRIPTION: This function creates a new `Order` for arrays based on a given `Order` for array elements. It compares arrays by applying the element `Order` to each item, then by length if all elements are equal. Useful for comparing arrays with custom element comparison logic.

LANGUAGE: typescript
CODE:
declare const getOrder: <A>(O: Order.Order<A>) => Order.Order<ReadonlyArray<A>>

----------------------------------------

TITLE: Constructing Effect with Fiber Descriptor in TypeScript
DESCRIPTION: The descriptorWith function creates an effect based on the current Fiber's descriptor. It takes a function that receives a Fiber.Descriptor and returns an Effect. This allows for creating effects that depend on the current execution context.

LANGUAGE: typescript
CODE:
declare const descriptorWith: <A, E, R>(f: (descriptor: Fiber.Fiber.Descriptor) => Effect<A, E, R>) => Effect<A, E, R>

----------------------------------------

TITLE: Implementing NAND Operation in TypeScript using effect/Boolean
DESCRIPTION: This snippet demonstrates the usage of the nand function from the effect/Boolean module. It combines two boolean values using the NAND operation, which is equivalent to !(self && that).

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { nand } from "effect/Boolean"

assert.deepStrictEqual(nand(true, true), false)
assert.deepStrictEqual(nand(true, false), true)
assert.deepStrictEqual(nand(false, true), true)
assert.deepStrictEqual(nand(false, false), true)

----------------------------------------

TITLE: Creating TestConfig Layer in TypeScript
DESCRIPTION: Function that constructs a new TestConfig service layer with configurable test parameters including repeats, retries, samples, and shrinks counts.

LANGUAGE: typescript
CODE:
declare const testConfigLayer: (params: { readonly repeats: number; readonly retries: number; readonly samples: number; readonly shrinks: number; }) => Layer.Layer<TestConfig.TestConfig>

----------------------------------------

TITLE: Filtering Array with flatMapNullable in TypeScript
DESCRIPTION: Demonstrates how to use flatMapNullable to map over an array and remove null/undefined values. The function takes an array and a mapping function that can return null or undefined, producing a new array with only non-null values.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const result = Array.flatMapNullable([1, 2, 3], n => (n % 2 === 0 ? null : n))
console.log(result) // [1, 3]

LANGUAGE: typescript
CODE:
declare const flatMapNullable: { <A, B>(f: (a: A) => B | null | undefined): (self: ReadonlyArray<A>) => Array<NonNullable<B>>; <A, B>(self: ReadonlyArray<A>, f: (a: A) => B | null | undefined): Array<NonNullable<B>>; }

----------------------------------------

TITLE: Implementing Queue Take Operation in TypeScript using Effect STM
DESCRIPTION: Function declaration for taking up to a maximum number of values from a TDequeue. Supports both curried and non-curried invocation patterns, returning values wrapped in an STM transaction.

LANGUAGE: typescript
CODE:
declare const takeUpTo: { (max: number): <A>(self: TDequeue<A>) => STM.STM<Array<A>>; <A>(self: TDequeue<A>, max: number): STM.STM<Array<A>>; }

----------------------------------------

TITLE: Creating BigDecimal from bigint and scale in TypeScript
DESCRIPTION: The make function creates a BigDecimal instance from a bigint value and a scale. It takes two parameters: value (of type bigint) and scale (of type number), and returns a BigDecimal object.

LANGUAGE: typescript
CODE:
declare const make: (value: bigint, scale: number) => BigDecimal

----------------------------------------

TITLE: Disabling RuntimeFlags in TypeScript
DESCRIPTION: The disableAll function is used to disable all RuntimeFlags in a specified set. It can be called with either one or two arguments, allowing for flexible usage patterns.

LANGUAGE: typescript
CODE:
declare const disableAll: { (flags: RuntimeFlags): (self: RuntimeFlags) => RuntimeFlags; (self: RuntimeFlags, flags: RuntimeFlags): RuntimeFlags; }

----------------------------------------

TITLE: Defining contextWithChannel Function in TypeScript
DESCRIPTION: Declares the contextWithChannel function, which accesses the context of a channel within another channel's context. It takes a function as an argument and returns a new Channel with combined environment types.

LANGUAGE: typescript
CODE:
declare const contextWithChannel: <Env, OutElem, InElem, OutErr, InErr, OutDone, InDone, Env1>(f: (env: Context.Context<Env>) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env1>) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env | Env1>

----------------------------------------

TITLE: Implementing Stream.dieSync in TypeScript
DESCRIPTION: Defines a function that creates a stream that terminates with a lazily evaluated defect. The function takes a LazyArg parameter that evaluates to the defect value and returns a Stream that never produces any values.

LANGUAGE: typescript
CODE:
declare const dieSync: (evaluate: LazyArg<unknown>) => Stream<never>

----------------------------------------

TITLE: Defining minimum Interval function in TypeScript
DESCRIPTION: Declares a function 'min' that takes two Interval parameters and returns the minimum Interval. It supports both curried and non-curried invocations.

LANGUAGE: typescript
CODE:
declare const min: { (that: Interval): (self: Interval) => Interval; (self: Interval, that: Interval): Interval; }

----------------------------------------

TITLE: Retrieving Reversed Keys from RedBlackTree in TypeScript
DESCRIPTION: A function that returns an IterableIterator containing all keys present in a RedBlackTree data structure in reverse order. The function takes a RedBlackTree instance as input and works with generic key and value types.

LANGUAGE: typescript
CODE:
declare const keysReversed: <K, V>(self: RedBlackTree<K, V>) => IterableIterator<K>

----------------------------------------

TITLE: Type Signature of isUnknown Function in TypeScript
DESCRIPTION: Provides the type signature for the isUnknown function. It takes an unknown input and returns a boolean indicating whether the input is of type unknown.

LANGUAGE: typescript
CODE:
declare const isUnknown: (input: unknown) => input is unknown

----------------------------------------

TITLE: Implementing Error Handling for Channels in TypeScript
DESCRIPTION: Defines a 'catchAll' function that creates a new channel with enhanced error handling. It allows fallback to an alternative channel if the original one encounters any typed error.

LANGUAGE: typescript
CODE:
declare const catchAll: { <OutErr, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(f: (error: OutErr) => Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>): <OutElem, InElem, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1 | OutElem, InElem & InElem1, OutErr1, InErr & InErr1, OutDone1 | OutDone, InDone & InDone1, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (error: OutErr) => Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>): Channel<OutElem | OutElem1, InElem & InElem1, OutErr1, InErr & InErr1, OutDone | OutDone1, InDone & InDone1, Env | Env1>; }

----------------------------------------

TITLE: Defining parseNumber Function in TypeScript
DESCRIPTION: Declares the parseNumber function that transforms a string into a number. It uses the parse function from the effect/Number module and handles special string values like "NaN", "Infinity", and "-Infinity". Returns an error for non-convertible values.

LANGUAGE: typescript
CODE:
declare const parseNumber: <S extends Schema.Any, A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => transformOrFail<S, typeof Number$>

----------------------------------------

TITLE: Defining Effect.optionFromOptional Function Signature in TypeScript
DESCRIPTION: This snippet shows the TypeScript function signature for Effect.optionFromOptional. It takes an Effect that may produce a value of type A or fail with an error of type E, and returns an Effect that produces an Option<A> or fails with an error of type E (excluding NoSuchElementException).

LANGUAGE: typescript
CODE:
declare const optionFromOptional: <A, E, R>(self: Effect<A, E, R>) => Effect<Option.Option<A>, Exclude<E, Cause.NoSuchElementException>, R>

----------------------------------------

TITLE: TypeScript Function Signature for firstSomeOf in Option Module
DESCRIPTION: Provides the TypeScript function signature for the firstSomeOf function. This signature shows that the function takes an iterable collection of Options and returns an Option of the inferred type.

LANGUAGE: typescript
CODE:
declare const firstSomeOf: <T, C extends Iterable<Option<T>> = Iterable<Option<T>>>(collection: C) => [C] extends [Iterable<Option<infer A>>] ? Option<A> : never

----------------------------------------

TITLE: Checking RuntimeFlag Status in TypeScript
DESCRIPTION: The isEnabled function determines if a given RuntimeFlag is enabled in a RuntimeFlagsPatch. It can be called with either the flag first and self second, or self first and flag second.

LANGUAGE: typescript
CODE:
declare const isEnabled: { (flag: RuntimeFlags.RuntimeFlag): (self: RuntimeFlagsPatch) => boolean; (self: RuntimeFlagsPatch, flag: RuntimeFlags.RuntimeFlag): boolean; }

----------------------------------------

TITLE: Defining GenAITelemetryAttributes Type for OpenTelemetry in TypeScript
DESCRIPTION: A TypeScript type definition that combines multiple GenAI-related attribute interfaces using intersection types. It includes attributes for base properties, operations, tokens, usage metrics, requests, and responses, all prefixed with appropriate namespaces following OpenTelemetry conventions.

LANGUAGE: typescript
CODE:
type GenAITelemetryAttributes = Simplify<
  & GenAI.AttributesWithPrefix<GenAI.BaseAttributes, "gen_ai">
  & GenAI.AttributesWithPrefix<GenAI.OperationAttributes, "gen_ai.operation">
  & GenAI.AttributesWithPrefix<GenAI.TokenAttributes, "gen_ai.token">
  & GenAI.AttributesWithPrefix<GenAI.UsageAttributes, "gen_ai.usage">
  & GenAI.AttributesWithPrefix<GenAI.RequestAttributes, "gen_ai.request">
  & GenAI.AttributesWithPrefix<GenAI.ResponseAttributes, "gen_ai.response">
>

----------------------------------------

TITLE: Doc.empty Type Definition in TypeScript
DESCRIPTION: Type signature for the Doc.empty constructor, showing it creates a Doc with never type parameter.

LANGUAGE: typescript
CODE:
declare const empty: Doc<never>

----------------------------------------

TITLE: Declaring zipLeft Function for Option Combination in TypeScript
DESCRIPTION: This code snippet declares the zipLeft function, which combines two Option values. It keeps the value from the first Option if both are Some, returning None if either Option is None. The function is useful for sequencing computations where the second Option's value is irrelevant but must exist.

LANGUAGE: typescript
CODE:
declare const zipLeft: { <_>(that: Option<_>): <A>(self: Option<A>) => Option<A>; <A, X>(self: Option<A>, that: Option<X>): Option<A>; }

----------------------------------------

TITLE: Defining lessThanEqualReversed Function in TypeScript for RedBlackTree
DESCRIPTION: This code snippet defines the lessThanEqualReversed function for the RedBlackTree data structure. It returns an iterator that traverses entries in reverse order with keys less than or equal to the specified key. The function is overloaded to accept either the key first or the RedBlackTree instance first.

LANGUAGE: typescript
CODE:
declare const lessThanEqualReversed: { <K>(key: K): <V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>; <K, V>(self: RedBlackTree<K, V>, key: K): Iterable<[K, V]>; }

----------------------------------------

TITLE: Retrieving Record Values as Array in TypeScript
DESCRIPTION: The 'values' function takes a readonly record and returns an array of its values. It works with records having string keys and any value type.

LANGUAGE: typescript
CODE:
declare const values: <K extends string, A>(self: ReadonlyRecord<K, A>) => Array<A>

----------------------------------------

TITLE: Interrupting Child Effects in TypeScript using Effect Package
DESCRIPTION: The interruptWhenPossible function interrupts a child effect when specified requests are no longer needed. It can be called with either the effect first and requests second, or requests first and effect second.

LANGUAGE: typescript
CODE:
declare const interruptWhenPossible: { (all: Iterable<Request<any, any>>): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<void, E, R>; <A, E, R>(self: Effect.Effect<A, E, R>, all: Iterable<Request<any, any>>): Effect.Effect<void, E, R>; }

----------------------------------------

TITLE: TypeScript Function Signature for Effect.catchAllDefect
DESCRIPTION: Provides the TypeScript function signature for the catchAllDefect method in the Effect module. It shows the method's type definition and parameter types.

LANGUAGE: typescript
CODE:
declare const catchAllDefect: { <A2, E2, R2>(f: (defect: unknown) => Effect<A2, E2, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, f: (defect: unknown) => Effect<A2, E2, R2>): Effect<A | A2, E | E2, R | R2>; }

----------------------------------------

TITLE: Implementing Stream Head Extraction in TypeScript
DESCRIPTION: Function that executes a stream and returns an Effect containing an Option of the first emitted value. The operation discards all subsequent elements after retrieving the first value.

LANGUAGE: typescript
CODE:
declare const runHead: <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<Option.Option<A>, E, R>

----------------------------------------

TITLE: Using forEach Method with HashSet in TypeScript
DESCRIPTION: Demonstrates different ways to use the forEach method on a HashSet, including data-last (pipeable) API, pipe method, and data-first API. The method applies a specified function to each value in the HashSet.

LANGUAGE: typescript
CODE:
// Syntax
import { HashSet, pipe } from "effect"

// with `data-last`, a.k.a. `pipeable` API
pipe(HashSet.make(0, 1, 2), HashSet.forEach(console.log)) // logs: 0 1 2

// or piped with the pipe method
HashSet.make(0, 1, 2).pipe(HashSet.forEach(console.log)) // logs: 0 1 2

// or with `data-first` API
HashSet.forEach(HashSet.make(0, 1, 2), console.log) // logs: 0 1 2

----------------------------------------

TITLE: Failing a Deferred with a Cause in TypeScript
DESCRIPTION: The failCauseSync function fails a Deferred with a specified Cause, which is then propagated to all fibers waiting on the Deferred's value. It returns an Effect that resolves to a boolean.

LANGUAGE: typescript
CODE:
declare const failCauseSync: { <E>(evaluate: LazyArg<Cause.Cause<E>>): <A>(self: Deferred<A, E>) => Effect.Effect<boolean>; <A, E>(self: Deferred<A, E>, evaluate: LazyArg<Cause.Cause<E>>): Effect.Effect<boolean>; }

----------------------------------------

TITLE: Implementing Boolean AND Operation in TypeScript
DESCRIPTION: Demonstrates the usage of the 'and' function that performs a logical AND operation between two boolean values. The function supports both curried and uncurried forms of invocation.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { and } from "effect/Boolean"

assert.deepStrictEqual(and(true, true), true)
assert.deepStrictEqual(and(true, false), false)
assert.deepStrictEqual(and(false, true), false)
assert.deepStrictEqual(and(false, false), false)

LANGUAGE: typescript
CODE:
declare const and: { (that: boolean): (self: boolean) => boolean; (self: boolean, that: boolean): boolean; }

----------------------------------------

TITLE: Mapping Effect Fiber Values with TypeScript
DESCRIPTION: Defines a function that effectually maps over the value computed by a fiber. Takes a mapping function that returns an Effect and transforms the fiber's result type accordingly. Supports both curried and uncurried function signatures.

LANGUAGE: typescript
CODE:
declare const mapEffect: { <A, A2, E2>(f: (a: A) => Effect.Effect<A2, E2>): <E>(self: Fiber<A, E>) => Fiber<A2, E2 | E>; <A, E, A2, E2>(self: Fiber<A, E>, f: (a: A) => Effect.Effect<A2, E2>): Fiber<A2, E | E2>; }

----------------------------------------

TITLE: Implementing Layer.flatMap Operation in TypeScript
DESCRIPTION: Defines a flatMap operation that enables dynamic layer construction based on the context output of an existing layer. The operation supports combining layers with different error and requirement types.

LANGUAGE: typescript
CODE:
declare const flatMap: { <A, A2, E2, R2>(f: (context: Context.Context<A>) => Layer<A2, E2, R2>): <E, R>(self: Layer<A, E, R>) => Layer<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Layer<A, E, R>, f: (context: Context.Context<A>) => Layer<A2, E2, R2>): Layer<A2, E | E2, R | R2>; }

----------------------------------------

TITLE: Implementing List Prepend Operation in TypeScript
DESCRIPTION: Function signature for prependAllReversed that takes a prefix list and prepends it in reverse order to another list. Supports both curried and uncurried versions of the function with generic type parameters.

LANGUAGE: typescript
CODE:
declare const prependAllReversed: { <B>(prefix: List<B>): <A>(self: List<A>) => List<A | B>; <A, B>(self: List<A>, prefix: List<B>): List<A | B>; }

----------------------------------------

TITLE: Defining collectAllFrom Function for Sink in TypeScript
DESCRIPTION: Declares the collectAllFrom function which takes a Sink as input and returns a new Sink that accumulates results into a Chunk. The function is generic, allowing for various types of input, output, and error handling.

LANGUAGE: typescript
CODE:
declare const collectAllFrom: <A, In, L extends In, E, R>(self: Sink<A, In, L, E, R>) => Sink<Chunk.Chunk<A>, In, L, E, R>

----------------------------------------

TITLE: Implementing TPubSub Subscribe Method in TypeScript
DESCRIPTION: Function signature for subscribing to a TPubSub instance to receive messages. Returns an STM transaction that produces a TDequeue for consuming messages. Subscribers must handle unsubscription by shutting down the queue when done.

LANGUAGE: typescript
CODE:
declare const subscribe: <A>(self: TPubSub<A>) => STM.STM<TQueue.TDequeue<A>>

----------------------------------------

TITLE: Implementing Stream Layer Provider in TypeScript
DESCRIPTION: Defines a function that provides a Layer to a Stream, enabling translation between different levels. The function supports both curried and uncurried versions, handling error types and resource requirements.

LANGUAGE: typescript
CODE:
declare const provideLayer: { <RIn, E2, ROut>(layer: Layer.Layer<ROut, E2, RIn>): <A, E>(self: Stream<A, E, ROut>) => Stream<A, E2 | E, RIn>; <A, E, RIn, E2, ROut>(self: Stream<A, E, ROut>, layer: Layer.Layer<ROut, E2, RIn>): Stream<A, E | E2, RIn>; }

----------------------------------------

TITLE: Implementing Chunk.zip in TypeScript
DESCRIPTION: Defines a zip function that combines two Chunks by pairing their elements. The function supports both curried and uncurried forms, allowing for flexible usage patterns. Returns a new Chunk containing tuples of corresponding elements from both input Chunks.

LANGUAGE: typescript
CODE:
declare const zip: { 
  <B>(that: Chunk<B>): <A>(self: Chunk<A>) => Chunk<[A, B]>; 
  <A, B>(self: Chunk<A>, that: Chunk<B>): Chunk<[A, B]>; 
}

----------------------------------------

TITLE: Defining DateTime Type in TypeScript
DESCRIPTION: Defines the DateTime type as a union of Utc and Zoned types. This type represents a point in time and can optionally include a time zone.

LANGUAGE: typescript
CODE:
type DateTime = Utc | Zoned

----------------------------------------

TITLE: isNegative Function Signature in TypeScript
DESCRIPTION: Provides the TypeScript signature for the isNegative function, which takes a BigDecimal as input and returns a boolean indicating whether it's negative.

LANGUAGE: typescript
CODE:
declare const isNegative: (n: BigDecimal) => boolean

----------------------------------------

TITLE: Using isNotNullable Predicate in TypeScript
DESCRIPTION: Demonstrates how to use the isNotNullable predicate function to check if values are neither null nor undefined. The function returns true for any non-null/undefined value and false otherwise, providing type narrowing through TypeScript's type guard system.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { isNotNullable } from "effect/Predicate"

assert.deepStrictEqual(isNotNullable({}), true)
assert.deepStrictEqual(isNotNullable([]), true)

assert.deepStrictEqual(isNotNullable(null), false)
assert.deepStrictEqual(isNotNullable(undefined), false)

LANGUAGE: typescript
CODE:
declare const isNotNullable: <A>(input: A) => input is NonNullable<A>

----------------------------------------

TITLE: Declaring DurationFromNanos Schema Class in TypeScript
DESCRIPTION: Defines a schema class that transforms non-negative bigint values representing nanoseconds into Duration objects. This class is part of the Schema module in the effect package.

LANGUAGE: typescript
CODE:
declare class DurationFromNanos

----------------------------------------

TITLE: Effect.Service Type Signature in TypeScript
DESCRIPTION: Type signature for the Effect.Service function showing supported configuration options including scoped, effect, sync, and succeed implementations with optional dependencies and accessors.

LANGUAGE: typescript
CODE:
declare const Service: <Self = never>() => [Self] extends [never] ? MissingSelfGeneric : { <const Key extends string, const Make extends { readonly scoped: Effect<Service.AllowedType<Key, Make>, any, any>; readonly dependencies?: ReadonlyArray<Layer.Layer.Any>; readonly accessors?: boolean; readonly ಠ_ಠ: never; } | { readonly effect: Effect<Service.AllowedType<Key, Make>, any, any>; readonly dependencies?: ReadonlyArray<Layer.Layer.Any>; readonly accessors?: boolean; readonly ಠ_ಠ: never; } | { readonly sync: LazyArg<Service.AllowedType<Key, Make>>; readonly dependencies?: ReadonlyArray<Layer.Layer.Any>; readonly accessors?: boolean; readonly ಠ_ಠ: never; } | { readonly succeed: Service.AllowedType<Key, Make>; readonly dependencies?: ReadonlyArray<Layer.Layer.Any>; readonly accessors?: boolean; readonly ಠ_ಠ: never; }>(key: Key, make: Make): Service.Class<Self, Key, Make>; <const Key extends string, const Make extends NoExcessProperties<{ readonly scoped: Effect<Service.AllowedType<Key, Make>, any, any>; readonly dependencies?: ReadonlyArray<Layer.Layer.Any>; readonly accessors?: boolean; }, Make>>(key: Key, make: Make): Service.Class<Self, Key, Make>; <const Key extends string, const Make extends NoExcessProperties<{ readonly effect: Effect<Service.AllowedType<Key, Make>, any, any>; readonly dependencies?: ReadonlyArray<Layer.Layer.Any>; readonly accessors?: boolean; }, Make>>(key: Key, make: Make): Service.Class<Self, Key, Make>; <const Key extends string, const Make extends NoExcessProperties<{ readonly sync: LazyArg<Service.AllowedType<Key, Make>>; readonly dependencies?: ReadonlyArray<Layer.Layer.Any>; readonly accessors?: boolean; }, Make>>(key: Key, make: Make): Service.Class<Self, Key, Make>; <const Key extends string, const Make extends NoExcessProperties<{ readonly succeed: Service.AllowedType<Key, Make>; readonly dependencies?: ReadonlyArray<Layer.Layer.Any>; readonly accessors?: boolean; }, Make>>(key: Key, make: Make): Service.Class<Self, Key, Make>; }

----------------------------------------

TITLE: Implementing takeUpTo Operation in Effect-TS Queue
DESCRIPTION: Function signature for taking up to a maximum number of values from a dequeue. It supports both curried and uncurried calling styles, returning an Effect containing a Chunk of values.

LANGUAGE: typescript
CODE:
declare const takeUpTo: { 
  (max: number): <A>(self: Dequeue<A>) => Effect.Effect<Chunk.Chunk<A>>; 
  <A>(self: Dequeue<A>, max: number): Effect.Effect<Chunk.Chunk<A>>; 
}

----------------------------------------

TITLE: Declaring Union Operation for HashMap in TypeScript
DESCRIPTION: Defines the union operation for HashMap, which combines two HashMaps. It supports both curried and non-curried versions, allowing for flexible usage patterns.

LANGUAGE: typescript
CODE:
declare const union: { <K1, V1>(that: HashMap<K1, V1>): <K0, V0>(self: HashMap<K0, V0>) => HashMap<K1 | K0, V1 | V0>; <K0, V0, K1, V1>(self: HashMap<K0, V0>, that: HashMap<K1, V1>): HashMap<K0 | K1, V0 | V1>; }

----------------------------------------

TITLE: Inserting an Element into an Array using Effect Array Module in TypeScript
DESCRIPTION: Demonstrates how to use the Array.insertAt function to insert an element at a specific index in an array. The function returns an Option containing a new NonEmptyArray if successful, or None if the index is out of bounds.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const result = Array.insertAt(['a', 'b', 'c', 'e'], 3, 'd')
console.log(result) // Option.some(['a', 'b', 'c', 'd', 'e'])

LANGUAGE: typescript
CODE:
declare const insertAt: { <B>(i: number, b: B): <A>(self: Iterable<A>) => Option.Option<NonEmptyArray<A | B>>; <A, B>(self: Iterable<A>, i: number, b: B): Option.Option<NonEmptyArray<A | B>>; }

----------------------------------------

TITLE: Implementing Channel Finalizer in TypeScript
DESCRIPTION: Defines a function that attaches a finalizer to a channel. The finalizer executes after channel execution starts, regardless of completion status. The function supports both curried and uncurried calling patterns.

LANGUAGE: typescript
CODE:
declare const ensuringWith: {
  <OutDone, OutErr, Env2>(
    finalizer: (e: Exit.Exit<OutDone, OutErr>) => Effect.Effect<unknown, never, Env2>
  ): <OutElem, InElem, InErr, InDone, Env>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>
  ) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env2 | Env>;
  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, Env2>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,
    finalizer: (e: Exit.Exit<OutDone, OutErr>) => Effect.Effect<unknown, never, Env2>
  ): Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env | Env2>;
}

----------------------------------------

TITLE: Implementing Range Comparison in TypeScript using Order Module
DESCRIPTION: A generic function that creates a comparator to check if a value falls between a minimum and maximum value (inclusive). Takes an Order<A> parameter and returns a function that can be used in two ways: either with options object first or with value and options.

LANGUAGE: typescript
CODE:
declare const between: <A>(O: Order<A>) => { (options: { minimum: A; maximum: A; }): (self: A) => boolean; (self: A, options: { minimum: A; maximum: A; }): boolean; }

----------------------------------------

TITLE: Windowed Schedule TypeScript Function Signature
DESCRIPTION: TypeScript type declaration for the windowed function that takes a Duration input parameter and returns a Schedule of numbers

LANGUAGE: typescript
CODE:
declare const windowed: (interval: Duration.DurationInput) => Schedule<number>

----------------------------------------

TITLE: Implementing Red-Black Tree Traversal in TypeScript
DESCRIPTION: Function signature for traversing a Red-Black Tree and visiting nodes with keys greater than or equal to a specified minimum value. The function accepts a minimum key value and a callback function to execute for each visited node.

LANGUAGE: typescript
CODE:
declare const forEachGreaterThanEqual: { <K, V>(min: K, f: (key: K, value: V) => void): (self: RedBlackTree<K, V>) => void; <K, V>(self: RedBlackTree<K, V>, min: K, f: (key: K, value: V) => void): void; }

----------------------------------------

TITLE: Creating a Database Connection Pool with TTL in TypeScript
DESCRIPTION: Demonstrates how to create a database connection pool using the Pool.makeWithTTL function from the effect package. It sets up a pool with minimum and maximum sizes, a time-to-live duration, and uses the mysql2 package for creating database connections.

LANGUAGE: typescript
CODE:
import { createConnection } from "mysql2";
import { Duration, Effect, Pool } from "effect"

const acquireDBConnection = Effect.acquireRelease(
  Effect.sync(() => createConnection('mysql://...')),
  (connection) => Effect.sync(() => connection.end(() => {}))
)

const connectionPool = Effect.flatMap(
 Pool.makeWithTTL({
    acquire: acquireDBConnection,
    min: 10,
    max: 20,
    timeToLive: Duration.seconds(60)
  }),
  (pool) => pool.get
)

----------------------------------------

TITLE: Constructing Config for Value Sequence in TypeScript
DESCRIPTION: The chunk function creates a configuration for a sequence of values. It takes a config of type A and an optional name parameter, returning a Config of Chunk.Chunk<A>.

LANGUAGE: typescript
CODE:
declare const chunk: <A>(config: Config<A>, name?: string) => Config<Chunk.Chunk<A>>

----------------------------------------

TITLE: Type Guard Definition for Doc.isText in TypeScript
DESCRIPTION: A type guard function that determines if a given Doc<A> instance is specifically a Text<A> type. Returns true if the document is a Text node, false otherwise.

LANGUAGE: typescript
CODE:
declare const isText: <A>(self: Doc<A>) => self is Text<A>

----------------------------------------

TITLE: Effect.zip Type Signature in TypeScript
DESCRIPTION: The type signature for the Effect.zip function, showing its polymorphic nature and options for concurrent execution, batching, and finalizer handling.

LANGUAGE: typescript
CODE:
declare const zip: { <A2, E2, R2>(that: Effect<A2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; readonly batching?: boolean | "inherit" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): <A, E, R>(self: Effect<A, E, R>) => Effect<[A, A2], E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, that: Effect<A2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; readonly batching?: boolean | "inherit" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): Effect<[A, A2], E | E2, R | R2>; }

----------------------------------------

TITLE: Implementing STM.zip Operation in TypeScript
DESCRIPTION: Defines a zip function that sequentially combines two STM values into a tuple. The operation combines error types and environment requirements from both input STMs.

LANGUAGE: typescript
CODE:
declare const zip: { 
  <A1, E1, R1>(that: STM<A1, E1, R1>): 
    <A, E, R>(self: STM<A, E, R>) => STM<[A, A1], E1 | E, R1 | R>; 
  <A, E, R, A1, E1, R1>(self: STM<A, E, R>, that: STM<A1, E1, R1>): 
    STM<[A, A1], E | E1, R | R1>; 
}

----------------------------------------

TITLE: Exporting Spans to Console with OpenTelemetry in TypeScript
DESCRIPTION: Shows how to export traced function spans to the console using OpenTelemetry integration. Includes setup of span processors and exporters with detailed span information capture.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"
import { NodeSdk } from "@effect/opentelemetry"
import {
  ConsoleSpanExporter,
  BatchSpanProcessor
} from "@opentelemetry/sdk-trace-base"

const myfunc = Effect.fn("myspan")(function* <N extends number>(n: N) {
  yield* Effect.annotateCurrentSpan("n", n)
  console.log(`got: ${n}`)
  yield* Effect.fail(new Error("Boom!"))
})

const program = myfunc(100)

const NodeSdkLive = NodeSdk.layer(() => ({
  resource: { serviceName: "example" },
  // Export span data to the console
  spanProcessor: new BatchSpanProcessor(new ConsoleSpanExporter())
}))

Effect.runFork(program.pipe(Effect.provide(NodeSdkLive)))

----------------------------------------

TITLE: Implementing Stream Fold Operation in TypeScript using Effect-TS
DESCRIPTION: Defines a runFold function that executes a pure fold over a stream of values, reducing all elements to a single value of type S. The function supports both curried and non-curried versions for flexibility in usage.

LANGUAGE: typescript
CODE:
declare const runFold: { <S, A>(s: S, f: (s: S, a: A) => S): <E, R>(self: Stream<A, E, R>) => Effect.Effect<S, E, R>; <A, E, R, S>(self: Stream<A, E, R>, s: S, f: (s: S, a: A) => S): Effect.Effect<S, E, R>; }

----------------------------------------

TITLE: Defining RequestResolver.never in TypeScript
DESCRIPTION: Declares a constant 'never' of type RequestResolver that never executes requests. It is typed with 'never' for both input and output types, indicating it will not handle any requests or produce any results.

LANGUAGE: typescript
CODE:
declare const never: RequestResolver<never, never>

----------------------------------------

TITLE: Using Function.satisfies for Type Checking in TypeScript
DESCRIPTION: Demonstrates the usage of the satisfies function to ensure type compatibility. It shows how the function preserves the literal type of the input while checking against a more general type.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { satisfies } from "effect/Function"

const test1 = satisfies<number>()(5 as const)
    //^? const test: 5
    // @ts-expect-error
const test2 = satisfies<string>()(5)
    //^? Argument of type 'number' is not assignable to parameter of type 'string'

assert.deepStrictEqual(satisfies<number>()(5), 5)

----------------------------------------

TITLE: Defining Brand Interface in TypeScript for Effect Package
DESCRIPTION: This code defines a generic interface called Brand that is used to create branded types. It uses a symbol BrandTypeId as a key to store a readonly object with the generic type K. This allows for type-safe branding of primitive types.

LANGUAGE: typescript
CODE:
export interface Brand<in out K extends string | symbol> {
  readonly [BrandTypeId]: {
    readonly [k in K]: K
  }
}

----------------------------------------

TITLE: Pipe Function Type Signature
DESCRIPTION: Complete type signature of the pipe function showing all possible overloads

LANGUAGE: typescript
CODE:
declare const pipe: { <A>(a: A): A; <A, B = never>(a: A, ab: (a: A) => B): B; <A, B = never, C = never>(a: A, ab: (a: A) => B, bc: (b: B) => C): C; <A, B = never, C = never, D = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D): D; <A, B = never, C = never, D = never, E = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E): E; <A, B = never, C = never, D = never, E = never, F = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F): F; <A, B = never, C = never, D = never, E = never, F = never, G = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G): G; <A, B = never, C = never, D = never, E = never, F = never, G = never, H = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H): H; <A, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I): I; <A, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never, J = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I, ij: (i: I) => J): J; <A, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never, J = never, K = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I, ij: (i: I) => J, jk: (j: J) => K): K; <A, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never, J = never, K = never, L = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I, ij: (i: I) => J, jk: (j: J) => K, kl: (k: K) => L): L; <A, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never, J = never, K = never, L = never, M = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I, ij: (i: I) => J, jk: (j: J) => K, kl: (k: K) => L, lm: (l: L) => M): M; <A, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never, J = never, K = never, L = never, M = never, N = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I, ij: (i: I) => J, jk: (j: J) => K, kl: (k: K) => L, lm: (l: L) => M, mn: (m: M) => N): N; <A, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never, J = never, K = never, L = never, M = never, N = never, O = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I, ij: (i: I) => J, jk: (j: J) => K, kl: (k: K) => L, lm: (l: L) => M, mn: (m: M) => N, no: (n: N) => O): O; <A, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never, J = never, K = never, L = never, M = never, N = never, O = never, P = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I, ij: (i: I) => J, jk: (j: J) => K, kl: (k: K) => L, lm: (l: L) => M, mn: (m: M) => N, no: (n: N) => O, op: (o: O) => P): P; <A, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never, J = never, K = never, L = never, M = never, N = never, O = never, P = never, Q = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I, ij: (i: I) => J, jk: (j: J) => K, kl: (k: K) => L, lm: (l: L) => M, mn: (m: M) => N, no: (n: N) => O, op: (o: O) => P, pq: (p: P) => Q): Q; <A, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never, J = never, K = never, L = never, M = never, N = never, O = never, P = never, Q = never, R = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I, ij: (i: I) => J, jk: (j: J) => K, kl: (k: K) => L, lm: (l: L) => M, mn: (m: M) => N, no: (n: N) => O, op: (o: O) => P, pq: (p: P) => Q, qr: (q: Q) => R): R; <A, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never, J = never, K = never, L = never, M = never, N = never, O = never, P = never, Q = never, R = never, S = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I, ij: (i: I) => J, jk: (j: J) => K, kl: (k: K) => L, lm: (l: L) => M, mn: (m: M) => N, no: (n: N) => O, op: (o: O) => P, pq: (p: P) => Q, qr: (q: Q) => R, rs: (r: R) => S): S; <A, B = never, C = never, D = never, E = never, F = never, G = never, H = never, I = never, J = never, K = never, L = never, M = never, N = never, O = never, P = never, Q = never, R = never, S = never, T = never>(a: A, ab: (a: A) => B, bc: (b: B) => C, cd: (c: C) => D, de: (d: D) => E, ef: (e: E) => F, fg: (f: F) => G, gh: (g: G) => H, hi: (h: H) => I, ij: (i: I) => J, jk: (j: J) => K, kl: (k: K) => L, lm: (l: L) => M, mn: (m: M) => N, no: (n: N) => O, op: (o: O) => P, pq: (p: P) => Q, qr: (q: Q) => R, rs: (r: R) => S, st: (s: S) => T): T; }

----------------------------------------

TITLE: Using BigDecimal.between in TypeScript
DESCRIPTION: Demonstrates how to use BigDecimal.between to check if a number falls within an inclusive range. The function takes minimum and maximum BigDecimal values and returns a boolean indicating if the tested value is within that range.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { BigDecimal } from "effect"

const between = BigDecimal.between({
  minimum: BigDecimal.unsafeFromString("1"),
  maximum: BigDecimal.unsafeFromString("5") }
)

assert.deepStrictEqual(between(BigDecimal.unsafeFromString("3")), true)
assert.deepStrictEqual(between(BigDecimal.unsafeFromString("0")), false)
assert.deepStrictEqual(between(BigDecimal.unsafeFromString("6")), false)

LANGUAGE: typescript
CODE:
declare const between: { (options: { minimum: BigDecimal; maximum: BigDecimal; }): (self: BigDecimal) => boolean; (self: BigDecimal, options: { minimum: BigDecimal; maximum: BigDecimal; }): boolean; }

----------------------------------------

TITLE: Parsing ISO8601 Duration Strings with Duration.fromIso in TypeScript
DESCRIPTION: The Duration.fromIso function parses an ISO8601 duration string into a Duration object. It assumes months are 30 days and years are 365 days. The function returns an Option.Option<Duration>.

LANGUAGE: typescript
CODE:
import { Duration, Option } from "effect"

Duration.fromIso("P1D") // => Option.some(Duration.days(1))
Duration.fromIso("PT1H") // => Option.some(Duration.hours(1))
Duration.fromIso("PT1M") // => Option.some(Duration.minutes(1))
Duration.fromIso("PT1.5S") // => Option.some(Duration.seconds(1.5))

LANGUAGE: typescript
CODE:
declare const fromIso: (iso: string) => Option.Option<Duration>

----------------------------------------

TITLE: Retrieving Fiber Write Locks Count in TReentrantLock (TypeScript)
DESCRIPTION: The fiberWriteLocks function retrieves the number of acquired write locks for a given fiber using a TReentrantLock. It returns an STM (Software Transactional Memory) operation that resolves to a number.

LANGUAGE: typescript
CODE:
declare const fiberWriteLocks: (self: TReentrantLock) => STM.STM<number>

----------------------------------------

TITLE: Adding Fibers to FiberSet in TypeScript
DESCRIPTION: The unsafeAdd function adds a fiber to the FiberSet. It automatically removes the fiber when it completes. The function accepts optional parameters for interrupt behavior and propagation.

LANGUAGE: typescript
CODE:
declare const unsafeAdd: { <A, E, XE extends E, XA extends A>(fiber: Fiber.RuntimeFiber<XA, XE>, options?: { readonly interruptAs?: FiberId.FiberId | undefined; readonly propagateInterruption?: boolean | undefined; } | undefined): (self: FiberSet<A, E>) => void; <A, E, XE extends E, XA extends A>(self: FiberSet<A, E>, fiber: Fiber.RuntimeFiber<XA, XE>, options?: { readonly interruptAs?: FiberId.FiberId | undefined; readonly propagateInterruption?: boolean | undefined; } | undefined): void; }

----------------------------------------

TITLE: Mapping Error Cause in Exit Module (TypeScript)
DESCRIPTION: The mapErrorCause function maps over the Cause contained in the Failure of a specified exit using a provided function. It can be used in two ways: either by passing the function first and then the exit, or by passing the exit first and then the function.

LANGUAGE: typescript
CODE:
declare const mapErrorCause: {
  <E, E2>(f: (cause: Cause.Cause<E>) => Cause.Cause<E2>): <A>(self: Exit<A, E>) => Exit<A, E2>;
  <E, A, E2>(self: Exit<A, E>, f: (cause: Cause.Cause<E>) => Cause.Cause<E2>): Exit<A, E2>;
}

----------------------------------------

TITLE: Effect.provideService Function Signature in TypeScript
DESCRIPTION: This code block shows the TypeScript signature for the Effect.provideService function. It defines two overloads for providing a service implementation to an effect.

LANGUAGE: typescript
CODE:
declare const provideService: { <I, S>(tag: Context.Tag<I, S>, service: NoInfer<S>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, Exclude<R, I>>; <A, E, R, I, S>(self: Effect<A, E, R>, tag: Context.Tag<I, S>, service: NoInfer<S>): Effect<A, E, Exclude<R, I>>; }

----------------------------------------

TITLE: Negating Predicates with Predicate.not in TypeScript
DESCRIPTION: Demonstrates the usage of Predicate.not to create a new predicate that negates the result of a given predicate. The example shows how to create an 'isPositive' predicate by negating the 'lessThan(0)' predicate.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Predicate, Number } from "effect"

const isPositive = Predicate.not(Number.lessThan(0))

assert.deepStrictEqual(isPositive(-1), false)
assert.deepStrictEqual(isPositive(0), true)
assert.deepStrictEqual(isPositive(1), true)

LANGUAGE: typescript
CODE:
declare const not: <A>(self: Predicate<A>) => Predicate<A>

----------------------------------------

TITLE: Declaring Schema.Uint8ArrayFromBase64Url Type in TypeScript
DESCRIPTION: Type declaration for a Schema that converts base64 URL-encoded strings into Uint8Array objects. The schema handles the transformation from string input to Uint8Array output with no error channel.

LANGUAGE: typescript
CODE:
declare const Uint8ArrayFromBase64Url: Schema<Uint8Array<ArrayBufferLike>, string, never>

----------------------------------------

TITLE: Creating File Path Option in Effect CLI
DESCRIPTION: The 'file' function creates a parameter that expects a path to a file. It takes a name string and an optional configuration object as arguments, and returns an Options object of type string.

LANGUAGE: typescript
CODE:
declare const file: (name: string, config?: Options.PathOptionsConfig) => Options<string>

----------------------------------------

TITLE: Converting Either to Option with Option.getRight
DESCRIPTION: Demonstrates how to use Option.getRight to convert Either values into Option values by keeping successful results and discarding errors. Shows examples of converting both Right and Left cases.

LANGUAGE: typescript
CODE:
import { Either, Option } from "effect"

console.log(Option.getRight(Either.right("ok")))
// Output: { _id: 'Option', _tag: 'Some', value: 'ok' }

console.log(Option.getRight(Either.left("err")))
// Output: { _id: 'Option', _tag: 'None' }

LANGUAGE: typescript
CODE:
declare const getRight: <R, L>(self: Either<R, L>) => Option<R>

----------------------------------------

TITLE: Defining Command Output Type in TypeScript
DESCRIPTION: This snippet defines the Output type for the Command module, which is used to configure the pipes established between parent and child processes for stderr and stdout streams.

LANGUAGE: typescript
CODE:
type Output = CommandOutput

----------------------------------------

TITLE: Interrupting Multiple Fibers in TypeScript using Effect
DESCRIPTION: The interruptAll function interrupts all fibers provided as an iterable, awaiting their interruption. It returns an Effect that represents the completion of all fiber interruptions.

LANGUAGE: typescript
CODE:
declare const interruptAll: (fibers: Iterable<Fiber<any, any>>) => Effect.Effect<void>

----------------------------------------

TITLE: Effect.retry Type Signature in TypeScript
DESCRIPTION: The type signature for the Effect.retry function showing its polymorphic nature and various overloads for different retry configurations.

LANGUAGE: typescript
CODE:
declare const retry: { <E, O extends NoExcessProperties<Retry.Options<E>, O>>(options: O): <A, R>(self: Effect<A, E, R>) => Retry.Return<R, E, A, O>; <B, E, R1>(policy: Schedule.Schedule<B, NoInfer<E>, R1>): <A, R>(self: Effect<A, E, R>) => Effect<A, E, R1 | R>; <A, E, R, O extends NoExcessProperties<Retry.Options<E>, O>>(self: Effect<A, E, R>, options: O): Retry.Return<R, E, A, O>; <A, E, R, B, R1>(self: Effect<A, E, R>, policy: Schedule.Schedule<B, E, R1>): Effect<A, E, R1 | R>; }

----------------------------------------

TITLE: Negate Function Signature for BigDecimal in TypeScript
DESCRIPTION: Provides the TypeScript function signature for the negate operation on BigDecimal values. It takes a BigDecimal as input and returns a negated BigDecimal.

LANGUAGE: typescript
CODE:
declare const negate: (n: BigDecimal) => BigDecimal

----------------------------------------

TITLE: Filtering Trie Entries with Predicates in TypeScript
DESCRIPTION: Demonstrates how to filter entries from a Trie data structure using predicates. The example shows filtering based on both value and key conditions, with two different approaches: filtering values greater than 1 and filtering keys longer than 3 characters.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Trie, Equal } from "effect"

const trie = Trie.empty<number>().pipe(
  Trie.insert("shells", 0),
  Trie.insert("sells", 1),
  Trie.insert("she", 2)
)

const trieMapV = Trie.empty<number>().pipe(
  Trie.insert("she", 2)
)

const trieMapK = Trie.empty<number>().pipe(
  Trie.insert("shells", 0),
  Trie.insert("sells", 1)
)

assert.equal(Equal.equals(Trie.filter(trie, (v) => v > 1), trieMapV), true)
assert.equal(Equal.equals(Trie.filter(trie, (_, k) => k.length > 3), trieMapK), true)

LANGUAGE: typescript
CODE:
declare const filter: { <A, B extends A>(f: (a: NoInfer<A>, k: string) => a is B): (self: Trie<A>) => Trie<B>; <A>(f: (a: NoInfer<A>, k: string) => boolean): (self: Trie<A>) => Trie<A>; <A, B extends A>(self: Trie<A>, f: (a: A, k: string) => a is B): Trie<B>; <A>(self: Trie<A>, f: (a: A, k: string) => boolean): Trie<A>; }

----------------------------------------

TITLE: Using greaterThanOrEqualTo Function in TypeScript
DESCRIPTION: Demonstrates how to use the greaterThanOrEqualTo function to compare numbers. The function can be used both in curried and non-curried form to check if one number is greater than or equal to another.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { greaterThanOrEqualTo } from "effect/Number"

assert.deepStrictEqual(greaterThanOrEqualTo(2, 3), false)
assert.deepStrictEqual(greaterThanOrEqualTo(3, 3), true)
assert.deepStrictEqual(greaterThanOrEqualTo(4, 3), true)

LANGUAGE: typescript
CODE:
declare const greaterThanOrEqualTo: { (that: number): (self: number) => boolean; (self: number, that: number): boolean; }

----------------------------------------

TITLE: Using setNonEmptyHead in Effect Array Module
DESCRIPTION: Demonstrates how to change the first element of a non-empty array using the setNonEmptyHead function. Returns a new array with the modified head while preserving the rest of the elements.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const result = Array.setNonEmptyHead([1, 2, 3], 10)
console.log(result) // [10, 2, 3]

LANGUAGE: typescript
CODE:
declare const setNonEmptyHead: { <B>(b: B): <A>(self: NonEmptyReadonlyArray<A>) => NonEmptyArray<A | B>; <A, B>(self: NonEmptyReadonlyArray<A>, b: B): NonEmptyArray<A | B>; }

----------------------------------------

TITLE: Schema.extend Function Signature - TypeScript Definition
DESCRIPTION: Type declaration for the Schema.extend function showing its polymorphic nature and type constraints.

LANGUAGE: typescript
CODE:
declare const extend: { <That extends Schema.Any>(that: That): <Self extends Schema.Any>(self: Self) => extend<Self, That>; <Self extends Schema.Any, That extends Schema.Any>(self: Self, that: That): extend<Self, That>; }

----------------------------------------

TITLE: Effect.mapAccum Function Signature in TypeScript
DESCRIPTION: The type signature for the Effect.mapAccum function, which supports both curried and non-curried forms. It takes an initial state, a transformation function, and an iterable of elements to process.

LANGUAGE: typescript
CODE:
declare const mapAccum: { <S, A, B, E, R, I extends Iterable<A> = Iterable<A>>(initial: S, f: (state: S, a: RA.ReadonlyArray.Infer<I>, i: number) => Effect<readonly [S, B], E, R>): (elements: I) => Effect<[S, RA.ReadonlyArray.With<I, B>], E, R>; <A, S, B, E, R, I extends Iterable<A> = Iterable<A>>(elements: I, initial: S, f: (state: S, a: RA.ReadonlyArray.Infer<I>, i: number) => Effect<readonly [S, B], E, R>): Effect<[S, RA.ReadonlyArray.With<I, B>], E, R>; }

----------------------------------------

TITLE: Retrieving Original Value from Redacted Instance in TypeScript
DESCRIPTION: This example demonstrates how to use the Redacted.value function to retrieve the original value from a Redacted instance. It creates a Redacted instance with an API key and then asserts that the retrieved value matches the original.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Redacted } from "effect"

const API_KEY = Redacted.make("1234567890")

assert.equal(Redacted.value(API_KEY), "1234567890")

----------------------------------------

TITLE: Demonstrating Doc.cats Usage in TypeScript
DESCRIPTION: Example showing how the cats combinator works with different page width settings. It demonstrates both inline concatenation when content fits and automatic line breaks when content exceeds page width.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import * as String from "effect/String"

const doc: Doc.Doc<never> = Doc.hsep([
  Doc.text("Docs:"),
  Doc.cats(Doc.words("lorem ipsum dolor"))
])

assert.strictEqual(
  Doc.render(doc, { style: "pretty" }),
  "Docs: loremipsumdolor"
)

// If the document exceeds the width of the page, the documents are rendered
// one above another
assert.strictEqual(
  Doc.render(doc, {
    style: "pretty",
    options: { lineWidth: 10 }
  }),
  String.stripMargin(
    `|Docs: lorem
     |ipsum
     |dolor`
  )
)

----------------------------------------

TITLE: Function.compose Type Signature
DESCRIPTION: Type declaration for the compose function showing its polymorphic nature. It can be used either with two separate function arguments or with a curried version taking a single function at a time.

LANGUAGE: typescript
CODE:
declare const compose: { <B, C>(bc: (b: B) => C): <A>(self: (a: A) => B) => (a: A) => C; <A, B, C>(self: (a: A) => B, bc: (b: B) => C): (a: A) => C; }

----------------------------------------

TITLE: Creating Closeable Scope with Effect Library
DESCRIPTION: Creates a new closeable scope that manages finalizer execution using a specified ExecutionStrategy. If no strategy is provided, it defaults to sequential execution. Returns an Effect containing a CloseableScope.

LANGUAGE: typescript
CODE:
declare const make: (executionStrategy?: ExecutionStrategy.ExecutionStrategy) => Effect.Effect<CloseableScope>

----------------------------------------

TITLE: Rounding Numbers with Precision in TypeScript using Effect Package
DESCRIPTION: Demonstrates how to use the `round` function from the Effect package's Number module to round numbers with a specified precision. The function can be used with both curried and uncurried forms.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { round } from "effect/Number"

assert.deepStrictEqual(round(1.1234, 2), 1.12)
assert.deepStrictEqual(round(1.567, 2), 1.57)

LANGUAGE: typescript
CODE:
declare const round: { (precision: number): (self: number) => number; (self: number, precision: number): number; }

----------------------------------------

TITLE: Trie.entriesWithPrefix Function Signature in TypeScript
DESCRIPTION: The type signature of the Trie.entriesWithPrefix function. It can be called with either the prefix first and the Trie second, or vice versa. It returns an IterableIterator of string-value pairs.

LANGUAGE: typescript
CODE:
declare const entriesWithPrefix: { (prefix: string): <V>(self: Trie<V>) => IterableIterator<[string, V]>; <V>(self: Trie<V>, prefix: string): IterableIterator<[string, V]>; }

----------------------------------------

TITLE: Semigroup Type Signature for Ordering in TypeScript
DESCRIPTION: Provides the type signature for the Semigroup instance of Ordering. It declares a constant Semigroup of type semigroup.Semigroup<Ordering>.

LANGUAGE: typescript
CODE:
declare const Semigroup: semigroup.Semigroup<Ordering>

----------------------------------------

TITLE: Defining greaterThanEqual Function for RedBlackTree in TypeScript
DESCRIPTION: This code snippet defines the greaterThanEqual function for the RedBlackTree data structure. It returns an iterator that traverses entries in order with keys greater than or equal to the specified key. The function is overloaded to accept either the key first or the RedBlackTree instance first.

LANGUAGE: typescript
CODE:
declare const greaterThanEqual: { <K>(key: K): <V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>; <K, V>(self: RedBlackTree<K, V>, key: K): Iterable<[K, V]>; }

----------------------------------------

TITLE: Defining ScopedCache.Lookup Type in TypeScript
DESCRIPTION: Defines the type signature for the Lookup function in the ScopedCache module. It takes a key and returns an Effect that includes a Value, Error, Environment, and Scope.

LANGUAGE: typescript
CODE:
type Lookup<Key, Value, Error, Environment> = (
  key: Key
) => Effect.Effect<Value, Error, Environment | Scope.Scope>

----------------------------------------

TITLE: Using Boolean.match for Conditional Function Execution in TypeScript
DESCRIPTION: Demonstrates how to use Boolean.match to execute different functions based on a boolean value. The function takes a boolean value and an options object containing two functions (onTrue and onFalse) and returns the result of the appropriate function.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Boolean } from "effect"

assert.deepStrictEqual(Boolean.match(true, { onFalse: () => "It's false!", onTrue: () => "It's true!" }), "It's true!")

LANGUAGE: typescript
CODE:
declare const match: { <A, B = A>(options: { readonly onFalse: LazyArg<A>; readonly onTrue: LazyArg<B>; }): (value: boolean) => A | B; <A, B>(value: boolean, options: { readonly onFalse: LazyArg<A>; readonly onTrue: LazyArg<B>; }): A | B; }

----------------------------------------

TITLE: Implementing PubSub Queue Shutdown Wait in TypeScript
DESCRIPTION: A TypeScript function that returns an Effect which waits for a PubSub queue to shutdown. The Effect remains suspended until the queue is shutdown, or resumes immediately if the queue is already in shutdown state.

LANGUAGE: typescript
CODE:
declare const awaitShutdown: <A>(self: PubSub<A>) => Effect.Effect<void>

----------------------------------------

TITLE: Checking Key Existence in Records using Effect/Record
DESCRIPTION: Demonstrates how to use the has function to check if a key exists in a record. The function accepts a record and a key, returning a boolean indicating whether the key exists in the record.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { empty, has } from "effect/Record"

assert.deepStrictEqual(has({ a: 1, b: 2 }, "a"), true);
assert.deepStrictEqual(has(empty<string>(), "c"), false);

LANGUAGE: typescript
CODE:
declare const has: { <K extends string | symbol>(key: NoInfer<K>): <A>(self: ReadonlyRecord<K, A>) => boolean; <K extends string | symbol, A>(self: ReadonlyRecord<K, A>, key: NoInfer<K>): boolean; }

----------------------------------------

TITLE: Implementing Array Intersection in TypeScript using Effect Library
DESCRIPTION: Demonstrates how to use Array.intersection to find common elements between two iterables. The function returns an array of unique values that exist in both input iterables, maintaining the order and references from the first iterable.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const result = Array.intersection([1, 2, 3], [3, 4, 1])
console.log(result) // [1, 3]

LANGUAGE: typescript
CODE:
declare const intersection: { <B>(that: Iterable<B>): <A>(self: Iterable<A>) => Array<A & B>; <A, B>(self: Iterable<A>, that: Iterable<B>): Array<A & B>; }

----------------------------------------

TITLE: Stream.buffer Function Signature in TypeScript
DESCRIPTION: Provides the TypeScript signature for the Stream.buffer function, showing its overloads and options for capacity and strategy.

LANGUAGE: typescript
CODE:
declare const buffer: { (options: { readonly capacity: "unbounded"; } | { readonly capacity: number; readonly strategy?: "dropping" | "sliding" | "suspend" | undefined; }): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, options: { readonly capacity: "unbounded"; } | { readonly capacity: number; readonly strategy?: "dropping" | "sliding" | "suspend" | undefined; }): Stream<A, E, R>; }

----------------------------------------

TITLE: Implementing TArray.someSTM Function in TypeScript
DESCRIPTION: Defines the someSTM function which checks if any element in a TArray satisfies a given transactional predicate. It returns an STM (Software Transactional Memory) operation that resolves to a boolean.

LANGUAGE: typescript
CODE:
declare const someSTM: { <A, R, E>(predicate: (value: A) => STM.STM<boolean, E, R>): (self: TArray<A>) => STM.STM<boolean, E, R>; <A, R, E>(self: TArray<A>, predicate: (value: A) => STM.STM<boolean, E, R>): STM.STM<boolean, E, R>; }

----------------------------------------

TITLE: Creating a NonEmptyArray using Array.make in TypeScript
DESCRIPTION: Demonstrates how to use the Array.make function from the Effect library to create a NonEmptyArray. The function takes a non-empty collection of elements and returns a NonEmptyArray.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const result = Array.make(1, 2, 3)
console.log(result) // [1, 2, 3]

----------------------------------------

TITLE: Implementing Fiber Fallback Logic in TypeScript
DESCRIPTION: Defines a function that combines two fibers where the second fiber acts as a fallback when the first one fails. The operation handles both success and error cases, with sequential interruption of both fibers from left to right when interrupted.

LANGUAGE: typescript
CODE:
declare const orElse: { <A2, E2>(that: Fiber<A2, E2>): <A, E>(self: Fiber<A, E>) => Fiber<A2 | A, E2 | E>; <A, E, A2, E2>(self: Fiber<A, E>, that: Fiber<A2, E2>): Fiber<A | A2, E | E2>; }

----------------------------------------

TITLE: Implementing Layer.fail Function in TypeScript
DESCRIPTION: Defines a function that constructs a layer that fails with a specified error. The function takes an error parameter of generic type E and returns a Layer that can fail with that error type.

LANGUAGE: typescript
CODE:
declare const fail: <E>(error: E) => Layer<unknown, E>

----------------------------------------

TITLE: Implementing Literal Value Matching in TypeScript with Effect Match.is
DESCRIPTION: Type definition for Match.is function that creates a predicate refinement for matching literal values. The function accepts a variable number of literal values (strings, numbers, bigints, booleans, or null) and returns a type-safe predicate that can match against those values.

LANGUAGE: typescript
CODE:
declare const is: <Literals extends ReadonlyArray<string | number | bigint | boolean | null>>(...literals: Literals) => Predicate.Refinement<unknown, Literals[number]>

----------------------------------------

TITLE: Implementing Reversed Greater Than Iterator in TypeScript
DESCRIPTION: Function signature for creating an iterator that traverses RedBlackTree entries in reverse order where keys are greater than a specified key. The function is overloaded to support both curried and direct parameter passing styles.

LANGUAGE: typescript
CODE:
declare const greaterThanReversed: { <K>(key: K): <V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>; <K, V>(self: RedBlackTree<K, V>, key: K): Iterable<[K, V]>; }

----------------------------------------

TITLE: Type Definition for parallelFinalizers Function
DESCRIPTION: TypeScript type signature for the parallelFinalizers function, showing it takes an Effect with generic type parameters and returns a new Effect with the same type parameters.

LANGUAGE: typescript
CODE:
declare const parallelFinalizers: <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>

----------------------------------------

TITLE: Function Signature for Stream.sliding in Effect
DESCRIPTION: This code block shows the TypeScript signature for the Stream.sliding function. It can be used in two ways: either by passing the chunk size as the first argument, or by passing the stream as the first argument and the chunk size as the second.

LANGUAGE: typescript
CODE:
declare const sliding: { (chunkSize: number): <A, E, R>(self: Stream<A, E, R>) => Stream<Chunk.Chunk<A>, E, R>; <A, E, R>(self: Stream<A, E, R>, chunkSize: number): Stream<Chunk.Chunk<A>, E, R>; }

----------------------------------------

TITLE: Predicate.and Type Definition in TypeScript
DESCRIPTION: Type signature for the Predicate.and function showing its polymorphic nature. Supports both Refinement and Predicate types with proper type inference.

LANGUAGE: typescript
CODE:
declare const and: { <A, C extends A>(that: Refinement<A, C>): <B extends A>(self: Refinement<A, B>) => Refinement<A, B & C>; <A, B extends A, C extends A>(self: Refinement<A, B>, that: Refinement<A, C>): Refinement<A, B & C>; <A>(that: Predicate<A>): (self: Predicate<A>) => Predicate<A>; <A>(self: Predicate<A>, that: Predicate<A>): Predicate<A>; }

----------------------------------------

TITLE: BigDecimal Division Example Usage
DESCRIPTION: Demonstrates how to use BigDecimal.divide operation for different division scenarios including exact division, decimal results, and division by zero handling. The operation returns an Option type containing the result or None for invalid operations.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { BigDecimal, Option } from "effect"

assert.deepStrictEqual(BigDecimal.divide(BigDecimal.unsafeFromString("6"), BigDecimal.unsafeFromString("3")), Option.some(BigDecimal.unsafeFromString("2")))
assert.deepStrictEqual(BigDecimal.divide(BigDecimal.unsafeFromString("6"), BigDecimal.unsafeFromString("4")), Option.some(BigDecimal.unsafeFromString("1.5")))
assert.deepStrictEqual(BigDecimal.divide(BigDecimal.unsafeFromString("6"), BigDecimal.unsafeFromString("0")), Option.none())

----------------------------------------

TITLE: Defining CurrentRunnerAddress Class in TypeScript
DESCRIPTION: Declares a class CurrentRunnerAddress that serves as a Context.Tag for accessing the current Runner address in a cluster environment. This is available since version 1.0.0 of the package.

LANGUAGE: typescript
CODE:
declare class CurrentRunnerAddress

----------------------------------------

TITLE: Trie.entries Type Definition
DESCRIPTION: Type signature for the entries function that returns an IterableIterator of string-value pairs from a Trie data structure.

LANGUAGE: typescript
CODE:
declare const entries: <V>(self: Trie<V>) => IterableIterator<[string, V]>

----------------------------------------

TITLE: Merging Values in TMap using TypeScript
DESCRIPTION: Implements a merge operation that combines existing and new values in a transactional map. If the key exists, it merges the existing value with the new one using the provided function f. If the key doesn't exist, it stores the new value directly.

LANGUAGE: typescript
CODE:
declare const merge: { 
  <K, V>(key: K, value: V, f: (x: V, y: V) => V): (self: TMap<K, V>) => STM.STM<V>; 
  <K, V>(self: TMap<K, V>, key: K, value: V, f: (x: V, y: V) => V): STM.STM<V>; 
}

----------------------------------------

TITLE: TypeScript Signature of aroundRequests Function
DESCRIPTION: Provides the TypeScript type signature for the aroundRequests function, detailing its parameters and return type. It shows the function's overloaded nature and generic type constraints.

LANGUAGE: typescript
CODE:
declare const aroundRequests: { <A, A2, R2, X, R3>(before: (requests: ReadonlyArray<Types.NoInfer<A>>) => Effect.Effect<A2, never, R2>, after: (requests: ReadonlyArray<Types.NoInfer<A>>, _: A2) => Effect.Effect<X, never, R3>): <R>(self: RequestResolver<A, R>) => RequestResolver<A, R2 | R3 | R>; <A, R, A2, R2, X, R3>(self: RequestResolver<A, R>, before: (requests: ReadonlyArray<Types.NoInfer<A>>) => Effect.Effect<A2, never, R2>, after: (requests: ReadonlyArray<Types.NoInfer<A>>, _: A2) => Effect.Effect<X, never, R3>): RequestResolver<A, R | R2 | R3>; }

----------------------------------------

TITLE: Defining Either.map Function in TypeScript
DESCRIPTION: Declares the map function for the Either type. It maps the Right side of an Either value to a new Either value. The function can be used in two ways: as a standalone function or as a method on an Either instance.

LANGUAGE: typescript
CODE:
declare const map: { <R, R2>(f: (right: R) => R2): <L>(self: Either<R, L>) => Either<R2, L>; <R, L, R2>(self: Either<R, L>, f: (right: R) => R2): Either<R2, L>; }

----------------------------------------

TITLE: Modifying Trie Values in TypeScript using effect Package
DESCRIPTION: Demonstrates how to use the Trie.modify function to update values in a Trie data structure. It shows inserting elements, modifying existing values, and handling non-existent keys.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Trie, Equal, Option } from "effect"

const trie = Trie.empty<number>().pipe(
  Trie.insert("shells", 0),
  Trie.insert("sells", 1),
  Trie.insert("she", 2)
)

assert.deepStrictEqual(trie.pipe(Trie.modify("she", (v) => v + 10), Trie.get("she")), Option.some(12))

assert.equal(Equal.equals(trie.pipe(Trie.modify("me", (v) => v)), trie), true)

----------------------------------------

TITLE: Obtaining Write Lock with TReentrantLock in TypeScript
DESCRIPTION: Function signature for obtaining a write lock in a scoped context using TReentrantLock. Returns an Effect that produces a number, never fails, and requires a Scope context. Used for managing concurrent access to shared resources.

LANGUAGE: typescript
CODE:
declare const writeLock: (self: TReentrantLock) => Effect.Effect<number, never, Scope.Scope>

----------------------------------------

TITLE: Using Option.exists in TypeScript
DESCRIPTION: Demonstrates how to use the Option.exists function to check if a value in an Option satisfies a given predicate. The example shows checking for even numbers in Some and None cases.

LANGUAGE: typescript
CODE:
import { Option } from "effect"

const isEven = (n: number) => n % 2 === 0

console.log(Option.some(2).pipe(Option.exists(isEven)))
// Output: true

console.log(Option.some(1).pipe(Option.exists(isEven)))
// Output: false

console.log(Option.none().pipe(Option.exists(isEven)))
// Output: false

----------------------------------------

TITLE: Collecting TPriorityQueue Values into Chunk in TypeScript
DESCRIPTION: The toChunk function collects all values from a TPriorityQueue<A> into a Chunk.Chunk<A> using STM (Software Transactional Memory). It operates within the STM context, allowing for composable atomic operations.

LANGUAGE: typescript
CODE:
declare const toChunk: <A>(self: TPriorityQueue<A>) => STM.STM<Chunk.Chunk<A>>

----------------------------------------

TITLE: Constructing a Layer from Scoped Effect in TypeScript
DESCRIPTION: The scopedDiscard function creates a layer from a specified scoped effect. It takes an Effect as input and returns a Layer. The returned Layer has no output, may fail with an error of type E, and requires all dependencies of R except for Scope.Scope.

LANGUAGE: typescript
CODE:
declare const scopedDiscard: <X, E, R>(effect: Effect.Effect<X, E, R>) => Layer<never, E, Exclude<R, Scope.Scope>>

----------------------------------------

TITLE: Defining PubSub Interface in TypeScript
DESCRIPTION: Declares the PubSub interface, which extends Queue.Enqueue and Pipeable. It includes methods for publishing messages, publishing multiple messages, and subscribing to receive messages.

LANGUAGE: typescript
CODE:
export interface PubSub<in out A> extends Queue.Enqueue<A>, Pipeable {
  /**
   * Publishes a message to the `PubSub`, returning whether the message was published
   * to the `PubSub`.
   */
  publish(value: A): Effect.Effect<boolean>

  /**
   * Publishes all of the specified messages to the `PubSub`, returning whether they
   * were published to the `PubSub`.
   */
  publishAll(elements: Iterable<A>): Effect.Effect<boolean>

  /**
   * Subscribes to receive messages from the `PubSub`. The resulting subscription can
   * be evaluated multiple times within the scope to take a message from the `PubSub`
   * each time.
   */
  readonly subscribe: Effect.Effect<Queue.Dequeue<A>, never, Scope.Scope>
}

----------------------------------------

TITLE: Illustrating Fixed Schedule Execution
DESCRIPTION: This ASCII diagram illustrates how the fixed schedule executes actions at regular intervals, adjusting for actions that take longer than the interval to prevent overlaps.

LANGUAGE: text
CODE:
|-----interval-----|-----interval-----|-----interval-----|
|---------action--------||action|-----|action|-----------|

----------------------------------------

TITLE: TypeScript Signature for Option.liftNullable
DESCRIPTION: Provides the TypeScript function signature for the Option.liftNullable function. It shows the function takes a function that accepts any number of arguments and returns a value or null/undefined, and returns a function that produces an Option.

LANGUAGE: typescript
CODE:
declare const liftNullable: <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => B | null | undefined) => (...a: A) => Option<NonNullable<B>>

----------------------------------------

TITLE: Schema.pickLiteral Function Signature in TypeScript
DESCRIPTION: Provides the TypeScript type signature for the Schema.pickLiteral function. It shows that the function takes literal values and a schema as input, and returns a new Literal schema.

LANGUAGE: typescript
CODE:
declare const pickLiteral: <A extends AST.LiteralValue, L extends array_.NonEmptyReadonlyArray<A>>(...literals: L) => <I, R>(_schema: Schema<A, I, R>) => Literal<[...L]>

----------------------------------------

TITLE: TypeScript Signature for Stream.zipAll Function
DESCRIPTION: Provides the TypeScript type signature for the Stream.zipAll function. It shows the function's overloads and type parameters, illustrating how it can be used with different stream types and default values.

LANGUAGE: typescript
CODE:
declare const zipAll: { <A2, E2, R2, A>(options: { readonly other: Stream<A2, E2, R2>; readonly defaultSelf: A; readonly defaultOther: A2; }): <E, R>(self: Stream<A, E, R>) => Stream<[A, A2], E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, options: { readonly other: Stream<A2, E2, R2>; readonly defaultSelf: A; readonly defaultOther: A2; }): Stream<[A, A2], E | E2, R | R2>; }

----------------------------------------

TITLE: Creating Frequency Metric in Effect
DESCRIPTION: Demonstrates how to create a frequency metric to count event occurrences using the Effect library. The example shows creating an error frequency counter with an optional description.

LANGUAGE: typescript
CODE:
import { Metric } from "effect"

const errorFrequency = Metric.frequency("error_frequency", {
   description: "Counts the occurrences of errors."
});

LANGUAGE: typescript
CODE:
declare const frequency: (name: string, options?: { readonly description?: string | undefined; readonly preregisteredWords?: ReadonlyArray<string> | undefined; } | undefined) => Metric.Frequency<string>

----------------------------------------

TITLE: Type Signature for Array.getRights in TypeScript
DESCRIPTION: This code block shows the type signature for the Array.getRights function. It takes an Iterable of Either types and returns an array of the Right values.

LANGUAGE: typescript
CODE:
declare const getRights: <T extends Iterable<Either.Either<any, any>>>(self: T) => Array<Either.Either.Right<ReadonlyArray.Infer<T>>>

----------------------------------------

TITLE: Implementing Either.flip Type Definition in TypeScript
DESCRIPTION: Type definition for the flip function that takes an Either<R, L> and returns an Either<L, R>, effectively swapping the error and success type parameters. This enables operations on the error channel using success case methods before potentially flipping back.

LANGUAGE: typescript
CODE:
declare const flip: <R, L>(self: Either<R, L>) => Either<L, R>

----------------------------------------

TITLE: TypeScript Signature for tupled Function
DESCRIPTION: Provides the TypeScript type signature for the tupled function. It shows that the function takes a function with multiple arguments and returns a new function that accepts a single tuple argument.

LANGUAGE: typescript
CODE:
declare const tupled: <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => B) => (a: A) => B

----------------------------------------

TITLE: Comparing BigDecimal Values with greaterThan Function in TypeScript
DESCRIPTION: The greaterThan function compares two BigDecimal values, returning true if the first argument is greater than the second, otherwise false. It accepts BigDecimal inputs and returns a boolean result.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { greaterThan, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(greaterThan(unsafeFromString("2"), unsafeFromString("3")), false)
assert.deepStrictEqual(greaterThan(unsafeFromString("3"), unsafeFromString("3")), false)
assert.deepStrictEqual(greaterThan(unsafeFromString("4"), unsafeFromString("3")), true)

LANGUAGE: typescript
CODE:
declare const greaterThan: { (that: BigDecimal): (self: BigDecimal) => boolean; (self: BigDecimal, that: BigDecimal): boolean; }

----------------------------------------

TITLE: Using TestClock to Test Effect.timeout in TypeScript
DESCRIPTION: This snippet demonstrates how to use TestClock to test the Effect.timeout function. It creates a fiber with a sleep effect, adjusts the TestClock, and then checks the result of the timeout.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Duration, Effect, Fiber, TestClock, Option, pipe } from "effect"

Effect.gen(function*() {
  const fiber = yield* pipe(
    Effect.sleep(Duration.minutes(5)),
    Effect.timeout(Duration.minutes(1)),
    Effect.fork
  )
  yield* TestClock.adjust(Duration.minutes(1))
  const result = yield* Fiber.join(fiber)
  assert.deepStrictEqual(result, Option.none())
})

----------------------------------------

TITLE: Declaring HashMap.entries Function in TypeScript
DESCRIPTION: Defines the entries function for HashMap, which returns an IterableIterator of key-value pairs. It takes a HashMap as input and outputs an iterable of tuples containing keys and values.

LANGUAGE: typescript
CODE:
declare const entries: <K, V>(self: HashMap<K, V>) => IterableIterator<[K, V]>

----------------------------------------

TITLE: Retrieving Last Element from NonEmptyChunk in TypeScript
DESCRIPTION: Function signature for retrieving the last element from a non-empty chunk data structure. The function takes a NonEmptyChunk<A> as input and returns a single element of type A.

LANGUAGE: typescript
CODE:
declare const lastNonEmpty: <A>(self: NonEmptyChunk<A>) => A

----------------------------------------

TITLE: Using RegExp.escape in TypeScript
DESCRIPTION: Demonstrates how to use the RegExp.escape function to escape special characters in a regular expression pattern. The function takes a string input and returns a string with special regex characters properly escaped.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { RegExp } from "effect"

assert.deepStrictEqual(RegExp.escape("a*b"), "a\\*b")

LANGUAGE: typescript
CODE:
declare const escape: (string: string) => string

----------------------------------------

TITLE: Declaring Doc.rangle Constant in TypeScript
DESCRIPTION: Declares a constant named 'rangle' of type Doc<never> representing a document with a single '>' character. This is part of the @effect/printer package's Doc module.

LANGUAGE: typescript
CODE:
declare const rangle: Doc<never>

----------------------------------------

TITLE: Declaring Ordering.Monoid Type in TypeScript
DESCRIPTION: Shows the type declaration for the Monoid instance of Ordering. It defines Monoid as a constant of type monoid.Monoid<Ordering>.

LANGUAGE: typescript
CODE:
declare const Monoid: monoid.Monoid<Ordering>

----------------------------------------

TITLE: Defining Channel.mergeMap Function in TypeScript
DESCRIPTION: Declares the mergeMap function for the Channel module. This function creates a new channel that applies a mapping function to each emitted element, creating new channels, and then merges them based on specified strategies and concurrency limits.

LANGUAGE: typescript
CODE:
declare const mergeMap: { <OutElem, OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1>(f: (outElem: OutElem) => Channel<OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1>, options: { readonly concurrency: number | "unbounded"; readonly bufferSize?: number | undefined; readonly mergeStrategy?: MergeStrategy.MergeStrategy | undefined; }): <InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1, InElem & InElem1, OutErr1 | OutErr, InErr & InErr1, unknown, InDone & InDone1, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (outElem: OutElem) => Channel<OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1>, options: { readonly concurrency: number | "unbounded"; readonly bufferSize?: number | undefined; readonly mergeStrategy?: MergeStrategy.MergeStrategy | undefined; }): Channel<OutElem1, InElem & InElem1, OutErr | OutErr1, InErr & InErr1, unknown, InDone & InDone1, Env | Env1>; }

----------------------------------------

TITLE: Retrieving Supervised Fibers in Effect TypeScript
DESCRIPTION: Function that returns a SortedSet containing all fibers being managed within the current test context. This allows inspection and management of concurrent operations during testing.

LANGUAGE: typescript
CODE:
declare const supervisedFibers: () => Effect.Effect<SortedSet.SortedSet<Fiber.RuntimeFiber<unknown, unknown>>>

----------------------------------------

TITLE: Using Effect.either for Error Handling in TypeScript
DESCRIPTION: Example demonstrating how to use Effect.either to handle recoverable errors in an Effect program. Shows conversion of a potentially failing Effect into one that always succeeds by wrapping results in Either type.

LANGUAGE: typescript
CODE:
import { Effect, Either, Random } from "effect"

class HttpError {
  readonly _tag = "HttpError"
}

class ValidationError {
  readonly _tag = "ValidationError"
}

//      ┌─── Effect<string, HttpError | ValidationError, never>
//      ▼
const program = Effect.gen(function* () {
  const n1 = yield* Random.next
  const n2 = yield* Random.next
  if (n1 < 0.5) {
    yield* Effect.fail(new HttpError())
  }
  if (n2 < 0.5) {
    yield* Effect.fail(new ValidationError())
  }
  return "some result"
})

//      ┌─── Effect<string, never, never>
//      ▼
const recovered = Effect.gen(function* () {
  //      ┌─── Either<string, HttpError | ValidationError>
  //      ▼
  const failureOrSuccess = yield* Effect.either(program)
  return Either.match(failureOrSuccess, {
    onLeft: (error) => `Recovering from ${error._tag}`,
    onRight: (value) => value // Do nothing in case of success
  })
})

----------------------------------------

TITLE: Initializing RedBlackTree with Ordered Keys in TypeScript
DESCRIPTION: Function signature for creating a new RedBlackTree instance. Takes an Order<K> parameter for key comparison and variable number of key-value tuple entries. Returns a typed RedBlackTree structure with inferred value types.

LANGUAGE: typescript
CODE:
declare const make: <K>(ord: Order<K>) => <Entries extends Array<readonly [K, any]>>(...entries: Entries) => RedBlackTree<K, Entries[number] extends readonly [any, infer V] ? V : never>

----------------------------------------

TITLE: Defining TReentrantLock Interface in TypeScript
DESCRIPTION: TypeScript interface definition for TReentrantLock, which extends the TReentrantLock.Proto interface. This structure provides reentrant read/write locking functionality with methods for acquiring read and write locks in scoped contexts.

LANGUAGE: typescript
CODE:
export interface TReentrantLock extends TReentrantLock.Proto {}

----------------------------------------

TITLE: Defining GenAI Usage Attributes Interface in TypeScript
DESCRIPTION: Interface definition for tracking AI usage metrics, specifically input and output token counts. The interface is part of the GenAI specification and is namespaced under gen_ai.usage.

LANGUAGE: typescript
CODE:
export interface UsageAttributes {
    readonly inputTokens?: number | null | undefined
    readonly outputTokens?: number | null | undefined
  }

----------------------------------------

TITLE: Creating Cartesian Product of Streams using Stream.cross
DESCRIPTION: Demonstrates how to use Stream.cross to create a cartesian product of two streams. The example shows combining a stream of numbers (1,2,3) with a stream of letters (a,b) to produce all possible pairs.

LANGUAGE: typescript
CODE:
import { Effect, Stream } from "effect"

const s1 = Stream.make(1, 2, 3)
const s2 = Stream.make("a", "b")

const product = Stream.cross(s1, s2)

Effect.runPromise(Stream.runCollect(product)).then(console.log)
// {
//   _id: "Chunk",
//   values: [
//     [ 1, "a" ], [ 1, "b" ], [ 2, "a" ], [ 2, "b" ], [ 3, "a" ], [ 3, "b" ]
//   ]
// }

----------------------------------------

TITLE: Sorting Array with Custom Mapping Function in TypeScript
DESCRIPTION: Demonstrates how to use Array.sortWith to sort an array of strings based on their lengths in ascending order. The function takes an array, a mapping function to determine the sorting key, and an order specification.

LANGUAGE: typescript
CODE:
import { Array, Order } from "effect"

const result = Array.sortWith(["aaa", "b", "cc"], (s) => s.length, Order.number)
console.log(result) // ["b", "cc", "aaa"]

----------------------------------------

TITLE: Using Option.getOrNull in TypeScript with Effect Package
DESCRIPTION: Demonstrates how to use Option.getOrNull to extract values from Option types, returning the contained value for Some and null for None. This function is useful when interacting with APIs that use null for missing values.

LANGUAGE: typescript
CODE:
import { Option } from "effect"

console.log(Option.getOrNull(Option.some(1)))
// Output: 1

console.log(Option.getOrNull(Option.none()))
// Output: null

LANGUAGE: typescript
CODE:
declare const getOrNull: <A>(self: Option<A>) => A | null

----------------------------------------

TITLE: TypeScript Function Signature for Number Increment
DESCRIPTION: Provides the TypeScript function signature for the increment function. It takes a number as input and returns a number.

LANGUAGE: typescript
CODE:
declare const increment: (n: number) => number

----------------------------------------

TITLE: Creating HashSet from Chunk in TypeScript
DESCRIPTION: Demonstrates creating a HashSet from Effect's Chunk data structure using the fromIterable function.

LANGUAGE: typescript
CODE:
import { Chunk, HashSet, pipe } from "effect"

console.log(
  pipe(
    Chunk.make(1, 2, 3, 4), // Iterable<number>
    HashSet.fromIterable,
    HashSet.toValues // turns the HashSet back into an array
  )
) // Outputs: [1, 2, 3, 4]

----------------------------------------

TITLE: Effect.validateFirst Type Signature
DESCRIPTION: Type signature showing the function overloads and options for validateFirst, including concurrency, batching, and finalizer settings.

LANGUAGE: typescript
CODE:
declare const validateFirst: { <A, B, E, R>(f: (a: A, i: number) => Effect<B, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): (elements: Iterable<A>) => Effect<B, Array<E>, R>; <A, B, E, R>(elements: Iterable<A>, f: (a: A, i: number) => Effect<B, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): Effect<B, Array<E>, R>; }

----------------------------------------

TITLE: Modifying DocTree Annotations in TypeScript
DESCRIPTION: A function that changes the annotation type of a DocTree from type A to type B using a transformation function. Supports both curried and uncurried calling styles.

LANGUAGE: typescript
CODE:
declare const reAnnotate: { <A, B>(f: (a: A) => B): (self: DocTree<A>) => DocTree<B>; <A, B>(self: DocTree<A>, f: (a: A) => B): DocTree<B>; }

----------------------------------------

TITLE: Inserting Entries into a Trie Data Structure in TypeScript
DESCRIPTION: This code snippet demonstrates how to use the Trie.insert function to add new key-value pairs to a Trie data structure. It shows the process of creating an empty Trie and inserting multiple entries, with assertions to verify the correct insertion of data.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Trie } from "effect"

const trie1 = Trie.empty<number>().pipe(
  Trie.insert("call", 0)
)
const trie2 = trie1.pipe(Trie.insert("me", 1))
const trie3 = trie2.pipe(Trie.insert("mind", 2))
const trie4 = trie3.pipe(Trie.insert("mid", 3))

assert.deepStrictEqual(Array.from(trie1), [["call", 0]])
assert.deepStrictEqual(Array.from(trie2), [["call", 0], ["me", 1]])
assert.deepStrictEqual(Array.from(trie3), [["call", 0], ["me", 1], ["mind", 2]])
assert.deepStrictEqual(Array.from(trie4), [["call", 0], ["me", 1], ["mid", 3], ["mind", 2]])

----------------------------------------

TITLE: TypeScript Signature for isEmptyReadonlyRecord Function
DESCRIPTION: Provides the TypeScript type signature for the isEmptyReadonlyRecord function. It takes a ReadonlyRecord as input and returns a boolean indicating whether the record is empty.

LANGUAGE: typescript
CODE:
declare const isEmptyReadonlyRecord: <K extends string, A>(self: ReadonlyRecord<K, A>) => self is ReadonlyRecord<K, never>

----------------------------------------

TITLE: Creating NonEmptyArray Using Array.of in TypeScript
DESCRIPTION: Function that constructs a new NonEmptyArray<A> from a single value. This utility ensures the array will always contain at least one element of type A.

LANGUAGE: typescript
CODE:
declare const of: <A>(a: A) => NonEmptyArray<A>

----------------------------------------

TITLE: Extracting User Roles with Match.option in TypeScript
DESCRIPTION: This example demonstrates how to use Match.option to create a matcher that extracts user roles and wraps the result in an Option. It handles cases where a role matches and where it doesn't, returning Some or None accordingly.

LANGUAGE: typescript
CODE:
import { Match } from "effect"

type User = { readonly role: "admin" | "editor" | "viewer" }

// Create a matcher to extract user roles
const getRole = Match.type<User>().pipe(
  Match.when({ role: "admin" }, () => "Has full access"),
  Match.when({ role: "editor" }, () => "Can edit content"),
  Match.option // Wrap the result in an Option
)

console.log(getRole({ role: "admin" }))
// Output: { _id: 'Option', _tag: 'Some', value: 'Has full access' }

console.log(getRole({ role: "viewer" }))
// Output: { _id: 'Option', _tag: 'None' }

----------------------------------------

TITLE: Using Types.Equals for Type Comparison in TypeScript
DESCRIPTION: Demonstrates how to use the Types.Equals utility to compare two TypeScript types for equality. The example shows comparing object types with different properties.

LANGUAGE: typescript
CODE:
import type { Types } from "effect"

type Res1 = Types.Equals<{ a: number }, { a: number }> // true
type Res2 = Types.Equals<{ a: number }, { b: number }> // false

----------------------------------------

TITLE: Implementing TPubSub Shutdown Wait in TypeScript
DESCRIPTION: Defines an STM operation that waits for a TPubSub instance to be shutdown. The operation resolves when the queue reaches shutdown state or immediately if already shutdown.

LANGUAGE: typescript
CODE:
declare const awaitShutdown: <A>(self: TPubSub<A>) => STM.STM<void>

----------------------------------------

TITLE: Creating Choice Options in TypeScript using @effect/cli
DESCRIPTION: Demonstrates how to use the Options.choice function to create a command-line option that allows choosing between 'dog' and 'cat'. This function constructs Options that represent a choice between several inputs, which will be mapped to their associated values during parsing.

LANGUAGE: typescript
CODE:
import * as Options from "@effect/cli/Options"

export const animal: Options.Options<"dog" | "cat"> = Options.choice(
  "animal",
  ["dog", "cat"]
)

----------------------------------------

TITLE: Using Function.flip in TypeScript with Effect Library
DESCRIPTION: Demonstrates how to use the flip function to reverse argument order in a curried function. The example shows flipping a function that takes a number and string to return a numeric difference.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { flip } from "effect/Function"

const f = (a: number) => (b: string) => a - b.length

assert.deepStrictEqual(flip(f)('aaa')(2), -1)

LANGUAGE: typescript
CODE:
declare const flip: <A extends Array<unknown>, B extends Array<unknown>, C>(f: (...a: A) => (...b: B) => C) => (...b: B) => (...a: A) => C

----------------------------------------

TITLE: Defining Chunk.modify Function in TypeScript
DESCRIPTION: Declares the modify function for the Chunk module. This function applies a transformation to an element at a specified index in a Chunk, creating a new Chunk or returning the original if the index is out of bounds.

LANGUAGE: typescript
CODE:
declare const modify: { <A, B>(i: number, f: (a: A) => B): (self: Chunk<A>) => Chunk<A | B>; <A, B>(self: Chunk<A>, i: number, f: (a: A) => B): Chunk<A | B>; }

----------------------------------------

TITLE: Deduplicating Adjacent Elements in TypeScript Iterable
DESCRIPTION: The dedupeAdjacent function removes adjacent duplicate elements from an iterable. It takes an Iterable<A> as input and returns a new Iterable<A> with adjacent duplicates removed. This function is part of the Iterable module in the effect package.

LANGUAGE: typescript
CODE:
declare const dedupeAdjacent: <A>(self: Iterable<A>) => Iterable<A>

----------------------------------------

TITLE: Calculating Absolute Value of BigInt in TypeScript
DESCRIPTION: Demonstrates the usage of the abs function from the Effect library's BigInt module to calculate the absolute value of bigint numbers. The function takes a bigint as input and returns its absolute value.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { abs } from "effect/BigInt"

assert.deepStrictEqual(abs(-5n), 5n)
assert.deepStrictEqual(abs(0n), 0n)
assert.deepStrictEqual(abs(5n), 5n)

LANGUAGE: typescript
CODE:
declare const abs: (n: bigint) => bigint

----------------------------------------

TITLE: Trie.fromIterable Function Signature in TypeScript
DESCRIPTION: Provides the TypeScript signature for the Trie.fromIterable function, which takes an iterable of key/value pairs and returns a new Trie.

LANGUAGE: typescript
CODE:
declare const fromIterable: <V>(entries: Iterable<readonly [string, V]>) => Trie<V>

----------------------------------------

TITLE: Creating RuntimeFlagsPatch with diff Function in TypeScript
DESCRIPTION: The diff function creates a RuntimeFlagsPatch that describes the difference between two RuntimeFlags objects. It can be called with either one or two arguments, allowing for both curried and non-curried usage.

LANGUAGE: typescript
CODE:
declare const diff: { (that: RuntimeFlags): (self: RuntimeFlags) => RuntimeFlagsPatch.RuntimeFlagsPatch; (self: RuntimeFlags, that: RuntimeFlags): RuntimeFlagsPatch.RuntimeFlagsPatch; }

----------------------------------------

TITLE: Using Trie.toEntries in TypeScript
DESCRIPTION: Demonstrates how to use the Trie.toEntries function to convert a Trie into an array of key-value pairs. It creates a Trie with two entries and then converts it to an array.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Trie } from "effect"

const trie = Trie.empty<number>().pipe(
  Trie.insert("call", 0),
  Trie.insert("me", 1)
)
const result = Trie.toEntries(trie)

assert.deepStrictEqual(result, [["call", 0], ["me", 1]])

----------------------------------------

TITLE: Implementing List.some Function in TypeScript
DESCRIPTION: Defines the 'some' function for the List module. It checks if a predicate holds true for at least one element in a List. The function is overloaded to accept either the predicate first or the list first.

LANGUAGE: typescript
CODE:
declare const some: { <A>(predicate: Predicate<NoInfer<A>>): (self: List<A>) => self is Cons<A>; <A>(self: List<A>, predicate: Predicate<A>): self is Cons<A>; }

----------------------------------------

TITLE: Creating Literal Config Values in Effect TypeScript
DESCRIPTION: Demonstrates how to create a configuration value that must match one of several literal string values. This is useful for enforcing that a config value must be one of a predefined set of options.

LANGUAGE: typescript
CODE:
import { Config } from "effect"

const config = Config.literal("http", "https")("PROTOCOL")

LANGUAGE: typescript
CODE:
declare const literal: <Literals extends ReadonlyArray<LiteralValue>>(...literals: Literals) => (name?: string) => Config<Literals[number]>

----------------------------------------

TITLE: Updating FiberRef Values in Effect Module
DESCRIPTION: A function that updates the FiberRef values for the currently running fiber using a provided update function. The function takes a callback that receives the runtime fiber ID and current fiber refs, and should return the updated fiber refs.

LANGUAGE: typescript
CODE:
declare const updateFiberRefs: (f: (fiberId: FiberId.Runtime, fiberRefs: FiberRefs.FiberRefs) => FiberRefs.FiberRefs) => Effect<void>

----------------------------------------

TITLE: Checking Non-Empty Status of TPriorityQueue in TypeScript
DESCRIPTION: The isNonEmpty function checks whether a given TPriorityQueue is not empty. It returns an STM (Software Transactional Memory) operation that resolves to a boolean value. This function is useful for conditional operations based on the queue's status.

LANGUAGE: typescript
CODE:
declare const isNonEmpty: <A>(self: TPriorityQueue<A>) => STM.STM<boolean>

----------------------------------------

TITLE: Updating Channel Services in TypeScript using Effect-TS
DESCRIPTION: Provides type definitions for updating services within a channel context. The function allows modification of service resources through a transformation function while maintaining type safety. Supports both curried and uncurried calling patterns.

LANGUAGE: typescript
CODE:
declare const updateService: { 
  <I, S>(tag: Context.Tag<I, S>, f: (resource: Types.NoInfer<S>) => Types.NoInfer<S>): 
    <OutElem, OutErr, InErr, OutDone, InDone, R>
    (self: Channel<OutElem, unknown, OutErr, InErr, OutDone, InDone, R>) => 
    Channel<OutElem, unknown, OutErr, InErr, OutDone, InDone, I | R>; 
  <OutElem, OutErr, InErr, OutDone, InDone, R, I, S>
  (self: Channel<OutElem, unknown, OutErr, InErr, OutDone, InDone, R>, 
   tag: Context.Tag<I, S>, 
   f: (resource: Types.NoInfer<S>) => Types.NoInfer<S>): 
   Channel<OutElem, unknown, OutErr, InErr, OutDone, InDone, I | R>; 
}

----------------------------------------

TITLE: Array.dropRight Function Signature in TypeScript
DESCRIPTION: Provides the TypeScript signature for the Array.dropRight function. It shows two overloads: one that takes the number of elements to drop as the first argument, and another that takes the array as the first argument.

LANGUAGE: typescript
CODE:
declare const dropRight: { (n: number): <A>(self: Iterable<A>) => Array<A>; <A>(self: Iterable<A>, n: number): Array<A>; }

----------------------------------------

TITLE: Using Doc.punctuate to Add Commas in TypeScript
DESCRIPTION: This example demonstrates how to use the punctuate function to add commas between words in a document. It shows both horizontal and vertical rendering of the punctuated document.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import { pipe } from "effect/Function"
import * as String from "effect/String"

const docs = pipe(
  Doc.words("lorem ipsum dolor sit amet"),
  Doc.punctuate(Doc.comma)
)

assert.strictEqual(
  Doc.render(Doc.hsep(docs), { style: "pretty" }),
  "lorem, ipsum, dolor, sit, amet"
)

// The separators are put at the end of the entries, which can be better
// visualzied if the documents are rendered vertically
assert.strictEqual(
  Doc.render(Doc.vsep(docs), { style: "pretty" }),
  String.stripMargin(
    `|lorem,
     |ipsum,
     |dolor,
     |sit,
     |amet`
  )
)

----------------------------------------

TITLE: Creating Chunk from Iterable in TypeScript
DESCRIPTION: Function signature for creating a new Chunk data structure from any iterable collection. Takes an iterable of type A and returns a Chunk containing elements of type A.

LANGUAGE: typescript
CODE:
declare const fromIterable: <A>(self: Iterable<A>) => Chunk<A>

----------------------------------------

TITLE: Executing Micro Effect and Returning Promise in TypeScript
DESCRIPTION: The runPromise function executes a Micro effect and returns a Promise that resolves with the successful value of the computation. It accepts an effect of type Micro<A, E> and optional configuration options including an AbortSignal and a MicroScheduler.

LANGUAGE: typescript
CODE:
declare const runPromise: <A, E>(effect: Micro<A, E>, options?: { readonly signal?: AbortSignal | undefined; readonly scheduler?: MicroScheduler | undefined; } | undefined) => Promise<A>

----------------------------------------

TITLE: Defining Effect.Latch Interface in TypeScript
DESCRIPTION: This code snippet defines the Effect.Latch interface, which extends Effect<void>. It includes methods for opening, closing, and waiting on the latch, as well as releasing fibers and executing effects when the latch is open.

LANGUAGE: typescript
CODE:
export interface Latch extends Effect<void> {
  readonly open: Effect<void>

  readonly unsafeOpen: () => void

  readonly release: Effect<void>

  readonly await: Effect<void>

  readonly close: Effect<void>

  readonly unsafeClose: () => void

  readonly whenOpen: <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>

  readonly [Unify.typeSymbol]?: unknown
  readonly [Unify.unifySymbol]?: LatchUnify<this>
  readonly [Unify.ignoreSymbol]?: LatchUnifyIgnore
}

----------------------------------------

TITLE: Creating Scoped Tracing Spans in TypeScript using Effect
DESCRIPTION: The makeSpanScoped function creates a new span for tracing and automatically closes it when the Scope finalizes. The span is not added to the current span stack, so no child spans will be created for it. It takes a name and optional span options as parameters.

LANGUAGE: typescript
CODE:
declare const makeSpanScoped: (name: string, options?: Tracer.SpanOptions | undefined) => Effect<Tracer.Span, never, Scope.Scope>

----------------------------------------

TITLE: Effect.head Function Signature in TypeScript
DESCRIPTION: This code block shows the TypeScript signature for the Effect.head function. It takes an Effect that produces an Iterable and returns an Effect that produces the first element of that Iterable or a NoSuchElementException if the Iterable is empty.

LANGUAGE: typescript
CODE:
declare const head: <A, E, R>(self: Effect<Iterable<A>, E, R>) => Effect<A, Cause.NoSuchElementException | E, R>

----------------------------------------

TITLE: Cron.parse Function Signature in TypeScript
DESCRIPTION: The signature of the Cron.parse function, which takes a cron expression string and an optional timezone parameter. It returns an Either type containing either a Cron instance or a ParseError.

LANGUAGE: typescript
CODE:
declare const parse: (cron: string, tz?: DateTime.TimeZone | string) => Either.Either<Cron, ParseError>

----------------------------------------

TITLE: Stream.intersperseAffixes Type Definition
DESCRIPTION: Type signature for the intersperseAffixes function showing its polymorphic nature and type constraints. The function accepts options for start, middle, and end elements, and works with streams of any type.

LANGUAGE: typescript
CODE:
declare const intersperseAffixes: { <A2, A3, A4>(options: { readonly start: A2; readonly middle: A3; readonly end: A4; }): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A3 | A4 | A, E, R>; <A, E, R, A2, A3, A4>(self: Stream<A, E, R>, options: { readonly start: A2; readonly middle: A3; readonly end: A4; }): Stream<A | A2 | A3 | A4, E, R>; }

----------------------------------------

TITLE: Creating a KeyedPool with Fixed Size in TypeScript
DESCRIPTION: The make function creates a new pool of specified fixed size. The pool is returned in a Scope, which manages its lifetime. When the Scope is closed, the pool is shutdown and its items are released in an unspecified order.

LANGUAGE: typescript
CODE:
declare const make: <K, A, E, R>(options: { readonly acquire: (key: K) => Effect.Effect<A, E, R>; readonly size: number; }) => Effect.Effect<KeyedPool<K, A, E>, never, Scope.Scope | R>

----------------------------------------

TITLE: Creating Fresh Layer in TypeScript using effect Package
DESCRIPTION: The fresh function creates a new version of a given layer that will not be shared. It takes a Layer<A, E, R> as input and returns a new Layer<A, E, R>. This function is part of the Layer module in the effect package.

LANGUAGE: typescript
CODE:
declare const fresh: <A, E, R>(self: Layer<A, E, R>) => Layer<A, E, R>

----------------------------------------

TITLE: Lifting a Predicate into an Array in TypeScript
DESCRIPTION: Demonstrates how to use Array.liftPredicate to convert a predicate function into an array-returning function. The example shows lifting an 'isEven' predicate and applying it to different numbers.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const isEven = (n: number) => n % 2 === 0
const to = Array.liftPredicate(isEven)
console.log(to(1)) // []
console.log(to(2)) // [2]

----------------------------------------

TITLE: Defining BaseTQueue Interface in TypeScript
DESCRIPTION: Defines the BaseTQueue interface with methods for capacity, size, state checks, and shutdown operations. This interface is crucial for implementing queue-like structures with transactional semantics in the Effect library.

LANGUAGE: typescript
CODE:
export interface BaseTQueue {
  /**
   * Returns the number of elements the queue can hold.
   */
  capacity(): number

  /**
   * Retrieves the size of the queue, which is equal to the number of elements
   * in the queue. This may be negative if fibers are suspended waiting for
   * elements to be added to the queue.
   */
  readonly size: STM.STM<number>

  /**
   * Returns `true` if the `TQueue` contains at least one element, `false`
   * otherwise.
   */
  readonly isFull: STM.STM<boolean>

  /**
   * Returns `true` if the `TQueue` contains zero elements, `false` otherwise.
   */
  readonly isEmpty: STM.STM<boolean>

  /**
   * Interrupts any fibers that are suspended on `offer` or `take`. Future calls
   * to `offer*` and `take*` will be interrupted immediately.
   */
  readonly shutdown: STM.STM<void>

  /**
   * Returns `true` if `shutdown` has been called, otherwise returns `false`.
   */
  readonly isShutdown: STM.STM<boolean>

  /**
   * Waits until the queue is shutdown. The `STM` returned by this method will
   * not resume until the queue has been shutdown. If the queue is already
   * shutdown, the `STM` will resume right away.
   */
  readonly awaitShutdown: STM.STM<void>
}

----------------------------------------

TITLE: Defining Array.init Function Signature in TypeScript
DESCRIPTION: Type declaration for the init function that takes an Iterable of type A and returns an Option containing an Array of type A, excluding the last element. Returns None if the Iterable is empty.

LANGUAGE: typescript
CODE:
declare const init: <A>(self: Iterable<A>) => Option.Option<Array<A>>

----------------------------------------

TITLE: Implementing Channel.writeAll Function in TypeScript
DESCRIPTION: Defines a function that writes multiple values to a channel. The function accepts a variable number of elements and returns a Channel that can output any of the provided element types.

LANGUAGE: typescript
CODE:
declare const writeAll: <OutElems extends Array<any>>(...outs: OutElems) => Channel<OutElems[number]>

----------------------------------------

TITLE: Constructing Array Config in TypeScript using Effect
DESCRIPTION: This function constructs a config for an array of values. It takes a Config<A> and an optional name parameter, and returns a Config<Array<A>>.

LANGUAGE: typescript
CODE:
declare const array: <A>(config: Config<A>, name?: string) => Config<Array<A>>

----------------------------------------

TITLE: Retrieving Cookies in TypeScript using @effect/platform
DESCRIPTION: Defines a function 'get' to retrieve a cookie from a Cookies object. It can be called with either (name)(self) or (self, name) parameter order. Returns an Option<Cookie>.

LANGUAGE: typescript
CODE:
declare const get: { (name: string): (self: Cookies) => Option.Option<Cookie>; (self: Cookies, name: string): Option.Option<Cookie>; }

----------------------------------------

TITLE: Implementing Predicate Check on Chunk Elements in TypeScript
DESCRIPTION: The 'some' function checks if a predicate holds true for some element in a Chunk. It has two overloads: one takes a predicate and returns a function, the other takes both the Chunk and the predicate. Both return a type predicate indicating if the Chunk is non-empty.

LANGUAGE: typescript
CODE:
declare const some: { <A>(predicate: Predicate<NoInfer<A>>): (self: Chunk<A>) => self is NonEmptyChunk<A>; <A>(self: Chunk<A>, predicate: Predicate<A>): self is NonEmptyChunk<A>; }

----------------------------------------

TITLE: Implementing Scope-Based Effects in TypeScript using Effect.scopeWith
DESCRIPTION: Function signature for scopeWith that enables access to the current scope for performing specified effects. Takes a function parameter that receives a Scope object and returns an Effect, producing a new Effect that includes the Scope requirement.

LANGUAGE: typescript
CODE:
declare const scopeWith: <A, E, R>(f: (scope: Scope.Scope) => Effect<A, E, R>) => Effect<A, E, R | Scope.Scope>

----------------------------------------

TITLE: Handling Success or Failure with Either in Effect.race
DESCRIPTION: Demonstrates using Effect.either to handle both success and failure outcomes when racing effects.

LANGUAGE: typescript
CODE:
import { Effect, Console } from "effect"

const task1 = Effect.fail("task1").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Console.log("task1 done")),
  Effect.onInterrupt(() => Console.log("task1 interrupted"))
)
const task2 = Effect.succeed("task2").pipe(
  Effect.delay("200 millis"),
  Effect.tap(Console.log("task2 done")),
  Effect.onInterrupt(() => Console.log("task2 interrupted"))
)

// Run both tasks concurrently, wrapping the result
// in Either to capture success or failure
const program = Effect.race(Effect.either(task1), Effect.either(task2))

Effect.runPromise(program).then(console.log)
// Output:
// task2 interrupted
// { _id: 'Either', _tag: 'Left', left: 'task1' }

----------------------------------------

TITLE: Defining Lowercase Schema Class - TypeScript
DESCRIPTION: Declaration of the Lowercase class schema that converts strings to lowercase. Part of the Schema module in the effect package.

LANGUAGE: typescript
CODE:
declare class Lowercase

----------------------------------------

TITLE: Using Boolean SemigroupSome Combine Operations
DESCRIPTION: Demonstrates the usage of SemigroupSome's combine operation for boolean values under disjunction (OR operation). The combine method returns true if either or both inputs are true, and false only when both inputs are false.

LANGUAGE: typescript
CODE:
import { SemigroupSome } from "@effect/typeclass/data/Boolean"

console.log(SemigroupSome.combine(true, true))
// true
console.log(SemigroupSome.combine(true, false))
// true
console.log(SemigroupSome.combine(false, true))
// true
console.log(SemigroupSome.combine(false, false))
// false

LANGUAGE: typescript
CODE:
declare const SemigroupSome: semigroup.Semigroup<boolean>

----------------------------------------

TITLE: Defining zipAllSortedByKeyLeft Function in TypeScript
DESCRIPTION: Declares the zipAllSortedByKeyLeft function for zipping two sorted streams by key. It takes options including the other stream, default value, and ordering, and returns a new stream with values from the first stream.

LANGUAGE: typescript
CODE:
declare const zipAllSortedByKeyLeft: { <A2, E2, R2, A, K>(options: { readonly other: Stream<readonly [K, A2], E2, R2>; readonly defaultSelf: A; readonly order: Order.Order<K>; }): <E, R>(self: Stream<readonly [K, A], E, R>) => Stream<[K, A], E2 | E, R2 | R>; <K, A, E, R, A2, E2, R2>(self: Stream<readonly [K, A], E, R>, options: { readonly other: Stream<readonly [K, A2], E2, R2>; readonly defaultSelf: A; readonly order: Order.Order<K>; }): Stream<[K, A], E | E2, R | R2>; }

----------------------------------------

TITLE: Implementing String.includes Function in TypeScript for Effect Library
DESCRIPTION: Defines a function that checks if a searchString is present within a given string, starting from an optional position. It returns a boolean indicating the presence of the substring.

LANGUAGE: typescript
CODE:
declare const includes: (searchString: string, position?: number) => (self: string) => boolean

----------------------------------------

TITLE: Implementing Iterable Drop Operation in TypeScript
DESCRIPTION: Function declaration for dropping a specified number of elements from the start of an Iterable. The function normalizes the input number to a non-negative integer and supports both curried and non-curried invocation patterns.

LANGUAGE: typescript
CODE:
declare const drop: { (n: number): <A>(self: Iterable<A>) => Iterable<A>; <A>(self: Iterable<A>, n: number): Iterable<A>; }

----------------------------------------

TITLE: Creating RedBlackTree from Iterable in TypeScript
DESCRIPTION: The fromIterable function creates a new RedBlackTree from an iterable collection of key/value pairs. It takes an Order function for comparison and an iterable of entries. The function is overloaded to allow for different parameter orderings.

LANGUAGE: typescript
CODE:
declare const fromIterable: { <B>(ord: Order<B>): <K extends B, V>(entries: Iterable<readonly [K, V]>) => RedBlackTree<K, V>; <K extends B, V, B>(entries: Iterable<readonly [K, V]>, ord: Order<B>): RedBlackTree<K, V>; }

----------------------------------------

TITLE: Array.mapAccum Function Signature in TypeScript
DESCRIPTION: Provides the TypeScript signature for the Array.mapAccum function, showing its overloaded variants and type parameters.

LANGUAGE: typescript
CODE:
declare const mapAccum: { <S, A, B, I extends Iterable<A> = Iterable<A>>(s: S, f: (s: S, a: ReadonlyArray.Infer<I>, i: number) => readonly [S, B]): (self: I) => [state: S, mappedArray: ReadonlyArray.With<I, B>]; <S, A, B, I extends Iterable<A> = Iterable<A>>(self: I, s: S, f: (s: S, a: ReadonlyArray.Infer<I>, i: number) => readonly [S, B]): [state: S, mappedArray: ReadonlyArray.With<I, B>]; }

----------------------------------------

TITLE: Mutating HashMap in TypeScript
DESCRIPTION: The mutate function allows for mutation of a HashMap within the context of a provided function. It can be used in two ways: either by passing a function that mutates the HashMap, or by passing the HashMap itself along with the mutating function.

LANGUAGE: typescript
CODE:
declare const mutate: { <K, V>(f: (self: HashMap<K, V>) => void): (self: HashMap<K, V>) => HashMap<K, V>; <K, V>(self: HashMap<K, V>, f: (self: HashMap<K, V>) => void): HashMap<K, V>; }

----------------------------------------

TITLE: Defining differenceWith Function for Chunk Comparison in TypeScript
DESCRIPTION: Declares the differenceWith function, which creates a new Chunk containing values from the first Chunk that are not present in the second Chunk, based on a custom equivalence function. The function is curried and can be called with either one or two Chunk arguments.

LANGUAGE: TypeScript
CODE:
declare const differenceWith: <A>(isEquivalent: (self: A, that: A) => boolean) => { (that: Chunk<A>): (self: Chunk<A>) => Chunk<A>; (self: Chunk<A>, that: Chunk<A>): Chunk<A>; }

----------------------------------------

TITLE: Using Array.extend for Subarray Mapping in TypeScript
DESCRIPTION: Demonstrates how to use Array.extend to map each subarray to its length. The function processes each subarray starting from each element position and applies the given mapping function.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const result = Array.extend([1, 2, 3], as => as.length)
console.log(result) // [3, 2, 1]

// Explanation:
// The function maps each subarray starting from each element to its length.
// The subarrays are: [1, 2, 3], [2, 3], [3].
// The lengths are: 3, 2, 1.
// Therefore, the result is [3, 2, 1].

----------------------------------------

TITLE: Using Array.difference in TypeScript with Effect Library
DESCRIPTION: Demonstrates how to use the Array.difference function to create an array containing elements from the first iterable that are not present in the second iterable. The function preserves the order and references of values from the first iterable.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const difference = Array.difference([1, 2, 3], [2, 3, 4])
console.log(difference) // [1]

LANGUAGE: typescript
CODE:
declare const difference: { <A>(that: Iterable<A>): (self: Iterable<A>) => Array<A>; <A>(self: Iterable<A>, that: Iterable<A>): Array<A>; }

----------------------------------------

TITLE: Defining aggregateWithin Function in TypeScript for Stream Aggregation
DESCRIPTION: Declares the 'aggregateWithin' function, which aggregates stream elements using a sink and a schedule. It returns only the Right results, unlike 'aggregateWithinEither'. The function is overloaded to accept parameters in different orders.

LANGUAGE: TypeScript
CODE:
declare const aggregateWithin: { <B, A, A2, E2, R2, C, R3>(sink: Sink.Sink<B, A | A2, A2, E2, R2>, schedule: Schedule.Schedule<C, Option.Option<B>, R3>): <E, R>(self: Stream<A, E, R>) => Stream<B, E2 | E, R2 | R3 | R>; <A, E, R, B, A2, E2, R2, C, R3>(self: Stream<A, E, R>, sink: Sink.Sink<B, A | A2, A2, E2, R2>, schedule: Schedule.Schedule<C, Option.Option<B>, R3>): Stream<B, E | E2, R | R2 | R3>; }

----------------------------------------

TITLE: TypeScript Signature for Stream.mergeWithTag Function
DESCRIPTION: Provides the TypeScript signature for the Stream.mergeWithTag function. It shows two overloads: one for direct usage with streams and options, and another for creating a curried function with options.

LANGUAGE: typescript
CODE:
declare const mergeWithTag: { <S extends { [k in string]: Stream<any, any, any>; }>(streams: S, options: { readonly concurrency: number | "unbounded"; readonly bufferSize?: number | undefined; }): Stream<{ [K in keyof S]: { _tag: K; value: Stream.Success<S[K]>; }; }[keyof S], Stream.Error<S[keyof S]>, Stream.Context<S[keyof S]>>; (options: { readonly concurrency: number | "unbounded"; readonly bufferSize?: number | undefined; }): <S extends { [k in string]: Stream<any, any, any>; }>(streams: S) => Stream<{ [K in keyof S]: { _tag: K; value: Stream.Success<S[K]>; }; }[keyof S], Stream.Error<S[keyof S]>, Stream.Context<S[keyof S]>>; }

----------------------------------------

TITLE: Checking TQueue Emptiness in TypeScript
DESCRIPTION: The isEmpty function returns a boolean indicating whether a TQueue contains zero elements. It works with both TDequeue and TEnqueue types and returns an STM (Software Transactional Memory) operation.

LANGUAGE: typescript
CODE:
declare const isEmpty: <A>(self: TDequeue<A> | TEnqueue<A>) => STM.STM<boolean>

----------------------------------------

TITLE: Using max Function from Effect Number Module
DESCRIPTION: Demonstrates how to use the max function to find the larger of two numbers. The function can be used either with curried or binary syntax.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { max } from "effect/Number"

assert.deepStrictEqual(max(2, 3), 3)

LANGUAGE: typescript
CODE:
declare const max: { (that: number): (self: number) => number; (self: number, that: number): number; }

----------------------------------------

TITLE: Declaring filterMap Function in TypeScript for Micro Module
DESCRIPTION: Defines the filterMap function that effectfully filters and maps elements of an iterable. It allows concurrent processing of elements through the concurrency option.

LANGUAGE: typescript
CODE:
declare const filterMap: <A, B, E, R>(iterable: Iterable<A>, f: (a: NoInfer<A>) => Micro<Option.Option<B>, E, R>, options?: { readonly concurrency?: Concurrency | undefined; }) => Micro<Array<B>, E, R>

----------------------------------------

TITLE: HashSet.mutate Type Signature
DESCRIPTION: Type declaration for the HashSet.mutate function showing its polymorphic nature and support for both data-first and data-last APIs.

LANGUAGE: typescript
CODE:
declare const mutate: { <A>(f: (set: HashSet<A>) => void): (self: HashSet<A>) => HashSet<A>; <A>(self: HashSet<A>, f: (set: HashSet<A>) => void): HashSet<A>; }

----------------------------------------

TITLE: Defining Sequential ExecutionStrategy Interface in TypeScript
DESCRIPTION: Defines the Sequential interface for the ExecutionStrategy module. This interface represents a strategy for executing effects sequentially, identified by the _tag property set to "Sequential".

LANGUAGE: typescript
CODE:
export interface Sequential {
  readonly _tag: "Sequential"
}

----------------------------------------

TITLE: Declaring StringFromBase64Url Schema Type in TypeScript
DESCRIPTION: Type declaration for the StringFromBase64Url schema transformer that converts base64 URL-encoded strings to UTF-8 strings. The schema type indicates it transforms from string to string with no error type.

LANGUAGE: typescript
CODE:
declare const StringFromBase64Url: Schema<string, string, never>

----------------------------------------

TITLE: Adding Cookies with unsafeSet Function in TypeScript
DESCRIPTION: The unsafeSet function adds a cookie to a Cookies object. It takes the cookie name, value, and optional settings as parameters. The function can be used in two ways: either by passing the Cookies object as the first argument, or as a curried function returning a function that takes the Cookies object.

LANGUAGE: typescript
CODE:
declare const unsafeSet: { (name: string, value: string, options?: Cookie["options"]): (self: Cookies) => Cookies; (self: Cookies, name: string, value: string, options?: Cookie["options"]): Cookies; }

----------------------------------------

TITLE: Creating Branded Schema in TypeScript using Effect Schema
DESCRIPTION: Demonstrates how to create a nominal branded schema by applying a brand to a given schema. The example shows creating an Int type by branding a number schema.

LANGUAGE: typescript
CODE:
import * as Schema from "effect/Schema"

const Int = Schema.Number.pipe(Schema.int(), Schema.brand("Int"))
type Int = Schema.Schema.Type<typeof Int> // number & Brand<"Int">

----------------------------------------

TITLE: Implementing Boolean SemigroupXor in TypeScript
DESCRIPTION: Demonstrates the usage of SemigroupXor for combining boolean values using exclusive disjunction (XOR). Shows how different boolean combinations result in true only when inputs differ, and false when inputs are the same.

LANGUAGE: typescript
CODE:
import { SemigroupXor } from "@effect/typeclass/data/Boolean"

console.log(SemigroupXor.combine(true, true))
// false
console.log(SemigroupXor.combine(true, false))
// true
console.log(SemigroupXor.combine(false, true))
// true
console.log(SemigroupXor.combine(false, false))
// false

LANGUAGE: typescript
CODE:
declare const SemigroupXor: semigroup.Semigroup<boolean>

----------------------------------------

TITLE: Combining BrandErrors in TypeScript for Effect Package
DESCRIPTION: This function takes a variable number of BrandErrors and combines them into a single BrandErrors object. It's used for aggregating refinement errors in the Brand module.

LANGUAGE: typescript
CODE:
declare const errors: (...errors: Array<Brand.BrandErrors>) => Brand.BrandErrors

----------------------------------------

TITLE: Configuring Unhandled Error Logging Example
DESCRIPTION: Demonstrates how to configure the logging level for unhandled errors in child fibers using Effect.withUnhandledErrorLogLevel. The example shows creating a fiber that fails with an error and configuring it to log at the Error level.

LANGUAGE: typescript
CODE:
import { Effect, Fiber, LogLevel, Option } from "effect"

const program = Effect.gen(function*() {
  const fiber = yield* Effect.fork(Effect.fail("Unhandled error!"))
  yield* Fiber.join(fiber)
})

Effect.runFork(program.pipe(Effect.withUnhandledErrorLogLevel(Option.some(LogLevel.Error))))
// Output:
// timestamp=... level=ERROR fiber=#1 message="Fiber terminated with an unhandled error" cause="Error: Unhandled error!"

----------------------------------------

TITLE: Splitting Lists with List.splitAt in TypeScript
DESCRIPTION: Function that splits a list into two separate lists at a specified index position. Returns a tuple containing two lists: one with elements before the index and another with elements from the index onwards. Supports both curried and non-curried function calls.

LANGUAGE: typescript
CODE:
declare const splitAt: { 
  (n: number): <A>(self: List<A>) => [beforeIndex: List<A>, fromIndex: List<A>]; 
  <A>(self: List<A>, n: number): [beforeIndex: List<A>, fromIndex: List<A>]; 
}

----------------------------------------

TITLE: Defining filterInput Function in TypeScript for Sink Module
DESCRIPTION: Declares the filterInput function which filters a sink's input using either a Refinement or a Predicate. It returns a new Sink with the filtered input type.

LANGUAGE: typescript
CODE:
declare const filterInput: { <In, In1 extends In, In2 extends In1>(f: Refinement<In1, In2>): <A, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In2, L, E, R>; <In, In1 extends In>(f: Predicate<In1>): <A, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In1, L, E, R>; }

----------------------------------------

TITLE: Using Array.dropWhile in TypeScript with Effect Library
DESCRIPTION: Demonstrates how to use the dropWhile function to remove elements from the beginning of an array while they satisfy a given predicate. The function returns a new array containing only the remaining elements after the longest matching sequence.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const result = Array.dropWhile([1, 2, 3, 4, 5], x => x < 4)
console.log(result) // [4, 5]

LANGUAGE: typescript
CODE:
declare const dropWhile: { <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Array<A>; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Array<A>; }

----------------------------------------

TITLE: Defining Unbounded Interface for PageWidth in TypeScript
DESCRIPTION: This code snippet defines the Unbounded interface, which extends PageWidth.Proto. It represents a PageWidth setting that avoids line breaks in document layout. The interface includes a readonly _tag property set to "Unbounded".

LANGUAGE: typescript
CODE:
export interface Unbounded extends PageWidth.Proto {
  readonly _tag: "Unbounded"
}

----------------------------------------

TITLE: Merging Error and Success Channels in STM Effect (TypeScript)
DESCRIPTION: The STM.merge function takes an STM effect and returns a new effect where the error channel has been merged into the success channel. This results in a combined type for both error and success outcomes.

LANGUAGE: typescript
CODE:
declare const merge: <A, E, R>(self: STM<A, E, R>) => STM<E | A, never, R>

----------------------------------------

TITLE: Using String.isEmpty in TypeScript
DESCRIPTION: Demonstrates how to use the String.isEmpty function to check if a string is empty. It imports the necessary modules and uses assert to verify the function's behavior.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { String } from "effect"

assert.deepStrictEqual(String.isEmpty(''), true)
assert.deepStrictEqual(String.isEmpty('a'), false)

----------------------------------------

TITLE: Defining unfoldChunkEffect Function in TypeScript for Effect Stream Module
DESCRIPTION: This function creates a stream by effectfully peeling off the "layers" of a value of type S. It takes an initial state and a function that produces an Effect containing an Option of a tuple with a Chunk of values and the next state.

LANGUAGE: typescript
CODE:
declare const unfoldChunkEffect: <S, A, E, R>(s: S, f: (s: S) => Effect.Effect<Option.Option<readonly [Chunk.Chunk<A>, S]>, E, R>) => Stream<A, E, R>

----------------------------------------

TITLE: Type Signature for Array.max Function in Effect Library
DESCRIPTION: Provides the TypeScript type signature for the Array.max function. It shows that the function can be used with two different parameter orders and works with non-empty readonly arrays.

LANGUAGE: typescript
CODE:
declare const max: { <A>(O: Order.Order<A>): (self: NonEmptyReadonlyArray<A>) => A; <A>(self: NonEmptyReadonlyArray<A>, O: Order.Order<A>): A; }

----------------------------------------

TITLE: Function Signature of Schema.standardSchemaV1 in TypeScript
DESCRIPTION: Provides the TypeScript function signature for Schema.standardSchemaV1, showing its generic types and parameters. It takes a Schema and optional parse options, returning a StandardSchemaV1 object combined with a SchemaClass.

LANGUAGE: typescript
CODE:
declare const standardSchemaV1: <A, I>(schema: Schema<A, I, never>, overrideOptions?: AST.ParseOptions) => StandardSchemaV1<I, A> & SchemaClass<A, I, never>

----------------------------------------

TITLE: Implementing Stream.zipFlatten in TypeScript
DESCRIPTION: Defines a function that zips two streams together point-wise, producing tuples of elements from both streams. The operation continues until one stream ends. The function supports generic types for different array elements, error types, and runtime requirements.

LANGUAGE: typescript
CODE:
declare const zipFlatten: { 
  <A2, E2, R2>(that: Stream<A2, E2, R2>): 
    <A extends ReadonlyArray<any>, E, R>(self: Stream<A, E, R>) => 
      Stream<[...A, A2], E2 | E, R2 | R>; 
  <A extends ReadonlyArray<any>, E, R, A2, E2, R2>
    (self: Stream<A, E, R>, that: Stream<A2, E2, R2>): 
      Stream<[...A, A2], E | E2, R | R2>; 
}

----------------------------------------

TITLE: Creating an Iterable with makeBy Function in TypeScript
DESCRIPTION: Demonstrates how to use the makeBy function to create an Iterable with elements initialized by a function. The example shows creating an Iterable of even numbers with a specified length.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { makeBy } from "effect/Iterable"

assert.deepStrictEqual(Array.from(makeBy(n => n * 2, { length: 5 })), [0, 2, 4, 6, 8])

----------------------------------------

TITLE: TypeScript Signature for Record.mapKeys Function
DESCRIPTION: Provides the TypeScript signature for the mapKeys function, showing its overloaded versions for different parameter orders and type constraints.

LANGUAGE: typescript
CODE:
declare const mapKeys: { <K extends string, A, K2 extends string>(f: (key: K, a: A) => K2): (self: ReadonlyRecord<K, A>) => Record<K2, A>; <K extends string, A, K2 extends string>(self: ReadonlyRecord<K, A>, f: (key: K, a: A) => K2): Record<K2, A>; }

----------------------------------------

TITLE: Checking Array Contains Value with STM in TypeScript
DESCRIPTION: Method to determine if a transactional array contains a specified value. The function supports both curried and direct parameter passing styles and returns an STM boolean result.

LANGUAGE: typescript
CODE:
declare const contains: { 
  <A>(value: A): (self: TArray<A>) => STM.STM<boolean>; 
  <A>(self: TArray<A>, value: A): STM.STM<boolean>; 
}

----------------------------------------

TITLE: Converting List to Chunk in TypeScript
DESCRIPTION: The toChunk function converts a List<A> to a Chunk.Chunk<A>. It is part of the List module in the Effect library. This function is available since version 2.0.0 of the library.

LANGUAGE: typescript
CODE:
declare const toChunk: <A>(self: List<A>) => Chunk.Chunk<A>

----------------------------------------

TITLE: Creating Tuples with Effect/Tuple make Function
DESCRIPTION: Demonstrates how to create a new tuple using the make function from the Effect library's Tuple module. The function accepts variable arguments and returns them as a tuple array.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { make } from "effect/Tuple"

assert.deepStrictEqual(make(1, 'hello', true), [1, 'hello', true])

LANGUAGE: typescript
CODE:
declare const make: <A extends ReadonlyArray<any>>(...elements: A) => A

----------------------------------------

TITLE: Effect zipRight Function Type Signature
DESCRIPTION: Type declaration for the zipRight function showing its polymorphic nature and support for options including concurrent execution, batching, and concurrent finalizers.

LANGUAGE: typescript
CODE:
declare const zipRight: { <A2, E2, R2>(that: Effect<A2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; readonly batching?: boolean | "inherit" | undefined; readonly concurrentFinalizers?: boolean | undefined; }): <A, E, R>(self: Effect<A, E, R>) => Effect<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, that: Effect<A2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; readonly batching?: boolean | "inherit" | undefined; readonly concurrentFinalizers?: boolean | undefined; }): Effect<A2, E2 | E, R2 | R>; }

----------------------------------------

TITLE: Defining ChildExecutorDecision.Continue Interface in TypeScript
DESCRIPTION: Defines a TypeScript interface representing a decision to continue executing the current substream. The interface extends ChildExecutorDecision.Proto and includes a discriminant _tag property with value "Continue".

LANGUAGE: typescript
CODE:
export interface Continue extends ChildExecutorDecision.Proto {
  readonly _tag: "Continue"
}

----------------------------------------

TITLE: Using HashSet.mutate in Effect Library
DESCRIPTION: Demonstrates different ways to use the HashSet.mutate function for modifying HashSet contents. Shows data-last (pipeable), piped, and data-first API approaches.

LANGUAGE: typescript
CODE:
// Syntax
import { HashSet, pipe } from "effect"

// with data-last, a.k.a. pipeable API
pipe(
  HashSet.make(1, 2, 3),
  HashSet.mutate((set) => {
    HashSet.add(set, 4)
    HashSet.remove(set, 1)
  })
)

// or piped with the pipe function
HashSet.make(1, 2, 3).pipe(
  HashSet.mutate((set) => {
    HashSet.add(set, 4)
    HashSet.remove(set, 1)
  })
)

// or with data-first API
HashSet.mutate(HashSet.make(1, 2, 3), (set) => {
  HashSet.add(set, 4)
  HashSet.remove(set, 1)
})

----------------------------------------

TITLE: Converting Error Options to Value Options in STM - TypeScript
DESCRIPTION: Function signature for unsome, which transforms an STM operation containing an Option of errors into an STM operation containing an Option of values. This allows for more flexible error handling in transactional operations.

LANGUAGE: typescript
CODE:
declare const unsome: <A, E, R>(self: STM<A, Option.Option<E>, R>) => STM<Option.Option<A>, E, R>

----------------------------------------

TITLE: Implementing TSet Intersection in TypeScript
DESCRIPTION: Defines an atomic operation that transforms a TSet into its intersection with another provided TSet. The operation is provided in both curried and uncurried forms, returning an STM transaction that performs the intersection.

LANGUAGE: typescript
CODE:
declare const intersection: { <A>(other: TSet<A>): (self: TSet<A>) => STM.STM<void>; <A>(self: TSet<A>, other: TSet<A>): STM.STM<void>; }

----------------------------------------

TITLE: Implementing Scoped Test Configuration in Effect
DESCRIPTION: A utility function that temporarily sets a test configuration implementation and automatically restores the original configuration when the scope closes. Takes a TestConfig parameter and returns an Effect that requires a Scope.

LANGUAGE: typescript
CODE:
declare const withTestConfigScoped: (config: TestConfig.TestConfig) => Effect.Effect<void, never, Scope.Scope>

----------------------------------------

TITLE: Constructing HashMap Differ in TypeScript
DESCRIPTION: The hashMap function constructs a differ that can diff a HashMap of keys and values. It takes a differ for the values as input and returns a new differ for the entire HashMap structure.

LANGUAGE: typescript
CODE:
declare const hashMap: <Key, Value, Patch>(differ: Differ<Value, Patch>) => Differ<HashMap<Key, Value>, Differ.HashMap.Patch<Key, Value, Patch>>

----------------------------------------

TITLE: Extending Layer Scope in TypeScript
DESCRIPTION: The extendScope function extends the scope of a layer, returning a new layer that doesn't immediately release its resources when an effect completes. Instead, resources are released when the scope the resulting effect depends on is closed. It takes a Layer as input and returns a new Layer with modified behavior.

LANGUAGE: typescript
CODE:
declare const extendScope: <RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Layer<ROut, E, Scope.Scope | RIn>

----------------------------------------

TITLE: Declaring Stream.crossLeft Function in TypeScript
DESCRIPTION: Defines the crossLeft function for composing streams. It creates a cartesian product of elements from two streams, keeping only elements from the left stream. The right stream is run multiple times for each element in the left stream.

LANGUAGE: typescript
CODE:
declare const crossLeft: { <AR, ER, RR>(right: Stream<AR, ER, RR>): <AL, EL, RL>(left: Stream<AL, EL, RL>) => Stream<AL, EL | ER, RL | RR>; <AL, EL, RL, AR, ER, RR>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>): Stream<AL, EL | ER, RL | RR>; }

----------------------------------------

TITLE: Creating and Using a FiberSet in TypeScript
DESCRIPTION: This example demonstrates how to create a FiberSet, add fibers to it using FiberSet.run, and automatically interrupt the fibers when the scope is closed. It uses the Effect and FiberSet modules from the 'effect' package.

LANGUAGE: typescript
CODE:
import { Effect, FiberSet } from "effect"

Effect.gen(function*() {
  const set = yield* FiberSet.make()

  // run some effects and add the fibers to the set
  yield* FiberSet.run(set, Effect.never)
  yield* FiberSet.run(set, Effect.never)

  yield* Effect.sleep(1000)
}).pipe(
  Effect.scoped // The fibers will be interrupted when the scope is closed
)

----------------------------------------

TITLE: Defining Composite Class for Multiple Parsing Issues in TypeScript
DESCRIPTION: This code defines the Composite class within the ParseResult module. It represents an error that contains multiple parsing issues. The class constructor takes parameters for the AST, actual value, parsing issues, and optional output.

LANGUAGE: typescript
CODE:
declare class Composite { constructor(
    readonly ast: AST.AST,
    readonly actual: unknown,
    readonly issues: SingleOrNonEmpty<ParseIssue>,
    readonly output?: unknown
  ) }

----------------------------------------

TITLE: Creating Sliding Queue in TypeScript using Effect Package
DESCRIPTION: Creates a new bounded Queue with sliding strategy where new elements replace old ones when capacity is reached. For optimal performance, capacity should be a power of 2. The function returns an Effect containing the created Queue.

LANGUAGE: typescript
CODE:
declare const sliding: <A>(requestedCapacity: number) => Effect.Effect<Queue<A>>

----------------------------------------

TITLE: Defining Channel.unwrap Function in TypeScript
DESCRIPTION: Defines the unwrap function that constructs a Channel from an effect. It takes an Effect that results in a Channel and returns a new Channel with combined type parameters.

LANGUAGE: typescript
CODE:
declare const unwrap: <OutElem, InElem, OutErr, InErr, OutDone, InDone, R2, E, R>(channel: Effect.Effect<Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, R2>, E, R>) => Channel<OutElem, InElem, E | OutErr, InErr, OutDone, InDone, R | R2>

----------------------------------------

TITLE: Defining orDie Function for Stream in TypeScript
DESCRIPTION: The orDie function translates any failure in a Stream into a stream termination. It takes a Stream that may fail with error type E and returns a Stream that never fails, effectively making all failures unchecked.

LANGUAGE: typescript
CODE:
declare const orDie: <A, E, R>(self: Stream<A, E, R>) => Stream<A, never, R>

----------------------------------------

TITLE: Finding Minimum Array Element using Effect Array.min
DESCRIPTION: Demonstrates how to find the minimum element in an array using the Effect library's Array.min function with a number comparator. The function requires a non-empty array and an Order instance for comparison.

LANGUAGE: typescript
CODE:
import { Array, Order } from "effect"

const result = Array.min([3, 1, 2], Order.number)
console.log(result) // 1

LANGUAGE: typescript
CODE:
declare const min: { <A>(O: Order.Order<A>): (self: NonEmptyReadonlyArray<A>) => A; <A>(self: NonEmptyReadonlyArray<A>, O: Order.Order<A>): A; }

----------------------------------------

TITLE: Defining finalizersMask Function in TypeScript
DESCRIPTION: Declares the finalizersMask function that applies a custom execution strategy to finalizers. It takes an ExecutionStrategy and returns a function that applies this strategy to an effect, with a restore operation to revert to the default strategy.

LANGUAGE: typescript
CODE:
declare const finalizersMask: (strategy: ExecutionStrategy) => <A, E, R>(self: (restore: <A1, E1, R1>(self: Effect<A1, E1, R1>) => Effect<A1, E1, R1>) => Effect<A, E, R>) => Effect<A, E, R>

----------------------------------------

TITLE: Using Array.dropWhile in TypeScript with Effect Library
DESCRIPTION: Demonstrates how to use the dropWhile function to remove elements from the beginning of an array while they satisfy a given predicate. The function returns a new array containing only the remaining elements after the longest matching sequence.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const result = Array.dropWhile([1, 2, 3, 4, 5], x => x < 4)
console.log(result) // [4, 5]

LANGUAGE: typescript
CODE:
declare const dropWhile: { <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Array<A>; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Array<A>; }

----------------------------------------

TITLE: Defining Micro.zipWith Function Signature in TypeScript
DESCRIPTION: This code snippet defines the signature of the Micro.zipWith function. It shows how the function can combine two Micro effects and apply a transformation function to their results. The function supports both curried and non-curried forms, and includes an optional concurrent execution parameter.

LANGUAGE: typescript
CODE:
declare const zipWith: { <A2, E2, R2, A, B>(that: Micro<A2, E2, R2>, f: (a: A, b: A2) => B, options?: { readonly concurrent?: boolean | undefined; }): <E, R>(self: Micro<A, E, R>) => Micro<B, E2 | E, R2 | R>; <A, E, R, A2, E2, R2, B>(self: Micro<A, E, R>, that: Micro<A2, E2, R2>, f: (a: A, b: A2) => B, options?: { readonly concurrent?: boolean | undefined; }): Micro<B, E2 | E, R2 | R>; }

----------------------------------------

TITLE: Channel.provideSomeLayer Type Definition in TypeScript
DESCRIPTION: Type definition for provideSomeLayer function that splits context into two parts, providing one part using the specified layer and leaving the remainder as Env0. The function supports both curried and uncurried calling styles.

LANGUAGE: typescript
CODE:
declare const provideSomeLayer: { 
  <R2, OutErr2, Env0>(layer: Layer.Layer<R2, OutErr2, Env0>): 
    <OutElem, InElem, OutErr, InErr, OutDone, InDone, R>
    (self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, R>) => 
    Channel<OutElem, InElem, OutErr2 | OutErr, InErr, OutDone, InDone, Env0 | Exclude<R, R2>>; 
  <OutElem, InElem, OutErr, InErr, OutDone, InDone, R, R2, OutErr2, Env0>
  (self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, R>, 
   layer: Layer.Layer<R2, OutErr2, Env0>): 
   Channel<OutElem, InElem, OutErr | OutErr2, InErr, OutDone, InDone, Env0 | Exclude<R, R2>>; 
}

----------------------------------------

TITLE: Using MonoidSum for Number Addition
DESCRIPTION: Demonstrates how to use MonoidSum to combine numbers under addition, where 0 acts as the identity element. The combine operation adds two numbers together, and combining with empty (0) returns the original number.

LANGUAGE: typescript
CODE:
import { MonoidSum } from "@effect/typeclass/data/Number"

console.log(MonoidSum.combine(2, 3))
// 5
console.log(MonoidSum.combine(2, MonoidSum.empty))
// 2

LANGUAGE: typescript
CODE:
declare const MonoidSum: monoid.Monoid<number>

----------------------------------------

TITLE: Converting TSet to HashSet in TypeScript using Effect Library
DESCRIPTION: Function that collects all elements from a TSet into a HashSet. Returns an STM transaction that produces a HashSet containing all elements from the input TSet.

LANGUAGE: typescript
CODE:
declare const toHashSet: <A>(self: TSet<A>) => STM.STM<HashSet.HashSet<A>>

----------------------------------------

TITLE: TypeScript Function Signature for HashSet.remove
DESCRIPTION: Defines the TypeScript function signature for the HashSet.remove function. It shows that the function can be used with both data-last and data-first approaches, accepting a HashSet and a value to remove.

LANGUAGE: typescript
CODE:
declare const remove: { <A>(value: A): (self: HashSet<A>) => HashSet<A>; <A>(self: HashSet<A>, value: A): HashSet<A>; }

----------------------------------------

TITLE: Creating Reloadable Service with manual Function in TypeScript
DESCRIPTION: The manual function creates a new reloadable service from a layer that describes the construction of a static service. It takes a context tag and options containing a layer as parameters.

LANGUAGE: typescript
CODE:
declare const manual: <I, S, In, E>(tag: Context.Tag<I, S>, options: { readonly layer: Layer.Layer<I, E, In>; }) => Layer.Layer<Reloadable<I>, E, In>

----------------------------------------

TITLE: Defining Boolean Primitive in TypeScript for @effect/cli
DESCRIPTION: This code snippet defines a boolean primitive for use in a command-line interface. It accepts an optional default value and returns a Primitive<boolean>. The function supports various string inputs to represent true and false values.

LANGUAGE: typescript
CODE:
declare const boolean: (defaultValue: Option<boolean>) => Primitive<boolean>

----------------------------------------

TITLE: Defining TestAnnotationMap Interface in TypeScript
DESCRIPTION: Interface definition for TestAnnotationMap that maintains a HashMap of test annotations. It includes a type identifier and an internal map property for storing annotations of different types.

LANGUAGE: typescript
CODE:
export interface TestAnnotationMap {
  readonly [TestAnnotationMapTypeId]: TestAnnotationMapTypeId
  /** @internal */
  readonly map: HashMap.HashMap<TestAnnotation.TestAnnotation<any>, any>
}

----------------------------------------

TITLE: Defining runForEach Function in TypeScript for Stream Processing
DESCRIPTION: Declares the runForEach function which consumes all elements of a stream, passing them to a specified callback. The function has two overloads to handle different parameter orders and supports generic types for flexible usage.

LANGUAGE: typescript
CODE:
declare const runForEach: { <A, X, E2, R2>(f: (a: A) => Effect.Effect<X, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect.Effect<void, E2 | E, R2 | R>; <A, E, R, X, E2, R2>(self: Stream<A, E, R>, f: (a: A) => Effect.Effect<X, E2, R2>): Effect.Effect<void, E | E2, R | R2>; }

----------------------------------------

TITLE: TypeScript Signature for Array.replicate
DESCRIPTION: Provides the TypeScript function signature for the Array.replicate function. It shows two overloads: one that takes the count first and returns a function, and another that takes both arguments at once.

LANGUAGE: typescript
CODE:
declare const replicate: { (n: number): <A>(a: A) => NonEmptyArray<A>; <A>(a: A, n: number): NonEmptyArray<A>; }

----------------------------------------

TITLE: Racing Tasks with One Failure
DESCRIPTION: Shows racing three tasks where one fails and two succeed, demonstrating how the first successful task completes while others are interrupted.

LANGUAGE: typescript
CODE:
import { Effect, Console } from "effect"

const task1 = Effect.fail("task1").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Console.log("task1 done")),
  Effect.onInterrupt(() => Console.log("task1 interrupted"))
)
const task2 = Effect.succeed("task2").pipe(
  Effect.delay("200 millis"),
  Effect.tap(Console.log("task2 done")),
  Effect.onInterrupt(() => Console.log("task2 interrupted"))
)

const task3 = Effect.succeed("task3").pipe(
  Effect.delay("150 millis"),
  Effect.tap(Console.log("task3 done")),
  Effect.onInterrupt(() => Console.log("task3 interrupted"))
)

const program = Effect.raceAll([task1, task2, task3])

Effect.runFork(program)

----------------------------------------

TITLE: Creating Mutable Schema AST in TypeScript
DESCRIPTION: Creates a new Abstract Syntax Tree (AST) with shallow mutability applied to its properties. This function is used to enable mutation of AST nodes while preserving the original structure.

LANGUAGE: typescript
CODE:
declare const mutable: (ast: AST) => AST

----------------------------------------

TITLE: Implementing Record Intersection with Semigroup in TypeScript
DESCRIPTION: Demonstrates how to use getSemigroupIntersection to combine two records keeping only shared keys. Values for matching keys are combined using a provided Semigroup instance. The example shows combining records with numeric values using MonoidSum.

LANGUAGE: typescript
CODE:
import * as NumberInstances from "@effect/typeclass/data/Number"
import { getSemigroupIntersection } from "@effect/typeclass/data/Record"

console.log(getSemigroupIntersection(NumberInstances.MonoidSum).combine({ a: 1 }, { a: 1, b: 3 }))
// { a: 2 }

LANGUAGE: typescript
CODE:
declare const getSemigroupIntersection: <A>(value: semigroup.Semigroup<A>) => semigroup.Semigroup<Record.ReadonlyRecord<string, A>>

----------------------------------------

TITLE: Defining hashSet Differ Function for HashSet in TypeScript
DESCRIPTION: Declares a function that constructs a differ capable of diffing a HashSet of values. It returns a Differ object that works with HashSet<Value> and produces a Differ.HashSet.Patch<Value>.

LANGUAGE: typescript
CODE:
declare const hashSet: <Value>() => Differ<HashSet<Value>, Differ.HashSet.Patch<Value>>

----------------------------------------

TITLE: Creating EntryStats in TypeScript for Effect Cache Module
DESCRIPTION: The makeEntryStats function constructs a new EntryStats object from a specified loadedMillis value. It is part of the Cache module in the Effect package.

LANGUAGE: typescript
CODE:
declare const makeEntryStats: (loadedMillis: number) => EntryStats

----------------------------------------

TITLE: Calculating String Length in TypeScript using Effect Library
DESCRIPTION: Demonstrates how to use the String.length function from the Effect library to calculate the number of characters in a string. The function takes a string as input and returns a number representing its length.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { String } from "effect"

assert.deepStrictEqual(String.length('abc'), 3)

LANGUAGE: typescript
CODE:
declare const length: (self: string) => number

----------------------------------------

TITLE: Defining Stream.scopedWith Function in TypeScript
DESCRIPTION: Declares the scopedWith function that takes a function receiving a Scope and returning an Effect, and returns a Stream. The output element of the Stream will be the result of the returned Effect, if successful.

LANGUAGE: typescript
CODE:
declare const scopedWith: <A, E, R>(f: (scope: Scope.Scope) => Effect.Effect<A, E, R>) => Stream<A, E, R>

----------------------------------------

TITLE: Implementing FilterMap Function in TypeScript for Effect List Module
DESCRIPTION: Defines a filterMap function that simultaneously filters and maps list elements using a partial function that returns an Option type. The function can be used either in curried form or with direct application, allowing flexible usage patterns.

LANGUAGE: typescript
CODE:
declare const filterMap: {
  <A, B>(f: (a: A) => Option.Option<B>): (self: List<A>) => List<B>;
  <A, B>(self: List<A>, f: (a: A) => Option.Option<B>): List<B>;
}

----------------------------------------

TITLE: TypeScript Function Signature for sumAll in Effect Library
DESCRIPTION: Provides the TypeScript function signature for the sumAll function in the Effect library's BigInt module. It shows that the function accepts an Iterable of bigints and returns a single bigint.

LANGUAGE: typescript
CODE:
declare const sumAll: (collection: Iterable<bigint>) => bigint

----------------------------------------

TITLE: Configuring HashSet in Effect-TS TypeScript
DESCRIPTION: Function signature for creating a Config instance that handles HashSet data structures. Takes a base configuration for type A and an optional name parameter, returning a Config for HashSet<A>.

LANGUAGE: typescript
CODE:
declare const hashSet: <A>(config: Config<A>, name?: string) => Config<HashSet.HashSet<A>>

----------------------------------------

TITLE: Implementing String Margin Stripping in TypeScript
DESCRIPTION: Function declaration for stripMarginWith that removes leading prefixes from string lines. It accepts a margin character and can be used in both curried and direct forms to process strings by removing leading whitespace and control characters up to the specified margin character.

LANGUAGE: typescript
CODE:
declare const stripMarginWith: { (marginChar: string): (self: string) => string; (self: string, marginChar: string): string; }

----------------------------------------

TITLE: Array.getEquivalence Function Signature in TypeScript
DESCRIPTION: Provides the TypeScript signature for the Array.getEquivalence function. It takes an Equivalence<A> as input and returns an Equivalence for ReadonlyArray<A>.

LANGUAGE: typescript
CODE:
declare const getEquivalence: <A>(isEquivalent: Equivalence.Equivalence<A>) => Equivalence.Equivalence<ReadonlyArray<A>>

----------------------------------------

TITLE: Using Stream.takeRight in Effect
DESCRIPTION: Demonstrates how to use Stream.takeRight to extract the last specified number of elements from a stream. The example shows taking the last 3 elements from a stream of numbers 1-6.

LANGUAGE: typescript
CODE:
import { Effect, Stream } from "effect"

const stream = Stream.takeRight(Stream.make(1, 2, 3, 4, 5, 6), 3)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 4, 5, 6 ] }

----------------------------------------

TITLE: Types.Simplify Implementation
DESCRIPTION: Type utility implementation that takes a type parameter A and simplifies its structure by converting intersection types into a single object type.

LANGUAGE: typescript
CODE:
type Simplify<A> = {
  [K in keyof A]: A[K]
} extends infer B ? B : never

----------------------------------------

TITLE: Linking Spans in Effect Module (TypeScript)
DESCRIPTION: The linkSpans function adds a link between all spans in an effect and a provided span. It can be used in two ways: as a higher-order function or directly on an Effect instance. It optionally accepts attributes for the link.

LANGUAGE: typescript
CODE:
declare const linkSpans: { (span: Tracer.AnySpan, attributes?: Record<string, unknown>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, span: Tracer.AnySpan, attributes?: Record<string, unknown>): Effect<A, E, R>; }

----------------------------------------

TITLE: TypeScript Signature for Array.match Function in Effect Library
DESCRIPTION: Provides the TypeScript type signature for the Array.match function. It shows the function's polymorphic nature, allowing different return types for empty and non-empty cases.

LANGUAGE: typescript
CODE:
declare const match: { <B, A, C = B>(options: { readonly onEmpty: LazyArg<B>; readonly onNonEmpty: (self: NonEmptyReadonlyArray<A>) => C; }): (self: ReadonlyArray<A>) => B | C; <A, B, C = B>(self: ReadonlyArray<A>, options: { readonly onEmpty: LazyArg<B>; readonly onNonEmpty: (self: NonEmptyReadonlyArray<A>) => C; }): B | C; }

----------------------------------------

TITLE: Comparing Two Numbers with Effect's Number.min Function in TypeScript
DESCRIPTION: This snippet demonstrates how to use the `min` function from the Effect package's Number module to find the minimum of two numbers. It imports the function, uses it to compare 2 and 3, and asserts that the result is 2.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { min } from "effect/Number"

assert.deepStrictEqual(min(2, 3), 2)

----------------------------------------

TITLE: Defining orDie Function for Micro Effects in TypeScript
DESCRIPTION: The orDie function takes a Micro effect and converts all expected errors to unexpected errors, changing the error type to never. This is useful for scenarios where you want to treat all errors as fatal.

LANGUAGE: typescript
CODE:
declare const orDie: <A, E, R>(self: Micro<A, E, R>) => Micro<A, never, R>

----------------------------------------

TITLE: Lookup Value with Custom Hash in HashMap - TypeScript
DESCRIPTION: Function signature for retrieving a value from a HashMap using a specified key and custom hash value. The function is overloaded to support both curried and non-curried invocation patterns, returning an Option type containing the found value.

LANGUAGE: typescript
CODE:
declare const getHash: { <K1>(key: K1, hash: number): <K, V>(self: HashMap<K, V>) => Option<V>; <K, V, K1>(self: HashMap<K, V>, key: K1, hash: number): Option<V>; }

----------------------------------------

TITLE: Flipping Success and Failure Channels in TypeScript STM
DESCRIPTION: The flip function reverses the success and failure channels of a transactional effect. This allows for manipulation of the error channel before potentially flipping back. It takes an STM<A, E, R> as input and returns an STM<E, A, R>.

LANGUAGE: typescript
CODE:
declare const flip: <A, E, R>(self: STM<A, E, R>) => STM<E, A, R>

----------------------------------------

TITLE: Implementing Element Presence Check in TSet (TypeScript)
DESCRIPTION: The 'has' function tests whether a TSet contains a specific element. It can be used in two ways: either by passing the value first and then the set, or by passing the set first and then the value. The function returns an STM (Software Transactional Memory) operation that resolves to a boolean.

LANGUAGE: typescript
CODE:
declare const has: { <A>(value: A): (self: TSet<A>) => STM.STM<boolean>; <A>(self: TSet<A>, value: A): STM.STM<boolean>; }

----------------------------------------

TITLE: Defining TestConfig Interface in TypeScript for Effect Package
DESCRIPTION: Defines the TestConfig interface with properties for test configuration. It includes settings for test repetition, retry attempts, sample size for random variables, and maximum shrinkings for failure minimization.

LANGUAGE: typescript
CODE:
export interface TestConfig {
  /**
   * The number of times to repeat tests to ensure they are stable.
   */
  readonly repeats: number
  /**
   * The number of times to retry flaky tests.
   */
  readonly retries: number
  /**
   * The number of sufficient samples to check for a random variable.
   */
  readonly samples: number
  /**
   * The maximum number of shrinkings to minimize large failures
   */
  readonly shrinks: number
}

----------------------------------------

TITLE: Implementing Maximum Semigroup in TypeScript
DESCRIPTION: Creates a Semigroup instance that combines elements by selecting the maximum value according to a provided Order. The function takes an Order instance as input and returns a Semigroup that operates on values of the same type.

LANGUAGE: typescript
CODE:
declare const max: <A>(O: Order<A>) => Semigroup<A>

----------------------------------------

TITLE: Configuring Test HTTP Server Layer in TypeScript
DESCRIPTION: Defines a Layer that initializes a test HTTP server on a random port and configures an HttpClient with the server's URL. The Layer combines multiple dependencies including HttpServer, HttpPlatform, Etag Generator, BunContext, and HttpClient.

LANGUAGE: typescript
CODE:
declare const layerTest: Layer.Layer<Server.HttpServer | Platform.HttpPlatform | Etag.Generator | BunContext.BunContext | HttpClient.HttpClient, HttpServerError.ServeError, never>

----------------------------------------

TITLE: Declaring Effect.annotateCurrentSpan Function Type in TypeScript
DESCRIPTION: Type declaration for the annotateCurrentSpan function that accepts either a key-value pair or a record of key-value pairs to annotate the current span in an Effect trace. The function returns an Effect of void.

LANGUAGE: typescript
CODE:
declare const annotateCurrentSpan: { (key: string, value: unknown): Effect<void>; (values: Record<string, unknown>): Effect<void>; }

----------------------------------------

TITLE: Implementing HashMap.some Predicate Check in TypeScript
DESCRIPTION: Function signature for checking if any entry in a HashMap meets a specified predicate condition. Provides two overloads: one for curried usage and one for direct application. The function takes a predicate that evaluates each key-value pair and returns a boolean.

LANGUAGE: typescript
CODE:
declare const some: { 
  <K, A>(predicate: (a: NoInfer<A>, k: K) => boolean): (self: HashMap<K, A>) => boolean; 
  <K, A>(self: HashMap<K, A>, predicate: (a: A, k: K) => boolean): boolean; 
}

----------------------------------------

TITLE: Creating Bounded PubSub in TypeScript
DESCRIPTION: Creates a bounded PubSub with back pressure strategy. It retains messages until taken by all subscribers and applies back pressure to publishers when at capacity. For optimal performance, use capacities that are powers of two.

LANGUAGE: typescript
CODE:
declare const bounded: <A>(capacity: number | { readonly capacity: number; readonly replay?: number | undefined; }) => Effect.Effect<PubSub<A>>

----------------------------------------

TITLE: Defining Empty String Constant in TypeScript
DESCRIPTION: Declares a constant representing an empty string with strict type definition. This provides a typed empty string value that can be used throughout the Effect package.

LANGUAGE: typescript
CODE:
declare const empty: ""

----------------------------------------

TITLE: Implementing drainFork Function in TypeScript Effect-TS Stream
DESCRIPTION: Defines a drainFork operation that runs a secondary stream in the background while the main stream is active. The operation handles error propagation and automatically interrupts the secondary stream if the main stream completes first.

LANGUAGE: typescript
CODE:
declare const drainFork: { 
  <A2, E2, R2>(that: Stream<A2, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; 
  <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>): Stream<A, E | E2, R | R2>; 
}

----------------------------------------

TITLE: Type Guard Function for Composite ParseIssue - TypeScript
DESCRIPTION: Defines a type guard function that checks if a ParseIssue value is specifically a Composite type. The function returns a boolean and provides proper type narrowing in TypeScript.

LANGUAGE: typescript
CODE:
declare const isComposite: (issue: ParseIssue) => issue is Composite

----------------------------------------

TITLE: Using isBigInt Type Guard in TypeScript
DESCRIPTION: Example demonstrating how to use the isBigInt predicate function to check if a value is a BigInt. The function acts as a type guard that returns true only for bigint values.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { isBigInt } from "effect/Predicate"

assert.deepStrictEqual(isBigInt(1n), true)

assert.deepStrictEqual(isBigInt(1), false)

LANGUAGE: typescript
CODE:
declare const isBigInt: (input: unknown) => input is bigint

----------------------------------------

TITLE: Using isNull Predicate in TypeScript
DESCRIPTION: Demonstrates how to use the isNull function from the Predicate module to test if a value is null. The example shows true for null and false for undefined and string values.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { isNull } from "effect/Predicate"

assert.deepStrictEqual(isNull(null), true)

assert.deepStrictEqual(isNull(undefined), false)
assert.deepStrictEqual(isNull("null"), false)

----------------------------------------

TITLE: Retrieving First Interrupt from Cause in TypeScript
DESCRIPTION: The interruptOption function retrieves the first Interrupt in a Cause, if present. It returns an Option with the first fiber interruption discovered, which is useful for concurrency analysis or debugging cancellations.

LANGUAGE: typescript
CODE:
declare const interruptOption: <E>(self: Cause<E>) => Option.Option<FiberId.FiberId>

----------------------------------------

TITLE: Executing Workflows with Custom Sized Service in Effect
DESCRIPTION: Function that executes a workflow effect with a specified implementation of the sized service. It provides both curried and uncurried versions for flexibility in usage.

LANGUAGE: typescript
CODE:
declare const withSized: ((sized: Sized.TestSized) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>) & (<A, E, R>(effect: Effect.Effect<A, E, R>, sized: Sized.TestSized) => Effect.Effect<A, E, R>)

----------------------------------------

TITLE: Declaring Empty List Function in TypeScript
DESCRIPTION: Defines the empty function that constructs a new empty List<A>. It is an alias of nil and can be used with type inference.

LANGUAGE: typescript
CODE:
declare const empty: <A = never>() => List<A>

----------------------------------------

TITLE: Extracting Key Type from HashMap using Type Utility in TypeScript
DESCRIPTION: Demonstrates how to use the HashMap.HashMap.Key type utility to extract the key type K from a HashMap<K, V> type. This utility is useful for type inference and type safety when working with HashMaps.

LANGUAGE: typescript
CODE:
import { HashMap } from "effect"

declare const hm: HashMap.HashMap<string, number>

// $ExpectType string
type K = HashMap.HashMap.Key<typeof hm>

LANGUAGE: typescript
CODE:
type Key<T> = [T] extends [HashMap<infer _K, infer _V>] ? _K : never

----------------------------------------

TITLE: Defining Channel.mergeOut Function in TypeScript
DESCRIPTION: Declares the mergeOut function with two overloads. It takes a number parameter and returns a new channel that merges a specified number of channels emitted by the original channel. The function uses a back pressuring merge strategy and is compatible with various generic types for elements, errors, and environments.

LANGUAGE: typescript
CODE:
declare const mergeOut: { (n: number): <OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<Channel<OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1>, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1, InElem & InElem1, OutErr1 | OutErr, InErr & InErr1, unknown, InDone & InDone1, Env1 | Env>; <OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<Channel<OutElem1, InElem1, OutErr1, InErr1, Z, InDone1, Env1>, InElem, OutErr, InErr, OutDone, InDone, Env>, n: number): Channel<OutElem1, InElem & InElem1, OutErr1 | OutErr, InErr & InErr1, unknown, InDone & InDone1, Env1 | Env>; }

----------------------------------------

TITLE: Implementing zipLeft Function in Chainable Typeclass - TypeScript
DESCRIPTION: Implementation of the zipLeft function that sequences two effects but only returns the value from the first effect. Takes a Chainable type class instance and returns a function that can combine two effects, preserving only the first effect's value while executing both.

LANGUAGE: typescript
CODE:
declare const zipLeft: <F extends TypeLambda>(F: Chainable<F>) => { 
  <R2, O2, E2, _>(that: Kind<F, R2, O2, E2, _>): 
    <R1, O1, E1, A>(self: Kind<F, R1, O1, E1, A>) => Kind<F, R1 & R2, O2 | O1, E2 | E1, A>; 
  <R1, O1, E1, A, R2, O2, E2, _>(self: Kind<F, R1, O1, E1, A>, that: Kind<F, R2, O2, E2, _>): 
    Kind<F, R1 & R2, O1 | O2, E1 | E2, A>; 
}

----------------------------------------

TITLE: Splitting Cause into Failure or Remaining Cause in TypeScript
DESCRIPTION: The failureOrCause function takes a Cause<E> and returns an Either containing either the first Fail error (E) or the remaining Cause<never> with defects or interruptions. This helps in determining if there's a recoverable path or only unhandled issues remain.

LANGUAGE: typescript
CODE:
declare const failureOrCause: <E>(self: Cause<E>) => Either.Either<Cause<never>, E>

----------------------------------------

TITLE: Defining Handlers Interface in TypeScript
DESCRIPTION: This code snippet defines the Handlers interface, which represents a handled HttpApi. It includes generic type parameters for error handling, context provision, and endpoint definitions. The interface provides methods for adding implementations to the Handlers group.

LANGUAGE: typescript
CODE:
export interface Handlers<
  E,
  Provides,
  R,
  Endpoints extends HttpApiEndpoint.HttpApiEndpoint.Any = never
> extends Pipeable {
  readonly [HandlersTypeId]: {
    _Endpoints: Covariant<Endpoints>
  }
  readonly group: HttpApiGroup.HttpApiGroup.AnyWithProps
  readonly handlers: Chunk.Chunk<Handlers.Item<E, R>>

  /**
   * Add the implementation for an `HttpApiEndpoint` to a `Handlers` group.
   */
  handle<Name extends HttpApiEndpoint.HttpApiEndpoint.Name<Endpoints>, R1>(
    name: Name,
    handler: HttpApiEndpoint.HttpApiEndpoint.HandlerWithName<Endpoints, Name, E, R1>
  ): Handlers<
    E,
    Provides,
    | R
    | Exclude<
      HttpApiEndpoint.HttpApiEndpoint.ExcludeProvided<
        Endpoints,
        Name,
        R1 | HttpApiEndpoint.HttpApiEndpoint.ContextWithName<Endpoints, Name>
      >,
      Provides
    >,
    HttpApiEndpoint.HttpApiEndpoint.ExcludeName<Endpoints, Name>
  >

  /**
   * Add the implementation for an `HttpApiEndpoint` to a `Handlers` group.
   * This version of the api allows you to return the full response object.
   */
  handleRaw<Name extends HttpApiEndpoint.HttpApiEndpoint.Name<Endpoints>, R1>(
    name: Name,
    handler: HttpApiEndpoint.HttpApiEndpoint.HandlerResponseWithName<Endpoints, Name, E, R1>
  ): Handlers<
    E,
    Provides,
    | R
    | Exclude<
      HttpApiEndpoint.HttpApiEndpoint.ExcludeProvided<
        Endpoints,
        Name,
        R1 | HttpApiEndpoint.HttpApiEndpoint.ContextWithName<Endpoints, Name>
      >,
      Provides
    >,
    HttpApiEndpoint.HttpApiEndpoint.ExcludeName<Endpoints, Name>
  >
}

----------------------------------------

TITLE: Effect.sleep Function Signature in TypeScript
DESCRIPTION: Type declaration for the Effect.sleep function showing it accepts a DurationInput parameter and returns an Effect of void.

LANGUAGE: typescript
CODE:
declare const sleep: (duration: Duration.DurationInput) => Effect<void>

----------------------------------------

TITLE: Incrementing BigInt Values in TypeScript
DESCRIPTION: The increment function takes a BigInt value and returns the result of adding 1n to it. This example demonstrates how to use the function and verify its output using node:assert.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { increment } from "effect/BigInt"

assert.deepStrictEqual(increment(2n), 3n)

----------------------------------------

TITLE: Defining Record.intersection Function in TypeScript
DESCRIPTION: Declares a function to merge two records, keeping only entries that exist in both. It provides overloads for different parameter orderings and uses generic types for flexibility.

LANGUAGE: typescript
CODE:
declare const intersection: { <K1 extends string, A, B, C>(that: ReadonlyRecord<K1, B>, combine: (selfValue: A, thatValue: B) => C): <K0 extends string>(self: ReadonlyRecord<K0, A>) => Record<ReadonlyRecord.IntersectKeys<K0, K1>, C>; <K0 extends string, A, K1 extends string, B, C>(self: ReadonlyRecord<K0, A>, that: ReadonlyRecord<K1, B>, combine: (selfValue: A, thatValue: B) => C): Record<ReadonlyRecord.IntersectKeys<K0, K1>, C>; }

----------------------------------------

TITLE: Declaring Channel.mapOutEffect Function in TypeScript
DESCRIPTION: Function signature for mapOutEffect that creates a modified channel where an effectful function is applied to each output element. The function supports both curried and uncurried calling styles and preserves type safety across channel transformations.

LANGUAGE: typescript
CODE:
declare const mapOutEffect: { <OutElem, OutElem1, OutErr1, Env1>(f: (o: OutElem) => Effect.Effect<OutElem1, OutErr1, Env1>): <InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1, InElem, OutErr1 | OutErr, InErr, OutDone, InDone, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, OutErr1, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (o: OutElem) => Effect.Effect<OutElem1, OutErr1, Env1>): Channel<OutElem1, InElem, OutErr | OutErr1, InErr, OutDone, InDone, Env | Env1>; }

----------------------------------------

TITLE: Effect.fail Function Signature in TypeScript
DESCRIPTION: This code block shows the TypeScript signature of the Effect.fail function. It takes an error of type E and returns an Effect with never as the environment and value types, and E as the error type.

LANGUAGE: typescript
CODE:
declare const fail: <E>(error: E) => Effect<never, E>

----------------------------------------

TITLE: Defining Exit.Success Interface in TypeScript
DESCRIPTION: TypeScript interface definition that represents a successful Effect workflow completion. The interface extends Effect.Effect and includes type parameters for the success value (A) and error type (E), along with internal type symbols for unification.

LANGUAGE: typescript
CODE:
export interface Success<out A, out E> extends Effect.Effect<A, E>, Pipeable, Inspectable {
  readonly _tag: "Success"
  readonly _op: "Success"
  readonly value: A
  [Unify.typeSymbol]?: unknown
  [Unify.unifySymbol]?: ExitUnify<this>
  [Unify.ignoreSymbol]?: ExitUnifyIgnore
  /** @internal */
  readonly effect_instruction_i0: A
}

----------------------------------------

TITLE: Defining Unbranded Utility Type in TypeScript
DESCRIPTION: Implements a utility type called Unbranded that extracts the value type from a brand. It uses conditional types to remove the brand information, returning the underlying type.

LANGUAGE: typescript
CODE:
type Unbranded<P> = P extends infer Q & Brands<P> ? Q : P

----------------------------------------

TITLE: Implementing Boolean SemigroupEvery in TypeScript
DESCRIPTION: Demonstrates the usage of SemigroupEvery, a boolean semigroup implementation for conjunction operations. Shows how the combine operation works with different boolean value combinations.

LANGUAGE: typescript
CODE:
import { SemigroupEvery } from "@effect/typeclass/data/Boolean"

console.log(SemigroupEvery.combine(true, true))
// true
console.log(SemigroupEvery.combine(true, false))
// false
console.log(SemigroupEvery.combine(false, true))
// false
console.log(SemigroupEvery.combine(false, false))
// false

LANGUAGE: typescript
CODE:
declare const SemigroupEvery: semigroup.Semigroup<boolean>

----------------------------------------

TITLE: Type Signature of functionWithSpan
DESCRIPTION: The type definition for the functionWithSpan function, showing its parameters and return type. Takes an options object containing the function body, span options configuration, and optional stack trace capturing flag.

LANGUAGE: typescript
CODE:
declare const functionWithSpan: <Args extends Array<any>, Ret extends Effect<any, any, any>>(options: { readonly body: (...args: Args) => Ret; readonly options: FunctionWithSpanOptions | ((...args: Args) => FunctionWithSpanOptions); readonly captureStackTrace?: boolean | undefined; }) => (...args: Args) => Unify.Unify<Ret>

----------------------------------------

TITLE: Accessing Sink Context with contextWith in TypeScript
DESCRIPTION: The contextWith function allows access to the context of a sink. It takes a function that receives the context and returns a value, which is then used to create a new Sink.

LANGUAGE: typescript
CODE:
declare const contextWith: <R, Z>(f: (context: Context.Context<R>) => Z) => Sink<Z, unknown, never, never, R>

----------------------------------------

TITLE: Configuring Command stderr in TypeScript
DESCRIPTION: Function signature for specifying the standard error stream of a command. The function provides two overloads: one that takes stderr as first argument and returns a function, and another that takes both command and stderr directly.

LANGUAGE: typescript
CODE:
declare const stderr: { (stderr: Command.Output): (self: Command) => Command; (self: Command, stderr: Command.Output): Command; }

----------------------------------------

TITLE: Using SK Combinator in TypeScript
DESCRIPTION: This snippet demonstrates how to use the SK combinator function from the effect/Function module. It shows that the function discards the first argument and returns the second argument.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { SK } from "effect/Function";

assert.deepStrictEqual(SK(0, "hello"), "hello")

----------------------------------------

TITLE: Declaring Line Iterator Function in TypeScript
DESCRIPTION: TypeScript declaration for the linesIterator function that creates an IterableIterator to process strings line by line. The function takes a string input and returns a LinesIterator that yields each line from the string with trailing newline characters removed.

LANGUAGE: typescript
CODE:
declare const linesIterator: (self: string) => LinesIterator

----------------------------------------

TITLE: Declaring forEach Function for Chunk Iteration in TypeScript
DESCRIPTION: Declares the forEach function for iterating over elements in a Chunk. It accepts a function to be applied to each element and can be used in two ways: either by passing the Chunk as the first argument, or as a curried function.

LANGUAGE: typescript
CODE:
declare const forEach: { <A, B>(f: (a: A, index: number) => B): (self: Chunk<A>) => void; <A, B>(self: Chunk<A>, f: (a: A, index: number) => B): void; }

----------------------------------------

TITLE: Implementing Array Search with STM in TypeScript
DESCRIPTION: Function definition for findFirstSTM that searches for the first element in a TArray that matches a transactional predicate. Returns an STM computation that resolves to an Option containing the first matching element.

LANGUAGE: typescript
CODE:
declare const findFirstSTM: { 
  <A, R, E>(predicate: (value: A) => STM.STM<boolean, E, R>): (self: TArray<A>) => STM.STM<Option.Option<A>, E, R>; 
  <A, R, E>(self: TArray<A>, predicate: (value: A) => STM.STM<boolean, E, R>): STM.STM<Option.Option<A>, E, R>; 
}

----------------------------------------

TITLE: Defining PushAnnotationStream Interface in TypeScript
DESCRIPTION: Defines a TypeScript interface representing the addition of an annotation to a Doc. The interface extends DocStream.Variance<A> and includes properties for the annotation type and stream reference.

LANGUAGE: typescript
CODE:
export interface PushAnnotationStream<A> extends DocStream.Variance<A> {
  readonly _tag: "PushAnnotationStream"
  readonly annotation: A
  readonly stream: DocStream<A>
}

----------------------------------------

TITLE: Defining Args Interface for CLI Arguments in TypeScript
DESCRIPTION: Defines a generic interface Args<A> that extends Args.Variance<A> and Pipeable, used to represent command-line arguments that can be passed to an application.

LANGUAGE: typescript
CODE:
export interface Args<A> extends Args.Variance<A>, Pipeable {}

----------------------------------------

TITLE: Testing Object Type with isObject Function in TypeScript
DESCRIPTION: Demonstrates how to use the isObject function from the effect/Predicate module to test if a value is an object. It shows examples of both positive and negative cases.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { isObject } from "effect/Predicate"

assert.deepStrictEqual(isObject({}), true)
assert.deepStrictEqual(isObject([]), true)

assert.deepStrictEqual(isObject(null), false)
assert.deepStrictEqual(isObject(undefined), false)

----------------------------------------

TITLE: Validating ExceededCapacityException in TypeScript
DESCRIPTION: Type guard function that checks if an unknown value is an ExceededCapacityException. This function provides type safety by narrowing the type of the input parameter when the check passes.

LANGUAGE: typescript
CODE:
declare const isExceededCapacityException: (u: unknown) => u is ExceededCapacityException

----------------------------------------

TITLE: Exposing Stream Chunks in TypeScript
DESCRIPTION: The chunks function takes a Stream of type A, E, R and returns a Stream of Chunk.Chunk<A>, E, R. It exposes the underlying chunks of the input stream as a stream of chunks of elements.

LANGUAGE: typescript
CODE:
declare const chunks: <A, E, R>(self: Stream<A, E, R>) => Stream<Chunk.Chunk<A>, E, R>

----------------------------------------

TITLE: Filtering Collections with Effectual Predicates in STM (TypeScript)
DESCRIPTION: The filter function allows filtering of collections using effectual predicates in the STM context. It can be used in two ways: as a higher-order function that returns a filtering function, or directly with an iterable and a predicate. The function works with any Iterable<A> and returns an STM<Array<A>, E, R>.

LANGUAGE: typescript
CODE:
declare const filter: { <A, R, E>(predicate: (a: NoInfer<A>) => STM<boolean, E, R>): (iterable: Iterable<A>) => STM<Array<A>, E, R>; <A, R, E>(iterable: Iterable<A>, predicate: (a: A) => STM<boolean, E, R>): STM<Array<A>, E, R>; }

----------------------------------------

TITLE: Defining failCause Function in Effect Module (TypeScript)
DESCRIPTION: Creates an Effect that fails with the specified Cause. This function takes a Cause<E> as input and returns an Effect that never succeeds but may fail with an error of type E.

LANGUAGE: typescript
CODE:
declare const failCause: <E>(cause: Cause.Cause<E>) => Effect<never, E>

----------------------------------------

TITLE: Using BigInt Multiplication with Effect Library
DESCRIPTION: Demonstrates how to use the multiply function from Effect's BigInt module to perform multiplication operations on bigint values. The function supports both curried and uncurried calling styles.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { multiply } from "effect/BigInt"

assert.deepStrictEqual(multiply(2n, 3n), 6n)

LANGUAGE: typescript
CODE:
declare const multiply: { (that: bigint): (self: bigint) => bigint; (self: bigint, that: bigint): bigint; }

----------------------------------------

TITLE: Implementing Command Piping in TypeScript
DESCRIPTION: Defines the pipeTo function signature in TypeScript, allowing for piping one command to another. It supports both curried and non-curried function calls.

LANGUAGE: typescript
CODE:
declare const pipeTo: { (into: Command): (self: Command) => Command; (self: Command, into: Command): Command; }

----------------------------------------

TITLE: Implementing Timeout Function in TypeScript Effect Package
DESCRIPTION: Function signature for timeout implementation that takes a duration in milliseconds and returns an effect that will fail with TimeoutException if the timeout elapses. The function safely interrupts the running effect if timeout occurs.

LANGUAGE: typescript
CODE:
declare const timeout: { 
  (millis: number): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E | TimeoutException, R>; 
  <A, E, R>(self: Micro<A, E, R>, millis: number): Micro<A, E | TimeoutException, R>; 
}

----------------------------------------

TITLE: Trie.isEmpty Function Signature in TypeScript
DESCRIPTION: Provides the TypeScript function signature for the Trie.isEmpty function. It takes a Trie<V> as input and returns a boolean indicating whether the Trie is empty.

LANGUAGE: typescript
CODE:
declare const isEmpty: <V>(self: Trie<V>) => boolean

----------------------------------------

TITLE: Data.Class Type Definition
DESCRIPTION: Type signature for the Data.Class constructor, showing its generic type parameter and argument requirements.

LANGUAGE: typescript
CODE:
declare const Class: new <A extends Record<string, any> = {}>(args: Types.Equals<A, {}> extends true ? void : { readonly [P in keyof A]: A[P]; }) => Readonly<A>

----------------------------------------

TITLE: Using Trie.entries with TypeScript
DESCRIPTION: Demonstrates how to use Trie.entries() to retrieve key-value pairs from a Trie data structure. The example shows creation of a Trie with two entries and accessing them in alphabetical order using Array.from().

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Trie } from "effect"

const trie = Trie.empty<number>().pipe(
  Trie.insert("call", 0),
  Trie.insert("me", 1)
)

const result = Array.from(Trie.entries(trie))
assert.deepStrictEqual(result, [["call", 0], ["me", 1]])

----------------------------------------

TITLE: Defining KeyedPool Interface in TypeScript
DESCRIPTION: Defines a generic interface KeyedPool that manages multiple pools of items. Each pool is associated with a key of type K and contains items of type A. The interface includes methods for retrieving items from specific pools and invalidating items.

LANGUAGE: typescript
CODE:
export interface KeyedPool<in K, in out A, out E = never> extends KeyedPool.Variance<K, A, E>, Pipeable {
  /**
   * Retrieves an item from the pool belonging to the given key in a scoped
   * effect. Note that if acquisition fails, then the returned effect will fail
   * for that same reason. Retrying a failed acquisition attempt will repeat the
   * acquisition attempt.
   */
  get(key: K): Effect.Effect<A, E, Scope.Scope>

  /**
   * Invalidates the specified item. This will cause the pool to eventually
   * reallocate the item, although this reallocation may occur lazily rather
   * than eagerly.
   */
  invalidate(item: A): Effect.Effect<void>
}

----------------------------------------

TITLE: Defining forEachChunk Sink Function in TypeScript
DESCRIPTION: Declares a function that creates a sink which applies an effectful function to each chunk of input. The function takes a callback that processes chunks and returns an Effect, and it produces a Sink that handles input of type In, never fails, may cause effects of type E, and requires an environment of type R.

LANGUAGE: typescript
CODE:
declare const forEachChunk: <In, X, E, R>(f: (input: Chunk.Chunk<In>) => Effect.Effect<X, E, R>) => Sink<void, In, never, E, R>

----------------------------------------

TITLE: Defining Nested Configuration Function in TypeScript
DESCRIPTION: Declares a function 'nested' that allows nesting a configuration as a property of a specified name. It can be used in two ways: either by passing the name first, or by passing the configuration first and the name second.

LANGUAGE: typescript
CODE:
declare const nested: { (name: string): <A>(self: Config<A>) => Config<A>; <A>(self: Config<A>, name: string): Config<A>; }

----------------------------------------

TITLE: Declaring DurationFromMillis Schema Class in TypeScript
DESCRIPTION: Class declaration for a schema that converts non-negative numbers (representing milliseconds) into Duration objects. Can handle both finite and infinite values.

LANGUAGE: typescript
CODE:
declare class DurationFromMillis

----------------------------------------

TITLE: Implementing Effect.awaitAllChildren in TypeScript
DESCRIPTION: A function that takes an Effect and returns a new Effect that waits for all child fibers to complete before succeeding. This ensures proper handling of concurrent operations within the Effect system.

LANGUAGE: typescript
CODE:
declare const awaitAllChildren: <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>

----------------------------------------

TITLE: Partitioning Record Elements with Effect
DESCRIPTION: Demonstrates how to use Record.partitionMap to split record elements into two groups based on a predicate that returns Either. The function takes a record and a mapping function that returns Either<C, B>, producing two new records containing the left and right values respectively.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Record, Either } from "effect"

const x = { a: 1, b: 2, c: 3 }
const f = (n: number) => (n % 2 === 0 ? Either.right(n) : Either.left(n))
assert.deepStrictEqual(Record.partitionMap(x, f), [{ a: 1, c: 3 }, { b: 2}])

LANGUAGE: typescript
CODE:
declare const partitionMap: { <K extends string, A, B, C>(f: (a: A, key: K) => Either<C, B>): (self: ReadonlyRecord<K, A>) => [left: Record<ReadonlyRecord.NonLiteralKey<K>, B>, right: Record<ReadonlyRecord.NonLiteralKey<K>, C>]; <K extends string, A, B, C>(self: ReadonlyRecord<K, A>, f: (a: A, key: K) => Either<C, B>): [left: Record<ReadonlyRecord.NonLiteralKey<K>, B>, right: Record<ReadonlyRecord.NonLiteralKey<K>, C>]; }

----------------------------------------

TITLE: Completing Requests with Results in Effect Framework
DESCRIPTION: Defines a complete function that takes a Request and its result to produce an Effect. The function is overloaded to support both curried and uncurried forms of invocation.

LANGUAGE: typescript
CODE:
declare const complete: {
  <A extends Request<any, any>>(result: Request.Result<A>): (self: A) => Effect.Effect<void>;
  <A extends Request<any, any>>(self: A, result: Request.Result<A>): Effect.Effect<void>;
}

----------------------------------------

TITLE: Creating Entity from RpcGroup in TypeScript
DESCRIPTION: The fromRpcGroup function creates a new Entity of a specified type that accepts messages adhering to a provided RpcGroup. It takes a string type and an RpcGroup protocol as parameters and returns an Entity that can handle the specified RPCs.

LANGUAGE: typescript
CODE:
declare const fromRpcGroup: <Rpcs extends Rpc.Any>(type: string, protocol: RpcGroup.RpcGroup<Rpcs>) => Entity<Rpcs>

----------------------------------------

TITLE: Implementing Pipeable String.matchAll Function in TypeScript
DESCRIPTION: Defines a pipeable version of the native matchAll string method. Takes a RegExp pattern and returns a function that accepts a string, producing an IterableIterator of RegExpMatchArray results.

LANGUAGE: typescript
CODE:
declare const matchAll: (regexp: RegExp) => (self: string) => IterableIterator<RegExpMatchArray>

----------------------------------------

TITLE: Declaring provideContext Function in TypeScript for Channel Module
DESCRIPTION: Defines the provideContext function which provides a channel with its required context. It has two overloads: one takes the environment first, and the other takes the channel first. Both versions return a Channel that no longer depends on Env.

LANGUAGE: typescript
CODE:
declare const provideContext: { <Env>(env: Context.Context<Env>): <OutElem, InElem, OutErr, InErr, OutDone, InDone>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, never>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, env: Context.Context<Env>): Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, never>; }

----------------------------------------

TITLE: Checking Interruption Status in Effect Cause Module
DESCRIPTION: Function that determines if a Cause contains only interruptions without other failure types like Fail or Die. Used to verify pure cancellation scenarios in effect handling.

LANGUAGE: typescript
CODE:
declare const isInterruptedOnly: <E>(self: Cause<E>) => boolean

----------------------------------------

TITLE: Implementing Parallel Finalizers in Effect
DESCRIPTION: Demonstrates how to use parallelFinalizers to run multiple cleanup tasks concurrently. The example shows three finalizers with different delays being executed in parallel, resulting in non-sequential completion order.

LANGUAGE: typescript
CODE:
import { Console, Effect } from "effect"

// Define a program that adds multiple finalizers
const program = Effect.gen(function*() {
  yield* Effect.addFinalizer(() => Console.log("Finalizer 1 executed").pipe(Effect.delay("300 millis")))
  yield* Effect.addFinalizer(() => Console.log("Finalizer 2 executed").pipe(Effect.delay("100 millis")))
  yield* Effect.addFinalizer(() => Console.log("Finalizer 3 executed").pipe(Effect.delay("200 millis")))
  return "some result"
})

// Modify the program to ensure finalizers run in parallel
const modified = program.pipe(Effect.parallelFinalizers)

const runnable = Effect.scoped(modified)

Effect.runFork(runnable)

----------------------------------------

TITLE: Removing Elements from Priority Queue in TypeScript using Effect Library
DESCRIPTION: The removeIf function removes all elements from a priority queue that match a specified predicate. It can be used in two ways: either by passing the queue and predicate separately, or by partially applying the predicate first.

LANGUAGE: typescript
CODE:
declare const removeIf: { <A>(predicate: Predicate<A>): (self: TPriorityQueue<A>) => STM.STM<void>; <A>(self: TPriorityQueue<A>, predicate: Predicate<A>): STM.STM<void>; }

----------------------------------------

TITLE: Defining Sink.forEachChunkWhile Function in TypeScript
DESCRIPTION: Declares a function that creates a sink to process chunks of input. The sink applies an effectful function to each chunk until it returns false. It takes a function parameter that processes chunks and returns an Effect with a boolean result.

LANGUAGE: typescript
CODE:
declare const forEachChunkWhile: <In, E, R>(f: (input: Chunk.Chunk<In>) => Effect.Effect<boolean, E, R>) => Sink<void, In, In, E, R>

----------------------------------------

TITLE: Creating Duration Config in Effect-TS
DESCRIPTION: Function that constructs a configuration for Duration values. Takes an optional name parameter and returns a Config instance that handles Duration types.

LANGUAGE: typescript
CODE:
declare const duration: (name?: string) => Config<Duration.Duration>

----------------------------------------

TITLE: Creating Bounded PubSub with Sliding Strategy in TypeScript
DESCRIPTION: The sliding function creates a bounded PubSub that adds new messages and drops old messages when at capacity. It's recommended to use capacities that are powers of two for optimal performance. The function can take either a number or an object with capacity and optional replay properties.

LANGUAGE: typescript
CODE:
declare const sliding: <A>(capacity: number | { readonly capacity: number; readonly replay?: number | undefined; }) => Effect.Effect<PubSub<A>>

----------------------------------------

TITLE: Checking Key Existence in FiberMap - TypeScript
DESCRIPTION: Function signature for checking if a key exists in a FiberMap. Supports both curried and uncurried calling styles, returning an Effect containing a boolean result.

LANGUAGE: typescript
CODE:
declare const has: { 
  <K>(key: K): <A, E>(self: FiberMap<K, A, E>) => Effect.Effect<boolean>; 
  <K, A, E>(self: FiberMap<K, A, E>, key: K): Effect.Effect<boolean>; 
}

----------------------------------------

TITLE: Constructing a New Request using Request.of in TypeScript
DESCRIPTION: The Request.of function is used to construct a new Request object. It returns a constructor for a Request of type R, where R extends Request<any, any>.

LANGUAGE: typescript
CODE:
declare const of: <R extends Request<any, any>>() => Request.Constructor<R>

----------------------------------------

TITLE: TypeScript Type Definition for isPromise
DESCRIPTION: Type signature for the isPromise function, showing it takes an unknown input and returns a type predicate indicating if the input is a Promise of unknown type

LANGUAGE: typescript
CODE:
declare const isPromise: (input: unknown) => input is Promise<unknown>

----------------------------------------

TITLE: Writing Single Value to Channel in TypeScript
DESCRIPTION: Function signature for writing a single value to a channel. The function takes a generic output element and returns a Channel of that element type.

LANGUAGE: typescript
CODE:
declare const write: <OutElem>(out: OutElem) => Channel<OutElem>

----------------------------------------

TITLE: Implementing findOne Query with SqlSchema in TypeScript
DESCRIPTION: Function to execute a SQL query and return the first result matching the provided request and result schemas. Takes request schema, result schema, and execute function as options and returns an Effect containing an optional result.

LANGUAGE: typescript
CODE:
declare const findOne: <IR, II, IA, AR, AI, A, R, E>(
  options: {
    readonly Request: Schema.Schema<IA, II, IR>;
    readonly Result: Schema.Schema<A, AI, AR>;
    readonly execute: (request: II) => Effect.Effect<ReadonlyArray<unknown>, E, R>;
  }) => (request: IA) => Effect.Effect<Option.Option<A>, E | ParseError, R | IR | AR>

----------------------------------------

TITLE: Defining ReadonlyMailbox Interface in TypeScript
DESCRIPTION: This code snippet defines the ReadonlyMailbox interface, which extends Effect and Inspectable. It includes methods for reading messages, clearing the mailbox, and checking its status.

LANGUAGE: typescript
CODE:
export interface ReadonlyMailbox<out A, out E = never>
  extends Effect<readonly [messages: Chunk<A>, done: boolean], E>, Inspectable
{
  readonly [ReadonlyTypeId]: ReadonlyTypeId
  /**
   * Take all messages from the mailbox, returning an empty Chunk if the mailbox
   * is empty or done.
   */
  readonly clear: Effect<Chunk<A>, E>
  /**
   * Take all messages from the mailbox, or wait for messages to be available.
   *
   * If the mailbox is done, the `done` flag will be `true`. If the mailbox
   * fails, the Effect will fail with the error.
   */
  readonly takeAll: Effect<readonly [messages: Chunk<A>, done: boolean], E>
  /**
   * Take a specified number of messages from the mailbox. It will only take
   * up to the capacity of the mailbox.
   *
   * If the mailbox is done, the `done` flag will be `true`. If the mailbox
   * fails, the Effect will fail with the error.
   */
  readonly takeN: (n: number) => Effect<readonly [messages: Chunk<A>, done: boolean], E>
  /**
   * Take a single message from the mailbox, or wait for a message to be
   * available.
   *
   * If the mailbox is done, it will fail with `NoSuchElementException`. If the
   * mailbox fails, the Effect will fail with the error.
   */
  readonly take: Effect<A, E | NoSuchElementException>
  /** Wait for the mailbox to be done. */
  readonly await: Effect<void, E>
  /**
   * Check the size of the mailbox.
   *
   * If the mailbox is complete, it will return `None`.
   */
  readonly size: Effect<Option<number>>
  /**
   * Check the size of the mailbox.
   *
   * If the mailbox is complete, it will return `None`.
   */
  readonly unsafeSize: () => Option<number>
}

----------------------------------------

TITLE: Using Match.discriminators for Pattern Matching in TypeScript
DESCRIPTION: Demonstrates how to use the Match.discriminators function to perform pattern matching on a discriminated union based on a 'type' field. The example shows matching against three different types (A, B, and C) with different payload structures.

LANGUAGE: typescript
CODE:
import { Match, pipe } from "effect"

const match = pipe(
  Match.type<{ type: "A"; a: string } | { type: "B"; b: number } | { type: "C"; c: boolean }>(),
  Match.discriminators("type")({
    A: (a) => a.a,
    B: (b) => b.b,
    C: (c) => c.c
  }),
  Match.exhaustive
)

----------------------------------------

TITLE: Checking Pool Instance in TypeScript
DESCRIPTION: The isPool function is a type guard that determines if a given value is an instance of Pool. It takes an unknown value as input and returns a boolean indicating whether the value is a Pool of unknown types.

LANGUAGE: typescript
CODE:
declare const isPool: (u: unknown) => u is Pool<unknown, unknown>

----------------------------------------

TITLE: Implementing Stream Repetition with Schedule in TypeScript
DESCRIPTION: Function signature for repeatEither that takes a schedule and a stream as input. The function repeats the stream execution according to the schedule, wrapping original stream values and schedule outputs in Either type. The repeated stream preserves error types and combines resource requirements.

LANGUAGE: typescript
CODE:
declare const repeatEither: {
  <B, R2>(schedule: Schedule.Schedule<B, unknown, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<Either.Either<A, B>, E, R2 | R>;
  <A, E, R, B, R2>(self: Stream<A, E, R>, schedule: Schedule.Schedule<B, unknown, R2>): Stream<Either.Either<A, B>, E, R | R2>;
}

----------------------------------------

TITLE: Stream.mapAccum Type Definition in TypeScript
DESCRIPTION: Type signature for the mapAccum function showing its polymorphic nature and support for different stream types and accumulator states.

LANGUAGE: typescript
CODE:
declare const mapAccum: { <S, A, A2>(s: S, f: (s: S, a: A) => readonly [S, A2]): <E, R>(self: Stream<A, E, R>) => Stream<A2, E, R>; <A, E, R, S, A2>(self: Stream<A, E, R>, s: S, f: (s: S, a: A) => readonly [S, A2]): Stream<A2, E, R>; }

----------------------------------------

TITLE: Getting Last Element from Chunk Type Definition
DESCRIPTION: Type definition for the last function that safely retrieves the last element from a Chunk data structure. Returns an Option type to handle cases where the chunk might be empty.

LANGUAGE: typescript
CODE:
declare const last: <A>(self: Chunk<A>) => Option<A>

----------------------------------------

TITLE: Defining pipeThroughChannel Function for Stream in TypeScript
DESCRIPTION: Declares the pipeThroughChannel function, which pipes all values from a stream through a provided channel. It supports both curried and uncurried versions, allowing flexibility in usage.

LANGUAGE: typescript
CODE:
declare const pipeThroughChannel: {
  <R2, E, E2, A, A2>(channel: Channel.Channel<Chunk.Chunk<A2>, Chunk.Chunk<A>, E2, E, unknown, unknown, R2>): <R>(self: Stream<A, E, R>) => Stream<A2, E2, R2 | R>;
  <R, R2, E, E2, A, A2>(self: Stream<A, E, R>, channel: Channel.Channel<Chunk.Chunk<A2>, Chunk.Chunk<A>, E2, E, unknown, unknown, R2>): Stream<A2, E2, R | R2>;
}

----------------------------------------

TITLE: Lifting Either to STM in TypeScript
DESCRIPTION: The fromEither function lifts an Either into an STM. It takes an Either<A, E> as input and returns an STM<A, E>. This function has been available since version 2.0.0 of the package.

LANGUAGE: typescript
CODE:
declare const fromEither: <A, E>(either: Either.Either<A, E>) => STM<A, E>

----------------------------------------

TITLE: Array.every Type Definition in TypeScript
DESCRIPTION: Type definition for the every function that checks if a predicate holds true for every element in a ReadonlyArray. Supports both type refinements and boolean predicates, with index-aware callbacks.

LANGUAGE: typescript
CODE:
declare const every: { 
  <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: ReadonlyArray<A>) => self is ReadonlyArray<B>; 
  <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: ReadonlyArray<A>) => boolean; 
  <A, B extends A>(self: ReadonlyArray<A>, refinement: (a: A, i: number) => a is B): self is ReadonlyArray<B>; 
  <A>(self: ReadonlyArray<A>, predicate: (a: A, i: number) => boolean): boolean; 
}

----------------------------------------

TITLE: Declaring FiberMap.run Function in TypeScript
DESCRIPTION: Defines the run function for FiberMap, which executes an Effect and adds the resulting fiber to the FiberMap. The function handles fiber lifecycle, including removal upon completion. It supports optional parameters for conditional execution and interruption propagation.

LANGUAGE: TypeScript
CODE:
declare const run: { <K, A, E>(self: FiberMap<K, A, E>, key: K, options?: { readonly onlyIfMissing?: boolean | undefined; readonly propagateInterruption?: boolean | undefined; } | undefined): <R, XE extends E, XA extends A>(effect: Effect.Effect<XA, XE, R>) => Effect.Effect<Fiber.RuntimeFiber<XA, XE>, never, R>; <K, A, E, R, XE extends E, XA extends A>(self: FiberMap<K, A, E>, key: K, effect: Effect.Effect<XA, XE, R>, options?: { readonly onlyIfMissing?: boolean | undefined; readonly propagateInterruption?: boolean | undefined; } | undefined): Effect.Effect<Fiber.RuntimeFiber<XA, XE>, never, R>; }

----------------------------------------

TITLE: Implementing Synchronous Effect Execution with Exit in TypeScript
DESCRIPTION: Defines a function that synchronously executes an effect and returns its exit state. The function supports both direct execution and curried form, accepting a runtime environment and an effect as parameters.

LANGUAGE: typescript
CODE:
declare const runSyncExit: { <A, E, R>(runtime: Runtime<R>, effect: Effect.Effect<A, E, R>): Exit.Exit<A, E>; <R>(runtime: Runtime<R>): <A, E>(effect: Effect.Effect<A, E, R>) => Exit.Exit<A, E>; }

----------------------------------------

TITLE: Defining 'never' Stream Constant in TypeScript
DESCRIPTION: Declares a constant 'never' of type Stream that never produces any value or fails with any error. It uses never types for all type parameters.

LANGUAGE: typescript
CODE:
declare const never: Stream<never, never, never>

----------------------------------------

TITLE: Checking Number Range with Number.between in TypeScript
DESCRIPTION: Demonstrates how to use the Number.between function to check if a number falls within a specified range. The function returns true if the number is between the minimum and maximum values (inclusive), and false otherwise.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Number } from "effect"

const between = Number.between({ minimum: 0, maximum: 5 })

assert.deepStrictEqual(between(3), true)
assert.deepStrictEqual(between(-1), false)
assert.deepStrictEqual(between(6), false)

LANGUAGE: typescript
CODE:
declare const between: { (options: { minimum: number; maximum: number; }): (self: number) => boolean; (self: number, options: { minimum: number; maximum: number; }): boolean; }

----------------------------------------

TITLE: Implementing RetainIf Function in TypeScript Priority Queue
DESCRIPTION: Defines a function that filters elements in a priority queue, keeping only those that match the given predicate. The operation is performed within an STM (Software Transactional Memory) context for thread safety.

LANGUAGE: typescript
CODE:
declare const retainIf: { <A>(predicate: Predicate<A>): (self: TPriorityQueue<A>) => STM.STM<void>; <A>(self: TPriorityQueue<A>, predicate: Predicate<A>): STM.STM<void>; }

----------------------------------------

TITLE: Defining QuitException Class in TypeScript
DESCRIPTION: Defines a QuitException class that represents when a user quits a Terminal prompt, typically via ctrl+c. This class is part of the @effect/platform package's Terminal module.

LANGUAGE: typescript
CODE:
declare class QuitException

----------------------------------------

TITLE: isTruthy Function Signature in TypeScript
DESCRIPTION: Provides the TypeScript signature for the isTruthy function. It takes an unknown input and returns a boolean indicating whether the input is truthy.

LANGUAGE: typescript
CODE:
declare const isTruthy: (input: unknown) => boolean

----------------------------------------

TITLE: Implementing unsafeLast Function in TypeScript for Effect Chunk Module
DESCRIPTION: Function that returns the last element of a Chunk data structure. This is an unsafe operation that will throw an error if the chunk is empty. Used in the Effect package since version 2.0.0.

LANGUAGE: typescript
CODE:
declare const unsafeLast: <A>(self: Chunk<A>) => A

----------------------------------------

TITLE: Creating Monoid for ReadonlyArray in TypeScript
DESCRIPTION: The array function creates and returns a Monoid for ReadonlyArray<A>. It takes no parameters and returns a Monoid instance. The empty value for this Monoid is an empty array.

LANGUAGE: typescript
CODE:
declare const array: <A>() => Monoid<ReadonlyArray<A>>

----------------------------------------

TITLE: Checking for Union Type in Doc Module (TypeScript)
DESCRIPTION: The isUnion function determines if a given Doc<A> is of type Union<A>. It returns true if the Doc is a Union, and false otherwise. This function is useful for type checking and conditional logic based on Doc types.

LANGUAGE: typescript
CODE:
declare const isUnion: <A>(self: Doc<A>) => self is Union<A>

----------------------------------------

TITLE: Modifying MutableHashMap Values in TypeScript
DESCRIPTION: Function signature for modifying values in a MutableHashMap. Supports both curried and uncurried versions for updating a value at a specified key using a transformation function.

LANGUAGE: typescript
CODE:
declare const modify: { 
  <K, V>(key: K, f: (v: V) => V): (self: MutableHashMap<K, V>) => MutableHashMap<K, V>; 
  <K, V>(self: MutableHashMap<K, V>, key: K, f: (v: V) => V): MutableHashMap<K, V>; 
}

----------------------------------------

TITLE: Demonstrating BigInt Division in TypeScript using Effect Library
DESCRIPTION: This code snippet demonstrates the usage of the unsafeDivide function from the Effect library's BigInt module. It shows how to perform division on bigint values, including cases where the result is not an exact division.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { unsafeDivide } from "effect/BigInt"

assert.deepStrictEqual(unsafeDivide(6n, 3n), 2n)
assert.deepStrictEqual(unsafeDivide(6n, 4n), 1n)

----------------------------------------

TITLE: Implementing Array.some Type Definition in TypeScript
DESCRIPTION: Type definition for the Array.some function that checks if a predicate holds true for some elements in a ReadonlyArray. The function supports both curried and non-curried versions and includes type narrowing to NonEmptyReadonlyArray.

LANGUAGE: typescript
CODE:
declare const some: { <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: ReadonlyArray<A>) => self is NonEmptyReadonlyArray<A>; <A>(self: ReadonlyArray<A>, predicate: (a: A, i: number) => boolean): self is NonEmptyReadonlyArray<A>; }

----------------------------------------

TITLE: Defining RunnerHealth Class in TypeScript
DESCRIPTION: Declares the RunnerHealth class, which represents a service for checking Runner health in a cluster. It's used to determine if shards should be reassigned based on Runner responsiveness.

LANGUAGE: typescript
CODE:
declare class RunnerHealth

----------------------------------------

TITLE: Implementing Running Total with Stream.mapAccum in TypeScript
DESCRIPTION: Demonstrates using Stream.mapAccum to calculate running totals of numbers in a stream. The example shows how to maintain a running sum while transforming each element.

LANGUAGE: typescript
CODE:
import { Effect, Stream } from "effect"

const runningTotal = (stream: Stream.Stream<number>): Stream.Stream<number> =>
  stream.pipe(Stream.mapAccum(0, (s, a) => [s + a, s + a]))

// input:  0, 1, 2, 3, 4, 5, 6
Effect.runPromise(Stream.runCollect(runningTotal(Stream.range(0, 6)))).then(
  console.log
)
// { _id: "Chunk", values: [ 0, 1, 3, 6, 10, 15, 21 ] }

----------------------------------------

TITLE: Defining WithResult Interface in TypeScript
DESCRIPTION: Interface definition for WithResult trait that encapsulates operation outcomes with separate schemas for success and failure cases. It uses a symbol key to store schema definitions for both success and failure scenarios, with generic type parameters for flexible typing.

LANGUAGE: typescript
CODE:
export interface WithResult<Success, SuccessEncoded, Failure, FailureEncoded, ResultR> {
  readonly [symbolWithResult]: {
    readonly success: Schema<Success, SuccessEncoded, ResultR>
    readonly failure: Schema<Failure, FailureEncoded, ResultR>
  }
}

----------------------------------------

TITLE: TypeScript Function Signature for matchCause
DESCRIPTION: Shows the TypeScript type signature for the matchCause function, defining its parameters and return types for both curried and uncurried versions.

LANGUAGE: typescript
CODE:
declare const matchCause: { <E, A2, A, A3>(options: { readonly onFailure: (cause: Cause.Cause<E>) => A2; readonly onSuccess: (a: A) => A3; }): <R>(self: Effect<A, E, R>) => Effect<A2 | A3, never, R>; <A, E, R, A2, A3>(self: Effect<A, E, R>, options: { readonly onFailure: (cause: Cause.Cause<E>) => A2; readonly onSuccess: (a: A) => A3; }): Effect<A2 | A3, never, R>; }

----------------------------------------

TITLE: Creating SortedMap from Iterable in TypeScript
DESCRIPTION: Defines the fromIterable function that creates a new SortedMap from an iterable collection of key/value pairs. It takes an Order for comparison and an iterable of key/value pairs. The function is overloaded to allow for flexible parameter ordering.

LANGUAGE: typescript
CODE:
declare const fromIterable: { <B>(ord: Order<B>): <K extends B, V>(iterable: Iterable<readonly [K, V]>) => SortedMap<K, V>; <K extends B, V, B>(iterable: Iterable<readonly [K, V]>, ord: Order<B>): SortedMap<K, V>; }

----------------------------------------

TITLE: Implementing Random Shuffle Function in TypeScript with Effect
DESCRIPTION: Defines a shuffle function that takes an iterable of elements and returns an Effect containing a shuffled Chunk of those elements. The function uses a pseudo-random number generator to perform the shuffling operation.

LANGUAGE: typescript
CODE:
declare const shuffle: <A>(elements: Iterable<A>) => Effect.Effect<Chunk.Chunk<A>>

----------------------------------------

TITLE: Implementing filterMapComposition for TypeLambda in TypeScript
DESCRIPTION: Implements a default binary filterMap composition function that works with two type constructors F and G, where F is Covariant and G is Filterable. The function allows mapping and filtering values within nested type structures.

LANGUAGE: typescript
CODE:
declare const filterMapComposition: <F extends TypeLambda, G extends TypeLambda>(F: Covariant<F>, G: Filterable<G>) => <FR, FO, FE, GR, GO, GE, A, B>(self: Kind<F, FR, FO, FE, Kind<G, GR, GO, GE, A>>, f: (a: A) => Option.Option<B>) => Kind<F, FR, FO, FE, Kind<G, GR, GO, GE, B>>

----------------------------------------

TITLE: Declaring tapInput Function in TypeScript for Effect Package's Schedule Module
DESCRIPTION: This code snippet declares the tapInput function, which creates a new schedule that runs an effectful function for each input before continuing execution. It supports both curried and uncurried versions of the function.

LANGUAGE: typescript
CODE:
declare const tapInput: { <In2, X, R2>(f: (input: In2) => Effect.Effect<X, never, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In & In2, R2 | R>; <Out, In, R, In2, X, R2>(self: Schedule<Out, In, R>, f: (input: In2) => Effect.Effect<X, never, R2>): Schedule<Out, In & In2, R | R2>; }

----------------------------------------

TITLE: Retrieving Services from Context in TypeScript using Effect
DESCRIPTION: This snippet demonstrates how to use Context.get to retrieve services from a context. It creates a context with Port and Timeout services and then retrieves the Timeout service.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { pipe, Context } from "effect"

const Port = Context.GenericTag<{ PORT: number }>("Port")
const Timeout = Context.GenericTag<{ TIMEOUT: number }>("Timeout")

const Services = pipe(
  Context.make(Port, { PORT: 8080 }),
  Context.add(Timeout, { TIMEOUT: 5000 })
)

assert.deepStrictEqual(Context.get(Services, Timeout), { TIMEOUT: 5000 })

----------------------------------------

TITLE: Stream.fromSchedule Type Definition
DESCRIPTION: Type signature for the fromSchedule function that creates a Stream from a Schedule. The function takes a Schedule that produces values of type A and requires environment R, returning a Stream that never fails.

LANGUAGE: typescript
CODE:
declare const fromSchedule: <A, R>(schedule: Schedule.Schedule<A, unknown, R>) => Stream<A, never, R>

----------------------------------------

TITLE: Defining DocStream.CharStream Interface in TypeScript
DESCRIPTION: TypeScript interface definition for DocStream.CharStream that extends DocStream.Variance<A>. It represents a document stream containing a single character with an associated stream continuation.

LANGUAGE: typescript
CODE:
export interface CharStream<A> extends DocStream.Variance<A> {
  readonly _tag: "CharStream"
  readonly char: string
  readonly stream: DocStream<A>
}

----------------------------------------

TITLE: Retrieving Values from TMap using STM in TypeScript
DESCRIPTION: Function signature for retrieving a value associated with a key from a TMap using Software Transactional Memory. Supports both curried and uncurried versions of the function call. Returns the value wrapped in an Option type within an STM context.

LANGUAGE: typescript
CODE:
declare const get: { 
  <K>(key: K): <V>(self: TMap<K, V>) => STM.STM<Option.Option<V>>; 
  <K, V>(self: TMap<K, V>, key: K): STM.STM<Option.Option<V>>; 
}

----------------------------------------

TITLE: Defining Scope Interface in TypeScript for Effect Package
DESCRIPTION: Defines the Scope interface which extends Pipeable. It includes properties for scope type identification and execution strategy, and methods for forking child scopes and adding finalizers. The interface is designed for managing resource lifecycles and cleanup operations.

LANGUAGE: typescript
CODE:
export interface Scope extends Pipeable {
  readonly [ScopeTypeId]: ScopeTypeId
  /**
   * The execution strategy for running finalizers in this scope.
   */
  readonly strategy: ExecutionStrategy.ExecutionStrategy
  /**
   * Forks a new child scope with the specified execution strategy. The child scope
   * will automatically be closed when this scope is closed.
   *
   * @internal
   */
  fork(strategy: ExecutionStrategy.ExecutionStrategy): Effect.Effect<Scope.Closeable>
  /**
   * Adds a finalizer to this scope. The finalizer will be run when the scope is closed.
   *
   * @internal
   */
  addFinalizer(finalizer: Scope.Finalizer): Effect.Effect<void>
}

----------------------------------------

TITLE: Defining Path Argument Function in TypeScript
DESCRIPTION: Creates a path argument with an optional configuration. The function returns an Args<string> type. If no custom argument name is provided, it defaults to "path".

LANGUAGE: typescript
CODE:
declare const path: (config?: Args.PathArgsConfig) => Args<string>

----------------------------------------

TITLE: Usage Examples of Predicate.struct in TypeScript
DESCRIPTION: These examples demonstrate how to use the struct function to create refinements and predicates for structured data. It shows different combinations of refinements and predicates as input.

LANGUAGE: typescript
CODE:
{ ab: Refinement<A, B>; cd: Refinement<C, D>, ... } -> Refinement<{ ab: A; cd: C; ... }, { ab: B; cd: D; ... }>
{ a: Predicate<A, B>; b: Predicate<B>, ... } -> Predicate<{ a: A; b: B; ... }>
{ ab: Refinement<A, B>; c: Predicate<C>, ... } -> Refinement<{ ab: A; c: C; ... }, { ab: B; c: С; ... }>

----------------------------------------

TITLE: Declaring RuntimeFlag Interruption Constant - TypeScript
DESCRIPTION: Defines a constant representing the interruption flag that determines whether the Effect runtime system will interrupt a fiber. This flag is a key control mechanism for fiber execution behavior.

LANGUAGE: typescript
CODE:
declare const Interruption: RuntimeFlag

----------------------------------------

TITLE: Constructing Channel from Option in TypeScript
DESCRIPTION: The fromOption function creates a Channel from an Option. It takes an Option<A> as input and returns a Channel that never fails, has unknown input and output types, and produces an A value.

LANGUAGE: typescript
CODE:
declare const fromOption: <A>(option: Option.Option<A>) => Channel<never, unknown, Option.Option<never>, unknown, A, unknown>

----------------------------------------

TITLE: Calculating Number Remainder in TypeScript
DESCRIPTION: Demonstrates how to use the remainder function to calculate the remainder when dividing two numbers. The function maintains the sign of the dividend in the result.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { remainder } from "effect/Number"

assert.deepStrictEqual(remainder(2, 2), 0)
assert.deepStrictEqual(remainder(3, 2), 1)
assert.deepStrictEqual(remainder(-4, 2), -0)

LANGUAGE: typescript
CODE:
declare const remainder: { (divisor: number): (self: number) => number; (self: number, divisor: number): number; }

----------------------------------------

TITLE: Creating Promise-based Effect Runtime with FiberMap
DESCRIPTION: Creates an Effect run function that uses FiberMap as its backing implementation. The function returns a Promise and allows running effects with a given key, with optional configuration for run fork options and conditional execution.

LANGUAGE: typescript
CODE:
declare const makeRuntimePromise: <R, K, A = unknown, E = unknown>() => Effect.Effect<(<XE extends E, XA extends A>(key: K, effect: Effect.Effect<XA, XE, R>, options?: (Runtime.RunForkOptions & { readonly onlyIfMissing?: boolean | undefined; }) | undefined) => Promise<XA>), never, Scope.Scope | R>

----------------------------------------

TITLE: Checking Config Type in TypeScript
DESCRIPTION: The isConfig function checks if a given value is of type Config. It returns true if the value is a Config, false otherwise. This function is useful for type-checking before operating on Config values.

LANGUAGE: typescript
CODE:
declare const isConfig: (u: unknown) => u is Config<unknown>

----------------------------------------

TITLE: TypeScript Signature for NAND Function in effect/Boolean
DESCRIPTION: This code block shows the TypeScript signature of the nand function. It demonstrates that the function can be called with either one or two boolean arguments, providing flexibility in usage.

LANGUAGE: typescript
CODE:
declare const nand: { (that: boolean): (self: boolean) => boolean; (self: boolean, that: boolean): boolean; }

----------------------------------------

TITLE: Defining Schedule.whileOutput Function Type in TypeScript
DESCRIPTION: Type declaration for the whileOutput function that creates a new schedule continuing execution while a predicate on the output remains true. The function supports both curried and uncurried forms for flexibility in usage.

LANGUAGE: typescript
CODE:
declare const whileOutput: {
  <Out>(f: Predicate<Out>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>;
  <Out, In, R>(self: Schedule<Out, In, R>, f: Predicate<Out>): Schedule<Out, In, R>;
}

----------------------------------------

TITLE: Implementing forEach Function for RedBlackTree in TypeScript
DESCRIPTION: Defines a forEach function that executes a specified function for each node of a RedBlackTree, in order. The function is overloaded to allow for both curried and uncurried usage.

LANGUAGE: typescript
CODE:
declare const forEach: {
  <K, V>(f: (key: K, value: V) => void): (self: RedBlackTree<K, V>) => void;
  <K, V>(self: RedBlackTree<K, V>, f: (key: K, value: V) => void): void;
}

----------------------------------------

TITLE: Defining InterruptedException Interface in TypeScript
DESCRIPTION: Interface definition for InterruptedException that extends YieldableError. This interface represents errors occurring when a fiber is forcefully interrupted during concurrent operations. It includes a _tag property for type identification and an InterruptedExceptionTypeId symbol property.

LANGUAGE: typescript
CODE:
export interface InterruptedException extends YieldableError {
  readonly _tag: "InterruptedException"
  readonly [InterruptedExceptionTypeId]: InterruptedExceptionTypeId
}

----------------------------------------

TITLE: Defining MetricPolling Interface in TypeScript
DESCRIPTION: TypeScript interface definition for MetricPolling that extends Pipeable. It contains a metric property for updates and a poll effect property that retrieves values for the metric. The interface is generic with type parameters for input/output types and error handling.

LANGUAGE: typescript
CODE:
export interface MetricPolling<in out Type, in out In, out R, out E, out Out> extends Pipeable {
  readonly [MetricPollingTypeId]: MetricPollingTypeId
  /**
   * The metric that this `MetricPolling` polls to update.
   */
  readonly metric: Metric.Metric<Type, In, Out>
  /**
   * An effect that polls a value that may be fed to the metric.
   */
  readonly poll: Effect.Effect<In, E, R>
}

----------------------------------------

TITLE: Defining PersistenceError Class in TypeScript
DESCRIPTION: Declaration of the PersistenceError class that represents failures when persisting messages to cluster's mailbox storage. This class is part of the error handling system for cluster operations.

LANGUAGE: typescript
CODE:
declare class PersistenceError

----------------------------------------

TITLE: Defining SqlResolver.ordered Function in TypeScript
DESCRIPTION: This code snippet defines the signature of the SqlResolver.ordered function. It creates a resolver for SQL queries with request and result schemas, handling input validation, output validation, and ordered mapping of results to requests.

LANGUAGE: typescript
CODE:
declare const ordered: <T extends string, I, II, RI, A, IA, _, E, RA = never, R = never>(tag: T, options: { readonly Request: Schema.Schema<I, II, RI>; readonly Result: Schema.Schema<A, IA>; readonly execute: (requests: Array<Types.NoInfer<II>>) => Effect.Effect<ReadonlyArray<_>, E>; readonly withContext?: false; } | { readonly Request: Schema.Schema<I, II, RI>; readonly Result: Schema.Schema<A, IA, RA>; readonly execute: (requests: Array<Types.NoInfer<II>>) => Effect.Effect<ReadonlyArray<_>, E, R>; readonly withContext: true; }) => Effect.Effect<SqlResolver<T, I, A, E | ResultLengthMismatch, RI>, never, RA | R>

----------------------------------------

TITLE: Constructing Layer from Context in TypeScript
DESCRIPTION: The succeedContext function constructs a layer from a specified context value. It takes a context that returns one or more services and creates a Layer<A> from it. This function has been available since version 2.0.0 of the package.

LANGUAGE: typescript
CODE:
declare const succeedContext: <A>(context: Context.Context<A>) => Layer<A>

----------------------------------------

TITLE: Setting Scoped Configuration Provider in Effect Module
DESCRIPTION: Function that sets a configuration provider within a scope and ensures it is restored to its original value when the scope closes. Takes a ConfigProvider parameter and returns an Effect that requires a Scope and never produces an error.

LANGUAGE: typescript
CODE:
declare const withConfigProviderScoped: (provider: ConfigProvider) => Effect<void, never, Scope.Scope>

----------------------------------------

TITLE: Composing Configurations with zipWith in TypeScript
DESCRIPTION: Function that combines two Config instances using a provided combining function. It supports both curried and uncurried versions for flexibility in composition.

LANGUAGE: typescript
CODE:
declare const zipWith: {
  <B, A, C>(that: Config<B>, f: (a: A, b: B) => C): (self: Config<A>) => Config<C>;
  <A, B, C>(self: Config<A>, that: Config<B>, f: (a: A, b: B) => C): Config<C>;
}

----------------------------------------

TITLE: Implementing XOR Operation in TypeScript with Effect Library
DESCRIPTION: Demonstrates the XOR logical operation that returns true when exactly one of the inputs is true, and false otherwise. The function supports both curried and non-curried forms for flexible usage patterns.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { xor } from "effect/Boolean"

assert.deepStrictEqual(xor(true, true), false)
assert.deepStrictEqual(xor(true, false), true)
assert.deepStrictEqual(xor(false, true), true)
assert.deepStrictEqual(xor(false, false), false)

LANGUAGE: typescript
CODE:
declare const xor: { (that: boolean): (self: boolean) => boolean; (self: boolean, that: boolean): boolean; }

----------------------------------------

TITLE: Creating List from Iterable in TypeScript
DESCRIPTION: The fromIterable function creates a new List from an iterable collection of values. It takes an iterable of type A as input and returns a List of type A.

LANGUAGE: typescript
CODE:
declare const fromIterable: <A>(prefix: Iterable<A>) => List<A>

----------------------------------------

TITLE: Defining validateAll Function in TypeScript for STM Module
DESCRIPTION: Declares the validateAll function, which processes elements of type A using a provided function f. It accumulates errors in an error channel or successes in a success channel. This function is lossy, as errors will cause loss of all successes. For retaining all information, STM.partition is recommended.

LANGUAGE: typescript
CODE:
declare const validateAll: { <A, B, E, R>(f: (a: A) => STM<B, E, R>): (elements: Iterable<A>) => STM<Array<B>, [E, ...Array<E>], R>; <A, B, E, R>(elements: Iterable<A>, f: (a: A) => STM<B, E, R>): STM<Array<B>, [E, ...Array<E>], R>; }

----------------------------------------

TITLE: Defining STM.tapError Function in TypeScript
DESCRIPTION: Declares the `tapError` function, which allows peeking at the error of a transactional effect. It takes a function that processes the error and returns a new STM effect.

LANGUAGE: typescript
CODE:
declare const tapError: { <E, X, E2, R2>(f: (error: NoInfer<E>) => STM<X, E2, R2>): <A, R>(self: STM<A, E, R>) => STM<A, E | E2, R2 | R>; <A, E, R, X, E2, R2>(self: STM<A, E, R>, f: (error: E) => STM<X, E2, R2>): STM<A, E | E2, R | R2>; }

----------------------------------------

TITLE: Creating Bounded MutableQueue in TypeScript
DESCRIPTION: Function signature for creating a new bounded MutableQueue with a specified capacity. The function takes a numeric capacity parameter and returns a generic MutableQueue instance of type A.

LANGUAGE: typescript
CODE:
declare const bounded: <A>(capacity: number) => MutableQueue<A>

----------------------------------------

TITLE: Defining Date Matching Predicate in TypeScript
DESCRIPTION: Declares a constant 'date' as a Predicate.Refinement that matches values that are instances of Date. This predicate can be used to refine unknown values to Date types.

LANGUAGE: typescript
CODE:
declare const date: Predicate.Refinement<unknown, Date>

----------------------------------------

TITLE: BigDecimal Division Function Signature
DESCRIPTION: TypeScript type declaration for the divide function showing its polymorphic interface. The function can be called with parameters in curried or uncurried form, always returning an Option of BigDecimal.

LANGUAGE: typescript
CODE:
declare const divide: { (that: BigDecimal): (self: BigDecimal) => Option.Option<BigDecimal>; (self: BigDecimal, that: BigDecimal): Option.Option<BigDecimal>; }

----------------------------------------

TITLE: Negating Boolean STM Effect in TypeScript
DESCRIPTION: The negate function takes an STM effect that produces a boolean value and returns a new effect where the boolean value is negated. It maintains the same error type and environment requirements as the original effect.

LANGUAGE: typescript
CODE:
declare const negate: <E, R>(self: STM<boolean, E, R>) => STM<boolean, E, R>

----------------------------------------

TITLE: Implementing Queue Offer Operation in TypeScript
DESCRIPTION: Defines a function that offers (enqueues) an element to a MutableQueue. The function is curried and returns a boolean indicating whether the enqueue operation was successful.

LANGUAGE: typescript
CODE:
declare const offer: { <A>(self: MutableQueue<A>, value: A): boolean; <A>(value: A): (self: MutableQueue<A>) => boolean; }

----------------------------------------

TITLE: Testing for Non-null Values in TypeScript
DESCRIPTION: This snippet demonstrates the usage of the isNotNull function from the effect/Predicate module. It shows how the function returns true for undefined and string values, but false for null.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { isNotNull } from "effect/Predicate"

assert.deepStrictEqual(isNotNull(undefined), true)
assert.deepStrictEqual(isNotNull("null"), true)

assert.deepStrictEqual(isNotNull(null), false)

----------------------------------------

TITLE: Declaring mapOutEffectPar Function in TypeScript
DESCRIPTION: Defines a function that creates a new channel by applying a ZIO function to each emitted output element of an existing channel, processing n elements in parallel. It handles various type parameters for input/output elements, errors, and environments.

LANGUAGE: typescript
CODE:
declare const mapOutEffectPar: { <OutElem, OutElem1, OutErr1, Env1>(f: (o: OutElem) => Effect.Effect<OutElem1, OutErr1, Env1>, n: number): <InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1, InElem, OutErr1 | OutErr, InErr, OutDone, InDone, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, OutErr1, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (o: OutElem) => Effect.Effect<OutElem1, OutErr1, Env1>, n: number): Channel<OutElem1, InElem, OutErr | OutErr1, InErr, OutDone, InDone, Env | Env1>; }

----------------------------------------

TITLE: Implementing Effect Transplantation in TypeScript
DESCRIPTION: Defines a transplant function that allows effects to be moved to different scopes. The function takes a grafter callback that can transplant effects to extend their lifespans into the parent scope, ensuring proper effect management across different hierarchical levels.

LANGUAGE: typescript
CODE:
declare const transplant: <A, E, R>(f: (grafter: <A2, E2, R2>(effect: Effect<A2, E2, R2>) => Effect<A2, E2, R2>) => Effect<A, E, R>) => Effect<A, E, R>

----------------------------------------

TITLE: Implementing TPubSub Shutdown in TypeScript
DESCRIPTION: Defines the shutdown function for TPubSub that interrupts fibers suspended on offer or take operations. The function returns an STM transaction that resolves to void. After shutdown, any subsequent offer or take operations will be immediately interrupted.

LANGUAGE: typescript
CODE:
declare const shutdown: <A>(self: TPubSub<A>) => STM.STM<void>

----------------------------------------

TITLE: Implementing Record Subset Comparison in TypeScript
DESCRIPTION: Function signature for isSubrecord, which determines if one record contains all keys and values of another record using Effect's Equal.equivalence(). The function supports both curried and uncurried calling styles.

LANGUAGE: typescript
CODE:
declare const isSubrecord: { 
  <K extends string, A>(that: ReadonlyRecord<K, A>): (self: ReadonlyRecord<K, A>) => boolean; 
  <K extends string, A>(self: ReadonlyRecord<K, A>, that: ReadonlyRecord<K, A>): boolean; 
}

----------------------------------------

TITLE: TypeScript Function Signature for FiberMap.join
DESCRIPTION: Provides the TypeScript function signature for the FiberMap.join function. It takes a FiberMap as input and returns an Effect that resolves to void or fails with an error of type E.

LANGUAGE: typescript
CODE:
declare const join: <K, A, E>(self: FiberMap<K, A, E>) => Effect.Effect<void, E>

----------------------------------------

TITLE: Array.scan Function Signature in TypeScript
DESCRIPTION: Provides the TypeScript signature for the Array.scan function. It shows two overloads: one for curried usage and another for direct application.

LANGUAGE: typescript
CODE:
declare const scan: { <B, A>(b: B, f: (b: B, a: A) => B): (self: Iterable<A>) => NonEmptyArray<B>; <A, B>(self: Iterable<A>, b: B, f: (b: B, a: A) => B): NonEmptyArray<B>; }

----------------------------------------

TITLE: Setting Custom Scheduler in Effect Module
DESCRIPTION: Function signature for withScheduler which takes a Scheduler parameter and an Effect, returning a new Effect with the specified scheduler. Supports both curried and uncurried calling styles.

LANGUAGE: typescript
CODE:
declare const withScheduler: { (scheduler: Scheduler.Scheduler): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, scheduler: Scheduler.Scheduler): Effect<A, E, R>; }

----------------------------------------

TITLE: TypeScript Signature for Chunk.reverse Function in Effect Library
DESCRIPTION: This code block shows the TypeScript signature for the Chunk.reverse function. It takes a Chunk of any type and returns a reversed Chunk of the same type, preserving the NonEmptyChunk type if applicable.

LANGUAGE: typescript
CODE:
declare const reverse: <S extends Chunk<any>>(self: S) => Chunk.With<S, Chunk.Infer<S>>

----------------------------------------

TITLE: Implementing Array Head Retrieval with Fallback in TypeScript
DESCRIPTION: Function declaration for headOrElse that retrieves the first element of a ReadonlyArray. It accepts an optional fallback argument that is returned when the array is empty. The function supports both curried and non-curried calling styles.

LANGUAGE: typescript
CODE:
declare const headOrElse: {
  <S extends Schema.Any, A extends ReadonlyArray<unknown>>(
    fallback?: LazyArg<A[number]>
  ): (self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => transform<S, SchemaClass<A[number]>>;
  <S extends Schema.Any, A extends ReadonlyArray<unknown>>(
    self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>,
    fallback?: LazyArg<A[number]>
  ): transform<S, SchemaClass<A[number]>>;
}

----------------------------------------

TITLE: Creating Single Value Take - TypeScript Effect Library
DESCRIPTION: Function signature for creating a Take instance containing a single value chunk. The function is generic and accepts any type A, returning a Take of that same type.

LANGUAGE: typescript
CODE:
declare const of: <A>(value: A) => Take<A>

----------------------------------------

TITLE: Defining Metric Interface in TypeScript
DESCRIPTION: TypeScript interface definition for the Metric type that represents a concurrent metric system. It includes methods for updating, retrieving values, and modifying metrics with support for extra tags and labels.

LANGUAGE: typescript
CODE:
export interface Metric<in out Type, in In, out Out> extends Metric.Variance<Type, In, Out>, Pipeable {
  /**
   * The type of the underlying primitive metric. For example, this could be
   * `MetricKeyType.Counter` or `MetricKeyType.Gauge`.
   */
  readonly keyType: Type
  unsafeUpdate(input: In, extraTags: ReadonlyArray<MetricLabel.MetricLabel>): void
  unsafeValue(extraTags: ReadonlyArray<MetricLabel.MetricLabel>): Out
  unsafeModify(input: In, extraTags: ReadonlyArray<MetricLabel.MetricLabel>): void
  register(): this
  <A extends In, E, R>(effect: Effect.Effect<A, E, R>): Effect.Effect<A, E, R>
}

----------------------------------------

TITLE: Implementing Stream Interruption in TypeScript
DESCRIPTION: Function declaration for interruptAfter that takes a Duration input and returns a function to interrupt a Stream after the specified duration. Supports both curried and uncurried function calls.

LANGUAGE: typescript
CODE:
declare const interruptAfter: { 
  (duration: Duration.DurationInput): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; 
  <A, E, R>(self: Stream<A, E, R>, duration: Duration.DurationInput): Stream<A, E, R>; 
}

----------------------------------------

TITLE: Function.dual TypeScript Signature
DESCRIPTION: The TypeScript signature for the dual function, showing its overloads for both arity-based and predicate-based usage.

LANGUAGE: typescript
CODE:
declare const dual: { <DataLast extends (...args: Array<any>) => any, DataFirst extends (...args: Array<any>) => any>(arity: Parameters<DataFirst>["length"], body: DataFirst): DataLast & DataFirst; <DataLast extends (...args: Array<any>) => any, DataFirst extends (...args: Array<any>) => any>(isDataFirst: (args: IArguments) => boolean, body: DataFirst): DataLast & DataFirst; }

----------------------------------------

TITLE: Matching Stream Halt Strategy in TypeScript
DESCRIPTION: A function that performs pattern matching on HaltStrategy values by folding over the strategy using provided case functions. It supports both curried and uncurried calling styles and handles four different halt strategies: left, right, both, and either.

LANGUAGE: typescript
CODE:
declare const match: { 
  <Z>(options: { 
    readonly onLeft: () => Z; 
    readonly onRight: () => Z; 
    readonly onBoth: () => Z; 
    readonly onEither: () => Z; 
  }): (self: HaltStrategy) => Z; 
  <Z>(self: HaltStrategy, options: { 
    readonly onLeft: () => Z; 
    readonly onRight: () => Z; 
    readonly onBoth: () => Z; 
    readonly onEither: () => Z; 
  }): Z; 
}

----------------------------------------

TITLE: Match.when Function Signature in TypeScript
DESCRIPTION: Provides the TypeScript type signature for the Match.when function, showing its complex generic types for pattern matching and return value handling.

LANGUAGE: typescript
CODE:
declare const when: <R, const P extends Types.PatternPrimitive<R> | Types.PatternBase<R>, Ret, Fn extends (_: Types.WhenMatch<R, P>) => Ret>(pattern: P, f: Fn) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr, Ret>) => Matcher<I, Types.AddWithout<F, Types.PForExclude<P>>, Types.ApplyFilters<I, Types.AddWithout<F, Types.PForExclude<P>>>, A | ReturnType<Fn>, Pr, Ret>

----------------------------------------

TITLE: Implementing Type Guard for EncodeException in TypeScript
DESCRIPTION: This function checks if a given value is an instance of EncodeException. It takes an unknown input and returns a boolean indicating whether the input is an EncodeException. This type guard can be used for type narrowing in TypeScript.

LANGUAGE: typescript
CODE:
declare const isEncodeException: (u: unknown) => u is EncodeException

----------------------------------------

TITLE: Retrieving Services from Context with Fallback in TypeScript
DESCRIPTION: The getOrElse function retrieves a service from the context corresponding to a given tag. If the service is not found, it uses a fallback value. It can be called in two ways: by providing the context as the first argument, or as a method on the context object.

LANGUAGE: typescript
CODE:
declare const getOrElse: {
  <S, I, B>(tag: Tag<I, S>, orElse: LazyArg<B>): <Services>(self: Context<Services>) => S | B;
  <Services, S, I, B>(self: Context<Services>, tag: Tag<I, S>, orElse: LazyArg<B>): S | B;
}

----------------------------------------

TITLE: Offering Values to TPriorityQueue in TypeScript
DESCRIPTION: The offer function adds a specified value to a TPriorityQueue. It can be used in two ways: by passing the value and queue separately, or by passing the value to a function that takes the queue. It returns an STM (Software Transactional Memory) operation that, when executed, adds the value to the queue.

LANGUAGE: typescript
CODE:
declare const offer: { <A>(value: A): (self: TPriorityQueue<A>) => STM.STM<void>; <A>(self: TPriorityQueue<A>, value: A): STM.STM<void>; }

----------------------------------------

TITLE: Implementing STM Effect Replication in TypeScript
DESCRIPTION: Function signature for replicating an STM effect n times. Takes a number parameter and returns an array of replicated STM effects. Returns empty array for zero or negative numbers.

LANGUAGE: typescript
CODE:
declare const replicate: { (n: number): <A, E, R>(self: STM<A, E, R>) => Array<STM<A, E, R>>; <A, E, R>(self: STM<A, E, R>, n: number): Array<STM<A, E, R>>; }

----------------------------------------

TITLE: Visualizing Windowed Schedule Pattern
DESCRIPTION: ASCII diagram showing how the windowed schedule divides time into fixed intervals and handles action execution at window boundaries

LANGUAGE: text
CODE:
     10s        10s        10s       10s
|----------|----------|----------|----------|
|action------|sleep---|act|-sleep|action----|

----------------------------------------

TITLE: Checking Failure Status of Transactional Effect in TypeScript
DESCRIPTION: The isFailure function determines whether a given transactional effect is a failure. It takes an STM<A, E, R> as input and returns an STM<boolean, never, R>. This function is useful for error handling and flow control in transactional operations.

LANGUAGE: typescript
CODE:
declare const isFailure: <A, E, R>(self: STM<A, E, R>) => STM<boolean, never, R>

----------------------------------------

TITLE: Extracting Brands from Branded Types in TypeScript
DESCRIPTION: The Brands<P> type is a utility type that extracts the brands from a branded type. It uses conditional types and mapped types to create an intersection of individual brands when given a branded type.

LANGUAGE: typescript
CODE:
type Brands<P> = P extends Brand<any> ? Types.UnionToIntersection<
      {
        [k in keyof P[BrandTypeId]]: k extends string | symbol ? Brand<k>
          : never
      }[keyof P[BrandTypeId]]
    >
    : never

----------------------------------------

TITLE: Checking for Unexpected Errors in Cause - TypeScript
DESCRIPTION: The isDie function checks if a Cause contains any unexpected or unhandled errors (Die). It returns a boolean value, true if such errors are present. This function is useful for distinguishing between known failures and unexpected errors in error handling scenarios.

LANGUAGE: typescript
CODE:
declare const isDie: <E>(self: Cause<E>) => boolean

----------------------------------------

TITLE: TypeScript Declaration for Match.tags Function
DESCRIPTION: Provides the TypeScript type declaration for the Match.tags function. It shows the complex generic types used to ensure type safety when matching against discriminated unions.

LANGUAGE: typescript
CODE:
declare const tags: <R, Ret, P extends { readonly [Tag in Types.Tags<"_tag", R> & string]?: ((_: Extract<R, Record<"_tag", Tag>>) => Ret) | undefined; } & { readonly [Tag in Exclude<keyof P, Types.Tags<"_tag", R>>]: never; }>(fields: P) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr, Ret>) => Matcher<I, Types.AddWithout<F, Extract<R, Record<"_tag", keyof P>>>, Types.ApplyFilters<I, Types.AddWithout<F, Extract<R, Record<"_tag", keyof P>>>>, A | ReturnType<P[keyof P] & {}>, Pr, Ret>

----------------------------------------

TITLE: Merging Streams with Either in TypeScript
DESCRIPTION: Function signature for merging two streams into a single stream where elements are wrapped in Either. The function accepts two streams and combines them preserving their error and environment types.

LANGUAGE: typescript
CODE:
declare const mergeEither: { <A2, E2, R2>(that: Stream<A2, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<Either.Either<A2, A>, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>): Stream<Either.Either<A2, A>, E | E2, R | R2>; }

----------------------------------------

TITLE: InterleaveWith Function Signature - TypeScript
DESCRIPTION: Type signature for the interleaveWith function showing its polymorphic nature and type parameters for error handling and environmental requirements.

LANGUAGE: typescript
CODE:
declare const interleaveWith: { <A2, E2, R2, E3, R3>(that: Stream<A2, E2, R2>, decider: Stream<boolean, E3, R3>): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2 | E3 | E, R2 | R3 | R>; <A, E, R, A2, E2, R2, E3, R3>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>, decider: Stream<boolean, E3, R3>): Stream<A | A2, E | E2 | E3, R | R2 | R3>; }

----------------------------------------

TITLE: Defining Take Interface in TypeScript
DESCRIPTION: Defines the Take interface that extends Take.Variance and Pipeable, containing an internal exit property that handles both successful chunks and optional errors.

LANGUAGE: typescript
CODE:
export interface Take<out A, out E = never> extends Take.Variance<A, E>, Pipeable {
  /** @internal */
  readonly exit: Exit.Exit<Chunk.Chunk<A>, Option.Option<E>>
}

----------------------------------------

TITLE: Checking Queue Fullness in TypeScript
DESCRIPTION: The isFull function determines whether a MutableQueue is full. It takes a MutableQueue<A> as input and returns a boolean indicating if the queue is at capacity.

LANGUAGE: typescript
CODE:
declare const isFull: <A>(self: MutableQueue<A>) => boolean

----------------------------------------

TITLE: Determining Number Sign in TypeScript using effect/Number
DESCRIPTION: This snippet demonstrates how to use the sign function from the effect/Number module to determine the sign of a number. It returns -1 for negative numbers, 0 for zero, and 1 for positive numbers.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { sign } from "effect/Number"

assert.deepStrictEqual(sign(-5), -1)
assert.deepStrictEqual(sign(0), 0)
assert.deepStrictEqual(sign(5), 1)

----------------------------------------

TITLE: TypeScript Function Signature for Array.groupWith
DESCRIPTION: Provides the TypeScript function signature for Array.groupWith. It shows two overloads: one taking the equivalence function first and returning a function, and another taking the array and equivalence function together.

LANGUAGE: typescript
CODE:
declare const groupWith: { <A>(isEquivalent: (self: A, that: A) => boolean): (self: NonEmptyReadonlyArray<A>) => NonEmptyArray<NonEmptyArray<A>>; <A>(self: NonEmptyReadonlyArray<A>, isEquivalent: (self: A, that: A) => boolean): NonEmptyArray<NonEmptyArray<A>>; }

----------------------------------------

TITLE: Declaring repeatEffectWithSchedule Function in TypeScript
DESCRIPTION: Defines a function that creates a stream from an effect producing a value of type A, which is repeated using the specified schedule. It takes an effect and a schedule as parameters and returns a Stream.

LANGUAGE: typescript
CODE:
declare const repeatEffectWithSchedule: <A, E, R, X, A0 extends A, R2>(effect: Effect.Effect<A, E, R>, schedule: Schedule.Schedule<X, A0, R2>) => Stream<A, E, R | R2>

----------------------------------------

TITLE: Using getFirst Function in TypeScript Effect Package
DESCRIPTION: Demonstrates how to use the getFirst function to extract the first element from a tuple. The function accepts a readonly tuple of two elements and returns the first element.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { getFirst } from "effect/Tuple"

assert.deepStrictEqual(getFirst(["hello", 42]), "hello")

LANGUAGE: typescript
CODE:
declare const getFirst: <L, R>(self: readonly [L, R]) => L

----------------------------------------

TITLE: Declaring Monthly Schedule Function in TypeScript
DESCRIPTION: Type declaration for a function that creates a schedule recurring on a specific day of each month. The function takes a day number parameter and returns a Schedule that produces incrementing execution counts. The schedule triggers at midnight on the specified day and skips months with insufficient days.

LANGUAGE: typescript
CODE:
declare const dayOfMonth: (day: number) => Schedule<number>

----------------------------------------

TITLE: Defining annotationsWith Function in TestServices Module (TypeScript)
DESCRIPTION: This function retrieves the Annotations service for a test and uses it to run a specified workflow. It takes a function that accepts TestAnnotations and returns an Effect, and it returns an Effect with the same type parameters.

LANGUAGE: typescript
CODE:
declare const annotationsWith: <A, E, R>(f: (annotations: Annotations.TestAnnotations) => Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>

----------------------------------------

TITLE: Implementing Bimap Composition for Nested Type Constructors in TypeScript
DESCRIPTION: This function returns a default ternary bimap composition for nested type constructors F and G. It takes Covariant and Bicovariant instances for F and G respectively, and returns a function that applies bimap across the nested structure.

LANGUAGE: typescript
CODE:
declare const bimapComposition: <F extends TypeLambda, G extends TypeLambda>(CovariantF: Covariant<F>, BicovariantG: Bicovariant<G>) => <FR, FO, FE, GR, GO, E1, A, E2, B>(self: Kind<F, FR, FO, FE, Kind<G, GR, GO, E1, A>>, f: (e: E1) => E2, g: (a: A) => B) => Kind<F, FR, FO, FE, Kind<G, GR, GO, E2, B>>

----------------------------------------

TITLE: Implementing BigDecimal Multiplication in TypeScript
DESCRIPTION: Demonstrates how to use the multiply function from the Effect library's BigDecimal module to perform multiplication operations on BigDecimal values. The function accepts two BigDecimal parameters and returns their product.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { multiply, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(multiply(unsafeFromString("2"), unsafeFromString("3")), unsafeFromString("6"))

LANGUAGE: typescript
CODE:
declare const multiply: { (that: BigDecimal): (self: BigDecimal) => BigDecimal; (self: BigDecimal, that: BigDecimal): BigDecimal; }

----------------------------------------

TITLE: Implementing withParentSpan Function in TypeScript Effect Module
DESCRIPTION: Function definition for withParentSpan that adds a provided span to the current span stack. It supports both curried and uncurried forms, operating on Effect types with generic type parameters for result, error, and requirements.

LANGUAGE: typescript
CODE:
declare const withParentSpan: { 
  (span: Tracer.AnySpan): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, Exclude<R, Tracer.ParentSpan>>; 
  <A, E, R>(self: Effect<A, E, R>, span: Tracer.AnySpan): Effect<A, E, Exclude<R, Tracer.ParentSpan>>; 
}

----------------------------------------

TITLE: Declaring logAnnotations Function in TypeScript
DESCRIPTION: Function declaration for retrieving log annotations from the current scope. Returns an Effect containing a HashMap of string keys to unknown values, with never types for error and requirement parameters.

LANGUAGE: typescript
CODE:
declare const logAnnotations: Effect<HashMap.HashMap<string, unknown>, never, never>

----------------------------------------

TITLE: Retrieving First Element from List in TypeScript
DESCRIPTION: The head function returns the first element of a given list as an Option type. If the list is empty, it returns None. This function is part of the List module in the Effect package.

LANGUAGE: typescript
CODE:
declare const head: <A>(self: List<A>) => Option.Option<A>

----------------------------------------

TITLE: Defining cursorLeft ANSI Cursor Control Function in TypeScript
DESCRIPTION: Declares a constant cursorLeft of type Ansi that moves the cursor to the first column of the current row. This function is part of the Ansi module in the @effect/printer-ansi package.

LANGUAGE: typescript
CODE:
declare const cursorLeft: Ansi

----------------------------------------

TITLE: Creating MutableList in TypeScript using Effect Package
DESCRIPTION: Function signature for creating a new MutableList from a variable number of elements. The function is generic, accepting elements of any type A and returning a MutableList of the same type.

LANGUAGE: typescript
CODE:
declare const make: <A>(...elements: ReadonlyArray<A>) => MutableList<A>

----------------------------------------

TITLE: Creating Tagged Objects with Data.tagged in TypeScript
DESCRIPTION: Demonstrates how to use the Data.tagged function to create a constructor for objects with a specified _tag property. The example creates a Person type and constructor, then uses it to create an object.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Data } from "effect"

interface Person {
  readonly _tag: "Person" // the tag
  readonly name: string
}

const Person = Data.tagged<Person>("Person")

const mike = Person({ name: "Mike" })

assert.deepEqual(mike, { _tag: "Person", name: "Mike" })

----------------------------------------

TITLE: Implementing Stream.zipWithChunks in TypeScript
DESCRIPTION: Defines a function that zips two streams together point-wise, applying a custom function to paired chunks of elements. The function handles both overloaded cases and supports early termination when either stream ends. It includes comprehensive type parameters for proper type inference and error handling.

LANGUAGE: typescript
CODE:
declare const zipWithChunks: {
  <A2, E2, R2, A, A3>(
    that: Stream<A2, E2, R2>,
    f: (left: Chunk.Chunk<A>, right: Chunk.Chunk<A2>) => readonly [Chunk.Chunk<A3>, Either.Either<Chunk.Chunk<A2>, Chunk.Chunk<A>>]
  ): <E, R>(self: Stream<A, E, R>) => Stream<A3, E2 | E, R2 | R>;
  <A, E, R, A2, E2, R2, A3>(
    self: Stream<A, E, R>,
    that: Stream<A2, E2, R2>,
    f: (left: Chunk.Chunk<A>, right: Chunk.Chunk<A2>) => readonly [Chunk.Chunk<A3>, Either.Either<Chunk.Chunk<A2>, Chunk.Chunk<A>>]
  ): Stream<A3, E | E2, R | R2>;
}

----------------------------------------

TITLE: Calculating Record Size in TypeScript using Effect/Record
DESCRIPTION: This snippet demonstrates how to use the 'size' function from the Effect/Record module to count the number of key/value pairs in a record. It imports the necessary modules, creates a sample record, and uses an assertion to verify the correct size.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { size } from "effect/Record";

assert.deepStrictEqual(size({ a: "a", b: 1, c: true }), 3);

----------------------------------------

TITLE: Implementing Atomic Minimum Element Search in TArray - TypeScript
DESCRIPTION: Defines a function that atomically computes the minimum element in a TArray using STM transactions. The function takes an Order comparator and returns an Option containing the minimum element if the array is non-empty.

LANGUAGE: typescript
CODE:
declare const minOption: { 
  <A>(order: Order.Order<A>): (self: TArray<A>) => STM.STM<Option.Option<A>>; 
  <A>(self: TArray<A>, order: Order.Order<A>): STM.STM<Option.Option<A>>; 
}

----------------------------------------

TITLE: Trie.modify Function Signature in TypeScript
DESCRIPTION: Provides the TypeScript function signature for the Trie.modify function. It shows two overloads: one for curried usage and another for direct usage.

LANGUAGE: typescript
CODE:
declare const modify: { <V1, V>(key: string, f: (v: V) => V1): (self: Trie<V>) => Trie<V1 | V>; <V1, V>(self: Trie<V>, key: string, f: (v: V) => V1): Trie<V | V1>; }

----------------------------------------

TITLE: Option.zipWith Function Signature in TypeScript
DESCRIPTION: The type signature for the Option.zipWith function, showing its polymorphic nature and ability to work with different Option types and combining functions.

LANGUAGE: typescript
CODE:
declare const zipWith: { <B, A, C>(that: Option<B>, f: (a: A, b: B) => C): (self: Option<A>) => Option<C>; <A, B, C>(self: Option<A>, that: Option<B>, f: (a: A, b: B) => C): Option<C>; }

----------------------------------------

TITLE: Reducing HashSet Values in TypeScript using effect Package
DESCRIPTION: Demonstrates how to use the HashSet.reduce function to sum the values of a HashSet. The function can be used with both data-last (pipeable) and data-first APIs.

LANGUAGE: typescript
CODE:
import { HashSet, pipe } from "effect"

const sum = (a: number, b: number): number => a + b

// with `data-last`, a.k.a. `pipeable` API
pipe(HashSet.make(0, 1, 2), HashSet.reduce(0, sum))

// or with the pipe method
HashSet.make(0, 1, 2).pipe(HashSet.reduce(0, sum))

// or with `data-first` API
HashSet.reduce(HashSet.make(0, 1, 2), 0, sum)

----------------------------------------

TITLE: Removing Multiple Entries from TMap in TypeScript
DESCRIPTION: The removeAll function deletes all entries associated with the specified keys from a TMap. It can be used in two ways: either by passing the keys and the TMap separately, or by passing the keys first and then the TMap.

LANGUAGE: typescript
CODE:
declare const removeAll: { <K>(keys: Iterable<K>): <V>(self: TMap<K, V>) => STM.STM<void>; <K, V>(self: TMap<K, V>, keys: Iterable<K>): STM.STM<void>; }

----------------------------------------

TITLE: Implementing Recurring Schedule in TypeScript
DESCRIPTION: Defines a schedule that executes a fixed number of times and returns the current count of recurrences. The schedule terminates after reaching the specified number of iterations.

LANGUAGE: typescript
CODE:
declare const recurs: (n: number) => Schedule<number>

----------------------------------------

TITLE: Mapping HashSet Values in TypeScript using Effect Package
DESCRIPTION: Demonstrates different ways to use the HashSet.map function to transform values in a HashSet. It shows data-last (pipeable) API, piped method, and data-first API approaches.

LANGUAGE: typescript
CODE:
import { HashSet, pipe } from "effect"

// with `data-last`, a.k.a. `pipeable` API
pipe(
  HashSet.make(0, 1, 2), // HashSet.HashSet<number>
  HashSet.map(String) // HashSet.HashSet<string>
)

// or piped with the pipe method
HashSet.make(0, 1, 2).pipe(HashSet.map(String))

// or with `data-first` API
HashSet.map(HashSet.make(0, 1, 2), String)

----------------------------------------

TITLE: Defining Any Schema Type in TypeScript
DESCRIPTION: Type definition for Any schema that can handle any type except 'never'. This is a core type used in Effect's Schema module for type validation and transformation.

LANGUAGE: typescript
CODE:
type Any = Schema<any, any, unknown>

----------------------------------------

TITLE: Transforming Sink Input and Output with Effects in TypeScript
DESCRIPTION: The dimapChunksEffect function effectfully transforms both input chunks and the result of a sink. It takes options for transforming input and output, and returns a new sink with modified input and output types. The function preserves chunking-invariance.

LANGUAGE: typescript
CODE:
declare const dimapChunksEffect: { <In0, In, E2, R2, A, A2, E3, R3>(options: { readonly onInput: (chunk: Chunk.Chunk<In0>) => Effect.Effect<Chunk.Chunk<In>, E2, R2>; readonly onDone: (a: A) => Effect.Effect<A2, E3, R3>; }): <L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A2, In0, L, E2 | E3 | E, R2 | R3 | R>; <A, In, L, E, R, In0, E2, R2, A2, E3, R3>(self: Sink<A, In, L, E, R>, options: { readonly onInput: (chunk: Chunk.Chunk<In0>) => Effect.Effect<Chunk.Chunk<In>, E2, R2>; readonly onDone: (a: A) => Effect.Effect<A2, E3, R3>; }): Sink<A2, In0, L, E | E2 | E3, R | R2 | R3>; }

----------------------------------------

TITLE: Implementing STM Service Provider in TypeScript
DESCRIPTION: Defines a function provideServiceSTM that provides a single service requirement to an STM effect. It supports two function signatures - one for providing the service to an existing STM effect, and another for creating a new provider. The function handles type transformations for error handling and environment requirements.

LANGUAGE: typescript
CODE:
declare const provideServiceSTM: {
  <I, S, E1, R1>(tag: Context.Tag<I, S>, stm: STM<NoInfer<S>, E1, R1>): <A, E, R>(self: STM<A, E, R>) => STM<A, E1 | E, R1 | Exclude<R, I>>;
  <A, E, R, I, S, E1, R1>(self: STM<A, E, R>, tag: Context.Tag<I, S>, stm: STM<NoInfer<S>, E1, R1>): STM<A, E1 | E, R1 | Exclude<R, I>>;
}

----------------------------------------

TITLE: Multiplying Numbers in an Iterable using Effect/Number in TypeScript
DESCRIPTION: The multiplyAll function takes an Iterable of numbers and returns their multiplication as a single number. It's part of the Number module in the Effect package.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { multiplyAll } from "effect/Number"

assert.deepStrictEqual(multiplyAll([2, 3, 4]), 24)

LANGUAGE: typescript
CODE:
declare const multiplyAll: (collection: Iterable<number>) => number

----------------------------------------

TITLE: Defining HttpClient Request Transformation in TypeScript
DESCRIPTION: Declares a function that allows preprocessing of HTTP client requests through an effect-based transformation. The function supports both curried and uncurried forms, enabling flexible composition of request modifications.

LANGUAGE: typescript
CODE:
declare const mapRequestInputEffect: {
  <E2, R2>(f: (a: ClientRequest.HttpClientRequest) => Effect.Effect<ClientRequest.HttpClientRequest, E2, R2>): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E | E2, R | R2>;
  <E, R, E2, R2>(self: HttpClient.With<E, R>, f: (a: ClientRequest.HttpClientRequest) => Effect.Effect<ClientRequest.HttpClientRequest, E2, R2>): HttpClient.With<E | E2, R | R2>;
}

----------------------------------------

TITLE: Interleaving Streams Example - TypeScript
DESCRIPTION: Demonstrates how to combine two number streams using a boolean control stream to determine which stream to pull from. Uses the Effect library's Stream module to create and manipulate streams.

LANGUAGE: typescript
CODE:
import { Effect, Stream } from "effect"

const s1 = Stream.make(1, 3, 5, 7, 9)
const s2 = Stream.make(2, 4, 6, 8, 10)

const booleanStream = Stream.make(true, false, false).pipe(Stream.forever)

const stream = Stream.interleaveWith(s1, s2, booleanStream)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// {
//   _id: 'Chunk',
//   values: [
//     1, 2,  4, 3, 6,
//     8, 5, 10, 7, 9
//   ]
// }

----------------------------------------

TITLE: Using isTupleOf Predicate in TypeScript
DESCRIPTION: Demonstrates how to use the isTupleOf function to check if an array has exactly N elements, with type narrowing capabilities. The function returns true only when the array length matches the specified number.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { isTupleOf } from "effect/Predicate"

assert.deepStrictEqual(isTupleOf([1, 2, 3], 3), true);
assert.deepStrictEqual(isTupleOf([1, 2, 3], 2), false);
assert.deepStrictEqual(isTupleOf([1, 2, 3], 4), false);

const arr: number[] = [1, 2, 3];
if (isTupleOf(arr, 3)) {
  console.log(arr);
  // ^? [number, number, number]
}

----------------------------------------

TITLE: Retrieving Ordered Values from RedBlackTree in TypeScript
DESCRIPTION: This function retrieves all values present in a Red-Black Tree data structure in order. It takes a RedBlackTree instance as input and returns an IterableIterator of the values. The function is part of the RedBlackTree module in the effect package.

LANGUAGE: typescript
CODE:
declare const values: <K, V>(self: RedBlackTree<K, V>) => IterableIterator<V>

----------------------------------------

TITLE: Declaring Default Pretty Logger in TypeScript
DESCRIPTION: Defines a default version of the pretty logger named prettyLoggerDefault. It is a constant of type Logger<unknown, void>.

LANGUAGE: typescript
CODE:
declare const prettyLoggerDefault: Logger<unknown, void>

----------------------------------------

TITLE: TypeScript Function Signature for Match.orElse
DESCRIPTION: Provides the TypeScript function signature for the Match.orElse function. This signature shows the complex type parameters and return types involved in the implementation of the orElse function.

LANGUAGE: typescript
CODE:
declare const orElse: <RA, Ret, F extends (_: RA) => Ret>(f: F) => <I, R, A, Pr>(self: Matcher<I, R, RA, A, Pr, Ret>) => [Pr] extends [never] ? (input: I) => Unify<ReturnType<F> | A> : Unify<ReturnType<F> | A>

----------------------------------------

TITLE: Effect.flatMap TypeScript Function Signature
DESCRIPTION: Provides the TypeScript function signature for Effect.flatMap, showing its polymorphic nature and the types it works with.

LANGUAGE: typescript
CODE:
declare const flatMap: { <A, B, E1, R1>(f: (a: A) => Effect<B, E1, R1>): <E, R>(self: Effect<A, E, R>) => Effect<B, E1 | E, R1 | R>; <A, E, R, B, E1, R1>(self: Effect<A, E, R>, f: (a: A) => Effect<B, E1, R1>): Effect<B, E | E1, R | R1>; }

----------------------------------------

TITLE: Implementing Array.take Function in TypeScript
DESCRIPTION: This code snippet demonstrates the usage of the Array.take function from the Effect package. It keeps a specified number of elements from the start of an Iterable, creating a new Array. The function normalizes the input to a non-negative integer.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const result = Array.take([1, 2, 3, 4, 5], 3)
console.log(result) // [1, 2, 3]

----------------------------------------

TITLE: Deduplicating Arrays in TypeScript using Effect-TS
DESCRIPTION: The dedupe function removes duplicates from an Iterable while preserving the order of the first occurrence of each element. It uses the Equal.equivalence() from the Equal module for element comparison. The function returns a NonEmptyArray for non-empty input arrays and a regular Array for other Iterables.

LANGUAGE: typescript
CODE:
declare const dedupe: <S extends Iterable<any>>(self: S) => S extends NonEmptyReadonlyArray<infer A> ? NonEmptyArray<A> : S extends Iterable<infer A> ? Array<A> : never

----------------------------------------

TITLE: TypeScript Function Signature for DateTime.make in Effect Package
DESCRIPTION: Provides the TypeScript function signature for the DateTime.make function. It shows that the function takes an input of type A (extending DateTime.Input) and returns an Option of DateTime.PreserveZone<A>.

LANGUAGE: typescript
CODE:
declare const make: <A extends DateTime.Input>(input: A) => Option.Option<DateTime.PreserveZone<A>>

----------------------------------------

TITLE: Removing Cookies in Effect Platform TypeScript
DESCRIPTION: Function signature for removing a cookie by its name. Supports both curried and uncurried calling styles. Returns a new Cookies instance after removal.

LANGUAGE: typescript
CODE:
declare const remove: { (name: string): (self: Cookies) => Cookies; (self: Cookies, name: string): Cookies; }

----------------------------------------

TITLE: Using Predicate.or with Number Comparisons in TypeScript
DESCRIPTION: Demonstrates how to combine two number comparison predicates using Predicate.or to create a nonZero check function. The example shows checking values -1, 0, and 1.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Predicate, Number } from "effect"

const nonZero = Predicate.or(Number.lessThan(0), Number.greaterThan(0))

assert.deepStrictEqual(nonZero(-1), true)
assert.deepStrictEqual(nonZero(0), false)
assert.deepStrictEqual(nonZero(1), true)

----------------------------------------

TITLE: Reducing RedBlackTree Entries in TypeScript
DESCRIPTION: Function signature for reducing a RedBlackTree data structure to a single value. The function accepts an initial value and a reducer function that processes each key-value pair in the tree. Supports both curried and uncurried forms of invocation.

LANGUAGE: typescript
CODE:
declare const reduce: {
  <Z, V, K>(zero: Z, f: (accumulator: Z, value: V, key: K) => Z): (self: RedBlackTree<K, V>) => Z;
  <Z, V, K>(self: RedBlackTree<K, V>, zero: Z, f: (accumulator: Z, value: V, key: K) => Z): Z;
}

----------------------------------------

TITLE: Subtracting BigDecimals in TypeScript using Effect Library
DESCRIPTION: Demonstrates how to use the subtract function from the BigDecimal module to perform subtraction on BigDecimal values. It includes importing necessary functions, creating BigDecimal instances, and performing the subtraction operation.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { subtract, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(subtract(unsafeFromString("2"), unsafeFromString("3")), unsafeFromString("-1"))

----------------------------------------

TITLE: Using BigInt.sign Function in TypeScript
DESCRIPTION: Demonstrates how to use the sign function to determine if a bigint number is negative (-1), zero (0), or positive (1). The function takes a bigint parameter and returns an Ordering value.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { sign } from "effect/BigInt"

assert.deepStrictEqual(sign(-5n), -1)
assert.deepStrictEqual(sign(0n), 0)
assert.deepStrictEqual(sign(5n), 1)

LANGUAGE: typescript
CODE:
declare const sign: (n: bigint) => Ordering

----------------------------------------

TITLE: Retrieving Exit Code from Command Execution in TypeScript
DESCRIPTION: This function returns the exit code of a command after the process has completed execution. It takes a Command object as input and returns an Effect that resolves to an ExitCode, potentially resulting in a PlatformError, and requires a CommandExecutor.

LANGUAGE: typescript
CODE:
declare const exitCode: (self: Command) => Effect<ExitCode, PlatformError, CommandExecutor>

----------------------------------------

TITLE: Transforming Channel Error Handling with mapInputErrorEffect in TypeScript
DESCRIPTION: Defines a function that creates a new channel by applying an effectual transformation to the input channel's error value. The function takes an error handler that returns an Effect and produces a modified channel with updated error handling capabilities.

LANGUAGE: typescript
CODE:
declare const mapInputErrorEffect: {
  <InErr0, InDone, InErr, Env1>
  (f: (error: InErr0) => Effect.Effect<InDone, InErr, Env1>):
    <OutElem, InElem, OutErr, OutDone, Env>
    (self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) =>
    Channel<OutElem, InElem, OutErr, InErr0, OutDone, InDone, Env1 | Env>;

  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InErr0, Env1>
  (self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,
   f: (error: InErr0) => Effect.Effect<InDone, InErr, Env1>):
    Channel<OutElem, InElem, OutErr, InErr0, OutDone, InDone, Env | Env1>;
}

----------------------------------------

TITLE: Demonstrating BigDecimal Division in TypeScript
DESCRIPTION: Example showing how to use the unsafeDivide function with BigDecimal values. Demonstrates both exact and non-exact division cases.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { unsafeDivide, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(unsafeDivide(unsafeFromString("6"), unsafeFromString("3")), unsafeFromString("2"))
assert.deepStrictEqual(unsafeDivide(unsafeFromString("6"), unsafeFromString("4")), unsafeFromString("1.5"))

----------------------------------------

TITLE: Using Array.isEmptyArray Function in TypeScript
DESCRIPTION: Demonstrates how to use the Array.isEmptyArray function to check if an array is empty. The function returns true for empty arrays and false otherwise, while also providing type narrowing to [].

LANGUAGE: typescript
CODE:
import { Array } from "effect"

console.log(Array.isEmptyArray([])) // true
console.log(Array.isEmptyArray([1, 2, 3])) // false

LANGUAGE: typescript
CODE:
declare const isEmptyArray: <A>(self: Array<A>) => self is []

----------------------------------------

TITLE: Using takeWhile Function in Effect Module (TypeScript)
DESCRIPTION: Demonstrates how to use the takeWhile function to process a collection of elements based on a predicate. The function takes elements as long as the predicate returns true, discarding the remaining elements once it returns false.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

const numbers = [1, 2, 3, 4, 5, 6]
const predicate = (n: number, i: number) => Effect.succeed(n <= 3)

const program = Effect.gen(function*() {
  const result = yield* Effect.takeWhile(numbers, predicate)
  console.log(result)
})

Effect.runFork(program)
// Output: [1, 2, 3]

----------------------------------------

TITLE: Defining EntityAddress Class in TypeScript
DESCRIPTION: Declares the EntityAddress class, which is used to represent the unique address of an entity within a cluster. This class is part of the @effect/cluster package and is defined in the EntityAddress module.

LANGUAGE: typescript
CODE:
declare class EntityAddress

----------------------------------------

TITLE: Declaring recurWhile Function in TypeScript for Effect Schedule Module
DESCRIPTION: Defines a function that creates a schedule recurring while a predicate is true. It takes a predicate function and returns a Schedule that continues executing as long as the predicate returns true for the input value.

LANGUAGE: typescript
CODE:
declare const recurWhile: <A>(f: Predicate<A>) => Schedule<A, A>

----------------------------------------

TITLE: Unzipping Arrays with Effect Library in TypeScript
DESCRIPTION: Demonstrates the usage of Array.unzip function from the Effect library. This function takes an Iterable of pairs and returns two corresponding Arrays, effectively reversing the zip operation.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const result = Array.unzip([[1, "a"], [2, "b"], [3, "c")])
console.log(result) // [[1, 2, 3], ['a', 'b', 'c']]

----------------------------------------

TITLE: Declaring Cause.as Function in TypeScript
DESCRIPTION: Declares the Cause.as function, which replaces errors in a Cause with a provided constant error. It can be called with either the error first and Cause second, or vice versa.

LANGUAGE: typescript
CODE:
declare const as: { <E2>(error: E2): <E>(self: Cause<E>) => Cause<E2>; <E, E2>(self: Cause<E>, error: E2): Cause<E2>; }

----------------------------------------

TITLE: TypeScript Signature of untupled Function
DESCRIPTION: This code block shows the TypeScript signature of the untupled function. It takes a function that accepts a tuple and returns a new function that accepts spread arguments.

LANGUAGE: typescript
CODE:
declare const untupled: <A extends ReadonlyArray<unknown>, B>(f: (a: A) => B) => (...a: A) => B

----------------------------------------

TITLE: Using TupleOfAtLeast Type in TypeScript
DESCRIPTION: Demonstrates how to use the TupleOfAtLeast type to create tuples with a minimum number of elements. It shows valid and invalid examples of tuples with at least 3 numbers.

LANGUAGE: typescript
CODE:
import { TupleOfAtLeast } from "effect/Types"

// A tuple with at least 3 numbers
const example1: TupleOfAtLeast<3, number> = [1, 2, 3]; // valid
const example2: TupleOfAtLeast<3, number> = [1, 2, 3, 4, 5]; // valid
// @ts-expect-error
const example3: TupleOfAtLeast<3, number> = [1, 2]; // invalid

----------------------------------------

TITLE: Implementing Deferred.succeed Function in TypeScript
DESCRIPTION: The succeed function completes a Deferred with a specified value. It has two overloads: one that takes a value and returns a function expecting a Deferred, and another that takes both the Deferred and the value directly. Both return an Effect of boolean.

LANGUAGE: typescript
CODE:
declare const succeed: {
  <A>(value: A): <E>(self: Deferred<A, E>) => Effect.Effect<boolean>;
  <A, E>(self: Deferred<A, E>, value: A): Effect.Effect<boolean>;
}

----------------------------------------

TITLE: Declaring TestAnnotation for Ignored Tests in TypeScript
DESCRIPTION: Declares a constant 'ignored' of type TestAnnotation<number> used to count ignored tests. This annotation is part of the TestAnnotation module in the Effect package.

LANGUAGE: typescript
CODE:
declare const ignored: TestAnnotation<number>

----------------------------------------

TITLE: Creating SubscriptionRef in TypeScript
DESCRIPTION: The make function creates a new SubscriptionRef with the specified value. It returns an Effect that produces a SubscriptionRef<A> where A is the type of the initial value.

LANGUAGE: typescript
CODE:
declare const make: <A>(value: A) => Effect.Effect<SubscriptionRef<A>>

----------------------------------------

TITLE: Creating Layer from System's Local Time Zone in TypeScript
DESCRIPTION: This snippet defines the layerCurrentZoneLocal constant, which creates a Layer from the system's local time zone. It uses the Layer type from the effect package and is parameterized with CurrentTimeZone.

LANGUAGE: typescript
CODE:
declare const layerCurrentZoneLocal: Layer.Layer<CurrentTimeZone, never, never>

----------------------------------------

TITLE: Adding Fiber to FiberSet in TypeScript
DESCRIPTION: The 'add' function is used to add a fiber to the FiberSet. It takes a RuntimeFiber and optional propagation settings as parameters. The fiber is automatically removed from the set upon completion.

LANGUAGE: typescript
CODE:
declare const add: { <A, E, XE extends E, XA extends A>(fiber: Fiber.RuntimeFiber<XA, XE>, options?: { readonly propagateInterruption?: boolean | undefined; } | undefined): (self: FiberSet<A, E>) => Effect.Effect<void>; <A, E, XE extends E, XA extends A>(self: FiberSet<A, E>, fiber: Fiber.RuntimeFiber<XA, XE>, options?: { readonly propagateInterruption?: boolean | undefined; } | undefined): Effect.Effect<void>; }

----------------------------------------

TITLE: List.prependAll Function Signature
DESCRIPTION: Type declaration for the prependAll function showing its polymorphic nature and handling of different list types including non-empty lists (Cons).

LANGUAGE: typescript
CODE:
declare const prependAll: { <S extends List<any>, T extends List<any>>(that: T): (self: S) => List.OrNonEmpty<S, T, List.Infer<S> | List.Infer<T>>; <A, B>(self: List<A>, that: Cons<B>): Cons<A | B>; <A, B>(self: Cons<A>, that: List<B>): Cons<A | B>; <A, B>(self: List<A>, that: List<B>): List<A | B>; }

----------------------------------------

TITLE: Removing Duplicates with Custom Equivalence in TypeScript Arrays
DESCRIPTION: The Array.dedupeWith function removes duplicates from an Iterable using a provided isEquivalent function. It preserves the order of the first occurrence of each element. This function works with various types of Iterables and Arrays.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const result = Array.dedupeWith([1, 2, 2, 3, 3, 3], (a, b) => a === b)
console.log(result) // [1, 2, 3]

LANGUAGE: typescript
CODE:
declare const dedupeWith: { <S extends Iterable<any>>(isEquivalent: (self: ReadonlyArray.Infer<S>, that: ReadonlyArray.Infer<S>) => boolean): (self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S>>; <A>(self: NonEmptyReadonlyArray<A>, isEquivalent: (self: A, that: A) => boolean): NonEmptyArray<A>; <A>(self: Iterable<A>, isEquivalent: (self: A, that: A) => boolean): Array<A>; }

----------------------------------------

TITLE: Defining TMap.transform Function in TypeScript
DESCRIPTION: Declares the transform function for TMap, which atomically updates all bindings using a pure function. It can be used in two ways: by passing the function first, or by passing the TMap instance first.

LANGUAGE: typescript
CODE:
declare const transform: { <K, V>(f: (key: K, value: V) => readonly [K, V]): (self: TMap<K, V>) => STM.STM<void>; <K, V>(self: TMap<K, V>, f: (key: K, value: V) => readonly [K, V]): STM.STM<void>; }

----------------------------------------

TITLE: Stream Run Function Signature in TypeScript
DESCRIPTION: Type definition for the run function that processes a stream using a sink. The function is overloaded to accept parameters in different orders and handles generic types for stream elements, errors, and environment requirements. It returns an Effect that produces either the sink's result or an error.

LANGUAGE: typescript
CODE:
declare const run: { 
  <A2, A, E2, R2>(sink: Sink.Sink<A2, A, unknown, E2, R2>): 
    <E, R>(self: Stream<A, E, R>) => Effect.Effect<A2, E2 | E, Exclude<R | R2, Scope.Scope>>; 
  <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, sink: Sink.Sink<A2, A, unknown, E2, R2>): 
    Effect.Effect<A2, E | E2, Exclude<R | R2, Scope.Scope>>; 
}

----------------------------------------

TITLE: Defining Uncapitalized String Validation in TypeScript Schema
DESCRIPTION: Type definition for a validation function that verifies if a string is uncapitalized. The function accepts optional annotations and returns a filter that can be applied to schema validations.

LANGUAGE: typescript
CODE:
declare const uncapitalized: <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>

----------------------------------------

TITLE: Implementing mapOrFail Configuration Transform in TypeScript
DESCRIPTION: Defines a function that transforms a Config<A> into a Config<B> using a provided fallible mapping function. The transformation can either succeed with a new value or fail with a ConfigError.

LANGUAGE: typescript
CODE:
declare const mapOrFail: { <A, B>(f: (a: A) => Either.Either<B, ConfigError.ConfigError>): (self: Config<A>) => Config<B>; <A, B>(self: Config<A>, f: (a: A) => Either.Either<B, ConfigError.ConfigError>): Config<B>; }

----------------------------------------

TITLE: Converting Option to Array in TypeScript using Effect
DESCRIPTION: Demonstrates how to convert an Option type to an Array using Option.toArray. When given Some(value), returns a single-element array containing the value. When given None, returns an empty array.

LANGUAGE: typescript
CODE:
import { Option } from "effect"

console.log(Option.toArray(Option.some(1)))
// Output: [1]

console.log(Option.toArray(Option.none()))
// Output: []

LANGUAGE: typescript
CODE:
declare const toArray: <A>(self: Option<A>) => Array<A>

----------------------------------------

TITLE: Defining zipLeft Function for Channel Composition in TypeScript
DESCRIPTION: Declares the zipLeft function for sequential composition of channels. It returns a new channel that combines the current channel with a specified channel, terminating with the terminal value of the current channel. The function supports both curried and non-curried forms, with an optional concurrent parameter.

LANGUAGE: typescript
CODE:
declare const zipLeft: { <OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(that: Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>, options?: { readonly concurrent?: boolean | undefined; } | undefined): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1 | OutElem, InElem & InElem1, OutErr1 | OutErr, InErr & InErr1, OutDone, InDone & InDone1, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, that: Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>, options?: { readonly concurrent?: boolean | undefined; } | undefined): Channel<OutElem | OutElem1, InElem & InElem1, OutErr | OutErr1, InErr & InErr1, OutDone, InDone & InDone1, Env | Env1>; }

----------------------------------------

TITLE: Reversing Elements in a Chunk using Effect Library in TypeScript
DESCRIPTION: This snippet demonstrates how to use the Chunk.reverse function to reverse the order of elements in a Chunk. It creates a Chunk with three elements, reverses it, and logs the result.

LANGUAGE: typescript
CODE:
import { Chunk } from "effect"

const chunk = Chunk.make(1, 2, 3)
const result = Chunk.reverse(chunk)

console.log(result)
// { _id: 'Chunk', values: [ 3, 2, 1 ] }

----------------------------------------

TITLE: Using Doc.tupled to Format Array Elements in TypeScript
DESCRIPTION: This example demonstrates how to use the Doc.tupled function to format an array of numbers as a parenthesized, comma-separated list. It includes importing necessary modules, creating a document, and rendering it.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"

const doc = Doc.tupled(
  ["1", "20", "300", "4000"].map(
    (n) => (n.length === 1 ? Doc.char(n) : Doc.text(n))
  )
)

assert.strictEqual(
  Doc.render(doc, { style: "pretty" }),
  "(1, 20, 300, 4000)"
)

----------------------------------------

TITLE: Comparing BigDecimal Values in TypeScript
DESCRIPTION: Demonstrates how to use the lessThanOrEqualTo function to compare BigDecimal values. The function checks if one BigDecimal is less than or equal to another.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { lessThanOrEqualTo, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(lessThanOrEqualTo(unsafeFromString("2"), unsafeFromString("3")), true)
assert.deepStrictEqual(lessThanOrEqualTo(unsafeFromString("3"), unsafeFromString("3")), true)
assert.deepStrictEqual(lessThanOrEqualTo(unsafeFromString("4"), unsafeFromString("3")), false)

----------------------------------------

TITLE: TypeScript Function Signature for Record.pop
DESCRIPTION: This code snippet shows the TypeScript function signature for the Record.pop function, detailing its polymorphic nature and return type.

LANGUAGE: typescript
CODE:
declare const pop: { <K extends string | symbol, X extends K>(key: X): <A>(self: ReadonlyRecord<K, A>) => Option.Option<[A, Record<Exclude<K, X>, A>]>; <K extends string | symbol, A, X extends K>(self: ReadonlyRecord<K, A>, key: X): Option.Option<[A, Record<Exclude<K, X>, A>]>; }

----------------------------------------

TITLE: Defining ANSI Cursor Position Restoration - TypeScript
DESCRIPTION: Declares a constant for restoring the cursor position along with shift state and formatting attributes in ANSI terminals. If no previous save exists, it resets to default values.

LANGUAGE: typescript
CODE:
declare const cursorRestorePosition: Ansi

----------------------------------------

TITLE: Retrieving Sorted Keys from Trie - TypeScript Example
DESCRIPTION: Demonstrates how to create a Trie, insert multiple key-value pairs, and retrieve all keys in alphabetical order using the keys() function. The example shows that keys are returned sorted regardless of insertion order.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Trie } from "effect"

const trie = Trie.empty<number>().pipe(
  Trie.insert("cab", 0),
  Trie.insert("abc", 1),
  Trie.insert("bca", 2)
)

const result = Array.from(Trie.keys(trie))
assert.deepStrictEqual(result, ["abc", "bca", "cab"])

----------------------------------------

TITLE: Declaring Schedule.intersect Function in TypeScript
DESCRIPTION: Defines the 'intersect' function for combining two schedules. It creates a new schedule that continues only when both input schedules allow, using the longer delay. The function returns a tuple of both schedules' outputs and accepts inputs compatible with both schedules.

LANGUAGE: TypeScript
CODE:
declare const intersect: { <Out2, In2, R2>(that: Schedule<Out2, In2, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<[Out, Out2], In & In2, R2 | R>; <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>): Schedule<[Out, Out2], In & In2, R | R2>; }

----------------------------------------

TITLE: Creating Redacted Text Arguments in Effect CLI
DESCRIPTION: Function signature for creating a redacted text argument with optional configuration. The function accepts an optional BaseArgsConfig parameter and returns an Args instance of type Redacted. This is useful for handling sensitive text input that should be redacted in logs or output.

LANGUAGE: typescript
CODE:
declare const redacted: (config?: Args.BaseArgsConfig) => Args<Redacted>

----------------------------------------

TITLE: Interrupting Deferred Operations in TypeScript Effect
DESCRIPTION: Method that completes a Deferred with interruption. When called, it interrupts all fibers waiting on the Deferred's value using the FiberId of the calling fiber. Returns an Effect containing a boolean value.

LANGUAGE: typescript
CODE:
declare const interrupt: <A, E>(self: Deferred<A, E>) => Effect.Effect<boolean>

----------------------------------------

TITLE: Defining Effect.allowInterrupt Function in TypeScript
DESCRIPTION: Declaration of the allowInterrupt function that checks for and allows fiber self-interruption. It returns an Effect with void return type and never types for both error and environment parameters, indicating it cannot fail and requires no specific environment.

LANGUAGE: typescript
CODE:
declare const allowInterrupt: Effect<void, never, never>

----------------------------------------

TITLE: Retrieving Metric Labels in Effect TypeScript Module
DESCRIPTION: Defines a constant metricLabels that returns an Effect containing an array of metric labels from the current scope. The Effect never fails and requires no environment.

LANGUAGE: typescript
CODE:
declare const metricLabels: Effect<ReadonlyArray<MetricLabel.MetricLabel>, never, never>

----------------------------------------

TITLE: Retrieving Primitive Type Name in TypeScript
DESCRIPTION: The getTypeName function returns a string representation of the primitive type. It takes a Primitive<A> as input and returns a string.

LANGUAGE: typescript
CODE:
declare const getTypeName: <A>(self: Primitive<A>) => string

----------------------------------------

TITLE: Defining mapInput Function for Metric Transformation in TypeScript
DESCRIPTION: The mapInput function returns a new metric that is powered by an existing one, but accepts updates of a new type. It requires a transformation function from the new input type to the original input type. This function can be used in two ways: by passing the transformation function first, or by passing the metric first.

LANGUAGE: typescript
CODE:
declare const mapInput: { <In, In2>(f: (input: In2) => In): <Type, Out>(self: Metric<Type, In, Out>) => Metric<Type, In2, Out>; <Type, In, Out, In2>(self: Metric<Type, In, Out>, f: (input: In2) => In): Metric<Type, In2, Out>; }

----------------------------------------

TITLE: Checking Transaction Success Status in TypeScript STM
DESCRIPTION: Function that determines whether a transactional effect represents a success state. Takes an STM instance and returns a new STM containing a boolean value indicating success, without the possibility of failure.

LANGUAGE: typescript
CODE:
declare const isSuccess: <A, E, R>(self: STM<A, E, R>) => STM<boolean, never, R>

----------------------------------------

TITLE: Defining orElseEither Function Signature in TypeScript
DESCRIPTION: This code snippet defines the type signature for the orElseEither function. It shows two overloads: one for curried usage and another for direct usage. The function takes an Option and a lazy fallback Option, returning an Option of Either.

LANGUAGE: typescript
CODE:
declare const orElseEither: { <B>(that: LazyArg<Option<B>>): <A>(self: Option<A>) => Option<Either<B, A>>; <A, B>(self: Option<A>, that: LazyArg<Option<B>>): Option<Either<B, A>>; }

----------------------------------------

TITLE: Type Signature for Doc.cats Function
DESCRIPTION: TypeScript type declaration for the cats combinator function, showing it accepts an Iterable of Doc<A> and returns a Doc<A>.

LANGUAGE: typescript
CODE:
declare const cats: <A>(docs: Iterable<Doc<A>>) => Doc<A>

----------------------------------------

TITLE: Defining DateTime.Utc Schema in Effect SQL
DESCRIPTION: Declares a constant Date type that represents a schema for DateTime.Utc values serialized as YYYY-MM-DD format strings.

LANGUAGE: typescript
CODE:
declare const Date: Date

----------------------------------------

TITLE: Declaring Double Quote Document Constant in TypeScript
DESCRIPTION: Defines a constant Doc type that represents a single double quote character in the document printing system. The Doc type parameter <never> indicates this document contains no annotations.

LANGUAGE: typescript
CODE:
declare const dquote: Doc<never>

----------------------------------------

TITLE: Implementing Atomic Reduction with TArray.reduce in TypeScript
DESCRIPTION: This function atomically folds elements of a TArray using a pure function. It takes an initial value, a folding function, and the TArray as inputs, and returns an STM (Software Transactional Memory) operation that produces the final result.

LANGUAGE: typescript
CODE:
declare const reduce: { <Z, A>(zero: Z, f: (accumulator: Z, current: A) => Z): (self: TArray<A>) => STM.STM<Z>; <Z, A>(self: TArray<A>, zero: Z, f: (accumulator: Z, current: A) => Z): STM.STM<Z>; }

----------------------------------------

TITLE: Option.filter Function Signature in TypeScript
DESCRIPTION: Provides the TypeScript signature for the Option.filter function. It includes overloads for different use cases, including refinements and predicates.

LANGUAGE: typescript
CODE:
declare const filter: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: Option<A>) => Option<B>; <A>(predicate: Predicate<NoInfer<A>>): (self: Option<A>) => Option<A>; <A, B extends A>(self: Option<A>, refinement: Refinement<A, B>): Option<B>; <A>(self: Option<A>, predicate: Predicate<A>): Option<A>; }

----------------------------------------

TITLE: Type Guard Implementation for NeverFlat Type in TypeScript
DESCRIPTION: Implements a type guard function that checks if a given Flatten<A> instance is specifically a NeverFlat<A>. This function is useful for runtime type checking and conditional logic based on Flatten variants.

LANGUAGE: typescript
CODE:
declare const isNeverFlat: <A>(a: Flatten<A>) => a is NeverFlat<A>

----------------------------------------

TITLE: Constructing Data Source from Effectual Function in TypeScript
DESCRIPTION: The fromEffect function creates a RequestResolver from an effectual function. It takes a function that transforms a Request into an Effect and returns a RequestResolver. The function handles generic types for the request, success, error, and environment.

LANGUAGE: typescript
CODE:
declare const fromEffect: <R, A extends Request.Request<any, any>>(f: (a: A) => Effect.Effect<Request.Request.Success<A>, Request.Request.Error<A>, R>) => RequestResolver<A, R>

----------------------------------------

TITLE: Defining zipWith Function for Schedule Module in TypeScript
DESCRIPTION: Declares the zipWith function, which is equivalent to 'intersect' followed by 'map'. It takes two schedules and a combining function to create a new schedule.

LANGUAGE: typescript
CODE:
declare const zipWith: { <Out2, In2, R2, Out, Out3>(that: Schedule<Out2, In2, R2>, f: (out: Out, out2: Out2) => Out3): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out3, In & In2, R2 | R>; <Out, In, R, Out2, In2, R2, Out3>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>, f: (out: Out, out2: Out2) => Out3): Schedule<Out3, In & In2, R | R2>; }

----------------------------------------

TITLE: Creating Stream from Chunk - TypeScript Example
DESCRIPTION: Demonstrates how to create a Stream from a Chunk of values using Stream.fromChunk. The example shows creating a stream with numeric values and collecting the results.

LANGUAGE: typescript
CODE:
import { Chunk, Effect, Stream } from "effect"

// Creating a stream with values from a single Chunk
const stream = Stream.fromChunk(Chunk.make(1, 2, 3))

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 1, 2, 3 ] }

----------------------------------------

TITLE: Defining Doc.colon Constant in TypeScript
DESCRIPTION: Declares a constant representing a single colon character in document formatting. The type parameter never indicates this Doc has no additional type parameters.

LANGUAGE: typescript
CODE:
declare const colon: Doc<never>

----------------------------------------

TITLE: Demonstrating Either.getRight Usage in TypeScript
DESCRIPTION: This code snippet demonstrates how to use the Either.getRight function to convert an Either to an Option, discarding the Left value. It shows examples with both Right and Left cases.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Either, Option } from "effect"

assert.deepStrictEqual(Either.getRight(Either.right('ok')), Option.some('ok'))
assert.deepStrictEqual(Either.getRight(Either.left('err')), Option.none())

----------------------------------------

TITLE: Defining Left Bracket Document Constant in TypeScript
DESCRIPTION: Declares a constant representing a document containing a single '[' character. The type parameter <never> indicates this document doesn't contain any annotations.

LANGUAGE: typescript
CODE:
declare const lbracket: Doc<never>

----------------------------------------

TITLE: Comparing Numbers with greaterThan Function in Effect Library (TypeScript)
DESCRIPTION: The greaterThan function returns true if the first argument is greater than the second, otherwise false. It can be used with both curried and non-curried syntax.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { greaterThan } from "effect/Number"

assert.deepStrictEqual(greaterThan(2, 3), false)
assert.deepStrictEqual(greaterThan(3, 3), false)
assert.deepStrictEqual(greaterThan(4, 3), true)

LANGUAGE: typescript
CODE:
declare const greaterThan: { (that: number): (self: number) => boolean; (self: number, that: number): boolean; }

----------------------------------------

TITLE: Creating Context with Single Service in TypeScript
DESCRIPTION: Demonstrates how to use Context.make to create a new Context with a single service associated to a tag. It shows the creation of a Port tag, making a Context with this tag, and then retrieving the service from the Context.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Context } from "effect"

const Port = Context.GenericTag<{ PORT: number }>("Port")

const Services = Context.make(Port, { PORT: 8080 })

assert.deepStrictEqual(Context.get(Services, Port), { PORT: 8080 })

----------------------------------------

TITLE: Creating HashSet from Another HashSet in TypeScript
DESCRIPTION: Shows how to create a new HashSet from an existing HashSet using the Iterable interface implementation.

LANGUAGE: typescript
CODE:
import { HashSet, pipe } from "effect"

console.log(
  pipe(
    // since HashSet implements the Iterable interface, we can use it to create a new HashSet
    HashSet.make(1, 2, 3, 4),
    HashSet.fromIterable,
    HashSet.toValues // turns the HashSet back into an array
  )
) // Output: [1, 2, 3, 4]

----------------------------------------

TITLE: Option.match Type Definition
DESCRIPTION: Type signature for the Option.match function showing its polymorphic nature and support for different return types for Some and None cases.

LANGUAGE: typescript
CODE:
declare const match: { <B, A, C = B>(options: { readonly onNone: LazyArg<B>; readonly onSome: (a: A) => C; }): (self: Option<A>) => B | C; <A, B, C = B>(self: Option<A>, options: { readonly onNone: LazyArg<B>; readonly onSome: (a: A) => C; }): B | C; }

----------------------------------------

TITLE: Accessing Optional Context Services in TypeScript
DESCRIPTION: Function declaration for serviceOption that takes a Context.Tag parameter and returns a Micro wrapped Option of the service. Used to optionally access services from the environment without tracking dependencies at the type level.

LANGUAGE: typescript
CODE:
declare const serviceOption: <I, S>(tag: Context.Tag<I, S>) => Micro<Option.Option<S>>

----------------------------------------

TITLE: Transforming Stream Chunks with Effects in TypeScript
DESCRIPTION: A function that effectfully transforms chunks emitted by a stream. It takes a transformation function that converts chunks of type A to Effect-wrapped chunks of type B, and returns a new stream with transformed chunks.

LANGUAGE: typescript
CODE:
declare const mapChunksEffect: { <A, B, E2, R2>(f: (chunk: Chunk.Chunk<A>) => Effect.Effect<Chunk.Chunk<B>, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<B, E2 | E, R2 | R>; <A, E, R, B, E2, R2>(self: Stream<A, E, R>, f: (chunk: Chunk.Chunk<A>) => Effect.Effect<Chunk.Chunk<B>, E2, R2>): Stream<B, E | E2, R | R2>; }

----------------------------------------

TITLE: Defining Schedule.delayed Function in TypeScript
DESCRIPTION: TypeScript type declaration for the Schedule.delayed function. This function takes a delay transformation function and a schedule, returning a modified schedule with transformed delays. It supports both curried and uncurried function calls.

LANGUAGE: typescript
CODE:
declare const delayed: { 
  (f: (duration: Duration.Duration) => Duration.DurationInput): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; 
  <Out, In, R>(self: Schedule<Out, In, R>, f: (duration: Duration.Duration) => Duration.DurationInput): Schedule<Out, In, R>; 
}

----------------------------------------

TITLE: Using BigDecimal.abs Function in TypeScript
DESCRIPTION: Demonstrates how to use the abs function to calculate absolute values of BigDecimal numbers. The function takes a BigDecimal input and returns its absolute value, removing any negative sign while preserving the magnitude.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { abs, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(abs(unsafeFromString("-5")), unsafeFromString("5"))
assert.deepStrictEqual(abs(unsafeFromString("0")), unsafeFromString("0"))
assert.deepStrictEqual(abs(unsafeFromString("5")), unsafeFromString("5"))

LANGUAGE: typescript
CODE:
declare const abs: (n: BigDecimal) => BigDecimal

----------------------------------------

TITLE: Type Signature for Effect.clock in TypeScript
DESCRIPTION: This code block shows the type signature for the Effect.clock function. It returns an Effect that provides the Clock.Clock service with no requirements or errors.

LANGUAGE: typescript
CODE:
declare const clock: Effect<Clock.Clock, never, never>

----------------------------------------

TITLE: Defining filterOrFail Function Signature in TypeScript
DESCRIPTION: Type declaration for the filterOrFail function that filters effects with a predicate or refinement, failing with a specified error if the predicate fails. The function supports both curried and uncurried forms, allowing type refinement of the success channel.

LANGUAGE: typescript
CODE:
declare const filterOrFail: { 
  <A, B extends A, E2>(refinement: Refinement<A, B>, orFailWith: (a: NoInfer<A>) => E2): <E, R>(self: Micro<A, E, R>) => Micro<B, E2 | E, R>; 
  <A, E2>(predicate: Predicate<NoInfer<A>>, orFailWith: (a: NoInfer<A>) => E2): <E, R>(self: Micro<A, E, R>) => Micro<A, E2 | E, R>; 
  <A, E, R, B extends A, E2>(self: Micro<A, E, R>, refinement: Refinement<A, B>, orFailWith: (a: A) => E2): Micro<B, E | E2, R>; 
  <A, E, R, E2>(self: Micro<A, E, R>, predicate: Predicate<A>, orFailWith: (a: A) => E2): Micro<A, E | E2, R>; 
}

----------------------------------------

TITLE: Using getPartUtc Function in Effect's DateTime Module (TypeScript)
DESCRIPTION: This snippet demonstrates how to use the getPartUtc function from the DateTime module to extract a specific part (year in this case) from a DateTime object in UTC timezone.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { DateTime } from "effect"

const now = DateTime.unsafeMake({ year: 2024 })
const year = DateTime.getPartUtc(now, "year")
assert.strictEqual(year, 2024)

----------------------------------------

TITLE: Creating Layer from IANA Time Zone in TypeScript
DESCRIPTION: The layerCurrentZoneNamed function creates a Layer from a given IANA time zone identifier. It returns a Layer that resolves to a CurrentTimeZone, with potential IllegalArgumentException errors.

LANGUAGE: typescript
CODE:
declare const layerCurrentZoneNamed: (zoneId: string) => Layer.Layer<CurrentTimeZone, IllegalArgumentException>

----------------------------------------

TITLE: Transforming Chunk Elements with FilterMapWhile in TypeScript
DESCRIPTION: The filterMapWhile function transforms elements of a chunk as long as the specified function returns some value. It takes a function that maps elements to an Option<B> and applies it to each element of the chunk until a None is encountered.

LANGUAGE: typescript
CODE:
declare const filterMapWhile: { <A, B>(f: (a: A) => Option<B>): (self: Chunk<A>) => Chunk<B>; <A, B>(self: Chunk<A>, f: (a: A) => Option<B>): Chunk<B>; }

----------------------------------------

TITLE: Executing Workflows with Custom Clock in Effect Module (TypeScript)
DESCRIPTION: The withClock function allows executing a specified workflow with a custom implementation of the Clock service. It can be used in two ways: either by providing the clock first and then the effect, or by providing the effect first and then the clock.

LANGUAGE: typescript
CODE:
declare const withClock: { <C extends Clock.Clock>(clock: C): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <C extends Clock.Clock, A, E, R>(effect: Effect<A, E, R>, clock: C): Effect<A, E, R>; }

----------------------------------------

TITLE: Implementing takeSome Function for TMap in TypeScript
DESCRIPTION: Defines the takeSome function which takes matching values from a TMap, or retries until at least one value is found. It accepts a predicate function and returns an STM (Software Transactional Memory) operation that yields an array with at least one element.

LANGUAGE: typescript
CODE:
declare const takeSome: {
  <K, V, A>(pf: (key: K, value: V) => Option.Option<A>): (self: TMap<K, V>) => STM.STM<[A, ...Array<A>]>;
  <K, V, A>(self: TMap<K, V>, pf: (key: K, value: V) => Option.Option<A>): STM.STM<[A, ...Array<A>]>;
}

----------------------------------------

TITLE: Extracting Primary Defect from Cause in TypeScript
DESCRIPTION: The squash function reduces a Cause to a single, prioritized defect. It evaluates the Cause in order of priority: failures, defects, and interruptions. This function is useful for simplifying error reporting or logging in complex scenarios.

LANGUAGE: TypeScript
CODE:
declare const squash: <E>(self: Cause<E>) => unknown

----------------------------------------

TITLE: Implementing Channel.failCause in TypeScript
DESCRIPTION: Function signature for creating a channel that fails immediately with a specified Cause. Takes a Cause parameter of type E and returns a Channel that represents an immediate failure.

LANGUAGE: typescript
CODE:
declare const failCause: <E>(cause: Cause.Cause<E>) => Channel<never, unknown, E, unknown, never, unknown>

----------------------------------------

TITLE: Demonstrating Option.tap Usage in TypeScript
DESCRIPTION: This example shows how to use the Option.tap function with different inputs, including None, Some with an integer, and Some with a non-integer.

LANGUAGE: typescript
CODE:
import { Option } from "effect"

const getInteger = (n: number) => Number.isInteger(n) ? Option.some(n) : Option.none()

console.log(Option.tap(Option.none(), getInteger))
// Output: { _id: 'Option', _tag: 'None' }

console.log(Option.tap(Option.some(1), getInteger))
// Output: { _id: 'Option', _tag: 'Some', value: 1 }

console.log(Option.tap(Option.some(1.14), getInteger))
// Output: { _id: 'Option', _tag: 'None' }

----------------------------------------

TITLE: Filtering Right Values in Either Type with TypeScript
DESCRIPTION: Demonstrates how to use the filterOrLeft function to filter the right value of an Either type. If the predicate fails, it sets the left value with the result of the provided function.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { pipe, Either } from "effect"

const isPositive = (n: number): boolean => n > 0

assert.deepStrictEqual(
  pipe(
    Either.right(1),
    Either.filterOrLeft(isPositive, n => `${n} is not positive`)
  ),
  Either.right(1)
)
assert.deepStrictEqual(
  pipe(
    Either.right(0),
    Either.filterOrLeft(isPositive, n => `${n} is not positive`)
  ),
  Either.left("0 is not positive")
)

----------------------------------------

TITLE: Creating Equivalence for Records in TypeScript
DESCRIPTION: The getEquivalence function creates an Equivalence for records using the provided Equivalence for values. It takes an Equivalence<A> as input and returns an Equivalence for ReadonlyRecord<K, A>.

LANGUAGE: typescript
CODE:
declare const getEquivalence: <K extends string, A>(equivalence: Equivalence<A>) => Equivalence<ReadonlyRecord<K, A>>

----------------------------------------

TITLE: Defining FlatAlt Interface in TypeScript
DESCRIPTION: TypeScript interface definition for FlatAlt that extends Doc.Variance<A>. It contains a _tag property identifying it as "FlatAlt" and two Doc<A> properties (left and right) representing alternative document layouts. The layout algorithms will use the left document by default, but prefer the right document when flattened via grouping.

LANGUAGE: typescript
CODE:
export interface FlatAlt<A> extends Doc.Variance<A> {
  readonly _tag: "FlatAlt"
  readonly left: Doc<A>
  readonly right: Doc<A>
}

----------------------------------------

TITLE: TypeScript Function Signature for OpenApi.fromApi
DESCRIPTION: This code snippet shows the TypeScript function signature for the OpenApi.fromApi function. It details the input parameters and return type, including the options for controlling additional properties handling.

LANGUAGE: typescript
CODE:
declare const fromApi: <Id extends string, Groups extends HttpApiGroup.Any, E, R>(api: HttpApi.HttpApi<Id, Groups, E, R>, options?: { readonly additionalPropertiesStrategy?: AdditionalPropertiesStrategy | undefined; } | undefined) => OpenAPISpec

----------------------------------------

TITLE: Retrieving Keys from RedBlackTree in TypeScript
DESCRIPTION: This function returns an IterableIterator of all keys present in the RedBlackTree in order. It takes a RedBlackTree instance as input and works with generic key and value types.

LANGUAGE: typescript
CODE:
declare const keys: <K, V>(self: RedBlackTree<K, V>) => IterableIterator<K>

----------------------------------------

TITLE: Transforming Tuple Elements with Tuple.map in TypeScript
DESCRIPTION: Demonstrates how to use the Tuple.map function to transform each element of a tuple using a given function. The example shows converting elements to uppercase strings.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { pipe, Tuple } from "effect"

const result = pipe(
  ["a", 1, false] as const,
  Tuple.map((el) => el.toString().toUpperCase())
)
assert.deepStrictEqual(result, ['A', '1', 'FALSE'])

----------------------------------------

TITLE: Merging Annotations in SchemaAST for TypeScript
DESCRIPTION: The annotations function merges a set of new annotations with existing ones in an Abstract Syntax Tree (AST), potentially overwriting any duplicates. It takes two parameters: the existing AST and an object containing new annotations to be merged.

LANGUAGE: typescript
CODE:
declare const annotations: (ast: AST, overrides: Annotations) => AST

----------------------------------------

TITLE: Retrieving Trie Size in TypeScript using Effect Library
DESCRIPTION: Demonstrates how to get the number of entries in a Trie data structure using the size method. The example shows creating a Trie with two entries and checking its size.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Trie } from "effect"

const trie = Trie.empty<number>().pipe(
  Trie.insert("a", 0),
  Trie.insert("b", 1)
)

assert.equal(Trie.size(trie), 2)

LANGUAGE: typescript
CODE:
declare const size: <V>(self: Trie<V>) => number

----------------------------------------

TITLE: Defining onDecision Function for Schedule Enhancement in TypeScript
DESCRIPTION: Declares the onDecision function, which takes a schedule and an effect function to be executed on each decision. It returns a new schedule that incorporates the additional effect. The function is overloaded to allow for different parameter orders.

LANGUAGE: typescript
CODE:
declare const onDecision: { <Out, X, R2>(f: (out: Out, decision: ScheduleDecision.ScheduleDecision) => Effect.Effect<X, never, R2>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>; <Out, In, R, X, R2>(self: Schedule<Out, In, R>, f: (out: Out, decision: ScheduleDecision.ScheduleDecision) => Effect.Effect<X, never, R2>): Schedule<Out, In, R | R2>; }

----------------------------------------

TITLE: Testing BigInt Type with isBigInt Function
DESCRIPTION: A type guard function that tests whether a given value is a bigint. It returns true for bigint values and false for all other types.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { isBigInt } from "effect/BigInt"

assert.deepStrictEqual(isBigInt(1n), true)
assert.deepStrictEqual(isBigInt(1), false)

LANGUAGE: typescript
CODE:
declare const isBigInt: (u: unknown) => u is bigint

----------------------------------------

TITLE: Function Signature for filterEffectOrFail
DESCRIPTION: TypeScript type declaration showing the function signature for filterEffectOrFail, including its generic type parameters and options object structure.

LANGUAGE: typescript
CODE:
declare const filterEffectOrFail: { <A, E2, R2, E3>(options: { readonly predicate: (a: NoInfer<A>) => Effect<boolean, E2, R2>; readonly orFailWith: (a: NoInfer<A>) => E3; }): <E, R>(self: Effect<A, E, R>) => Effect<A, E | E2 | E3, R | R2>; <A, E, R, E2, R2, E3>(self: Effect<A, E, R>, options: { readonly predicate: (a: A) => Effect<boolean, E2, R2>; readonly orFailWith: (a: A) => E3; }): Effect<A, E | E2 | E3, R | R2>; }

----------------------------------------

TITLE: Implementing Input Collection Schedule in TypeScript Effect
DESCRIPTION: Defines a schedule that continuously collects all received inputs into a Chunk data structure. The schedule never terminates and appends each new input to the accumulated collection. Useful for scenarios like logging, tracking retry attempts, or gathering data for batch processing.

LANGUAGE: typescript
CODE:
declare const collectAllInputs: <A>() => Schedule<Chunk.Chunk<A>, A>

----------------------------------------

TITLE: Implementing Exit.mapBoth Function in TypeScript
DESCRIPTION: Defines a function that maps over both Success and Failure cases of an Exit type. It takes mapping functions for both success and failure cases and returns a new Exit with transformed values. The function supports both curried and uncurried calling patterns.

LANGUAGE: typescript
CODE:
declare const mapBoth: {
  <E, A, E2, A2>(options: {
    readonly onFailure: (e: E) => E2;
    readonly onSuccess: (a: A) => A2;
  }): (self: Exit<A, E>) => Exit<A2, E2>;
  <A, E, E2, A2>(
    self: Exit<A, E>,
    options: {
      readonly onFailure: (e: E) => E2;
      readonly onSuccess: (a: A) => A2;
    }
  ): Exit<A2, E2>;
}

----------------------------------------

TITLE: TypeScript Signature for Record.separate Function
DESCRIPTION: Provides the TypeScript type signature for the Record.separate function, showing its input and output types.

LANGUAGE: typescript
CODE:
declare const separate: <K extends string, A, B>(self: ReadonlyRecord<K, Either<B, A>>) => [Record<ReadonlyRecord.NonLiteralKey<K>, A>, Record<ReadonlyRecord.NonLiteralKey<K>, B>]

----------------------------------------

TITLE: Implementing Schedule Reset Functionality in TypeScript
DESCRIPTION: Defines a function that creates a new schedule which automatically resets to its initial state after a specified duration of inactivity. The function accepts a duration parameter and can be applied to any existing schedule.

LANGUAGE: typescript
CODE:
declare const resetAfter: { 
  (duration: Duration.DurationInput): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; 
  <Out, In, R>(self: Schedule<Out, In, R>, duration: Duration.DurationInput): Schedule<Out, In, R>; 
}

----------------------------------------

TITLE: Filtering Optional Values in Effect Chunk Module
DESCRIPTION: Implementation signature for the compact function that filters out optional values from a Chunk data structure. Takes a Chunk containing Option<A> values and returns a new Chunk containing only the defined values of type A.

LANGUAGE: typescript
CODE:
declare const compact: <A>(self: Chunk<Option<A>>) => Chunk<A>

----------------------------------------

TITLE: Running Channel Operations in TypeScript using Effect Library
DESCRIPTION: Function signature for running a Channel until completion. Takes a Channel instance with generic type parameters for input/output errors and completion values, returning an Effect that resolves to the output completion value or fails with output error.

LANGUAGE: typescript
CODE:
declare const run: <OutErr, InErr, OutDone, InDone, Env>(self: Channel<never, unknown, OutErr, InErr, OutDone, InDone, Env>) => Effect.Effect<OutDone, OutErr, Env>

----------------------------------------

TITLE: Function Signature for removeTime in TypeScript
DESCRIPTION: Shows the TypeScript function signature for the removeTime function in the DateTime module. It takes a DateTime object as input and returns a Utc object.

LANGUAGE: typescript
CODE:
declare const removeTime: (self: DateTime) => Utc

----------------------------------------

TITLE: Type Signature for Struct.omit in TypeScript
DESCRIPTION: This code block provides the type signature for the Struct.omit function. It shows the function's polymorphic nature, allowing for both curried and non-curried usage with type inference.

LANGUAGE: typescript
CODE:
declare const omit: { <Keys extends Array<PropertyKey>>(...keys: Keys): <S extends { [K in Keys[number]]?: any; }>(s: S) => Simplify<Omit<S, Keys[number]>>; <S extends object, Keys extends Array<keyof S>>(s: S, ...keys: Keys): Simplify<Omit<S, Keys[number]>>; }

----------------------------------------

TITLE: Creating Effect from Fiber in TypeScript
DESCRIPTION: The fromFiber function creates an Effect value that represents the exit value of a specified fiber. It takes a Fiber as input and returns an Effect. This function is useful for converting fiber outcomes into Effect values.

LANGUAGE: typescript
CODE:
declare const fromFiber: <A, E>(fiber: Fiber.Fiber<A, E>) => Effect<A, E>

----------------------------------------

TITLE: RcRef.make Function Signature in TypeScript
DESCRIPTION: Provides the TypeScript signature for the RcRef.make function. It shows the function's parameters and return type, including the options for resource acquisition and idle time management.

LANGUAGE: typescript
CODE:
declare const make: <A, E, R>(options: { readonly acquire: Effect.Effect<A, E, R>; readonly idleTimeToLive?: Duration.DurationInput | undefined; }) => Effect.Effect<RcRef<A, E>, never, R | Scope.Scope>

----------------------------------------

TITLE: Boolean Negation Example in TypeScript
DESCRIPTION: Demonstrates how to use the not() function from Effect's Boolean module to negate boolean values. The function takes a boolean input and returns its opposite value.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { not } from "effect/Boolean"

assert.deepStrictEqual(not(true), false)
assert.deepStrictEqual(not(false), true)

LANGUAGE: typescript
CODE:
declare const not: (self: boolean) => boolean

----------------------------------------

TITLE: Defining dedupeAdjacentWith Function in TypeScript
DESCRIPTION: Declares the dedupeAdjacentWith function, which takes an equivalence function and an iterable, and returns a new iterable with adjacent duplicate elements removed. The function has two overloads to support both curried and non-curried usage.

LANGUAGE: typescript
CODE:
declare const dedupeAdjacentWith: { <A>(isEquivalent: (self: A, that: A) => boolean): (self: Iterable<A>) => Iterable<A>; <A>(self: Iterable<A>, isEquivalent: (self: A, that: A) => boolean): Iterable<A>; }

----------------------------------------

TITLE: Finding Last Element with Predicate in TArray - TypeScript
DESCRIPTION: Function signature for finding the last element in a transactional array that matches a given predicate. Returns an STM (Software Transactional Memory) operation that yields an Option containing the found element.

LANGUAGE: typescript
CODE:
declare const findLast: { <A>(predicate: Predicate<A>): (self: TArray<A>) => STM.STM<Option.Option<A>>; <A>(self: TArray<A>, predicate: Predicate<A>): STM.STM<Option.Option<A>>; }

----------------------------------------

TITLE: Declaring DateTimeUpdate Type in TypeScript
DESCRIPTION: Defines a constant DateTimeUpdate that represents a field storing UTC datetime values which automatically update on database inserts and updates. The value is serialized as a string in the database.

LANGUAGE: typescript
CODE:
declare const DateTimeUpdate: DateTimeUpdate

----------------------------------------

TITLE: Tuple.map Function Signature in TypeScript
DESCRIPTION: Provides the TypeScript signature for the Tuple.map function. It shows two overloads: one for curried usage and another for direct application.

LANGUAGE: typescript
CODE:
declare const map: { <T extends ReadonlyArray<any> | [], B>(fn: (element: T[number]) => B): (self: T) => TupleOf<T["length"], B>; <B, T extends ReadonlyArray<any> | []>(self: T, fn: (element: T[number]) => B): TupleOf<T["length"], B>; }

----------------------------------------

TITLE: Type Guard Implementation for Exit Type in TypeScript
DESCRIPTION: A type guard function that checks if a value is an Exit type. Takes an unknown value and returns a type predicate indicating if the value is an Exit<unknown, unknown>.

LANGUAGE: typescript
CODE:
declare const isExit: (u: unknown) => u is Exit<unknown, unknown>

----------------------------------------

TITLE: Checking Interrupt Type in Cause Module (TypeScript)
DESCRIPTION: This function checks if a given Cause is of the Interrupt type. It is part of the Cause module in the Effect package. The function takes a Cause<E> as input and returns a boolean indicating if it's an Interrupt.

LANGUAGE: typescript
CODE:
declare const isInterruptType: <E>(self: Cause<E>) => self is Interrupt

----------------------------------------

TITLE: Checking for Empty Records in TypeScript using Effect's Record Module
DESCRIPTION: The `isEmptyRecord` function determines if a given record is empty. It returns true for an empty object and false for any object with properties. This function is part of the Record module in the Effect package.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { isEmptyRecord } from "effect/Record"

assert.deepStrictEqual(isEmptyRecord({}), true);
assert.deepStrictEqual(isEmptyRecord({ a: 3 }), false);

LANGUAGE: typescript
CODE:
declare const isEmptyRecord: <K extends string, A>(self: Record<K, A>) => self is Record<K, never>

----------------------------------------

TITLE: Creating No-op FileSystem in TypeScript
DESCRIPTION: The makeNoop function creates a no-op file system that can be used for testing. It takes a partial FileSystem object as input and returns a complete FileSystem object.

LANGUAGE: typescript
CODE:
declare const makeNoop: (fileSystem: Partial<FileSystem>) => FileSystem

----------------------------------------

TITLE: Mapping Keys in a ReadonlyRecord using TypeScript
DESCRIPTION: Demonstrates how to use the mapKeys function to transform the keys of a ReadonlyRecord while preserving the corresponding values. The example shows mapping lowercase keys to uppercase.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { mapKeys } from "effect/Record"

assert.deepStrictEqual(mapKeys({ a: 3, b: 5 }, (key) => key.toUpperCase()), { A: 3, B: 5 })

----------------------------------------

TITLE: Implementing filterMapWhile Stream Operation in TypeScript
DESCRIPTION: Defines a function that transforms stream elements using a partial function until it becomes undefined. The function takes a partial function that returns an Option type and applies it to a Stream, producing a new Stream with transformed elements.

LANGUAGE: typescript
CODE:
declare const filterMapWhile: { <A, A2>(pf: (a: A) => Option.Option<A2>): <E, R>(self: Stream<A, E, R>) => Stream<A2, E, R>; <A, E, R, A2>(self: Stream<A, E, R>, pf: (a: A) => Option.Option<A2>): Stream<A2, E, R>; }

----------------------------------------

TITLE: Defining Layer.flatten Function in TypeScript
DESCRIPTION: Defines the flatten function for the Layer module. This function flattens layers nested in the context of an effect. It provides two overloads to handle different parameter orders.

LANGUAGE: typescript
CODE:
declare const flatten: { <I, A, E2, R2>(tag: Context.Tag<I, Layer<A, E2, R2>>): <E, R>(self: Layer<I, E, R>) => Layer<A, E2 | E, R2 | R>; <I, E, R, A, E2, R2>(self: Layer<I, E, R>, tag: Context.Tag<I, Layer<A, E2, R2>>): Layer<A, E | E2, R | R2>; }

----------------------------------------

TITLE: Creating Tagged Struct with Effect Schema
DESCRIPTION: Demonstrates how to create and use a tagged struct using Effect's Schema module. The example creates a User type with name and age fields, automatically adding a '_tag' property for type discrimination.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Schema } from "effect"

const User = Schema.TaggedStruct("User", {
  name: Schema.String,
  age: Schema.Number
})

assert.deepStrictEqual(User.make({ name: "John", age: 44 }), { _tag: "User", name: "John", age: 44 })

LANGUAGE: typescript
CODE:
declare const TaggedStruct: <Tag extends AST.LiteralValue, Fields extends Struct.Fields>(value: Tag, fields: Fields) => TaggedStruct<Tag, Fields>

----------------------------------------

TITLE: Using Array.mapAccum in TypeScript
DESCRIPTION: Demonstrates how to use the Array.mapAccum function to statefully map over an array, producing new elements and accumulating a state.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const result = Array.mapAccum([1, 2, 3], 0, (acc, n) => [acc + n, acc + n])
console.log(result) // [6, [1, 3, 6]]

----------------------------------------

TITLE: Transforming Schema Types with Error Handling in TypeScript
DESCRIPTION: Function signature for transformOrFail that creates a new Schema by transforming input and output of an existing Schema using provided decoding functions. Supports both strict and non-strict transformations with comprehensive error handling through Effect.Effect type.

LANGUAGE: typescript
CODE:
declare const transformOrFail: { <To extends Schema.Any, From extends Schema.Any, RD, RE>(to: To, options: { readonly decode: (fromA: Schema.Type<From>, options: ParseOptions, ast: AST.Transformation, fromI: Schema.Encoded<From>) => Effect.Effect<Schema.Encoded<To>, ParseResult.ParseIssue, RD>; readonly encode: (toI: Schema.Encoded<To>, options: ParseOptions, ast: AST.Transformation, toA: Schema.Type<To>) => Effect.Effect<Schema.Type<From>, ParseResult.ParseIssue, RE>; readonly strict?: true; } | { readonly decode: (fromA: Schema.Type<From>, options: ParseOptions, ast: AST.Transformation, fromI: Schema.Encoded<From>) => Effect.Effect<unknown, ParseResult.ParseIssue, RD>; readonly encode: (toI: Schema.Encoded<To>, options: ParseOptions, ast: AST.Transformation, toA: Schema.Type<To>) => Effect.Effect<unknown, ParseResult.ParseIssue, RE>; readonly strict: false; }): (from: From) => transformOrFail<From, To, RD | RE>; <To extends Schema.Any, From extends Schema.Any, RD, RE>(from: From, to: To, options: { readonly decode: (fromA: Schema.Type<From>, options: ParseOptions, ast: AST.Transformation, fromI: Schema.Encoded<From>) => Effect.Effect<Schema.Encoded<To>, ParseResult.ParseIssue, RD>; readonly encode: (toI: Schema.Encoded<To>, options: ParseOptions, ast: AST.Transformation, toA: Schema.Type<To>) => Effect.Effect<Schema.Type<From>, ParseResult.ParseIssue, RE>; readonly strict?: true; } | { readonly decode: (fromA: Schema.Type<From>, options: ParseOptions, ast: AST.Transformation, fromI: Schema.Encoded<From>) => Effect.Effect<unknown, ParseResult.ParseIssue, RD>; readonly encode: (toI: Schema.Encoded<To>, options: ParseOptions, ast: AST.Transformation, toA: Schema.Type<To>) => Effect.Effect<unknown, ParseResult.ParseIssue, RE>; readonly strict: false; }): transformOrFail<From, To, RD | RE>; }

----------------------------------------

TITLE: Creating Integer Range Chunk in TypeScript
DESCRIPTION: The range function creates a non-empty Chunk containing a range of integers, including both endpoints. It takes two parameters: start and end, both of type number.

LANGUAGE: typescript
CODE:
declare const range: (start: number, end: number) => NonEmptyChunk<number>

----------------------------------------

TITLE: Defining chunksWith Function for Stream Transformation in TypeScript
DESCRIPTION: The chunksWith function performs a specified stream transformation with the chunk structure of the stream exposed. It takes a transformation function as an argument and returns a new stream. The function can be used in both curried and uncurried forms.

LANGUAGE: typescript
CODE:
declare const chunksWith: { <A, E, R, A2, E2, R2>(f: (stream: Stream<Chunk.Chunk<A>, E, R>) => Stream<Chunk.Chunk<A2>, E2, R2>): (self: Stream<A, E, R>) => Stream<A2, E | E2, R | R2>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, f: (stream: Stream<Chunk.Chunk<A>, E, R>) => Stream<Chunk.Chunk<A2>, E2, R2>): Stream<A2, E | E2, R | R2>; }

----------------------------------------

TITLE: HashSet Filter Function Signature in TypeScript
DESCRIPTION: Type declaration for the filter function showing supported parameter combinations for both refinement and predicate-based filtering.

LANGUAGE: typescript
CODE:
declare const filter: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: HashSet<A>) => HashSet<B>; <A>(predicate: Predicate<NoInfer<A>>): (self: HashSet<A>) => HashSet<A>; <A, B extends A>(self: HashSet<A>, refinement: Refinement<A, B>): HashSet<B>; <A>(self: HashSet<A>, predicate: Predicate<A>): HashSet<A>; }

----------------------------------------

TITLE: Converting List to Array in TypeScript - Effect Library
DESCRIPTION: Function signature for converting a List data structure to a native JavaScript Array. Takes a List of type A as input and returns an Array of the same type.

LANGUAGE: typescript
CODE:
declare const toArray: <A>(self: List<A>) => Array<A>

----------------------------------------

TITLE: Defining concatMapWith Function for Channel in TypeScript
DESCRIPTION: Declares the concatMapWith function for the Channel module. This function creates a new channel by concatenating outputs of channels created by a factory function, using a merging function to combine terminal values.

LANGUAGE: typescript
CODE:
declare const concatMapWith: { <OutElem, OutElem2, InElem2, OutErr2, InErr2, OutDone, InDone2, Env2, OutDone2, OutDone3>(f: (o: OutElem) => Channel<OutElem2, InElem2, OutErr2, InErr2, OutDone, InDone2, Env2>, g: (o: OutDone, o1: OutDone) => OutDone, h: (o: OutDone, o2: OutDone2) => OutDone3): <Env, InErr, InElem, InDone, OutErr>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env>) => Channel<OutElem2, InElem & InElem2, OutErr2 | OutErr, InErr & InErr2, OutDone3, InDone & InDone2, Env2 | Env>; <OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env, OutElem2, InElem2, OutErr2, InErr2, OutDone, InDone2, Env2, OutDone3>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env>, f: (o: OutElem) => Channel<OutElem2, InElem2, OutErr2, InErr2, OutDone, InDone2, Env2>, g: (o: OutDone, o1: OutDone) => OutDone, h: (o: OutDone, o2: OutDone2) => OutDone3): Channel<OutElem2, InElem & InElem2, OutErr | OutErr2, InErr & InErr2, OutDone3, InDone & InDone2, Env | Env2>; }

----------------------------------------

TITLE: Declaring orElseAbsurd Function in TypeScript
DESCRIPTION: Defines the orElseAbsurd function, which finalizes a matcher by throwing an error if no pattern matches. It's useful for ensuring all cases are covered and unexpected inputs trigger errors.

LANGUAGE: typescript
CODE:
declare const orElseAbsurd: <I, R, RA, A, Pr, Ret>(self: Matcher<I, R, RA, A, Pr, Ret>) => [Pr] extends [never] ? (input: I) => Unify<A> : Unify<A>

----------------------------------------

TITLE: Defining doubleQuoted Function in TypeScript
DESCRIPTION: Declares a constant function doubleQuoted that takes a Doc<A> as input and returns a Doc<A>. This function encloses the input document in double quotes.

LANGUAGE: typescript
CODE:
declare const doubleQuoted: <A>(self: Doc<A>) => Doc<A>

----------------------------------------

TITLE: Validating Context Tags in Effect TypeScript
DESCRIPTION: Demonstrates how to use Context.isTag to check if a value is a Tag instance. The function takes an unknown input and returns a type predicate indicating if the input is a Tag of any type.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Context } from "effect"

assert.strictEqual(Context.isTag(Context.GenericTag("Tag")), true)

LANGUAGE: typescript
CODE:
declare const isTag: (input: unknown) => input is Tag<any, any>

----------------------------------------

TITLE: Determining BigDecimal Sign in TypeScript
DESCRIPTION: The sign function determines the sign of a given BigDecimal. It returns -1 for negative numbers, 0 for zero, and 1 for positive numbers. The function uses the Ordering type for its return value.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { sign, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(sign(unsafeFromString("-5")), -1)
assert.deepStrictEqual(sign(unsafeFromString("0")), 0)
assert.deepStrictEqual(sign(unsafeFromString("5")), 1)

LANGUAGE: typescript
CODE:
declare const sign: (n: BigDecimal) => Ordering

----------------------------------------

TITLE: Retrieving Elements by Index in RedBlackTree (TypeScript)
DESCRIPTION: The getAt function returns the element at a specified index within a RedBlackTree, or None if the index doesn't exist. It can be called with either the index first or the tree first.

LANGUAGE: typescript
CODE:
declare const getAt: { (index: number): <K, V>(self: RedBlackTree<K, V>) => Option<[K, V]>; <K, V>(self: RedBlackTree<K, V>, index: number): Option<[K, V]>; }

----------------------------------------

TITLE: Context.make Function Signature in TypeScript
DESCRIPTION: Provides the TypeScript signature for the Context.make function. It shows that the function takes a tag and a service as parameters and returns a Context with the tag's identifier.

LANGUAGE: typescript
CODE:
declare const make: <T extends Tag<any, any>>(tag: T, service: Tag.Service<T>) => Context<Tag.Identifier<T>>

----------------------------------------

TITLE: Defining flipWith Function in TypeScript for Effect Module
DESCRIPTION: Declares the flipWith function which swaps error/value parameters, applies a given function, and flips the parameters back. It supports both curried and non-curried usage patterns.

LANGUAGE: typescript
CODE:
declare const flipWith: { <E, A, R, E2, A2, R2>(f: (effect: Effect<E, A, R>) => Effect<E2, A2, R2>): (self: Effect<A, E, R>) => Effect<A2, E2, R2>; <A, E, R, E2, A2, R2>(self: Effect<A, E, R>, f: (effect: Effect<E, A, R>) => Effect<E2, A2, R2>): Effect<A2, E2, R2>; }

----------------------------------------

TITLE: Defining TRandom Service Tag in TypeScript
DESCRIPTION: Declares a constant Tag that serves as a service identifier for accessing TRandom functionality within an effect's environment. The tag is typed to both provide and require TRandom implementations.

LANGUAGE: typescript
CODE:
declare const Tag: Context.Tag<TRandom, TRandom>

----------------------------------------

TITLE: Defining getOrder Function for Tuple Comparison in TypeScript
DESCRIPTION: The getOrder function creates and returns a new Order for comparing tuples. It takes Order instances for each tuple element as arguments and returns an Order that compares tuples by applying the corresponding Order to each element. This is useful for comparing tuples with custom comparison logic for each element.

LANGUAGE: typescript
CODE:
declare const getOrder: <T extends ReadonlyArray<order.Order<any>>>(...elements: T) => order.Order<{ [I in keyof T]: [T[I]] extends [order.Order<infer A>] ? A : never; }>

----------------------------------------

TITLE: Implementing Chunk Differ in TypeScript
DESCRIPTION: Defines a function that constructs a differ capable of comparing Chunks of values. It takes a differ for individual values and returns a new differ that can handle Chunks of those values.

LANGUAGE: typescript
CODE:
declare const chunk: <Value, Patch>(differ: Differ<Value, Patch>) => Differ<Chunk<Value>, Differ.Chunk.Patch<Value, Patch>>

----------------------------------------

TITLE: Declaring groupBy Function in TypeScript for Iterable Module
DESCRIPTION: Defines the groupBy function that splits an Iterable into sub-non-empty-arrays stored in an object. It groups elements based on the result of a string-returning function applied to each element.

LANGUAGE: typescript
CODE:
declare const groupBy: { <A, K extends string | symbol>(f: (a: A) => K): (self: Iterable<A>) => Record<Record.ReadonlyRecord.NonLiteralKey<K>, NonEmptyArray<A>>; <A, K extends string | symbol>(self: Iterable<A>, f: (a: A) => K): Record<Record.ReadonlyRecord.NonLiteralKey<K>, NonEmptyArray<A>>; }

----------------------------------------

TITLE: Context Mapping Function for Effect Schedules in TypeScript
DESCRIPTION: Implements a function that transforms the required context of a schedule from type R to R0. This allows adapting schedules to different dependency environments while preserving core logic. The function supports both curried and non-curried calling styles.

LANGUAGE: typescript
CODE:
declare const mapInputContext: { 
  <R0, R>(f: (env0: Context.Context<R0>) => Context.Context<R>): 
    <Out, In>(self: Schedule<Out, In, R>) => Schedule<Out, In, R0>; 
  <Out, In, R, R0>(self: Schedule<Out, In, R>, f: (env0: Context.Context<R0>) => Context.Context<R>): 
    Schedule<Out, In, R0>; 
}

----------------------------------------

TITLE: Reversing an Array using Effect Library in TypeScript
DESCRIPTION: Demonstrates how to use the Array.reverse function from the Effect library to reverse an iterable, creating a new Array. The function works with any Iterable type and preserves type information for non-empty arrays.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const result = Array.reverse([1, 2, 3, 4])
console.log(result) // [4, 3, 2, 1]

LANGUAGE: typescript
CODE:
declare const reverse: <S extends Iterable<any>>(self: S) => S extends NonEmptyReadonlyArray<infer A> ? NonEmptyArray<A> : S extends Iterable<infer A> ? Array<A> : never

----------------------------------------

TITLE: Retrieving Failure Option from Cause in TypeScript
DESCRIPTION: Function that extracts the first recoverable error from a Cause instance, returning it wrapped in an Option type. Used for error handling and display purposes in the Effect package.

LANGUAGE: typescript
CODE:
declare const failureOption: <E>(self: Cause<E>) => Option.Option<E>

----------------------------------------

TITLE: Implementing Schedule Intersection with Custom Interval Merging in TypeScript
DESCRIPTION: Function signature for intersectWith that combines two schedules and merges their intervals using a custom function. The resulting schedule continues only when both input schedules allow it, with the interval between executions determined by the provided merge function. Returns a tuple containing both schedules' outputs.

LANGUAGE: typescript
CODE:
declare const intersectWith: { <Out2, In2, R2>(that: Schedule<Out2, In2, R2>, f: (x: Intervals.Intervals, y: Intervals.Intervals) => Intervals.Intervals): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<[Out, Out2], In & In2, R2 | R>; <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>, f: (x: Intervals.Intervals, y: Intervals.Intervals) => Intervals.Intervals): Schedule<[Out, Out2], In & In2, R | R2>; }

----------------------------------------

TITLE: Defining Channel.map Function Signature in TypeScript
DESCRIPTION: Type signature for the Channel.map function which provides two overloads: one for curried usage and one for direct application. The function transforms the terminal value of a channel using a mapping function while preserving the channel's structure.

LANGUAGE: typescript
CODE:
declare const map: {
  <OutDone, OutDone2>(f: (out: OutDone) => OutDone2): <OutElem, InElem, OutErr, InErr, InDone, Env>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>
  ) => Channel<OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env>;
  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutDone2>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,
    f: (out: OutDone) => OutDone2
  ): Channel<OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env>;
}

----------------------------------------

TITLE: Implementing Child Fiber Callback Handling in TypeScript Effect Module
DESCRIPTION: Defines a function that acts on child fibers, ensuring a specified callback is executed regardless of the effect's success or failure. The function takes a callback that operates on a Fiber containing an array of unknown values and returns a new Effect.

LANGUAGE: typescript
CODE:
declare const ensuringChild: {
  <X, R2>(f: (fiber: Fiber.Fiber<ReadonlyArray<unknown>, any>) => Effect<X, never, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R2 | R>;
  <A, E, R, X, R2>(self: Effect<A, E, R>, f: (fiber: Fiber.Fiber<ReadonlyArray<unknown>, any>) => Effect<X, never, R2>): Effect<A, E, R | R2>;
}

----------------------------------------

TITLE: Creating SQL Data Loaders in TypeScript using Effect
DESCRIPTION: Function signature for creating data loaders from a model. It generates methods for inserting, finding, and deleting records using SQL operations. The function takes a model and configuration options including table name, span prefix, ID column, window duration, and optional batch size.

LANGUAGE: typescript
CODE:
declare const makeDataLoaders: <S extends AnyNoContext, Id extends (keyof S["Type"]) & (keyof S["update"]["Type"]) & (keyof S["fields"])>(Model: S, options: { readonly tableName: string; readonly spanPrefix: string; readonly idColumn: Id; readonly window: DurationInput; readonly maxBatchSize?: number | undefined; }) => Effect.Effect<{ readonly insert: (insert: S["insert"]["Type"]) => Effect.Effect<S["Type"]>; readonly insertVoid: (insert: S["insert"]["Type"]) => Effect.Effect<void>; readonly findById: (id: Schema.Schema.Type<S["fields"][Id]>) => Effect.Effect<Option.Option<S["Type"]>>; readonly delete: (id: Schema.Schema.Type<S["fields"][Id]>) => Effect.Effect<void>; }, never, SqlClient | Scope>

----------------------------------------

TITLE: Setting Time Zone of DateTime Object in TypeScript using Effect
DESCRIPTION: This snippet demonstrates how to use the DateTime.setZone function from the Effect package to set the time zone of a DateTime object. It creates a new DateTime.Zoned instance with the specified time zone.

LANGUAGE: typescript
CODE:
import { DateTime, Effect } from "effect"

Effect.gen(function* () {
  const now = yield* DateTime.now
  const zone = DateTime.zoneUnsafeMakeNamed("Europe/London")

  // set the time zone
  const zoned: DateTime.Zoned = DateTime.setZone(now, zone)
})

----------------------------------------

TITLE: Defining TPriorityQueue Interface in TypeScript
DESCRIPTION: Defines the TPriorityQueue interface, which extends TPriorityQueue.Variance<A>. It represents a priority queue that contains values of type A with a defined Order, where take returns the highest priority value.

LANGUAGE: typescript
CODE:
export interface TPriorityQueue<in out A> extends TPriorityQueue.Variance<A> {}

----------------------------------------

TITLE: Defining uninterruptible Effect Method in TypeScript
DESCRIPTION: TypeScript method signature for marking an Effect as uninterruptible. Takes an Effect<A, E, R> as input and returns the same effect type marked as uninterruptible.

LANGUAGE: typescript
CODE:
declare const uninterruptible: <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>

----------------------------------------

TITLE: Updating Array Elements in TArray (TypeScript)
DESCRIPTION: The update function allows modifying an element in a TArray using a provided function. It can be used in two ways: either by passing the TArray as the first argument, or by returning a function that takes the TArray as an argument.

LANGUAGE: typescript
CODE:
declare const update: { <A>(index: number, f: (value: A) => A): (self: TArray<A>) => STM.STM<void>; <A>(self: TArray<A>, index: number, f: (value: A) => A): STM.STM<void>; }

----------------------------------------

TITLE: Setting Current Time Zone for DateTime Objects in TypeScript
DESCRIPTION: Demonstrates how to set a DateTime object's time zone to the current time zone using Effect.gen and DateTime.setZoneCurrent. The example shows setting the time zone to 'Europe/London'.

LANGUAGE: typescript
CODE:
import { DateTime, Effect } from "effect"

Effect.gen(function* () {
  const now = yield* DateTime.now

  // set the time zone to "Europe/London"
  const zoned = yield* DateTime.setZoneCurrent(now)
}).pipe(DateTime.withCurrentZoneNamed("Europe/London"))

LANGUAGE: typescript
CODE:
declare const setZoneCurrent: (self: DateTime) => Effect.Effect<Zoned, never, CurrentTimeZone>

----------------------------------------

TITLE: Creating File Content Parameter in Effect CLI - TypeScript
DESCRIPTION: Creates a parameter that expects a file path and returns both the path and the file contents as a Uint8Array. This is used for CLI options that need to read file contents.

LANGUAGE: typescript
CODE:
declare const fileContent: (name: string) => Options<readonly [path: string, content: Uint8Array]>

----------------------------------------

TITLE: TypeScript Function Signature for Number Sign Determination
DESCRIPTION: This snippet shows the TypeScript function signature for the sign function. It takes a number as input and returns an Ordering type.

LANGUAGE: typescript
CODE:
declare const sign: (n: number) => Ordering

----------------------------------------

TITLE: Metric.counter Function Signature in TypeScript
DESCRIPTION: Provides the TypeScript signature for the Metric.counter function, showing its overloads for creating number and bigint counters with various options.

LANGUAGE: typescript
CODE:
declare const counter: { (name: string, options?: { readonly description?: string | undefined; readonly bigint?: false | undefined; readonly incremental?: boolean | undefined; }): Metric.Counter<number>; (name: string, options: { readonly description?: string | undefined; readonly bigint: true; readonly incremental?: boolean | undefined; }): Metric.Counter<bigint>; }

----------------------------------------

TITLE: Splitting Chunks with Predicate in TypeScript
DESCRIPTION: The splitWhere function splits a chunk into two parts based on the first element that matches a given predicate. It returns a tuple containing two chunks: one before the match and one from the match onward. This function is overloaded to work with both curried and non-curried forms.

LANGUAGE: TypeScript
CODE:
declare const splitWhere: { <A>(predicate: Predicate<NoInfer<A>>): (self: Chunk<A>) => [beforeMatch: Chunk<A>, fromMatch: Chunk<A>]; <A>(self: Chunk<A>, predicate: Predicate<A>): [beforeMatch: Chunk<A>, fromMatch: Chunk<A>]; }

----------------------------------------

TITLE: Implementing Boolean MonoidEvery in TypeScript
DESCRIPTION: Defines a boolean monoid implementation under conjunction where the empty value is true. This is part of the @effect/typeclass package's Boolean module and builds on the SemigroupEvery functionality.

LANGUAGE: typescript
CODE:
declare const MonoidEvery: monoid.Monoid<boolean>

----------------------------------------

TITLE: Creating Effect from Pull Operation in TypeScript
DESCRIPTION: The fromPull function creates an effect from Effect<Chunk<A>, Option<E>, R> that succeeds with Take<A, E>. It handles stream errors by converting them to Take.failCause and end-of-stream to Take.end.

LANGUAGE: typescript
CODE:
declare const fromPull: <A, E, R>(pull: Effect.Effect<Chunk.Chunk<A>, Option.Option<E>, R>) => Effect.Effect<Take<A, E>, never, R>

----------------------------------------

TITLE: Defining SingleProducerAsyncInput Interface in TypeScript
DESCRIPTION: This code snippet defines the SingleProducerAsyncInput interface, which extends AsyncInputProducer and AsyncInputConsumer. It includes methods for closing the input and taking elements, with specific handling for errors and completion signals.

LANGUAGE: typescript
CODE:
export interface SingleProducerAsyncInput<in out Err, in out Elem, in out Done>
  extends AsyncInputProducer<Err, Elem, Done>, AsyncInputConsumer<Err, Elem, Done>
{
  readonly close: Effect.Effect<unknown>
  readonly take: Effect.Effect<Exit.Exit<Elem, Either.Either<Done, Err>>>
}

----------------------------------------

TITLE: Implementing Cursor Down Movement in TypeScript using AnsiDoc
DESCRIPTION: Function that moves the cursor down by a specified number of lines in an ANSI-compatible terminal. If no line count is specified, defaults to moving down 1 line. The movement is relative to current cursor position and has no effect if cursor is at screen edge.

LANGUAGE: typescript
CODE:
declare const cursorDown: (lines?: number) => AnsiDoc

----------------------------------------

TITLE: Retrieving Reversed Values from RedBlackTree in TypeScript
DESCRIPTION: The valuesReversed function returns an IterableIterator of all values in a RedBlackTree in reverse order. It takes a RedBlackTree instance as input and works with generic key and value types.

LANGUAGE: typescript
CODE:
declare const valuesReversed: <K, V>(self: RedBlackTree<K, V>) => IterableIterator<V>

----------------------------------------

TITLE: Implementing Cartesian Product with Custom Combiner in TypeScript
DESCRIPTION: Function signature for cartesianWith operation that combines two Iterables using a custom combining function. It supports both curried and uncurried forms for flexible usage patterns.

LANGUAGE: typescript
CODE:
declare const cartesianWith: { <A, B, C>(that: Iterable<B>, f: (a: A, b: B) => C): (self: Iterable<A>) => Iterable<C>; <A, B, C>(self: Iterable<A>, that: Iterable<B>, f: (a: A, b: B) => C): Iterable<C>; }

----------------------------------------

TITLE: Implementing Metric Polling in TypeScript using Effect
DESCRIPTION: Function signature for pollAndUpdate that creates an Effect which polls for a value and updates a metric. Takes a MetricPolling configuration object and returns an Effect that resolves to void while potentially producing an error of type E.

LANGUAGE: typescript
CODE:
declare const pollAndUpdate: <Type, In, R, E, Out>(self: MetricPolling<Type, In, R, E, Out>) => Effect.Effect<void, E, R>

----------------------------------------

TITLE: Implementing Channel orElse Operation in TypeScript
DESCRIPTION: Defines a function that creates a new channel by combining the operations of an existing channel with a fallback channel. The fallback channel is used when the primary channel fails. The function supports generic type parameters for flexible input/output element types, error handling, and environment configurations.

LANGUAGE: typescript
CODE:
declare const orElse: { <OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(that: LazyArg<Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>>): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1 | OutElem, InElem & InElem1, OutErr1, InErr & InErr1, OutDone1 | OutDone, InDone & InDone1, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, that: LazyArg<Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>>): Channel<OutElem | OutElem1, InElem & InElem1, OutErr1, InErr & InErr1, OutDone | OutDone1, InDone & InDone1, Env | Env1>; }

----------------------------------------

TITLE: Adding Duration to DateTime in TypeScript using Effect Package
DESCRIPTION: Demonstrates how to add a duration (5 minutes) to a DateTime object using the addDuration function. The function accepts a Duration input and returns a new DateTime instance with the added duration.

LANGUAGE: typescript
CODE:
import { DateTime } from "effect"

// add 5 minutes
DateTime.unsafeMake(0).pipe(
  DateTime.addDuration("5 minutes")
)

LANGUAGE: typescript
CODE:
declare const addDuration: { (duration: Duration.DurationInput): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, duration: Duration.DurationInput): A; }

----------------------------------------

TITLE: Handling Results as Exit with Effect.runSyncExit in TypeScript
DESCRIPTION: Demonstrates how to use Effect.runSyncExit to handle both success and failure outcomes of synchronous effects, returning results as Exit types.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

console.log(Effect.runSyncExit(Effect.succeed(1)))
// Output:
// {
//   _id: "Exit",
//   _tag: "Success",
//   value: 1
// }

console.log(Effect.runSyncExit(Effect.fail("my error")))
// Output:
// {
//   _id: "Exit",
//   _tag: "Failure",
//   cause: {
//     _id: "Cause",
//     _tag: "Fail",
//     failure: "my error"
//   }
// }

----------------------------------------

TITLE: Implementing Exit.exists Function in TypeScript
DESCRIPTION: Defines a function that executes a predicate on a Success Exit value, returning false for other cases. The function supports both refinement and predicate operations on Exit types, with generic type parameters for the success value (A), refined type (B), and error type (E).

LANGUAGE: typescript
CODE:
declare const exists: { 
  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): <E>(self: Exit<A, E>) => self is Exit<B>; 
  <A>(predicate: Predicate<NoInfer<A>>): <E>(self: Exit<A, E>) => boolean; 
  <A, E, B extends A>(self: Exit<A, E>, refinement: Refinement<A, B>): self is Exit<B>; 
  <A, E>(self: Exit<A, E>, predicate: Predicate<A>): boolean; 
}

----------------------------------------

TITLE: Defining mapFiber Function in TypeScript
DESCRIPTION: Declares the mapFiber function which maps the success of a fiber to a new fiber. It takes a callback function that transforms the success value of the original fiber into a new fiber, and returns an Effect that produces the new fiber.

LANGUAGE: typescript
CODE:
declare const mapFiber: {
  <E, E2, A, B>(f: (a: A) => Fiber<B, E2>): (self: Fiber<A, E>) => Effect.Effect<Fiber<B, E | E2>>;
  <A, E, E2, B>(self: Fiber<A, E>, f: (a: A) => Fiber<B, E2>): Effect.Effect<Fiber<B, E | E2>>;
}

----------------------------------------

TITLE: Defining Stream.die Function in TypeScript
DESCRIPTION: Defines the die function in the Stream module. This function creates a stream that immediately terminates with the specified defect. It takes an unknown defect as input and returns a Stream that never produces any values.

LANGUAGE: typescript
CODE:
declare const die: (defect: unknown) => Stream<never>

----------------------------------------

TITLE: Implementing Scoped Console Service in TypeScript Effect Module
DESCRIPTION: A function that temporarily sets a custom console implementation within a scoped context. The console implementation is restored to its original value when the scope closes. Takes a Console parameter and returns an Effect that requires a Scope.

LANGUAGE: typescript
CODE:
declare const withConsoleScoped: <A extends Console>(console: A) => Effect<void, never, Scope.Scope>

----------------------------------------

TITLE: Defining Micro.exit Function Signature in TypeScript
DESCRIPTION: This code snippet defines the signature of the Micro.exit function. It takes a Micro effect as input and returns a new Micro effect that accesses the MicroExit of the input effect.

LANGUAGE: typescript
CODE:
declare const exit: <A, E, R>(self: Micro<A, E, R>) => Micro<MicroExit<A, E>, never, R>

----------------------------------------

TITLE: Match.exhaustive Type Signature
DESCRIPTION: Type signature for the Match.exhaustive function, showing its generic type parameters and return type for pattern matching operations.

LANGUAGE: typescript
CODE:
declare const exhaustive: <I, F, A, Pr, Ret>(self: Matcher<I, F, never, A, Pr, Ret>) => [Pr] extends [never] ? (u: I) => Unify<A> : Unify<A>

----------------------------------------

TITLE: Inheriting FiberRef Values in TypeScript using Effect Module
DESCRIPTION: The inheritFiberRefs function inherits values from all FiberRef instances into the current fiber. It takes a FiberRefs object as input and returns an Effect of void.

LANGUAGE: typescript
CODE:
declare const inheritFiberRefs: (childFiberRefs: FiberRefs.FiberRefs) => Effect<void>

----------------------------------------

TITLE: Checking Negative BigDecimal in TypeScript
DESCRIPTION: Demonstrates how to use the isNegative function from the BigDecimal module to check if a BigDecimal is negative. It also shows the usage of unsafeFromString for creating BigDecimal instances.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { isNegative, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(isNegative(unsafeFromString("-1")), true)
assert.deepStrictEqual(isNegative(unsafeFromString("0")), false)
assert.deepStrictEqual(isNegative(unsafeFromString("1")), false)

----------------------------------------

TITLE: Using mapSecond Function in Effect/Tuple
DESCRIPTION: Demonstrates how to use the mapSecond function to transform the second element of a tuple. The function takes a tuple and a mapping function as arguments and returns a new tuple with the second element transformed.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { mapSecond } from "effect/Tuple"

assert.deepStrictEqual(
  mapSecond(["hello", 42], n => n.toString()),
  ["hello", "42"]
)

LANGUAGE: typescript
CODE:
declare const mapSecond: { <R1, R2>(f: (right: R1) => R2): <L>(self: readonly [L, R1]) => [L, R2]; <L, R1, R2>(self: readonly [L, R1], f: (right: R1) => R2): [L, R2]; }

----------------------------------------

TITLE: Trie.toEntries Function Signature in TypeScript
DESCRIPTION: Provides the TypeScript signature for the Trie.toEntries function. It takes a Trie<V> as input and returns an array of string-V pairs.

LANGUAGE: typescript
CODE:
declare const toEntries: <V>(self: Trie<V>) => Array<[string, V]>

----------------------------------------

TITLE: Defining lessThan Function for RedBlackTree in TypeScript
DESCRIPTION: The lessThan function returns an iterator that traverses entries in order with keys less than the specified key in a RedBlackTree. It supports both curried and non-curried function calls.

LANGUAGE: typescript
CODE:
declare const lessThan: { <K>(key: K): <V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>; <K, V>(self: RedBlackTree<K, V>, key: K): Iterable<[K, V]>; }

----------------------------------------

TITLE: Using cachedInvalidateWithTTL in Effect Module
DESCRIPTION: Example demonstrating how to use cachedInvalidateWithTTL to cache expensive task results with manual invalidation. The example shows caching a promise-based task for 1 hour with the ability to invalidate the cache manually.

LANGUAGE: typescript
CODE:
import { Effect, Console } from "effect"

let i = 1
const expensiveTask = Effect.promise<string>(() => {
  console.log("expensive task...")
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(`result ${i++}`)
    }, 100)
  })
})

const program = Effect.gen(function* () {
  const [cached, invalidate] = yield* Effect.cachedInvalidateWithTTL(
    expensiveTask,
    "1 hour"
  )
  yield* cached.pipe(Effect.andThen(Console.log))
  yield* cached.pipe(Effect.andThen(Console.log))
  yield* invalidate
  yield* cached.pipe(Effect.andThen(Console.log))
})

Effect.runFork(program)

LANGUAGE: typescript
CODE:
declare const cachedInvalidateWithTTL: { (timeToLive: Duration.DurationInput): <A, E, R>(self: Effect<A, E, R>) => Effect<[Effect<A, E>, Effect<void>], never, R>; <A, E, R>(self: Effect<A, E, R>, timeToLive: Duration.DurationInput): Effect<[Effect<A, E>, Effect<void>], never, R>; }

----------------------------------------

TITLE: Interrupting a Fiber in TypeScript using effect package
DESCRIPTION: The interruptFork function interrupts a fiber from the calling fiber. It operates in a separate daemon fiber and returns an effect that resumes immediately without waiting. This function is part of the Fiber module in the effect package.

LANGUAGE: typescript
CODE:
declare const interruptFork: <A, E>(self: Fiber<A, E>) => Effect.Effect<void>

----------------------------------------

TITLE: Implementing Delayed Effect Schedule Modification in TypeScript
DESCRIPTION: Defines a function that modifies a schedule by adding an effectfully computed delay before each execution. The delay is dynamically calculated using an effect-producing function that takes the current delay duration and returns a new duration. This enables adaptive scheduling based on external conditions.

LANGUAGE: typescript
CODE:
declare const delayedEffect: {
  <R2>(f: (duration: Duration.Duration) => Effect.Effect<Duration.DurationInput, never, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>;
  <Out, In, R, R2>(self: Schedule<Out, In, R>, f: (duration: Duration.Duration) => Effect.Effect<Duration.DurationInput, never, R2>): Schedule<Out, In, R | R2>;
}

----------------------------------------

TITLE: Checking for Some Value in Option - TypeScript
DESCRIPTION: Demonstrates how to use the Option.isSome function to check if an Option contains a value (Some). It shows examples of checking both Some and None values.

LANGUAGE: typescript
CODE:
import { Option } from "effect"

console.log(Option.isSome(Option.some(1)))
// Output: true

console.log(Option.isSome(Option.none()))
// Output: false

----------------------------------------

TITLE: Defining RuntimeException Interface in TypeScript
DESCRIPTION: Defines a TypeScript interface for representing runtime errors that are recoverable or typed. The interface extends YieldableError and includes a type tag and RuntimeExceptionTypeId property.

LANGUAGE: typescript
CODE:
export interface RuntimeException extends YieldableError {
  readonly _tag: "RuntimeException"
  readonly [RuntimeExceptionTypeId]: RuntimeExceptionTypeId
}

----------------------------------------

TITLE: Creating and Using an RcRef with Effect in TypeScript
DESCRIPTION: Demonstrates how to create an RcRef using RcRef.make, and how to use it with Effect.gen. The example shows lazy resource acquisition and proper release management.

LANGUAGE: typescript
CODE:
import { Effect, RcRef } from "effect"

Effect.gen(function*() {
  const ref = yield* RcRef.make({
    acquire: Effect.acquireRelease(
      Effect.succeed("foo"),
      () => Effect.log("release foo")
    )
  })

  // will only acquire the resource once, and release it
  // when the scope is closed
  yield* RcRef.get(ref).pipe(
    Effect.andThen(RcRef.get(ref)),
    Effect.scoped
  )
})

----------------------------------------

TITLE: Incrementing a Number using Effect Library in TypeScript
DESCRIPTION: Demonstrates how to use the increment function from the Effect library's Number module to add 1 to a given number. The example shows importing the function, using it, and asserting the result.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { increment } from "effect/Number"

assert.deepStrictEqual(increment(2), 3)

----------------------------------------

TITLE: Type Signature for mapEpochMillis Function in TypeScript
DESCRIPTION: This code block defines the type signature for the mapEpochMillis function. It shows that the function can be called with either a transformation function first and a DateTime object second, or with a DateTime object first and a transformation function second.

LANGUAGE: typescript
CODE:
declare const mapEpochMillis: { (f: (millis: number) => number): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, f: (millis: number) => number): A; }

----------------------------------------

TITLE: Using Semigroup.combine for Ordering in TypeScript
DESCRIPTION: Demonstrates the usage of Semigroup.combine method for Ordering type. The function returns the left-most non-zero Ordering when combining two Ordering values.

LANGUAGE: typescript
CODE:
import { Semigroup } from "@effect/typeclass/data/Ordering"

console.log(Semigroup.combine(0, -1))
// -1
console.log(Semigroup.combine(0, 1))
// 1
console.log(Semigroup.combine(1, -1))
// 1

----------------------------------------

TITLE: Mapping Exit Values in TypeScript
DESCRIPTION: Defines a map function that transforms the Success value of an Exit type while preserving the error type. The function supports both curried and uncurried calling styles for flexibility in usage.

LANGUAGE: typescript
CODE:
declare const map: { 
  <A, B>(f: (a: A) => B): <E>(self: Exit<A, E>) => Exit<B, E>; 
  <A, E, B>(self: Exit<A, E>, f: (a: A) => B): Exit<B, E>; 
}

----------------------------------------

TITLE: Constructing a Cache with makeWith in TypeScript
DESCRIPTION: The makeWith function creates a new cache with customizable capacity, lookup function, and time to live based on the Exit value. It returns an Effect containing the constructed Cache.

LANGUAGE: typescript
CODE:
declare const makeWith: <Key, Value, Error = never, Environment = never>(options: { readonly capacity: number; readonly lookup: Lookup<Key, Value, Error, Environment>; readonly timeToLive: (exit: Exit.Exit<Value, Error>) => Duration.DurationInput; }) => Effect.Effect<Cache<Key, Value, Error>, never, Environment>

----------------------------------------

TITLE: Defining provideContext Function in TypeScript for Effect's Schedule Module
DESCRIPTION: This code snippet defines the provideContext function, which takes a context and a schedule, and returns a new schedule that doesn't require external dependencies. It supports both curried and uncurried function calls.

LANGUAGE: typescript
CODE:
declare const provideContext: { <R>(context: Context.Context<R>): <Out, In>(self: Schedule<Out, In, R>) => Schedule<Out, In, never>; <Out, In, R>(self: Schedule<Out, In, R>, context: Context.Context<R>): Schedule<Out, In, never>; }

----------------------------------------

TITLE: Modifying DateTime Using UTC Date Function in TypeScript
DESCRIPTION: Function that takes a mutation function and applies it to a cloned UTC Date instance of a DateTime object. Supports both curried and uncurried parameter orders for flexibility in usage.

LANGUAGE: typescript
CODE:
declare const mutateUtc: { 
  (f: (date: Date) => void): <A extends DateTime>(self: A) => A; 
  <A extends DateTime>(self: A, f: (date: Date) => void): A; 
}

----------------------------------------

TITLE: Defining HttpClient.retryTransient Function in TypeScript
DESCRIPTION: This code snippet defines the signature of the HttpClient.retryTransient function. It allows for retrying HTTP client operations in case of transient errors, with options for customizing the retry behavior through predicates and schedules.

LANGUAGE: typescript
CODE:
declare const retryTransient: { <B, E, R1 = never>(options: { readonly while?: Predicate.Predicate<NoInfer<E>>; readonly schedule?: Schedule.Schedule<B, NoInfer<E>, R1>; readonly times?: number; } | Schedule.Schedule<B, NoInfer<E>, R1>): <R>(self: HttpClient.With<E, R>) => HttpClient.With<E, R1 | R>; <E, R, B, R1 = never>(self: HttpClient.With<E, R>, options: { readonly while?: Predicate.Predicate<NoInfer<E>>; readonly schedule?: Schedule.Schedule<B, NoInfer<E>, R1>; readonly times?: number; } | Schedule.Schedule<B, NoInfer<E>, R1>): HttpClient.With<E, R1 | R>; }

----------------------------------------

TITLE: Implementing Custom Configuration Provider in Effect
DESCRIPTION: Demonstrates how to use Effect.withConfigProvider to override the default configuration provider with a custom implementation. Shows creating a custom provider from a Map and accessing configuration values within an Effect.

LANGUAGE: typescript
CODE:
import { Config, ConfigProvider, Effect } from "effect"

const customProvider: ConfigProvider.ConfigProvider = ConfigProvider.fromMap(
  new Map([["custom-key", "custom-value"]])
)

const program = Effect.withConfigProvider(customProvider)(
  Effect.gen(function*() {
    const value = yield* Config.string("custom-key")
    console.log(`Config value: ${value}`)
  })
)

Effect.runPromise(program)
// Output:
// Config value: custom-value

LANGUAGE: typescript
CODE:
declare const withConfigProvider: { (provider: ConfigProvider): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, provider: ConfigProvider): Effect<A, E, R>; }

----------------------------------------

TITLE: Using withCurrentZoneOffset in Effect for DateTime Operations in TypeScript
DESCRIPTION: This snippet demonstrates how to use the withCurrentZoneOffset function from the DateTime module to set a custom time zone offset for an effect. It creates an effect that gets the current time in the system's local time zone and applies a 3-hour offset.

LANGUAGE: typescript
CODE:
import { DateTime, Effect } from "effect"

Effect.gen(function* () {
  // will use the system's local time zone
  const now = yield* DateTime.nowInCurrentZone
}).pipe(DateTime.withCurrentZoneOffset(3 * 60 * 60 * 1000))

----------------------------------------

TITLE: Either.transposeOption Type Signature
DESCRIPTION: TypeScript type signature for the Either.transposeOption function, showing the input type of Option<Either<A, E>> and return type of Either<Option<A>, E>.

LANGUAGE: typescript
CODE:
declare const transposeOption: <A = never, E = never>(self: Option<Either<A, E>>) => Either<Option<A>, E>

----------------------------------------

TITLE: Array.liftPredicate Function Signature in TypeScript
DESCRIPTION: Provides the TypeScript signature for the Array.liftPredicate function. It shows two overloads: one for refinements and another for predicates, both returning functions that produce arrays.

LANGUAGE: typescript
CODE:
declare const liftPredicate: { <A, B extends A>(refinement: Predicate.Refinement<A, B>): (a: A) => Array<B>; <A>(predicate: Predicate.Predicate<A>): <B extends A>(b: B) => Array<B>; }

----------------------------------------

TITLE: Retrieving Order Instance from SortedMap in TypeScript
DESCRIPTION: Function that retrieves the Order<K> instance used by a SortedMap<K, V> for key ordering. This allows access to the comparison logic used to maintain the map's sorting.

LANGUAGE: typescript
CODE:
declare const getOrder: <K, V>(self: SortedMap<K, V>) => Order<K>

----------------------------------------

TITLE: Defining RuntimeFlags Type in TypeScript
DESCRIPTION: Defines a TypeScript type for RuntimeFlags that represents a set of runtime flags affecting the Effect runtime system. The type is a number with an additional unique symbol property for type safety.

LANGUAGE: typescript
CODE:
type RuntimeFlags = number & {
  readonly RuntimeFlags: unique symbol
}

----------------------------------------

TITLE: Defining Non-recurring Schedule in TypeScript Effect Library
DESCRIPTION: Implements a schedule that immediately stops and never recurs. Uses a generic type signature where the environment is void, error is unknown, and output is never, indicating this schedule cannot produce any values.

LANGUAGE: typescript
CODE:
declare const stop: Schedule<void, unknown, never>

----------------------------------------

TITLE: Declaring withDefault Function for Config in TypeScript
DESCRIPTION: Defines a function that returns a config with a specified default value. It can be used in two ways: either by providing the default value first, or by providing the config and then the default value.

LANGUAGE: typescript
CODE:
declare const withDefault: { <const A2>(def: A2): <A>(self: Config<A>) => Config<A2 | A>; <A, const A2>(self: Config<A>, def: A2): Config<A | A2>; }

----------------------------------------

TITLE: Implementing Parallel Zipping of Exit Results in TypeScript
DESCRIPTION: The zipPar function parallelly zips an Exit result with another specified result. If either result fails, it returns the failed Cause<E | E2>. It supports both curried and uncurried versions.

LANGUAGE: typescript
CODE:
declare const zipPar: { <A2, E2>(that: Exit<A2, E2>): <A, E>(self: Exit<A, E>) => Exit<[A, A2], E2 | E>; <A, E, A2, E2>(self: Exit<A, E>, that: Exit<A2, E2>): Exit<[A, A2], E | E2>; }

----------------------------------------

TITLE: Calculating HashSet Size in TypeScript
DESCRIPTION: Demonstrates how to use the HashSet.size function to calculate the number of unique values in a HashSet. It shows examples with an empty HashSet and a HashSet with duplicate values.

LANGUAGE: typescript
CODE:
import { HashSet, pipe } from "effect"
import assert from "node:assert/strict"

assert.deepStrictEqual(pipe(HashSet.empty(), HashSet.size), 0)

assert.deepStrictEqual(
  pipe(HashSet.make(1, 2, 2, 3, 4, 3), HashSet.size),
  4
)

----------------------------------------

TITLE: Defining runDrain Function for Stream in TypeScript
DESCRIPTION: Declares the runDrain function that takes a Stream as input and returns an Effect. It runs the stream for its side effects, discarding any emitted elements. The function is generic over types A, E, and R.

LANGUAGE: typescript
CODE:
declare const runDrain: <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<void, E, R>

----------------------------------------

TITLE: Adding GenAI Telemetry Annotations in TypeScript
DESCRIPTION: Function declaration for addGenAIAnnotations that provides two overloads for applying GenAI telemetry attributes to a Span object. The function can be called either with options first followed by span, or with span first followed by options. The operation mutates the span in-place.

LANGUAGE: typescript
CODE:
declare const addGenAIAnnotations: { (options: GenAITelemetryAttributeOptions): (span: Span) => void; (span: Span, options: GenAITelemetryAttributeOptions): void; }

----------------------------------------

TITLE: Implementing Duration-Limited Recurring Schedule in TypeScript
DESCRIPTION: Defines a schedule that executes repeatedly until a specified duration has elapsed. The schedule tracks and returns the elapsed time on each recurrence. This is commonly used for implementing time-based retry policies, enforcing timeouts, or limiting the duration of recurring operations.

LANGUAGE: typescript
CODE:
declare const recurUpTo: (duration: Duration.DurationInput) => Schedule<Duration.Duration>

----------------------------------------

TITLE: Retrieving Values from a Trie in Typescript
DESCRIPTION: Demonstrates how to use the Trie.values function to retrieve an IterableIterator of values from a Trie data structure. The values are ordered based on their keys in alphabetical order.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Trie } from "effect"

const trie = Trie.empty<number>().pipe(
  Trie.insert("call", 0),
  Trie.insert("me", 1),
  Trie.insert("and", 2)
)

const result = Array.from(Trie.values(trie))
assert.deepStrictEqual(result, [2, 0, 1])

----------------------------------------

TITLE: Defining Iterable.scan Function in TypeScript
DESCRIPTION: Declares the scan function for the Iterable module. It reduces an Iterable from the left, keeping all intermediate results instead of only the final result. The function has two overloads to support different calling patterns.

LANGUAGE: typescript
CODE:
declare const scan: { <B, A>(b: B, f: (b: B, a: A) => B): (self: Iterable<A>) => Iterable<B>; <A, B>(self: Iterable<A>, b: B, f: (b: B, a: A) => B): Iterable<B>; }

----------------------------------------

TITLE: TypeScript Signature for Doc.flatAlt Function
DESCRIPTION: This code snippet shows the TypeScript signature for the flatAlt function in the Doc module. It defines the function's type and its overloads.

LANGUAGE: typescript
CODE:
declare const flatAlt: { <B>(that: Doc<B>): <A>(self: Doc<A>) => Doc<B | A>; <A, B>(self: Doc<A>, that: Doc<B>): Doc<A | B>; }

----------------------------------------

TITLE: Implementing Channel Suspension in TypeScript
DESCRIPTION: Type definition for the suspend function that enables lazy construction of channels. The function takes an evaluation function that produces a Channel with generically typed elements, errors, and completion values.

LANGUAGE: typescript
CODE:
declare const suspend: <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(evaluate: LazyArg<Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>>) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>

----------------------------------------

TITLE: Converting DateTime to Nearest Time Unit in TypeScript
DESCRIPTION: Demonstrates how to use DateTime.nearest to round a DateTime to its nearest time unit. The function takes a time unit part (like 'day') and optional weekStartsOn parameter for week-based calculations. Returns the adjusted DateTime instance.

LANGUAGE: typescript
CODE:
import { DateTime } from "effect"

// returns "2024-01-02T00:00:00Z"
DateTime.unsafeMake("2024-01-01T12:01:00Z").pipe(
  DateTime.nearest("day"),
  DateTime.formatIso
)

LANGUAGE: typescript
CODE:
declare const nearest: { 
  (part: DateTime.UnitSingular, options?: { 
    readonly weekStartsOn?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | undefined; 
  }): <A extends DateTime>(self: A) => A; 
  <A extends DateTime>(self: A, part: DateTime.UnitSingular, options?: { 
    readonly weekStartsOn?: 0 | 1 | 2 | 3 | 4 | 5 | 6 | undefined; 
  }): A; 
}

----------------------------------------

TITLE: Declaring filterOrFailCause Function Type in TypeScript
DESCRIPTION: Type declaration for filterOrFailCause function that filters effects with a predicate and handles failures with MicroCause. The function supports both refinement and predicate-based filtering with overloaded signatures for flexible usage patterns.

LANGUAGE: typescript
CODE:
declare const filterOrFailCause: {
  <A, B extends A, E2>(
    refinement: Refinement<A, B>,
    orFailWith: (a: NoInfer<A>) => MicroCause<E2>
  ): <E, R>(self: Micro<A, E, R>) => Micro<B, E2 | E, R>;
  <A, E2>(
    predicate: Predicate<NoInfer<A>>,
    orFailWith: (a: NoInfer<A>) => MicroCause<E2>
  ): <E, R>(self: Micro<A, E, R>) => Micro<A, E2 | E, R>;
  <A, E, R, B extends A, E2>(
    self: Micro<A, E, R>,
    refinement: Refinement<A, B>,
    orFailWith: (a: A) => MicroCause<E2>
  ): Micro<B, E | E2, R>;
  <A, E, R, E2>(
    self: Micro<A, E, R>,
    predicate: Predicate<A>,
    orFailWith: (a: A) => MicroCause<E2>
  ): Micro<A, E | E2, R>;
}

----------------------------------------

TITLE: Either.bind Type Signature
DESCRIPTION: Type declaration for the Either.bind function showing its generic parameters and return types. The signature supports both curried and uncurried function calls with proper type inference.

LANGUAGE: typescript
CODE:
declare const bind: { <N extends string, A extends object, B, L2>(name: Exclude<N, keyof A>, f: (a: NoInfer<A>) => Either<B, L2>): <L1>(self: Either<A, L1>) => Either<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }, L1 | L2>; <A extends object, L1, N extends string, B, L2>(self: Either<A, L1>, name: Exclude<N, keyof A>, f: (a: NoInfer<A>) => Either<B, L2>): Either<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }, L1 | L2>; }

----------------------------------------

TITLE: Effect.orElseSucceed Function Signature in TypeScript
DESCRIPTION: Provides the TypeScript function signature for the Effect.orElseSucceed function. It shows the function's type definitions and overloads, illustrating how it can be used with different parameter orders.

LANGUAGE: typescript
CODE:
declare const orElseSucceed: { <A2>(evaluate: LazyArg<A2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A2 | A, never, R>; <A, E, R, A2>(self: Effect<A, E, R>, evaluate: LazyArg<A2>): Effect<A | A2, never, R>; }

----------------------------------------

TITLE: TypeScript Signature for Option.isNone Function
DESCRIPTION: Provides the TypeScript type signature for the isNone function. It takes an Option<A> as input and returns a boolean indicating whether it's None<A>.

LANGUAGE: typescript
CODE:
declare const isNone: <A>(self: Option<A>) => self is None<A>

----------------------------------------

TITLE: Implementing Error Recovery with STM.catchTags in TypeScript
DESCRIPTION: Defines the catchTags function for handling multiple tagged errors in STM (Software Transactional Memory) operations. It allows specifying error handlers for different error tags, providing type-safe error recovery in transactional contexts.

LANGUAGE: typescript
CODE:
declare const catchTags: { <E extends { _tag: string; }, Cases extends { [K in E["_tag"]]+?: ((error: Extract<E, { _tag: K; }>) => STM<any, any, any>); }>(cases: Cases): <A, R>(self: STM<A, E, R>) => STM<A | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => STM<infer A, any, any> ? A : never; }[keyof Cases], Exclude<E, { _tag: keyof Cases; }> | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => STM<any, infer E, any> ? E : never; }[keyof Cases], R | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => STM<any, any, infer R> ? R : never; }[keyof Cases]>; <R, E extends { _tag: string; }, A, Cases extends { [K in E["_tag"]]+?: ((error: Extract<E, { _tag: K; }>) => STM<any, any, any>); }>(self: STM<A, E, R>, cases: Cases): STM<A | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => STM<infer A, any, any> ? A : never; }[keyof Cases], Exclude<E, { _tag: keyof Cases; }> | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => STM<any, infer E, any> ? E : never; }[keyof Cases], R | { [K in keyof Cases]: Cases[K] extends (...args: Array<any>) => STM<any, any, infer R> ? R : never; }[keyof Cases]>; }

----------------------------------------

TITLE: Using Match.orElse for Default Cases in TypeScript
DESCRIPTION: Demonstrates how to use Match.orElse to provide a fallback value when no patterns match in a matcher. It creates a matcher for string or number values, defines a specific case, and provides a default fallback.

LANGUAGE: typescript
CODE:
import { Match } from "effect"

// Create a matcher for string or number values
const match = Match.type<string | number>().pipe(
  // Match when the value is "a"
  Match.when("a", () => "ok"),
  // Fallback when no patterns match
  Match.orElse(() => "fallback")
)

console.log(match("a"))
// Output: "ok"

console.log(match("b"))
// Output: "fallback"

----------------------------------------

TITLE: Implementing constNull Function in TypeScript
DESCRIPTION: Demonstrates the usage of constNull function which is a thunk (lazy argument) that always returns null. This utility function is useful in scenarios where a consistent null return value is needed.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { constNull } from "effect/Function"

assert.deepStrictEqual(constNull(), null)

LANGUAGE: typescript
CODE:
declare const constNull: LazyArg<null>

----------------------------------------

TITLE: Defining List Type in TypeScript
DESCRIPTION: Type definition for an immutable linked list that can contain elements of type A. The list is implemented as a union type of Cons (non-empty list) and Nil (empty list), making it suitable for LIFO (Last-In-First-Out) operations.

LANGUAGE: typescript
CODE:
type List<A> = Cons<A> | Nil<A>

----------------------------------------

TITLE: Defining unfoldChunk Function for Stream Creation in TypeScript
DESCRIPTION: This function creates a stream by iteratively peeling off layers of a value of type S. It takes an initial state and a function that produces chunks of elements and a new state, returning an Option of this tuple.

LANGUAGE: typescript
CODE:
declare const unfoldChunk: <S, A>(s: S, f: (s: S) => Option.Option<readonly [Chunk.Chunk<A>, S]>) => Stream<A>

----------------------------------------

TITLE: Declaring ExceededCapacityException Type Identifier in TypeScript
DESCRIPTION: Defines a unique symbol constant that serves as a type identifier for ExceededCapacityException. This symbol is used internally to identify exceptions related to capacity limits being exceeded in resources.

LANGUAGE: typescript
CODE:
declare const ExceededCapacityExceptionTypeId: unique symbol

----------------------------------------

TITLE: Implementing changesUponFlattening Function in TypeScript for @effect/printer
DESCRIPTION: This function selects the first element of each Union and discards the first element of each FlatAlt to produce a flattened version of the input document. It returns different results based on how the document structure changes during flattening.

LANGUAGE: typescript
CODE:
declare const changesUponFlattening: <A>(self: Doc<A>) => Flatten<Doc<A>>

----------------------------------------

TITLE: Using withCurrentZoneLocal with DateTime Effect
DESCRIPTION: Demonstrates how to use withCurrentZoneLocal to provide CurrentTimeZone to an effect using the system's local timezone. The example shows getting the current time in the local timezone.

LANGUAGE: typescript
CODE:
import { DateTime, Effect } from "effect"

Effect.gen(function* () {
  // will use the system's local time zone
  const now = yield* DateTime.nowInCurrentZone
}).pipe(DateTime.withCurrentZoneLocal)

----------------------------------------

TITLE: Type Signature for Array.unionWith Function in TypeScript
DESCRIPTION: Provides the complex type signature for the Array.unionWith function. It shows various overloads to handle different input types, including iterables and non-empty arrays, with a custom equivalence function.

LANGUAGE: typescript
CODE:
declare const unionWith: { <S extends Iterable<any>, T extends Iterable<any>>(that: T, isEquivalent: (self: ReadonlyArray.Infer<S>, that: ReadonlyArray.Infer<T>) => boolean): (self: S) => ReadonlyArray.OrNonEmpty<S, T, ReadonlyArray.Infer<S> | ReadonlyArray.Infer<T>>; <A, B>(self: NonEmptyReadonlyArray<A>, that: Iterable<B>, isEquivalent: (self: A, that: B) => boolean): NonEmptyArray<A | B>; <A, B>(self: Iterable<A>, that: NonEmptyReadonlyArray<B>, isEquivalent: (self: A, that: B) => boolean): NonEmptyArray<A | B>; <A, B>(self: Iterable<A>, that: Iterable<B>, isEquivalent: (self: A, that: B) => boolean): Array<A | B>; }

----------------------------------------

TITLE: Executing and Managing Effects with FiberSet.run in TypeScript
DESCRIPTION: The 'run' function forks an Effect and adds the resulting fiber to a FiberSet. It automatically removes the fiber from the set upon completion. It supports optional propagation of interruption and can be called with or without explicit effect parameters.

LANGUAGE: TypeScript
CODE:
declare const run: { <A, E>(self: FiberSet<A, E>, options?: { readonly propagateInterruption?: boolean | undefined; } | undefined): <R, XE extends E, XA extends A>(effect: Effect.Effect<XA, XE, R>) => Effect.Effect<Fiber.RuntimeFiber<XA, XE>, never, R>; <A, E, R, XE extends E, XA extends A>(self: FiberSet<A, E>, effect: Effect.Effect<XA, XE, R>, options?: { readonly propagateInterruption?: boolean | undefined; } | undefined): Effect.Effect<Fiber.RuntimeFiber<XA, XE>, never, R>; }

----------------------------------------

TITLE: Effect.makeLatch Function Signature in TypeScript
DESCRIPTION: This code snippet shows the TypeScript signature for the Effect.makeLatch function. It takes an optional boolean parameter and returns an Effect that produces a Latch.

LANGUAGE: typescript
CODE:
declare const makeLatch: (open?: boolean | undefined) => Effect<Latch, never, never>

----------------------------------------

TITLE: Doc.column Function Type Signature
DESCRIPTION: Type declaration for the Doc.column function showing it takes a callback that receives the column position and returns a Doc instance.

LANGUAGE: typescript
CODE:
declare const column: <A>(react: (position: number) => Doc<A>) => Doc<A>

----------------------------------------

TITLE: Checking BothRunning State in TypeScript
DESCRIPTION: The isBothRunning function is a type guard that determines if a given MergeState is in the BothRunning state. It takes a MergeState object as input and returns a boolean indicating whether it's a BothRunning state. This function is useful for type narrowing in conditional blocks.

LANGUAGE: typescript
CODE:
declare const isBothRunning: <Env, Err, Err1, Err2, Elem, Done, Done1, Done2>(self: MergeState<Env, Err, Err1, Err2, Elem, Done, Done1, Done2>) => self is BothRunning<Env, Err, Err1, Err2, Elem, Done, Done1, Done2>

----------------------------------------

TITLE: Creating BigDecimal from bigint in TypeScript
DESCRIPTION: The fromBigInt function takes a bigint value and returns a BigDecimal. It is part of the BigDecimal module in the effect package. This function has been available since version 2.0.0 of the package.

LANGUAGE: typescript
CODE:
declare const fromBigInt: (n: bigint) => BigDecimal

----------------------------------------

TITLE: Effect.supervised Function Signature in TypeScript
DESCRIPTION: The type signature for the Effect.supervised function, which takes a supervisor and returns a function that wraps an Effect, supervising all child fibers within it.

LANGUAGE: typescript
CODE:
declare const supervised: { <X>(supervisor: Supervisor.Supervisor<X>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R, X>(self: Effect<A, E, R>, supervisor: Supervisor.Supervisor<X>): Effect<A, E, R>; }

----------------------------------------

TITLE: Creating Reference-Counted Resource Map with Effect
DESCRIPTION: Demonstrates how to create and use an RcMap for managing reference-counted resources. Resources are acquired lazily on first access and released when the last reference is dropped. Supports configurable idle timeout and capacity limits.

LANGUAGE: typescript
CODE:
import { Effect, RcMap } from "effect"

Effect.gen(function*() {
  const map = yield* RcMap.make({
    lookup: (key: string) =>
      Effect.acquireRelease(
        Effect.succeed(`acquired ${key}`),
        () => Effect.log(`releasing ${key}`)
      )
  })

  // Get "foo" from the map twice, which will only acquire it once.
  // It will then be released once the scope closes.
  yield* RcMap.get(map, "foo").pipe(
    Effect.andThen(RcMap.get(map, "foo")),
    Effect.scoped
  )
})

LANGUAGE: typescript
CODE:
declare const make: { <K, A, E, R>(options: { readonly lookup: (key: K) => Effect.Effect<A, E, R>; readonly idleTimeToLive?: Duration.DurationInput | undefined; readonly capacity?: undefined; }): Effect.Effect<RcMap<K, A, E>, never, Scope.Scope | R>; <K, A, E, R>(options: { readonly lookup: (key: K) => Effect.Effect<A, E, R>; readonly idleTimeToLive?: Duration.DurationInput | undefined; readonly capacity: number; }): Effect.Effect<RcMap<K, A, E | Cause.ExceededCapacityException>, never, Scope.Scope | R>; }

----------------------------------------

TITLE: Defining OpenAI Telemetry Attributes Type in TypeScript
DESCRIPTION: Defines a TypeScript type that combines general AI telemetry attributes with OpenAI-specific request and response attributes. The type uses prefix namespacing for OpenAI-specific fields following OpenTelemetry conventions.

LANGUAGE: typescript
CODE:
type OpenAiTelemetryAttributes = Simplify<
  & AiTelemetry.GenAITelemetryAttributes
  & AiTelemetry.GenAI.AttributesWithPrefix<OpenAiTelemetry.RequestAttributes, "gen_ai.openai.request">
  & AiTelemetry.GenAI.AttributesWithPrefix<OpenAiTelemetry.ResponseAttributes, "gen_ai.openai.request">
>

----------------------------------------

TITLE: Defining Exit.Failure Interface in TypeScript
DESCRIPTION: TypeScript interface definition for Exit.Failure that extends Effect.Effect and includes Pipeable and Inspectable. It represents a failed workflow with a cause of type E and includes type system metadata.

LANGUAGE: typescript
CODE:
export interface Failure<out A, out E> extends Effect.Effect<A, E>, Pipeable, Inspectable {
  readonly _tag: "Failure"
  readonly _op: "Failure"
  readonly cause: Cause.Cause<E>
  [Unify.typeSymbol]?: unknown
  [Unify.unifySymbol]?: ExitUnify<this>
  [Unify.ignoreSymbol]?: ExitUnifyIgnore
  /** @internal */
  readonly effect_instruction_i0: Cause.Cause<E>
}

----------------------------------------

TITLE: Implementing Stream Error Handling with catchAll in TypeScript
DESCRIPTION: Function signature for catchAll operator that switches to an alternative stream when the original stream fails with a typed error. Takes an error handling function that produces a new stream and returns a combined stream that can emit values from either source.

LANGUAGE: typescript
CODE:
declare const catchAll: { <E, A2, E2, R2>(f: (error: E) => Stream<A2, E2, R2>): <A, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, f: (error: E) => Stream<A2, E2, R2>): Stream<A | A2, E2, R | R2>; }

----------------------------------------

TITLE: Implementing STM orElse Operation in TypeScript
DESCRIPTION: Defines a function that attempts to execute an STM effect and falls back to another effect if the first one fails or retries. The operation is curried and supports generic type parameters for different result, error, and environment types.

LANGUAGE: typescript
CODE:
declare const orElse: { <A2, E2, R2>(that: LazyArg<STM<A2, E2, R2>>): <A, E, R>(self: STM<A, E, R>) => STM<A2 | A, E2, R2 | R>; <A, E, R, A2, E2, R2>(self: STM<A, E, R>, that: LazyArg<STM<A2, E2, R2>>): STM<A | A2, E2, R | R2>; }

----------------------------------------

TITLE: Converting Option to Micro Effect in TypeScript
DESCRIPTION: Function that transforms an Option type into a Micro effect. The resulting effect will either succeed with the Option's value or fail with NoSuchElementException if the Option is None.

LANGUAGE: typescript
CODE:
declare const fromOption: <A>(option: Option.Option<A>) => Micro<A, NoSuchElementException>

----------------------------------------

TITLE: Constructing Exit.Failure with failCause in TypeScript
DESCRIPTION: The failCause function creates a new Exit.Failure from a given Cause of type E. It takes a Cause<E> as input and returns an Exit<never, E>. This function is part of the Exit module in the Effect package.

LANGUAGE: typescript
CODE:
declare const failCause: <E>(cause: Cause.Cause<E>) => Exit<never, E>

----------------------------------------

TITLE: Checking for None in Option Type using TypeScript
DESCRIPTION: Demonstrates the usage of Option.isNone function to check if an Option represents the absence of a value (None). It includes examples of checking both Some and None cases.

LANGUAGE: typescript
CODE:
import { Option } from "effect"

console.log(Option.isNone(Option.some(1)))
// Output: false

console.log(Option.isNone(Option.none()))
// Output: true

----------------------------------------

TITLE: Implementing List.tail Function in TypeScript
DESCRIPTION: A function that returns the tail (all elements except the first) of a given list wrapped in an Option type. Returns None if the list is empty.

LANGUAGE: typescript
CODE:
declare const tail: <A>(self: List<A>) => Option.Option<List<A>>

----------------------------------------

TITLE: Creating Brand Errors in TypeScript using Effect-TS
DESCRIPTION: Function signature for creating a BrandErrors object containing a single RefinementError. Takes a message string and optional metadata as parameters.

LANGUAGE: typescript
CODE:
declare const error: (message: string, meta?: unknown) => Brand.BrandErrors

----------------------------------------

TITLE: Implementing Deferred.dieSync in TypeScript
DESCRIPTION: Function signature for dieSync, which kills a Deferred with a specified defect. The defect is propagated to all fibers waiting on the Deferred's value. Returns an Effect containing a boolean result.

LANGUAGE: typescript
CODE:
declare const dieSync: { 
  (evaluate: LazyArg<unknown>): <A, E>(self: Deferred<A, E>) => Effect.Effect<boolean>; 
  <A, E>(self: Deferred<A, E>, evaluate: LazyArg<unknown>): Effect.Effect<boolean>; 
}

----------------------------------------

TITLE: Using Ordering.match in TypeScript
DESCRIPTION: Demonstrates how to use the Ordering.match function to convert numeric ordering values (-1, 0, 1) into descriptive strings based on comparison results. The function accepts an options object with three handlers for less than, equal, and greater than cases.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Ordering } from "effect"
import { constant } from "effect/Function"

const toMessage = Ordering.match({
  onLessThan: constant('less than'),
  onEqual: constant('equal'),
  onGreaterThan: constant('greater than')
})

assert.deepStrictEqual(toMessage(-1), "less than")
assert.deepStrictEqual(toMessage(0), "equal")
assert.deepStrictEqual(toMessage(1), "greater than")

LANGUAGE: typescript
CODE:
declare const match: { <A, B, C = B>(options: { readonly onLessThan: LazyArg<A>; readonly onEqual: LazyArg<B>; readonly onGreaterThan: LazyArg<C>; }): (self: Ordering) => A | B | C; <A, B, C = B>(o: Ordering, options: { readonly onLessThan: LazyArg<A>; readonly onEqual: LazyArg<B>; readonly onGreaterThan: LazyArg<C>; }): A | B | C; }

----------------------------------------

TITLE: Defining ResponseAttributes Interface for GenAI Telemetry in TypeScript
DESCRIPTION: This code snippet defines the ResponseAttributes interface, which is part of the GenAI specification for telemetry. It includes properties for response ID, model name, and finish reasons, all of which are optional and potentially nullable.

LANGUAGE: typescript
CODE:
export interface ResponseAttributes {
    /**
     * The unique identifier for the completion.
     */
    readonly id?: string | null | undefined
    /**
     * The name of the model that generated the response.
     */
    readonly model?: string | null | undefined
    /**
     * Array of reasons the model stopped generating tokens, corresponding to
     * each generation received.
     */
    readonly finishReasons?: ReadonlyArray<string> | null | undefined
  }

----------------------------------------

TITLE: Retrieving Earliest Interval Start in TypeScript
DESCRIPTION: This function returns the start time of the earliest interval in a specified set of Intervals. It takes an Intervals object as input and returns a number representing the start time.

LANGUAGE: typescript
CODE:
declare const start: (self: Intervals) => number

----------------------------------------

TITLE: Defining dropRight Function for Stream Module in TypeScript
DESCRIPTION: This code snippet defines the dropRight function for the Stream module. It drops the last specified number of elements from a stream. The function has two overloads: one that takes the number of elements to drop as the first argument, and another that takes the stream as the first argument and the number of elements to drop as the second.

LANGUAGE: typescript
CODE:
declare const dropRight: { (n: number): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, n: number): Stream<A, E, R>; }

----------------------------------------

TITLE: Filtering None Values from Trie of Options in TypeScript
DESCRIPTION: Demonstrates how to use the Trie.compact function to filter out None values from a Trie of Options. The example creates a Trie with Some and None values, compacts it, and compares the result with an expected Trie.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Trie, Equal, Option } from "effect"

const trie = Trie.empty<Option.Option<number>>().pipe(
  Trie.insert("shells", Option.some(0)),
  Trie.insert("sells", Option.none()),
  Trie.insert("she", Option.some(2))
)

const trieMapV = Trie.empty<number>().pipe(
  Trie.insert("shells", 0),
  Trie.insert("she", 2)
)

assert.equal(Equal.equals(Trie.compact(trie), trieMapV), true)

----------------------------------------

TITLE: Type Signature for catWithLine Function
DESCRIPTION: The type signature for the catWithLine combinator, showing its polymorphic nature and support for different document types through generics.

LANGUAGE: typescript
CODE:
declare const catWithLine: { <B>(that: Doc<B>): <A>(self: Doc<A>) => Doc<B | A>; <A, B>(self: Doc<A>, that: Doc<B>): Doc<A | B>; }

----------------------------------------

TITLE: Implementing Error Recovery in TypeScript using Micro.orElseSucceed
DESCRIPTION: The orElseSucceed function allows recovery from all errors by succeeding with a specified value. It takes a lazy argument function and returns a new Micro effect that will never fail.

LANGUAGE: typescript
CODE:
declare const orElseSucceed: { <B>(f: LazyArg<B>): <A, E, R>(self: Micro<A, E, R>) => Micro<A | B, never, R>; <A, E, R, B>(self: Micro<A, E, R>, f: LazyArg<B>): Micro<A | B, never, R>; }

----------------------------------------

TITLE: TypeScript Signature of Effect.filter Function
DESCRIPTION: This code block shows the TypeScript signature of the Effect.filter function. It includes overloaded versions for different parameter orders and optional configuration options.

LANGUAGE: typescript
CODE:
declare const filter: { <A, E, R>(predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly negate?: boolean | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): (elements: Iterable<A>) => Effect<Array<A>, E, R>; <A, E, R>(elements: Iterable<A>, predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly batching?: boolean | "inherit" | undefined; readonly negate?: boolean | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): Effect<Array<A>, E, R>; }

----------------------------------------

TITLE: getLefts Function Signature
DESCRIPTION: Type signature for the getLefts function that takes an Iterable of Either<R, L> and returns an Iterable of L (Left values).

LANGUAGE: typescript
CODE:
declare const getLefts: <R, L>(self: Iterable<Either<R, L>>) => Iterable<L>

----------------------------------------

TITLE: Using Ordering.Monoid in TypeScript
DESCRIPTION: Demonstrates the usage of the Monoid instance for Ordering. It shows how to combine Ordering values using the Monoid.combine function, including combining with the empty value and combining non-zero values.

LANGUAGE: typescript
CODE:
import { Monoid } from "@effect/typeclass/data/Ordering"

console.log(Monoid.combine(Monoid.empty, -1))
// -1
console.log(Monoid.combine(Monoid.empty, 1))
// 1
console.log(Monoid.combine(1, -1))
// 1

----------------------------------------

TITLE: Filtering Groups in Effect GroupBy Module
DESCRIPTION: Defines a filter function that accepts a predicate to filter groups in a GroupBy structure. The function is overloaded to support both curried and non-curried forms, allowing flexible usage patterns for group filtering operations.

LANGUAGE: typescript
CODE:
declare const filter: { 
  <K>(predicate: Predicate<NoInfer<K>>): <V, E, R>(self: GroupBy<K, V, E, R>) => GroupBy<K, V, E, R>; 
  <K, V, E, R>(self: GroupBy<K, V, E, R>, predicate: Predicate<K>): GroupBy<K, V, E, R>; 
}

----------------------------------------

TITLE: Creating a Trie from Iterable in TypeScript
DESCRIPTION: Demonstrates how to create a Trie from an iterable collection of key/value pairs using the Trie.fromIterable function. It also shows how to extract entries from the Trie and compare it with a manually created Trie.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Trie, Equal } from "effect"

const iterable: Array<readonly [string, number]> = [["call", 0], ["me", 1], ["mind", 2], ["mid", 3]]
const trie = Trie.fromIterable(iterable)

// The entries in the `Trie` are extracted in alphabetical order, regardless of the insertion order
assert.deepStrictEqual(Array.from(trie), [["call", 0], ["me", 1], ["mid", 3], ["mind", 2]])
assert.equal(Equal.equals(Trie.make(["call", 0], ["me", 1], ["mind", 2], ["mid", 3]), trie), true)

----------------------------------------

TITLE: Accessing Current Context in Micro Module (TypeScript)
DESCRIPTION: The context function allows access to the current Context from the environment. It is generic over type R and returns a Micro<Context.Context<R>>.

LANGUAGE: typescript
CODE:
declare const context: <R>() => Micro<Context.Context<R>>

----------------------------------------

TITLE: Defining Recurrence Schedule with Conditional Mapping in TypeScript
DESCRIPTION: This function creates a schedule that recurs until a partial function returns Some(value), then maps the result to Option<B>. It's useful for defining schedules that stop on a condition and transform the final value.

LANGUAGE: typescript
CODE:
declare const recurUntilOption: <A, B>(pf: (a: A) => Option.Option<B>) => Schedule<Option.Option<B>, A>

----------------------------------------

TITLE: Using hardLine for Forced Line Breaks in Effect Printer
DESCRIPTION: Demonstrates how to use Doc.hardLine to create forced line breaks between text elements in a document. The example shows that even with ample line width, the hardLine forces a break in the output.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import * as String from "effect/String"

const doc: Doc.Doc<never> = Doc.hcat([
  Doc.text("lorem ipsum"),
  Doc.hardLine,
  Doc.text("dolor sit amet")
])

// Even with enough space, a line break is introduced
assert.strictEqual(
  Doc.render(doc, {
    style: "pretty",
    options: { lineWidth: 1000 }
  }),
  String.stripMargin(
    `|lorem ipsum
     |dolor sit amet`
  )
)

LANGUAGE: typescript
CODE:
declare const hardLine: Doc<never>

----------------------------------------

TITLE: Executing Micro Effects Synchronously in TypeScript
DESCRIPTION: Function signature for runSync that attempts to execute a Micro effect synchronously and return its success value. Takes a Micro effect with generic type parameters for the success value A and error type E.

LANGUAGE: typescript
CODE:
declare const runSync: <A, E>(effect: Micro<A, E>) => A

----------------------------------------

TITLE: Converting TMap to Array in TypeScript using STM
DESCRIPTION: Function that collects all key-value pair bindings from a TMap into an Array using Software Transactional Memory (STM). Takes a TMap as input and returns an STM transaction that produces an array of key-value tuples.

LANGUAGE: typescript
CODE:
declare const toArray: <K, V>(self: TMap<K, V>) => STM.STM<Array<[K, V]>>

----------------------------------------

TITLE: Function Signature of satisfies in TypeScript
DESCRIPTION: Provides the TypeScript type signature for the satisfies function. It shows that the function takes a type parameter A and returns a function that accepts a value of type B extending A, returning the same type B.

LANGUAGE: typescript
CODE:
declare const satisfies: <A>() => <B extends A>(b: B) => B

----------------------------------------

TITLE: Defining TArray.transform Function in TypeScript
DESCRIPTION: Declares the transform function for TArray, which atomically updates all elements using a pure function. It has two overloads: one that takes a function and returns a function that takes a TArray, and another that takes a TArray and a function directly.

LANGUAGE: typescript
CODE:
declare const transform: { <A>(f: (value: A) => A): (self: TArray<A>) => STM.STM<void>; <A>(self: TArray<A>, f: (value: A) => A): STM.STM<void>; }

----------------------------------------

TITLE: Creating HashSet with Custom Character Class Implementation
DESCRIPTION: Example demonstrating how to create a HashSet using HashSet.make with a custom Character class that implements Equal and Hash interfaces. Shows equality comparison between different HashSet construction methods.

LANGUAGE: typescript
CODE:
import { Equal, Hash, HashSet, pipe } from "effect"
import assert from "node:assert/strict"

class Character implements Equal.Equal {
  readonly name: string
  readonly trait: string

  constructor(name: string, trait: string) {
    this.name = name
    this.trait = trait
  }

  // Define equality based on name, and trait
  [Equal.symbol](that: Equal.Equal): boolean {
    if (that instanceof Character) {
      return (
        Equal.equals(this.name, that.name) &&
        Equal.equals(this.trait, that.trait)
      )
    }
    return false
  }

  // Generate a hash code based on the sum of the character's name and trait
  [Hash.symbol](): number {
    return Hash.hash(this.name + this.trait)
  }

  static readonly of = (name: string, trait: string): Character => {
    return new Character(name, trait)
  }
}

----------------------------------------

TITLE: Using Struct.keys for Type-Safe Key Extraction in TypeScript
DESCRIPTION: Demonstrates how to use Struct.keys to extract string keys from an object while maintaining type safety. The function filters out non-string keys (like symbols) and returns an array of string keys with proper typing.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Struct } from "effect"

const symbol: unique symbol = Symbol()

const value = {
  a: 1,
  b: 2,
  [symbol]: 3
}

const keys: Array<"a" | "b"> = Struct.keys(value)

assert.deepStrictEqual(keys, ["a", "b"])

LANGUAGE: typescript
CODE:
declare const keys: <T extends {}>(o: T) => Array<(keyof T) & string>

----------------------------------------

TITLE: Combining RuntimeFlagsPatch with both Operation in TypeScript
DESCRIPTION: Defines a function that combines two RuntimeFlagsPatch instances by applying both patches. The function supports both curried and uncurried calling styles.

LANGUAGE: typescript
CODE:
declare const both: { 
  (that: RuntimeFlagsPatch): (self: RuntimeFlagsPatch) => RuntimeFlagsPatch; 
  (self: RuntimeFlagsPatch, that: RuntimeFlagsPatch): RuntimeFlagsPatch; 
}

----------------------------------------

TITLE: Using Match.not for Pattern Matching in TypeScript
DESCRIPTION: Example demonstrating how to use Match.not to handle all values except a specific case. Creates a matcher for string or number values that returns 'ok' for all inputs except 'hi', which returns 'fallback'.

LANGUAGE: typescript
CODE:
import { Match } from "effect"

// Create a matcher for string or number values
const match = Match.type<string | number>().pipe(
  // Match any value except "hi", returning "ok"
  Match.not("hi", () => "ok"),
  // Fallback case for when the value is "hi"
  Match.orElse(() => "fallback")
)

console.log(match("hello"))
// Output: "ok"

console.log(match("hi"))
// Output: "fallback"

----------------------------------------

TITLE: Checking Logger Instance in TypeScript
DESCRIPTION: The isLogger function is a type guard that determines if a given value is an instance of Logger. It takes an unknown input and returns a boolean indicating whether the input is a Logger of unknown types.

LANGUAGE: typescript
CODE:
declare const isLogger: (u: unknown) => u is Logger<unknown, unknown>

----------------------------------------

TITLE: Defining Forbidden Class Constructor in TypeScript
DESCRIPTION: Defines the Forbidden class constructor that represents forbidden operations during parsing. Takes an AST node, the actual value encountered, and an optional error message as parameters.

LANGUAGE: typescript
CODE:
declare class Forbidden { constructor(
    readonly ast: AST.AST,
    readonly actual: unknown,
    readonly message?: string
  ) }

----------------------------------------

TITLE: Creating Fail Cause in TypeScript Effect Package
DESCRIPTION: Defines a function that constructs a Cause carrying an error of type E. Used to represent known or anticipated failures in effectful computations. The function takes an error parameter and returns a typed Cause instance.

LANGUAGE: typescript
CODE:
declare const fail: <E>(error: E) => Cause<E>

----------------------------------------

TITLE: Constructing Live Test Service Layer in TypeScript
DESCRIPTION: Creates a new Live service wrapped in a Layer. This function returns a Layer that provides a Live.TestLive service with no requirements beyond DefaultServices.

LANGUAGE: typescript
CODE:
declare const liveLayer: () => Layer.Layer<Live.TestLive, never, DefaultServices.DefaultServices>

----------------------------------------

TITLE: Effect.withLogSpan Type Definition
DESCRIPTION: Type signature for the withLogSpan function showing its polymorphic nature. It can be called either with the label first and effect second, or with effect first and label second.

LANGUAGE: typescript
CODE:
declare const withLogSpan: { (label: string): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(effect: Effect<A, E, R>, label: string): Effect<A, E, R>; }

----------------------------------------

TITLE: Updating URL Path with setPathname in TypeScript
DESCRIPTION: The setPathname function is used to update the path of a URL. It can be called with either a pathname and a URL, or just a pathname, returning a function that takes a URL. The function returns a new URL object with the updated path.

LANGUAGE: typescript
CODE:
declare const setPathname: { (pathname: string): (url: URL) => URL; (url: URL, pathname: string): URL; }

----------------------------------------

TITLE: Implementing Cursor Show Command in TypeScript
DESCRIPTION: Declares a constant cursorShow of type Ansi that implements the ANSI escape sequence to make the terminal cursor visible. This is part of the @effect/printer-ansi package's terminal control functionality.

LANGUAGE: typescript
CODE:
declare const cursorShow: Ansi

----------------------------------------

TITLE: Implementing List Partition Function in TypeScript
DESCRIPTION: Provides type definitions for a List partition operation that splits a list into two based on a predicate or refinement function. Returns a tuple containing excluded and satisfying elements. Supports both direct and curried function calls.

LANGUAGE: typescript
CODE:
declare const partition: {
  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: List<A>) => [excluded: List<Exclude<A, B>>, satisfying: List<B>];
  <A>(predicate: Predicate<NoInfer<A>>): (self: List<A>) => [excluded: List<A>, satisfying: List<A>];
  <A, B extends A>(self: List<A>, refinement: Refinement<A, B>): [excluded: List<Exclude<A, B>>, satisfying: List<B>];
  <A>(self: List<A>, predicate: Predicate<A>): [excluded: List<A>, satisfying: List<A>];
}

----------------------------------------

TITLE: Using getSomes with Effect Iterable
DESCRIPTION: Demonstrates how to use the getSomes function to extract valid Some values from an Iterable of Options, filtering out None values.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Iterable, Option } from "effect"

assert.deepStrictEqual(
  Array.from(Iterable.getSomes([Option.some(1), Option.none(), Option.some(2)])),
  [1, 2]
)

LANGUAGE: typescript
CODE:
declare const getSomes: <A>(self: Iterable<Option<A>>) => Iterable<A>

----------------------------------------

TITLE: Using Iterable.replicate in TypeScript
DESCRIPTION: Example showing how to use the replicate function to create an iterable that repeats a value multiple times. The function takes a value and a number parameter and returns an Iterable containing the value repeated n times.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { replicate } from "effect/Iterable"

assert.deepStrictEqual(Array.from(replicate("a", 3)), ["a", "a", "a"])

LANGUAGE: typescript
CODE:
declare const replicate: { (n: number): <A>(a: A) => Iterable<A>; <A>(a: A, n: number): Iterable<A>; }

----------------------------------------

TITLE: Implementing scanReduce Function for Stream in TypeScript
DESCRIPTION: Defines the scanReduce function for the Stream module. This function statefully maps over the elements of a stream to produce all intermediate results. It's similar to the scan function but includes the initial value in the output.

LANGUAGE: typescript
CODE:
declare const scanReduce: { <A2, A>(f: (a2: A2 | A, a: A) => A2): <E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E, R>; <A, E, R, A2>(self: Stream<A, E, R>, f: (a2: A | A2, a: A) => A2): Stream<A | A2, E, R>; }

----------------------------------------

TITLE: Checking for FlatAlt Doc Type in TypeScript
DESCRIPTION: The isFlatAlt function checks if a given Doc is of type FlatAlt. It returns true if the Doc is a FlatAlt, false otherwise. This function is useful for type checking and conditional logic based on Doc types.

LANGUAGE: typescript
CODE:
declare const isFlatAlt: <A>(self: Doc<A>) => self is FlatAlt<A>

----------------------------------------

TITLE: Implementing Effect Racing with Micro.raceAll in TypeScript
DESCRIPTION: Function signature for raceAll that takes an Iterable of Micro effects and returns a new effect that completes when the first effect succeeds. The function interrupts all other effects once a winner is determined. Returns a Micro effect parameterized with the success, error and context types of the input effects.

LANGUAGE: typescript
CODE:
declare const raceAll: <Eff extends Micro<any, any, any>>(all: Iterable<Eff>) => Micro<Micro.Success<Eff>, Micro.Error<Eff>, Micro.Context<Eff>>

----------------------------------------

TITLE: Decoding Base64 Strings in TypeScript using Effect
DESCRIPTION: This function decodes a base64 (RFC4648) encoded string into a UTF-8 string. It returns an Either type, which can contain either the decoded string or a DecodeException if the decoding fails.

LANGUAGE: typescript
CODE:
declare const decodeBase64String: (str: string) => Either.Either<string, DecodeException>

----------------------------------------

TITLE: Implementing Stream FilterMap Operation in TypeScript
DESCRIPTION: Defines a filterMap operation that combines filtering and mapping in a single step. It takes a function that returns an Option type and applies it to stream elements, effectively filtering out None results and unwrapping Some values.

LANGUAGE: typescript
CODE:
declare const filterMap: { <A, B>(pf: (a: A) => Option.Option<B>): <E, R>(self: Stream<A, E, R>) => Stream<B, E, R>; <A, E, R, B>(self: Stream<A, E, R>, pf: (a: A) => Option.Option<B>): Stream<B, E, R>; }

----------------------------------------

TITLE: Implementing Document Annotation Removal in TypeScript
DESCRIPTION: Function signature for unAnnotate, which takes a Doc<A> and returns a Doc<never>. This function removes all annotations from a document tree, though it's noted that using unAnnotateS after producing layout is preferable for performance reasons.

LANGUAGE: typescript
CODE:
declare const unAnnotate: <A>(self: Doc<A>) => Doc<never>

----------------------------------------

TITLE: Looping with Collected Results Using Effect.loop in TypeScript
DESCRIPTION: Example of using Effect.loop to create a loop that runs 5 times, collecting each iteration's result in an array.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

// A loop that runs 5 times, collecting each iteration's result
const result = Effect.loop(
  // Initial state
  1,
  {
    // Condition to continue looping
    while: (state) => state <= 5,
    // State update function
    step: (state) => state + 1,
    // Effect to be performed on each iteration
    body: (state) => Effect.succeed(state)
  }
)

Effect.runPromise(result).then(console.log)
// Output: [1, 2, 3, 4, 5]

----------------------------------------

TITLE: TypeScript Signature for HashSet.toggle Function
DESCRIPTION: Provides the TypeScript type signature for the HashSet.toggle function. It shows that the function can be used in both data-first and data-last styles, operating on a HashSet of type A and a value of type A.

LANGUAGE: typescript
CODE:
declare const toggle: { <A>(value: A): (self: HashSet<A>) => HashSet<A>; <A>(self: HashSet<A>, value: A): HashSet<A>; }

----------------------------------------

TITLE: Creating Stream from Iterable Effect - TypeScript Example
DESCRIPTION: Demonstrates how to create a stream from an effect that produces an array of users. Shows integration with a Database context and effect handling.

LANGUAGE: typescript
CODE:
import { Context, Effect, Stream } from "effect"

class Database extends Context.Tag("Database")<
  Database,
  { readonly getUsers: Effect.Effect<Array<string>> }
>() {}

const getUsers = Database.pipe(Effect.andThen((_) => _.getUsers))

const stream = Stream.fromIterableEffect(getUsers)

Effect.runPromise(
  Stream.runCollect(stream.pipe(Stream.provideService(Database, { getUsers: Effect.succeed(["user1", "user2"]) })))
).then(console.log)
// { _id: 'Chunk', values: [ 'user1', 'user2' ] }

----------------------------------------

TITLE: Testing Symbol Type in TypeScript using Effect's Predicate
DESCRIPTION: This code snippet demonstrates how to use the isSymbol function from Effect's Predicate module to test if a value is a symbol. It shows both a positive and negative test case.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Predicate } from "effect"

assert.deepStrictEqual(Predicate.isSymbol(Symbol.for("a")), true)
assert.deepStrictEqual(Predicate.isSymbol("a"), false)

----------------------------------------

TITLE: Defining Prompt Action Type in TypeScript
DESCRIPTION: Defines a union type representing different actions a Prompt can take: Beep, NextFrame, or Submit. It uses a TaggedEnum structure to create a discriminated union with associated data for each action type.

LANGUAGE: typescript
CODE:
type { readonly _tag: "Beep"; } | { readonly _tag: "NextFrame"; readonly state: State; } | { readonly _tag: "Submit"; readonly value: Output; } = TaggedEnum<{
    readonly Beep: {}
    readonly NextFrame: { readonly state: State }
    readonly Submit: { readonly value: Output }
  }>

----------------------------------------

TITLE: Retrieving Current Version of Reloadable Service in TypeScript
DESCRIPTION: The get function retrieves the current version of a reloadable service. It takes a Context.Tag as an argument and returns an Effect that resolves to a Reloadable instance of the specified type.

LANGUAGE: typescript
CODE:
declare const get: <I, S>(tag: Context.Tag<I, S>) => Effect.Effect<S, never, Reloadable<I>>

----------------------------------------

TITLE: Trie Map Function Signature in TypeScript
DESCRIPTION: Provides the TypeScript signature for the `map` function in the `Trie` module. It shows both the curried and uncurried versions of the function, which transform values in the Trie based on a provided mapping function.

LANGUAGE: typescript
CODE:
declare const map: { <A, V>(f: (value: V, key: string) => A): (self: Trie<V>) => Trie<A>; <V, A>(self: Trie<V>, f: (value: V, key: string) => A): Trie<A>; }

----------------------------------------

TITLE: Request.Class Constructor Type Definition
DESCRIPTION: Type signature for the Request.Class constructor showing its generic type parameters and conditional type checking for additional properties.

LANGUAGE: typescript
CODE:
declare const Class: new <Success, Error, A extends Record<string, any>>(args: Types.Equals<Omit<A, keyof Request<unknown, unknown>>, {}> extends true ? void : { readonly [P in keyof A as P extends keyof Request<unknown, unknown> ? never : P]: A[P]; }) => Request<Success, Error> & Readonly<A>

----------------------------------------

TITLE: Defining InvalidPubSubCapacityException Interface in TypeScript
DESCRIPTION: TypeScript interface definition for InvalidPubSubCapacityException that extends YieldableError. This exception is used to handle cases where an invalid capacity is specified for a PubSub implementation. It includes a readonly _tag property and a symbolic property for type identification.

LANGUAGE: typescript
CODE:
export interface InvalidPubSubCapacityException extends YieldableError {
  readonly _tag: "InvalidPubSubCapacityException"
  readonly [InvalidPubSubCapacityExceptionTypeId]: InvalidPubSubCapacityExceptionTypeId
}

----------------------------------------

TITLE: SK Combinator Function Signature in TypeScript
DESCRIPTION: This snippet shows the TypeScript signature of the SK combinator function. It defines a generic function that takes two arguments of types A and B, and returns a value of type B.

LANGUAGE: typescript
CODE:
declare const SK: <A, B>(_: A, b: B) => B

----------------------------------------

TITLE: Effect.withEarlyRelease TypeScript Function Signature
DESCRIPTION: The TypeScript function signature for Effect.withEarlyRelease, showing its input and output types. It takes an Effect and returns an Effect that yields both a finalizer and the original effect's result.

LANGUAGE: typescript
CODE:
declare const withEarlyRelease: <A, E, R>(self: Effect<A, E, R>) => Effect<[finalizer: Effect<void>, result: A], E, R | Scope.Scope>

----------------------------------------

TITLE: Defining Deferred.die Function in TypeScript
DESCRIPTION: Declares the die function for the Deferred module. This function kills a Deferred with a specified defect, propagating it to all fibers waiting on the Deferred's value. It returns an Effect that resolves to a boolean.

LANGUAGE: typescript
CODE:
declare const die: { (defect: unknown): <A, E>(self: Deferred<A, E>) => Effect.Effect<boolean>; <A, E>(self: Deferred<A, E>, defect: unknown): Effect.Effect<boolean>; }

----------------------------------------

TITLE: Implementing Differ.patch in TypeScript
DESCRIPTION: Defines a patch function that takes a patch and an old value to produce an updated value. The function is overloaded to support both curried and direct invocation patterns.

LANGUAGE: typescript
CODE:
declare const patch: { 
  <Patch, Value>(patch: Patch, oldValue: Value): (self: Differ<Value, Patch>) => Value; 
  <Patch, Value>(self: Differ<Value, Patch>, patch: Patch, oldValue: Value): Value; 
}

----------------------------------------

TITLE: Testing Number Type with Effect Library
DESCRIPTION: Example showing how to use the isNumber function to test if values are numbers. The function returns true for numeric values and false for non-numeric values.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { isNumber } from "effect/Number"

assert.deepStrictEqual(isNumber(2), true)
assert.deepStrictEqual(isNumber("2"), false)

LANGUAGE: typescript
CODE:
declare const isNumber: (input: unknown) => input is number

----------------------------------------

TITLE: TypeScript Function Signature for Url.modifyUrlParams in @effect/platform
DESCRIPTION: This code block shows the TypeScript function signature for the Url.modifyUrlParams function. It demonstrates the function's overloaded nature, allowing for both curried and non-curried usage.

LANGUAGE: typescript
CODE:
declare const modifyUrlParams: { (f: (urlParams: UrlParams.UrlParams) => UrlParams.UrlParams): (url: URL) => URL; (url: URL, f: (urlParams: UrlParams.UrlParams) => UrlParams.UrlParams): URL; }

----------------------------------------

TITLE: Type Definition for Array.intersectionWith in TypeScript
DESCRIPTION: Provides the type signature for the Array.intersectionWith function. It takes an equivalence function and returns a function that can be applied to two Iterables to produce an Array of common elements.

LANGUAGE: typescript
CODE:
declare const intersectionWith: <A>(isEquivalent: (self: A, that: A) => boolean) => { (that: Iterable<A>): (self: Iterable<A>) => Array<A>; (self: Iterable<A>, that: Iterable<A>): Array<A>; }

----------------------------------------

TITLE: Transforming Array Elements with State Using Effect.mapAccum in TypeScript
DESCRIPTION: This example demonstrates how to use Effect.mapAccum to transform an array of strings while accumulating state. It capitalizes each string and keeps track of the total length of all strings processed.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

// Define an initial state and a transformation function
const initialState = 0

const transformation = (state: number, element: string) =>
  Effect.succeed<[number, string]>([state + element.length, element.toUpperCase()])

// Apply mapAccum to transform an array of strings
const program = Effect.mapAccum(["a", "bb", "ccc"], initialState, transformation)

Effect.runPromise(program).then(([finalState, transformedCollection]) => {
  console.log(finalState)
  console.log(transformedCollection)
})
// Output:
// 6
// [ 'A', 'BB', 'CCC' ]

----------------------------------------

TITLE: Creating Cache Statistics in TypeScript using Effect-TS
DESCRIPTION: Function to create a new CacheStats object with specified hit count, miss count, and cache size metrics. This is part of the Cache module in the effect package for managing cache performance statistics.

LANGUAGE: typescript
CODE:
declare const makeCacheStats: (options: { readonly hits: number; readonly misses: number; readonly size: number; }) => CacheStats

----------------------------------------

TITLE: Implementing Cursor Movement in TypeScript using ANSI Escape Codes
DESCRIPTION: The cursorMove function moves the cursor position by the specified number of rows and columns relative to the current position. It handles edge cases where the cursor is already at the screen edge.

LANGUAGE: typescript
CODE:
declare const cursorMove: (column: number, row?: number) => Ansi

----------------------------------------

TITLE: Implementing Iterable Zip Operation in TypeScript
DESCRIPTION: Defines a zip function that takes two Iterables and combines them into a single Iterable of paired values. The function supports both curried and uncurried versions for flexibility in usage.

LANGUAGE: typescript
CODE:
declare const zip: { <B>(that: Iterable<B>): <A>(self: Iterable<A>) => Iterable<[A, B]>; <A, B>(self: Iterable<A>, that: Iterable<B>): Iterable<[A, B]>; }

----------------------------------------

TITLE: Defining Column Interface in TypeScript for @effect/printer
DESCRIPTION: Defines a TypeScript interface for Column that extends Doc.Variance<A>. The interface represents a document that can react to the current cursor position through a reaction function.

LANGUAGE: typescript
CODE:
export interface Column<A> extends Doc.Variance<A> {
  readonly _tag: "Column"
  readonly react: (position: number) => Doc<A>
}

----------------------------------------

TITLE: Doc.reflow Function Signature in TypeScript
DESCRIPTION: Provides the TypeScript function signature for the Doc.reflow function. It takes a string and an optional character to split on, returning a Doc<never> type.

LANGUAGE: typescript
CODE:
declare const reflow: (s: string, char?: string) => Doc<never>

----------------------------------------

TITLE: Declaring Sleep Function in TypeScript for Micro Effects
DESCRIPTION: This snippet defines the signature of the sleep function in the Micro module. It creates a Micro effect that sleeps for a specified number of milliseconds.

LANGUAGE: typescript
CODE:
declare const sleep: (millis: number) => Micro<void>

----------------------------------------

TITLE: Defining 'none' Supervisor in TypeScript
DESCRIPTION: Declares a constant 'none' of type Supervisor<void> that doesn't perform any actions in response to supervision events.

LANGUAGE: typescript
CODE:
declare const none: Supervisor<void>

----------------------------------------

TITLE: Implementing Record Difference Operation in TypeScript
DESCRIPTION: Defines a function to merge two records, preserving only the entries that are unique to each record. It supports both curried and non-curried function calls with generic types for keys and values.

LANGUAGE: typescript
CODE:
declare const difference: { <K1 extends string, B>(that: ReadonlyRecord<K1, B>): <K0 extends string, A>(self: ReadonlyRecord<K0, A>) => Record<K0 | K1, A | B>; <K0 extends string, A, K1 extends string, B>(self: ReadonlyRecord<K0, A>, that: ReadonlyRecord<K1, B>): Record<K0 | K1, A | B>; }

----------------------------------------

TITLE: Constructing Date Config in TypeScript
DESCRIPTION: This function constructs a config for a date value. It takes an optional name parameter and returns a Config<Date> object.

LANGUAGE: typescript
CODE:
declare const date: (name?: string) => Config<Date>

----------------------------------------

TITLE: Option.filterMap Type Signature in TypeScript
DESCRIPTION: The type signature for the filterMap function, showing its polymorphic nature and support for both curried and uncurried forms. It takes a transformation function and returns a new Option.

LANGUAGE: typescript
CODE:
declare const filterMap: { <A, B>(f: (a: A) => Option<B>): (self: Option<A>) => Option<B>; <A, B>(self: Option<A>, f: (a: A) => Option<B>): Option<B>; }

----------------------------------------

TITLE: Lifting Binary Function for Option Values in TypeScript
DESCRIPTION: Demonstrates how to use Option.lift2 to apply a binary function to two Option values. It shows examples of successful application with two Some values and a case where one Option is None.

LANGUAGE: typescript
CODE:
import { Option } from "effect"

// A binary function to add two numbers
const add = (a: number, b: number): number => a + b

// Lift the `add` function to work with `Option` values
const addOptions = Option.lift2(add)

// Both `Option`s are `Some`
console.log(addOptions(Option.some(2), Option.some(3)))
// Output: { _id: 'Option', _tag: 'Some', value: 5 }

// One `Option` is `None`
console.log(addOptions(Option.some(2), Option.none()))
// Output: { _id: 'Option', _tag: 'None' }

----------------------------------------

TITLE: Defining TimeoutException Interface in TypeScript
DESCRIPTION: Interface definition for TimeoutException that extends YieldableError. It includes a readonly _tag property set to 'TimeoutException' and a TimeoutExceptionTypeId symbol property.

LANGUAGE: typescript
CODE:
export interface TimeoutException extends YieldableError {
  readonly _tag: "TimeoutException"
  readonly [TimeoutExceptionTypeId]: TimeoutExceptionTypeId
}

----------------------------------------

TITLE: Defining FunctionWithSpanOptions Interface in TypeScript
DESCRIPTION: Interface that specifies options for creating a new span when wrapping effect-returning functions for tracing. Includes configuration for span name, attributes, links, parent span, root status, context, and span kind.

LANGUAGE: typescript
CODE:
export interface FunctionWithSpanOptions {
  readonly name: string
  readonly attributes?: Record<string, unknown> | undefined
  readonly links?: ReadonlyArray<Tracer.SpanLink> | undefined
  readonly parent?: Tracer.AnySpan | undefined
  readonly root?: boolean | undefined
  readonly context?: Context.Context<never> | undefined
  readonly kind?: Tracer.SpanKind | undefined
}

----------------------------------------

TITLE: Converting TMap to ReadonlyMap in TypeScript using Effect
DESCRIPTION: A function that collects all key-value bindings from a TMap structure and converts them into a ReadonlyMap. This operation is performed within an STM (Software Transactional Memory) context.

LANGUAGE: typescript
CODE:
declare const toMap: <K, V>(self: TMap<K, V>) => STM.STM<ReadonlyMap<K, V>>

----------------------------------------

TITLE: Removing Fail and Interrupt Nodes from Cause in TypeScript
DESCRIPTION: The stripFailures function removes Fail and Interrupt nodes from a Cause, keeping only defects (Die). It returns a Cause<never> that can still store Die or finalizer-related defects, useful for analyzing only the irrecoverable portion of an error.

LANGUAGE: typescript
CODE:
declare const stripFailures: <E>(self: Cause<E>) => Cause<never>

----------------------------------------

TITLE: Declaring lessThanEqual Function for RedBlackTree in TypeScript
DESCRIPTION: Defines a function that returns an iterator to traverse entries in a RedBlackTree with keys less than or equal to a specified key. It supports both curried and non-curried invocations.

LANGUAGE: typescript
CODE:
declare const lessThanEqual: { <K>(key: K): <V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>; <K, V>(self: RedBlackTree<K, V>, key: K): Iterable<[K, V]>; }

----------------------------------------

TITLE: Implementing TestClock Save Operation in TypeScript
DESCRIPTION: Defines a function that saves the current state of a TestClock instance and returns an Effect that can restore the saved state. This is useful for testing time-dependent behaviors in Effect-based applications.

LANGUAGE: typescript
CODE:
declare const save: () => Effect.Effect<Effect.Effect<void>>

----------------------------------------

TITLE: Declaring InterruptedExceptionTypeId Symbol in TypeScript
DESCRIPTION: Declares a constant InterruptedExceptionTypeId as a unique symbol. This symbol is used to identify InterruptedException instances, typically for internal use in handling fiber interruption logic.

LANGUAGE: typescript
CODE:
declare const InterruptedExceptionTypeId: unique symbol

----------------------------------------

TITLE: Creating HTTP Layer for ShardManager in TypeScript
DESCRIPTION: Defines a function 'layerHttpOptions' that creates an HTTP layer for the ShardManager server. It adds a route to the provided HttpRouter.Tag, with options for customizing the path, router tag, runner details, and logging behavior.

LANGUAGE: typescript
CODE:
declare const layerHttpOptions: <I = HttpRouter.Default>(options: { readonly path: HttpRouter.PathInput; readonly routerTag?: HttpRouter.HttpRouter.TagClass<I, string, any, any>; readonly runnerPath: string; readonly runnerHttps?: boolean | undefined; readonly logAddress?: boolean | undefined; }) => Layer.Layer<ShardManager.ShardManager, never, RpcSerialization.RpcSerialization | ShardStorage | RunnerHealth.RunnerHealth | HttpClient.HttpClient | HttpServer.HttpServer | ShardManager.Config | ShardingConfig>

----------------------------------------

TITLE: Separating Iterable Based on Predicate in TypeScript
DESCRIPTION: The separate function splits an Iterable of Either values into two arrays. It returns a tuple containing an array of Left values and an array of Right values. This function is useful for partitioning data based on success or failure conditions.

LANGUAGE: typescript
CODE:
declare const separate: <T extends Iterable<Either.Either<any, any>>>(self: T) => [Array<Either.Either.Left<ReadonlyArray.Infer<T>>>, Array<Either.Either.Right<ReadonlyArray.Infer<T>>>]

----------------------------------------

TITLE: Defining DocTree Type in TypeScript
DESCRIPTION: Defines a union type DocTree<A> that represents a document tree structure. It consists of various tree node types including EmptyTree, CharTree, TextTree, LineTree, AnnotationTree, and ConcatTree. This structure is optimized for rendering to formats like HTML where a hierarchical representation is preferred over linear streams.

LANGUAGE: typescript
CODE:
type DocTree<A> = | EmptyTree<A>
  | CharTree<A>
  | TextTree<A>
  | LineTree<A>
  | AnnotationTree<A>
  | ConcatTree<A>

----------------------------------------

TITLE: Implementing Layer.discard Function in TypeScript
DESCRIPTION: Function signature for Layer.discard that takes a Layer with generic types for input (RIn), error (E), and output (ROut) and returns a Layer that preserves side effects but discards output. The returned Layer has a 'never' output type, maintaining the original error and input types.

LANGUAGE: typescript
CODE:
declare const discard: <RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Layer<never, E, RIn>

----------------------------------------

TITLE: Interleaving Streams in TypeScript using Effect Library
DESCRIPTION: Demonstrates how to use the Stream.interleave function to combine two streams by alternating their values. The example creates two streams, interleaves them, and then collects and logs the result.

LANGUAGE: typescript
CODE:
import { Effect, Stream } from "effect"

const s1 = Stream.make(1, 2, 3)
const s2 = Stream.make(4, 5, 6)

const stream = Stream.interleave(s1, s2)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 1, 4, 2, 5, 3, 6 ] }

----------------------------------------

TITLE: Using Doc.vcat for Vertical Document Concatenation in TypeScript
DESCRIPTION: Demonstrates how to use Doc.vcat to vertically concatenate words in a document. The example shows how words are arranged vertically with line breaks between them, while maintaining proper formatting.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import * as String from "effect/String"

const doc: Doc.Doc<never> = Doc.vcat(Doc.words("lorem ipsum dolor"))

assert.strictEqual(
  Doc.render(doc, { style: "pretty" }),
  String.stripMargin(
    `|lorem
     |ipsum
     |dolor`
  )
)

LANGUAGE: typescript
CODE:
declare const vcat: <A>(docs: Iterable<Doc<A>>) => Doc<A>

----------------------------------------

TITLE: Declaring succeedNone Function in TypeScript
DESCRIPTION: Defines a constant succeedNone of type Micro<Option.Option<never>, never, never>. This function creates a Micro effect that succeeds with None.

LANGUAGE: typescript
CODE:
declare const succeedNone: Micro<Option.Option<never>, never, never>

----------------------------------------

TITLE: Extracting Values from Either Types in TypeScript
DESCRIPTION: The getOrThrow function extracts the value of an Either or throws if the Either is Left. It throws a default error of 'Error("getOrThrow called on a Left")'. This example demonstrates how to use getOrThrow with Either.right and Either.left.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Either } from "effect"

assert.deepStrictEqual(Either.getOrThrow(Either.right(1)), 1)
assert.throws(() => Either.getOrThrow(Either.left("error")))

----------------------------------------

TITLE: Defining Pretty-Print Function for RuntimeFiber in TypeScript
DESCRIPTION: Declares a function named 'pretty' that takes a RuntimeFiber object and returns an Effect containing a string representation. This function is used for pretty-printing RuntimeFiber objects.

LANGUAGE: typescript
CODE:
declare const pretty: <A, E>(self: RuntimeFiber<A, E>) => Effect.Effect<string>

----------------------------------------

TITLE: Using constVoid Function in TypeScript
DESCRIPTION: Demonstrates usage of the constVoid function which is a thunk that always returns void (undefined). The example shows how to import and use the function with assertion testing.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { constVoid } from "effect/Function"

assert.deepStrictEqual(constVoid(), undefined)

LANGUAGE: typescript
CODE:
declare const constVoid: LazyArg<void>

----------------------------------------

TITLE: Checking Empty Interval in TypeScript
DESCRIPTION: A function that determines whether a given Interval is empty. Returns a boolean value indicating the emptiness status of the interval.

LANGUAGE: typescript
CODE:
declare const isEmpty: (self: Interval) => boolean

----------------------------------------

TITLE: Transforming Struct Values with Effect Struct.evolve
DESCRIPTION: Demonstrates how to use Struct.evolve to transform values in an object by applying specific transformation functions to selected keys. Untransformed keys retain their original values.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { pipe, Struct } from "effect"

assert.deepStrictEqual(
  pipe(
    { a: 'a', b: 1, c: 3 },
    Struct.evolve({
      a: (a) => a.length,
      b: (b) => b * 2
    })
  ),
  { a: 1, b: 2, c: 3 }
)

LANGUAGE: typescript
CODE:
declare const evolve: { <O, T>(t: PartialTransform<O, T>): (obj: O) => Transformed<O, T>; <O, T>(obj: O, t: PartialTransform<O, T>): Transformed<O, T>; }

----------------------------------------

TITLE: Implementing Record.some Function in TypeScript
DESCRIPTION: Type signature for a function that checks if any entry in a readonly record meets a predicate condition. The function can be used in both curried and non-curried forms, taking a predicate function that receives value and key parameters.

LANGUAGE: typescript
CODE:
declare const some: {
  <A, K extends string>(predicate: (value: A, key: K) => boolean): (self: ReadonlyRecord<K, A>) => boolean;
  <K extends string, A>(self: ReadonlyRecord<K, A>, predicate: (value: A, key: K) => boolean): boolean;
}

----------------------------------------

TITLE: Implementing Any Value Matcher in TypeScript
DESCRIPTION: Defines a SafeRefinement type that matches any value without applying restrictions. This is useful for creating flexible pattern matching conditions that accept all input types.

LANGUAGE: typescript
CODE:
declare const any: SafeRefinement<unknown, any>

----------------------------------------

TITLE: Defining raceBoth Function for Parallel Sink Execution in TypeScript
DESCRIPTION: Declares the raceBoth function which runs two sinks in parallel, returning the result or error from the one that finishes first. It supports optional capacity configuration and handles various type parameters for flexibility.

LANGUAGE: typescript
CODE:
declare const raceBoth: { <A1, In1, L1, E1, R1>(that: Sink<A1, In1, L1, E1, R1>, options?: { readonly capacity?: number | undefined; } | undefined): <A, In, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<Either.Either<A1, A>, In & In1, L1 | L, E1 | E, R1 | R>; <A, In, L, E, R, A1, In1, L1, E1, R1>(self: Sink<A, In, L, E, R>, that: Sink<A1, In1, L1, E1, R1>, options?: { readonly capacity?: number | undefined; } | undefined): Sink<Either.Either<A1, A>, In & In1, L | L1, E | E1, R | R1>; }

----------------------------------------

TITLE: Defining DocStream Type in TypeScript for @effect/printer
DESCRIPTION: Defines the DocStream type as a union of various stream subtypes. This type represents a document that has been laid out and is ready for rendering. It simplifies the complexity of the Doc type, making it easier to convert to other formats like plaintext or terminal output.

LANGUAGE: typescript
CODE:
type DocStream<A> = | FailedStream<A>
  | EmptyStream<A>
  | CharStream<A>
  | TextStream<A>
  | LineStream<A>
  | PushAnnotationStream<A>
  | PopAnnotationStream<A>

----------------------------------------

TITLE: Checking Doc Type with isChar Function in TypeScript
DESCRIPTION: A type predicate function that determines whether a given Doc instance is specifically of the Char variant. Returns true if the Doc is a Char, false otherwise. This function is part of the @effect/printer package's Doc module.

LANGUAGE: typescript
CODE:
declare const isChar: <A>(self: Doc<A>) => self is Char<A>

----------------------------------------

TITLE: TypeScript Function Signature for Option.bind
DESCRIPTION: Provides the TypeScript function signature for Option.bind, showing its type parameters and overloads. This signature defines how bind can be used with different argument configurations.

LANGUAGE: typescript
CODE:
declare const bind: { <N extends string, A extends object, B>(name: Exclude<N, keyof A>, f: (a: NoInfer<A>) => Option<B>): (self: Option<A>) => Option<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }>; <A extends object, N extends string, B>(self: Option<A>, name: Exclude<N, keyof A>, f: (a: NoInfer<A>) => Option<B>): Option<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }>; }

----------------------------------------

TITLE: Checking Key Existence in FiberMap using TypeScript
DESCRIPTION: The unsafeHas function is used to check if a key exists in a FiberMap. It has two overloaded signatures allowing for different parameter orderings. This function is part of the FiberMap module in the Effect package.

LANGUAGE: typescript
CODE:
declare const unsafeHas: { <K>(key: K): <A, E>(self: FiberMap<K, A, E>) => boolean; <K, A, E>(self: FiberMap<K, A, E>, key: K): boolean; }

----------------------------------------

TITLE: Declaring WindDown RuntimeFlag in TypeScript
DESCRIPTION: Declares the WindDown constant as a RuntimeFlag type. This flag determines whether the Effect runtime system will execute effects in wind-down mode, allowing fibers to continue execution uninterrupted even if interruption is enabled.

LANGUAGE: typescript
CODE:
declare const WindDown: RuntimeFlag

----------------------------------------

TITLE: Converting DateTime to Date in TypeScript
DESCRIPTION: The toDate function converts a DateTime object to a standard JavaScript Date object, applying the time zone first. It takes a DateTime as input and returns a Date object.

LANGUAGE: typescript
CODE:
declare const toDate: (self: DateTime) => Date

----------------------------------------

TITLE: Implementing ANSI Screen Clearing in TypeScript
DESCRIPTION: Defines a constant eraseDown of type Ansi that clears the terminal screen from the current cursor position to the bottom. The cursor position remains unchanged after the operation.

LANGUAGE: typescript
CODE:
declare const eraseDown: Ansi

----------------------------------------

TITLE: Extracting Tagged Union Types in TypeScript using Effect.ts
DESCRIPTION: The ExtractTag type utility extracts a specific variant from a discriminated union based on the _tag property value. It uses TypeScript's Extract utility type to filter union members matching the specified tag.

LANGUAGE: typescript
CODE:
import type { Types } from "effect"

type Res = Types.ExtractTag<{ _tag: "a", a: number } | { _tag: "b", b: number }, "b"> // { _tag: "b", b: number }

LANGUAGE: typescript
CODE:
type ExtractTag<E, K> = Extract<E, { _tag: K }>

----------------------------------------

TITLE: Implementing Schedule.tapOutput Function in TypeScript
DESCRIPTION: Function signature for tapOutput that creates a modified schedule executing side effects on outputs. It accepts an effect-producing function and returns a new schedule that maintains the original behavior while performing the side effects after each step.

LANGUAGE: typescript
CODE:
declare const tapOutput: {
  <X, R2, Out>(f: (out: Types.NoInfer<Out>) => Effect.Effect<X, never, R2>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>;
  <Out, In, R, X, R2>(self: Schedule<Out, In, R>, f: (out: Out) => Effect.Effect<X, never, R2>): Schedule<Out, In, R | R2>;
}

----------------------------------------

TITLE: Declaring None RuntimeFlag Constant in TypeScript
DESCRIPTION: Defines a constant None of type RuntimeFlag that represents the absence of any runtime flags in the Effect system.

LANGUAGE: typescript
CODE:
declare const None: RuntimeFlag

----------------------------------------

TITLE: Initializing Socket Server Protocol Layer in TypeScript
DESCRIPTION: Defines a Layer that implements an RPC protocol using SocketServer for communication. The layer provides Protocol capabilities while requiring RpcSerialization and SocketServer dependencies.

LANGUAGE: typescript
CODE:
declare const layerProtocolSocketServer: Layer.Layer<Protocol, never, RpcSerialization.RpcSerialization | SocketServer.SocketServer>

----------------------------------------

TITLE: Defining Reloadable Interface in TypeScript
DESCRIPTION: Defines a generic interface for services that can be dynamically reloaded during runtime. The interface includes a scoped reference to the service implementation and a reload effect for swapping implementations.

LANGUAGE: typescript
CODE:
export interface Reloadable<in out A> extends Reloadable.Variance<A> {
  /**
   * @internal
   */
  readonly scopedRef: ScopedRef.ScopedRef<A>
  /**
   * @internal
   */
  readonly reload: Effect.Effect<void, unknown>
}

----------------------------------------

TITLE: Implementing findAll Operation for TMap in TypeScript
DESCRIPTION: Defines a function that searches through a TMap for key/value pairs matching a predicate and extracts values from matching pairs. The function supports both curried and non-curried calling styles and returns results wrapped in an STM monad.

LANGUAGE: typescript
CODE:
declare const findAll: { 
  <K, V, A>(pf: (key: K, value: V) => Option.Option<A>): (self: TMap<K, V>) => STM.STM<Array<A>>; 
  <K, V, A>(self: TMap<K, V>, pf: (key: K, value: V) => Option.Option<A>): STM.STM<Array<A>>; 
}

----------------------------------------

TITLE: Implementing STM.filterOrFail in TypeScript
DESCRIPTION: Defines a function that filters STM transactions and fails with a specified error if the predicate fails. The function provides overloads for both refinement and predicate-based filtering, with custom error handling for failed cases.

LANGUAGE: typescript
CODE:
declare const filterOrFail: { <A, B extends A, E2>(refinement: Refinement<NoInfer<A>, B>, orFailWith: (a: NoInfer<A>) => E2): <E, R>(self: STM<A, E, R>) => STM<B, E2 | E, R>; <A, E2>(predicate: Predicate<NoInfer<A>>, orFailWith: (a: NoInfer<A>) => E2): <E, R>(self: STM<A, E, R>) => STM<A, E2 | E, R>; <A, E, R, B extends A, E2>(self: STM<A, E, R>, refinement: Refinement<A, B>, orFailWith: (a: A) => E2): STM<B, E | E2, R>; <A, E, R, E2>(self: STM<A, E, R>, predicate: Predicate<A>, orFailWith: (a: A) => E2): STM<A, E | E2, R>; }

----------------------------------------

TITLE: Implementing Conditional Schedule Execution with Effect Predicates in TypeScript
DESCRIPTION: Defines a function that modifies a schedule to continue execution while an effectful predicate returns true for its output. The function supports both curried and uncurried calling styles and integrates with the Effect type system for handling side effects.

LANGUAGE: typescript
CODE:
declare const whileOutputEffect: {
  <Out, R2>(f: (out: Out) => Effect.Effect<boolean, never, R2>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>;
  <Out, In, R, R2>(self: Schedule<Out, In, R>, f: (out: Out) => Effect.Effect<boolean, never, R2>): Schedule<Out, In, R | R2>;
}

----------------------------------------

TITLE: Summing BigInts using Effect Library in TypeScript
DESCRIPTION: Demonstrates how to use the sumAll function from the Effect library's BigInt module to sum an array of bigint values. The function takes an Iterable of bigints and returns their sum as a single bigint.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { sumAll } from "effect/BigInt"

assert.deepStrictEqual(sumAll([2n, 3n, 4n]), 9n)

----------------------------------------

TITLE: Implementing Scope.use Function in TypeScript Effect Package
DESCRIPTION: Defines a function that provides closeable scope functionality to Effect operations. The scope is guaranteed to close with the effect's result upon completion, whether through success, failure, or interruption. The function supports both curried and non-curried usage patterns.

LANGUAGE: typescript
CODE:
declare const use: {
  (scope: CloseableScope): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, Exclude<R, Scope>>;
  <A, E, R>(effect: Effect.Effect<A, E, R>, scope: CloseableScope): Effect.Effect<A, E, Exclude<R, Scope>>;
}

----------------------------------------

TITLE: Match.option Function Signature in TypeScript
DESCRIPTION: The TypeScript signature for the Match.option function, which takes a Matcher and returns a function that produces an Option result. This signature shows the complex type parameters involved in the function's definition.

LANGUAGE: typescript
CODE:
declare const option: <I, F, R, A, Pr, Ret>(self: Matcher<I, F, R, A, Pr, Ret>) => [Pr] extends [never] ? (input: I) => Option.Option<Unify<A>> : Option.Option<Unify<A>>

----------------------------------------

TITLE: Declaring isFull Function for TQueue in TypeScript
DESCRIPTION: Defines the isFull function for TQueue, which checks if the queue contains at least one element. It works with both TDequeue and TEnqueue types and returns an STM boolean value.

LANGUAGE: typescript
CODE:
declare const isFull: <A>(self: TDequeue<A> | TEnqueue<A>) => STM.STM<boolean>

----------------------------------------

TITLE: Type Signature of catWithSoftLine in TypeScript
DESCRIPTION: Provides the type signature for the catWithSoftLine combinator, showing its polymorphic nature and overloaded versions.

LANGUAGE: typescript
CODE:
declare const catWithSoftLine: { <B>(that: Doc<B>): <A>(self: Doc<A>) => Doc<B | A>; <A, B>(self: Doc<A>, that: Doc<B>): Doc<A | B>; }

----------------------------------------

TITLE: Defining isSet Function Signature in TypeScript
DESCRIPTION: Provides the TypeScript type signature for the isSet function, which takes an unknown input and returns a boolean indicating if the input is a Set.

LANGUAGE: typescript
CODE:
declare const isSet: (input: unknown) => input is Set<unknown>

----------------------------------------

TITLE: Configuring OpenAPI Middleware in Effect-TS Platform
DESCRIPTION: A middleware function that adds an openapi.json endpoint to the API. It accepts optional configuration for the path and additional properties strategy for OpenAPI schema generation.

LANGUAGE: typescript
CODE:
declare const middlewareOpenApi: (options?: { readonly path?: HttpApiEndpoint.PathSegment | undefined; readonly additionalPropertiesStrategy?: OpenApi.AdditionalPropertiesStrategy | undefined; } | undefined) => Layer.Layer<never, never, HttpApi.Api>

----------------------------------------

TITLE: Creating Boolean Config in Effect TypeScript
DESCRIPTION: Function signature for creating a boolean configuration value in the Effect Config module. The function accepts an optional name parameter and returns a Config instance typed for boolean values.

LANGUAGE: typescript
CODE:
declare const boolean: (name?: string) => Config<boolean>

----------------------------------------

TITLE: Using Types.Mutable with Different Data Structures in TypeScript
DESCRIPTION: Demonstrates how to use Types.Mutable to convert readonly properties to mutable ones across different TypeScript data structures including objects, arrays, tuples, and records.

LANGUAGE: typescript
CODE:
import type { Types } from "effect"

type MutableStruct = Types.Mutable<{ readonly a: string; readonly b: number }> // { a: string; b: number; }

type MutableArray = Types.Mutable<ReadonlyArray<string>> // string[]

type MutableTuple = Types.Mutable<readonly [string, number]> // [string, number]

type MutableRecord = Types.Mutable<{ readonly [_: string]: number }> // { [x: string]: number; }

----------------------------------------

TITLE: Defining Chunk.partition Function in TypeScript
DESCRIPTION: Declares the partition function for the Chunk module. It separates elements based on a predicate that also exposes the element index. The function has overloads for both refinement and predicate use cases, and can be used with or without currying.

LANGUAGE: typescript
CODE:
declare const partition: {
  <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Chunk<A>) => [excluded: Chunk<Exclude<A, B>>, satisfying: Chunk<B>];
  <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Chunk<A>) => [excluded: Chunk<A>, satisfying: Chunk<A>];
  <A, B extends A>(self: Chunk<A>, refinement: (a: A, i: number) => a is B): [excluded: Chunk<Exclude<A, B>>, satisfying: Chunk<B>];
  <A>(self: Chunk<A>, predicate: (a: A, i: number) => boolean): [excluded: Chunk<A>, satisfying: Chunk<A>];
}

----------------------------------------

TITLE: Defining Effect.summarized Type Signature in TypeScript
DESCRIPTION: Type definition for the summarized function that accepts a summary effect and a combining function to produce a summarized version of an effect. The function computes values before and after execution and combines them with the result.

LANGUAGE: typescript
CODE:
declare const summarized: {
  <B, E2, R2, C>(summary: Effect<B, E2, R2>, f: (start: B, end: B) => C): <A, E, R>(self: Effect<A, E, R>) => Effect<[C, A], E2 | E, R2 | R>;
  <A, E, R, B, E2, R2, C>(self: Effect<A, E, R>, summary: Effect<B, E2, R2>, f: (start: B, end: B) => C): Effect<[C, A], E2 | E, R2 | R>;
}

----------------------------------------

TITLE: Declaring unsafeOffer Function in TypeScript for Queue Module
DESCRIPTION: Defines the unsafeOffer function for placing a value in a queue. It has two overloads: one that takes a value and returns a function, and another that takes both the queue and the value directly. Both return a boolean indicating success.

LANGUAGE: typescript
CODE:
declare const unsafeOffer: { <A>(value: A): (self: Enqueue<A>) => boolean; <A>(self: Enqueue<A>, value: A): boolean; }

----------------------------------------

TITLE: Creating Float Configuration in Effect TypeScript
DESCRIPTION: This function constructs a configuration for a float value. It takes an optional name parameter and returns a Config object of type number.

LANGUAGE: typescript
CODE:
declare const number: (name?: string) => Config<number>

----------------------------------------

TITLE: Defining Doc.backslash Constant in TypeScript
DESCRIPTION: Declares a constant representing a single backslash character in the effect-ts printer Doc type system. The type parameter never indicates this Doc doesn't contain any annotations.

LANGUAGE: typescript
CODE:
declare const backslash: Doc<never>

----------------------------------------

TITLE: Defining updateWith Function for Differ in TypeScript
DESCRIPTION: Declares the `updateWith` function that creates a Differ with a custom combination function. It takes a function to combine old and new values, and returns a Differ that produces a function to update values.

LANGUAGE: typescript
CODE:
declare const updateWith: <A>(f: (x: A, y: A) => A) => Differ<A, (a: A) => A>

----------------------------------------

TITLE: Defining dimapEffect Function for Effectful Sink Transformation in TypeScript
DESCRIPTION: Declares the dimapEffect function, which effectfully transforms both inputs and results of a sink using provided functions. It accepts options for input transformation and result processing, returning a new sink with modified input and output types.

LANGUAGE: typescript
CODE:
declare const dimapEffect: { <In0, In, E2, R2, A, A2, E3, R3>(options: { readonly onInput: (input: In0) => Effect.Effect<In, E2, R2>; readonly onDone: (a: A) => Effect.Effect<A2, E3, R3>; }): <L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A2, In0, L, E2 | E3 | E, R2 | R3 | R>; <A, In, L, E, R, In0, E2, R2, A2, E3, R3>(self: Sink<A, In, L, E, R>, options: { readonly onInput: (input: In0) => Effect.Effect<In, E2, R2>; readonly onDone: (a: A) => Effect.Effect<A2, E3, R3>; }): Sink<A2, In0, L, E | E2 | E3, R | R2 | R3>; }

----------------------------------------

TITLE: Implementing filterMap Function for HashMap in TypeScript
DESCRIPTION: Defines a filterMap function that maps over the entries of a HashMap using a specified partial function and filters out None values. It can be used in two ways: as a standalone function or as a method on a HashMap instance.

LANGUAGE: typescript
CODE:
declare const filterMap: { <A, K, B>(f: (value: A, key: K) => Option<B>): (self: HashMap<K, A>) => HashMap<K, B>; <K, A, B>(self: HashMap<K, A>, f: (value: A, key: K) => Option<B>): HashMap<K, B>; }

----------------------------------------

TITLE: Implementing TReentrantLock.lock Method in TypeScript
DESCRIPTION: Defines a convenience method for applications requiring reentrant locks without reader/writer distinction. Returns an Effect that produces a number and requires a Scope, with no error channel.

LANGUAGE: typescript
CODE:
declare const lock: (self: TReentrantLock) => Effect.Effect<number, never, Scope.Scope>

----------------------------------------

TITLE: Using encloseSep for Document Collection in TypeScript
DESCRIPTION: This example demonstrates how to use the `encloseSep` combinator to create a document with a list of numbers enclosed in brackets and separated by commas. It shows both horizontal and vertical layouts based on available page width.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import { pipe } from "effect/Function"
import * as String from "effect/String"

const doc = Doc.hsep([
  Doc.text("list"),
  Doc.align(
    pipe(
      ["1", "20", "300", "4000"].map(
        (n) => n.length === 1 ? Doc.char(n) : Doc.text(n)
      ),
      Doc.encloseSep(Doc.lbracket, Doc.rbracket, Doc.comma)
    )
  )
])

// The documents are laid out horizontally if the document fits the page
assert.strictEqual(
  Doc.render(doc, { style: "pretty" }),
  "list [1,20,300,4000]"
)

// Otherwise they are laid out vertically, with separators put in the front
assert.strictEqual(
  Doc.render(doc, {
    style: "pretty",
    options: { lineWidth: 10 }
  }),
  String.stripMargin(
    `|list [1
     |     ,20
     |     ,300
     |     ,4000]`
  )
)

----------------------------------------

TITLE: Either.fromNullable Function Signature in TypeScript
DESCRIPTION: This code block shows the TypeScript signature of the Either.fromNullable function. It defines two overloads for handling nullable values and converting them to Either types.

LANGUAGE: typescript
CODE:
declare const fromNullable: { <R, L>(onNullable: (right: R) => L): (self: R) => Either<NonNullable<R>, L>; <R, L>(self: R, onNullable: (right: R) => L): Either<NonNullable<R>, L>; }

----------------------------------------

TITLE: Declaring mkString Function for Stream Concatenation in TypeScript
DESCRIPTION: Defines the mkString function that takes a Stream of strings and returns an Effect that produces a concatenated string. It handles potential errors and runtime dependencies.

LANGUAGE: typescript
CODE:
declare const mkString: <E, R>(self: Stream<string, E, R>) => Effect.Effect<string, E, R>

----------------------------------------

TITLE: Implementing DocTree Type Guard in TypeScript
DESCRIPTION: A type guard function that checks if an unknown value is a DocTree instance. Returns a boolean indicating whether the input value matches the DocTree type signature.

LANGUAGE: typescript
CODE:
declare const isDocTree: (u: unknown) => u is DocTree<unknown>

----------------------------------------

TITLE: Creating New Objects with Selected Properties using Struct.pick in TypeScript
DESCRIPTION: Demonstrates how to use the Struct.pick function to create a new object by selecting specific properties from an existing object. It shows both pipe and direct function call syntax.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { pipe, Struct } from "effect"

assert.deepStrictEqual(pipe({ a: "a", b: 1, c: true }, Struct.pick("a", "b")), { a: "a", b: 1 })
assert.deepStrictEqual(Struct.pick({ a: "a", b: 1, c: true }, "a", "b"), { a: "a", b: 1 })

----------------------------------------

TITLE: Appending Elements to Tuples in TypeScript
DESCRIPTION: The appendElement function adds a new element to the end of a tuple. It can be used in two ways: curried form with the element first, or with both tuple and element as arguments. The function preserves the original tuple types and adds the new element type.

LANGUAGE: typescript
CODE:
declare const appendElement: { <B>(that: B): <A extends ReadonlyArray<unknown>>(self: A) => [...A, B]; <A extends ReadonlyArray<unknown>, B>(self: A, that: B): [...A, B]; }

----------------------------------------

TITLE: Combining FiberRefsPatch Instances in TypeScript
DESCRIPTION: The combine function merges two FiberRefsPatch instances to create a new patch that applies changes from both patches sequentially. It provides both curried and uncurried versions of the function.

LANGUAGE: typescript
CODE:
declare const combine: { (that: FiberRefsPatch): (self: FiberRefsPatch) => FiberRefsPatch; (self: FiberRefsPatch, that: FiberRefsPatch): FiberRefsPatch; }

----------------------------------------

TITLE: Replacing Option Values with Constants in TypeScript
DESCRIPTION: Demonstrates how to use the Option.as function to replace the value inside a Some option with a constant value, while leaving None unchanged. This is useful for preserving the presence of a value but replacing its content with a fixed value.

LANGUAGE: typescript
CODE:
import { Option } from "effect"

// Replacing the value of a `Some`
const someValue = Option.some(42)

console.log(Option.as(someValue, "new value"))
// Output: { _id: 'Option', _tag: 'Some', value: 'new value' }

// Replacing a `None` (no effect)
const noneValue = Option.none<number>()

console.log(Option.as(noneValue, "new value"))
// Output: { _id: 'Option', _tag: 'None' }

----------------------------------------

TITLE: Defining TupleOf Type in TypeScript for Effect Library
DESCRIPTION: This snippet defines the TupleOf type, which creates a tuple with a fixed number of elements of a specified type. It includes usage examples showing valid and invalid tuple definitions.

LANGUAGE: typescript
CODE:
import { TupleOf } from "effect/Types"

// A tuple with exactly 3 numbers
const example1: TupleOf<3, number> = [1, 2, 3]; // valid
// @ts-expect-error
const example2: TupleOf<3, number> = [1, 2]; // invalid
// @ts-expect-error
const example3: TupleOf<3, number> = [1, 2, 3, 4]; // invalid

LANGUAGE: typescript
CODE:
type TupleOf<N, T> = N extends N ? number extends N ? Array<T> : _TupleOf<T, N, []> : never

----------------------------------------

TITLE: Defining CacheStats Interface in TypeScript
DESCRIPTION: Defines a TypeScript interface that captures cache performance metrics at a point in time. The interface includes readonly properties for tracking cache hits, misses, and current size.

LANGUAGE: typescript
CODE:
export interface CacheStats {
  readonly hits: number
  readonly misses: number
  readonly size: number
}

----------------------------------------

TITLE: Implementing Cursor Next Line Movement in TypeScript
DESCRIPTION: Function that moves the cursor to the beginning of the line a specified number of rows down. If no row count is specified, defaults to moving down 1 row. Returns an AnsiDoc instance.

LANGUAGE: typescript
CODE:
declare const cursorNextLine: (rows?: number) => AnsiDoc

----------------------------------------

TITLE: Defining fromEffectTagged Function in TypeScript for RequestResolver
DESCRIPTION: Constructs a data source from a list of tags paired to functions. It takes a list of requests and returns a list of results of the same size. Each result item corresponds to the request item at the same index. The function uses complex TypeScript generics to ensure type safety and flexibility.

LANGUAGE: typescript
CODE:
declare const fromEffectTagged: <A extends Request.Request<any, any> & { readonly _tag: string; }>() => <Fns extends { readonly [Tag in A["_tag"]]: [Extract<A, { readonly _tag: Tag; }>] extends [infer Req] ? Req extends Request.Request<infer ReqA, infer ReqE> ? (requests: Array<Req>) => Effect.Effect<Iterable<ReqA>, ReqE, any> : never : never; }>(fns: Fns) => RequestResolver<A, ReturnType<Fns[keyof Fns]> extends Effect.Effect<infer _A, infer _E, infer R> ? R : never>

----------------------------------------

TITLE: Implementing SemigroupMin for BigInt in TypeScript
DESCRIPTION: Demonstrates the usage of SemigroupMin, a Semigroup implementation that combines two BigInt values by selecting the minimum value. Used for finding the smaller of two BigInt numbers.

LANGUAGE: typescript
CODE:
import { SemigroupMin } from "@effect/typeclass/data/BigInt"

console.log(SemigroupMin.combine(2n, 3n))
// 2n

LANGUAGE: typescript
CODE:
declare const SemigroupMin: semigroup.Semigroup<bigint>

----------------------------------------

TITLE: Declaring unsafeRoots Function in TypeScript
DESCRIPTION: Defines the unsafeRoots function that returns an array of RuntimeFiber objects. This function takes no arguments (void) and returns all root fibers. It is marked as unsafe, indicating potential side effects or runtime dependencies.

LANGUAGE: typescript
CODE:
declare const unsafeRoots: (_: void) => Array<RuntimeFiber<any, any>>

----------------------------------------

TITLE: Declaring Schema.TimeZoneNamed Class in TypeScript
DESCRIPTION: Defines a schema class named TimeZoneNamed that attempts to convert a string to a TimeZone.Named instance. It utilizes the DateTime.zoneUnsafeMakeNamed constructor for the conversion.

LANGUAGE: typescript
CODE:
declare class TimeZoneNamed

----------------------------------------

TITLE: Function Signature for HttpApiBuilder.securitySetCookie in TypeScript
DESCRIPTION: Provides the TypeScript signature for the HttpApiBuilder.securitySetCookie function, showing its parameters and return type. It takes an ApiKey instance, a string or Redacted value, and optional cookie options, returning an Effect of void.

LANGUAGE: typescript
CODE:
declare const securitySetCookie: (self: HttpApiSecurity.ApiKey, value: string | Redacted.Redacted, options?: Cookie["options"]) => Effect.Effect<void>

----------------------------------------

TITLE: Using Either.isEither Type Guard in TypeScript
DESCRIPTION: Demonstrates how to use the Either.isEither function to check if a value is an Either type. The function returns true for both Right and Left variants of Either, and false for other objects.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Either } from "effect"

assert.deepStrictEqual(Either.isEither(Either.right(1)), true)
assert.deepStrictEqual(Either.isEither(Either.left("a")), true)
assert.deepStrictEqual(Either.isEither({ right: 1 }), false)

LANGUAGE: typescript
CODE:
declare const isEither: (input: unknown) => input is Either<unknown, unknown>

----------------------------------------

TITLE: Filtering HashSet with Refinement in TypeScript
DESCRIPTION: Shows how to filter string values from a mixed number/string HashSet using a type refinement function. Demonstrates three different syntax approaches with type-safe results.

LANGUAGE: typescript
CODE:
import { HashSet, pipe } from "effect"

const stringRefinement = (value: unknown): value is string =>
  typeof value === "string"

// with `data-last`, a.k.a. `pipeable` API
pipe(
  HashSet.make(1, "unos", 2, "two", 3, "trois", 4, "vier"), // // HashSet.HashSet<number | string>
  HashSet.filter(stringRefinement)
) // HashSet.HashSet<string>

// or with the pipe method
HashSet.make(1, "unos", 2, "two", 3, "trois", 4, "vier") // HashSet.HashSet<number | string>
  .pipe(HashSet.filter(stringRefinement)) // HashSet.HashSet<string>

// or with `data-first` API
HashSet.filter(
  HashSet.make(1, "unos", 2, "two", 3, "trois", 4, "vier"), // HashSet.HashSet<number | string>
  stringRefinement
) // HashSet.HashSet<string>

----------------------------------------

TITLE: Concatenating Documents with Custom Combinators in TypeScript
DESCRIPTION: Demonstrates how to use Doc.concatWith to concatenate document elements with a custom spacing function. The example shows combining characters with space separation using the catWithSpace combinator.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import { pipe } from "effect/Function"

const doc: Doc.Doc<never> = pipe(
  [Doc.char("a"), Doc.char("b")],
  Doc.concatWith((x, y) => Doc.catWithSpace(y)(x))
)

assert.strictEqual(
  Doc.render(doc, { style: "pretty" }),
  "a b"
)

LANGUAGE: typescript
CODE:
declare const concatWith: { <A>(f: (left: Doc<A>, right: Doc<A>) => Doc<A>): (docs: Iterable<Doc<A>>) => Doc<A>; <A>(docs: Iterable<Doc<A>>, f: (left: Doc<A>, right: Doc<A>) => Doc<A>): Doc<A>; }

----------------------------------------

TITLE: Defining ParseIssue Union Type in TypeScript
DESCRIPTION: Defines a union type that represents different categories of parsing errors including type mismatches, missing values, unexpected values, forbidden values, and composite errors like pointer, refinement, and transformation issues.

LANGUAGE: typescript
CODE:
type ParseIssue = | Type
  | Missing
  | Unexpected
  | Forbidden
  // composite
  | Pointer
  | Refinement
  | Transformation
  | Composite

----------------------------------------

TITLE: Implementing Queue-based Sink in TypeScript with Effect-TS
DESCRIPTION: Creates a Sink that enqueues elements into a specified Queue. Takes a Queue.Enqueue instance and optional configuration for shutdown behavior. Returns a Sink that processes elements of type In and produces void.

LANGUAGE: typescript
CODE:
declare const fromQueue: <In>(queue: Queue.Enqueue<In>, options?: { readonly shutdown?: boolean | undefined; }) => Sink<void, In>

----------------------------------------

TITLE: Converting Record to Iterable Using fromRecord in TypeScript
DESCRIPTION: Demonstrates how to convert a record object into an iterable of key-value tuple pairs. The function takes a readonly record with string keys and returns an iterable containing tuples of the record's keys and values.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { fromRecord } from "effect/Iterable"

const x = { a: 1, b: 2, c: 3 }
assert.deepStrictEqual(Array.from(fromRecord(x)), [["a", 1], ["b", 2], ["c", 3]])

LANGUAGE: typescript
CODE:
declare const fromRecord: <K extends string, A>(self: Readonly<Record<K, A>>) => Iterable<[K, A]>

----------------------------------------

TITLE: Defining pipeThrough Function in TypeScript for Stream Module
DESCRIPTION: Declares the pipeThrough function, which pipes all values from a stream through a provided sink. It has two overloads to handle different parameter orders and type constraints.

LANGUAGE: typescript
CODE:
declare const pipeThrough: { <A2, A, L, E2, R2>(sink: Sink.Sink<A2, A, L, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<L, E2 | E, R2 | R>; <A, E, R, A2, L, E2, R2>(self: Stream<A, E, R>, sink: Sink.Sink<A2, A, L, E2, R2>): Stream<L, E | E2, R | R2>; }

----------------------------------------

TITLE: Checking Success Status of Exit in TypeScript
DESCRIPTION: The isSuccess function is a type guard that determines if an Exit instance is a Success. It takes an Exit<A, E> as input and returns a boolean indicating whether it's a Success<A, E>.

LANGUAGE: typescript
CODE:
declare const isSuccess: <A, E>(self: Exit<A, E>) => self is Success<A, E>

----------------------------------------

TITLE: Flattening Nested STM Effects in TypeScript
DESCRIPTION: A utility function that flattens a nested STM effect structure into a single STM effect. It takes a nested STM structure and combines the error types and environment requirements of both layers.

LANGUAGE: typescript
CODE:
declare const flatten: <A, E2, R2, E, R>(self: STM<STM<A, E2, R2>, E, R>) => STM<A, E2 | E, R2 | R>

----------------------------------------

TITLE: Initializing Empty Schedule Intervals in TypeScript
DESCRIPTION: Creates an empty collection of Interval objects. This is a basic constructor that serves as a starting point for interval-based scheduling operations.

LANGUAGE: typescript
CODE:
declare const empty: Intervals

----------------------------------------

TITLE: Defining takeFirstSTM Function in TypeScript
DESCRIPTION: Defines the takeFirstSTM function, which takes the first matching value from a TMap or retries until one is found. It accepts a predicate function and returns an STM (Software Transactional Memory) operation.

LANGUAGE: typescript
CODE:
declare const takeFirstSTM: { <K, V, A, E, R>(pf: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>): (self: TMap<K, V>) => STM.STM<A, E, R>; <K, V, A, E, R>(self: TMap<K, V>, pf: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>): STM.STM<A, E, R>; }

----------------------------------------

TITLE: Implementing HashSet Collection Sink in TypeScript
DESCRIPTION: A TypeScript function that creates a Sink which collects all input elements into a HashSet. The sink aggregates incoming elements of type In into a HashSet data structure.

LANGUAGE: typescript
CODE:
declare const collectAllToSet: <In>() => Sink<HashSet.HashSet<In>, In>

----------------------------------------

TITLE: Retrieving Values from Structs using Struct.get in TypeScript
DESCRIPTION: Demonstrates how to use the Struct.get function to retrieve a value from a struct by its key. The example shows importing necessary modules, creating a struct, and using pipe to apply the get function.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { pipe, Struct } from "effect"

const value = pipe({ a: 1, b: 2 }, Struct.get("a"))

assert.deepStrictEqual(value, 1)

----------------------------------------

TITLE: Folding UpstreamPullStrategy in TypeScript
DESCRIPTION: Function signature for matching/folding an UpstreamPullStrategy<A> into a value of type Z. Takes options object with onNext and onAllEnqueued functions that handle emitting separators and returns the folded value.

LANGUAGE: typescript
CODE:
declare const match: { 
  <A, Z>(options: { 
    readonly onNext: (emitSeparator: Option.Option<A>) => Z; 
    readonly onAllEnqueued: (emitSeparator: Option.Option<A>) => Z; 
  }): (self: UpstreamPullStrategy<A>) => Z; 
  <A, Z>(self: UpstreamPullStrategy<A>, 
    options: { 
      readonly onNext: (emitSeparator: Option.Option<A>) => Z; 
      readonly onAllEnqueued: (emitSeparator: Option.Option<A>) => Z; 
    }
  ): Z; 
}

----------------------------------------

TITLE: Implementing Chunk Folding with Effects in TypeScript
DESCRIPTION: Defines a sink that performs effectful folding operations on input chunks using a provided function and initial state. The function must maintain chunking-invariance during processing.

LANGUAGE: typescript
CODE:
declare const foldLeftChunksEffect: <S, In, E, R>(s: S, f: (s: S, chunk: Chunk.Chunk<In>) => Effect.Effect<S, E, R>) => Sink<S, In, never, E, R>

----------------------------------------

TITLE: Defining tapError Function for HttpClient in TypeScript
DESCRIPTION: Defines the tapError function, which performs an additional effect after an unsuccessful HTTP request. It takes a function that processes the error and returns a new HttpClient instance with potentially modified error and resource types.

LANGUAGE: typescript
CODE:
declare const tapError: { <_, E, E2, R2>(f: (e: NoInfer<E>) => Effect.Effect<_, E2, R2>): <R>(self: HttpClient.With<E, R>) => HttpClient.With<E | E2, R | R2>; <E, R, _, E2, R2>(self: HttpClient.With<E, R>, f: (e: NoInfer<E>) => Effect.Effect<_, E2, R2>): HttpClient.With<E | E2, R | R2>; }

----------------------------------------

TITLE: Declaring Micro.interrupt Function in TypeScript
DESCRIPTION: This code snippet declares the Micro.interrupt function, which is used to abort the current Micro effect. It has a return type of Micro<never, never, never>, indicating it doesn't return a value, doesn't have an error type, and doesn't have an environment type.

LANGUAGE: typescript
CODE:
declare const interrupt: Micro<never, never, never>

----------------------------------------

TITLE: Merging Schema Annotations in TypeScript
DESCRIPTION: Function signature for merging new annotations with existing ones in Schema operations. Supports both curried and uncurried versions for flexible usage patterns. Works with any annotable schema type and handles potential duplicate annotations.

LANGUAGE: typescript
CODE:
declare const annotations: { 
  <S extends Annotable.All>(annotations: Annotations.GenericSchema<Schema.Type<S>>): (self: S) => Annotable.Self<S>; 
  <S extends Annotable.All>(self: S, annotations: Annotations.GenericSchema<Schema.Type<S>>): Annotable.Self<S>; 
}

----------------------------------------

TITLE: Defining Effect.validateWith Function in TypeScript
DESCRIPTION: Declares the validateWith function, which combines two effects using a specified combiner function while accumulating errors. It supports various options for execution control including concurrency, batching, and finalizer behavior.

LANGUAGE: typescript
CODE:
declare const validateWith: { <B, E1, R1, A, C>(that: Effect<B, E1, R1>, f: (a: A, b: B) => C, options?: { readonly concurrent?: boolean | undefined; readonly batching?: boolean | "inherit" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): <E, R>(self: Effect<A, E, R>) => Effect<C, E1 | E, R1 | R>; <A, E, R, B, E1, R1, C>(self: Effect<A, E, R>, that: Effect<B, E1, R1>, f: (a: A, b: B) => C, options?: { readonly concurrent?: boolean | undefined; readonly batching?: boolean | "inherit" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): Effect<C, E | E1, R | R1>; }

----------------------------------------

TITLE: Implementing Queue Take Operation in Effect TypeScript
DESCRIPTION: Defines a take operation that retrieves the oldest value from a Dequeue. When the queue is empty, it returns an Effect that will resume once an item becomes available.

LANGUAGE: typescript
CODE:
declare const take: <A>(self: Dequeue<A>) => Effect.Effect<A>

----------------------------------------

TITLE: Creating Array Equivalence Relation in TypeScript
DESCRIPTION: Demonstrates how to use the Array.getEquivalence function to create an equivalence relation for arrays of numbers. The function takes an equivalence function for individual elements and returns an equivalence function for arrays.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const eq = Array.getEquivalence<number>((a, b) => a === b)
console.log(eq([1, 2, 3], [1, 2, 3])) // true

----------------------------------------

TITLE: Constructing Channel from Queue in TypeScript
DESCRIPTION: The fromQueue function constructs a Channel from a Queue. It takes a Queue of Either<Elem, Exit<Done, Err>> and returns a Channel with specific type parameters.

LANGUAGE: typescript
CODE:
declare const fromQueue: <Done, Err, Elem>(queue: Queue.Dequeue<Either.Either<Elem, Exit.Exit<Done, Err>>>) => Channel<Elem, unknown, Err, unknown, Done, unknown>

----------------------------------------

TITLE: Context.empty Function Signature in TypeScript
DESCRIPTION: Provides the TypeScript function signature for the Context.empty function. It shows that the function takes no parameters and returns a Context with a never type parameter.

LANGUAGE: typescript
CODE:
declare const empty: () => Context<never>

----------------------------------------

TITLE: Creating TSet from Iterable in TypeScript
DESCRIPTION: The fromIterable function creates a new TSet from an iterable collection of values. It returns an STM (Software Transactional Memory) effect that produces a TSet<A> when executed. This function is part of the TSet module in the effect package.

LANGUAGE: typescript
CODE:
declare const fromIterable: <A>(iterable: Iterable<A>) => STM.STM<TSet<A>>

----------------------------------------

TITLE: Implementing File Tree Configuration Layer in TypeScript
DESCRIPTION: Creates a Layer that provides file tree-based configuration capabilities. This function allows specifying a root directory for configuration files and replaces the current ConfigProvider with a file tree implementation. Returns a Layer that requires FileSystem and Path dependencies.

LANGUAGE: typescript
CODE:
declare const layerFileTree: (options?: { readonly rootDirectory?: string; }) => Layer.Layer<never, never, Path.Path | FileSystem.FileSystem>

----------------------------------------

TITLE: Stream.debounce Function Signature in TypeScript
DESCRIPTION: This code snippet shows the type signature of the Stream.debounce function. It demonstrates that debounce can be called with either the duration first or the stream first, providing flexibility in usage.

LANGUAGE: typescript
CODE:
declare const debounce: { (duration: Duration.DurationInput): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, duration: Duration.DurationInput): Stream<A, E, R>; }

----------------------------------------

TITLE: Declaring sequentialFinalizers Function in TypeScript
DESCRIPTION: Declares the sequentialFinalizers function, which takes an Effect and returns a modified Effect that ensures finalizers are run sequentially in reverse order when the scope is closed. This function is particularly useful when the scope is configured to run finalizers concurrently by default.

LANGUAGE: typescript
CODE:
declare const sequentialFinalizers: <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>

----------------------------------------

TITLE: Implementing Fork Operation in Effect RPC
DESCRIPTION: A TypeScript function that wraps a response Effect or Stream to ensure concurrent execution regardless of RpcServer concurrency settings. The function takes a value of type A and returns a Fork of type A.

LANGUAGE: typescript
CODE:
declare const fork: <A>(value: A) => Fork<A>

----------------------------------------

TITLE: Defining 'some' Function for Stream Conversion in TypeScript
DESCRIPTION: Declares a function 'some' that converts a Stream of Option<A> to a Stream of A with Option<E> as the error type. This allows for handling optional values in a stream context.

LANGUAGE: typescript
CODE:
declare const some: <A, E, R>(self: Stream<Option.Option<A>, E, R>) => Stream<A, Option.Option<E>, R>

----------------------------------------

TITLE: Implementing Layer Retry with Schedule in TypeScript
DESCRIPTION: Defines a retry operation for Layer construction that uses a Schedule to determine retry timing and conditions. The function can be used in two ways: either by passing the schedule first and then the layer, or by passing the layer first and then the schedule.

LANGUAGE: typescript
CODE:
declare const retry: {
  <X, E, RIn2>(schedule: Schedule.Schedule<X, NoInfer<E>, RIn2>): <ROut, RIn>(self: Layer<ROut, E, RIn>) => Layer<ROut, E, RIn2 | RIn>;
  <ROut, E, RIn, X, RIn2>(self: Layer<ROut, E, RIn>, schedule: Schedule.Schedule<X, E, RIn2>): Layer<ROut, E, RIn | RIn2>;
}

----------------------------------------

TITLE: Implementing Document Concatenation with fillCat in TypeScript
DESCRIPTION: The fillCat combinator function concatenates documents horizontally with empty space between them, automatically inserting line breaks when page width is exceeded. When grouped, documents are separated by empty space rather than newlines. Takes an Iterable of Doc<A> and returns a combined Doc<A>.

LANGUAGE: typescript
CODE:
declare const fillCat: <A>(docs: Iterable<Doc<A>>) => Doc<A>

----------------------------------------

TITLE: Creating Keyed Pool with TTL in TypeScript
DESCRIPTION: Creates a new resource pool with configurable minimum/maximum sizes and time-to-live settings per key. The pool is managed within a Scope and automatically releases resources when shut down. Each key can have different pool size configurations.

LANGUAGE: typescript
CODE:
declare const makeWithTTLBy: <K, A, E, R>(options: { readonly acquire: (key: K) => Effect.Effect<A, E, R>; readonly min: (key: K) => number; readonly max: (key: K) => number; readonly timeToLive: (key: K) => Duration.DurationInput; }) => Effect.Effect<KeyedPool<K, A, E>, never, Scope.Scope | R>

----------------------------------------

TITLE: Creating STM Value from Partial Function in TypeScript
DESCRIPTION: The attempt function creates an STM value from a partial (but pure) function. It takes a lazy argument of type A and returns an STM value that may contain A or an unknown error.

LANGUAGE: typescript
CODE:
declare const attempt: <A>(evaluate: LazyArg<A>) => STM<A, unknown>

----------------------------------------

TITLE: Defining Cause.reduce Function in TypeScript
DESCRIPTION: This code snippet defines the signature of the Cause.reduce function. It combines all parts of a Cause into a single value, starting with an initial value and applying a custom function. The function can be used in two ways: as a curried function or with all parameters at once.

LANGUAGE: typescript
CODE:
declare const reduce: {
  <Z, E>(zero: Z, pf: (accumulator: Z, cause: Cause<E>) => Option.Option<Z>): (self: Cause<E>) => Z;
  <Z, E>(self: Cause<E>, zero: Z, pf: (accumulator: Z, cause: Cause<E>) => Option.Option<Z>): Z;
}

----------------------------------------

TITLE: Using discriminatorsExhaustive for Exhaustive Pattern Matching in TypeScript
DESCRIPTION: This snippet demonstrates how to use the discriminatorsExhaustive function to perform exhaustive pattern matching on a discriminated union. It ensures that all possible cases of the 'type' field are handled.

LANGUAGE: typescript
CODE:
import { Match, pipe } from "effect"

const match = pipe(
  Match.type<{ type: "A"; a: string } | { type: "B"; b: number } | { type: "C"; c: boolean }>(),
  Match.discriminatorsExhaustive("type")({
    A: (a) => a.a,
    B: (b) => b.b,
    C: (c) => c.c
  })
)

----------------------------------------

TITLE: Retrieving Last Entry from RedBlackTree in TypeScript
DESCRIPTION: Function signature for retrieving the last key-value pair from a RedBlackTree data structure. Returns an Option type containing a tuple of key and value if the tree is not empty.

LANGUAGE: typescript
CODE:
declare const last: <K, V>(self: RedBlackTree<K, V>) => Option<[K, V]>

----------------------------------------

TITLE: Types.Mutable Type Definition Implementation
DESCRIPTION: The core type definition for the Mutable utility type that removes readonly modifiers from all properties in a type T using mapped types.

LANGUAGE: typescript
CODE:
type Mutable<T> = {
  -readonly [P in keyof T]: T[P]
}

----------------------------------------

TITLE: Defining Micro.as Type Signature in TypeScript
DESCRIPTION: Type declaration for the Micro.as function that enables replacing the success value of a given effect. The function supports both curried and uncurried forms, allowing flexible usage patterns.

LANGUAGE: typescript
CODE:
declare const as: { 
  <A, B>(value: B): <E, R>(self: Micro<A, E, R>) => Micro<B, E, R>; 
  <A, E, R, B>(self: Micro<A, E, R>, value: B): Micro<B, E, R>; 
}

----------------------------------------

TITLE: Streaming Command Output in TypeScript using @effect/platform
DESCRIPTION: The stream function starts running a given Command and returns its output as a Stream of Uint8Array. It handles potential PlatformErrors and requires a CommandExecutor.

LANGUAGE: typescript
CODE:
declare const stream: (command: Command) => Stream<Uint8Array, PlatformError, CommandExecutor>

----------------------------------------

TITLE: Using NodeHttpServer.layerTest for HTTP Server Testing in TypeScript
DESCRIPTION: Demonstrates how to use NodeHttpServer.layerTest to create a test environment for HTTP servers. The layer starts a server on a random port and provides an HttpClient configured with the server's URL. This example shows making a GET request to the root path of an empty router.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { HttpClient, HttpRouter, HttpServer } from "@effect/platform"
import { NodeHttpServer } from "@effect/platform-node"
import { Effect } from "effect"

Effect.gen(function*() {
  yield* HttpServer.serveEffect(HttpRouter.empty)
  const response = yield* HttpClient.get("/")
  assert.strictEqual(response.status, 404)
}).pipe(Effect.provide(NodeHttpServer.layerTest))

LANGUAGE: typescript
CODE:
declare const layerTest: Layer.Layer<Server.HttpServer | Platform.HttpPlatform | Etag.Generator | NodeContext.NodeContext | HttpClient.HttpClient, ServeError, never>

----------------------------------------

TITLE: Partitioning Stream into Even and Odd Numbers using Effect Stream
DESCRIPTION: Demonstrates how to use Stream.partition to split a range of numbers into even and odd substreams. The example shows stream creation, partitioning, and collecting results with a specified buffer size.

LANGUAGE: typescript
CODE:
import { Effect, Stream } from "effect"

const partition = Stream.range(1, 9).pipe(
  Stream.partition((n) => n % 2 === 0, { bufferSize: 5 })
)

const program = Effect.scoped(
  Effect.gen(function*() {
    const [odds, evens] = yield* partition
    console.log(yield* Stream.runCollect(odds))
    console.log(yield* Stream.runCollect(evens))
  })
)

Effect.runPromise(program)
// { _id: 'Chunk', values: [ 1, 3, 5, 7, 9 ] }
// { _id: 'Chunk', values: [ 2, 4, 6, 8 ] }

----------------------------------------

TITLE: Demonstrating BigInt MonoidSum Usage
DESCRIPTION: Shows how to use the MonoidSum monoid implementation for BigInt values. The monoid combines BigInt values through addition with 0n as the empty (identity) element.

LANGUAGE: typescript
CODE:
import { MonoidSum } from "@effect/typeclass/data/BigInt"

console.log(MonoidSum.combine(2n, 3n))
// 5n
console.log(MonoidSum.combine(2n, MonoidSum.empty))
// 2n

LANGUAGE: typescript
CODE:
declare const MonoidSum: monoid.Monoid<bigint>

----------------------------------------

TITLE: Defining Layer.provide Function Signature in TypeScript
DESCRIPTION: Declares the type signature for the Layer.provide function, which takes two layers and combines them by feeding the outputs of one into the inputs of another. It includes overloads for handling single layers and arrays of layers.

LANGUAGE: typescript
CODE:
declare const provide: { <RIn, E, ROut>(that: Layer<ROut, E, RIn>): <RIn2, E2, ROut2>(self: Layer<ROut2, E2, RIn2>) => Layer<ROut2, E | E2, RIn | Exclude<RIn2, ROut>>; <const Layers extends [Layer.Any, ...Array<Layer.Any>]>(that: Layers): <A, E, R>(self: Layer<A, E, R>) => Layer<A, E | { [k in keyof Layers]: Layer.Error<Layers[k]>; }[number], { [k in keyof Layers]: Layer.Context<Layers[k]>; }[number] | Exclude<R, { [k in keyof Layers]: Layer.Success<Layers[k]>; }[number]>>; <RIn2, E2, ROut2, RIn, E, ROut>(self: Layer<ROut2, E2, RIn2>, that: Layer<ROut, E, RIn>): Layer<ROut2, E | E2, RIn | Exclude<RIn2, ROut>>; <A, E, R, const Layers extends [Layer.Any, ...Array<Layer.Any>]>(self: Layer<A, E, R>, that: Layers): Layer<A, E | { [k in keyof Layers]: Layer.Error<Layers[k]>; }[number], { [k in keyof Layers]: Layer.Context<Layers[k]>; }[number] | Exclude<R, { [k in keyof Layers]: Layer.Success<Layers[k]>; }[number]>>; }

----------------------------------------

TITLE: Checking Interruption RuntimeFlag in TypeScript
DESCRIPTION: Function that checks if the Interruption RuntimeFlag is enabled for a given RuntimeFlags instance. Returns a boolean indicating the flag's state.

LANGUAGE: typescript
CODE:
declare const interruption: (self: RuntimeFlags) => boolean

----------------------------------------

TITLE: TypeScript Signature for Pool.makeWithTTL Function
DESCRIPTION: Provides the TypeScript type signature for the Pool.makeWithTTL function. It details the expected parameters and return type, including options for acquire, min, max, concurrency, targetUtilization, timeToLive, and timeToLiveStrategy.

LANGUAGE: typescript
CODE:
declare const makeWithTTL: <A, E, R>(options: { readonly acquire: Effect.Effect<A, E, R>; readonly min: number; readonly max: number; readonly concurrency?: number | undefined; readonly targetUtilization?: number | undefined; readonly timeToLive: Duration.DurationInput; readonly timeToLiveStrategy?: "creation" | "usage" | undefined; }) => Effect.Effect<Pool<A, E>, never, Scope.Scope | R>

----------------------------------------

TITLE: Removing Annotations from DocStream in TypeScript
DESCRIPTION: Function signature for unAnnotate that removes all annotations from a DocStream<A> and returns a DocStream<never>. This is a type-safe operation that ensures no annotations remain in the resulting stream.

LANGUAGE: typescript
CODE:
declare const unAnnotate: <A>(self: DocStream<A>) => DocStream<never>

----------------------------------------

TITLE: TypeScript Function Signature for Doc.list
DESCRIPTION: This code snippet shows the TypeScript function signature for the Doc.list function. It takes an Iterable of Doc<A> and returns a Doc<A>.

LANGUAGE: typescript
CODE:
declare const list: <A>(docs: Iterable<Doc<A>>) => Doc<A>

----------------------------------------

TITLE: Using Doc.hang for Column-Based Indentation in TypeScript
DESCRIPTION: Demonstrates how to use the hang combinator to indent text based on the current column position. The example shows formatting text with a prefix and hanging indent of 4 spaces, rendered with a line width of 24 characters.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import { pipe } from "effect/Function"
import * as String from "effect/String"

const doc = Doc.hsep([
  Doc.text("prefix"),
  pipe(Doc.reflow("Indenting these words with hang"), Doc.hang(4))
])

assert.strictEqual(
  Doc.render(doc, {
    style: "pretty",
    options: { lineWidth: 24 }
  }),
  String.stripMargin(
    `|prefix Indenting these
     |           words with
     |           hang`
  )
)

----------------------------------------

TITLE: Creating Successful Fiber in TypeScript
DESCRIPTION: The succeed function returns a fiber that has already succeeded with the specified value. It takes a generic type parameter A and a value of that type, returning a Fiber<A>.

LANGUAGE: typescript
CODE:
declare const succeed: <A>(value: A) => Fiber<A>

----------------------------------------

TITLE: Implementing Effect Replication in TypeScript
DESCRIPTION: Function signature for replicating a Micro effect n times. Supports both curried and non-curried versions of the function call. Returns an array containing n copies of the provided effect.

LANGUAGE: typescript
CODE:
declare const replicate: { 
  (n: number): <A, E, R>(self: Micro<A, E, R>) => Array<Micro<A, E, R>>; 
  <A, E, R>(self: Micro<A, E, R>, n: number): Array<Micro<A, E, R>>; 
}

----------------------------------------

TITLE: LogLevel.locally Function Signature (TypeScript)
DESCRIPTION: Provides the TypeScript function signature for LogLevel.locally, showing its overloaded versions for different usage patterns.

LANGUAGE: typescript
CODE:
declare const locally: { (self: LogLevel): <A, E, R>(use: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; <A, E, R>(use: Effect.Effect<A, E, R>, self: LogLevel): Effect.Effect<A, E, R>; }

----------------------------------------

TITLE: Implementing STM.forEach Function in TypeScript
DESCRIPTION: Defines a function that applies a transformation to each element of an Iterable within a Software Transactional Memory (STM) context. The function can either return an array of transformed values or void based on the discard option. It supports both curried and non-curried function signatures.

LANGUAGE: typescript
CODE:
declare const forEach: { 
  <A, A2, E, R>(f: (a: A) => STM<A2, E, R>, options?: { readonly discard?: false | undefined; } | undefined): (elements: Iterable<A>) => STM<Array<A2>, E, R>; 
  <A, A2, E, R>(f: (a: A) => STM<A2, E, R>, options: { readonly discard: true; }): (elements: Iterable<A>) => STM<void, E, R>; 
  <A, A2, E, R>(elements: Iterable<A>, f: (a: A) => STM<A2, E, R>, options?: { readonly discard?: false | undefined; } | undefined): STM<Array<A2>, E, R>; 
  <A, A2, E, R>(elements: Iterable<A>, f: (a: A) => STM<A2, E, R>, options: { readonly discard: true; }): STM<void, E, R>; 
}

----------------------------------------

TITLE: TypeScript Signature of makeBy Function in Iterable Module
DESCRIPTION: Provides the TypeScript type signature for the makeBy function. It shows that the function takes a callback and an optional options object with a length property, returning an Iterable of the specified type.

LANGUAGE: typescript
CODE:
declare const makeBy: <A>(f: (i: number) => A, options?: { readonly length?: number; }) => Iterable<A>

----------------------------------------

TITLE: Converting Fiber to Scoped Effect in TypeScript
DESCRIPTION: The 'scoped' function converts a Fiber into a scoped Effect. When the scope is closed, the fiber is interrupted. It takes a Fiber<A, E> as input and returns an Effect that produces a Fiber<A, E> and requires a Scope.

LANGUAGE: typescript
CODE:
declare const scoped: <A, E>(self: Fiber<A, E>) => Effect.Effect<Fiber<A, E>, never, Scope.Scope>

----------------------------------------

TITLE: Using Doc.spaces for Formatting in TypeScript
DESCRIPTION: This example demonstrates how to use the `spaces` combinator from the `@effect/printer` package to create a document with a specified number of spaces. It shows the creation of a document with 5 spaces, enclosed in double quotes and square brackets.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"

const doc = Doc.squareBracketed(Doc.doubleQuoted(Doc.spaces(5)))

assert.strictEqual(
  Doc.render(doc, { style: "pretty" }),
  "[\"     \"]"
)

----------------------------------------

TITLE: Defining SubscriptionRef Interface in TypeScript
DESCRIPTION: This code snippet defines the SubscriptionRef interface, which extends SynchronizedRef and Subscribable. It includes internal properties for managing the reference, publication/subscription, and synchronization, as well as a stream of changes.

LANGUAGE: typescript
CODE:
export interface SubscriptionRef<in out A>
  extends SubscriptionRef.Variance<A>, Synchronized.SynchronizedRef<A>, Subscribable<A>
{
  /** @internal */
  readonly ref: Ref.Ref<A>
  /** @internal */
  readonly pubsub: PubSub.PubSub<A>
  /** @internal */
  readonly semaphore: Effect.Semaphore
  /**
   * A stream containing the current value of the `Ref` as well as all changes
   * to that value.
   */
  readonly changes: Stream.Stream<A>
  readonly [Unify.typeSymbol]?: unknown
  readonly [Unify.unifySymbol]?: SubscriptionRefUnify<this>
  readonly [Unify.ignoreSymbol]?: SubscriptionRefUnifyIgnore
}

----------------------------------------

TITLE: Creating Stream from EventListener - TypeScript
DESCRIPTION: Function signature for creating a Stream from an event listener. Takes an event listener target, event type string, and optional configuration options for the listener behavior and buffer size. Returns a Stream of type A.

LANGUAGE: typescript
CODE:
declare const fromEventListener: <A = unknown>(target: EventListener<A>, type: string, options?: boolean | { readonly capture?: boolean; readonly passive?: boolean; readonly once?: boolean; readonly bufferSize?: number | "unbounded" | undefined; } | undefined) => Stream<A>

----------------------------------------

TITLE: Creating Polling Metrics with MetricPolling.make in TypeScript
DESCRIPTION: Function signature for constructing a new polling metric by combining a metric with a polling effect. Takes a metric of type Metric<Type, In, Out> and a polling effect of type Effect<In, E, R> to produce a MetricPolling instance.

LANGUAGE: typescript
CODE:
declare const make: <Type, In, Out, R, E>(metric: Metric.Metric<Type, In, Out>, poll: Effect.Effect<In, E, R>) => MetricPolling<Type, In, R, E, Out>

----------------------------------------

TITLE: Demonstrating Do Simulation with Option in TypeScript
DESCRIPTION: This example illustrates how to use the do simulation in Effect's Option module. It demonstrates binding variables, using let for simple value assignment, and applying filter operations within the simulation scope.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Option, pipe } from "effect"

const result = pipe(
  Option.Do,
  Option.bind("x", () => Option.some(2)),
  Option.bind("y", () => Option.some(3)),
  Option.let("sum", ({ x, y }) => x + y),
  Option.filter(({ x, y }) => x * y > 5)
)
assert.deepStrictEqual(result, Option.some({ x: 2, y: 3, sum: 5 }))

----------------------------------------

TITLE: Disconnected Effect Racing
DESCRIPTION: Example of racing effects with disconnect for quicker returns.

LANGUAGE: typescript
CODE:
Effect.raceFirst(Effect.disconnect(task1), Effect.disconnect(task2))

----------------------------------------

TITLE: Using Option.getOrUndefined in TypeScript
DESCRIPTION: Demonstrates how to use Option.getOrUndefined to extract values from Option types, returning undefined for None cases. The example shows both Some and None scenarios.

LANGUAGE: typescript
CODE:
import { Option } from "effect"

console.log(Option.getOrUndefined(Option.some(1)))
// Output: 1

console.log(Option.getOrUndefined(Option.none()))
// Output: undefined

----------------------------------------

TITLE: TypeScript Signature for discriminatorStartsWith Function
DESCRIPTION: Provides the TypeScript type signature for the discriminatorStartsWith function, showing its generic parameters and return type. This signature is useful for understanding the function's type constraints and usage in TypeScript projects.

LANGUAGE: typescript
CODE:
declare const discriminatorStartsWith: <D extends string>(field: D) => <R, P extends string, Ret, Fn extends (_: Extract<R, Record<D, `${P}${string}`>>) => Ret>(pattern: P, f: Fn) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr, Ret>) => Matcher<I, Types.AddWithout<F, Extract<R, Record<D, `${P}${string}`>>>, Types.ApplyFilters<I, Types.AddWithout<F, Extract<R, Record<D, `${P}${string}`>>>>, A | ReturnType<Fn>, Pr, Ret>

----------------------------------------

TITLE: Implementing findFirstIndexWhereSTM in TypeScript for TArray
DESCRIPTION: Function signature for finding the first index in a transactional array that matches a given predicate. The function operates within the STM (Software Transactional Memory) context and returns an Option of the found index.

LANGUAGE: typescript
CODE:
declare const findFirstIndexWhereSTM: {
  <A, R, E>(predicate: (value: A) => STM.STM<boolean, E, R>): (self: TArray<A>) => STM.STM<Option.Option<number>, E, R>;
  <A, R, E>(self: TArray<A>, predicate: (value: A) => STM.STM<boolean, E, R>): STM.STM<Option.Option<number>, E, R>;
}

----------------------------------------

TITLE: Defining mapAttempt Function for Config Transformation in TypeScript
DESCRIPTION: The mapAttempt function returns a new config with the same structure as the original, but with values transformed by a provided function. It handles exceptions by converting them into validation errors.

LANGUAGE: typescript
CODE:
declare const mapAttempt: { <A, B>(f: (a: A) => B): (self: Config<A>) => Config<B>; <A, B>(self: Config<A>, f: (a: A) => B): Config<B>; }

----------------------------------------

TITLE: Implementing Async Effect Registration in TypeScript
DESCRIPTION: Defines a function that handles asynchronous effect registration where the callback can return an Effect. The register function takes a callback that accepts an Effect and may return either an Effect<void> or void. The function combines multiple effect types and error channels.

LANGUAGE: typescript
CODE:
declare const asyncEffect: <A, E, R, R3, E2, R2>(register: (callback: (_: Effect<A, E, R>) => void) => Effect<Effect<void, never, R3> | void, E2, R2>) => Effect<A, E | E2, R | R2 | R3>

----------------------------------------

TITLE: Declaring Number Parsing Function in TypeScript
DESCRIPTION: Declares a function 'parse' that attempts to convert a string to a number using the Number() function. It supports special string values like 'NaN', 'Infinity', and '-Infinity'. The function returns an Option<number> type.

LANGUAGE: typescript
CODE:
declare const parse: (s: string) => Option<number>

----------------------------------------

TITLE: Defining Event Interface in TypeScript for Effect Library
DESCRIPTION: This code snippet defines the Event interface, which is a generic type representing an event in an EventLog. It includes properties for tag, payload, success, and error, along with associated schemas and functions for primary key generation and MsgPack serialization.

LANGUAGE: typescript
CODE:
export interface Event<
  out Tag extends string,
  in out Payload extends Schema.Schema.Any = typeof Schema.Void,
  in out Success extends Schema.Schema.Any = typeof Schema.Void,
  in out Error extends Schema.Schema.All = typeof Schema.Never
> {
  readonly [TypeId]: TypeId
  readonly tag: Tag
  readonly primaryKey: (payload: Schema.Schema.Type<Payload>) => string
  readonly payload: Payload
  readonly payloadMsgPack: MsgPack.schema<Payload>
  readonly success: Success
  readonly error: Error
}

----------------------------------------

TITLE: Configuring RPC Health Check Layer in TypeScript
DESCRIPTION: Defines a Layer that implements health checking functionality for Runners by establishing direct RPC connections to verify their health status. This layer depends on ShardingConfig and Runners.RpcClientProtocol.

LANGUAGE: typescript
CODE:
declare const layerRpc: Layer.Layer<RunnerHealth, never, ShardingConfig | Runners.RpcClientProtocol>

----------------------------------------

TITLE: Defining Cause Union Type in TypeScript
DESCRIPTION: Defines a union type that captures different kinds of failures in Effect operations, including empty causes, failures, defects, interruptions, and both sequential and parallel error compositions. This type enables complete error tracking and debugging.

LANGUAGE: typescript
CODE:
type Cause<E> = | Empty
  | Fail<E>
  | Die
  | Interrupt
  | Sequential<E>
  | Parallel<E>

----------------------------------------

TITLE: Creating Failing Take Instance in TypeScript
DESCRIPTION: Function signature for creating a failing Take instance with a generic error type E. The function takes an error parameter and returns a Take that never succeeds but fails with the specified error type.

LANGUAGE: typescript
CODE:
declare const fail: <E>(error: E) => Take<never, E>

----------------------------------------

TITLE: Transforming Sink Errors in TypeScript
DESCRIPTION: The `mapError` function transforms errors emitted by a sink using a provided function. It can be used in two ways: as a standalone function or as a method on a Sink instance.

LANGUAGE: typescript
CODE:
declare const mapError: { <E, E2>(f: (error: E) => E2): <A, In, L, R>(self: Sink<A, In, L, E, R>) => Sink<A, In, L, E2, R>; <A, In, L, E, R, E2>(self: Sink<A, In, L, E, R>, f: (error: E) => E2): Sink<A, In, L, E2, R>; }

----------------------------------------

TITLE: Defining unsandbox Function in TypeScript for Effect Module
DESCRIPTION: The unsandbox function reverts a sandboxed effect to its original state, removing detailed Cause<E> information from the error channel. It's useful for returning to standard error handling after using sandbox.

LANGUAGE: typescript
CODE:
declare const unsandbox: <A, E, R>(self: Effect<A, Cause.Cause<E>, R>) => Effect<A, E, R>

----------------------------------------

TITLE: Creating PubSub Sink in TypeScript with Effect
DESCRIPTION: Creates a sink that publishes each received element to a specified PubSub instance. Includes an optional shutdown parameter that controls whether the PubSub should be shutdown after sink evaluation.

LANGUAGE: typescript
CODE:
declare const fromPubSub: <In>(pubsub: PubSub.PubSub<In>, options?: { readonly shutdown?: boolean | undefined; }) => Sink<void, In>

----------------------------------------

TITLE: Configuring ShardManager Layer without HTTP Server in TypeScript
DESCRIPTION: Creates a Layer for the ShardManager service that provides only the Runners RPC client functionality without running a server. This can be combined with toHttpApp and toHttpAppWebsocket APIs for a complete ShardManager server implementation.

LANGUAGE: typescript
CODE:
declare const layerNoServerHttp: (options: { readonly runnerPath: string; readonly runnerHttps?: boolean | undefined; }) => Layer.Layer<ShardManager.ShardManager, never, RpcSerialization.RpcSerialization | ShardStorage | RunnerHealth.RunnerHealth | HttpClient.HttpClient | ShardManager.Config | ShardingConfig>

----------------------------------------

TITLE: Implementing Read Lock Operation in Effect-TS
DESCRIPTION: Defines a function that executes a provided effect while holding a read lock. The function supports both curried and uncurried calling styles, working with Effect.Effect types.

LANGUAGE: typescript
CODE:
declare const withReadLock: { 
  (self: TReentrantLock): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; 
  <A, E, R>(effect: Effect.Effect<A, E, R>, self: TReentrantLock): Effect.Effect<A, E, R>; 
}

----------------------------------------

TITLE: Function Signature for Doc.spaces in TypeScript
DESCRIPTION: This code snippet shows the TypeScript function signature for the `spaces` combinator in the `@effect/printer` package. It takes a number as input and returns a `Doc` object with a `never` type parameter.

LANGUAGE: typescript
CODE:
declare const spaces: (n: number) => Doc<never>

----------------------------------------

TITLE: Demonstrating NOR Operation with Boolean in TypeScript
DESCRIPTION: This snippet demonstrates the usage of the 'nor' function from the Effect library's Boolean module. It showcases how the NOR operation is applied to different boolean combinations.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { nor } from "effect/Boolean"

assert.deepStrictEqual(nor(true, true), false)
assert.deepStrictEqual(nor(true, false), false)
assert.deepStrictEqual(nor(false, true), false)
assert.deepStrictEqual(nor(false, false), true)

----------------------------------------

TITLE: Defining takeFirstSTM Function in TypeScript
DESCRIPTION: Declares the takeFirstSTM function, which takes the first matching value from a TSet or retries until one is found. It accepts a predicate function and returns an STM (Software Transactional Memory) operation.

LANGUAGE: typescript
CODE:
declare const takeFirstSTM: { <A, B, E, R>(pf: (a: A) => STM.STM<B, Option.Option<E>, R>): (self: TSet<A>) => STM.STM<B, E, R>; <A, B, E, R>(self: TSet<A>, pf: (a: A) => STM.STM<B, Option.Option<E>, R>): STM.STM<B, E, R>; }

----------------------------------------

TITLE: Splitting Array Using Effect Library's Array.splitAt
DESCRIPTION: Demonstrates how to use Array.splitAt to split an iterable into two segments. The function takes a number n and returns two arrays: one containing the first n elements and another containing the remaining elements.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const result = Array.splitAt([1, 2, 3, 4, 5], 3)
console.log(result) // [[1, 2, 3], [4, 5]]

LANGUAGE: typescript
CODE:
declare const splitAt: { (n: number): <A>(self: Iterable<A>) => [beforeIndex: Array<A>, fromIndex: Array<A>]; <A>(self: Iterable<A>, n: number): [beforeIndex: Array<A>, fromIndex: Array<A>]; }

----------------------------------------

TITLE: Declaring Micro.all Function in TypeScript
DESCRIPTION: Defines the Micro.all function signature. It accepts an iterable or record of Micro effects and optional configuration parameters. The function runs all provided effects in sequence, respecting the input structure.

LANGUAGE: typescript
CODE:
declare const all: <const Arg extends Iterable<Micro<any, any, any>> | Record<string, Micro<any, any, any>>, O extends NoExcessProperties<{ readonly concurrency?: Concurrency | undefined; readonly discard?: boolean | undefined; }, O>>(arg: Arg, options?: O) => All.Return<Arg, O>

----------------------------------------

TITLE: Getting TPubSub Capacity in TypeScript
DESCRIPTION: A TypeScript function that returns the maximum number of elements a TPubSub instance can hold. The function takes a TPubSub<A> instance as input and returns a number representing its capacity.

LANGUAGE: typescript
CODE:
declare const capacity: <A>(self: TPubSub<A>) => number

----------------------------------------

TITLE: Transforming TSet Elements Atomically using STM
DESCRIPTION: Provides a function that atomically updates all elements in a TSet using a transactional function. The transformation is performed within STM context, ensuring atomic operations across the entire set.

LANGUAGE: typescript
CODE:
declare const transformSTM: { <A, R, E>(f: (a: A) => STM.STM<A, E, R>): (self: TSet<A>) => STM.STM<void, E, R>; <A, R, E>(self: TSet<A>, f: (a: A) => STM.STM<A, E, R>): STM.STM<void, E, R>; }

----------------------------------------

TITLE: Defining Order.struct Type Signature in TypeScript
DESCRIPTION: Type declaration for the struct function that creates an Order instance for a struct type. It takes an object of Order instances for each field and returns an Order for the complete struct type.

LANGUAGE: typescript
CODE:
declare const struct: <R extends { readonly [x: string]: Order<any>; }>(fields: R) => Order<{ [K in keyof R]: [R[K]] extends [Order<infer A>] ? A : never; }>

----------------------------------------

TITLE: Declaring Union Operation for Intervals in TypeScript
DESCRIPTION: Defines a union operation for Intervals. It can be called with two Intervals as separate arguments or with the second Interval as an argument to a function returned by the first call.

LANGUAGE: typescript
CODE:
declare const union: { (that: Intervals): (self: Intervals) => Intervals; (self: Intervals, that: Intervals): Intervals; }

----------------------------------------

TITLE: Using DateTime.withDate with Timezone Adjustment in TypeScript
DESCRIPTION: Demonstrates how to use DateTime.withDate to apply a function to a timezone-adjusted Date object. The example shows converting a UTC timestamp to local time in Europe/London timezone and getting the milliseconds value.

LANGUAGE: typescript
CODE:
import { DateTime } from "effect"

// get the time zone adjusted date in milliseconds
DateTime.unsafeMakeZoned(0, { timeZone: "Europe/London" }).pipe(
  DateTime.withDate((date) => date.getTime())
)

LANGUAGE: typescript
CODE:
declare const withDate: { <A>(f: (date: Date) => A): (self: DateTime) => A; <A>(self: DateTime, f: (date: Date) => A): A; }

----------------------------------------

TITLE: Defining Empty Document Interface in TypeScript
DESCRIPTION: Defines a TypeScript interface for the Empty document type that extends Doc.Variance<A>. The Empty document represents a conceptual unit of Cat and is identified by the _tag property with value "Empty".

LANGUAGE: typescript
CODE:
export interface Empty<A> extends Doc.Variance<A> {
  readonly _tag: "Empty"
}

----------------------------------------

TITLE: Lifting Effect to Fiber in TypeScript
DESCRIPTION: The fromEffect function lifts an Effect into a Fiber. It takes an Effect as input and returns a new Effect that produces a Fiber.

LANGUAGE: typescript
CODE:
declare const fromEffect: <A, E>(effect: Effect.Effect<A, E>) => Effect.Effect<Fiber<A, E>>

----------------------------------------

TITLE: Defining Permissions Interface in TypeScript for Effect-TS
DESCRIPTION: TypeScript interface that wraps the browser's Permission API (navigator.permissions). Provides a query method that returns an Effect containing permission status for a given permission name.

LANGUAGE: typescript
CODE:
export interface Permissions {
  readonly [TypeId]: TypeId

  /**
   * Returns the state of a user permission on the global scope.
   */
  readonly query: <Name extends PermissionName>(
    name: Name
  ) => Effect.Effect<
    // `name` is identical to the name passed to Permissions.query
    // https://developer.mozilla.org/en-US/docs/Web/API/PermissionStatus
    Omit<PermissionStatus, "name"> & { name: Name },
    PermissionsError
  >
}

----------------------------------------

TITLE: Type Checking DocStream in TypeScript
DESCRIPTION: A type guard function that determines whether a given DocStream instance is specifically a CharStream. This function enables type narrowing in TypeScript, allowing for type-safe operations on CharStream instances.

LANGUAGE: typescript
CODE:
declare const isCharStream: <A>(self: DocStream<A>) => self is CharStream<A>

----------------------------------------

TITLE: Defining SingletonRegistered Interface in TypeScript
DESCRIPTION: Defines an interface representing an event that occurs when a new singleton is registered with a runner. The interface includes a discriminator tag and address field.

LANGUAGE: typescript
CODE:
export interface SingletonRegistered {
  readonly _tag: "SingletonRegistered"
  readonly address: SingletonAddress
}

----------------------------------------

TITLE: Initializing Exponential MicroSchedule in TypeScript
DESCRIPTION: Creates a MicroSchedule that generates delays with exponential backoff. Takes a base delay in milliseconds and an optional multiplication factor to calculate the exponential increase in delay intervals.

LANGUAGE: typescript
CODE:
declare const scheduleExponential: (baseMillis: number, factor?: number) => MicroSchedule

----------------------------------------

TITLE: Invalidating Pool Items in Effect-TS
DESCRIPTION: Function to invalidate items in a Pool, triggering eventual reallocation. The invalidation can be performed either eagerly or lazily based on the pool's implementation. Takes a pool and a value as parameters and returns an Effect wrapped in a Scope.

LANGUAGE: typescript
CODE:
declare const invalidate: { 
  <A>(value: A): <E>(self: Pool<A, E>) => Effect.Effect<void, never, Scope.Scope>; 
  <A, E>(self: Pool<A, E>, value: A): Effect.Effect<void, never, Scope.Scope>; 
}

----------------------------------------

TITLE: Constructing Failing Layer in TypeScript using Effect's Layer Module
DESCRIPTION: The failCause function constructs a layer that fails with a specified cause. It takes a Cause<E> as input and returns a Layer<unknown, E>. This function is useful for creating layers that represent failure scenarios.

LANGUAGE: typescript
CODE:
declare const failCause: <E>(cause: Cause.Cause<E>) => Layer<unknown, E>

----------------------------------------

TITLE: Using Doc.hcat for Horizontal Concatenation in TypeScript
DESCRIPTION: Demonstrates how to use the hcat combinator to concatenate words horizontally without spaces. The example shows concatenating 'lorem ipsum dolor' into a single string without spaces between words.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import * as String from "effect/String"

const doc: Doc.Doc<never> = Doc.hcat(Doc.words("lorem ipsum dolor"))

assert.strictEqual(
  Doc.render(doc, { style: "pretty" }),
  "loremipsumdolor"
)

LANGUAGE: typescript
CODE:
declare const hcat: <A>(docs: Iterable<Doc<A>>) => Doc<A>

----------------------------------------

TITLE: Implementing Tagged Error Recovery in TypeScript Effect
DESCRIPTION: Function signature for catchTag, which handles recovery from tagged errors. It takes a tag key and an error handler function, returning a new Micro effect that either succeeds with the original value or the recovery value.

LANGUAGE: typescript
CODE:
declare const catchTag: { <K extends E extends { _tag: string; } ? E["_tag"] : never, E, A1, E1, R1>(k: K, f: (e: Extract<E, { _tag: K; }>) => Micro<A1, E1, R1>): <A, R>(self: Micro<A, E, R>) => Micro<A1 | A, E1 | Exclude<E, { _tag: K; }>, R1 | R>; <A, E, R, K extends E extends { _tag: string; } ? E["_tag"] : never, R1, E1, A1>(self: Micro<A, E, R>, k: K, f: (e: Extract<E, { _tag: K; }>) => Micro<A1, E1, R1>): Micro<A | A1, E1 | Exclude<E, { _tag: K; }>, R | R1>; }

----------------------------------------

TITLE: Struct.get Function Signature in TypeScript
DESCRIPTION: Provides the TypeScript signature for the Struct.get function. It shows that the function takes a key of type PropertyKey and returns a function that accepts a struct and returns the value associated with the key.

LANGUAGE: typescript
CODE:
declare const get: <K extends PropertyKey>(key: K) => <S extends { [P in K]?: any; }>(s: S) => MatchRecord<S, S[K] | undefined, S[K]>

----------------------------------------

TITLE: Declaring collectAll Function for Metric Polling in TypeScript
DESCRIPTION: Function signature for collectAll that combines multiple MetricPolling instances into a single polling metric. It takes an Iterable of MetricPolling instances and returns a new MetricPolling instance that handles the collection of all metrics together.

LANGUAGE: typescript
CODE:
declare const collectAll: <R, E, Out>(iterable: Iterable<MetricPolling<any, any, R, E, Out>>) => MetricPolling<Array<any>, Array<any>, R, E, Array<Out>>

----------------------------------------

TITLE: Creating Fast-Check Arbitrary from Schema in TypeScript
DESCRIPTION: The make function takes a Schema and returns a fast-check Arbitrary for the A type of the provided schema. It is part of the Arbitrary module in the effect package.

LANGUAGE: typescript
CODE:
declare const make: <A, I, R>(schema: Schema.Schema<A, I, R>) => FastCheck.Arbitrary<A>

----------------------------------------

TITLE: Implementing greaterThanOrEqualTo Comparison in TypeScript
DESCRIPTION: Defines a function that creates a comparison operation to test if one value is non-strictly greater than another value. Takes an Order<A> type class instance and returns a curried function for comparing two values of type A.

LANGUAGE: typescript
CODE:
declare const greaterThanOrEqualTo: <A>(O: Order<A>) => { (that: A): (self: A) => boolean; (self: A, that: A): boolean; }

----------------------------------------

TITLE: Signature of takeWhile Function in Effect Module (TypeScript)
DESCRIPTION: Provides the TypeScript signature for the takeWhile function. It shows the function's type definition, including its parameters and return type.

LANGUAGE: typescript
CODE:
declare const takeWhile: { <A, E, R>(predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>): (elements: Iterable<A>) => Effect<Array<A>, E, R>; <A, E, R>(elements: Iterable<A>, predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>): Effect<Array<A>, E, R>; }

----------------------------------------

TITLE: Implementing filterMapWhile Function for Iterables in TypeScript
DESCRIPTION: Defines a function that transforms elements of an Iterable as long as a specified function returns some value. It takes a function f that maps elements to an Option<B> and applies it to each element of the Iterable until it returns None.

LANGUAGE: typescript
CODE:
declare const filterMapWhile: { <A, B>(f: (a: A, i: number) => Option<B>): (self: Iterable<A>) => Iterable<B>; <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option<B>): Iterable<B>; }

----------------------------------------

TITLE: Declaring Test Repetition Constant in TypeScript
DESCRIPTION: Defines a constant 'repeats' that represents the number of times to repeat tests to ensure stability. It returns an Effect with a number value and no error or dependency.

LANGUAGE: typescript
CODE:
declare const repeats: Effect.Effect<number, never, never>

----------------------------------------

TITLE: Declaring Layer.updateService Function in TypeScript
DESCRIPTION: Type declaration for the updateService function that enables modifying existing service implementations in a context. The function supports both curried and uncurried forms, taking a context tag, transformation function, and layer as parameters.

LANGUAGE: typescript
CODE:
declare const updateService: (<I, A>(tag: Context.Tag<I, A>, f: (a: A) => A) => <A1, E1, R1>(layer: Layer<A1, E1, R1>) => Layer<A1, E1, I | R1>) & (<A1, E1, R1, I, A>(layer: Layer<A1, E1, R1>, tag: Context.Tag<I, A>, f: (a: A) => A) => Layer<A1, E1, I | R1>)

----------------------------------------

TITLE: Defining Uppercase Schema Class in TypeScript
DESCRIPTION: TypeScript class declaration for the Uppercase schema transformer that converts strings to uppercase format. Part of the Effect library's Schema module for data transformation.

LANGUAGE: typescript
CODE:
declare class Uppercase

----------------------------------------

TITLE: Defining TSet Interface in TypeScript
DESCRIPTION: Type definition for the TSet interface that represents a transactional set. The interface uses a generic type parameter A with in/out variance modifiers and extends TSet.Variance<A>.

LANGUAGE: typescript
CODE:
export interface TSet<in out A> extends TSet.Variance<A> {}

----------------------------------------

TITLE: Checking FiberStatus Type in TypeScript
DESCRIPTION: This function is a type guard that checks if the given value is of type FiberStatus. It takes an unknown input and returns a boolean indicating whether the input is a FiberStatus. This is useful for type narrowing in TypeScript.

LANGUAGE: typescript
CODE:
declare const isFiberStatus: (u: unknown) => u is FiberStatus

----------------------------------------

TITLE: Defining CauseReducer Interface in TypeScript
DESCRIPTION: This snippet defines the CauseReducer interface, which includes methods for handling different cases in the Cause structure. It's designed for advanced transformations of Cause, allowing customization of how various parts of the Cause structure are transformed into a final type Z.

LANGUAGE: typescript
CODE:
export interface CauseReducer<in C, in E, in out Z> {
  emptyCase(context: C): Z
  failCase(context: C, error: E): Z
  dieCase(context: C, defect: unknown): Z
  interruptCase(context: C, fiberId: FiberId.FiberId): Z
  sequentialCase(context: C, left: Z, right: Z): Z
  parallelCase(context: C, left: Z, right: Z): Z
}

----------------------------------------

TITLE: Defining orElseIfEmpty Function for Stream in TypeScript
DESCRIPTION: Declares the orElseIfEmpty function, which produces a specified element if the stream is empty. It can be used in two ways: as a standalone function or as a method on a Stream instance.

LANGUAGE: typescript
CODE:
declare const orElseIfEmpty: { <A2>(element: LazyArg<A2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E, R>; <A, E, R, A2>(self: Stream<A, E, R>, element: LazyArg<A2>): Stream<A | A2, E, R>; }

----------------------------------------

TITLE: Demonstrating Incorrect Usage of runSync in TypeScript
DESCRIPTION: This example shows incorrect usage of runSync with failing or asynchronous effects. It demonstrates that attempting to run effects that involve asynchronous operations or failures will result in exceptions being thrown.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

try {
  // Attempt to run an effect that fails
  Effect.runSync(Effect.fail("my error"))
} catch (e) {
  console.error(e)
}
// Output:
// (FiberFailure) Error: my error

try {
  // Attempt to run an effect that involves async work
  Effect.runSync(Effect.promise(() => Promise.resolve(1)))
} catch (e) {
  console.error(e)
}
// Output:
// (FiberFailure) AsyncFiberException: Fiber #0 cannot be resolved synchronously. This is caused by using runSync on an effect that performs async work

----------------------------------------

TITLE: Declaring isAnnotated Function in TypeScript
DESCRIPTION: This snippet defines the isAnnotated function, which takes a Doc<A> as input and returns a boolean indicating whether it's an Annotated<A>. The function uses a type predicate for more precise type narrowing.

LANGUAGE: typescript
CODE:
declare const isAnnotated: <A>(self: Doc<A>) => self is Annotated<A>

----------------------------------------

TITLE: Defining formatLocal Function for DateTime Formatting in TypeScript
DESCRIPTION: This code snippet defines the formatLocal function, which formats a DateTime object as a string using the system's local time zone and locale. It utilizes the DateTimeFormat API and allows for optional formatting options.

LANGUAGE: typescript
CODE:
declare const formatLocal: { (options?: (Intl.DateTimeFormatOptions & { readonly locale?: string | undefined; }) | undefined): (self: DateTime) => string; (self: DateTime, options?: (Intl.DateTimeFormatOptions & { readonly locale?: string | undefined; }) | undefined): string; }

----------------------------------------

TITLE: Converting FiberId to HashSet in TypeScript
DESCRIPTION: The toSet function converts a FiberId into a HashSet<FiberId>. It takes a FiberId as input and returns a HashSet.HashSet<Runtime>. This function has been available since version 2.0.0 of the package.

LANGUAGE: typescript
CODE:
declare const toSet: (self: FiberId) => HashSet.HashSet<Runtime>

----------------------------------------

TITLE: Declaring service function in TypeScript for accessing Context.Tag
DESCRIPTION: This code snippet declares the `service` function, which is used to access a given `Context.Tag` from the environment. It has two overloads to handle different types of input tags.

LANGUAGE: typescript
CODE:
declare const service: { <I, S>(tag: Context.Reference<I, S>): Micro<S>; <I, S>(tag: Context.Tag<I, S>): Micro<S, never, I>; }

----------------------------------------

TITLE: Defining mapErrorCause Function for Micro Effects in TypeScript
DESCRIPTION: This code snippet defines the 'mapErrorCause' function, which transforms the full 'MicroCause' object of a given 'Micro' effect. It provides two overloads: one for curried usage and another for direct application.

LANGUAGE: typescript
CODE:
declare const mapErrorCause: { <E, E2>(f: (e: MicroCause<E>) => MicroCause<E2>): <A, R>(self: Micro<A, E, R>) => Micro<A, E2, R>; <A, E, R, E2>(self: Micro<A, E, R>, f: (e: MicroCause<E>) => MicroCause<E2>): Micro<A, E2, R>; }

----------------------------------------

TITLE: Checking Sequential ExecutionStrategy in TypeScript
DESCRIPTION: The isSequential function determines if a given ExecutionStrategy is an instance of Sequential. It returns true for Sequential instances and false otherwise. This function is useful for type checking and conditional logic based on execution strategy types.

LANGUAGE: typescript
CODE:
declare const isSequential: (self: ExecutionStrategy) => self is Sequential

----------------------------------------

TITLE: Demonstrating Doc.flatAlt Usage in TypeScript
DESCRIPTION: This example demonstrates how to use Doc.flatAlt to create a flexible document layout that adapts to available space. It creates a 'do' block that can be rendered on a single line or multiple lines based on the available width.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import { pipe } from "effect/Function"
import * as String from "effect/String"

const open = pipe(Doc.empty, Doc.flatAlt(Doc.text("{ ")))
const close = pipe(Doc.empty, Doc.flatAlt(Doc.text(" }")))
const separator = pipe(Doc.empty, Doc.flatAlt(Doc.text("; ")))

const prettyDo = <A>(documents: Array<Doc.Doc<A>>): Doc.Doc<A> => {
  return pipe(
    Doc.hsep([
      Doc.text("do"),
      pipe(
        documents,
        Doc.encloseSep(open, close, separator),
        Doc.align
      )
    ]),
    Doc.group
  )
}

const statements = [
  Doc.text("name:_ <- getArgs"),
  Doc.text("let greet = \"Hello, \" <> name"),
  Doc.text("putStrLn greet")
]

// If it fits, then the content is put onto a single line with the `{;}` style
assert.strictEqual(
  pipe(
    prettyDo(statements),
    Doc.render({
      style: "pretty",
      options: { lineWidth: 80 }
    })
  ),
  "do { name:_ <- getArgs; let greet = \"Hello, \" <> name; putStrLn greet }"
)

// When there is not enough space, the content is broken up onto multiple lines
assert.strictEqual(
  pipe(
    prettyDo(statements),
    Doc.render({
      style: "pretty",
      options: { lineWidth: 10 }
    })
  ),
  String.stripMargin(
    `|do name:_ <- getArgs
     |   let greet = "Hello, " <> name
     |   putStrLn greet`
  )
)

----------------------------------------

TITLE: Implementing Stream Leftover Collection in TypeScript Effect Sink
DESCRIPTION: Function that enhances a Sink by collecting remaining elements (leftovers) from the stream when the sink succeeds. Returns a new Sink that produces both the original result and the collected leftovers as a tuple.

LANGUAGE: typescript
CODE:
declare const collectLeftover: <A, In, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<[A, Chunk.Chunk<L>], In, never, E, R>

----------------------------------------

TITLE: Defining mapInputContext Function in RequestResolver Module
DESCRIPTION: This code snippet defines the mapInputContext function in the RequestResolver module. It allows mapping the input context of a RequestResolver, providing flexibility in context transformation.

LANGUAGE: typescript
CODE:
declare const mapInputContext: { <R0, R>(f: (context: Context.Context<R0>) => Context.Context<R>): <A extends Request.Request<any, any>>(self: RequestResolver<A, R>) => RequestResolver<A, R0>; <R, A extends Request.Request<any, any>, R0>(self: RequestResolver<A, R>, f: (context: Context.Context<R0>) => Context.Context<R>): RequestResolver<A, R0>; }

----------------------------------------

TITLE: Defining Schema.Redacted Transformation in TypeScript
DESCRIPTION: Declares a constant Redacted that transforms a Schema<A, I, R> into a RedactedFromSelf<A>. It takes a Value extending Schema.Any and returns a Redacted version of that Value.

LANGUAGE: typescript
CODE:
declare const Redacted: <Value extends Schema.Any>(value: Value) => Redacted<Value>

----------------------------------------

TITLE: Defining Record Matching Predicate in TypeScript
DESCRIPTION: Declares a constant 'record' as a Predicate.Refinement that matches objects where keys are string or symbol and values are unknown. This function is part of the Match module in the Effect package.

LANGUAGE: typescript
CODE:
declare const record: Predicate.Refinement<unknown, { [x: string]: unknown; [x: symbol]: unknown; }>

----------------------------------------

TITLE: Defining contextWith Function in Channel Module (TypeScript)
DESCRIPTION: Declares the contextWith function, which accesses the context of a channel with a specified function. It takes a function that operates on the environment context and returns a Channel with specific type parameters.

LANGUAGE: typescript
CODE:
declare const contextWith: <Env, OutDone>(f: (env: Context.Context<Env>) => OutDone) => Channel<never, unknown, never, unknown, OutDone, unknown, Env>

----------------------------------------

TITLE: Signature of bindTo Function in TypeScript for Effect Module
DESCRIPTION: This code snippet shows the TypeScript signature of the bindTo function in the Effect module. It defines two overloads for the function, allowing it to be used with different parameter orders.

LANGUAGE: typescript
CODE:
declare const bindTo: { <N extends string>(name: N): <A, E, R>(self: Effect<A, E, R>) => Effect<{ [K in N]: A; }, E, R>; <A, E, R, N extends string>(self: Effect<A, E, R>, name: N): Effect<{ [K in N]: A; }, E, R>; }

----------------------------------------

TITLE: Using isPromise Type Guard in TypeScript
DESCRIPTION: Example demonstrating how to use the isPromise type guard function to check if a value is a Promise instance. Shows verification against both a plain object and an actual Promise.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { isPromise } from "effect/Predicate"

assert.deepStrictEqual(isPromise({}), false)
assert.deepStrictEqual(isPromise(Promise.resolve("hello")), true)

----------------------------------------

TITLE: Defining STM.provideContext Function in TypeScript
DESCRIPTION: Declares the provideContext function which provides the transaction its required environment, eliminating its dependency on R. It has two overloads for different use cases.

LANGUAGE: typescript
CODE:
declare const provideContext: { <R>(env: Context.Context<R>): <A, E>(self: STM<A, E, R>) => STM<A, E>; <A, E, R>(self: STM<A, E, R>, env: Context.Context<R>): STM<A, E>; }

----------------------------------------

TITLE: Implementing STM Finalization Transaction in TypeScript
DESCRIPTION: Defines a function that executes a finalization transaction in STM operations. The finalizer runs whether the main transaction succeeds or fails, though all operations are rolled back if the full transaction fails. The function is overloaded to support both curried and uncurried calling styles.

LANGUAGE: typescript
CODE:
declare const ensuring: {
  <R1, B>(finalizer: STM<B, never, R1>): <A, E, R>(self: STM<A, E, R>) => STM<A, E, R1 | R>;
  <A, E, R, R1, B>(self: STM<A, E, R>, finalizer: STM<B, never, R1>): STM<A, E, R | R1>;
}

----------------------------------------

TITLE: Checking for Context Instance in TypeScript
DESCRIPTION: Demonstrates how to use the Context.isContext function to check if a given argument is a Context instance. The example uses Node's assert module for verification.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Context } from "effect"

assert.strictEqual(Context.isContext(Context.empty()), true)

----------------------------------------

TITLE: Defining HttpApi.reflect Function in TypeScript
DESCRIPTION: Declares a function 'reflect' that extracts metadata from an HttpApi. It takes an HttpApi instance and options including predicates and callbacks for processing groups and endpoints. The function is designed to be used for documentation generation and tooling.

LANGUAGE: typescript
CODE:
declare const reflect: <Id extends string, Groups extends HttpApiGroup.HttpApiGroup.Any, Error, R>(self: HttpApi<Id, Groups, Error, R>, options: { readonly predicate?: Predicate.Predicate<{ readonly endpoint: HttpApiEndpoint.HttpApiEndpoint.AnyWithProps; readonly group: HttpApiGroup.HttpApiGroup.AnyWithProps; }>; readonly onGroup: (options: { readonly group: HttpApiGroup.HttpApiGroup.AnyWithProps; readonly mergedAnnotations: Context.Context<never>; }) => void; readonly onEndpoint: (options: { readonly group: HttpApiGroup.HttpApiGroup.AnyWithProps; readonly endpoint: HttpApiEndpoint.HttpApiEndpoint<string, HttpMethod>; readonly mergedAnnotations: Context.Context<never>; readonly middleware: ReadonlySet<HttpApiMiddleware.TagClassAny>; readonly payloads: ReadonlyMap<string, { readonly encoding: HttpApiSchema.Encoding; readonly ast: AST.AST; }>; readonly successes: ReadonlyMap<number, { readonly ast: Option.Option<AST.AST>; readonly description: Option.Option<string>; }>; readonly errors: ReadonlyMap<number, { readonly ast: Option.Option<AST.AST>; readonly description: Option.Option<string>; }>; }) => void; }) => void

----------------------------------------

TITLE: Checking Integer Status of BigDecimal Values in TypeScript
DESCRIPTION: Demonstrates how to use the isInteger function to check if a BigDecimal value represents an integer. The function returns true for whole numbers and false for decimal values.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { isInteger, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(isInteger(unsafeFromString("0")), true)
assert.deepStrictEqual(isInteger(unsafeFromString("1")), true)
assert.deepStrictEqual(isInteger(unsafeFromString("1.1")), false)

LANGUAGE: typescript
CODE:
declare const isInteger: (n: BigDecimal) => boolean

----------------------------------------

TITLE: Implementing Atomic Folding with reduceSTM in TypeScript
DESCRIPTION: The reduceSTM function atomically folds elements of a TSet using a transactional function. It takes an initial value, a folding function, and the TSet itself, returning an STM (Software Transactional Memory) operation.

LANGUAGE: typescript
CODE:
declare const reduceSTM: { <Z, A, R, E>(zero: Z, f: (accumulator: Z, value: A) => STM.STM<Z, E, R>): (self: TSet<A>) => STM.STM<Z, E, R>; <Z, A, R, E>(self: TSet<A>, zero: Z, f: (accumulator: Z, value: A) => STM.STM<Z, E, R>): STM.STM<Z, E, R>; }

----------------------------------------

TITLE: Defining Float Primitive Type in TypeScript
DESCRIPTION: Declares a constant float type that represents floating point numbers using Effect's Primitive type system. This is used for type-safe CLI parameter handling.

LANGUAGE: typescript
CODE:
declare const float: Primitive<number>

----------------------------------------

TITLE: Using HashSet.some in TypeScript
DESCRIPTION: Demonstrates different ways to use the HashSet.some method to check if a predicate holds true for any element in a HashSet. Shows data-first, data-last (pipeable), and pipe function approaches.

LANGUAGE: typescript
CODE:
// Syntax
import { HashSet, pipe } from "effect"

const set: HashSet.HashSet<number> = HashSet.make(0, 1, 2)

// with `data-last`, a.k.a. `pipeable` API
pipe(
  set,
  HashSet.some((n) => n > 0)
) // true

// or piped with the pipe function
set.pipe(HashSet.some((n) => n > 0)) // true

// or with `data-first` API
HashSet.some(set, (n) => n > 0) // true

LANGUAGE: typescript
CODE:
declare const some: { <A>(f: Predicate<A>): (self: HashSet<A>) => boolean; <A>(self: HashSet<A>, f: Predicate<A>): boolean; }

----------------------------------------

TITLE: Defining asVoid Function for STM in TypeScript
DESCRIPTION: This function maps the success value of an STM to void. It preserves the success or failure state of the original STM, only modifying the success value type to void.

LANGUAGE: typescript
CODE:
declare const asVoid: <A, E, R>(self: STM<A, E, R>) => STM<void, E, R>

----------------------------------------

TITLE: Creating Cookies Object from ReadonlyRecord in TypeScript
DESCRIPTION: This function creates a Cookies object from a ReadonlyRecord of string keys and Cookie values. It is part of the Cookies module in the @effect/platform package.

LANGUAGE: typescript
CODE:
declare const fromReadonlyRecord: (cookies: Record.ReadonlyRecord<string, Cookie>) => Cookies

----------------------------------------

TITLE: Interrupting Multiple Fibers in TypeScript using Effect
DESCRIPTION: The interruptAllAs function interrupts all specified fibers using a given fiber ID. It can be called with either the fiber ID first and fibers second, or fibers first and fiber ID second. The function returns an Effect that completes when all fibers have been interrupted.

LANGUAGE: typescript
CODE:
declare const interruptAllAs: { (fiberId: FiberId.FiberId): (fibers: Iterable<Fiber<any, any>>) => Effect.Effect<void>; (fibers: Iterable<Fiber<any, any>>, fiberId: FiberId.FiberId): Effect.Effect<void>; }

----------------------------------------

TITLE: Defining Left Angle Bracket Document in TypeScript
DESCRIPTION: Defines a constant Doc.langle that represents a document containing a single left angle bracket (<) character. This is part of the @effect/printer package's document formatting functionality.

LANGUAGE: typescript
CODE:
declare const langle: Doc<never>

----------------------------------------

TITLE: Defining Sink.some Function in TypeScript
DESCRIPTION: Declares a function 'some' that creates a sink which returns whether an element satisfies a specified predicate. It takes a predicate function as input and returns a Sink that processes elements of type 'In' and produces a boolean result.

LANGUAGE: typescript
CODE:
declare const some: <In>(predicate: Predicate<In>) => Sink<boolean, In, In>

----------------------------------------

TITLE: Using constUndefined Function in TypeScript
DESCRIPTION: Demonstrates how to use the constUndefined function, which is a thunk that always returns undefined. This utility function can be useful in scenarios where a consistent undefined return value is needed.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { constUndefined } from "effect/Function"

assert.deepStrictEqual(constUndefined(), undefined)

LANGUAGE: typescript
CODE:
declare const constUndefined: LazyArg<undefined>

----------------------------------------

TITLE: Using Doc.width Combinator in TypeScript
DESCRIPTION: Demonstrates how to use the Doc.width combinator to annotate documents with their width. It creates a function that wraps a document in square brackets and appends its width.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import { pipe } from "effect/Function"
import * as String from "effect/String"

const annotate = <A>(doc: Doc.Doc<A>): Doc.Doc<A> =>
  pipe(
    Doc.squareBracketed(doc),
    Doc.width((w) => Doc.text(` <- width: ${w}`))
  )

const docs = [
  Doc.text("---"),
  Doc.text("------"),
  Doc.indent(Doc.text("---"), 3),
  Doc.vsep([Doc.text("---"), Doc.indent(Doc.text("---"), 4)])
]

const doc = Doc.align(Doc.vsep(docs.map(annotate)))

assert.strictEqual(
  Doc.render(doc, { style: "pretty" }),
  String.stripMargin(
    `|[---] <- width: 5
     |[------] <- width: 8
     |[   ---] <- width: 8
     |[---
     |    ---] <- width: 8`
  )
)

----------------------------------------

TITLE: Getting Help Documentation for Primitive Types in Effect CLI
DESCRIPTION: Function that returns help documentation in the form of a Span for a given primitive type. This is used to generate CLI help text for primitive type parameters.

LANGUAGE: typescript
CODE:
declare const getHelp: <A>(self: Primitive<A>) => Span

----------------------------------------

TITLE: Retrieving First Element from MutableList in TypeScript
DESCRIPTION: The head function returns the first element of a MutableList if it exists. It takes a MutableList<A> as input and returns either an element of type A or undefined if the list is empty.

LANGUAGE: typescript
CODE:
declare const head: <A>(self: MutableList<A>) => A | undefined

----------------------------------------

TITLE: Using nextPow2 Function in Effect/Number
DESCRIPTION: Demonstrates how to use the nextPow2 function to find the next power of 2 for a given number. The function takes a number as input and returns the smallest power of 2 that is greater than or equal to the input.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { nextPow2 } from "effect/Number"

assert.deepStrictEqual(nextPow2(5), 8)
assert.deepStrictEqual(nextPow2(17), 32)

LANGUAGE: typescript
CODE:
declare const nextPow2: (n: number) => number

----------------------------------------

TITLE: Swapping Tuple Elements in TypeScript using effect/Tuple
DESCRIPTION: Demonstrates how to use the swap function from the effect/Tuple module to interchange the elements of a tuple. The function takes a tuple with two elements and returns a new tuple with the elements in reverse order.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { swap } from "effect/Tuple"

assert.deepStrictEqual(swap(["hello", 42]), [42, "hello"])

----------------------------------------

TITLE: Match.not Type Signature in TypeScript
DESCRIPTION: Type signature for the Match.not function showing its generic parameters and return type. Demonstrates the complex type system used to ensure type safety in pattern matching.

LANGUAGE: typescript
CODE:
declare const not: <R, const P extends Types.PatternPrimitive<R> | Types.PatternBase<R>, Ret, Fn extends (_: Exclude<R, Types.ExtractMatch<R, Types.PForExclude<P>>>) => Ret>(pattern: P, f: Fn) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr, Ret>) => Matcher<I, Types.AddOnly<F, Types.WhenMatch<R, P>>, Types.ApplyFilters<I, Types.AddOnly<F, Types.WhenMatch<R, P>>>, A | ReturnType<Fn>, Pr, Ret>

----------------------------------------

TITLE: Defining layerTestClient Layer in TypeScript for @effect/platform HttpServer
DESCRIPTION: Declares a constant layerTestClient as a Layer that produces an HttpClient. It prepends the URL of the running HTTP server to the client. The Layer depends on HttpServer and HttpClient, with no errors.

LANGUAGE: typescript
CODE:
declare const layerTestClient: Layer.Layer<Client.HttpClient, never, HttpServer | Client.HttpClient>

----------------------------------------

TITLE: Stream Finalizer Type Signature in TypeScript
DESCRIPTION: Type signature for the Stream.finalizer function, showing it takes an Effect that never fails and returns a Stream of void that never fails.

LANGUAGE: typescript
CODE:
declare const finalizer: <R, X>(finalizer: Effect.Effect<X, never, R>) => Stream<void, never, R>

----------------------------------------

TITLE: Defining bindTo Function for Micro Effects in TypeScript
DESCRIPTION: This code snippet defines the bindTo function for Micro effects. It allows binding the success value of a Micro effect to a provided name. The function has two overloads to support different calling patterns.

LANGUAGE: typescript
CODE:
declare const bindTo: { <N extends string>(name: N): <A, E, R>(self: Micro<A, E, R>) => Micro<{ [K in N]: A; }, E, R>; <A, E, R, N extends string>(self: Micro<A, E, R>, name: N): Micro<{ [K in N]: A; }, E, R>; }

----------------------------------------

TITLE: Using Effect.cause for Error Handling in TypeScript
DESCRIPTION: Demonstrates how to use Effect.cause to retrieve and log the detailed cause of a failed effect. The example shows creating a failing effect and recovering it to inspect the failure cause.

LANGUAGE: typescript
CODE:
import { Effect, Console } from "effect"

//      ┌─── Effect<number, string, never>
//      ▼
const program = Effect.fail("Oh uh!").pipe(Effect.as(2))

//      ┌─── Effect<void, never, never>
//      ▼
const recovered = Effect.gen(function* () {
  const cause = yield* Effect.cause(program)
  yield* Console.log(cause)
})

----------------------------------------

TITLE: Defining takeSomeSTM Function in TypeScript for TSet Module
DESCRIPTION: Declares a function takeSomeSTM that takes matching values from a TSet, or retries until there is at least one. It accepts a partial function and a TSet as parameters, returning an STM (Software Transactional Memory) operation.

LANGUAGE: typescript
CODE:
declare const takeSomeSTM: { <A, B, E, R>(pf: (a: A) => STM.STM<B, Option.Option<E>, R>): (self: TSet<A>) => STM.STM<[B, ...Array<B>], E, R>; <A, B, E, R>(self: TSet<A>, pf: (a: A) => STM.STM<B, Option.Option<E>, R>): STM.STM<[B, ...Array<B>], E, R>; }

----------------------------------------

TITLE: Checking Runtime Flag Status in Effect TypeScript
DESCRIPTION: Function definition for checking if a specific RuntimeFlag is enabled. The function supports both curried and direct calling styles, taking a RuntimeFlag parameter and returning a boolean indicating if the flag is enabled.

LANGUAGE: typescript
CODE:
declare const isEnabled: { (flag: RuntimeFlag): (self: RuntimeFlags) => boolean; (self: RuntimeFlags, flag: RuntimeFlag): boolean; }

----------------------------------------

TITLE: Implementing Request.failCause in TypeScript
DESCRIPTION: Function signature for completing a Request with a specified cause. Provides two overloads: one that takes the cause first and returns a function, and another that takes both the request and cause directly.

LANGUAGE: typescript
CODE:
declare const failCause: { 
  <A extends Request<any, any>>(cause: Cause<Request.Error<A>>): (self: A) => Effect.Effect<void>; 
  <A extends Request<any, any>>(self: A, cause: Cause<Request.Error<A>>): Effect.Effect<void>; 
}

----------------------------------------

TITLE: Testing undefined values with Effect Predicate.isNotUndefined
DESCRIPTION: Demonstrates the usage of isNotUndefined predicate function that checks if a value is not undefined. The function returns true for any value except undefined, including null and the string 'undefined'.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { isNotUndefined } from "effect/Predicate"

assert.deepStrictEqual(isNotUndefined(null), true)
assert.deepStrictEqual(isNotUndefined("undefined"), true)

assert.deepStrictEqual(isNotUndefined(undefined), false)

LANGUAGE: typescript
CODE:
declare const isNotUndefined: <A>(input: A) => input is Exclude<A, undefined>

----------------------------------------

TITLE: Defining matchEffect Function in TypeScript for Take Module
DESCRIPTION: Declares the matchEffect function, which is an effectful version of Take.fold. It folds over the failure cause, success value, and end-of-stream marker to yield an effect. The function takes options for handling end, failure, and success cases, and returns an Effect.

LANGUAGE: typescript
CODE:
declare const matchEffect: { <Z, E2, R, E, Z2, R2, A, Z3, E3, R3>(options: { readonly onEnd: Effect.Effect<Z, E2, R>; readonly onFailure: (cause: Cause.Cause<E>) => Effect.Effect<Z2, E2, R2>; readonly onSuccess: (chunk: Chunk.Chunk<A>) => Effect.Effect<Z3, E3, R3>; }): (self: Take<A, E>) => Effect.Effect<Z | Z2 | Z3, E2 | E | E3, R | R2 | R3>; <A, E, Z, E2, R, Z2, R2, Z3, E3, R3>(self: Take<A, E>, options: { readonly onEnd: Effect.Effect<Z, E2, R>; readonly onFailure: (cause: Cause.Cause<E>) => Effect.Effect<Z2, E2, R2>; readonly onSuccess: (chunk: Chunk.Chunk<A>) => Effect.Effect<Z3, E3, R3>; }): Effect.Effect<Z | Z2 | Z3, E | E2 | E3, R | R2 | R3>; }

----------------------------------------

TITLE: Defining WithPageWidth Interface for Responsive Document Rendering in TypeScript
DESCRIPTION: This TypeScript interface defines WithPageWidth, which extends Doc.Variance<A>. It includes a _tag property set to "WithPageWidth" and a react method that takes a PageWidth parameter and returns a Doc<A>. This structure allows for creating documents that can adapt their rendering based on the available page width.

LANGUAGE: typescript
CODE:
export interface WithPageWidth<A> extends Doc.Variance<A> {
  readonly _tag: "WithPageWidth"
  readonly react: (pageWidth: PageWidth) => Doc<A>
}

----------------------------------------

TITLE: Calculating Remaining Width in TypeScript
DESCRIPTION: Function signature for calculating the remaining width on the current line. Takes parameters for line length, ribbon fraction, line indentation, and current column position to determine available space.

LANGUAGE: typescript
CODE:
declare const remainingWidth: (lineLength: number, ribbonFraction: number, lineIndent: number, currentColumn: number) => number

----------------------------------------

TITLE: Defining minuteOfHour Schedule Function in TypeScript
DESCRIPTION: This snippet defines the minuteOfHour function, which creates a schedule that recurs every specified minute of each hour. It returns a Schedule<number> that produces a count of executions.

LANGUAGE: typescript
CODE:
declare const minuteOfHour: (minute: number) => Schedule<number>

----------------------------------------

TITLE: Resource Management with Micro.acquireRelease in TypeScript
DESCRIPTION: Creates a resource with an associated cleanup effect that executes when the MicroScope closes. Takes an acquire function to obtain the resource and a release function to clean it up.

LANGUAGE: typescript
CODE:
declare const acquireRelease: <A, E, R>(acquire: Micro<A, E, R>, release: (a: A, exit: MicroExit<unknown, unknown>) => Micro<void>) => Micro<A, E, R | MicroScope>

----------------------------------------

TITLE: Defining RPC Interface with Generic Types in TypeScript
DESCRIPTION: TypeScript interface definition for an RPC endpoint that includes generic type parameters for tag, payload schema, success schema, error schema and middleware. The interface provides methods for setting schemas, adding middleware and handling annotations.

LANGUAGE: typescript
CODE:
export interface Rpc<
  out Tag extends string,
  out Payload extends AnyStructSchema = Schema.Struct<{}>,
  out Success extends Schema.Schema.Any = typeof Schema.Void,
  out Error extends Schema.Schema.All = typeof Schema.Never,
  out Middleware extends RpcMiddleware.TagClassAny = never
> extends Pipeable {
  readonly [TypeId]: TypeId
  readonly _tag: Tag
  readonly key: string
  readonly payloadSchema: Payload
  readonly successSchema: Success
  readonly errorSchema: Error
  readonly annotations: Context_.Context<never>
  readonly middlewares: ReadonlySet<Middleware>

  /**
   * Set the schema for the success response of the rpc.
   */
  setSuccess<S extends Schema.Schema.Any>(schema: S): Rpc<
    Tag,
    Payload,
    S,
    Error,
    Middleware
  >

  /**
   * Set the schema for the error response of the rpc.
   */
  setError<E extends Schema.Schema.Any>(schema: E): Rpc<
    Tag,
    Payload,
    Success,
    E,
    Middleware
  >

  /**
   * Set the schema for the payload of the rpc.
   */
  setPayload<P extends Schema.Struct<any> | Schema.Struct.Fields>(
    schema: P
  ): Rpc<
    Tag,
    P extends Schema.Struct<infer _> ? P : P extends Schema.Struct.Fields ? Schema.Struct<P> : never,
    Success,
    Error,
    Middleware
  >

  /**
   * Add an `RpcMiddleware` to this procedure.
   */
  middleware<M extends RpcMiddleware.TagClassAny>(middleware: M): Rpc<
    Tag,
    Payload,
    Success,
    Error,
    Middleware | M
  >

  /**
   * Add an annotation on the rpc.
   */
  annotate<I, S>(
    tag: Context_.Tag<I, S>,
    value: S
  ): Rpc<Tag, Payload, Success, Error, Middleware>

  /**
   * Merge the annotations of the rpc with the provided context.
   */
  annotateContext<I>(
    context: Context_.Context<I>
  ): Rpc<Tag, Payload, Success, Error, Middleware>
}

----------------------------------------

TITLE: Implementing catchSomeCause Function in TypeScript Effect Module
DESCRIPTION: Function signature for catchSomeCause, which recovers from specific causes using a provided partial function. It provides two overloads for handling cause recovery with different parameter orders. The function allows selective error handling based on the Cause type.

LANGUAGE: typescript
CODE:
declare const catchSomeCause: { <E, A2, E2, R2>(f: (cause: Cause.Cause<NoInfer<E>>) => Option.Option<Effect<A2, E2, R2>>): <A, R>(self: Effect<A, E, R>) => Effect<A2 | A, E | E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, f: (cause: Cause.Cause<NoInfer<E>>) => Option.Option<Effect<A2, E2, R2>>): Effect<A2 | A, E | E2, R2 | R>; }

----------------------------------------

TITLE: Implementing findLastIndex Function in TypeScript Effect Package
DESCRIPTION: Defines a function that returns the last index in a Chunk where a given predicate returns true. The function supports both curried and uncurried calling styles and returns an Option type containing the found index.

LANGUAGE: typescript
CODE:
declare const findLastIndex: { <A>(predicate: Predicate<A>): (self: Chunk<A>) => Option<number>; <A>(self: Chunk<A>, predicate: Predicate<A>): Option<number>; }

----------------------------------------

TITLE: Implementing Stream Context Access in TypeScript
DESCRIPTION: Defines a function that allows accessing the context of a Stream. The function takes a callback that receives the Context<R> and returns a value of type A, producing a Stream<A, never, R>.

LANGUAGE: typescript
CODE:
declare const contextWith: <R, A>(f: (env: Context.Context<R>) => A) => Stream<A, never, R>

----------------------------------------

TITLE: Checking Failures in Cause Module - TypeScript
DESCRIPTION: Function that determines if a Cause contains a failure by checking for Fail errors. This is useful for distinguishing between anticipated errors versus defects or interruptions in Effect workflows.

LANGUAGE: typescript
CODE:
declare const isFailure: <E>(self: Cause<E>) => boolean

----------------------------------------

TITLE: Declaring linesWithSeparators Function in TypeScript
DESCRIPTION: Declares a function named linesWithSeparators that takes a string as input and returns a LinesIterator. This function yields each line in the input string along with its trailing newline character.

LANGUAGE: typescript
CODE:
declare const linesWithSeparators: (s: string) => LinesIterator

----------------------------------------

TITLE: TypeScript Function Signature for isNumber Predicate
DESCRIPTION: This code block shows the TypeScript function signature for the isNumber predicate. It defines a function that takes an unknown input and returns a boolean indicating if the input is a number.

LANGUAGE: typescript
CODE:
declare const isNumber: (input: unknown) => input is number

----------------------------------------

TITLE: Implementing Atomic Conjunction Evaluation on TArray in TypeScript
DESCRIPTION: The 'every' function atomically evaluates the conjunction of a predicate across the members of a TArray. It can be called with the predicate first or the array first, providing flexibility in usage.

LANGUAGE: typescript
CODE:
declare const every: { <A>(predicate: Predicate<A>): (self: TArray<A>) => STM.STM<boolean>; <A>(self: TArray<A>, predicate: Predicate<A>): STM.STM<boolean>; }

----------------------------------------

TITLE: Implementing STM.repeatWhile Function in TypeScript
DESCRIPTION: Defines a function that repeats an STM effect while its result satisfies a predicate condition. Important considerations include that it uses a busy loop which consumes a thread until completion and cannot yield. It's recommended to use retryWhile instead if transaction state doesn't need to be maintained between repeats.

LANGUAGE: typescript
CODE:
declare const repeatWhile: { <A>(predicate: Predicate<A>): <E, R>(self: STM<A, E, R>) => STM<A, E, R>; <A, E, R>(self: STM<A, E, R>, predicate: Predicate<A>): STM<A, E, R>; }

----------------------------------------

TITLE: Defining RunnerUnavailable Error Class in TypeScript for @effect/cluster
DESCRIPTION: Declares the RunnerUnavailable class to represent errors when a Runner is unresponsive in a cluster. This class is part of the ClusterError module and is used to handle scenarios where a Runner becomes unavailable during cluster operations.

LANGUAGE: typescript
CODE:
declare class RunnerUnavailable

----------------------------------------

TITLE: Implementing NDJSON RPC Serialization Layer in TypeScript
DESCRIPTION: Defines a Layer for RPC serialization that uses NDJSON (Newline Delimited JSON) format. This implementation is specifically designed for protocols that don't support message framing, providing an alternative to the standard JSON layer.

LANGUAGE: typescript
CODE:
declare const layerNdjson: Layer.Layer<RpcSerialization, never, never>

----------------------------------------

TITLE: Either.liftPredicate Type Definition
DESCRIPTION: Type signature for the Either.liftPredicate function showing its polymorphic nature. It supports both refinement and predicate functions with corresponding error handling.

LANGUAGE: typescript
CODE:
declare const liftPredicate: { <A, B extends A, E>(refinement: Refinement<NoInfer<A>, B>, orLeftWith: (a: NoInfer<A>) => E): (a: A) => Either<B, E>; <A, E>(predicate: Predicate<NoInfer<A>>, orLeftWith: (a: NoInfer<A>) => E): (a: A) => Either<A, E>; <A, E, B extends A>(self: A, refinement: Refinement<A, B>, orLeftWith: (a: A) => E): Either<B, E>; <A, E>(self: A, predicate: Predicate<NoInfer<A>>, orLeftWith: (a: NoInfer<A>) => E): Either<A, E>; }

----------------------------------------

TITLE: Calculating DateTime Differences with Effect
DESCRIPTION: Demonstrates how to calculate the duration between two DateTime values, returning a Left for negative durations (when other is before self) and Right for positive durations (when other is after self). The function returns the difference as an Either<Duration, Duration> type.

LANGUAGE: typescript
CODE:
import { DateTime, Effect } from "effect"

Effect.gen(function* () {
  const now = yield* DateTime.now
  const other = DateTime.add(now, { minutes: 1 })

  // returns Either.right(Duration.minutes(1))
  DateTime.distanceDurationEither(now, other)

  // returns Either.left(Duration.minutes(1))
  DateTime.distanceDurationEither(other, now)
})

LANGUAGE: typescript
CODE:
declare const distanceDurationEither: { (other: DateTime): (self: DateTime) => Either.Either<Duration.Duration, Duration.Duration>; (self: DateTime, other: DateTime): Either.Either<Duration.Duration, Duration.Duration>; }

----------------------------------------

TITLE: Creating Dual-Style Functions with Predicate in TypeScript
DESCRIPTION: Illustrates how to use a predicate function instead of arity to determine the function style when creating a dual-style function.

LANGUAGE: typescript
CODE:
import { dual, pipe } from "effect/Function"

const sum = dual<
  (that: number) => (self: number) => number,
  (self: number, that: number) => number
>(
  (args) => args.length === 2,
  (self, that) => self + that
)

console.log(sum(2, 3)) // 5
console.log(pipe(2, sum(3))) // 5

----------------------------------------

TITLE: Declaring Test Services Context in TypeScript
DESCRIPTION: Declares a constant liveServices that represents the default Effect test services context. This provides the default implementation of test services for the Effect framework.

LANGUAGE: typescript
CODE:
declare const liveServices: Context.Context<TestServices>

----------------------------------------

TITLE: Defining Deep Optimization Interface in TypeScript
DESCRIPTION: Defines a TypeScript interface for deep document fusion optimization that recursively processes all leaves of the document tree, including layout alternatives and location-sensitive values. This optimization strategy should only be used when profiling shows significant performance improvements over Shallow optimization.

LANGUAGE: typescript
CODE:
export interface Deep {
  readonly _tag: "Deep"
}

----------------------------------------

TITLE: Defining Micro.flatMap Function Signature in TypeScript
DESCRIPTION: Declares the type signature for the flatMap function, which maps the success value of a Micro effect to another Micro effect and flattens the result. It supports both curried and uncurried forms of the function.

LANGUAGE: typescript
CODE:
declare const flatMap: { <A, B, E2, R2>(f: (a: A) => Micro<B, E2, R2>): <E, R>(self: Micro<A, E, R>) => Micro<B, E | E2, R | R2>; <A, E, R, B, E2, R2>(self: Micro<A, E, R>, f: (a: A) => Micro<B, E2, R2>): Micro<B, E | E2, R | R2>; }

----------------------------------------

TITLE: Copying Arrays with Effect Library in TypeScript
DESCRIPTION: Demonstrates how to use the Array.copy function from the Effect library to create a shallow copy of an array. The function works with both regular arrays and non-empty arrays, preserving their type.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const result = Array.copy([1, 2, 3])
console.log(result) // [1, 2, 3]

LANGUAGE: typescript
CODE:
declare const copy: { <A>(self: NonEmptyReadonlyArray<A>): NonEmptyArray<A>; <A>(self: ReadonlyArray<A>): Array<A>; }

----------------------------------------

TITLE: Using isTruthy Predicate in TypeScript
DESCRIPTION: Demonstrates how to use the isTruthy function from the Effect library's Predicate module. It tests various values for truthiness and uses Node.js assertions to verify the results.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { isTruthy } from "effect/Predicate"

assert.deepStrictEqual(isTruthy(1), true)
assert.deepStrictEqual(isTruthy(0), false)
assert.deepStrictEqual(isTruthy(""), false)

----------------------------------------

TITLE: Defining haltWhenDeferred Function for Stream Manipulation in TypeScript
DESCRIPTION: Declares the haltWhenDeferred function, which halts the evaluation of a stream when a provided promise resolves. If the promise fails, the stream emits that failure. The function is overloaded to handle different parameter orders.

LANGUAGE: typescript
CODE:
declare const haltWhenDeferred: { <X, E2>(deferred: Deferred.Deferred<X, E2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R>; <A, E, R, X, E2>(self: Stream<A, E, R>, deferred: Deferred.Deferred<X, E2>): Stream<A, E | E2, R>; }

----------------------------------------

TITLE: Converting Duration to Time Parts in TypeScript
DESCRIPTION: Function signature for converting a Duration input into an object containing its time components. Returns an object with numeric values for days, hours, minutes, seconds, milliseconds and nanoseconds.

LANGUAGE: typescript
CODE:
declare const parts: (self: DurationInput) => { days: number; hours: number; minutes: number; seconds: number; millis: number; nanos: number; }

----------------------------------------

TITLE: Checking Shutdown Status in TPubSub Module (TypeScript)
DESCRIPTION: The isShutdown function returns a boolean indicating whether the shutdown method has been called on a TPubSub instance. It operates within the STM (Software Transactional Memory) context.

LANGUAGE: typescript
CODE:
declare const isShutdown: <A>(self: TPubSub<A>) => STM.STM<boolean>

----------------------------------------

TITLE: Initializing LocalStorage Layer in Effect Platform Browser
DESCRIPTION: Creates a KeyValueStore layer implementation that uses browser's localStorage API to persist data between sessions. This layer can be used to integrate localStorage-based storage into Effect applications.

LANGUAGE: typescript
CODE:
declare const layerLocalStorage: Layer.Layer<KeyValueStore.KeyValueStore, never, never>

----------------------------------------

TITLE: Implementing Choice-Based CLI Options in TypeScript with Effect
DESCRIPTION: Demonstrates how to create a command-line option that maps string choices to specific data types using the @effect/cli library. The example shows mapping 'dog' and 'cat' strings to Dog and Cat type instances respectively.

LANGUAGE: typescript
CODE:
import * as Options from "@effect/cli/Options"
import * as Data from "effect/Data"

export type Animal = Dog | Cat

export interface Dog {
  readonly _tag: "Dog"
}

export const Dog = Data.tagged<Dog>("Dog")

export interface Cat {
  readonly _tag: "Cat"
}

export const Cat = Data.tagged<Cat>("Cat")

export const animal: Options.Options<Animal> = Options.choiceWithValue("animal", [
  ["dog", Dog()],
  ["cat", Cat()],
])

LANGUAGE: typescript
CODE:
declare const choiceWithValue: <C extends ReadonlyArray<[string, any]>>(name: string, choices: C) => Options<C[number][1]>

----------------------------------------

TITLE: Formatting BigDecimal to Exponential Notation in TypeScript
DESCRIPTION: Demonstrates how to use the toExponential function from the BigDecimal module to format a BigDecimal as a string in scientific notation. The example creates a BigDecimal using the make function and then formats it using toExponential.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { toExponential, make } from "effect/BigDecimal"

assert.deepStrictEqual(toExponential(make(123456n, -5)), "1.23456e+10")

----------------------------------------

TITLE: Getting Queue Capacity in Effect TQueue
DESCRIPTION: Function signature for retrieving the maximum number of elements that can be stored in either a TDequeue or TEnqueue queue. Returns a number representing the queue's capacity.

LANGUAGE: typescript
CODE:
declare const capacity: <A>(self: TDequeue<A> | TEnqueue<A>) => number

----------------------------------------

TITLE: Implementing Atomic Transactional Effects on TSet Elements in TypeScript
DESCRIPTION: The forEach function atomically performs a transactional effect for each element in a TSet. It takes a function that transforms each element into an STM (Software Transactional Memory) effect and applies it to all elements in the set.

LANGUAGE: typescript
CODE:
declare const forEach: { <A, R, E>(f: (value: A) => STM.STM<void, E, R>): (self: TSet<A>) => STM.STM<void, E, R>; <A, R, E>(self: TSet<A>, f: (value: A) => STM.STM<void, E, R>): STM.STM<void, E, R>; }

----------------------------------------

TITLE: Using MergeRight Type in TypeScript
DESCRIPTION: Demonstrates how to use the MergeRight type to merge two object types. In this example, it merges an object with number properties and another with a string property, resulting in a combined type.

LANGUAGE: typescript
CODE:
import type { Types } from "effect"
type MergeRight = Types.MergeRight<{ a: number, b: number; }, { a: string }> // { a: string; b: number; }

----------------------------------------

TITLE: Implementing STM.zipWith Function in TypeScript
DESCRIPTION: Function signature for zipWith operation that sequentially combines two STM values using a specified combiner function. Supports both curried and uncurried versions of the operation, handling different error and environment type combinations.

LANGUAGE: typescript
CODE:
declare const zipWith: { 
  <A1, E1, R1, A, A2>(that: STM<A1, E1, R1>, f: (a: A, b: A1) => A2): <E, R>(self: STM<A, E, R>) => STM<A2, E1 | E, R1 | R>; 
  <A, E, R, A1, E1, R1, A2>(self: STM<A, E, R>, that: STM<A1, E1, R1>, f: (a: A, b: A1) => A2): STM<A2, E | E1, R | R1>; 
}

----------------------------------------

TITLE: Declaring taggedWithLabels Function for MetricKey in TypeScript
DESCRIPTION: This code snippet defines the taggedWithLabels function, which returns a new MetricKey with specified tags appended. It supports both curried and non-curried function calls.

LANGUAGE: typescript
CODE:
declare const taggedWithLabels: { (extraTags: ReadonlyArray<MetricLabel.MetricLabel>): <Type extends MetricKeyType.MetricKeyType<any, any>>(self: MetricKey<Type>) => MetricKey<Type>; <Type extends MetricKeyType.MetricKeyType<any, any>>(self: MetricKey<Type>, extraTags: ReadonlyArray<MetricLabel.MetricLabel>): MetricKey<Type>; }

----------------------------------------

TITLE: Forking Service Reload in TypeScript using Effect
DESCRIPTION: The reloadFork function forks the reload of a service in the background, ignoring any errors. It takes a Context.Tag as a parameter and returns an Effect that requires a Reloadable<I>.

LANGUAGE: typescript
CODE:
declare const reloadFork: <I, S>(tag: Context.Tag<I, S>) => Effect.Effect<void, unknown, Reloadable<I>>

----------------------------------------

TITLE: Implementing productMany for SemiProduct in TypeScript
DESCRIPTION: This function returns a default implementation of productMany for the SemiProduct typeclass. It takes the map method from Covariant and the product method from SemiProduct as parameters to create the implementation.

LANGUAGE: typescript
CODE:
declare const productMany: <F extends TypeLambda>(map: Covariant<F>["map"], product: SemiProduct<F>["product"]) => SemiProduct<F>["productMany"]

----------------------------------------

TITLE: TypeScript Function Signature for Effect.transposeMapOption
DESCRIPTION: Provides the TypeScript function signature for the Effect.transposeMapOption function, showing its type parameters and overloads.

LANGUAGE: typescript
CODE:
declare const transposeMapOption: (<A, B, E = never, R = never>(f: (self: A) => Effect<B, E, R>) => (self: Option.Option<A>) => Effect<Option.Option<B>, E, R>) & (<A, B, E = never, R = never>(self: Option.Option<A>, f: (self: A) => Effect<B, E, R>) => Effect<Option.Option<B>, E, R>)

----------------------------------------

TITLE: Type Signature for Option.contains in TypeScript
DESCRIPTION: This code snippet shows the type signature for the Option.contains function. It demonstrates that the function can be used in two ways: either by passing the value first and then the Option, or by passing the Option first and then the value.

LANGUAGE: typescript
CODE:
declare const contains: { <A>(a: A): (self: Option<A>) => boolean; <A>(self: Option<A>, a: A): boolean; }

----------------------------------------

TITLE: Defining PageWidth Type in TypeScript for @effect/printer
DESCRIPTION: Defines the PageWidth type as a union of AvailablePerLine and Unbounded. This type is used to specify the maximum character limit for a single line in document layout algorithms.

LANGUAGE: typescript
CODE:
type PageWidth = AvailablePerLine | Unbounded

----------------------------------------

TITLE: Defining getOrElse Function for FiberId in TypeScript
DESCRIPTION: Declares the getOrElse function for FiberId, which returns the current FiberId if it's not None, otherwise returns the provided FiberId. The function has two overloads to support different parameter orders.

LANGUAGE: typescript
CODE:
declare const getOrElse: { (that: FiberId): (self: FiberId) => FiberId; (self: FiberId, that: FiberId): FiberId; }

----------------------------------------

TITLE: Accessing Effect Context in TypeScript
DESCRIPTION: A type declaration for accessing the full context of an effect. The context function returns an Effect that provides access to the environment values and dependencies needed by an effect to run. It takes a generic type parameter R for the context type.

LANGUAGE: typescript
CODE:
declare const context: <R>() => Effect<Context.Context<R>, never, R>

----------------------------------------

TITLE: Comparing BigInt Values Using greaterThan Function in TypeScript
DESCRIPTION: Demonstrates how to use the greaterThan function to compare two BigInt values. The function returns true if the first argument is greater than the second, and false otherwise. It supports both curried and uncurried calling styles.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { greaterThan } from "effect/BigInt"

assert.deepStrictEqual(greaterThan(2n, 3n), false)
assert.deepStrictEqual(greaterThan(3n, 3n), false)
assert.deepStrictEqual(greaterThan(4n, 3n), true)

LANGUAGE: typescript
CODE:
declare const greaterThan: { (that: bigint): (self: bigint) => boolean; (self: bigint, that: bigint): boolean; }

----------------------------------------

TITLE: Defining collect Function for Channel Transformation in TypeScript
DESCRIPTION: Defines the collect function that returns a new channel with filtered and transformed outputs. It takes a partial function as an argument to perform the transformation on the channel's output elements.

LANGUAGE: typescript
CODE:
declare const collect: { <OutElem, OutElem2>(pf: (o: OutElem) => Option.Option<OutElem2>): <InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, unknown, never, unknown, void, unknown, never>) => Channel<OutElem2, InElem, OutErr, InErr, OutDone, InDone, Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem2>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, pf: (o: OutElem) => Option.Option<OutElem2>): Channel<OutElem2, InElem, OutErr, InErr, OutDone, InDone, Env>; }

----------------------------------------

TITLE: Creating SSE Parser Function in TypeScript
DESCRIPTION: Function signature for creating an SSE (Server-Sent Events) parser. Takes a callback function that handles parsed events and returns a Parser object. Adapted from the eventsource-parser library under MIT license.

LANGUAGE: typescript
CODE:
declare const makeParser: (onParse: (event: AnyEvent) => void) => Parser

----------------------------------------

TITLE: Retrieving STM Context in TypeScript
DESCRIPTION: Function declaration for retrieving the environment context inside an STM transaction. Returns an STM that provides access to the context of type R.

LANGUAGE: typescript
CODE:
declare const context: <R>() => STM<Context.Context<R>, never, R>

----------------------------------------

TITLE: Defining Schedule.untilInputEffect Function in TypeScript
DESCRIPTION: Declares a function that creates a new schedule which stops execution when a given effectful predicate evaluates to true. The function supports both curried and uncurried forms, accepting a schedule and an effect-producing predicate function.

LANGUAGE: typescript
CODE:
declare const untilInputEffect: { <In, R2>(f: (input: In) => Effect.Effect<boolean, never, R2>): <Out, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>; <Out, In, R, R2>(self: Schedule<Out, In, R>, f: (input: In) => Effect.Effect<boolean, never, R2>): Schedule<Out, In, R | R2>; }

----------------------------------------

TITLE: Implementing isFailedStream Type Guard in TypeScript
DESCRIPTION: This function is a type guard that checks if a given DocStream is specifically a FailedStream. It returns true for FailedStream instances and false for other types of DocStream.

LANGUAGE: typescript
CODE:
declare const isFailedStream: <A>(self: DocStream<A>) => self is FailedStream<A>

----------------------------------------

TITLE: Implementing Identity Function in TypeScript using Effect Package
DESCRIPTION: Demonstrates the usage of the identity function from the Effect package's Function module. The identity function returns its input argument unchanged. This example shows how to import and use the function, along with an assertion to verify its behavior.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { identity } from "effect/Function"

assert.deepStrictEqual(identity(5), 5)

----------------------------------------

TITLE: Defining Closeable Type Alias in TypeScript
DESCRIPTION: Type alias definition that establishes Closeable as equivalent to CloseableScope type, providing a mechanism for explicitly closeable scopes in Effect-TS.

LANGUAGE: typescript
CODE:
type Closeable = CloseableScope

----------------------------------------

TITLE: Option.flatMapNullable Type Signature in TypeScript
DESCRIPTION: Type declaration for the flatMapNullable function showing its polymorphic nature and support for both curried and uncurried forms.

LANGUAGE: typescript
CODE:
declare const flatMapNullable: { <A, B>(f: (a: A) => B | null | undefined): (self: Option<A>) => Option<NonNullable<B>>; <A, B>(self: Option<A>, f: (a: A) => B | null | undefined): Option<NonNullable<B>>; }

----------------------------------------

TITLE: RegExp Type Guard Function Signature
DESCRIPTION: Type definition for the isRegExp function that serves as a type guard to narrow unknown types to RegExp when the check passes.

LANGUAGE: typescript
CODE:
declare const isRegExp: (input: unknown) => input is RegExp

----------------------------------------

TITLE: Implementing Atomic Value Transformation in TypeScript using TMap
DESCRIPTION: Defines a function that atomically updates all values in a TMap using a pure transformation function. The function supports both curried and direct invocation patterns and operates within STM transactions.

LANGUAGE: typescript
CODE:
declare const transformValues: { 
  <V>(f: (value: V) => V): <K>(self: TMap<K, V>) => STM.STM<void>; 
  <K, V>(self: TMap<K, V>, f: (value: V) => V): STM.STM<void>; 
}

----------------------------------------

TITLE: Declaring succeedNone Function in TypeScript for STM Module
DESCRIPTION: Defines the succeedNone constant as an STM effect that returns an empty Option value. This function is part of the STM module in the Effect package and has been available since version 2.0.0.

LANGUAGE: typescript
CODE:
declare const succeedNone: STM<Option.Option<never>, never, never>

----------------------------------------

TITLE: Formatting DateTime as UTC ISO Date String in TypeScript
DESCRIPTION: This function, formatIsoDateUtc, takes a DateTime object and returns a string representation of the date in UTC ISO format. It is part of the DateTime module in the Effect library.

LANGUAGE: typescript
CODE:
declare const formatIsoDateUtc: (self: DateTime) => string

----------------------------------------

TITLE: Defining zipWith Function for Iterables in TypeScript
DESCRIPTION: Declares the zipWith function, which applies a function to pairs of elements at the same index in two Iterables. It collects the results and handles cases where one Iterable is shorter than the other.

LANGUAGE: typescript
CODE:
declare const zipWith: { <B, A, C>(that: Iterable<B>, f: (a: A, b: B) => C): (self: Iterable<A>) => Iterable<C>; <A, B, C>(self: Iterable<A>, that: Iterable<B>, f: (a: A, b: B) => C): Iterable<C>; }

----------------------------------------

TITLE: Defining FileSystem.Size Type in TypeScript
DESCRIPTION: Creates a branded bigint type specifically for representing file sizes in bytes. Uses the Brand utility to create a type-safe representation that prevents mixing with regular bigint values.

LANGUAGE: typescript
CODE:
type Size = Brand.Branded<bigint, "Size">

----------------------------------------

TITLE: Implementing Type Flip Operation in TypeScript Effect Package
DESCRIPTION: Function signature for flip operation that swaps the error (E) and success (A) types of a Micro effect while preserving the environment type (R). This is useful for inverting the success and error channels of an effect.

LANGUAGE: typescript
CODE:
declare const flip: <A, E, R>(self: Micro<A, E, R>) => Micro<E, A, R>

----------------------------------------

TITLE: Defining ANSI eraseUp Function in TypeScript
DESCRIPTION: Declares a constant eraseUp of type Ansi. This function clears the screen from the current cursor position to the beginning without changing the cursor position.

LANGUAGE: typescript
CODE:
declare const eraseUp: Ansi

----------------------------------------

TITLE: Implementing STM Retry Function in TypeScript
DESCRIPTION: Defines a constant retry function for aborting and retrying STM transactions when underlying transactional variables change. The function takes no parameters and returns never, indicating it always aborts the current transaction.

LANGUAGE: typescript
CODE:
declare const retry: STM<never, never, never>

----------------------------------------

TITLE: Declaring Schema.TimeZoneOffset Class in TypeScript
DESCRIPTION: Defines the Schema.TimeZoneOffset class, which creates a schema for converting numbers to TimeZone.Offset instances. It utilizes the DateTime.zoneMakeOffset constructor for the conversion process.

LANGUAGE: typescript
CODE:
declare class TimeZoneOffset

----------------------------------------

TITLE: Defining zipWith Function Signature in TypeScript
DESCRIPTION: TypeScript type declaration for the zipWith function that combines two sinks. The function takes another sink, a combining function, and optional concurrent execution settings to produce a new sink that combines results from both input sinks.

LANGUAGE: typescript
CODE:
declare const zipWith: { <A2, In, In2 extends In, L2, E2, R2, A, A3>(that: Sink<A2, In2, L2, E2, R2>, f: (a: A, a2: A2) => A3, options?: { readonly concurrent?: boolean | undefined; } | undefined): <L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A3, In & In2, L2 | L, E2 | E, R2 | R>; <A, In, L, E, R, A2, In2 extends In, L2, E2, R2, A3>(self: Sink<A, In, L, E, R>, that: Sink<A2, In2, L2, E2, R2>, f: (a: A, a2: A2) => A3, options?: { readonly concurrent?: boolean | undefined; } | undefined): Sink<A3, In & In2, L | L2, E | E2, R | R2>; }

----------------------------------------

TITLE: Creating ScopedRef from Effect - TypeScript Implementation
DESCRIPTION: Function signature for creating a new ScopedRef from an effect that resourcefully produces a value. The function takes an acquire effect and returns a new effect that produces a scoped reference.

LANGUAGE: typescript
CODE:
declare const fromAcquire: <A, E, R>(acquire: Effect.Effect<A, E, R>) => Effect.Effect<ScopedRef<A>, E, Scope.Scope | R>

----------------------------------------

TITLE: Retrieving FiberRef Values in TypeScript using Effect
DESCRIPTION: The getFiberRefs function returns a collection of all FiberRef values for the fiber running this effect. It takes no parameters and returns an Effect that resolves to FiberRefs.FiberRefs with no error or environment dependencies.

LANGUAGE: typescript
CODE:
declare const getFiberRefs: Effect<FiberRefs.FiberRefs, never, never>

----------------------------------------

TITLE: Declaring ANSI EraseEndLine Operation in TypeScript
DESCRIPTION: Defines a constant eraseEndLine of type Ansi that provides functionality to clear text from the current cursor position to the end of the current line. The cursor position remains unchanged after the operation.

LANGUAGE: typescript
CODE:
declare const eraseEndLine: Ansi

----------------------------------------

TITLE: Implementing Boolean OR Operation in TypeScript using Effect Library
DESCRIPTION: This snippet demonstrates the usage of the 'or' function from the Effect library's Boolean module. It combines two boolean values using the OR operation. The function can be used in both curried and uncurried forms.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { or } from "effect/Boolean"

assert.deepStrictEqual(or(true, true), true)
assert.deepStrictEqual(or(true, false), true)
assert.deepStrictEqual(or(false, true), true)
assert.deepStrictEqual(or(false, false), false)

LANGUAGE: typescript
CODE:
declare const or: { (that: boolean): (self: boolean) => boolean; (self: boolean, that: boolean): boolean; }

----------------------------------------

TITLE: Testing TSet Emptiness in TypeScript
DESCRIPTION: The isEmpty function tests if a given TSet is empty. It returns an STM (Software Transactional Memory) operation that resolves to a boolean value indicating whether the set is empty or not.

LANGUAGE: typescript
CODE:
declare const isEmpty: <A>(self: TSet<A>) => STM.STM<boolean>

----------------------------------------

TITLE: Testing HTTP Methods in TypeScript using @effect/platform
DESCRIPTION: Demonstrates the usage of HttpMethod.isHttpMethod function to check if a value is a valid HTTP method. The function returns true for valid HTTP method strings (in uppercase) and false for invalid inputs.

LANGUAGE: typescript
CODE:
import { HttpMethod } from "@effect/platform"

console.log(HttpMethod.isHttpMethod("GET"))
// true
console.log(HttpMethod.isHttpMethod("get"))
// false
console.log(HttpMethod.isHttpMethod(1))
// false

----------------------------------------

TITLE: Implementing Environment Context Mapping in Effect STM
DESCRIPTION: Defines a function that transforms the environment context provided to an effect using a mapping function. Supports both curried and uncurried function signatures for flexibility in usage.

LANGUAGE: typescript
CODE:
declare const mapInputContext: { <R0, R>(f: (context: Context.Context<R0>) => Context.Context<R>): <A, E>(self: STM<A, E, R>) => STM<A, E, R0>; <A, E, R0, R>(self: STM<A, E, R>, f: (context: Context.Context<R0>) => Context.Context<R>): STM<A, E, R0>; }

----------------------------------------

TITLE: Effect.withTracerEnabled Function Signature in TypeScript
DESCRIPTION: This code snippet shows the TypeScript signature for the Effect.withTracerEnabled function. It can be used in two ways: either by passing the 'enabled' boolean as the first argument, or by passing the Effect as the first argument and the 'enabled' boolean as the second.

LANGUAGE: typescript
CODE:
declare const withTracerEnabled: { (enabled: boolean): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(effect: Effect<A, E, R>, enabled: boolean): Effect<A, E, R>; }

----------------------------------------

TITLE: Formatting DateTime.Zoned Objects in TypeScript
DESCRIPTION: Function signature for formatIsoZoned that converts DateTime.Zoned objects into ISO 8601 formatted strings with timezone information. The output format follows the pattern YYYY-MM-DDTHH:mm:ss.sss+HH:MM[Time/Zone].

LANGUAGE: typescript
CODE:
declare const formatIsoZoned: (self: Zoned) => string

----------------------------------------

TITLE: Configuring Description Addition in Effect Config Module
DESCRIPTION: Type definition for the withDescription function that adds a human-readable description to a configuration. The function supports both curried and uncurried calling styles.

LANGUAGE: typescript
CODE:
declare const withDescription: { (description: string): <A>(self: Config<A>) => Config<A>; <A>(self: Config<A>, description: string): Config<A>; }

----------------------------------------

TITLE: Defining isEnqueue Function in TypeScript for Effect Queue Module
DESCRIPTION: This code snippet defines the isEnqueue function, which checks if a given value is of type Enqueue. It takes an unknown parameter and returns a boolean indicating whether the value is an Enqueue of unknown type.

LANGUAGE: typescript
CODE:
declare const isEnqueue: (u: unknown) => u is Enqueue<unknown>

----------------------------------------

TITLE: Request.TaggedClass Type Signature
DESCRIPTION: Type signature for the TaggedClass constructor showing its generic type parameters and return type structure. It handles type checking for Success, Error, and additional properties.

LANGUAGE: typescript
CODE:
declare const TaggedClass: <Tag extends string>(tag: Tag) => new <Success, Error, A extends Record<string, any>>(args: Types.Equals<Omit<A, keyof Request<unknown, unknown>>, {}> extends true ? void : { readonly [P in keyof A as P extends "_tag" | keyof Request<unknown, unknown> ? never : P]: A[P]; }) => Request<Success, Error> & Readonly<A> & { readonly _tag: Tag; }

----------------------------------------

TITLE: Decoding Hex Strings to Uint8Array in TypeScript
DESCRIPTION: Function signature for decoding hexadecimal encoded strings into Uint8Array. Returns an Either type that handles successful decoding with Uint8Array or failed decoding with DecodeException.

LANGUAGE: typescript
CODE:
declare const decodeHex: (str: string) => Either.Either<Uint8Array, DecodeException>

----------------------------------------

TITLE: Creating Window Event Listener Stream in TypeScript
DESCRIPTION: Defines a function 'fromEventListenerWindow' that creates a Stream from window.addEventListener. It supports various event types and configuration options for the event listener.

LANGUAGE: typescript
CODE:
declare const fromEventListenerWindow: <K extends keyof WindowEventMap>(type: K, options?: boolean | { readonly capture?: boolean; readonly passive?: boolean; readonly once?: boolean; readonly bufferSize?: number | "unbounded" | undefined; } | undefined) => Stream.Stream<WindowEventMap[K], never, never>

----------------------------------------

TITLE: Implementing Error Ignore Function for Micro Effects in TypeScript
DESCRIPTION: Defines a function that takes a Micro effect and ignores any expected errors, transforming the result type to void and removing the error channel. This is useful for cases where error handling is not needed and the operation should proceed silently.

LANGUAGE: typescript
CODE:
declare const ignore: <A, E, R>(self: Micro<A, E, R>) => Micro<void, never, R>

----------------------------------------

TITLE: Checking for NoUpstream Type in TypeScript
DESCRIPTION: The isNoUpstream function is a type guard that determines if a given UpstreamPullRequest is of the NoUpstream type. It takes an UpstreamPullRequest<A> as input and returns a boolean indicating whether it's a NoUpstream instance.

LANGUAGE: typescript
CODE:
declare const isNoUpstream: <A>(self: UpstreamPullRequest<A>) => self is NoUpstream

----------------------------------------

TITLE: Implementing succeedSome Function in TypeScript
DESCRIPTION: Function signature for creating a Micro effect that succeeds with a value wrapped in Some option type. Takes a value of type A and returns a Micro effect containing an Option of type A.

LANGUAGE: typescript
CODE:
declare const succeedSome: <A>(a: A) => Micro<Option.Option<A>>

----------------------------------------

TITLE: Implementing Stream Timeout Switch in TypeScript
DESCRIPTION: Defines a function that switches from one stream to another if the original stream does not produce a value within a specified duration. The function is overloaded to support both curried and standard parameter ordering.

LANGUAGE: typescript
CODE:
declare const timeoutTo: { 
  <A2, E2, R2>(duration: Duration.DurationInput, that: Stream<A2, E2, R2>): 
    <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2 | E, R2 | R>; 
  <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, duration: Duration.DurationInput, that: Stream<A2, E2, R2>): 
    Stream<A | A2, E | E2, R | R2>; 
}

----------------------------------------

TITLE: Merging Success and Error Channels in Effect (TypeScript)
DESCRIPTION: Demonstrates how to use Effect.merge to combine both success and error channels of an effect into a single outcome. This is useful when you want to continue execution regardless of the error type and capture both successful results and errors as part of the outcome.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

//      ┌─── Effect<number, string, never>
//      ▼
const program = Effect.fail("Oh uh!").pipe(Effect.as(2))

//      ┌─── Effect<number | string, never, never>
//      ▼
const recovered = Effect.merge(program)

LANGUAGE: typescript
CODE:
declare const merge: <A, E, R>(self: Effect<A, E, R>) => Effect<E | A, never, R>

----------------------------------------

TITLE: Defining Differ Interface in TypeScript
DESCRIPTION: Defines the Differ interface, which provides methods for comparing, combining, and patching values. It includes type parameters for the value and patch types, and defines methods for diffing, combining, and patching.

LANGUAGE: typescript
CODE:
export interface Differ<in out Value, in out Patch> extends Pipeable {
  readonly [TypeId]: {
    readonly _V: Types.Invariant<Value>
    readonly _P: Types.Invariant<Patch>
  }
  readonly empty: Patch
  diff(oldValue: Value, newValue: Value): Patch
  combine(first: Patch, second: Patch): Patch
  patch(patch: Patch, oldValue: Value): Value
}

----------------------------------------

TITLE: Retrieving TPubSub Size in TypeScript
DESCRIPTION: This function retrieves the size of a TPubSub instance, which represents the number of elements in the TPubSub. The size can be negative if fibers are suspended waiting for elements to be added. It returns an STM (Software Transactional Memory) effect that resolves to a number.

LANGUAGE: TypeScript
CODE:
declare const size: <A>(self: TPubSub<A>) => STM.STM<number>

----------------------------------------

TITLE: Defining Layer Context Constructor in TypeScript
DESCRIPTION: Defines a Layer.context function that creates a Layer instance which passes the specified context R as output. The Layer never produces an error (never type) and returns the context type R.

LANGUAGE: typescript
CODE:
declare const context: <R>() => Layer<R, never, R>

----------------------------------------

TITLE: Retrieving All Values from TPriorityQueue in TypeScript
DESCRIPTION: The takeAll function is used to extract all values from a TPriorityQueue. It returns an STM (Software Transactional Memory) operation that, when executed, will yield an array containing all the elements from the queue.

LANGUAGE: typescript
CODE:
declare const takeAll: <A>(self: TPriorityQueue<A>) => STM.STM<Array<A>>

----------------------------------------

TITLE: TypeScript Signature of Match.either Function
DESCRIPTION: Provides the TypeScript signature for the Match.either function, showing its generic type parameters and return type. This signature helps developers understand the function's type constraints and usage in TypeScript projects.

LANGUAGE: typescript
CODE:
declare const either: <I, F, R, A, Pr, Ret>(self: Matcher<I, F, R, A, Pr, Ret>) => [Pr] extends [never] ? (input: I) => Either.Either<Unify<A>, R> : Either.Either<Unify<A>, R>

----------------------------------------

TITLE: Defining Drain Sink in TypeScript
DESCRIPTION: Declares a constant 'drain' as a Sink that ignores its inputs. It takes void as input and never produces any output or error.

LANGUAGE: typescript
CODE:
declare const drain: Sink<void, unknown, never, never, never>

----------------------------------------

TITLE: Checking TPubSub Empty State in TypeScript
DESCRIPTION: Function that checks if a TPubSub instance contains zero elements. Returns an STM computation that resolves to a boolean value indicating whether the TPubSub is empty.

LANGUAGE: typescript
CODE:
declare const isEmpty: <A>(self: TPubSub<A>) => STM.STM<boolean>

----------------------------------------

TITLE: Modifying HashMap Values with Update Function in TypeScript
DESCRIPTION: Function signature for modifyAt operation that allows setting or removing a key in a HashMap using an update function. The function can be used in both curried and uncurried forms, taking a key and an update function that receives the current value (or None if key doesn't exist).

LANGUAGE: typescript
CODE:
declare const modifyAt: { <K, V>(key: K, f: HashMap.UpdateFn<V>): (self: HashMap<K, V>) => HashMap<K, V>; <K, V>(self: HashMap<K, V>, key: K, f: HashMap.UpdateFn<V>): HashMap<K, V>; }

----------------------------------------

TITLE: Creating Mutable Schema in TypeScript
DESCRIPTION: The 'mutable' function creates a new schema with shallow mutability applied to its properties. It takes a schema of any type as input and returns a mutable version of that schema.

LANGUAGE: typescript
CODE:
declare const mutable: <S extends Schema.Any>(schema: S) => mutable<S>

----------------------------------------

TITLE: Creating LazyArbitrary from Schema in TypeScript
DESCRIPTION: The makeLazy function returns a LazyArbitrary for the A type of the provided schema. It takes a Schema object as input and produces a LazyArbitrary<A> as output.

LANGUAGE: typescript
CODE:
declare const makeLazy: <A, I, R>(schema: Schema.Schema<A, I, R>) => LazyArbitrary<A>

----------------------------------------

TITLE: Defining Channel.unwrapScoped Function in TypeScript
DESCRIPTION: Declares the unwrapScoped function that constructs a Channel from a scoped effect. The function takes an Effect that results in a Channel if successful and returns a new Channel with combined type parameters.

LANGUAGE: typescript
CODE:
declare const unwrapScoped: <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, E, R>(self: Effect.Effect<Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, E, R>) => Channel<OutElem, InElem, E | OutErr, InErr, OutDone, InDone, Env | Exclude<R, Scope.Scope>>

----------------------------------------

TITLE: Applying FiberRefsPatch in TypeScript
DESCRIPTION: The 'patch' function applies changes described by a FiberRefsPatch to a collection of FiberRef values. It takes a FiberId, the old FiberRefs value, and returns a function that applies the patch to create new FiberRefs.

LANGUAGE: typescript
CODE:
declare const patch: { (fiberId: FiberId.Runtime, oldValue: FiberRefs.FiberRefs): (self: FiberRefsPatch) => FiberRefs.FiberRefs; (self: FiberRefsPatch, fiberId: FiberId.Runtime, oldValue: FiberRefs.FiberRefs): FiberRefs.FiberRefs; }

----------------------------------------

TITLE: Implementing Optional Error Handling in STM - TypeScript
DESCRIPTION: Function signature for orElseOptional that returns an effect which produces the value of the original effect unless it fails with None, in which case it produces the value of the specified alternative effect. The function supports generic types for values, errors, and environment requirements.

LANGUAGE: typescript
CODE:
declare const orElseOptional: { <A2, E2, R2>(that: LazyArg<STM<A2, Option.Option<E2>, R2>>): <A, E, R>(self: STM<A, Option.Option<E>, R>) => STM<A2 | A, Option.Option<E2 | E>, R2 | R>; <A, E, R, A2, E2, R2>(self: STM<A, Option.Option<E>, R>, that: LazyArg<STM<A2, Option.Option<E2>, R2>>): STM<A | A2, Option.Option<E | E2>, R | R2>; }

----------------------------------------

TITLE: Implementing Dynamic Page Width Layout in TypeScript with Effect Printer
DESCRIPTION: Demonstrates how to use Doc.pageWidth to create a document that responds to different page width settings. The example shows how to format text differently based on available line width and ribbon fraction parameters.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import * as String from "effect/String"

const doc = Doc.hsep([
  Doc.text("prefix"),
  Doc.pageWidth((pageWidth) => {
    switch (pageWidth._tag) {
      case "AvailablePerLine": {
        const { lineWidth, ribbonFraction } = pageWidth
        return Doc.squareBracketed(
          Doc.text(`Width: ${lineWidth}, Ribbon Fraction: ${ribbonFraction}`)
        )
      }
      case "Unbounded": {
        return Doc.empty
      }
    }
  })
])

const example = Doc.vsep([0, 4, 8].map((n) => Doc.indent(n)(doc)))

assert.strictEqual(
  Doc.render(example, {
    style: "pretty",
    options: { lineWidth: 32 }
  }),
  String.stripMargin(
    `|prefix [Width: 32, Ribbon Fraction: 1]
     |    prefix [Width: 32, Ribbon Fraction: 1]
     |        prefix [Width: 32, Ribbon Fraction: 1]`
  )
)

LANGUAGE: typescript
CODE:
declare const pageWidth: <A>(react: (pageWidth: PageWidth) => Doc<A>) => Doc<A>

----------------------------------------

TITLE: Declaring isShutdown Function in PubSub Module (TypeScript)
DESCRIPTION: Declares the isShutdown function, which returns a boolean Effect indicating whether the PubSub instance has been shut down. It takes a PubSub<A> as input and returns an Effect<boolean>.

LANGUAGE: typescript
CODE:
declare const isShutdown: <A>(self: PubSub<A>) => Effect.Effect<boolean>

----------------------------------------

TITLE: Formatting BigDecimal Values to Strings in TypeScript
DESCRIPTION: Demonstrates how to format BigDecimal values into strings using the format function. Handles negative numbers, decimal places, and automatically uses scientific notation for numbers with scale >= 16.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { format, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(format(unsafeFromString("-5")), "-5")
assert.deepStrictEqual(format(unsafeFromString("123.456")), "123.456")
assert.deepStrictEqual(format(unsafeFromString("-0.00000123")), "-0.00000123")

LANGUAGE: typescript
CODE:
declare const format: (n: BigDecimal) => string

----------------------------------------

TITLE: Using Doc.surround in TypeScript with @effect/printer
DESCRIPTION: Demonstrates how to use the Doc.surround function to enclose a document between left and right documents. The example creates a document with a hyphen surrounded by 'A' and 'Z' characters.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import { pipe } from "effect/Function"

const doc = pipe(
  Doc.char("-"),
  Doc.surround(Doc.char("A"), Doc.char("Z"))
)

assert.strictEqual(
  Doc.render(doc, { style: "pretty" }),
  "A-Z"
)

----------------------------------------

TITLE: TypeScript Function Signature for Stream.fromAsyncIterable
DESCRIPTION: Provides the TypeScript function signature for the Stream.fromAsyncIterable function. It takes an AsyncIterable and an error handling function as parameters, and returns a Stream.

LANGUAGE: typescript
CODE:
declare const fromAsyncIterable: <A, E>(iterable: AsyncIterable<A>, onError: (e: unknown) => E) => Stream<A, E>

----------------------------------------

TITLE: Defining provideContext Function for Stream Module in TypeScript
DESCRIPTION: This code snippet defines the provideContext function for the Stream module. It allows providing a stream with its required context, eliminating its dependency on R. The function has two overloads to support different usage patterns.

LANGUAGE: typescript
CODE:
declare const provideContext: { <R>(context: Context.Context<R>): <A, E>(self: Stream<A, E, R>) => Stream<A, E>; <A, E, R>(self: Stream<A, E, R>, context: Context.Context<R>): Stream<A, E>; }

----------------------------------------

TITLE: Using Array.replaceOption in TypeScript Effect Library
DESCRIPTION: Demonstrates how to use the replaceOption function to safely replace an element at a specific index in an array. Returns Some with the modified array if the index is valid, or None if the index is out of bounds.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const result = Array.replaceOption([1, 2, 3], 1, 4)
console.log(result) // Option.some([1, 4, 3])

LANGUAGE: typescript
CODE:
declare const replaceOption: { <B>(i: number, b: B): <A, S extends Iterable<A> = Iterable<A>>(self: S) => Option.Option<ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>>; <A, B, S extends Iterable<A> = Iterable<A>>(self: S, i: number, b: B): Option.Option<ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>>; }

----------------------------------------

TITLE: Creating Bounded TPubSub with Dropping Strategy in TypeScript
DESCRIPTION: The dropping function creates a bounded TPubSub that drops new messages when at capacity. It takes a requestedCapacity parameter and returns an STM effect that produces a TPubSub of type A.

LANGUAGE: typescript
CODE:
declare const dropping: <A>(requestedCapacity: number) => STM.STM<TPubSub<A>>

----------------------------------------

TITLE: Creating FiberSet-backed Effect Runtime in TypeScript
DESCRIPTION: The makeRuntime function creates an Effect run function that is backed by a FiberSet. It returns an Effect that, when executed, provides a function to run and fork effects into fibers managed by the FiberSet.

LANGUAGE: typescript
CODE:
declare const makeRuntime: <R = never, A = unknown, E = unknown>() => Effect.Effect<(<XE extends E, XA extends A>(effect: Effect.Effect<XA, XE, R>, options?: Runtime.RunForkOptions | undefined) => Fiber.RuntimeFiber<XA, XE>), never, Scope.Scope | R>

----------------------------------------

TITLE: Checking WindDown RuntimeFlag Status in TypeScript
DESCRIPTION: Function that checks if the WindDown RuntimeFlag is enabled for a given RuntimeFlags instance. Returns a boolean indicating the flag status.

LANGUAGE: typescript
CODE:
declare const windDown: (self: RuntimeFlags) => boolean

----------------------------------------

TITLE: Defining runIntoPubSubScoped Function in TypeScript
DESCRIPTION: Declares the runIntoPubSubScoped function, which is similar to Stream.runIntoPubSub but provides the result as a scoped effect for scope composition. It takes a PubSub of Take<A, E> and returns an Effect that runs the stream into the PubSub.

LANGUAGE: typescript
CODE:
declare const runIntoPubSubScoped: { <A, E>(pubsub: PubSub.PubSub<Take.Take<A, E>>): <R>(self: Stream<A, E, R>) => Effect.Effect<void, never, Scope.Scope | R>; <A, E, R>(self: Stream<A, E, R>, pubsub: PubSub.PubSub<Take.Take<A, E>>): Effect.Effect<void, never, Scope.Scope | R>; }

----------------------------------------

TITLE: Implementing Cause Contains Check in TypeScript
DESCRIPTION: Function signature for checking if one Cause contains or equals another Cause. Takes two Cause parameters and returns a boolean indicating if one contains the other. Useful for error pattern matching and failure deduplication.

LANGUAGE: typescript
CODE:
declare const contains: { <E2>(that: Cause<E2>): <E>(self: Cause<E>) => boolean; <E, E2>(self: Cause<E>, that: Cause<E2>): boolean; }

----------------------------------------

TITLE: Implementing eraseEndLine ANSI Terminal Control in TypeScript
DESCRIPTION: Defines the eraseEndLine constant of type AnsiDoc that clears text from the current cursor position to the end of the current line in ANSI terminals. The cursor position remains unchanged after the operation.

LANGUAGE: typescript
CODE:
declare const eraseEndLine: AnsiDoc

----------------------------------------

TITLE: Using SemigroupMax in TypeScript
DESCRIPTION: Demonstrates how to use the SemigroupMax from the @effect/typeclass package to find the maximum of two numbers. The SemigroupMax.combine method is used to compare and return the larger of two numeric values.

LANGUAGE: typescript
CODE:
import { SemigroupMax } from "@effect/typeclass/data/Number"

console.log(SemigroupMax.combine(2, 3))
// 3

----------------------------------------

TITLE: Checking for LineTree in DocTree Module (TypeScript)
DESCRIPTION: The isLineTree function is a type predicate that determines if a given DocTree<A> is specifically a LineTree<A>. It returns true for LineTree instances and false for other DocTree types.

LANGUAGE: typescript
CODE:
declare const isLineTree: <A>(self: DocTree<A>) => self is LineTree<A>

----------------------------------------

TITLE: Creating Failing Take with Error Message in TypeScript
DESCRIPTION: Function signature for dieMessage that creates a failing Take instance with a specified error message. Takes a string message parameter and returns a Take that can never succeed.

LANGUAGE: typescript
CODE:
declare const dieMessage: (message: string) => Take<never>

----------------------------------------

TITLE: Checking Lock Status in TReentrantLock (TypeScript)
DESCRIPTION: The locked function determines if any fiber has a read or write lock on a TReentrantLock instance. It returns an STM (Software Transactional Memory) effect that resolves to a boolean value.

LANGUAGE: typescript
CODE:
declare const locked: (self: TReentrantLock) => STM.STM<boolean>

----------------------------------------

TITLE: Declaring yieldFlush Function in TypeScript
DESCRIPTION: Defines the yieldFlush function which flushes any yielded effects waiting to be executed. It returns a Micro type with void result, and never for both error and environment types.

LANGUAGE: typescript
CODE:
declare const yieldFlush: Micro<void, never, never>

----------------------------------------

TITLE: TypeScript Signature for Array.union Function in Effect Library
DESCRIPTION: Provides the TypeScript type signature for the Array.union function in the Effect library. The signature shows various overloads for different input types, including Iterable, ReadonlyArray, and NonEmptyReadonlyArray, with corresponding return types.

LANGUAGE: typescript
CODE:
declare const union: { <T extends Iterable<any>>(that: T): <S extends Iterable<any>>(self: S) => ReadonlyArray.OrNonEmpty<S, T, ReadonlyArray.Infer<S> | ReadonlyArray.Infer<T>>; <A, B>(self: NonEmptyReadonlyArray<A>, that: ReadonlyArray<B>): NonEmptyArray<A | B>; <A, B>(self: ReadonlyArray<A>, that: NonEmptyReadonlyArray<B>): NonEmptyArray<A | B>; <A, B>(self: Iterable<A>, that: Iterable<B>): Array<A | B>; }

----------------------------------------

TITLE: Implementing List.unsafeHead in TypeScript
DESCRIPTION: A function that unsafely retrieves the first element from a List data structure. This operation is unsafe as it does not handle the case of an empty list and may throw an error if the list is empty.

LANGUAGE: typescript
CODE:
declare const unsafeHead: <A>(self: List<A>) => A

----------------------------------------

TITLE: Declaring ANSI Screen Erase Function - TypeScript
DESCRIPTION: Defines a constant eraseScreen of type AnsiDoc that clears the entire terminal screen and repositions the cursor to the top-left position (0,0). This is part of the @effect/printer-ansi package's terminal control functionality.

LANGUAGE: typescript
CODE:
declare const eraseScreen: AnsiDoc

----------------------------------------

TITLE: Declaring publishAll Function for PubSub in TypeScript
DESCRIPTION: Defines the publishAll function for the PubSub module. It publishes all specified messages to the PubSub and returns an Effect indicating whether the messages were successfully published. The function supports both curried and non-curried versions.

LANGUAGE: typescript
CODE:
declare const publishAll: { <A>(elements: Iterable<A>): (self: PubSub<A>) => Effect.Effect<boolean>; <A>(self: PubSub<A>, elements: Iterable<A>): Effect.Effect<boolean>; }

----------------------------------------

TITLE: Type Signature for Array.reduce in Effect Library
DESCRIPTION: Provides the TypeScript type signature for the Array.reduce function in the Effect library. It shows two overloads: one for passing the initial value and reducer function separately, and another for passing the array along with the initial value and reducer function.

LANGUAGE: typescript
CODE:
declare const reduce: { <B, A>(b: B, f: (b: B, a: A, i: number) => B): (self: Iterable<A>) => B; <A, B>(self: Iterable<A>, b: B, f: (b: B, a: A, i: number) => B): B; }

----------------------------------------

TITLE: Defining Symbol Matching Predicate in TypeScript
DESCRIPTION: Declares a constant 'symbol' as a refinement predicate that matches values of type 'symbol'. This predicate can be used to narrow down unknown types to symbol types in a type-safe manner.

LANGUAGE: typescript
CODE:
declare const symbol: Predicate.Refinement<unknown, symbol>

----------------------------------------

TITLE: Transforming ConfigProvider with Path in TypeScript
DESCRIPTION: Function signature for ConfigProvider.within which returns a new config provider that transforms the original provider using a specified function within a given path. It supports both curried and non-curried versions of the function.

LANGUAGE: typescript
CODE:
declare const within: { 
  (path: ReadonlyArray<string>, f: (self: ConfigProvider) => ConfigProvider): (self: ConfigProvider) => ConfigProvider; 
  (self: ConfigProvider, path: ReadonlyArray<string>, f: (self: ConfigProvider) => ConfigProvider): ConfigProvider; 
}

----------------------------------------

TITLE: Using Tuple.at in TypeScript
DESCRIPTION: Demonstrates how to use the Tuple.at function to retrieve an element at a specific index from a tuple. The example shows accessing the second element (index 1) from a 3-element tuple.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Tuple } from "effect"

assert.deepStrictEqual(Tuple.at([1, 'hello', true], 1), 'hello')

----------------------------------------

TITLE: Mapping Input Effects in Channels - TypeScript
DESCRIPTION: Defines a function that transforms a channel by applying an effectual function to the input channel's done value. The function supports both curried and uncurried forms, allowing for flexible composition of channel transformations.

LANGUAGE: typescript
CODE:
declare const mapInputEffect: {
  <InDone0, InDone, InErr, Env1>(
    f: (i: InDone0) => Effect.Effect<InDone, InErr, Env1>
  ): <OutElem, InElem, OutErr, OutDone, Env>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>
  ) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone0, Env1 | Env>;
  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InDone0, Env1>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,
    f: (i: InDone0) => Effect.Effect<InDone, InErr, Env1>
  ): Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone0, Env | Env1>;
}

----------------------------------------

TITLE: Defining DataFromSelf Schema Type in TypeScript
DESCRIPTION: Type definition for Schema.DataFromSelf that enforces constraints where Type and Encoded must extend Readonly<Record<string, any>> or ReadonlyArray<any>. This allows for self-referential schema definitions with proper type safety.

LANGUAGE: typescript
CODE:
declare const DataFromSelf: <S extends Schema.Any, A extends Readonly<Record<string, unknown>> | ReadonlyArray<unknown>, I extends Readonly<Record<string, unknown>> | ReadonlyArray<unknown>>(value: S & Schema<A & Schema.Type<S>, I & Schema.Encoded<S>, Schema.Context<S>>) => DataFromSelf<S>

----------------------------------------

TITLE: Declaring DateTimeUpdateFromNumber Field Type in TypeScript
DESCRIPTION: Defines a field type that automatically updates to the current UTC DateTime on database inserts and updates. The field is serialized as a number in the database while maintaining DateTime semantics in the application.

LANGUAGE: typescript
CODE:
declare const DateTimeUpdateFromNumber: DateTimeUpdateFromNumber

----------------------------------------

TITLE: Implementing STM.zipLeft Function in TypeScript
DESCRIPTION: Defines a function that sequentially combines two STM values, keeping only the first element. The function handles effect composition with proper type handling for errors (E, E1) and environment requirements (R, R1).

LANGUAGE: typescript
CODE:
declare const zipLeft: { 
  <A1, E1, R1>(that: STM<A1, E1, R1>): <A, E, R>(self: STM<A, E, R>) => STM<A, E1 | E, R1 | R>; 
  <A, E, R, A1, E1, R1>(self: STM<A, E, R>, that: STM<A1, E1, R1>): STM<A, E | E1, R | R1>; 
}

----------------------------------------

TITLE: Enabling RuntimeFlags in Effect TypeScript
DESCRIPTION: Function signature for enabling a specific RuntimeFlag. The function supports both curried and uncurried forms for enabling flags on RuntimeFlags instances.

LANGUAGE: typescript
CODE:
declare const enable: { (flag: RuntimeFlag): (self: RuntimeFlags) => RuntimeFlags; (self: RuntimeFlags, flag: RuntimeFlag): RuntimeFlags; }

----------------------------------------

TITLE: Defining haltWhen Function for Stream Halting in TypeScript
DESCRIPTION: Declares the haltWhen function, which halts the evaluation of a stream when a provided effect completes. The function forks the given effect and discards its success. If the effect fails, the stream emits that failure. It does not interrupt elements in the process of being pulled.

LANGUAGE: typescript
CODE:
declare const haltWhen: { <X, E2, R2>(effect: Effect.Effect<X, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, X, E2, R2>(self: Stream<A, E, R>, effect: Effect.Effect<X, E2, R2>): Stream<A, E | E2, R | R2>; }

----------------------------------------

TITLE: Retrieving TArray Size in TypeScript
DESCRIPTION: The size function returns the number of elements in a TArray. It takes a TArray<A> as input and returns a number. This function has been available since version 2.0.0 of the effect package.

LANGUAGE: typescript
CODE:
declare const size: <A>(self: TArray<A>) => number

----------------------------------------

TITLE: Converting Iterables to Arrays using Array.fromIterable in TypeScript
DESCRIPTION: Creates a new Array from an iterable collection of values. Returns the input unchanged if it's already an array, otherwise converts the iterable to an array. Useful for standardizing iterable data structures into arrays.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const result = Array.fromIterable(new Set([1, 2, 3]))
console.log(result) // [1, 2, 3]

LANGUAGE: typescript
CODE:
declare const fromIterable: <A>(collection: Iterable<A>) => Array<A>

----------------------------------------

TITLE: Executing Effects as Promises in TypeScript
DESCRIPTION: The `runPromise` function runs an Effect and returns a JavaScript Promise. It resolves with the effect's value upon successful execution or rejects with the first error or exception thrown. This function is effectful and should be used only at the edges of a program.

LANGUAGE: typescript
CODE:
declare const runPromise: { <R>(runtime: Runtime<R>): <A, E>(effect: Effect.Effect<A, E, R>, options?: { readonly signal?: AbortSignal; } | undefined) => Promise<A>; <R, A, E>(runtime: Runtime<R>, effect: Effect.Effect<A, E, R>, options?: { readonly signal?: AbortSignal; } | undefined): Promise<A>; }

----------------------------------------

TITLE: Executing Effects as Promises in TypeScript
DESCRIPTION: The `runPromise` function runs an Effect and returns a JavaScript Promise. It resolves with the effect's value upon successful execution or rejects with the first error or exception thrown. This function is effectful and should be used only at the edges of a program.

LANGUAGE: typescript
CODE:
declare const runPromise: { <R>(runtime: Runtime<R>): <A, E>(effect: Effect.Effect<A, E, R>, options?: { readonly signal?: AbortSignal; } | undefined) => Promise<A>; <R, A, E>(runtime: Runtime<R>, effect: Effect.Effect<A, E, R>, options?: { readonly signal?: AbortSignal; } | undefined): Promise<A>; }

----------------------------------------

TITLE: Declaring Effect.withMetric Function Signature in TypeScript
DESCRIPTION: TypeScript type declaration for the withMetric function that associates a metric with an effect. The function supports both curried and uncurried forms, allowing metrics to be tracked as effects progress.

LANGUAGE: typescript
CODE:
declare const withMetric: { <Type, In, Out>(metric: Metric.Metric<Type, In, Out>): <A extends In, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A extends In, E, R, Type, In, Out>(self: Effect<A, E, R>, metric: Metric.Metric<Type, In, Out>): Effect<A, E, R>; }

----------------------------------------

TITLE: Record.modify Type Signature in TypeScript
DESCRIPTION: Type signature for the Record.modify function showing its polymorphic nature and support for both curried and uncurried forms. Handles generic types for keys, input values, and transformed values.

LANGUAGE: typescript
CODE:
declare const modify: { <K extends string | symbol, A, B>(key: NoInfer<K>, f: (a: A) => B): (self: ReadonlyRecord<K, A>) => Record<K, A | B>; <K extends string | symbol, A, B>(self: ReadonlyRecord<K, A>, key: NoInfer<K>, f: (a: A) => B): Record<K, A | B>; }

----------------------------------------

TITLE: Order.tuple TypeScript Implementation Signature
DESCRIPTION: The complete TypeScript type signature for the Order.tuple function, showing how it handles variadic Order arguments and constructs a typed tuple result

LANGUAGE: typescript
CODE:
declare const tuple: <T extends ReadonlyArray<Order<any>>>(...elements: T) => Order<Readonly<{ [I in keyof T]: [T[I]] extends [Order<infer A>] ? A : never; }>>

----------------------------------------

TITLE: Executing Workflow with Lock in TypeScript using Effect
DESCRIPTION: The withLock function runs a specified effect with a reentrant lock. It takes a TReentrantLock instance and an Effect, and returns a new Effect that executes with the lock acquired. This function can be used to ensure thread-safe execution of critical sections in concurrent environments.

LANGUAGE: typescript
CODE:
declare const withLock: { (self: TReentrantLock): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; <A, E, R>(effect: Effect.Effect<A, E, R>, self: TReentrantLock): Effect.Effect<A, E, R>; }

----------------------------------------

TITLE: Constructing MemoMap for Layer Building in TypeScript
DESCRIPTION: The makeMemoMap function creates a MemoMap that can be used to build additional layers. It returns an Effect that produces a MemoMap without any requirements or errors.

LANGUAGE: typescript
CODE:
declare const makeMemoMap: Effect.Effect<MemoMap, never, never>

----------------------------------------

TITLE: Creating MutableHashMap from Iterable in TypeScript
DESCRIPTION: The fromIterable function creates a new MutableHashMap from an iterable collection of key/value pairs. It takes an Iterable of readonly tuples containing keys and values, and returns a MutableHashMap with the corresponding key-value mappings.

LANGUAGE: typescript
CODE:
declare const fromIterable: <K, V>(entries: Iterable<readonly [K, V]>) => MutableHashMap<K, V>

----------------------------------------

TITLE: Creating Stream from Document Event Listener in TypeScript
DESCRIPTION: The fromEventListenerDocument function creates a Stream from document.addEventListener. It takes an event type and optional options as parameters, and returns a Stream of the corresponding event type.

LANGUAGE: typescript
CODE:
declare const fromEventListenerDocument: <K extends keyof DocumentEventMap>(type: K, options?: boolean | { readonly capture?: boolean; readonly passive?: boolean; readonly once?: boolean; readonly bufferSize?: number | "unbounded" | undefined; } | undefined) => Stream.Stream<DocumentEventMap[K], never, never>

----------------------------------------

TITLE: Using BigInt.clamp in TypeScript
DESCRIPTION: Demonstrates how to use the BigInt.clamp function to restrict a bigint value within a specified range. It shows examples of clamping values within, below, and above the range.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { BigInt } from "effect"

const clamp = BigInt.clamp({ minimum: 1n, maximum: 5n })

assert.equal(clamp(3n), 3n)
assert.equal(clamp(0n), 1n)
assert.equal(clamp(6n), 5n)

----------------------------------------

TITLE: Defining Schema.Schema.All Type in TypeScript
DESCRIPTION: Defines a union type that encompasses all possible schema types in the Effect library. This includes Any schema and various Schema combinations with never types. Used as a base type for schema operations.

LANGUAGE: typescript
CODE:
type All = | Any
    | Schema<any, never, unknown>
    | Schema<never, any, unknown>
    | Schema<never, never, unknown>

----------------------------------------

TITLE: Defining filterOrElse Function in HttpClient Module (TypeScript)
DESCRIPTION: Declares the filterOrElse function, which filters the result of a response or runs an alternative effect if the predicate fails. It provides two overloads for different usage patterns.

LANGUAGE: typescript
CODE:
declare const filterOrElse: { <E2, R2>(predicate: Predicate.Predicate<ClientResponse.HttpClientResponse>, orElse: (response: ClientResponse.HttpClientResponse) => Effect.Effect<ClientResponse.HttpClientResponse, E2, R2>): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E2 | E, R2 | R>; <E, R, E2, R2>(self: HttpClient.With<E, R>, predicate: Predicate.Predicate<ClientResponse.HttpClientResponse>, orElse: (response: ClientResponse.HttpClientResponse) => Effect.Effect<ClientResponse.HttpClientResponse, E2, R2>): HttpClient.With<E2 | E, R2 | R>; }

----------------------------------------

TITLE: Checking Parallel Type in Effect Cause Module
DESCRIPTION: Function that determines if a given Cause instance is of Parallel type. It performs type checking and returns a boolean with type narrowing support via type predicate.

LANGUAGE: typescript
CODE:
declare const isParallelType: <E>(self: Cause<E>) => self is Parallel<E>

----------------------------------------

TITLE: Checking Read Lock Status in TReentrantLock - TypeScript
DESCRIPTION: Function signature for determining if any fiber currently holds a read lock on a TReentrantLock instance. Returns an STM transaction that resolves to a boolean indicating the lock status.

LANGUAGE: typescript
CODE:
declare const readLocked: (self: TReentrantLock) => STM.STM<boolean>

----------------------------------------

TITLE: Defining Schedule.as Type Signature in TypeScript
DESCRIPTION: Type declaration for the Schedule.as function that transforms a schedule to always return a constant output value. The function supports both curried and uncurried calling styles for flexibility in usage.

LANGUAGE: typescript
CODE:
declare const as: { 
  <Out2>(out: Out2): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out2, In, R>; 
  <Out, In, R, Out2>(self: Schedule<Out, In, R>, out: Out2): Schedule<Out2, In, R>; 
}

----------------------------------------

TITLE: Demonstrating Compact Layout Algorithm in TypeScript
DESCRIPTION: This example compares the output of the 'pretty' and 'compact' rendering styles using the Layout.compact function. It shows how the compact style removes indentation while preserving line breaks.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import { pipe } from "effect/Function"
import * as String from "effect/String"

const doc = pipe(
  Doc.vsep([
    Doc.text("lorem"),
    Doc.text("ipsum"),
    pipe(
      Doc.vsep([Doc.text("dolor"), Doc.text("sit")]),
      Doc.hang(4)
    )
  ]),
  Doc.hang(4)
)

assert.strictEqual(
  Doc.render(doc, { style: "pretty" }),
  String.stripMargin(
    `|lorem
     |    ipsum
     |    dolor
     |        sit`
  )
)

assert.strictEqual(
  Doc.render(doc, { style: "compact" }),
  String.stripMargin(
    `|lorem
     |ipsum
     |dolor
     |sit`
  )
)

----------------------------------------

TITLE: Defining Doc.Union Interface in TypeScript
DESCRIPTION: This code snippet defines the Union interface extending Doc.Variance<A>. It specifies the structure for representing the union of two documents, including a tag and references to left and right Doc<A> instances.

LANGUAGE: typescript
CODE:
export interface Union<A> extends Doc.Variance<A> {
  readonly _tag: "Union"
  readonly left: Doc<A>
  readonly right: Doc<A>
}

----------------------------------------

TITLE: Defining BooleanFromString Class in TypeScript
DESCRIPTION: Declares a class named BooleanFromString that converts string values "true" and "false" to their corresponding boolean values. This class is part of the Schema module in the effect package.

LANGUAGE: typescript
CODE:
declare class BooleanFromString

----------------------------------------

TITLE: Implementing Intersperse Function for Iterables in TypeScript
DESCRIPTION: This function, intersperse, takes an element and places it between each member of an Iterable. If the input is a non-empty array, the result is also guaranteed to be a non-empty array. It supports both curried and non-curried usage.

LANGUAGE: typescript
CODE:
declare const intersperse: { <B>(middle: B): <A>(self: Iterable<A>) => Iterable<A | B>; <A, B>(self: Iterable<A>, middle: B): Iterable<A | B>; }

----------------------------------------

TITLE: Implementing Die Cause Creation in TypeScript
DESCRIPTION: Function signature for creating a Die cause from an unexpected error. Takes an unknown defect parameter and returns a Cause that never resolves to a value. Used for handling unforeseen runtime issues in a structured way.

LANGUAGE: typescript
CODE:
declare const die: (defect: unknown) => Cause<never>

----------------------------------------

TITLE: Defining RuntimeFlags Differ in TypeScript
DESCRIPTION: Constructs a differ that knows how to diff RuntimeFlags values. It uses the Differ type from the Differ module and operates on RuntimeFlags and RuntimeFlagsPatch types.

LANGUAGE: typescript
CODE:
declare const differ: Differ.Differ<RuntimeFlags, RuntimeFlagsPatch.RuntimeFlagsPatch>

----------------------------------------

TITLE: Changing Last Element of Non-Empty Array in TypeScript
DESCRIPTION: The `setNonEmptyLast` function creates a new `NonEmptyReadonlyArray` by changing the last element of the input array. It takes a non-empty array and a new value as parameters, returning a new array with the last element replaced.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const result = Array.setNonEmptyLast([1, 2, 3], 4)
console.log(result) // [1, 2, 4]

LANGUAGE: typescript
CODE:
declare const setNonEmptyLast: { <B>(b: B): <A>(self: NonEmptyReadonlyArray<A>) => NonEmptyArray<A | B>; <A, B>(self: NonEmptyReadonlyArray<A>, b: B): NonEmptyArray<A | B>; }

----------------------------------------

TITLE: Using FiberSet.runtime to Fork Effects in TypeScript
DESCRIPTION: This example demonstrates how to use FiberSet.runtime to create a fiber set, capture a runtime, and use it to fork effects. It includes defining a Users context, creating a fiber set, and running effects that are added to the set.

LANGUAGE: typescript
CODE:
import { Context, Effect, FiberSet } from "effect"

interface Users {
  readonly _: unique symbol
}
const Users = Context.GenericTag<Users, {
   getAll: Effect.Effect<Array<unknown>>
}>("Users")

Effect.gen(function*() {
  const set = yield* FiberSet.make()
  const run = yield* FiberSet.runtime(set)<Users>()

  // run some effects and add the fibers to the set
  run(Effect.andThen(Users, _ => _.getAll))
}).pipe(
  Effect.scoped // The fibers will be interrupted when the scope is closed
)

----------------------------------------

TITLE: Updating URL Password in TypeScript using @effect/platform
DESCRIPTION: The setPassword function updates the password used for authentication in a URL. It can be called with either a password and a URL, or just a password to create a function that can be applied to a URL later.

LANGUAGE: typescript
CODE:
declare const setPassword: { (password: string): (url: URL) => URL; (url: URL, password: string): URL; }

----------------------------------------

TITLE: Implementing HashSet Intersection in TypeScript
DESCRIPTION: Demonstrates different ways to compute set intersection using HashSet in the Effect library. The operation returns elements present in both sets with O(n) complexity. Requires matching hash and equality implementations for elements.

LANGUAGE: typescript
CODE:
// Syntax
import { HashSet, pipe } from "effect"

// with data-last, a.k.a. pipeable API
pipe(HashSet.make(1, 2, 3), HashSet.intersection(HashSet.make(2, 3, 4)))

// or piped with the pipe function
HashSet.make(1, 2, 3).pipe(HashSet.intersection(HashSet.make(2, 3, 4)))

// or with data-first API
HashSet.intersection(HashSet.make(1, 2, 3), HashSet.make(2, 3, 4))

LANGUAGE: typescript
CODE:
declare const intersection: { <A>(that: Iterable<A>): (self: HashSet<A>) => HashSet<A>; <A>(self: HashSet<A>, that: Iterable<A>): HashSet<A>; }

----------------------------------------

TITLE: Creating Micro Effect with MicroFiber in TypeScript
DESCRIPTION: Function signature for withMicroFiber that creates a Micro effect using the current MicroFiber. It takes an evaluation function that accepts a MicroFiberImpl instance and returns a Micro effect with generic type parameters for the result type (A), error type (E), and environment type (R).

LANGUAGE: typescript
CODE:
declare const withMicroFiber: <A, E = never, R = never>(evaluate: (fiber: MicroFiberImpl<A, E>) => Micro<A, E, R>) => Micro<A, E, R>

----------------------------------------

TITLE: Formatting Durations to ISO8601 Strings in TypeScript
DESCRIPTION: The Duration.formatIso function converts a Duration object into an ISO8601 duration string. It handles various time units and returns Option.none() for infinite durations. The function assumes 30 days per month and 365 days per year.

LANGUAGE: typescript
CODE:
import { Duration, Option } from "effect"

Duration.formatIso(Duration.days(1)) // => Option.some("P1D")
Duration.formatIso(Duration.minutes(90)) // => Option.some("PT1H30M")
Duration.formatIso(Duration.millis(1500)) // => Option.some("PT1.5S")
Duration.formatIso(Duration.infinity) // => Option.none()

LANGUAGE: typescript
CODE:
declare const formatIso: (self: DurationInput) => Option.Option<string>

----------------------------------------

TITLE: Implementing Atomic Array Predicate Evaluation in TypeScript
DESCRIPTION: Defines the everySTM function that atomically evaluates a transactional predicate across all members of a TArray. The function supports both curried and uncurried calling styles and operates within the STM (Software Transactional Memory) context.

LANGUAGE: typescript
CODE:
declare const everySTM: { 
  <A, R, E>(predicate: (value: A) => STM.STM<boolean, E, R>): (self: TArray<A>) => STM.STM<boolean, E, R>; 
  <A, R, E>(self: TArray<A>, predicate: (value: A) => STM.STM<boolean, E, R>): STM.STM<boolean, E, R>; 
}

----------------------------------------

TITLE: Constructing Interrupted Fiber in TypeScript
DESCRIPTION: The 'interrupted' function creates a Fiber that is already in an interrupted state. It takes a FiberId as a parameter and returns a Fiber that never completes.

LANGUAGE: typescript
CODE:
declare const interrupted: (fiberId: FiberId.FiberId) => Fiber<never>

----------------------------------------

TITLE: Defining fromEffect Function in TypeScript for Effect Package's Channel Module
DESCRIPTION: This code snippet defines the fromEffect function, which takes an Effect and returns a Channel. The function is used to create a channel that ends with the result of the given effect. It's part of the Channel module in the Effect package.

LANGUAGE: typescript
CODE:
declare const fromEffect: <A, E, R>(effect: Effect.Effect<A, E, R>) => Channel<never, unknown, E, unknown, A, unknown, R>

----------------------------------------

TITLE: Defining tapErrorCauseIf Function in TypeScript
DESCRIPTION: Declares the tapErrorCauseIf function with multiple overloads. It allows performing side effects on a Micro object if its error cause matches a specified predicate or refinement.

LANGUAGE: typescript
CODE:
declare const tapErrorCauseIf: { <E, B, E2, R2, EB extends MicroCause<E>>(refinement: Refinement<MicroCause<E>, EB>, f: (a: EB) => Micro<B, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A, E | E2, R | R2>; <E, B, E2, R2>(predicate: (cause: NoInfer<MicroCause<E>>) => boolean, f: (a: NoInfer<MicroCause<E>>) => Micro<B, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A, E | E2, R | R2>; <A, E, R, B, E2, R2, EB extends MicroCause<E>>(self: Micro<A, E, R>, refinement: Refinement<MicroCause<E>, EB>, f: (a: EB) => Micro<B, E2, R2>): Micro<A, E | E2, R | R2>; <A, E, R, B, E2, R2>(self: Micro<A, E, R>, predicate: (cause: NoInfer<MicroCause<E>>) => boolean, f: (a: NoInfer<MicroCause<E>>) => Micro<B, E2, R2>): Micro<A, E | E2, R | R2>; }

----------------------------------------

TITLE: Defining Terminal Interface in TypeScript
DESCRIPTION: Defines a TypeScript interface for terminal operations including reading input, displaying text, and getting terminal dimensions. The interface handles user input events, line reading, and text display with appropriate error handling.

LANGUAGE: typescript
CODE:
export interface Terminal {
  /**
   * The number of columns available on the platform's terminal interface.
   */
  readonly columns: Effect<number>
  /**
   * Reads a single input event from the default standard input.
   */
  readonly readInput: Effect<UserInput, QuitException>
  /**
   * Reads a single line from the default standard input.
   */
  readonly readLine: Effect<string, QuitException>
  /**
   * Displays text to the the default standard output.
   */
  readonly display: (text: string) => Effect<void, PlatformError>
}

----------------------------------------

TITLE: Implementing Record.reduce Function in TypeScript
DESCRIPTION: Defines a reduce function for records that combines entries using a specified function. It supports both curried and non-curried usage, allowing flexible application to ReadonlyRecord types.

LANGUAGE: typescript
CODE:
declare const reduce: { <Z, V, K extends string>(zero: Z, f: (accumulator: Z, value: V, key: K) => Z): (self: ReadonlyRecord<K, V>) => Z; <K extends string, V, Z>(self: ReadonlyRecord<K, V>, zero: Z, f: (accumulator: Z, value: V, key: K) => Z): Z; }

----------------------------------------

TITLE: Declaring repeatExit Function in TypeScript
DESCRIPTION: Defines the repeatExit function for repeating a Micro effect. It takes options including a while predicate, optional number of times to repeat, and an optional schedule. The function can be called with options first or with the Micro effect first.

LANGUAGE: typescript
CODE:
declare const repeatExit: { <A, E>(options: { while: Predicate<MicroExit<A, E>>; times?: number | undefined; schedule?: MicroSchedule | undefined; }): <R>(self: Micro<A, E, R>) => Micro<A, E, R>; <A, E, R>(self: Micro<A, E, R>, options: { while: Predicate<MicroExit<A, E>>; times?: number | undefined; schedule?: MicroSchedule | undefined; }): Micro<A, E, R>; }

----------------------------------------

TITLE: Defining Duration Schema Class in TypeScript
DESCRIPTION: Declares a Duration class that represents a schema for converting JSON-compatible tagged unions into Duration objects. This class is part of the Schema module in the Effect package.

LANGUAGE: typescript
CODE:
declare class Duration

----------------------------------------

TITLE: Concatenating Iterables with appendAll Function - TypeScript
DESCRIPTION: Function signature for appendAll which takes two iterables and combines their elements into a single iterable. Supports both curried and uncurried forms for flexible usage patterns.

LANGUAGE: typescript
CODE:
declare const appendAll: { <B>(that: Iterable<B>): <A>(self: Iterable<A>) => Iterable<A | B>; <A, B>(self: Iterable<A>, that: Iterable<B>): Iterable<A | B>; }

----------------------------------------

TITLE: Transforming Schedule Delays in TypeScript
DESCRIPTION: A function that modifies a schedule to output the Duration between scheduled executions instead of its original output. This utility helps in tracking and managing execution intervals in scheduled tasks.

LANGUAGE: typescript
CODE:
declare const delays: <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Duration.Duration, In, R>

----------------------------------------

TITLE: Decoding Base64 to Uint8Array in TypeScript
DESCRIPTION: Defines a Schema for decoding base64 (RFC4648) encoded strings into Uint8Array objects. This function is part of the Schema module in the effect package.

LANGUAGE: typescript
CODE:
declare const Uint8ArrayFromBase64: Schema<Uint8Array<ArrayBufferLike>, string, never>

----------------------------------------

TITLE: TypeScript Function Signature for RateLimiter.withCost
DESCRIPTION: Defines the TypeScript function signature for the RateLimiter.withCost function. It takes a cost as a number and returns a function that applies this cost to an Effect.

LANGUAGE: typescript
CODE:
declare const withCost: (cost: number) => <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>

----------------------------------------

TITLE: Retrieving MutableQueue Length in TypeScript
DESCRIPTION: This function returns the current number of elements in a MutableQueue. It takes a MutableQueue instance as a parameter and returns a number representing the queue's length.

LANGUAGE: typescript
CODE:
declare const length: <A>(self: MutableQueue<A>) => number

----------------------------------------

TITLE: Using uninterruptibleMask with Micro Effects in TypeScript
DESCRIPTION: Demonstrates how to wrap a Micro effect in an uninterruptible region while allowing specific portions to remain interruptible using the restore function. The example shows two sequential sleep operations with different interruption states.

LANGUAGE: typescript
CODE:
import * as Micro from "effect/Micro"

Micro.uninterruptibleMask((restore) =>
  Micro.sleep(1000).pipe( // uninterruptible
    Micro.andThen(restore(Micro.sleep(1000))) // interruptible
  )
)

LANGUAGE: typescript
CODE:
declare const uninterruptibleMask: <A, E, R>(f: (restore: <A, E, R>(effect: Micro<A, E, R>) => Micro<A, E, R>) => Micro<A, E, R>) => Micro<A, E, R>

----------------------------------------

TITLE: Testing Map Type Using Effect Predicate
DESCRIPTION: Example usage of the isMap predicate function showing various test cases for Map type validation. The function returns true for Map instances and false for other types including objects, null, and undefined.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { isMap } from "effect/Predicate"

assert.deepStrictEqual(isMap(new Map()), true)
assert.deepStrictEqual(isMap({}), false)
assert.deepStrictEqual(isMap(null), false)
assert.deepStrictEqual(isMap(undefined), false)

LANGUAGE: typescript
CODE:
declare const isMap: (input: unknown) => input is Map<unknown, unknown>

----------------------------------------

TITLE: Type Guard for PushAnnotationStream in TypeScript
DESCRIPTION: A type guard function that determines if a given DocStream is specifically a PushAnnotationStream. Takes a DocStream<A> as input and returns a boolean indicating if it's a PushAnnotationStream<A>. Used for type narrowing in TypeScript.

LANGUAGE: typescript
CODE:
declare const isPushAnnotationStream: <A>(self: DocStream<A>) => self is PushAnnotationStream<A>

----------------------------------------

TITLE: Calculating Time Zone Offset in TypeScript (Effect Package)
DESCRIPTION: The zonedOffsetIso function calculates the time zone offset of a Zoned DateTime object and returns it as a formatted string. The offset is represented in the ±HH:MM format. This function is part of the DateTime module in the Effect package.

LANGUAGE: typescript
CODE:
declare const zonedOffsetIso: (self: Zoned) => string

----------------------------------------

TITLE: Implementing Passthrough Layer in TypeScript
DESCRIPTION: The passthrough function creates a new layer that produces the outputs of the original layer while also passing through the inputs. It takes a Layer as input and returns a new Layer with modified type parameters.

LANGUAGE: typescript
CODE:
declare const passthrough: <RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Layer<RIn | ROut, E, RIn>

----------------------------------------

TITLE: Creating TArray from Iterable - TypeScript STM Implementation
DESCRIPTION: Function signature for creating a new TArray from an iterable collection of values within the STM (Software Transactional Memory) context. Returns an STM effect that produces a TArray containing the elements from the input iterable.

LANGUAGE: typescript
CODE:
declare const fromIterable: <A>(iterable: Iterable<A>) => STM.STM<TArray<A>>

----------------------------------------

TITLE: Implementing Sequential Zip Operation in TypeScript STM
DESCRIPTION: Defines a function that sequentially combines two STM values, keeping only the second value. The function is polymorphic and handles error types (E, E1) and environment types (R, R1) from both input STMs.

LANGUAGE: typescript
CODE:
declare const zipRight: { 
  <A1, E1, R1>(that: STM<A1, E1, R1>): <A, E, R>(self: STM<A, E, R>) => STM<A1, E1 | E, R1 | R>; 
  <A, E, R, A1, E1, R1>(self: STM<A, E, R>, that: STM<A1, E1, R1>): STM<A1, E | E1, R | R1>; 
}

----------------------------------------

TITLE: Defining foldCauseChannel Function in TypeScript
DESCRIPTION: This snippet defines the foldCauseChannel function, which folds over the result of a channel including any cause of termination. It takes options for handling failure and success cases, and returns a new channel.

LANGUAGE: typescript
CODE:
declare const foldCauseChannel: { <OutErr, OutElem1, InElem1, OutErr2, InErr1, OutDone2, InDone1, Env1, OutDone, OutElem2, InElem2, OutErr3, InErr2, OutDone3, InDone2, Env2>(options: { readonly onFailure: (c: Cause.Cause<OutErr>) => Channel<OutElem1, InElem1, OutErr2, InErr1, OutDone2, InDone1, Env1>; readonly onSuccess: (o: OutDone) => Channel<OutElem2, InElem2, OutErr3, InErr2, OutDone3, InDone2, Env2>; }): <Env, InErr, InElem, InDone, OutElem>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1 | OutElem2 | OutElem, InElem & InElem1 & InElem2, OutErr2 | OutErr3, InErr & InErr1 & InErr2, OutDone2 | OutDone3, InDone & InDone1 & InDone2, Env1 | Env2 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr2, InErr1, OutDone2, InDone1, Env1, OutElem2, InElem2, OutErr3, InErr2, OutDone3, InDone2, Env2>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, options: { readonly onFailure: (c: Cause.Cause<OutErr>) => Channel<OutElem1, InElem1, OutErr2, InErr1, OutDone2, InDone1, Env1>; readonly onSuccess: (o: OutDone) => Channel<OutElem2, InElem2, OutErr3, InErr2, OutDone3, InDone2, Env2>; }): Channel<OutElem | OutElem1 | OutElem2, InElem & InElem1 & InElem2, OutErr2 | OutErr3, InErr & InErr1 & InErr2, OutDone2 | OutDone3, InDone & InDone1 & InDone2, Env | Env1 | Env2>; }

----------------------------------------

TITLE: Declaring mapBoth Function for STM in TypeScript
DESCRIPTION: Defines the mapBoth function for STM effects. It takes options for mapping both failure and success channels, returning a new STM effect with transformed error and value types.

LANGUAGE: typescript
CODE:
declare const mapBoth: { <E, E2, A, A2>(options: { readonly onFailure: (error: E) => E2; readonly onSuccess: (value: A) => A2; }): <R>(self: STM<A, E, R>) => STM<A2, E2, R>; <A, E, R, E2, A2>(self: STM<A, E, R>, options: { readonly onFailure: (error: E) => E2; readonly onSuccess: (value: A) => A2; }): STM<A2, E2, R>; }

----------------------------------------

TITLE: Implementing Adjacent Element Deduplication in TypeScript
DESCRIPTION: Function signature for dedupeAdjacent, which takes a Chunk of elements and returns a new Chunk with adjacent duplicate elements removed. The function preserves the type parameter A of the input Chunk.

LANGUAGE: typescript
CODE:
declare const dedupeAdjacent: <A>(self: Chunk<A>) => Chunk<A>

----------------------------------------

TITLE: Defining TMap.updateWith Function Signature in TypeScript
DESCRIPTION: Declares the signature for the updateWith function, which updates or removes a key-value mapping in a TMap. It takes a key and a function that processes the current value, returning an updated value or None to remove the entry.

LANGUAGE: typescript
CODE:
declare const updateWith: { <K, V>(key: K, f: (value: Option.Option<V>) => Option.Option<V>): (self: TMap<K, V>) => STM.STM<Option.Option<V>>; <K, V>(self: TMap<K, V>, key: K, f: (value: Option.Option<V>) => Option.Option<V>): STM.STM<Option.Option<V>>; }

----------------------------------------

TITLE: Array.findFirst Function Signature in TypeScript
DESCRIPTION: Provides the type signature for the Array.findFirst function. It shows various overloads allowing for different predicate types and return values, including support for refinement types and Option returns.

LANGUAGE: typescript
CODE:
declare const findFirst: { <A, B>(f: (a: NoInfer<A>, i: number) => Option.Option<B>): (self: Iterable<A>) => Option.Option<B>; <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => Option.Option<B>; <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Option.Option<A>; <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option.Option<B>): Option.Option<B>; <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): Option.Option<B>; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Option.Option<A>; }

----------------------------------------

TITLE: Creating Stream from Iterator in TypeScript
DESCRIPTION: The fromIteratorSucceed function creates a stream from an iterator. It takes an IterableIterator<A> as input and an optional maxChunkSize parameter. The function returns a Stream<A>.

LANGUAGE: typescript
CODE:
declare const fromIteratorSucceed: <A>(iterator: IterableIterator<A>, maxChunkSize?: number) => Stream<A>

----------------------------------------

TITLE: Creating Layer from Time Zone Offset in TypeScript
DESCRIPTION: The layerCurrentZoneOffset function creates a Layer from a given time zone offset. It takes a number representing the offset and returns a Layer of type CurrentTimeZone. This function is useful for setting up time zone contexts in applications.

LANGUAGE: typescript
CODE:
declare const layerCurrentZoneOffset: (offset: number) => Layer.Layer<CurrentTimeZone>

----------------------------------------

TITLE: Implementing Infinite Stream Repetition in TypeScript
DESCRIPTION: Function signature for the forever operation that takes a Stream of type <A, E, R> and returns a Stream that repeats the input stream infinitely. The function maintains the same type parameters as the input stream.

LANGUAGE: typescript
CODE:
declare const forever: <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>

----------------------------------------

TITLE: Publishing Messages in TPubSub using TypeScript
DESCRIPTION: Defines a generic publish function that takes a value and publishes it to a TPubSub instance. The function returns an STM (Software Transactional Memory) operation that resolves to a boolean indicating whether the message was successfully published.

LANGUAGE: typescript
CODE:
declare const publish: { <A>(value: A): (self: TPubSub<A>) => STM.STM<boolean>; <A>(self: TPubSub<A>, value: A): STM.STM<boolean>; }

----------------------------------------

TITLE: Declaring Schedule Duration Function in TypeScript
DESCRIPTION: TypeScript type declaration for the duration function that creates a Schedule from a Duration input. The function takes a DurationInput parameter and returns a Schedule of Duration type.

LANGUAGE: typescript
CODE:
declare const duration: (duration: Duration.DurationInput) => Schedule<Duration.Duration>

----------------------------------------

TITLE: Using OptionFromNonEmptyTrimmedString Schema in TypeScript
DESCRIPTION: Demonstrates how to use the OptionFromNonEmptyTrimmedString schema to transform strings into Option types. The schema trims whitespace and returns Option.none() for empty strings and Option.some() for non-empty strings.

LANGUAGE: typescript
CODE:
import { Schema } from "effect"

console.log(Schema.decodeSync(Schema.OptionFromNonEmptyTrimmedString)("")) // Option.none()
console.log(Schema.decodeSync(Schema.OptionFromNonEmptyTrimmedString)(" a ")) // Option.some("a")
console.log(Schema.decodeSync(Schema.OptionFromNonEmptyTrimmedString)("a")) // Option.some("a")

LANGUAGE: typescript
CODE:
declare class OptionFromNonEmptyTrimmedString

----------------------------------------

TITLE: Checking Deferred Completion Status in TypeScript
DESCRIPTION: The isDone function returns a boolean Effect indicating whether a Deferred has been completed with a value or an error. It takes a Deferred<A, E> as input and returns an Effect<boolean>.

LANGUAGE: typescript
CODE:
declare const isDone: <A, E>(self: Deferred<A, E>) => Effect.Effect<boolean>

----------------------------------------

TITLE: Declaring Last Element Function in TypeScript for Effect List Module
DESCRIPTION: Defines a function 'last' that returns the last element of a List<A> as an Option<A>. If the list is empty, it returns None. This function is part of the Effect library's List module.

LANGUAGE: typescript
CODE:
declare const last: <A>(self: List<A>) => Option.Option<A>

----------------------------------------

TITLE: Accessing Stream Context in TypeScript using Effect-TS
DESCRIPTION: Defines a function that provides access to the entire context of a stream. Returns a Stream that contains the Context of type R and never produces an error.

LANGUAGE: typescript
CODE:
declare const context: <R>() => Stream<Context.Context<R>, never, R>

----------------------------------------

TITLE: Defining dropUntil Function for Stream Operations in TypeScript
DESCRIPTION: Declares the dropUntil function which drops all elements of a stream until the specified predicate evaluates to true. It supports two overloads: one for curried usage and another for direct application to a stream.

LANGUAGE: typescript
CODE:
declare const dropUntil: { <A>(predicate: Predicate<NoInfer<A>>): <E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, predicate: Predicate<A>): Stream<A, E, R>; }

----------------------------------------

TITLE: Defining RPC Handler Interface in TypeScript
DESCRIPTION: Defines a generic interface for RPC handlers that includes a unique tag, request handler function, and context. The handler function can return either an Effect or Stream type, processing requests with associated headers.

LANGUAGE: typescript
CODE:
export interface Handler<Tag extends string> {
  readonly _: unique symbol
  readonly tag: Tag
  readonly handler: (request: any, headers: Headers) => Effect<any, any> | Stream<any, any>
  readonly context: Context<never>
}

----------------------------------------

TITLE: FiberSet.runtime Function Signature in TypeScript
DESCRIPTION: This code snippet shows the TypeScript signature for the FiberSet.runtime function. It takes a FiberSet as input and returns an Effect that, when run, provides a function to fork effects and add them to the fiber set.

LANGUAGE: typescript
CODE:
declare const runtime: <A, E>(self: FiberSet<A, E>) => <R = never>() => Effect.Effect<(<XE extends E, XA extends A>(effect: Effect.Effect<XA, XE, R>, options?: (Runtime.RunForkOptions & { readonly propagateInterruption?: boolean | undefined; }) | undefined) => Fiber.RuntimeFiber<XA, XE>), never, R>

----------------------------------------

TITLE: Creating Iterable from Single Value - TypeScript
DESCRIPTION: Function signature for creating a new Iterable<A> from a single value. Takes a value of type A and returns an Iterable containing that value.

LANGUAGE: typescript
CODE:
declare const of: <A>(a: A) => Iterable<A>

----------------------------------------

TITLE: Checking Positive BigDecimal Values in TypeScript
DESCRIPTION: Demonstrates how to use the isPositive function from the BigDecimal module to check if a BigDecimal value is positive. It uses the unsafeFromString function to create BigDecimal values from strings for testing.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { isPositive, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(isPositive(unsafeFromString("-1")), false)
assert.deepStrictEqual(isPositive(unsafeFromString("0")), false)
assert.deepStrictEqual(isPositive(unsafeFromString("1")), true)

----------------------------------------

TITLE: Mapping Trie Entries in TypeScript using Effect Library
DESCRIPTION: Demonstrates how to use the `map` function to transform values in a `Trie` data structure. It shows mapping over values and keys separately, with assertions to verify the results.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Trie, Equal } from "effect"

const trie = Trie.empty<number>().pipe(
  Trie.insert("shells", 0),
  Trie.insert("sells", 1),
  Trie.insert("she", 2)
)

const trieMapV = Trie.empty<number>().pipe(
  Trie.insert("shells", 1),
  Trie.insert("sells", 2),
  Trie.insert("she", 3)
)

const trieMapK = Trie.empty<number>().pipe(
  Trie.insert("shells", 6),
  Trie.insert("sells", 5),
  Trie.insert("she", 3)
)

assert.equal(Equal.equals(Trie.map(trie, (v) => v + 1), trieMapV), true)
assert.equal(Equal.equals(Trie.map(trie, (_, k) => k.length), trieMapK), true)

----------------------------------------

TITLE: Defining File Content Argument in TypeScript using Effect CLI
DESCRIPTION: Function signature for creating a file argument that reads its contents. Takes an optional configuration object and returns an Args type containing a tuple of file path string and content as Uint8Array.

LANGUAGE: typescript
CODE:
declare const fileContent: (config?: Args.BaseArgsConfig | undefined) => Args<readonly [path: string, content: Uint8Array]>

----------------------------------------

TITLE: Function Signature for unsafeToNumber in TypeScript
DESCRIPTION: Provides the TypeScript function signature for the unsafeToNumber function. It takes a BigDecimal as input and returns a number.

LANGUAGE: typescript
CODE:
declare const unsafeToNumber: (n: BigDecimal) => number

----------------------------------------

TITLE: Defining Request.fail Function in TypeScript
DESCRIPTION: This code snippet defines the 'fail' function in the 'Request' module. It completes a Request with a specified error and can be used in two ways: as a curried function or with both arguments provided at once.

LANGUAGE: typescript
CODE:
declare const fail: {
  <A extends Request<any, any>>(error: Request.Error<A>): (self: A) => Effect.Effect<void>;
  <A extends Request<any, any>>(self: A, error: Request.Error<A>): Effect.Effect<void>;
}

----------------------------------------

TITLE: Getting Fiber Identity in TypeScript Effect Package
DESCRIPTION: Function signature for retrieving the unique identifier of a Fiber instance. Takes a Fiber instance with generic type parameters for success (A) and error (E) cases and returns a FiberId.

LANGUAGE: typescript
CODE:
declare const id: <A, E>(self: Fiber<A, E>) => FiberId.FiberId

----------------------------------------

TITLE: Defining Error Utility Type for Request in TypeScript
DESCRIPTION: This code snippet defines a utility type named Error that extracts the error type from a Request. It uses conditional types and infer to determine the error type E from a given Request<A, E>.

LANGUAGE: typescript
CODE:
type Error<T> = [T] extends [Request<infer _A, infer _E>] ? _E : never

----------------------------------------

TITLE: Checking for DecodeException in TypeScript
DESCRIPTION: This function checks if a given value is an instance of DecodeException. It takes an unknown value as input and returns a boolean indicating whether the value is a DecodeException.

LANGUAGE: typescript
CODE:
declare const isDecodeException: (u: unknown) => u is DecodeException

----------------------------------------

TITLE: Converting Chunk to ReadonlyArray in TypeScript
DESCRIPTION: Function signature for converting a Chunk into a ReadonlyArray. When converting a NonEmptyChunk, it preserves the non-empty property by returning a NonEmptyReadonlyArray. Takes a Chunk type parameter and returns either a ReadonlyArray or NonEmptyReadonlyArray depending on the input type.

LANGUAGE: typescript
CODE:
declare const toReadonlyArray: <S extends Chunk<any>>(self: S) => S extends NonEmptyChunk<any> ? RA.NonEmptyReadonlyArray<Chunk.Infer<S>> : ReadonlyArray<Chunk.Infer<S>>

----------------------------------------

TITLE: Concatenating Channels with Custom Combinators in TypeScript
DESCRIPTION: Implements sequential concatenation of a channel of channels with custom combining functions for OutDone values. The function takes a channel of channels and two combining functions to merge OutDone values during concatenation.

LANGUAGE: typescript
CODE:
declare const concatAllWith: <OutElem, InElem2, OutErr2, InErr2, OutDone, InDone2, Env2, InElem, OutErr, InErr, OutDone2, InDone, Env, OutDone3>(channels: Channel<Channel<OutElem, InElem2, OutErr2, InErr2, OutDone, InDone2, Env2>, InElem, OutErr, InErr, OutDone2, InDone, Env>, f: (o: OutDone, o1: OutDone) => OutDone, g: (o: OutDone, o2: OutDone2) => OutDone3) => Channel<OutElem, InElem & InElem2, OutErr2 | OutErr, InErr & InErr2, OutDone3, InDone & InDone2, Env2 | Env>

----------------------------------------

TITLE: Implementing TQueue.takeAll Operation in TypeScript
DESCRIPTION: Function signature for taking all values from a TQueue data structure. The operation returns an STM (Software Transactional Memory) effect that produces an array of values when executed. It works with any type A and returns an empty array if the queue is empty.

LANGUAGE: typescript
CODE:
declare const takeAll: <A>(self: TDequeue<A>) => STM.STM<Array<A>>

----------------------------------------

TITLE: Calculating Interval Size in TypeScript
DESCRIPTION: Function that computes the duration between the start and end points of an Interval. Returns a Duration type representing the time span of the interval.

LANGUAGE: typescript
CODE:
declare const size: (self: Interval) => Duration.Duration

----------------------------------------

TITLE: Defining Integer Primitive Type in TypeScript
DESCRIPTION: Declares a constant integer of type Primitive<number> that represents an integer value in the Effect CLI system. This primitive type is used for handling integer inputs and values in the CLI framework.

LANGUAGE: typescript
CODE:
declare const integer: Primitive<number>

----------------------------------------

TITLE: Creating HTTP API Group Handler Layer in TypeScript
DESCRIPTION: The 'group' function creates a Layer that implements all endpoints in an HttpApi. It allows you to build handlers for a specific group within the API, using the provided Handlers instance to implement endpoints.

LANGUAGE: typescript
CODE:
declare const group: <ApiId extends string, Groups extends HttpApiGroup.HttpApiGroup.Any, ApiError, ApiR, const Name extends HttpApiGroup.HttpApiGroup.Name<Groups>, Return>(api: HttpApi.HttpApi<ApiId, Groups, ApiError, ApiR>, groupName: Name, build: (handlers: Handlers.FromGroup<ApiError, ApiR, HttpApiGroup.HttpApiGroup.WithName<Groups, Name>>) => Handlers.ValidateReturn<Return>) => Layer.Layer<HttpApiGroup.ApiGroup<ApiId, Name>, Handlers.Error<Return>, Exclude<Handlers.Context<Return> | HttpApiGroup.HttpApiGroup.MiddlewareWithName<Groups, Name>, Scope>>

----------------------------------------

TITLE: Creating MutableHashSet from Iterable in TypeScript
DESCRIPTION: The fromIterable function creates a new MutableHashSet from an iterable collection of values. It takes an Iterable of type K and returns a MutableHashSet of the same type.

LANGUAGE: typescript
CODE:
declare const fromIterable: <K = never>(keys: Iterable<K>) => MutableHashSet<K>

----------------------------------------

TITLE: Defining Monoid.tuple Function in TypeScript
DESCRIPTION: The Monoid.tuple function creates a new Monoid for tuples based on given Monoids for each element. It combines two tuples by applying corresponding Monoids to each element. The empty value is a tuple of empty values from input Monoids.

LANGUAGE: typescript
CODE:
declare const tuple: <T extends ReadonlyArray<Monoid<any>>>(...elements: T) => Monoid<{ readonly [I in keyof T]: [T[I]] extends [Monoid<infer A>] ? A : never; }>

----------------------------------------

TITLE: Defining DateTimeUtcFromDate Schema Class in TypeScript
DESCRIPTION: Defines a schema class that converts JavaScript Date objects to DateTime.Utc instances using the DateTime.unsafeMake constructor. This class is part of the Effect-TS Schema module and provides type-safe date conversions.

LANGUAGE: typescript
CODE:
declare class DateTimeUtcFromDate

----------------------------------------

TITLE: Creating File Arguments in Effect CLI
DESCRIPTION: Function signature for creating file arguments in the Effect CLI framework. The function accepts optional configuration parameters and returns an Args instance of type string. The argument name defaults to 'file' if not specified.

LANGUAGE: typescript
CODE:
declare const file: (config?: Args.PathArgsConfig) => Args<string>

----------------------------------------

TITLE: Declaring Micro.either Function in TypeScript
DESCRIPTION: This code snippet defines the signature of the Micro.either function. It takes a Micro effect and returns a new Micro effect where the success value is wrapped in an Either type, with Right for success and Left for expected errors.

LANGUAGE: typescript
CODE:
declare const either: <A, E, R>(self: Micro<A, E, R>) => Micro<Either.Either<A, E>, never, R>

----------------------------------------

TITLE: Creating Timer Metric in TypeScript using Effect Library
DESCRIPTION: The timer function creates a timer metric based on a histogram to track durations in milliseconds. It automatically adds a time unit tag to the metric. The function takes a name and an optional description as parameters.

LANGUAGE: typescript
CODE:
declare const timer: (name: string, description?: string) => Metric<MetricKeyType.MetricKeyType.Histogram, Duration.Duration, MetricState.MetricState.Histogram>

----------------------------------------

TITLE: Normalizing BigDecimal Values Example
DESCRIPTION: Demonstrates how to use the normalize function to remove trailing zeros from BigDecimal values. Shows examples with both decimal and whole number values.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { normalize, make, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(normalize(unsafeFromString("123.00000")), normalize(make(123n, 0)))
assert.deepStrictEqual(normalize(unsafeFromString("12300000")), normalize(make(123n, -5)))

----------------------------------------

TITLE: Implementing String Concatenation in TypeScript with Effect-TS
DESCRIPTION: Defines a type-safe string concatenation function that works at runtime. The function supports both curried and uncurried forms, with generic type parameters to preserve string literal types in the result.

LANGUAGE: typescript
CODE:
declare const concat: { 
  <B extends string>(that: B): <A extends string>(self: A) => Concat<A, B>; 
  <A extends string, B extends string>(self: A, that: B): Concat<A, B>; 
}

----------------------------------------

TITLE: Adding Tags to Effect Metrics in TypeScript
DESCRIPTION: Function signature for adding key-value tag pairs to an existing metric. Supports both curried and uncurried forms of invocation. The function preserves the original metric's Type, In, and Out type parameters while adding the specified tags.

LANGUAGE: typescript
CODE:
declare const tagged: { 
  <Type, In, Out>(key: string, value: string): (self: Metric<Type, In, Out>) => Metric<Type, In, Out>; 
  <Type, In, Out>(self: Metric<Type, In, Out>, key: string, value: string): Metric<Type, In, Out>; 
}

----------------------------------------

TITLE: Implementing Cursor Up Movement in TypeScript with AnsiDoc
DESCRIPTION: Function that moves the cursor up in a terminal by a specified number of lines. It accepts an optional lines parameter defaulting to 1 and returns an AnsiDoc instance. The function has no effect if the cursor is at the screen edge.

LANGUAGE: typescript
CODE:
declare const cursorUp: (lines?: number) => AnsiDoc

----------------------------------------

TITLE: Trie.reduce Function Signature in TypeScript
DESCRIPTION: Defines the type signature for the Trie.reduce function. It supports both curried and non-curried forms, allowing flexible usage in different contexts.

LANGUAGE: typescript
CODE:
declare const reduce: { <Z, V>(zero: Z, f: (accumulator: Z, value: V, key: string) => Z): (self: Trie<V>) => Z; <Z, V>(self: Trie<V>, zero: Z, f: (accumulator: Z, value: V, key: string) => Z): Z; }

----------------------------------------

TITLE: Creating FiberRefs with unsafeMake in TypeScript
DESCRIPTION: Function signature for creating FiberRefs from a Map of FiberRef locals. The function takes a Map containing FiberRef keys and non-empty arrays of FiberId/value pairs. Important note: the function does not copy the provided Map, so a fresh Map should be provided.

LANGUAGE: typescript
CODE:
declare const unsafeMake: (fiberRefLocals: Map<FiberRef.FiberRef<any>, Arr.NonEmptyReadonlyArray<readonly [FiberId.Single, any]>>) => FiberRefs

----------------------------------------

TITLE: Creating TMap from Iterable in TypeScript
DESCRIPTION: The fromIterable function creates a new TMap from an iterable collection of key/value pairs. It returns an STM (Software Transactional Memory) operation that produces a TMap<K, V>.

LANGUAGE: typescript
CODE:
declare const fromIterable: <K, V>(iterable: Iterable<readonly [K, V]>) => STM.STM<TMap<K, V>>

----------------------------------------

TITLE: Retrieving Fibers from FiberMap in TypeScript
DESCRIPTION: The 'get' function retrieves a fiber from the FiberMap. It accepts a key and returns an Effect that resolves to a RuntimeFiber or a NoSuchElementException if the fiber is not found. The function is overloaded to allow for curried and non-curried usage.

LANGUAGE: typescript
CODE:
declare const get: { <K>(key: K): <A, E>(self: FiberMap<K, A, E>) => Effect.Effect<Fiber.RuntimeFiber<A, E>, NoSuchElementException>; <K, A, E>(self: FiberMap<K, A, E>, key: K): Effect.Effect<Fiber.RuntimeFiber<A, E>, NoSuchElementException>; }

----------------------------------------

TITLE: Implementing Traversable.traverseTap in TypeScript
DESCRIPTION: Defines a traverseTap function that threads an effect through values in a traversable structure T, returning the original structure wrapped in an effect context F while ignoring the values returned by the provided function. Takes a Traversable type class instance and an Applicative type class instance as parameters.

LANGUAGE: typescript
CODE:
declare const traverseTap: <T extends TypeLambda>(T: Traversable<T>) => <F extends TypeLambda>(F: Applicative<F>) => { 
  <A, R, O, E, B>(f: (a: A) => Kind<F, R, O, E, B>): 
    <TR, TO, TE>(self: Kind<T, TR, TO, TE, A>) => Kind<F, R, O, E, Kind<T, TR, TO, TE, A>>; 
  <TR, TO, TE, A, R, O, E, B>(self: Kind<T, TR, TO, TE, A>, f: (a: A) => Kind<F, R, O, E, B>): 
    Kind<F, R, O, E, Kind<T, TR, TO, TE, A>>; 
}

----------------------------------------

TITLE: Creating File Content Parameter in Effect CLI TypeScript
DESCRIPTION: The fileText function creates a parameter that expects a file path and returns both the path and the file's contents. This is commonly used in CLI applications to read and process file contents.

LANGUAGE: typescript
CODE:
declare const fileText: (name: string) => Options<readonly [path: string, content: string]>

----------------------------------------

TITLE: Implementing Channel Error Handling in TypeScript
DESCRIPTION: Implements a catchAllCause function that creates a new channel with enhanced error handling. The function takes an error handler that processes any typed errors and returns a fallback channel. The implementation supports both curried and uncurried function signatures with complex generic type parameters.

LANGUAGE: typescript
CODE:
declare const catchAllCause: { <OutErr, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(f: (cause: Cause.Cause<OutErr>) => Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>): <OutElem, InElem, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1 | OutElem, InElem & InElem1, OutErr1, InErr & InErr1, OutDone1 | OutDone, InDone & InDone1, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (cause: Cause.Cause<OutErr>) => Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>): Channel<OutElem | OutElem1, InElem & InElem1, OutErr1, InErr & InErr1, OutDone | OutDone1, InDone & InDone1, Env | Env1>; }

----------------------------------------

TITLE: Implementing DeepMutable Type in TypeScript
DESCRIPTION: Defines the DeepMutable type utility that recursively transforms readonly properties into mutable ones. It handles primitive types, ReadonlyMap, ReadonlySet, and nested object structures.

LANGUAGE: typescript
CODE:
type DeepMutable<T> = T extends ReadonlyMap<infer K, infer V> ? Map<DeepMutable<K>, DeepMutable<V>>
  : T extends ReadonlySet<infer V> ? Set<DeepMutable<V>>
  : T extends string | number | boolean | bigint | symbol ? T
  : { -readonly [K in keyof T]: DeepMutable<T[K]> }

----------------------------------------

TITLE: Implementing reduceOptionSTM for Atomic Array Reduction in TypeScript
DESCRIPTION: Defines a function for atomically reducing a non-empty TArray using a transactional binary operator. It takes a binary operator function and a TArray, returning an STM that resolves to an Option of the reduced value. The function is overloaded to allow for different parameter orders.

LANGUAGE: typescript
CODE:
declare const reduceOptionSTM: { <A, R, E>(f: (x: A, y: A) => STM.STM<A, E, R>): (self: TArray<A>) => STM.STM<Option.Option<A>, E, R>; <A, R, E>(self: TArray<A>, f: (x: A, y: A) => STM.STM<A, E, R>): STM.STM<Option.Option<A>, E, R>; }

----------------------------------------

TITLE: Defining unwrapScopedWith Function for Channel in TypeScript
DESCRIPTION: This function constructs a Channel from a function that receives a Scope and returns an effect resulting in a Channel if successful. It handles scoping and error handling for channel creation.

LANGUAGE: typescript
CODE:
declare const unwrapScopedWith: <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, E, R>(f: (scope: Scope.Scope) => Effect.Effect<Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, E, R>) => Channel<OutElem, InElem, E | OutErr, InErr, OutDone, InDone, R | Env>

----------------------------------------

TITLE: Defining unless Function in TypeScript for Conditional Effect Execution
DESCRIPTION: The `unless` function executes an effect only if the provided condition is false. It returns an Effect that resolves to an Option of the original effect's result type. The function supports both curried and non-curried versions.

LANGUAGE: typescript
CODE:
declare const unless: {
  (condition: LazyArg<boolean>): <A, E, R>(self: Effect<A, E, R>) => Effect<Option.Option<A>, E, R>;
  <A, E, R>(self: Effect<A, E, R>, condition: LazyArg<boolean>): Effect<Option.Option<A>, E, R>;
}

----------------------------------------

TITLE: TypeScript Signature for Match.tag Function
DESCRIPTION: Provides the TypeScript signature for the Match.tag function, showing its complex type parameters and return type. This signature is essential for understanding the function's type-level behavior.

LANGUAGE: typescript
CODE:
declare const tag: <R, P extends Types.Tags<"_tag", R> & string, Ret, Fn extends (_: Extract<R, Record<"_tag", P>>) => Ret>(...pattern: [first: P, ...values: Array<P>, f: Fn]) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr, Ret>) => Matcher<I, Types.AddWithout<F, Extract<R, Record<"_tag", P>>>, Types.ApplyFilters<I, Types.AddWithout<F, Extract<R, Record<"_tag", P>>>>, ReturnType<Fn> | A, Pr, Ret>

----------------------------------------

TITLE: Defining TestLive Interface in TypeScript
DESCRIPTION: Defines the TestLive interface that provides access to live default Effect services within tests. It includes a type identifier and a provide method for wrapping effects.

LANGUAGE: typescript
CODE:
export interface TestLive {
  readonly [TestLiveTypeId]: TestLiveTypeId
  provide<A, E, R>(effect: Effect.Effect<A, E, R>): Effect.Effect<A, E, R>
}

----------------------------------------

TITLE: Implementing Stream.flattenTake in TypeScript
DESCRIPTION: A function that unwraps Exit values and flattens chunks in streams that signify end-of-stream by failing with None. It transforms a Stream of Take values into a flattened Stream with potential error types from both the outer and inner streams.

LANGUAGE: typescript
CODE:
declare const flattenTake: <A, E2, E, R>(self: Stream<Take.Take<A, E2>, E, R>) => Stream<A, E | E2, R>

----------------------------------------

TITLE: TypeScript Declaration for nowInCurrentZone Function in DateTime Module
DESCRIPTION: This code snippet shows the TypeScript declaration for the nowInCurrentZone function in the DateTime module. It returns an Effect that produces a Zoned DateTime, never throws an error, and requires a CurrentTimeZone context.

LANGUAGE: typescript
CODE:
declare const nowInCurrentZone: Effect.Effect<Zoned, never, CurrentTimeZone>

----------------------------------------

TITLE: Implementing failSync Function in TypeScript
DESCRIPTION: Function signature for creating a Micro effect that fails with a lazily evaluated error. The function takes a LazyArg<E> parameter and returns a Micro<never, E> type, where E represents the error type and never indicates that no successful value can be produced.

LANGUAGE: typescript
CODE:
declare const failSync: <E>(error: LazyArg<E>) => Micro<never, E>

----------------------------------------

TITLE: Defining ShardStorage Class in TypeScript
DESCRIPTION: Declares the base ShardStorage class that serves as an interface for persistent storage operations in the cluster. This class is part of the @effect/cluster package and provides the foundation for implementing cluster storage functionality.

LANGUAGE: typescript
CODE:
declare class ShardStorage

----------------------------------------

TITLE: Defining ParseResult.Type Class in TypeScript
DESCRIPTION: Defines the Type class within the ParseResult module. This class represents a parsing error when the actual value doesn't match the expected type. It includes fields for the expected AST, the actual value, and an optional error message.

LANGUAGE: typescript
CODE:
declare class Type { constructor(
    readonly ast: AST.AST,
    readonly actual: unknown,
    readonly message?: string
  ) }

----------------------------------------

TITLE: Defining mergeRight Function for Stream Merging in TypeScript
DESCRIPTION: The mergeRight function merges two streams, discarding values from the left stream. It has two overloads: one for curried usage and another for direct application to two streams.

LANGUAGE: typescript
CODE:
declare const mergeRight: { <AR, ER, RR>(right: Stream<AR, ER, RR>): <AL, EL, RL>(left: Stream<AL, EL, RL>) => Stream<AR, ER | EL, RR | RL>; <AL, EL, RL, AR, ER, RR>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>): Stream<AR, EL | ER, RL | RR>; }

----------------------------------------

TITLE: Converting DateTime to UTC Example
DESCRIPTION: Demonstrates how to convert a DateTime object with a specific timezone to UTC using DateTime.toUtc function. The example creates a DateTime instance for London timezone and converts it to UTC.

LANGUAGE: typescript
CODE:
import { DateTime } from "effect"

const now = DateTime.unsafeMakeZoned({ year: 2024 }, { timeZone: "Europe/London" })

// set as UTC
const utc: DateTime.Utc = DateTime.toUtc(now)

----------------------------------------

TITLE: Checking Empty DocStream in TypeScript
DESCRIPTION: Type guard function that determines if a given DocStream is of type EmptyStream. Returns a boolean indicating whether the stream is empty and provides type narrowing in TypeScript.

LANGUAGE: typescript
CODE:
declare const isEmptyStream: <A>(self: DocStream<A>) => self is EmptyStream<A>

----------------------------------------

TITLE: Converting Duration to Nanoseconds in TypeScript
DESCRIPTION: Function that converts a duration input to nanoseconds represented as a bigint. Returns Option.none() for infinite durations, providing type-safe handling of duration conversions.

LANGUAGE: typescript
CODE:
declare const toNanos: (self: DurationInput) => Option.Option<bigint>

----------------------------------------

TITLE: Checking LeftDone State in TypeScript Effect Framework
DESCRIPTION: Type definition for a function that checks if a MergeState instance is specifically a LeftDone state. The function takes a MergeState parameter with multiple generic type parameters and returns a boolean type predicate.

LANGUAGE: typescript
CODE:
declare const isLeftDone: <Env, Err, Err1, Err2, Elem, Done, Done1, Done2>(self: MergeState<Env, Err, Err1, Err2, Elem, Done, Done1, Done2>) => self is LeftDone<Env, Err, Err1, Err2, Elem, Done, Done1, Done2>

----------------------------------------

TITLE: Defining TestAnnotations Interface in TypeScript
DESCRIPTION: This code snippet defines the TestAnnotations interface, which includes methods for managing test annotations and accessing supervised fibers. It provides functionality for getting and setting annotations, as well as retrieving the set of all fibers in the test.

LANGUAGE: typescript
CODE:
export interface TestAnnotations {
  readonly [TestAnnotationsTypeId]: TestAnnotationsTypeId

  /**
   * A ref containing the bacnking map for all annotations
   */
  readonly ref: Ref.Ref<TestAnnotationMap.TestAnnotationMap>

  /**
   * Accesses an `Annotations` instance in the context and retrieves the
   * annotation of the specified type, or its default value if there is none.
   */
  get<A>(key: TestAnnotation.TestAnnotation<A>): Effect.Effect<A>

  /**
   * Accesses an `Annotations` instance in the context and appends the
   * specified annotation to the annotation map.
   */
  annotate<A>(key: TestAnnotation.TestAnnotation<A>, value: A): Effect.Effect<void>

  /**
   * Returns the set of all fibers in this test.
   */
  readonly supervisedFibers: Effect.Effect<
    SortedSet.SortedSet<Fiber.RuntimeFiber<unknown, unknown>>
  >
}

----------------------------------------

TITLE: Creating Directory Path Option in TypeScript for Effect CLI
DESCRIPTION: Defines a function to create a parameter that expects a path to a directory. The function takes a name for the option and an optional configuration object.

LANGUAGE: typescript
CODE:
declare const directory: (name: string, config?: Options.PathOptionsConfig) => Options<string>

----------------------------------------

TITLE: Checking for Empty Doc in Effect Printer (TypeScript)
DESCRIPTION: The isEmpty function checks if a given Doc is an Empty document. It returns true if the document is Empty, false otherwise. This function is part of the @effect/printer package's Doc module.

LANGUAGE: typescript
CODE:
declare const isEmpty: <A>(self: Doc<A>) => self is Empty<A>

----------------------------------------

TITLE: Retrieving Queue Size in PubSub Module (TypeScript)
DESCRIPTION: The 'size' method retrieves the number of elements in the PubSub queue. It returns an Effect that resolves to a number, which may be negative if fibers are suspended waiting for elements to be added to the queue.

LANGUAGE: typescript
CODE:
declare const size: <A>(self: PubSub<A>) => Effect.Effect<number>

----------------------------------------

TITLE: Checking CooperativeYielding RuntimeFlag in TypeScript
DESCRIPTION: This function checks if the CooperativeYielding RuntimeFlag is enabled. It takes a RuntimeFlags object as input and returns a boolean value. True indicates the flag is enabled, while false means it's disabled.

LANGUAGE: typescript
CODE:
declare const cooperativeYielding: (self: RuntimeFlags) => boolean

----------------------------------------

TITLE: Creating Array Equivalence in TypeScript - Effect Package
DESCRIPTION: Function that creates a new Equivalence for comparing arrays by comparing their elements using a provided element-wise Equivalence function. Takes an Equivalence<A> for comparing individual elements and returns an Equivalence for comparing arrays of those elements.

LANGUAGE: typescript
CODE:
declare const array: <A>(item: Equivalence<A>) => Equivalence<ReadonlyArray<A>>

----------------------------------------

TITLE: Checking Fiber Running Status in TypeScript Effect Library
DESCRIPTION: Type definition for the isRunning function that checks if a FiberStatus is in Running state. The function is a type predicate that narrows the type to Running when true.

LANGUAGE: typescript
CODE:
declare const isRunning: (self: FiberStatus) => self is Running

----------------------------------------

TITLE: Type Guard Function for Unsupported ConfigError - TypeScript
DESCRIPTION: A type guard function that checks if a given ConfigError is specifically an Unsupported error type. Returns true if the error is an Unsupported instance, false otherwise. This function helps with type narrowing in TypeScript.

LANGUAGE: typescript
CODE:
declare const isUnsupported: (self: ConfigError) => self is Unsupported

----------------------------------------

TITLE: Checking Queue Emptiness in TPriorityQueue (TypeScript)
DESCRIPTION: The isEmpty function checks whether a given TPriorityQueue is empty. It takes a TPriorityQueue<A> as input and returns an STM.STM<boolean>. This function is part of the TPriorityQueue module in the effect package.

LANGUAGE: typescript
CODE:
declare const isEmpty: <A>(self: TPriorityQueue<A>) => STM.STM<boolean>

----------------------------------------

TITLE: Converting Option-Returning Function to Type Guard in TypeScript
DESCRIPTION: Demonstrates how to use Option.toRefinement to convert an Option-returning function into a type guard. The example shows creating a type guard for string validation from a union type.

LANGUAGE: typescript
CODE:
import { Option } from "effect"

type MyData = string | number

const parseString = (data: MyData): Option.Option<string> =>
  typeof data === "string" ? Option.some(data) : Option.none()

//      ┌─── (a: MyData) => a is string
//      ▼
const isString = Option.toRefinement(parseString)

console.log(isString("a"))
// Output: true

console.log(isString(1))
// Output: false

----------------------------------------

TITLE: Testing String Type in TypeScript using effect/Predicate
DESCRIPTION: Demonstrates the usage of the isString function from the effect/Predicate module to check if a value is a string. It includes an example showing true for a string input and false for a number input.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { isString } from "effect/Predicate"

assert.deepStrictEqual(isString("a"), true)

assert.deepStrictEqual(isString(1), false)

----------------------------------------

TITLE: Creating Tagged Request Class in TypeScript with Effect
DESCRIPTION: Example showing how to create a custom Request class using the TaggedClass constructor. The example demonstrates defining success and error types along with required properties.

LANGUAGE: typescript
CODE:
import { Request } from "effect"

type Success = string
type Error = never

class MyRequest extends Request.TaggedClass("MyRequest")<Success, Error, {
  readonly name: string
}> {}

----------------------------------------

TITLE: Setting Current Time Zone with Effect
DESCRIPTION: Demonstrates how to provide CurrentTimeZone to an Effect using the DateTime.withCurrentZone function. The example shows creating a time zone for Europe/London and using it with a generator function that gets the current time.

LANGUAGE: typescript
CODE:
import { DateTime, Effect } from "effect"

const zone = DateTime.zoneUnsafeMakeNamed("Europe/London")

Effect.gen(function* () {
  const now = yield* DateTime.nowInCurrentZone
}).pipe(DateTime.withCurrentZone(zone))

LANGUAGE: typescript
CODE:
declare const withCurrentZone: { (zone: TimeZone): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, Exclude<R, CurrentTimeZone>>; <A, E, R>(effect: Effect.Effect<A, E, R>, zone: TimeZone): Effect.Effect<A, E, Exclude<R, CurrentTimeZone>>; }

----------------------------------------

TITLE: Implementing Traversable Composition Function in TypeScript
DESCRIPTION: Defines a function that composes two Traversable instances with an Applicative functor. It provides a default binary traverse composition for handling nested traversable structures. The function takes two Traversable instances and returns a function that accepts an Applicative functor to perform the traversal.

LANGUAGE: typescript
CODE:
declare const traverseComposition: <T extends TypeLambda, G extends TypeLambda>(T: Traversable<T>, G: Traversable<G>) => <F extends TypeLambda>(F: Applicative<F>) => <TR, TO, TE, GR, GO, GE, A, R, O, E, B>(self: Kind<T, TR, TO, TE, Kind<G, GR, GO, GE, A>>, f: (a: A) => Kind<F, R, O, E, B>) => Kind<F, R, O, E, Kind<T, TR, TO, TE, Kind<G, GR, GO, GE, B>>>

----------------------------------------

TITLE: Defining ConfigError Union Type in TypeScript
DESCRIPTION: A TypeScript type definition that represents the various ways configuration loading can fail, including And, Or, InvalidData, MissingData, SourceUnavailable, and Unsupported cases.

LANGUAGE: typescript
CODE:
type ConfigError = | And
  | Or
  | InvalidData
  | MissingData
  | SourceUnavailable
  | Unsupported

----------------------------------------

TITLE: Declaring Schema.Trim Class in TypeScript
DESCRIPTION: This code snippet declares the Trim class within the Schema module. It is used to create a schema that removes whitespace from the beginning and end of a string.

LANGUAGE: typescript
CODE:
declare class Trim

----------------------------------------

TITLE: Retrieving Last Element from Non-Empty Array in TypeScript
DESCRIPTION: The 'lastNonEmpty' function returns the last element of a non-empty array. It takes a NonEmptyReadonlyArray<A> as input and returns an element of type A.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const result = Array.lastNonEmpty([1, 2, 3, 4])
console.log(result) // 4

LANGUAGE: typescript
CODE:
declare const lastNonEmpty: <A>(self: NonEmptyReadonlyArray<A>) => A

----------------------------------------

TITLE: Implementing Schedule.either Union Operation in TypeScript
DESCRIPTION: Defines a function that combines two schedules using a union operation. The function accepts two schedules and returns a new schedule that combines their output types, input types, and requirement types.

LANGUAGE: typescript
CODE:
declare const either: { <Out2, In2, R2>(that: Schedule<Out2, In2, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<[Out, Out2], In & In2, R2 | R>; <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>): Schedule<[Out, Out2], In & In2, R | R2>; }

----------------------------------------

TITLE: Padding an Array with Effect in TypeScript
DESCRIPTION: Demonstrates how to use the Array.pad function to extend an array to a specified length, filling with a given value. The function returns a new array without modifying the original.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const result = Array.pad([1, 2, 3], 6, 0)
console.log(result) // [1, 2, 3, 0, 0, 0]

----------------------------------------

TITLE: Creating Named Time Zone from IANA Identifier in TypeScript
DESCRIPTION: This function creates a named time zone from an IANA time zone identifier. It returns an Option of TimeZone.Named. If the provided time zone identifier is invalid, None will be returned.

LANGUAGE: typescript
CODE:
declare const zoneMakeNamed: (zoneId: string) => Option.Option<TimeZone.Named>

----------------------------------------

TITLE: Defining CliApp Interface in TypeScript
DESCRIPTION: This code snippet defines the CliApp interface, which extends Pipeable and includes properties for a command-line application's metadata and structure. It specifies the name, version, executable, command, summary, and footer of the application.

LANGUAGE: typescript
CODE:
export interface CliApp<A> extends Pipeable {
  readonly name: string
  readonly version: string
  readonly executable: string
  readonly command: Command<A>
  readonly summary: Span
  readonly footer: HelpDoc
}

----------------------------------------

TITLE: Demonstrating Array.unprepend in TypeScript
DESCRIPTION: This snippet shows how to use the Array.unprepend function from the Effect library. It separates the first element from the rest of the array, returning a tuple with the first element and a new array of the remaining elements.

LANGUAGE: typescript
CODE:
import { Array } from "effect";

const result = Array.unprepend([1, 2, 3, 4])
console.log(result) // [1, [2, 3, 4]]

----------------------------------------

TITLE: Getting FiberRef Values in TypeScript
DESCRIPTION: Function signature for retrieving the value of a specified FiberRef from a collection of FiberRef values. Returns an Option type containing the value if it exists, or None if it doesn't. Supports both curried and uncurried calling styles.

LANGUAGE: typescript
CODE:
declare const get: { <A>(fiberRef: FiberRef.FiberRef<A>): (self: FiberRefs) => Option.Option<A>; <A>(self: FiberRefs, fiberRef: FiberRef.FiberRef<A>): Option.Option<A>; }

----------------------------------------

TITLE: Implementing No-op Logger in TypeScript
DESCRIPTION: Defines a Logger implementation that does nothing in response to logging events. It uses generic types unknown for input and void for output to indicate its no-op nature.

LANGUAGE: typescript
CODE:
declare const none: Logger<unknown, void>

----------------------------------------

TITLE: Declaring hasProperty Function in TypeScript
DESCRIPTION: Defines the hasProperty function which checks if a value is an object containing a specified property key. It can be used in two ways: as a curried function or with two arguments.

LANGUAGE: typescript
CODE:
declare const hasProperty: { <P extends PropertyKey>(property: P): (self: unknown) => self is { [K in P]: unknown; }; <P extends PropertyKey>(self: unknown, property: P): self is { [K in P]: unknown; }; }

----------------------------------------

TITLE: Declaring toValues Function for HashMap in TypeScript
DESCRIPTION: Defines the toValues function that takes a HashMap and returns an Array of its values. It is generic over the key and value types of the HashMap.

LANGUAGE: typescript
CODE:
declare const toValues: <K, V>(self: HashMap<K, V>) => Array<V>

----------------------------------------

TITLE: Implementing SortedSet.some Predicate Check in TypeScript
DESCRIPTION: Defines a function that tests if any element in a SortedSet satisfies a given predicate. The function supports both curried and uncurried calling styles for checking predicates against SortedSet elements.

LANGUAGE: typescript
CODE:
declare const some: { \n  <A>(predicate: Predicate<A>): (self: SortedSet<A>) => boolean; \n  <A>(self: SortedSet<A>, predicate: Predicate<A>): boolean; \n}

----------------------------------------

TITLE: Implementing Schema Equivalence in TypeScript
DESCRIPTION: Function signature for creating an Equivalence instance from a Schema. Takes a Schema<A, I, R> as input and returns an Equivalence.Equivalence<A>. Used for comparing values of type A for equality based on the schema definition.

LANGUAGE: typescript
CODE:
declare const equivalence: <A, I, R>(schema: Schema<A, I, R>) => Equivalence.Equivalence<A>

----------------------------------------

TITLE: Implementing TestClock.sleep Function in TypeScript
DESCRIPTION: Defines the sleep function that semantically blocks the current fiber until the clock time reaches or exceeds the specified duration. It's used for simulating time-based operations in test environments.

LANGUAGE: typescript
CODE:
declare const sleep: (durationInput: Duration.DurationInput) => Effect.Effect<void>

----------------------------------------

TITLE: Implementing uninterruptibleMask Function in TypeScript Effect Module
DESCRIPTION: A function that makes execution uninterruptible while providing a restore function to selectively enable interruption. The restore function can be used to make specific regions of code interruptible again within an otherwise uninterruptible block.

LANGUAGE: typescript
CODE:
declare const uninterruptibleMask: <A, E, R>(f: (restore: <AX, EX, RX>(effect: Effect<AX, EX, RX>) => Effect<AX, EX, RX>) => Effect<A, E, R>) => Effect<A, E, R>

----------------------------------------

TITLE: Implementing Foldable Reduce Composition in TypeScript
DESCRIPTION: Defines a function that returns a default ternary reduce composition for two Foldable type constructors F and G. This allows composing reduction operations across nested foldable structures.

LANGUAGE: typescript
CODE:
declare const reduceComposition: <F extends TypeLambda, G extends TypeLambda>(F: Foldable<F>, G: Foldable<G>) => <FR, FO, FE, GR, GO, GE, A, B>(self: Kind<F, FR, FO, FE, Kind<G, GR, GO, GE, A>>, b: B, f: (b: B, a: A) => B) => B

----------------------------------------

TITLE: Implementing Atomic Map Transformation in TypeScript using Effect STM
DESCRIPTION: Defines a transformSTM function that atomically updates all key-value bindings in a TMap using a transactional function. The function accepts a transformation callback that processes each key-value pair and returns a new key-value tuple within an STM context.

LANGUAGE: typescript
CODE:
declare const transformSTM: {
  <K, V, R, E>(f: (key: K, value: V) => STM.STM<readonly [K, V], E, R>): (self: TMap<K, V>) => STM.STM<void, E, R>;
  <K, V, R, E>(self: TMap<K, V>, f: (key: K, value: V) => STM.STM<readonly [K, V], E, R>): STM.STM<void, E, R>;
}

----------------------------------------

TITLE: Checking Empty MutableList in TypeScript
DESCRIPTION: The isEmpty function checks if a MutableList contains zero elements. It returns true if the list is empty, and false otherwise. This function is part of the MutableList module in the effect package.

LANGUAGE: typescript
CODE:
declare const isEmpty: <A>(self: MutableList<A>) => boolean

----------------------------------------

TITLE: Converting Channel to Pullable Effect - TypeScript Function Signature
DESCRIPTION: Function signature for toPull that converts a Channel into an Effect that can repeatedly pull elements. The resulting Effect can fail with the channel's failure, or return either the channel's done value or an emitted element.

LANGUAGE: typescript
CODE:
declare const toPull: <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Effect.Effect<Effect.Effect<Either.Either<OutElem, OutDone>, OutErr, Env>, never, Scope.Scope | Env>

----------------------------------------

TITLE: Converting Record to Array using Effect Array.fromRecord
DESCRIPTION: Demonstrates how to convert a record object into an array of key-value tuple pairs using the fromRecord function from the Effect library's Array module. The function takes a readonly record as input and returns an array where each element is a tuple containing a key and its corresponding value.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const result = Array.fromRecord({ a: 1, b: 2, c: 3 })
console.log(result) // [["a", 1], ["b", 2], ["c", 3]]

LANGUAGE: typescript
CODE:
declare const fromRecord: <K extends string, A>(self: Readonly<Record<K, A>>) => Array<[K, A]>

----------------------------------------

TITLE: TypeScript Function Signature for Doc.fillBreak
DESCRIPTION: This code snippet shows the TypeScript function signature for the Doc.fillBreak function. It demonstrates that the function can be called with either curried or uncurried syntax.

LANGUAGE: typescript
CODE:
declare const fillBreak: { (w: number): <A>(self: Doc<A>) => Doc<A>; <A>(self: Doc<A>, w: number): Doc<A>; }

----------------------------------------

TITLE: Finding Minimum Between BigDecimals in TypeScript
DESCRIPTION: Demonstrates how to use the min function to compare two BigDecimal values and return the smaller one. The function accepts two BigDecimal parameters and returns the minimum value.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { min, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(min(unsafeFromString("2"), unsafeFromString("3")), unsafeFromString("2"))

LANGUAGE: typescript
CODE:
declare const min: { (that: BigDecimal): (self: BigDecimal) => BigDecimal; (self: BigDecimal, that: BigDecimal): BigDecimal; }

----------------------------------------

TITLE: Declaring BigInt MonoidMultiply Type in TypeScript
DESCRIPTION: This snippet shows the type declaration for the MonoidMultiply constant. It is defined as a Monoid instance for bigint values.

LANGUAGE: typescript
CODE:
declare const MonoidMultiply: monoid.Monoid<bigint>

----------------------------------------

TITLE: Function Signature for BigInt LCM in TypeScript
DESCRIPTION: This code block shows the TypeScript function signature for the lcm function in the BigInt module. It supports both curried and non-curried invocations, taking two bigint parameters and returning a bigint result.

LANGUAGE: typescript
CODE:
declare const lcm: { (that: bigint): (self: bigint) => bigint; (self: bigint, that: bigint): bigint; }

----------------------------------------

TITLE: Implementing Conditional Schedule Filtering in TypeScript with Effect-TS
DESCRIPTION: Function signature for checkEffect, which takes a test function that returns an Effect<boolean> and modifies a schedule based on input-output pairs. The test function determines whether the schedule should continue (true) or stop (false). This is particularly useful for scenarios involving asynchronous operations like database queries or API calls.

LANGUAGE: typescript
CODE:
declare const checkEffect: { <In, Out, R2>(test: (input: In, output: Out) => Effect.Effect<boolean, never, R2>): <R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>; <Out, In, R, R2>(self: Schedule<Out, In, R>, test: (input: In, output: Out) => Effect.Effect<boolean, never, R2>): Schedule<Out, In, R | R2>; }

----------------------------------------

TITLE: Testing Set Identification in TypeScript
DESCRIPTION: Demonstrates the usage of the isSet function from the effect/Predicate module to test if various values are Sets. It includes examples of true and false cases.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { isSet } from "effect/Predicate"

assert.deepStrictEqual(isSet(new Set([1, 2])), true)
assert.deepStrictEqual(isSet(new Set()), true)
assert.deepStrictEqual(isSet({}), false)
assert.deepStrictEqual(isSet(null), false)
assert.deepStrictEqual(isSet(undefined), false)

----------------------------------------

TITLE: Defining Option Type in TypeScript
DESCRIPTION: Type definition for the Option data type that represents optional values. It can either be Some<A> containing a value of type A, or None representing the absence of a value. Used for handling optional values, partial functions, and nullable data.

LANGUAGE: typescript
CODE:
type Option<A> = None<A> | Some<A>

----------------------------------------

TITLE: Constructing Fiber Descriptor Effect in TypeScript
DESCRIPTION: Defines a constant 'descriptor' that constructs an Effect containing information about the current Fiber. The effect has no requirements and cannot fail.

LANGUAGE: typescript
CODE:
declare const descriptor: Effect<Fiber.Fiber.Descriptor, never, never>

----------------------------------------

TITLE: Stream.unfold Function Signature in TypeScript
DESCRIPTION: The type signature for the Stream.unfold function, which takes an initial state of type S and a function that produces an Option of a tuple containing the next value and state.

LANGUAGE: typescript
CODE:
declare const unfold: <S, A>(s: S, f: (s: S) => Option.Option<readonly [A, S]>) => Stream<A>

----------------------------------------

TITLE: Creating Unbounded Queue in Effect TQueue
DESCRIPTION: Defines a function that creates an unbounded transactional queue. The function takes no parameters and returns an STM (Software Transactional Memory) operation that produces a TQueue of type A.

LANGUAGE: typescript
CODE:
declare const unbounded: <A>() => STM.STM<TQueue<A>>

----------------------------------------

TITLE: Checking Fiber Type in TypeScript
DESCRIPTION: The isFiber function is a type guard that checks if the provided value is a Fiber. It returns true if the value is a Fiber, and false otherwise. This function is useful for type-checking and conditional logic based on Fiber instances.

LANGUAGE: typescript
CODE:
declare const isFiber: (u: unknown) => u is Fiber<unknown, unknown>

----------------------------------------

TITLE: Creating Cron Instance - TypeScript Effect Library
DESCRIPTION: Function signature for creating a new Cron instance with configurable time parameters. Allows specification of seconds, minutes, hours, days, months, weekdays, and timezone. All time parameters except seconds are required and must be provided as Iterable<number>.

LANGUAGE: typescript
CODE:
declare const make: (values: { readonly seconds?: Iterable<number> | undefined; readonly minutes: Iterable<number>; readonly hours: Iterable<number>; readonly days: Iterable<number>; readonly months: Iterable<number>; readonly weekdays: Iterable<number>; readonly tz?: DateTime.TimeZone | undefined; }) => Cron

----------------------------------------

TITLE: Creating TPriorityQueue with Specified Values in TypeScript
DESCRIPTION: The make function creates a new TPriorityQueue initialized with specified values. It takes an Order parameter for element comparison and returns a function that accepts an array of elements to initialize the queue.

LANGUAGE: typescript
CODE:
declare const make: <A>(order: Order.Order<A>) => (...elements: Array<A>) => STM.STM<TPriorityQueue<A>>

----------------------------------------

TITLE: Demonstrating Boolean Implication in TypeScript using Effect Library
DESCRIPTION: This code snippet demonstrates the usage of the 'implies' function from the Effect library's Boolean module. It shows how boolean implication works for different combinations of true and false values.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { implies } from "effect/Boolean"

assert.deepStrictEqual(implies(true, true), true)
assert.deepStrictEqual(implies(true, false), false)
assert.deepStrictEqual(implies(false, true), true)
assert.deepStrictEqual(implies(false, false), true)

----------------------------------------

TITLE: Implementing Fiber Fallback with Error Handling in TypeScript
DESCRIPTION: Defines the `orElseEither` function that combines two fibers, preferring the first but falling back to the second on failure. It returns a new fiber that can be interrupted, which will sequentially interrupt both original fibers.

LANGUAGE: TypeScript
CODE:
declare const orElseEither: { <A2, E2>(that: Fiber<A2, E2>): <A, E>(self: Fiber<A, E>) => Fiber<Either.Either<A2, A>, E2 | E>; <A, E, A2, E2>(self: Fiber<A, E>, that: Fiber<A2, E2>): Fiber<Either.Either<A2, A>, E | E2>; }

----------------------------------------

TITLE: Defining TokenAttributes Interface for GenAI Telemetry
DESCRIPTION: Defines an interface for token attributes used in GenAI telemetry specification. The interface includes an optional type property that can be a string, null, or undefined.

LANGUAGE: typescript
CODE:
export interface TokenAttributes {
    readonly type?: string | null | undefined
  }

----------------------------------------

TITLE: Implementing Scoped Sized Service - TypeScript
DESCRIPTION: Declares a function that sets a temporary sized service implementation within a scoped context. The function takes a TestSized parameter and returns an Effect that requires a Scope and produces no error, restoring the original implementation when the scope closes.

LANGUAGE: typescript
CODE:
declare const withSizedScoped: (sized: Sized.TestSized) => Effect.Effect<void, never, Scope.Scope>

----------------------------------------

TITLE: Defining WebSocket Constructor Layer in TypeScript
DESCRIPTION: Implements a Layer for WebSocket construction that uses the browser's native WebSocket implementation through globalThis.WebSocket. This provides WebSocket functionality for the Effect platform in browser environments.

LANGUAGE: typescript
CODE:
declare const layerWebSocketConstructor: Layer.Layer<Socket.WebSocketConstructor, never, never>

----------------------------------------

TITLE: Structured Logger Type Signature in TypeScript
DESCRIPTION: This code snippet shows the type signature of the structuredLogger constant. It defines the structure of the log output, including logLevel, fiberId, timestamp, message, cause, annotations, and spans.

LANGUAGE: typescript
CODE:
declare const structuredLogger: Logger<unknown, { readonly logLevel: string; readonly fiberId: string; readonly timestamp: string; readonly message: unknown; readonly cause: string | undefined; readonly annotations: Record<string, unknown>; readonly spans: Record<string, number>; }>

----------------------------------------

TITLE: Implementing Array Order Comparison in TypeScript
DESCRIPTION: Function signature for creating an Order instance that compares arrays by comparing their elements using a provided Order. The function takes an Order<A> parameter and returns an Order for ReadonlyArray<A>. When comparing arrays, it applies the element-wise Order and falls back to length comparison if all elements are equal.

LANGUAGE: typescript
CODE:
declare const array: <A>(O: Order<A>) => Order<ReadonlyArray<A>>

----------------------------------------

TITLE: Implementing orElseIfEmptyChunk Function in TypeScript
DESCRIPTION: Defines a function that takes a lazy chunk argument and returns a function that transforms a stream. If the input stream is empty, it produces the specified chunk. The function supports both curried and uncurried calling patterns.

LANGUAGE: typescript
CODE:
declare const orElseIfEmptyChunk: {
  <A2>(chunk: LazyArg<Chunk.Chunk<A2>>): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E, R>;
  <A, E, R, A2>(self: Stream<A, E, R>, chunk: LazyArg<Chunk.Chunk<A2>>): Stream<A | A2, E, R>;
}

----------------------------------------

TITLE: Function Signature for toEntriesWithPrefix in TypeScript
DESCRIPTION: Provides the TypeScript function signature for the toEntriesWithPrefix function. It shows the function's polymorphic nature, accepting either a prefix first or a Trie first.

LANGUAGE: typescript
CODE:
declare const toEntriesWithPrefix: { (prefix: string): <V>(self: Trie<V>) => Array<[string, V]>; <V>(self: Trie<V>, prefix: string): Array<[string, V]>; }

----------------------------------------

TITLE: Defining Integer Config in Effect TypeScript
DESCRIPTION: Function signature for creating a configuration that accepts integer values. The function optionally takes a name parameter and returns a Config instance typed for numbers.

LANGUAGE: typescript
CODE:
declare const integer: (name?: string) => Config<number>

----------------------------------------

TITLE: Effect.mapError Type Definition
DESCRIPTION: Type signature for the mapError function showing its polymorphic nature and support for different error types. The function can be used either in pipeable form or with direct application.

LANGUAGE: typescript
CODE:
declare const mapError: { <E, E2>(f: (e: E) => E2): <A, R>(self: Effect<A, E, R>) => Effect<A, E2, R>; <A, E, R, E2>(self: Effect<A, E, R>, f: (e: E) => E2): Effect<A, E2, R>; }

----------------------------------------

TITLE: Chunk.map Function Signature in TypeScript
DESCRIPTION: Provides the TypeScript signature for the Chunk.map function. It shows the function's overloads for different input types and return values, including support for non-empty chunks.

LANGUAGE: typescript
CODE:
declare const map: { <S extends Chunk<any>, B>(f: (a: Chunk.Infer<S>, i: number) => B): (self: S) => Chunk.With<S, B>; <A, B>(self: NonEmptyChunk<A>, f: (a: A, i: number) => B): NonEmptyChunk<B>; <A, B>(self: Chunk<A>, f: (a: A, i: number) => B): Chunk<B>; }

----------------------------------------

TITLE: Updating Multiple FiberRef Values in TypeScript
DESCRIPTION: Function signature for updateManyAs that updates multiple FiberRef values using a provided FiberId. Takes options containing optional forkAs parameter and required entries array of FiberRef/value pairs.

LANGUAGE: typescript
CODE:
declare const updateManyAs: { 
  (options: { 
    readonly forkAs?: FiberId.Single | undefined; 
    readonly entries: readonly [readonly [FiberRef.FiberRef<any>, readonly [readonly [FiberId.Single, any], ...Array<readonly [FiberId.Single, any]>]], ...Array<readonly [FiberRef.FiberRef<any>, readonly [readonly [FiberId.Single, any], ...Array<readonly [FiberId.Single, any]>]]>]; 
  }): (self: FiberRefs) => FiberRefs; 
  (self: FiberRefs, options: { 
    readonly forkAs?: FiberId.Single | undefined; 
    readonly entries: readonly [readonly [FiberRef.FiberRef<any>, readonly [readonly [FiberId.Single, any], ...Array<readonly [FiberId.Single, any]>]], ...Array<readonly [FiberRef.FiberRef<any>, readonly [readonly [FiberId.Single, any], ...Array<readonly [FiberId.Single, any]>]]>]; 
  }): FiberRefs; 
}

----------------------------------------

TITLE: Effect.repeatOrElse Type Signature
DESCRIPTION: Type signature for the repeatOrElse function showing its polymorphic nature and type parameters. It supports both curried and uncurried calling styles with generic type parameters for different aspects of the effect, schedule, and error handling.

LANGUAGE: typescript
CODE:
declare const repeatOrElse: { <R2, A, B, E, E2, R3>(schedule: Schedule.Schedule<B, A, R2>, orElse: (error: E, option: Option.Option<B>) => Effect<B, E2, R3>): <R>(self: Effect<A, E, R>) => Effect<B, E2, R2 | R3 | R>; <A, E, R, R2, B, E2, R3>(self: Effect<A, E, R>, schedule: Schedule.Schedule<B, A, R2>, orElse: (error: E, option: Option.Option<B>) => Effect<B, E2, R3>): Effect<B, E2, R | R2 | R3>; }

----------------------------------------

TITLE: Replacing Record Values with Option Type in TypeScript
DESCRIPTION: Demonstrates how to use Record.replaceOption to safely replace values in a record, returning an Option type. The function returns Some with the modified record if the key exists, or None if the key doesn't exist.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Record, Option } from "effect"

assert.deepStrictEqual(
  Record.replaceOption({ a: 1, b: 2, c: 3 }, 'a', 10),
  Option.some({ a: 10, b: 2, c: 3 })
)
assert.deepStrictEqual(Record.replaceOption(Record.empty<string>(), 'a', 10), Option.none())

LANGUAGE: typescript
CODE:
declare const replaceOption: { <K extends string | symbol, B>(key: NoInfer<K>, b: B): <A>(self: ReadonlyRecord<K, A>) => Option.Option<Record<K, A | B>>; <K extends string | symbol, A, B>(self: ReadonlyRecord<K, A>, key: NoInfer<K>, b: B): Option.Option<Record<K, A | B>>; }

----------------------------------------

TITLE: Defining Schema.withDefaults Function in TypeScript
DESCRIPTION: This code snippet defines the withDefaults function in the Schema module. It enhances a property signature with default decoding and constructor values, allowing for more flexible schema definitions.

LANGUAGE: typescript
CODE:
declare const withDefaults: { <Type>(defaults: { constructor: () => Types.NoInfer<Exclude<Type, undefined>>; decoding: () => Types.NoInfer<Exclude<Type, undefined>>; }): <Key extends PropertyKey, Encoded, R>(self: PropertySignature<"?:", Type, Key, "?:", Encoded, boolean, R>) => PropertySignature<":", Exclude<Type, undefined>, Key, "?:", Encoded, true, R>; <Type, Key extends PropertyKey, Encoded, R>(self: PropertySignature<"?:", Type, Key, "?:", Encoded, boolean, R>, defaults: { constructor: () => Types.NoInfer<Exclude<Type, undefined>>; decoding: () => Types.NoInfer<Exclude<Type, undefined>>; }): PropertySignature<":", Exclude<Type, undefined>, Key, "?:", Encoded, true, R>; }

----------------------------------------

TITLE: Type Guard Function for AnnotationTree in TypeScript
DESCRIPTION: A type guard function that determines whether a given DocTree instance is specifically an AnnotationTree. Returns a boolean value and provides type narrowing in TypeScript.

LANGUAGE: typescript
CODE:
declare const isAnnotationTree: <A>(self: DocTree<A>) => self is AnnotationTree<A>

----------------------------------------

TITLE: Defining FieldOption Interface for Optional Fields in TypeScript
DESCRIPTION: This code snippet defines the FieldOption interface, which extends VariantSchema.Field. It specifies how a field should be treated as optional across different database operations and JSON representations, including handling of null values and missing keys.

LANGUAGE: typescript
CODE:
export interface FieldOption<S extends Schema.Schema.Any> extends
  VariantSchema.Field<{
    readonly select: Schema.OptionFromNullOr<S>
    readonly insert: Schema.OptionFromNullOr<S>
    readonly update: Schema.OptionFromNullOr<S>
    readonly json: Schema.optionalWith<S, { as: "Option" }>
    readonly jsonCreate: Schema.optionalWith<S, { as: "Option"; nullable: true }>
    readonly jsonUpdate: Schema.optionalWith<S, { as: "Option"; nullable: true }>
  }>
{}

----------------------------------------

TITLE: Offering Multiple Elements to TPriorityQueue in TypeScript
DESCRIPTION: The offerAll function provides a way to add all elements from an iterable collection to a TPriorityQueue. It returns an STM (Software Transactional Memory) operation that, when executed, will add the elements to the queue.

LANGUAGE: typescript
CODE:
declare const offerAll: { <A>(values: Iterable<A>): (self: TPriorityQueue<A>) => STM.STM<void>; <A>(self: TPriorityQueue<A>, values: Iterable<A>): STM.STM<void>; }

----------------------------------------

TITLE: Implementing Schedule.unfold in TypeScript
DESCRIPTION: Function signature for creating a schedule that recursively transforms a state value. It takes an initial value and a transformation function, producing an infinite sequence of values by repeatedly applying the transformation.

LANGUAGE: typescript
CODE:
declare const unfold: <A>(initial: A, f: (a: A) => A) => Schedule<A>

----------------------------------------

TITLE: Creating Choice Arguments in TypeScript with @effect/cli
DESCRIPTION: The choice function creates a choice argument with an array of string-value pairs and optional configuration. It returns an Args<A> object. The argument name defaults to "choice" if not specified.

LANGUAGE: typescript
CODE:
declare const choice: <A>(choices: ReadonlyArray<[string, A]>, config?: Args.BaseArgsConfig) => Args<A>

----------------------------------------

TITLE: Using fromIterableWith to Create a Record from an Iterable in TypeScript
DESCRIPTION: Demonstrates how to use the fromIterableWith function to convert an iterable of numbers into a record. The function maps each number to a key-value pair where the key is the string representation of the number and the value is twice the number.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { fromIterableWith } from "effect/Record"

const input = [1, 2, 3, 4]

assert.deepStrictEqual(
  fromIterableWith(input, a => [String(a), a * 2]),
  { '1': 2, '2': 4, '3': 6, '4': 8 }
)

----------------------------------------

TITLE: Using Types.Simplify in TypeScript
DESCRIPTION: Example demonstrating how to use Types.Simplify to merge intersected object types into a single object type.

LANGUAGE: typescript
CODE:
import type { Types } from "effect"

type Res = Types.Simplify<{ a: number } & { b: number }> // { a: number; b: number; }

----------------------------------------

TITLE: Defining Predicate.struct Function in TypeScript
DESCRIPTION: The struct function creates predicates or refinements for structured data. It takes an object of predicates or refinements and returns a new predicate or refinement that applies these checks to a structured object.

LANGUAGE: typescript
CODE:
declare const struct: <R extends Record<string, Predicate.Any>>(fields: R) => [Extract<R[keyof R], Refinement.Any>] extends [never] ? Predicate<{ readonly [K in keyof R]: Predicate.In<R[K]>; }> : Refinement<{ readonly [K in keyof R]: R[K] extends Refinement.Any ? Refinement.In<R[K]> : Predicate.In<R[K]>; }, { readonly [K in keyof R]: R[K] extends Refinement.Any ? Refinement.Out<R[K]> : Predicate.In<R[K]>; }>

----------------------------------------

TITLE: Type Checking UpstreamPullStrategy in TypeScript
DESCRIPTION: A type guard function that checks if a given UpstreamPullStrategy is specifically a PullAfterAllEnqueued instance. Returns true if the strategy is PullAfterAllEnqueued, false otherwise.

LANGUAGE: typescript
CODE:
declare const isPullAfterAllEnqueued: <A>(self: UpstreamPullStrategy<A>) => self is PullAfterAllEnqueued<A>

----------------------------------------

TITLE: Implementing Type Guard for SourceUnavailable ConfigError in TypeScript
DESCRIPTION: Type guard function that checks if a given ConfigError is specifically a SourceUnavailable error. Returns true if the error is of type SourceUnavailable, false otherwise. This function helps with type narrowing in TypeScript.

LANGUAGE: typescript
CODE:
declare const isSourceUnavailable: (self: ConfigError) => self is SourceUnavailable

----------------------------------------

TITLE: Creating Environment Differ in TypeScript
DESCRIPTION: Function that constructs a differ capable of computing differences between Context values of type A. The differ produces patches that can transform one Context value into another.

LANGUAGE: typescript
CODE:
declare const environment: <A>() => Differ<Context<A>, Differ.Context.Patch<A, A>>

----------------------------------------

TITLE: Using Option.liftPredicate in TypeScript
DESCRIPTION: Demonstrates how to use Option.liftPredicate to transform a predicate function into an Option-returning function. The example checks if a number is positive.

LANGUAGE: typescript
CODE:
import { Option } from "effect"

// Check if a number is positive
const isPositive = (n: number) => n > 0

//      ┌─── (b: number) => Option<number>
//      ▼
const parsePositive = Option.liftPredicate(isPositive)

console.log(parsePositive(1))
// Output: { _id: 'Option', _tag: 'Some', value: 1 }

console.log(parsePositive(-1))
// OUtput: { _id: 'Option', _tag: 'None' }

----------------------------------------

TITLE: Declaring forkScoped Function for Micro Effects in TypeScript
DESCRIPTION: The forkScoped function runs a Micro effect in a new MicroFiber that can be awaited, joined, or aborted. It attaches the lifetime of the handle to the current MicroScope. This function is part of the Micro module in the effect package.

LANGUAGE: typescript
CODE:
declare const forkScoped: <A, E, R>(self: Micro<A, E, R>) => Micro<MicroFiber<A, E>, never, R | MicroScope>

----------------------------------------

TITLE: Effect.takeUntil Function Signature in TypeScript
DESCRIPTION: Provides the TypeScript function signature for Effect.takeUntil. The function is overloaded to accept either the predicate first and elements second, or vice versa.

LANGUAGE: typescript
CODE:
declare const takeUntil: { <A, R, E>(predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>): (elements: Iterable<A>) => Effect<Array<A>, E, R>; <A, E, R>(elements: Iterable<A>, predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>): Effect<Array<A>, E, R>; }

----------------------------------------

TITLE: Implementing findAllSTM Function in TypeScript
DESCRIPTION: Function declaration for findAllSTM that searches for key/value pairs in a TMap matching a predicate and transforms them using STM operations. The function supports both curried and uncurried calling styles and handles optional error cases through Option type.

LANGUAGE: typescript
CODE:
declare const findAllSTM: {
  <K, V, A, E, R>(pf: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>): (self: TMap<K, V>) => STM.STM<Array<A>, E, R>;
  <K, V, A, E, R>(self: TMap<K, V>, pf: (key: K, value: V) => STM.STM<A, Option.Option<E>, R>): STM.STM<Array<A>, E, R>;
}

----------------------------------------

TITLE: Extending Effect Scope in TypeScript
DESCRIPTION: Function signature for extending the scope of an Effect that requires a scope. The function allows providing a scope to an effect without closing it when the effect completes execution, enabling scope extension into larger contexts.

LANGUAGE: typescript
CODE:
declare const extend: { 
  (scope: Scope): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, Exclude<R, Scope>>; 
  <A, E, R>(effect: Effect.Effect<A, E, R>, scope: Scope): Effect.Effect<A, E, Exclude<R, Scope>>; 
}

----------------------------------------

TITLE: Effect.tapDefect Type Signature
DESCRIPTION: Type declaration for the tapDefect function showing its polymorphic nature and type constraints.

LANGUAGE: typescript
CODE:
declare const tapDefect: { <X, E2, R2>(f: (cause: Cause.Cause<never>) => Effect<X, E2, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E2 | E, R2 | R>; <A, E, R, X, E2, R2>(self: Effect<A, E, R>, f: (cause: Cause.Cause<never>) => Effect<X, E2, R2>): Effect<A, E | E2, R | R2>; }

----------------------------------------

TITLE: Implementing rejectSTM Function in TypeScript STM Module
DESCRIPTION: Function signature for rejectSTM that processes an STM transaction with a partial function. It continues with the returned computation if the specified partial function matches, translating successful matches into failures, otherwise maintains the original value.

LANGUAGE: typescript
CODE:
declare const rejectSTM: { 
  <A, E2, R2>(pf: (a: A) => Option.Option<STM<E2, E2, R2>>): <E, R>(self: STM<A, E, R>) => STM<A, E2 | E, R2 | R>; 
  <A, E, R, E2, R2>(self: STM<A, E, R>, pf: (a: A) => Option.Option<STM<E2, E2, R2>>): STM<A, E | E2, R | R2>; 
}

----------------------------------------

TITLE: Creating a Runner Object in TypeScript
DESCRIPTION: The Runner.make function creates a Runner object representing a physical application server. It takes an object with 'address' and 'version' properties as input. The address must be unique for communication, and the version is used for prioritizing newer servers during rebalancing.

LANGUAGE: typescript
CODE:
declare const make: (props: { readonly address: RunnerAddress; readonly version: number; }) => Runner

----------------------------------------

TITLE: Converting BigDecimal to number in TypeScript
DESCRIPTION: Demonstrates the usage of unsafeToNumber function to convert a BigDecimal to a number. The example shows how to import the necessary functions and perform the conversion. It's important to note that this function may produce incorrect results if the BigDecimal exceeds the 64-bit range of a number.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { unsafeToNumber, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(unsafeToNumber(unsafeFromString("123.456")), 123.456)

----------------------------------------

TITLE: Creating Text Arguments in Effect CLI (TypeScript)
DESCRIPTION: The text function creates a text argument for the Effect CLI. It accepts an optional configuration object of type Args.BaseArgsConfig. If no custom argument name is provided, it defaults to "text". The function returns an Args<string> object.

LANGUAGE: typescript
CODE:
declare const text: (config?: Args.BaseArgsConfig) => Args<string>

----------------------------------------

TITLE: Comparing BigInt Values with lessThan Function in TypeScript
DESCRIPTION: The 'lessThan' function compares two BigInt values and returns true if the first argument is less than the second, otherwise false. It can be used in both curried and uncurried forms.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { lessThan } from "effect/BigInt"

assert.deepStrictEqual(lessThan(2n, 3n), true)
assert.deepStrictEqual(lessThan(3n, 3n), false)
assert.deepStrictEqual(lessThan(4n, 3n), false)

LANGUAGE: typescript
CODE:
declare const lessThan: { (that: bigint): (self: bigint) => boolean; (self: bigint, that: bigint): boolean; }

----------------------------------------

TITLE: Defining EntityNotManagedByRunner Error Class in TypeScript
DESCRIPTION: Declares the EntityNotManagedByRunner class, which represents an error that occurs when a Runner receives a message for an entity it's not responsible for managing. This class is part of the ClusterError module in the @effect/cluster package.

LANGUAGE: typescript
CODE:
declare class EntityNotManagedByRunner

----------------------------------------

TITLE: Retrieving Last Element from MutableList in TypeScript
DESCRIPTION: The tail function returns the last element of a MutableList, if it exists. It takes a MutableList<A> as input and returns either an element of type A or undefined if the list is empty.

LANGUAGE: typescript
CODE:
declare const tail: <A>(self: MutableList<A>) => A | undefined

----------------------------------------

TITLE: Implementing Exit.zipLeft Function in TypeScript
DESCRIPTION: Function declaration for zipLeft that combines two Exit results, retaining the first value while merging error types. It provides both curried and uncurried versions of the function for flexibility in usage.

LANGUAGE: typescript
CODE:
declare const zipLeft: { <A2, E2>(that: Exit<A2, E2>): <A, E>(self: Exit<A, E>) => Exit<A, E2 | E>; <A, E, A2, E2>(self: Exit<A, E>, that: Exit<A2, E2>): Exit<A, E | E2>; }

----------------------------------------

TITLE: Extracting Tags from Union Types using Types.Tags in TypeScript
DESCRIPTION: A type utility that extracts the string literal types from the '_tag' property of objects in a union type. Returns 'never' for types that don't have a '_tag' property.

LANGUAGE: typescript
CODE:
import type { Types } from "effect"

type Res = Types.Tags<string | { _tag: "a" } | { _tag: "b" } > // "a" | "b"

LANGUAGE: typescript
CODE:
type Tags<E> = E extends { _tag: string } ? E["_tag"] : never

----------------------------------------

TITLE: Checking for Dequeue Type in TypeScript
DESCRIPTION: The isDequeue function is a type predicate that determines if a given value is of type Dequeue. It takes an unknown value as input and returns a boolean indicating whether the value is a Dequeue instance. This function is useful for type narrowing in TypeScript.

LANGUAGE: typescript
CODE:
declare const isDequeue: (u: unknown) => u is Dequeue<unknown>

----------------------------------------

TITLE: Checking Disabled RuntimeFlags in TypeScript
DESCRIPTION: The isDisabled function returns true if a specified RuntimeFlag is disabled, false otherwise. It can be called with either the flag first and RuntimeFlags second, or RuntimeFlags first and flag second.

LANGUAGE: typescript
CODE:
declare const isDisabled: { (flag: RuntimeFlag): (self: RuntimeFlags) => boolean; (self: RuntimeFlags, flag: RuntimeFlag): boolean; }

----------------------------------------

TITLE: Transforming Predicates with mapInput in TypeScript
DESCRIPTION: Demonstrates how to use Predicate.mapInput to transform a predicate that works on numbers into one that works on strings by mapping the input. The example shows creating a string length validation predicate.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Predicate, Number } from "effect"

const minLength3 = Predicate.mapInput(Number.greaterThan(2), (s: string) => s.length)

assert.deepStrictEqual(minLength3("a"), false)
assert.deepStrictEqual(minLength3("aa"), false)
assert.deepStrictEqual(minLength3("aaa"), true)
assert.deepStrictEqual(minLength3("aaaa"), true)

LANGUAGE: typescript
CODE:
declare const mapInput: { <B, A>(f: (b: B) => A): (self: Predicate<A>) => Predicate<B>; <A, B>(self: Predicate<A>, f: (b: B) => A): Predicate<B>; }

----------------------------------------

TITLE: Retrieving Disabled RuntimeFlags in TypeScript
DESCRIPTION: The disabledSet function takes a RuntimeFlagsPatch object and returns a ReadonlySet containing the RuntimeFlags described as disabled by the specified patch. It's part of the RuntimeFlagsPatch module in the Effect package.

LANGUAGE: TypeScript
CODE:
declare const disabledSet: (self: RuntimeFlagsPatch) => ReadonlySet<RuntimeFlags.RuntimeFlag>

----------------------------------------

TITLE: TypeScript Type Definition for Stream.asyncPush Function
DESCRIPTION: Provides the type signature for the Stream.asyncPush function, including its parameters and return type. It shows the function's flexibility in handling different buffer sizes and strategies.

LANGUAGE: typescript
CODE:
declare const asyncPush: <A, E = never, R = never>(register: (emit: Emit.EmitOpsPush<E, A>) => Effect.Effect<unknown, E, R | Scope.Scope>, options?: { readonly bufferSize: "unbounded"; } | { readonly bufferSize?: number | undefined; readonly strategy?: "dropping" | "sliding" | undefined; } | undefined) => Stream<A, E, Exclude<R, Scope.Scope>>

----------------------------------------

TITLE: Converting FiberId to Thread Name in TypeScript
DESCRIPTION: Function that takes a FiberId instance and returns a string representation of the current thread name. Used for identifying and naming execution threads within the Effect system.

LANGUAGE: typescript
CODE:
declare const threadName: (self: FiberId) => string

----------------------------------------

TITLE: TestClock Interface Definition in TypeScript
DESCRIPTION: This code defines the TestClock interface, which extends the Clock interface. It includes methods for adjusting time, saving the current state, setting time, and retrieving scheduled sleeps.

LANGUAGE: typescript
CODE:
export interface TestClock extends Clock.Clock {
  adjust(duration: Duration.DurationInput): Effect.Effect<void>
  adjustWith(duration: Duration.DurationInput): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>
  readonly save: Effect.Effect<Effect.Effect<void>>
  setTime(time: number): Effect.Effect<void>
  readonly sleeps: Effect.Effect<Chunk.Chunk<number>>
}

----------------------------------------

TITLE: Implementing foldUntilEffect Sink in TypeScript
DESCRIPTION: Creates a sink that effectfully folds elements of type In into a structure of type S until max elements have been folded. It's similar to Sink.foldWeightedEffect but uses a constant cost function of 1.

LANGUAGE: TypeScript
CODE:
declare const foldUntilEffect: <S, In, E, R>(s: S, max: number, f: (s: S, input: In) => Effect.Effect<S, E, R>) => Sink<S, In, In, E, R>

----------------------------------------

TITLE: Constructing Empty List in TypeScript using Effect Library
DESCRIPTION: The nil function creates a new empty List<A>. It takes no parameters and returns an empty List of type A, where A defaults to never if not specified.

LANGUAGE: typescript
CODE:
declare const nil: <A = never>() => List<A>

----------------------------------------

TITLE: Implementing peekOption Operation for TPriorityQueue in TypeScript
DESCRIPTION: Defines a function that retrieves the first value from a priority queue without removing it, returning None if the queue is empty. The operation is performed within an STM (Software Transactional Memory) context.

LANGUAGE: typescript
CODE:
declare const peekOption: <A>(self: TPriorityQueue<A>) => STM.STM<Option.Option<A>>

----------------------------------------

TITLE: Checking Empty Cause Type in TypeScript
DESCRIPTION: A TypeScript function that checks whether a given Cause instance is of Empty type. Takes a Cause<E> parameter and returns a type predicate indicating if it's an Empty cause.

LANGUAGE: typescript
CODE:
declare const isEmptyType: <E>(self: Cause<E>) => self is Empty

----------------------------------------

TITLE: Using Doc.empty with Doc.vsep in TypeScript
DESCRIPTION: Demonstrates how Doc.empty behaves when used within vertical document composition, showing that it renders as an empty line rather than being completely invisible.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import * as String from "effect/String"

const doc = Doc.vsep([
  Doc.text("hello"),
  // `parentheses` for visibility purposes only
  Doc.parenthesized(Doc.empty),
  Doc.text("world")
])

const expected = `|hello
                  |()
                  |world`

assert.strictEqual(
  Doc.render(doc, { style: "pretty" }),
  String.stripMargin(expected)
)

----------------------------------------

TITLE: Defining foldWeightedDecomposeEffect Function in TypeScript
DESCRIPTION: This function creates a sink that folds elements of type In into a structure of type S, with a maximum weight limit. It includes a decompose function for breaking down elements that would exceed the weight limit. The function handles effects and can work with different error and environment types.

LANGUAGE: typescript
CODE:
declare const foldWeightedDecomposeEffect: <S, In, E, R, E2, R2, E3, R3>(options: { readonly initial: S; readonly maxCost: number; readonly cost: (s: S, input: In) => Effect.Effect<number, E, R>; readonly decompose: (input: In) => Effect.Effect<Chunk.Chunk<In>, E2, R2>; readonly body: (s: S, input: In) => Effect.Effect<S, E3, R3>; }) => Sink<S, In, In, E | E2 | E3, R | R2 | R3>

----------------------------------------

TITLE: Using Types.Has for Key Checking in TypeScript
DESCRIPTION: Demonstrates how to use the Types.Has utility type to check if an object type contains specific keys. Returns true if the object type contains any of the specified keys, false otherwise.

LANGUAGE: typescript
CODE:
import type { Types } from "effect"

type Res1 = Types.Has<{ a: number }, "a" | "b"> // true
type Res2 = Types.Has<{ c: number }, "a" | "b"> // false

LANGUAGE: typescript
CODE:
type Has<A, Key> = (Key extends infer K ? K extends keyof A ? true : never : never) extends never
  ? false
  : true

----------------------------------------

TITLE: Defining retry function for MetricPolling in TypeScript
DESCRIPTION: Declares a retry function that returns a new polling metric with a specified retry policy. It can be called with either the policy first or the metric first, allowing for flexible usage.

LANGUAGE: typescript
CODE:
declare const retry: { <X, E, R2>(policy: Schedule.Schedule<X, NoInfer<E>, R2>): <Type, In, R, Out>(self: MetricPolling<Type, In, R, E, Out>) => MetricPolling<Type, In, R2 | R, E, Out>; <Type, In, R, E, Out, X, R2>(self: MetricPolling<Type, In, R, E, Out>, policy: Schedule.Schedule<X, E, R2>): MetricPolling<Type, In, R | R2, E, Out>; }

----------------------------------------

TITLE: Specifying Standard Output Stream for Command in TypeScript
DESCRIPTION: The stdout function is used to specify the standard output stream for a command. It can be called with either one or two arguments, allowing for flexible usage in different contexts.

LANGUAGE: typescript
CODE:
declare const stdout: { (stdout: Command.Output): (self: Command) => Command; (self: Command, stdout: Command.Output): Command; }

----------------------------------------

TITLE: Defining BooleanFromNumber Model in TypeScript for Effect SQL
DESCRIPTION: Declares a class BooleanFromNumber to represent a boolean value parsed from 0 or 1 in SQL operations. This model is part of the @effect/sql package in the Model module.

LANGUAGE: typescript
CODE:
declare class BooleanFromNumber

----------------------------------------

TITLE: Checking TDequeue Type in TypeScript
DESCRIPTION: A type guard function that determines whether an unknown value is a TDequeue instance. This function is part of the Effect library's TQueue module and helps with type narrowing in TypeScript.

LANGUAGE: typescript
CODE:
declare const isTDequeue: (u: unknown) => u is TDequeue<unknown>

----------------------------------------

TITLE: Implementing Config Fallback Logic in TypeScript
DESCRIPTION: The orElse function defines a configuration fallback mechanism where if the primary config fails to read, it falls back to a secondary config. It works with generic types A and A2 to support different configuration value types.

LANGUAGE: typescript
CODE:
declare const orElse: { <A2>(that: LazyArg<Config<A2>>): <A>(self: Config<A>) => Config<A2 | A>; <A, A2>(self: Config<A>, that: LazyArg<Config<A2>>): Config<A | A2>; }

----------------------------------------

TITLE: Extracting Value Type from HashMap in TypeScript
DESCRIPTION: Example showing how to use HashMap.HashMap.Value to extract the value type from a HashMap instance. This utility type helps in type inference and type safety when working with HashMaps.

LANGUAGE: typescript
CODE:
import { HashMap } from "effect"

declare const hm: HashMap.HashMap<string, number>

// $ExpectType number
type V = HashMap.HashMap.Value<typeof hm>

LANGUAGE: typescript
CODE:
type Value<T> = [T] extends [HashMap<infer _K, infer _V>] ? _V : never

----------------------------------------

TITLE: Creating Inverse RuntimeFlagsPatch in TypeScript
DESCRIPTION: The inverse function creates a RuntimeFlagsPatch that describes the inverse of the provided RuntimeFlagsPatch. It takes a RuntimeFlagsPatch as input and returns a new RuntimeFlagsPatch representing the inverse operation.

LANGUAGE: typescript
CODE:
declare const inverse: (patch: RuntimeFlagsPatch) => RuntimeFlagsPatch

----------------------------------------

TITLE: Creating and Using FiberMap in TypeScript
DESCRIPTION: Demonstrates how to create and use a FiberMap to manage multiple fibers. The example shows storing never-ending effects in the map and their automatic cleanup when the scope closes.

LANGUAGE: typescript
CODE:
import { Effect, FiberMap } from "effect"

Effect.gen(function*() {
  const map = yield* FiberMap.make<string>()

  // run some effects and add the fibers to the map
  yield* FiberMap.run(map, "fiber a", Effect.never)
  yield* FiberMap.run(map, "fiber b", Effect.never)

  yield* Effect.sleep(1000)
}).pipe(
  Effect.scoped // The fibers will be interrupted when the scope is closed
)

----------------------------------------

TITLE: Flattening Nested Iterables in TypeScript
DESCRIPTION: Function signature for flattening an Iterable of Iterables into a single Iterable structure. Takes a nested Iterable as input and returns a flattened Iterable containing elements of type A.

LANGUAGE: typescript
CODE:
declare const flatten: <A>(self: Iterable<Iterable<A>>) => Iterable<A>

----------------------------------------

TITLE: Adjusting TestClock Time in TypeScript
DESCRIPTION: The adjust function increments the time of a TestClock instance in the context by a specified duration. It runs any scheduled actions up to the new time. The function takes a DurationInput parameter and returns an Effect of void.

LANGUAGE: typescript
CODE:
declare const adjust: (durationInput: Duration.DurationInput) => Effect.Effect<void>

----------------------------------------

TITLE: Option.getEquivalence Type Signature in TypeScript
DESCRIPTION: Type declaration for the getEquivalence function showing it takes an Equivalence of type A and returns an Equivalence for Option<A>.

LANGUAGE: typescript
CODE:
declare const getEquivalence: <A>(isEquivalent: Equivalence.Equivalence<A>) => Equivalence.Equivalence<Option<A>>

----------------------------------------

TITLE: Type Checking with ParseResult.is in TypeScript
DESCRIPTION: Defines a type guard function that validates if a value matches a given schema. The function accepts a schema and optional parse options, returning a type predicate function. By default, the 'exact' option is set to true.

LANGUAGE: typescript
CODE:
declare const is: <A, I, R>(schema: Schema.Schema<A, I, R>, options?: AST.ParseOptions) => (u: unknown, overrideOptions?: AST.ParseOptions | number) => u is A

----------------------------------------

TITLE: Declaring Interruptible Effect Function in TypeScript
DESCRIPTION: Function signature for marking a Micro effect as interruptible. When an effect is marked as interruptible, it will be interrupted immediately when an interruption occurs.

LANGUAGE: typescript
CODE:
declare const interruptible: <A, E, R>(self: Micro<A, E, R>) => Micro<A, E, R>

----------------------------------------

TITLE: String.isEmpty Function Signature in TypeScript
DESCRIPTION: Provides the TypeScript signature for the String.isEmpty function. It shows that the function takes a string parameter and returns a boolean, with a type predicate for an empty string.

LANGUAGE: typescript
CODE:
declare const isEmpty: (self: string) => self is ""

----------------------------------------

TITLE: Implementing repeatUntil Function in TypeScript STM Module
DESCRIPTION: Function declaration for repeatUntil that repeats an STM effect until a predicate is satisfied. It includes two overloads - one taking predicate first and another taking the STM effect first. Comes with a warning about busy loop implementation that can consume threads.

LANGUAGE: typescript
CODE:
declare const repeatUntil: { <A>(predicate: Predicate<A>): <E, R>(self: STM<A, E, R>) => STM<A, E, R>; <A, E, R>(self: STM<A, E, R>, predicate: Predicate<A>): STM<A, E, R>; }

----------------------------------------

TITLE: Defining Document Concatenation Interface in TypeScript
DESCRIPTION: Interface definition for the Cat type that represents document concatenation. It extends Doc.Variance<A> and contains a _tag identifier and references to left and right documents that are being concatenated.

LANGUAGE: typescript
CODE:
export interface Cat<A> extends Doc.Variance<A> {
  readonly _tag: "Cat"
  readonly left: Doc<A>
  readonly right: Doc<A>
}

----------------------------------------

TITLE: Modifying Metrics in Effect TypeScript
DESCRIPTION: Provides a function to modify metrics with update messages. The function accepts an input value and a metric instance, returning an Effect that updates the metric value. This is commonly used for operations like incrementing gauges.

LANGUAGE: typescript
CODE:
declare const modify: { 
  <In>(input: In): <Type, Out>(self: Metric<Type, In, Out>) => Effect.Effect<void>; 
  <Type, In, Out>(self: Metric<Type, In, Out>, input: In): Effect.Effect<void>; 
}

----------------------------------------

TITLE: TypeScript Signature for JSON Logger in Effect Library
DESCRIPTION: This code snippet shows the TypeScript signature for the JSON logger in the Effect library. It defines 'json' as a Layer with no requirements, errors, or output.

LANGUAGE: typescript
CODE:
declare const json: Layer.Layer<never, never, never>

----------------------------------------

TITLE: Extracting Right Values from Either Iterable in TypeScript
DESCRIPTION: Demonstrates how to use Iterable.getRights to filter and extract the Right values from an Iterable of Either types. The function ignores Left values and returns only the successful Right values.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Iterable, Either } from "effect"

assert.deepStrictEqual(
  Array.from(Iterable.getRights([Either.right(1), Either.left("err"), Either.right(2)])),
  [1, 2]
)

LANGUAGE: typescript
CODE:
declare const getRights: <R, L>(self: Iterable<Either<R, L>>) => Iterable<R>

----------------------------------------

TITLE: Checking MergeStrategy Type in TypeScript
DESCRIPTION: The isMergeStrategy function is a type guard that checks if a given value is of type MergeStrategy. It returns true if the input is a MergeStrategy, false otherwise. This function is useful for runtime type checking and validation.

LANGUAGE: typescript
CODE:
declare const isMergeStrategy: (u: unknown) => u is MergeStrategy

----------------------------------------

TITLE: Serializing Cookies to Set-Cookie Headers in TypeScript
DESCRIPTION: This function converts a Cookies object into an array of Set-Cookie header strings. It takes a Cookies object as input and returns an array of strings, each representing a Set-Cookie header. This is useful for preparing cookies to be sent in HTTP responses.

LANGUAGE: typescript
CODE:
declare const toSetCookieHeaders: (self: Cookies) => Array<string>

----------------------------------------

TITLE: TypeScript Signature for Array.differenceWith
DESCRIPTION: This code block provides the TypeScript type signature for the Array.differenceWith function, showing its parameters and return type.

LANGUAGE: typescript
CODE:
declare const differenceWith: <A>(isEquivalent: (self: A, that: A) => boolean) => { (that: Iterable<A>): (self: Iterable<A>) => Array<A>; (self: Iterable<A>, that: Iterable<A>): Array<A>; }

----------------------------------------

TITLE: Calculating Square Root of BigInt in TypeScript using Effect Library
DESCRIPTION: The unsafeSqrt function calculates the square root of a given bigint value. It throws an error if the input is negative. The function is part of the BigInt module in the Effect library.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { unsafeSqrt } from "effect/BigInt"

assert.deepStrictEqual(unsafeSqrt(4n), 2n)
assert.deepStrictEqual(unsafeSqrt(9n), 3n)
assert.deepStrictEqual(unsafeSqrt(16n), 4n)

LANGUAGE: typescript
CODE:
declare const unsafeSqrt: (n: bigint) => bigint

----------------------------------------

TITLE: Concatenating Channel Outputs in TypeScript
DESCRIPTION: Defines a function that concatenates multiple channels written out by a parent channel. This operation is specifically for channels that output other channels, combining their outputs into a single channel.

LANGUAGE: typescript
CODE:
declare const concatOut: <OutElem, InElem, OutErr, InErr, InDone, Env, OutDone>(self: Channel<Channel<OutElem, InElem, OutErr, InErr, unknown, InDone, Env>, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr, InErr, unknown, InDone, Env>

----------------------------------------

TITLE: Using Option.reduceCompact in TypeScript
DESCRIPTION: Example demonstrating how to use Option.reduceCompact to sum numbers from an iterable of Options while ignoring None values. The function processes an array containing both Some and None values, combining only the Some values using addition.

LANGUAGE: typescript
CODE:
import { Option, pipe } from "effect"

const iterable = [Option.some(1), Option.none(), Option.some(2), Option.none()]

console.log(pipe(iterable, Option.reduceCompact(0, (b, a) => b + a)))
// Output: 3

LANGUAGE: typescript
CODE:
declare const reduceCompact: { <B, A>(b: B, f: (b: B, a: A) => B): (self: Iterable<Option<A>>) => B; <A, B>(self: Iterable<Option<A>>, b: B, f: (b: B, a: A) => B): B; }

----------------------------------------

TITLE: TypeScript Signature for isNotNull Function
DESCRIPTION: This code block shows the TypeScript signature of the isNotNull function. It takes an input of type A and returns a boolean, with a type predicate indicating the result excludes null from the input type.

LANGUAGE: typescript
CODE:
declare const isNotNull: <A>(input: A) => input is Exclude<A, null>

----------------------------------------

TITLE: Defining RequestBlock Union Type in TypeScript
DESCRIPTION: Defines RequestBlock as a union type of Empty, Par, Seq, and Single types. This structure allows for representing different request execution patterns including parallel, sequential, and single requests.

LANGUAGE: typescript
CODE:
type RequestBlock = Empty | Par | Seq | Single

----------------------------------------

TITLE: Defining hasHash Function Signature in TypeScript
DESCRIPTION: Declares the type signature for the hasHash function, which checks if a specified key has an entry in the HashMap using a custom hash. The function is overloaded to accept either separate arguments or a HashMap as the first argument.

LANGUAGE: typescript
CODE:
declare const hasHash: { <K1>(key: K1, hash: number): <K, V>(self: HashMap<K, V>) => boolean; <K, V, K1>(self: HashMap<K, V>, key: K1, hash: number): boolean; }

----------------------------------------

TITLE: Converting Cookies to Record in TypeScript
DESCRIPTION: The toRecord function converts a Cookies object to a Record<string, string>. It takes a Cookies object as input and returns a plain JavaScript object where keys are cookie names and values are cookie values.

LANGUAGE: typescript
CODE:
declare const toRecord: (self: Cookies) => Record<string, string>

----------------------------------------

TITLE: GlobalValue Function Type Definition
DESCRIPTION: Type signature for the globalValue function, showing it accepts an id of unknown type and a compute function that returns type A, ultimately returning type A.

LANGUAGE: typescript
CODE:
declare const globalValue: <A>(id: unknown, compute: () => A) => A

----------------------------------------

TITLE: Creating Sink from Effect in TypeScript
DESCRIPTION: Function signature for unwrap, which creates a sink from an Effect. It takes an Effect that produces a Sink and returns a new Sink that combines the error and requirement types of both the effect and the produced sink.

LANGUAGE: typescript
CODE:
declare const unwrap: <A, In, L, E2, R2, E, R>(effect: Effect.Effect<Sink<A, In, L, E2, R2>, E, R>) => Sink<A, In, L, E2 | E, R2 | R>

----------------------------------------

TITLE: Checking for Interrupted Exit in TypeScript
DESCRIPTION: The isInterrupted function determines if a given Exit instance represents a Failure caused by interruption. It takes an Exit<A, E> as input and returns a boolean value. True indicates an interrupted failure, while false suggests otherwise.

LANGUAGE: typescript
CODE:
declare const isInterrupted: <A, E>(self: Exit<A, E>) => boolean

----------------------------------------

TITLE: Implementing findFirstIndex Function in Effect TypeScript
DESCRIPTION: Defines a function that finds the first index of a given value in a TArray. Returns an STM transaction that resolves to an Option containing the index if found. Supports both curried and uncurried calling styles.

LANGUAGE: typescript
CODE:
declare const findFirstIndex: { 
  <A>(value: A): (self: TArray<A>) => STM.STM<Option.Option<number>>; 
  <A>(self: TArray<A>, value: A): STM.STM<Option.Option<number>>; 
}

----------------------------------------

TITLE: Defining Doc.semi Constant in TypeScript
DESCRIPTION: Declares a constant named 'semi' of type Doc<never>, representing a document containing a single semicolon character. This is part of the @effect/printer package.

LANGUAGE: typescript
CODE:
declare const semi: Doc<never>

----------------------------------------

TITLE: Declaring TimeoutException Type Identifier in TypeScript
DESCRIPTION: Declares a unique symbol that serves as an identifier for TimeoutException types in the Effect framework. This symbol helps the framework identify and handle timeout-related errors when operations exceed their allocated time limits.

LANGUAGE: typescript
CODE:
declare const TimeoutExceptionTypeId: unique symbol

----------------------------------------

TITLE: Implementing RequestResolver Race Method in TypeScript
DESCRIPTION: Defines a race method that executes multiple requests concurrently and returns the result of the first one to complete, while safely interrupting the slower request. The method supports generic request types and return values.

LANGUAGE: typescript
CODE:
declare const race: { 
  <A2 extends Request.Request<any, any>, R2>(that: RequestResolver<A2, R2>): 
    <A extends Request.Request<any, any>, R>(self: RequestResolver<A, R>) => RequestResolver<A2 | A, R2 | R>; 
  <A extends Request.Request<any, any>, R, A2 extends Request.Request<any, any>, R2>
    (self: RequestResolver<A, R>, that: RequestResolver<A2, R2>): RequestResolver<A | A2, R | R2>; 
}

----------------------------------------

TITLE: TypeScript Function Signature for getOrThrow in Either Module
DESCRIPTION: This code snippet shows the TypeScript function signature for the getOrThrow function in the Either module. It takes an Either<R, L> as input and returns a value of type R.

LANGUAGE: typescript
CODE:
declare const getOrThrow: <R, L>(self: Either<R, L>) => R

----------------------------------------

TITLE: Declaring cursorMove Function in TypeScript for ANSI Cursor Manipulation
DESCRIPTION: Defines a function to move the cursor position relative to its current location. It takes column and optional row parameters, returning an AnsiDoc. The function has no effect if the cursor is at the screen edge.

LANGUAGE: typescript
CODE:
declare const cursorMove: (column: number, row?: number) => AnsiDoc

----------------------------------------

TITLE: FiberHandle.runtime Function Signature in TypeScript
DESCRIPTION: The TypeScript signature for the FiberHandle.runtime function, showing its generic types and return value structure. It takes a FiberHandle and returns an Effect that can run and manage fibers.

LANGUAGE: typescript
CODE:
declare const runtime: <A, E>(self: FiberHandle<A, E>) => <R = never>() => Effect.Effect<(<XE extends E, XA extends A>(effect: Effect.Effect<XA, XE, R>, options?: (Runtime.RunForkOptions & { readonly onlyIfMissing?: boolean | undefined; readonly propagateInterruption?: boolean | undefined; }) | undefined) => Fiber.RuntimeFiber<XA, XE>), never, R>

----------------------------------------

TITLE: Creating Halting Sink with Defect in TypeScript
DESCRIPTION: The dieSync function creates a sink that halts with a specified defect. It takes a lazy argument that evaluates to the defect and returns a Sink that never produces a value but may halt with the evaluated defect.

LANGUAGE: typescript
CODE:
declare const dieSync: (evaluate: LazyArg<unknown>) => Sink<never, unknown>

----------------------------------------

TITLE: Splitting Chunks using splitAt in Effect TypeScript
DESCRIPTION: A function that splits a Chunk into two parts at a specified index. Returns a tuple containing the elements before the index and the elements from the index onwards. Supports both curried and non-curried function signatures.

LANGUAGE: typescript
CODE:
declare const splitAt: { 
  (n: number): <A>(self: Chunk<A>) => [beforeIndex: Chunk<A>, fromIndex: Chunk<A>]; 
  <A>(self: Chunk<A>, n: number): [beforeIndex: Chunk<A>, fromIndex: Chunk<A>]; 
}

----------------------------------------

TITLE: Context.unsafeGet Type Signature in TypeScript
DESCRIPTION: Type declaration for the unsafeGet function showing its polymorphic nature and type parameters for services and tags.

LANGUAGE: typescript
CODE:
declare const unsafeGet: { <S, I>(tag: Tag<I, S>): <Services>(self: Context<Services>) => S; <Services, S, I>(self: Context<Services>, tag: Tag<I, S>): S; }

----------------------------------------

TITLE: Declaring ValidDateFromSelf Schema Class in TypeScript
DESCRIPTION: Defines a schema class that validates Date objects to ensure they represent valid dates. The schema specifically rejects Date instances that represent invalid dates like 'new Date("Invalid Date")', ensuring all processed dates are properly formed.

LANGUAGE: typescript
CODE:
declare class ValidDateFromSelf

----------------------------------------

TITLE: FiberMap.make Type Definition
DESCRIPTION: Type signature for the FiberMap.make function, showing its generic parameters and return type. Creates a new FiberMap that requires a Scope for proper resource management.

LANGUAGE: typescript
CODE:
declare const make: <K, A = unknown, E = unknown>() => Effect.Effect<FiberMap<K, A, E>, never, Scope.Scope>

----------------------------------------

TITLE: Defining TRef Interface in TypeScript
DESCRIPTION: Defines the TRef interface for handling transactional mutable references. TRef<A> represents a purely functional description of a mutable reference that can be modified within transactional effects. The interface extends TRef.Variance<A> and Pipeable, providing a modify method for transforming the reference value.

LANGUAGE: typescript
CODE:
export interface TRef<in out A> extends TRef.Variance<A>, Pipeable {
  /**
   * Note: the method is unbound, exposed only for potential extensions.
   */
  modify<B>(f: (a: A) => readonly [B, A]): STM.STM<B>
}

----------------------------------------

TITLE: Implementing Stream Error Refinement in TypeScript using Effect-TS
DESCRIPTION: Defines a function that filters Stream errors using a partial function, keeping some errors while terminating the fiber for others. The function supports both curried and uncurried calling styles.

LANGUAGE: typescript
CODE:
declare const refineOrDie: {
  <E, E2>(pf: (error: E) => Option.Option<E2>): <A, R>(self: Stream<A, E, R>) => Stream<A, E2, R>;
  <A, E, R, E2>(self: Stream<A, E, R>, pf: (error: E) => Option.Option<E2>): Stream<A, E2, R>;
}

----------------------------------------

TITLE: Using Option.liftThrowable with JSON Parsing in TypeScript
DESCRIPTION: Demonstrates how to use Option.liftThrowable to safely parse JSON strings by converting potential exceptions into Option types. The function returns Some(value) for successful parsing and None for failures.

LANGUAGE: typescript
CODE:
import { Option } from "effect"

const parse = Option.liftThrowable(JSON.parse)

console.log(parse("1"))
// Output: { _id: 'Option', _tag: 'Some', value: 1 }

console.log(parse(""))
// Output: { _id: 'Option', _tag: 'None' }

LANGUAGE: typescript
CODE:
declare const liftThrowable: <A extends ReadonlyArray<unknown>, B>(f: (...a: A) => B) => (...a: A) => Option<B>

----------------------------------------

TITLE: Checking for TextTree in TypeScript
DESCRIPTION: The isTextTree function is a type guard that determines if a given DocTree is specifically a TextTree. It takes a DocTree<A> as input and returns a boolean indicating whether it's a TextTree<A>.

LANGUAGE: typescript
CODE:
declare const isTextTree: <A>(self: DocTree<A>) => self is TextTree<A>

----------------------------------------

TITLE: Creating BigDecimal from Number in TypeScript
DESCRIPTION: Demonstrates how to use BigDecimal.safeFromNumber to create BigDecimal instances from various number types. The function returns an Option type, with Some containing the BigDecimal for finite numbers, and None for non-finite numbers.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { BigDecimal, Option } from "effect"

assert.deepStrictEqual(BigDecimal.safeFromNumber(123), Option.some(BigDecimal.make(123n, 0)))
assert.deepStrictEqual(BigDecimal.safeFromNumber(123.456), Option.some(BigDecimal.make(123456n, 3)))
assert.deepStrictEqual(BigDecimal.safeFromNumber(Infinity), Option.none())

----------------------------------------

TITLE: Terminating Stream with Lazy Error in TypeScript
DESCRIPTION: The failSync function is used to terminate a Stream with a specified lazily evaluated error. It takes a LazyArg<E> as input and returns a Stream that never produces a value but may fail with an error of type E.

LANGUAGE: typescript
CODE:
declare const failSync: <E>(evaluate: LazyArg<E>) => Stream<never, E>

----------------------------------------

TITLE: Using Boolean EQV Operation in TypeScript
DESCRIPTION: Example demonstrating how to use the eqv function from effect/Boolean to perform logical XNOR operations. The function returns true when both inputs are the same (both true or both false) and false when inputs differ.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { eqv } from "effect/Boolean"

assert.deepStrictEqual(eqv(true, true), true)
assert.deepStrictEqual(eqv(true, false), false)
assert.deepStrictEqual(eqv(false, true), false)
assert.deepStrictEqual(eqv(false, false), true)

LANGUAGE: typescript
CODE:
declare const eqv: { (that: boolean): (self: boolean) => boolean; (self: boolean, that: boolean): boolean; }

----------------------------------------

TITLE: Finding First Index with Predicate in TArray - TypeScript
DESCRIPTION: Function signature for finding the first index of an element in a TArray that matches a given predicate. Returns an STM transaction that resolves to an Option containing the index if found. Supports both curried and uncurried calling styles.

LANGUAGE: typescript
CODE:
declare const findFirstIndexWhere: { <A>(predicate: Predicate<A>): (self: TArray<A>) => STM.STM<Option.Option<number>>; <A>(self: TArray<A>, predicate: Predicate<A>): STM.STM<Option.Option<number>>; }

----------------------------------------

TITLE: Defining Fiber Interface in TypeScript
DESCRIPTION: Defines the Fiber interface with various methods for fiber management, including awaiting results, retrieving children, inheriting values, and interrupting execution.

LANGUAGE: typescript
CODE:
export interface Fiber<out A, out E = never> extends Effect.Effect<A, E>, Fiber.Variance<A, E> {
  /**
   * The identity of the fiber.
   */
  id(): FiberId.FiberId

  /**
   * Awaits the fiber, which suspends the awaiting fiber until the result of the
   * fiber has been determined.
   */
  readonly await: Effect.Effect<Exit.Exit<A, E>>

  /**
   * Retrieves the immediate children of the fiber.
   */
  readonly children: Effect.Effect<Array<Fiber.Runtime<any, any>>>

  /**
   * Inherits values from all `FiberRef` instances into current fiber. This
   * will resume immediately.
   */
  readonly inheritAll: Effect.Effect<void>

  /**
   * Tentatively observes the fiber, but returns immediately if it is not
   * already done.
   */
  readonly poll: Effect.Effect<Option.Option<Exit.Exit<A, E>>>

  /**
   * In the background, interrupts the fiber as if interrupted from the
   * specified fiber. If the fiber has already exited, the returned effect will
   * resume immediately. Otherwise, the effect will resume when the fiber exits.
   */
  interruptAsFork(fiberId: FiberId.FiberId): Effect.Effect<void>

  readonly [Unify.typeSymbol]?: unknown
  readonly [Unify.unifySymbol]?: FiberUnify<this>
  readonly [Unify.ignoreSymbol]?: FiberUnifyIgnore
}

----------------------------------------

TITLE: Declaring List.prepend Function in TypeScript
DESCRIPTION: Defines the 'prepend' function for the List module. This function adds a specified element to the beginning of a list, creating a new Cons (non-empty list). It supports both curried and non-curried usage.

LANGUAGE: typescript
CODE:
declare const prepend: { <B>(element: B): <A>(self: List<A>) => Cons<A | B>; <A, B>(self: List<A>, element: B): Cons<A | B>; }

----------------------------------------

TITLE: Implementing Reverse Traversal in RedBlackTree - TypeScript
DESCRIPTION: Type definition for the reversed function that traverses a RedBlackTree in reverse order. The function takes a RedBlackTree with generic key and value types and returns an Iterable of key-value pairs.

LANGUAGE: typescript
CODE:
declare const reversed: <K, V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>

----------------------------------------

TITLE: Defining Nest Interface for Indented Documents in TypeScript
DESCRIPTION: This code snippet defines the Nest interface, which extends Doc.Variance<A>. It represents a document indented by a certain number of columns, containing properties for the indentation level and the document itself.

LANGUAGE: typescript
CODE:
export interface Nest<A> extends Doc.Variance<A> {
  readonly _tag: "Nest"
  readonly indent: number
  readonly doc: Doc<A>
}

----------------------------------------

TITLE: Negating BigDecimal Values in TypeScript
DESCRIPTION: Demonstrates the usage of the negate function from the BigDecimal module. It shows how to negate positive and negative BigDecimal values using the negate and unsafeFromString functions.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { negate, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(negate(unsafeFromString("3")), unsafeFromString("-3"))
assert.deepStrictEqual(negate(unsafeFromString("-6")), unsafeFromString("6"))

----------------------------------------

TITLE: Modifying Document Stream Annotations in TypeScript
DESCRIPTION: Function signature for reAnnotate, which provides functionality to modify annotations within a DocStream. It supports both curried and uncurried forms of function application for transforming annotations from type A to type B.

LANGUAGE: typescript
CODE:
declare const reAnnotate: { <A, B>(f: (a: A) => B): (self: DocStream<A>) => DocStream<B>; <A, B>(self: DocStream<A>, f: (a: A) => B): DocStream<B>; }

----------------------------------------

TITLE: Defining Line Interface for Doc Module in TypeScript
DESCRIPTION: Defines the Line interface extending Doc.Variance<A>. It represents a document containing a hard line break and includes a readonly _tag property set to "Line".

LANGUAGE: typescript
CODE:
export interface Line<A> extends Doc.Variance<A> {
  readonly _tag: "Line"
}

----------------------------------------

TITLE: Retrieving Values from a Trie in TypeScript using Effect
DESCRIPTION: Demonstrates how to safely lookup values in a Trie data structure using the Trie.get function. It shows various scenarios including successful retrievals and attempts to access non-existent keys.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Trie, Option } from "effect"

const trie = Trie.empty<number>().pipe(
  Trie.insert("call", 0),
  Trie.insert("me", 1),
  Trie.insert("mind", 2),
  Trie.insert("mid", 3)
)

assert.deepStrictEqual(Trie.get(trie, "call"), Option.some(0))
assert.deepStrictEqual(Trie.get(trie, "me"), Option.some(1))
assert.deepStrictEqual(Trie.get(trie, "mind"), Option.some(2))
assert.deepStrictEqual(Trie.get(trie, "mid"), Option.some(3))
assert.deepStrictEqual(Trie.get(trie, "cale"), Option.none())
assert.deepStrictEqual(Trie.get(trie, "ma"), Option.none())
assert.deepStrictEqual(Trie.get(trie, "midn"), Option.none())
assert.deepStrictEqual(Trie.get(trie, "mea"), Option.none())

----------------------------------------

TITLE: Defining transformSTM Function in TypeScript
DESCRIPTION: Declares the transformSTM function, which atomically updates all elements of a TArray using a provided transactional effect. It supports both curried and uncurried versions of the function.

LANGUAGE: typescript
CODE:
declare const transformSTM: { <A, R, E>(f: (value: A) => STM.STM<A, E, R>): (self: TArray<A>) => STM.STM<void, E, R>; <A, R, E>(self: TArray<A>, f: (value: A) => STM.STM<A, E, R>): STM.STM<void, E, R>; }

----------------------------------------

TITLE: Declaring NoSuchElementException Class in TypeScript
DESCRIPTION: Defines a checked exception class that represents situations where an expected element could not be found. This class is part of the Effect-TS library's Micro module and is used for error handling.

LANGUAGE: typescript
CODE:
declare class NoSuchElementException

----------------------------------------

TITLE: Effect.timeoutFail Type Definition
DESCRIPTION: Type signature for the timeoutFail function showing its parameters and return types. The function accepts options including an onTimeout handler and duration, and returns an Effect that may fail with either the original error type or the custom timeout error type.

LANGUAGE: typescript
CODE:
declare const timeoutFail: { <E1>(options: { readonly onTimeout: LazyArg<E1>; readonly duration: Duration.DurationInput; }): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E1 | E, R>; <A, E, R, E1>(self: Effect<A, E, R>, options: { readonly onTimeout: LazyArg<E1>; readonly duration: Duration.DurationInput; }): Effect<A, E | E1, R>; }

----------------------------------------

TITLE: Implementing Parallel Zip Left Operation in TypeScript Exit Module
DESCRIPTION: Function signature for zipParLeft that parallelly combines two Exit results, keeping only the first value while combining error types. Takes Exit instances as input and returns a new Exit instance with combined error types but only the first success value.

LANGUAGE: typescript
CODE:
declare const zipParLeft: { 
  <A2, E2>(that: Exit<A2, E2>): <A, E>(self: Exit<A, E>) => Exit<A, E2 | E>; 
  <A, E, A2, E2>(self: Exit<A, E>, that: Exit<A2, E2>): Exit<A, E | E2>; 
}

----------------------------------------

TITLE: Using Stream.tap for Stream Element Effects in TypeScript
DESCRIPTION: Demonstrates how to use Stream.tap to add logging effects before and after stream element transformations. The example shows logging stream elements before and after mapping operation.

LANGUAGE: typescript
CODE:
import { Console, Effect, Stream } from "effect"

const stream = Stream.make(1, 2, 3).pipe(
  Stream.tap((n) => Console.log(`before mapping: ${n}`)),
  Stream.map((n) => n * 2),
  Stream.tap((n) => Console.log(`after mapping: ${n}`))
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// before mapping: 1
// after mapping: 2
// before mapping: 2
// after mapping: 4
// before mapping: 3
// after mapping: 6
// { _id: 'Chunk', values: [ 2, 4, 6 ] }

LANGUAGE: typescript
CODE:
declare const tap: { <A, X, E2, R2>(f: (a: NoInfer<A>) => Effect.Effect<X, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, X, E2, R2>(self: Stream<A, E, R>, f: (a: NoInfer<A>) => Effect.Effect<X, E2, R2>): Stream<A, E | E2, R | R2>; }

----------------------------------------

TITLE: Validating Primitive Types in TypeScript for @effect/cli
DESCRIPTION: Defines a `validate` function that checks if a given value matches a specified primitive type. It takes a value, CLI configuration, and a Primitive<A> type, returning an Effect that resolves to the validated value or an error string. It requires the FileSystem as a dependency.

LANGUAGE: typescript
CODE:
declare const validate: { (value: Option<string>, config: CliConfig): <A>(self: Primitive<A>) => Effect<A, string, FileSystem>; <A>(self: Primitive<A>, value: Option<string>, config: CliConfig): Effect<A, string, FileSystem>; }

----------------------------------------

TITLE: Defining FailedStream Interface in TypeScript
DESCRIPTION: TypeScript interface definition for FailedStream that extends DocStream.Variance<A>. Used to represent a Doc that failed during layout processing. Contains a discriminator _tag property with value 'FailedStream'.

LANGUAGE: typescript
CODE:
export interface FailedStream<A> extends DocStream.Variance<A> {
  readonly _tag: "FailedStream"
}

----------------------------------------

TITLE: BigInt.sqrt Function Signature in TypeScript
DESCRIPTION: The function signature for BigInt.sqrt, which takes a bigint as input and returns an Option of bigint. This signature is part of the Effect library's BigInt module.

LANGUAGE: typescript
CODE:
declare const sqrt: (n: bigint) => Option.Option<bigint>

----------------------------------------

TITLE: Defining addDelayEffect Function in TypeScript for Effect Package
DESCRIPTION: This code snippet defines the addDelayEffect function, which adds an effectfully computed delay to every interval in a schedule. It takes a function that computes the delay based on the schedule's output and returns a modified schedule.

LANGUAGE: typescript
CODE:
declare const addDelayEffect: { <Out, R2>(f: (out: Out) => Effect.Effect<Duration.DurationInput, never, R2>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>; <Out, In, R, R2>(self: Schedule<Out, In, R>, f: (out: Out) => Effect.Effect<Duration.DurationInput, never, R2>): Schedule<Out, In, R | R2>; }

----------------------------------------

TITLE: Defining Micro.repeat Function in TypeScript
DESCRIPTION: This code snippet defines the signature of the Micro.repeat function. It allows repeating a Micro effect with options for controlling the repetition behavior, including conditions, number of times, and scheduling.

LANGUAGE: typescript
CODE:
declare const repeat: { <A, E>(options?: { while?: Predicate<A> | undefined; times?: number | undefined; schedule?: MicroSchedule | undefined; } | undefined): <R>(self: Micro<A, E, R>) => Micro<A, E, R>; <A, E, R>(self: Micro<A, E, R>, options?: { while?: Predicate<A> | undefined; times?: number | undefined; schedule?: MicroSchedule | undefined; } | undefined): Micro<A, E, R>; }

----------------------------------------

TITLE: Using catWithSoftLine Combinator in TypeScript
DESCRIPTION: Demonstrates how to use the catWithSoftLine combinator to concatenate two documents with a softLine between them. The example shows the output with different rendering options.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import { pipe } from "effect/Function"
import * as String from "effect/String"

const doc: Doc.Doc<never> = pipe(
  Doc.char("a"),
  Doc.catWithSoftLine(Doc.char("b"))
)

assert.strictEqual(
  Doc.render(doc, { style: "pretty" }),
  "a b"
)

assert.strictEqual(
  Doc.render(doc, {
    style: "pretty",
    options: { lineWidth: 1 }
  }),
  String.stripMargin(
    `|a
     |b`
  )
)

----------------------------------------

TITLE: Defining Retries Constant for Test Services in TypeScript
DESCRIPTION: Declares a constant named retries as an Effect that resolves to a number. This Effect represents the number of times to retry flaky tests. It has no error type and no environment dependencies.

LANGUAGE: typescript
CODE:
declare const retries: Effect.Effect<number, never, never>

----------------------------------------

TITLE: Option.gen Function Signature in TypeScript
DESCRIPTION: This code snippet shows the TypeScript signature for the Option.gen function. It uses generics to define the return type and adapter type for the generator.

LANGUAGE: typescript
CODE:
declare const gen: Gen.Gen<OptionTypeLambda, Gen.Adapter<OptionTypeLambda>>

----------------------------------------

TITLE: Comparing BigDecimal Values with lessThan Function in TypeScript
DESCRIPTION: The lessThan function returns true if the first BigDecimal argument is less than the second, otherwise false. It can be used with both curried and uncurried syntax. The function is part of the BigDecimal module in the effect package.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { lessThan, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(lessThan(unsafeFromString("2"), unsafeFromString("3")), true)
assert.deepStrictEqual(lessThan(unsafeFromString("3"), unsafeFromString("3")), false)
assert.deepStrictEqual(lessThan(unsafeFromString("4"), unsafeFromString("3")), false)

----------------------------------------

TITLE: Using Doc.fill to Format Type Signatures in TypeScript
DESCRIPTION: Demonstrates how to use Doc.fill to create formatted type signatures with consistent spacing. The example shows formatting of function signatures with names padded to 5 characters, followed by their types.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import { pipe } from "effect/Function"
import * as String from "effect/String"

type Signature = [name: string, type: string]

const signatures: Array<Signature> = [
  ["empty", "Doc"],
  ["nest", "Int -> Doc -> Doc"],
  ["fillSep", "[Doc] -> Doc"]
]

const prettySignature = <A>([name, type]: Signature): Doc.Doc<A> =>
  Doc.hsep([
    pipe(Doc.text(name), Doc.fill(5)),
    Doc.text("::"),
    Doc.text(type)
  ])

const doc = Doc.hsep([
  Doc.text("let"),
  Doc.align(Doc.vcat(signatures.map(prettySignature)))
])

assert.strictEqual(
  Doc.render(doc, { style: "pretty" }),
  String.stripMargin(
    `|let empty :: Doc
     |    nest  :: Int -> Doc -> Doc
     |    fillSep :: [Doc] -> Doc`
  )
)

----------------------------------------

TITLE: Defining clampBigInt Function in TypeScript for Effect Schema
DESCRIPTION: This code snippet defines the clampBigInt function, which takes minimum and maximum bigint values and returns a transform function. The transform function clamps a bigint value within the specified range for a given Schema.

LANGUAGE: typescript
CODE:
declare const clampBigInt: (minimum: bigint, maximum: bigint) => <S extends Schema.Any, A extends bigint>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => transform<S, filter<SchemaClass<A>>>

----------------------------------------

TITLE: Creating Batched Request Resolver in TypeScript
DESCRIPTION: Function signature for makeBatched that constructs a data source from a function handling multiple requests at once. Takes a run function that processes an array of requests and returns an Effect, producing a RequestResolver.

LANGUAGE: typescript
CODE:
declare const makeBatched: <A extends Request.Request<any, any>, R>(run: (requests: NonEmptyArray<A>) => Effect.Effect<void, never, R>) => RequestResolver<A, R>

----------------------------------------

TITLE: Concatenating Lists with List.appendAll in TypeScript
DESCRIPTION: Demonstrates how to concatenate two lists using the List.appendAll function from the Effect library. The function combines elements from both lists while preserving non-emptiness properties. Works with mixed element types.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { List } from "effect"

assert.deepStrictEqual(
  List.make(1, 2).pipe(List.appendAll(List.make("a", "b")), List.toArray),
  [1, 2, "a", "b"]
)

LANGUAGE: typescript
CODE:
declare const appendAll: { <S extends List<any>, T extends List<any>>(that: T): (self: S) => List.OrNonEmpty<S, T, List.Infer<S> | List.Infer<T>>; <A, B>(self: List<A>, that: Cons<B>): Cons<A | B>; <A, B>(self: Cons<A>, that: List<B>): Cons<A | B>; <A, B>(self: List<A>, that: List<B>): List<A | B>; }

----------------------------------------

TITLE: Forking FiberRefs in TypeScript
DESCRIPTION: Function signature for forking a collection of fiber refs with a specified child fiber ID. The function supports both curried and uncurried calling styles. The operation may modify fiber ref values based on the individual refs in the collection.

LANGUAGE: typescript
CODE:
declare const forkAs: { (childId: FiberId.Single): (self: FiberRefs) => FiberRefs; (self: FiberRefs, childId: FiberId.Single): FiberRefs; }

----------------------------------------

TITLE: Checking Success Status of Take Instance in TypeScript
DESCRIPTION: The isSuccess function checks if a given Take instance represents a successful operation. It takes a Take<A, E> as input and returns a boolean indicating whether it's a success or not.

LANGUAGE: typescript
CODE:
declare const isSuccess: <A, E>(self: Take<A, E>) => boolean

----------------------------------------

TITLE: Implementing Conditional Scoped Effect Stream Folding in TypeScript
DESCRIPTION: Defines a function that executes an effectful fold over a stream of values, returning a scoped value representing the stream's scope. The fold operation continues until a specified condition is no longer met. Supports both curried and uncurried function signatures.

LANGUAGE: typescript
CODE:
declare const runFoldWhileScopedEffect: { 
  <S, A, E2, R2>(s: S, cont: Predicate<S>, f: (s: S, a: A) => Effect.Effect<S, E2, R2>): 
    <E, R>(self: Stream<A, E, R>) => Effect.Effect<S, E2 | E, R2 | R | Scope.Scope>; 
  <A, E, R, S, E2, R2>(self: Stream<A, E, R>, s: S, cont: Predicate<S>, f: (s: S, a: A) => Effect.Effect<S, E2, R2>): 
    Effect.Effect<S, E | E2, Scope.Scope | R | R2>; 
}

----------------------------------------

TITLE: Implementing Metric Labels in TypeScript Effect Module
DESCRIPTION: Function signature for labelMetrics that adds MetricLabel objects to effect metrics. It provides two overloads: one taking labels first and another taking the effect first. The labels apply to all metrics within the effect's execution context.

LANGUAGE: typescript
CODE:
declare const labelMetrics: { 
  (labels: Iterable<MetricLabel.MetricLabel>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; 
  <A, E, R>(self: Effect<A, E, R>, labels: Iterable<MetricLabel.MetricLabel>): Effect<A, E, R>; 
}

----------------------------------------

TITLE: Implementing Type Check for Flatten in TypeScript
DESCRIPTION: The isFlatten function is a type guard that checks if the given value is of type Flatten<unknown>. It returns true if the value is a Flatten, false otherwise. This function is useful for runtime type checking and conditional logic based on the Flatten type.

LANGUAGE: typescript
CODE:
declare const isFlatten: (u: unknown) => u is Flatten<unknown>

----------------------------------------

TITLE: Polling from TQueue in TypeScript
DESCRIPTION: The poll function takes a single element from a transactional queue (TDequeue), returning None if the queue is empty. It operates within the STM (Software Transactional Memory) context.

LANGUAGE: typescript
CODE:
declare const poll: <A>(self: TDequeue<A>) => STM.STM<Option.Option<A>>

----------------------------------------

TITLE: Implementing Layer Fallback with orElse in TypeScript
DESCRIPTION: The orElse function executes a layer and returns its output if successful, otherwise executing a specified fallback layer. It supports both curried and uncurried versions, allowing flexibility in usage.

LANGUAGE: typescript
CODE:
declare const orElse: { <A2, E2, R2>(that: LazyArg<Layer<A2, E2, R2>>): <A, E, R>(self: Layer<A, E, R>) => Layer<A & A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Layer<A, E, R>, that: LazyArg<Layer<A2, E2, R2>>): Layer<A & A2, E | E2, R | R2>; }

----------------------------------------

TITLE: Retrieving First Entry of TArray in TypeScript
DESCRIPTION: The headOption function returns the first entry of a TArray if it exists. It returns an STM (Software Transactional Memory) of an Option containing the first element of type A. This function is useful when you need to safely access the first element of a potentially empty array in a transactional context.

LANGUAGE: typescript
CODE:
declare const headOption: <A>(self: TArray<A>) => STM.STM<Option.Option<A>>

----------------------------------------

TITLE: Implementing MergeLeft Type Operation in TypeScript
DESCRIPTION: Demonstrates how to use the MergeLeft type utility to merge two object types where the properties of the left object take precedence in case of conflicts. The example shows merging an object with number properties with another object containing a string property.

LANGUAGE: typescript
CODE:
import type { Types } from "effect"
type MergeLeft = Types.MergeLeft<{ a: number, b: number; }, { a: string }> // { a: number; b: number; }

LANGUAGE: typescript
CODE:
type MergeLeft<Source, Target> = MergeRight<Target, Source>

----------------------------------------

TITLE: TypeScript Function Signature for BigInt Multiplication
DESCRIPTION: The function signature for the multiplyAll function in the Effect library's BigInt module. It shows that the function accepts an Iterable of bigints and returns a single bigint.

LANGUAGE: typescript
CODE:
declare const multiplyAll: (collection: Iterable<bigint>) => bigint

----------------------------------------

TITLE: Declaring DateTimeInsert Model in TypeScript
DESCRIPTION: Declares a constant DateTimeInsert of type DateTimeInsert. This model represents a date-time field that is automatically set to the current UTC time upon insertion, serialized as a string in the database, and omitted from updates but available for selection.

LANGUAGE: typescript
CODE:
declare const DateTimeInsert: DateTimeInsert

----------------------------------------

TITLE: Implementing Column-Based Document Layout in TypeScript
DESCRIPTION: Examples demonstrating how to use Doc.column to create column-aware document layouts. Shows both simple column position detection and more complex indentation with column tracking.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import * as String from "effect/String"

// Example 1:
const example1 = Doc.column((l) =>
  Doc.hsep([Doc.text("Columns are"), Doc.text(`${l}-based`)])
)

assert.strictEqual(
  Doc.render(example1, { style: "pretty" }),
  "Columns are 0-based"
)

// Example 2:
const doc = Doc.hsep([
  Doc.text("prefix"),
  Doc.column((l) => Doc.text(`| <- column ${l}`))
])

const example2 = Doc.vsep([0, 4, 8].map((n) => Doc.indent(n)(doc)))

assert.strictEqual(
  Doc.render(example2, { style: "pretty" }),
  String.stripMargin(
    `|prefix | <- column 7
     |    prefix | <- column 11
     |        prefix | <- column 15`
  )
)

----------------------------------------

TITLE: Demonstrating Doc.align Usage in TypeScript
DESCRIPTION: This code snippet demonstrates the usage of Doc.align combinator, comparing aligned and unaligned document layouts. It shows how alignment affects the positioning of vsep-ed documents.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import * as String from "effect/String"

// As an example, the documents below will be placed one above the other
// regardless of the current nesting level

// Without `align`ment, the second line is simply placed below everything
// that has been laid out so far
const unaligned = Doc.hsep([
  Doc.text("lorem"),
  Doc.vsep([Doc.text("ipsum"), Doc.text("dolor")])
])

assert.strictEqual(
  Doc.render(unaligned, { style: "pretty" }),
  String.stripMargin(
    `|lorem ipsum
     |dolor`
  )
)

// With `align`ment, the `vsep`ed documents all start at the same column
const aligned = Doc.hsep([
  Doc.text("lorem"),
  Doc.align(Doc.vsep([Doc.text("ipsum"), Doc.text("dolor")]))
])

assert.strictEqual(
  Doc.render(aligned, { style: "pretty" }),
  String.stripMargin(
    `|lorem ipsum
     |      dolor`
  )
)

----------------------------------------

TITLE: Defining Contravariant Type in TypeScript
DESCRIPTION: Defines a Contravariant helper type that takes a type parameter A and returns a function type that accepts A and returns void. This is used for contravariant type relationships in the Effect library.

LANGUAGE: typescript
CODE:
type Contravariant<A> = (_: A) => void

----------------------------------------

TITLE: Declaring ANSI Cursor Save Position Function in TypeScript
DESCRIPTION: Declares a constant cursorSavePosition of type Ansi. This function saves the cursor position, encoding shift state, and formatting attributes in the terminal.

LANGUAGE: typescript
CODE:
declare const cursorSavePosition: Ansi

----------------------------------------

TITLE: Type Guard Function for Command Objects in TypeScript
DESCRIPTION: A type guard function that checks if a value is a Command object. Returns true if the input is a Command, false otherwise. This helps with type narrowing in TypeScript.

LANGUAGE: typescript
CODE:
declare const isCommand: (u: unknown) => u is Command

----------------------------------------

TITLE: Function Signature for BigDecimal sum operation in TypeScript
DESCRIPTION: Provides the TypeScript function signature for the sum operation on BigDecimal values. The function is overloaded to accept parameters in different orders.

LANGUAGE: typescript
CODE:
declare const sum: { (that: BigDecimal): (self: BigDecimal) => BigDecimal; (self: BigDecimal, that: BigDecimal): BigDecimal; }

----------------------------------------

TITLE: Defining NonNegativeInt Schema in TypeScript
DESCRIPTION: Declares a constant NonNegativeInt as a refined type of number, based on the NonNegative type. This type represents non-negative integers, excluding positive infinity.

LANGUAGE: typescript
CODE:
declare const NonNegativeInt: refine<number, typeof NonNegative>

----------------------------------------

TITLE: Retrieving FiberRef Set in TypeScript using Effect Package
DESCRIPTION: The fiberRefs function takes a FiberRefs collection and returns a HashSet of FiberRef instances. It's used to get a set of all FiberRefs in the collection.

LANGUAGE: typescript
CODE:
declare const fiberRefs: (self: FiberRefs) => HashSet.HashSet<FiberRef.FiberRef<any>>

----------------------------------------

TITLE: Implementing Stream Error Handling with orElseEither in TypeScript
DESCRIPTION: Defines the orElseEither function that switches to an alternative stream when the original stream fails, wrapping the results in an Either type. Takes a lazy argument for the fallback stream and returns a new stream that produces Either values containing either the original or fallback stream results.

LANGUAGE: typescript
CODE:
declare const orElseEither: {
  <A2, E2, R2>(that: LazyArg<Stream<A2, E2, R2>>): <A, E, R>(self: Stream<A, E, R>) => Stream<Either.Either<A2, A>, E2, R2 | R>;
  <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: LazyArg<Stream<A2, E2, R2>>): Stream<Either.Either<A2, A>, E2, R | R2>;
}

----------------------------------------

TITLE: Creating a Stream from an Iterator Using repeatEffectOption in TypeScript
DESCRIPTION: This example demonstrates how to use Stream.repeatEffectOption to create a stream from an iterator. It repeatedly calls the iterator's next() method, succeeding with each value until the iterator is exhausted.

LANGUAGE: typescript
CODE:
import { Stream, Effect, Option } from "effect"

const drainIterator = <A>(it: Iterator<A>): Stream.Stream<A> =>
  Stream.repeatEffectOption(
    Effect.sync(() => it.next()).pipe(
      Effect.andThen((res) => {
        if (res.done) {
          return Effect.fail(Option.none())
        }
        return Effect.succeed(res.value)
      })
    )
  )

----------------------------------------

TITLE: Doc.words Function Signature in TypeScript
DESCRIPTION: Provides the TypeScript signature for the Doc.words function. It takes a string and an optional character to split on, returning an array of Doc objects.

LANGUAGE: typescript
CODE:
declare const words: (s: string, char?: string) => ReadonlyArray<Doc<never>>

----------------------------------------

TITLE: Type Checking DocStream in TypeScript
DESCRIPTION: Type guard function that determines if a given DocStream is specifically a LineStream type. Returns a boolean indicating whether the input stream is a LineStream instance.

LANGUAGE: typescript
CODE:
declare const isLineStream: <A>(self: DocStream<A>) => self is LineStream<A>

----------------------------------------

TITLE: Flattening Nested Causes in TypeScript
DESCRIPTION: Function that flattens a nested Cause<Cause<E>> structure into a single Cause<E>. Used to simplify nested cause structures that may result from multiple transformations or compositions.

LANGUAGE: typescript
CODE:
declare const flatten: <E>(self: Cause<Cause<E>>) => Cause<E>

----------------------------------------

TITLE: Implementing Reverse Iterator for RedBlackTree in TypeScript
DESCRIPTION: Defines a function that returns an iterator to traverse RedBlackTree entries in reverse order where keys are less than a specified value. The function supports both curried and non-curried invocation patterns.

LANGUAGE: typescript
CODE:
declare const lessThanReversed: { <K>(key: K): <V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>; <K, V>(self: RedBlackTree<K, V>, key: K): Iterable<[K, V]>; }

----------------------------------------

TITLE: Defining File Parsing Argument in Effect CLI (TypeScript)
DESCRIPTION: Creates a file argument that reads and parses its contents. It can optionally take a configuration object to customize the argument name, which defaults to "file".

LANGUAGE: typescript
CODE:
declare const fileParse: (config?: Args.FormatArgsConfig | undefined) => Args<unknown>

----------------------------------------

TITLE: Demonstrating Pattern Matching with Match.whenOr in TypeScript
DESCRIPTION: This example illustrates how to use Match.whenOr for handling different error types in a concise manner. It defines an ErrorType union and creates a handler function that matches against different error patterns.

LANGUAGE: typescript
CODE:
import { Match } from "effect"

type ErrorType =
  | { readonly _tag: "NetworkError"; readonly message: string }
  | { readonly _tag: "TimeoutError"; readonly duration: number }
  | { readonly _tag: "ValidationError"; readonly field: string }

const handleError = Match.type<ErrorType>().pipe(
  Match.whenOr(
    { _tag: "NetworkError" },
    { _tag: "TimeoutError" },
    () => "Retry the request"
  ),
  Match.when({ _tag: "ValidationError" }, (_) => `Invalid field: ${_.field}`),
  Match.exhaustive
)

console.log(handleError({ _tag: "NetworkError", message: "No connection" }))
// Output: "Retry the request"

console.log(handleError({ _tag: "ValidationError", field: "email" }))
// Output: "Invalid field: email"

----------------------------------------

TITLE: Defining File Schema Parameter - TypeScript
DESCRIPTION: Creates a parameter that expects a file path, reads the file contents, and validates them using a provided Schema. Supports multiple file formats including JSON, YAML, INI, and TOML.

LANGUAGE: typescript
CODE:
declare const fileSchema: <I, A>(name: string, schema: Schema<A, I, FileSystem | Path | Terminal>, format?: "json" | "yaml" | "ini" | "toml" | undefined) => Options<A>

----------------------------------------

TITLE: Defining eraseLines Function in TypeScript for Ansi Module
DESCRIPTION: This code snippet defines the eraseLines function in the Ansi module. It takes a number of rows as input and returns an Ansi object. The function is used to erase a specified number of rows from the current cursor position upwards.

LANGUAGE: typescript
CODE:
declare const eraseLines: (rows: number) => Ansi

----------------------------------------

TITLE: Order.tuple Type Signature Example
DESCRIPTION: Shows a simplified type signature of how Order.tuple transforms an array of Orders into an Order of tuple

LANGUAGE: text
CODE:
[Order<A>, Order<B>, ...] -> Order<[A, B, ...]>

----------------------------------------

TITLE: Transforming Exit Success Values to Void in TypeScript
DESCRIPTION: A utility function that maps the Success value of an Exit type to void while maintaining the error type. This is useful when you want to discard the success value but preserve the exit structure and error handling.

LANGUAGE: typescript
CODE:
declare const asVoid: <A, E>(self: Exit<A, E>) => Exit<void, E>

----------------------------------------

TITLE: Filtering and Mapping Trie Entries in TypeScript
DESCRIPTION: Demonstrates how to use the filterMap function to transform and filter entries in a Trie data structure. The function maps over entries using a partial function and removes None values.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Trie, Equal, Option } from "effect"

const trie = Trie.empty<number>().pipe(
  Trie.insert("shells", 0),
  Trie.insert("sells", 1),
  Trie.insert("she", 2)
)

const trieMapV = Trie.empty<number>().pipe(
  Trie.insert("she", 2)
)

const trieMapK = Trie.empty<number>().pipe(
  Trie.insert("shells", 0),
  Trie.insert("sells", 1)
)

assert.equal(Equal.equals(Trie.filterMap(trie, (v) => v > 1 ? Option.some(v) : Option.none()), trieMapV), true)
assert.equal(
  Equal.equals(Trie.filterMap(trie, (v, k) => k.length > 3 ? Option.some(v) : Option.none()), trieMapK),
  true
)

----------------------------------------

TITLE: Creating Synchronous Config Values in Effect-TS
DESCRIPTION: A function that constructs a Config instance containing a specified lazy value. The function takes a LazyArg<A> parameter and returns a Config<A>.

LANGUAGE: typescript
CODE:
declare const sync: <A>(value: LazyArg<A>) => Config<A>

----------------------------------------

TITLE: Decrementing BigInt Values in TypeScript
DESCRIPTION: Demonstrates how to use the decrement function to subtract 1n from a BigInt value. The function takes a BigInt parameter and returns a new BigInt value decremented by 1.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { decrement } from "effect/BigInt"

assert.deepStrictEqual(decrement(3n), 2n)

LANGUAGE: typescript
CODE:
declare const decrement: (n: bigint) => bigint

----------------------------------------

TITLE: Checking UpstreamPullRequest Type in TypeScript
DESCRIPTION: A type guard function that determines if a given value is an UpstreamPullRequest. It takes an unknown value as input and returns a boolean indicating whether the value is an UpstreamPullRequest of unknown type.

LANGUAGE: typescript
CODE:
declare const isUpstreamPullRequest: (u: unknown) => u is UpstreamPullRequest<unknown>

----------------------------------------

TITLE: Calculating DateTime Distance in Effect Framework TypeScript
DESCRIPTION: Demonstrates how to calculate the millisecond difference between two DateTime values. The function returns a positive number if the 'other' DateTime is after 'self', making it useful for duration calculations.

LANGUAGE: typescript
CODE:
import { DateTime, Effect } from "effect"

Effect.gen(function* () {
  const now = yield* DateTime.now
  const other = DateTime.add(now, { minutes: 1 })

  // returns 60000
  DateTime.distance(now, other)
})

LANGUAGE: typescript
CODE:
declare const distance: { (other: DateTime): (self: DateTime) => number; (self: DateTime, other: DateTime): number; }

----------------------------------------

TITLE: Running Effect Into Mailbox - TypeScript Implementation
DESCRIPTION: Defines a function that executes an Effect into a Mailbox where success completes the mailbox and failure fails it. Returns an Effect that resolves to a boolean indicating the operation result.

LANGUAGE: typescript
CODE:
declare const into: { 
  <A, E>(self: Mailbox<A, E>): <AX, EX extends E, RX>(effect: Effect<AX, EX, RX>) => Effect<boolean, never, RX>; 
  <AX, E, EX extends E, RX, A>(effect: Effect<AX, EX, RX>, self: Mailbox<A, E>): Effect<boolean, never, RX>; 
}

----------------------------------------

TITLE: Defining singleQuoted Function in TypeScript for @effect/printer Doc Module
DESCRIPTION: This snippet defines the singleQuoted function, which takes a Doc<A> as input and returns a new Doc<A> enclosed in single quotes. The function is part of the Doc module in the @effect/printer package.

LANGUAGE: typescript
CODE:
declare const singleQuoted: <A>(self: Doc<A>) => Doc<A>

----------------------------------------

TITLE: Enabling All RuntimeFlags in TypeScript
DESCRIPTION: The enableAll function enables all RuntimeFlags in a specified set. It can be called with either one or two arguments, allowing for flexible usage patterns.

LANGUAGE: typescript
CODE:
declare const enableAll: { (flags: RuntimeFlags): (self: RuntimeFlags) => RuntimeFlags; (self: RuntimeFlags, flags: RuntimeFlags): RuntimeFlags; }

----------------------------------------

TITLE: Defining orDieWith Function for Channel Error Handling in TypeScript
DESCRIPTION: The orDieWith function is used to handle errors in a Channel. It keeps none of the errors and terminates the fiber with them, using a specified function to convert the OutErr into a defect. This function is overloaded to accept arguments in different orders.

LANGUAGE: typescript
CODE:
declare const orDieWith: {
  <OutErr>(f: (e: OutErr) => unknown): <OutElem, InElem, InErr, OutDone, InDone, Env>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>
  ) => Channel<OutElem, InElem, never, InErr, OutDone, InDone, Env>;
  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(
    self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,
    f: (e: OutErr) => unknown
  ): Channel<OutElem, InElem, never, InErr, OutDone, InDone, Env>;
}

----------------------------------------

TITLE: Implementing forEach Function for Iterables in TypeScript
DESCRIPTION: Function signature for forEach implementation that takes a callback function and an Iterable. The callback receives each item and its index, executing a void operation for each element. Supports both curried and uncurried forms of invocation.

LANGUAGE: typescript
CODE:
declare const forEach: {
  <A>(f: (a: A, i: number) => void): (self: Iterable<A>) => void;
  <A>(self: Iterable<A>, f: (a: A, i: number) => void): void;
}

----------------------------------------

TITLE: Combining FiberIds in TypeScript
DESCRIPTION: The combineAll function takes a HashSet of FiberIds and combines them into a single FiberId. This function is part of the FiberId module in the effect package.

LANGUAGE: typescript
CODE:
declare const combineAll: (fiberIds: HashSet.HashSet<FiberId>) => FiberId

----------------------------------------

TITLE: Retrieving Queue Size in Effect TQueue
DESCRIPTION: Function to get the current size of a transactional queue. Returns the number of elements in the queue, which can be negative if fibers are suspended waiting for elements to be added. Works with both TDequeue and TEnqueue types.

LANGUAGE: typescript
CODE:
declare const size: <A>(self: TDequeue<A> | TEnqueue<A>) => STM.STM<number>

----------------------------------------

TITLE: Implementing Pipeable String Matching in TypeScript
DESCRIPTION: Defines a type signature for a pipeable string matching function that takes a RegExp or string pattern and returns a function that processes a string input, returning an Option of RegExpMatchArray.

LANGUAGE: typescript
CODE:
declare const match: (regexp: RegExp | string) => (self: string) => Option.Option<RegExpMatchArray>

----------------------------------------

TITLE: Implementing Pipeable String Matching in TypeScript
DESCRIPTION: Defines a type signature for a pipeable string matching function that takes a RegExp or string pattern and returns a function that processes a string input, returning an Option of RegExpMatchArray.

LANGUAGE: typescript
CODE:
declare const match: (regexp: RegExp | string) => (self: string) => Option.Option<RegExpMatchArray>

----------------------------------------

TITLE: Retrieving Keys from TMap - TypeScript Effect
DESCRIPTION: Function signature for retrieving all keys stored in a TMap data structure. Returns an STM operation that resolves to an array of keys. The operation is part of the Effect library's transactional memory system.

LANGUAGE: typescript
CODE:
declare const keys: <K, V>(self: TMap<K, V>) => STM.STM<Array<K>>

----------------------------------------

TITLE: Implementing Minimum Semigroup Function in TypeScript
DESCRIPTION: Creates a Semigroup instance that combines elements by selecting the minimum value according to a given Order type class. The function takes an Order<A> parameter and returns a Semigroup<A> that can be used to combine elements by keeping the minimum value.

LANGUAGE: typescript
CODE:
declare const min: <A>(O: Order<A>) => Semigroup<A>

----------------------------------------

TITLE: Implementing filterMapWhileEffect in TypeScript Stream Module
DESCRIPTION: Defines a function that transforms stream elements using a partial function that returns optional effects. The transformation continues as long as the partial function is defined. The function supports both curried and uncurried calling patterns.

LANGUAGE: typescript
CODE:
declare const filterMapWhileEffect: {
  <A, A2, E2, R2>(pf: (a: A) => Option.Option<Effect.Effect<A2, E2, R2>>): <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>;
  <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, pf: (a: A) => Option.Option<Effect.Effect<A2, E2, R2>>): Stream<A2, E | E2, R | R2>;
}

----------------------------------------

TITLE: Splitting Array with Predicate in TypeScript using effect Library
DESCRIPTION: The splitWhere function splits an iterable into two arrays based on the first element that matches a given predicate. It returns a tuple with the first array containing elements before the match, and the second array containing elements from the match onward.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const result = Array.splitWhere([1, 2, 3, 4, 5], n => n > 3)
console.log(result) // [[1, 2, 3], [4, 5]]

LANGUAGE: typescript
CODE:
declare const splitWhere: { <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => [beforeMatch: Array<A>, fromMatch: Array<A>]; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): [beforeMatch: Array<A>, fromMatch: Array<A>]; }

----------------------------------------

TITLE: Implementing PageWidth Type Check in TypeScript
DESCRIPTION: Type guard function that checks if an unknown value is of type PageWidth. This function is used for runtime type checking in the Effect printer package.

LANGUAGE: typescript
CODE:
declare const isPageWidth: (u: unknown) => u is PageWidth

----------------------------------------

TITLE: Implementing Lazy Stream Construction in TypeScript using Effect
DESCRIPTION: The 'suspend' function creates a lazily constructed stream. It takes a LazyArg that produces a Stream and returns a new Stream with the same type parameters. This allows for deferred stream creation, which can be useful for performance optimization or handling circular dependencies.

LANGUAGE: typescript
CODE:
declare const suspend: <A, E, R>(stream: LazyArg<Stream<A, E, R>>) => Stream<A, E, R>

----------------------------------------

TITLE: Defining CurrentAddress Class in TypeScript
DESCRIPTION: Declares a CurrentAddress class that serves as a Context.Tag for accessing the current entity address in the Effect cluster system. This is a core component for entity management and addressing.

LANGUAGE: typescript
CODE:
declare class CurrentAddress

----------------------------------------

TITLE: Defining takeRight Function in TypeScript for Chunk Module
DESCRIPTION: Declares a function takeRight that takes the last n elements from a Chunk. It can be called with either the number of elements first, or the Chunk first. The function is generic, working with Chunks of any type A.

LANGUAGE: typescript
CODE:
declare const takeRight: { (n: number): <A>(self: Chunk<A>) => Chunk<A>; <A>(self: Chunk<A>, n: number): Chunk<A>; }

----------------------------------------

TITLE: Implementing EnsureCommonBase Utility Type in TypeScript
DESCRIPTION: This code snippet defines a utility type 'EnsureCommonBase' that checks if all brands in a given set have the same base type. It uses conditional types and mapped types to perform the check.

LANGUAGE: typescript
CODE:
type EnsureCommonBase<Brands> = {
    [B in keyof Brands]: Brand.Unbranded<Brand.FromConstructor<Brands[0]>> extends
      Brand.Unbranded<Brand.FromConstructor<Brands[B]>>
      ? Brand.Unbranded<Brand.FromConstructor<Brands[B]>> extends Brand.Unbranded<Brand.FromConstructor<Brands[0]>>
        ? Brands[B]
      : Brands[B]
      : "ERROR: All brands should have the same base type"
  }

----------------------------------------

TITLE: Attaching Property Signatures to Schemas in TypeScript
DESCRIPTION: Demonstrates how to use the attachPropertySignature function to add a 'kind' property to Circle and Square schemas, creating a discriminated union Shape schema.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import * as S from "effect/Schema"
import { pipe } from "effect/Function"

const Circle = S.Struct({ radius: S.Number })
const Square = S.Struct({ sideLength: S.Number })
const Shape = S.Union(
  Circle.pipe(S.attachPropertySignature("kind", "circle")),
  Square.pipe(S.attachPropertySignature("kind", "square"))
)

assert.deepStrictEqual(S.decodeSync(Shape)({ radius: 10 }), {
  kind: "circle",
  radius: 10
})

----------------------------------------

TITLE: Defining FiberRefsPatch Type in TypeScript
DESCRIPTION: Defines the FiberRefsPatch type as a union of Empty, Add, Remove, Update, and AndThen variants. This type is used to represent changes in FiberRef values, allowing fibers to apply changes made by a workflow without inheriting all FiberRef values.

LANGUAGE: typescript
CODE:
type FiberRefsPatch = Empty | Add | Remove | Update | AndThen

----------------------------------------

TITLE: Declaring filterOrDie Function in TypeScript for STM Module
DESCRIPTION: Defines the filterOrDie function with multiple overloads. It takes a refinement or predicate function and a defect, and returns a new STM computation that either passes the filter or terminates with the specified defect.

LANGUAGE: typescript
CODE:
declare const filterOrDie: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>, defect: LazyArg<unknown>): <E, R>(self: STM<A, E, R>) => STM<B, E, R>; <A>(predicate: Predicate<NoInfer<A>>, defect: LazyArg<unknown>): <E, R>(self: STM<A, E, R>) => STM<A, E, R>; <A, E, R, B extends A>(self: STM<A, E, R>, refinement: Refinement<A, B>, defect: LazyArg<unknown>): STM<B, E, R>; <A, E, R>(self: STM<A, E, R>, predicate: Predicate<A>, defect: LazyArg<unknown>): STM<A, E, R>; }

----------------------------------------

TITLE: Converting Chunk to Array in TypeScript
DESCRIPTION: This function converts a Chunk into an Array. It preserves the non-empty property, returning a NonEmptyArray if the input is a NonEmptyChunk. The function is generic, working with any type of Chunk.

LANGUAGE: typescript
CODE:
declare const toArray: <S extends Chunk<any>>(self: S) => S extends NonEmptyChunk<any> ? RA.NonEmptyArray<Chunk.Infer<S>> : Array<Chunk.Infer<S>>

----------------------------------------

TITLE: Checking for Reference Type in TypeScript
DESCRIPTION: The isReference function is a type guard that checks if the provided argument is a Reference. It takes an unknown value and returns a boolean indicating whether the value is a Reference of any type.

LANGUAGE: typescript
CODE:
declare const isReference: (u: unknown) => u is Reference<any, any>

----------------------------------------

TITLE: Declaring writeChunk Function in TypeScript for Effect Channel Module
DESCRIPTION: Declares the writeChunk function that writes a Chunk of values to a channel. It takes a Chunk of OutElem type and returns a Channel of OutElem type. This function is part of the Channel module in the Effect library.

LANGUAGE: typescript
CODE:
declare const writeChunk: <OutElem>(outs: Chunk.Chunk<OutElem>) => Channel<OutElem>

----------------------------------------

TITLE: Defining RuntimeFiber Interface in TypeScript
DESCRIPTION: This code snippet defines the RuntimeFiber interface, which extends Fiber<A, E> and Fiber.RuntimeVariance<A, E>. It includes methods for managing fiber state, observers, and context, as well as properties for accessing fiber information.

LANGUAGE: typescript
CODE:
export interface RuntimeFiber<out A, out E = never> extends Fiber<A, E>, Fiber.RuntimeVariance<A, E> {
  get currentOpCount(): number

  getFiberRef<X>(fiberRef: FiberRef<X>): X

  id(): FiberId.Runtime

  readonly status: Effect.Effect<FiberStatus.FiberStatus>

  readonly runtimeFlags: Effect.Effect<RuntimeFlags.RuntimeFlags>

  addObserver(observer: (exit: Exit.Exit<A, E>) => void): void

  removeObserver(observer: (exit: Exit.Exit<A, E>) => void): void

  getFiberRefs(): FiberRefs.FiberRefs

  unsafePoll(): Exit.Exit<A, E> | null

  unsafeInterruptAsFork(fiberId: FiberId.FiberId): void

  get currentContext(): Context<never>

  get currentDefaultServices(): Context<DefaultServices>

  get currentScheduler(): Scheduler

  get currentTracer(): Tracer

  get currentSpan(): AnySpan | undefined

  get currentSupervisor(): Supervisor<unknown>

  readonly [Unify.typeSymbol]?: unknown
  readonly [Unify.unifySymbol]?: RuntimeFiberUnify<this>
  readonly [Unify.ignoreSymbol]?: RuntimeFiberUnifyIgnore
}

----------------------------------------

TITLE: Implementing Channel.flatMap in TypeScript
DESCRIPTION: Function signature for flatMap operation that combines channels sequentially. It takes a channel and a factory function that creates a new channel based on the terminal value of the first channel. The resulting channel performs operations of the first channel followed by operations of the created channel.

LANGUAGE: typescript
CODE:
declare const flatMap: { <OutDone, OutElem1, InElem1, OutErr1, InErr1, OutDone2, InDone1, Env1>(f: (d: OutDone) => Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone2, InDone1, Env1>): <OutElem, InElem, OutErr, InErr, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1 | OutElem, InElem & InElem1, OutErr1 | OutErr, InErr & InErr1, OutDone2, InDone & InDone1, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone2, InDone1, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (d: OutDone) => Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone2, InDone1, Env1>): Channel<OutElem | OutElem1, InElem & InElem1, OutErr | OutErr1, InErr & InErr1, OutDone2, InDone & InDone1, Env | Env1>; }

----------------------------------------

TITLE: Modifying MutableHashMap Entries in TypeScript
DESCRIPTION: Function signature for modifyAt operation that allows setting or removing a key in MutableHashMap using an update function. The function supports both curried and uncurried forms, operating on Option<V> values.

LANGUAGE: typescript
CODE:
declare const modifyAt: { <K, V>(key: K, f: (value: Option.Option<V>) => Option.Option<V>): (self: MutableHashMap<K, V>) => MutableHashMap<K, V>; <K, V>(self: MutableHashMap<K, V>, key: K, f: (value: Option.Option<V>) => Option.Option<V>): MutableHashMap<K, V>; }

----------------------------------------

TITLE: Defining Number Matching Predicate in TypeScript
DESCRIPTION: Declares a constant 'number' as a refinement predicate for matching values of type 'number'. This function can be used to determine if an unknown value is a number.

LANGUAGE: typescript
CODE:
declare const number: Predicate.Refinement<unknown, number>

----------------------------------------

TITLE: Defining MetricKey Interface in TypeScript
DESCRIPTION: Defines the MetricKey interface with properties for name, keyType, description, and tags. It extends MetricKey.Variance, Equal.Equal, and Pipeable interfaces.

LANGUAGE: typescript
CODE:
export interface MetricKey<out Type extends MetricKeyType.MetricKeyType<any, any>>
  extends MetricKey.Variance<Type>, Equal.Equal, Pipeable
{
  readonly name: string
  readonly keyType: Type
  readonly description: Option.Option<string>
  readonly tags: ReadonlyArray<MetricLabel.MetricLabel>
}

----------------------------------------

TITLE: Defining URL Schema Class in TypeScript
DESCRIPTION: Declares a schema class URLFromSelf that represents a URL object for type-safe URL handling in the Effect library. This class is part of the Schema module and was introduced in version 3.11.0.

LANGUAGE: typescript
CODE:
declare class URLFromSelf

----------------------------------------

TITLE: Declaring keyof Function in SchemaAST Module (TypeScript)
DESCRIPTION: Declares the keyof function which takes an AST as input and returns an AST. This function is equivalent to the TypeScript type-level keyof operator at runtime.

LANGUAGE: typescript
CODE:
declare const keyof: (ast: AST) => AST

----------------------------------------

TITLE: Subtracting Time Units from DateTime in TypeScript using Effect Library
DESCRIPTION: This code snippet demonstrates how to use the DateTime.subtract function from the Effect library to subtract a specified amount of time from a DateTime object. It includes an example of subtracting 5 minutes from a DateTime instance.

LANGUAGE: typescript
CODE:
import { DateTime } from "effect"

// subtract 5 minutes
DateTime.unsafeMake(0).pipe(
  DateTime.subtract({ minutes: 5 })
)

----------------------------------------

TITLE: Defining Default Chunk Size Constant in TypeScript
DESCRIPTION: Declares a constant that specifies the default chunk size used by various Stream combinators and constructors in the Effect library. This value determines the default size of chunks when processing streams of data.

LANGUAGE: typescript
CODE:
declare const DefaultChunkSize: number

----------------------------------------

TITLE: Implementing Cursor Down Movement in TypeScript with @effect/printer-ansi
DESCRIPTION: Defines a function 'cursorDown' that moves the cursor down by a specified number of lines (default 1) relative to the current position. This function has no effect if the cursor is already at the bottom edge of the screen.

LANGUAGE: typescript
CODE:
declare const cursorDown: (lines?: number) => Ansi

----------------------------------------

TITLE: TypeScript Function Signature for Option.some
DESCRIPTION: This snippet shows the TypeScript function signature for the Option.some function. It takes a generic type A and returns an Option of type A.

LANGUAGE: typescript
CODE:
declare const some: <A>(value: A) => Option<A>

----------------------------------------

TITLE: HashSet.fromIterable Function Signature
DESCRIPTION: Type declaration for the fromIterable function showing it accepts any Iterable of type A and returns a HashSet of the same type.

LANGUAGE: typescript
CODE:
declare const fromIterable: <A>(elements: Iterable<A>) => HashSet<A>

----------------------------------------

TITLE: Creating Discarding Layer from Effect in TypeScript
DESCRIPTION: Function that constructs a Layer from an Effect, discarding the effect's output value. Takes an Effect<X,E,R> as input and returns a Layer<never,E,R> where the output type is never since it's discarded.

LANGUAGE: typescript
CODE:
declare const effectDiscard: <X, E, R>(effect: Effect.Effect<X, E, R>) => Layer<never, E, R>

----------------------------------------

TITLE: Defining Stream.peel Function in TypeScript
DESCRIPTION: Declares the peel function for the Stream module. This function peels off material from a stream to construct a value using a provided Sink, returning both the constructed value and the remaining stream in a scope.

LANGUAGE: typescript
CODE:
declare const peel: { <A2, A, E2, R2>(sink: Sink.Sink<A2, A, A, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect.Effect<[A2, Stream<A, E, never>], E2 | E, Scope.Scope | R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, sink: Sink.Sink<A2, A, A, E2, R2>): Effect.Effect<[A2, Stream<A, E, never>], E | E2, Scope.Scope | R | R2>; }

----------------------------------------

TITLE: Implementing Omit Type Utility in TypeScript SchemaAST
DESCRIPTION: A function that provides runtime equivalent functionality to TypeScript's Omit utility type. It takes an AST object and an array of property keys to remove, returning either a TypeLiteral or Transformation.

LANGUAGE: typescript
CODE:
declare const omit: (ast: AST, keys: ReadonlyArray<PropertyKey>) => TypeLiteral | Transformation

----------------------------------------

TITLE: Implementing Sequential Schedule Composition in TypeScript - Effect Package
DESCRIPTION: Definition of the andThen function that combines two schedules sequentially, merging their outputs into a unified result. The function supports both curried and uncurried forms, allowing flexible composition of schedules while maintaining type safety through generic constraints.

LANGUAGE: typescript
CODE:
declare const andThen: { <Out2, In2, R2>(that: Schedule<Out2, In2, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out2 | Out, In & In2, R2 | R>; <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>): Schedule<Out | Out2, In & In2, R | R2>; }

----------------------------------------

TITLE: Extracting Option Value Type in TypeScript
DESCRIPTION: Demonstrates how to extract the type of a value contained within an Option using the Option.Option.Value type helper. This is useful for type inference and manipulation in TypeScript.

LANGUAGE: typescript
CODE:
import { Option } from "effect"

// Declare an Option holding a string
declare const myOption: Option.Option<string>

// Extract the type of the value within the Option
//
//      ┌─── string
//      ▼
type MyType = Option.Option.Value<typeof myOption>

LANGUAGE: typescript
CODE:
type Value<T> = [T] extends [Option<infer _A>] ? _A : never

----------------------------------------

TITLE: Declaring ANSI Line Erasure Function in TypeScript
DESCRIPTION: Defines a constant function that clears characters from the current cursor position to the start of the current line in an ANSI terminal. The cursor position remains unchanged after the operation.

LANGUAGE: typescript
CODE:
declare const eraseStartLine: AnsiDoc

----------------------------------------

TITLE: Creating DateTime Objects with unsafeMake in TypeScript
DESCRIPTION: Demonstrates various ways to create DateTime objects using the unsafeMake function. The function accepts different input types including Date instances, object literals with date parts, and date strings. Invalid dates will throw an IllegalArgumentException.

LANGUAGE: typescript
CODE:
import { DateTime } from "effect"

// from Date
DateTime.unsafeMake(new Date())

// from parts
DateTime.unsafeMake({ year: 2024 })

// from string
DateTime.unsafeMake("2024-01-01")

LANGUAGE: typescript
CODE:
declare const unsafeMake: <A extends DateTime.Input>(input: A) => DateTime.PreserveZone<A>

----------------------------------------

TITLE: Defining catchAllDefect Function for Error Handling in Micro Effects (TypeScript)
DESCRIPTION: Declares the catchAllDefect function, which catches unexpected errors in Micro effects. It takes a handler function and returns a new Micro effect that can recover from defects. The function has two overloads to support different usage patterns.

LANGUAGE: typescript
CODE:
declare const catchAllDefect: { <E, B, E2, R2>(f: (defect: unknown) => Micro<B, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A | B, E | E2, R | R2>; <A, E, R, B, E2, R2>(self: Micro<A, E, R>, f: (defect: unknown) => Micro<B, E2, R2>): Micro<A | B, E | E2, R | R2>; }

----------------------------------------

TITLE: Converting DateTime to UTC Parts in TypeScript
DESCRIPTION: Function signature for converting a DateTime object into its UTC components. Returns an object containing date and time parts including weekday information.

LANGUAGE: typescript
CODE:
declare const toPartsUtc: (self: DateTime) => DateTime.PartsWithWeekday

----------------------------------------

TITLE: Setting URL Port - TypeScript Effect Platform
DESCRIPTION: Function signature for updating the port of a URL object. Supports both curried and direct invocation patterns. Can accept either string or number port values.

LANGUAGE: typescript
CODE:
declare const setPort: { (port: string | number): (url: URL) => URL; (url: URL, port: string | number): URL; }

----------------------------------------

TITLE: Checking if BigDecimal is Zero in TypeScript
DESCRIPTION: This example demonstrates how to use the isZero function from the BigDecimal module to check if a BigDecimal value is zero. It also shows the usage of the unsafeFromString function to create BigDecimal instances.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { isZero, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(isZero(unsafeFromString("0")), true)
assert.deepStrictEqual(isZero(unsafeFromString("1")), false)

----------------------------------------

TITLE: Checking Empty Chunks in TypeScript with Effect-TS
DESCRIPTION: A utility function that determines whether a Chunk data structure is empty. Takes a Chunk<A> as input and returns a boolean indicating if the chunk contains no elements.

LANGUAGE: typescript
CODE:
declare const isEmpty: <A>(self: Chunk<A>) => boolean

----------------------------------------

TITLE: Getting Chunk Size in TypeScript Effect Library
DESCRIPTION: A function that returns the number of elements contained within a Chunk data structure. Takes a Chunk<A> as input and returns a number representing its size.

LANGUAGE: typescript
CODE:
declare const size: <A>(self: Chunk<A>) => number

----------------------------------------

TITLE: Using Doc.reflow to Format Text in TypeScript
DESCRIPTION: Demonstrates how to use the Doc.reflow function to split a long string into multiple lines with a specified line width. It uses the @effect/printer package to format text and node:assert for validation.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import * as String from "effect/String"

const doc = Doc.reflow(
  "Lorem ipsum dolor sit amet, consectetur adipisicing elit, " +
    "sed do eiusmod tempor incididunt ut labore et dolore magna aliqua."
)

assert.strictEqual(
  Doc.render(doc, {
    style: "pretty",
    options: { lineWidth: 32 }
  }),
  String.stripMargin(
    `|Lorem ipsum dolor sit amet,
     |consectetur adipisicing elit,
     |sed do eiusmod tempor incididunt
     |ut labore et dolore magna
     |aliqua.`
  )
)

----------------------------------------

TITLE: Declaring Cause.interruptors Function in TypeScript
DESCRIPTION: This snippet declares the interruptors function, which takes a Cause<E> as input and returns a HashSet of FiberId instances. It's used to collect all FiberIds responsible for interrupting a fiber, useful for debugging concurrency issues or tracing cancellations.

LANGUAGE: typescript
CODE:
declare const interruptors: <E>(self: Cause<E>) => HashSet.HashSet<FiberId.FiberId>

----------------------------------------

TITLE: Implementing Fibonacci-based Schedule in TypeScript
DESCRIPTION: Creates a schedule that uses Fibonacci sequence for increasing delay intervals. Takes a base duration as input and returns a Schedule object that produces Duration values. Useful for implementing progressive backoff strategies with naturally growing delays.

LANGUAGE: typescript
CODE:
declare const fibonacci: (one: Duration.DurationInput) => Schedule<Duration.Duration>

----------------------------------------

TITLE: Disabling RuntimeFlags in TypeScript
DESCRIPTION: Function signature for disabling specific RuntimeFlags. Supports both curried and uncurried calling styles for disabling a given RuntimeFlag on a RuntimeFlags instance.

LANGUAGE: typescript
CODE:
declare const disable: { (flag: RuntimeFlag): (self: RuntimeFlags) => RuntimeFlags; (self: RuntimeFlags, flag: RuntimeFlag): RuntimeFlags; }

----------------------------------------

TITLE: Defining Success Utility Type for Request in TypeScript
DESCRIPTION: This code snippet defines a utility type named Success that extracts the value type from a Request. It uses conditional types and infer to determine the success type of a given Request.

LANGUAGE: typescript
CODE:
type Success<T> = [T] extends [Request<infer _A, infer _E>] ? _A : never

----------------------------------------

TITLE: Defining filterOrElse Function in TypeScript for STM Module
DESCRIPTION: Declares the filterOrElse function with multiple overloads. It filters STM operations based on a predicate or refinement, supplying an alternative STM operation if the condition fails. The function handles various type combinations and preserves type information.

LANGUAGE: typescript
CODE:
declare const filterOrElse: { <A, B extends A, C, E2, R2>(refinement: Refinement<NoInfer<A>, B>, orElse: (a: NoInfer<A>) => STM<C, E2, R2>): <E, R>(self: STM<A, E, R>) => STM<B | C, E2 | E, R2 | R>; <A, B, E2, R2>(predicate: Predicate<NoInfer<A>>, orElse: (a: NoInfer<A>) => STM<B, E2, R2>): <E, R>(self: STM<A, E, R>) => STM<A | B, E2 | E, R2 | R>; <A, E, R, B extends A, C, E2, R2>(self: STM<A, E, R>, refinement: Refinement<A, B>, orElse: (a: A) => STM<C, E2, R2>): STM<B | C, E | E2, R | R2>; <A, E, R, B, E2, R2>(self: STM<A, E, R>, predicate: Predicate<A>, orElse: (a: A) => STM<B, E2, R2>): STM<A | B, E | E2, R | R2>; }

----------------------------------------

TITLE: Validating Channel Exceptions in TypeScript
DESCRIPTION: A type predicate function that checks whether an unknown value is an instance of ChannelException. Returns true if the value is a ChannelException, false otherwise. This function provides type safety through TypeScript's type guard mechanism.

LANGUAGE: typescript
CODE:
declare const isChannelException: (u: unknown) => u is ChannelException<unknown>

----------------------------------------

TITLE: Implementing Record Union with Semigroup in TypeScript
DESCRIPTION: Demonstrates using getSemigroupUnion to combine two records. When keys exist in both records, values are combined using the provided Semigroup instance. For unique keys, the key-value pairs are included as-is in the result.

LANGUAGE: typescript
CODE:
import * as NumberInstances from "@effect/typeclass/data/Number"
import { getSemigroupUnion } from "@effect/typeclass/data/Record"

console.log(getSemigroupUnion(NumberInstances.MonoidSum).combine({ a: 1 }, { a: 1, b: 3 }))
// { a: 2, b: 3 }

LANGUAGE: typescript
CODE:
declare const getSemigroupUnion: <A>(value: semigroup.Semigroup<A>) => semigroup.Semigroup<Record.ReadonlyRecord<string, A>>

----------------------------------------

TITLE: Converting TSet to Chunk in TypeScript using Effect
DESCRIPTION: Function signature for converting a TSet collection to a Chunk data structure using STM (Software Transactional Memory). Takes a TSet of type A and returns an STM that produces a Chunk containing all elements of type A.

LANGUAGE: typescript
CODE:
declare const toChunk: <A>(self: TSet<A>) => STM.STM<Chunk.Chunk<A>>

----------------------------------------

TITLE: Using discriminatorStartsWith for Pattern Matching in TypeScript
DESCRIPTION: Demonstrates how to use the discriminatorStartsWith function for pattern matching on discriminated unions with hierarchical discriminants. It shows matching values based on a common prefix in the discriminant field.

LANGUAGE: typescript
CODE:
import { Match, pipe } from "effect"

const match = pipe(
  Match.type<{ type: "A" } | { type: "B" } | { type: "A.A" } | {}>(),
  Match.discriminatorStartsWith("type")("A", (_) => 1 as const),
  Match.discriminatorStartsWith("type")("B", (_) => 2 as const),
  Match.orElse((_) => 3 as const)
)

console.log(match({ type: "A" })) // 1
console.log(match({ type: "B" })) // 2
console.log(match({ type: "A.A" })) // 1

----------------------------------------

TITLE: Creating Runtime Promise with FiberHandle in TypeScript
DESCRIPTION: Creates an Effect run function backed by a FiberHandle. The function returns a Promise that resolves with the effect's result. It supports generic type parameters for the environment (R), success type (A), and error type (E).

LANGUAGE: typescript
CODE:
declare const makeRuntimePromise: <R = never, A = unknown, E = unknown>() => Effect.Effect<(<XE extends E, XA extends A>(effect: Effect.Effect<XA, XE, R>, options?: Runtime.RunForkOptions | undefined) => Promise<XA>), never, Scope.Scope | R>

----------------------------------------

TITLE: Defining Micro Interface in TypeScript
DESCRIPTION: Defines the Micro interface that extends Effect type with specific type parameters for output (A), error (E), and requirements (R). Includes type variance, iterator implementation, and unification symbols.

LANGUAGE: typescript
CODE:
export interface Micro<out A, out E = never, out R = never> extends Effect<A, E, R> {
  readonly [TypeId]: Micro.Variance<A, E, R>
  [Symbol.iterator](): MicroIterator<Micro<A, E, R>>
  [Unify.typeSymbol]?: unknown
  [Unify.unifySymbol]?: MicroUnify<this>
  [Unify.ignoreSymbol]?: MicroUnifyIgnore
}

----------------------------------------

TITLE: Implementing greaterThan Filter in TypeScript Schema
DESCRIPTION: A filter function that validates whether a number is greater than a specified minimum value. Takes an exclusiveMinimum parameter and optional annotations, returning a filter function that can be applied to Schema types.

LANGUAGE: typescript
CODE:
declare const greaterThan: <S extends Schema.Any>(exclusiveMinimum: number, annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>

----------------------------------------

TITLE: Declaring Config.option Function in TypeScript
DESCRIPTION: Defines a function that converts a Config<A> into a Config<Option<A>>. The resulting config will be None if data is missing from configuration, and Some otherwise.

LANGUAGE: typescript
CODE:
declare const option: <A>(self: Config<A>) => Config<Option.Option<A>>

----------------------------------------

TITLE: Function Signature for Random.choice in TypeScript
DESCRIPTION: This code block shows the TypeScript signature for the Random.choice function. It accepts an iterable and returns an Effect that resolves to a random element from the input. The return type varies based on the input type, handling non-empty iterables, arrays, and regular iterables differently.

LANGUAGE: typescript
CODE:
declare const choice: <Self extends Iterable<unknown>>(elements: Self) => Self extends NonEmptyIterable.NonEmptyIterable<infer A> ? Effect.Effect<A> : Self extends Array.NonEmptyReadonlyArray<infer A> ? Effect.Effect<A> : Self extends Iterable<infer A> ? Effect.Effect<A, Cause.NoSuchElementException> : never

----------------------------------------

TITLE: Implementing Stream.unwrapScopedWith in TypeScript
DESCRIPTION: Function that creates a stream from a scope-based effect. It takes a function that receives a Scope and returns an Effect containing a Stream. The resulting stream will emit a single element upon successful execution of the effect.

LANGUAGE: typescript
CODE:
declare const unwrapScopedWith: <A, E2, R2, E, R>(f: (scope: Scope.Scope) => Effect.Effect<Stream<A, E2, R2>, E, R>) => Stream<A, E | E2, R | R2>

----------------------------------------

TITLE: Implementing Boolean MonoidSome in TypeScript
DESCRIPTION: Defines a boolean monoid under disjunction. The empty value is false. This is part of the @effect/typeclass package in the Boolean module.

LANGUAGE: typescript
CODE:
declare const MonoidSome: monoid.Monoid<boolean>

----------------------------------------

TITLE: Implementing Boolean MonoidEqv in TypeScript
DESCRIPTION: Defines a boolean monoid under equivalence where the empty value is true. This implementation is part of the @effect/typeclass package's Boolean module.

LANGUAGE: typescript
CODE:
declare const MonoidEqv: monoid.Monoid<boolean>

----------------------------------------

TITLE: Type Checking BigDecimal in TypeScript
DESCRIPTION: Defines a function to check if a given value is a BigDecimal. This type guard function takes an unknown input and returns a boolean indicating whether the input is a BigDecimal.

LANGUAGE: typescript
CODE:
declare const isBigDecimal: (u: unknown) => u is BigDecimal

----------------------------------------

TITLE: Defining CloseLatch Interface in TypeScript for @effect/platform WorkerRunner
DESCRIPTION: This code snippet defines the CloseLatch interface used by platform runners to signal that a worker has been closed. It contains a readonly property with a unique symbol type to ensure type safety and prevent accidental implementation.

LANGUAGE: typescript
CODE:
export interface CloseLatch {
  readonly _: unique symbol
}

----------------------------------------

TITLE: Checking Take Failure State in TypeScript
DESCRIPTION: Function signature for checking if a Take instance represents a failure state. Takes a Take<A, E> parameter and returns a boolean indicating if it's a failure.

LANGUAGE: typescript
CODE:
declare const isFailure: <A, E>(self: Take<A, E>) => boolean

----------------------------------------

TITLE: Defining SingletonAddress Class in TypeScript
DESCRIPTION: Declares the SingletonAddress class which represents a unique address for a singleton within the cluster. This class is part of the @effect/cluster package and is used for singleton identification.

LANGUAGE: typescript
CODE:
declare class SingletonAddress

----------------------------------------

TITLE: Using Schema.Struct.Field in TypeScript with Effect Library
DESCRIPTION: This snippet demonstrates how to use the Schema.Struct.Field type to create a function that omits a field from a struct schema. It imports the Schema module from effect and defines a function that takes a Schema.Struct with specific fields and returns a new schema with the 'a' field omitted.

LANGUAGE: typescript
CODE:
import { Schema } from "effect"

const f = <Fields extends Record<"a" | "b", Schema.Struct.Field>>(
  schema: Schema.Struct<Fields>
) => {
  return schema.omit("a")
}

//      ┌─── Schema.Struct<{ b: typeof Schema.Number; }>
//      ▼
const result = f(Schema.Struct({ a: Schema.String, b: Schema.Number }))

----------------------------------------

TITLE: Type Signature of Option.composeK in TypeScript
DESCRIPTION: Provides the type signature for the Option.composeK function, showing its polymorphic nature and ability to compose functions with different input and output types.

LANGUAGE: typescript
CODE:
declare const composeK: { <B, C>(bfc: (b: B) => Option<C>): <A>(afb: (a: A) => Option<B>) => (a: A) => Option<C>; <A, B, C>(afb: (a: A) => Option<B>, bfc: (b: B) => Option<C>): (a: A) => Option<C>; }

----------------------------------------

TITLE: Implementing STM.dieSync Function in TypeScript
DESCRIPTION: Defines a function that fails a transactional effect with a lazily evaluated defect. It takes a LazyArg parameter that evaluates to the defect value and returns an STM that never succeeds.

LANGUAGE: typescript
CODE:
declare const dieSync: (evaluate: LazyArg<unknown>) => STM<never>

----------------------------------------

TITLE: Using HashSet.isSubset in TypeScript with Effect Library
DESCRIPTION: Demonstrates different ways to check if one HashSet is a subset of another. Includes data-first, data-last (pipeable), and pipe function approaches. The operation has O(n) time complexity and requires both sets to use the same hash and equal functions.

LANGUAGE: typescript
CODE:
// Syntax
import { HashSet, pipe } from "effect"

const set1 = HashSet.make(0, 1)
const set2 = HashSet.make(1, 2)
const set3 = HashSet.make(0, 1, 2)

// with `data-last`, a.k.a. `pipeable` API
pipe(set1, HashSet.isSubset(set2)) // false
pipe(set1, HashSet.isSubset(set3)) // true

// or piped with the pipe function
set1.pipe(HashSet.isSubset(set2)) // false
set1.pipe(HashSet.isSubset(set3)) // true

// or with `data-first` API
HashSet.isSubset(set1, set2) // false
HashSet.isSubset(set1, set3) // true

LANGUAGE: typescript
CODE:
declare const isSubset: { <A>(that: HashSet<A>): (self: HashSet<A>) => boolean; <A>(self: HashSet<A>, that: HashSet<A>): boolean; }

----------------------------------------

TITLE: Checking OpSupervision Runtime Flag in TypeScript
DESCRIPTION: Function that checks if the OpSupervision RuntimeFlag is enabled. Takes a RuntimeFlags object as input and returns a boolean indicating whether the flag is enabled.

LANGUAGE: typescript
CODE:
declare const opSupervision: (self: RuntimeFlags) => boolean

----------------------------------------

TITLE: Splitting Words into Text Documents using Doc.words in TypeScript
DESCRIPTION: Demonstrates how to use Doc.words to split a string into individual Text documents and create a tupled representation. The example shows splitting 'lorem ipsum dolor' and rendering it as a tuple.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"

const doc = Doc.tupled(Doc.words("lorem ipsum dolor"))

assert.strictEqual(
  Doc.render(doc, { style: "pretty" }),
  "(lorem, ipsum, dolor)"
)

----------------------------------------

TITLE: Type Checking Doc Instances in TypeScript
DESCRIPTION: A type guard function that checks if a given unknown value is an instance of Doc. Returns true if the value is a Doc instance, false otherwise. This function provides type safety through TypeScript's type guard mechanism.

LANGUAGE: typescript
CODE:
declare const isDoc: (u: unknown) => u is Doc<unknown>

----------------------------------------

TITLE: Checking Disabled RuntimeFlags in TypeScript
DESCRIPTION: This function checks if a RuntimeFlagsPatch describes a specified RuntimeFlag as disabled. It can be called with either the flag first and the patch second, or vice versa.

LANGUAGE: typescript
CODE:
declare const isDisabled: { (flag: RuntimeFlags.RuntimeFlag): (self: RuntimeFlagsPatch) => boolean; (self: RuntimeFlagsPatch, flag: RuntimeFlags.RuntimeFlag): boolean; }

----------------------------------------

TITLE: Implementing foldLeftEffect Sink in TypeScript
DESCRIPTION: Defines a sink that performs an effectful fold operation on inputs. Takes an initial state and a function that processes each input with the current state to produce a new state wrapped in an Effect.

LANGUAGE: typescript
CODE:
declare const foldLeftEffect: <S, In, E, R>(s: S, f: (s: S, input: In) => Effect.Effect<S, E, R>) => Sink<S, In, In, E, R>

----------------------------------------

TITLE: Implementing foldLeftEffect Sink in TypeScript
DESCRIPTION: Defines a sink that performs an effectful fold operation on inputs. Takes an initial state and a function that processes each input with the current state to produce a new state wrapped in an Effect.

LANGUAGE: typescript
CODE:
declare const foldLeftEffect: <S, In, E, R>(s: S, f: (s: S, input: In) => Effect.Effect<S, E, R>) => Sink<S, In, In, E, R>

----------------------------------------

TITLE: Extracting Left Values from Either Array in TypeScript
DESCRIPTION: Demonstrates how to use Array.getLefts to extract Left values from an Iterable of Either types. The function filters and collects all Left values into an array, ignoring Right values.

LANGUAGE: typescript
CODE:
import { Array, Either } from "effect"

const result = Array.getLefts([Either.right(1), Either.left("err"), Either.right(2)])
console.log(result) // ["err"]

LANGUAGE: typescript
CODE:
declare const getLefts: <T extends Iterable<Either.Either<any, any>>>(self: T) => Array<Either.Either.Left<ReadonlyArray.Infer<T>>>

----------------------------------------

TITLE: Defining acquireUseRelease Function in TypeScript for Resource Management
DESCRIPTION: This function manages the lifecycle of a resource by acquiring it, using it, and then releasing it. It takes three parameters: acquire (to obtain the resource), use (to utilize the resource), and release (to clean up the resource). The function returns a Micro effect that combines these operations.

LANGUAGE: typescript
CODE:
declare const acquireUseRelease: <Resource, E, R, A, E2, R2, E3, R3>(acquire: Micro<Resource, E, R>, use: (a: Resource) => Micro<A, E2, R2>, release: (a: Resource, exit: MicroExit<A, E2>) => Micro<void, E3, R3>) => Micro<A, E | E2 | E3, R | R2 | R3>

----------------------------------------

TITLE: Declaring TimeZoneOffsetFromSelf Class in TypeScript
DESCRIPTION: Defines a class named TimeZoneOffsetFromSelf that describes a schema representing a TimeZone.Offset instance. This class is part of the Schema module in the effect package.

LANGUAGE: typescript
CODE:
declare class TimeZoneOffsetFromSelf

----------------------------------------

TITLE: Using Context.empty in TypeScript with Effect
DESCRIPTION: Demonstrates how to use the Context.empty function from the Effect package to create an empty Context object. The example uses Node.js assert to verify that the returned value is indeed a Context.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Context } from "effect"

assert.strictEqual(Context.isContext(Context.empty()), true)

----------------------------------------

TITLE: DateTime.subtract Function Signature in TypeScript
DESCRIPTION: This code block shows the TypeScript signature for the DateTime.subtract function. It defines the function as accepting a partial DateTime.PartsForMath object and returning a function that can be applied to a DateTime instance, or alternatively, accepting both a DateTime instance and a partial DateTime.PartsForMath object directly.

LANGUAGE: typescript
CODE:
declare const subtract: { (parts: Partial<DateTime.PartsForMath>): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, parts: Partial<DateTime.PartsForMath>): A; }

----------------------------------------

TITLE: Creating JSON Schema with Definitions in TypeScript
DESCRIPTION: Function signature for creating a JSON schema with additional definitions and configuration options. Allows customization of definition paths, top-level reference handling, and additional properties behavior.

LANGUAGE: typescript
CODE:
declare const makeWithDefs: <A, I, R>(schema: Schema.Schema<A, I, R>, options: { readonly defs: Record<string, any>; readonly defsPath?: string | undefined; readonly topLevelReferenceStrategy?: TopLevelReferenceStrategy | undefined; readonly additionalPropertiesStrategy?: AdditionalPropertiesStrategy | undefined; }) => JsonSchema

----------------------------------------

TITLE: TypeScript Signature for setZoneOffset Function
DESCRIPTION: This code block shows the TypeScript signature for the setZoneOffset function. It can be called with either the offset and options first, followed by the DateTime object, or with the DateTime object first, followed by the offset and options.

LANGUAGE: typescript
CODE:
declare const setZoneOffset: { (offset: number, options?: { readonly adjustForTimeZone?: boolean | undefined; }): (self: DateTime) => Zoned; (self: DateTime, offset: number, options?: { readonly adjustForTimeZone?: boolean | undefined; }): Zoned; }

----------------------------------------

TITLE: Linking Spans in Effect Module (TypeScript)
DESCRIPTION: Defines the linkSpanCurrent function for adding span links to the current span. It supports two overloads: one for linking a single span with optional attributes, and another for linking multiple spans.

LANGUAGE: typescript
CODE:
declare const linkSpanCurrent: { (span: Tracer.AnySpan, attributes?: Readonly<Record<string, unknown>> | undefined): Effect<void>; (links: ReadonlyArray<Tracer.SpanLink>): Effect<void>; }

----------------------------------------

TITLE: Concatenating Documents with Line Breaks in Effect-TS
DESCRIPTION: Demonstrates how to use the catWithLine combinator to join two documents with a line break between them. The example shows joining two single characters 'a' and 'b' with a line break, using the Effect-TS printer library.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import { pipe } from "effect/Function"
import * as String from "effect/String"

const doc: Doc.Doc<never> = pipe(
  Doc.char("a"),
  Doc.catWithLine(Doc.char("b"))
)

assert.strictEqual(
  Doc.render(doc, { style: "pretty" }),
  String.stripMargin(
    `|a
     |b`
  )
)

----------------------------------------

TITLE: Defining Schedule.once in TypeScript
DESCRIPTION: Declares a constant 'once' as a Schedule that executes only once with void input, unknown output, and never as the error type. This schedule triggers a single execution and then terminates without repeating.

LANGUAGE: typescript
CODE:
declare const once: Schedule<void, unknown, never>

----------------------------------------

TITLE: Generating Random Integers with TRandom.nextInt in TypeScript
DESCRIPTION: Function signature for generating the next pseudo-random integer using STM (Software Transactional Memory). Returns an STM effect that produces a number value without any error channel.

LANGUAGE: typescript
CODE:
declare const nextInt: STM.STM<number, never, TRandom>

----------------------------------------

TITLE: Using foldWeightedDecompose with Stream
DESCRIPTION: Example showing how to use foldWeightedDecompose to process a stream of numbers with a maximum weight limit of 4, decomposing larger elements into smaller ones. The example demonstrates folding numbers into chunks while respecting the weight constraint.

LANGUAGE: typescript
CODE:
pipe(
  Stream.make(1, 5, 1),
  Stream.transduce(
    Sink.foldWeightedDecompose(
      Chunk.empty<number>(),
      4,
      (n: number) => n,
      (n: number) => Chunk.make(n - 1, 1),
      (acc, el) => pipe(acc, Chunk.append(el))
    )
  ),
  Stream.runCollect
)

----------------------------------------

TITLE: Generating Random Integers in Range using TRandom in TypeScript
DESCRIPTION: The nextIntBetween function returns the next integer within a specified range from a pseudo-random number generator. It takes two parameters: 'low' and 'high' to define the range, and returns an STM (Software Transactional Memory) effect that produces a number.

LANGUAGE: typescript
CODE:
declare const nextIntBetween: (low: number, high: number) => STM.STM<number, never, TRandom>

----------------------------------------

TITLE: Defining URI Component Encoder Function in TypeScript
DESCRIPTION: Type signature for a function that encodes UTF-8 strings into URI components. Returns an Either type that can contain either the encoded string or an EncodeException on failure.

LANGUAGE: typescript
CODE:
declare const encodeUriComponent: (str: string) => Either.Either<string, EncodeException>

----------------------------------------

TITLE: Retrieving Fiber from FiberHandle in TypeScript
DESCRIPTION: Function that retrieves the fiber from a FiberHandle instance. Returns an Option that may contain a RuntimeFiber. This function provides unsafe access to the underlying fiber.

LANGUAGE: typescript
CODE:
declare const unsafeGet: <A, E>(self: FiberHandle<A, E>) => Option.Option<Fiber.RuntimeFiber<A, E>>

----------------------------------------

TITLE: Defining Uppercased String Verification in TypeScript
DESCRIPTION: This function verifies that a string is uppercased. It takes optional annotations and returns a filter function that can be applied to a schema of type string.

LANGUAGE: typescript
CODE:
declare const uppercased: <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>

----------------------------------------

TITLE: Implementing Test Annotation in Effect-TS using TypeScript
DESCRIPTION: Function signature for annotate method that adds annotations to the Effect context. It takes a TestAnnotation key and corresponding value, returning an Effect of void. This allows for type-safe annotation management within test contexts.

LANGUAGE: typescript
CODE:
declare const annotate: <A>(key: TestAnnotation.TestAnnotation<A>, value: A) => Effect.Effect<void>

----------------------------------------

TITLE: Configuring Maximum Test Shrinks in Effect-TS
DESCRIPTION: Defines a configuration effect that specifies the maximum number of shrinking attempts allowed when minimizing failing test cases in property-based testing. This value determines how thoroughly the testing framework will try to reduce complex failing cases to simpler ones.

LANGUAGE: typescript
CODE:
declare const shrinks: Effect.Effect<number, never, never>

----------------------------------------

TITLE: Implementing Stream Fallback Logic in TypeScript
DESCRIPTION: Defines a function that switches to an alternative stream when the current stream is empty. The function is overloaded to handle different type parameter combinations and maintains type safety through generic constraints.

LANGUAGE: typescript
CODE:
declare const orElseIfEmptyStream: {
  <A2, E2, R2>(stream: LazyArg<Stream<A2, E2, R2>>): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2 | E, R2 | R>;
  <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, stream: LazyArg<Stream<A2, E2, R2>>): Stream<A | A2, E | E2, R | R2>;
}

----------------------------------------

TITLE: Defining runForEachWhileScoped Function in TypeScript
DESCRIPTION: Declares the runForEachWhileScoped function, which is similar to Stream.runForEachWhile but returns a scoped effect for controlled finalization order. It takes a predicate function and a stream, returning an Effect that processes stream elements while the predicate holds true.

LANGUAGE: typescript
CODE:
declare const runForEachWhileScoped: { <A, E2, R2>(f: (a: A) => Effect.Effect<boolean, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect.Effect<void, E2 | E, Scope.Scope | R2 | R>; <A, E, R, E2, R2>(self: Stream<A, E, R>, f: (a: A) => Effect.Effect<boolean, E2, R2>): Effect.Effect<void, E | E2, Scope.Scope | R | R2>; }

----------------------------------------

TITLE: Defining MonoidXor for Boolean in TypeScript
DESCRIPTION: Implements a monoid for boolean values under exclusive disjunction (XOR). The empty value is defined as false. This is part of the @effect/typeclass package's Boolean module.

LANGUAGE: typescript
CODE:
declare const MonoidXor: monoid.Monoid<boolean>

----------------------------------------

TITLE: Defining EventGroup Interface in TypeScript
DESCRIPTION: Defines the EventGroup interface with methods for adding events and error schemas. It uses generics to handle different event types and includes TypeScript-specific features like mapped types and conditional types.

LANGUAGE: typescript
CODE:
export interface EventGroup<
  out Events extends Event.Any = never
> extends Pipeable {
  new(_: never): {}

  readonly [TypeId]: TypeId
  readonly events: Record.ReadonlyRecord<string, Events>

  /**
   * Add an `Event` to the `EventGroup`.
   */
  add<
    Tag extends string,
    Payload extends Schema.Schema.Any = typeof Schema.Void,
    Success extends Schema.Schema.Any = typeof Schema.Void,
    Error extends Schema.Schema.All = typeof Schema.Never
  >(options: {
    readonly tag: Tag
    readonly primaryKey: (payload: Schema.Schema.Type<Payload>) => string
    readonly payload?: Payload
    readonly success?: Success
    readonly error?: Error
  }): EventGroup<Events | Event<Tag, Payload, Success, Error>>

  /**
   * Add an error schema to all the events in the `EventGroup`.
   */
  addError<Error extends Schema.Schema.Any>(error: Error): EventGroup<Event.AddError<Events, Error>>
}

----------------------------------------

TITLE: Checking if a Doc is Cat in TypeScript
DESCRIPTION: The isCat function takes a Doc<A> as input and returns a boolean indicating if it is of type Cat<A>. It uses a type predicate to narrow the type if true.

LANGUAGE: typescript
CODE:
declare const isCat: <A>(self: Doc<A>) => self is Cat<A>

----------------------------------------

TITLE: Transforming Take<A, E> to Effect<A, E> in TypeScript
DESCRIPTION: The 'done' function transforms a Take<A, E> to an Effect<A, E>. It returns an Effect that resolves to a Chunk of A values or an Option of an E error.

LANGUAGE: typescript
CODE:
declare const done: <A, E>(self: Take<A, E>) => Effect.Effect<Chunk.Chunk<A>, Option.Option<E>>

----------------------------------------

TITLE: Constructing Annotations Layer in TypeScript
DESCRIPTION: The annotationsLayer function constructs a new Annotations service wrapped in a Layer. It returns a Layer of type Annotations.TestAnnotations.

LANGUAGE: typescript
CODE:
declare const annotationsLayer: () => Layer.Layer<Annotations.TestAnnotations>

----------------------------------------

TITLE: Implementing Array Head Operation in Effect Schema TypeScript
DESCRIPTION: TypeScript type signature for the head operation that extracts the first element from a ReadonlyArray. The operation works with any Schema type and returns a transformed option containing the first element's type if present.

LANGUAGE: typescript
CODE:
declare const head: <S extends Schema.Any, A extends ReadonlyArray<unknown>>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => transform<S, OptionFromSelf<SchemaClass<A[number]>>>

----------------------------------------

TITLE: Defining STM.collect Function in TypeScript
DESCRIPTION: Declares the collect function for the STM module. This function takes a partial function that filters and maps values, and applies it to an STM effect. It can be used in two ways: as a higher-order function or with the effect as the first argument.

LANGUAGE: typescript
CODE:
declare const collect: { <A, A2>(pf: (a: A) => Option.Option<A2>): <E, R>(self: STM<A, E, R>) => STM<A2, E, R>; <A, E, R, A2>(self: STM<A, E, R>, pf: (a: A) => Option.Option<A2>): STM<A2, E, R>; }

----------------------------------------

TITLE: Defining Schema.Data Type Signature in TypeScript
DESCRIPTION: Defines a generic type signature for Schema.Data that handles type-safe data structures. The implementation supports readonly records and arrays with specific type constraints for schema compatibility.

LANGUAGE: typescript
CODE:
declare const Data: <S extends Schema.Any, A extends Readonly<Record<string, unknown>> | ReadonlyArray<unknown>, I extends Readonly<Record<string, unknown>> | ReadonlyArray<unknown>>(value: S & Schema<A & Schema.Type<S>, I & Schema.Encoded<S>, Schema.Context<S>>) => Data<S>

----------------------------------------

TITLE: Defining Channel.drain Function in TypeScript
DESCRIPTION: Declares the drain function for Channel, which creates a new channel that reads and ignores all elements from the upstream output channel, then terminates with the upstream result value. It takes a Channel as input and returns a new Channel with modified type parameters.

LANGUAGE: typescript
CODE:
declare const drain: <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<never, InElem, OutErr, InErr, OutDone, InDone, Env>

----------------------------------------

TITLE: Decoding Hex-Encoded Strings to UTF-8 in TypeScript using Effect
DESCRIPTION: The decodeHexString function takes a hex-encoded string and returns an Either type containing either the decoded UTF-8 string or a DecodeException. It's part of the Encoding module in the Effect package.

LANGUAGE: typescript
CODE:
declare const decodeHexString: (str: string) => Either.Either<string, DecodeException>

----------------------------------------

TITLE: isTupleOf Function Signature
DESCRIPTION: Type signature for the isTupleOf function showing its overloaded versions. It can be called with either the length parameter first or the array first, returning a type predicate for TupleOf.

LANGUAGE: typescript
CODE:
declare const isTupleOf: { <N extends number>(n: N): <T>(self: ReadonlyArray<T>) => self is TupleOf<N, T>; <T, N extends number>(self: ReadonlyArray<T>, n: N): self is TupleOf<N, T>; }

----------------------------------------

TITLE: Creating FiberId - TypeScript Effect Library
DESCRIPTION: Function signature for creating a new FiberId instance. Takes a numeric id and start time in seconds as parameters and returns a FiberId object. Available since version 2.0.0 of the Effect library.

LANGUAGE: typescript
CODE:
declare const make: (id: number, startTimeSeconds: number) => FiberId

----------------------------------------

TITLE: Creating Cookies from Set-Cookie Headers in TypeScript
DESCRIPTION: Function that creates a Cookies object from either a single Set-Cookie header string or an iterable of Set-Cookie header strings. This utility function helps in parsing and handling cookie data in the Effect platform.

LANGUAGE: typescript
CODE:
declare const fromSetCookie: (headers: Iterable<string> | string) => Cookies

----------------------------------------

TITLE: Demonstrating Doc.softLine Usage in TypeScript
DESCRIPTION: Shows how the softLine document behaves differently based on available page width. When space permits, it acts like a space character, but when constrained it introduces a line break.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import * as String from "effect/String"

const doc: Doc.Doc<never> = Doc.hcat([
  Doc.text("lorem ipsum"),
  Doc.softLine,
  Doc.text("dolor sit amet")
])

// Here we have enough space to put everything onto one line
assert.strictEqual(
  Doc.render(doc, {
    style: "pretty",
    options: { lineWidth: 80 }
  }),
  "lorem ipsum dolor sit amet"
)

// If the page width is narrowed to `10`, the layout algorithm will
// introduce a line break
assert.strictEqual(
  Doc.render(Doc.group(doc), {
    style: "pretty",
    options: { lineWidth: 10 }
  }),
  String.stripMargin(
    `|lorem ipsum
     |dolor sit amet`
  )
)

LANGUAGE: typescript
CODE:
declare const softLine: Doc<never>

----------------------------------------

TITLE: Defining Default Layout Options in TypeScript Effect Printer
DESCRIPTION: Defines the default layout options constant that provides standard configuration for layout printing. These options are intended for general use cases where specific formatting requirements are not needed.

LANGUAGE: typescript
CODE:
declare const defaultOptions: Layout.Options

----------------------------------------

TITLE: Declaring ANSI Cursor Hide Control - TypeScript
DESCRIPTION: Defines a constant cursorHide of type AnsiDoc that provides functionality to hide the terminal cursor. This is part of the ANSI terminal control features in the Effect Printer library.

LANGUAGE: typescript
CODE:
declare const cursorHide: AnsiDoc

----------------------------------------

TITLE: Implementing Monoid for Maximum Value in TypeScript
DESCRIPTION: Defines a function 'max' that creates a Monoid for a given Bounded type A. This Monoid returns the last maximum of elements. It requires a Bounded<A> as input and returns a Monoid<A>.

LANGUAGE: typescript
CODE:
declare const max: <A>(B: Bounded<A>) => Monoid<A>

----------------------------------------

TITLE: Joining Multiple Fibers in Effect-TS
DESCRIPTION: Function signature for joinAll that takes an Iterable of Fibers and returns an Effect containing an array of successful completion values. The function will throw a catchable error if any of the fibers have errored, unless the error is from interruption.

LANGUAGE: typescript
CODE:
declare const joinAll: <A, E>(fibers: Iterable<Fiber<A, E>>) => Effect.Effect<Array<A>, E>

----------------------------------------

TITLE: Partitioning HashSet with Predicate in TypeScript
DESCRIPTION: Demonstrates how to partition a HashSet of numbers using a predicate function that checks for even numbers. Shows three different API styles: data-last (pipeable), pipe method, and data-first.

LANGUAGE: typescript
CODE:
import { HashSet, pipe, Predicate } from "effect"

// with `data-last`, a.k.a. `pipeable` API
pipe(
  HashSet.make(0, 1, 2, 3, 4, 5),
  HashSet.partition((n) => n % 2 === 0)
)

// or with the pipe method
HashSet.make(0, 1, 2, 3, 4, 5).pipe(
  HashSet.partition((n) => n % 2 === 0)
)

// or with `data-first` API
HashSet.partition(HashSet.make(0, 1, 2, 3, 4, 5), (n) => n % 2 === 0)

----------------------------------------

TITLE: Implementing Monoid.struct Type Definition in TypeScript
DESCRIPTION: Type definition for the struct function that creates a Monoid for structured data. It takes an object of Monoids as input and returns a new Monoid that operates on objects with corresponding value types. This enables combining structured data types while preserving their properties.

LANGUAGE: typescript
CODE:
declare const struct: <R extends { readonly [x: string]: Monoid<any>; }>(fields: R) => Monoid<{ readonly [K in keyof R]: [R[K]] extends [Monoid<infer A>] ? A : never; }>

----------------------------------------

TITLE: Implementing Cursor Left Movement with AnsiDoc in TypeScript
DESCRIPTION: Function declaration for moving the cursor to the beginning of the current line using ANSI escape codes. This constant provides cursor control functionality as part of the AnsiDoc type system.

LANGUAGE: typescript
CODE:
declare const cursorLeft: AnsiDoc

----------------------------------------

TITLE: Applying OpenAI GenAI Telemetry Attributes to Spans in TypeScript
DESCRIPTION: This function applies specified OpenAI GenAI telemetry attributes to a provided Span object. It can be called in two ways: either by passing options first and then the span, or by passing the span first and then the options. The function mutates the Span object in-place.

LANGUAGE: typescript
CODE:
declare const addGenAIAnnotations: ((options: OpenAiTelemetryAttributeOptions) => (span: Span) => void) & ((span: Span, options: OpenAiTelemetryAttributeOptions) => void)

----------------------------------------

TITLE: Retrieving First Element from ReadonlyArray in TypeScript
DESCRIPTION: The 'head' function gets the first element of a ReadonlyArray, returning an Option type. If the array is empty, it returns None. This function is part of the Array module in the Effect package.

LANGUAGE: typescript
CODE:
declare const head: <A>(self: ReadonlyArray<A>) => Option.Option<A>

----------------------------------------

TITLE: Defining match function for UpstreamPullRequest in TypeScript
DESCRIPTION: Declares the match function for UpstreamPullRequest<A>. It takes options with onPulled and onNoUpstream handlers to fold the UpstreamPullRequest into a value of type Z. The function has two overloads: one for curried usage and another for direct application.

LANGUAGE: typescript
CODE:
declare const match: {
  <A, Z>(options: {
    readonly onPulled: (value: A) => Z;
    readonly onNoUpstream: (activeDownstreamCount: number) => Z;
  }): (self: UpstreamPullRequest<A>) => Z;
  <A, Z>(
    self: UpstreamPullRequest<A>,
    options: {
      readonly onPulled: (value: A) => Z;
      readonly onNoUpstream: (activeDownstreamCount: number) => Z;
    }
  ): Z;
}

----------------------------------------

TITLE: Defining BigDecimal.fromNumber Function in TypeScript
DESCRIPTION: Declares a function that converts a number to a BigDecimal. It throws a RangeError for non-finite numbers and is not recommended for direct conversion of floating point numbers due to potential representation issues.

LANGUAGE: typescript
CODE:
declare const fromNumber: (n: number) => BigDecimal

----------------------------------------

TITLE: Implementing Fiber Join Operation in TypeScript
DESCRIPTION: Defines a join operation that suspends the joining fiber until the target fiber's result is determined. It handles error cases and inner interruptions, allowing for error catching and recovery. The operation works with fibers of generic type parameters A for the result type and E for the error type.

LANGUAGE: typescript
CODE:
declare const join: <A, E>(self: Fiber<A, E>) => Effect.Effect<A, E>

----------------------------------------

TITLE: TupleOfAtLeast Type Signature in TypeScript
DESCRIPTION: Defines the type signature for TupleOfAtLeast, which constructs a tuple with a fixed number of elements N of type T, followed by any number of additional elements of the same type.

LANGUAGE: typescript
CODE:
type [...TupleOf<N, T>, ...T[]] = [...TupleOf<N, T>, ...Array<T>]

----------------------------------------

TITLE: Function Signature for DateTime.setZone in TypeScript
DESCRIPTION: This code block shows the TypeScript function signature for the DateTime.setZone function. It defines two overloads: one that takes the zone and options first, and another that takes the DateTime object first.

LANGUAGE: typescript
CODE:
declare const setZone: { (zone: TimeZone, options?: { readonly adjustForTimeZone?: boolean | undefined; }): (self: DateTime) => Zoned; (self: DateTime, zone: TimeZone, options?: { readonly adjustForTimeZone?: boolean | undefined; }): Zoned; }

----------------------------------------

TITLE: Declaring IllegalArgumentExceptionTypeId Symbol in TypeScript
DESCRIPTION: Declares a unique symbol identifier for the IllegalArgumentException type. This symbol is used to uniquely identify IllegalArgumentException instances, often in scenarios where invalid arguments are supplied to methods expecting specific input.

LANGUAGE: typescript
CODE:
declare const IllegalArgumentExceptionTypeId: unique symbol

----------------------------------------

TITLE: Converting STM Error to Option - TypeScript
DESCRIPTION: Function signature for asSomeError that transforms an STM effect by mapping its error channel to an Option type. This allows handling errors as optional values rather than direct error types.

LANGUAGE: typescript
CODE:
declare const asSomeError: <A, E, R>(self: STM<A, E, R>) => STM<A, Option.Option<E>, R>

----------------------------------------

TITLE: Transforming Channel Input Elements with mapInputIn in TypeScript
DESCRIPTION: Defines a mapInputIn function that creates a new channel by applying a transformation function to the input channel's output elements. The function supports both curried and uncurried calling styles with generic type parameters for input/output elements, errors, and done values.

LANGUAGE: typescript
CODE:
declare const mapInputIn: {
  <InElem0, InElem>(f: (a: InElem0) => InElem): <OutElem, OutErr, InErr, OutDone, InDone, Env>
    (self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) =>
      Channel<OutElem, InElem0, OutErr, InErr, OutDone, InDone, Env>;
  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InElem0>
    (self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,
     f: (a: InElem0) => InElem): Channel<OutElem, InElem0, OutErr, InErr, OutDone, InDone, Env>;
}

----------------------------------------

TITLE: Defining OptionalResult Type in TypeScript
DESCRIPTION: A conditional type that extracts the optional result type from a Request. It uses type inference to obtain the success (A) and error (E) types from a Request, wrapping the success type in an Option and combining with Exit.

LANGUAGE: typescript
CODE:
type OptionalResult<T> = T extends Request<infer A, infer E>
    ? Exit.Exit<Option.Option<A>, E>
    : never

----------------------------------------

TITLE: Defining collectAllWhile Function in TypeScript
DESCRIPTION: Declares the collectAllWhile function which accumulates incoming elements into a chunk as long as they verify a given predicate. It has two overloads: one for refinement and another for predicate.

LANGUAGE: typescript
CODE:
declare const collectAllWhile: { <In, Out extends In>(refinement: Refinement<In, Out>): Sink<Chunk.Chunk<Out>, In, In>; <In>(predicate: Predicate<In>): Sink<Chunk.Chunk<In>, In, In>; }

----------------------------------------

TITLE: Defining groupWith Function for Iterable Grouping in TypeScript
DESCRIPTION: The groupWith function groups equal, consecutive elements of an Iterable into NonEmptyArrays using a provided isEquivalent function. It can be used in two ways: with the isEquivalent function as the first argument, or with the Iterable as the first argument and isEquivalent as the second.

LANGUAGE: typescript
CODE:
declare const groupWith: {
  <A>(isEquivalent: (self: A, that: A) => boolean): (self: Iterable<A>) => Iterable<NonEmptyArray<A>>;
  <A>(self: Iterable<A>, isEquivalent: (self: A, that: A) => boolean): Iterable<NonEmptyArray<A>>;
}

----------------------------------------

TITLE: Implementing Document Annotation Transformation in TypeScript
DESCRIPTION: Function declaration for reAnnotate, which transforms document annotations from type A to type B. The function supports both curried and uncurried calling styles, traversing the entire document tree to apply the transformation.

LANGUAGE: typescript
CODE:
declare const reAnnotate: { <A, B>(f: (a: A) => B): (self: Doc<A>) => Doc<B>; <A, B>(self: Doc<A>, f: (a: A) => B): Doc<B>; }

----------------------------------------

TITLE: Creating and Using FiberHandle in TypeScript with Effect
DESCRIPTION: This snippet demonstrates how to create a FiberHandle and use it to manage fibers. It shows how to run effects on the handle and how the fibers are automatically managed within a scoped context.

LANGUAGE: typescript
CODE:
import { Effect, FiberHandle } from "effect"

Effect.gen(function*() {
  const handle = yield* FiberHandle.make()

  // run some effects
  yield* FiberHandle.run(handle, Effect.never)
  // this will interrupt the previous fiber
  yield* FiberHandle.run(handle, Effect.never)

  yield* Effect.sleep(1000)
}).pipe(
  Effect.scoped // The fiber will be interrupted when the scope is closed
)

----------------------------------------

TITLE: Declaring Spaced Schedule Function in TypeScript
DESCRIPTION: Declares a function that creates a schedule recurring continuously with a specified duration between executions. The function takes a DurationInput parameter and returns a Schedule of numbers.

LANGUAGE: typescript
CODE:
declare const spaced: (duration: Duration.DurationInput) => Schedule<number>

----------------------------------------

TITLE: Defining Doc.Annotated Interface in TypeScript
DESCRIPTION: Defines the Annotated interface extending Doc.Variance<A>. It includes properties for the annotation tag, the annotation itself, and the associated document.

LANGUAGE: typescript
CODE:
export interface Annotated<A> extends Doc.Variance<A> {
  readonly _tag: "Annotated"
  readonly annotation: A
  readonly doc: Doc<A>
}

----------------------------------------

TITLE: Retrieving Test Annotations in TypeScript using Effect
DESCRIPTION: A function that retrieves an annotation of a specified type from a TestAnnotationMap, returning either the annotation value or its default value if none exists. The function supports both curried and uncurried calling patterns.

LANGUAGE: typescript
CODE:
declare const get: (<A>(key: TestAnnotation.TestAnnotation<A>) => (self: TestAnnotationMap) => A) & (<A>(self: TestAnnotationMap, key: TestAnnotation.TestAnnotation<A>) => A)

----------------------------------------

TITLE: Testing Boolean Values with Effect Predicate Module
DESCRIPTION: Demonstrates how to use the isBoolean function to check if a value is of boolean type. The function accepts any value and returns true only if the input is specifically a boolean value.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { isBoolean } from "effect/Predicate"

assert.deepStrictEqual(isBoolean(true), true)

assert.deepStrictEqual(isBoolean("true"), false)

LANGUAGE: typescript
CODE:
declare const isBoolean: (input: unknown) => input is boolean

----------------------------------------

TITLE: Defining embedInput Function in TypeScript for Channel Module
DESCRIPTION: Declares the embedInput function which returns a new channel by connecting an AsyncInputProducer as input. It supports both curried and uncurried versions, allowing flexible usage patterns.

LANGUAGE: typescript
CODE:
declare const embedInput: { <InErr, InElem, InDone>(input: SingleProducerAsyncInput.AsyncInputProducer<InErr, InElem, InDone>): <OutElem, OutErr, OutDone, Env>(self: Channel<OutElem, unknown, OutErr, unknown, OutDone, unknown, Env>) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>; <OutElem, OutErr, OutDone, Env, InErr, InElem, InDone>(self: Channel<OutElem, unknown, OutErr, unknown, OutDone, unknown, Env>, input: SingleProducerAsyncInput.AsyncInputProducer<InErr, InElem, InDone>): Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>; }

----------------------------------------

TITLE: Doc.width Function Signature in TypeScript
DESCRIPTION: The type signature of the Doc.width function, showing its overloaded versions for different use cases.

LANGUAGE: typescript
CODE:
declare const width: { <A, B>(react: (width: number) => Doc<B>): (self: Doc<A>) => Doc<A | B>; <A, B>(self: Doc<A>, react: (width: number) => Doc<B>): Doc<A | B>; }

----------------------------------------

TITLE: Defining orElseSucceed Function in TypeScript for STM Module
DESCRIPTION: Declares the orElseSucceed function, which tries an effect first and if it fails or retries, succeeds with a specified value. It takes a lazy argument for the fallback value and returns a new STM effect.

LANGUAGE: typescript
CODE:
declare const orElseSucceed: { <A2>(value: LazyArg<A2>): <A, E, R>(self: STM<A, E, R>) => STM<A2 | A, never, R>; <A, E, R, A2>(self: STM<A, E, R>, value: LazyArg<A2>): STM<A | A2, never, R>; }

----------------------------------------

TITLE: TypeScript Function Signature for Stream.zipWithIndex
DESCRIPTION: Provides the TypeScript function signature for the Stream.zipWithIndex function. It takes a Stream of type A with error E and environment R, and returns a Stream of tuples containing the original elements and their indices.

LANGUAGE: typescript
CODE:
declare const zipWithIndex: <A, E, R>(self: Stream<A, E, R>) => Stream<[A, number], E, R>

----------------------------------------

TITLE: Creating Done Fiber with Exit Value in TypeScript
DESCRIPTION: Function that creates a Fiber instance that represents a completed computation with a specified Exit value. The function is generic over the success type A and error type E.

LANGUAGE: typescript
CODE:
declare const done: <A, E>(exit: Exit.Exit<A, E>) => Fiber<A, E>

----------------------------------------

TITLE: Declaring MetricPolling.poll Function in TypeScript
DESCRIPTION: Defines the poll function in the MetricPolling module. This function creates an effect that polls a value which can be used for a metric. It takes a MetricPolling object as input and returns an Effect.

LANGUAGE: typescript
CODE:
declare const poll: <Type, In, R, E, Out>(self: MetricPolling<Type, In, R, E, Out>) => Effect.Effect<In, E, R>

----------------------------------------

TITLE: Retrieving Enabled RuntimeFlags from RuntimeFlagsPatch in TypeScript
DESCRIPTION: The enabledSet function takes a RuntimeFlagsPatch as input and returns a ReadonlySet of RuntimeFlags that are enabled in that patch. It's part of the RuntimeFlagsPatch module in the Effect package.

LANGUAGE: TypeScript
CODE:
declare const enabledSet: (self: RuntimeFlagsPatch) => ReadonlySet<RuntimeFlags.RuntimeFlag>

----------------------------------------

TITLE: Defining Doc.char Function Signature in TypeScript
DESCRIPTION: Type definition for Doc.char function that creates a document from a single character. The function accepts a string character input and returns a Doc type that never produces an error. Important constraint: The input character cannot be a newline character ("\n").

LANGUAGE: typescript
CODE:
declare const char: (char: string) => Doc<never>

----------------------------------------

TITLE: Checking PubSub Queue Status in Effect-TS
DESCRIPTION: Type declaration for the isFull function that checks if a PubSub queue contains at least one element. Returns an Effect containing a boolean value indicating the queue status.

LANGUAGE: typescript
CODE:
declare const isFull: <A>(self: PubSub<A>) => Effect.Effect<boolean>

----------------------------------------

TITLE: Defining UnionToIntersection Utility Type in TypeScript
DESCRIPTION: This code snippet defines a utility type called UnionToIntersection that takes a union type T and transforms it into an intersection type. It uses conditional types and inferred type parameters to achieve this transformation.

LANGUAGE: typescript
CODE:
type UnionToIntersection<T> = (T extends any ? (x: T) => any : never) extends (x: infer R) => any ? R : never

----------------------------------------

TITLE: Declaring provideService Function in TypeScript for Effect Library Schedule Module
DESCRIPTION: This code snippet declares the provideService function, which allows supplying a single service dependency to a schedule. It can be used in two ways: either by passing the tag and service first, or by passing the schedule first followed by the tag and service.

LANGUAGE: typescript
CODE:
declare const provideService: { <I, S>(tag: Context.Tag<I, S>, service: Types.NoInfer<S>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, Exclude<R, I>>; <Out, In, R, I, S>(self: Schedule<Out, In, R>, tag: Context.Tag<I, S>, service: Types.NoInfer<S>): Schedule<Out, In, Exclude<R, I>>; }

----------------------------------------

TITLE: Defining flatMap Function for Sink in TypeScript
DESCRIPTION: Defines the flatMap function for the Sink module. It runs a sink until it yields a result, then uses that result to create and run another sink. This allows for sequential execution of sinks.

LANGUAGE: TypeScript
CODE:
declare const flatMap: { <A, A1, In, In1 extends In, L1, E1, R1>(f: (a: A) => Sink<A1, In1, L1, E1, R1>): <L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A1, In & In1, L1 | L, E1 | E, R1 | R>; <A, In, L, E, R, A1, In1 extends In, L1, E1, R1>(self: Sink<A, In, L, E, R>, f: (a: A) => Sink<A1, In1, L1, E1, R1>): Sink<A1, In & In1, L | L1, E | E1, R | R1>; }

----------------------------------------

TITLE: Declaring Empty Cookies Object in TypeScript
DESCRIPTION: Defines an empty Cookies object. This constant represents a Cookies instance with no content, which can be used as a starting point for cookie operations or as a default value.

LANGUAGE: typescript
CODE:
declare const empty: Cookies

----------------------------------------

TITLE: Creating Semigroup Instance with TypeScript
DESCRIPTION: Function to create a Semigroup instance with a required combine operation and an optional combineMany implementation. The combineMany parameter can be customized for performance optimizations, otherwise it uses a standard implementation.

LANGUAGE: typescript
CODE:
declare const make: <A>(combine: Semigroup<A>["combine"], combineMany?: Semigroup<A>["combineMany"]) => Semigroup<A>

----------------------------------------

TITLE: Overriding Context Tag Default Value in TypeScript
DESCRIPTION: Shows how to override the default value of a context tag using Effect.provideService. Demonstrates the flexibility of Context.Reference in allowing custom implementations.

LANGUAGE: typescript
CODE:
import { Context, Effect } from "effect"

class SpecialNumber extends Context.Reference<SpecialNumber>()(
  "SpecialNumber",
  { defaultValue: () => 2048 }
) {}

const program = Effect.gen(function* () {
  const specialNumber = yield* SpecialNumber
  console.log(`The special number is ${specialNumber}`)
})

Effect.runPromise(program.pipe(Effect.provideService(SpecialNumber, -1)))
// Output: The special number is -1

----------------------------------------

TITLE: Adding Parent Span to Stack in TypeScript
DESCRIPTION: The parentSpan function adds a provided span to the span stack. It takes a Tracer.AnySpan as input and returns a Layer of Tracer.ParentSpan. This function is useful for tracing and monitoring in effect-based applications.

LANGUAGE: typescript
CODE:
declare const parentSpan: (span: Tracer.AnySpan) => Layer<Tracer.ParentSpan>

----------------------------------------

TITLE: Using Option.filterMap for Transformation and Filtering in TypeScript
DESCRIPTION: Demonstrates how to use Option.filterMap to transform and filter numbers, converting even numbers into descriptive strings while filtering out odd numbers. The function works with both Some and None variants of Option.

LANGUAGE: typescript
CODE:
import { Option } from "effect"

// Transform and filter numbers
const transformEven = (n: Option.Option<number>): Option.Option<string> =>
  Option.filterMap(n, (n) => (n % 2 === 0 ? Option.some(`Even: ${n}`) : Option.none()))

console.log(transformEven(Option.none()))
// Output: { _id: 'Option', _tag: 'None' }

console.log(transformEven(Option.some(1)))
// Output: { _id: 'Option', _tag: 'None' }

console.log(transformEven(Option.some(2)))
// Output: { _id: 'Option', _tag: 'Some', value: 'Even: 2' }

----------------------------------------

TITLE: Comparing Cron Objects for Equality in TypeScript
DESCRIPTION: This function checks if two Cron objects are equal. It provides two overloaded signatures: one for curried usage and another for direct comparison. The function is part of the Cron module in the Effect package.

LANGUAGE: typescript
CODE:
declare const equals: { (that: Cron): (self: Cron) => boolean; (self: Cron, that: Cron): boolean; }

----------------------------------------

TITLE: Generating Random Boolean in Effect (TypeScript)
DESCRIPTION: Defines a function that returns the next boolean value from a pseudo-random number generator. It's part of the Random module in the Effect package.

LANGUAGE: typescript
CODE:
declare const nextBoolean: Effect.Effect<boolean, never, never>

----------------------------------------

TITLE: Creating Channel from Stream in TypeScript
DESCRIPTION: The toChannel function converts a Stream to a Channel. It takes a Stream of type A with error type E and effect type R, and returns a Channel that emits chunks of A, with the same error and effect types.

LANGUAGE: typescript
CODE:
declare const toChannel: <A, E, R>(stream: Stream<A, E, R>) => Channel.Channel<Chunk.Chunk<A>, unknown, E, unknown, unknown, unknown, R>

----------------------------------------

TITLE: Defining NonEmptyString Refinement in TypeScript
DESCRIPTION: Declares a constant nonEmptyString as a SafeRefinement type that matches non-empty strings. This utility can be used for type-safe string validation in TypeScript applications.

LANGUAGE: typescript
CODE:
declare const nonEmptyString: SafeRefinement<string, never>

----------------------------------------

TITLE: Creating Struct Equivalence in TypeScript using Effect
DESCRIPTION: Demonstrates how to use Struct.getEquivalence to create an Equivalence for comparing person objects based on name and age properties. It uses String.Equivalence and Number.Equivalence for individual property comparisons.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Struct, String, Number } from "effect"

const PersonEquivalence = Struct.getEquivalence({
  name: String.Equivalence,
  age: Number.Equivalence
})

assert.deepStrictEqual(
  PersonEquivalence({ name: "John", age: 25 }, { name: "John", age: 25 }),
  true
)
assert.deepStrictEqual(
  PersonEquivalence({ name: "John", age: 25 }, { name: "John", age: 40 }),
  false
)

----------------------------------------

TITLE: Checking Sequential Cause Type in TypeScript
DESCRIPTION: The isSequentialType function checks if a given Cause is of the Sequential type. It takes a Cause<E> as input and returns a boolean indicating whether it's a Sequential<E>. This function is useful for type narrowing in conditional statements.

LANGUAGE: typescript
CODE:
declare const isSequentialType: <E>(self: Cause<E>) => self is Sequential<E>

----------------------------------------

TITLE: Declaring asSome Function for Micro Effects in TypeScript
DESCRIPTION: The asSome function takes a Micro effect and returns a new Micro effect where the success value is wrapped in a Some option type. It preserves the error type and environment type of the original effect.

LANGUAGE: typescript
CODE:
declare const asSome: <A, E, R>(self: Micro<A, E, R>) => Micro<Option.Option<A>, E, R>

----------------------------------------

TITLE: Implementing Doc Annotation Function in TypeScript
DESCRIPTION: Function signature for annotate that adds an annotation to a Doc object. The function is overloaded to support both curried and direct parameter passing styles. The annotation can be used by rendering algorithms for custom formatting like adding colors.

LANGUAGE: typescript
CODE:
declare const annotate: { <A>(annotation: A): (self: Doc<A>) => Doc<A>; <A>(self: Doc<A>, annotation: A): Doc<A>; }

----------------------------------------

TITLE: Formatting DateTime as UTC ISO String in TypeScript
DESCRIPTION: The formatIso function takes a DateTime object and returns its representation as a UTC ISO string. This function is part of the DateTime module in the Effect package.

LANGUAGE: typescript
CODE:
declare const formatIso: (self: DateTime) => string

----------------------------------------

TITLE: Defining AvailablePerLine Interface in TypeScript for @effect/printer PageWidth Module
DESCRIPTION: This code snippet defines the AvailablePerLine interface, which extends PageWidth.Proto. It includes properties for specifying the maximum line width and the fraction of the page width that can be printed on. This interface is used to inform layout algorithms about space constraints per line.

LANGUAGE: typescript
CODE:
export interface AvailablePerLine extends PageWidth.Proto {
  readonly _tag: "AvailablePerLine"
  /**
   * The number of characters, including whitespace, that can fit on a single
   * line.
   */
  readonly lineWidth: number
  /**
   * The fraction of the total page width that can be printed on. This allows
   * limiting the length of printable text per line. Values must be between
   * `0` and `1` (`0.4` to `1` is typical).
   */
  readonly ribbonFraction: number
}

----------------------------------------

TITLE: Constructing Non-Empty String Config in TypeScript
DESCRIPTION: The nonEmptyString function creates a Config object for non-empty string values. It optionally takes a name parameter and returns a Config<string>. This utility is useful for ensuring that string configurations are not empty.

LANGUAGE: typescript
CODE:
declare const nonEmptyString: (name?: string) => Config<string>

----------------------------------------

TITLE: Schema.parseJson Function Signature in TypeScript
DESCRIPTION: Provides the TypeScript signature for the Schema.parseJson function. It shows the function's overloads, including options for specifying a schema and ParseJsonOptions.

LANGUAGE: typescript
CODE:
declare const parseJson: { <S extends Schema.Any>(schema: S, options?: ParseJsonOptions): transform<SchemaClass<unknown, string>, S>; (options?: ParseJsonOptions): SchemaClass<unknown, string>; }

----------------------------------------

TITLE: Function Signature for DateTime.zoneToString in TypeScript
DESCRIPTION: Provides the TypeScript function signature for the DateTime.zoneToString function, which takes a TimeZone object and returns a string representation.

LANGUAGE: typescript
CODE:
declare const zoneToString: (self: TimeZone) => string

----------------------------------------

TITLE: Mapping STM Success to Optional Value in TypeScript
DESCRIPTION: The asSome function takes an STM effect and maps its success value to an Option type. It preserves the error type and environment type of the original effect.

LANGUAGE: typescript
CODE:
declare const asSome: <A, E, R>(self: STM<A, E, R>) => STM<Option.Option<A>, E, R>

----------------------------------------

TITLE: Implementing Conditional FiberRef Execution in TypeScript
DESCRIPTION: Function signature for whenFiberRef that conditionally executes an effect based on a FiberRef value matching a predicate. Returns the FiberRef value and an optional effect result. Supports both curried and non-curried versions of the function.

LANGUAGE: typescript
CODE:
declare const whenFiberRef: {
  <S>(fiberRef: FiberRef.FiberRef<S>, predicate: Predicate<S>): <A, E, R>(self: Effect<A, E, R>) => Effect<[S, Option.Option<A>], E, R>;
  <A, E, R, S>(self: Effect<A, E, R>, fiberRef: FiberRef.FiberRef<S>, predicate: Predicate<S>): Effect<[S, Option.Option<A>], E, R>;
}

----------------------------------------

TITLE: TypeScript Signature for Option.lift2 Function
DESCRIPTION: Provides the TypeScript type signature for the Option.lift2 function. It shows that the function takes a binary function as input and returns a new function that works with Option values.

LANGUAGE: typescript
CODE:
declare const lift2: <A, B, C>(f: (a: A, b: B) => C) => { (that: Option<B>): (self: Option<A>) => Option<C>; (self: Option<A>, that: Option<B>): Option<C>; }

----------------------------------------

TITLE: Adding End Effect to Stream in TypeScript
DESCRIPTION: Demonstrates how to add an effect to be executed at the end of a stream using Stream.onEnd. The example creates a stream, maps its values, logs intermediary results, and adds an end effect.

LANGUAGE: typescript
CODE:
import { Console, Effect, Stream } from "effect"

const stream = Stream.make(1, 2, 3).pipe(
  Stream.map((n) => n * 2),
  Stream.tap((n) => Console.log(`after mapping: ${n}`)),
  Stream.onEnd(Console.log("Stream ended"))
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// after mapping: 2
// after mapping: 4
// after mapping: 6
// Stream ended
// { _id: 'Chunk', values: [ 2, 4, 6 ] }

----------------------------------------

TITLE: Implementing Reverse Iterator for RedBlackTree in TypeScript
DESCRIPTION: Defines a function that returns an iterator pointing to an element at a specified index in a RedBlackTree, traversing elements in reverse order. The function supports both curried and uncurried calling styles.

LANGUAGE: typescript
CODE:
declare const atReversed: { 
  (index: number): <K, V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>; 
  <K, V>(self: RedBlackTree<K, V>, index: number): Iterable<[K, V]>; 
}

----------------------------------------

TITLE: Executing Synchronous Micro Effects in TypeScript
DESCRIPTION: Function signature for runSyncExit that attempts to execute a Micro effect synchronously. Returns MicroExit on success or CauseDie containing MicroFiber if asynchronous effects are encountered.

LANGUAGE: typescript
CODE:
declare const runSyncExit: <A, E>(effect: Micro<A, E>) => MicroExit<A, E>

----------------------------------------

TITLE: Defining BooleanFromUnknown Schema Type in TypeScript
DESCRIPTION: Declares a class that handles conversion of unknown values to boolean type by evaluating their truthiness using the !! operator. Used for type-safe boolean coercion in the Effect library's schema system.

LANGUAGE: typescript
CODE:
declare class BooleanFromUnknown

----------------------------------------

TITLE: Removing Elements from HashMap in TypeScript
DESCRIPTION: Type signature for removing an entry from a HashMap using a specified key. The function supports both curried and uncurried forms, allowing flexible usage patterns for key-value removal operations.

LANGUAGE: typescript
CODE:
declare const remove: { <K>(key: K): <V>(self: HashMap<K, V>) => HashMap<K, V>; <K, V>(self: HashMap<K, V>, key: K): HashMap<K, V>; }

----------------------------------------

TITLE: Creating Redacted Values with Redacted.make in TypeScript
DESCRIPTION: Demonstrates how to create a Redacted<A> instance that securely hides sensitive content. Commonly used for hiding sensitive information like API keys or credentials in logs or debug output.

LANGUAGE: typescript
CODE:
import { Redacted } from "effect"

const API_KEY = Redacted.make("1234567890")

LANGUAGE: typescript
CODE:
declare const make: <A>(value: A) => Redacted<A>

----------------------------------------

TITLE: Defining ShardingRegistrationEvent Type in TypeScript
DESCRIPTION: Defines a union type ShardingRegistrationEvent that represents events occurring during entity or singleton registration by a runner. It can be either EntityRegistered or SingletonRegistered.

LANGUAGE: typescript
CODE:
type ShardingRegistrationEvent = | EntityRegistered
  | SingletonRegistered

----------------------------------------

TITLE: Implementing STM Effect Matching in TypeScript
DESCRIPTION: Defines a matchSTM function that takes success and failure handlers to fold over an STM effect. The function provides two overloads - one for curried usage and one for direct application. Both handlers must return STM effects.

LANGUAGE: typescript
CODE:
declare const matchSTM: {
  <E, A1, E1, R1, A, A2, E2, R2>(
    options: {
      readonly onFailure: (e: E) => STM<A1, E1, R1>;
      readonly onSuccess: (a: A) => STM<A2, E2, R2>;
    }
  ): <R>(self: STM<A, E, R>) => STM<A1 | A2, E1 | E2, R1 | R2 | R>;
  <A, E, R, A1, E1, R1, A2, E2, R2>(
    self: STM<A, E, R>,
    options: {
      readonly onFailure: (e: E) => STM<A1, E1, R1>;
      readonly onSuccess: (a: A) => STM<A2, E2, R2>;
    }
  ): STM<A1 | A2, E1 | E2, R | R1 | R2>;
}

----------------------------------------

TITLE: Defining encodedBoundSchema Function in TypeScript
DESCRIPTION: Function signature for encodedBoundSchema that takes a Schema with generic types A, I, and R and returns a SchemaClass of type I. This function preserves refinements up to the first transformation point in the original schema.

LANGUAGE: typescript
CODE:
declare const encodedBoundSchema: <A, I, R>(schema: Schema<A, I, R>) => SchemaClass<I>

----------------------------------------

TITLE: Declaring StringFromBase64 Schema Type in TypeScript
DESCRIPTION: Type declaration for a Schema that transforms base64 encoded strings into UTF-8 strings. This schema handles the conversion from base64 (RFC4648) format to regular UTF-8 string representation without potential for errors.

LANGUAGE: typescript
CODE:
declare const StringFromBase64: Schema<string, string, never>

----------------------------------------

TITLE: Demonstrating Array.liftEither Usage in TypeScript
DESCRIPTION: Example showing how to use Array.liftEither to convert a function that returns Either into one that returns an array. The function demonstrates parsing numbers from strings, returning either a single-element array with the parsed number or an empty array for invalid inputs.

LANGUAGE: typescript
CODE:
import { Array, Either } from "effect"

const parseNumber = (s: string): Either.Either<number, Error> =>
  isNaN(Number(s)) ? Either.left(new Error("Not a number")) : Either.right(Number(s))

const liftedParseNumber = Array.liftEither(parseNumber)

const result1 = liftedParseNumber("42")
console.log(result1) // [42]

const result2 = liftedParseNumber("not a number")
console.log(result2) // []

LANGUAGE: typescript
CODE:
declare const liftEither: <A extends Array<unknown>, E, B>(f: (...a: A) => Either.Either<B, E>) => (...a: A) => Array<B>

----------------------------------------

TITLE: Getting Priority Queue Size with STM in TypeScript
DESCRIPTION: A function that returns the size of a TPriorityQueue using Software Transactional Memory (STM). It takes a TPriorityQueue instance as input and returns an STM transaction that resolves to a number representing the queue size.

LANGUAGE: typescript
CODE:
declare const size: <A>(self: TPriorityQueue<A>) => STM.STM<number>

----------------------------------------

TITLE: Declaring splitOnChunk Function in TypeScript
DESCRIPTION: Defines the splitOnChunk function that splits elements on a delimiter and transforms the splits into desired output. It can be used with different parameter orders for flexibility.

LANGUAGE: typescript
CODE:
declare const splitOnChunk: { <A>(delimiter: Chunk.Chunk<A>): <E, R>(self: Stream<A, E, R>) => Stream<Chunk.Chunk<A>, E, R>; <A, E, R>(self: Stream<A, E, R>, delimiter: Chunk.Chunk<A>): Stream<Chunk.Chunk<A>, E, R>; }

----------------------------------------

TITLE: Context.Reference Type Signature in TypeScript
DESCRIPTION: Type signature for the Context.Reference function showing its generic parameters and return type structure.

LANGUAGE: typescript
CODE:
declare const Reference: <Self>() => <const Id extends string, Service>(id: Id, options: { readonly defaultValue: () => Service; }) => ReferenceClass<Self, Id, Service>

----------------------------------------

TITLE: Defining layerContext Layer in NodeHttpServer Module
DESCRIPTION: Declares a constant layerContext as a Layer providing HttpPlatform, FileSystem, Etag.Generator, and Path services. The FileSystem service is a no-op implementation, making this layer suitable for platforms without a file system.

LANGUAGE: typescript
CODE:
declare const layerContext: Layer.Layer<Platform.HttpPlatform | Etag.Generator | NodeContext.NodeContext, never, never>

----------------------------------------

TITLE: Implementing Option.zipRight Function in TypeScript
DESCRIPTION: Defines a function that combines two Option values, keeping only the value from the second Option if both are Some. Returns None if the first Option is None, regardless of the second Option's value. The function supports both curried and uncurried usage patterns.

LANGUAGE: typescript
CODE:
declare const zipRight: { 
  <B>(that: Option<B>): <_>(self: Option<_>) => Option<B>; 
  <X, B>(self: Option<X>, that: Option<B>): Option<B>; 
}

----------------------------------------

TITLE: Testing RegExp Type Check in TypeScript
DESCRIPTION: Demonstrates how to use the RegExp.isRegExp function to check if a value is a RegExp instance. The example shows both positive and negative test cases using node's assert module.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { RegExp } from "effect"

assert.deepStrictEqual(RegExp.isRegExp(/a/), true)
assert.deepStrictEqual(RegExp.isRegExp("a"), false)

----------------------------------------

TITLE: Constructing RequestResolver with makeWithEntry in TypeScript
DESCRIPTION: The makeWithEntry function constructs a data source with a specified identifier and method to run requests. It takes a runAll function as a parameter, which handles an array of request entries and returns an Effect.

LANGUAGE: typescript
CODE:
declare const makeWithEntry: <A, R>(runAll: (requests: Array<Array<Request.Entry<A>>>) => Effect.Effect<void, never, R>) => RequestResolver<A, R>

----------------------------------------

TITLE: Implementing InterruptibleMask in Effect TypeScript
DESCRIPTION: Function signature for interruptibleMask that extends interruptible functionality by providing a restore function to control interruptibility of specific code regions. The restore function can be used to make specific effects interruptible within an otherwise non-interruptible context.

LANGUAGE: typescript
CODE:
declare const interruptibleMask: <A, E, R>(f: (restore: <AX, EX, RX>(effect: Effect<AX, EX, RX>) => Effect<AX, EX, RX>) => Effect<A, E, R>) => Effect<A, E, R>

----------------------------------------

TITLE: Implementing Stream.zipRight in TypeScript Effect Library
DESCRIPTION: Defines a function that zips two streams together point-wise, keeping only the outputs from the right stream. The operation continues until either stream ends. The function supports both curried and uncurried calling styles.

LANGUAGE: typescript
CODE:
declare const zipRight: {
  <AR, ER, RR>(right: Stream<AR, ER, RR>): <AL, EL, RL>(left: Stream<AL, EL, RL>) => Stream<AR, ER | EL, RR | RL>;
  <AL, EL, RL, AR, ER, RR>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>): Stream<AR, EL | ER, RL | RR>;
}

----------------------------------------

TITLE: Defining BaseAttributes Interface for GenAI Telemetry in TypeScript
DESCRIPTION: Defines the base telemetry attributes interface for generative AI systems. The interface includes an optional 'system' property that can be a string, WellKnownSystem, null, or undefined, representing the Generative AI product identifier.

LANGUAGE: typescript
CODE:
export interface BaseAttributes {
    /**
     * The Generative AI product as identified by the client or server
     * instrumentation.
     */
    readonly system?: (string & {}) | WellKnownSystem | null | undefined
  }

----------------------------------------

TITLE: Rendering RuntimeFlagsPatch to String in TypeScript
DESCRIPTION: The render function takes a RuntimeFlagsPatch object and converts it to a string representation. This function is part of the RuntimeFlagsPatch module in the Effect package. It has been available since version 2.0.0 of the package.

LANGUAGE: typescript
CODE:
declare const render: (self: RuntimeFlagsPatch) => string

----------------------------------------

TITLE: Defining TimeZone Schema Class in TypeScript
DESCRIPTION: Declares a TimeZone schema class that handles conversion of strings to TimeZone objects using the DateTime.zoneFromString constructor. This schema is part of the Effect library's Schema module.

LANGUAGE: typescript
CODE:
declare class TimeZone

----------------------------------------

TITLE: Declaring Cause.squashWith Function in TypeScript
DESCRIPTION: Defines the squashWith function, which extracts the most important defect from a Cause, transforming failures into defects using a provided function. It handles failures, defects, and interruptions in a specific order.

LANGUAGE: TypeScript
CODE:
declare const squashWith: { <E>(f: (error: E) => unknown): (self: Cause<E>) => unknown; <E>(self: Cause<E>, f: (error: E) => unknown): unknown; }

----------------------------------------

TITLE: Effect.reduceRight Type Definition
DESCRIPTION: Type signature for the reduceRight function showing its polymorphic nature and support for both curried and non-curried forms. Handles effects with error type E and environment type R.

LANGUAGE: typescript
CODE:
declare const reduceRight: { <A, Z, R, E>(zero: Z, f: (a: A, z: Z, i: number) => Effect<Z, E, R>): (elements: Iterable<A>) => Effect<Z, E, R>; <A, Z, R, E>(elements: Iterable<A>, zero: Z, f: (a: A, z: Z, i: number) => Effect<Z, E, R>): Effect<Z, E, R>; }

----------------------------------------

TITLE: Creating Linear Histogram Boundaries in TypeScript
DESCRIPTION: Helper method that generates histogram bucket boundaries with linear spacing. Takes options object with start value, width between buckets, and number of buckets to create. Returns a MetricBoundaries object containing the generated boundary values.

LANGUAGE: typescript
CODE:
declare const linear: (options: { readonly start: number; readonly width: number; readonly count: number; }) => MetricBoundaries

----------------------------------------

TITLE: Creating Cookies with makeCookie Function in TypeScript
DESCRIPTION: Function signature for creating a new cookie with name, value, and optional configuration. Returns an Either type that can contain either a valid Cookie or a CookiesError.

LANGUAGE: typescript
CODE:
declare const makeCookie: (name: string, value: string, options?: Cookie["options"] | undefined) => Either.Either<Cookie, CookiesError>

----------------------------------------

TITLE: TypeScript Function Signature for Option.exists
DESCRIPTION: Provides the TypeScript function signature for the Option.exists function, showing its polymorphic nature and support for both predicates and refinements.

LANGUAGE: typescript
CODE:
declare const exists: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: Option<A>) => self is Option<B>; <A>(predicate: Predicate<NoInfer<A>>): (self: Option<A>) => boolean; <A, B extends A>(self: Option<A>, refinement: Refinement<A, B>): self is Option<B>; <A>(self: Option<A>, predicate: Predicate<A>): boolean; }

----------------------------------------

TITLE: Implementing Conditional Fallback for Configuration in TypeScript
DESCRIPTION: The `orElseIf` function provides a way to create a configuration that reads from the primary source but falls back to an alternative if an error occurs that satisfies a specified predicate. It's useful for implementing conditional fallback logic in configuration management.

LANGUAGE: typescript
CODE:
declare const orElseIf: {
  <A2>(
    options: {
      readonly if: Predicate<ConfigError.ConfigError>;
      readonly orElse: LazyArg<Config<A2>>;
    }
  ): <A>(self: Config<A>) => Config<A>;
  <A, A2>(
    self: Config<A>,
    options: {
      readonly if: Predicate<ConfigError.ConfigError>;
      readonly orElse: LazyArg<Config<A2>>;
    }
  ): Config<A>;
}

----------------------------------------

TITLE: Defining whileInput Function in TypeScript for Schedule Module
DESCRIPTION: Declares the whileInput function that takes a predicate and a schedule, returning a new schedule that continues execution while the predicate is true for the input. It supports both curried and uncurried forms.

LANGUAGE: typescript
CODE:
declare const whileInput: { <In>(f: Predicate<In>): <Out, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R>(self: Schedule<Out, In, R>, f: Predicate<In>): Schedule<Out, In, R>; }

----------------------------------------

TITLE: Prepending Elements to Arrays in TypeScript using Effect Library
DESCRIPTION: Demonstrates the usage of Array.prepend function to add an element to the front of an Iterable, creating a new NonEmptyArray. The function takes an iterable and a new element as arguments, returning a new array with the element prepended.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const result = Array.prepend([2, 3, 4], 1)
console.log(result) // [1, 2, 3, 4]

LANGUAGE: typescript
CODE:
declare const prepend: { <B>(head: B): <A>(self: Iterable<A>) => NonEmptyArray<A | B>; <A, B>(self: Iterable<A>, head: B): NonEmptyArray<A | B>; }

----------------------------------------

TITLE: Function Signature for 'implies' in Predicate Module
DESCRIPTION: This code block shows the TypeScript function signature for the 'implies' function in the Predicate module. It defines the types and overloads for the function.

LANGUAGE: typescript
CODE:
declare const implies: { <A>(consequent: Predicate<A>): (antecedent: Predicate<A>) => Predicate<A>; <A>(antecedent: Predicate<A>, consequent: Predicate<A>): Predicate<A>; }

----------------------------------------

TITLE: Trie.has Function Signature in TypeScript
DESCRIPTION: Provides the TypeScript function signature for the Trie.has function. It shows two overloads: one for curried usage and another for direct application.

LANGUAGE: typescript
CODE:
declare const has: { (key: string): <V>(self: Trie<V>) => boolean; <V>(self: Trie<V>, key: string): boolean; }

----------------------------------------

TITLE: Marking HashMap as Immutable in TypeScript
DESCRIPTION: The endMutation function is used to mark a HashMap as immutable. It takes a mutable HashMap and returns an immutable version of it. This function is part of the HashMap module in the effect package.

LANGUAGE: typescript
CODE:
declare const endMutation: <K, V>(self: HashMap<K, V>) => HashMap<K, V>

----------------------------------------

TITLE: Adding BigDecimals using sum function in TypeScript
DESCRIPTION: Demonstrates how to use the sum function to add two BigDecimal values. The example imports necessary functions, creates BigDecimal instances, and performs addition.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { sum, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(sum(unsafeFromString("2"), unsafeFromString("3")), unsafeFromString("5"))

----------------------------------------

TITLE: Adding Multiple Cookies to Cookies Object in TypeScript
DESCRIPTION: The setAllCookie function is used to add multiple cookies to a Cookies object. It can be called with the cookies as the first argument and the Cookies object as the second, or vice versa. The function returns a new Cookies object with the added cookies.

LANGUAGE: typescript
CODE:
declare const setAllCookie: { (cookies: Iterable<Cookie>): (self: Cookies) => Cookies; (self: Cookies, cookies: Iterable<Cookie>): Cookies; }

----------------------------------------

TITLE: Executing Workflows with Test Live Service in TypeScript
DESCRIPTION: The withLive function allows executing a specified workflow with a custom implementation of the live service. It can be used in two ways: as a higher-order function or by directly passing the effect and live service.

LANGUAGE: typescript
CODE:
declare const withLive: ((live: Live.TestLive) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>) & (<A, E, R>(effect: Effect.Effect<A, E, R>, live: Live.TestLive) => Effect.Effect<A, E, R>)

----------------------------------------

TITLE: Formatting TimeZones as Strings in TypeScript using Effect
DESCRIPTION: Demonstrates how to use the DateTime.zoneToString function to format TimeZone objects as strings. It shows examples for both offset-based and named time zones.

LANGUAGE: typescript
CODE:
import { DateTime, Effect } from "effect"

// Outputs "+03:00"
DateTime.zoneToString(DateTime.zoneMakeOffset(3 * 60 * 60 * 1000))

// Outputs "Europe/London"
DateTime.zoneToString(DateTime.zoneUnsafeMakeNamed("Europe/London"))

----------------------------------------

TITLE: Setting FiberRef Values in Effect Module (TypeScript)
DESCRIPTION: Defines the setFiberRefs function which sets the FiberRef values for the fiber running an effect to the values in a specified collection of FiberRef values. It takes a FiberRefs.FiberRefs parameter and returns an Effect<void>.

LANGUAGE: typescript
CODE:
declare const setFiberRefs: (fiberRefs: FiberRefs.FiberRefs) => Effect<void>

----------------------------------------

TITLE: Intersecting Intervals in TypeScript using Effect's ScheduleInterval
DESCRIPTION: Defines a function 'intersect' that computes the intersection of two Interval objects. It can be called with either curried or uncurried syntax. The function is part of the ScheduleInterval module in the Effect package.

LANGUAGE: typescript
CODE:
declare const intersect: { (that: Interval): (self: Interval) => Interval; (self: Interval, that: Interval): Interval; }

----------------------------------------

TITLE: Declaring jitteredWith Function in TypeScript for Schedule Module
DESCRIPTION: This code snippet defines the jitteredWith function, which returns a new schedule with randomly adjusted interval sizes. It allows customization of the minimum and maximum multipliers for the jitter range, defaulting to 0.8 and 1.2 respectively if not specified.

LANGUAGE: typescript
CODE:
declare const jitteredWith: { (options: { min?: number | undefined; max?: number | undefined; }): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R>(self: Schedule<Out, In, R>, options: { min?: number | undefined; max?: number | undefined; }): Schedule<Out, In, R>; }

----------------------------------------

TITLE: Function Signature for headNonEmpty in TypeScript
DESCRIPTION: This code block shows the TypeScript function signature for the headNonEmpty function. It takes a NonEmptyReadonlyArray<A> as input and returns an element of type A.

LANGUAGE: typescript
CODE:
declare const headNonEmpty: <A>(self: NonEmptyReadonlyArray<A>) => A

----------------------------------------

TITLE: Testing Function Type in TypeScript using effect/Predicate
DESCRIPTION: Demonstrates how to use the isFunction predicate from the effect/Predicate module to check if a value is a function. It includes an example usage and the type signature of the isFunction predicate.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { isFunction } from "effect/Predicate"

assert.deepStrictEqual(isFunction(isFunction), true)

assert.deepStrictEqual(isFunction("function"), false)

LANGUAGE: typescript
CODE:
declare const isFunction: (input: unknown) => input is Function

----------------------------------------

TITLE: BigInt.clamp Function Signature in TypeScript
DESCRIPTION: Provides the TypeScript signature for the BigInt.clamp function. It shows that the function can be called with options first and then the bigint value, or with the bigint value first followed by the options.

LANGUAGE: typescript
CODE:
declare const clamp: { (options: { minimum: bigint; maximum: bigint; }): (self: bigint) => bigint; (self: bigint, options: { minimum: bigint; maximum: bigint; }): bigint; }

----------------------------------------

TITLE: Creating Generic Tags in TypeScript using Effect Context Module
DESCRIPTION: Demonstrates how to create and compare GenericTag instances using the Context module. The example shows that identical keys create tags with matching key properties.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Context } from "effect"

assert.strictEqual(Context.GenericTag("PORT").key === Context.GenericTag("PORT").key, true)

LANGUAGE: typescript
CODE:
declare const GenericTag: <Identifier, Service = Identifier>(key: string) => Tag<Identifier, Service>

----------------------------------------

TITLE: Generating Next Pseudo-Random Number in TypeScript
DESCRIPTION: The 'next' function is part of the TRandom module and returns the next number from a pseudo-random number generator. It uses the STM (Software Transactional Memory) type for its implementation.

LANGUAGE: typescript
CODE:
declare const next: STM.STM<number, never, TRandom>

----------------------------------------

TITLE: Defining AsyncInputConsumer Interface in TypeScript
DESCRIPTION: Defines the AsyncInputConsumer interface with a generic takeWith method. This method takes three callback functions to handle errors, elements, and completion, returning an Effect.

LANGUAGE: typescript
CODE:
export interface AsyncInputConsumer<out Err, out Elem, out Done> {
  takeWith<A>(
    onError: (cause: Cause.Cause<Err>) => A,
    onElement: (element: Elem) => A,
    onDone: (value: Done) => A
  ): Effect.Effect<A>
}

----------------------------------------

TITLE: Constructing ScopedCache with Custom Parameters in TypeScript
DESCRIPTION: The makeWith function creates a new cache with specified capacity, time to live, and lookup function. The time to live can depend on the Exit value returned by the lookup function. It returns an Effect that produces a ScopedCache.

LANGUAGE: typescript
CODE:
declare const makeWith: <Key, Value, Error = never, Environment = never>(options: { readonly capacity: number; readonly lookup: Lookup<Key, Value, Error, Environment>; readonly timeToLive: (exit: Exit.Exit<Value, Error>) => Duration.DurationInput; }) => Effect.Effect<ScopedCache<Key, Value, Error>, never, Scope.Scope | Environment>

----------------------------------------

TITLE: Inverting Ordering Values in TypeScript
DESCRIPTION: Demonstrates how to use the reverse function to invert ordering values (1, -1, 0). The function takes an Ordering value and returns its inverse, where 1 becomes -1, -1 becomes 1, and 0 remains unchanged.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { reverse } from "effect/Ordering"

assert.deepStrictEqual(reverse(1), -1)
assert.deepStrictEqual(reverse(-1), 1)
assert.deepStrictEqual(reverse(0), 0)

LANGUAGE: typescript
CODE:
declare const reverse: (o: Ordering) => Ordering

----------------------------------------

TITLE: Channel.provideService TypeScript Type Definition
DESCRIPTION: Type definition for the provideService function which provides a single required service to an effect within a channel. This function offers two overloads - one where the service and tag are provided separately, and another where they're provided along with the channel instance.

LANGUAGE: typescript
CODE:
declare const provideService: {
  <I, S>(tag: Context.Tag<I, S>, service: Types.NoInfer<S>): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>
    (self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) =>
      Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Exclude<Env, I>>;
  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, I, S>
    (self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,
     tag: Context.Tag<I, S>,
     service: Types.NoInfer<S>): Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Exclude<Env, I>>;
}

----------------------------------------

TITLE: Implementing Sink Collection with Effect Predicate in TypeScript
DESCRIPTION: Function that creates a Sink which accumulates incoming elements into a Chunk until a provided effectful predicate returns true. Takes a predicate function that returns an Effect of boolean and returns a Sink that processes elements of type In.

LANGUAGE: typescript
CODE:
declare const collectAllUntilEffect: <In, E, R>(p: (input: In) => Effect.Effect<boolean, E, R>) => Sink<Chunk.Chunk<In>, In, In, E, R>

----------------------------------------

TITLE: Schema.Struct.Field Type Definition in TypeScript
DESCRIPTION: This snippet shows the type definition of Schema.Struct.Field. It is defined as a union type of Schema.All and PropertySignature.All, indicating that it can represent either a schema or a property signature.

LANGUAGE: typescript
CODE:
type Field = | Schema.All
    | PropertySignature.All

----------------------------------------

TITLE: Declaring yieldNow Function in TypeScript
DESCRIPTION: Declares the yieldNow function, which pauses the execution of the current Micro effect and resumes it on the next scheduler tick. It returns a Micro effect that resolves to void and never produces an error or failure.

LANGUAGE: typescript
CODE:
declare const yieldNow: Micro<void, never, never>

----------------------------------------

TITLE: Defining Schema.Defect Class in TypeScript
DESCRIPTION: Declares the Schema.Defect class for handling JavaScript errors and other defects. It provides functionality for decoding objects into Error instances and encoding Error instances into plain objects, which is useful for error serialization across network boundaries.

LANGUAGE: typescript
CODE:
declare class Defect

----------------------------------------

TITLE: Implementing String Non-Empty Check in TypeScript
DESCRIPTION: TypeScript function signature for checking if a string is non-empty. Takes a string parameter and returns a boolean indicating if the string has any characters.

LANGUAGE: typescript
CODE:
declare const isNonEmpty: (self: string) => boolean

----------------------------------------

TITLE: Defining taggedWithLabelsInput Function in TypeScript for Effect Metric Module
DESCRIPTION: Declares a function that returns a new metric with dynamic tags added based on update values. The returned metric doesn't provide useful information due to the dynamic nature of the added tags. It takes a function that generates MetricLabel iterables from input and applies it to the existing metric.

LANGUAGE: typescript
CODE:
declare const taggedWithLabelsInput: { <In>(f: (input: In) => Iterable<MetricLabel.MetricLabel>): <Type, Out>(self: Metric<Type, In, Out>) => Metric<Type, In, void>; <Type, In, Out>(self: Metric<Type, In, Out>, f: (input: In) => Iterable<MetricLabel.MetricLabel>): Metric<Type, In, void>; }

----------------------------------------

TITLE: Declaring fromAST Function for JSON Schema Generation in TypeScript
DESCRIPTION: This snippet defines the signature of the fromAST function, which generates a JSON Schema from an AST (Abstract Syntax Tree). It includes options for customizing the output schema, such as definitions, target specification, and handling of references and additional properties.

LANGUAGE: typescript
CODE:
declare const fromAST: (ast: AST.AST, options: { readonly definitions: Record<string, JsonSchema7>; readonly definitionPath?: string | undefined; readonly target?: Target | undefined; readonly topLevelReferenceStrategy?: TopLevelReferenceStrategy | undefined; readonly additionalPropertiesStrategy?: AdditionalPropertiesStrategy | undefined; }) => JsonSchema7

----------------------------------------

TITLE: Stream.tick Function Signature in TypeScript
DESCRIPTION: This snippet shows the TypeScript signature for the Stream.tick function. It takes a DurationInput parameter and returns a Stream of void values.

LANGUAGE: typescript
CODE:
declare const tick: (interval: Duration.DurationInput) => Stream<void>

----------------------------------------

TITLE: Setting URL href in TypeScript using Effect Platform
DESCRIPTION: A function that replaces the entire URL string. Provides both curried and uncurried versions for flexibility in usage. Takes a URL object and href string as parameters and returns a modified URL object.

LANGUAGE: typescript
CODE:
declare const setHref: { (href: string): (url: URL) => URL; (url: URL, href: string): URL; }

----------------------------------------

TITLE: Converting Effect Stream to ReadableStream in TypeScript
DESCRIPTION: Function signature for converting a Stream to a ReadableStream using Effect. Accepts optional queuing strategy parameter for controlling stream behavior. Returns an Effect containing a ReadableStream.

LANGUAGE: typescript
CODE:
declare const toReadableStreamEffect: { 
  <A>(options?: { readonly strategy?: QueuingStrategy<A> | undefined; }): 
    <E, R>(self: Stream<A, E, R>) => Effect.Effect<ReadableStream<A>, never, R>; 
  <A, E, R>(self: Stream<A, E, R>, options?: { readonly strategy?: QueuingStrategy<A> | undefined; }): 
    Effect.Effect<ReadableStream<A>, never, R>; 
}

----------------------------------------

TITLE: Retrieving First Element from NonEmptyChunk - TypeScript
DESCRIPTION: Function definition for headNonEmpty that returns the first element of a non-empty chunk data structure. Takes a NonEmptyChunk<A> as input and returns a value of type A.

LANGUAGE: typescript
CODE:
declare const headNonEmpty: <A>(self: NonEmptyChunk<A>) => A

----------------------------------------

TITLE: Option.flatMap Function Signature in TypeScript
DESCRIPTION: The type signature of the Option.flatMap function, showing its overloaded forms for both curried and non-curried usage with generic types.

LANGUAGE: typescript
CODE:
declare const flatMap: { <A, B>(f: (a: A) => Option<B>): (self: Option<A>) => Option<B>; <A, B>(self: Option<A>, f: (a: A) => Option<B>): Option<B>; }

----------------------------------------

TITLE: Converting Effect with NoSuchElementException to Effect with Option in TypeScript
DESCRIPTION: This snippet demonstrates how to use Effect.optionFromOptional to convert an effect that might fail with NoSuchElementException into an effect that succeeds with an Option. It shows examples with both Some and None cases.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

//      ┌─── Effect<number, NoSuchElementException, never>
//      ▼
const maybe1 = Effect.fromNullable(1)

//      ┌─── Effect<Option<number>, never, never>
//      ▼
const option1 = Effect.optionFromOptional(maybe1)

Effect.runPromise(option1).then(console.log)
// Output: { _id: 'Option', _tag: 'Some', value: 1 }

//      ┌─── Effect<number, NoSuchElementException, never>
//      ▼
const maybe2 = Effect.fromNullable(null as number | null)

//      ┌─── Effect<Option<number>, never, never>
//      ▼
const option2 = Effect.optionFromOptional(maybe2)

Effect.runPromise(option2).then(console.log)
// Output: { _tag: 'None' }

----------------------------------------

TITLE: Releasing Write Lock in TReentrantLock - TypeScript
DESCRIPTION: Function signature for releasing a write lock held by a fiber. Returns an STM effect that resolves to the number of remaining write locks held by the fiber after release.

LANGUAGE: typescript
CODE:
declare const releaseWrite: (self: TReentrantLock) => STM.STM<number>

----------------------------------------

TITLE: Implementing Strict Equality Comparison in TypeScript
DESCRIPTION: Defines a generic function that returns an Equivalence type for comparing values using strict equality (===). This utility enables type-safe equality comparisons for any type A.

LANGUAGE: typescript
CODE:
declare const strict: <A>() => Equivalence<A>

----------------------------------------

TITLE: Implementing Effect Micro Yield Function in TypeScript
DESCRIPTION: Definition of yieldNowWith function that pauses the execution of the current Micro effect and resumes it on the next scheduler tick. Takes an optional priority parameter and returns a Micro<void>.

LANGUAGE: typescript
CODE:
declare const yieldNowWith: (priority?: number) => Micro<void>

----------------------------------------

TITLE: Retrieving a Fiber from FiberMap in TypeScript
DESCRIPTION: The unsafeGet function is used to retrieve a fiber from a FiberMap. It takes a key and returns an Option of a RuntimeFiber. This function is overloaded to allow for different parameter orderings.

LANGUAGE: typescript
CODE:
declare const unsafeGet: { <K>(key: K): <A, E>(self: FiberMap<K, A, E>) => Option.Option<Fiber.RuntimeFiber<A, E>>; <K, A, E>(self: FiberMap<K, A, E>, key: K): Option.Option<Fiber.RuntimeFiber<A, E>>; }

----------------------------------------

TITLE: Defining Cause.pretty Function in TypeScript
DESCRIPTION: Declares the pretty function that converts a Cause into a human-readable string. It takes a Cause object and optional rendering options, returning a formatted string representation of the error cause.

LANGUAGE: typescript
CODE:
declare const pretty: <E>(cause: Cause<E>, options?: { readonly renderErrorCause?: boolean | undefined; }) => string

----------------------------------------

TITLE: Implementing Stream Chunk Accumulation in TypeScript
DESCRIPTION: Function signature for accumulateChunks, which takes a Stream of type A with error type E and environment R, and returns a new Stream with accumulated chunks. This function reorganizes the elements of the stream by accumulating each underlying chunk.

LANGUAGE: typescript
CODE:
declare const accumulateChunks: <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>

----------------------------------------

TITLE: Implementing Greater Than Comparison in TypeScript with Effect-TS Order Module
DESCRIPTION: Function signature for implementing strict greater than comparison between two values of type A. Takes an Order<A> parameter and returns a function that can be used in both curried and uncurried forms to compare values.

LANGUAGE: typescript
CODE:
declare const greaterThan: <A>(O: Order<A>) => { (that: A): (self: A) => boolean; (self: A, that: A): boolean; }

----------------------------------------

TITLE: Defining BigDecimal.scale Function in TypeScript
DESCRIPTION: Declares a function named scale for scaling BigDecimal values. It can be called with either the scale first and BigDecimal second, or vice versa. The function rounds down to the nearest integer if the new scale is smaller than the current scale.

LANGUAGE: typescript
CODE:
declare const scale: { (scale: number): (self: BigDecimal) => BigDecimal; (self: BigDecimal, scale: number): BigDecimal; }

----------------------------------------

TITLE: Setting Time Zone for DateTime Object in TypeScript
DESCRIPTION: Demonstrates how to use the unsafeSetZoneNamed function to set the time zone of a DateTime object. It uses the Effect.gen function for asynchronous operations and sets the time zone to 'Europe/London'.

LANGUAGE: typescript
CODE:
import { DateTime, Effect } from "effect"

Effect.gen(function* () {
  const now = yield* DateTime.now
  // set the time zone
  DateTime.unsafeSetZoneNamed(now, "Europe/London")
})

----------------------------------------

TITLE: Creating Tagged Enum Data Type in TypeScript using effect/Data
DESCRIPTION: Demonstrates how to create a tagged enum data type using the Data.TaggedEnum type from the effect package. The example shows the creation of an HttpError type with BadRequest and NotFound variants.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Data } from "effect"

type HttpError = Data.TaggedEnum<{
  BadRequest: { readonly status: 400, readonly message: string }
  NotFound: { readonly status: 404, readonly message: string }
}>

// Equivalent to:
type HttpErrorPlain =
  | {
    readonly _tag: "BadRequest"
    readonly status: 400
    readonly message: string
  }
  | {
    readonly _tag: "NotFound"
    readonly status: 404
    readonly message: string
  }

----------------------------------------

TITLE: Defining repeated Channel Function in TypeScript
DESCRIPTION: The 'repeated' function creates a channel that repeatedly runs the input channel. It takes a Channel as input and returns a new Channel with the same type parameters.

LANGUAGE: typescript
CODE:
declare const repeated: <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>

----------------------------------------

TITLE: Creating Infinite Schedule with Constant Value in TypeScript
DESCRIPTION: Defines a function that creates a schedule which recurs indefinitely, always producing the same specified constant value. The function is generic, accepting any type A and returning a Schedule of type A.

LANGUAGE: typescript
CODE:
declare const succeed: <A>(value: A) => Schedule<A>

----------------------------------------

TITLE: Implementing Key Existence Check in TMap - TypeScript
DESCRIPTION: The 'has' function checks if a given key exists in a TMap. It can be used in two ways: by providing the key first and then the TMap, or by providing the TMap first and then the key. The function returns an STM (Software Transactional Memory) operation that resolves to a boolean.

LANGUAGE: typescript
CODE:
declare const has: { <K>(key: K): <V>(self: TMap<K, V>) => STM.STM<boolean>; <K, V>(self: TMap<K, V>, key: K): STM.STM<boolean>; }

----------------------------------------

TITLE: Defining ResponseAttributes Interface for OpenAI Telemetry in TypeScript
DESCRIPTION: This code snippet defines the ResponseAttributes interface, which includes optional properties for serviceTier and systemFingerprint. These attributes are used for OpenAI telemetry and are namespaced by gen_ai.openai.response.

LANGUAGE: typescript
CODE:
export interface ResponseAttributes {
    /**
     * The service tier used for the response.
     */
    readonly serviceTier?: string | null | undefined
    /**
     * A fingerprint to track any eventual change in the Generative AI
     * environment.
     */
    readonly systemFingerprint?: string | null | undefined
  }

----------------------------------------

TITLE: Implementing String Join Operation in Effect Chunk Module - TypeScript
DESCRIPTION: Defines a join function that concatenates elements of a Chunk<string> using a specified separator. The function is overloaded to support both curried and direct invocation patterns.

LANGUAGE: typescript
CODE:
declare const join: { (sep: string): (self: Chunk<string>) => string; (self: Chunk<string>, sep: string): string; }

----------------------------------------

TITLE: Checking FiberId Type in TypeScript
DESCRIPTION: Type guard function that checks whether an unknown value is a FiberId instance. Returns true if the input is a valid FiberId, false otherwise. Used for runtime type checking of FiberId objects.

LANGUAGE: typescript
CODE:
declare const isFiberId: (self: unknown) => self is FiberId

----------------------------------------

TITLE: Retrieving MutableList Length in TypeScript
DESCRIPTION: This snippet defines the signature for the length property of a MutableList. It takes a MutableList of type A as input and returns a number representing the list's length.

LANGUAGE: typescript
CODE:
declare const length: <A>(self: MutableList<A>) => number

----------------------------------------

TITLE: Type Signature for Context.getOption in TypeScript
DESCRIPTION: Provides the type signature for the Context.getOption function, showing its polymorphic nature and the types it works with.

LANGUAGE: typescript
CODE:
declare const getOption: { <S, I>(tag: Tag<I, S>): <Services>(self: Context<Services>) => Option<S>; <Services, S, I>(self: Context<Services>, tag: Tag<I, S>): Option<S>; }

----------------------------------------

TITLE: Generating Random Boolean Values in TypeScript using TRandom
DESCRIPTION: The nextBoolean function returns the next boolean value from a pseudo-random number generator. It is part of the TRandom module in the effect package and operates within the STM (Software Transactional Memory) context.

LANGUAGE: typescript
CODE:
declare const nextBoolean: STM.STM<boolean, never, TRandom>

----------------------------------------

TITLE: Resetting MutableList in TypeScript
DESCRIPTION: A function that removes all elements from a doubly-linked list data structure. It takes a MutableList instance as input and returns the emptied list. This operation modifies the list in place.

LANGUAGE: typescript
CODE:
declare const reset: <A>(self: MutableList<A>) => MutableList<A>

----------------------------------------

TITLE: TypeScript Signature of scanRight Function in Effect Array Module
DESCRIPTION: Provides the TypeScript type signature for the scanRight function, showing its overloaded versions for different parameter orders.

LANGUAGE: typescript
CODE:
declare const scanRight: { <B, A>(b: B, f: (b: B, a: A) => B): (self: Iterable<A>) => NonEmptyArray<B>; <A, B>(self: Iterable<A>, b: B, f: (b: B, a: A) => B): NonEmptyArray<B>; }

----------------------------------------

TITLE: Defining AnyNoContext Schema Type in TypeScript
DESCRIPTION: Defines a type alias for schemas that have no context (Context = never) but can have any input and output types. This is a core type used throughout the Effect Schema system for context-free schemas.

LANGUAGE: typescript
CODE:
type AnyNoContext = Schema<any, any, never>

----------------------------------------

TITLE: Implementing findFirstIndexWhereFrom Function in TypeScript
DESCRIPTION: Defines a function that searches for the first element index matching a predicate in a TArray, starting from a specified index position. Returns an STM transaction containing an Option of the found index.

LANGUAGE: typescript
CODE:
declare const findFirstIndexWhereFrom: {
  <A>(predicate: Predicate<A>, from: number): (self: TArray<A>) => STM.STM<Option.Option<number>>;
  <A>(self: TArray<A>, predicate: Predicate<A>, from: number): STM.STM<Option.Option<number>>;
}

----------------------------------------

TITLE: Implementing Partial Type Transform for Schema AST in TypeScript
DESCRIPTION: Function declaration for creating a partial version of a Schema AST, similar to TypeScript's built-in Partial utility type. Takes an AST parameter and optional configuration for exact matching.

LANGUAGE: typescript
CODE:
declare const partial: (ast: AST, options?: { readonly exact: true; }) => AST

----------------------------------------

TITLE: Serializing Cookie Objects in TypeScript using Effect Platform
DESCRIPTION: Function signature for serializing a Cookie object into its string representation. The function takes a Cookie object as input and returns the serialized cookie string.

LANGUAGE: typescript
CODE:
declare const serializeCookie: (self: Cookie) => string

----------------------------------------

TITLE: Defining Stream.transduce Function in TypeScript
DESCRIPTION: Declares the transduce function for the Stream module. This function applies a transducer to a stream and emits its outputs. It supports both curried and uncurried forms.

LANGUAGE: typescript
CODE:
declare const transduce: { <A2, A, E2, R2>(sink: Sink.Sink<A2, A, A, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, sink: Sink.Sink<A2, A, A, E2, R2>): Stream<A2, E | E2, R | R2>; }

----------------------------------------

TITLE: Using Cron.next in TypeScript
DESCRIPTION: Demonstrates how to use the Cron.next function to find the next run date for a given cron expression. It parses a cron string, sets a starting date, and asserts the expected next run date.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Cron, Either } from "effect"

const after = new Date("2021-01-01 00:00:00")
const cron = Either.getOrThrow(Cron.parse("0 4 8-14 * *"))
assert.deepStrictEqual(Cron.next(cron, after), new Date("2021-01-08 04:00:00"))

----------------------------------------

TITLE: Type Checking RightDone State in TypeScript
DESCRIPTION: Type guard function that determines if a MergeState instance is specifically a RightDone variant. Returns a boolean indicating whether the provided MergeState is of RightDone type. Used for type narrowing in TypeScript.

LANGUAGE: typescript
CODE:
declare const isRightDone: <Env, Err, Err1, Err2, Elem, Done, Done1, Done2>(self: MergeState<Env, Err, Err1, Err2, Elem, Done, Done1, Done2>) => self is RightDone<Env, Err, Err1, Err2, Elem, Done, Done1, Done2>

----------------------------------------

TITLE: Implementing Stream.mapAccumEffect in TypeScript
DESCRIPTION: Function declaration for statefully and effectfully mapping over stream elements. Takes an initial state S and a mapping function that produces effects containing updated state and new elements. Returns a transformed stream with accumulated state.

LANGUAGE: typescript
CODE:
declare const mapAccumEffect: { 
  <S, A, A2, E2, R2>(s: S, f: (s: S, a: A) => Effect.Effect<readonly [S, A2], E2, R2>): 
    <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>; 
  <A, E, R, S, A2, E2, R2>(self: Stream<A, E, R>, s: S, f: (s: S, a: A) => Effect.Effect<readonly [S, A2], E2, R2>): 
    Stream<A2, E | E2, R | R2>; 
}

----------------------------------------

TITLE: Accessing Channel Context in Effect - TypeScript
DESCRIPTION: The contextWithEffect function allows accessing the context of a channel within an effect. It takes a function that receives the context and returns an Effect, and produces a Channel that combines the environments of both the input and output.

LANGUAGE: typescript
CODE:
declare const contextWithEffect: <Env, OutDone, OutErr, Env1>(f: (env: Context.Context<Env>) => Effect.Effect<OutDone, OutErr, Env1>) => Channel<never, unknown, OutErr, unknown, OutDone, unknown, Env | Env1>

----------------------------------------

TITLE: Applying Effect on Option and Transposing Result in TypeScript
DESCRIPTION: Demonstrates the usage of Effect.transposeMapOption function to apply an Effect on an Option and transpose the result. It shows examples for both None and Some cases.

LANGUAGE: typescript
CODE:
import { Effect, Option, pipe } from "effect"

//          ┌─── Effect<Option<number>, never, never>>
//          ▼
const noneResult = pipe(
  Option.none(),
  Effect.transposeMapOption(() => Effect.succeed(42)) // will not be executed
)
console.log(Effect.runSync(noneResult))
// Output: { _id: 'Option', _tag: 'None' }

//          ┌─── Effect<Option<number>, never, never>>
//          ▼
const someSuccessResult = pipe(
  Option.some(42),
  Effect.transposeMapOption((value) => Effect.succeed(value * 2))
)
console.log(Effect.runSync(someSuccessResult))
// Output: { _id: 'Option', _tag: 'Some', value: 84 }

----------------------------------------

TITLE: Implementing Type Hole Simulation in TypeScript
DESCRIPTION: The 'hole' function simulates a type hole in TypeScript. It is a generic function that can be used to represent a placeholder for any type T. This can be useful for type-driven development or debugging complex type inference scenarios.

LANGUAGE: typescript
CODE:
declare const hole: <T>() => T

----------------------------------------

TITLE: Implementing Write Lock Function in Effect TypeScript
DESCRIPTION: Defines a withWriteLock function that executes an Effect workflow while holding a write lock. The function supports both curried and uncurried calling styles and preserves the effect's type parameters.

LANGUAGE: typescript
CODE:
declare const withWriteLock: { 
  (self: TReentrantLock): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; 
  <A, E, R>(effect: Effect.Effect<A, E, R>, self: TReentrantLock): Effect.Effect<A, E, R>; 
}

----------------------------------------

TITLE: Implementing Maximum Interval Comparison in TypeScript
DESCRIPTION: Defines a function that compares two Interval objects and returns the maximum interval. The function is curried and can be called with either one or two arguments.

LANGUAGE: typescript
CODE:
declare const max: { (that: Interval): (self: Interval) => Interval; (self: Interval, that: Interval): Interval; }

----------------------------------------

TITLE: Implementing Defect Tracking with Effect Metrics in TypeScript
DESCRIPTION: Defines an aspect that updates a metric based on defect throwables in effects. The function takes a metric and a transformation function to process defects, returning a modified Effect that includes metric tracking functionality.

LANGUAGE: typescript
CODE:
declare const trackDefectWith: { 
  <Type, In, Out>(metric: Metric<Type, In, Out>, f: (defect: unknown) => In): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; 
  <A, E, R, Type, In, Out>(self: Effect.Effect<A, E, R>, metric: Metric<Type, In, Out>, f: (defect: unknown) => In): Effect.Effect<A, E, R>; 
}

----------------------------------------

TITLE: Using isNever Type Guard in TypeScript
DESCRIPTION: Demonstrates usage of the isNever predicate function which acts as a type guard that always returns false for any input. This is useful for type narrowing scenarios where you need to explicitly handle the 'never' type case.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { isNever } from "effect/Predicate"

assert.deepStrictEqual(isNever(null), false)
assert.deepStrictEqual(isNever(undefined), false)
assert.deepStrictEqual(isNever({}), false)
assert.deepStrictEqual(isNever([]), false)

LANGUAGE: typescript
CODE:
declare const isNever: (input: unknown) => input is never

----------------------------------------

TITLE: Implementing Number Addition in TypeScript using Effect Package
DESCRIPTION: Demonstrates the usage of the sum function from the Effect package's Number module. The function supports both curried and uncurried forms for adding two numbers together.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { sum } from "effect/Number"

assert.deepStrictEqual(sum(2, 3), 5)

LANGUAGE: typescript
CODE:
declare const sum: { (that: number): (self: number) => number; (self: number, that: number): number; }

----------------------------------------

TITLE: String.isString Function Signature in TypeScript
DESCRIPTION: Provides the TypeScript signature for the String.isString function. It is defined as a Refinement type that checks if an unknown value is a string.

LANGUAGE: typescript
CODE:
declare const isString: Refinement<unknown, string>

----------------------------------------

TITLE: Stream.cross Type Signature
DESCRIPTION: Type definition for the Stream.cross operation showing its polymorphic nature and type constraints. The function can be called with either curried or uncurried parameters.

LANGUAGE: typescript
CODE:
declare const cross: { <AR, ER, RR>(right: Stream<AR, ER, RR>): <AL, EL, RL>(left: Stream<AL, EL, RL>) => Stream<[AL, AR], EL | ER, RL | RR>; <AL, ER, RR, AR, EL, RL>(left: Stream<AL, ER, RR>, right: Stream<AR, EL, RL>): Stream<[AL, AR], EL | ER, RL | RR>; }

----------------------------------------

TITLE: Implementing Sensitive Field Type in TypeScript
DESCRIPTION: Defines a generic type constructor for creating sensitive fields in SQL models. The sensitive field wrapper ensures values are not exposed in JSON serialization. Takes a schema parameter that can be either a Schema.All or PropertySignature.All type.

LANGUAGE: typescript
CODE:
declare const Sensitive: <S extends Schema.Schema.All | Schema.PropertySignature.All>(schema: S) => Sensitive<S>

----------------------------------------

TITLE: Retrieving Size of RedBlackTree in TypeScript
DESCRIPTION: This function returns the size (number of elements) of a Red-Black Tree. It takes a RedBlackTree instance as an argument and returns a number representing the tree's size.

LANGUAGE: typescript
CODE:
declare const size: <K, V>(self: RedBlackTree<K, V>) => number

----------------------------------------

TITLE: Using lessThan Function for Number Comparison in TypeScript
DESCRIPTION: Demonstrates how to use the lessThan function to compare two numbers. The function returns true if the first number is less than the second number, and false otherwise. Supports both curried and uncurried function calls.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { lessThan } from "effect/Number"

assert.deepStrictEqual(lessThan(2, 3), true)
assert.deepStrictEqual(lessThan(3, 3), false)
assert.deepStrictEqual(lessThan(4, 3), false)

LANGUAGE: typescript
CODE:
declare const lessThan: { (that: number): (self: number) => boolean; (self: number, that: number): boolean; }

----------------------------------------

TITLE: Defining Primitive Interface in TypeScript
DESCRIPTION: Defines a generic interface Primitive that extends Primitive.Variance and represents primitive types that can be parsed and validated from strings in Effect CLI.

LANGUAGE: typescript
CODE:
export interface Primitive<A> extends Primitive.Variance<A> {}

----------------------------------------

TITLE: Decoding URI Components in TypeScript using Effect Library
DESCRIPTION: A function that decodes a URI component string into a UTF-8 string. Returns an Either type that contains either the successfully decoded string or a DecodeException if decoding fails.

LANGUAGE: typescript
CODE:
declare const decodeUriComponent: (str: string) => Either.Either<string, DecodeException>

----------------------------------------

TITLE: Defining Bigint Predicate in TypeScript for effect Package
DESCRIPTION: Declares a constant 'bigint' as a Predicate.Refinement that matches values of type bigint. This predicate can be used to refine unknown values to bigint type.

LANGUAGE: typescript
CODE:
declare const bigint: Predicate.Refinement<unknown, bigint>

----------------------------------------

TITLE: Stream.takeRight Type Signature
DESCRIPTION: Type signature for the takeRight function showing its polymorphic nature and support for both curried and uncurried calling styles.

LANGUAGE: typescript
CODE:
declare const takeRight: { (n: number): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, n: number): Stream<A, E, R>; }

----------------------------------------

TITLE: Defining Yield Interface for ChildExecutorDecision in TypeScript
DESCRIPTION: Defines the Yield interface extending ChildExecutorDecision.Proto. It specifies a readonly _tag property with the value "Yield". This interface is used to pass execution to the next substream, either pulling a new element from upstream or yielding to an already created active substream.

LANGUAGE: typescript
CODE:
export interface Yield extends ChildExecutorDecision.Proto {
  readonly _tag: "Yield"
}

----------------------------------------

TITLE: Using keysWithPrefix Function in Trie Module (TypeScript)
DESCRIPTION: Demonstrates how to use the keysWithPrefix function to retrieve keys with a specific prefix from a Trie. The example creates a Trie with string keys and number values, then retrieves keys starting with 'she'.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Trie } from "effect"

const trie = Trie.empty<number>().pipe(
  Trie.insert("she", 0),
  Trie.insert("shells", 1),
  Trie.insert("sea", 2),
  Trie.insert("shore", 3)
)

const result = Array.from(Trie.keysWithPrefix(trie, "she"))
assert.deepStrictEqual(result, ["she", "shells"])

----------------------------------------

TITLE: Defining slash constant in Doc module (TypeScript)
DESCRIPTION: Defines a constant 'slash' representing a document containing a single '/' character. It has a type of Doc<never>, indicating it doesn't contain any specific type parameter.

LANGUAGE: typescript
CODE:
declare const slash: Doc<never>

----------------------------------------

TITLE: Implementing Interval Intersection in TypeScript
DESCRIPTION: Defines a function that computes the intersection between two Intervals objects. The function is implemented with curried and uncurried variants for flexibility in usage.

LANGUAGE: typescript
CODE:
declare const intersect: { (that: Intervals): (self: Intervals) => Intervals; (self: Intervals, that: Intervals): Intervals; }

----------------------------------------

TITLE: Creating Sink from Channel in Effect Library
DESCRIPTION: Type signature for the fromChannel function that creates a Sink from a Channel. The function takes a Channel that processes chunks of data and returns a Sink that can be used for data processing pipelines.

LANGUAGE: typescript
CODE:
declare const fromChannel: <L, In, E, A, R>(channel: Channel.Channel<Chunk.Chunk<L>, Chunk.Chunk<In>, E, never, A, unknown, R>) => Sink<A, In, L, E, R>

----------------------------------------

TITLE: TypeScript Function Signature for isZero
DESCRIPTION: This code snippet shows the TypeScript function signature for the isZero function. It takes a BigDecimal as input and returns a boolean indicating whether the input is zero.

LANGUAGE: typescript
CODE:
declare const isZero: (n: BigDecimal) => boolean

----------------------------------------

TITLE: Defining Micro.bind Function Signature in TypeScript
DESCRIPTION: Declares the signature of the Micro.bind function, which binds the success value of a Micro effect to a provided name. It supports both curried and uncurried versions of the function.

LANGUAGE: typescript
CODE:
declare const bind: { <N extends string, A extends Record<string, any>, B, E2, R2>(name: N, f: (a: NoInfer<A>) => Micro<B, E2, R2>): <E, R>(self: Micro<A, E, R>) => Micro<Simplify<Omit<A, N> & { [K in N]: B; }>, E | E2, R | R2>; <A extends Record<string, any>, E, R, B, E2, R2, N extends string>(self: Micro<A, E, R>, name: N, f: (a: NoInfer<A>) => Micro<B, E2, R2>): Micro<Simplify<Omit<A, N> & { [K in N]: B; }>, E | E2, R | R2>; }

----------------------------------------

TITLE: Declaring DateTimeUpdateFromDate Field in TypeScript
DESCRIPTION: Defines a constant DateTimeUpdateFromDate representing a date-time field that automatically updates to the current UTC time on inserts and updates. It is serialized as a Date in the database and is available for selection.

LANGUAGE: typescript
CODE:
declare const DateTimeUpdateFromDate: DateTimeUpdateFromDate

----------------------------------------

TITLE: Separating Elements in a Chunk using Either values in TypeScript
DESCRIPTION: The separate function partitions the elements of a Chunk containing Either values into two separate Chunks. It takes a Chunk of Either<B, A> and returns a tuple of two Chunks: one containing all 'A' values and another containing all 'B' values.

LANGUAGE: typescript
CODE:
declare const separate: <A, B>(self: Chunk<Either<B, A>>) => [Chunk<A>, Chunk<B>]

----------------------------------------

TITLE: Using LogLevel.locally in Effect Workflows (TypeScript)
DESCRIPTION: Demonstrates how to use LogLevel.locally to temporarily adjust the log level for a specific part of an Effect workflow. It shows how log messages are affected by different log levels.

LANGUAGE: typescript
CODE:
import { Effect, LogLevel } from "effect"

const program = Effect.gen(function*() {
  yield* Effect.log("message1")
  yield* Effect.gen(function*() {
    yield* Effect.log("message2")
    yield* Effect.log("message3")
  }).pipe(LogLevel.locally(LogLevel.Warning))
})

Effect.runFork(program)
// timestamp=... level=INFO fiber=#0 message=message1
// timestamp=... level=WARN fiber=#0 message=message2
// timestamp=... level=WARN fiber=#0 message=message3

----------------------------------------

TITLE: Prepending Elements to MutableList in TypeScript
DESCRIPTION: Function signature for prepending a value to the beginning of a MutableList. Supports both curried and uncurried versions of the operation. Returns the modified MutableList instance.

LANGUAGE: typescript
CODE:
declare const prepend: { <A>(value: A): (self: MutableList<A>) => MutableList<A>; <A>(self: MutableList<A>, value: A): MutableList<A>; }

----------------------------------------

TITLE: Implementing Schedule Passthrough in TypeScript
DESCRIPTION: Defines a function that modifies a schedule to return its input values instead of original output values while maintaining the original timing. The function takes a Schedule with generic types for output, input, and return value, and produces a modified Schedule where input and output types are the same.

LANGUAGE: typescript
CODE:
declare const passthrough: <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<In, In, R>

----------------------------------------

TITLE: Converting FiberId to Option<FiberId> in TypeScript
DESCRIPTION: This function converts a FiberId into an Option<FiberId>. It takes a FiberId as input and returns an Option<FiberId>. This function has been available since version 2.0.0 of the effect package.

LANGUAGE: typescript
CODE:
declare const toOption: (self: FiberId) => Option.Option<FiberId>

----------------------------------------

TITLE: Defining ScheduleInterval.Interval Interface in TypeScript
DESCRIPTION: Defines an interface for representing time intervals with start and end timestamps in milliseconds. The interface includes a type identifier and millisecond-precision boundary timestamps. Can represent both finite and infinite time intervals.

LANGUAGE: typescript
CODE:
export interface Interval {
  readonly [IntervalTypeId]: IntervalTypeId
  readonly startMillis: number
  readonly endMillis: number
}

----------------------------------------

TITLE: Type Signature of Order.clamp Function in TypeScript
DESCRIPTION: Provides the type signature for the Order.clamp function. It takes an Order instance and returns a function that can be called with options for minimum and maximum values, or with a value and options.

LANGUAGE: typescript
CODE:
declare const clamp: <A>(O: Order<A>) => { (options: { minimum: A; maximum: A; }): (self: A) => A; (self: A, options: { minimum: A; maximum: A; }): A; }

----------------------------------------

TITLE: Converting Stream to PubSub in TypeScript
DESCRIPTION: Function signature for converting a Stream to a PubSub instance. Supports configuration of capacity (bounded/unbounded), replay buffer size, and queue management strategy (sliding/dropping/suspend). Returns an Effect that produces a PubSub instance handling Take objects containing stream values and errors.

LANGUAGE: typescript
CODE:
declare const toPubSub: { 
  (capacity: number | { readonly capacity: "unbounded"; readonly replay?: number | undefined; } | { readonly capacity: number; readonly strategy?: "sliding" | "dropping" | "suspend" | undefined; readonly replay?: number | undefined; }): <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<PubSub.PubSub<Take.Take<A, E>>, never, Scope.Scope | R>; 
  <A, E, R>(self: Stream<A, E, R>, capacity: number | { readonly capacity: "unbounded"; readonly replay?: number | undefined; } | { readonly capacity: number; readonly strategy?: "sliding" | "dropping" | "suspend" | undefined; readonly replay?: number | undefined; }): Effect.Effect<PubSub.PubSub<Take.Take<A, E>>, never, Scope.Scope | R>; 
}

----------------------------------------

TITLE: Defining DeepMutable Type in TypeScript
DESCRIPTION: Demonstrates the usage of the DeepMutable type utility to recursively make all properties of an object mutable. It transforms readonly properties and arrays into their mutable counterparts.

LANGUAGE: typescript
CODE:
import type { Types } from "effect"

type DeepMutableStruct = Types.DeepMutable<{
  readonly a: string;
  readonly b: readonly string[]
}>
// { a: string; b: string[] }

----------------------------------------

TITLE: Creating NonEmptyChunk with Chunk.of in TypeScript
DESCRIPTION: Creates a NonEmptyChunk data structure from a single element. This function ensures type safety by guaranteeing the chunk will contain at least one element.

LANGUAGE: typescript
CODE:
declare const of: <A>(a: A) => NonEmptyChunk<A>

----------------------------------------

TITLE: Creating Summary Metric Key in TypeScript
DESCRIPTION: This function creates a metric key for a summary with specified name, maxAge, maxSize, error, and quantiles. It can optionally include a description. The function is part of the MetricKey module in the effect package.

LANGUAGE: typescript
CODE:
declare const summary: (options: { readonly name: string; readonly maxAge: Duration.DurationInput; readonly maxSize: number; readonly error: number; readonly quantiles: ReadonlyArray<number>; readonly description?: string | undefined; }) => MetricKey.Summary

----------------------------------------

TITLE: Configuring Effect Workflow Supervision in TypeScript
DESCRIPTION: Function that takes an Effect workflow and returns a new workflow that will not supervise any fibers forked by the original workflow. This is useful for creating daemon processes that run independently.

LANGUAGE: typescript
CODE:
declare const daemonChildren: <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>

----------------------------------------

TITLE: Subtracting Numbers using Effect/Number Module in TypeScript
DESCRIPTION: Demonstrates how to use the subtract function from the Number module in the Effect package. The function supports both curried and uncurried usage for subtracting two numbers.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { subtract } from "effect/Number"

assert.deepStrictEqual(subtract(2, 3), -1)

LANGUAGE: typescript
CODE:
declare const subtract: { (that: number): (self: number) => number; (self: number, that: number): number; }

----------------------------------------

TITLE: Creating Daily Schedule - Effect TypeScript Schedule Module
DESCRIPTION: Function signature for creating a schedule that recurs at a specific hour each day. The schedule triggers once per day at the specified hour (0-23) and returns an incrementing execution count. Used for implementing daily recurring tasks like batch jobs.

LANGUAGE: typescript
CODE:
declare const hourOfDay: (hour: number) => Schedule<number>

----------------------------------------

TITLE: Implementing BigDecimal Clamping in TypeScript
DESCRIPTION: Type signature for a function that creates a schema transformation to clamp BigDecimal values between minimum and maximum bounds. Takes minimum and maximum BigDecimal values as parameters and returns a transform function that can be applied to schemas containing BigDecimal values.

LANGUAGE: typescript
CODE:
declare const clampBigDecimal: (minimum: bigDecimal_.BigDecimal, maximum: bigDecimal_.BigDecimal) => <S extends Schema.Any, A extends bigDecimal_.BigDecimal>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => transform<S, filter<SchemaClass<A>>>

----------------------------------------

TITLE: TypeScript Signature of Option.liftPredicate
DESCRIPTION: The TypeScript signature for the Option.liftPredicate function, showing its polymorphic nature and ability to work with both Refinement and Predicate types.

LANGUAGE: typescript
CODE:
declare const liftPredicate: { <A, B extends A>(refinement: Refinement<A, B>): (a: A) => Option<B>; <B extends A, A = B>(predicate: Predicate<A>): (b: B) => Option<B>; <A, B extends A>(self: A, refinement: Refinement<A, B>): Option<B>; <B extends A, A = B>(self: B, predicate: Predicate<A>): Option<B>; }

----------------------------------------

TITLE: Defining NdjsonOptions Interface in TypeScript
DESCRIPTION: Defines the NdjsonOptions interface with a single optional property 'ignoreEmptyLines'. This property determines whether the parser should ignore empty lines in newline delimited JSON, defaulting to false.

LANGUAGE: typescript
CODE:
export interface NdjsonOptions {
  /**
   * Whether or not the newline delimited JSON parser should ignore empty lines.
   *
   * Defaults to `false`.
   *
   * From the [newline delimited JSON spec](https://github.com/ndjson/ndjson-spec):
   * ```text
   * The parser MAY silently ignore empty lines, e.g. \n\n. This behavior MUST
   * be documented and SHOULD be configurable by the user of the parser.
   * ```
   *
   * @since 1.0.0
   */
  readonly ignoreEmptyLines?: boolean
}

----------------------------------------

TITLE: LazyArg Interface Definition in TypeScript
DESCRIPTION: This snippet shows the type signature for the LazyArg interface. It defines a function that takes no arguments and returns a value of type A.

LANGUAGE: typescript
CODE:
export interface LazyArg<A> {
  (): A
}

----------------------------------------

TITLE: Declaring DateTimeInsertFromNumber Field in TypeScript
DESCRIPTION: Defines a constant DateTimeInsertFromNumber that represents a date-time field. This field is inserted as the current DateTime.Utc, serialized as a number, omitted from updates, and available for selection.

LANGUAGE: typescript
CODE:
declare const DateTimeInsertFromNumber: DateTimeInsertFromNumber

----------------------------------------

TITLE: Declaring Schedule.repeatForever Type in TypeScript
DESCRIPTION: Type declaration for the repeatForever constant, which is an alias of the forever function. It represents a Schedule that repeats indefinitely with a number input and never produces a value.

LANGUAGE: typescript
CODE:
declare const repeatForever: Schedule<number, unknown, never>

----------------------------------------

TITLE: TypeScript Signature for Option.bindTo Function
DESCRIPTION: This code snippet shows the TypeScript signature for the bindTo function in the Option module. It defines the function's type and its overloads for different usage patterns.

LANGUAGE: typescript
CODE:
declare const bindTo: { <N extends string>(name: N): <A>(self: Option<A>) => Option<{ [K in N]: A; }>; <A, N extends string>(self: Option<A>, name: N): Option<{ [K in N]: A; }>; }

----------------------------------------

TITLE: Checking Layer Freshness in TypeScript
DESCRIPTION: The isFresh function determines if a specified Layer is a fresh version that will not be shared. It takes a Layer object as input and returns a boolean value.

LANGUAGE: typescript
CODE:
declare const isFresh: <RIn, E, ROut>(self: Layer<ROut, E, RIn>) => boolean

----------------------------------------

TITLE: Implementing Chunk Folding Sink in Effect-TS
DESCRIPTION: Defines a sink that processes input chunks using an effect-based folding function. Takes an initial state, continuation predicate, and folding function that must maintain chunking-invariance. The continuation check occurs at initialization and after each chunk processing.

LANGUAGE: typescript
CODE:
declare const foldChunksEffect: <S, In, E, R>(
  s: S,
  contFn: Predicate<S>,
  f: (s: S, chunk: Chunk.Chunk<In>) => Effect.Effect<S, E, R>
) => Sink<S, In, In, E, R>

----------------------------------------

TITLE: Implementing Stream pipeThroughChannelOrFail in TypeScript
DESCRIPTION: Defines a function that pipes values from a stream through a provided channel while maintaining error handling. It passes through any errors from the original stream unchanged while allowing new errors from the channel operation.

LANGUAGE: typescript
CODE:
declare const pipeThroughChannelOrFail: { <R2, E, E2, A, A2>(chan: Channel.Channel<Chunk.Chunk<A2>, Chunk.Chunk<A>, E2, E, unknown, unknown, R2>): <R>(self: Stream<A, E, R>) => Stream<A2, E | E2, R2 | R>; <R, R2, E, E2, A, A2>(self: Stream<A, E, R>, chan: Channel.Channel<Chunk.Chunk<A2>, Chunk.Chunk<A>, E2, E, unknown, unknown, R2>): Stream<A2, E | E2, R | R2>; }

----------------------------------------

TITLE: Implementing Stream Error Termination in TypeScript
DESCRIPTION: The orDieWith function terminates a stream when encountering errors by converting the error type E into a defect using a provided conversion function. This removes error handling from the stream type, effectively changing the error type to never.

LANGUAGE: typescript
CODE:
declare const orDieWith: { <E>(f: (e: E) => unknown): <A, R>(self: Stream<A, E, R>) => Stream<A, never, R>; <A, E, R>(self: Stream<A, E, R>, f: (e: E) => unknown): Stream<A, never, R>; }

----------------------------------------

TITLE: Defining Channel.mapErrorCause Function Signature in TypeScript
DESCRIPTION: TypeScript type definition for the mapErrorCause function that maps error causes in a Channel. The function takes a mapping function for error causes and returns a new Channel with transformed error types.

LANGUAGE: typescript
CODE:
declare const mapErrorCause: {
  <OutErr, OutErr2>(f: (cause: Cause.Cause<OutErr>) => Cause.Cause<OutErr2>):
    <OutElem, InElem, InErr, OutDone, InDone, Env>
    (self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) =>
    Channel<OutElem, InElem, OutErr2, InErr, OutDone, InDone, Env>;

  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutErr2>
  (self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,
   f: (cause: Cause.Cause<OutErr>) => Cause.Cause<OutErr2>):
   Channel<OutElem, InElem, OutErr2, InErr, OutDone, InDone, Env>;
}

----------------------------------------

TITLE: Implementing Metric Snapshot in TypeScript with Effect
DESCRIPTION: Defines a snapshot function that captures all metrics recorded by the application. Returns an Effect containing an array of untyped metric pairs with no requirements and no error type.

LANGUAGE: typescript
CODE:
declare const snapshot: Effect.Effect<Array<MetricPair.MetricPair.Untyped>, never, never>

----------------------------------------

TITLE: Error Handling with Effect.tapErrorCause in TypeScript
DESCRIPTION: Demonstrates how to use tapErrorCause to inspect and log error causes without modifying the original effect. Shows examples with both regular errors and fatal defects.

LANGUAGE: typescript
CODE:
import { Effect, Console } from "effect"

// Create a task that fails with a NetworkError
const task1: Effect.Effect<number, string> = Effect.fail("NetworkError")

const tapping1 = Effect.tapErrorCause(task1, (cause) =>
  Console.log(`error cause: ${cause}`)
)

Effect.runFork(tapping1)
// Output:
// error cause: Error: NetworkError

// Simulate a severe failure in the system
const task2: Effect.Effect<number, string> = Effect.dieMessage(
  "Something went wrong"
)

const tapping2 = Effect.tapErrorCause(task2, (cause) =>
  Console.log(`error cause: ${cause}`)
)

Effect.runFork(tapping2)
// Output:
// error cause: RuntimeException: Something went wrong
//   ... stack trace ...

LANGUAGE: typescript
CODE:
declare const tapErrorCause: { <E, X, E2, R2>(f: (cause: Cause.Cause<NoInfer<E>>) => Effect<X, E2, R2>): <A, R>(self: Effect<A, E, R>) => Effect<A, E | E2, R2 | R>; <A, E, R, X, E2, R2>(self: Effect<A, E, R>, f: (cause: Cause.Cause<E>) => Effect<X, E2, R2>): Effect<A, E | E2, R | R2>; }

----------------------------------------

TITLE: Option.getOrUndefined Function Signature
DESCRIPTION: TypeScript type signature for the getOrUndefined function, showing it accepts an Option<A> and returns either A or undefined.

LANGUAGE: typescript
CODE:
declare const getOrUndefined: <A>(self: Option<A>) => A | undefined

----------------------------------------

TITLE: Implementing List Partition with Either in TypeScript
DESCRIPTION: Function that partitions a list into two lists based on Left/Right Either results. Takes a mapping function that converts list elements to Either values and returns a tuple of two lists containing the Left and Right results respectively.

LANGUAGE: typescript
CODE:
declare const partitionMap: { <A, B, C>(f: (a: A) => Either.Either<C, B>): (self: List<A>) => [left: List<B>, right: List<C>]; <A, B, C>(self: List<A>, f: (a: A) => Either.Either<C, B>): [left: List<B>, right: List<C>]; }

----------------------------------------

TITLE: Defining Sink.as Type Signature in TypeScript
DESCRIPTION: Type definition for the 'as' function that transforms a Sink by replacing its result type. The function supports both curried and non-curried calling styles for replacing a sink's result type A with a new type A2.

LANGUAGE: typescript
CODE:
declare const as: { <A2>(a: A2): <A, In, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A2, In, L, E, R>; <A, In, L, E, R, A2>(self: Sink<A, In, L, E, R>, a: A2): Sink<A2, In, L, E, R>; }

----------------------------------------

TITLE: Implementing Struct Semigroup in TypeScript
DESCRIPTION: Defines a function that creates a Semigroup for combining structured data types. It takes an object of Semigroups as input and returns a new Semigroup that can combine objects by applying the corresponding Semigroup to each property.

LANGUAGE: typescript
CODE:
declare const struct: <R extends { readonly [x: string]: Semigroup<any>; }>(fields: R) => Semigroup<{ readonly [K in keyof R]: [R[K]] extends [Semigroup<infer A>] ? A : never; }>

----------------------------------------

TITLE: Finding First Value in RedBlackTree - TypeScript
DESCRIPTION: Function signature for finding the first value associated with a key in a Red-Black Tree. Supports both curried and uncurried function calls, returning an Option type containing the found value if it exists.

LANGUAGE: typescript
CODE:
declare const findFirst: { 
  <K>(key: K): <V>(self: RedBlackTree<K, V>) => Option<V>; 
  <K, V>(self: RedBlackTree<K, V>, key: K): Option<V>; 
}

----------------------------------------

TITLE: Defining Request Interface in TypeScript
DESCRIPTION: Defines the Request interface with generic type parameters A and E. A represents the successful value type, while E represents the potential error type. The interface extends Request.Variance<A, E>.

LANGUAGE: typescript
CODE:
export interface Request<out A, out E = never> extends Request.Variance<A, E> {}

----------------------------------------

TITLE: Implementing HashMap forEach in TypeScript
DESCRIPTION: Function declaration for iterating over HashMap entries. Provides two function overloads: one that takes a function and returns a function accepting a HashMap, and another that takes both HashMap and function directly. The function applies the provided callback to each key-value pair in the HashMap.

LANGUAGE: typescript
CODE:
declare const forEach: {
  <V, K>(f: (value: V, key: K) => void): (self: HashMap<K, V>) => void;
  <V, K>(self: HashMap<K, V>, f: (value: V, key: K) => void): void;
}

----------------------------------------

TITLE: Defining GroupBy Interface in TypeScript
DESCRIPTION: Defines the GroupBy interface, which extends GroupBy.Variance and Pipeable. It includes a 'grouped' property representing a stream of key-value pairs, where values are queues of Takes.

LANGUAGE: typescript
CODE:
export interface GroupBy<out K, out V, out E = never, out R = never> extends GroupBy.Variance<K, V, E, R>, Pipeable {
  readonly grouped: Stream.Stream<readonly [K, Queue.Dequeue<Take.Take<V, E>>], E, R>
}

----------------------------------------

TITLE: TypeScript Signature for constTrue Function
DESCRIPTION: Provides the TypeScript type signature for the constTrue function. It is defined as a LazyArg of boolean type.

LANGUAGE: typescript
CODE:
declare const constTrue: LazyArg<boolean>

----------------------------------------

TITLE: Implementing SortedSet.every Predicate Check in TypeScript
DESCRIPTION: Defines a function that tests if all elements in a SortedSet satisfy a given predicate. The function supports both curried and uncurried calling styles, taking either a predicate first or the SortedSet and predicate together.

LANGUAGE: typescript
CODE:
declare const every: { 
  <A>(predicate: Predicate<A>): (self: SortedSet<A>) => boolean; 
  <A>(self: SortedSet<A>, predicate: Predicate<A>): boolean; 
}

----------------------------------------

TITLE: Implementing traversePartitionMap for Traversable and Filterable Types in TypeScript
DESCRIPTION: This function returns a default binary traversePartitionMap implementation for types that are both Traversable and Filterable. It takes a Traversable and Filterable type T and an Applicative type F as input, and returns a function that can traverse and partition a structure based on a provided mapping function.

LANGUAGE: TypeScript
CODE:
declare const traversePartitionMap: <T extends TypeLambda>(T: Traversable<T> & Covariant<T> & Filterable<T>) => <F extends TypeLambda>(F: Applicative<F>) => <TR, TO, TE, A, R, O, E, B, C>(self: Kind<T, TR, TO, TE, A>, f: (a: A) => Kind<F, R, O, E, Either<C, B>>) => Kind<F, R, O, E, [Kind<T, TR, TO, TE, B>, Kind<T, TR, TO, TE, C>]>

----------------------------------------

TITLE: Wrapping Non-Empty Array into Chunk in TypeScript
DESCRIPTION: The unsafeFromNonEmptyArray function wraps a non-empty array into a chunk without copying. This operation is unsafe when used with mutable arrays. It takes a NonEmptyReadonlyArray<A> as input and returns a NonEmptyChunk<A>.

LANGUAGE: typescript
CODE:
declare const unsafeFromNonEmptyArray: <A>(self: NonEmptyReadonlyArray<A>) => NonEmptyChunk<A>

----------------------------------------

TITLE: Implementing takeUntilEffect in TypeScript for Effect Stream
DESCRIPTION: Function definition for takeUntilEffect that takes stream elements until a predicate returns true. The function supports both curried and uncurried forms, working with Effect streams and effectual predicates.

LANGUAGE: typescript
CODE:
declare const takeUntilEffect: {
  <A, E2, R2>(predicate: (a: NoInfer<A>) => Effect.Effect<boolean, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>;
  <A, E, R, E2, R2>(self: Stream<A, E, R>, predicate: (a: A) => Effect.Effect<boolean, E2, R2>): Stream<A, E | E2, R | R2>;
}

----------------------------------------

TITLE: Defining Fiber.match Function in TypeScript
DESCRIPTION: Defines the match function for the Fiber module. This function allows folding over Fiber or RuntimeFiber types, providing separate handlers for each case. It supports both curried and uncurried calling styles.

LANGUAGE: typescript
CODE:
declare const match: {
  <A, E, Z>(options: {
    readonly onFiber: (fiber: Fiber<A, E>) => Z;
    readonly onRuntimeFiber: (fiber: RuntimeFiber<A, E>) => Z;
  }): (self: Fiber<A, E>) => Z;
  <A, E, Z>(
    self: Fiber<A, E>,
    options: {
      readonly onFiber: (fiber: Fiber<A, E>) => Z;
      readonly onRuntimeFiber: (fiber: RuntimeFiber<A, E>) => Z;
    }
  ): Z;
}

----------------------------------------

TITLE: TypeScript Function Signature for HashSet.reduce in effect Package
DESCRIPTION: Provides the TypeScript function signature for the HashSet.reduce function, showing its overloaded versions for both data-first and data-last usage patterns.

LANGUAGE: typescript
CODE:
declare const reduce: { <A, Z>(zero: Z, f: (accumulator: Z, value: A) => Z): (self: HashSet<A>) => Z; <A, Z>(self: HashSet<A>, zero: Z, f: (accumulator: Z, value: A) => Z): Z; }

----------------------------------------

TITLE: Defining Structural Region Function in TypeScript
DESCRIPTION: Experimental utility function that executes code within a structural comparison context. Takes a body function to execute and an optional custom equality tester. Returns the result of the body function execution.

LANGUAGE: typescript
CODE:
declare const structuralRegion: <A>(body: () => A, tester?: (a: unknown, b: unknown) => boolean) => A

----------------------------------------

TITLE: Defining Layout Options Interface in TypeScript
DESCRIPTION: Defines an interface named Options that contains configuration parameters for layout algorithms. Currently includes a single required property pageWidth that determines page width settings.

LANGUAGE: typescript
CODE:
export interface Options {
    readonly pageWidth: PageWidth
  }

----------------------------------------

TITLE: Transforming Differ Types in TypeScript
DESCRIPTION: Provides functionality to transform the type of values that a differ can handle using mapping functions between old and new value types. Takes options containing toNew and toOld transformation functions and returns a new differ instance that works with the transformed types.

LANGUAGE: typescript
CODE:
declare const transform: { 
  <Value, Value2>(
    options: { 
      readonly toNew: (value: Value) => Value2; 
      readonly toOld: (value: Value2) => Value; 
    }
  ): <Patch>(
    self: Differ<Value, Patch>
  ) => Differ<Value2, Patch>; 
  <Value, Patch, Value2>(
    self: Differ<Value, Patch>, 
    options: { 
      readonly toNew: (value: Value) => Value2; 
      readonly toOld: (value: Value2) => Value; 
    }
  ): Differ<Value2, Patch>; 
}

----------------------------------------

TITLE: Implementing headNonEmpty Schema Transform in TypeScript
DESCRIPTION: A utility function that extracts the first element from a non-empty readonly array within a Schema context. This transformation preserves type safety and schema constraints while providing access to the head element.

LANGUAGE: typescript
CODE:
declare const headNonEmpty: <S extends Schema.Any, A extends array_.NonEmptyReadonlyArray<unknown>>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => transform<S, SchemaClass<A[number]>>

----------------------------------------

TITLE: Transforming Cause Objects with Custom Handlers in TypeScript
DESCRIPTION: Function signature for the Cause.match utility that processes a Cause object using custom handlers for each possible case type. The function takes an options object containing handlers for empty causes, failures, defects, interruptions, and sequential/parallel cause combinations, returning a single value of type Z.

LANGUAGE: typescript
CODE:
declare const match: { 
  <Z, E>(options: { 
    readonly onEmpty: Z; 
    readonly onFail: (error: E) => Z; 
    readonly onDie: (defect: unknown) => Z; 
    readonly onInterrupt: (fiberId: FiberId.FiberId) => Z; 
    readonly onSequential: (left: Z, right: Z) => Z; 
    readonly onParallel: (left: Z, right: Z) => Z; 
  }): (self: Cause<E>) => Z; 
  <Z, E>(self: Cause<E>, options: { 
    readonly onEmpty: Z; 
    readonly onFail: (error: E) => Z; 
    readonly onDie: (defect: unknown) => Z; 
    readonly onInterrupt: (fiberId: FiberId.FiberId) => Z; 
    readonly onSequential: (left: Z, right: Z) => Z; 
    readonly onParallel: (left: Z, right: Z) => Z; 
  }): Z; 
}

----------------------------------------

TITLE: Defining BrandErrors Interface in TypeScript
DESCRIPTION: This code snippet defines the BrandErrors interface, which extends the Array type to represent a list of RefinementError objects. It is used in the Brand module of the Effect package to handle refinement errors.

LANGUAGE: typescript
CODE:
export interface BrandErrors extends Array<RefinementError> {}

----------------------------------------

TITLE: Defining isParseError Function in TypeScript for Cron Module
DESCRIPTION: This snippet defines the isParseError function in the Cron module. It takes an unknown value and returns a boolean indicating whether the value is of type ParseError. This function is useful for type checking and error handling in cron-related operations.

LANGUAGE: typescript
CODE:
declare const isParseError: (u: unknown) => u is ParseError

----------------------------------------

TITLE: Retrieving Live Test Service in TypeScript using Effect
DESCRIPTION: Defines a constant 'live' that represents an Effect for obtaining the Live service for testing. It has no input requirements and produces no errors, returning a Live.TestLive instance.

LANGUAGE: typescript
CODE:
declare const live: Effect.Effect<Live.TestLive, never, never>

----------------------------------------

TITLE: Creating Supervisor from Effect in TypeScript
DESCRIPTION: The fromEffect function creates a new supervisor that constantly yields the given effect when polled. It takes an Effect<A> as input and returns a Supervisor<A>.

LANGUAGE: typescript
CODE:
declare const fromEffect: <A>(effect: Effect.Effect<A>) => Supervisor<A>

----------------------------------------

TITLE: Defining List.drop Function in TypeScript
DESCRIPTION: Declares the drop function for the List module. This function removes the first n elements from a given list. It can be called with either the number of elements to drop followed by the list, or with the list followed by the number of elements to drop.

LANGUAGE: typescript
CODE:
declare const drop: { (n: number): <A>(self: List<A>) => List<A>; <A>(self: List<A>, n: number): List<A>; }

----------------------------------------

TITLE: Creating SortedSet from Iterable in TypeScript
DESCRIPTION: The fromIterable function creates a new SortedSet from an iterable collection of values. It requires an Order object for comparison and can be called with either the order first and iterable second, or vice versa.

LANGUAGE: typescript
CODE:
declare const fromIterable: { <B>(ord: Order<B>): <A extends B>(iterable: Iterable<A>) => SortedSet<A>; <A extends B, B>(iterable: Iterable<A>, ord: Order<B>): SortedSet<A>; }

----------------------------------------

TITLE: Converting Either to Micro Effect in TypeScript
DESCRIPTION: The fromEither function converts an Either type into a Micro effect. If the Either is a Left, the Micro effect will fail with the left value. If it's a Right, the Micro effect will succeed with the right value.

LANGUAGE: typescript
CODE:
declare const fromEither: <R, L>(either: Either.Either<R, L>) => Micro<R, L>

----------------------------------------

TITLE: Setting Scheduling Priority in Effect Module
DESCRIPTION: Function signature for withSchedulingPriority that sets the scheduling priority when yielding effects. It supports both curried and uncurried calling styles for setting priority on Effect instances.

LANGUAGE: typescript
CODE:
declare const withSchedulingPriority: { 
  (priority: number): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; 
  <A, E, R>(self: Effect<A, E, R>, priority: number): Effect<A, E, R>; 
}

----------------------------------------

TITLE: Implementing Channel Error Handling in TypeScript
DESCRIPTION: The orDie function transforms channel failure into fiber death, making all failures unchecked and removing them from the channel's type signature. It accepts either a channel and error handler or just an error handler that can be applied to a channel.

LANGUAGE: typescript
CODE:
declare const orDie: {
  <E>(error: LazyArg<E>): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>
    (self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) =>
      Channel<OutElem, InElem, never, InErr, OutDone, InDone, Env>;
  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, E>
    (self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, error: LazyArg<E>):
      Channel<OutElem, InElem, never, InErr, OutDone, InDone, Env>;
}

----------------------------------------

TITLE: Implementing Duration Tracking with Metric in TypeScript
DESCRIPTION: Defines a trackDurationWith function that creates an aspect to measure the duration of effect execution. The function accepts a metric and a conversion function to transform Duration into the metric's input type.

LANGUAGE: typescript
CODE:
declare const trackDurationWith: { 
  <Type, In, Out>(metric: Metric<Type, In, Out>, f: (duration: Duration.Duration) => In): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; 
  <A, E, R, Type, In, Out>(self: Effect.Effect<A, E, R>, metric: Metric<Type, In, Out>, f: (duration: Duration.Duration) => In): Effect.Effect<A, E, R>; 
}

----------------------------------------

TITLE: Checking Flattened Status in TypeScript
DESCRIPTION: The isFlattened function checks if a given Flatten<A> is of type Flattened<A>. It returns true if the input is a Flattened instance, false otherwise. This function is useful for type narrowing in conditional logic.

LANGUAGE: typescript
CODE:
declare const isFlattened: <A>(a: Flatten<A>) => a is Flattened<A>

----------------------------------------

TITLE: Creating Intervals with ScheduleInterval.make in TypeScript
DESCRIPTION: The 'make' function constructs a new interval from two specified endpoints (start and end milliseconds). If the start is greater than the end, a zero-size interval is returned. This function is part of the ScheduleInterval module in the Effect package.

LANGUAGE: typescript
CODE:
declare const make: (startMillis: number, endMillis: number) => Interval

----------------------------------------

TITLE: Converting Iterable to Option in TypeScript
DESCRIPTION: The fromIterable function converts an Iterable into an Option, wrapping the first element if it exists. It returns Some with the first element if the Iterable is non-empty, or None if it's empty.

LANGUAGE: typescript
CODE:
import { Option } from "effect"

console.log(Option.fromIterable([1, 2, 3]))
// Output: { _id: 'Option', _tag: 'Some', value: 1 }

console.log(Option.fromIterable([]))
// Output: { _id: 'Option', _tag: 'None' }

LANGUAGE: typescript
CODE:
declare const fromIterable: <A>(collection: Iterable<A>) => Option<A>

----------------------------------------

TITLE: Converting TemplateLiteral AST to RegExp in TypeScript
DESCRIPTION: Function that takes a TemplateLiteral AST node and converts it into a regular expression. This is a non-capturing variant, with a separate function available for capturing patterns.

LANGUAGE: typescript
CODE:
declare const getTemplateLiteralRegExp: (ast: TemplateLiteral) => RegExp

----------------------------------------

TITLE: Defining unsafeSet Function in FiberHandle Module (TypeScript)
DESCRIPTION: Declares the unsafeSet function for setting a fiber in a FiberHandle. It allows setting a new fiber, optionally interrupting an existing one, and configuring behavior through options like interruptAs, onlyIfMissing, and propagateInterruption.

LANGUAGE: typescript
CODE:
declare const unsafeSet: {
  <A, E, XE extends E, XA extends A>(
    fiber: Fiber.RuntimeFiber<XA, XE>,
    options?: {
      readonly interruptAs?: FiberId.FiberId | undefined;
      readonly onlyIfMissing?: boolean | undefined;
      readonly propagateInterruption?: boolean | undefined;
    }
  ): (self: FiberHandle<A, E>) => void;
  <A, E, XE extends E, XA extends A>(
    self: FiberHandle<A, E>,
    fiber: Fiber.RuntimeFiber<XA, XE>,
    options?: {
      readonly interruptAs?: FiberId.FiberId | undefined;
      readonly onlyIfMissing?: boolean | undefined;
      readonly propagateInterruption?: boolean | undefined;
    }
  ): void;
}

----------------------------------------

TITLE: Concatenating DocTree Elements in TypeScript
DESCRIPTION: Function signature for horizontally concatenating multiple DocTree elements in the Effect Printer module. Takes an array of DocTree elements and combines them into a single DocTree.

LANGUAGE: typescript
CODE:
declare const concat: <A>(trees: ReadonlyArray<DocTree<A>>) => DocTree<A>

----------------------------------------

TITLE: Type Checking PageWidth for Unbounded Type in TypeScript
DESCRIPTION: A type guard function that checks whether a given PageWidth instance is of the Unbounded type. Returns true if the PageWidth is Unbounded, false otherwise. This function is part of the @effect/printer package's PageWidth module.

LANGUAGE: typescript
CODE:
declare const isUnbounded: (self: PageWidth) => self is Unbounded

----------------------------------------

TITLE: Testing String Type in TypeScript using Effect Package
DESCRIPTION: Demonstrates how to use the String.isString function from the Effect package to check if a value is a string. The example shows testing both a string and a number.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { String } from "effect"

assert.deepStrictEqual(String.isString("a"), true)
assert.deepStrictEqual(String.isString(1), false)

----------------------------------------

TITLE: Inserting Key-Value Pairs into RedBlackTree in TypeScript
DESCRIPTION: Function signature for inserting a new key-value pair into a Red-Black Tree. Supports both curried and non-curried versions of the insert operation, allowing flexible usage patterns. Returns a new RedBlackTree instance containing the inserted element.

LANGUAGE: typescript
CODE:
declare const insert: { 
  <K, V>(key: K, value: V): (self: RedBlackTree<K, V>) => RedBlackTree<K, V>; 
  <K, V>(self: RedBlackTree<K, V>, key: K, value: V): RedBlackTree<K, V>; 
}

----------------------------------------

TITLE: Calculating Time Zone Offset in TypeScript using Effect's DateTime Module
DESCRIPTION: The zonedOffset function calculates the time zone offset of a DateTime.Zoned object in milliseconds. It takes a Zoned object as input and returns a number representing the offset.

LANGUAGE: typescript
CODE:
declare const zonedOffset: (self: Zoned) => number

----------------------------------------

TITLE: Stream.drain Function Signature in TypeScript
DESCRIPTION: This code snippet shows the TypeScript signature for the Stream.drain function. It takes a Stream of type A, E, R and returns a Stream of never, E, R, effectively removing all emitted elements while preserving error and resource types.

LANGUAGE: typescript
CODE:
declare const drain: <A, E, R>(self: Stream<A, E, R>) => Stream<never, E, R>

----------------------------------------

TITLE: Defining Equivalence.struct Function in TypeScript
DESCRIPTION: This function creates a new Equivalence that compares values of a struct by applying each Equivalence to the corresponding property of the struct. It takes a record of Equivalences as input and returns a new Equivalence for the entire struct.

LANGUAGE: typescript
CODE:
declare const struct: <R extends Record<string, Equivalence<any>>>(fields: R) => Equivalence<{ readonly [K in keyof R]: [R[K]] extends [Equivalence<infer A>] ? A : never; }>

----------------------------------------

TITLE: Defining failCauseSync Function in TypeScript for Channel Module
DESCRIPTION: This snippet defines the failCauseSync function, which constructs a channel that succeeds immediately with a specified lazily evaluated Cause. It takes a LazyArg of Cause<E> and returns a Channel that never produces output but may fail with the specified cause.

LANGUAGE: typescript
CODE:
declare const failCauseSync: <E>(evaluate: LazyArg<Cause.Cause<E>>) => Channel<never, unknown, E, unknown, never, unknown>

----------------------------------------

TITLE: Trie.compact Function Signature in TypeScript
DESCRIPTION: Provides the TypeScript signature for the Trie.compact function, which takes a Trie of Options and returns a Trie of the underlying type.

LANGUAGE: typescript
CODE:
declare const compact: <A>(self: Trie<Option<A>>) => Trie<A>

----------------------------------------

TITLE: Appending Elements to Chunks in TypeScript
DESCRIPTION: The append function adds a specified element to the end of a Chunk. It can be used in two ways: as a standalone function or as a method on a Chunk object. The function returns a NonEmptyChunk, which is guaranteed to contain at least one element.

LANGUAGE: typescript
CODE:
declare const append: { <A2>(a: A2): <A>(self: Chunk<A>) => NonEmptyChunk<A2 | A>; <A, A2>(self: Chunk<A>, a: A2): NonEmptyChunk<A | A2>; }

----------------------------------------

TITLE: Defining fileSchema Function in TypeScript for @effect/cli Args Module
DESCRIPTION: Declares the fileSchema function that creates a file argument. It takes a schema and optional configuration, and returns an Args<A>. The function can read, parse, and validate file contents, with an optional custom argument name.

LANGUAGE: typescript
CODE:
declare const fileSchema: <I, A>(schema: Schema<A, I, FileSystem | Path | Terminal>, config?: Args.FormatArgsConfig | undefined) => Args<A>

----------------------------------------

TITLE: Defining distributedWith Function in TypeScript for Stream Module
DESCRIPTION: Declares the distributedWith function, which distributes stream elements to multiple queues based on a custom decision function. It takes options including the number of queues, maximum lag, and a decision function. Returns an Effect that produces a tuple of Dequeues containing the distributed stream elements.

LANGUAGE: TypeScript
CODE:
declare const distributedWith: { <N extends number, A>(options: { readonly size: N; readonly maximumLag: number; readonly decide: (a: A) => Effect.Effect<Predicate<number>>; }): <E, R>(self: Stream<A, E, R>) => Effect.Effect<TupleOf<N, Queue.Dequeue<Exit.Exit<A, Option.Option<E>>>>, never, Scope.Scope | R>; <A, E, R, N extends number>(self: Stream<A, E, R>, options: { readonly size: N; readonly maximumLag: number; readonly decide: (a: A) => Effect.Effect<Predicate<number>>; }): Effect.Effect<TupleOf<N, Queue.Dequeue<Exit.Exit<A, Option.Option<E>>>>, never, Scope.Scope | R>; }

----------------------------------------

TITLE: Declaring URL Protocol Setter in TypeScript
DESCRIPTION: Defines a function to update the protocol of a URL. The function is curried and can accept either a protocol string first followed by a URL, or a URL and protocol string together. Returns a new URL instance with the updated protocol.

LANGUAGE: typescript
CODE:
declare const setProtocol: { (protocol: string): (url: URL) => URL; (url: URL, protocol: string): URL; }

----------------------------------------

TITLE: Redacted.value Function Signature in TypeScript
DESCRIPTION: This code snippet shows the TypeScript signature for the Redacted.value function. It takes a Redacted<A> instance as input and returns the original value of type A.

LANGUAGE: typescript
CODE:
declare const value: <A>(self: Redacted<A>) => A

----------------------------------------

TITLE: Checking AvailablePerLine in PageWidth Module (TypeScript)
DESCRIPTION: The isAvailablePerLine function is a type guard that checks if a given PageWidth is of type AvailablePerLine. It returns true if the input is an AvailablePerLine, and false otherwise. This function is useful for narrowing down the type of a PageWidth object in TypeScript.

LANGUAGE: typescript
CODE:
declare const isAvailablePerLine: (self: PageWidth) => self is AvailablePerLine

----------------------------------------

TITLE: Grouping Consecutive Equal Elements in TypeScript Iterable
DESCRIPTION: This function groups equal, consecutive elements of an Iterable into NonEmptyArrays. It takes an Iterable of type A as input and returns an Iterable of NonEmptyArrays of type A.

LANGUAGE: typescript
CODE:
declare const group: <A>(self: Iterable<A>) => Iterable<NonEmptyArray<A>>

----------------------------------------

TITLE: Using Record.replace in TypeScript
DESCRIPTION: Demonstrates how to replace a value in a record by its key. The function takes a key and new value, returning a new record with the updated value. If the specified key doesn't exist, the original record is returned unchanged.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Record } from "effect"

assert.deepStrictEqual(Record.replace("a", 3)({ a: 1, b: 2 }), { a: 3, b: 2 });
assert.deepStrictEqual(Record.replace("c", 3)({ a: 1, b: 2 }), { a: 1, b: 2 });

LANGUAGE: typescript
CODE:
declare const replace: { <K extends string | symbol, B>(key: NoInfer<K>, value: B): <A>(self: ReadonlyRecord<K, A>) => Record<K, A | B>; <K extends string | symbol, A, B>(self: ReadonlyRecord<K, A>, key: NoInfer<K>, value: B): Record<K, A | B>; }

----------------------------------------

TITLE: Defining ScopeTypeId Type in TypeScript
DESCRIPTION: Defines the ScopeTypeId type as the type of the unique identifier for Scope. This type is based on the ScopeTypeId constant.

LANGUAGE: typescript
CODE:
type ScopeTypeId = typeof ScopeTypeId

----------------------------------------

TITLE: Retrieving Fiber Children in TypeScript
DESCRIPTION: The 'children' function retrieves the immediate children of a given fiber. It takes a Fiber<A, E> as input and returns an Effect that resolves to an array of RuntimeFiber instances. This function is useful for inspecting the hierarchical structure of fibers in an Effect-based application.

LANGUAGE: typescript
CODE:
declare const children: <A, E>(self: Fiber<A, E>) => Effect.Effect<Array<RuntimeFiber<any, any>>>

----------------------------------------

TITLE: Updating Metrics in TypeScript using effect Package
DESCRIPTION: The update function allows updating a metric with a specified input. It can be used for various metric types, such as incrementing a counter. The function is overloaded to accept inputs in different orders.

LANGUAGE: typescript
CODE:
declare const update: { <In>(input: In): <Type, Out>(self: Metric<Type, In, Out>) => Effect.Effect<void>; <Type, In, Out>(self: Metric<Type, In, Out>, input: In): Effect.Effect<void>; }

----------------------------------------

TITLE: Type Checking ManagedRuntime in TypeScript
DESCRIPTION: Type guard function that checks if the provided input argument is a ManagedRuntime instance. Takes an unknown input and returns a type predicate indicating if the value is a ManagedRuntime<unknown, unknown>.

LANGUAGE: typescript
CODE:
declare const isManagedRuntime: (input: unknown) => input is ManagedRuntime<unknown, unknown>

----------------------------------------

TITLE: Defining OpenAI Telemetry Attributes Type in TypeScript
DESCRIPTION: Defines a composite type that combines generic AI telemetry attributes with OpenAI-specific request and response attributes. This type is used for comprehensive telemetry tracking in OpenAI integrations.

LANGUAGE: typescript
CODE:
type AllAttributes = AiTelemetry.GenAI.AllAttributes & RequestAttributes & ResponseAttributes

----------------------------------------

TITLE: Reducing Trie Entries in TypeScript
DESCRIPTION: Demonstrates how to use the Trie.reduce function to aggregate values or keys from a Trie data structure. The function can accumulate numeric values or concatenate keys.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Trie } from "effect"

const trie = Trie.empty<number>().pipe(
  Trie.insert("shells", 0),
  Trie.insert("sells", 1),
  Trie.insert("she", 2)
)

assert.equal(
  trie.pipe(
    Trie.reduce(0, (acc, n) => acc + n)
  ),
  3
)
assert.equal(
  trie.pipe(
    Trie.reduce(10, (acc, n) => acc + n)
  ),
  13
)
assert.equal(
  trie.pipe(
    Trie.reduce("", (acc, _, key) => acc + key)
  ),
  "sellssheshells"
)

----------------------------------------

TITLE: Defining concatMapWithCustom Function in TypeScript
DESCRIPTION: This code snippet defines the concatMapWithCustom function, which creates a new channel by concatenating and merging outputs from multiple channels. It takes functions for mapping outputs, merging terminal values, handling pull requests, and making child executor decisions.

LANGUAGE: typescript
CODE:
declare const concatMapWithCustom: { <OutElem, OutElem2, InElem2, OutErr2, InErr2, OutDone, InDone2, Env2, OutDone2, OutDone3>(f: (o: OutElem) => Channel<OutElem2, InElem2, OutErr2, InErr2, OutDone, InDone2, Env2>, g: (o: OutDone, o1: OutDone) => OutDone, h: (o: OutDone, o2: OutDone2) => OutDone3, onPull: (upstreamPullRequest: UpstreamPullRequest.UpstreamPullRequest<OutElem>) => UpstreamPullStrategy.UpstreamPullStrategy<OutElem2>, onEmit: (elem: OutElem2) => ChildExecutorDecision.ChildExecutorDecision): <Env, InErr, InElem, InDone, OutErr>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env>) => Channel<OutElem2, InElem & InElem2, OutErr2 | OutErr, InErr & InErr2, OutDone3, InDone & InDone2, Env2 | Env>; <OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env, OutElem2, InElem2, OutErr2, InErr2, OutDone, InDone2, Env2, OutDone3>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone2, InDone, Env>, f: (o: OutElem) => Channel<OutElem2, InElem2, OutErr2, InErr2, OutDone, InDone2, Env2>, g: (o: OutDone, o1: OutDone) => OutDone, h: (o: OutDone, o2: OutDone2) => OutDone3, onPull: (upstreamPullRequest: UpstreamPullRequest.UpstreamPullRequest<OutElem>) => UpstreamPullStrategy.UpstreamPullStrategy<OutElem2>, onEmit: (elem: OutElem2) => ChildExecutorDecision.ChildExecutorDecision): Channel<OutElem2, InElem & InElem2, OutErr | OutErr2, InErr & InErr2, OutDone3, InDone & InDone2, Env | Env2>; }

----------------------------------------

TITLE: Implementing Bounded.between Function in TypeScript
DESCRIPTION: Defines a function 'between' that checks if a value is between the lower and upper limit of a Bounded type. It takes a Bounded<A> as a parameter and returns a function that accepts a value of type A and returns a boolean.

LANGUAGE: typescript
CODE:
declare const between: <A>(B: Bounded<A>) => (a: A) => boolean

----------------------------------------

TITLE: Declaring splitLines Function in TypeScript for Effect Package
DESCRIPTION: Declares the splitLines function, which creates a Channel that splits input strings on newlines. It handles both Windows (\r\n) and UNIX (\n) newline formats. The function takes no parameters and returns a Channel that processes chunks of strings.

LANGUAGE: typescript
CODE:
declare const splitLines: <Err, Done>() => Channel<Chunk.Chunk<string>, Chunk.Chunk<string>, Err, Err, Done, Done, never>

----------------------------------------

TITLE: Defining PrettyError Interface in TypeScript
DESCRIPTION: Defines a PrettyError interface that extends the standard Error type with an optional span property for source code location information. Used for creating prettified error messages with source context.

LANGUAGE: typescript
CODE:
export interface PrettyError extends Error {
  readonly span: Span | undefined
}

----------------------------------------

TITLE: Defining keySet Function for HashMap in TypeScript
DESCRIPTION: Declares a function named keySet that takes a HashMap as input and returns a HashSet of its keys. The function is generic, working with any key and value types.

LANGUAGE: typescript
CODE:
declare const keySet: <K, V>(self: HashMap<K, V>) => HashSet<K>

----------------------------------------

TITLE: Using Number.divide for Safe Division in TypeScript
DESCRIPTION: Demonstrates how to use the Number.divide function to perform safe division operations that handle division by zero by returning Option types. The function returns Some(result) for valid divisions and None for division by zero.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Number, Option } from "effect"

assert.deepStrictEqual(Number.divide(6, 3), Option.some(2))
assert.deepStrictEqual(Number.divide(6, 0), Option.none())

LANGUAGE: typescript
CODE:
declare const divide: { (that: number): (self: number) => Option<number>; (self: number, that: number): Option<number>; }

----------------------------------------

TITLE: Effect.liftPredicate Type Signature
DESCRIPTION: Type signature showing the function overloads for Effect.liftPredicate. Supports both refinement and predicate functions, with options for curried and non-curried usage.

LANGUAGE: typescript
CODE:
declare const liftPredicate: { <A, B extends A, E>(refinement: Refinement<NoInfer<A>, B>, orFailWith: (a: NoInfer<A>) => E): (a: A) => Effect<B, E>; <A, E>(predicate: Predicate<NoInfer<A>>, orFailWith: (a: NoInfer<A>) => E): (a: A) => Effect<A, E>; <A, E, B extends A>(self: A, refinement: Refinement<A, B>, orFailWith: (a: A) => E): Effect<B, E>; <A, E>(self: A, predicate: Predicate<NoInfer<A>>, orFailWith: (a: NoInfer<A>) => E): Effect<A, E>; }

----------------------------------------

TITLE: Schema.NonEmptyTrimmedString Class Declaration in TypeScript
DESCRIPTION: This snippet shows the class declaration for Schema.NonEmptyTrimmedString. It is a TypeScript class used for validating non-empty trimmed strings.

LANGUAGE: typescript
CODE:
declare class NonEmptyTrimmedString

----------------------------------------

TITLE: Rendering Decorated DocTree Example in TypeScript
DESCRIPTION: Demonstrates how to use DocTree.renderSimplyDecorated to render an annotated document tree with custom decorations. The example shows annotating text with void type and surrounding annotated regions with >>> and <<<.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import * as DocTree from "@effect/printer/DocTree"
import * as Layout from "@effect/printer/Layout"
import { identity, pipe } from "effect/Function"
import * as String from "@effect/typeclass/data/String"

const doc: Doc.Doc<void> = Doc.hsep([
  Doc.text("hello"),
  pipe(
    Doc.text("world"),
    Doc.annotate(undefined),
    Doc.cat(Doc.char("!"))
  )
])

const tree = DocTree.treeForm(Layout.pretty(Layout.defaultOptions)(doc))

const rendered = pipe(
  tree,
  DocTree.renderSimplyDecorated(String.Monoid, identity, (_, x) => `>>>${x}<<<`)
)

assert.strictEqual(
  rendered,
  "hello >>>world<<<!"
)

LANGUAGE: typescript
CODE:
declare const renderSimplyDecorated: { <A, M>(M: monoid.Monoid<M>, renderText: (text: string) => M, renderAnnotation: (annotation: A, out: M) => M): (self: DocTree<A>) => M; <A, M>(self: DocTree<A>, M: monoid.Monoid<M>, renderText: (text: string) => M, renderAnnotation: (annotation: A, out: M) => M): M; }

----------------------------------------

TITLE: Parsing Cookie Headers in TypeScript with @effect/platform
DESCRIPTION: Function that parses a cookie header string into a Record object containing key-value pairs. This implementation is adapted from the fastify-cookie library and is used for processing HTTP cookie headers.

LANGUAGE: typescript
CODE:
declare const parseHeader: (header: string) => Record<string, string>

----------------------------------------

TITLE: Implementing Chunk Equivalence Comparison in TypeScript
DESCRIPTION: Defines a function that creates an equivalence comparison for chunks of equal length using a provided equivalence function. The function accepts an equivalence function for type A and returns an equivalence function for Chunk<A>.

LANGUAGE: typescript
CODE:
declare const getEquivalence: <A>(isEquivalent: Equivalence.Equivalence<A>) => Equivalence.Equivalence<Chunk<A>>

----------------------------------------

TITLE: Checking for Die Cause Type in TypeScript
DESCRIPTION: The isDieType function checks if a given Cause is of the Die type. It takes a Cause<E> as input and returns a boolean indicating if it's a Die cause. This function is useful for type narrowing in conditional statements.

LANGUAGE: typescript
CODE:
declare const isDieType: <E>(self: Cause<E>) => self is Die

----------------------------------------

TITLE: Implementing Unsafe Element Access in Effect Chunk Module - TypeScript
DESCRIPTION: Function declaration for unsafeGet that retrieves an element from a Chunk at a specified index. This is an unsafe operation that will throw an error if the index is out of bounds. The function supports both curried and uncurried calling styles.

LANGUAGE: typescript
CODE:
declare const unsafeGet: { (index: number): <A>(self: Chunk<A>) => A; <A>(self: Chunk<A>, index: number): A; }

----------------------------------------

TITLE: Type Checking ChildExecutorDecision in TypeScript
DESCRIPTION: This function checks if a given value is of type ChildExecutorDecision. It takes an unknown value as input and returns a boolean indicating whether the value is a ChildExecutorDecision or not. This type guard can be used for runtime type checking.

LANGUAGE: typescript
CODE:
declare const isChildExecutorDecision: (u: unknown) => u is ChildExecutorDecision

----------------------------------------

TITLE: Declaring firstSuccessOf Function in TypeScript for STM Module
DESCRIPTION: This code snippet defines the signature of the firstSuccessOf function. It takes an iterable of STM values and returns a new STM value representing the first successful STM value in the iterable, or a failed STM value if all inputs fail.

LANGUAGE: typescript
CODE:
declare const firstSuccessOf: <A, E, R>(effects: Iterable<STM<A, E, R>>) => STM<A, E, R>

----------------------------------------

TITLE: Defining EncodeException Interface in TypeScript
DESCRIPTION: Defines a TypeScript interface for encoding exceptions. The interface includes a type tag, an exception type ID, the input string that failed encoding, and an optional error message.

LANGUAGE: typescript
CODE:
export interface EncodeException {
  readonly _tag: "EncodeException"
  readonly [EncodeExceptionTypeId]: EncodeExceptionTypeId
  readonly input: string
  readonly message?: string
}

----------------------------------------

TITLE: Declaring Error Constructor Type in TypeScript
DESCRIPTION: Defines a constructor type for creating YieldableError instances with optional custom properties. The constructor accepts a generic type parameter A extending Record<string,any> and returns a YieldableError with readonly properties from type A.

LANGUAGE: typescript
CODE:
declare const Error: new <A extends Record<string, any> = {}>(args: Types.Equals<A, {}> extends true ? void : { readonly [P in keyof A]: A[P]; }) => Cause.YieldableError & Readonly<A>

----------------------------------------

TITLE: Implementing foldUntil Sink in TypeScript
DESCRIPTION: Creates a sink that folds elements of type In into a structure of type S until a maximum number of elements have been processed. Similar to Sink.foldWeighted but uses a constant cost function of 1.

LANGUAGE: typescript
CODE:
declare const foldUntil: <In, S>(s: S, max: number, f: (s: S, input: In) => S) => Sink<S, In, In>

----------------------------------------

TITLE: Implementing Scoped Sink Construction in TypeScript
DESCRIPTION: Function signature for unwrapScopedWith, which creates a Sink by taking a function that accepts a Scope parameter and returns an Effect containing a Sink. This allows for scoped resource management when constructing Sinks.

LANGUAGE: typescript
CODE:
declare const unwrapScopedWith: <A, In, L, E, R>(f: (scope: Scope.Scope) => Effect.Effect<Sink<A, In, L, E, R>, E, R>) => Sink<A, In, L, E, R>

----------------------------------------

TITLE: Retrieving Die Defect from Cause in TypeScript
DESCRIPTION: Function signature for dieOption that extracts the first Die defect from a Cause. Returns an Option containing the first unexpected failure if present. Useful for error chain diagnosis.

LANGUAGE: typescript
CODE:
declare const dieOption: <E>(self: Cause<E>) => Option.Option<unknown>

----------------------------------------

TITLE: Implementing Fiber.zipWith in TypeScript
DESCRIPTION: Defines a function that combines two fibers using a combiner function. The operation performs both joins and interruptions sequentially from left to right, returning a new fiber with the combined result.

LANGUAGE: typescript
CODE:
declare const zipWith: {
  <B, E2, A, C>(that: Fiber<B, E2>, f: (a: A, b: B) => C): <E>(self: Fiber<A, E>) => Fiber<C, E2 | E>;
  <A, E, B, E2, C>(self: Fiber<A, E>, that: Fiber<B, E2>, f: (a: A, b: B) => C): Fiber<C, E | E2>;
}

----------------------------------------

TITLE: Comparing Schedule Intervals with lessThan in TypeScript
DESCRIPTION: Defines a function that compares two Schedule Intervals to determine if one is less than the other. The function is implemented with curried and non-curried variants for flexibility in usage.

LANGUAGE: typescript
CODE:
declare const lessThan: { (that: Interval): (self: Interval) => boolean; (self: Interval, that: Interval): boolean; }

----------------------------------------

TITLE: Checking Runtime Type for FiberId in TypeScript
DESCRIPTION: A type predicate function that determines if a given FiberId instance is specifically a Runtime type. Returns true for Runtime instances and false for other FiberId types.

LANGUAGE: typescript
CODE:
declare const isRuntime: (self: FiberId) => self is Runtime

----------------------------------------

TITLE: Checking RequestResolver Type in TypeScript
DESCRIPTION: Type guard function that checks if an unknown value is an instance of RequestResolver. Returns a boolean indicating whether the input is a RequestResolver with unknown request and response types.

LANGUAGE: typescript
CODE:
declare const isRequestResolver: (u: unknown) => u is RequestResolver<unknown, unknown>

----------------------------------------

TITLE: Implementing Channel mapEffect Function in TypeScript
DESCRIPTION: Defines a function that transforms a channel by applying an effectful function to its terminal value. The function supports both curried and uncurried versions, allowing for flexible channel transformation while preserving type safety.

LANGUAGE: typescript
CODE:
declare const mapEffect: { <OutDone, OutDone1, OutErr1, Env1>(f: (o: OutDone) => Effect.Effect<OutDone1, OutErr1, Env1>): <OutElem, InElem, OutErr, InErr, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr1 | OutErr, InErr, OutDone1, InDone, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutDone1, OutErr1, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (o: OutDone) => Effect.Effect<OutDone1, OutErr1, Env1>): Channel<OutElem, InElem, OutErr | OutErr1, InErr, OutDone1, InDone, Env | Env1>; }

----------------------------------------

TITLE: HashSet.size Function Signature in TypeScript
DESCRIPTION: Provides the TypeScript type signature for the HashSet.size function. It takes a HashSet of any type A and returns a number representing the size of the set.

LANGUAGE: typescript
CODE:
declare const size: <A>(self: HashSet<A>) => number

----------------------------------------

TITLE: Stream.grouped Type Signature
DESCRIPTION: Type signature for the Stream.grouped function showing its polymorphic nature. It can be called either with chunkSize first or with the stream first followed by chunkSize.

LANGUAGE: typescript
CODE:
declare const grouped: { (chunkSize: number): <A, E, R>(self: Stream<A, E, R>) => Stream<Chunk.Chunk<A>, E, R>; <A, E, R>(self: Stream<A, E, R>, chunkSize: number): Stream<Chunk.Chunk<A>, E, R>; }

----------------------------------------

TITLE: Declaring findFirstIndexFrom Function in TypeScript
DESCRIPTION: This snippet defines the findFirstIndexFrom function, which searches for the first occurrence of a value in a TArray starting from a specified index. It returns an STM (Software Transactional Memory) operation that yields an Option of the found index.

LANGUAGE: typescript
CODE:
declare const findFirstIndexFrom: { <A>(value: A, from: number): (self: TArray<A>) => STM.STM<Option.Option<number>>; <A>(self: TArray<A>, value: A, from: number): STM.STM<Option.Option<number>>; }

----------------------------------------

TITLE: Interrupting Fiber Execution in Effect-TS
DESCRIPTION: Method to interrupt a fiber's execution from another calling fiber. The effect returns immediately if the target fiber has already completed, otherwise it waits for the fiber to exit before resuming. Returns an Effect containing the Exit state of the interrupted fiber.

LANGUAGE: typescript
CODE:
declare const interrupt: <A, E>(self: Fiber<A, E>) => Effect.Effect<Exit.Exit<A, E>>

----------------------------------------

TITLE: Forking a Fiber in a Specific Scope using Effect.forkIn in TypeScript
DESCRIPTION: This example demonstrates how to use Effect.forkIn to fork a child fiber into an outer scope, allowing it to outlive an inner scope but still be terminated when the outer scope is closed. It uses Effect, Console, and Schedule from the effect package.

LANGUAGE: typescript
CODE:
import { Console, Effect, Schedule } from "effect"

// Child fiber that logs a message repeatedly every second
const child = Effect.repeat(
  Console.log("child: still running!"),
  Schedule.fixed("1 second")
)

const program = Effect.scoped(
  Effect.gen(function* () {
    yield* Effect.addFinalizer(() =>
      Console.log("The outer scope is about to be closed!")
    )

    // Capture the outer scope
    const outerScope = yield* Effect.scope

    // Create an inner scope
    yield* Effect.scoped(
      Effect.gen(function* () {
        yield* Effect.addFinalizer(() =>
          Console.log("The inner scope is about to be closed!")
        )
        // Fork the child fiber in the outer scope
        yield* Effect.forkIn(child, outerScope)
        yield* Effect.sleep("3 seconds")
      })
    )

    yield* Effect.sleep("5 seconds")
  })
)

Effect.runFork(program)
// Output:
// child: still running!
// child: still running!
// child: still running!
// The inner scope is about to be closed!
// child: still running!
// child: still running!
// child: still running!
// child: still running!
// child: still running!
// child: still running!
// The outer scope is about to be closed!

----------------------------------------

TITLE: Defining runFoldWhileScoped Function in TypeScript for Stream Module
DESCRIPTION: Declares the runFoldWhileScoped function, which executes a pure fold over a stream of values. It returns a scoped value representing the stream's scope and can stop the fold early based on a condition. The function has two overloads to accommodate different parameter orders.

LANGUAGE: typescript
CODE:
declare const runFoldWhileScoped: { <S, A>(s: S, cont: Predicate<S>, f: (s: S, a: A) => S): <E, R>(self: Stream<A, E, R>) => Effect.Effect<S, E, Scope.Scope | R>; <A, E, R, S>(self: Stream<A, E, R>, s: S, cont: Predicate<S>, f: (s: S, a: A) => S): Effect.Effect<S, E, Scope.Scope | R>; }

----------------------------------------

TITLE: Defining curlyBraced Function in TypeScript for Effect Printer
DESCRIPTION: This snippet defines the curlyBraced function, which takes a Doc<A> as input and returns a new Doc<A> enclosed in curly braces. It's part of the Doc module in the @effect/printer package.

LANGUAGE: typescript
CODE:
declare const curlyBraced: <A>(self: Doc<A>) => Doc<A>

----------------------------------------

TITLE: Array.bind Function Signature in TypeScript
DESCRIPTION: This snippet shows the TypeScript signature for the Array.bind function. It defines the function's type structure, including its generic parameters and return types.

LANGUAGE: typescript
CODE:
declare const bind: { <A extends object, N extends string, B>(tag: Exclude<N, keyof A>, f: (a: NoInfer<A>) => ReadonlyArray<B>): (self: ReadonlyArray<A>) => Array<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }>; <A extends object, N extends string, B>(self: ReadonlyArray<A>, tag: Exclude<N, keyof A>, f: (a: NoInfer<A>) => ReadonlyArray<B>): Array<{ [K in N | keyof A]: K extends keyof A ? A[K] : B; }>; }

----------------------------------------

TITLE: Declaring DateTimeUtcFromSelf Class in TypeScript
DESCRIPTION: Defines a class named DateTimeUtcFromSelf that represents a schema for DateTime.Utc instances. This class is part of the Schema module in the effect package.

LANGUAGE: typescript
CODE:
declare class DateTimeUtcFromSelf

----------------------------------------

TITLE: Creating Failed Fiber in TypeScript Effect Library
DESCRIPTION: Function signature for creating a fiber that has already failed with a specified error value. Takes a generic error type E and returns a Fiber that never succeeds but fails with the provided error.

LANGUAGE: typescript
CODE:
declare const fail: <E>(error: E) => Fiber<never, E>

----------------------------------------

TITLE: Implementing Atomic Reduction for TSet in TypeScript
DESCRIPTION: Defines a reduce function that atomically folds elements of a TSet using a pure function. The function supports both curried and uncurried versions, taking an initial value and a reducer function to combine elements.

LANGUAGE: typescript
CODE:
declare const reduce: {
  <Z, A>(zero: Z, f: (accumulator: Z, value: A) => Z): (self: TSet<A>) => STM.STM<Z>;
  <Z, A>(self: TSet<A>, zero: Z, f: (accumulator: Z, value: A) => Z): STM.STM<Z>;
}

----------------------------------------

TITLE: Retrieving Cookie Value in TypeScript with @effect/platform
DESCRIPTION: The getValue function retrieves a cookie value from a Cookies object. It can be called with either the name parameter first or the Cookies object first. The function returns an Option.Option<string> representing the cookie value if found.

LANGUAGE: typescript
CODE:
declare const getValue: { (name: string): (self: Cookies) => Option.Option<string>; (self: Cookies, name: string): Option.Option<string>; }

----------------------------------------

TITLE: Filtering None Values from Option Lists in TypeScript
DESCRIPTION: The compact function removes all None values from a List containing Option types. It transforms a List<Option<A>> into a List<A> by filtering out None values and unwrapping the Some values.

LANGUAGE: typescript
CODE:
declare const compact: <A>(self: List<Option.Option<A>>) => List<A>

----------------------------------------

TITLE: Defining TestClock.Data Interface in TypeScript
DESCRIPTION: Interface definition for TestClock.Data that maintains the state of a test clock. Contains two readonly properties: instant for the current clock time as a number, and sleeps for managing deferred sleep operations using Chunk data structure.

LANGUAGE: typescript
CODE:
export interface Data {
  readonly instant: number
  readonly sleeps: Chunk.Chunk<readonly [number, Deferred.Deferred<void>]>
}

----------------------------------------

TITLE: Decrementing a Number using effect/Number in TypeScript
DESCRIPTION: Demonstrates how to use the decrement function from the effect/Number module to decrease a number by 1. The example includes an import statement, function call, and assertion to verify the result.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { decrement } from "effect/Number"

assert.deepStrictEqual(decrement(3), 2)

----------------------------------------

TITLE: Implementing Cursor Next Line Movement in TypeScript
DESCRIPTION: Function that moves the cursor to the beginning of the line a specified number of rows down. If no row count is specified, defaults to moving down 1 row. Returns an Ansi type representing the cursor movement operation.

LANGUAGE: typescript
CODE:
declare const cursorNextLine: (rows?: number) => Ansi

----------------------------------------

TITLE: Defining CliConfig Interface in TypeScript
DESCRIPTION: Interface that specifies how command-line arguments should be parsed and displayed. Includes configuration options for case sensitivity, auto-correction threshold, built-in command handling, and various display preferences for help documentation.

LANGUAGE: typescript
CODE:
export interface CliConfig {
  /**
   * Whether or not the argument parser should be case sensitive.
   *
   * Defaults to `false`.
   */
  readonly isCaseSensitive: boolean
  /**
   * Levenstein distance threshold for when to show auto correct suggestions.
   *
   * Defaults to `2`.
   */
  readonly autoCorrectLimit: number
  /**
   * Whether or not to perform a final check of the command-line arguments for
   * a built-in option, even if the provided command is not valid.
   *
   * Defaults to `false`.
   */
  readonly finalCheckBuiltIn: boolean
  /**
   * Whether or not to display all the names of an option in the usage of a
   * particular command.
   *
   * Defaults to `true`.
   */
  readonly showAllNames: boolean
  /**
   * Whether or not to display built-in options in the help documentation
   * generated for a `Command`.
   *
   * Defaults to `true`.
   */
  readonly showBuiltIns: boolean
  /**
   * Whether or not to display the type of an option in the usage of a
   * particular command.
   *
   * Defaults to `true`.
   */
  readonly showTypes: boolean
}

----------------------------------------

TITLE: Declaring isEmpty Function for PubSub in TypeScript
DESCRIPTION: Declares the isEmpty function for the PubSub module. It takes a PubSub<A> as input and returns an Effect that resolves to a boolean, indicating whether the Queue is empty.

LANGUAGE: typescript
CODE:
declare const isEmpty: <A>(self: PubSub<A>) => Effect.Effect<boolean>

----------------------------------------

TITLE: Converting Mailbox to Channel in TypeScript
DESCRIPTION: The toChannel function creates a Channel from a ReadonlyMailbox. It takes a ReadonlyMailbox of type A and E as input and returns a Channel that emits Chunks of type A and can potentially error with type E.

LANGUAGE: typescript
CODE:
declare const toChannel: <A, E>(self: ReadonlyMailbox<A, E>) => Channel<Chunk<A>, unknown, E>

----------------------------------------

TITLE: Declaring tapErrorCause Function in TypeScript
DESCRIPTION: Type declaration for the tapErrorCause function that provides two overloads for handling error causes in Micro instances. The function allows executing side effects by accessing the full MicroCause object and returns a new Micro instance with potentially modified error and requirement types.

LANGUAGE: typescript
CODE:
declare const tapErrorCause: { <E, B, E2, R2>(f: (cause: NoInfer<MicroCause<E>>) => Micro<B, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A, E | E2, R | R2>; <A, E, R, B, E2, R2>(self: Micro<A, E, R>, f: (cause: NoInfer<MicroCause<E>>) => Micro<B, E2, R2>): Micro<A, E | E2, R | R2>; }

----------------------------------------

TITLE: Defining a Recurring Schedule with Input Transformation in TypeScript
DESCRIPTION: Creates a schedule that continuously recurs, applying a specified function to transform input values. This method is useful for defining schedules that map inputs to outputs dynamically, without controlling delays or stopping conditions.

LANGUAGE: typescript
CODE:
declare const fromFunction: <A, B>(f: (a: A) => B) => Schedule<B, A>

----------------------------------------

TITLE: Using withDateUtc Function in DateTime Module (TypeScript)
DESCRIPTION: Demonstrates how to use the withDateUtc function to apply a custom operation on a UTC-adjusted Date object. In this example, it retrieves the timestamp in milliseconds from a DateTime instance.

LANGUAGE: typescript
CODE:
import { DateTime } from "effect"

// get the date in milliseconds
DateTime.unsafeMake(0).pipe(
  DateTime.withDateUtc((date) => date.getTime())
)

----------------------------------------

TITLE: Type Guard for PullAfterNext Strategy in TypeScript
DESCRIPTION: Type guard function that checks if a given UpstreamPullStrategy is specifically a PullAfterNext strategy. Returns true if the strategy is PullAfterNext, false otherwise.

LANGUAGE: typescript
CODE:
declare const isPullAfterNext: <A>(self: UpstreamPullStrategy<A>) => self is PullAfterNext<A>

----------------------------------------

TITLE: Defining Clipboard Layer Type in TypeScript
DESCRIPTION: Declares a type definition for a Layer that interfaces with the navigator.clipboard API. The layer has no requirements (never) and no errors (never), while providing Clipboard functionality.

LANGUAGE: typescript
CODE:
declare const layer: Layer.Layer<Clipboard, never, never>

----------------------------------------

TITLE: Transforming Sink Inputs and Results with dimap in TypeScript
DESCRIPTION: The dimap function transforms both inputs and results of a sink using provided functions. It takes options for input transformation and result transformation, and returns a new sink with modified input and output types.

LANGUAGE: typescript
CODE:
declare const dimap: { <In0, In, A, A2>(options: { readonly onInput: (input: In0) => In; readonly onDone: (a: A) => A2; }): <L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A2, In0, L, E, R>; <A, In, L, E, R, In0, A2>(self: Sink<A, In, L, E, R>, options: { readonly onInput: (input: In0) => In; readonly onDone: (a: A) => A2; }): Sink<A2, In0, L, E, R>; }

----------------------------------------

TITLE: Matching Discriminated Unions with Exhaustive Tags in TypeScript
DESCRIPTION: Demonstrates how to use the Match.tagsExhaustive function to match values based on their _tag field, ensuring all possible cases are handled. This example shows matching for a union type with three possible tags.

LANGUAGE: typescript
CODE:
import { Match, pipe } from "effect"

const match = pipe(
  Match.type<{ _tag: "A"; a: string } | { _tag: "B"; b: number } | { _tag: "C"; c: boolean }>(),
  Match.tagsExhaustive({
    A: (a) => a.a,
    B: (b) => b.b,
    C: (c) => c.c
  })
)

----------------------------------------

TITLE: Transforming Tuple Elements using mapBoth in TypeScript
DESCRIPTION: Demonstrates how to use mapBoth to transform both elements of a tuple using separate mapping functions. The first element is transformed using onFirst function and the second element using onSecond function.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { mapBoth } from "effect/Tuple"

assert.deepStrictEqual(
  mapBoth(["hello", 42], { onFirst: s => s.toUpperCase(), onSecond: n => n.toString() }),
  ["HELLO", "42"]
)

LANGUAGE: typescript
CODE:
declare const mapBoth: { <L1, L2, R1, R2>(options: { readonly onFirst: (e: L1) => L2; readonly onSecond: (a: R1) => R2; }): (self: readonly [L1, R1]) => [L2, R2]; <L1, R1, L2, R2>(self: readonly [L1, R1], options: { readonly onFirst: (e: L1) => L2; readonly onSecond: (a: R1) => R2; }): [L2, R2]; }

----------------------------------------

TITLE: Defining processCommandLine Function for Command-Line Argument Processing in TypeScript
DESCRIPTION: Declares the processCommandLine function, which processes command-line arguments and searches for specified Options. It returns an Effect containing a tuple with an Option<ValidationError>, leftover arguments, and the constructed value of type A. The function can be called with arguments and config first, or with Options first.

LANGUAGE: typescript
CODE:
declare const processCommandLine: { (args: ReadonlyArray<string>, config: CliConfig): <A>(self: Options<A>) => Effect<[Option<ValidationError>, Array<string>, A], ValidationError, FileSystem | Path | Terminal>; <A>(self: Options<A>, args: ReadonlyArray<string>, config: CliConfig): Effect<[Option<ValidationError>, Array<string>, A], ValidationError, FileSystem | Path | Terminal>; }

----------------------------------------

TITLE: Using Doc.nest for Document Indentation in TypeScript
DESCRIPTION: Demonstrates how to use Doc.nest to create a document with nested indentation. The example shows text layout with a 4-space indent applied to specific lines while maintaining document structure.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import { pipe } from "effect/Function"
import * as String from "effect/String"

const doc = Doc.vsep([
  pipe(Doc.vsep(Doc.words("lorem ipsum dolor")), Doc.nest(4)),
  Doc.text("sit"),
  Doc.text("amet")
])

assert.strictEqual(
  Doc.render(doc, { style: "pretty" }),
  String.stripMargin(
    `|lorem
     |    ipsum
     |    dolor
     |sit
     |amet`
  )
)

LANGUAGE: typescript
CODE:
declare const nest: { (indent: number): <A>(self: Doc<A>) => Doc<A>; <A>(self: Doc<A>, indent: number): Doc<A>; }

----------------------------------------

TITLE: Computing Interval Unions in TypeScript
DESCRIPTION: Defines a function that computes the union of two Interval instances. Returns Some containing the unified interval if possible, or None if the intervals cannot form a union. The function supports both curried and uncurried calling styles.

LANGUAGE: typescript
CODE:
declare const union: { 
  (that: Interval): (self: Interval) => Option.Option<Interval>; 
  (self: Interval, that: Interval): Option.Option<Interval>; 
}

----------------------------------------

TITLE: Disconnected Tasks Race Example
DESCRIPTION: Example demonstrating racing disconnected tasks for quicker returns.

LANGUAGE: typescript
CODE:
import { Effect, Console } from "effect"

const task1 = Effect.succeed("task1").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Console.log("task1 done")),
  Effect.onInterrupt(() =>
    Console.log("task1 interrupted").pipe(Effect.delay("100 millis"))
  )
)
const task2 = Effect.succeed("task2").pipe(
  Effect.delay("200 millis"),
  Effect.tap(Console.log("task2 done")),
  Effect.onInterrupt(() =>
    Console.log("task2 interrupted").pipe(Effect.delay("100 millis"))
  )
)

const program = Effect.raceFirst(
  Effect.disconnect(task1),
  Effect.disconnect(task2)
).pipe(Effect.tap(Console.log("more work...")))

Effect.runPromiseExit(program).then(console.log)

----------------------------------------

TITLE: Defining failCause Function in Effect Stream Module (TypeScript)
DESCRIPTION: This code snippet defines the failCause function in the Stream module. It creates a stream that always fails with a specified Cause. The function takes a Cause<E> as an argument and returns a Stream that never emits values and always fails with the given cause.

LANGUAGE: typescript
CODE:
declare const failCause: <E>(cause: Cause.Cause<E>) => Stream<never, E>

----------------------------------------

TITLE: Executing Schedule with Inputs in TypeScript
DESCRIPTION: The run function executes a schedule with a sequence of input values, starting from a specified timestamp, and accumulates all outputs into a Chunk. It's useful for batch processing, simulating execution, or testing schedules with predefined input sequences.

LANGUAGE: typescript
CODE:
declare const run: { <In>(now: number, input: Iterable<In>): <Out, R>(self: Schedule<Out, In, R>) => Effect.Effect<Chunk.Chunk<Out>, never, R>; <Out, In, R>(self: Schedule<Out, In, R>, now: number, input: Iterable<In>): Effect.Effect<Chunk.Chunk<Out>, never, R>; }

----------------------------------------

TITLE: DateTime.getPart Function Signature in TypeScript
DESCRIPTION: The TypeScript signature for the DateTime.getPart function. It shows that the function can be called with either the part first and DateTime object second, or vice versa. The function returns a number representing the requested part of the DateTime.

LANGUAGE: typescript
CODE:
declare const getPart: { (part: keyof DateTime.PartsWithWeekday): (self: DateTime) => number; (self: DateTime, part: keyof DateTime.PartsWithWeekday): number; }

----------------------------------------

TITLE: TypeScript Signature for Either.bindTo Function
DESCRIPTION: This code block provides the TypeScript signature for the Either.bindTo function. It shows that bindTo can be used in two ways: as a curried function or with two arguments for binding a name to an Either value.

LANGUAGE: typescript
CODE:
declare const bindTo: { <N extends string>(name: N): <R, L>(self: Either<R, L>) => Either<{ [K in N]: R; }, L>; <R, L, N extends string>(self: Either<R, L>, name: N): Either<{ [K in N]: R; }, L>; }

----------------------------------------

TITLE: Defining NoInfer Utility Type in TypeScript for Effect Library
DESCRIPTION: Defines the NoInfer utility type, which is used to avoid type inference on a specific parameter. This type is part of the Effect library's Types module.

LANGUAGE: typescript
CODE:
type NoInfer<A> = [A][A extends any ? 0 : never]

----------------------------------------

TITLE: Implementing foldLeft Sink in TypeScript
DESCRIPTION: Defines a function that creates a sink which folds its inputs. It takes an initial state and a folding function as parameters. The function signature shows it returns a Sink that processes inputs of type In and produces a result of type S.

LANGUAGE: typescript
CODE:
declare const foldLeft: <S, In>(s: S, f: (s: S, input: In) => S) => Sink<S, In>

----------------------------------------

TITLE: Implementing Context Splitting in STM with TypeScript
DESCRIPTION: Defines a function that splits an STM context into two parts, allowing partial context provision. Takes a Context<R> parameter and returns a function that can process STM operations while managing the divided context. Enables more granular context control in transactional operations.

LANGUAGE: typescript
CODE:
declare const provideSomeContext: {
  <R>(context: Context.Context<R>): <R1, E, A>(self: STM<A, E, R1>) => STM<A, E, Exclude<R1, R>>;
  <R, R1, E, A>(self: STM<A, E, R1>, context: Context.Context<R>): STM<A, E, Exclude<R1, R>>;
}

----------------------------------------

TITLE: TypeScript Signature for Struct.getEquivalence Function
DESCRIPTION: Provides the TypeScript type signature for the Struct.getEquivalence function. It takes a record of Equivalences and returns a new Equivalence for comparing structs with corresponding property types.

LANGUAGE: typescript
CODE:
declare const getEquivalence: <R extends Record<string, Equivalence.Equivalence<any>>>(isEquivalents: R) => Equivalence.Equivalence<{ readonly [K in keyof R]: [R[K]] extends [Equivalence.Equivalence<infer A>] ? A : never; }>

----------------------------------------

TITLE: Executing Test Workflows with Custom Config in Effect-TS
DESCRIPTION: A utility function that allows running Effect workflows with a custom test configuration service implementation. Supports both curried and uncurried function calls for flexibility in usage.

LANGUAGE: typescript
CODE:
declare const withTestConfig: ((config: TestConfig.TestConfig) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>) & (<A, E, R>(effect: Effect.Effect<A, E, R>, config: TestConfig.TestConfig) => Effect.Effect<A, E, R>)

----------------------------------------

TITLE: Stream.repeatEffect Type Signature - TypeScript
DESCRIPTION: Type signature for the repeatEffect function showing it takes an Effect of type A with error type E and environment R, returning a Stream of the same types.

LANGUAGE: typescript
CODE:
declare const repeatEffect: <A, E, R>(effect: Effect.Effect<A, E, R>) => Stream<A, E, R>

----------------------------------------

TITLE: Effect.catchSomeDefect Function Signature in TypeScript
DESCRIPTION: Provides the TypeScript signature for the Effect.catchSomeDefect function, showing its type parameters and return types.

LANGUAGE: typescript
CODE:
declare const catchSomeDefect: { <A2, E2, R2>(pf: (defect: unknown) => Option.Option<Effect<A2, E2, R2>>): <A, E, R>(self: Effect<A, E, R>) => Effect<A2 | A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, pf: (defect: unknown) => Option.Option<Effect<A2, E2, R2>>): Effect<A | A2, E | E2, R | R2>; }

----------------------------------------

TITLE: Checking Queue Shutdown Status in TypeScript Effect
DESCRIPTION: Function that determines whether a queue has been shut down. Takes either a TDequeue or TEnqueue instance as input and returns an STM boolean value indicating the shutdown status.

LANGUAGE: typescript
CODE:
declare const isShutdown: <A>(self: TDequeue<A> | TEnqueue<A>) => STM.STM<boolean>

----------------------------------------

TITLE: Implementing Race Operation in Effect Micro Module
DESCRIPTION: Defines a race operation that takes two Micro effects and returns a new effect that completes with the result of whichever effect finishes first. The losing effect is automatically interrupted. Supports generic types for values, errors, and requirements.

LANGUAGE: typescript
CODE:
declare const race: {
  <A2, E2, R2>(that: Micro<A2, E2, R2>): <A, E, R>(self: Micro<A, E, R>) => Micro<A | A2, E | E2, R | R2>;
  <A, E, R, A2, E2, R2>(self: Micro<A, E, R>, that: Micro<A2, E2, R2>): Micro<A | A2, E | E2, R | R2>;
}

----------------------------------------

TITLE: Defining dieMessage Function in TypeScript for STM Module
DESCRIPTION: Declares a constant function named dieMessage that takes a string message as input and returns an STM effect. This function is used to kill the fiber running the effect with a Cause.RuntimeException containing the specified message.

LANGUAGE: typescript
CODE:
declare const dieMessage: (message: string) => STM<never>

----------------------------------------

TITLE: Defining End-of-Stream Marker in TypeScript for Effect's Take Module
DESCRIPTION: This code snippet defines the 'end' constant, which represents the end-of-stream marker in the Take module. It is typed as Take<never, never>, indicating it doesn't carry any value or error.

LANGUAGE: typescript
CODE:
declare const end: Take<never, never>

----------------------------------------

TITLE: Using HashSet.union in Effect Library - TypeScript Examples
DESCRIPTION: Demonstrates different ways to perform set union operations using the Effect library's HashSet module. Shows data-last (pipeable), piped, and data-first API approaches. Time complexity is O(n) where n is the number of elements in the set.

LANGUAGE: typescript
CODE:
// Syntax
import { HashSet, pipe } from "effect"

// with data-last, a.k.a. pipeable API
pipe(HashSet.make(1, 2, 3), HashSet.union(HashSet.make(3, 4, 5)))

// or piped with the pipe function
HashSet.make(1, 2, 3).pipe(HashSet.union(HashSet.make(3, 4, 5)))

// or with data-first API
HashSet.union(HashSet.make(1, 2, 3), HashSet.make(3, 4, 5))

LANGUAGE: typescript
CODE:
declare const union: { <A>(that: Iterable<A>): (self: HashSet<A>) => HashSet<A>; <A>(self: HashSet<A>, that: Iterable<A>): HashSet<A>; }

----------------------------------------

TITLE: Array.chunksOf Type Definition in TypeScript
DESCRIPTION: Provides the type signature for the chunksOf function, showing its polymorphic nature and support for different array types including NonEmptyReadonlyArray and standard arrays.

LANGUAGE: typescript
CODE:
declare const chunksOf: { (n: number): <S extends Iterable<any>>(self: S) => ReadonlyArray.With<S, NonEmptyArray<ReadonlyArray.Infer<S>>>; <A>(self: NonEmptyReadonlyArray<A>, n: number): NonEmptyArray<NonEmptyArray<A>>; <A>(self: Iterable<A>, n: number): Array<NonEmptyArray<A>>; }

----------------------------------------

TITLE: Retrieving Last Element from List - TypeScript Effect Library
DESCRIPTION: Function declaration for unsafeLast that returns the last element of a List without performing safety checks. Takes a List of type A as input and returns a single element of type A. This is an unsafe operation as it does not handle empty lists.

LANGUAGE: typescript
CODE:
declare const unsafeLast: <A>(self: List<A>) => A

----------------------------------------

TITLE: Interrupting a Fiber with Specified FiberId in TypeScript
DESCRIPTION: The interruptAs function interrupts a fiber as if it were interrupted from a specified fiber. It returns an Effect that resumes immediately if the fiber has already exited, or when the fiber exits if it's still running. The function accepts a FiberId and a Fiber, and returns an Effect containing the Exit state of the interrupted fiber.

LANGUAGE: typescript
CODE:
declare const interruptAs: { (fiberId: FiberId.FiberId): <A, E>(self: Fiber<A, E>) => Effect.Effect<Exit.Exit<A, E>>; <A, E>(self: Fiber<A, E>, fiberId: FiberId.FiberId): Effect.Effect<Exit.Exit<A, E>>; }

----------------------------------------

TITLE: TypeScript Function Signature for tryPromise in Micro Module
DESCRIPTION: Provides the TypeScript function signature for the tryPromise function in the Micro module. It shows the expected parameters and return type for the function.

LANGUAGE: typescript
CODE:
declare const tryPromise: <A, E>(options: { readonly try: (signal: AbortSignal) => PromiseLike<A>; readonly catch: (error: unknown) => E; }) => Micro<A, E>

----------------------------------------

TITLE: Creating Empty TSet in TypeScript using Effect STM
DESCRIPTION: Function signature for creating an empty transactional set (TSet) using Software Transactional Memory. The function is generic, accepting any type A, and returns an STM transaction that produces an empty TSet.

LANGUAGE: typescript
CODE:
declare const empty: <A>() => STM.STM<TSet<A>>

----------------------------------------

TITLE: Defining YieldableError Interface in TypeScript
DESCRIPTION: Defines the YieldableError interface, which extends Pipeable, Inspectable, and Readonly<Error>. It includes several readonly properties with specific type identifiers and a Symbol.iterator method.

LANGUAGE: typescript
CODE:
export interface YieldableError extends Pipeable, Inspectable, Readonly<Error> {
  readonly [Effect.EffectTypeId]: Effect.Effect.VarianceStruct<never, this, never>
  readonly [Stream.StreamTypeId]: Stream.Stream.VarianceStruct<never, this, never>
  readonly [Sink.SinkTypeId]: Sink.Sink.VarianceStruct<never, unknown, never, this, never>
  readonly [Channel.ChannelTypeId]: Channel.Channel.VarianceStruct<never, unknown, this, unknown, never, unknown, never>
  [Symbol.iterator](): Effect.EffectGenerator<Effect.Effect<never, this, never>>
}

----------------------------------------

TITLE: Collecting TSet Elements into ReadonlySet in TypeScript
DESCRIPTION: The toReadonlySet function collects all elements from a TSet into a ReadonlySet. It returns an STM (Software Transactional Memory) operation that produces a ReadonlySet when executed.

LANGUAGE: typescript
CODE:
declare const toReadonlySet: <A>(self: TSet<A>) => STM.STM<ReadonlySet<A>>

----------------------------------------

TITLE: Implementing Sink.zipRight Generic Type Definition in TypeScript
DESCRIPTION: Type definition for the zipRight operation that combines two sinks, preserving only the result from the second sink. Supports optional concurrent execution through options parameter. The operation maintains type safety across generic parameters for input types, error types, and result types.

LANGUAGE: typescript
CODE:
declare const zipRight: {
  <A2, In, In2 extends In, L2, E2, R2>
  (that: Sink<A2, In2, L2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; } | undefined):
  <A, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A2, In & In2, L2 | L, E2 | E, R2 | R>;

  <A, In, L, E, R, A2, In2 extends In, L2, E2, R2>
  (self: Sink<A, In, L, E, R>, that: Sink<A2, In2, L2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; } | undefined):
  Sink<A2, In & In2, L | L2, E | E2, R | R2>;
}

----------------------------------------

TITLE: Using HashSet.has in TypeScript with Effect Package
DESCRIPTION: Demonstrates different ways to check if a value exists in a HashSet using both data-first and data-last (pipeable) APIs. The method has O(1) average time complexity.

LANGUAGE: typescript
CODE:
// Syntax
import { HashSet, pipe } from "effect"

// with `data-last`, a.k.a. `pipeable` API
pipe(HashSet.make(0, 1, 2), HashSet.has(3)) // false

// or piped with the pipe function
HashSet.make(0, 1, 2).pipe(HashSet.has(3)) // false

// or with `data-first` API
HashSet.has(HashSet.make(0, 1, 2), 3) // false

LANGUAGE: typescript
CODE:
declare const has: { <A>(value: A): (self: HashSet<A>) => boolean; <A>(self: HashSet<A>, value: A): boolean; }

----------------------------------------

TITLE: Defining Doc.Fail Interface in TypeScript
DESCRIPTION: Declares the Fail interface that extends Doc.Variance<A> and includes a readonly _tag property of 'Fail'. This represents a document that fails to render and is used by layout algorithms to select alternative rendering options.

LANGUAGE: typescript
CODE:
export interface Fail<A> extends Doc.Variance<A> {
  readonly _tag: "Fail"
}

----------------------------------------

TITLE: Creating Tagged Classes with Effect Data Module
DESCRIPTION: Demonstrates how to create and use tagged classes with the Effect library's Data module. Shows class creation, instance comparison, and tag access. Includes equality checking using the Equal module.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Data, Equal } from "effect"

class Person extends Data.TaggedClass("Person")<{ readonly name: string }> {}

// Creating instances of Person
const mike1 = new Person({ name: "Mike" })
const mike2 = new Person({ name: "Mike" })
const john = new Person({ name: "John" })

// Checking equality
assert.deepStrictEqual(Equal.equals(mike1, mike2), true)
assert.deepStrictEqual(Equal.equals(mike1, john), false)

assert.deepStrictEqual(mike1._tag, "Person")

----------------------------------------

TITLE: Using getSecond Function with TypeScript Tuples
DESCRIPTION: Demonstrates how to use the getSecond function to extract the second element from a tuple. The function takes a readonly tuple of two elements and returns the second element with proper type inference.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { getSecond } from "effect/Tuple"

assert.deepStrictEqual(getSecond(["hello", 42]), 42)

LANGUAGE: typescript
CODE:
declare const getSecond: <L, R>(self: readonly [L, R]) => R

----------------------------------------

TITLE: Subtracting BigInts using Effect Package in TypeScript
DESCRIPTION: Demonstrates how to use the subtract function from the BigInt module in the effect package to perform subtraction on bigint values. The function can be used with both curried and non-curried syntax.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { subtract } from "effect/BigInt"

assert.deepStrictEqual(subtract(2n, 3n), -1n)

LANGUAGE: typescript
CODE:
declare const subtract: { (that: bigint): (self: bigint) => bigint; (self: bigint, that: bigint): bigint; }

----------------------------------------

TITLE: Retrieving First Element from Chunk in TypeScript
DESCRIPTION: Function that returns the first element of a Chunk if it exists, wrapped in an Option type. This provides a safe way to access the first element without throwing errors on empty chunks.

LANGUAGE: typescript
CODE:
declare const head: <A>(self: Chunk<A>) => Option<A>

----------------------------------------

TITLE: Combining Numbers with SemigroupSum in TypeScript
DESCRIPTION: Demonstrates the usage of SemigroupSum from the @effect/typeclass/data/Number module to combine two numbers using addition. The example shows how to import and use the SemigroupSum object to add 2 and 3.

LANGUAGE: typescript
CODE:
import { SemigroupSum } from "@effect/typeclass/data/Number"

console.log(SemigroupSum.combine(2, 3))
// 5

----------------------------------------

TITLE: FiberSet.make Function Signature in TypeScript
DESCRIPTION: This code snippet shows the TypeScript signature for the FiberSet.make function. It creates a FiberSet for managing fibers of type A with potential errors of type E, and requires a Scope for proper resource management.

LANGUAGE: typescript
CODE:
declare const make: <A = unknown, E = unknown>() => Effect.Effect<FiberSet<A, E>, never, Scope.Scope>

----------------------------------------

TITLE: Checking Non-Empty Intervals in TypeScript Effect
DESCRIPTION: A utility function that checks if an Intervals data structure contains any elements. Returns a boolean indicating whether the Intervals instance is non-empty.

LANGUAGE: typescript
CODE:
declare const isNonEmpty: (self: Intervals) => boolean

----------------------------------------

TITLE: Joining FiberRefs with Single FiberId in TypeScript
DESCRIPTION: Provides functionality to join collections of fiber refs, using a specified fiber ID. The function performs diffing and merging operations to maintain maximum information from both child and parent references.

LANGUAGE: typescript
CODE:
declare const joinAs: { 
  (fiberId: FiberId.Single, that: FiberRefs): (self: FiberRefs) => FiberRefs; 
  (self: FiberRefs, fiberId: FiberId.Single, that: FiberRefs): FiberRefs; 
}

----------------------------------------

TITLE: Defining Request Entry Interface in TypeScript
DESCRIPTION: Defines a generic Entry interface that tracks a request of type R along with a Deferred result reference. The interface includes request metadata, result storage, listeners, owner ID, and completion state. This structure supports data sources with varying result types while maintaining type safety.

LANGUAGE: typescript
CODE:
export interface Entry<out R> extends Entry.Variance<R> {
  readonly request: R
  readonly result: Deferred<
    [R] extends [Request<infer _A, infer _E>] ? _A : never,
    [R] extends [Request<infer _A, infer _E>] ? _E : never
  >
  readonly listeners: Listeners
  readonly ownerId: FiberId
  readonly state: {
    completed: boolean
  }
}

----------------------------------------

TITLE: Extracting Branded Type from Brand.Constructor in TypeScript
DESCRIPTION: This utility type extracts a branded type from a Brand.Constructor. It uses conditional types to check if the input type A extends Brand.Constructor, and if so, infers and returns the branded type B. Otherwise, it returns never.

LANGUAGE: typescript
CODE:
type FromConstructor<A> = A extends Brand.Constructor<infer B> ? B : never

----------------------------------------

TITLE: Type Signature of taggedEnum Function in TypeScript
DESCRIPTION: Provides the complex type signature for the taggedEnum function, showing its flexibility in handling different numbers of generic parameters and tagged enum definitions.

LANGUAGE: typescript
CODE:
declare const taggedEnum: { <Z extends TaggedEnum.WithGenerics<1>>(): Types.Simplify<{ readonly [Tag in Z["taggedEnum"]["_tag"]]: <A>(args: TaggedEnum.Args<TaggedEnum.Kind<Z, A>, Tag, Extract<TaggedEnum.Kind<Z, A>, { readonly _tag: Tag; }>>) => TaggedEnum.Value<TaggedEnum.Kind<Z, A>, Tag>; } & TaggedEnum.GenericMatchers<Z>>; <Z extends TaggedEnum.WithGenerics<2>>(): Types.Simplify<{ readonly [Tag in Z["taggedEnum"]["_tag"]]: <A, B>(args: TaggedEnum.Args<TaggedEnum.Kind<Z, A, B>, Tag, Extract<TaggedEnum.Kind<Z, A, B>, { readonly _tag: Tag; }>>) => TaggedEnum.Value<TaggedEnum.Kind<Z, A, B>, Tag>; } & TaggedEnum.GenericMatchers<Z>>; <Z extends TaggedEnum.WithGenerics<3>>(): Types.Simplify<{ readonly [Tag in Z["taggedEnum"]["_tag"]]: <A, B, C>(args: TaggedEnum.Args<TaggedEnum.Kind<Z, A, B, C>, Tag, Extract<TaggedEnum.Kind<Z, A, B, C>, { readonly _tag: Tag; }>>) => TaggedEnum.Value<TaggedEnum.Kind<Z, A, B, C>, Tag>; } & TaggedEnum.GenericMatchers<Z>>; <Z extends TaggedEnum.WithGenerics<4>>(): Types.Simplify<{ readonly [Tag in Z["taggedEnum"]["_tag"]]: <A, B, C, D>(args: TaggedEnum.Args<TaggedEnum.Kind<Z, A, B, C, D>, Tag, Extract<TaggedEnum.Kind<Z, A, B, C, D>, { readonly _tag: Tag; }>>) => TaggedEnum.Value<TaggedEnum.Kind<Z, A, B, C, D>, Tag>; } & TaggedEnum.GenericMatchers<Z>>; <A extends { readonly _tag: string; }>(): TaggedEnum.Constructor<A>; }

----------------------------------------

TITLE: Creating ConfigProvider from Flat Structure in TypeScript
DESCRIPTION: The fromFlat function constructs a new ConfigProvider from a key/value (flat) provider, where nesting is embedded into the string keys. It takes a ConfigProvider.Flat as input and returns a ConfigProvider.

LANGUAGE: typescript
CODE:
declare const fromFlat: (flat: ConfigProvider.Flat) => ConfigProvider

----------------------------------------

TITLE: Implementing Schedule Combination in TypeScript
DESCRIPTION: Defines a function that merges two schedules, preserving both input and output types. The resulting schedule accepts inputs from both original schedules and produces a tuple of their outputs. It continues recursing while either schedule wants to continue, using the shorter delay interval.

LANGUAGE: typescript
CODE:
declare const bothInOut: { <Out2, In2, R2>(that: Schedule<Out2, In2, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<[Out, Out2], readonly [In, In2], R2 | R>; <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>): Schedule<[Out, Out2], readonly [In, In2], R | R2>; }

----------------------------------------

TITLE: Defining EntityRegistered Interface in TypeScript
DESCRIPTION: Defines the interface for an event that represents when a new entity is registered with a runner in the Effect cluster sharding system. The interface includes a type tag for identification and an entity reference.

LANGUAGE: typescript
CODE:
export interface EntityRegistered {
  readonly _tag: "EntityRegistered"
  readonly entity: Entity<any>
}

----------------------------------------

TITLE: Associating Cookies with HttpClient in TypeScript
DESCRIPTION: The withCookiesRef function associates a Ref of cookies with an HttpClient for handling cookies across requests. It can be used in two ways: by passing the Ref first, or by passing the HttpClient first.

LANGUAGE: typescript
CODE:
declare const withCookiesRef: { (ref: Ref<Cookies>): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E, R>; <E, R>(self: HttpClient.With<E, R>, ref: Ref<Cookies>): HttpClient.With<E, R>; }

----------------------------------------

TITLE: Implementing Synchronous Sink in TypeScript with Effect
DESCRIPTION: Defines a synchronous sink that immediately terminates with a specified lazy value. The sink takes a lazy argument of type A and returns a Sink that produces values of type A and can handle unknown errors.

LANGUAGE: typescript
CODE:
declare const sync: <A>(evaluate: LazyArg<A>) => Sink<A, unknown>

----------------------------------------

TITLE: TypeScript Signature for Option.toRefinement Function
DESCRIPTION: Provides the TypeScript type signature for the Option.toRefinement function. It shows the function takes a function that returns an Option and produces a type guard function.

LANGUAGE: typescript
CODE:
declare const toRefinement: <A, B extends A>(f: (a: A) => Option<B>) => (a: A) => a is B

----------------------------------------

TITLE: Implementing takeWhile Function in TypeScript
DESCRIPTION: Function declaration for takeWhile that takes elements from a Chunk as long as they satisfy a predicate condition. Supports both refinement and predicate function overloads for type narrowing and filtering.

LANGUAGE: typescript
CODE:
declare const takeWhile: {
  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: Chunk<A>) => Chunk<B>;
  <A>(predicate: Predicate<NoInfer<A>>): (self: Chunk<A>) => Chunk<A>;
  <A, B extends A>(self: Chunk<A>, refinement: Refinement<A, B>): Chunk<B>;
  <A>(self: Chunk<A>, predicate: Predicate<A>): Chunk<A>;
}

----------------------------------------

TITLE: Defining Chunk.filter Function in TypeScript
DESCRIPTION: Declares the 'filter' function for the Chunk module. This function returns a filtered and mapped subset of elements from a Chunk. It supports both refinement and predicate-based filtering for different use cases.

LANGUAGE: typescript
CODE:
declare const filter: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: Chunk<A>) => Chunk<B>; <A>(predicate: Predicate<NoInfer<A>>): (self: Chunk<A>) => Chunk<A>; <A, B extends A>(self: Chunk<A>, refinement: Refinement<A, B>): Chunk<B>; <A>(self: Chunk<A>, predicate: Predicate<A>): Chunk<A>; }

----------------------------------------

TITLE: Declaring contextWithEffect Function in TypeScript
DESCRIPTION: Defines the contextWithEffect function that takes a function as an argument and returns a Stream. The function parameter takes a Context and returns an Effect, allowing access to the stream's context within an effect.

LANGUAGE: typescript
CODE:
declare const contextWithEffect: <R0, A, E, R>(f: (env: Context.Context<R0>) => Effect.Effect<A, E, R>) => Stream<A, E, R0 | R>

----------------------------------------

TITLE: Declaring fnUntraced Function in TypeScript
DESCRIPTION: Declares the fnUntraced constant as a function of type fn.Untraced. This function is similar to 'fn', but creates a function that is not traced, which is useful for performance-critical scenarios.

LANGUAGE: typescript
CODE:
declare const fnUntraced: fn.Untraced

----------------------------------------

TITLE: Composing Config Instances in TypeScript
DESCRIPTION: The zip function composes two Config instances, creating a new Config that combines the values of both. It can be used with either curried or non-curried syntax.

LANGUAGE: typescript
CODE:
declare const zip: { <B>(that: Config<B>): <A>(self: Config<A>) => Config<[A, B]>; <A, B>(self: Config<A>, that: Config<B>): Config<[A, B]>; }

----------------------------------------

TITLE: Defining Micro.tapDefect Function Signature in TypeScript
DESCRIPTION: Type declaration for tapDefect function that performs side effects on unexpected errors in a Micro context. The function takes an error handler and returns a new Micro instance that preserves the original success type while potentially expanding the error and environment types.

LANGUAGE: typescript
CODE:
declare const tapDefect: { <E, B, E2, R2>(f: (defect: unknown) => Micro<B, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A, E | E2, R | R2>; <A, E, R, B, E2, R2>(self: Micro<A, E, R>, f: (defect: unknown) => Micro<B, E2, R2>): Micro<A, E | E2, R | R2>; }

----------------------------------------

TITLE: Creating Reverse Semigroup Operation in TypeScript
DESCRIPTION: Implements a function that creates the dual of a Semigroup by flipping the arguments of the combine operation. This allows for reverse combination order while maintaining the Semigroup properties.

LANGUAGE: typescript
CODE:
declare const reverse: <A>(S: Semigroup<A>) => Semigroup<A>

----------------------------------------

TITLE: Unwrapping Exit Values in Effect-TS Streams
DESCRIPTION: Function that transforms a Stream of Exit values containing Option-wrapped errors into a simpler Stream structure. It unwraps Exit values and handles end-of-stream cases by failing with None.

LANGUAGE: typescript
CODE:
declare const flattenExitOption: <A, E2, E, R>(self: Stream<Exit.Exit<A, Option.Option<E2>>, E, R>) => Stream<A, E | E2, R>

----------------------------------------

TITLE: Implementing Weighted Effect Folding in TypeScript using Effect-TS
DESCRIPTION: Creates a sink that folds elements of type In into a structure of type S with a maximum weight limit. The weight of each element is determined by a cost function, and folding continues until the maximum cost is reached. Both the cost calculation and folding operation are effectful.

LANGUAGE: typescript
CODE:
declare const foldWeightedEffect: <S, In, E, R, E2, R2>(options: { readonly initial: S; readonly maxCost: number; readonly cost: (s: S, input: In) => Effect.Effect<number, E, R>; readonly body: (s: S, input: In) => Effect.Effect<S, E2, R2>; }) => Sink<S, In, In, E | E2, R | R2>

----------------------------------------

TITLE: Declaring timeoutFailCause Function in TypeScript
DESCRIPTION: This code snippet defines the timeoutFailCause function, which takes a cause and duration as input and returns a function that can be applied to a Stream. It fails the stream with the given cause if it doesn't produce a value within the specified duration. The function has two overloads to allow for different parameter orderings.

LANGUAGE: typescript
CODE:
declare const timeoutFailCause: { <E2>(cause: LazyArg<Cause.Cause<E2>>, duration: Duration.DurationInput): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R>; <A, E, R, E2>(self: Stream<A, E, R>, cause: LazyArg<Cause.Cause<E2>>, duration: Duration.DurationInput): Stream<A, E | E2, R>; }

----------------------------------------

TITLE: Converting TArray to Array using STM in TypeScript
DESCRIPTION: Function signature for converting a TArray to a standard Array using Software Transactional Memory (STM). Takes a TArray of type A and returns an STM transaction that produces an Array of type A.

LANGUAGE: typescript
CODE:
declare const toArray: <A>(self: TArray<A>) => STM.STM<Array<A>>

----------------------------------------

TITLE: Array.take Function Signature in TypeScript
DESCRIPTION: This code snippet shows the TypeScript signature for the Array.take function. It demonstrates that the function can be called with the number of elements to take as the first or second argument, allowing for flexible usage.

LANGUAGE: typescript
CODE:
declare const take: { (n: number): <A>(self: Iterable<A>) => Array<A>; <A>(self: Iterable<A>, n: number): Array<A>; }

----------------------------------------

TITLE: Array.sortWith Function Signature in TypeScript
DESCRIPTION: Provides the TypeScript signature for the Array.sortWith function. It shows the function's polymorphic nature, supporting different types of iterables and return types based on the input.

LANGUAGE: typescript
CODE:
declare const sortWith: { <S extends Iterable<any>, B>(f: (a: ReadonlyArray.Infer<S>) => B, order: Order.Order<B>): (self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S>>; <A, B>(self: NonEmptyReadonlyArray<A>, f: (a: A) => B, O: Order.Order<B>): NonEmptyArray<A>; <A, B>(self: Iterable<A>, f: (a: A) => B, order: Order.Order<B>): Array<A>; }

----------------------------------------

TITLE: Initializing JSON RPC Serialization Layer in TypeScript
DESCRIPTION: Defines a Layer for RPC serialization that uses JSON format. This layer should be used when the protocol supports message framing. For protocols without framing support, layerNdjson should be used instead.

LANGUAGE: typescript
CODE:
declare const layerJson: Layer.Layer<RpcSerialization, never, never>

----------------------------------------

TITLE: Implementing Universal Path Layer in TypeScript
DESCRIPTION: Defines a Layer implementation of the Path interface that uses POSIX path standards. This implementation is environment-agnostic and can be used in any context, including browser environments.

LANGUAGE: typescript
CODE:
declare const layer: Layer<Path, never, never>

----------------------------------------

TITLE: Implementing Set Difference Operation in TypeScript using TSet
DESCRIPTION: Defines a function 'difference' that atomically transforms a set into the difference of itself and another provided set. It operates within the STM (Software Transactional Memory) context.

LANGUAGE: typescript
CODE:
declare const difference: { <A>(other: TSet<A>): (self: TSet<A>) => STM.STM<void>; <A>(self: TSet<A>, other: TSet<A>): STM.STM<void>; }

----------------------------------------

TITLE: Defining layerContext Layer in TypeScript for @effect/platform HttpServer
DESCRIPTION: Declares a constant layerContext that provides a Layer including FileSystem, Path, HttpPlatform, and Generator services. The FileSystem service is a no-op implementation, making this layer suitable for platforms without a file system.

LANGUAGE: typescript
CODE:
declare const layerContext: Layer.Layer<FileSystem | Path | HttpPlatform | Generator, never, never>

----------------------------------------

TITLE: Implementing Cursor Forward Movement in TypeScript with ANSI Controls
DESCRIPTION: Function that moves the cursor forward by a specified number of columns in an ANSI-compatible terminal. If no column count is specified, defaults to moving forward by 1 column. The movement is bounded by the screen edge.

LANGUAGE: typescript
CODE:
declare const cursorForward: (columns?: number) => Ansi

----------------------------------------

TITLE: Defining FileSystem.SizeInput Type in TypeScript
DESCRIPTION: Type definition that represents file sizes in bytes. Accepts either bigint, number, or Size type as valid inputs for representing file sizes in the FileSystem module.

LANGUAGE: typescript
CODE:
type SizeInput = bigint | number | Size

----------------------------------------

TITLE: Defining SemigroupMax in TypeScript
DESCRIPTION: Shows the type declaration for the SemigroupMax constant. It is defined as a Semigroup of numbers, which implements the combine operation to return the maximum of two numbers.

LANGUAGE: typescript
CODE:
declare const SemigroupMax: semigroup.Semigroup<number>

----------------------------------------

TITLE: Defining STM.check Function in TypeScript
DESCRIPTION: Declares the check function in the STM module. This function takes a predicate and returns an STM of void. It checks a condition and retries if false, otherwise returns unit.

LANGUAGE: typescript
CODE:
declare const check: (predicate: LazyArg<boolean>) => STM<void>

----------------------------------------

TITLE: TypeScript Signature for vsep Combinator in @effect/printer
DESCRIPTION: Provides the TypeScript signature for the vsep combinator function. It takes an Iterable of Doc<A> and returns a Doc<A>.

LANGUAGE: typescript
CODE:
declare const vsep: <A>(docs: Iterable<Doc<A>>) => Doc<A>

----------------------------------------

TITLE: Implementing STM.head Function in TypeScript
DESCRIPTION: Function declaration for retrieving the first element of an iterable within an STM transaction. Returns a successful effect with the head element if the iterable is non-empty, or fails with Option.Option<E> if empty.

LANGUAGE: typescript
CODE:
declare const head: <A, E, R>(self: STM<Iterable<A>, E, R>) => STM<A, Option.Option<E>, R>

----------------------------------------

TITLE: Retrieving Test Annotations in TypeScript using Effect
DESCRIPTION: This function retrieves the Annotations service for tests. It returns an Effect that resolves to TestAnnotations from the Annotations module.

LANGUAGE: typescript
CODE:
declare const annotations: () => Effect.Effect<Annotations.TestAnnotations>

----------------------------------------

TITLE: Implementing Deferred.fail Operation in TypeScript
DESCRIPTION: TypeScript signature for the fail operation that takes an error value and a Deferred instance, returning an Effect that resolves to a boolean. The operation can be called with parameters in either order through function overloading.

LANGUAGE: typescript
CODE:
declare const fail: {
  <E>(error: E): <A>(self: Deferred<A, E>) => Effect.Effect<boolean>;
  <A, E>(self: Deferred<A, E>, error: E): Effect.Effect<boolean>;
}

----------------------------------------

TITLE: Defining EventLog.Handlers Interface in TypeScript
DESCRIPTION: Defines a generic interface for handling typed events with support for event groups, handlers mapping, and context management. The interface includes methods for adding event implementations with proper type constraints and error handling.

LANGUAGE: typescript
CODE:
export interface Handlers<
  R,
  Events extends Event.Any = never
> extends Pipeable {
  readonly [HandlersTypeId]: {
    _Endpoints: Covariant<Events>
  }
  readonly group: EventGroup.AnyWithProps
  readonly handlers: Record.ReadonlyRecord<string, Handlers.Item<R>>
  readonly context: Context.Context<any>

  /**
   * Add the implementation for an `Event` to a `Handlers` group.
   */
  handle<Tag extends Events["tag"], R1>(
    name: Tag,
    handler: (
      options: {
        readonly payload: Event.PayloadWithTag<Events, Tag>
        readonly entry: Entry
        readonly conflicts: Array<{
          readonly entry: Entry
          readonly payload: Event.PayloadWithTag<Events, Tag>
        }>
      }
    ) => Effect.Effect<Event.SuccessWithTag<Events, Tag>, Event.ErrorWithTag<Events, Tag>, R1>
  ): Handlers<
    R | R1,
    Event.ExcludeTag<Events, Tag>
  >
}

----------------------------------------

TITLE: Implementing Schedule Output Collection in TypeScript
DESCRIPTION: Function that modifies a schedule to accumulate all outputs into a Chunk data structure rather than returning individual outputs. Used for tracking results over time, logging, and maintaining output history.

LANGUAGE: typescript
CODE:
declare const collectAllOutputs: <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Chunk.Chunk<Out>, In, R>

----------------------------------------

TITLE: Defining FusionDepth Type in TypeScript for @effect/printer Optimize Module
DESCRIPTION: Defines the FusionDepth type as a union of Shallow and Deep. This type is used to instruct the document fusion optimizer on how deeply to traverse the document tree during optimization.

LANGUAGE: typescript
CODE:
type FusionDepth = Shallow | Deep

----------------------------------------

TITLE: Creating Named Time Zone in TypeScript using Effect
DESCRIPTION: Attempts to create a named time zone from an IANA time zone identifier. Throws an IllegalArgumentException if the time zone is invalid. This function is part of the DateTime module in the Effect package.

LANGUAGE: typescript
CODE:
declare const zoneUnsafeMakeNamed: (zoneId: string) => TimeZone.Named

----------------------------------------

TITLE: Constructing Tagged Request in TypeScript
DESCRIPTION: Type signature for the Request.tagged constructor function that creates a new Request instance. The function takes a tag parameter and returns a Request constructor that enforces the tag type.

LANGUAGE: typescript
CODE:
declare const tagged: <R extends Request<any, any> & { _tag: string; }>(tag: R["_tag"]) => Request.Constructor<R, "_tag">

----------------------------------------

TITLE: TypeScript Type Signature for Option.orElseSome
DESCRIPTION: Provides the TypeScript type signature for the Option.orElseSome function, showing its overloaded nature and type parameters.

LANGUAGE: typescript
CODE:
declare const orElseSome: { <B>(onNone: LazyArg<B>): <A>(self: Option<A>) => Option<B | A>; <A, B>(self: Option<A>, onNone: LazyArg<B>): Option<A | B>; }

----------------------------------------

TITLE: Declaring Chunk.replace Function in TypeScript
DESCRIPTION: Declares the replace function for the Chunk module. This function changes the element at a specified index in a Chunk, creating a new Chunk, or returns the input if the index is out of bounds. It supports both curried and non-curried forms.

LANGUAGE: typescript
CODE:
declare const replace: { <B>(i: number, b: B): <A>(self: Chunk<A>) => Chunk<B | A>; <A, B>(self: Chunk<A>, i: number, b: B): Chunk<B | A>; }

----------------------------------------

TITLE: Configuring HTTP Tracing Propagation in TypeScript
DESCRIPTION: Function signature for withTracerPropagation that allows enabling or disabling tracing propagation for HTTP requests. It supports both curried and uncurried calling styles, operating on Effect instances.

LANGUAGE: typescript
CODE:
declare const withTracerPropagation: { (enabled: boolean): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; <A, E, R>(effect: Effect.Effect<A, E, R>, enabled: boolean): Effect.Effect<A, E, R>; }

----------------------------------------

TITLE: Defining ConfigProvider.lowerCase Function in TypeScript
DESCRIPTION: This function creates a new config provider that automatically converts all property names to lowercase. It's useful for adapting configuration property names from camel case to the naming convention of a specific config provider.

LANGUAGE: typescript
CODE:
declare const lowerCase: (self: ConfigProvider) => ConfigProvider

----------------------------------------

TITLE: Summing Numbers with Effect/Number Module
DESCRIPTION: The sumAll function takes an Iterable of numbers and returns their sum as a single number. It provides a simple way to calculate the total of a collection of numbers.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { sumAll } from "effect/Number"

assert.deepStrictEqual(sumAll([2, 3, 4]), 9)

LANGUAGE: typescript
CODE:
declare const sumAll: (collection: Iterable<number>) => number

----------------------------------------

TITLE: Defining orDieWith Function for STM Error Handling in TypeScript
DESCRIPTION: Declares the `orDieWith` function, which takes an error conversion function and an STM effect. It terminates the fiber running the STM effect with the converted error, effectively handling errors by converting them to defects.

LANGUAGE: typescript
CODE:
declare const orDieWith: { <E>(f: (error: E) => unknown): <A, R>(self: STM<A, E, R>) => STM<A, never, R>; <A, E, R>(self: STM<A, E, R>, f: (error: E) => unknown): STM<A, never, R>; }

----------------------------------------

TITLE: Checking Request Type in TypeScript
DESCRIPTION: The isRequest function is a type guard that checks if the provided value is an instance of Request. It returns true if the value is a Request, false otherwise. This function is useful for type narrowing in TypeScript.

LANGUAGE: typescript
CODE:
declare const isRequest: (u: unknown) => u is Request<unknown, unknown>

----------------------------------------

TITLE: Defining filterOrFail Function for HttpClient in TypeScript
DESCRIPTION: Declares the filterOrFail function which takes a predicate and an error-generating function to filter HttpClient responses. It can be used in two ways: either as a higher-order function or directly on an HttpClient instance.

LANGUAGE: typescript
CODE:
declare const filterOrFail: { <E2>(predicate: Predicate.Predicate<ClientResponse.HttpClientResponse>, orFailWith: (response: ClientResponse.HttpClientResponse) => E2): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E2 | E, R>; <E, R, E2>(self: HttpClient.With<E, R>, predicate: Predicate.Predicate<ClientResponse.HttpClientResponse>, orFailWith: (response: ClientResponse.HttpClientResponse) => E2): HttpClient.With<E2 | E, R>; }

----------------------------------------

TITLE: Filtering None Values from HashMap in TypeScript
DESCRIPTION: The compact function filters out None values from a HashMap of Options. It takes a HashMap with key type K and value type Option<A>, and returns a new HashMap with key type K and value type A, containing only the Some values.

LANGUAGE: typescript
CODE:
declare const compact: <K, A>(self: HashMap<K, Option<A>>) => HashMap<K, A>

----------------------------------------

TITLE: Declaring Nested Config Provider Function in TypeScript
DESCRIPTION: Defines a function that creates a new config provider with all configuration nested under a specified property name. This can be used to aggregate separate configuration sources required for loading a single configuration value.

LANGUAGE: typescript
CODE:
declare const nested: { (name: string): (self: ConfigProvider) => ConfigProvider; (self: ConfigProvider, name: string): ConfigProvider; }

----------------------------------------

TITLE: Initializing Bounded PubSub with Dropping Strategy in TypeScript
DESCRIPTION: Creates a bounded PubSub that drops new messages when at capacity. The function accepts either a number for capacity or an object with capacity and optional replay settings. Optimal performance is achieved with power-of-two capacities.

LANGUAGE: typescript
CODE:
declare const dropping: <A>(capacity: number | { readonly capacity: number; readonly replay?: number | undefined; }) => Effect.Effect<PubSub<A>>

----------------------------------------

TITLE: Creating a Fiber-Tracking Supervisor in TypeScript
DESCRIPTION: The fibersIn function creates a new supervisor that tracks child fibers in a sorted set. It takes a mutable reference to a sorted set of runtime fibers as input and returns an Effect that produces a Supervisor.

LANGUAGE: TypeScript
CODE:
declare const fibersIn: (ref: MutableRef.MutableRef<SortedSet.SortedSet<Fiber.RuntimeFiber<any, any>>>) => Effect.Effect<Supervisor<SortedSet.SortedSet<Fiber.RuntimeFiber<any, any>>>>

----------------------------------------

TITLE: Creating Recursive MicroSchedule in TypeScript
DESCRIPTION: Function signature for creating a MicroSchedule that repeats a specified number of times. The schedule will automatically stop after reaching the specified number of attempts.

LANGUAGE: typescript
CODE:
declare const scheduleRecurs: (n: number) => MicroSchedule

----------------------------------------

TITLE: Defining broadcastedQueues Function in TypeScript
DESCRIPTION: Defines the broadcastedQueues function that converts a stream to a scoped list of queues. It replicates values to every queue, allowing for a specified maximum lag before back-pressure is applied. Queues can unsubscribe by shutting down.

LANGUAGE: typescript
CODE:
declare const broadcastedQueues: { <N extends number>(n: N, maximumLag: number | { readonly capacity: "unbounded"; readonly replay?: number | undefined; } | { readonly capacity: number; readonly strategy?: "sliding" | "dropping" | "suspend" | undefined; readonly replay?: number | undefined; }): <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<TupleOf<N, Queue.Dequeue<Take.Take<A, E>>>, never, Scope.Scope | R>; <A, E, R, N extends number>(self: Stream<A, E, R>, n: N, maximumLag: number | { readonly capacity: "unbounded"; readonly replay?: number | undefined; } | { readonly capacity: number; readonly strategy?: "sliding" | "dropping" | "suspend" | undefined; readonly replay?: number | undefined; }): Effect.Effect<TupleOf<N, Queue.Dequeue<Take.Take<A, E>>>, never, Scope.Scope | R>; }

----------------------------------------

TITLE: Type Signature for Trie.insert Function in TypeScript
DESCRIPTION: This code snippet provides the type signature for the Trie.insert function. It shows two overloads: one for inserting a new value with a key into an existing Trie, and another for creating a new Trie with an inserted key-value pair.

LANGUAGE: typescript
CODE:
declare const insert: { <V1>(key: string, value: V1): <V>(self: Trie<V>) => Trie<V | V1>; <V1, V>(self: Trie<V>, key: string, value: V1): Trie<V | V1>; }

----------------------------------------

TITLE: TypeScript Signature of Stream.repeatEffectOption Function
DESCRIPTION: This code snippet shows the TypeScript signature of the Stream.repeatEffectOption function. It takes an Effect that produces values of type A and may fail with an Option<E>, and returns a Stream of A that may fail with E.

LANGUAGE: typescript
CODE:
declare const repeatEffectOption: <A, E, R>(effect: Effect.Effect<A, Option.Option<E>, R>) => Stream<A, E, R>

----------------------------------------

TITLE: Creating Type-Based Pattern Matcher in TypeScript
DESCRIPTION: Demonstrates creating and using a type-based matcher for handling string and number values using Match.type. The matcher defines specific handlers for different types and ensures exhaustive matching.

LANGUAGE: typescript
CODE:
import { Match } from "effect"

// Create a matcher for values that are either strings or numbers
//
//      ┌─── (u: string | number) => string
//      ▼
const match = Match.type<string | number>().pipe(
  // Match when the value is a number
  Match.when(Match.number, (n) => `number: ${n}`),
  // Match when the value is a string
  Match.when(Match.string, (s) => `string: ${s}`),
  // Ensure all possible cases are handled
  Match.exhaustive
)

console.log(match(0))
// Output: "number: 0"

console.log(match("hello"))
// Output: "string: hello"

----------------------------------------

TITLE: Creating Infinite Stream with Random Numbers - TypeScript
DESCRIPTION: Demonstrates how to create an infinite stream of random integers using Stream.repeatEffect, taking only the first 5 values. The example shows the usage with Random.nextInt effect that generates random numbers.

LANGUAGE: typescript
CODE:
import { Effect, Random, Stream } from "effect"

const stream = Stream.repeatEffect(Random.nextInt)

Effect.runPromise(Stream.runCollect(stream.pipe(Stream.take(5)))).then(console.log)
// Example Output: { _id: 'Chunk', values: [ 3891571149, 4239494205, 2352981603, 2339111046, 1488052210 ] }

----------------------------------------

TITLE: Defining String Type Refinement Predicate in TypeScript
DESCRIPTION: Type definition for a predicate that refines unknown values to string type. This predicate is used in the Effect-TS Match module for type-safe string matching.

LANGUAGE: typescript
CODE:
declare const string: Predicate.Refinement<unknown, string>

----------------------------------------

TITLE: Defining failSync Function for STM in TypeScript
DESCRIPTION: Declares the failSync function, which fails a transactional effect with a lazily evaluated error. It takes a LazyArg<E> as input and returns an STM<never, E>.

LANGUAGE: typescript
CODE:
declare const failSync: <E>(evaluate: LazyArg<E>) => STM<never, E>

----------------------------------------

TITLE: Formatting Durations to ISO8601 in TypeScript using Effect
DESCRIPTION: Demonstrates how to format Duration objects into ISO8601 duration strings. The function handles days, hours, minutes, and fractional seconds, with months assumed as 30 days and years as 365 days. Throws RangeError if duration is not finite.

LANGUAGE: typescript
CODE:
import { Duration } from "effect"

Duration.unsafeFormatIso(Duration.days(1)) // => "P1D"
Duration.unsafeFormatIso(Duration.minutes(90)) // => "PT1H30M"
Duration.unsafeFormatIso(Duration.millis(1500)) // => "PT1.5S"

LANGUAGE: typescript
CODE:
declare const unsafeFormatIso: (self: DurationInput) => string

----------------------------------------

TITLE: Declaring Empty EventGroup in TypeScript
DESCRIPTION: Defines an empty EventGroup constant. An EventGroup is a collection of Events that can represent a portion of a domain. The events can be implemented later using the EventLog.group API.

LANGUAGE: typescript
CODE:
declare const empty: EventGroup<never>

----------------------------------------

TITLE: Looping with Discarded Results Using Effect.loop in TypeScript
DESCRIPTION: Example of using Effect.loop with the discard option set to true, which causes the intermediate results to be ignored and the effect to return void.

LANGUAGE: typescript
CODE:
import { Effect, Console } from "effect"

const result = Effect.loop(
  // Initial state
  1,
  {
    // Condition to continue looping
    while: (state) => state <= 5,
    // State update function
    step: (state) => state + 1,
    // Effect to be performed on each iteration
    body: (state) => Console.log(`Currently at state ${state}`),
    // Discard intermediate results
    discard: true
  }
)

Effect.runPromise(result).then(console.log)
// Output:
// Currently at state 1
// Currently at state 2
// Currently at state 3
// Currently at state 4
// Currently at state 5
// undefined

----------------------------------------

TITLE: Declaring recurUntil Function in TypeScript for Effect Package
DESCRIPTION: This snippet declares the recurUntil function, which creates a schedule that recurs until a given predicate evaluates to true. It takes a predicate function as an argument and returns a Schedule that operates on and produces values of the same type.

LANGUAGE: typescript
CODE:
declare const recurUntil: <A>(f: Predicate<A>) => Schedule<A, A>

----------------------------------------

TITLE: Creating Take Instance in TypeScript using Effect Package
DESCRIPTION: Function signature for constructing a Take instance from an Exit value. Takes a generic Exit type containing a Chunk of values A and an Option of error type E, returning a Take<A, E>.

LANGUAGE: typescript
CODE:
declare const make: <A, E>(exit: Exit.Exit<Chunk.Chunk<A>, Option.Option<E>>) => Take<A, E>

----------------------------------------

TITLE: Declaring collectUntil Function in TypeScript
DESCRIPTION: Defines a function that creates a schedule to collect inputs into a Chunk until a given predicate function returns false. It takes a predicate function as an argument and returns a Schedule that operates on Chunks of the input type.

LANGUAGE: typescript
CODE:
declare const collectUntil: <A>(f: Predicate<A>) => Schedule<Chunk.Chunk<A>, A>

----------------------------------------

TITLE: Removing Entry by Key in RedBlackTree - TypeScript
DESCRIPTION: Function signature for removing the first entry with a specified key from a RedBlackTree. Supports both curried and uncurried function calls for flexible usage patterns.

LANGUAGE: typescript
CODE:
declare const removeFirst: { 
  <K>(key: K): <V>(self: RedBlackTree<K, V>) => RedBlackTree<K, V>; 
  <K, V>(self: RedBlackTree<K, V>, key: K): RedBlackTree<K, V>; 
}

----------------------------------------

TITLE: Declaring Schedule.untilInput Function in TypeScript
DESCRIPTION: Defines a function that modifies a schedule to stop execution when a predicate evaluates to true for incoming inputs. The function supports both curried and uncurried calling patterns and works with generic input/output types.

LANGUAGE: typescript
CODE:
declare const untilInput: { <In>(f: Predicate<In>): <Out, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R>(self: Schedule<Out, In, R>, f: Predicate<In>): Schedule<Out, In, R>; }

----------------------------------------

TITLE: TypeScript Function Signature for Array.containsWith in Effect Library
DESCRIPTION: Provides the TypeScript type signature for the containsWith function in the Effect library's Array module. It shows the function's parameter types and return type, indicating it creates a higher-order function for array containment checks.

LANGUAGE: typescript
CODE:
declare const containsWith: <A>(isEquivalent: (self: A, that: A) => boolean) => { (a: A): (self: Iterable<A>) => boolean; (self: Iterable<A>, a: A): boolean; }

----------------------------------------

TITLE: Configuring WebSocket Layer for ShardManager in TypeScript
DESCRIPTION: Defines a Layer that adds WebSocket route handling to the ShardManager server. The layer requires dependencies including ShardStorage, ShardingConfig, RpcSerialization, RunnerHealth, ShardManager.Config, WebSocketConstructor, and HttpServer. By default, it uses the HttpRouter.Default tag.

LANGUAGE: typescript
CODE:
declare const layerWebsocket: Layer.Layer<ShardManager.ShardManager, never, ShardStorage | ShardingConfig | RpcSerialization.RpcSerialization | RunnerHealth.RunnerHealth | ShardManager.Config | Socket.WebSocketConstructor | HttpServer.HttpServer>

----------------------------------------

TITLE: Defining FittingPredicate Interface in TypeScript
DESCRIPTION: Defines a type interface for a predicate function that determines whether a DocStream fits within specified layout constraints. The predicate considers the original indentation, initial indentation for line breaks, and width constraints.

LANGUAGE: typescript
CODE:
export interface FittingPredicate<A> {
    (
      stream: DocStream<A>,
      indentation: number,
      currentColumn: number,
      comparator: LazyArg<DocStream<A>>
    ): boolean
  }

----------------------------------------

TITLE: Combining RuntimeFlagsPatch Instances with andThen in TypeScript
DESCRIPTION: The andThen function creates a new RuntimeFlagsPatch by applying one patch followed by another. It can be used in both curried and uncurried forms. This function is available since version 2.0.0 of the package.

LANGUAGE: typescript
CODE:
declare const andThen: { (that: RuntimeFlagsPatch): (self: RuntimeFlagsPatch) => RuntimeFlagsPatch; (self: RuntimeFlagsPatch, that: RuntimeFlagsPatch): RuntimeFlagsPatch; }

----------------------------------------

TITLE: Checking Parallel ExecutionStrategy in TypeScript
DESCRIPTION: The isParallel function checks if a given ExecutionStrategy is an instance of Parallel. It returns true for Parallel instances and false otherwise. This function is useful for determining the execution strategy of a process.

LANGUAGE: typescript
CODE:
declare const isParallel: (self: ExecutionStrategy) => self is Parallel

----------------------------------------

TITLE: Defining takeWhile Function for Iterables in TypeScript
DESCRIPTION: This code snippet defines the takeWhile function for Iterables. It calculates the longest initial Iterable where all elements satisfy a specified predicate, creating a new Iterable. The function supports both refinement and predicate-based filtering.

LANGUAGE: typescript
CODE:
declare const takeWhile: { <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => Iterable<B>; <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Iterable<A>; <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): Iterable<B>; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Iterable<A>; }

----------------------------------------

TITLE: Testing Function Type in TypeScript using Effect Package
DESCRIPTION: Demonstrates how to use the isFunction utility from the Effect package to check if a value is a function. The example shows true for a function and false for a string.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { isFunction } from "effect/Predicate"

assert.deepStrictEqual(isFunction(isFunction), true)
assert.deepStrictEqual(isFunction("function"), false)

----------------------------------------

TITLE: Converting Exit to Take in TypeScript
DESCRIPTION: Function that creates a Take instance from an Exit type. This utility allows for type-safe conversion between the two types while preserving the generic type parameters for both success (A) and error (E) cases.

LANGUAGE: typescript
CODE:
declare const fromExit: <A, E>(exit: Exit.Exit<A, E>) => Take<A, E>

----------------------------------------

TITLE: Importing and Using SemigroupMultiply in TypeScript
DESCRIPTION: This snippet demonstrates how to import and use the SemigroupMultiply from the @effect/typeclass package. It combines two numbers using multiplication.

LANGUAGE: typescript
CODE:
import { SemigroupMultiply } from "@effect/typeclass/data/Number"

console.log(SemigroupMultiply.combine(2, 3))
// 6

----------------------------------------

TITLE: Using zipWithPrevious with Effect Stream
DESCRIPTION: Demonstrates how to use the zipWithPrevious function to combine each element in a stream with its previous element. The first element is paired with None, while subsequent elements are paired with Some of the previous value.

LANGUAGE: typescript
CODE:
import { Chunk, Effect, Stream } from "effect"

const stream = Stream.zipWithPrevious(Stream.make(1, 2, 3, 4))

Effect.runPromise(Stream.runCollect(stream)).then((chunk) => console.log(Chunk.toArray(chunk)))
// [
//   [ { _id: 'Option', _tag: 'None' }, 1 ],
//   [ { _id: 'Option', _tag: 'Some', value: 1 }, 2 ],
//   [ { _id: 'Option', _tag: 'Some', value: 2 }, 3 ],
//   [ { _id: 'Option', _tag: 'Some', value: 3 }, 4 ]
// ]

LANGUAGE: typescript
CODE:
declare const zipWithPrevious: <A, E, R>(self: Stream<A, E, R>) => Stream<[Option.Option<A>, A], E, R>

----------------------------------------

TITLE: Implementing Cursor Previous Line Movement in TypeScript
DESCRIPTION: Function that moves the cursor to the beginning of the line a specified number of rows up (defaults to 1 row). Returns an Ansi type that can be used for terminal manipulation.

LANGUAGE: typescript
CODE:
declare const cursorPrevLine: (rows?: number) => Ansi

----------------------------------------

TITLE: TypeScript Function Signature for Redacted.getEquivalence
DESCRIPTION: This snippet shows the TypeScript function signature for the Redacted.getEquivalence function. It takes an Equivalence<A> as input and returns an Equivalence<Redacted<A>>.

LANGUAGE: typescript
CODE:
declare const getEquivalence: <A>(isEquivalent: Equivalence.Equivalence<A>) => Equivalence.Equivalence<Redacted<A>>

----------------------------------------

TITLE: Defining Supervisor.track Function Signature in TypeScript
DESCRIPTION: Declares the signature of the Supervisor.track function, which creates a new supervisor that tracks children in a set. It returns an Effect that produces a Supervisor managing an array of RuntimeFibers.

LANGUAGE: typescript
CODE:
declare const track: Effect.Effect<Supervisor<Array<Fiber.RuntimeFiber<any, any>>>, never, never>

----------------------------------------

TITLE: Defining getOrder Function for Struct in TypeScript
DESCRIPTION: The getOrder function creates and returns a new Order for a struct of values based on the given Orders for each property in the struct. It is an alias of order.struct.

LANGUAGE: typescript
CODE:
declare const getOrder: <R extends { readonly [x: string]: order.Order<any>; }>(fields: R) => order.Order<{ [K in keyof R]: [R[K]] extends [order.Order<infer A>] ? A : never; }>

----------------------------------------

TITLE: Defining Runner Class in TypeScript for @effect/cluster
DESCRIPTION: This code snippet declares the Runner class. A Runner represents a physical application server with a unique address for communication and a version for prioritization during rebalancing.

LANGUAGE: typescript
CODE:
declare class Runner

----------------------------------------

TITLE: Defining Cause.Fail Interface in TypeScript
DESCRIPTION: TypeScript interface definition for Cause.Fail, which extends Cause.Variance<E>, Equal.Equal, Pipeable, and Inspectable. It represents an expected error of type E within a Cause, containing a _tag identifier and the error value.

LANGUAGE: typescript
CODE:
export interface Fail<out E> extends Cause.Variance<E>, Equal.Equal, Pipeable, Inspectable {
  readonly _tag: "Fail"
  readonly error: E
}

----------------------------------------

TITLE: Defining Nesting Interface for Reactive Documents in TypeScript
DESCRIPTION: This code snippet defines the Nesting interface, which extends Doc.Variance<A>. It includes a _tag property set to "Nesting" and a react method that takes a nesting level as input and returns a Doc<A>.

LANGUAGE: typescript
CODE:
export interface Nesting<A> extends Doc.Variance<A> {
  readonly _tag: "Nesting"
  readonly react: (level: number) => Doc<A>
}

----------------------------------------

TITLE: Defining Schedule.sync Function in TypeScript
DESCRIPTION: Defines a function that creates an indefinitely recurring schedule. It takes a lazy argument function and returns a Schedule of the same type. The schedule evaluates the given function to produce a constant value.

LANGUAGE: typescript
CODE:
declare const sync: <A>(evaluate: LazyArg<A>) => Schedule<A>

----------------------------------------

TITLE: Checking for Empty Cause in Effect Package (TypeScript)
DESCRIPTION: The isEmpty function checks if a Cause is entirely empty. It returns true if the Cause contains no errors, defects, or interruptions, which is useful for verifying if a computation had no failures. The function takes a Cause<E> as input and returns a boolean.

LANGUAGE: typescript
CODE:
declare const isEmpty: <E>(self: Cause<E>) => boolean

----------------------------------------

TITLE: Declaring AdditionalSchemas Class in TypeScript
DESCRIPTION: Class declaration for AdditionalSchemas which allows adding additional schemas to components/schemas. The schemas must include an identifier annotation to be valid.

LANGUAGE: typescript
CODE:
declare class AdditionalSchemas

----------------------------------------

TITLE: Defining Parallel Execution Strategy in TypeScript
DESCRIPTION: Declares a constant 'parallel' of type ExecutionStrategy, which is used to execute effects in parallel within the Effect package.

LANGUAGE: typescript
CODE:
declare const parallel: ExecutionStrategy

----------------------------------------

TITLE: Declaring prepend Function for Iterable in TypeScript
DESCRIPTION: Defines the prepend function which adds an element to the beginning of an Iterable. It supports two overloads: one that takes the head element first and returns a function, and another that takes both the Iterable and the head element.

LANGUAGE: typescript
CODE:
declare const prepend: { <B>(head: B): <A>(self: Iterable<A>) => Iterable<A | B>; <A, B>(self: Iterable<A>, head: B): Iterable<A | B>; }

----------------------------------------

TITLE: Constructing HTTP Web Handler from RpcGroup in TypeScript
DESCRIPTION: The toWebHandler function creates an HTTP web handler from an RpcGroup. It takes an RpcGroup and options as parameters, and returns an object with a handler function and a dispose function. The handler processes HTTP requests, while the dispose function cleans up resources.

LANGUAGE: typescript
CODE:
declare const toWebHandler: <Rpcs extends Rpc.Any, LE>(group: RpcGroup.RpcGroup<Rpcs>, options: { readonly layer: Layer.Layer<Rpc.ToHandler<Rpcs> | Rpc.Middleware<Rpcs> | RpcSerialization.RpcSerialization | HttpRouter.HttpRouter.DefaultServices, LE>; readonly disableTracing?: boolean | undefined; readonly spanPrefix?: string | undefined; readonly middleware?: (httpApp: HttpApp.Default) => HttpApp.Default<never, HttpRouter.HttpRouter.DefaultServices>; readonly memoMap?: Layer.MemoMap; }) => { readonly handler: (request: globalThis.Request, context?: Context.Context<never> | undefined) => Promise<Response>; readonly dispose: () => Promise<void>; }

----------------------------------------

TITLE: Removing Annotations from DocTree in TypeScript
DESCRIPTION: The unAnnotate function removes all annotations from a DocTree<A> and returns a DocTree<never>. It takes a DocTree<A> as input and processes it to strip all annotations.

LANGUAGE: typescript
CODE:
declare const unAnnotate: <A>(self: DocTree<A>) => DocTree<never>

----------------------------------------

TITLE: Declaring foldChunks Function in TypeScript for Effect Sink Module
DESCRIPTION: Defines a function that creates a sink for folding input chunks. It takes an initial state, a continuation predicate, and a folding function. The function preserves chunking-invariance and checks the continuation condition at specific points.

LANGUAGE: typescript
CODE:
declare const foldChunks: <S, In>(s: S, contFn: Predicate<S>, f: (s: S, chunk: Chunk.Chunk<In>) => S) => Sink<S, In>

----------------------------------------

TITLE: Creating Cookies Object from Iterable in TypeScript
DESCRIPTION: This function creates a Cookies object from an Iterable of Cookie items. It is part of the Cookies module in the @effect/platform package.

LANGUAGE: typescript
CODE:
declare const fromIterable: (cookies: Iterable<Cookie>) => Cookies

----------------------------------------

TITLE: Implementing forEach Method for TArray in TypeScript
DESCRIPTION: Defines a forEach method that atomically executes a transactional effect for each element in a TArray. The method accepts a function that transforms array elements into STM transactions and returns a new STM transaction.

LANGUAGE: typescript
CODE:
declare const forEach: {
  <A, R, E>(f: (value: A) => STM.STM<void, E, R>): (self: TArray<A>) => STM.STM<void, E, R>;
  <A, R, E>(self: TArray<A>, f: (value: A) => STM.STM<void, E, R>): STM.STM<void, E, R>;
}

----------------------------------------

TITLE: Implementing ANSI Terminal Line Erasure in TypeScript
DESCRIPTION: Defines a constant eraseStartLine of type Ansi that clears text from the current cursor position to the start of the current line. The cursor position remains unchanged after the operation.

LANGUAGE: typescript
CODE:
declare const eraseStartLine: Ansi

----------------------------------------

TITLE: Setting Multiple Cookies with Error Handling in Effect Platform
DESCRIPTION: A function that adds multiple cookies to a Cookies object. It accepts either a curried form or direct application with cookies data. The function throws an error if invalid cookie data is provided. Each cookie entry consists of a name, value, and optional configuration options.

LANGUAGE: typescript
CODE:
declare const unsafeSetAll: { 
  (cookies: Iterable<readonly [name: string, value: string, options?: Cookie["options"]]>): (self: Cookies) => Cookies; 
  (self: Cookies, cookies: Iterable<readonly [name: string, value: string, options?: Cookie["options"]]>): Cookies; 
}

----------------------------------------

TITLE: Effect.Tag Function Signature in TypeScript
DESCRIPTION: This snippet shows the TypeScript signature of the Effect.Tag function. It defines the function's parameters and return type, including complex generic constraints.

LANGUAGE: typescript
CODE:
declare const Tag: <const Id extends string>(id: Id) => <Self, Type extends Tag.AllowedType>() => Context.TagClass<Self, Id, Type> & (Type extends Record<PropertyKey, any> ? Tag.Proxy<Self, Type> : {}) & { use: <X>(body: (_: Type) => X) => [X] extends [Effect<infer A, infer E, infer R>] ? Effect<A, E, R | Self> : [X] extends [PromiseLike<infer A>] ? Effect<A, Cause.UnknownException, Self> : Effect<X, never, Self>; }

----------------------------------------

TITLE: Implementing TSet.retainIf in TypeScript
DESCRIPTION: Defines a function that filters a TSet by retaining only elements that match a predicate. The function can either discard removed elements (returning void) or return them as an array. It operates within the STM (Software Transactional Memory) context.

LANGUAGE: typescript
CODE:
declare const retainIf: {
  <A>(predicate: Predicate<A>, options: { readonly discard: true; }): (self: TSet<A>) => STM.STM<void>;
  <A>(predicate: Predicate<A>, options?: { readonly discard: false; }): (self: TSet<A>) => STM.STM<Array<A>>;
  <A>(self: TSet<A>, predicate: Predicate<A>, options: { readonly discard: true; }): STM.STM<void>;
  <A>(self: TSet<A>, predicate: Predicate<A>, options?: { readonly discard: false; }): STM.STM<Array<A>>;
}

----------------------------------------

TITLE: Updating FiberRef Value with FiberId in TypeScript
DESCRIPTION: The updateAs function updates the value of a specified FiberRef using the provided FiberId. It can be called in two ways: as a curried function or with all parameters at once. The function takes options including the fiberId, fiberRef, and the new value.

LANGUAGE: typescript
CODE:
declare const updateAs: {
  <A>(options: {
    readonly fiberId: FiberId.Single;
    readonly fiberRef: FiberRef.FiberRef<A>;
    readonly value: A;
  }): (self: FiberRefs) => FiberRefs;
  <A>(self: FiberRefs, options: {
    readonly fiberId: FiberId.Single;
    readonly fiberRef: FiberRef.FiberRef<A>;
    readonly value: A;
  }): FiberRefs;
}

----------------------------------------

TITLE: Declaring Elapsed Schedule Function in TypeScript
DESCRIPTION: Declares a constant 'elapsed' as a Schedule that returns a Duration and never fails. It continuously executes and tracks the total time passed since the first execution.

LANGUAGE: typescript
CODE:
declare const elapsed: Schedule<Duration.Duration, unknown, never>

----------------------------------------

TITLE: Implementing Channel Error Mapping in TypeScript
DESCRIPTION: Function signature for mapError operation that transforms channel error types. It takes a mapping function and returns a new channel with transformed error type while preserving other type parameters. Supports both curried and uncurried calling styles.

LANGUAGE: typescript
CODE:
declare const mapError: {
  <OutErr, OutErr2>(f: (err: OutErr) => OutErr2): <OutElem, InElem, InErr, OutDone, InDone, Env>
    (self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) =>
    Channel<OutElem, InElem, OutErr2, InErr, OutDone, InDone, Env>;
  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutErr2>
    (self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,
     f: (err: OutErr) => OutErr2): Channel<OutElem, InElem, OutErr2, InErr, OutDone, InDone, Env>;
}

----------------------------------------

TITLE: Retrieving Order Function from RedBlackTree in TypeScript
DESCRIPTION: Gets the Order<K> comparison function that a RedBlackTree<K, V> instance is using for key comparison and ordering. This function is essential for understanding how keys are compared within the tree structure.

LANGUAGE: typescript
CODE:
declare const getOrder: <K, V>(self: RedBlackTree<K, V>) => Order<K>

----------------------------------------

TITLE: Setting URL Search Parameters in TypeScript using Effect Platform
DESCRIPTION: Function signature for setSearch utility that modifies a URL's query string. Supports both curried and direct invocation patterns for updating the search portion of a URL object.

LANGUAGE: typescript
CODE:
declare const setSearch: { (search: string): (url: URL) => URL; (url: URL, search: string): URL; }

----------------------------------------

TITLE: Filtering Cause Objects in TypeScript using Effect Library
DESCRIPTION: Function signature for filtering Cause objects using either predicates or refinements. It supports both curried and non-curried versions, allowing type-safe filtering of Cause structures to retain only matching elements. The function can narrow down types when used with refinements.

LANGUAGE: typescript
CODE:
declare const filter: {
  <E, EB extends E>(refinement: Refinement<Cause<NoInfer<E>>, Cause<EB>>): (self: Cause<E>) => Cause<EB>;
  <E>(predicate: Predicate<Cause<NoInfer<E>>>): (self: Cause<E>) => Cause<E>;
  <E, EB extends E>(self: Cause<E>, refinement: Refinement<Cause<E>, Cause<EB>>): Cause<EB>;
  <E>(self: Cause<E>, predicate: Predicate<Cause<E>>): Cause<E>;
}

----------------------------------------

TITLE: Implementing Side Effect Execution with Micro.tap in TypeScript
DESCRIPTION: Type definition for the tap function that executes a side effect on the success value of a Micro effect. The function supports both function and non-function inputs, maintaining type safety through conditional types. The original success value is preserved while allowing side effects to be executed.

LANGUAGE: typescript
CODE:
declare const tap: { <A, X>(f: (a: NoInfer<A>) => X): <E, R>(self: Micro<A, E, R>) => [X] extends [Micro<infer _A1, infer E1, infer R1>] ? Micro<A, E | E1, R | R1> : Micro<A, E, R>; <X>(f: NotFunction<X>): <A, E, R>(self: Micro<A, E, R>) => [X] extends [Micro<infer _A1, infer E1, infer R1>] ? Micro<A, E | E1, R | R1> : Micro<A, E, R>; <A, E, R, X>(self: Micro<A, E, R>, f: (a: NoInfer<A>) => X): [X] extends [Micro<infer _A1, infer E1, infer R1>] ? Micro<A, E | E1, R | R1> : Micro<A, E, R>; <A, E, R, X>(self: Micro<A, E, R>, f: NotFunction<X>): [X] extends [Micro<infer _A1, infer E1, infer R1>] ? Micro<A, E | E1, R | R1> : Micro<A, E, R>; }

----------------------------------------

TITLE: TypeScript Function Signature for Options.choice
DESCRIPTION: Provides the TypeScript function signature for the Options.choice function. It shows that the function takes a name string and an array of choices, returning an Options object with the union type of the choices.

LANGUAGE: typescript
CODE:
declare const choice: <A extends string, C extends ReadonlyArray<A>>(name: string, choices: C) => Options<C[number]>

----------------------------------------

TITLE: Defining offerAll Function for Queue in TypeScript
DESCRIPTION: Declares the offerAll function for the Queue module. It can be called with an iterable and a queue, or with a queue and an iterable. The function returns an Effect that resolves to a boolean indicating success.

LANGUAGE: typescript
CODE:
declare const offerAll: { <A>(iterable: Iterable<A>): (self: Enqueue<A>) => Effect.Effect<boolean>; <A>(self: Enqueue<A>, iterable: Iterable<A>): Effect.Effect<boolean>; }

----------------------------------------

TITLE: Demonstrating Record.getMonoidUnion in TypeScript
DESCRIPTION: This example shows how to use the getMonoidUnion function to create a Monoid that combines two records. It uses the MonoidSum instance from the Number module to sum the values of matching keys.

LANGUAGE: typescript
CODE:
import * as NumberInstances from "@effect/typeclass/data/Number"
import { getMonoidUnion } from "@effect/typeclass/data/Record"

const monoid = getMonoidUnion(NumberInstances.MonoidSum)

console.log(monoid.combine({ a: 1 }, { a: 1, b: 3 }))
// { a: 2, b: 3 }

console.log(monoid.combine({ a: 1 }, monoid.empty))
// { a: 1 }

----------------------------------------

TITLE: Defining RunnerHealth Layer in TypeScript
DESCRIPTION: Declares a constant 'layer' of type Layer.Layer<RunnerHealth, never, Runners.Runners>. This layer is used to ping a Runner directly to check if it is healthy.

LANGUAGE: typescript
CODE:
declare const layer: Layer.Layer<RunnerHealth, never, Runners.Runners>

----------------------------------------

TITLE: Checking Empty ReadonlyArray in TypeScript with Effect Library
DESCRIPTION: The isEmptyReadonlyArray function determines if a ReadonlyArray is empty, narrowing down the type to readonly []. It takes a ReadonlyArray as input and returns a boolean indicating whether the array is empty.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

console.log(Array.isEmptyReadonlyArray([])) // true
console.log(Array.isEmptyReadonlyArray([1, 2, 3])) // false

LANGUAGE: typescript
CODE:
declare const isEmptyReadonlyArray: <A>(self: ReadonlyArray<A>) => self is readonly []

----------------------------------------

TITLE: Defining Cause.find Function in TypeScript
DESCRIPTION: Declares the find function for searching a Cause using a partial function. It can be used in two ways: as a curried function or with both arguments provided at once. The function returns an Option containing the extracted value if found.

LANGUAGE: typescript
CODE:
declare const find: { <E, Z>(pf: (cause: Cause<E>) => Option.Option<Z>): (self: Cause<E>) => Option.Option<Z>; <E, Z>(self: Cause<E>, pf: (cause: Cause<E>) => Option.Option<Z>): Option.Option<Z>; }

----------------------------------------

TITLE: Configuring HTTP RPC Protocol Layer in TypeScript
DESCRIPTION: Defines a layer for RPC protocol using HTTP streaming communication. Takes options including path configuration and optional router tag settings. Returns a Layer that provides Protocol functionality and depends on RpcSerialization.

LANGUAGE: typescript
CODE:
declare const layerProtocolHttp: <I = HttpRouter.Default>(options: { readonly path: HttpRouter.PathInput; readonly routerTag?: HttpRouter.HttpRouter.TagClass<I, string, any, any>; }) => Layer.Layer<Protocol, never, RpcSerialization.RpcSerialization>

----------------------------------------

TITLE: Defining STM.interruptAs Function in TypeScript
DESCRIPTION: Function declaration for interrupting a fiber running an effect with a specified FiberId within software transactional memory context. This is part of the Effect library's STM module functionality.

LANGUAGE: typescript
CODE:
declare const interruptAs: (fiberId: FiberId.FiberId) => STM<never>

----------------------------------------

TITLE: Defining Concurrency Type in TypeScript
DESCRIPTION: Defines a union type for specifying concurrency settings when executing multiple Effects. Can be a number for fixed concurrency, 'unbounded' for unlimited concurrency, or 'inherit' to use parent context settings.

LANGUAGE: typescript
CODE:
type Concurrency = number | "unbounded" | "inherit"

----------------------------------------

TITLE: Defining repeatElements Function in TypeScript for Stream Module
DESCRIPTION: Declares the repeatElements function which repeats each element of a stream using a provided schedule. The function takes a Schedule parameter and returns a function that can be applied to a Stream. Repetitions are additional to the first execution.

LANGUAGE: typescript
CODE:
declare const repeatElements: { <B, R2>(schedule: Schedule.Schedule<B, unknown, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R2 | R>; <A, E, R, B, R2>(self: Stream<A, E, R>, schedule: Schedule.Schedule<B, unknown, R2>): Stream<A, E, R | R2>; }

----------------------------------------

TITLE: Defining UUID Schema Class in TypeScript
DESCRIPTION: Declares a class named UUID that represents a Universally Unique Identifier (UUID) schema. This schema ensures that provided strings adhere to the standard UUID format.

LANGUAGE: typescript
CODE:
declare class UUID

----------------------------------------

TITLE: Defining EntryStats Interface for Cache Statistics in TypeScript
DESCRIPTION: This code snippet defines the EntryStats interface, which represents a snapshot of statistics for an entry in the cache. It includes a single readonly property 'loadedMillis' of type number, likely representing the time when the entry was loaded into the cache.

LANGUAGE: typescript
CODE:
export interface EntryStats {
  readonly loadedMillis: number
}

----------------------------------------

TITLE: Setting URL Parameters using @effect/platform
DESCRIPTION: Demonstrates how to update query parameters of a URL using the Url.setUrlParams function. The function creates a new URL instance with modified parameters while preserving the original URL object.

LANGUAGE: typescript
CODE:
import { Url, UrlParams } from "@effect/platform"

const myUrl = new URL("https://example.com?foo=bar")

// Write parameters
const updatedUrl = Url.setUrlParams(
  myUrl,
  UrlParams.fromInput([["key", "value"]])
)

console.log(updatedUrl.toString())
// Output: https://example.com/?key=value

LANGUAGE: typescript
CODE:
declare const setUrlParams: { (urlParams: UrlParams.UrlParams): (url: URL) => URL; (url: URL, urlParams: UrlParams.UrlParams): URL; }

----------------------------------------

TITLE: Defining Schedule.check Function in TypeScript
DESCRIPTION: Declares the 'check' function for the Schedule module. This function takes a test function and applies it to each input-output pair of a schedule, determining whether to continue or stop execution based on the test result.

LANGUAGE: typescript
CODE:
declare const check: { <In, Out>(test: (input: In, output: Out) => boolean): <R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R>(self: Schedule<Out, In, R>, test: (input: In, output: Out) => boolean): Schedule<Out, In, R>; }

----------------------------------------

TITLE: Rotating Array Elements using Effect Array Module
DESCRIPTION: Demonstrates how to use Array.rotate to shift elements in an array by a specified number of positions. The function works with both arrays and iterables, guaranteeing that non-empty arrays remain non-empty after rotation.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const result = Array.rotate(['a', 'b', 'c', 'd'], 2)
console.log(result) // ['c', 'd', 'a', 'b']

LANGUAGE: typescript
CODE:
declare const rotate: { (n: number): <S extends Iterable<any>>(self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S>>; <A>(self: NonEmptyReadonlyArray<A>, n: number): NonEmptyArray<A>; <A>(self: Iterable<A>, n: number): Array<A>; }

----------------------------------------

TITLE: TypeScript Function Signature for Option.getOrThrowWith
DESCRIPTION: Function signature showing the type definition of getOrThrowWith, which accepts an error factory function and returns either the contained value or throws the generated error.

LANGUAGE: typescript
CODE:
declare const getOrThrowWith: { (onNone: () => unknown): <A>(self: Option<A>) => A; <A>(self: Option<A>, onNone: () => unknown): A; }

----------------------------------------

TITLE: Defining Schema.Char Class in TypeScript
DESCRIPTION: Declares the Char class within the Schema module. This class represents a schema for a single character in the effect package.

LANGUAGE: typescript
CODE:
declare class Char

----------------------------------------

TITLE: Type Guard Function for Nest Doc Type in TypeScript
DESCRIPTION: A type guard function that checks if a given Doc<A> instance is specifically a Nest<A> type. Returns true if the doc is a Nest, false otherwise. This function is part of the @effect/printer package's Doc module.

LANGUAGE: typescript
CODE:
declare const isNest: <A>(self: Doc<A>) => self is Nest<A>

----------------------------------------

TITLE: Declaring provideService Function in TypeScript
DESCRIPTION: This code snippet defines the type signature for the provideService function. It allows adding a provided service to the current context, with overloaded versions for different parameter orders.

LANGUAGE: typescript
CODE:
declare const provideService: { <I, S>(tag: Context.Tag<I, S>, service: S): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E, Exclude<R, I>>; <A, E, R, I, S>(self: Micro<A, E, R>, tag: Context.Tag<I, S>, service: S): Micro<A, E, Exclude<R, I>>; }

----------------------------------------

TITLE: Converting STM Option Values to Option Errors in TypeScript
DESCRIPTION: Function signature for STM.some that transforms an STM containing an Option<A> into an STM that moves the Option to the error channel. This allows for handling optional values as potential errors in STM transactions.

LANGUAGE: typescript
CODE:
declare const some: <A, E, R>(self: STM<Option.Option<A>, E, R>) => STM<A, Option.Option<E>, R>

----------------------------------------

TITLE: Logger.batched Function Signature in TypeScript
DESCRIPTION: The signature of the Logger.batched function, which creates a batched logger. It takes a window duration and a processing function as parameters, and returns a new logger that batches messages.

LANGUAGE: typescript
CODE:
declare const batched: { <Output, R>(window: DurationInput, f: (messages: Array<Types.NoInfer<Output>>) => Effect<void, never, R>): <Message>(self: Logger<Message, Output>) => Effect<Logger<Message, void>, never, R | Scope>; <Message, Output, R>(self: Logger<Message, Output>, window: DurationInput, f: (messages: Array<Types.NoInfer<Output>>) => Effect<void, never, R>): Effect<Logger<Message, void>, never, Scope | R>; }

----------------------------------------

TITLE: Constructing Primitive Config in TypeScript
DESCRIPTION: Creates a new primitive configuration with a description and parse function. The parse function converts string input to either a valid configuration value or a ConfigError.

LANGUAGE: typescript
CODE:
declare const primitive: <A>(description: string, parse: (text: string) => Either.Either<A, ConfigError.ConfigError>) => Config<A>

----------------------------------------

TITLE: Implementing STM Ignore Operation in TypeScript
DESCRIPTION: Function signature for creating a new STM effect that ignores the success or failure of the input effect. It transforms any STM effect into one that returns void and never produces an error, while maintaining the same environment type.

LANGUAGE: typescript
CODE:
declare const ignore: <A, E, R>(self: STM<A, E, R>) => STM<void, never, R>

----------------------------------------

TITLE: Parsing Cron Expressions with Cron.unsafeParse in TypeScript
DESCRIPTION: This function parses a cron expression string into a Cron instance. It can handle optional time zone parameters and throws a ParseError for invalid expressions. The resulting Cron instance represents the schedule defined by the input expression.

LANGUAGE: typescript
CODE:
import { Cron } from "effect"

// At 04:00 on every day-of-month from 8 through 14.
console.log(Cron.unsafeParse("0 4 8-14 * *"))
// Output:
// {
//   _id: 'Cron',
//   tz: { _id: 'Option', _tag: 'None' },
//   seconds: [ 0 ],
//   minutes: [ 0 ],
//   hours: [ 4 ],
//   days: [
//      8,  9, 10, 11,
//     12, 13, 14
//   ],
//   months: [],
//   weekdays: []
// }

LANGUAGE: typescript
CODE:
declare const unsafeParse: (cron: string, tz?: DateTime.TimeZone | string) => Cron

----------------------------------------

TITLE: Declaring mapInputInEffect Function in TypeScript
DESCRIPTION: Defines the mapInputInEffect function, which returns a new channel that applies an effectual function to the input channel's output elements. It supports both curried and uncurried versions of the function.

LANGUAGE: typescript
CODE:
declare const mapInputInEffect: { <InElem0, InElem, InErr, Env1>(f: (a: InElem0) => Effect.Effect<InElem, InErr, Env1>): <OutElem, OutErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem0, OutErr, InErr, OutDone, InDone, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InElem0, Env1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (a: InElem0) => Effect.Effect<InElem, InErr, Env1>): Channel<OutElem, InElem0, OutErr, InErr, OutDone, InDone, Env | Env1>; }

----------------------------------------

TITLE: Implementing findEffect Function in Sink Module (TypeScript)
DESCRIPTION: The findEffect function creates a sink that produces values until one verifies the given predicate. It has two overloads to accommodate different parameter orders.

LANGUAGE: typescript
CODE:
declare const findEffect: {
  <A, E2, R2>(f: (a: A) => Effect.Effect<boolean, E2, R2>): <In, L extends In, E, R>(self: Sink<A, In, L, E, R>) => Sink<Option.Option<A>, In, L, E2 | E, R2 | R>;
  <A, In, L extends In, E, R, E2, R2>(self: Sink<A, In, L, E, R>, f: (a: A) => Effect.Effect<boolean, E2, R2>): Sink<Option.Option<A>, In, L, E | E2, R | R2>;
}

----------------------------------------

TITLE: Defining AlreadyFlat Interface in TypeScript
DESCRIPTION: Defines the AlreadyFlat interface which extends Flatten.Variance<A> and includes a readonly _tag property set to "AlreadyFlat". This interface is used to represent a FlattenResult where the input was already flat.

LANGUAGE: typescript
CODE:
export interface AlreadyFlat<A> extends Flatten.Variance<A> {
  readonly _tag: "AlreadyFlat"
}

----------------------------------------

TITLE: Signature of catWithSoftLineBreak in TypeScript
DESCRIPTION: The type signature of the catWithSoftLineBreak function, showing its polymorphic nature and overloaded versions.

LANGUAGE: typescript
CODE:
declare const catWithSoftLineBreak: { <B>(that: Doc<B>): <A>(self: Doc<A>) => Doc<B | A>; <A, B>(self: Doc<A>, that: Doc<B>): Doc<A | B>; }

----------------------------------------

TITLE: TypeScript Signature of logfmtLogger Function
DESCRIPTION: Provides the TypeScript type signature for the logfmtLogger function. It is defined as a Logger that takes an unknown input and produces a string output.

LANGUAGE: typescript
CODE:
declare const logfmtLogger: Logger<unknown, string>

----------------------------------------

TITLE: Defining Empty Patch Function in Differ Module (TypeScript)
DESCRIPTION: Declares an 'empty' function that returns an empty patch describing no changes. It takes a Differ object as a parameter and returns a Patch.

LANGUAGE: typescript
CODE:
declare const empty: <Value, Patch>(self: Differ<Value, Patch>) => Patch

----------------------------------------

TITLE: Declaring filterInputEffect Function in TypeScript
DESCRIPTION: Declares the filterInputEffect function which filters the input of a sink using an effectful predicate. It has two overloads: one for curried usage and another for direct application. The function returns a new Sink with filtered input.

LANGUAGE: typescript
CODE:
declare const filterInputEffect: {
  <In, In1 extends In, E2, R2>(f: (input: In1) => Effect.Effect<boolean, E2, R2>): <A, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In1, L, E2 | E, R2 | R>;
  <A, In, L, E, R, In1 extends In, E2, R2>(self: Sink<A, In, L, E, R>, f: (input: In1) => Effect.Effect<boolean, E2, R2>): Sink<A, In1, L, E | E2, R | R2>;
}

----------------------------------------

TITLE: Setting Working Directory for Command Execution in TypeScript
DESCRIPTION: Function signature for setting the working directory for command execution. Supports both curried and uncurried function calls. When used with piped commands, the working directory setting applies to each command in the pipeline.

LANGUAGE: typescript
CODE:
declare const workingDirectory: { (cwd: string): (self: Command) => Command; (self: Command, cwd: string): Command; }

----------------------------------------

TITLE: Implementing Conditional STM Operations in TypeScript
DESCRIPTION: Defines the type signature for STM.when function that implements conditional execution within software transactional memory. It takes a predicate and returns an optional result wrapped in an STM context. The function provides both curried and uncurried variants.

LANGUAGE: typescript
CODE:
declare const when: { 
  (predicate: LazyArg<boolean>): <A, E, R>(self: STM<A, E, R>) => STM<Option.Option<A>, E, R>; 
  <A, E, R>(self: STM<A, E, R>, predicate: LazyArg<boolean>): STM<Option.Option<A>, E, R>; 
}

----------------------------------------

TITLE: Using catWithSpace to Concatenate Documents with Space in TypeScript
DESCRIPTION: Demonstrates how to use the catWithSpace combinator to concatenate two Doc objects with a space between them. The example creates a document by combining two characters 'a' and 'b' with a space, then renders it.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import { pipe } from "effect/Function"

const doc: Doc.Doc<never> = pipe(
  Doc.char("a"),
  Doc.catWithSpace(Doc.char("b"))
)

assert.strictEqual(
  Doc.render(doc, { style: "pretty" }),
  "a b"
)

----------------------------------------

TITLE: Implementing Channel.toPullIn in TypeScript
DESCRIPTION: Function signature for toPullIn, which creates an Effect that pulls elements from a Channel. It takes a Scope parameter and returns an Effect that can produce either channel elements or a done value, with potential failure handling.

LANGUAGE: typescript
CODE:
declare const toPullIn: { (scope: Scope.Scope): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Effect.Effect<Effect.Effect<Either.Either<OutElem, OutDone>, OutErr, Env>, never, Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, scope: Scope.Scope): Effect.Effect<Effect.Effect<Either.Either<OutElem, OutDone>, OutErr, Env>, never, Env>; }

----------------------------------------

TITLE: Mapping Channel Output in TypeScript
DESCRIPTION: Function signature for mapOut which takes a mapping function and a Channel, returning a new Channel with transformed output elements. The function can be used in both curried and uncurried forms.

LANGUAGE: typescript
CODE:
declare const mapOut: { <OutElem, OutElem2>(f: (o: OutElem) => OutElem2): <InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem2, InElem, OutErr, InErr, OutDone, InDone, Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem2>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (o: OutElem) => OutElem2): Channel<OutElem2, InElem, OutErr, InErr, OutDone, InDone, Env>; }

----------------------------------------

TITLE: Declaring DateFromSelf Schema Class - TypeScript
DESCRIPTION: Defines a schema class that handles Date instances, including potentially invalid ones like 'new Date("Invalid Date")', without rejecting them. This provides more flexible date handling capabilities.

LANGUAGE: typescript
CODE:
declare class DateFromSelf

----------------------------------------

TITLE: Defining an Infinite Counting Schedule in TypeScript
DESCRIPTION: Declares a constant 'count' as a Schedule that recurs indefinitely, counting the number of recurrences. It takes a number as input, can work with any unknown value, and never fails (hence the 'never' type for errors).

LANGUAGE: typescript
CODE:
declare const count: Schedule<number, unknown, never>

----------------------------------------

TITLE: Declaring count Sink in TypeScript
DESCRIPTION: Declares a constant 'count' as a Sink that counts the number of elements fed to it. The Sink takes a number as input and has no specific output type, error type, or environment requirements.

LANGUAGE: typescript
CODE:
declare const count: Sink<number, unknown, never, never, never>

----------------------------------------

TITLE: Declaring head function for Iterable in TypeScript
DESCRIPTION: Declares a function named head that takes an Iterable<A> as input and returns an Option<A>. It retrieves the first element of the Iterable or returns None if the Iterable is empty.

LANGUAGE: typescript
CODE:
declare const head: <A>(self: Iterable<A>) => Option<A>

----------------------------------------

TITLE: Declaring Sink.zip Function in TypeScript
DESCRIPTION: Defines the 'zip' function for the Sink module. It combines two sinks, processing inputs and combining their results into a tuple. The function supports both sequential and concurrent processing based on the provided options.

LANGUAGE: typescript
CODE:
declare const zip: { <A2, In, In2 extends In, L2, E2, R2>(that: Sink<A2, In2, L2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; } | undefined): <A, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<[A, A2], In & In2, L2 | L, E2 | E, R2 | R>; <A, In, L, E, R, A2, In2 extends In, L2, E2, R2>(self: Sink<A, In, L, E, R>, that: Sink<A2, In2, L2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; } | undefined): Sink<[A, A2], In & In2, L | L2, E | E2, R | R2>; }

----------------------------------------

TITLE: Implementing Conditional Recurrence Schedule in TypeScript with Effect
DESCRIPTION: Defines a schedule that continues executing as long as the provided effectful predicate returns true. The function takes a predicate that performs an effect and returns a boolean, allowing for dynamic condition evaluation.

LANGUAGE: typescript
CODE:
declare const recurWhileEffect: <A, R>(f: (a: A) => Effect.Effect<boolean, never, R>) => Schedule<A, A, R>

----------------------------------------

TITLE: Defining ActionDefinition Interface in TypeScript for @effect/cli Prompt Module
DESCRIPTION: Defines the ActionDefinition interface that extends TaggedEnum.WithGenerics<2>. It includes a readonly property 'taggedEnum' of type Action with generic type arguments. This interface is required for creating a Data.TaggedEnum with generic type arguments.

LANGUAGE: typescript
CODE:
export interface ActionDefinition extends TaggedEnum.WithGenerics<2> {
    readonly taggedEnum: Action<this["A"], this["B"]>
  }

----------------------------------------

TITLE: Defining updateService Function in TypeScript for Effect Framework
DESCRIPTION: This code snippet defines the updateService function with multiple overloads. It allows updating a service for a given Context.Tag in the Micro environment. The function can work with both Context.Reference and Context.Tag, and can be applied to an existing Micro instance or return a function to be applied later.

LANGUAGE: typescript
CODE:
declare const updateService: { <I, A>(tag: Context.Reference<I, A>, f: (value: A) => A): <XA, E, R>(self: Micro<XA, E, R>) => Micro<XA, E, R>; <I, A>(tag: Context.Tag<I, A>, f: (value: A) => A): <XA, E, R>(self: Micro<XA, E, R>) => Micro<XA, E, R | I>; <XA, E, R, I, A>(self: Micro<XA, E, R>, tag: Context.Reference<I, A>, f: (value: A) => A): Micro<XA, E, R>; <XA, E, R, I, A>(self: Micro<XA, E, R>, tag: Context.Tag<I, A>, f: (value: A) => A): Micro<XA, E, R | I>; }

----------------------------------------

TITLE: Type Guard Function Definition for Column Type in TypeScript
DESCRIPTION: Defines a type guard function that checks if a given Doc<A> instance is specifically a Column<A>. This function helps with type narrowing in TypeScript by providing compile-time type information.

LANGUAGE: typescript
CODE:
declare const isColumn: <A>(self: Doc<A>) => self is Column<A>

----------------------------------------

TITLE: Declaring andThenEither Function in TypeScript
DESCRIPTION: Defines the andThenEither function that combines two schedules sequentially and collects their outputs in an Either structure. It provides two overloads for different use cases.

LANGUAGE: typescript
CODE:
declare const andThenEither: { <Out2, In2, R2>(that: Schedule<Out2, In2, R2>): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Either.Either<Out2, Out>, In & In2, R2 | R>; <Out, In, R, Out2, In2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>): Schedule<Either.Either<Out2, Out>, In & In2, R | R2>; }

----------------------------------------

TITLE: Using MonoidMin for Number Combination in TypeScript
DESCRIPTION: Example showing how to use MonoidMin to find the minimum between two numbers. The Monoid implementation uses -Infinity as its empty value and returns the smaller of two numbers when combined.

LANGUAGE: typescript
CODE:
import { MonoidMin } from "@effect/typeclass/data/Number"

console.log(MonoidMin.combine(2, 3))
// 2
console.log(MonoidMin.combine(2, MonoidMin.empty))
// 2

LANGUAGE: typescript
CODE:
declare const MonoidMin: monoid.Monoid<number>

----------------------------------------

TITLE: TypeScript Function Type Checking Signature
DESCRIPTION: Provides the TypeScript type signature for the isFunction utility. It takes an unknown input and returns a boolean, with a type predicate for narrowing the type to Function if true.

LANGUAGE: typescript
CODE:
declare const isFunction: (input: unknown) => input is Function

----------------------------------------

TITLE: Extracting Unrecoverable Defects from Cause in TypeScript
DESCRIPTION: The defects function extracts all unrecoverable defects (unexpected errors) from a Cause object. It returns a Chunk of unknown values representing these errors, which can be used for capturing or logging unanticipated failures that may require special handling, such as bug reports.

LANGUAGE: typescript
CODE:
declare const defects: <E>(self: Cause<E>) => Chunk.Chunk<unknown>

----------------------------------------

TITLE: BigDecimal Normalize Function Signature
DESCRIPTION: TypeScript type declaration for the normalize function showing it takes a BigDecimal parameter and returns a BigDecimal result.

LANGUAGE: typescript
CODE:
declare const normalize: (self: BigDecimal) => BigDecimal

----------------------------------------

TITLE: Creating Layer from TimeZone in TypeScript
DESCRIPTION: Defines a function 'layerCurrentZone' that creates a Layer from a given time zone. This function is part of the DateTime module in the Effect package and is used for time zone operations.

LANGUAGE: typescript
CODE:
declare const layerCurrentZone: (zone: TimeZone) => Layer.Layer<CurrentTimeZone>

----------------------------------------

TITLE: Defining Sink.ensuring Function in TypeScript
DESCRIPTION: Declares the 'ensuring' function that returns a new sink with an attached finalizer. The finalizer is guaranteed to execute once the sink begins execution, regardless of completion. It supports both curried and non-curried invocations.

LANGUAGE: typescript
CODE:
declare const ensuring: { <X, R2>(finalizer: Effect.Effect<X, never, R2>): <A, In, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In, L, E, R2 | R>; <A, In, L, E, R, X, R2>(self: Sink<A, In, L, E, R>, finalizer: Effect.Effect<X, never, R2>): Sink<A, In, L, E, R | R2>; }

----------------------------------------

TITLE: Implementing Cursor Forward Movement in TypeScript for ANSI Terminals
DESCRIPTION: The cursorForward function moves the cursor forward by a specified number of columns (defaulting to 1) relative to the current position. It has no effect if the cursor is already at the screen's edge.

LANGUAGE: typescript
CODE:
declare const cursorForward: (columns?: number) => AnsiDoc

----------------------------------------

TITLE: Defining Layer.buildWithScope Function Signature in TypeScript
DESCRIPTION: Declares the function signature for Layer.buildWithScope, which builds a layer into an Effect value. It allows specifying a scope for resource management and supports both curried and non-curried function calls.

LANGUAGE: typescript
CODE:
declare const buildWithScope: { (scope: Scope.Scope): <RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Effect.Effect<Context.Context<ROut>, E, RIn>; <RIn, E, ROut>(self: Layer<ROut, E, RIn>, scope: Scope.Scope): Effect.Effect<Context.Context<ROut>, E, RIn>; }

----------------------------------------

TITLE: Specifying Environment Variables for Commands in TypeScript
DESCRIPTION: The Command.env function allows specifying environment variables to be used when running a command. It can be called with either an environment object and a command, or just an environment object to create a function that takes a command.

LANGUAGE: typescript
CODE:
declare const env: { (environment: Record<string, string | undefined>): (self: Command) => Command; (self: Command, environment: Record<string, string | undefined>): Command; }

----------------------------------------

TITLE: Declaring NoSuchElementExceptionTypeId Symbol in TypeScript
DESCRIPTION: Declares a unique symbol identifying the NoSuchElementException type. This symbol is used to differentiate cases where a required element is missing within a data structure.

LANGUAGE: typescript
CODE:
declare const NoSuchElementExceptionTypeId: unique symbol

----------------------------------------

TITLE: Defining Record.keys Function in TypeScript
DESCRIPTION: Declares a function named keys that takes a ReadonlyRecord and returns an array of its keys. The function is generic, allowing for string or symbol keys and any value type.

LANGUAGE: typescript
CODE:
declare const keys: <K extends string | symbol, A>(self: ReadonlyRecord<K, A>) => Array<K & string>

----------------------------------------

TITLE: Demonstrating Either.getLeft Usage in TypeScript
DESCRIPTION: This example shows how to use the Either.getLeft function to convert an Either to an Option, discarding the right value. It demonstrates the behavior for both right and left cases.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Either, Option } from "effect"

assert.deepStrictEqual(Either.getLeft(Either.right('ok')), Option.none())
assert.deepStrictEqual(Either.getLeft(Either.left('err')), Option.some('err'))

----------------------------------------

TITLE: Defining AsSchema Type in TypeScript for effect Package
DESCRIPTION: Defines the AsSchema type, which is a type-level representation of the Schema.asSchema function. It takes a generic type S and constructs a Schema type with Type, Encoded, and Context from S.

LANGUAGE: typescript
CODE:
type AsSchema<S> = Schema<Type<S>, Encoded<S>, Context<S>>

----------------------------------------

TITLE: Declaring Layer.scope Type in TypeScript
DESCRIPTION: Type declaration for Layer.scope which creates a layer that manages a Scope lifecycle. The layer constructs a scope and ensures it is properly closed when the workflow completes, regardless of the completion state (success, failure, or interruption).

LANGUAGE: typescript
CODE:
declare const scope: Layer<Scope.Scope, never, never>

----------------------------------------

TITLE: Defining SemiApplicative.lift2 Function in TypeScript
DESCRIPTION: Defines the lift2 function for SemiApplicative, which lifts a binary function into F. The function takes a SemiApplicative instance and returns a higher-order function that can be applied to binary functions and two values of type F.

LANGUAGE: typescript
CODE:
declare const lift2: <F extends TypeLambda>(F: SemiApplicative<F>) => <A, B, C>(f: (a: A, b: B) => C) => { <R2, O2, E2>(that: Kind<F, R2, O2, E2, B>): <R1, O1, E1>(self: Kind<F, R1, O1, E1, A>) => Kind<F, R1 & R2, O2 | O1, E2 | E1, C>; <R1, O1, E1, R2, O2, E2>(self: Kind<F, R1, O1, E1, A>, that: Kind<F, R2, O2, E2, B>): Kind<F, R1 & R2, O1 | O2, E1 | E2, C>; }

----------------------------------------

TITLE: Declaring collectUntilEffect Function in TypeScript
DESCRIPTION: Defines the collectUntilEffect function that creates a schedule to collect inputs into a Chunk until a given effectful predicate returns false. The function takes a predicate that returns an Effect of boolean and produces a Schedule that operates on Chunks of the input type.

LANGUAGE: typescript
CODE:
declare const collectUntilEffect: <A, R>(f: (a: A) => Effect.Effect<boolean, never, R>) => Schedule<Chunk.Chunk<A>, A, R>

----------------------------------------

TITLE: Implementing Covariant Map Composition in TypeScript
DESCRIPTION: This function returns a default map composition for nested type constructors F and G that implement the Covariant typeclass. It allows mapping over a value of type F<G<A>> to produce F<G<B>>.

LANGUAGE: typescript
CODE:
declare const mapComposition: <F extends TypeLambda, G extends TypeLambda>(F: Covariant<F>, G: Covariant<G>) => <FR, FO, FE, GR, GO, GE, A, B>(self: Kind<F, FR, FO, FE, Kind<G, GR, GO, GE, A>>, f: (a: A) => B) => Kind<F, FR, FO, FE, Kind<G, GR, GO, GE, B>>

----------------------------------------

TITLE: Implementing Fiber.zipRight in TypeScript
DESCRIPTION: Function signature for zipRight operation that combines two Fibers, discarding the output of the first Fiber and keeping the output of the second Fiber. Handles error union types from both Fibers.

LANGUAGE: typescript
CODE:
declare const zipRight: { <A2, E2>(that: Fiber<A2, E2>): <A, E>(self: Fiber<A, E>) => Fiber<A2, E2 | E>; <A, E, A2, E2>(self: Fiber<A, E>, that: Fiber<A2, E2>): Fiber<A2, E | E2>; }

----------------------------------------

TITLE: Type Guard Function for BufferSliding MergeStrategy in TypeScript
DESCRIPTION: A type guard function that determines if a given MergeStrategy instance is specifically of type BufferSliding. Returns true if the strategy is BufferSliding, false otherwise. This function helps with type narrowing in TypeScript.

LANGUAGE: typescript
CODE:
declare const isBufferSliding: (self: MergeStrategy) => self is BufferSliding

----------------------------------------

TITLE: Checking Non-Empty Intervals in TypeScript
DESCRIPTION: The isNonEmpty function determines whether a given Interval is non-empty. It takes an Interval as input and returns a boolean value. This function is part of the ScheduleInterval module in the effect package.

LANGUAGE: typescript
CODE:
declare const isNonEmpty: (self: Interval) => boolean

----------------------------------------

TITLE: Getting MutableQueue Capacity in TypeScript
DESCRIPTION: A type declaration for retrieving the maximum capacity of a MutableQueue. The capacity indicates the maximum number of elements the queue can hold, with unbounded queues returning Infinity.

LANGUAGE: typescript
CODE:
declare const capacity: <A>(self: MutableQueue<A>) => number

----------------------------------------

TITLE: Demonstrating STM.loop Functionality in TypeScript
DESCRIPTION: This code snippet illustrates the conceptual equivalent of the STM.loop function using a while loop. It demonstrates how the function collects results into an array while iterating over a state, controlled by a continuation condition.

LANGUAGE: typescript
CODE:
const as = []
let s  = initial

while (cont(s)) {
  as.push(body(s))
  s  = inc(s)
}

return as

----------------------------------------

TITLE: Defining MicroCause Type in TypeScript
DESCRIPTION: This code snippet defines the MicroCause type, which represents different ways a Micro can fail. It includes Die for unforeseen defects, Fail for anticipated errors, and Interrupt for purposefully stopped operations.

LANGUAGE: typescript
CODE:
type MicroCause<E> = | MicroCause.Die
  | MicroCause.Fail<E>
  | MicroCause.Interrupt

----------------------------------------

TITLE: TypeScript Signature for Doc.align Function
DESCRIPTION: This code snippet shows the TypeScript signature for the Doc.align function. It takes a Doc<A> as input and returns a Doc<A>.

LANGUAGE: typescript
CODE:
declare const align: <A>(self: Doc<A>) => Doc<A>

----------------------------------------

TITLE: Defining Close Interface for ChildExecutorDecision in TypeScript
DESCRIPTION: Defines the Close interface extending ChildExecutorDecision.Proto. It includes a _tag property set to "Close" and a value property of unknown type. This interface is used to close the current substream with a given value and pass execution to the next substream.

LANGUAGE: typescript
CODE:
export interface Close extends ChildExecutorDecision.Proto {
  readonly _tag: "Close"
  readonly value: unknown
}

----------------------------------------

TITLE: Creating Streams with unfoldEffect in TypeScript
DESCRIPTION: Demonstrates how to create a stream using Stream.unfoldEffect by generating random boolean values and transforming numbers. The function takes an initial state and a transformation function that returns an Effect containing an Option of a tuple with the current value and next state.

LANGUAGE: typescript
CODE:
import { Effect, Option, Random, Stream } from "effect"

const stream = Stream.unfoldEffect(1, (n) =>
  Random.nextBoolean.pipe(
    Effect.map((b) => (b ? Option.some([n, -n]) : Option.some([n, n])))
  ))

Effect.runPromise(Stream.runCollect(stream.pipe(Stream.take(5)))).then(console.log)
// { _id: 'Chunk', values: [ 1, -1, -1, -1, -1 ] }

LANGUAGE: typescript
CODE:
declare const unfoldEffect: <S, A, E, R>(s: S, f: (s: S) => Effect.Effect<Option.Option<readonly [A, S]>, E, R>) => Stream<A, E, R>

----------------------------------------

TITLE: Implementing scanEffect Stream Operation in TypeScript
DESCRIPTION: Defines a scanEffect operation that statefully and effectfully maps over stream elements to produce intermediate results of type S given an initial value. The function supports both curried and uncurried forms with generic type parameters for stream elements, effects, and environment.

LANGUAGE: typescript
CODE:
declare const scanEffect: { 
  <S, A, E2, R2>(s: S, f: (s: S, a: A) => Effect.Effect<S, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<S, E2 | E, R2 | R>; 
  <A, E, R, S, E2, R2>(self: Stream<A, E, R>, s: S, f: (s: S, a: A) => Effect.Effect<S, E2, R2>): Stream<S, E | E2, R | R2>; 
}

----------------------------------------

TITLE: Creating Custom Schedule with State in TypeScript
DESCRIPTION: The makeWithState function creates a new schedule with a custom state and step function. It allows for defining complex scheduling logic by specifying an initial state and a step function that determines how the schedule progresses over time. The step function is called on each iteration with the current time, input value, and current state, returning the next state, output value, and a decision on whether to continue or stop.

LANGUAGE: typescript
CODE:
declare const makeWithState: <S, In, Out, R = never>(initial: S, step: (now: number, input: In, state: S) => Effect.Effect<readonly [S, Out, ScheduleDecision.ScheduleDecision], never, R>) => Schedule<Out, In, R>

----------------------------------------

TITLE: TypeScript Signature of catWithLineBreak Function
DESCRIPTION: The TypeScript type signature for the catWithLineBreak function, showing its polymorphic nature and ability to work with different document types.

LANGUAGE: typescript
CODE:
declare const catWithLineBreak: { <B>(that: Doc<B>): <A>(self: Doc<A>) => Doc<B | A>; <A, B>(self: Doc<A>, that: Doc<B>): Doc<A | B>; }

----------------------------------------

TITLE: Forking Micro Effects in TypeScript
DESCRIPTION: The fork function runs a Micro effect in a new MicroFiber that can be awaited, joined, or aborted. The parent Micro will abort this Micro when it finishes. It takes a Micro effect as input and returns a new Micro that produces a MicroFiber.

LANGUAGE: typescript
CODE:
declare const fork: <A, E, R>(self: Micro<A, E, R>) => Micro<MicroFiber<A, E>, never, R>

----------------------------------------

TITLE: Declaring collectWhileEffect Function in TypeScript
DESCRIPTION: Defines a function that creates a schedule to collect inputs into a Chunk while an effectful condition is true. It takes a predicate function that returns an Effect of boolean and produces a Schedule that accumulates inputs of type A.

LANGUAGE: typescript
CODE:
declare const collectWhileEffect: <A, R>(f: (a: A) => Effect.Effect<boolean, never, R>) => Schedule<Chunk.Chunk<A>, A, R>

----------------------------------------

TITLE: Declaring provideServiceEffect Function for Micro Service Provision in TypeScript
DESCRIPTION: This code snippet declares the 'provideServiceEffect' function, which creates a service using the Micro effect and adds it to the current context. It has two overloads to handle different parameter orders and supports generic types for flexibility.

LANGUAGE: typescript
CODE:
declare const provideServiceEffect: { <I, S, E2, R2>(tag: Context.Tag<I, S>, acquire: Micro<S, E2, R2>): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E | E2, Exclude<R, I> | R2>; <A, E, R, I, S, E2, R2>(self: Micro<A, E, R>, tag: Context.Tag<I, S>, acquire: Micro<S, E2, R2>): Micro<A, E | E2, Exclude<R, I> | R2>; }

----------------------------------------

TITLE: TypeScript Function Signature for Tuple First Element Transformation
DESCRIPTION: Provides the TypeScript function signature for the 'mapFirst' function from the Effect/Tuple module. The signature shows two overloads: one for curried usage and another for direct application, allowing flexibility in how the function is called.

LANGUAGE: typescript
CODE:
declare const mapFirst: { <L1, L2>(f: (left: L1) => L2): <R>(self: readonly [L1, R]) => [L2, R]; <L1, R, L2>(self: readonly [L1, R], f: (left: L1) => L2): [L2, R]; }

----------------------------------------

TITLE: Finding Last Element with Predicate in TypeScript Array
DESCRIPTION: Demonstrates how to use the Array.findLast function to find the last element in an array that satisfies a given condition. The function returns an Option containing the found element or Option.none if no element matches.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const result = Array.findLast([1, 2, 3, 4, 5], n => n % 2 === 0)
console.log(result) // Option.some(4)

----------------------------------------

TITLE: Creating MutableList from Iterable in TypeScript
DESCRIPTION: Function signature for creating a new MutableList from an iterable collection. Takes an Iterable<A> as input and returns a MutableList<A> containing the same elements.

LANGUAGE: typescript
CODE:
declare const fromIterable: <A>(iterable: Iterable<A>) => MutableList<A>

----------------------------------------

TITLE: Patching RuntimeFlags with TypeScript
DESCRIPTION: Function signature for patching RuntimeFlags with a RuntimeFlagsPatch. Supports both curried and direct invocation patterns for modifying RuntimeFlag sets.

LANGUAGE: typescript
CODE:
declare const patch: { 
  (patch: RuntimeFlagsPatch.RuntimeFlagsPatch): (self: RuntimeFlags) => RuntimeFlags; 
  (self: RuntimeFlags, patch: RuntimeFlagsPatch.RuntimeFlagsPatch): RuntimeFlags; 
}

----------------------------------------

TITLE: Transforming Sink Input Chunks in TypeScript
DESCRIPTION: Function signature for mapInputChunks, which transforms a sink's input chunks while preserving chunking-invariance. It provides two overloads: one that takes the transformation function first, and another that takes the sink first.

LANGUAGE: typescript
CODE:
declare const mapInputChunks: { <In0, In>(f: (chunk: Chunk.Chunk<In0>) => Chunk.Chunk<In>): <A, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In0, L, E, R>; <A, In, L, E, R, In0>(self: Sink<A, In, L, E, R>, f: (chunk: Chunk.Chunk<In0>) => Chunk.Chunk<In>): Sink<A, In0, L, E, R>; }

----------------------------------------

TITLE: Retrieving TestClock Service in TypeScript
DESCRIPTION: Function signature for retrieving the TestClock service instance for test environments. Returns an Effect containing the TestClock service that can be used for controlling time in tests.

LANGUAGE: typescript
CODE:
declare const testClock: () => Effect.Effect<TestClock>

----------------------------------------

TITLE: Implementing Array Element Counter in TypeScript Effect Package
DESCRIPTION: Defines a count function that takes a predicate and returns the number of elements in a TArray that satisfy the predicate. The function operates within the STM (Software Transactional Memory) context and supports both curried and uncurried calling styles.

LANGUAGE: typescript
CODE:
declare const count: { <A>(predicate: Predicate<A>): (self: TArray<A>) => STM.STM<number>; <A>(self: TArray<A>, predicate: Predicate<A>): STM.STM<number>; }

----------------------------------------

TITLE: TypeScript Function Signature for Tuple Swapping
DESCRIPTION: Provides the TypeScript function signature for the swap function in the Tuple module. It shows that the function takes a readonly tuple with two elements of types L and R, and returns a new tuple with the elements swapped.

LANGUAGE: typescript
CODE:
declare const swap: <L, R>(self: readonly [L, R]) => [R, L]

----------------------------------------

TITLE: Validating UnknownException Types in TypeScript
DESCRIPTION: A type guard function that checks if a given unknown value is an UnknownException. This utility helps with type narrowing and runtime type checking of exception objects.

LANGUAGE: typescript
CODE:
declare const isUnknownException: (u: unknown) => u is UnknownException

----------------------------------------

TITLE: Setting Current Time Zone in Effect Operations with TypeScript
DESCRIPTION: Demonstrates how to use the withCurrentZoneNamed function to set the current time zone for DateTime operations in Effect. It uses the IANA time zone identifier and handles potential IllegalArgumentException errors.

LANGUAGE: typescript
CODE:
import { DateTime, Effect } from "effect"

Effect.gen(function* () {
  // will use the "Europe/London" time zone
  const now = yield* DateTime.nowInCurrentZone
}).pipe(DateTime.withCurrentZoneNamed("Europe/London"))

LANGUAGE: typescript
CODE:
declare const withCurrentZoneNamed: { (zone: string): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E | IllegalArgumentException, Exclude<R, CurrentTimeZone>>; <A, E, R>(effect: Effect.Effect<A, E, R>, zone: string): Effect.Effect<A, E | IllegalArgumentException, Exclude<R, CurrentTimeZone>>; }

----------------------------------------

TITLE: Creating Empty FiberRefs Collection in TypeScript
DESCRIPTION: The empty function creates and returns an empty collection of FiberRef values. It takes no parameters and returns a FiberRefs object.

LANGUAGE: typescript
CODE:
declare const empty: () => FiberRefs

----------------------------------------

TITLE: Implementing Error Handling for Micro Effects in TypeScript
DESCRIPTION: Function signature for ignoreLogged that takes a Micro effect and returns a new Micro effect that ignores any expected errors, transforming the return type to void and never producing errors.

LANGUAGE: typescript
CODE:
declare const ignoreLogged: <A, E, R>(self: Micro<A, E, R>) => Micro<void, never, R>

----------------------------------------

TITLE: Transforming Tuple First Element in TypeScript using Effect/Tuple
DESCRIPTION: Demonstrates how to use the 'mapFirst' function from the Effect/Tuple module to transform the first element of a tuple. The function takes a tuple and a transformation function as arguments, applying the function to the first element while leaving the second element unchanged.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { mapFirst } from "effect/Tuple"

assert.deepStrictEqual(
  mapFirst(["hello", 42], s => s.toUpperCase()),
  ["HELLO", 42]
)

----------------------------------------

TITLE: Declaring reduceEffect Function in TypeScript for Effect Schedule Module
DESCRIPTION: Defines the reduceEffect function, which creates a new schedule that accumulates outputs over time using an effectful reducer function. It supports both curried and uncurried versions, allowing for flexible usage patterns.

LANGUAGE: typescript
CODE:
declare const reduceEffect: { <Z, Out, R2>(zero: Z, f: (z: Z, out: Out) => Effect.Effect<Z, never, R2>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Z, In, R2 | R>; <Out, In, R, Z, R2>(self: Schedule<Out, In, R>, zero: Z, f: (z: Z, out: Out) => Effect.Effect<Z, never, R2>): Schedule<Z, In, R | R2>; }

----------------------------------------

TITLE: Defining CommandOutput Type in TypeScript
DESCRIPTION: Defines the CommandOutput type, which configures the pipes established between parent and child processes' stderr and stdout streams. It can be set to 'inherit', 'pipe', or a Sink<Uint8Array, Uint8Array>. The default value is 'pipe'.

LANGUAGE: typescript
CODE:
type CommandOutput = "inherit" | "pipe" | Sink<Uint8Array, Uint8Array>

----------------------------------------

TITLE: Transforming MicroSchedule with Maximum Delay in TypeScript
DESCRIPTION: The scheduleWithMaxDelay function transforms a MicroSchedule to ensure its delay never exceeds a specified maximum. It can be called with either the maximum delay first and the schedule second, or vice versa.

LANGUAGE: typescript
CODE:
declare const scheduleWithMaxDelay: { (max: number): (self: MicroSchedule) => MicroSchedule; (self: MicroSchedule, max: number): MicroSchedule; }

----------------------------------------

TITLE: Accessing First Element in Effect Chunk - TypeScript
DESCRIPTION: Function signature for unsafeHead that returns the first element of a Chunk collection. This operation is unsafe as it will throw an error if the chunk is empty rather than handling the empty case safely.

LANGUAGE: typescript
CODE:
declare const unsafeHead: <A>(self: Chunk<A>) => A

----------------------------------------

TITLE: Reloading Services with Reloadable.reload in TypeScript
DESCRIPTION: The reload function is used to reload a specified service. It takes a Context.Tag as an argument and returns an Effect that reloads the service associated with that tag. The function works with services that implement the Reloadable interface.

LANGUAGE: typescript
CODE:
declare const reload: <I, S>(tag: Context.Tag<I, S>) => Effect.Effect<void, unknown, Reloadable<I>>

----------------------------------------

TITLE: Handling Specific Defects with Effect.catchSomeDefect in TypeScript
DESCRIPTION: Demonstrates how to use Effect.catchSomeDefect to handle specific defects while allowing others to propagate. The example simulates a runtime error and attempts to catch an IllegalArgumentException.

LANGUAGE: typescript
CODE:
import { Effect, Cause, Option, Console } from "effect"

// Simulating a runtime error
const task = Effect.dieMessage("Boom!")

const program = Effect.catchSomeDefect(task, (defect) => {
  if (Cause.isIllegalArgumentException(defect)) {
    return Option.some(
      Console.log(
        `Caught an IllegalArgumentException defect: ${defect.message}`
      )
    )
  }
  return Option.none()
})

// Since we are only catching IllegalArgumentException
// we will get an Exit.Failure because we simulated a runtime error.
Effect.runPromiseExit(program).then(console.log)
// Output:
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: {
//     _id: 'Cause',
//     _tag: 'Die',
//     defect: { _tag: 'RuntimeException' }
//   }
// }

----------------------------------------

TITLE: Defining Stream Identity Function in TypeScript
DESCRIPTION: Declares the identity function for streams, which creates a stream without modifying its elements. It's a generic function that can work with any type of stream elements, error types, and environment types.

LANGUAGE: typescript
CODE:
declare const identity: <A, E = never, R = never>() => Stream<A, E, R>

----------------------------------------

TITLE: Declaring List.cons Function in TypeScript
DESCRIPTION: Defines the signature of the cons function for constructing a new List.Cons<A> from a head value and a tail List. The function takes a head of type A and a tail of type List<A>, returning a Cons<A>.

LANGUAGE: typescript
CODE:
declare const cons: <A>(head: A, tail: List<A>) => Cons<A>

----------------------------------------

TITLE: Defining reduceAll Function for STM in TypeScript
DESCRIPTION: Declares the reduceAll function with two overloads. It reduces an Iterable<STM> to a single STM, working sequentially. The function takes an initial STM value and a reducer function, or an iterable, initial value, and reducer function.

LANGUAGE: typescript
CODE:
declare const reduceAll: { <A, E2, R2>(initial: STM<A, E2, R2>, f: (x: A, y: A) => A): <E, R>(iterable: Iterable<STM<A, E, R>>) => STM<A, E2 | E, R2 | R>; <A, E, R, E2, R2>(iterable: Iterable<STM<A, E, R>>, initial: STM<A, E2, R2>, f: (x: A, y: A) => A): STM<A, E | E2, R | R2>; }

----------------------------------------

TITLE: Defining Cause.Interrupt Interface in TypeScript
DESCRIPTION: TypeScript interface definition for Cause.Interrupt that models fiber interruption. It extends multiple base interfaces including Cause.Variance, Equal.Equal, Pipeable, and Inspectable. Contains a discriminator tag and fiberId field to identify the interrupted fiber.

LANGUAGE: typescript
CODE:
export interface Interrupt extends Cause.Variance<never>, Equal.Equal, Pipeable, Inspectable {
  readonly _tag: "Interrupt"
  readonly fiberId: FiberId.FiberId
}

----------------------------------------

TITLE: Retrieving Live Service for Test Workflow in TypeScript
DESCRIPTION: The liveWith function retrieves the Live service for a test and uses it to run a specified workflow. It takes a function as an argument that receives the TestLive service and returns an Effect.

LANGUAGE: typescript
CODE:
declare const liveWith: <A, E, R>(f: (live: Live.TestLive) => Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>

----------------------------------------

TITLE: Defining encodedSchema Function in TypeScript
DESCRIPTION: The encodedSchema function extracts the Encoded portion of a schema, creating a new schema that conforms to the original properties without refinements or transformations. It takes a Schema<A, I, R> as input and returns a SchemaClass<I>.

LANGUAGE: typescript
CODE:
declare const encodedSchema: <A, I, R>(schema: Schema<A, I, R>) => SchemaClass<I>

----------------------------------------

TITLE: TypeScript Function Signature for groupByKey
DESCRIPTION: Function signature showing the type definition of groupByKey operation. Accepts a key function and optional buffer size, returns a GroupBy object.

LANGUAGE: typescript
CODE:
declare const groupByKey: { <A, K>(f: (a: A) => K, options?: { readonly bufferSize?: number | undefined; }): <E, R>(self: Stream<A, E, R>) => GroupBy.GroupBy<K, A, E, R>; <A, E, R, K>(self: Stream<A, E, R>, f: (a: A) => K, options?: { readonly bufferSize?: number | undefined; }): GroupBy.GroupBy<K, A, E, R>; }

----------------------------------------

TITLE: Retrieving TMap Size with STM in TypeScript
DESCRIPTION: Function signature for getting the number of key-value bindings in a TMap data structure. Returns an STM transaction that resolves to a number representing the map size.

LANGUAGE: typescript
CODE:
declare const size: <K, V>(self: TMap<K, V>) => STM.STM<number>

----------------------------------------

TITLE: Initializing List with Single Value in TypeScript
DESCRIPTION: Function signature for creating a new List<A> from a single value. Returns a Cons<A> which represents a non-empty list containing the provided value.

LANGUAGE: typescript
CODE:
declare const of: <A>(value: A) => Cons<A>

----------------------------------------

TITLE: Using isDate Predicate in TypeScript
DESCRIPTION: Demonstrates how to use the isDate predicate from the effect/Predicate module to check if a value is a Date object. It shows both positive and negative test cases.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { isDate } from "effect/Predicate"

assert.deepStrictEqual(isDate(new Date()), true)

assert.deepStrictEqual(isDate(null), false)
assert.deepStrictEqual(isDate({}), false)

----------------------------------------

TITLE: Constructing Exit.Success in TypeScript
DESCRIPTION: The succeed function creates a new Exit.Success instance containing a specified value of type A. It is part of the Exit module in the Effect package.

LANGUAGE: typescript
CODE:
declare const succeed: <A>(value: A) => Exit<A>

----------------------------------------

TITLE: Converting Option to Exit in TypeScript
DESCRIPTION: A utility function that converts an Option<A> type into an Exit<void, A> type. This allows for transforming optional values into the Exit type system used by the effect package.

LANGUAGE: typescript
CODE:
declare const fromOption: <A>(option: Option.Option<A>) => Exit<A, void>

----------------------------------------

TITLE: Setting DateTime Parts in Effect TypeScript Library
DESCRIPTION: Function signature for setParts, which allows modification of DateTime components using a Partial<DateTime.PartsWithWeekday> object. The function supports both curried and uncurried parameter variations, and returns the same DateTime type as input after applying timezone adjustments.

LANGUAGE: typescript
CODE:
declare const setParts: { (parts: Partial<DateTime.PartsWithWeekday>): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, parts: Partial<DateTime.PartsWithWeekday>): A; }

----------------------------------------

TITLE: Excluding RuntimeFlags using RuntimeFlagsPatch in TypeScript
DESCRIPTION: Defines a function that creates a RuntimeFlagsPatch for excluding specific RuntimeFlags from a set. The function supports both curried and uncurried calling styles, taking either a flag and returning a function, or taking both patch and flag parameters directly.

LANGUAGE: typescript
CODE:
declare const exclude: { (flag: RuntimeFlags.RuntimeFlag): (self: RuntimeFlagsPatch) => RuntimeFlagsPatch; (self: RuntimeFlagsPatch, flag: RuntimeFlags.RuntimeFlag): RuntimeFlagsPatch; }

----------------------------------------

TITLE: Implementing Delayed Schedule in TypeScript
DESCRIPTION: Defines a function that modifies a schedule by using its own output delays to control execution timing. The schedule will be delayed by the duration it produces instead of executing immediately at each interval.

LANGUAGE: typescript
CODE:
declare const delayedSchedule: <In, R>(schedule: Schedule<Duration.Duration, In, R>) => Schedule<Duration.Duration, In, R>

----------------------------------------

TITLE: Converting DateTime to UTC Date in TypeScript
DESCRIPTION: The toDateUtc function takes a DateTime object and returns its UTC Date equivalent. This function is part of the DateTime module in the Effect package and has been available since version 3.6.0.

LANGUAGE: typescript
CODE:
declare const toDateUtc: (self: DateTime) => Date

----------------------------------------

TITLE: Type Signature of Effect's Number.min Function in TypeScript
DESCRIPTION: This snippet shows the TypeScript type signature for the `min` function in the Effect package's Number module. It indicates that the function can be called with either one or two number parameters, returning a number in both cases.

LANGUAGE: typescript
CODE:
declare const min: { (that: number): (self: number) => number; (self: number, that: number): number; }

----------------------------------------

TITLE: Creating Intervals from Iterable in TypeScript
DESCRIPTION: The fromIterable function creates Intervals from a specified Iterable<Interval>. It takes an iterable of Interval objects as input and returns an Intervals object.

LANGUAGE: typescript
CODE:
declare const fromIterable: (intervals: Iterable<Interval.Interval>) => Intervals

----------------------------------------

TITLE: Creating Zoned DateTime from String in TypeScript
DESCRIPTION: Function that creates a DateTime.Zoned object from a string input. The string must follow the format YYYY-MM-DDTHH:mm:ss.sss+HH:MM[Time/Zone]. Returns an Option type containing the Zoned datetime if successful.

LANGUAGE: typescript
CODE:
declare const makeZonedFromString: (input: string) => Option.Option<Zoned>

----------------------------------------

TITLE: Transforming Schedule Output to Void in TypeScript
DESCRIPTION: Function signature for transforming a Schedule instance to return void instead of its original output type. Used when only the timing aspects of a schedule are relevant and the output values can be discarded.

LANGUAGE: typescript
CODE:
declare const asVoid: <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<void, In, R>

----------------------------------------

TITLE: Implementing Contravariant Functor Composition in TypeScript
DESCRIPTION: Implements composition between two contravariant functors that results in a covariant functor. The function takes two contravariant functors F and G and returns a binary map composition that can transform values of type A to type B within the nested functor structure.

LANGUAGE: typescript
CODE:
declare const contramapComposition: <F extends TypeLambda, G extends TypeLambda>(F: Contravariant<F>, G: Contravariant<G>) => <FR, FO, FE, GR, GO, GE, A, B>(self: Kind<F, FR, FO, FE, Kind<G, GR, GO, GE, A>>, f: (a: A) => B) => Kind<F, FR, FO, FE, Kind<G, GR, GO, GE, B>>

----------------------------------------

TITLE: Adding DotEnv Config Provider Layer in TypeScript
DESCRIPTION: Adds a dotenv ConfigProvider to the environment as a fallback to the current ConfigProvider. The function takes a file path parameter and returns a Layer that requires FileSystem functionality. If the specified .env file is not found, it logs a debug message and returns an empty layer.

LANGUAGE: typescript
CODE:
declare const layerDotEnvAdd: (path: string) => Layer.Layer<never, never, FileSystem.FileSystem>

----------------------------------------

TITLE: Stream.partition Type Definition
DESCRIPTION: TypeScript type signature for the Stream.partition function, showing supported parameter types and return values. Includes overloads for both refinement and predicate-based partitioning.

LANGUAGE: typescript
CODE:
declare const partition: { <C extends A, B extends A, A = C>(refinement: Refinement<NoInfer<A>, B>, options?: { bufferSize?: number | undefined; } | undefined): <E, R>(self: Stream<C, E, R>) => Effect.Effect<[excluded: Stream<Exclude<C, B>, E, never>, satisfying: Stream<B, E, never>], E, R | Scope.Scope>; <A>(predicate: Predicate<A>, options?: { bufferSize?: number | undefined; } | undefined): <E, R>(self: Stream<A, E, R>) => Effect.Effect<[excluded: Stream<A, E, never>, satisfying: Stream<A, E, never>], E, Scope.Scope | R>; <C extends A, E, R, B extends A, A = C>(self: Stream<C, E, R>, refinement: Refinement<A, B>, options?: { bufferSize?: number | undefined; } | undefined): Effect.Effect<[excluded: Stream<Exclude<C, B>, E, never>, satisfying: Stream<B, E, never>], E, R | Scope.Scope>; <A, E, R>(self: Stream<A, E, R>, predicate: Predicate<A>, options?: { bufferSize?: number | undefined; } | undefined): Effect.Effect<[excluded: Stream<A, E, never>, satisfying: Stream<A, E, never>], E, R | Scope.Scope>; }

----------------------------------------

TITLE: Implementing Traversable.sequence in TypeScript
DESCRIPTION: Defines a function that returns a default sequence implementation for Traversable structures. It takes a Traversable<T> and an Applicative<F> as parameters and returns a function that sequences a traversable structure of applicative values into an applicative of a traversable structure.

LANGUAGE: TypeScript
CODE:
declare const sequence: <T extends TypeLambda>(T: Traversable<T>) => <F extends TypeLambda>(F: Applicative<F>) => <TR, TO, TE, R, O, E, A>(self: Kind<T, TR, TO, TE, Kind<F, R, O, E, A>>) => Kind<F, R, O, E, Kind<T, TR, TO, TE, A>>

----------------------------------------

TITLE: Creating TTL-based KeyedPool in TypeScript
DESCRIPTION: Creates a new keyed pool with configurable minimum/maximum sizes and TTL for resource management. The pool is scoped and automatically releases resources when shutdown. Allows per-key configuration of pool sizes.

LANGUAGE: typescript
CODE:
declare const makeWithTTL: <K, A, E, R>(options: { readonly acquire: (key: K) => Effect.Effect<A, E, R>; readonly min: (key: K) => number; readonly max: (key: K) => number; readonly timeToLive: Duration.DurationInput; }) => Effect.Effect<KeyedPool<K, A, E>, never, Scope.Scope | R>

----------------------------------------

TITLE: Defining flipWith Function in TypeScript for STM Module
DESCRIPTION: Declares the flipWith function, which takes a function f that transforms an STM instance and returns a new function that applies f after swapping error and value parameters. It supports both curried and uncurried forms.

LANGUAGE: typescript
CODE:
declare const flipWith: { <E, A, R, E2, A2, R2>(f: (stm: STM<E, A, R>) => STM<E2, A2, R2>): (self: STM<A, E, R>) => STM<A | A2, E | E2, R | R2>; <A, E, R, E2, A2, R2>(self: STM<A, E, R>, f: (stm: STM<E, A, R>) => STM<E2, A2, R2>): STM<A | A2, E | E2, R | R2>; }

----------------------------------------

TITLE: Appending Elements to MutableList in TypeScript
DESCRIPTION: The append function adds a specified element to the end of a MutableList. It can be used in two ways: as a curried function or with both arguments provided at once. The function returns the modified MutableList.

LANGUAGE: typescript
CODE:
declare const append: { <A>(value: A): (self: MutableList<A>) => MutableList<A>; <A>(self: MutableList<A>, value: A): MutableList<A>; }

----------------------------------------

TITLE: TypeScript Signature of Struct.pick Function
DESCRIPTION: Provides the TypeScript type signature for the Struct.pick function, showing its polymorphic nature and type constraints.

LANGUAGE: typescript
CODE:
declare const pick: { <Keys extends Array<PropertyKey>>(...keys: Keys): <S extends { [K in Keys[number]]?: any; }>(s: S) => MatchRecord<S, { [K in Keys[number]]?: S[K]; }, Simplify<Pick<S, Keys[number]>>>; <S extends object, Keys extends Array<keyof S>>(s: S, ...keys: Keys): MatchRecord<S, { [K in Keys[number]]?: S[K]; }, Simplify<Pick<S, Keys[number]>>>; }

----------------------------------------

TITLE: Creating Stream from TPubSub in TypeScript
DESCRIPTION: Function that creates a Stream from a TPubSub subscription. Takes a TPubSub instance as input and returns a Stream of the same type.

LANGUAGE: typescript
CODE:
declare const fromTPubSub: <A>(pubsub: TPubSub<A>) => Stream<A>

----------------------------------------

TITLE: Declaring sizedWith Function in TypeScript for Effect Package
DESCRIPTION: Defines the sizedWith function that takes a function parameter using the Sized service and returns an Effect. It's used to run specified workflows with the Sized service in a test environment.

LANGUAGE: typescript
CODE:
declare const sizedWith: <A, E, R>(f: (sized: Sized.TestSized) => Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>

----------------------------------------

TITLE: Defining RunnerServer Layer in TypeScript
DESCRIPTION: Declares a constant 'layer' of type Layer.Layer that represents the RunnerServer. This layer handles message reception from other Runners, forwards them to the Sharding layer, and responds to Ping requests. It has no requirements and provides MessageStorage.MessageStorage, Sharding.Sharding, and RpcServer.Protocol.

LANGUAGE: typescript
CODE:
declare const layer: Layer.Layer<never, never, MessageStorage.MessageStorage | Sharding.Sharding | RpcServer.Protocol>

----------------------------------------

TITLE: Defining Permissions Layer for Navigator Permissions API in TypeScript
DESCRIPTION: This code snippet defines a constant 'layer' of type Layer.Layer<Permissions, never, never> that directly interfaces with the navigator.permissions API. It's part of the Permissions module in the @effect/platform-browser package.

LANGUAGE: typescript
CODE:
declare const layer: Layer.Layer<Permissions, never, never>

----------------------------------------

TITLE: Creating Deferred from FiberId in TypeScript
DESCRIPTION: The unsafeMake function unsafely creates a new Deferred from the specified FiberId. It takes a FiberId as input and returns a Deferred<A, E> where A is the type of the resolved value and E is the type of the error (defaulting to never).

LANGUAGE: typescript
CODE:
declare const unsafeMake: <A, E = never>(fiberId: FiberId.FiberId) => Deferred<A, E>

----------------------------------------

TITLE: Implementing Scoped Annotations Service in TypeScript with Effect
DESCRIPTION: The withAnnotationsScoped function sets the implementation of the annotations service to a specified value and restores it to its original value when the scope is closed. It returns an Effect that requires a Scope and never produces an error.

LANGUAGE: typescript
CODE:
declare const withAnnotationsScoped: (annotations: Annotations.TestAnnotations) => Effect.Effect<void, never, Scope.Scope>

----------------------------------------

TITLE: Implementing MergeStrategy Match Function in TypeScript
DESCRIPTION: A type definition for a function that folds a MergeStrategy into a value of type A. The function accepts options for handling backpressure and buffer sliding scenarios, supporting both curried and uncurried calling styles.

LANGUAGE: typescript
CODE:
declare const match: { 
  <A>(options: { readonly onBackPressure: () => A; readonly onBufferSliding: () => A; }): (self: MergeStrategy) => A; 
  <A>(self: MergeStrategy, options: { readonly onBackPressure: () => A; readonly onBufferSliding: () => A; }): A; 
}

----------------------------------------

TITLE: Implementing Stream Error Fallback with orElse in TypeScript
DESCRIPTION: Type signature for the orElse function that switches to an alternative stream when the current stream fails with a typed error. The function accepts a lazy argument that produces a fallback stream and returns a combined stream that can emit values from either the original or fallback stream.

LANGUAGE: typescript
CODE:
declare const orElse: { 
  <A2, E2, R2>(that: LazyArg<Stream<A2, E2, R2>>): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, E2, R2 | R>; 
  <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, that: LazyArg<Stream<A2, E2, R2>>): Stream<A | A2, E2, R | R2>; 
}

----------------------------------------

TITLE: Using isUnknown Predicate in TypeScript
DESCRIPTION: Demonstrates the usage of the isUnknown predicate function from the effect/Predicate module. This function always returns true, acting as a guard that succeeds for any input.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { isUnknown } from "effect/Predicate"

assert.deepStrictEqual(isUnknown(null), true)
assert.deepStrictEqual(isUnknown(undefined), true)

assert.deepStrictEqual(isUnknown({}), true)
assert.deepStrictEqual(isUnknown([]), true)

----------------------------------------

TITLE: Doc.hsep Function Signature in TypeScript
DESCRIPTION: This code snippet shows the TypeScript signature of the hsep function. It takes an Iterable of Doc<A> and returns a Doc<A>.

LANGUAGE: typescript
CODE:
declare const hsep: <A>(docs: Iterable<Doc<A>>) => Doc<A>

----------------------------------------

TITLE: Implementing Request.succeed in TypeScript - Effect Package
DESCRIPTION: Defines a function for completing a Request with a successful value. The function supports both curried and uncurried calling styles, returning an Effect that resolves to void.

LANGUAGE: typescript
CODE:
declare const succeed: {
  <A extends Request<any, any>>(value: Request.Success<A>): (self: A) => Effect.Effect<void>;
  <A extends Request<any, any>>(self: A, value: Request.Success<A>): Effect.Effect<void>;
}

----------------------------------------

TITLE: Declaring DateFromNumber Class in TypeScript
DESCRIPTION: Defines a schema that converts a number into a Date object using the new Date constructor. It does not validate the input, allowing potentially invalid values. During encoding, invalid Date objects are encoded to NaN.

LANGUAGE: typescript
CODE:
declare class DateFromNumber

----------------------------------------

TITLE: Defining File Argument with Content Reading in TypeScript
DESCRIPTION: The `fileText` function creates a file argument that reads its contents. It optionally accepts a configuration object and returns an `Args` type with a tuple containing the file path and content.

LANGUAGE: typescript
CODE:
declare const fileText: (config?: Args.BaseArgsConfig | undefined) => Args<readonly [path: string, content: string]>

----------------------------------------

TITLE: Implementing maxOption Function in Effect-TS TArray Module
DESCRIPTION: Function signature for atomically computing the greatest element in a TArray. It accepts an Order parameter for comparison and returns an STM transaction that resolves to an Option containing the maximum element if it exists.

LANGUAGE: typescript
CODE:
declare const maxOption: { <A>(order: Order.Order<A>): (self: TArray<A>) => STM.STM<Option.Option<A>>; <A>(self: TArray<A>, order: Order.Order<A>): STM.STM<Option.Option<A>>; }

----------------------------------------

TITLE: Checking Predicate for Every HashSet Element with Predicate in TypeScript
DESCRIPTION: Shows how to use the 'every' function with a Predicate to check if all numbers in a HashSet are non-negative. It demonstrates data-last (pipeable), piped, and data-first API styles.

LANGUAGE: typescript
CODE:
import { HashSet, pipe } from "effect"

const set = HashSet.make(1, 2, 3)

// with `data-last`, a.k.a. `pipeable` API
pipe(
  set,
  HashSet.every((n) => n >= 0)
) // true

// or piped with the pipe function
set.pipe(HashSet.every((n) => n >= 0)) // true

// or with `data-first` API
HashSet.every(set, (n) => n >= 0) // true

----------------------------------------

TITLE: Stream.throttle Type Signature in TypeScript
DESCRIPTION: Type definition for the Stream.throttle function showing its parameters and return types. Includes options for cost function, units, duration, burst, and strategy settings.

LANGUAGE: typescript
CODE:
declare const throttle: { <A>(options: { readonly cost: (chunk: Chunk.Chunk<A>) => number; readonly units: number; readonly duration: Duration.DurationInput; readonly burst?: number | undefined; readonly strategy?: "enforce" | "shape" | undefined; }): <E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R>(self: Stream<A, E, R>, options: { readonly cost: (chunk: Chunk.Chunk<A>) => number; readonly units: number; readonly duration: Duration.DurationInput; readonly burst?: number | undefined; readonly strategy?: "enforce" | "shape" | undefined; }): Stream<A, E, R>; }

----------------------------------------

TITLE: Deduplicating Array Elements in TypeScript
DESCRIPTION: The dedupe function removes duplicate elements from a Chunk (array-like structure), keeping only the first occurrence of each element. It takes a Chunk<A> as input and returns a new Chunk<A> with duplicates removed.

LANGUAGE: typescript
CODE:
declare const dedupe: <A>(self: Chunk<A>) => Chunk<A>

----------------------------------------

TITLE: Defining syncContext Function in TypeScript for Layer Construction
DESCRIPTION: Declares the syncContext function, which lazily constructs a layer from a specified value. The function takes an evaluate parameter of type LazyArg<Context.Context<A>> and returns a Layer<A>. This is used for creating layers that return one or more services.

LANGUAGE: typescript
CODE:
declare const syncContext: <A>(evaluate: LazyArg<Context.Context<A>>) => Layer<A>

----------------------------------------

TITLE: Defining RuntimeFlagsPatch.either Function in TypeScript
DESCRIPTION: Defines the 'either' function for RuntimeFlagsPatch. It creates a new patch that applies either the 'self' patch or 'that' patch. The function has two overloads: one that takes 'that' and returns a function, and another that takes both 'self' and 'that' directly.

LANGUAGE: typescript
CODE:
declare const either: { (that: RuntimeFlagsPatch): (self: RuntimeFlagsPatch) => RuntimeFlagsPatch; (self: RuntimeFlagsPatch, that: RuntimeFlagsPatch): RuntimeFlagsPatch; }

----------------------------------------

TITLE: Transforming Schedule Input Type in TypeScript
DESCRIPTION: The `mapInput` function modifies a schedule by applying a transformation function to its inputs. It allows adapting a schedule that expects one input type to work with a different input type. The function can be used in two ways: by providing the mapping function first, or by providing the schedule first.

LANGUAGE: typescript
CODE:
declare const mapInput: { <In, In2>(f: (in2: In2) => In): <Out, R>(self: Schedule<Out, In, R>) => Schedule<Out, In2, R>; <Out, In, R, In2>(self: Schedule<Out, In, R>, f: (in2: In2) => In): Schedule<Out, In2, R>; }

----------------------------------------

TITLE: Rendering RuntimeFlags to String in TypeScript
DESCRIPTION: The render function converts a RuntimeFlags object into its string representation. It takes a RuntimeFlags object as input and returns a string. This function is useful for debugging or displaying the current state of RuntimeFlags.

LANGUAGE: typescript
CODE:
declare const render: (self: RuntimeFlags) => string

----------------------------------------

TITLE: Type Signature for PlatformLogger.toFile in TypeScript
DESCRIPTION: Provides the type signature for the PlatformLogger.toFile function. It shows the function's parameters, return type, and overloads, indicating its flexibility in usage.

LANGUAGE: typescript
CODE:
declare const toFile: { (path: string, options?: (OpenFileOptions & { readonly batchWindow?: DurationInput | undefined; }) | undefined): <Message>(self: Logger.Logger<Message, string>) => Effect<Logger.Logger<Message, void>, PlatformError, Scope | FileSystem>; <Message>(self: Logger.Logger<Message, string>, path: string, options?: (OpenFileOptions & { readonly batchWindow?: DurationInput | undefined; }) | undefined): Effect<Logger.Logger<Message, void>, PlatformError, Scope | FileSystem>; }

----------------------------------------

TITLE: Implementing Stream Composition with crossRight in TypeScript
DESCRIPTION: The crossRight function composes two streams to create a cartesian product of elements, retaining only elements from the right stream. It allows the left stream to be run multiple times for each element in the right stream. This is a more specialized variant compared to the more common zipRight function.

LANGUAGE: typescript
CODE:
declare const crossRight: { <AR, ER, RR>(right: Stream<AR, ER, RR>): <AL, EL, RL>(left: Stream<AL, EL, RL>) => Stream<AR, EL | ER, RL | RR>; <AL, EL, RL, AR, ER, RR>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>): Stream<AR, EL | ER, RL | RR>; }

----------------------------------------

TITLE: Implementing Primitive Wizard Function in TypeScript
DESCRIPTION: Defines a wizard function that creates interactive prompts based on primitive types. The function takes a HelpDoc parameter and returns a Prompt for the specified primitive type. It supports both curried and uncurried calling styles.

LANGUAGE: typescript
CODE:
declare const wizard: { 
  (help: HelpDoc): <A>(self: Primitive<A>) => Prompt<A>; 
  <A>(self: Primitive<A>, help: HelpDoc): Prompt<A>; 
}

----------------------------------------

TITLE: Using MonoidMultiply in TypeScript
DESCRIPTION: Demonstrates how to use the MonoidMultiply constant from the @effect/typeclass package. It shows combining numbers using multiplication and the effect of combining with the empty value.

LANGUAGE: typescript
CODE:
import { MonoidMultiply } from "@effect/typeclass/data/Number"

console.log(MonoidMultiply.combine(2, 3))
// 6
console.log(MonoidMultiply.combine(2, MonoidMultiply.empty))
// 2

----------------------------------------

TITLE: Checking Composite FiberId in TypeScript
DESCRIPTION: The isComposite function is used to determine if a given FiberId is of type Composite. It returns true if the FiberId is a Composite, and false otherwise. This function is part of the FiberId module in the effect package.

LANGUAGE: typescript
CODE:
declare const isComposite: (self: FiberId) => self is Composite

----------------------------------------

TITLE: Dequeuing Elements from MutableQueue in TypeScript
DESCRIPTION: Function signature for pollUpTo operation that removes and returns up to n elements from a MutableQueue as a Chunk. Supports both curried and uncurried calling styles.

LANGUAGE: typescript
CODE:
declare const pollUpTo: { (n: number): <A>(self: MutableQueue<A>) => Chunk.Chunk<A>; <A>(self: MutableQueue<A>, n: number): Chunk.Chunk<A>; }

----------------------------------------

TITLE: Defining conditional STM operation with whenSTM in TypeScript
DESCRIPTION: The `whenSTM` function is the STM equivalent of an `if` statement where the condition has side effects. It takes a predicate STM operation and returns a function that conditionally executes another STM operation, wrapping the result in an Option.

LANGUAGE: TypeScript
CODE:
declare const whenSTM: { <E2, R2>(predicate: STM<boolean, E2, R2>): <A, E, R>(self: STM<A, E, R>) => STM<Option.Option<A>, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: STM<A, E, R>, predicate: STM<boolean, E2, R2>): STM<Option.Option<A>, E | E2, R | R2>; }

----------------------------------------

TITLE: Implementing Error Cause Handling in TypeScript Streams
DESCRIPTION: Function signature for tapErrorCause, which allows inspecting the cause of stream failures through an effect. It takes a function that processes the error cause and returns a new stream that maintains the original data flow while allowing side effects on errors.

LANGUAGE: typescript
CODE:
declare const tapErrorCause: {
  <E, X, E2, R2>(f: (cause: Cause.Cause<NoInfer<E>>) => Effect.Effect<X, E2, R2>): <A, R>(self: Stream<A, E, R>) => Stream<A, E | E2, R2 | R>;
  <A, E, R, X, E2, R2>(self: Stream<A, E, R>, f: (cause: Cause.Cause<E>) => Effect.Effect<X, E2, R2>): Stream<A, E | E2, R | R2>;
}

----------------------------------------

TITLE: Executing Single Result SQL Query with Schema Validation in TypeScript
DESCRIPTION: Function that executes a SQL query with schema validation for both request and result. It takes a request schema, result schema, and execution function as configuration, then returns a function that processes a single request and returns the first result. Throws NoSuchElementException if no results are found and ParseError if schema validation fails.

LANGUAGE: typescript
CODE:
declare const single: <IR, II, IA, AR, AI, A, R, E>(
  options: {
    readonly Request: Schema.Schema<IA, II, IR>;
    readonly Result: Schema.Schema<A, AI, AR>;
    readonly execute: (request: II) => Effect.Effect<ReadonlyArray<unknown>, E, R>;
  }
) => (request: IA) => Effect.Effect<A, E | ParseError | Cause.NoSuchElementException, R | IR | AR>

----------------------------------------

TITLE: Defining NeverFlat Interface in TypeScript
DESCRIPTION: Defines a TypeScript interface NeverFlat that extends Flatten.Variance and represents a FlattenResult indicating the input cannot be flattened. The interface includes a discriminator tag and preserves generic type parameter.

LANGUAGE: typescript
CODE:
export interface NeverFlat<A> extends Flatten.Variance<A> {
  readonly _tag: "NeverFlat"
}

----------------------------------------

TITLE: Implementing Sink.die Function in TypeScript
DESCRIPTION: Defines a function that creates a sink which halts with a specified defect. The sink never produces a value and can accept any type of defect.

LANGUAGE: typescript
CODE:
declare const die: (defect: unknown) => Sink<never, unknown>

----------------------------------------

TITLE: Defining filterOrElse Function in TypeScript for Effect Module
DESCRIPTION: Declares the filterOrElse function, which filters an effect and provides an alternative effect if the predicate fails. It includes multiple overloads to handle different use cases with refinements and predicates.

LANGUAGE: typescript
CODE:
declare const filterOrElse: { <A, B extends A, C, E2, R2>(refinement: Refinement<NoInfer<A>, B>, orElse: (a: NoInfer<A>) => Effect<C, E2, R2>): <E, R>(self: Effect<A, E, R>) => Effect<B | C, E2 | E, R2 | R>; <A, B, E2, R2>(predicate: Predicate<NoInfer<A>>, orElse: (a: NoInfer<A>) => Effect<B, E2, R2>): <E, R>(self: Effect<A, E, R>) => Effect<A | B, E2 | E, R2 | R>; <A, E, R, B extends A, C, E2, R2>(self: Effect<A, E, R>, refinement: Refinement<A, B>, orElse: (a: A) => Effect<C, E2, R2>): Effect<B | C, E | E2, R | R2>; <A, E, R, B, E2, R2>(self: Effect<A, E, R>, predicate: Predicate<A>, orElse: (a: A) => Effect<B, E2, R2>): Effect<A | B, E | E2, R | R2>; }

----------------------------------------

TITLE: Creating a Halting Sink with Message in TypeScript
DESCRIPTION: The dieMessage function creates a sink that halts execution with a specified message. The message is wrapped in a RuntimeException. This function is part of the Sink module in the Effect package.

LANGUAGE: typescript
CODE:
declare const dieMessage: (message: string) => Sink<never, unknown>

----------------------------------------

TITLE: Defining Layer Function Signature in TypeScript
DESCRIPTION: Declares the signature of the layer function, which allows sharing a Layer between multiple tests. It can optionally wrap tests in a describe block if a name is provided.

LANGUAGE: typescript
CODE:
declare const layer: <R, E>(layer_: Layer.Layer<R, E>, options?: { readonly memoMap?: Layer.MemoMap; readonly timeout?: Duration.DurationInput; }) => { (f: (it: Vitest.MethodsNonLive<R>) => void): void; (name: string, f: (it: Vitest.MethodsNonLive<R>) => void): void; }

----------------------------------------

TITLE: Declaring awaitAll Function in TypeScript for Fiber Completion
DESCRIPTION: Defines the awaitAll function that awaits the completion of all provided fibers, whether successful or not. It returns an Effect containing the Exit statuses of all fibers.

LANGUAGE: typescript
CODE:
declare const awaitAll: <const T extends Iterable<Fiber<any, any>>>(fibers: T) => Effect.Effect<[T] extends [ReadonlyArray<infer U>] ? number extends T["length"] ? Array<U extends Fiber<infer A, infer E> ? Exit.Exit<A, E> : never> : { -readonly [K in keyof T]: T[K] extends Fiber<infer A, infer E> ? Exit.Exit<A, E> : never; } : Array<T extends Iterable<infer U> ? U extends Fiber<infer A, infer E> ? Exit.Exit<A, E> : never : never>>

----------------------------------------

TITLE: Creating HttpApi Instance in TypeScript
DESCRIPTION: The HttpApi.make function creates an HttpApi instance with a specified identifier. It represents a collection of HttpApiEndpoints that can be implemented later using HttpApiBuilder.make.

LANGUAGE: typescript
CODE:
declare const make: <const Id extends string>(identifier: Id) => HttpApi<Id, never, HttpApiDecodeError>

----------------------------------------

TITLE: Defining Type Matcher for Non-null Values in TypeScript
DESCRIPTION: Defines a type guard function that matches any defined value (non-null and non-undefined). The function takes a generic type parameter A and returns a type predicate indicating whether the value is defined.

LANGUAGE: typescript
CODE:
declare const defined: <A>(u: A) => u is A & {}

----------------------------------------

TITLE: Checking Interruptible Status in RuntimeFlags - TypeScript
DESCRIPTION: Function that determines if a fiber is interruptible by checking if interruption is enabled and wind-down is disabled. Used to verify if a fiber can be interrupted during its normal execution phase.

LANGUAGE: typescript
CODE:
declare const interruptible: (self: RuntimeFlags) => boolean

----------------------------------------

TITLE: Defining EmptyStream Interface in TypeScript
DESCRIPTION: Defines a TypeScript interface for EmptyStream that extends DocStream.Variance<A> and includes a discriminant tag property. This interface represents an empty Doc in the printer system.

LANGUAGE: typescript
CODE:
export interface EmptyStream<A> extends DocStream.Variance<A> {
  readonly _tag: "EmptyStream"
}

----------------------------------------

TITLE: Checking ParallelN Type in ExecutionStrategy - TypeScript
DESCRIPTION: Type definition for a function that checks if an ExecutionStrategy instance is specifically of type ParallelN. Returns a boolean type predicate that narrows the type when true.

LANGUAGE: typescript
CODE:
declare const isParallelN: (self: ExecutionStrategy) => self is ParallelN

----------------------------------------

TITLE: Implementing stripMargin Function in TypeScript
DESCRIPTION: Defines a function that removes leading whitespace and '|' character from each line of a string. This is useful for formatting multi-line strings with consistent margins.

LANGUAGE: typescript
CODE:
declare const stripMargin: (self: string) => string

----------------------------------------

TITLE: Defining Stream.catchTag Function in TypeScript
DESCRIPTION: Declares a function that handles specific error types in streams. It switches to an alternative stream if the current one fails with a matching error tag. The function is overloaded to support both curried and non-curried usage.

LANGUAGE: typescript
CODE:
declare const catchTag: { <K extends E["_tag"] & string, E extends { _tag: string; }, A1, E1, R1>(k: K, f: (e: Extract<E, { _tag: K; }>) => Stream<A1, E1, R1>): <A, R>(self: Stream<A, E, R>) => Stream<A1 | A, E1 | Exclude<E, { _tag: K; }>, R1 | R>; <A, E extends { _tag: string; }, R, K extends E["_tag"] & string, A1, E1, R1>(self: Stream<A, E, R>, k: K, f: (e: Extract<E, { _tag: K; }>) => Stream<A1, E1, R1>): Stream<A | A1, E1 | Exclude<E, { _tag: K; }>, R | R1>; }

----------------------------------------

TITLE: Executing Command with String Output in TypeScript
DESCRIPTION: Function signature for running commands and returning their output as a string with optional encoding. Default encoding is utf-8. Returns an Effect that may result in a PlatformError and requires a CommandExecutor.

LANGUAGE: typescript
CODE:
declare const string: { 
  (encoding?: string): (command: Command) => Effect<string, PlatformError, CommandExecutor>; 
  (command: Command, encoding?: string): Effect<string, PlatformError, CommandExecutor>; 
}

----------------------------------------

TITLE: Declaring ConfigProvider.upperCase Function in TypeScript
DESCRIPTION: TypeScript function declaration for upperCase that takes a ConfigProvider and returns a new ConfigProvider with property names converted to uppercase. This allows adapting camelCase property names to uppercase naming conventions.

LANGUAGE: typescript
CODE:
declare const upperCase: (self: ConfigProvider) => ConfigProvider

----------------------------------------

TITLE: Removing Multiple Keys from Trie in TypeScript
DESCRIPTION: Demonstrates how to remove multiple entries from a Trie data structure using the removeMany function. The example shows creating a Trie with multiple string keys and number values, then removing specific keys using removeMany.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Trie, Equal } from "effect"

const trie = Trie.empty<number>().pipe(
  Trie.insert("shells", 0),
  Trie.insert("sells", 1),
  Trie.insert("she", 2)
)

assert.equal(
  Equal.equals(trie.pipe(Trie.removeMany(["she", "sells"])), Trie.empty<number>().pipe(Trie.insert("shells", 0))),
  true
)

LANGUAGE: typescript
CODE:
declare const removeMany: { (keys: Iterable<string>): <V>(self: Trie<V>) => Trie<V>; <V>(self: Trie<V>, keys: Iterable<string>): Trie<V>; }

----------------------------------------

TITLE: Combining Fibers with Fiber.all in TypeScript
DESCRIPTION: The 'all' function collects multiple fibers into a single fiber, producing an in-order list of their results. It takes an iterable of fibers as input and returns a new fiber that resolves to an array of the results.

LANGUAGE: typescript
CODE:
declare const all: <A, E>(fibers: Iterable<Fiber<A, E>>) => Fiber<ReadonlyArray<A>, E>

----------------------------------------

TITLE: Layout.smart Function Type Definition
DESCRIPTION: Type signature for the Layout.smart function, which takes layout options and a document as parameters and returns a document stream.

LANGUAGE: typescript
CODE:
declare const smart: { (options: Layout.Options): <A>(self: Doc<A>) => DocStream<A>; <A>(self: Doc<A>, options: Layout.Options): DocStream<A>; }

----------------------------------------

TITLE: Converting Either to Exit in TypeScript Effect Module
DESCRIPTION: Utility function that converts an Either<R, L> type into an Exit<R, L> type. This function enables transformation between these two type constructs in the Effect ecosystem.

LANGUAGE: typescript
CODE:
declare const fromEither: <R, L>(either: Either.Either<R, L>) => Exit<R, L>

----------------------------------------

TITLE: Defining Custom Prompt Function in TypeScript
DESCRIPTION: Declares the custom function for creating a Prompt with initial state and handlers. The function supports both pure values and Effects for initial state, and uses handlers to control rendering, input processing, and clearing of the Terminal.

LANGUAGE: typescript
CODE:
declare const custom: <State, Output>(initialState: State | Effect<State, never, Prompt.Environment>, handlers: Prompt.Handlers<State, Output>) => Prompt<Output>

----------------------------------------

TITLE: Declaring Uninterruptible Effect Function in TypeScript
DESCRIPTION: Function signature for marking a Micro effect as uninterruptible. When an effect is marked as uninterruptible, it will continue executing until completion even if an interruption is requested.

LANGUAGE: typescript
CODE:
declare const uninterruptible: <A, E, R>(self: Micro<A, E, R>) => Micro<A, E, R>

----------------------------------------

TITLE: Declaring jittered function in TypeScript for Effect package Schedule module
DESCRIPTION: Defines the jittered function that takes a Schedule object and returns a new Schedule with randomized interval adjustments. The function modifies the delay between executions to be between 80% and 120% of the original interval.

LANGUAGE: typescript
CODE:
declare const jittered: <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>

----------------------------------------

TITLE: Defining Take.tap Function in TypeScript
DESCRIPTION: Defines the tap function which returns an effect that effectfully "peeks" at the success of a take. It accepts a function that processes a chunk of data and returns an Effect, and can be applied to a Take instance.

LANGUAGE: typescript
CODE:
declare const tap: {
  <A, X, E2, R>(f: (chunk: Chunk.Chunk<A>) => Effect.Effect<X, E2, R>): <E>(self: Take<A, E>) => Effect.Effect<void, E2 | E, R>;
  <A, E, X, E2, R>(self: Take<A, E>, f: (chunk: Chunk.Chunk<A>) => Effect.Effect<X, E2, R>): Effect.Effect<void, E | E2, R>;
}

----------------------------------------

TITLE: Providing Context to RequestResolver in TypeScript
DESCRIPTION: The provideContext function is used to provide a RequestResolver with its required context. It has two overloads: one for curried usage and another for direct application. This function allows for flexible context provision in effect-based request resolution.

LANGUAGE: typescript
CODE:
declare const provideContext: { <R>(context: Context.Context<R>): <A extends Request.Request<any, any>>(self: RequestResolver<A, R>) => RequestResolver<A>; <R, A extends Request.Request<any, any>>(self: RequestResolver<A, R>, context: Context.Context<R>): RequestResolver<A>; }

----------------------------------------

TITLE: Checking Iterable Emptiness with isEmpty in TypeScript
DESCRIPTION: The isEmpty function determines if an Iterable is empty. It takes an Iterable as input and returns a boolean indicating whether the Iterable is empty or not. The function also uses a type predicate to narrow the type to Iterable<never> when it returns true.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { isEmpty } from "effect/Iterable"

assert.deepStrictEqual(isEmpty([]), true);
assert.deepStrictEqual(isEmpty([1, 2, 3]), false);

LANGUAGE: typescript
CODE:
declare const isEmpty: <A>(self: Iterable<A>) => self is Iterable<never>

----------------------------------------

TITLE: Declaring Stream.crossWith Function in TypeScript
DESCRIPTION: Defines the signature of the crossWith function, which composes two streams to create a cartesian product of elements using a specified function. The right stream is run multiple times for every element in the left stream.

LANGUAGE: typescript
CODE:
declare const crossWith: { <AR, ER, RR, AL, A>(right: Stream<AR, ER, RR>, f: (left: AL, right: AR) => A): <EL, RL>(left: Stream<AL, EL, RL>) => Stream<A, EL | ER, RL | RR>; <AL, EL, RL, AR, ER, RR, A>(left: Stream<AL, EL, RL>, right: Stream<AR, ER, RR>, f: (left: AL, right: AR) => A): Stream<A, EL | ER, RL | RR>; }

----------------------------------------

TITLE: Defining Schema.finite Function in TypeScript
DESCRIPTION: This code snippet shows the TypeScript signature for the Schema.finite function. It takes optional annotations and returns a function that filters a schema to ensure the value is a finite number.

LANGUAGE: typescript
CODE:
declare const finite: <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>

----------------------------------------

TITLE: Defining String Monoid in TypeScript for @effect/typeclass
DESCRIPTION: Implements a Monoid instance for strings with concatenation as the operation and an empty string as the identity element. This is part of the @effect/typeclass package's String module.

LANGUAGE: typescript
CODE:
declare const Monoid: monoid.Monoid<string>

----------------------------------------

TITLE: Declaring eraseUp Function in AnsiDoc Module (TypeScript)
DESCRIPTION: Declares the eraseUp constant of type AnsiDoc. This function clears the screen from the current cursor position to the beginning, without changing the cursor position.

LANGUAGE: typescript
CODE:
declare const eraseUp: AnsiDoc

----------------------------------------

TITLE: Creating Empty MutableList in TypeScript - Effect Package
DESCRIPTION: Function signature for creating an empty MutableList container that can hold elements of type A. This is a generic function that returns a new empty MutableList instance.

LANGUAGE: typescript
CODE:
declare const empty: <A>() => MutableList<A>

----------------------------------------

TITLE: Defining Cache Lookup Type in TypeScript
DESCRIPTION: Defines a generic Lookup type that represents a function taking a key and returning an Effect containing a value or error. The type supports parameterization for key type, value type, error type, and environment type.

LANGUAGE: typescript
CODE:
type Lookup<Key, Value, Error, Environment> = (
  key: Key
) => Effect.Effect<Value, Error, Environment>

----------------------------------------

TITLE: Creating Unbounded MutableQueue in TypeScript
DESCRIPTION: Function signature for creating a new unbounded MutableQueue that can hold elements of type A. The unbounded queue has no size limit and can grow dynamically as elements are added.

LANGUAGE: typescript
CODE:
declare const unbounded: <A>() => MutableQueue<A>

----------------------------------------

TITLE: Predicate Tuple Function Signature
DESCRIPTION: Detailed type declaration for the tuple function that handles both Predicates and Refinements, providing type-safe tuple transformations.

LANGUAGE: typescript
CODE:
declare const tuple: <T extends ReadonlyArray<Predicate.Any>>(...elements: T) => [Extract<T[number], Refinement.Any>] extends [never] ? Predicate<{ readonly [I in keyof T]: Predicate.In<T[I]>; }> : Refinement<{ readonly [I in keyof T]: T[I] extends Refinement.Any ? Refinement.In<T[I]> : Predicate.In<T[I]>; }, { readonly [I in keyof T]: T[I] extends Refinement.Any ? Refinement.Out<T[I]> : Predicate.In<T[I]>; }>

----------------------------------------

TITLE: Defining forEach Function for List Module in TypeScript
DESCRIPTION: Declares the forEach function that applies a specified function to each element of a List. It supports both curried and uncurried versions of the function.

LANGUAGE: typescript
CODE:
declare const forEach: { <A, B>(f: (a: A) => B): (self: List<A>) => void; <A, B>(self: List<A>, f: (a: A) => B): void; }

----------------------------------------

TITLE: Implementing Conditional Map Entry Setting in TypeScript
DESCRIPTION: Function signature for setIfAbsent operation that atomically adds a new key-value pair to a TMap only if the key doesn't already exist. Supports both curried and direct invocation patterns.

LANGUAGE: typescript
CODE:
declare const setIfAbsent: { <K, V>(key: K, value: V): (self: TMap<K, V>) => STM.STM<void>; <K, V>(self: TMap<K, V>, key: K, value: V): STM.STM<void>; }

----------------------------------------

TITLE: Configuring Max Operations Before Yield in Effect Schedulers - TypeScript
DESCRIPTION: Function signature for withMaxOpsBeforeYield, which sets the maximum number of operations that can be executed before the default schedulers yield control. Takes a priority number parameter and returns a function that transforms an Effect instance.

LANGUAGE: typescript
CODE:
declare const withMaxOpsBeforeYield: { 
  (priority: number): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; 
  <A, E, R>(self: Effect<A, E, R>, priority: number): Effect<A, E, R>; 
}

----------------------------------------

TITLE: Initializing ParcelWatcher Layer in TypeScript
DESCRIPTION: Defines a Layer type that implements the WatchBackend interface using @parcel/watcher as the underlying file watching system. The Layer has no requirements (never) and produces no errors (never).

LANGUAGE: typescript
CODE:
declare const layer: Layer<WatchBackend, never, never>

----------------------------------------

TITLE: Defining MicroExit Type in TypeScript
DESCRIPTION: Defines a union type MicroExit that represents either a successful computation with value A or a failed computation with error E wrapped in MicroCause. This type is fundamental for handling computation results in the Effect-TS ecosystem.

LANGUAGE: typescript
CODE:
type MicroExit<A, E> = | MicroExit.Success<A, E>
  | MicroExit.Failure<A, E>

----------------------------------------

TITLE: Using Doc.line for Line Breaks in TypeScript
DESCRIPTION: This example demonstrates how to use Doc.line to create line breaks in a document. It shows the behavior of line breaks both with and without grouping.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import * as String from "effect/String"

const doc: Doc.Doc<never> = Doc.hcat([
  Doc.text("lorem ipsum"),
  Doc.line,
  Doc.text("dolor sit amet")
])

assert.strictEqual(
  Doc.render(doc, { style: "pretty" }),
  String.stripMargin(
    `|lorem ipsum
     |dolor sit amet`
  )
)
assert.strictEqual(
  Doc.render(Doc.group(doc), { style: "pretty" }),
  "lorem ipsum dolor sit amet"
)

----------------------------------------

TITLE: Type Signature for Logger.withLeveledConsole in TypeScript
DESCRIPTION: Provides the TypeScript type signature for the Logger.withLeveledConsole function. It takes a Logger<M, O> and returns a Logger<M, void>.

LANGUAGE: typescript
CODE:
declare const withLeveledConsole: <M, O>(self: Logger<M, O>) => Logger<M, void>

----------------------------------------

TITLE: Declaring productMany Function for Combining Options in TypeScript
DESCRIPTION: This function combines a primary Option with a collection of Options into a single Option containing a tuple of their values if all are Some. It takes a primary Option and an Iterable of Options, returning an Option of a tuple.

LANGUAGE: typescript
CODE:
declare const productMany: <A>(self: Option<A>, collection: Iterable<Option<A>>) => Option<[A, ...Array<A>]>

----------------------------------------

TITLE: Implementing Schedule Control with Effectful Predicates in TypeScript
DESCRIPTION: Defines an overloaded function that creates a new schedule that stops execution when a given effectful predicate returns true for the output value. The function can be called with either the schedule first and predicate second, or predicate first and schedule second.

LANGUAGE: typescript
CODE:
declare const untilOutputEffect: {
  <Out, R2>(f: (out: Out) => Effect.Effect<boolean, never, R2>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>;
  <Out, In, R, R2>(self: Schedule<Out, In, R>, f: (out: Out) => Effect.Effect<boolean, never, R2>): Schedule<Out, In, R | R2>;
}

----------------------------------------

TITLE: Stream runFoldWhileEffect Implementation in TypeScript
DESCRIPTION: Executes an effectful fold over a stream of values with early termination capability. The operation continues folding as long as the continuation predicate returns true, accumulating results through an effect-producing function.

LANGUAGE: typescript
CODE:
declare const runFoldWhileEffect: {
  <S, A, E2, R2>(s: S, cont: Predicate<S>, f: (s: S, a: A) => Effect.Effect<S, E2, R2>):
    <E, R>(self: Stream<A, E, R>) => Effect.Effect<S, E2 | E, Exclude<R | R2, Scope.Scope>>;
  <A, E, R, S, E2, R2>(self: Stream<A, E, R>, s: S, cont: Predicate<S>, f: (s: S, a: A) => Effect.Effect<S, E2, R2>):
    Effect.Effect<S, E | E2, Exclude<R | R2, Scope.Scope>>;
}

----------------------------------------

TITLE: Multiplying BigInts using Effect Library in TypeScript
DESCRIPTION: The multiplyAll function takes an Iterable of bigints and returns their multiplication as a single bigint. It demonstrates how to use the function with an array of bigints.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { multiplyAll } from "effect/BigInt"

assert.deepStrictEqual(multiplyAll([2n, 3n, 4n]), 24n)

----------------------------------------

TITLE: Defining Micro.map Function in TypeScript
DESCRIPTION: Declares the map function for the Micro effect. It transforms the success value of a Micro effect using a provided function. The function can be used in two ways: by passing the function first, or by passing the Micro effect first followed by the transformation function.

LANGUAGE: typescript
CODE:
declare const map: { <A, B>(f: (a: A) => B): <E, R>(self: Micro<A, E, R>) => Micro<B, E, R>; <A, E, R, B>(self: Micro<A, E, R>, f: (a: A) => B): Micro<B, E, R>; }

----------------------------------------

TITLE: Generating Next Pseudo-Random Number in TypeScript using Effect
DESCRIPTION: The next function returns an Effect that produces the next numeric value from a pseudo-random number generator. It has no input parameters and never produces an error.

LANGUAGE: typescript
CODE:
declare const next: Effect.Effect<number, never, never>

----------------------------------------

TITLE: Implementing Schedule Repetition Counter in TypeScript
DESCRIPTION: Function signature for creating a new schedule that counts and outputs the number of times the original schedule has executed. The counter starts at 0 and increments with each execution.

LANGUAGE: typescript
CODE:
declare const repetitions: <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<number, In, R>

----------------------------------------

TITLE: Defining CloseableScopeTypeId Type in TypeScript
DESCRIPTION: Defines the CloseableScopeTypeId type as the type of the unique identifier for CloseableScope. This type is used for type-level operations and identification within the Scope module.

LANGUAGE: typescript
CODE:
type CloseableScopeTypeId = typeof CloseableScopeTypeId

----------------------------------------

TITLE: Implementing Pick Operation in SchemaAST Module
DESCRIPTION: Definition of the pick function that takes an AST object and an array of property keys, returning either a TypeLiteral or Transformation. This function provides runtime functionality equivalent to TypeScript's Pick utility type.

LANGUAGE: typescript
CODE:
declare const pick: (ast: AST, keys: ReadonlyArray<PropertyKey>) => TypeLiteral | Transformation

----------------------------------------

TITLE: Defining orElseSucceed Function for Stream in TypeScript
DESCRIPTION: Defines the orElseSucceed function for the Stream module. This function succeeds with a specified value if the original stream fails with a typed error. It takes a lazy argument for the fallback value and returns a new stream that never fails.

LANGUAGE: typescript
CODE:
declare const orElseSucceed: { <A2>(value: LazyArg<A2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A2 | A, never, R>; <A, E, R, A2>(self: Stream<A, E, R>, value: LazyArg<A2>): Stream<A | A2, never, R>; }

----------------------------------------

TITLE: Defining typeSchema Function in TypeScript for Schema Module
DESCRIPTION: The typeSchema function extracts the Type portion of a schema, creating a new schema that conforms to the properties of the original schema without considering initial encoding or transformation processes. It takes a Schema<A, I, R> as input and returns a SchemaClass<A>.

LANGUAGE: typescript
CODE:
declare const typeSchema: <A, I, R>(schema: Schema<A, I, R>) => SchemaClass<A>

----------------------------------------

TITLE: Declaring Doc.space constant in TypeScript
DESCRIPTION: This snippet defines the Doc.space constant, which represents a document containing a single space character. It is of type Doc<never>, indicating it does not produce any effects.

LANGUAGE: typescript
CODE:
declare const space: Doc<never>

----------------------------------------

TITLE: Combining Brand Validators in TypeScript using Effect Library
DESCRIPTION: Demonstrates how to combine multiple brand validators (Int and Positive) to create a composite validator for positive integers. Shows example usage and error handling with the Brand.all method.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Brand } from "effect"

type Int = number & Brand.Brand<"Int">
const Int = Brand.refined<Int>(
  (n) => Number.isInteger(n),
  (n) => Brand.error(`Expected ${n} to be an integer`)
)
type Positive = number & Brand.Brand<"Positive">
const Positive = Brand.refined<Positive>(
  (n) => n > 0,
  (n) => Brand.error(`Expected ${n} to be positive`)
)

const PositiveInt = Brand.all(Int, Positive)

console.log(PositiveInt(1))
// 1

assert.throws(() => PositiveInt(1.1))

----------------------------------------

TITLE: Defining scheduleIntersect Function in TypeScript
DESCRIPTION: This snippet defines the scheduleIntersect function, which combines two MicroSchedule objects. It recurs only if both schedules want to recur, using the maximum duration between recurrences.

LANGUAGE: typescript
CODE:
declare const scheduleIntersect: { (that: MicroSchedule): (self: MicroSchedule) => MicroSchedule; (self: MicroSchedule, that: MicroSchedule): MicroSchedule; }

----------------------------------------

TITLE: Declaring reject Function for STM in TypeScript
DESCRIPTION: Defines the reject function for STM (Software Transactional Memory) operations. It takes a partial function and returns a new STM that fails with the returned value if the partial function matches, otherwise continues with the original value.

LANGUAGE: typescript
CODE:
declare const reject: { <A, E2>(pf: (a: A) => Option.Option<E2>): <E, R>(self: STM<A, E, R>) => STM<A, E2 | E, R>; <A, E, R, E2>(self: STM<A, E, R>, pf: (a: A) => Option.Option<E2>): STM<A, E | E2, R>; }

----------------------------------------

TITLE: Declaring Micro.filter Function in TypeScript
DESCRIPTION: Defines the filter function for effectfully filtering elements of an iterable. It takes an iterable, a filtering function, and optional configuration for concurrency and negation. The function returns a Micro effect that produces an array of filtered elements.

LANGUAGE: typescript
CODE:
declare const filter: <A, E, R>(iterable: Iterable<A>, f: (a: NoInfer<A>) => Micro<boolean, E, R>, options?: { readonly concurrency?: Concurrency | undefined; readonly negate?: boolean | undefined; }) => Micro<Array<A>, E, R>

----------------------------------------

TITLE: Implementing findFirstIndex Function in TypeScript for Chunk Module
DESCRIPTION: Defines a function that returns the first index in a Chunk for which a predicate holds. It can be called with either the predicate first and Chunk second, or vice versa.

LANGUAGE: typescript
CODE:
declare const findFirstIndex: { <A>(predicate: Predicate<A>): (self: Chunk<A>) => Option<number>; <A>(self: Chunk<A>, predicate: Predicate<A>): Option<number>; }

----------------------------------------

TITLE: Effect.timeoutOption Function Signature in TypeScript
DESCRIPTION: Defines the TypeScript signature for the Effect.timeoutOption function. It shows the function's overloads and type parameters, illustrating how it can be used with different argument orders.

LANGUAGE: typescript
CODE:
declare const timeoutOption: { (duration: Duration.DurationInput): <A, E, R>(self: Effect<A, E, R>) => Effect<Option.Option<A>, E, R>; <A, E, R>(self: Effect<A, E, R>, duration: Duration.DurationInput): Effect<Option.Option<A>, E, R>; }

----------------------------------------

TITLE: Defining ExceededCapacityException Interface in TypeScript
DESCRIPTION: This code snippet defines the ExceededCapacityException interface, which extends YieldableError. It includes a readonly _tag property and a symbol-keyed property for type identification.

LANGUAGE: typescript
CODE:
export interface ExceededCapacityException extends YieldableError {
  readonly _tag: "ExceededCapacityException"
  readonly [ExceededCapacityExceptionTypeId]: ExceededCapacityExceptionTypeId
}

----------------------------------------

TITLE: Declaring Schema.ULID Class in TypeScript
DESCRIPTION: Defines the Schema.ULID class for representing and validating Universally Unique Lexicographically Sortable Identifiers (ULIDs). ULIDs are compact, URL-safe, and ordered identifiers suitable for various use cases.

LANGUAGE: typescript
CODE:
declare class ULID

----------------------------------------

TITLE: Declaring timedWith Function in TypeScript
DESCRIPTION: Defines the timedWith function signature for executing an effect and measuring its execution time using a custom clock. The function accepts an effect that represents the clock and returns the current time in nanoseconds.

LANGUAGE: typescript
CODE:
declare const timedWith: { <E1, R1>(nanoseconds: Effect<bigint, E1, R1>): <A, E, R>(self: Effect<A, E, R>) => Effect<[Duration.Duration, A], E1 | E, R1 | R>; <A, E, R, E1, R1>(self: Effect<A, E, R>, nanoseconds: Effect<bigint, E1, R1>): Effect<[Duration.Duration, A], E | E1, R | R1>; }

----------------------------------------

TITLE: Clamping Values with Order.clamp in TypeScript
DESCRIPTION: Demonstrates how to use the Order.clamp function to restrict a value within a specified range. It takes an Order instance and returns a function that clamps values between a minimum and maximum.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Order, Number } from "effect"

const clamp = Order.clamp(Number.Order)({ minimum: 1, maximum: 5 })

assert.equal(clamp(3), 3)
assert.equal(clamp(0), 1)
assert.equal(clamp(6), 5)

----------------------------------------

TITLE: Type Guard Function for Exit Failure State in TypeScript
DESCRIPTION: A type guard function that checks if an Exit instance represents a Failure state. Returns true if the Exit is a Failure, false otherwise. This function helps with type narrowing in TypeScript.

LANGUAGE: typescript
CODE:
declare const isFailure: <A, E>(self: Exit<A, E>) => self is Failure<A, E>

----------------------------------------

TITLE: Implementing Cause.andThen Function in TypeScript
DESCRIPTION: Function signature for sequencing two Causes where the second Cause can depend on the result of the first. Supports both dependent and independent sequencing through function overloads.

LANGUAGE: typescript
CODE:
declare const andThen: { 
  <E, E2>(f: (e: E) => Cause<E2>): (self: Cause<E>) => Cause<E2>; 
  <E2>(f: Cause<E2>): <E>(self: Cause<E>) => Cause<E2>; 
  <E, E2>(self: Cause<E>, f: (e: E) => Cause<E2>): Cause<E2>; 
  <E, E2>(self: Cause<E>, f: Cause<E2>): Cause<E2>; 
}

----------------------------------------

TITLE: Micro RunFork Function Signature
DESCRIPTION: Type definition for the runFork function that executes Micro effects. Takes a Micro effect and optional configuration including abort signal and scheduler, returns a MicroFiberImpl instance.

LANGUAGE: typescript
CODE:
declare const runFork: <A, E>(effect: Micro<A, E>, options?: { readonly signal?: AbortSignal | undefined; readonly scheduler?: MicroScheduler | undefined; } | undefined) => MicroFiberImpl<A, E>

----------------------------------------

TITLE: Implementing ANSI Terminal Beep in TypeScript
DESCRIPTION: Defines a constant that triggers the terminal bell sound. The beep functionality is implemented as an AnsiDoc type that produces an audible beep when executed in a terminal environment.

LANGUAGE: typescript
CODE:
declare const beep: AnsiDoc

----------------------------------------

TITLE: Effect.raceAll Type Definition
DESCRIPTION: TypeScript type definition for the raceAll function showing its signature and type parameters.

LANGUAGE: typescript
CODE:
declare const raceAll: <Eff extends Effect<any, any, any>>(all: Iterable<Eff>) => Effect<Effect.Success<Eff>, Effect.Error<Eff>, Effect.Context<Eff>>

----------------------------------------

TITLE: Declaring reduceRight Function in TypeScript for List Module
DESCRIPTION: Defines the reduceRight function which folds over the elements of a list using a specified function, starting from the last element. It accepts an initial value and a folding function, and can be used in both curried and uncurried forms.

LANGUAGE: typescript
CODE:
declare const reduceRight: { <Z, A>(zero: Z, f: (accumulator: Z, value: A) => Z): (self: List<A>) => Z; <Z, A>(self: List<A>, zero: Z, f: (accumulator: Z, value: A) => Z): Z; }

----------------------------------------

TITLE: Using lineBreak in Effect Printer TypeScript
DESCRIPTION: Demonstrates how to use the lineBreak document operation with hcat to create formatted text. Shows the difference between normal rendering and group rendering where lineBreak behaves like empty.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import * as String from "effect/String"

const doc: Doc.Doc<never> = Doc.hcat([
  Doc.text("lorem ipsum"),
  Doc.lineBreak,
  Doc.text("dolor sit amet")
])

assert.strictEqual(
  Doc.render(doc, { style: "pretty" }),
  String.stripMargin(
    `|lorem ipsum
     |dolor sit amet`
  )
)
assert.strictEqual(
  Doc.render(Doc.group(doc), { style: "pretty" }),
  "lorem ipsumdolor sit amet"
)

LANGUAGE: typescript
CODE:
declare const lineBreak: Doc<never>

----------------------------------------

TITLE: Creating Fixed Offset TimeZone in TypeScript using Effect
DESCRIPTION: The zoneMakeOffset function creates a fixed offset time zone. It takes a number parameter representing the offset and returns a TimeZone.Offset object. This function is part of the DateTime module in the Effect package.

LANGUAGE: typescript
CODE:
declare const zoneMakeOffset: (offset: number) => TimeZone.Offset

----------------------------------------

TITLE: Defining Doc.rbracket Constant in TypeScript
DESCRIPTION: Declares a constant named rbracket of type Doc<never>, representing a document containing a single ']' character. This is part of the @effect/printer package's Doc module.

LANGUAGE: typescript
CODE:
declare const rbracket: Doc<never>

----------------------------------------

TITLE: Creating Deferred with FiberId in TypeScript
DESCRIPTION: Function that creates a new Deferred instance from a specified FiberId. The Deferred can hold a value of type A with an optional error type E.

LANGUAGE: typescript
CODE:
declare const makeAs: <A, E = never>(fiberId: FiberId.FiberId) => Effect.Effect<Deferred<A, E>>

----------------------------------------

TITLE: Constructing Exit.Failure in TypeScript
DESCRIPTION: Function signature for creating an Exit.Failure instance from an unrecoverable defect. Takes an unknown defect parameter and returns an Exit type that can never succeed.

LANGUAGE: typescript
CODE:
declare const die: (defect: unknown) => Exit<never>

----------------------------------------

TITLE: Trie.insertMany Function Signature (TypeScript)
DESCRIPTION: Provides the TypeScript signature for the insertMany function in the Trie module. It shows two overloads for different use cases.

LANGUAGE: typescript
CODE:
declare const insertMany: { <V1>(iter: Iterable<[string, V1]>): <V>(self: Trie<V>) => Trie<V | V1>; <V1, V>(self: Trie<V>, iter: Iterable<[string, V1]>): Trie<V | V1>; }

----------------------------------------

TITLE: Stream.toPull Type Signature
DESCRIPTION: Type signature for the Stream.toPull function showing its input and output types. Takes a Stream of type A, E, R and returns an Effect that produces another Effect yielding chunks of type A.

LANGUAGE: typescript
CODE:
declare const toPull: <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<Effect.Effect<Chunk.Chunk<A>, Option.Option<E>, R>, never, Scope.Scope | R>

----------------------------------------

TITLE: Declaring secondOfMinute Function in TypeScript
DESCRIPTION: This snippet defines the signature of the secondOfMinute function. It takes a number parameter representing the second and returns a Schedule of numbers. The function creates a cron-like schedule that recurs at the specified second of each minute, starting at zero nanoseconds.

LANGUAGE: typescript
CODE:
declare const secondOfMinute: (second: number) => Schedule<number>

----------------------------------------

TITLE: Checking TPubSub Fullness in TypeScript
DESCRIPTION: The isFull function is a method of the TPubSub class that determines whether the TPubSub instance contains at least one element. It returns an STM (Software Transactional Memory) effect that resolves to a boolean value. True indicates the presence of at least one element, while false indicates an empty TPubSub.

LANGUAGE: typescript
CODE:
declare const isFull: <A>(self: TPubSub<A>) => STM.STM<boolean>

----------------------------------------

TITLE: Iterating Over Trie Entries with forEach in TypeScript
DESCRIPTION: Demonstrates how to use forEach to iterate over entries in a Trie data structure. The example shows inserting multiple string keys with numeric values and performing an accumulation operation on the entries.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Trie } from "effect"

let value = 0

Trie.empty<number>().pipe(
  Trie.insert("shells", 0),
  Trie.insert("sells", 1),
  Trie.insert("she", 2),
  Trie.forEach((n, key) => {
    value += n + key.length
  })
)

assert.equal(value, 17)

LANGUAGE: typescript
CODE:
declare const forEach: { <V>(f: (value: V, key: string) => void): (self: Trie<V>) => void; <V>(self: Trie<V>, f: (value: V, key: string) => void): void; }

----------------------------------------

TITLE: Declaring Empty Interval Constant in TypeScript
DESCRIPTION: Defines a constant representing an Interval with zero width. This is used as a base case or special value in Effect's scheduling system.

LANGUAGE: typescript
CODE:
declare const empty: Interval

----------------------------------------

TITLE: Defining Layer.tap Function in TypeScript
DESCRIPTION: Defines the tap function for the Layer module. This function performs a specified effect if the layer succeeds. It takes a function that receives a context and returns an Effect, and applies it to a Layer.

LANGUAGE: typescript
CODE:
declare const tap: { <ROut, XR extends ROut, RIn2, E2, X>(f: (context: Context.Context<XR>) => Effect.Effect<X, E2, RIn2>): <RIn, E>(self: Layer<ROut, E, RIn>) => Layer<ROut, E2 | E, RIn2 | RIn>; <RIn, E, ROut, XR extends ROut, RIn2, E2, X>(self: Layer<ROut, E, RIn>, f: (context: Context.Context<XR>) => Effect.Effect<X, E2, RIn2>): Layer<ROut, E | E2, RIn | RIn2>; }

----------------------------------------

TITLE: Creating Weighted Folding Sink in TypeScript
DESCRIPTION: This function creates a sink that folds elements of type In into a structure of type S, with a maximum cost limit. It uses a cost function to determine the weight of each element and stops folding when the max cost is reached.

LANGUAGE: typescript
CODE:
declare const foldWeighted: <S, In>(options: { readonly initial: S; readonly maxCost: number; readonly cost: (s: S, input: In) => number; readonly body: (s: S, input: In) => S; }) => Sink<S, In, In>

----------------------------------------

TITLE: Defining Parallel Execution Strategy Interface in TypeScript
DESCRIPTION: Defines the Parallel interface for the ExecutionStrategy module. This interface represents a strategy for executing effects in parallel, identified by the _tag property set to "Parallel".

LANGUAGE: typescript
CODE:
export interface Parallel {
  readonly _tag: "Parallel"
}

----------------------------------------

TITLE: Implementing Queue Element Extraction in TypeScript using TQueue.takeN
DESCRIPTION: Function signature for taking N elements from a transactional queue. The function supports both curried and non-curried versions, allowing for flexible usage patterns. It will retry until the requested number of elements becomes available in the queue.

LANGUAGE: typescript
CODE:
declare const takeN: { (n: number): <A>(self: TDequeue<A>) => STM.STM<Array<A>>; <A>(self: TDequeue<A>, n: number): STM.STM<Array<A>>; }

----------------------------------------

TITLE: Defining Stream.repeatElementsWith Function in TypeScript
DESCRIPTION: Declares the repeatElementsWith function for repeating stream elements with a schedule. It accepts a schedule and options for converting element and schedule outputs to a unified type. The function can be applied to a stream to create a new stream with repeated elements.

LANGUAGE: typescript
CODE:
declare const repeatElementsWith: { <B, R2, A, C>(schedule: Schedule.Schedule<B, unknown, R2>, options: { readonly onElement: (a: A) => C; readonly onSchedule: (b: B) => C; }): <E, R>(self: Stream<A, E, R>) => Stream<C, E, R2 | R>; <A, E, R, B, R2, C>(self: Stream<A, E, R>, schedule: Schedule.Schedule<B, unknown, R2>, options: { readonly onElement: (a: A) => C; readonly onSchedule: (b: B) => C; }): Stream<C, E, R | R2>; }

----------------------------------------

TITLE: Implementing Delay Function for Micro Effects in TypeScript
DESCRIPTION: This code snippet defines the delay function for Micro effects. It takes a duration in milliseconds and returns a new effect that delays the execution of the original effect by the specified duration. The function has two overloads to support different calling patterns.

LANGUAGE: typescript
CODE:
declare const delay: { (millis: number): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E, R>; <A, E, R>(self: Micro<A, E, R>, millis: number): Micro<A, E, R>; }

----------------------------------------

TITLE: Implementing Document Square Bracket Wrapping in TypeScript
DESCRIPTION: A TypeScript function that takes a document of type Doc<A> and returns a new document wrapped in square brackets. This utility helps format documents with consistent bracket notation.

LANGUAGE: typescript
CODE:
declare const squareBracketed: <A>(self: Doc<A>) => Doc<A>

----------------------------------------

TITLE: Defining Micro.sync Function in TypeScript
DESCRIPTION: Declares the sync function that creates a Micro effect succeeding with a lazily evaluated value. If evaluation throws an error, the effect fails with a Die variant of MicroCause.

LANGUAGE: typescript
CODE:
declare const sync: <A>(evaluate: LazyArg<A>) => Micro<A>

----------------------------------------

TITLE: Wrapping Array into Chunk without Copying in TypeScript
DESCRIPTION: The unsafeFromArray function takes a readonly array of type A and returns a Chunk of type A. It wraps the array into a chunk without copying, which makes it unsafe for use with mutable arrays. This function has been available since version 2.0.0 of the package.

LANGUAGE: typescript
CODE:
declare const unsafeFromArray: <A>(self: ReadonlyArray<A>) => Chunk<A>

----------------------------------------

TITLE: ManagedRuntime.make Function Signature
DESCRIPTION: Type signature for the ManagedRuntime.make function, showing its parameters and return type. Takes a Layer and optional memoMap parameter to create a ManagedRuntime instance.

LANGUAGE: typescript
CODE:
declare const make: <R, E>(layer: Layer.Layer<R, E, never>, memoMap?: Layer.MemoMap | undefined) => ManagedRuntime<R, E>

----------------------------------------

TITLE: Converting Optional to Required Schema Properties in TypeScript
DESCRIPTION: Defines a utility function that transforms optional schema properties into required ones by handling Option types. The function takes a source schema, target schema, and transformation functions for both decode and encode operations. The decode function handles missing values (none) from input, while encode function determines if values should be omitted from output.

LANGUAGE: typescript
CODE:
declare const optionalToRequired: <FA, FI, FR, TA, TI, TR>(
  from: Schema<FA, FI, FR>,
  to: Schema<TA, TI, TR>,
  options: {
    readonly decode: (o: option_.Option<FA>) => TI;
    readonly encode: (ti: TI) => option_.Option<FA>;
  }
) => PropertySignature<":", TA, never, "?:", FI, false, FR | TR>

----------------------------------------

TITLE: Defining RunnerNotRegistered Error Class in TypeScript
DESCRIPTION: Declares the RunnerNotRegistered class, which represents an error that occurs when a Runner is not registered with the shard manager. This class is part of the ClusterError module in the @effect/cluster package.

LANGUAGE: typescript
CODE:
declare class RunnerNotRegistered

----------------------------------------

TITLE: Defining Schema.lowercased Type in TypeScript
DESCRIPTION: Type signature for the lowercased function that verifies if a string is in lowercase. The function takes optional annotations and returns a filter that can be applied to string schemas.

LANGUAGE: typescript
CODE:
declare const lowercased: <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>

----------------------------------------

TITLE: Encoding Text Stream to Uint8Array Stream in TypeScript
DESCRIPTION: The encodeText function takes a Stream of strings and converts it into a Stream of Uint8Array chunks using a specified encoding. It operates on a Stream<string, E, R> and produces a Stream<Uint8Array, E, R>.

LANGUAGE: typescript
CODE:
declare const encodeText: <E, R>(self: Stream<string, E, R>) => Stream<Uint8Array, E, R>

----------------------------------------

TITLE: Using Schema.StringFromUriComponent for URL-safe Data Encoding in TypeScript
DESCRIPTION: This example demonstrates how to use Schema.StringFromUriComponent in combination with other schemas to encode structured data into a URL-safe string. It creates a PaginationSchema and composes it with StringFromUriComponent and parseJson to create a URL-safe encoding of pagination data.

LANGUAGE: typescript
CODE:
import { Schema } from "effect"

const PaginationSchema = Schema.Struct({
  maxItemPerPage: Schema.Number,
  page: Schema.Number
})

const UrlSchema = Schema.compose(Schema.StringFromUriComponent, Schema.parseJson(PaginationSchema))

console.log(Schema.encodeSync(UrlSchema)({ maxItemPerPage: 10, page: 1 }))
// Output: %7B%22maxItemPerPage%22%3A10%2C%22page%22%3A1%7D

----------------------------------------

TITLE: Implementing LogFmt Logger in Effect TypeScript
DESCRIPTION: Demonstrates how to use the logFmt logger to output human-readable logs with annotations and timing spans. The logger includes timestamps, log levels, fiber IDs, messages, and custom key-value pairs.

LANGUAGE: typescript
CODE:
import { Effect, Logger } from "effect"

const program = Effect.log("message1", "message2").pipe(
  Effect.annotateLogs({ key1: "value1", key2: "value2" }),
  Effect.withLogSpan("myspan")
)

Effect.runFork(program.pipe(Effect.provide(Logger.logFmt)))
// timestamp=... level=INFO fiber=#0 message=message1 message=message2 myspan=0ms key2=value2 key1=value1

LANGUAGE: typescript
CODE:
declare const logFmt: Layer.Layer<never, never, never>

----------------------------------------

TITLE: Multiplying Numbers using Effect/Number Module in TypeScript
DESCRIPTION: Demonstrates the usage of the multiply function from Effect's Number module. The function supports both curried and uncurried forms for multiplying two numbers together.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { multiply } from "effect/Number"

assert.deepStrictEqual(multiply(2, 3), 6)

LANGUAGE: typescript
CODE:
declare const multiply: { (that: number): (self: number) => number; (self: number, that: number): number; }

----------------------------------------

TITLE: Checking Boolean Flags in Options - TypeScript
DESCRIPTION: Function that determines whether an Options instance represents a boolean flag. Takes an Options<A> parameter and returns a boolean indicating if the option is a boolean flag.

LANGUAGE: typescript
CODE:
declare const isBool: <A>(self: Options<A>) => boolean

----------------------------------------

TITLE: Retrieving Fiber ID in STM Transaction - TypeScript
DESCRIPTION: Function signature for retrieving the fiber ID of the fiber that is committing the current STM transaction. Returns a FiberId value wrapped in an STM effect with no requirements or error types.

LANGUAGE: typescript
CODE:
declare const fiberId: STM<FiberId.FiberId, never, never>

----------------------------------------

TITLE: Implementing Selective Error Catching in Effect-TS Micro
DESCRIPTION: Function signature for catchCauseIf that allows selective catching of MicroCause errors based on a predicate. It provides overloaded implementations for both refinement-based and predicate-based error catching, supporting type-safe error handling in Effect-TS Micro workflows.

LANGUAGE: typescript
CODE:
declare const catchCauseIf: { <E, B, E2, R2, EB extends MicroCause<E>>(refinement: Refinement<MicroCause<E>, EB>, f: (cause: EB) => Micro<B, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A | B, Exclude<E, MicroCause.Error<EB>> | E2, R | R2>; <E, B, E2, R2>(predicate: Predicate<MicroCause<NoInfer<E>>>, f: (cause: NoInfer<MicroCause<E>>) => Micro<B, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A | B, E | E2, R | R2>; <A, E, R, B, E2, R2, EB extends MicroCause<E>>(self: Micro<A, E, R>, refinement: Refinement<MicroCause<E>, EB>, f: (cause: EB) => Micro<B, E2, R2>): Micro<A | B, Exclude<E, MicroCause.Error<EB>> | E2, R | R2>; <A, E, R, B, E2, R2>(self: Micro<A, E, R>, predicate: Predicate<MicroCause<NoInfer<E>>>, f: (cause: NoInfer<MicroCause<E>>) => Micro<B, E2, R2>): Micro<A | B, E | E2, R | R2>; }

----------------------------------------

TITLE: Implementing lessThan Filter in TypeScript with Effect-TS Schema
DESCRIPTION: A type definition for a filter that validates whether a number is less than a specified maximum value. The filter takes a maximum value and optional annotations, returning a function that can be applied to schemas containing number types.

LANGUAGE: typescript
CODE:
declare const lessThan: <S extends Schema.Any>(exclusiveMaximum: number, annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>

----------------------------------------

TITLE: Creating Failing Sink in TypeScript with Effect
DESCRIPTION: Defines a function that creates a sink which always fails with a provided error value. The sink never processes any input and always results in the specified error type E.

LANGUAGE: typescript
CODE:
declare const fail: <E>(e: E) => Sink<never, unknown, never, E>

----------------------------------------

TITLE: Defining Channel.doneCollect Function in TypeScript
DESCRIPTION: Declares the doneCollect function for Channel, which returns a new channel that collects all outputs and bundles them with the terminal value. It warns about potential memory issues for channels with large or unbounded outputs.

LANGUAGE: typescript
CODE:
declare const doneCollect: <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<never, InElem, OutErr, InErr, [Chunk.Chunk<OutElem>, OutDone], InDone, Env>

----------------------------------------

TITLE: Refreshing Resource Cache in TypeScript using Effect
DESCRIPTION: The refresh function is used to refresh the cache of a Resource. It returns an Effect that completes when the refresh operation is either successful or fails. This function takes a Resource<A, E> as input and returns an Effect<void, E>.

LANGUAGE: typescript
CODE:
declare const refresh: <A, E>(self: Resource<A, E>) => Effect.Effect<void, E>

----------------------------------------

TITLE: Declaring provideContext Function for Sink in TypeScript
DESCRIPTION: Defines the provideContext function for the Sink module. This function provides the sink with its required context, eliminating its dependency on R. It has two overloads: one for providing context to a sink, and another for currying the operation.

LANGUAGE: typescript
CODE:
declare const provideContext: { <R>(context: Context.Context<R>): <A, In, L, E>(self: Sink<A, In, L, E, R>) => Sink<A, In, L, E, never>; <A, In, L, E, R>(self: Sink<A, In, L, E, R>, context: Context.Context<R>): Sink<A, In, L, E, never>; }

----------------------------------------

TITLE: Declaring Live TRandom Layer in TypeScript
DESCRIPTION: Defines a constant 'live' that represents the TRandom service wrapped in a Layer. This Layer has no requirements and no errors.

LANGUAGE: typescript
CODE:
declare const live: Layer.Layer<TRandom, never, never>

----------------------------------------

TITLE: Defining Sequential Interface for Cause in TypeScript
DESCRIPTION: Defines the Sequential interface for the Cause module, representing the sequential composition of two Causes. It includes properties for left and right Causes, and extends various utility interfaces.

LANGUAGE: typescript
CODE:
export interface Sequential<out E> extends Cause.Variance<E>, Equal.Equal, Pipeable, Inspectable {
  readonly _tag: "Sequential"
  readonly left: Cause<E>
  readonly right: Cause<E>
}

----------------------------------------

TITLE: Declaring Empty Cause in TypeScript
DESCRIPTION: Declares a constant 'empty' of type Cause<never>, representing an absence of failure conditions. This is commonly used to signify 'no error' in the Effect package.

LANGUAGE: typescript
CODE:
declare const empty: Cause<never>

----------------------------------------

TITLE: Effect.tap Function Signature in TypeScript
DESCRIPTION: This code snippet shows the type signature of the Effect.tap function. It demonstrates the function's overloads and type parameters, illustrating its flexibility in handling different input types and configurations.

LANGUAGE: typescript
CODE:
declare const tap: { <A, X>(f: (a: NoInfer<A>) => X): <E, R>(self: Effect<A, E, R>) => [X] extends [Effect<infer _A1, infer E1, infer R1>] ? Effect<A, E | E1, R | R1> : [X] extends [PromiseLike<infer _A1>] ? Effect<A, E | Cause.UnknownException, R> : Effect<A, E, R>; <A, X, E1, R1>(f: (a: NoInfer<A>) => Effect<X, E1, R1>, options: { onlyEffect: true; }): <E, R>(self: Effect<A, E, R>) => Effect<A, E | E1, R | R1>; <X>(f: NotFunction<X>): <A, E, R>(self: Effect<A, E, R>) => [X] extends [Effect<infer _A1, infer E1, infer R1>] ? Effect<A, E | E1, R | R1> : [X] extends [PromiseLike<infer _A1>] ? Effect<A, E | Cause.UnknownException, R> : Effect<A, E, R>; <X, E1, R1>(f: Effect<X, E1, R1>, options: { onlyEffect: true; }): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E | E1, R | R1>; <A, E, R, X>(self: Effect<A, E, R>, f: (a: NoInfer<A>) => X): [X] extends [Effect<infer _A1, infer E1, infer R1>] ? Effect<A, E | E1, R | R1> : [X] extends [PromiseLike<infer _A1>] ? Effect<A, E | Cause.UnknownException, R> : Effect<A, E, R>; <A, E, R, X, E1, R1>(self: Effect<A, E, R>, f: (a: NoInfer<A>) => Effect<X, E1, R1>, options: { onlyEffect: true; }): Effect<A, E | E1, R | R1>; <A, E, R, X>(self: Effect<A, E, R>, f: NotFunction<X>): [X] extends [Effect<infer _A1, infer E1, infer R1>] ? Effect<A, E | E1, R | R1> : [X] extends [PromiseLike<infer _A1>] ? Effect<A, E | Cause.UnknownException, R> : Effect<A, E, R>; <A, E, R, X, E1, R1>(self: Effect<A, E, R>, f: Effect<X, E1, R1>, options: { onlyEffect: true; }): Effect<A, E | E1, R | R1>; }

----------------------------------------

TITLE: Converting HashSet to Array in TypeScript using Effect Library
DESCRIPTION: Demonstrates how to convert a HashSet to an Array using the HashSet.toValues function. The operation has O(n) time complexity where n is the number of elements in the set. Returns a standard JavaScript array containing all unique values from the HashSet.

LANGUAGE: typescript
CODE:
import { HashSet, pipe } from "effect"
import { deepStrictEqual } from "node:assert/strict"

deepStrictEqual(
  pipe(
    HashSet.make(0, 1, 1, 2), // HashSet<number>
    HashSet.toValues // takes an HashSet<A> and returns an Array<A>
  ),
  Array.of(0, 1, 2)
)

LANGUAGE: typescript
CODE:
declare const toValues: <A>(self: HashSet<A>) => Array<A>

----------------------------------------

TITLE: Type Signature of Data.TaggedEnum in TypeScript
DESCRIPTION: Provides the type signature for the Data.TaggedEnum type. It uses conditional types to create a union of tagged structs based on the input type A.

LANGUAGE: typescript
CODE:
type TaggedEnum<A> = keyof A extends infer Tag ?
  Tag extends keyof A ? Types.Simplify<{ readonly _tag: Tag } & { readonly [K in keyof A[Tag]]: A[Tag][K] }>
  : never
  : never

----------------------------------------

TITLE: Using DateTime.getPart in TypeScript
DESCRIPTION: Demonstrates how to use the DateTime.getPart function to extract a specific part (year) from a DateTime object. The example creates a DateTime object for the year 2024 in the Europe/London time zone and extracts the year value.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { DateTime } from "effect"

const now = DateTime.unsafeMakeZoned({ year: 2024 }, { timeZone: "Europe/London" })
const year = DateTime.getPart(now, "year")
assert.strictEqual(year, 2024)

----------------------------------------

TITLE: Lazy Config Construction in Effect-TS
DESCRIPTION: The suspend function enables lazy construction of Config objects by accepting a LazyArg that produces a Config<A>. This allows for deferred evaluation of configuration values and circular dependencies.

LANGUAGE: typescript
CODE:
declare const suspend: <A>(config: LazyArg<Config<A>>) => Config<A>

----------------------------------------

TITLE: Defining mapLeftover Function for Sink Transformation in TypeScript
DESCRIPTION: Declares the mapLeftover function which transforms the leftovers emitted by a sink using a provided function f. It supports two overloads: one for curried usage and another for direct application.

LANGUAGE: typescript
CODE:
declare const mapLeftover: { <L, L2>(f: (leftover: L) => L2): <A, In, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In, L2, E, R>; <A, In, L, E, R, L2>(self: Sink<A, In, L, E, R>, f: (leftover: L) => L2): Sink<A, In, L2, E, R>; }

----------------------------------------

TITLE: Using Doc.nesting for Layout Control in TypeScript
DESCRIPTION: This example demonstrates how to use Doc.nesting to create a document layout that depends on the current nesting level. It shows how the function affects the indentation of nested elements.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import * as String from "effect/String"

const doc = Doc.hsep([
  Doc.text("prefix"),
  Doc.nesting((l) => Doc.squareBracketed(Doc.text(`Nested: ${l}`)))
])

const example = Doc.vsep([0, 4, 8].map((n) => Doc.indent(n)(doc)))

assert.strictEqual(
  Doc.render(example, { style: "pretty" }),
  String.stripMargin(
    `|prefix [Nested: 0]
     |    prefix [Nested: 4]
     |        prefix [Nested: 8]`
  )
)

----------------------------------------

TITLE: Specifying Standard Input for Command in TypeScript
DESCRIPTION: The stdin function is used to specify the standard input stream for a command. It can be called in two ways: either by passing the stdin input followed by the command, or by passing the command followed by the stdin input.

LANGUAGE: typescript
CODE:
declare const stdin: { (stdin: Command.Input): (self: Command) => Command; (self: Command, stdin: Command.Input): Command; }

----------------------------------------

TITLE: Stream.fromChunk Type Signature - TypeScript
DESCRIPTION: Type signature for the Stream.fromChunk function showing it accepts a Chunk of type A and returns a Stream of type A.

LANGUAGE: typescript
CODE:
declare const fromChunk: <A>(chunk: Chunk.Chunk<A>) => Stream<A>

----------------------------------------

TITLE: Zipping Stream Elements with Previous and Next in TypeScript
DESCRIPTION: Demonstrates how to use the zipWithPreviousAndNext function from the Stream module to zip each element with its previous and next elements. The function returns a new stream where each element is a tuple containing the previous, current, and next elements, with None for boundary cases.

LANGUAGE: typescript
CODE:
import { Chunk, Effect, Stream } from "effect"

const stream = Stream.zipWithPreviousAndNext(Stream.make(1, 2, 3, 4))

Effect.runPromise(Stream.runCollect(stream)).then((chunk) => console.log(Chunk.toArray(chunk)))
// [
//   [
//     { _id: 'Option', _tag: 'None' },
//     1,
//     { _id: 'Option', _tag: 'Some', value: 2 }
//   ],
//   [
//     { _id: 'Option', _tag: 'Some', value: 1 },
//     2,
//     { _id: 'Option', _tag: 'Some', value: 3 }
//   ],
//   [
//     { _id: 'Option', _tag: 'Some', value: 2 },
//     3,
//     { _id: 'Option', _tag: 'Some', value: 4 }
//   ],
//   [
//     { _id: 'Option', _tag: 'Some', value: 3 },
//     4,
//     { _id: 'Option', _tag: 'None' }
//   ]
// ]

----------------------------------------

TITLE: Defining Sum Sink in TypeScript for Effect Package
DESCRIPTION: Declares a constant 'sum' as a Sink that takes number inputs and produces a number output. It has no error type, no leftover type, and no environment requirements.

LANGUAGE: typescript
CODE:
declare const sum: Sink<number, number, never, never, never>

----------------------------------------

TITLE: Function Signature for lessThanOrEqualTo in TypeScript
DESCRIPTION: Provides the TypeScript function signature for the lessThanOrEqualTo function. It shows that the function can be called with one or two BigDecimal arguments.

LANGUAGE: typescript
CODE:
declare const lessThanOrEqualTo: { (that: BigDecimal): (self: BigDecimal) => boolean; (self: BigDecimal, that: BigDecimal): boolean; }

----------------------------------------

TITLE: Extracting Values from TArray in TypeScript STM
DESCRIPTION: The 'get' function is used to extract a value from a reference in a TArray within an STM context. It can be called with either the index first or the array first, providing flexibility in usage. The function returns an STM effect that, when executed, will yield the value at the specified index.

LANGUAGE: TypeScript
CODE:
declare const get: { (index: number): <A>(self: TArray<A>) => STM.STM<A>; <A>(self: TArray<A>, index: number): STM.STM<A>; }

----------------------------------------

TITLE: Defining ANSI Line Erase Function in TypeScript
DESCRIPTION: Declares a constant eraseLine of type Ansi that provides functionality to clear the current line in a terminal without changing the cursor position. This is part of the @effect/printer-ansi package's ANSI terminal control features.

LANGUAGE: typescript
CODE:
declare const eraseLine: Ansi

----------------------------------------

TITLE: Implementing STM.orElseFail in TypeScript
DESCRIPTION: Function declaration for orElseFail that takes an error generator and an STM transaction, returning a new STM transaction that fails with the specified error if the original transaction fails or retries.

LANGUAGE: typescript
CODE:
declare const orElseFail: { <E2>(error: LazyArg<E2>): <A, E, R>(self: STM<A, E, R>) => STM<A, E2, R>; <A, E, R, E2>(self: STM<A, E, R>, error: LazyArg<E2>): STM<A, E2, R>; }

----------------------------------------

TITLE: Function.apply Type Signature
DESCRIPTION: TypeScript type declaration for the apply function, showing it takes a value of type A and returns a function that accepts a function from A to B, producing a result of type B.

LANGUAGE: typescript
CODE:
declare const apply: <A>(a: A) => <B>(self: (a: A) => B) => B

----------------------------------------

TITLE: Doc.softLineBreak Function Signature in TypeScript
DESCRIPTION: The type signature of the softLineBreak constant in the Doc module. It is a Doc with a never type parameter, indicating it doesn't produce any specific type.

LANGUAGE: typescript
CODE:
declare const softLineBreak: Doc<never>

----------------------------------------

TITLE: Declaring propertySignature Function in TypeScript
DESCRIPTION: Defines the propertySignature function that lifts a Schema into a PropertySignature. This function is part of the Schema module in the effect package and has been available since version 3.10.0.

LANGUAGE: typescript
CODE:
declare const propertySignature: <S extends Schema.All>(self: S) => propertySignature<S>

----------------------------------------

TITLE: Defining Compact Layout Function Signature in TypeScript
DESCRIPTION: This code snippet defines the type signature for the compact function in the Layout module. It takes a Doc<A> as input and returns a DocStream<A>.

LANGUAGE: typescript
CODE:
declare const compact: <A>(self: Doc<A>) => DocStream<A>

----------------------------------------

TITLE: Defining ChannelException Interface in TypeScript
DESCRIPTION: Defines a generic interface for Channel exceptions with a type parameter E for the error type. The interface includes a discriminator tag, a type ID, and the error value.

LANGUAGE: typescript
CODE:
export interface ChannelException<out E> {
  readonly _tag: "ChannelException"
  readonly [ChannelExceptionTypeId]: ChannelExceptionTypeId
  readonly error: E
}

----------------------------------------

TITLE: Transforming ConfigProvider Properties to Snake Case in TypeScript
DESCRIPTION: A utility function that takes a ConfigProvider instance and returns a new ConfigProvider with all property names converted to snake case format. This helps adapt configuration properties from camel case to snake case naming conventions.

LANGUAGE: typescript
CODE:
declare const snakeCase: (self: ConfigProvider) => ConfigProvider

----------------------------------------

TITLE: Defining Optimize Interface for Document Tree Optimization in TypeScript
DESCRIPTION: Defines the Optimize interface, which takes a depth parameter and returns an optimized Doc<A>. This interface is used for optimizing document trees by fusing redundant nodes.

LANGUAGE: typescript
CODE:
export interface Optimize<A> {
  (depth: Optimize.Depth): Doc<A>
}

----------------------------------------

TITLE: Declaring Stream.provideServiceStream Function in TypeScript
DESCRIPTION: Defines a function to provide a single service to a stream. It handles both single-service provisioning and cases where multiple services are required. The function is overloaded to accommodate different parameter orders.

LANGUAGE: typescript
CODE:
declare const provideServiceStream: { <I, S, E2, R2>(tag: Context.Tag<I, S>, stream: Stream<NoInfer<S>, E2, R2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | Exclude<R, I>>; <A, E, R, I, S, E2, R2>(self: Stream<A, E, R>, tag: Context.Tag<I, S>, stream: Stream<NoInfer<S>, E2, R2>): Stream<A, E2 | E, R2 | Exclude<R, I>>; }

----------------------------------------

TITLE: Retrieving Values from Records using Record.get in TypeScript
DESCRIPTION: Demonstrates how to safely access record values using Record.get, which returns an Option type. The example shows both successful retrieval of an existing key and handling of a missing key.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Record as R, Option } from "effect"

const person: Record<string, unknown> = { name: "John Doe", age: 35 }

assert.deepStrictEqual(R.get(person, "name"), Option.some("John Doe"))
assert.deepStrictEqual(R.get(person, "email"), Option.none())

LANGUAGE: typescript
CODE:
declare const get: { <K extends string | symbol>(key: NoInfer<K>): <A>(self: ReadonlyRecord<K, A>) => Option.Option<A>; <K extends string | symbol, A>(self: ReadonlyRecord<K, A>, key: NoInfer<K>): Option.Option<A>; }

----------------------------------------

TITLE: Defining peekOption Function for TQueue in TypeScript
DESCRIPTION: Declares a function peekOption that views the next element in a TDequeue without removing it. It returns an STM (Software Transactional Memory) operation that results in an Option of the element type. The function returns None if the queue is empty.

LANGUAGE: typescript
CODE:
declare const peekOption: <A>(self: TDequeue<A>) => STM.STM<Option.Option<A>>

----------------------------------------

TITLE: Checking FiberId None Type in TypeScript
DESCRIPTION: A type predicate function that determines if a given FiberId is of type None. Returns true if the FiberId is None, false otherwise. This is a type-safe check that can be used in conditional statements.

LANGUAGE: typescript
CODE:
declare const isNone: (self: FiberId) => self is None

----------------------------------------

TITLE: Splitting Chunks in TypeScript
DESCRIPTION: The split function divides a Chunk into n equally sized chunks. It can be called with the number of chunks as the first argument, or with the Chunk as the first argument and the number of chunks as the second.

LANGUAGE: typescript
CODE:
declare const split: { (n: number): <A>(self: Chunk<A>) => Chunk<Chunk<A>>; <A>(self: Chunk<A>, n: number): Chunk<Chunk<A>>; }

----------------------------------------

TITLE: Checking STM Type in TypeScript
DESCRIPTION: The isSTM function is a type guard that checks if the provided value is an STM instance. It returns true for STM values and false otherwise. This function is useful for type narrowing in TypeScript.

LANGUAGE: typescript
CODE:
declare const isSTM: (u: unknown) => u is STM<unknown, unknown, unknown>

----------------------------------------

TITLE: Defining dieMessage Function for Stream Termination in TypeScript
DESCRIPTION: The dieMessage function creates a Stream that immediately terminates with an exception described by the provided message. It takes a string parameter and returns a Stream that never produces any values.

LANGUAGE: typescript
CODE:
declare const dieMessage: (message: string) => Stream<never>

----------------------------------------

TITLE: Sorting Chunk Elements in TypeScript using effect Package
DESCRIPTION: This function sorts the elements of a Chunk in increasing order, creating a new Chunk. It takes an Order object for comparison and can be used with different element types.

LANGUAGE: typescript
CODE:
declare const sort: { <B>(O: Order.Order<B>): <A extends B>(self: Chunk<A>) => Chunk<A>; <A extends B, B>(self: Chunk<A>, O: Order.Order<B>): Chunk<A>; }

----------------------------------------

TITLE: Defining Intervals Interface in TypeScript
DESCRIPTION: Defines an interface called Intervals that contains a type identifier and a readonly array (Chunk) of Interval objects. The interface is used for representing multiple time intervals in the scheduling system.

LANGUAGE: typescript
CODE:
export interface Intervals {
  readonly [IntervalsTypeId]: IntervalsTypeId
  readonly intervals: Check.Chunk<Interval.Interval>
}

----------------------------------------

TITLE: Implementing Command.feed Method in TypeScript
DESCRIPTION: Implementation of a Command.feed method that provides functionality to feed string input to standard input with UTF-8 encoding. The method supports both curried and uncurried calling styles.

LANGUAGE: typescript
CODE:
declare const feed: { (input: string): (self: Command) => Command; (self: Command, input: string): Command; }

----------------------------------------

TITLE: Defining cursorBackward Function for ANSI Cursor Control in TypeScript
DESCRIPTION: Declares the cursorBackward function which moves the cursor backward by a specified number of columns. It takes an optional number parameter and returns an Ansi type. This function has no effect if the cursor is already at the edge of the screen.

LANGUAGE: typescript
CODE:
declare const cursorBackward: (columns?: number) => Ansi

----------------------------------------

TITLE: Declaring Single Quote Document in TypeScript
DESCRIPTION: This snippet declares a constant 'squote' of type Doc<never>, representing a document containing a single quotation mark character. It is part of the @effect/printer package's Doc module.

LANGUAGE: typescript
CODE:
declare const squote: Doc<never>

----------------------------------------

TITLE: Using repeatN Function in TypeScript with Effect
DESCRIPTION: This snippet demonstrates how to use the repeatN function from the Effect module. It creates an action to log 'success' and repeats it twice using repeatN.

LANGUAGE: typescript
CODE:
import { Effect, Console } from "effect"

const action = Console.log("success")
const program = Effect.repeatN(action, 2)

Effect.runPromise(program)

----------------------------------------

TITLE: Trie.make Function Signature in TypeScript
DESCRIPTION: This snippet shows the TypeScript signature for the Trie.make function. It accepts a variable number of entries, each being a tuple of a string and any value, and returns a Trie with the value type inferred from the entries.

LANGUAGE: typescript
CODE:
declare const make: <Entries extends Array<readonly [string, any]>>(...entries: Entries) => Trie<Entries[number] extends readonly [any, infer V] ? V : never>

----------------------------------------

TITLE: Parsing TimeZone from String in TypeScript
DESCRIPTION: The zoneFromString function attempts to parse a TimeZone from a given string. It returns an Option type, which may contain a TimeZone if parsing is successful. This function is part of the DateTime module in the Effect package.

LANGUAGE: typescript
CODE:
declare const zoneFromString: (zone: string) => Option.Option<TimeZone>

----------------------------------------

TITLE: WithUnhandledErrorLogLevel Function Signature
DESCRIPTION: Type declaration for the withUnhandledErrorLogLevel function, showing its polymorphic nature and support for both curried and uncurried calling styles.

LANGUAGE: typescript
CODE:
declare const withUnhandledErrorLogLevel: { (level: Option.Option<LogLevel.LogLevel>): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, level: Option.Option<LogLevel.LogLevel>): Effect<A, E, R>; }

----------------------------------------

TITLE: Appending Annotations in TestAnnotationMap (TypeScript)
DESCRIPTION: The annotate function is used to append a specified annotation to the annotation map. It can be called in two ways: either by passing the TestAnnotationMap as the first argument, or by using it in a curried form.

LANGUAGE: typescript
CODE:
declare const annotate: (<A>(key: TestAnnotation.TestAnnotation<A>, value: A) => (self: TestAnnotationMap) => TestAnnotationMap) & (<A>(self: TestAnnotationMap, key: TestAnnotation.TestAnnotation<A>, value: A) => TestAnnotationMap)

----------------------------------------

TITLE: Defining instanceOf Function in TypeScript for Effect Package
DESCRIPTION: This snippet defines the instanceOf function in the Match module. It creates a SafeRefinement that matches instances of a given class constructor. The function is generic, allowing it to work with any class type.

LANGUAGE: typescript
CODE:
declare const instanceOf: <A extends abstract new (...args: any) => any>(constructor: A) => SafeRefinement<InstanceType<A>, never>

----------------------------------------

TITLE: Effect.dropUntil Type Definition
DESCRIPTION: Type signature for the dropUntil function showing its polymorphic nature and support for both curried and non-curried forms. The function takes an iterable of elements and a predicate function that returns an Effect.

LANGUAGE: typescript
CODE:
declare const dropUntil: { <A, E, R>(predicate: (a: NoInfer<A>, i: number) => Effect<boolean, E, R>): (elements: Iterable<A>) => Effect<Array<A>, E, R>; <A, E, R>(elements: Iterable<A>, predicate: (a: A, i: number) => Effect<boolean, E, R>): Effect<Array<A>, E, R>; }

----------------------------------------

TITLE: Implementing Stream.runFoldScoped in TypeScript
DESCRIPTION: A function that executes a pure fold over a stream of values, returning a scoped value representing the stream's scope. Takes an initial state and a folding function as parameters, operating within the Effect monad.

LANGUAGE: typescript
CODE:
declare const runFoldScoped: {
  <S, A>(s: S, f: (s: S, a: A) => S): <E, R>(self: Stream<A, E, R>) => Effect.Effect<S, E, Scope.Scope | R>;
  <A, E, R, S>(self: Stream<A, E, R>, s: S, f: (s: S, a: A) => S): Effect.Effect<S, E, Scope.Scope | R>;
}

----------------------------------------

TITLE: Defining Schema.trimmed Type Signature in TypeScript
DESCRIPTION: Type signature for the trimmed function that creates a schema validator ensuring strings have no leading or trailing whitespace. Takes optional annotations and returns a filter function that can be applied to string schemas.

LANGUAGE: typescript
CODE:
declare const trimmed: <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>

----------------------------------------

TITLE: Demonstrating Boolean.some Function in TypeScript
DESCRIPTION: This example shows how to use the 'some' function from the Boolean module to check if any boolean in an array is true. It includes assertions to verify the function's behavior.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { some } from "effect/Boolean"

assert.deepStrictEqual(some([true, false, true]), true)
assert.deepStrictEqual(some([false, false, false]), false)

----------------------------------------

TITLE: Implementing tailNonEmpty Function for NonEmptyChunk in TypeScript
DESCRIPTION: This function returns every element after the first in a NonEmptyChunk. It takes a NonEmptyChunk<A> as input and returns a Chunk<A>. The function is part of the Chunk module in the effect package.

LANGUAGE: typescript
CODE:
declare const tailNonEmpty: <A>(self: NonEmptyChunk<A>) => Chunk<A>

----------------------------------------

TITLE: Computing Write Locks in TReentrantLock (TypeScript)
DESCRIPTION: The writeLocks function computes the number of write locks held by fibers for a given TReentrantLock instance. It returns an STM (Software Transactional Memory) operation that resolves to a number representing the count of write locks.

LANGUAGE: typescript
CODE:
declare const writeLocks: (self: TReentrantLock) => STM.STM<number>

----------------------------------------

TITLE: Declaring FiberSet.awaitEmpty Function in TypeScript
DESCRIPTION: TypeScript function declaration for awaitEmpty that takes a FiberSet as input and returns an Effect that resolves when the fiber set becomes empty. The function is generic over type parameters A (fiber result type) and E (error type).

LANGUAGE: typescript
CODE:
declare const awaitEmpty: <A, E>(self: FiberSet<A, E>) => Effect.Effect<void>

----------------------------------------

TITLE: Flattening Chunks in TypeScript using effect Package
DESCRIPTION: The flatten function concatenates all chunks within a chunk of chunks into a single chunk. It takes a Chunk<Chunk<any>> as input and returns a flattened Chunk. This function is part of the Chunk module in the effect package.

LANGUAGE: typescript
CODE:
declare const flatten: <S extends Chunk<Chunk<any>>>(self: S) => Chunk.Flatten<S>

----------------------------------------

TITLE: FiberMap.runtime Type Signature
DESCRIPTION: Type declaration for the FiberMap.runtime function showing its generic parameters and return type. The function takes a FiberMap and returns an Effect that can fork other effects with specified keys and options.

LANGUAGE: typescript
CODE:
declare const runtime: <K, A, E>(self: FiberMap<K, A, E>) => <R = never>() => Effect.Effect<(<XE extends E, XA extends A>(key: K, effect: Effect.Effect<XA, XE, R>, options?: (Runtime.RunForkOptions & { readonly onlyIfMissing?: boolean | undefined; readonly propagateInterruption?: boolean | undefined; }) | undefined) => Fiber.RuntimeFiber<XA, XE>), never, R>

----------------------------------------

TITLE: Defining mapInputError Function for Channel Transformation in TypeScript
DESCRIPTION: This snippet defines the mapInputError function, which creates a new channel by applying a given function to the input channel's error value. It supports both curried and uncurried versions of the function.

LANGUAGE: typescript
CODE:
declare const mapInputError: { <InErr0, InErr>(f: (a: InErr0) => InErr): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem, InElem, OutErr, InErr0, OutDone, InDone, Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InErr0>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (a: InErr0) => InErr): Channel<OutElem, InElem, OutErr, InErr0, OutDone, InDone, Env>; }

----------------------------------------

TITLE: Effect.addFinalizer Type Signature
DESCRIPTION: Type declaration for the addFinalizer function, showing its parameters and return type in TypeScript.

LANGUAGE: typescript
CODE:
declare const addFinalizer: <X, R>(finalizer: (exit: Exit.Exit<unknown, unknown>) => Effect<X, never, R>) => Effect<void, never, Scope.Scope | R>

----------------------------------------

TITLE: Evaluating Group Streams in Effect GroupBy Module
DESCRIPTION: Function that runs an operation across all groups in a GroupBy structure, collecting results in arbitrary order. Takes a function that processes each group's stream and optional buffer size configuration. Returns a new stream containing the processed results.

LANGUAGE: typescript
CODE:
declare const evaluate: { <K, V, E, A, E2, R2>(f: (key: K, stream: Stream.Stream<V, E, never>) => Stream.Stream<A, E2, R2>, options?: { readonly bufferSize?: number | undefined; } | undefined): <R>(self: GroupBy<K, V, E, R>) => Stream.Stream<A, E | E2, R2 | R>; <K, V, E, R, A, E2, R2>(self: GroupBy<K, V, E, R>, f: (key: K, stream: Stream.Stream<V, E, never>) => Stream.Stream<A, E2, R2>, options?: { readonly bufferSize?: number | undefined; } | undefined): Stream.Stream<A, E | E2, R | R2>; }

----------------------------------------

TITLE: Implementing foldSink Function in TypeScript for Effect Package
DESCRIPTION: Defines the foldSink function which folds over the result of a sink. It accepts options for handling failure and success cases, and returns a new sink with combined types.

LANGUAGE: typescript
CODE:
declare const foldSink: { <E, A1, In, In1 extends In, L1, E1, R1, A, A2, In2 extends In, L2, E2, R2>(options: { readonly onFailure: (err: E) => Sink<A1, In1, L1, E1, R1>; readonly onSuccess: (a: A) => Sink<A2, In2, L2, E2, R2>; }): <L, R>(self: Sink<A, In, L, E, R>) => Sink<A1 | A2, In1 & In2, L1 | L2, E1 | E2, R1 | R2 | R>; <A, In, L, E, R, A1, In1 extends In, L1, E1, R1, A2, In2 extends In, L2, E2, R2>(self: Sink<A, In, L, E, R>, options: { readonly onFailure: (err: E) => Sink<A1, In1, L1, E1, R1>; readonly onSuccess: (a: A) => Sink<A2, In2, L2, E2, R2>; }): Sink<A1 | A2, In1 & In2, L1 | L2, E1 | E2, R | R1 | R2>; }

----------------------------------------

TITLE: Defining untilOutput Function in TypeScript
DESCRIPTION: Declares the untilOutput function, which takes a predicate and a schedule, returning a new schedule that stops execution when the predicate on the output evaluates to true. It can be called with arguments in either order.

LANGUAGE: typescript
CODE:
declare const untilOutput: { <Out>(f: Predicate<Out>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R>(self: Schedule<Out, In, R>, f: Predicate<Out>): Schedule<Out, In, R>; }

----------------------------------------

TITLE: Implementing MutableQueue.offerAll in TypeScript
DESCRIPTION: Function signature for offerAll operation that enqueues multiple values into a MutableQueue. Returns a Chunk containing values that could not be enqueued. Supports both curried and standard parameter calling conventions.

LANGUAGE: typescript
CODE:
declare const offerAll: { <A>(values: Iterable<A>): (self: MutableQueue<A>) => Chunk.Chunk<A>; <A>(self: MutableQueue<A>, values: Iterable<A>): Chunk.Chunk<A>; }

----------------------------------------

TITLE: Signature of Boolean.some Function in TypeScript
DESCRIPTION: This code snippet shows the TypeScript signature of the 'some' function. It takes an iterable of boolean values and returns a boolean.

LANGUAGE: typescript
CODE:
declare const some: (collection: Iterable<boolean>) => boolean

----------------------------------------

TITLE: Implementing Option Wrapping Effect in TypeScript
DESCRIPTION: Function signature for succeedSome that takes a value of type A and returns an Effect containing an Option of type A. This creates an effect that successfully wraps the input value in a Some option type.

LANGUAGE: typescript
CODE:
declare const succeedSome: <A>(value: A) => Effect<Option.Option<A>>

----------------------------------------

TITLE: Checking List Type in TypeScript
DESCRIPTION: The isList function determines if a given value is a List. It accepts either an Iterable<A> or an unknown type, and returns a boolean indicating whether the input is a List<A> or List<unknown> respectively.

LANGUAGE: typescript
CODE:
declare const isList: { <A>(u: Iterable<A>): u is List<A>; (u: unknown): u is List<unknown>; }

----------------------------------------

TITLE: Function Signature for HashSet.every in TypeScript
DESCRIPTION: Provides the TypeScript function signature for the 'every' function in the HashSet module. It includes overloads for both Refinement and Predicate use cases.

LANGUAGE: typescript
CODE:
declare const every: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: HashSet<A>) => self is HashSet<B>; <A>(predicate: Predicate<A>): (self: HashSet<A>) => boolean; <A, B extends A>(self: HashSet<A>, refinement: Refinement<A, B>): self is HashSet<B>; <A>(self: HashSet<A>, predicate: Predicate<A>): boolean; }

----------------------------------------

TITLE: Implementing Schedule Delay Modification in TypeScript with Effect
DESCRIPTION: Function declaration for modifyDelayEffect that enables dynamic modification of a schedule's delay using an effectful function. It takes a function that processes the schedule's output and current duration to produce a new duration effect, returning a modified schedule with updated delay timing.

LANGUAGE: typescript
CODE:
declare const modifyDelayEffect: { 
  <Out, R2>(f: (out: Out, duration: Duration.Duration) => Effect.Effect<Duration.DurationInput, never, R2>): 
    <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R2 | R>; 
  <Out, In, R, R2>(self: Schedule<Out, In, R>, 
    f: (out: Out, duration: Duration.Duration) => Effect.Effect<Duration.DurationInput, never, R2>): 
      Schedule<Out, In, R | R2>; 
}

----------------------------------------

TITLE: Converting UrlParams to Record in TypeScript
DESCRIPTION: Demonstrates how to convert UrlParams into a Record containing key-value pairs where values are either strings or non-empty arrays of strings. The function handles different input types and automatically converts them to string representations.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { UrlParams } from "@effect/platform"

const urlParams = UrlParams.fromInput({ a: 1, b: true, c: "string", e: [1, 2, 3] })
const result = UrlParams.toRecord(urlParams)

assert.deepStrictEqual(
  result,
  { "a": "1", "b": "true", "c": "string", "e": ["1", "2", "3"] }
)

LANGUAGE: typescript
CODE:
declare const toRecord: (self: UrlParams) => Record<string, string | Arr.NonEmptyArray<string>>

----------------------------------------

TITLE: Trie.get Function Signature in TypeScript
DESCRIPTION: Provides the type signature for the Trie.get function. It shows that the function can be called with either the key first or the Trie first, allowing for flexible usage patterns.

LANGUAGE: typescript
CODE:
declare const get: { (key: string): <V>(self: Trie<V>) => Option<V>; <V>(self: Trie<V>, key: string): Option<V>; }

----------------------------------------

TITLE: Declaring Stream.unwrapScoped Function in TypeScript
DESCRIPTION: Defines the unwrapScoped function that creates a stream from a scoped Effect. It takes an Effect that produces a Stream and returns a new Stream with combined error and environment types.

LANGUAGE: typescript
CODE:
declare const unwrapScoped: <A, E2, R2, E, R>(effect: Effect.Effect<Stream<A, E2, R2>, E, R>) => Stream<A, E | E2, R2 | Exclude<R, Scope.Scope>>

----------------------------------------

TITLE: Defining RuntimeFlag Type in TypeScript for Effect Runtime
DESCRIPTION: Defines the RuntimeFlag type as a number with a unique symbol. This type is used to represent flags for enabling or disabling specific features in the Effect runtime.

LANGUAGE: typescript
CODE:
type RuntimeFlag = number & {
  readonly RuntimeFlag: unique symbol
}

----------------------------------------

TITLE: Defining mapConcatEffect Function for Stream in TypeScript
DESCRIPTION: Declares the mapConcatEffect function, which effectfully maps each element of a stream to an iterable and flattens the results. It supports both curried and uncurried calling styles.

LANGUAGE: typescript
CODE:
declare const mapConcatEffect: { <A, A2, E2, R2>(f: (a: A) => Effect.Effect<Iterable<A2>, E2, R2>): <E, R>(self: Stream<A, E, R>) => Stream<A2, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, f: (a: A) => Effect.Effect<Iterable<A2>, E2, R2>): Stream<A2, E | E2, R | R2>; }

----------------------------------------

TITLE: Defining MalformedMessage Error Class in TypeScript
DESCRIPTION: Declares the MalformedMessage class to represent deserialization errors in entity messages. This class is part of the ClusterError module in the @effect/cluster package.

LANGUAGE: typescript
CODE:
declare class MalformedMessage

----------------------------------------

TITLE: Defining fromFunctionBatched in RequestResolver Module (TypeScript)
DESCRIPTION: Declares a function that constructs a data source from a pure function handling batched requests. It takes a function that processes an array of requests and returns an iterable of successful results, maintaining the order of the input requests.

LANGUAGE: typescript
CODE:
declare const fromFunctionBatched: <A extends Request.Request<any>>(f: (chunk: NonEmptyArray<A>) => Iterable<Request.Request.Success<A>>) => RequestResolver<A>

----------------------------------------

TITLE: TypeScript Function Signature for fromIterableBy
DESCRIPTION: Provides the TypeScript function signature for the fromIterableBy function. It takes an iterable of type A and a function that maps A to a key K, returning a Record with keys of type K and values of type A.

LANGUAGE: typescript
CODE:
declare const fromIterableBy: <A, K extends string | symbol>(items: Iterable<A>, f: (a: A) => K) => Record<ReadonlyRecord.NonLiteralKey<K>, A>

----------------------------------------

TITLE: Declaring Required Type Utility in TypeScript
DESCRIPTION: Function signature for the required utility that transforms an AST into a new AST where all properties are required, mirroring TypeScript's Required utility type at runtime.

LANGUAGE: typescript
CODE:
declare const required: (ast: AST) => AST

----------------------------------------

TITLE: Transforming Sink Input/Output in TypeScript
DESCRIPTION: Function signature for dimapChunks that allows transforming both the input chunks and final result of a sink. Takes transformation functions for input chunks and final result, and returns a new sink with transformed types.

LANGUAGE: typescript
CODE:
declare const dimapChunks: { <In0, In, A, A2>(options: { readonly onInput: (chunk: Chunk.Chunk<In0>) => Chunk.Chunk<In>; readonly onDone: (a: A) => A2; }): <L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A2, In0, L, E, R>; <A, In, L, E, R, In0, A2>(self: Sink<A, In, L, E, R>, options: { readonly onInput: (chunk: Chunk.Chunk<In0>) => Chunk.Chunk<In>; readonly onDone: (a: A) => A2; }): Sink<A2, In0, L, E, R>; }

----------------------------------------

TITLE: Type Checking IllegalArgumentException in TypeScript
DESCRIPTION: Type guard function that checks if an unknown value is an IllegalArgumentException. This function implements a type predicate to ensure type safety when working with exceptions.

LANGUAGE: typescript
CODE:
declare const isIllegalArgumentException: (u: unknown) => u is IllegalArgumentException

----------------------------------------

TITLE: Creating Stream from PubSub in Effect-TS
DESCRIPTION: Function that creates a stream from a PubSub subscription. It accepts a PubSub instance handling chunks of type A and optional configuration for scoping and shutdown behavior. Returns either an Effect requiring a Scope or a direct Stream depending on the scoped option.

LANGUAGE: typescript
CODE:
declare const fromChunkPubSub: { 
  <A>(pubsub: PubSub.PubSub<Chunk.Chunk<A>>, 
      options: { 
        readonly scoped: true; 
        readonly shutdown?: boolean | undefined; 
      }
  ): Effect.Effect<Stream<A>, never, Scope.Scope>; 
  <A>(pubsub: PubSub.PubSub<Chunk.Chunk<A>>, 
      options?: { 
        readonly scoped?: false | undefined; 
        readonly shutdown?: boolean | undefined; 
      } | undefined
  ): Stream<A>; 
}

----------------------------------------

TITLE: Defining trackSuccessWith Function in Effect Metric Module (TypeScript)
DESCRIPTION: Declares the trackSuccessWith function, which returns an aspect to update a metric with the result of applying a specified function to the success value of effects. It can be used in two ways: either by passing the metric and function first, or by passing the effect first followed by the metric and function.

LANGUAGE: typescript
CODE:
declare const trackSuccessWith: { <Type, In, Out, In2>(metric: Metric<Type, In, Out>, f: (value: In2) => In): <A extends In2, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; <A extends In2, E, R, Type, In, Out, In2>(self: Effect.Effect<A, E, R>, metric: Metric<Type, In, Out>, f: (value: In2) => In): Effect.Effect<A, E, R>; }

----------------------------------------

TITLE: Effect.replicate Type Signature in TypeScript
DESCRIPTION: Type declaration for the replicate function showing its polymorphic nature. It can be called with either the number first and effect second, or effect first and number second.

LANGUAGE: typescript
CODE:
declare const replicate: { (n: number): <A, E, R>(self: Effect<A, E, R>) => Array<Effect<A, E, R>>; <A, E, R>(self: Effect<A, E, R>, n: number): Array<Effect<A, E, R>>; }

----------------------------------------

TITLE: Declaring Effect.annotateSpans Function Type in TypeScript
DESCRIPTION: Type declaration for the annotateSpans function which supports multiple overloads for adding annotations to spans. The function can accept either individual key-value pairs or records of annotations, and can be used both in curried and direct forms with Effect instances.

LANGUAGE: typescript
CODE:
declare const annotateSpans: { 
  (key: string, value: unknown): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; 
  (values: Record<string, unknown>): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, R>; 
  <A, E, R>(effect: Effect<A, E, R>, key: string, value: unknown): Effect<A, E, R>; 
  <A, E, R>(effect: Effect<A, E, R>, values: Record<string, unknown>): Effect<A, E, R>; 
}

----------------------------------------

TITLE: Checking TQueue Type in TypeScript
DESCRIPTION: The isTQueue function is a type guard that checks if a given value is of type TQueue. It takes an unknown value as input and returns a boolean indicating whether the value is a TQueue instance.

LANGUAGE: typescript
CODE:
declare const isTQueue: (u: unknown) => u is TQueue<unknown>

----------------------------------------

TITLE: Converting TPriorityQueue to Array in TypeScript STM
DESCRIPTION: Implementation signature for converting a TPriorityQueue to an array using STM transactions. The operation takes a TPriorityQueue of type A and returns an STM transaction that produces an Array of type A.

LANGUAGE: typescript
CODE:
declare const toArray: <A>(self: TPriorityQueue<A>) => STM.STM<Array<A>>

----------------------------------------

TITLE: Defining ignoreLeftover Function for Sink in TypeScript
DESCRIPTION: The ignoreLeftover function drains the remaining elements from the stream after the sink finishes. It takes a Sink as input and returns a new Sink that ignores any leftover elements.

LANGUAGE: typescript
CODE:
declare const ignoreLeftover: <A, In, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In, never, E, R>

----------------------------------------

TITLE: keysWithPrefix Function Signature (TypeScript)
DESCRIPTION: The type signature of the keysWithPrefix function. It can be called with either the prefix first and the Trie second, or with the Trie first and the prefix second. It returns an IterableIterator of strings.

LANGUAGE: typescript
CODE:
declare const keysWithPrefix: { (prefix: string): <V>(self: Trie<V>) => IterableIterator<string>; <V>(self: Trie<V>, prefix: string): IterableIterator<string>; }

----------------------------------------

TITLE: Publishing Multiple Messages to TPubSub in TypeScript
DESCRIPTION: The publishAll function is used to publish all specified messages to a TPubSub instance. It returns an STM (Software Transactional Memory) operation that resolves to a boolean indicating whether the messages were successfully published.

LANGUAGE: typescript
CODE:
declare const publishAll: { <A>(iterable: Iterable<A>): (self: TPubSub<A>) => STM.STM<boolean>; <A>(self: TPubSub<A>, iterable: Iterable<A>): STM.STM<boolean>; }

----------------------------------------

TITLE: Declaring cursorHide Function in TypeScript for Ansi Module
DESCRIPTION: Defines the cursorHide constant as an Ansi type. This function is used to hide the cursor in terminal output. It has been available since version 1.0.0 of the package.

LANGUAGE: typescript
CODE:
declare const cursorHide: Ansi

----------------------------------------

TITLE: Creating Failing Configuration in TypeScript using effect Config Module
DESCRIPTION: The fail function constructs a Config that always fails with a specified error message. It takes a string parameter for the message and returns a Config of type never, indicating it will always fail.

LANGUAGE: typescript
CODE:
declare const fail: (message: string) => Config<never>

----------------------------------------

TITLE: Creating Differ Instance in TypeScript
DESCRIPTION: Constructs a new Differ instance with specified parameters for handling value differences, patches, and combinations. The function takes configuration for empty patch state, diffing between values, combining patches, and applying patches to values.

LANGUAGE: typescript
CODE:
declare const make: <Value, Patch>(params: { readonly empty: Patch; readonly diff: (oldValue: Value, newValue: Value) => Patch; readonly combine: (first: Patch, second: Patch) => Patch; readonly patch: (patch: Patch, oldValue: Value) => Value; }) => Differ<Value, Patch>

----------------------------------------

TITLE: Implementing Redacted Config in TypeScript
DESCRIPTION: Defines a function signature for creating redacted configurations. The function can either take an optional name parameter to create a new redacted config, or transform an existing config into a redacted version.

LANGUAGE: typescript
CODE:
declare const redacted: { (name?: string): Config<Redacted.Redacted>; <A>(config: Config<A>): Config<Redacted.Redacted<A>>; }

----------------------------------------

TITLE: Declaring Scoped Metric Labels in TypeScript
DESCRIPTION: Function signature for applying temporary labels to metrics within a specific scope. Takes an array of MetricLabel objects and returns an Effect that requires a Scope and never produces an error.

LANGUAGE: typescript
CODE:
declare const labelMetricsScoped: (labels: ReadonlyArray<MetricLabel.MetricLabel>) => Effect<void, never, Scope.Scope>

----------------------------------------

TITLE: Defining isInterruptedException Type Guard in TypeScript
DESCRIPTION: Declares a type guard function that checks if an unknown value is an InterruptedException. This function is useful for narrowing down the type of an unknown value in type-safe code.

LANGUAGE: typescript
CODE:
declare const isInterruptedException: (u: unknown) => u is InterruptedException

----------------------------------------

TITLE: Implementing Option Chaining in TypeScript
DESCRIPTION: Type declaration for the andThen function that enables sequential composition of Option values. The function supports multiple overloads for handling both function-based and static Option values, with type parameters A and B representing input and output types respectively.

LANGUAGE: typescript
CODE:
declare const andThen: {
  <A, B>(f: (a: A) => Option<B>): (self: Option<A>) => Option<B>;
  <B>(f: Option<B>): <A>(self: Option<A>) => Option<B>;
  <A, B>(f: (a: A) => B): (self: Option<A>) => Option<B>;
  <B>(f: NotFunction<B>): <A>(self: Option<A>) => Option<B>;
  <A, B>(self: Option<A>, f: (a: A) => Option<B>): Option<B>;
  <A, B>(self: Option<A>, f: Option<B>): Option<B>;
  <A, B>(self: Option<A>, f: (a: A) => B): Option<B>;
  <A, B>(self: Option<A>, f: NotFunction<B>): Option<B>;
}

----------------------------------------

TITLE: Marking HashMap as Mutable in TypeScript
DESCRIPTION: The beginMutation function is used to mark a HashMap as mutable. It takes a HashMap<K, V> as input and returns the same HashMap type, allowing for subsequent mutation operations.

LANGUAGE: typescript
CODE:
declare const beginMutation: <K, V>(self: HashMap<K, V>) => HashMap<K, V>

----------------------------------------

TITLE: Defining fromPubSub Function in TypeScript for Effect-TS Stream Module
DESCRIPTION: This code snippet defines the fromPubSub function, which creates a stream from a PubSub subscription. It accepts a PubSub instance and options, including whether to scope the stream and shut down the PubSub after evaluation. The function has two overloads to handle different option configurations.

LANGUAGE: typescript
CODE:
declare const fromPubSub: { <A>(pubsub: PubSub.PubSub<A>, options: { readonly scoped: true; readonly maxChunkSize?: number | undefined; readonly shutdown?: boolean | undefined; }): Effect.Effect<Stream<A>, never, Scope.Scope>; <A>(pubsub: PubSub.PubSub<A>, options?: { readonly scoped?: false | undefined; readonly maxChunkSize?: number | undefined; readonly shutdown?: boolean | undefined; } | undefined): Stream<A>; }

----------------------------------------

TITLE: Retrieving Fiber Identifiers in TypeScript
DESCRIPTION: Function that retrieves the set of numeric identifiers associated with a FiberId instance. Returns a HashSet containing the identifier numbers.

LANGUAGE: typescript
CODE:
declare const ids: (self: FiberId) => HashSet.HashSet<number>

----------------------------------------

TITLE: Defining RequestAttributes Interface for OpenAI Telemetry in TypeScript
DESCRIPTION: TypeScript interface that defines the structure of request attributes for OpenAI telemetry, including optional properties for response format and service tier settings. The attributes are namespaced under gen_ai.openai.request as per the GenAI specification.

LANGUAGE: typescript
CODE:
export interface RequestAttributes {
    /**
     * The response format that is requested.
     */
    readonly responseFormat?: (string & {}) | WellKnownResponseFormat | null | undefined
    /**
     * The service tier requested. May be a specific tier, `default`, or `auto`.
     */
    readonly serviceTier?: (string & {}) | WellKnownServiceTier | null | undefined
  }

----------------------------------------

TITLE: Merging Channels with Custom Termination Behavior in TypeScript
DESCRIPTION: Function signature for mergeWith that creates a new channel by combining two channels. It accepts options for handling early termination through onSelfDone and onOtherDone merge decisions.

LANGUAGE: typescript
CODE:
declare const mergeWith: { <OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1, OutDone, OutErr, OutErr2, OutDone2, OutErr3, OutDone3>(options: { readonly other: Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>; readonly onSelfDone: (exit: Exit.Exit<OutDone, OutErr>) => MergeDecision.MergeDecision<Env1, OutErr1, OutDone1, OutErr2, OutDone2>; readonly onOtherDone: (ex: Exit.Exit<OutDone1, OutErr1>) => MergeDecision.MergeDecision<Env1, OutErr, OutDone, OutErr3, OutDone3>; }): <Env, InErr, InElem, InDone, OutElem>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1 | OutElem, InElem & InElem1, OutErr2 | OutErr3, InErr & InErr1, OutDone2 | OutDone3, InDone & InDone1, Env1 | Env>; <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1, OutErr2, OutDone2, OutErr3, OutDone3>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, options: { readonly other: Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>; readonly onSelfDone: (exit: Exit.Exit<OutDone, OutErr>) => MergeDecision.MergeDecision<Env1, OutErr1, OutDone1, OutErr2, OutDone2>; readonly onOtherDone: (ex: Exit.Exit<OutDone1, OutErr1>) => MergeDecision.MergeDecision<Env1, OutErr, OutDone, OutErr3, OutDone3>; }): Channel<OutElem | OutElem1, InElem & InElem1, OutErr2 | OutErr3, InErr & InErr1, OutDone2 | OutDone3, InDone & InDone1, Env | Env1>; }

----------------------------------------

TITLE: Checking Queue Emptiness in TypeScript with Effect Library
DESCRIPTION: The isEmpty function returns a boolean indicating whether a Queue contains zero elements. It works with both Dequeue and Enqueue types, returning an Effect wrapping the boolean result.

LANGUAGE: typescript
CODE:
declare const isEmpty: <A>(self: Dequeue<A> | Enqueue<A>) => Effect.Effect<boolean>

----------------------------------------

TITLE: Declaring logWarning Function in TypeScript for Effect Module
DESCRIPTION: Defines the logWarning function which logs messages at the WARNING level. It takes any number of arguments and returns an Effect with void result, never error, and never dependencies.

LANGUAGE: typescript
CODE:
declare const logWarning: (...message: ReadonlyArray<any>) => Effect<void, never, never>

----------------------------------------

TITLE: Checking Write Lock Status in TReentrantLock (TypeScript)
DESCRIPTION: The writeLocked function determines if a write lock is held by some fiber in a TReentrantLock. It takes a TReentrantLock instance as input and returns an STM (Software Transactional Memory) operation that resolves to a boolean.

LANGUAGE: typescript
CODE:
declare const writeLocked: (self: TReentrantLock) => STM.STM<boolean>

----------------------------------------

TITLE: Creating a Dropping Sink in TypeScript
DESCRIPTION: The drop function creates a sink that drops a specified number of elements. It takes a number as input and returns a Sink that processes input elements of type In, potentially dropping some based on the specified count.

LANGUAGE: typescript
CODE:
declare const drop: <In>(n: number) => Sink<unknown, In, In>

----------------------------------------

TITLE: Implementing Stream.timeoutFail in TypeScript
DESCRIPTION: Defines the timeoutFail function for Stream, which fails the stream with a given error if it doesn't produce a value within a specified duration. It accepts an error, duration, and the stream itself as parameters.

LANGUAGE: typescript
CODE:
declare const timeoutFail: { <E2>(error: LazyArg<E2>, duration: Duration.DurationInput): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R>; <A, E, R, E2>(self: Stream<A, E, R>, error: LazyArg<E2>, duration: Duration.DurationInput): Stream<A, E | E2, R>; }

----------------------------------------

TITLE: Implementing Record.every Type Definition in TypeScript
DESCRIPTION: Type definition for the every function that validates all entries in a record against a predicate or refinement. The function supports both curried and non-curried forms, and can work with type refinements or boolean predicates.

LANGUAGE: typescript
CODE:
declare const every: {
  <A, K extends string, B extends A>(refinement: (value: A, key: K) => value is B): (self: ReadonlyRecord<K, A>) => self is ReadonlyRecord<K, B>;
  <A, K extends string>(predicate: (value: A, key: K) => boolean): (self: ReadonlyRecord<K, A>) => boolean;
  <A, K extends string, B extends A>(self: ReadonlyRecord<K, A>, refinement: (value: A, key: K) => value is B): self is ReadonlyRecord<K, B>;
  <K extends string, A>(self: ReadonlyRecord<K, A>, predicate: (value: A, key: K) => boolean): boolean;
}

----------------------------------------

TITLE: Creating Reentrant Read/Write Lock in TypeScript using Effect
DESCRIPTION: The 'make' function creates a new reentrant read/write lock. It returns an STM (Software Transactional Memory) effect that, when executed, will produce a TReentrantLock instance.

LANGUAGE: typescript
CODE:
declare const make: STM.STM<TReentrantLock, never, never>

----------------------------------------

TITLE: Running and Counting Stream Elements in TypeScript
DESCRIPTION: The runCount function runs a stream and returns an Effect that emits the number of elements processed. It takes a Stream as input and produces an Effect that resolves to a number.

LANGUAGE: typescript
CODE:
declare const runCount: <A, E, R>(self: Stream<A, E, R>) => Effect.Effect<number, E, R>

----------------------------------------

TITLE: Defining Stream.whenCase Function in TypeScript
DESCRIPTION: Declares the whenCase function, which returns a resulting stream when a given PartialFunction is defined for a value, otherwise returns an empty stream. It takes an evaluation function and a partial function as parameters.

LANGUAGE: typescript
CODE:
declare const whenCase: <A, A2, E, R>(evaluate: LazyArg<A>, pf: (a: A) => Option.Option<Stream<A2, E, R>>) => Stream<A2, E, R>

----------------------------------------

TITLE: Exiting Deferred with Exit Value in TypeScript
DESCRIPTION: The done function exits a Deferred with a specified Exit value, propagating it to all fibers waiting on the Deferred's value. It has two overloads: one that takes the exit value first and returns a function, and another that takes the Deferred and exit value as separate arguments.

LANGUAGE: typescript
CODE:
declare const done: { <A, E>(exit: Exit.Exit<A, E>): (self: Deferred<A, E>) => Effect.Effect<boolean>; <A, E>(self: Deferred<A, E>, exit: Exit.Exit<A, E>): Effect.Effect<boolean>; }

----------------------------------------

TITLE: Implementing Defect Tracking in Effect-TS
DESCRIPTION: Defines a function that creates an aspect to update metrics with effect defects. The function supports both curried and uncurried calling styles, allowing metric tracking to be applied to Effect instances.

LANGUAGE: typescript
CODE:
declare const trackDefect: { 
  <Type, Out>(metric: Metric<Type, unknown, Out>): <A, E, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; 
  <A, E, R, Type, Out>(self: Effect.Effect<A, E, R>, metric: Metric<Type, unknown, Out>): Effect.Effect<A, E, R>; 
}

----------------------------------------

TITLE: Using Record.modifyOption in TypeScript with Effect Library
DESCRIPTION: Demonstrates how to use Record.modifyOption to modify values in a record by key, handling both existing and non-existing keys. The function returns Some with modified record if key exists, None otherwise.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Record as R, Option } from "effect"

const f = (x: number) => x * 2

assert.deepStrictEqual(
 R.modifyOption({ a: 3 }, 'a', f),
 Option.some({ a: 6 })
)
assert.deepStrictEqual(
 R.modifyOption({ a: 3 } as Record<string, number>, 'b', f),
 Option.none()
)

LANGUAGE: typescript
CODE:
declare const modifyOption: { <K extends string | symbol, A, B>(key: NoInfer<K>, f: (a: A) => B): (self: ReadonlyRecord<K, A>) => Option.Option<Record<K, A | B>>; <K extends string | symbol, A, B>(self: ReadonlyRecord<K, A>, key: NoInfer<K>, f: (a: A) => B): Option.Option<Record<K, A | B>>; }

----------------------------------------

TITLE: Defining isSubrecordBy Function in TypeScript
DESCRIPTION: Declares the isSubrecordBy function, which takes an Equivalence<A> and returns a function to check if one record is a subrecord of another. It supports both curried and uncurried usage patterns.

LANGUAGE: typescript
CODE:
declare const isSubrecordBy: <A>(equivalence: Equivalence<A>) => { <K extends string>(that: ReadonlyRecord<K, A>): (self: ReadonlyRecord<K, A>) => boolean; <K extends string>(self: ReadonlyRecord<K, A>, that: ReadonlyRecord<K, A>): boolean; }

----------------------------------------

TITLE: Using orElseFail in Effect Module
DESCRIPTION: Demonstrates how to use the orElseFail function to handle validation failures by replacing specific error types with a standardized error message. The example shows age validation with different failure cases.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

const validate = (age: number): Effect.Effect<number, string> => {
  if (age < 0) {
    return Effect.fail("NegativeAgeError")
  } else if (age < 18) {
    return Effect.fail("IllegalAgeError")
  } else {
    return Effect.succeed(age)
  }
}

const program = Effect.orElseFail(validate(-1), () => "invalid age")

console.log(Effect.runSyncExit(program))
// Output:
// {
//   _id: 'Exit',
//   _tag: 'Failure',
//   cause: { _id: 'Cause', _tag: 'Fail', failure: 'invalid age' }
// }

----------------------------------------

TITLE: Formatting DateTime as ISO String with Offset in TypeScript
DESCRIPTION: The formatIsoOffset function takes a DateTime object and returns a string representation in ISO format with an offset. It is part of the DateTime module in the effect package.

LANGUAGE: typescript
CODE:
declare const formatIsoOffset: (self: DateTime) => string

----------------------------------------

TITLE: Implementing Stream.someOrFail in TypeScript
DESCRIPTION: Function definition for someOrFail that extracts values from an Option within a Stream, failing with a provided error if the Option is None. The function supports both curried and uncurried calling styles.

LANGUAGE: typescript
CODE:
declare const someOrFail: { 
  <E2>(error: LazyArg<E2>): <A, E, R>(self: Stream<Option.Option<A>, E, R>) => Stream<A, E2 | E, R>; 
  <A, E, R, E2>(self: Stream<Option.Option<A>, E, R>, error: LazyArg<E2>): Stream<A, E | E2, R>; 
}

----------------------------------------

TITLE: Defining Config.Config.Wrap Type in TypeScript
DESCRIPTION: This snippet defines the 'Wrap' type which recursively transforms a nested structure into a Config type. It handles both plain objects and primitive values, wrapping them in Config<A> where appropriate. The type uses conditional types and inference to determine the structure of the input type.

LANGUAGE: typescript
CODE:
type Wrap<A> = [NonNullable<A>] extends [infer T] ? [IsPlainObject<T>] extends [true] ?
        | { readonly [K in keyof A]: Wrap<A[K]> }
        | Config<A>
    : Config<A>
    : Config<A>

----------------------------------------

TITLE: Getting Current Date with Effect DateTime Module
DESCRIPTION: Demonstrates how to get the current time as a Date object using the DateTime.nowAsDate Effect. This function returns an Effect that resolves to a Date instance without requiring any input dependencies.

LANGUAGE: typescript
CODE:
import { DateTime, Effect } from "effect"

Effect.gen(function* () {
  const now = yield* DateTime.nowAsDate
})

LANGUAGE: typescript
CODE:
declare const nowAsDate: Effect.Effect<Date, never, never>

----------------------------------------

TITLE: Combining FiberIds in TypeScript
DESCRIPTION: Function signature for combining two FiberId instances. The function is overloaded to support both curried and uncurried calling styles, allowing flexible composition of FiberIds.

LANGUAGE: typescript
CODE:
declare const combine: { (that: FiberId): (self: FiberId) => FiberId; (self: FiberId, that: FiberId): FiberId; }

----------------------------------------

TITLE: Implementing Error Recovery in Streams with catchSomeCause in TypeScript
DESCRIPTION: The catchSomeCause function allows switching to an alternative stream if the current one fails. It can handle all types of failures, including interruptions for uninterruptible streams. The function takes a partial function that maps error causes to optional new streams.

LANGUAGE: typescript
CODE:
declare const catchSomeCause: { <E, A2, E2, R2>(pf: (cause: Cause.Cause<E>) => Option.Option<Stream<A2, E2, R2>>): <A, R>(self: Stream<A, E, R>) => Stream<A2 | A, E | E2, R2 | R>; <A, E, R, A2, E2, R2>(self: Stream<A, E, R>, pf: (cause: Cause.Cause<E>) => Option.Option<Stream<A2, E2, R2>>): Stream<A | A2, E | E2, R | R2>; }

----------------------------------------

TITLE: Defining orElseFail Function in TypeScript for Stream Error Handling
DESCRIPTION: Declares the orElseFail function, which fails with a given error if the original stream fails with a typed error. It can be used as an alternative to Stream.catchAll for error handling in streams.

LANGUAGE: TypeScript
CODE:
declare const orElseFail: { <E2>(error: LazyArg<E2>): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E2, R>; <A, E, R, E2>(self: Stream<A, E, R>, error: LazyArg<E2>): Stream<A, E2, R>; }

----------------------------------------

TITLE: Effect.tapBoth Function Signature in TypeScript
DESCRIPTION: Provides the TypeScript signature for the Effect.tapBoth function, detailing its parameters and return types for both curried and non-curried versions.

LANGUAGE: typescript
CODE:
declare const tapBoth: { <E, X, E2, R2, A, X1, E3, R3>(options: { readonly onFailure: (e: NoInfer<E>) => Effect<X, E2, R2>; readonly onSuccess: (a: NoInfer<A>) => Effect<X1, E3, R3>; }): <R>(self: Effect<A, E, R>) => Effect<A, E | E2 | E3, R2 | R3 | R>; <A, E, R, X, E2, R2, X1, E3, R3>(self: Effect<A, E, R>, options: { readonly onFailure: (e: E) => Effect<X, E2, R2>; readonly onSuccess: (a: A) => Effect<X1, E3, R3>; }): Effect<A, E | E2 | E3, R | R2 | R3>; }

----------------------------------------

TITLE: Acquiring Read Lock in TReentrantLock (TypeScript)
DESCRIPTION: The acquireRead function acquires a read lock on a TReentrantLock. It suspends the transaction until no other fiber holds a write lock. The function returns the number of read locks held by the current fiber after acquisition.

LANGUAGE: typescript
CODE:
declare const acquireRead: (self: TReentrantLock) => STM.STM<number>

----------------------------------------

TITLE: Setting Scoped Random Service Implementation in Effect Module
DESCRIPTION: A function that temporarily sets the Random service implementation to a specified value within a scope. The original implementation is restored when the scope closes. Returns an Effect that requires a Scope and never fails.

LANGUAGE: typescript
CODE:
declare const withRandomScoped: <A extends Random.Random>(value: A) => Effect<void, never, Scope.Scope>

----------------------------------------

TITLE: Declaring unsafeDone Function in TypeScript for Deferred Module
DESCRIPTION: Defines the unsafeDone function which unsafely exits a Deferred with a specified Exit value. This function takes a Deferred<A, E> and an Effect.Effect<A, E> as parameters and returns void. It propagates the Exit value to all fibers waiting on the Deferred's value.

LANGUAGE: TypeScript
CODE:
declare const unsafeDone: <A, E>(self: Deferred<A, E>, effect: Effect.Effect<A, E>) => void

----------------------------------------

TITLE: Matcher Type Definition in Effect
DESCRIPTION: Type signature for the Matcher type in Effect's Match module, showing the generic parameters for Input, Filters, RemainingApplied, Result, Provided, and Return types.

LANGUAGE: typescript
CODE:
type Matcher<Input, Filters, RemainingApplied, Result, Provided, Return> = | TypeMatcher<Input, Filters, RemainingApplied, Result, Return>
  | ValueMatcher<Input, Filters, RemainingApplied, Result, Provided, Return>

----------------------------------------

TITLE: Implementing Semigroup for Tuples in TypeScript
DESCRIPTION: The tuple function creates a new Semigroup for a tuple of values based on given Semigroups for each element. It combines two tuples by applying the corresponding Semigroup to each element. This is useful for combining tuples with specific combination rules for each element.

LANGUAGE: typescript
CODE:
declare const tuple: <T extends ReadonlyArray<Semigroup<any>>>(...elements: T) => Semigroup<{ readonly [I in keyof T]: [T[I]] extends [Semigroup<infer A>] ? A : never; }>

----------------------------------------

TITLE: Implementing Stream Buffering in TypeScript using Effect
DESCRIPTION: Function signature for bufferChunks, which creates a buffered stream with specified capacity and strategy. It allows faster producers to operate independently of slower consumers by maintaining a buffer queue. Supports different buffering strategies including dropping, sliding, and suspend.

LANGUAGE: typescript
CODE:
declare const bufferChunks: { 
  (options: { readonly capacity: number; readonly strategy?: "dropping" | "sliding" | "suspend" | undefined; }): 
    <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; 
  <A, E, R>(self: Stream<A, E, R>, 
    options: { readonly capacity: number; readonly strategy?: "dropping" | "sliding" | "suspend" | undefined; }): 
    Stream<A, E, R>; 
}

----------------------------------------

TITLE: Using tapErrorTag with Effect in TypeScript
DESCRIPTION: Demonstrates how to use tapErrorTag to inspect specific error types based on their _tag property. The example shows handling of NetworkError and ValidationError types, with logging of NetworkError status codes while preserving the original error flow.

LANGUAGE: typescript
CODE:
import { Effect, Console } from "effect"

class NetworkError {
  readonly _tag = "NetworkError"
  constructor(readonly statusCode: number) {}
}

class ValidationError {
  readonly _tag = "ValidationError"
  constructor(readonly field: string) {}
}

// Create a task that fails with a NetworkError
const task: Effect.Effect<number, NetworkError | ValidationError> =
  Effect.fail(new NetworkError(504))

// Use tapErrorTag to inspect only NetworkError types and log the status code
const tapping = Effect.tapErrorTag(task, "NetworkError", (error) =>
  Console.log(`expected error: ${error.statusCode}`)
)

Effect.runFork(tapping)
// Output:
// expected error: 504

----------------------------------------

TITLE: Retrieving Last Option from TArray in TypeScript
DESCRIPTION: The lastOption function returns the last entry in a TArray if it exists. It takes a TArray<A> as input and returns an STM that resolves to an Option<A>.

LANGUAGE: typescript
CODE:
declare const lastOption: <A>(self: TArray<A>) => STM.STM<Option.Option<A>>

----------------------------------------

TITLE: Transforming DateTime Using mapEpochMillis in TypeScript
DESCRIPTION: This snippet demonstrates how to use the mapEpochMillis function to transform a DateTime object by adding 10 milliseconds to its epoch time. It imports the DateTime module from the effect package and applies the transformation using method chaining.

LANGUAGE: typescript
CODE:
import { DateTime } from "effect"

// add 10 milliseconds
DateTime.unsafeMake(0).pipe(
  DateTime.mapEpochMillis((millis) => millis + 10)
)

----------------------------------------

TITLE: Defining MetricState Interface in TypeScript
DESCRIPTION: Defines the MetricState interface which extends MetricState.Variance, Equal.Equal, and Pipeable. The interface uses a phantom type parameter 'A' to tie keys to their expected states.

LANGUAGE: typescript
CODE:
export interface MetricState<in A> extends MetricState.Variance<A>, Equal.Equal, Pipeable {}

----------------------------------------

TITLE: Defining ShardingConfig Class in TypeScript
DESCRIPTION: Declaration of the ShardingConfig class which represents configuration settings for the Sharding service on a runner in the Effect cluster system.

LANGUAGE: typescript
CODE:
declare class ShardingConfig

----------------------------------------

TITLE: Defining UnknownException Interface in TypeScript
DESCRIPTION: Defines a TypeScript interface for unknown exceptions that extends YieldableError. The interface includes a type tag, an UnknownExceptionTypeId, and stores the original unknown error.

LANGUAGE: typescript
CODE:
export interface UnknownException extends YieldableError {
  readonly _tag: "UnknownException"
  readonly [UnknownExceptionTypeId]: UnknownExceptionTypeId
  readonly error: unknown
}

----------------------------------------

TITLE: DateTime.toUtc Function Signature
DESCRIPTION: Type definition for the toUtc function that takes a DateTime instance and returns a DateTime.Utc instance.

LANGUAGE: typescript
CODE:
declare const toUtc: (self: DateTime) => Utc

----------------------------------------

TITLE: Declaring Doc.comma Constant in TypeScript
DESCRIPTION: Declares a constant named 'comma' of type Doc<never> representing a document with a single comma character. This constant is part of the @effect/printer package and is available since version 1.0.0.

LANGUAGE: typescript
CODE:
declare const comma: Doc<never>

----------------------------------------

TITLE: Joining Fibers with FiberSet in TypeScript
DESCRIPTION: Demonstrates how to use FiberSet.join to combine multiple fibers and handle their outcomes. If any fiber fails, the operation fails with the first encountered error. The example shows creating a FiberSet, adding a failing fiber, and joining the set.

LANGUAGE: typescript
CODE:
import { Effect, FiberSet } from "effect";

Effect.gen(function* (_) {
  const set = yield* _(FiberSet.make());
  yield* _(FiberSet.add(set, Effect.runFork(Effect.fail("error"))));

  // parent fiber will fail with "error"
  yield* _(FiberSet.join(set));
});

LANGUAGE: typescript
CODE:
declare const join: <A, E>(self: FiberSet<A, E>) => Effect.Effect<void, E>

----------------------------------------

TITLE: Encoding Input to Hexadecimal String in TypeScript
DESCRIPTION: The encodeHex function takes either a Uint8Array or a string as input and returns a hexadecimal string representation. It is part of the Encoding module in the effect package.

LANGUAGE: typescript
CODE:
declare const encodeHex: (input: Uint8Array | string) => string

----------------------------------------

TITLE: Implementing Stream Chunk Accumulation in TypeScript
DESCRIPTION: Function that collects each underlying Chunk of a stream into a new chunk and emits it on each pull. Takes a Stream of type A with error type E and environment R, and returns a Stream of Chunks of type A.

LANGUAGE: typescript
CODE:
declare const accumulate: <A, E, R>(self: Stream<A, E, R>) => Stream<Chunk.Chunk<A>, E, R>

----------------------------------------

TITLE: Calculating Square Root of BigInt in TypeScript using Effect Library
DESCRIPTION: The BigInt.sqrt function calculates the square root of a given bigint safely. It returns an Option containing the result if the input is non-negative, or None for negative inputs. This example demonstrates usage with various inputs.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { BigInt, Option } from "effect"

assert.deepStrictEqual(BigInt.sqrt(4n), Option.some(2n))
assert.deepStrictEqual(BigInt.sqrt(9n), Option.some(3n))
assert.deepStrictEqual(BigInt.sqrt(16n), Option.some(4n))
assert.deepStrictEqual(BigInt.sqrt(-1n), Option.none())

----------------------------------------

TITLE: Retrieving Fiber Read Lock Count in TypeScript STM
DESCRIPTION: A function that returns the number of read locks currently held by the calling fiber on a TReentrantLock. This is part of the STM (Software Transactional Memory) system and returns an STM effect that will yield the lock count.

LANGUAGE: typescript
CODE:
declare const fiberReadLocks: (self: TReentrantLock) => STM.STM<number>

----------------------------------------

TITLE: Declaring mapBothEffect Function in TypeScript
DESCRIPTION: Defines the mapBothEffect function for transforming both input and output of a schedule using effectful computations. It allows applying effectful transformations to modify existing schedules, supporting additional logic, resource access, or side effects.

LANGUAGE: typescript
CODE:
declare const mapBothEffect: { <In2, In, R2, Out, R3, Out2>(options: { readonly onInput: (input: In2) => Effect.Effect<In, never, R2>; readonly onOutput: (out: Out) => Effect.Effect<Out2, never, R3>; }): <R>(self: Schedule<Out, In, R>) => Schedule<Out2, In2, R2 | R3 | R>; <Out, In, R, In2, R2, Out2, R3>(self: Schedule<Out, In, R>, options: { readonly onInput: (input: In2) => Effect.Effect<In, never, R2>; readonly onOutput: (out: Out) => Effect.Effect<Out2, never, R3>; }): Schedule<Out2, In2, R | R2 | R3>; }

----------------------------------------

TITLE: Stream.make Function Signature in TypeScript
DESCRIPTION: The type signature for the Stream.make function, which creates a stream from a variable number of arguments. It returns a Stream of the type of the input elements.

LANGUAGE: typescript
CODE:
declare const make: <As extends Array<any>>(...as: As) => Stream<As[number]>

----------------------------------------

TITLE: Combining Patches with Differ.combine in TypeScript
DESCRIPTION: Function that combines two patches sequentially to create a new patch representing both updates. The operation is designed to be associative and potentially commutative for deterministic FiberRef values when joining multiple fibers concurrently.

LANGUAGE: typescript
CODE:
declare const combine: { 
  <Patch>(first: Patch, second: Patch): <Value>(self: Differ<Value, Patch>) => Patch; 
  <Value, Patch>(self: Differ<Value, Patch>, first: Patch, second: Patch): Patch; 
}

----------------------------------------

TITLE: Configuring HTTP Redirect Handling in TypeScript
DESCRIPTION: Function signature for configuring HTTP redirect following behavior in HttpClient. Allows specifying a maximum number of redirects to follow for HTTP requests, with optional parameters for flexibility in implementation.

LANGUAGE: typescript
CODE:
declare const followRedirects: { (maxRedirects?: number | undefined): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E, R>; <E, R>(self: HttpClient.With<E, R>, maxRedirects?: number | undefined): HttpClient.With<E, R>; }

----------------------------------------

TITLE: Defining HTTP Layer for Runners Services in TypeScript
DESCRIPTION: This function creates an HTTP layer for the Runners services. It adds a route to the provided HttpRouter.Tag, defaulting to HttpRouter.Default if not specified. The layer includes dependencies for sharding, runners, RPC serialization, and HTTP server functionality.

LANGUAGE: typescript
CODE:
declare const layer: <I = HttpRouter.Default>(options: { readonly path: HttpRouter.PathInput; readonly routerTag?: HttpRouter.HttpRouter.TagClass<I, string, any, any>; readonly logAddress?: boolean | undefined; }) => Layer.Layer<Sharding.Sharding | Runners.Runners, never, RpcSerialization.RpcSerialization | ShardingConfig.ShardingConfig | Runners.RpcClientProtocol | HttpServer.HttpServer | MessageStorage | ShardStorage>

----------------------------------------

TITLE: Creating FiberId Unsafely in TypeScript
DESCRIPTION: The unsafeMake function is used to create a new FiberId instance unsafely. It takes a void parameter and returns a Runtime object. This function has been available since version 2.0.0 of the package.

LANGUAGE: typescript
CODE:
declare const unsafeMake: (_: void) => Runtime

----------------------------------------

TITLE: Defining RequestResolver Interface in TypeScript
DESCRIPTION: Defines the RequestResolver interface, which handles the execution of requests. It includes methods for running batches of requests and identifying data sources. The interface is generic, allowing for different request and environment types.

LANGUAGE: typescript
CODE:
export interface RequestResolver<in A, out R = never> extends RequestResolver.Variance<A, R>, Equal.Equal, Pipeable {
  /**
   * Execute a collection of requests. The outer `Array` represents batches
   * of requests that must be performed sequentially. The inner `Array`
   * represents a batch of requests that can be performed in parallel.
   */
  runAll(requests: Array<Array<Request.Entry<A>>>): Effect.Effect<void, never, R>

  /**
   * Identify the data source using the specific identifier
   */
  identified(...identifiers: Array<unknown>): RequestResolver<A, R>
}

----------------------------------------

TITLE: Declaring Cursor Save Position Function in TypeScript
DESCRIPTION: Defines a constant that saves the current cursor position along with shift state and formatting attributes in ANSI terminal output. This is part of the AnsiDoc module in the @effect/printer-ansi package.

LANGUAGE: typescript
CODE:
declare const cursorSavePosition: AnsiDoc

----------------------------------------

TITLE: Flattening Chunks in Effect Stream
DESCRIPTION: A utility function that takes a Stream of Chunks and flattens them into a single Stream while preserving the chunk structure. This operation maintains the error type E and environment type R while transforming the value type from Chunk<A> to A.

LANGUAGE: typescript
CODE:
declare const flattenChunks: <A, E, R>(self: Stream<Chunk.Chunk<A>, E, R>) => Stream<A, E, R>

----------------------------------------

TITLE: Testing TMap Emptiness in TypeScript STM
DESCRIPTION: Defines a function that checks if a transactional map (TMap) is empty. Returns an STM transaction that resolves to a boolean indicating whether the map contains any entries.

LANGUAGE: typescript
CODE:
declare const isEmpty: <K, V>(self: TMap<K, V>) => STM.STM<boolean>

----------------------------------------

TITLE: Defining unlessSTM Function in TypeScript for Conditional STM Execution
DESCRIPTION: Declares the unlessSTM function, which is the STM equivalent of 'if (!p) exp' where p has side-effects. It takes a predicate and an STM transaction, returning an optional result wrapped in an STM.

LANGUAGE: typescript
CODE:
declare const unlessSTM: { <E2, R2>(predicate: STM<boolean, E2, R2>): <A, E, R>(self: STM<A, E, R>) => STM<Option.Option<A>, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: STM<A, E, R>, predicate: STM<boolean, E2, R2>): STM<Option.Option<A>, E | E2, R | R2>; }

----------------------------------------

TITLE: Declaring RuntimeExceptionTypeId Symbol in TypeScript
DESCRIPTION: Defines a unique symbol RuntimeExceptionTypeId used to identify RuntimeException types. This symbol is typically used internally by the library to recognize checked exceptions that occur during runtime.

LANGUAGE: typescript
CODE:
declare const RuntimeExceptionTypeId: unique symbol

----------------------------------------

TITLE: Defining Error Mapping Function in TypeScript
DESCRIPTION: Function signature for mapError that transforms errors of type E to E2 in a Micro effect. The function supports both curried and non-curried versions for transforming errors while preserving the success type A and environment type R.

LANGUAGE: typescript
CODE:
declare const mapError: { <E, E2>(f: (e: E) => E2): <A, R>(self: Micro<A, E, R>) => Micro<A, E2, R>; <A, E, R, E2>(self: Micro<A, E, R>, f: (e: E) => E2): Micro<A, E2, R>; }

----------------------------------------

TITLE: Implementing traverseFilterMap for TraversableFilterable Type Class
DESCRIPTION: Provides a default binary traverseFilterMap implementation that combines Traversable and Filterable typeclasses with Applicative functors. It processes elements of a traversable structure, allowing both filtering and mapping operations to be performed simultaneously.

LANGUAGE: typescript
CODE:
declare const traverseFilterMap: <T extends TypeLambda>(T: Traversable<T> & Filterable<T>) => <F extends TypeLambda>(F: Applicative<F>) => <TR, TO, TE, A, R, O, E, B>(self: Kind<T, TR, TO, TE, A>, f: (a: A) => Kind<F, R, O, E, Option<B>>) => Kind<F, R, O, E, Kind<T, TR, TO, TE, B>>

----------------------------------------

TITLE: Implementing Queue Shutdown in TypeScript with Effect
DESCRIPTION: Function that interrupts any fibers suspended on offer or take operations for a TQueue. After shutdown, subsequent offer and take operations will be immediately interrupted. Works with both TDequeue and TEnqueue types.

LANGUAGE: typescript
CODE:
declare const shutdown: <A>(self: TDequeue<A> | TEnqueue<A>) => STM.STM<void>

----------------------------------------

TITLE: Scoping Test Live Service Implementation in Effect TypeScript
DESCRIPTION: The withLiveScoped function sets a test implementation of the Live service for a scoped duration. It takes a TestLive instance and returns an Effect that restores the original implementation when the scope closes.

LANGUAGE: typescript
CODE:
declare const withLiveScoped: (live: Live.TestLive) => Effect.Effect<void, never, Scope.Scope>

----------------------------------------

TITLE: Calculating GCD of BigInts in TypeScript
DESCRIPTION: Demonstrates how to calculate the greatest common divisor (GCD) of two BigInt values using the gcd function from effect/BigInt. The function accepts two bigint parameters and returns their greatest common divisor as a bigint.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { gcd } from "effect/BigInt"

assert.deepStrictEqual(gcd(2n, 3n), 1n)
assert.deepStrictEqual(gcd(2n, 4n), 2n)
assert.deepStrictEqual(gcd(16n, 24n), 8n)

LANGUAGE: typescript
CODE:
declare const gcd: { (that: bigint): (self: bigint) => bigint; (self: bigint, that: bigint): bigint; }

----------------------------------------

TITLE: Declaring orElseEither Function in TypeScript
DESCRIPTION: Defines the orElseEither function which combines two differs to create a new differ capable of handling the sum of their values. It provides two overloads: one for curried usage and another for direct application with two parameters.

LANGUAGE: typescript
CODE:
declare const orElseEither: { <Value2, Patch2>(that: Differ<Value2, Patch2>): <Value, Patch>(self: Differ<Value, Patch>) => Differ<Either<Value2, Value>, Differ.Or.Patch<Value, Value2, Patch, Patch2>>; <Value, Patch, Value2, Patch2>(self: Differ<Value, Patch>, that: Differ<Value2, Patch2>): Differ<Either<Value2, Value>, Differ.Or.Patch<Value, Value2, Patch, Patch2>>; }

----------------------------------------

TITLE: Using constFalse Function in TypeScript
DESCRIPTION: Demonstrates how to use the constFalse function from the effect/Function module. This utility function is a thunk that always returns false when called.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { constFalse } from "effect/Function"

assert.deepStrictEqual(constFalse(), false)

LANGUAGE: typescript
CODE:
declare const constFalse: LazyArg<boolean>

----------------------------------------

TITLE: TypeScript Function Signature for Doc.tupled
DESCRIPTION: This code snippet shows the TypeScript function signature for the Doc.tupled function. It takes an Iterable of Doc<A> and returns a Doc<A>.

LANGUAGE: typescript
CODE:
declare const tupled: <A>(docs: Iterable<Doc<A>>) => Doc<A>

----------------------------------------

TITLE: Declaring throttleEffect Function in TypeScript
DESCRIPTION: Defines the throttleEffect function with two overloads. It takes options including cost function, units, duration, burst, and strategy to throttle a stream of data. The function can either enforce bandwidth constraints by dropping chunks or shape the stream by delaying chunks.

LANGUAGE: typescript
CODE:
declare const throttleEffect: { <A, E2, R2>(options: { readonly cost: (chunk: Chunk.Chunk<A>) => Effect.Effect<number, E2, R2>; readonly units: number; readonly duration: Duration.DurationInput; readonly burst?: number | undefined; readonly strategy?: "enforce" | "shape" | undefined; }): <E, R>(self: Stream<A, E, R>) => Stream<A, E2 | E, R2 | R>; <A, E, R, E2, R2>(self: Stream<A, E, R>, options: { readonly cost: (chunk: Chunk.Chunk<A>) => Effect.Effect<number, E2, R2>; readonly units: number; readonly duration: Duration.DurationInput; readonly burst?: number | undefined; readonly strategy?: "enforce" | "shape" | undefined; }): Stream<A, E | E2, R | R2>; }

----------------------------------------

TITLE: Using FiberHandle.join with Effect Generator
DESCRIPTION: Shows how to create a FiberHandle, set it with a failing Effect, and join it. Demonstrates error propagation where the parent fiber fails with the error from the child fiber.

LANGUAGE: typescript
CODE:
import { Effect, FiberHandle } from "effect";

Effect.gen(function* (_) {
  const handle = yield* _(FiberHandle.make());
  yield* _(FiberHandle.set(handle, Effect.runFork(Effect.fail("error"))));

  // parent fiber will fail with "error"
  yield* _(FiberHandle.join(handle));
});

----------------------------------------

TITLE: Patching FiberRef Values in TypeScript using Effect
DESCRIPTION: The patchFiberRefs function applies specified changes to the FiberRef values for the fiber running a workflow. It takes a FiberRefsPatch as an argument and returns an Effect of void.

LANGUAGE: typescript
CODE:
declare const patchFiberRefs: (patch: FiberRefsPatch.FiberRefsPatch) => Effect<void>

----------------------------------------

TITLE: Using firstSomeOf Function with Option in TypeScript
DESCRIPTION: Demonstrates how to use the firstSomeOf function to find the first Some value in an array of Options. This function efficiently iterates through a collection of Option values, returning the first Some encountered or None if no Some is found.

LANGUAGE: typescript
CODE:
import { Option } from "effect"

console.log(Option.firstSomeOf([
  Option.none(),
  Option.some(1),
  Option.some(2)
]))
// Output: { _id: 'Option', _tag: 'Some', value: 1 }

----------------------------------------

TITLE: Defining failCauseSync Function in TypeScript for Micro Module
DESCRIPTION: This snippet defines the failCauseSync function, which creates a Micro effect that fails with a lazily evaluated MicroCause. It takes a LazyArg of MicroCause<E> and returns a Micro<never, E>.

LANGUAGE: typescript
CODE:
declare const failCauseSync: <E>(evaluate: LazyArg<MicroCause<E>>) => Micro<never, E>

----------------------------------------

TITLE: Decoding Base64 URL String Function Declaration
DESCRIPTION: Function declaration for decoding base64 URL-encoded strings into UTF-8 strings. Returns an Either type containing either the decoded string or a DecodeException on failure.

LANGUAGE: typescript
CODE:
declare const decodeBase64UrlString: (str: string) => Either.Either<string, DecodeException>

----------------------------------------

TITLE: Creating a Stream from Repeating Effect Chunks in TypeScript
DESCRIPTION: The repeatEffectChunkOption function creates a stream from an effect that produces chunks of A values until it fails with None. It takes an Effect that returns a Chunk of A values and an Option of E error, and produces a Stream of A values that may fail with E error.

LANGUAGE: typescript
CODE:
declare const repeatEffectChunkOption: <A, E, R>(effect: Effect.Effect<Chunk.Chunk<A>, Option.Option<E>, R>) => Stream<A, E, R>

----------------------------------------

TITLE: Declaring cursorRestorePosition Function in TypeScript
DESCRIPTION: Defines a constant cursorRestorePosition of type AnsiDoc. This function restores the cursor position, encoding shift state, and formatting attributes from the previous save, or resets them to defaults if no previous save exists.

LANGUAGE: typescript
CODE:
declare const cursorRestorePosition: AnsiDoc

----------------------------------------

TITLE: TypeScript Signature for Stream.empty
DESCRIPTION: Provides the TypeScript type signature for the Stream.empty constant. It represents a Stream that never produces any values, never fails, and never requires any environment.

LANGUAGE: typescript
CODE:
declare const empty: Stream<never, never, never>

----------------------------------------

TITLE: Converting Cause<Option<E>> to Option<Cause<E>> in TypeScript
DESCRIPTION: A utility function that transforms a Cause containing optional errors into an optional Cause of errors. It filters out None failures and preserves other error cases, useful for handling optional error paths in effect-based applications.

LANGUAGE: typescript
CODE:
declare const flipCauseOption: <E>(self: Cause<Option.Option<E>>) => Option.Option<Cause<E>>

----------------------------------------

TITLE: Defining removeAll Function for TSet in TypeScript
DESCRIPTION: Declares the removeAll function which removes multiple elements from a TSet. It can be used in two ways: either by passing the TSet and iterable as separate arguments, or by passing the iterable first and then the TSet. The function returns an STM (Software Transactional Memory) operation that removes the elements when executed.

LANGUAGE: typescript
CODE:
declare const removeAll: { <A>(iterable: Iterable<A>): (self: TSet<A>) => STM.STM<void>; <A>(self: TSet<A>, iterable: Iterable<A>): STM.STM<void>; }

----------------------------------------

TITLE: Defining scheduleAddDelay Function in TypeScript
DESCRIPTION: Defines the scheduleAddDelay function, which takes a function that returns a number and a MicroSchedule, and returns a new MicroSchedule with an added calculated delay to each delay returned by the original schedule.

LANGUAGE: typescript
CODE:
declare const scheduleAddDelay: { (f: () => number): (self: MicroSchedule) => MicroSchedule; (self: MicroSchedule, f: () => number): MicroSchedule; }

----------------------------------------

TITLE: Generating Random Numbers in Range with TRandom.nextRange in TypeScript
DESCRIPTION: The nextRange function generates the next pseudo-random number within a specified range. It takes minimum and maximum values as parameters and returns an STM (Software Transactional Memory) effect that produces a number.

LANGUAGE: typescript
CODE:
declare const nextRange: (min: number, max: number) => STM.STM<number, never, TRandom>

----------------------------------------

TITLE: Trie.filterMap Function Signature in TypeScript
DESCRIPTION: Provides the TypeScript signature for the filterMap function in the Trie module. It shows the function's type definition and overloads.

LANGUAGE: typescript
CODE:
declare const filterMap: { <A, B>(f: (value: A, key: string) => Option<B>): (self: Trie<A>) => Trie<B>; <A, B>(self: Trie<A>, f: (value: A, key: string) => Option<B>): Trie<B>; }

----------------------------------------

TITLE: Getting Read Lock Count with TReentrantLock in TypeScript
DESCRIPTION: Function that returns an STM transaction which retrieves the total number of acquired read locks from a TReentrantLock instance. The function takes a TReentrantLock instance as input and returns an STM transaction that resolves to a number.

LANGUAGE: typescript
CODE:
declare const readLocks: (self: TReentrantLock) => STM.STM<number>

----------------------------------------

TITLE: Implementing Stream.runIntoQueueScoped in TypeScript
DESCRIPTION: Defines a function that runs a stream into a queue while providing scope composition capabilities. It takes a queue for storing stream elements and returns a scoped effect that manages the stream's lifecycle.

LANGUAGE: typescript
CODE:
declare const runIntoQueueScoped: {
  <A, E>(queue: Queue.Enqueue<Take.Take<A, E>>): <R>(self: Stream<A, E, R>) => Effect.Effect<void, never, Scope.Scope | R>;
  <A, E, R>(self: Stream<A, E, R>, queue: Queue.Enqueue<Take.Take<A, E>>): Effect.Effect<void, never, Scope.Scope | R>;
}

----------------------------------------

TITLE: Implementing Differ.zip Type Definition in TypeScript
DESCRIPTION: Defines a zip function that combines two Differ instances to create a new Differ that operates on tuples. The resulting differ can process pairs of values and patches from the original differs.

LANGUAGE: typescript
CODE:
declare const zip: { 
  <Value2, Patch2>(that: Differ<Value2, Patch2>): 
    <Value, Patch>(self: Differ<Value, Patch>) => 
      Differ<readonly [Value, Value2], readonly [Patch, Patch2]>; 
  <Value, Patch, Value2, Patch2>(
    self: Differ<Value, Patch>, 
    that: Differ<Value2, Patch2>
  ): Differ<readonly [Value, Value2], readonly [Patch, Patch2]>; 
}

----------------------------------------

TITLE: Defining Micro.scoped Function in TypeScript
DESCRIPTION: Declares the 'scoped' function that provides a MicroScope to a given effect, closing it after execution. It takes a Micro effect and returns a new Micro effect with the MicroScope excluded from its requirements.

LANGUAGE: typescript
CODE:
declare const scoped: <A, E, R>(self: Micro<A, E, R>) => Micro<A, E, Exclude<R, MicroScope>>

----------------------------------------

TITLE: Generating Capturing RegExp from TemplateLiteral AST in TypeScript
DESCRIPTION: The getTemplateLiteralCapturingRegExp function generates a regular expression that captures the pattern defined by a given TemplateLiteral AST. It is a variant of getTemplateLiteralRegExp that specifically captures the pattern.

LANGUAGE: typescript
CODE:
declare const getTemplateLiteralCapturingRegExp: (ast: TemplateLiteral) => RegExp

----------------------------------------

TITLE: Executing Async Effects with Callbacks in TypeScript Effect Runtime
DESCRIPTION: Function signature for runCallback that executes effects asynchronously and passes the exit value to a callback. Supports two overloads - one taking runtime and effect separately, and another combining them. Includes optional configuration through RunCallbackOptions and FiberId parameters.

LANGUAGE: typescript
CODE:
declare const runCallback: { 
  <R>(runtime: Runtime<R>): <A, E>(effect: Effect.Effect<A, E, R>, options?: RunCallbackOptions<A, E> | undefined) => (fiberId?: FiberId.FiberId, options?: RunCallbackOptions<A, E> | undefined) => void; 
  <R, A, E>(runtime: Runtime<R>, effect: Effect.Effect<A, E, R>, options?: RunCallbackOptions<A, E> | undefined): (fiberId?: FiberId.FiberId, options?: RunCallbackOptions<A, E> | undefined) => void; 
}

----------------------------------------

TITLE: Using isUint8Array Type Guard in TypeScript
DESCRIPTION: Example demonstrating how to use the isUint8Array type guard function to check if values are Uint8Array instances. The function returns true for Uint8Array instances and false for other types.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { isUint8Array } from "effect/Predicate"

assert.deepStrictEqual(isUint8Array(new Uint8Array()), true)

assert.deepStrictEqual(isUint8Array(null), false)
assert.deepStrictEqual(isUint8Array({}), false)

LANGUAGE: typescript
CODE:
declare const isUint8Array: (input: unknown) => input is Uint8Array

----------------------------------------

TITLE: Using Option.orElseSome in TypeScript
DESCRIPTION: Demonstrates how to use the Option.orElseSome function to provide a default value for None options or return existing Some values.

LANGUAGE: typescript
CODE:
import { Option } from "effect"

console.log(Option.none().pipe(Option.orElseSome(() => "b")))
// Output: { _id: 'Option', _tag: 'Some', value: 'b' }

console.log(Option.some("a").pipe(Option.orElseSome(() => "b")))
// Output: { _id: 'Option', _tag: 'Some', value: 'a' }

----------------------------------------

TITLE: Adding Time Units to DateTime in TypeScript
DESCRIPTION: Demonstrates how to use the DateTime.add function to add a specific amount of time units to a DateTime object. The example shows adding 5 minutes to a DateTime instance.

LANGUAGE: typescript
CODE:
import { DateTime } from "effect"

// add 5 minutes
DateTime.unsafeMake(0).pipe(
  DateTime.add({ minutes: 5 })
)

----------------------------------------

TITLE: Using Context.pick in TypeScript with effect Package
DESCRIPTION: This snippet demonstrates how to use Context.pick to create a new Context with only specified services. It shows the creation of a context with multiple services and then picking only one of them.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { pipe, Context, Option } from "effect"

const Port = Context.GenericTag<{ PORT: number }>("Port")
const Timeout = Context.GenericTag<{ TIMEOUT: number }>("Timeout")

const someContext = pipe(
  Context.make(Port, { PORT: 8080 }),
  Context.add(Timeout, { TIMEOUT: 5000 })
)

const Services = pipe(someContext, Context.pick(Port))

assert.deepStrictEqual(Context.getOption(Services, Port), Option.some({ PORT: 8080 }))
assert.deepStrictEqual(Context.getOption(Services, Timeout), Option.none())

----------------------------------------

TITLE: Implementing Error Handling with Micro.catchAll in TypeScript
DESCRIPTION: Type definition for the catchAll function that handles error recovery in Micro effects. It provides two overloads: one for curried form and another for standard two-parameter form. The function allows catching and handling expected errors by providing an error handler that returns a new Micro effect.

LANGUAGE: typescript
CODE:
declare const catchAll: {
  <E, B, E2, R2>(f: (e: NoInfer<E>) => Micro<B, E2, R2>): <A, R>(self: Micro<A, E, R>) => Micro<A | B, E2, R | R2>;
  <A, E, R, B, E2, R2>(self: Micro<A, E, R>, f: (e: NoInfer<E>) => Micro<B, E2, R2>): Micro<A | B, E2, R | R2>;
}

----------------------------------------

TITLE: Accessing TestClock Scheduled Times in TypeScript
DESCRIPTION: The sleeps function accesses a TestClock instance in the context and returns an Effect containing a Chunk of numbers representing the times that effects are scheduled to run. It's been available since version 2.0.0 of the package.

LANGUAGE: typescript
CODE:
declare const sleeps: () => Effect.Effect<Chunk.Chunk<number>>

----------------------------------------

TITLE: Creating Failing Take with Defect in TypeScript
DESCRIPTION: The die function creates a failing Take with the specified defect. It takes an unknown type as the defect parameter and returns a Take that never succeeds.

LANGUAGE: typescript
CODE:
declare const die: (defect: unknown) => Take<never>

----------------------------------------

TITLE: Implementing Cause Reduction with Context in TypeScript
DESCRIPTION: Function signature for reduceWithContext, which combines parts of a Cause into a single value using a custom reducer and context. It provides two overloads: one taking context and reducer first, another taking the Cause instance first. The function allows for stateful transformations and dynamic processing of Cause components.

LANGUAGE: typescript
CODE:
declare const reduceWithContext: { <C, E, Z>(context: C, reducer: CauseReducer<C, E, Z>): (self: Cause<E>) => Z; <C, E, Z>(self: Cause<E>, context: C, reducer: CauseReducer<C, E, Z>): Z; }

----------------------------------------

TITLE: Option.orElse Type Signature
DESCRIPTION: Type declaration for the orElse method showing its polymorphic nature and support for different type parameters.

LANGUAGE: typescript
CODE:
declare const orElse: { <B>(that: LazyArg<Option<B>>): <A>(self: Option<A>) => Option<B | A>; <A, B>(self: Option<A>, that: LazyArg<Option<B>>): Option<A | B>; }

----------------------------------------

TITLE: Trie.values Function Signature in Typescript
DESCRIPTION: The type signature for the Trie.values function, which takes a Trie<V> as input and returns an IterableIterator<V>.

LANGUAGE: typescript
CODE:
declare const values: <V>(self: Trie<V>) => IterableIterator<V>

----------------------------------------

TITLE: Calculating Least Common Multiple of BigInts in TypeScript
DESCRIPTION: This snippet demonstrates how to use the lcm function from the effect/BigInt module to calculate the least common multiple of two bigint values. It includes examples with different input pairs and their expected results.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { lcm } from "effect/BigInt"

assert.deepStrictEqual(lcm(2n, 3n), 6n)
assert.deepStrictEqual(lcm(2n, 4n), 4n)
assert.deepStrictEqual(lcm(16n, 24n), 48n)

----------------------------------------

TITLE: Implementing zipRight Operation for FlatMap Typeclass in TypeScript
DESCRIPTION: Defines the zipRight operation for the FlatMap typeclass. This operation is a variant of flatMap that ignores the value produced by the first effect and returns the second effect. It handles generic types and supports both curried and uncurried forms.

LANGUAGE: typescript
CODE:
declare const zipRight: <F extends TypeLambda>(F: FlatMap<F>) => { <R2, O2, E2, B>(that: Kind<F, R2, O2, E2, B>): <R1, O1, E1, _>(self: Kind<F, R1, O1, E1, _>) => Kind<F, R1 & R2, O2 | O1, E2 | E1, B>; <R1, O1, E1, _, R2, O2, E2, B>(self: Kind<F, R1, O1, E1, _>, that: Kind<F, R2, O2, E2, B>): Kind<F, R1 & R2, O1 | O2, E1 | E2, B>; }

----------------------------------------

TITLE: Defining DateTimeUtcFromNumber Schema Class in TypeScript
DESCRIPTION: Declares a schema class that converts number values to DateTime.Utc instances using the DateTime.unsafeMake constructor. This schema is part of the Effect-TS library's Schema module.

LANGUAGE: typescript
CODE:
declare class DateTimeUtcFromNumber

----------------------------------------

TITLE: Checking for PopAnnotationStream in TypeScript
DESCRIPTION: This function determines if a given DocStream is of type PopAnnotationStream. It takes a DocStream<A> as input and returns a boolean indicating whether it's a PopAnnotationStream<A>. This is useful for type narrowing and conditional logic based on DocStream types.

LANGUAGE: typescript
CODE:
declare const isPopAnnotationStream: <A>(self: DocStream<A>) => self is PopAnnotationStream<A>

----------------------------------------

TITLE: Defining fillSep Function in TypeScript for @effect/printer Doc Module
DESCRIPTION: The fillSep function is a combinator that concatenates documents horizontally with spaces, wrapping to new lines when exceeding page width. It takes an Iterable of Doc<A> and returns a Doc<A>.

LANGUAGE: typescript
CODE:
declare const fillSep: <A>(docs: Iterable<Doc<A>>) => Doc<A>

----------------------------------------

TITLE: Type Signature for isSymbol Function in TypeScript
DESCRIPTION: This code snippet shows the TypeScript type signature for the isSymbol function. It defines isSymbol as a function that takes an unknown input and returns a boolean indicating if the input is a symbol.

LANGUAGE: typescript
CODE:
declare const isSymbol: (u: unknown) => u is symbol

----------------------------------------

TITLE: Implementing Array Intersection with Custom Equivalence in TypeScript
DESCRIPTION: Demonstrates how to use Array.intersectionWith to find common elements between two arrays of objects based on a custom equivalence function. The function returns an array of unique values included in all given Iterables.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const array1 = [{ id: 1 }, { id: 2 }, { id: 3 }]
const array2 = [{ id: 3 }, { id: 4 }, { id: 1 }]
const isEquivalent = (a: { id: number }, b: { id: number }) => a.id === b.id
const result = Array.intersectionWith(isEquivalent)(array2)(array1)
console.log(result) // [{ id: 1 }, { id: 3 }]

----------------------------------------

TITLE: Implementing BigDecimal Equality Comparison in TypeScript
DESCRIPTION: Function declaration for comparing two BigDecimal values for equality. The function is overloaded to support both curried and non-curried calling styles.

LANGUAGE: typescript
CODE:
declare const equals: { (that: BigDecimal): (self: BigDecimal) => boolean; (self: BigDecimal, that: BigDecimal): boolean; }

----------------------------------------

TITLE: Defining Application-Generated Database Fields in TypeScript using Effect SQL
DESCRIPTION: A utility function that creates a field representation for columns that are generated by the application but required by the database. This is useful for handling fields that should be excluded from JSON variants while maintaining database schema requirements.

LANGUAGE: typescript
CODE:
declare const GeneratedByApp: <S extends Schema.Schema.All | Schema.PropertySignature.All>(schema: S) => GeneratedByApp<S>

----------------------------------------

TITLE: Declaring Sufficient Samples Constant in TypeScript for Effect Package
DESCRIPTION: Defines a constant 'samples' as an Effect that returns the number of sufficient samples to check for a random variable. The Effect has no requirements and cannot fail (never error type).

LANGUAGE: typescript
CODE:
declare const samples: Effect.Effect<number, never, never>

----------------------------------------

TITLE: Testing Symbol Type with Effect Predicate
DESCRIPTION: Demonstrates how to use the isSymbol predicate function to check if a value is a symbol type. The function returns true for Symbol instances and false for other types.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { isSymbol } from "effect/Predicate"

assert.deepStrictEqual(isSymbol(Symbol.for("a")), true)

assert.deepStrictEqual(isSymbol("a"), false)

LANGUAGE: typescript
CODE:
declare const isSymbol: (input: unknown) => input is symbol

----------------------------------------

TITLE: Type Signature of Brand.refined Function in TypeScript
DESCRIPTION: Provides the type signature for the Brand.refined function, showing its overloaded nature for different input types and return values.

LANGUAGE: typescript
CODE:
declare const refined: { <A extends Brand<any>>(f: (unbranded: Brand.Unbranded<A>) => Option.Option<Brand.BrandErrors>): Brand.Constructor<A>; <A extends Brand<any>>(refinement: Predicate<Brand.Unbranded<A>>, onFailure: (unbranded: Brand.Unbranded<A>) => Brand.BrandErrors): Brand.Constructor<A>; }

----------------------------------------

TITLE: Retrieving Queue Capacity in TypeScript
DESCRIPTION: Function signature for getting the capacity of a queue. Takes either a Dequeue or Enqueue queue instance as input and returns a number representing the maximum elements the queue can hold.

LANGUAGE: typescript
CODE:
declare const capacity: <A>(self: Dequeue<A> | Enqueue<A>) => number

----------------------------------------

TITLE: Defining Secret Argument in TypeScript for Effect CLI
DESCRIPTION: Creates a text argument for sensitive input, optionally allowing a custom argument name. It returns an Args<Secret> type. The default argument name is 'secret' if not specified.

LANGUAGE: typescript
CODE:
declare const secret: (config?: Args.BaseArgsConfig) => Args<Secret>

----------------------------------------

TITLE: Creating Take with Chunk in TypeScript
DESCRIPTION: This function creates a Take with the specified chunk. It takes a Chunk of type A as input and returns a Take of type A.

LANGUAGE: typescript
CODE:
declare const chunk: <A>(chunk: Chunk.Chunk<A>) => Take<A>

----------------------------------------

TITLE: Using catWithSoftLineBreak in TypeScript with @effect/printer
DESCRIPTION: Demonstrates how to use the catWithSoftLineBreak combinator to concatenate two documents with a soft line break. The example shows the output with different rendering options.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import { pipe } from "effect/Function"
import * as String from "effect/String"

const doc: Doc.Doc<never> = pipe(
  Doc.char("a"),
  Doc.catWithSoftLineBreak(Doc.char("b"))
)

assert.strictEqual(
  Doc.render(doc, { style: "pretty" }),
  "ab"
)

assert.strictEqual(
  Doc.render(doc, {
    style: "pretty",
    options: { lineWidth: 1 }
  }),
  String.stripMargin(
    `|a
     |b`
  )
)

----------------------------------------

TITLE: Implementing collectAllN Sink in TypeScript
DESCRIPTION: A TypeScript function signature for creating a sink that collects the first n elements into a chunk. The sink takes a number parameter and returns a Sink type that processes input elements into a chunk collection.

LANGUAGE: typescript
CODE:
declare const collectAllN: <In>(n: number) => Sink<Chunk.Chunk<In>, In, In>

----------------------------------------

TITLE: Implementing SemigroupMax for BigInt in TypeScript
DESCRIPTION: Demonstrates the usage of SemigroupMax from @effect/typeclass/data/BigInt to find the maximum of two BigInt values. The SemigroupMax is a Semigroup instance that combines BigInt values by selecting the larger one.

LANGUAGE: typescript
CODE:
import { SemigroupMax } from "@effect/typeclass/data/BigInt"

console.log(SemigroupMax.combine(2n, 3n))
// 3n

LANGUAGE: typescript
CODE:
declare const SemigroupMax: semigroup.Semigroup<bigint>

----------------------------------------

TITLE: Testing Tagged Objects with Effect Predicate
DESCRIPTION: Demonstrates the usage of isTagged function to check if a value is an object with a specific _tag property. The function supports both curried and uncurried calling styles and provides type safety through TypeScript.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { isTagged } from "effect/Predicate"

assert.deepStrictEqual(isTagged(1, "a"), false)
assert.deepStrictEqual(isTagged(null, "a"), false)
assert.deepStrictEqual(isTagged({}, "a"), false)
assert.deepStrictEqual(isTagged({ a: "a" }, "a"), false)
assert.deepStrictEqual(isTagged({ _tag: "a" }, "a"), true)
assert.deepStrictEqual(isTagged("a")({ _tag: "a" }), true)

LANGUAGE: typescript
CODE:
declare const isTagged: { <K extends string>(tag: K): (self: unknown) => self is { _tag: K; }; <K extends string>(self: unknown, tag: K): self is { _tag: K; }; }

----------------------------------------

TITLE: Mapping Exit Success Values in TypeScript
DESCRIPTION: The 'as' function maps the Success value of an Exit to a provided constant value. It can be used in two ways: either by providing the value first and then the Exit, or by providing the Exit first and then the value.

LANGUAGE: typescript
CODE:
declare const as: { <A2>(value: A2): <A, E>(self: Exit<A, E>) => Exit<A2, E>; <A, E, A2>(self: Exit<A, E>, value: A2): Exit<A2, E>; }

----------------------------------------

TITLE: Implementing Filterable partitionMapComposition in TypeScript
DESCRIPTION: Implements a default binary partitionMap composition function for Filterable typeclass. Takes Covariant and Filterable instances and returns a function that partitions and maps values using Either type.

LANGUAGE: typescript
CODE:
declare const partitionMapComposition: <F extends TypeLambda, G extends TypeLambda>(F: Covariant<F>, G: Filterable<G>) => <FR, FO, FE, GR, GO, GE, A, B, C>(self: Kind<F, FR, FO, FE, Kind<G, GR, GO, GE, A>>, f: (a: A) => Either.Either<C, B>) => [Kind<F, FR, FO, FE, Kind<G, GR, GO, GE, B>>, Kind<F, FR, FO, FE, Kind<G, GR, GO, GE, C>>]

----------------------------------------

TITLE: Implementing suspend Function in Effect Micro Module
DESCRIPTION: Function signature for suspend that lazily creates a Micro effect by taking a side-effect evaluation function. It accepts a LazyArg that returns a Micro effect and returns a new Micro effect with the same type parameters.

LANGUAGE: typescript
CODE:
declare const suspend: <A, E, R>(evaluate: LazyArg<Micro<A, E, R>>) => Micro<A, E, R>

----------------------------------------

TITLE: Implementing First Semigroup in TypeScript
DESCRIPTION: Creates a Semigroup instance that always returns the first argument in a combination operation. This is a generic implementation that works with any type A.

LANGUAGE: typescript
CODE:
declare const first: <A = never>() => Semigroup<A>

----------------------------------------

TITLE: Implementing Stack Trace Addition in TypeScript Micro Effects
DESCRIPTION: Function signature for withTrace, which takes a name parameter and adds stack traces to any failures occurring in a Micro effect. The traces are stored in the traces field of the MicroCause object.

LANGUAGE: typescript
CODE:
declare const withTrace: { 
  (name: string): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E, R>; 
  <A, E, R>(self: Micro<A, E, R>, name: string): Micro<A, E, R>; 
}

----------------------------------------

TITLE: Creating Zoned DateTime - Effect Library TypeScript
DESCRIPTION: Demonstrates how to create a DateTime.Zoned instance using unsafeMakeZoned with timezone specification. The function accepts a DateTime input and options for timezone and adjustment settings.

LANGUAGE: typescript
CODE:
import { DateTime } from "effect"

DateTime.unsafeMakeZoned(new Date(), { timeZone: "Europe/London" })

LANGUAGE: typescript
CODE:
declare const unsafeMakeZoned: (input: DateTime.Input, options?: { readonly timeZone?: number | string | TimeZone | undefined; readonly adjustForTimeZone?: boolean | undefined; }) => Zoned

----------------------------------------

TITLE: Using greaterThanOrEqualTo with BigDecimal in TypeScript
DESCRIPTION: Demonstrates how to use the greaterThanOrEqualTo function to compare BigDecimal values. The function accepts two BigDecimal values and returns a boolean indicating if the first value is greater than or equal to the second value.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { greaterThanOrEqualTo, unsafeFromString } from "effect/BigDecimal"

assert.deepStrictEqual(greaterThanOrEqualTo(unsafeFromString("2"), unsafeFromString("3")), false)
assert.deepStrictEqual(greaterThanOrEqualTo(unsafeFromString("3"), unsafeFromString("3")), true)
assert.deepStrictEqual(greaterThanOrEqualTo(unsafeFromString("4"), unsafeFromString("3")), true)

LANGUAGE: typescript
CODE:
declare const greaterThanOrEqualTo: { (that: BigDecimal): (self: BigDecimal) => boolean; (self: BigDecimal, that: BigDecimal): boolean; }

----------------------------------------

TITLE: Implementing Cartesian Product with Custom Combiner in TypeScript
DESCRIPTION: Demonstrates how to use Array.cartesianWith to create a cartesian product of two arrays with a custom combining function. The function takes two arrays and a combiner function to produce all possible combinations.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const result = Array.cartesianWith([1, 2], ["a", "b"], (a, b) => `${a}-${b}`)
console.log(result) // ["1-a", "1-b", "2-a", "2-b"]

LANGUAGE: typescript
CODE:
declare const cartesianWith: { <A, B, C>(that: ReadonlyArray<B>, f: (a: A, b: B) => C): (self: ReadonlyArray<A>) => Array<C>; <A, B, C>(self: ReadonlyArray<A>, that: ReadonlyArray<B>, f: (a: A, b: B) => C): Array<C>; }

----------------------------------------

TITLE: Declaring Doc.rparen Constant in TypeScript
DESCRIPTION: Declares a constant named 'rparen' of type Doc<never>, representing a document containing a single ')' character. This is part of the @effect/printer package's Doc module.

LANGUAGE: typescript
CODE:
declare const rparen: Doc<never>

----------------------------------------

TITLE: Defining Option Property Transformation Function in TypeScript
DESCRIPTION: TypeScript type declaration for optionalToOptional function that transforms optional properties between schemas. It takes source and target schemas along with decode/encode transformation functions that operate on Option types.

LANGUAGE: typescript
CODE:
declare const optionalToOptional: <FA, FI, FR, TA, TI, TR>(
  from: Schema<FA, FI, FR>,
  to: Schema<TA, TI, TR>,
  options: {
    readonly decode: (o: option_.Option<FA>) => option_.Option<TI>;
    readonly encode: (o: option_.Option<TI>) => option_.Option<FA>;
  }
) => PropertySignature<"?:", TA, never, "?:", FI, false, FR | TR>

----------------------------------------

TITLE: Defining Command Interface in TypeScript
DESCRIPTION: Defines the core Command interface that represents a command in a command-line application. The interface extends Command.Variance<A> and Pipeable, providing the foundation for implementing CLI commands.

LANGUAGE: typescript
CODE:
export interface Command<A> extends Command.Variance<A>, Pipeable {}

----------------------------------------

TITLE: Retrieving Scoped Reference Value in TypeScript
DESCRIPTION: The 'get' function retrieves the current value of a scoped reference. It takes a ScopedRef<A> as input and returns an Effect that resolves to the value of type A.

LANGUAGE: typescript
CODE:
declare const get: <A>(self: ScopedRef<A>) => Effect.Effect<A>

----------------------------------------

TITLE: Defining TimeZoneNamedFromSelf Schema Class in TypeScript
DESCRIPTION: Declares a schema class that represents a TimeZone.Named instance in the Effect library. This class is used for type-safe handling of named timezone representations.

LANGUAGE: typescript
CODE:
declare class TimeZoneNamedFromSelf

----------------------------------------

TITLE: Effect.filterMap Function Signature in TypeScript
DESCRIPTION: This code block shows the TypeScript signature of the filterMap function. It defines the function's type and parameters, illustrating how it can be used with different Effect types and filtering predicates.

LANGUAGE: typescript
CODE:
declare const filterMap: { <Eff extends Effect<any, any, any>, B>(pf: (a: Effect.Success<Eff>) => Option.Option<B>): (elements: Iterable<Eff>) => Effect<Array<B>, Effect.Error<Eff>, Effect.Context<Eff>>; <Eff extends Effect<any, any, any>, B>(elements: Iterable<Eff>, pf: (a: Effect.Success<Eff>) => Option.Option<B>): Effect<Array<B>, Effect.Error<Eff>, Effect.Context<Eff>>; }

----------------------------------------

TITLE: SemigroupSum Type Definition in TypeScript
DESCRIPTION: Provides the type signature for the SemigroupSum constant. It is defined as a Semigroup for numbers, which means it provides a way to combine numbers (in this case, through addition).

LANGUAGE: typescript
CODE:
declare const SemigroupSum: semigroup.Semigroup<number>

----------------------------------------

TITLE: Implementing Sink.failCause in TypeScript
DESCRIPTION: Creates a sink that halts with a specified Cause. This function is part of the Effect library's Sink module and allows creation of failing sinks with custom error causes.

LANGUAGE: typescript
CODE:
declare const failCause: <E>(cause: Cause.Cause<E>) => Sink<never, unknown, never, E>

----------------------------------------

TITLE: Creating No-op FileSystem Layer in TypeScript
DESCRIPTION: The layerNoop function creates a no-op file system that can be used for testing. It takes a partial FileSystem object as input and returns a Layer<FileSystem>.

LANGUAGE: typescript
CODE:
declare const layerNoop: (fileSystem: Partial<FileSystem>) => Layer<FileSystem>

----------------------------------------

TITLE: Defining HttpApiEndpoint Interface in TypeScript
DESCRIPTION: TypeScript interface definition for HttpApiEndpoint that represents an API endpoint with configurable route parameters, request/response schemas, and middleware support. Includes methods for adding success/error responses, setting request parameters, and configuring middleware.

LANGUAGE: typescript
CODE:
export interface HttpApiEndpoint<
  out Name extends string,
  out Method extends HttpMethod,
  in out Path = never,
  in out UrlParams = never,
  in out Payload = never,
  in out Headers = never,
  in out Success = void,
  in out Error = never,
  out R = never,
  out RE = never
> extends Pipeable {
  readonly [TypeId]: TypeId
  readonly name: Name
  readonly path: PathSegment
  readonly method: Method
  readonly pathSchema: Option.Option<Schema.Schema<Path, unknown, R>>
  readonly urlParamsSchema: Option.Option<Schema.Schema<UrlParams, unknown, R>>
  readonly payloadSchema: Option.Option<Schema.Schema<Payload, unknown, R>>
  readonly headersSchema: Option.Option<Schema.Schema<Headers, unknown, R>>
  readonly successSchema: Schema.Schema<Success, unknown, R>
  readonly errorSchema: Schema.Schema<Error, unknown, RE>
  readonly annotations: Context.Context<never>
  readonly middlewares: ReadonlySet<HttpApiMiddleware.TagClassAny>

  addSuccess<S extends Schema.Schema.Any>(
    schema: S,
    annotations?: {
      readonly status?: number | undefined
    }
  ): HttpApiEndpoint<Name, Method, Path, UrlParams, Payload, Headers, Exclude<Success, void> | Schema.Schema.Type<S>, Error, R | Schema.Schema.Context<S>, RE>

  addError<E extends Schema.Schema.Any>(
    schema: E,
    annotations?: {
      readonly status?: number | undefined
    }
  ): HttpApiEndpoint<Name, Method, Path, UrlParams, Payload, Headers, Success, Error | Schema.Schema.Type<E>, R, RE | Schema.Schema.Context<E>>

  setPayload<P extends Schema.Schema.Any>(
    schema: P & HttpApiEndpoint.ValidatePayload<Method, P>
  ): HttpApiEndpoint<Name, Method, Path, UrlParams, Schema.Schema.Type<P>, Headers, Success, Error, R | Schema.Schema.Context<P>, RE>

  setPath<Path extends Schema.Schema.Any>(
    schema: Path & HttpApiEndpoint.ValidatePath<Path>
  ): HttpApiEndpoint<Name, Method, Schema.Schema.Type<Path>, UrlParams, Payload, Headers, Success, Error, R | Schema.Schema.Context<Path>, RE>

  setUrlParams<UrlParams extends Schema.Schema.Any>(
    schema: UrlParams & HttpApiEndpoint.ValidateUrlParams<UrlParams>
  ): HttpApiEndpoint<Name, Method, Path, Schema.Schema.Type<UrlParams>, Payload, Headers, Success, Error, R | Schema.Schema.Context<Path>, RE>

  setHeaders<H extends Schema.Schema.Any>(
    schema: H & HttpApiEndpoint.ValidateHeaders<H>
  ): HttpApiEndpoint<Name, Method, Path, UrlParams, Payload, Schema.Schema.Type<H>, Success, Error, R | Schema.Schema.Context<H>, RE>

  prefix(
    prefix: PathSegment
  ): HttpApiEndpoint<Name, Method, Path, UrlParams, Payload, Headers, Success, Error, R, RE>

  middleware<I extends HttpApiMiddleware.HttpApiMiddleware.AnyId, S>(
    middleware: Context.Tag<I, S>
  ): HttpApiEndpoint<Name, Method, Path, UrlParams, Payload, Headers, Success, Error | HttpApiMiddleware.HttpApiMiddleware.Error<I>, R | I, RE | HttpApiMiddleware.HttpApiMiddleware.ErrorContext<I>>

  annotate<I, S>(
    tag: Context.Tag<I, S>,
    value: S
  ): HttpApiEndpoint<Name, Method, Path, UrlParams, Payload, Headers, Success, Error, R, RE>

  annotateContext<I>(
    context: Context.Context<I>
  ): HttpApiEndpoint<Name, Method, Path, UrlParams, Payload, Headers, Success, Error, R, RE>
}

----------------------------------------

TITLE: Defining Repeatable Command-Line Options in TypeScript for Effect CLI
DESCRIPTION: The 'repeated' function is used to indicate that a specified command-line option can be repeated 0 or more times. If the option is not provided, an empty array will be returned as the value. This function takes an Options<A> and returns an Options<Array<A>>.

LANGUAGE: typescript
CODE:
declare const repeated: <A>(self: Options<A>) => Options<Array<A>>

----------------------------------------

TITLE: Modifying Last Element of NonEmptyArray in TypeScript
DESCRIPTION: Function that applies a transformation to the last element of a non-empty array while preserving the non-empty array type constraint. Takes a transformation function and returns a new array with the last element modified.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const result = Array.modifyNonEmptyLast([1, 2, 3], n => n * 2)
console.log(result) // [1, 2, 6]

LANGUAGE: typescript
CODE:
declare const modifyNonEmptyLast: { <A, B>(f: (a: A) => B): (self: NonEmptyReadonlyArray<A>) => NonEmptyArray<A | B>; <A, B>(self: NonEmptyReadonlyArray<A>, f: (a: A) => B): NonEmptyArray<A | B>; }

----------------------------------------

TITLE: Optimizing Document Layout in TypeScript using @effect/printer
DESCRIPTION: Demonstrates the use of the optimize function from the Optimize module to combine text nodes for more efficient rendering. It compares an inefficient document layout with multiple entries to an optimized version with a single entry in the output DocStream.

LANGUAGE: typescript
CODE:
import * as Doc from "@effect/printer/Doc"
import * as Optimize from "@effect/printer/Optimize"

// The document below contains a chain of four entries in the output `DocStream`
const inefficient = Doc.hsep([
  Doc.char("a"),
  Doc.char("b"),
  Doc.char("c"),
  Doc.char("d")
])

// However, the above document is fully equivalent to the tightly packed
// document below which is only a single entry in the output `DocStream` and
// can be processed much more efficiently.
const efficient = Doc.text("abcd")

// We can optimize the `inefficient` document using `Optimize`
Optimize.optimize(Optimize.Deep)(inefficient)

----------------------------------------

TITLE: Checking if a Fiber is a RuntimeFiber in TypeScript
DESCRIPTION: This function determines whether a given Fiber is a RuntimeFiber. It takes a Fiber as input and returns a boolean indicating if it's a RuntimeFiber. The function uses TypeScript's type predicate feature for type narrowing.

LANGUAGE: typescript
CODE:
declare const isRuntimeFiber: <A, E>(self: Fiber<A, E>) => self is RuntimeFiber<A, E>

----------------------------------------

TITLE: Zipping Stream Elements with Indices in TypeScript using Effect
DESCRIPTION: Demonstrates how to use the Stream.zipWithIndex function to pair each element of a stream with its index. The example creates a stream of names, zips it with indices, and then collects and logs the result.

LANGUAGE: typescript
CODE:
import { Effect, Stream } from "effect"

const stream = Stream.make("Mary", "James", "Robert", "Patricia")

const indexedStream = Stream.zipWithIndex(stream)

Effect.runPromise(Stream.runCollect(indexedStream)).then(console.log)
// {
//   _id: 'Chunk',
//   values: [ [ 'Mary', 0 ], [ 'James', 1 ], [ 'Robert', 2 ], [ 'Patricia', 3 ] ]
// }

----------------------------------------

TITLE: Disabling Tracer for Effect in TypeScript
DESCRIPTION: This example demonstrates how to use Effect.withTracerEnabled to disable the tracer for a specific Effect. It creates an Effect that succeeds with 42, adds a span named 'my-span', and then disables the tracer for this Effect.

LANGUAGE: typescript
CODE:
import { Effect } from "effect"

Effect.succeed(42).pipe(
  Effect.withSpan("my-span"),
  // the span will not be registered with the tracer
  Effect.withTracerEnabled(false)
)

----------------------------------------

TITLE: Setting Minimum Log Level in TypeScript using effect Package
DESCRIPTION: This snippet demonstrates how to use the Logger.minimumLogLevel function to disable logging in an Effect program. It creates a program that logs a message, sleeps, and then logs to the console. The minimumLogLevel is set to None, effectively disabling all logging except the console.log.

LANGUAGE: typescript
CODE:
import { Effect, Logger, LogLevel } from "effect"

const program = Effect.gen(function*() {
  yield* Effect.log("Executing task...")
  yield* Effect.sleep("100 millis")
  console.log("task done")
})

// Logging disabled using a layer
Effect.runFork(program.pipe(Effect.provide(Logger.minimumLogLevel(LogLevel.None))))
// task done

----------------------------------------

TITLE: Implementing Parallel Sink Execution in TypeScript
DESCRIPTION: The 'race' function runs two sinks in parallel on the input, returning the result or error from the one that finishes first. It supports various type parameters for flexible usage.

LANGUAGE: typescript
CODE:
declare const race: { <R1, E1, In1, L1, A1>(that: Sink<A1, In1, L1, E1, R1>): <A, In, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A1 | A, In & In1, L1 | L, E1 | E, R1 | R>; <A, In, L, E, R, A1, In1, L1, E1, R1>(self: Sink<A, In, L, E, R>, that: Sink<A1, In1, L1, E1, R1>): Sink<A | A1, In & In1, L | L1, E | E1, R | R1>; }

----------------------------------------

TITLE: Implementing Error Handler for Forked Effects in TypeScript
DESCRIPTION: Defines a function that forks an Effect with custom error handling. Similar to fork but allows specifying a handler function for error cases. The handler takes an error of type E and returns an Effect of type X.

LANGUAGE: typescript
CODE:
declare const forkWithErrorHandler: { 
  <E, X>(handler: (e: E) => Effect<X>): <A, R>(self: Effect<A, E, R>) => Effect<Fiber.RuntimeFiber<A, E>, never, R>; 
  <A, E, R, X>(self: Effect<A, E, R>, handler: (e: E) => Effect<X>): Effect<Fiber.RuntimeFiber<A, E>, never, R>; 
}

----------------------------------------

TITLE: Checking Queue Type in TypeScript
DESCRIPTION: The isQueue function is a type guard that determines if a given value is a Queue. It takes an unknown input and returns a boolean indicating whether the input is a Queue of unknown type.

LANGUAGE: typescript
CODE:
declare const isQueue: (u: unknown) => u is Queue<unknown>

----------------------------------------

TITLE: Declaring eraseDown Function in AnsiDoc Module (TypeScript)
DESCRIPTION: Declares the eraseDown constant of type AnsiDoc. This function clears the screen from the current cursor position to the end, without changing the cursor position.

LANGUAGE: typescript
CODE:
declare const eraseDown: AnsiDoc

----------------------------------------

TITLE: Creating SQL Resolver with findById in TypeScript
DESCRIPTION: Creates a resolver that resolves results by ID using Effect.Effect. Supports both contextual and non-contextual execution with schema validation for IDs and results. Returns an Effect wrapped SqlResolver that produces Option<A> results.

LANGUAGE: typescript
CODE:
declare const findById: <T extends string, I, II, RI, A, IA, Row, E, RA = never, R = never>(
  tag: T,
  options: {
    readonly Id: Schema.Schema<I, II, RI>;
    readonly Result: Schema.Schema<A, IA>;
    readonly ResultId: (result: Types.NoInfer<A>, row: Types.NoInfer<Row>) => I;
    readonly execute: (requests: Array<Types.NoInfer<II>>) => Effect.Effect<ReadonlyArray<Row>, E>;
    readonly withContext?: false;
  } | {
    readonly Id: Schema.Schema<I, II, RI>;
    readonly Result: Schema.Schema<A, IA, RA>;
    readonly ResultId: (result: Types.NoInfer<A>, row: Types.NoInfer<Row>) => I;
    readonly execute: (requests: Array<Types.NoInfer<II>>) => Effect.Effect<ReadonlyArray<Row>, E, R>;
    readonly withContext: true;
  }) => Effect.Effect<SqlResolver<T, I, Option.Option<A>, E, RI>, never, RA | R>

----------------------------------------

TITLE: Using Predicate.and for String Length Validation in TypeScript
DESCRIPTION: Demonstrates how to combine two predicates using Predicate.and to create a validator that checks if a string's length is exactly a specified value. The example shows combining minLength and maxLength predicates.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Predicate } from "effect"

const minLength = (n: number) => (s: string) => s.length >= n
const maxLength = (n: number) => (s: string) => s.length <= n

const length = (n: number) => Predicate.and(minLength(n), maxLength(n))

assert.deepStrictEqual(length(2)("aa"), true)
assert.deepStrictEqual(length(2)("a"), false)
assert.deepStrictEqual(length(2)("aaa"), false)

----------------------------------------

TITLE: Defining runFoldScopedEffect Function in TypeScript for Effect Library
DESCRIPTION: Declares the runFoldScopedEffect function, which performs an effectful fold over a stream. It takes an initial state, a folding function, and a stream as inputs. The function returns an Effect that represents the final folded state and manages the stream's scope.

LANGUAGE: typescript
CODE:
declare const runFoldScopedEffect: { <S, A, E2, R2>(s: S, f: (s: S, a: A) => Effect.Effect<S, E2, R2>): <E, R>(self: Stream<A, E, R>) => Effect.Effect<S, E2 | E, Scope.Scope | R2 | R>; <A, E, R, S, E2, R2>(self: Stream<A, E, R>, s: S, f: (s: S, a: A) => Effect.Effect<S, E2, R2>): Effect.Effect<S, E | E2, Scope.Scope | R | R2>; }

----------------------------------------

TITLE: Defining fail Document Type in TypeScript
DESCRIPTION: Defines a constant 'fail' that represents a document that cannot be rendered, typically occurring when flattening a line. The layout algorithms will reject this document and choose alternative rendering options.

LANGUAGE: typescript
CODE:
declare const fail: Doc<never>

----------------------------------------

TITLE: Implementing Option.partitionMap in TypeScript
DESCRIPTION: Function declaration for partitionMap that splits an Option into two Options based on a mapping function returning Either. Takes an Option<A> and mapping function (a: A) => Either<C, B> and returns a tuple of [Option<B>, Option<C>]. Supports both curried and uncurried calling styles.

LANGUAGE: typescript
CODE:
declare const partitionMap: { 
  <A, B, C>(f: (a: A) => Either<C, B>): (self: Option<A>) => [left: Option<B>, right: Option<C>];
  <A, B, C>(self: Option<A>, f: (a: A) => Either<C, B>): [left: Option<B>, right: Option<C>];
}

----------------------------------------

TITLE: Creating Exit.Failure for Interrupted Workflows in TypeScript
DESCRIPTION: Function that constructs a new Exit.Failure instance from a FiberId, used to indicate that a Fiber running an Effect workflow was terminated due to interruption. Takes a FiberId parameter and returns an Exit type with never as the success type.

LANGUAGE: typescript
CODE:
declare const interrupt: (fiberId: FiberId.FiberId) => Exit<never>

----------------------------------------

TITLE: Creating Global Cache with Effect GlobalValue
DESCRIPTION: Demonstrates how to create a persistent global cache using the globalValue function. The cache persists across module reloads and multiple imports, with the value being computed only once.

LANGUAGE: typescript
CODE:
import { globalValue } from "effect/GlobalValue"

// This cache will persist as long as the module is running,
// even if reloaded or imported elsewhere
const myCache = globalValue(
  Symbol.for("myCache"),
  () => new WeakMap<object, number>()
)

----------------------------------------

TITLE: Implementing Config.repeat Function in TypeScript
DESCRIPTION: Function signature for creating a configuration that describes a sequence of values. Takes a Config<A> and returns a Config containing an array of those values.

LANGUAGE: typescript
CODE:
declare const repeat: <A>(self: Config<A>) => Config<Array<A>>

----------------------------------------

TITLE: HashMap Entry Type Signature
DESCRIPTION: Type definition showing the structure of the Entry type utility. Takes a HashMap type parameter T and returns a tuple type containing the key and value types.

LANGUAGE: typescript
CODE:
type Entry<T> = [Key<T>, Value<T>]

----------------------------------------

TITLE: Implementing Close Type Guard for ChildExecutorDecision in TypeScript
DESCRIPTION: Type guard function that checks if a ChildExecutorDecision instance is specifically a Close type. Returns true if the decision is Close, false otherwise. Used for type narrowing in TypeScript.

LANGUAGE: typescript
CODE:
declare const isClose: (self: ChildExecutorDecision) => self is Close

----------------------------------------

TITLE: Implementing Channel Flatten Operation in TypeScript
DESCRIPTION: Defines a flatten operation that takes a channel containing another channel as its terminal value and flattens it into a single channel. The operation preserves type safety through complex generic type parameters that handle the input/output elements, errors, and environment types of both the outer and inner channels.

LANGUAGE: typescript
CODE:
declare const flatten: <OutElem, InElem, OutErr, InErr, OutElem1, InElem1, OutErr1, InErr1, OutDone2, InDone1, Env1, InDone, Env>(self: Channel<OutElem, InElem, OutErr, InErr, Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone2, InDone1, Env1>, InDone, Env>) => Channel<OutElem | OutElem1, InElem & InElem1, OutErr | OutErr1, InErr & InErr1, OutDone2, InDone & InDone1, Env1 | Env>

----------------------------------------

TITLE: Predicate.or Type Signature in TypeScript
DESCRIPTION: Type declaration for the Predicate.or function showing its polymorphic nature. It supports both Refinement and Predicate types with various type parameters.

LANGUAGE: typescript
CODE:
declare const or: { <A, C extends A>(that: Refinement<A, C>): <B extends A>(self: Refinement<A, B>) => Refinement<A, B | C>; <A, B extends A, C extends A>(self: Refinement<A, B>, that: Refinement<A, C>): Refinement<A, B | C>; <A>(that: Predicate<A>): (self: Predicate<A>) => Predicate<A>; <A>(self: Predicate<A>, that: Predicate<A>): Predicate<A>; }

----------------------------------------

TITLE: Defining Result Utility Type for Request Objects in TypeScript
DESCRIPTION: This code snippet defines a utility type named Result that extracts the result type from a Request object. It uses conditional types to infer the success (A) and error (E) types from the Request generic type.

LANGUAGE: typescript
CODE:
type Result<T> = T extends Request<infer A, infer E> ? Exit.Exit<A, E> : never

----------------------------------------

TITLE: Setting Parent Span Context in Effect using OpenTelemetry
DESCRIPTION: Function that allows setting an effect's parent span from an existing OpenTelemetry SpanContext. This is useful when OpenTelemetry is configured outside Effect and you need to attach to a parent span. The function supports both curried and non-curried calling styles.

LANGUAGE: typescript
CODE:
declare const withSpanContext: {
  (spanContext: Otel.SpanContext): <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, Exclude<R, ParentSpan>>;
  <A, E, R>(effect: Effect<A, E, R>, spanContext: Otel.SpanContext): Effect<A, E, Exclude<R, ParentSpan>>;
}

----------------------------------------

TITLE: Retrieving Entries with Prefix from Trie in TypeScript
DESCRIPTION: Demonstrates how to use the toEntriesWithPrefix function to retrieve entries from a Trie data structure that have a specific prefix. The function returns an array of key-value pairs.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Trie } from "effect"

const trie = Trie.empty<number>().pipe(
  Trie.insert("shells", 0),
  Trie.insert("sells", 1),
  Trie.insert("sea", 2),
  Trie.insert("she", 3)
)

const result = Trie.toEntriesWithPrefix(trie, "she")
assert.deepStrictEqual(result, [["she", 3], ["shells", 0]])

----------------------------------------

TITLE: Implementing Cursor Backward Movement in TypeScript with AnsiDoc
DESCRIPTION: Function that moves the cursor backward by a specified number of columns in an ANSI-compatible terminal. If no column count is specified, defaults to 1. The movement is bounded by the screen edge.

LANGUAGE: typescript
CODE:
declare const cursorBackward: (columns?: number) => AnsiDoc

----------------------------------------

TITLE: Checking UpstreamPullStrategy Type in TypeScript
DESCRIPTION: This function determines if a given value is an UpstreamPullStrategy. It takes an unknown value as input and returns a boolean indicating whether the value is of type UpstreamPullStrategy<unknown>.

LANGUAGE: typescript
CODE:
declare const isUpstreamPullStrategy: (u: unknown) => u is UpstreamPullStrategy<unknown>

----------------------------------------

TITLE: Decoding Base64 URL-encoded Strings in TypeScript
DESCRIPTION: This function decodes a base64 URL-encoded string into a Uint8Array. It returns an Either type, which can contain either the decoded Uint8Array or a DecodeException if the decoding fails.

LANGUAGE: typescript
CODE:
declare const decodeBase64Url: (str: string) => Either.Either<Uint8Array, DecodeException>

----------------------------------------

TITLE: Retrieving FiberRef Values with getOrDefault in TypeScript
DESCRIPTION: The getOrDefault function retrieves the value of a specified FiberRef from a collection of FiberRef values. If the specified FiberRef doesn't exist in the collection, it returns the initial value of the FiberRef. This function supports both curried and uncurried calling styles.

LANGUAGE: typescript
CODE:
declare const getOrDefault: { <A>(fiberRef: FiberRef.FiberRef<A>): (self: FiberRefs) => A; <A>(self: FiberRefs, fiberRef: FiberRef.FiberRef<A>): A; }

----------------------------------------

TITLE: Checking for ConcatTree in TypeScript
DESCRIPTION: The isConcatTree function is a type guard that checks if a given DocTree is specifically a ConcatTree. It returns true if the input is a ConcatTree, and false otherwise. This function is useful for type narrowing in conditional logic.

LANGUAGE: typescript
CODE:
declare const isConcatTree: <A>(self: DocTree<A>) => self is ConcatTree<A>

----------------------------------------

TITLE: Implementing Atomic Set Union in TypeScript using TSet
DESCRIPTION: Defines a union operation that atomically combines two TSets. The operation takes another TSet as input and transforms the current set into the union of both sets using STM transactions.

LANGUAGE: typescript
CODE:
declare const union: { <A>(other: TSet<A>): (self: TSet<A>) => STM.STM<void>; <A>(self: TSet<A>, other: TSet<A>): STM.STM<void>; }

----------------------------------------

TITLE: Implementing GroupBy.first Function in TypeScript
DESCRIPTION: Defines the 'first' function in the GroupBy module. It limits the number of groups considered in a Stream to the first 'n' groups found. The function has two overloads to support different calling styles.

LANGUAGE: typescript
CODE:
declare const first: { (n: number): <K, V, E, R>(self: GroupBy<K, V, E, R>) => GroupBy<K, V, E, R>; <K, V, E, R>(self: GroupBy<K, V, E, R>, n: number): GroupBy<K, V, E, R>; }

----------------------------------------

TITLE: Implementing Maximum Value Comparison in TypeScript using Effect Order
DESCRIPTION: Function signature for comparing two values using an Order instance to determine the maximum value. Takes an Order<A> instance and returns a function that can compare two values of type A, returning the larger value according to the ordering. If values are considered equal, returns the first argument.

LANGUAGE: typescript
CODE:
declare const max: <A>(O: Order<A>) => { (that: A): (self: A) => A; (self: A, that: A): A; }

----------------------------------------

TITLE: Declaring collectAllWhileWith Function in TypeScript
DESCRIPTION: Defines a function that repeatedly runs a sink while results satisfy a predicate, accumulating results using a stepping function. Takes initial state, predicate condition, and accumulator function as parameters.

LANGUAGE: typescript
CODE:
declare const collectAllWhileWith: { <A, S>(options: { readonly initial: S; readonly while: Predicate<A>; readonly body: (s: S, a: A) => S; }): <In, L extends In, E, R>(self: Sink<A, In, L, E, R>) => Sink<S, In, L, E, R>; <A, In, L extends In, E, R, S>(self: Sink<A, In, L, E, R>, options: { readonly initial: S; readonly while: Predicate<A>; readonly body: (s: S, a: A) => S; }): Sink<S, In, L, E, R>; }

----------------------------------------

TITLE: Implementing Default imap for Contravariant Functor in TypeScript
DESCRIPTION: Defines a function that returns a default imap implementation for contravariant functors. It takes a contramap function as input and returns an implementation that satisfies the Invariant typeclass requirements.

LANGUAGE: typescript
CODE:
declare const imap: <F extends TypeLambda>(contramap: <R, O, E, A, B>(self: Kind<F, R, O, E, A>, f: (b: B) => A) => Kind<F, R, O, E, B>) => Invariant<F>["imap"]

----------------------------------------

TITLE: Implementing Sink.succeed in TypeScript
DESCRIPTION: A TypeScript function that creates a sink which immediately succeeds with the provided value. This is a utility function for creating simple sinks that complete instantly with a given value of type A.

LANGUAGE: typescript
CODE:
declare const succeed: <A>(a: A) => Sink<A, unknown>

----------------------------------------

TITLE: TypeScript Function Signature for withCurrentZoneOffset in DateTime Module
DESCRIPTION: This code block provides the TypeScript function signature for the withCurrentZoneOffset function. It shows two overloads: one that takes an offset and returns a function, and another that takes both an effect and an offset.

LANGUAGE: typescript
CODE:
declare const withCurrentZoneOffset: { (offset: number): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, Exclude<R, CurrentTimeZone>>; <A, E, R>(effect: Effect.Effect<A, E, R>, offset: number): Effect.Effect<A, E, Exclude<R, CurrentTimeZone>>; }

----------------------------------------

TITLE: Implementing Logical Implication for Predicates in TypeScript
DESCRIPTION: This snippet demonstrates the usage of the 'implies' function from the Predicate module. It shows how to create a predicate that checks the transitive property of order using logical implication.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Predicate } from "effect"

type Triple = {
  readonly a: number
  readonly b: number
  readonly c: number
}

const transitivity = Predicate.implies(
  // antecedent
  (input: Triple) => input.a <= input.b && input.b <= input.c,
  // consequent
  (input: Triple) => input.a <= input.c
)

assert.equal(transitivity({ a: 1, b: 2, c: 3 }), true)
// antecedent is `false`, so the result is `true`
assert.equal(transitivity({ a: 1, b: 0, c: 0 }), true)

----------------------------------------

TITLE: Modifying Document Annotations in TypeScript
DESCRIPTION: The alterAnnotations function changes the annotation of a document to a different annotation or removes it entirely. It takes a function that transforms annotations and applies it to a DocTree structure.

LANGUAGE: typescript
CODE:
declare const alterAnnotations: { <A, B>(f: (a: A) => Iterable<B>): (self: DocTree<A>) => DocTree<B>; <A, B>(self: DocTree<A>, f: (a: A) => Iterable<B>): DocTree<B>; }

----------------------------------------

TITLE: Implementing Error Tracking in Effect Operations using Metric.trackError
DESCRIPTION: Defines a function that creates an aspect to track error metrics in Effect operations. The function can be used in two ways: either by passing the metric first and then the effect, or by passing the effect first and then the metric. It works with effects that have error types extending the metric's input type.

LANGUAGE: typescript
CODE:
declare const trackError: { <Type, In, Out>(metric: Metric<Type, In, Out>): <A, E extends In, R>(self: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; <A, E extends In, R, Type, In, Out>(self: Effect.Effect<A, E, R>, metric: Metric<Type, In, Out>): Effect.Effect<A, E, R>; }

----------------------------------------

TITLE: Creating RuntimeFlagsPatch for Enabling RuntimeFlag in TypeScript
DESCRIPTION: The enable function creates a RuntimeFlagsPatch that describes enabling the provided RuntimeFlag. It takes a RuntimeFlag as input and returns a RuntimeFlagsPatch.

LANGUAGE: typescript
CODE:
declare const enable: (flag: RuntimeFlags.RuntimeFlag) => RuntimeFlagsPatch

----------------------------------------

TITLE: Implementing Scheduled Task Execution in TypeScript with Effect
DESCRIPTION: Function signature for scheduleForked that runs an effect repeatedly on a new fiber according to a schedule. It returns a RuntimeFiber that can be used to monitor the execution. The function supports both curried and uncurried parameter passing styles.

LANGUAGE: typescript
CODE:
declare const scheduleForked: { <Out, R2>(schedule: Schedule.Schedule<Out, unknown, R2>): <A, E, R>(self: Effect<A, E, R>) => Effect<Fiber.RuntimeFiber<Out, E>, never, Scope.Scope | R2 | R>; <A, E, R, Out, R2>(self: Effect<A, E, R>, schedule: Schedule.Schedule<Out, unknown, R2>): Effect<Fiber.RuntimeFiber<Out, E>, never, Scope.Scope | R | R2>; }

----------------------------------------

TITLE: Checking Queue Shutdown Status in TypeScript
DESCRIPTION: Function that checks whether a queue has been shut down. Takes either a Dequeue or Enqueue instance as input and returns an Effect containing a boolean value indicating the shutdown status.

LANGUAGE: typescript
CODE:
declare const isShutdown: <A>(self: Dequeue<A> | Enqueue<A>) => Effect.Effect<boolean>

----------------------------------------

TITLE: Implementing Annotation Modification in TypeScript for Effect Printer
DESCRIPTION: Function declaration for alterAnnotations that allows changing, removing, or replacing document annotations. It accepts a mapping function that transforms annotations of type A to multiple annotations of type B, and can be used either in curried or direct form.

LANGUAGE: typescript
CODE:
declare const alterAnnotations: { <A, B>(f: (a: A) => Iterable<B>): (self: Doc<A>) => Doc<B>; <A, B>(self: Doc<A>, f: (a: A) => Iterable<B>): Doc<B>; }

----------------------------------------

TITLE: Shutting Down PubSub in Effect-TS
DESCRIPTION: Function that interrupts any fibers suspended on offer or take operations in a PubSub instance. After shutdown, any subsequent offer or take operations will be immediately interrupted.

LANGUAGE: typescript
CODE:
declare const shutdown: <A>(self: PubSub<A>) => Effect.Effect<void>

----------------------------------------

TITLE: Implementing Deferred.completeWith in TypeScript Effect Package
DESCRIPTION: Defines a function that completes a deferred with the result of a specified effect. The function returns a boolean Effect indicating whether the completion was successful. If the deferred has already been completed, it returns false.

LANGUAGE: typescript
CODE:
declare const completeWith: {
  <A, E>(effect: Effect.Effect<A, E>): (self: Deferred<A, E>) => Effect.Effect<boolean>;
  <A, E>(self: Deferred<A, E>, effect: Effect.Effect<A, E>): Effect.Effect<boolean>;
}

----------------------------------------

TITLE: Implementing STM Context Access in TypeScript
DESCRIPTION: A function that provides access to the transaction environment allowing execution of STM operations with context. Takes a function that receives Context<R0> and returns an STM operation, composing them into a new STM operation that includes both the original and context requirements.

LANGUAGE: typescript
CODE:
declare const contextWithSTM: <R0, A, E, R>(f: (environment: Context.Context<R0>) => STM<A, E, R>) => STM<A, E, R0 | R>

----------------------------------------

TITLE: Creating FiberRefs Diff Patch in TypeScript
DESCRIPTION: Creates a patch object that captures the differences between two collections of FiberRef values. This function compares oldValue and newValue FiberRefs collections to generate a patch describing their changes.

LANGUAGE: typescript
CODE:
declare const diff: (oldValue: FiberRefs.FiberRefs, newValue: FiberRefs.FiberRefs) => FiberRefsPatch

----------------------------------------

TITLE: Transforming Schedule Input and Output in TypeScript
DESCRIPTION: The mapBoth function modifies an existing schedule by applying transformations to both its input and output values. It allows mapping the schedule to work with different input types while also modifying its outputs.

LANGUAGE: typescript
CODE:
declare const mapBoth: { <In2, In, Out, Out2>(options: { readonly onInput: (in2: In2) => In; readonly onOutput: (out: Out) => Out2; }): <R>(self: Schedule<Out, In, R>) => Schedule<Out2, In2, R>; <Out, In, R, In2, Out2>(self: Schedule<Out, In, R>, options: { readonly onInput: (in2: In2) => In; readonly onOutput: (out: Out) => Out2; }): Schedule<Out2, In2, R>; }

----------------------------------------

TITLE: Initializing TSet with Specified Values in TypeScript
DESCRIPTION: The make function creates a new TSet initialized with the provided elements. It returns an STM.STM object containing the newly created TSet. The function is generic, allowing for various element types.

LANGUAGE: typescript
CODE:
declare const make: <Elements extends Array<any>>(...elements: Elements) => STM.STM<TSet<Elements[number]>>

----------------------------------------

TITLE: Using HashMap Entry Type Extraction in TypeScript
DESCRIPTION: Example demonstrating how to use HashMap.HashMap.Entry to extract the [K, V] entry type from a HashMap<K, V> instance. Shows type inference with string keys and number values.

LANGUAGE: typescript
CODE:
import { HashMap } from "effect"

declare const hm: HashMap.HashMap<string, number>

// $ExpectType [string, number]
type V = HashMap.HashMap.Entry<typeof hm>

----------------------------------------

TITLE: Setting Security Cookie with HttpApiBuilder in TypeScript
DESCRIPTION: Demonstrates how to use HttpApiBuilder.securitySetCookie to set a cookie from an HttpApiSecurity.HttpApiKey instance before returning a response from an endpoint handler.

LANGUAGE: typescript
CODE:
handlers.handle(
  "authenticate",
  (_) => HttpApiBuilder.securitySetCookie(security, "secret123")
)

----------------------------------------

TITLE: Creating Semigroup for ReadonlyArray in TypeScript
DESCRIPTION: The array function creates and returns a Semigroup for ReadonlyArray<A>. This Semigroup combines two arrays by concatenating them. It takes no parameters and returns a Semigroup for ReadonlyArray<A>.

LANGUAGE: TypeScript
CODE:
declare const array: <A>() => Semigroup<ReadonlyArray<A>>

----------------------------------------

TITLE: Setting Values in ScopedRef with Resource Management in TypeScript
DESCRIPTION: The set method assigns a new value to a ScopedRef, managing resources and handling potential errors. It ensures that old resources are released and new ones are acquired atomically. The method is overloaded to accept either the ScopedRef as the first argument or as part of a curried function.

LANGUAGE: typescript
CODE:
declare const set: { <A, R, E>(acquire: Effect.Effect<A, E, R>): (self: ScopedRef<A>) => Effect.Effect<void, E, Exclude<R, Scope.Scope>>; <A, R, E>(self: ScopedRef<A>, acquire: Effect.Effect<A, E, R>): Effect.Effect<void, E, Exclude<R, Scope.Scope>>; }

----------------------------------------

TITLE: Defining orTry Function for STM in TypeScript
DESCRIPTION: Declares the orTry function which tries one effect and falls back to another if the first enters retry state. It's equivalent to Haskell's orElse. The function is overloaded to handle different parameter orders.

LANGUAGE: typescript
CODE:
declare const orTry: { <A1, E1, R1>(that: LazyArg<STM<A1, E1, R1>>): <A, E, R>(self: STM<A, E, R>) => STM<A1 | A, E1 | E, R1 | R>; <A, E, R, A1, E1, R1>(self: STM<A, E, R>, that: LazyArg<STM<A1, E1, R1>>): STM<A | A1, E | E1, R | R1>; }

----------------------------------------

TITLE: Implementing TMap Entry Retention in TypeScript
DESCRIPTION: Function signature for retainIf operation that filters TMap entries based on a predicate. Supports both discarding and returning removed entries. The predicate takes a key and value parameter and returns a boolean indicating whether to retain the entry.

LANGUAGE: typescript
CODE:
declare const retainIf: { 
  <K, V>(predicate: (key: K, value: V) => boolean, options: { readonly discard: true; }): (self: TMap<K, V>) => STM.STM<void>; 
  <K, V>(predicate: (key: K, value: V) => boolean, options?: { readonly discard: false; }): (self: TMap<K, V>) => STM.STM<Array<[K, V]>>; 
  <K, V>(self: TMap<K, V>, predicate: (key: K, value: V) => boolean, options: { readonly discard: true; }): STM.STM<void>; 
  <K, V>(self: TMap<K, V>, predicate: (key: K, value: V) => boolean, options?: { readonly discard: false; }): STM.STM<Array<[K, V]>>; 
}

----------------------------------------

TITLE: Polling Deferred Status in Effect-TS TypeScript
DESCRIPTION: Function that checks if a Deferred has been completed and returns Some<Effect<A, E, R>> if completed, or None if not completed. Takes a Deferred<A, E> as input and returns an Effect containing an Option of another Effect.

LANGUAGE: typescript
CODE:
declare const poll: <A, E>(self: Deferred<A, E>) => Effect.Effect<Option.Option<Effect.Effect<A, E>>>

----------------------------------------

TITLE: Setting Cookies in TypeScript using @effect/platform
DESCRIPTION: Defines a function 'set' for adding a cookie to a Cookies object. It takes a name, value, and optional options, returning an Either type that represents success or failure.

LANGUAGE: typescript
CODE:
declare const set: { (name: string, value: string, options?: Cookie["options"]): (self: Cookies) => Either.Either<Cookies, CookiesError>; (self: Cookies, name: string, value: string, options?: Cookie["options"]): Either.Either<Cookies, CookiesError>; }

----------------------------------------

TITLE: Creating Stream from Mailbox in TypeScript
DESCRIPTION: The toStream function creates a Stream from a ReadonlyMailbox. It takes a ReadonlyMailbox<A, E> as input and returns a Stream<A, E>.

LANGUAGE: typescript
CODE:
declare const toStream: <A, E>(self: ReadonlyMailbox<A, E>) => Stream<A, E>

----------------------------------------

TITLE: Zipping Sorted Streams by Key with Custom Handlers in TypeScript
DESCRIPTION: Defines a function 'zipAllSortedByKeyWith' that zips two streams sorted by distinct keys. It takes options for handling cases where keys exist in either or both streams, and an order for comparing keys. The function works in constant space for potentially unbounded streams.

LANGUAGE: typescript
CODE:
declare const zipAllSortedByKeyWith: { <K, A2, E2, R2, A, A3>(options: { readonly other: Stream<readonly [K, A2], E2, R2>; readonly onSelf: (a: A) => A3; readonly onOther: (a2: A2) => A3; readonly onBoth: (a: A, a2: A2) => A3; readonly order: Order.Order<K>; }): <E, R>(self: Stream<readonly [K, A], E, R>) => Stream<[K, A3], E2 | E, R2 | R>; <K, A, E, R, A2, E2, R2, A3>(self: Stream<readonly [K, A], E, R>, options: { readonly other: Stream<readonly [K, A2], E2, R2>; readonly onSelf: (a: A) => A3; readonly onOther: (a2: A2) => A3; readonly onBoth: (a: A, a2: A2) => A3; readonly order: Order.Order<K>; }): Stream<[K, A3], E | E2, R | R2>; }

----------------------------------------

TITLE: Defining setHostname Function for URL Domain Modification in TypeScript
DESCRIPTION: Declares a function setHostname that updates the domain of a URL without modifying the port. It can be used in two ways: either by passing the hostname and then the URL, or by passing the URL and then the hostname.

LANGUAGE: typescript
CODE:
declare const setHostname: { (hostname: string): (url: URL) => URL; (url: URL, hostname: string): URL; }

----------------------------------------

TITLE: Implementing Synchronous Deferred Failure in TypeScript
DESCRIPTION: Function signature for failSync that allows failing a Deferred with a specified error. The error is propagated to all fibers waiting on the Deferred's value. Supports both curried and uncurried calling styles.

LANGUAGE: typescript
CODE:
declare const failSync: { <E>(evaluate: LazyArg<E>): <A>(self: Deferred<A, E>) => Effect.Effect<boolean>; <A, E>(self: Deferred<A, E>, evaluate: LazyArg<E>): Effect.Effect<boolean>; }

----------------------------------------

TITLE: Adding Finalizer to Scope in TypeScript
DESCRIPTION: The addFinalizer function adds a finalizer to a scope, which is guaranteed to run when the scope is closed. It's useful when the finalizer doesn't need to know the Exit value of the closed scope.

LANGUAGE: typescript
CODE:
declare const addFinalizer: (self: Scope, finalizer: Effect.Effect<unknown>) => Effect.Effect<void>

----------------------------------------

TITLE: Using Layer Function with Effect and Vitest in TypeScript
DESCRIPTION: Demonstrates how to use the layer function with Effect and Vitest. It shows the creation of Foo and Bar classes with Live layers, and how to use them in nested test scenarios.

LANGUAGE: typescript
CODE:
import { expect, layer } from "@effect/vitest"
import { Context, Effect, Layer } from "effect"

class Foo extends Context.Tag("Foo")<Foo, "foo">() {
  static Live = Layer.succeed(Foo, "foo")
}

class Bar extends Context.Tag("Bar")<Bar, "bar">() {
  static Live = Layer.effect(
    Bar,
    Effect.map(Foo, () => "bar" as const)
  )
}

layer(Foo.Live)("layer", (it) => {
  it.effect("adds context", () =>
    Effect.gen(function* () {
      const foo = yield* Foo
      expect(foo).toEqual("foo")
    })
  )

  it.layer(Bar.Live)("nested", (it) => {
    it.effect("adds context", () =>
      Effect.gen(function* () {
        const foo = yield* Foo
        const bar = yield* Bar
        expect(foo).toEqual("foo")
        expect(bar).toEqual("bar")
      })
    )
  })
})

----------------------------------------

TITLE: Defining Command Input Type in TypeScript
DESCRIPTION: Configures the pipe that is established between the parent and child processes' stdin stream. It uses a type alias to CommandInput.

LANGUAGE: typescript
CODE:
type Input = CommandInput

----------------------------------------

TITLE: Defining Prompt Handlers Interface in TypeScript
DESCRIPTION: Defines the Handlers interface for managing prompts in a CLI. It includes methods for rendering frames, processing user input, and clearing the terminal screen.

LANGUAGE: typescript
CODE:
export interface Handlers<State, Output> {
    readonly render: (
      state: State,
      action: Action<State, Output>
    ) => Effect<string, never, Environment>
    readonly process: (
      input: UserInput,
      state: State
    ) => Effect<Action<State, Output>, never, Environment>
    readonly clear: (
      state: State,
      action: Action<State, Output>
    ) => Effect<string, never, Environment>
  }

----------------------------------------

TITLE: Demonstrating Option.contains Usage in TypeScript
DESCRIPTION: This code snippet demonstrates how to use the Option.contains function to check if an Option contains a specific value. It shows examples with Some and None values.

LANGUAGE: typescript
CODE:
import { Option } from "effect"

console.log(Option.some(2).pipe(Option.contains(2)))
// Output: true

console.log(Option.some(1).pipe(Option.contains(2)))
// Output: false

console.log(Option.none().pipe(Option.contains(2)))
// Output: false

----------------------------------------

TITLE: Implementing intercalate Function for Semigroup in TypeScript
DESCRIPTION: The intercalate function returns a new Semigroup instance that combines values with a given separator. It takes a Semigroup instance and a separator value as input. This function is useful for operations like concatenating an array of strings with a specific separator between each element.

LANGUAGE: typescript
CODE:
declare const intercalate: { <A>(separator: A): (S: Semigroup<A>) => Semigroup<A>; <A>(S: Semigroup<A>, separator: A): Semigroup<A>; }

----------------------------------------

TITLE: Retrieving Original Error in TypeScript using Effect's Cause Module
DESCRIPTION: The originalError function retrieves the original, unproxied error instance from an error object. It's useful for accessing native error properties without library-specific wrapping, aiding in detailed debugging or integration with external systems.

LANGUAGE: typescript
CODE:
declare const originalError: <E>(obj: E) => E

----------------------------------------

TITLE: Implementing Map Collection Sink in TypeScript using Effect
DESCRIPTION: A sink implementation that collects inputs into a HashMap. It uses a key extraction function to determine map keys and a merge function to handle duplicate keys. The sink processes inputs of type In and produces a HashMap<K, In> as output.

LANGUAGE: typescript
CODE:
declare const collectAllToMap: <In, K>(key: (input: In) => K, merge: (x: In, y: In) => In) => Sink<HashMap.HashMap<K, In>, In>

----------------------------------------

TITLE: Base64 URL Encoding Function Definition in TypeScript
DESCRIPTION: Function signature for encoding Uint8Array or string input into base64 URL format. The function takes either a Uint8Array buffer or a string as input and returns a base64 URL-encoded string.

LANGUAGE: typescript
CODE:
declare const encodeBase64Url: (input: Uint8Array | string) => string

----------------------------------------

TITLE: Defining failSync Function in TypeScript for effect Package
DESCRIPTION: Declares a constant failSync function that creates a sink which always fails with a lazily evaluated error. It takes a LazyArg<E> as input and returns a Sink that never succeeds, accepts any input, produces no output, and fails with an error of type E.

LANGUAGE: typescript
CODE:
declare const failSync: <E>(evaluate: LazyArg<E>) => Sink<never, unknown, never, E>

----------------------------------------

TITLE: Declaring unsafeGet Function for HashMap in TypeScript
DESCRIPTION: Defines the unsafeGet function for unsafe value lookup in a HashMap using the internal hashing function. It supports two overloads: one that takes a key and returns a function, and another that takes both the HashMap and key directly.

LANGUAGE: typescript
CODE:
declare const unsafeGet: { <K1>(key: K1): <K, V>(self: HashMap<K, V>) => V; <K, V, K1>(self: HashMap<K, V>, key: K1): V; }

----------------------------------------

TITLE: Using tagStartsWith for Discriminated Union Matching in TypeScript
DESCRIPTION: Demonstrates how to use the tagStartsWith function to match values in a discriminated union based on the _tag field prefix. This example shows matching for tags 'A', 'B', and 'A.A'.

LANGUAGE: typescript
CODE:
import { Match, pipe } from "effect"

const match = pipe(
  Match.type<{ _tag: "A" } | { _tag: "B" } | { _tag: "A.A" } | {}>,
  Match.tagStartsWith("A", (_) => 1 as const),
  Match.tagStartsWith("B", (_) => 2 as const),
  Match.orElse((_) => 3 as const)
)

console.log(match({ _tag: "A" })) // 1
console.log(match({ _tag: "B" })) // 2
console.log(match({ _tag: "A.A" })) // 1

----------------------------------------

TITLE: Creating ConfigProvider from JSON in TypeScript
DESCRIPTION: Function signature for constructing a new ConfigProvider instance from a JSON object. The function accepts an unknown type parameter and returns a ConfigProvider instance.

LANGUAGE: typescript
CODE:
declare const fromJson: (json: unknown) => ConfigProvider

----------------------------------------

TITLE: Converting DateTime to Unix Epoch Milliseconds in TypeScript
DESCRIPTION: The toEpochMillis function takes a DateTime object and returns the number of milliseconds since the Unix epoch. It is part of the DateTime module in the Effect package.

LANGUAGE: typescript
CODE:
declare const toEpochMillis: (self: DateTime) => number

----------------------------------------

TITLE: Updating URL Username in TypeScript
DESCRIPTION: The setUsername function updates the username used for authentication in a URL. It can be called with either a username and URL, or a URL followed by a username.

LANGUAGE: typescript
CODE:
declare const setUsername: { (username: string): (url: URL) => URL; (url: URL, username: string): URL; }

----------------------------------------

TITLE: Defining Differ.update Function in TypeScript
DESCRIPTION: Constructs a differ that compares two values by returning a function to set the new value. This differ doesn't support combining multiple updates compositionally and should only be used when there's no compositional way to update values.

LANGUAGE: typescript
CODE:
declare const update: <A>() => Differ<A, (a: A) => A>

----------------------------------------

TITLE: Array.group Function Signature in TypeScript
DESCRIPTION: Provides the TypeScript signature for the Array.group function. It takes a NonEmptyReadonlyArray<A> as input and returns a NonEmptyArray<NonEmptyArray<A>>.

LANGUAGE: typescript
CODE:
declare const group: <A>(self: NonEmptyReadonlyArray<A>) => NonEmptyArray<NonEmptyArray<A>>

----------------------------------------

TITLE: Checking RuntimeFlag Status in TypeScript
DESCRIPTION: Function signature for isActive method that determines if a RuntimeFlag is marked as active within a RuntimeFlagsPatch. Supports both curried and direct two-parameter calling styles.

LANGUAGE: typescript
CODE:
declare const isActive: { (flag: RuntimeFlagsPatch): (self: RuntimeFlagsPatch) => boolean; (self: RuntimeFlagsPatch, flag: RuntimeFlagsPatch): boolean; }

----------------------------------------

TITLE: Defining Sequential ExecutionStrategy in TypeScript
DESCRIPTION: Declares a constant 'sequential' of type ExecutionStrategy. This strategy is used to execute effects sequentially.

LANGUAGE: typescript
CODE:
declare const sequential: ExecutionStrategy

----------------------------------------

TITLE: Layer Match Function Type Definition - TypeScript
DESCRIPTION: Type definition for the Layer.match function that handles both success and failure cases of a layer. The function takes options for handling both error and success scenarios, returning a new composed layer. It supports two overloads - one with options as the first parameter and another with the layer as the first parameter.

LANGUAGE: typescript
CODE:
declare const match: { 
  <E, A2, E2, R2, A, A3, E3, R3>(
    options: { 
      readonly onFailure: (error: E) => Layer<A2, E2, R2>; 
      readonly onSuccess: (context: Context.Context<A>) => Layer<A3, E3, R3>; 
    }
  ): <R>(self: Layer<A, E, R>) => Layer<A2 & A3, E2 | E3, R2 | R3 | R>; 
  <A, E, R, A2, E2, R2, A3, E3, R3>(
    self: Layer<A, E, R>, 
    options: { 
      readonly onFailure: (error: E) => Layer<A2, E2, R2>; 
      readonly onSuccess: (context: Context.Context<A>) => Layer<A3, E3, R3>; 
    }
  ): Layer<A2 & A3, E2 | E3, R | R2 | R3>; 
}

----------------------------------------

TITLE: Declaring combineChunks Function in TypeScript
DESCRIPTION: Defines the combineChunks function that combines chunks from two streams using a specified combining function. It allows for maintaining internal state during the combining process.

LANGUAGE: typescript
CODE:
declare const combineChunks: { <A2, E2, R2, S, R3, E, A, R4, R5, A3>(that: Stream<A2, E2, R2>, s: S, f: (s: S, pullLeft: Effect.Effect<Chunk.Chunk<A>, Option.Option<E>, R3>, pullRight: Effect.Effect<Chunk.Chunk<A2>, Option.Option<E2>, R4>) => Effect.Effect<Exit.Exit<readonly [Chunk.Chunk<A3>, S], Option.Option<E2 | E>>, never, R5>): <R>(self: Stream<A, E, R>) => Stream<A3, E2 | E, R2 | R3 | R4 | R5 | R>; <R, A2, E2, R2, S, R3, E, A, R4, R5, A3>(self: Stream<A, E, R>, that: Stream<A2, E2, R2>, s: S, f: (s: S, pullLeft: Effect.Effect<Chunk.Chunk<A>, Option.Option<E>, R3>, pullRight: Effect.Effect<Chunk.Chunk<A2>, Option.Option<E2>, R4>) => Effect.Effect<Exit.Exit<readonly [Chunk.Chunk<A3>, S], Option.Option<E2 | E>>, never, R5>): Stream<A3, E2 | E, R | R2 | R3 | R4 | R5>; }

----------------------------------------

TITLE: Getting Set Cardinality in TSet Module
DESCRIPTION: A TypeScript function signature that defines a method to get the size of a transactional set (TSet). The function returns an STM (Software Transactional Memory) operation that resolves to a number representing the set's cardinality.

LANGUAGE: typescript
CODE:
declare const size: <A>(self: TSet<A>) => STM.STM<number>

----------------------------------------

TITLE: RegExp.isRegExp Type Definition
DESCRIPTION: Type signature for the isRegExp function that performs type checking. The function takes an unknown input and returns a type predicate indicating if the input is a RegExp.

LANGUAGE: typescript
CODE:
declare const isRegExp: (input: unknown) => input is RegExp

----------------------------------------

TITLE: Using Option.isOption Type Guard in TypeScript
DESCRIPTION: Demonstrates how to use the Option.isOption function to check if values are Option instances. The function returns true for both Some and None variants of Option, and false for other values. This type guard helps ensure type safety when working with Option types.

LANGUAGE: typescript
CODE:
import { Option } from "effect"

console.log(Option.isOption(Option.some(1)))
// Output: true

console.log(Option.isOption(Option.none()))
// Output: true

console.log(Option.isOption({}))
// Output: false

LANGUAGE: typescript
CODE:
declare const isOption: (input: unknown) => input is Option<unknown>

----------------------------------------

TITLE: Effect.acquireRelease Type Definition
DESCRIPTION: TypeScript type signature for the acquireRelease function, showing its polymorphic nature and type constraints for acquisition and release operations.

LANGUAGE: typescript
CODE:
declare const acquireRelease: { <A, X, R2>(release: (a: A, exit: Exit.Exit<unknown, unknown>) => Effect<X, never, R2>): <E, R>(acquire: Effect<A, E, R>) => Effect<A, E, Scope.Scope | R2 | R>; <A, E, R, X, R2>(acquire: Effect<A, E, R>, release: (a: A, exit: Exit.Exit<unknown, unknown>) => Effect<X, never, R2>): Effect<A, E, Scope.Scope | R | R2>; }

----------------------------------------

TITLE: Using Array.matchLeft Pattern Matching in TypeScript
DESCRIPTION: Demonstrates how to use Array.matchLeft to handle empty and non-empty array cases. The function takes an options object with onEmpty and onNonEmpty handlers, returning different results based on the array's content.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const matchLeft = Array.matchLeft({
  onEmpty: () => "empty",
  onNonEmpty: (head, tail) => `head: ${head}, tail: ${tail.length}`
})
console.log(matchLeft([])) // "empty"
console.log(matchLeft([1, 2, 3])) // "head: 1, tail: 2"

----------------------------------------

TITLE: Defining User-Defined Text Primitive in TypeScript for @effect/cli
DESCRIPTION: Declares a constant 'text' of type Primitive<string> to represent user-defined text. This primitive can be used for handling text input in CLI applications built with the @effect/cli package.

LANGUAGE: typescript
CODE:
declare const text: Primitive<string>

----------------------------------------

TITLE: Creating Exponential Histogram Boundaries in TypeScript
DESCRIPTION: Helper method that generates histogram bucket boundaries with exponentially increasing values. Takes options object with start value, growth factor, and number of buckets.

LANGUAGE: typescript
CODE:
declare const exponential: (options: { readonly start: number; readonly factor: number; readonly count: number; }) => MetricBoundaries

----------------------------------------

TITLE: Declaring takeFirst Function in TMap Module (TypeScript)
DESCRIPTION: Defines the takeFirst function which takes the first matching value from a TMap, or retries until a match is found. It accepts a predicate function and returns an STM (Software Transactional Memory) operation.

LANGUAGE: typescript
CODE:
declare const takeFirst: { <K, V, A>(pf: (key: K, value: V) => Option.Option<A>): (self: TMap<K, V>) => STM.STM<A>; <K, V, A>(self: TMap<K, V>, pf: (key: K, value: V) => Option.Option<A>): STM.STM<A>; }

----------------------------------------

TITLE: Defining greaterThanOrEqualTo Filter in TypeScript
DESCRIPTION: This code snippet defines the type signature for the greaterThanOrEqualTo filter function. It creates a filter that checks if a number is greater than or equal to a specified minimum value. The function is generic and works with any Schema type that extends Schema.Any.

LANGUAGE: typescript
CODE:
declare const greaterThanOrEqualTo: <S extends Schema.Any>(minimum: number, annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>

----------------------------------------

TITLE: Checking Yield Status in ChildExecutorDecision - TypeScript
DESCRIPTION: A type predicate function that determines if a ChildExecutorDecision instance is specifically of the Yield variant. Returns true if the decision is a Yield, false for other variants.

LANGUAGE: typescript
CODE:
declare const isYield: (self: ChildExecutorDecision) => self is Yield

----------------------------------------

TITLE: Defining productComposition Function in TypeScript
DESCRIPTION: This function returns a default product composition for SemiApplicative and SemiProduct types. It takes two type parameters F and G, which extend TypeLambda, and returns a function that composes products of these types.

LANGUAGE: TypeScript
CODE:
declare const productComposition: <F extends TypeLambda, G extends TypeLambda>(F: SemiApplicative<F>, G: SemiProduct<G>) => <FR1, FO1, FE1, GR1, GO1, GE1, A, FR2, FO2, FE2, GR2, GO2, GE2, B>(self: Kind<F, FR1, FO1, FE1, Kind<G, GR1, GO1, GE1, A>>, that: Kind<F, FR2, FO2, FE2, Kind<G, GR2, GO2, GE2, B>>) => Kind<F, FR1 & FR2, FO1 | FO2, FE1 | FE2, Kind<G, GR1 & GR2, GO1 | GO2, GE1 | GE2, [A, B]>>

----------------------------------------

TITLE: Defining PathPatch Type in TypeScript for Configuration Path Modification
DESCRIPTION: Defines the PathPatch type as a union of different path modification operations. This type is used to describe how to modify the path to a configuration value, including operations like Empty, AndThen, MapName, Nested, and Unnested.

LANGUAGE: typescript
CODE:
type PathPatch = Empty | AndThen | MapName | Nested | Unnested

----------------------------------------

TITLE: Defining NoSuchElementException Interface in TypeScript
DESCRIPTION: TypeScript interface definition for NoSuchElementException error type that extends YieldableError. Used to indicate when an expected element is missing in collections or data lookups. Includes a specific _tag identifier and type ID symbol.

LANGUAGE: typescript
CODE:
export interface NoSuchElementException extends YieldableError {
  readonly _tag: "NoSuchElementException"
  readonly [NoSuchElementExceptionTypeId]: NoSuchElementExceptionTypeId
}

----------------------------------------

TITLE: Converting Either to Channel in TypeScript
DESCRIPTION: Function signature for converting an Either type to a Channel type. The function takes an Either<R, L> as input and returns a Channel that never requires an input, can emit an error of type L, or a success value of type R.

LANGUAGE: typescript
CODE:
declare const fromEither: <R, L>(either: Either.Either<R, L>) => Channel<never, unknown, L, unknown, R, unknown>

----------------------------------------

TITLE: Appending Tags to MetricKey in TypeScript
DESCRIPTION: Function that creates a new MetricKey by appending a specified tag key-value pair to an existing MetricKey. Supports both curried and uncurried calling styles.

LANGUAGE: typescript
CODE:
declare const tagged: { 
  (key: string, value: string): <Type extends MetricKeyType.MetricKeyType<any, any>>(self: MetricKey<Type>) => MetricKey<Type>; 
  <Type extends MetricKeyType.MetricKeyType<any, any>>(self: MetricKey<Type>, key: string, value: string): MetricKey<Type>; 
}

----------------------------------------

TITLE: Defining addDelay Function in TypeScript for Effect Package Schedule Module
DESCRIPTION: This code snippet defines the addDelay function, which adds a delay to every interval in a schedule. It takes a function that computes the delay based on the schedule's output and returns a modified schedule with the additional delay applied.

LANGUAGE: typescript
CODE:
declare const addDelay: { <Out>(f: (out: Out) => Duration.DurationInput): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R>(self: Schedule<Out, In, R>, f: (out: Out) => Duration.DurationInput): Schedule<Out, In, R>; }

----------------------------------------

TITLE: Stream.iterate Type Signature in TypeScript
DESCRIPTION: Type signature for the Stream.iterate function showing it takes an initial value and a next function that computes subsequent values.

LANGUAGE: typescript
CODE:
declare const iterate: <A>(value: A, next: (value: A) => A) => Stream<A>

----------------------------------------

TITLE: Creating Frequency Metric Keys in TypeScript
DESCRIPTION: Defines a function that creates a metric key for categorical frequency tables. The function accepts a name parameter and optional configuration including description and preregistered words.

LANGUAGE: typescript
CODE:
declare const frequency: (name: string, options?: { readonly description?: string | undefined; readonly preregisteredWords?: ReadonlyArray<string> | undefined; } | undefined) => MetricKey.Frequency

----------------------------------------

TITLE: Schema.pluck Function Signature in TypeScript
DESCRIPTION: Type signature for the Schema.pluck function showing its polymorphic nature and type constraints. The function can be used either with curried parameters or with both arguments at once.

LANGUAGE: typescript
CODE:
declare const pluck: { <A, I, K extends keyof A & keyof I>(key: K): <R>(schema: Schema<A, I, R>) => SchemaClass<A[K], Simplify<Pick<I, K>>, R>; <A, I, R, K extends keyof A & keyof I>(schema: Schema<A, I, R>, key: K): SchemaClass<A[K], Simplify<Pick<I, K>>, R>; }

----------------------------------------

TITLE: Defining PropertySignature Enhancement Function in TypeScript
DESCRIPTION: Type signature for withConstructorDefault function that takes a default value constructor and property signature, returning an enhanced property signature with default value support. The function supports both curried and uncurried forms.

LANGUAGE: typescript
CODE:
declare const withConstructorDefault: { <Type>(defaultValue: () => Types.NoInfer<Type>): <TypeToken extends PropertySignature.Token, Key extends PropertyKey, EncodedToken extends PropertySignature.Token, Encoded, R>(self: PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, boolean, R>) => PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, true, R>; <TypeToken extends PropertySignature.Token, Type, Key extends PropertyKey, EncodedToken extends PropertySignature.Token, Encoded, R>(self: PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, boolean, R>, defaultValue: () => Types.NoInfer<Type>): PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, true, R>; }

----------------------------------------

TITLE: Using Either.getOrElse in TypeScript
DESCRIPTION: Demonstrates how to use the Either.getOrElse function to handle both Right and Left cases of an Either type. It returns the wrapped value for Right or applies a function to the error for Left.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Either } from "effect"

assert.deepStrictEqual(Either.getOrElse(Either.right(1), (error) => error + "!"), 1)
assert.deepStrictEqual(Either.getOrElse(Either.left("not a number"), (error) => error + "!"), "not a number!")

----------------------------------------

TITLE: Implementing ExecutionStrategy Match Function in TypeScript
DESCRIPTION: Function signature for matching on ExecutionStrategy values. Takes options object containing handler functions for sequential, parallel, and parallelN execution strategies. Returns a function that processes an ExecutionStrategy value or directly processes it when provided.

LANGUAGE: typescript
CODE:
declare const match: { 
  <A>(options: { 
    readonly onSequential: LazyArg<A>; 
    readonly onParallel: LazyArg<A>; 
    readonly onParallelN: (n: number) => A; 
  }): (self: ExecutionStrategy) => A; 
  <A>(self: ExecutionStrategy, 
    options: { 
      readonly onSequential: LazyArg<A>; 
      readonly onParallel: LazyArg<A>; 
      readonly onParallelN: (n: number) => A; 
    }
  ): A; 
}

----------------------------------------

TITLE: Creating Named Time Zone from System's Local Time Zone in TypeScript
DESCRIPTION: This function, zoneMakeLocal, creates a named TimeZone object based on the system's local time zone. It takes no parameters and returns a TimeZone.Named object.

LANGUAGE: typescript
CODE:
declare const zoneMakeLocal: () => TimeZone.Named

----------------------------------------

TITLE: Extracting DateTime Components in Effect TypeScript
DESCRIPTION: A function that takes a DateTime object and returns its components (including weekday) in an object format. The returned parts are adjusted according to the timezone settings.

LANGUAGE: typescript
CODE:
declare const toParts: (self: DateTime) => DateTime.PartsWithWeekday

----------------------------------------

TITLE: Implementing forEach Method for MutableList in TypeScript
DESCRIPTION: Type definition for the forEach method that executes a specified function for each element in a MutableList. The method provides two overloads: a curried version and a standard two-parameter version.

LANGUAGE: typescript
CODE:
declare const forEach: {
  <A>(f: (element: A) => void): (self: MutableList<A>) => void;
  <A>(self: MutableList<A>, f: (element: A) => void): void;
}

----------------------------------------

TITLE: Implementing Cursor Up Movement in TypeScript using ANSI Escape Codes
DESCRIPTION: Defines a function 'cursorUp' that moves the cursor up by a specified number of lines (default 1) using ANSI escape codes. This function returns an Ansi type and has no effect if the cursor is at the screen's edge.

LANGUAGE: typescript
CODE:
declare const cursorUp: (lines?: number) => Ansi

----------------------------------------

TITLE: Declaring DateTimeZonedFromSelf Schema Class in TypeScript
DESCRIPTION: Defines a class that represents a schema for DateTime.Zoned instances. This schema provides functionality for handling date and time values with timezone information in a type-safe manner.

LANGUAGE: typescript
CODE:
declare class DateTimeZonedFromSelf

----------------------------------------

TITLE: Setting URL Hash Fragment in TypeScript using Effect Platform
DESCRIPTION: Function signature for updating the hash fragment of a URL. Supports both curried and direct two-parameter versions for flexible usage patterns. The function takes a hash string and a URL object, returning the modified URL.

LANGUAGE: typescript
CODE:
declare const setHash: { (hash: string): (url: URL) => URL; (url: URL, hash: string): URL; }

----------------------------------------

TITLE: Implementing mapLeft for Bicovariant Typeclass in TypeScript
DESCRIPTION: This function returns a default implementation of mapLeft for the Bicovariant typeclass. It allows for mapping over the left type parameter of a bicovariant structure. The function is generic over the type constructor F and provides both curried and uncurried versions.

LANGUAGE: typescript
CODE:
declare const mapLeft: <F extends TypeLambda>(F: Bicovariant<F>) => { <E, G>(f: (e: E) => G): <R, O, A>(self: Kind<F, R, O, E, A>) => Kind<F, R, O, G, A>; <R, O, E, A, G>(self: Kind<F, R, O, E, A>, f: (e: E) => G): Kind<F, R, O, G, A>; }

----------------------------------------

TITLE: Creating a Record from Iterable Using fromIterableBy in TypeScript
DESCRIPTION: Demonstrates how to use the fromIterableBy function to create a new record from an iterable, using a provided function to determine the key for each element. The example shows creating a record of users indexed by their id.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { fromIterableBy } from "effect/Record"

const users = [
  { id: "2", name: "name2" },
  { id: "1", name: "name1" }
]

assert.deepStrictEqual(
  fromIterableBy(users, user => user.id),
  {
    "2": { id: "2", name: "name2" },
    "1": { id: "1", name: "name1" }
  }
)

----------------------------------------

TITLE: Showing Cursor in ANSI Terminal - TypeScript
DESCRIPTION: Definition of a constant that generates ANSI escape sequences to make the terminal cursor visible. Part of the AnsiDoc module in @effect/printer-ansi package.

LANGUAGE: typescript
CODE:
declare const cursorShow: AnsiDoc

----------------------------------------

TITLE: Providing Live Effect Services in TypeScript
DESCRIPTION: Function that provides a workflow with the default 'live' Effect services. It takes an Effect instance and returns a new Effect with the same type parameters but with live services provided.

LANGUAGE: typescript
CODE:
declare const provideLive: <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>

----------------------------------------

TITLE: Partitioning Record of Either Values in TypeScript
DESCRIPTION: Demonstrates the usage of Record.separate function to partition a record of Either values into two separate records: one with Left values and one with Right values.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Record, Either } from "effect"

assert.deepStrictEqual(
  Record.separate({ a: Either.left("e"), b: Either.right(1) }),
  [{ a: "e" }, { b: 1 }]
)

----------------------------------------

TITLE: TypeScript Signature of Data.tagged Function
DESCRIPTION: Provides the TypeScript signature for the Data.tagged function. It takes a tag string and returns a constructor for objects with that tag and additional properties.

LANGUAGE: typescript
CODE:
declare const tagged: <A extends { readonly _tag: string; }>(tag: A["_tag"]) => Case.Constructor<A, "_tag">

----------------------------------------

TITLE: Implementing Complex Pattern Matching with Match.whenAnd in TypeScript
DESCRIPTION: Demonstrates the usage of Match.whenAnd function to match a value that satisfies multiple conditions simultaneously. It shows how to check for a User object with specific age and role criteria.

LANGUAGE: typescript
CODE:
import { Match } from "effect"

type User = { readonly age: number; readonly role: "admin" | "user" }

const checkUser = Match.type<User>().pipe(
  Match.whenAnd(
    { age: (n) => n >= 18 },
    { role: "admin" },
    () => "Admin access granted"
  ),
  Match.orElse(() => "Access denied")
)

console.log(checkUser({ age: 20, role: "admin" }))
// Output: "Admin access granted"

console.log(checkUser({ age: 20, role: "user" }))
// Output: "Access denied"

----------------------------------------

TITLE: Transforming Stream Errors in TypeScript
DESCRIPTION: The `mapError` function transforms the errors emitted by a stream using a provided function. It can be used in two ways: as a higher-order function or directly on a stream instance.

LANGUAGE: typescript
CODE:
declare const mapError: { <E, E2>(f: (error: E) => E2): <A, R>(self: Stream<A, E, R>) => Stream<A, E2, R>; <A, E, R, E2>(self: Stream<A, E, R>, f: (error: E) => E2): Stream<A, E2, R>; }

----------------------------------------

TITLE: Constructing RequestResolver from Function in TypeScript
DESCRIPTION: Defines the fromFunction constructor that creates a RequestResolver from a pure function. It takes a function that processes a request and returns a successful response.

LANGUAGE: typescript
CODE:
declare const fromFunction: <A extends Request.Request<any>>(f: (request: A) => Request.Request.Success<A>) => RequestResolver<A>

----------------------------------------

TITLE: Defining Right Brace Document Constant in TypeScript
DESCRIPTION: Declares a constant representing a single right brace character (}) as a Doc type with never type parameter, indicating it cannot hold any additional type information.

LANGUAGE: typescript
CODE:
declare const rbrace: Doc<never>

----------------------------------------

TITLE: Checking AlreadyFlat Type in TypeScript
DESCRIPTION: The isAlreadyFlat function is a type guard that checks if a given Flatten<A> is specifically an AlreadyFlat<A>. It returns true if the input is an AlreadyFlat, false otherwise. This function is useful for type narrowing in TypeScript.

LANGUAGE: typescript
CODE:
declare const isAlreadyFlat: <A>(a: Flatten<A>) => a is AlreadyFlat<A>

----------------------------------------

TITLE: Effect.zipLeft Function Signature in TypeScript
DESCRIPTION: The TypeScript signature for the Effect.zipLeft function. It shows the function's type definition, including its parameters and return type.

LANGUAGE: typescript
CODE:
declare const zipLeft: { <A2, E2, R2>(that: Effect<A2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; readonly batching?: boolean | "inherit" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Effect<A, E, R>, that: Effect<A2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; readonly batching?: boolean | "inherit" | undefined; readonly concurrentFinalizers?: boolean | undefined; } | undefined): Effect<A, E | E2, R | R2>; }

----------------------------------------

TITLE: Creating Named Time Zone Effect in TypeScript
DESCRIPTION: A function that creates a named time zone from an IANA time zone identifier. Returns an Effect that either contains the named time zone or fails with an IllegalArgumentException if the zone ID is invalid.

LANGUAGE: typescript
CODE:
declare const zoneMakeNamedEffect: (zoneId: string) => Effect.Effect<TimeZone.Named, IllegalArgumentException>

----------------------------------------

TITLE: Declaring failCauseSync Function in TypeScript
DESCRIPTION: Defines a function that creates a stream which always fails with a specified lazily evaluated Cause. It takes a LazyArg of Cause<E> and returns a Stream that never emits a value but fails with the specified error.

LANGUAGE: typescript
CODE:
declare const failCauseSync: <E>(evaluate: LazyArg<Cause.Cause<E>>) => Stream<never, E>

----------------------------------------

TITLE: Option.as Function Signature in TypeScript
DESCRIPTION: Provides the TypeScript signature for the Option.as function. It shows two overloads: one that takes the new value first and returns a function, and another that takes both the Option and the new value.

LANGUAGE: typescript
CODE:
declare const as: { <B>(b: B): <X>(self: Option<X>) => Option<B>; <X, B>(self: Option<X>, b: B): Option<B>; }

----------------------------------------

TITLE: Declaring eraseScreen Function in TypeScript
DESCRIPTION: Declares the eraseScreen constant of type Ansi. This function clears the entire screen and moves the cursor to the upper left corner.

LANGUAGE: typescript
CODE:
declare const eraseScreen: Ansi

----------------------------------------

TITLE: TypeScript Signature of discriminatorsExhaustive Function
DESCRIPTION: This code block shows the TypeScript signature of the discriminatorsExhaustive function. It defines the function's type parameters and return type, illustrating its complex generic structure for type-safe pattern matching.

LANGUAGE: typescript
CODE:
declare const discriminatorsExhaustive: <D extends string>(field: D) => <R, Ret, P extends { readonly [Tag in Types.Tags<D, R> & string]: (_: Extract<R, Record<D, Tag>>) => Ret; } & { readonly [Tag in Exclude<keyof P, Types.Tags<D, R>>]: never; }>(fields: P) => <I, F, A, Pr>(self: Matcher<I, F, R, A, Pr, Ret>) => [Pr] extends [never] ? (u: I) => Unify<A | ReturnType<P[keyof P]>> : Unify<A | ReturnType<P[keyof P]>>

----------------------------------------

TITLE: Defining EntityAddressFromSelf Schema in TypeScript
DESCRIPTION: Declares a constant EntityAddressFromSelf as a Schema for EntityAddress type. This schema represents the unique address of an entity within the cluster.

LANGUAGE: typescript
CODE:
declare const EntityAddressFromSelf: Schema.Schema<EntityAddress, EntityAddress, never>

----------------------------------------

TITLE: Erasing Lines from Cursor Position in TypeScript using AnsiDoc
DESCRIPTION: The eraseLines function erases a specified number of rows from the current cursor position upwards. It takes a number parameter representing the rows to erase and returns an AnsiDoc object.

LANGUAGE: typescript
CODE:
declare const eraseLines: (rows: number) => AnsiDoc

----------------------------------------

TITLE: Declaring structuralRegionState Object in TypeScript
DESCRIPTION: Defines an experimental object called structuralRegionState with properties for enabling custom matchers in tests. It includes a boolean 'enabled' flag and an optional 'tester' function for comparing two unknown values.

LANGUAGE: typescript
CODE:
declare const structuralRegionState: { enabled: boolean; tester: ((a: unknown, b: unknown) => boolean) | undefined; }

----------------------------------------

TITLE: Defining concatMap Function for Channel in TypeScript
DESCRIPTION: Defines the concatMap function for the Channel module. This function creates a new channel by applying a factory function to the outputs of an existing channel and concatenating the resulting channels.

LANGUAGE: typescript
CODE:
declare const concatMap: { <OutElem, OutElem2, InElem2, OutErr2, InErr2, X, InDone2, Env2>(f: (o: OutElem) => Channel<OutElem2, InElem2, OutErr2, InErr2, X, InDone2, Env2>): <Env, InErr, InElem, InDone, OutErr, OutDone>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem2, InElem & InElem2, OutErr2 | OutErr, InErr & InErr2, unknown, InDone & InDone2, Env2 | Env>; <Env, InErr, InElem, InDone, OutErr, OutDone, OutElem, OutElem2, Env2, InErr2, InElem2, InDone2, OutErr2, X>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, f: (o: OutElem) => Channel<OutElem2, InElem2, OutErr2, InErr2, X, InDone2, Env2>): Channel<OutElem2, InElem & InElem2, OutErr | OutErr2, InErr & InErr2, unknown, InDone & InDone2, Env | Env2>; }

----------------------------------------

TITLE: Implementing TSet.takeSome Operation in TypeScript
DESCRIPTION: Defines a takeSome function that extracts matching values from a transactional set (TSet). The function takes a predicate function that returns an Option and applies it to set elements, retrying until at least one matching value is found.

LANGUAGE: typescript
CODE:
declare const takeSome: { 
  <A, B>(pf: (a: A) => Option.Option<B>): (self: TSet<A>) => STM.STM<[B, ...Array<B>]>; 
  <A, B>(self: TSet<A>, pf: (a: A) => Option.Option<B>): STM.STM<[B, ...Array<B>]>; 
}

----------------------------------------

TITLE: Demonstrating Stream.tick Usage in TypeScript
DESCRIPTION: This example shows how to use Stream.tick to create a stream that emits void values at regular intervals. It demonstrates logging the time between ticks and collecting the first 5 emitted values.

LANGUAGE: typescript
CODE:
import { Effect, Stream } from "effect"

let last = Date.now()
const log = (message: string) =>
  Effect.sync(() => {
    const end = Date.now()
    console.log(`${message} after ${end - last}ms`)
    last = end
  })

const stream = Stream.tick("1 seconds").pipe(Stream.tap(() => log("tick")))

Effect.runPromise(Stream.runCollect(stream.pipe(Stream.take(5)))).then(console.log)
// tick after 4ms
// tick after 1003ms
// tick after 1001ms
// tick after 1002ms
// tick after 1002ms
// { _id: 'Chunk', values: [ undefined, undefined, undefined, undefined, undefined ] }

----------------------------------------

TITLE: Comparing Intervals in TypeScript using Effect
DESCRIPTION: Defines a function that returns the maximum of two Intervals by comparing their start times. The function supports both curried and uncurried calling styles.

LANGUAGE: typescript
CODE:
declare const max: { (that: Intervals): (self: Intervals) => Intervals; (self: Intervals, that: Intervals): Intervals; }

----------------------------------------

TITLE: Mapping Fiber Values in TypeScript using Effect-TS
DESCRIPTION: Function signature for mapping over the value that a Fiber computes. Provides two overloads: one for curried usage and another for direct application. Takes a mapping function and returns a new Fiber with the transformed value while preserving the error type.

LANGUAGE: typescript
CODE:
declare const map: { <A, B>(f: (a: A) => B): <E>(self: Fiber<A, E>) => Fiber<B, E>; <A, E, B>(self: Fiber<A, E>, f: (a: A) => B): Fiber<B, E>; }

----------------------------------------

TITLE: Defining lessThanOrEqualTo Schema Validation Function in TypeScript
DESCRIPTION: This function creates a schema that checks if a provided number is less than or equal to a specified maximum. It takes a maximum value and optional annotations as parameters, and returns a function that can be applied to an existing schema.

LANGUAGE: typescript
CODE:
declare const lessThanOrEqualTo: <S extends Schema.Any>(maximum: number, annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends number>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>

----------------------------------------

TITLE: Creating Timed Stream from Schedule in TypeScript
DESCRIPTION: Demonstrates creating a stream that emits values every second for 5 iterations using Schedule composition. The example combines a 1-second interval with a recurrence limit.

LANGUAGE: typescript
CODE:
import { Effect, Schedule, Stream } from "effect"

// Emits values every 1 second for a total of 5 emissions
const schedule = Schedule.spaced("1 second").pipe(
  Schedule.compose(Schedule.recurs(5))
)

const stream = Stream.fromSchedule(schedule)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 0, 1, 2, 3, 4 ] }

----------------------------------------

TITLE: Function Signature for unsafeSetZoneNamed in TypeScript
DESCRIPTION: Provides the TypeScript function signature for unsafeSetZoneNamed. It shows two overloads: one taking zoneId and options first, and another taking the DateTime object first. Both return a Zoned object.

LANGUAGE: typescript
CODE:
declare const unsafeSetZoneNamed: { (zoneId: string, options?: { readonly adjustForTimeZone?: boolean | undefined; }): (self: DateTime) => Zoned; (self: DateTime, zoneId: string, options?: { readonly adjustForTimeZone?: boolean | undefined; }): Zoned; }

----------------------------------------

TITLE: Defining MailboxFull Error Class in TypeScript
DESCRIPTION: Declares the MailboxFull class, which represents an error that occurs when an entity's mailbox is full. This class is part of the ClusterError module in the @effect/cluster package.

LANGUAGE: typescript
CODE:
declare class MailboxFull

----------------------------------------

TITLE: Creating HashSet from Set in TypeScript
DESCRIPTION: Shows how to create a HashSet from a JavaScript Set containing strings, demonstrating automatic duplicate removal.

LANGUAGE: typescript
CODE:
import { HashSet, pipe } from "effect"

console.log(
  pipe(
    new Set(["apple", "banana", "orange", "apple"]), // Set<string> is an Iterable<string>
    HashSet.fromIterable,
    HashSet.toValues
  )
) // Output: ["apple", "banana", "orange"]

----------------------------------------

TITLE: Defining Micro.die Function in TypeScript
DESCRIPTION: Function signature for creating a Micro effect that terminates with a specified error. The error is not tracked at the type level and results in a Die variant of MicroCause type.

LANGUAGE: typescript
CODE:
declare const die: (defect: unknown) => Micro<never>

----------------------------------------

TITLE: Converting Cause to PrettyError Array in TypeScript
DESCRIPTION: A utility function that takes a Cause object and returns an array of PrettyError objects. Each PrettyError may contain additional metadata like Span to provide context about error locations and details. The function traverses the entire Cause structure to generate comprehensive error information.

LANGUAGE: typescript
CODE:
declare const prettyErrors: <E>(cause: Cause<E>) => Array<PrettyError>

----------------------------------------

TITLE: Checking Non-Empty ReadonlyArray in TypeScript
DESCRIPTION: Demonstrates usage of Array.isNonEmptyReadonlyArray function to determine if a ReadonlyArray contains elements. The function returns true if the array has at least one element and narrows the type to NonEmptyReadonlyArray.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

console.log(Array.isNonEmptyReadonlyArray([])) // false
console.log(Array.isNonEmptyReadonlyArray([1, 2, 3])) // true

LANGUAGE: typescript
CODE:
declare const isNonEmptyReadonlyArray: <A>(self: ReadonlyArray<A>) => self is NonEmptyReadonlyArray<A>

----------------------------------------

TITLE: Implementing Last Semigroup in TypeScript
DESCRIPTION: Defines a Semigroup implementation that always returns the last argument. This function creates a generic Semigroup instance that can work with any type A.

LANGUAGE: typescript
CODE:
declare const last: <A = never>() => Semigroup<A>

----------------------------------------

TITLE: Creating Gauge Metric Keys in TypeScript
DESCRIPTION: Function overloads for creating metric keys for gauges. Supports both number and bigint gauge types based on options. The gauge function accepts a name parameter and optional configuration including description and bigint flag.

LANGUAGE: typescript
CODE:
declare const gauge: { 
  (name: string, options?: { readonly description?: string | undefined; readonly bigint?: false | undefined; }): MetricKey.Gauge<number>; 
  (name: string, options: { readonly description?: string | undefined; readonly bigint: true; }): MetricKey.Gauge<bigint>; 
}

----------------------------------------

TITLE: Testing RegExp Type with Effect Predicate Module
DESCRIPTION: Example demonstrating how to use the Predicate.isRegExp function to check if values are RegExp objects. The function returns true for RegExp instances and false for other types.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Predicate } from "effect"

assert.deepStrictEqual(Predicate.isRegExp(/a/), true)
assert.deepStrictEqual(Predicate.isRegExp("a"), false)

----------------------------------------

TITLE: Array.bindTo Function Signature in TypeScript
DESCRIPTION: This code snippet shows the TypeScript signature for the Array.bindTo function. It defines the function's type and parameters, indicating how it can be used to bind array elements to named properties.

LANGUAGE: typescript
CODE:
declare const bindTo: { <N extends string>(tag: N): <A>(self: ReadonlyArray<A>) => Array<{ [K in N]: A; }>; <A, N extends string>(self: ReadonlyArray<A>, tag: N): Array<{ [K in N]: A; }>; }

----------------------------------------

TITLE: Creating ScopedRef in TypeScript using Effect
DESCRIPTION: Creates a new ScopedRef from the specified value. This method is not intended for values that require resource acquisition during creation. It returns an Effect that produces a ScopedRef<A> and requires a Scope.

LANGUAGE: typescript
CODE:
declare const make: <A>(evaluate: LazyArg<A>) => Effect.Effect<ScopedRef<A>, never, Scope.Scope>

----------------------------------------

TITLE: Defining runScoped Function in TypeScript for Channel Module
DESCRIPTION: Declares the runScoped function, which runs a channel until completion or failure. The function takes a Channel as input and returns an Effect. It's designed for channels that don't read input or write output, and adds channel closing and finalizer execution to the current scope.

LANGUAGE: typescript
CODE:
declare const runScoped: <OutErr, InErr, OutDone, InDone, Env>(self: Channel<never, unknown, OutErr, InErr, OutDone, InDone, Env>) => Effect.Effect<OutDone, OutErr, Env | Scope.Scope>

----------------------------------------

TITLE: HashSet Partition Type Signature in TypeScript
DESCRIPTION: The type signature for the partition function, showing its polymorphic nature and support for both refinement and predicate-based partitioning with different parameter ordering options.

LANGUAGE: typescript
CODE:
declare const partition: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): (self: HashSet<A>) => [excluded: HashSet<Exclude<A, B>>, satisfying: HashSet<B>]; <A>(predicate: Predicate<NoInfer<A>>): (self: HashSet<A>) => [excluded: HashSet<A>, satisfying: HashSet<A>]; <A, B extends A>(self: HashSet<A>, refinement: Refinement<A, B>): [excluded: HashSet<Exclude<A, B>>, satisfying: HashSet<B>]; <A>(self: HashSet<A>, predicate: Predicate<A>): [excluded: HashSet<A>, satisfying: HashSet<A>]; }

----------------------------------------

TITLE: Implementing Schedule Output Transformation in TypeScript
DESCRIPTION: Function signature for mapping schedule outputs to new values while maintaining the original timing and recurrence behavior. Provides two overloads: one for curried usage and another for direct application.

LANGUAGE: typescript
CODE:
declare const map: { <Out, Out2>(f: (out: Out) => Out2): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out2, In, R>; <Out, In, R, Out2>(self: Schedule<Out, In, R>, f: (out: Out) => Out2): Schedule<Out2, In, R>; }

----------------------------------------

TITLE: Declaring TestAnnotation.repeated Type in TypeScript
DESCRIPTION: Defines a TestAnnotation type for tracking the number of times a test is repeated. This annotation is used within the Effect testing framework to maintain a count of test repetitions.

LANGUAGE: typescript
CODE:
declare const repeated: TestAnnotation<number>

----------------------------------------

TITLE: TypeScript Function Signature for Record.getRights
DESCRIPTION: The type signature of the Record.getRights function. It takes a readonly record with Either values and returns a new record containing only the Right values.

LANGUAGE: typescript
CODE:
declare const getRights: <K extends string, R, L>(self: ReadonlyRecord<K, Either<R, L>>) => Record<string, R>

----------------------------------------

TITLE: Declaring zipParRight Function in TypeScript for Exit Module
DESCRIPTION: Defines the zipParRight function, which parallelly zips the result with another result, discarding the first element of the tuple or returning the failed Cause<E | E2>. It has two overloads to handle different parameter orders.

LANGUAGE: typescript
CODE:
declare const zipParRight: { <A2, E2>(that: Exit<A2, E2>): <A, E>(self: Exit<A, E>) => Exit<A2, E2 | E>; <A, E, A2, E2>(self: Exit<A, E>, that: Exit<A2, E2>): Exit<A2, E | E2>; }

----------------------------------------

TITLE: Checking CharTree Type in TypeScript
DESCRIPTION: A type guard function that determines if a given DocTree instance is specifically a CharTree type. Returns a boolean indicating whether the input matches the CharTree type specification.

LANGUAGE: typescript
CODE:
declare const isCharTree: <A>(self: DocTree<A>) => self is CharTree<A>

----------------------------------------

TITLE: Defining Emit Interface in TypeScript for Effect Package
DESCRIPTION: This code snippet defines the Emit interface, which represents an asynchronous callback that can be called multiple times. It takes an Effect that can emit chunks of values, terminate with an error, or signal the end of a stream.

LANGUAGE: typescript
CODE:
export interface Emit<in R, in E, in A, out B> extends EmitOps<R, E, A, B> {
  (f: Effect.Effect<Chunk.Chunk<A>, Option.Option<E>, R>): Promise<B>
}

----------------------------------------

TITLE: Defining AlreadyProcessingMessage Error Class in TypeScript
DESCRIPTION: Defines a class representing an error condition when an entity attempts to process a message while already processing another request. This error type helps manage concurrent message processing in clustered environments.

LANGUAGE: typescript
CODE:
declare class AlreadyProcessingMessage

----------------------------------------

TITLE: Launching Metric Polling with Schedule in TypeScript
DESCRIPTION: The launch function returns an effect that starts a metric polling process in a background fiber. It takes a schedule as input and can be used with different metric polling configurations. The function supports both curried and uncurried calling styles.

LANGUAGE: typescript
CODE:
declare const launch: {
  <A2, R2>(schedule: Schedule.Schedule<A2, unknown, R2>):
    <Type, In, R, E, Out>(self: MetricPolling<Type, In, R, E, Out>) =>
      Effect.Effect<Fiber.Fiber<A2, E>, never, R2 | R | Scope.Scope>;
  <Type, In, R, E, Out, A2, R2>(
    self: MetricPolling<Type, In, R, E, Out>,
    schedule: Schedule.Schedule<A2, unknown, R2>
  ): Effect.Effect<Fiber.Fiber<A2, E>, never, Scope.Scope | R | R2>;
}

----------------------------------------

TITLE: Removing Entries from Effect Trie
DESCRIPTION: Demonstrates how to remove entries from a Trie data structure using the remove method. The example shows initialization of a Trie with multiple entries and subsequent removal operations, using assertions to verify the results.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Trie, Option } from "effect"

const trie = Trie.empty<number>().pipe(
  Trie.insert("call", 0),
  Trie.insert("me", 1),
  Trie.insert("mind", 2),
  Trie.insert("mid", 3)
)

const trie1 = trie.pipe(Trie.remove("call"))
const trie2 = trie1.pipe(Trie.remove("mea"))

assert.deepStrictEqual(Trie.get(trie, "call"), Option.some(0))
assert.deepStrictEqual(Trie.get(trie1, "call"), Option.none())
assert.deepStrictEqual(Trie.get(trie2, "call"), Option.none())

LANGUAGE: typescript
CODE:
declare const remove: { (key: string): <V>(self: Trie<V>) => Trie<V>; <V>(self: Trie<V>, key: string): Trie<V>; }

----------------------------------------

TITLE: Retrieving Values from TMap using STM - TypeScript
DESCRIPTION: Function signature for retrieving all values stored in a TMap data structure. The function takes a TMap instance with key type K and value type V, and returns an STM transaction that resolves to an array of values.

LANGUAGE: typescript
CODE:
declare const values: <K, V>(self: TMap<K, V>) => STM.STM<Array<V>>

----------------------------------------

TITLE: Creating Constant Output Metric in TypeScript
DESCRIPTION: The succeed function creates a metric that ignores input and produces constant output. It takes a single parameter 'out' and returns a Metric object.

LANGUAGE: typescript
CODE:
declare const succeed: <Out>(out: Out) => Metric<void, unknown, Out>

----------------------------------------

TITLE: Getting Primitive Type Choices in TypeScript
DESCRIPTION: A function that takes a Primitive type parameter and returns an Option containing a string representation of valid choices for that primitive type. This is part of the @effect/cli package's type system.

LANGUAGE: typescript
CODE:
declare const getChoices: <A>(self: Primitive<A>) => Option<string>

----------------------------------------

TITLE: BigDecimal Remainder Function Signature in TypeScript
DESCRIPTION: Defines the function signature for the BigDecimal.remainder operation. It shows two overloads: one for curried usage and another for direct two-parameter usage.

LANGUAGE: typescript
CODE:
declare const remainder: { (divisor: BigDecimal): (self: BigDecimal) => Option.Option<BigDecimal>; (self: BigDecimal, divisor: BigDecimal): Option.Option<BigDecimal>; }

----------------------------------------

TITLE: Declaring fromKey Function in TypeScript for Schema Enhancement
DESCRIPTION: Defines the fromKey function which enhances a property signature by specifying a different key for it in the Encoded type. It provides two overloads for flexible usage with PropertySignature types.

LANGUAGE: typescript
CODE:
declare const fromKey: { <Key extends PropertyKey>(key: Key): <TypeToken extends PropertySignature.Token, Type, EncodedToken extends PropertySignature.Token, Encoded, HasDefault extends boolean, R>(self: PropertySignature<TypeToken, Type, PropertyKey, EncodedToken, Encoded, HasDefault, R>) => PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R>; <Type, TypeToken extends PropertySignature.Token, Encoded, EncodedToken extends PropertySignature.Token, HasDefault extends boolean, R, Key extends PropertyKey>(self: PropertySignature<TypeToken, Type, PropertyKey, EncodedToken, Encoded, HasDefault, R>, key: Key): PropertySignature<TypeToken, Type, Key, EncodedToken, Encoded, HasDefault, R>; }

----------------------------------------

TITLE: Defining CommandInput Type in TypeScript
DESCRIPTION: Defines a type that specifies how stdin streaming should be handled between parent and child processes. It can be configured as 'inherit', 'pipe', or a Stream of Uint8Array data with PlatformError error type. The default configuration is 'pipe'.

LANGUAGE: typescript
CODE:
type CommandInput = "inherit" | "pipe" | Stream<Uint8Array, PlatformError>

----------------------------------------

TITLE: Acquiring Write Lock in TReentrantLock - TypeScript
DESCRIPTION: Function signature for acquiring a write lock in a TReentrantLock implementation. The function suspends the transaction until no other fibers hold read or write locks and returns the number of write locks held by the current fiber.

LANGUAGE: typescript
CODE:
declare const acquireWrite: (self: TReentrantLock) => STM.STM<number>

----------------------------------------

TITLE: Checking Key Existence in Trie using TypeScript
DESCRIPTION: Demonstrates how to use the Trie.has function to check for the existence of keys in a Trie data structure. It shows creating a Trie, inserting values, and checking for both existing and non-existing keys.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Trie } from "effect"

const trie = Trie.empty<number>().pipe(
  Trie.insert("call", 0),
  Trie.insert("me", 1),
  Trie.insert("mind", 2),
  Trie.insert("mid", 3)
)

assert.equal(Trie.has(trie, "call"), true)
assert.equal(Trie.has(trie, "me"), true)
assert.equal(Trie.has(trie, "mind"), true)
assert.equal(Trie.has(trie, "mid"), true)
assert.equal(Trie.has(trie, "cale"), false)
assert.equal(Trie.has(trie, "ma"), false)
assert.equal(Trie.has(trie, "midn"), false)
assert.equal(Trie.has(trie, "mea"), false)

----------------------------------------

TITLE: Declaring Bearer Token Security Scheme in TypeScript
DESCRIPTION: Type declaration for creating a Bearer token security scheme that can be used with HttpApiBuilder.middlewareSecurity for API authentication. This is part of the @effect/platform package's HTTP API security functionality.

LANGUAGE: typescript
CODE:
declare const bearer: Bearer

----------------------------------------

TITLE: Creating Synchronized Metrics in TypeScript Effect Library
DESCRIPTION: Implements a function that creates a metric which ignores input and produces constant output. The metric is created using a lazy evaluation argument that determines the output value.

LANGUAGE: typescript
CODE:
declare const sync: <Out>(evaluate: LazyArg<Out>) => Metric<void, unknown, Out>

----------------------------------------

TITLE: Implementing Sink.fold Function in TypeScript
DESCRIPTION: Defines a fold function that creates a sink which processes inputs iteratively. It takes an initial state, a continuation predicate function, and a folding function to combine the state with each input. The sink continues processing until the predicate returns false.

LANGUAGE: typescript
CODE:
declare const fold: <S, In>(s: S, contFn: Predicate<S>, f: (s: S, input: In) => S) => Sink<S, In, In>

----------------------------------------

TITLE: Defining causeOption Function in TypeScript for Exit Module
DESCRIPTION: Declares the causeOption function that takes an Exit<A, E> and returns an Option<Cause<E>>. It returns Some<Cause<E>> if the exit is a Failure, and None otherwise.

LANGUAGE: typescript
CODE:
declare const causeOption: <A, E>(self: Exit<A, E>) => Option.Option<Cause.Cause<E>>

----------------------------------------

TITLE: Defining Fiber Descriptor Interface in TypeScript
DESCRIPTION: Interface definition for a Fiber descriptor that contains essential information about a Fiber including its unique identifier, status, and set of interrupting fibers. Used for tracking and managing fiber state in the Effect library.

LANGUAGE: typescript
CODE:
export interface Descriptor {
    /**
     * The fiber's unique identifier.
     */
    readonly id: FiberId.FiberId
    /**
     * The status of the fiber.
     */
    readonly status: FiberStatus.FiberStatus
    /**
     * The set of fibers attempting to interrupt the fiber or its ancestors.
     */
    readonly interruptors: HashSet.HashSet<FiberId.FiberId>
  }

----------------------------------------

TITLE: Creating Empty Trie in TypeScript using Effect Library
DESCRIPTION: Demonstrates how to create an empty Trie data structure using the Effect library's Trie.empty constructor. The example shows initialization and basic assertions to verify the empty state.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Trie, Equal } from "effect"

const trie = Trie.empty<string>()

assert.equal(Trie.size(trie), 0)
assert.deepStrictEqual(Array.from(trie), [])

LANGUAGE: typescript
CODE:
declare const empty: <V = never>() => Trie<V>

----------------------------------------

TITLE: Defining Finalizer Type in TypeScript
DESCRIPTION: Defines a Finalizer type that represents a cleanup function. It takes an Exit value containing success or failure information and returns an Effect that produces void. This is used for resource cleanup and management in the Effect system.

LANGUAGE: typescript
CODE:
type Finalizer = (exit: Exit.Exit<unknown, unknown>) => Effect.Effect<void>

----------------------------------------

TITLE: TypeScript Function Signature for matchEffect
DESCRIPTION: The complete type signature for the matchEffect function showing its polymorphic nature and type parameters for handling different effect types, errors, and return values.

LANGUAGE: typescript
CODE:
declare const matchEffect: { <E, A2, E2, R2, A, A3, E3, R3>(options: { readonly onFailure: (e: E) => Effect<A2, E2, R2>; readonly onSuccess: (a: A) => Effect<A3, E3, R3>; }): <R>(self: Effect<A, E, R>) => Effect<A2 | A3, E2 | E3, R2 | R3 | R>; <A, E, R, A2, E2, R2, A3, E3, R3>(self: Effect<A, E, R>, options: { readonly onFailure: (e: E) => Effect<A2, E2, R2>; readonly onSuccess: (a: A) => Effect<A3, E3, R3>; }): Effect<A2 | A3, E2 | E3, R2 | R3 | R>; }

----------------------------------------

TITLE: Demonstrating BigInt MonoidMultiply in TypeScript
DESCRIPTION: This snippet demonstrates the usage of the MonoidMultiply constant from the @effect/typeclass/data/BigInt module. It shows how to combine bigint values using multiplication and the behavior with the empty value.

LANGUAGE: typescript
CODE:
import { MonoidMultiply } from "@effect/typeclass/data/BigInt"

console.log(MonoidMultiply.combine(2n, 3n))
// 6n
console.log(MonoidMultiply.combine(2n, MonoidMultiply.empty))
// 2n

----------------------------------------

TITLE: Type Checking NoSuchElementException in TypeScript
DESCRIPTION: A type guard function that checks if an unknown value is specifically a NoSuchElementException. Used for type-safe error handling within the Effect ecosystem.

LANGUAGE: typescript
CODE:
declare const isNoSuchElementException: (u: unknown) => u is NoSuchElementException

----------------------------------------

TITLE: Implementing Tagged Metrics in TypeScript using Effect
DESCRIPTION: Function signature for taggedWithLabels, which creates a new metric by adding specified tags to an existing metric. The function supports both curried and uncurried forms, maintaining the original metric's Type, In, and Out type parameters.

LANGUAGE: typescript
CODE:
declare const taggedWithLabels: { 
  <Type, In, Out>(extraTags: Iterable<MetricLabel.MetricLabel>): 
    (self: Metric<Type, In, Out>) => Metric<Type, In, Out>; 
  <Type, In, Out>(self: Metric<Type, In, Out>, extraTags: Iterable<MetricLabel.MetricLabel>): 
    Metric<Type, In, Out>; 
}

----------------------------------------

TITLE: Using longestPrefixOf with Effect Trie in TypeScript
DESCRIPTION: Demonstrates how to use the longestPrefixOf function to find the longest matching prefix in a Trie data structure. The example shows creating a trie with multiple string keys and number values, then searching for various prefixes.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Trie, Option } from "effect"

const trie = Trie.empty<number>().pipe(
  Trie.insert("shells", 0),
  Trie.insert("sells", 1),
  Trie.insert("she", 2)
)

assert.deepStrictEqual(Trie.longestPrefixOf(trie, "sell"), Option.none())
assert.deepStrictEqual(Trie.longestPrefixOf(trie, "sells"), Option.some(["sells", 1]))
assert.deepStrictEqual(Trie.longestPrefixOf(trie, "shell"), Option.some(["she", 2]))
assert.deepStrictEqual(Trie.longestPrefixOf(trie, "shellsort"), Option.some(["shells", 0]))

LANGUAGE: typescript
CODE:
declare const longestPrefixOf: { (key: string): <V>(self: Trie<V>) => Option<[string, V]>; <V>(self: Trie<V>, key: string): Option<[string, V]>; }

----------------------------------------

TITLE: Creating a New Cookie with Error Handling in TypeScript
DESCRIPTION: The unsafeMakeCookie function creates a new cookie, throwing an error if the input is invalid. It takes a name, value, and optional options as parameters and returns a Cookie object.

LANGUAGE: typescript
CODE:
declare const unsafeMakeCookie: (name: string, value: string, options?: Cookie["options"] | undefined) => Cookie

----------------------------------------

TITLE: Creating Counter Metric Key in TypeScript
DESCRIPTION: Function signature for creating a metric counter key with configurable options. Supports both number and bigint counters with optional description and incremental settings.

LANGUAGE: typescript
CODE:
declare const counter: { 
  (name: string, options?: { 
    readonly description?: string | undefined; 
    readonly bigint?: false | undefined; 
    readonly incremental?: boolean | undefined; 
  }): MetricKey.Counter<number>; 
  (name: string, options: { 
    readonly description?: string | undefined; 
    readonly bigint: true; 
    readonly incremental?: boolean | undefined; 
  }): MetricKey.Counter<bigint>; 
}

----------------------------------------

TITLE: Initializing ReadonlyArray Differ in TypeScript
DESCRIPTION: Constructs a differ that can compute differences between ReadonlyArrays of values. Takes a differ for the element type and returns a differ for arrays of that type.

LANGUAGE: typescript
CODE:
declare const readonlyArray: <Value, Patch>(differ: Differ<Value, Patch>) => Differ<ReadonlyArray<Value>, Differ.ReadonlyArray.Patch<Value, Patch>>

----------------------------------------

TITLE: DateTime.add Function Signature in TypeScript
DESCRIPTION: Provides the TypeScript signature for the DateTime.add function. It shows that the function can be called with either the DateTime object first and parts second, or parts first as a curried function.

LANGUAGE: typescript
CODE:
declare const add: { (parts: Partial<DateTime.PartsForMath>): <A extends DateTime>(self: A) => A; <A extends DateTime>(self: A, parts: Partial<DateTime.PartsForMath>): A; }

----------------------------------------

TITLE: Creating Standard Schema with Schema.standardSchemaV1 in TypeScript
DESCRIPTION: Demonstrates how to use Schema.standardSchemaV1 to create a Standard Schema object from a Schema definition. The resulting schema can validate input synchronously or asynchronously depending on its components.

LANGUAGE: typescript
CODE:
import { Schema } from "effect"

const schema = Schema.Struct({
  name: Schema.String
})

//      ┌─── StandardSchemaV1<{ readonly name: string; }>
//      ▼
const standardSchema = Schema.standardSchemaV1(schema)

----------------------------------------

TITLE: Array.matchLeft Type Definition
DESCRIPTION: Type signature for the Array.matchLeft function showing its polymorphic nature and support for different return types for empty and non-empty cases.

LANGUAGE: typescript
CODE:
declare const matchLeft: { <B, A, C = B>(options: { readonly onEmpty: LazyArg<B>; readonly onNonEmpty: (head: A, tail: Array<A>) => C; }): (self: ReadonlyArray<A>) => B | C; <A, B, C = B>(self: ReadonlyArray<A>, options: { readonly onEmpty: LazyArg<B>; readonly onNonEmpty: (head: A, tail: Array<A>) => C; }): B | C; }

----------------------------------------

TITLE: Defining batchN Function for Parallel Request Execution in TypeScript
DESCRIPTION: The batchN function returns a data source that executes at most 'n' requests in parallel. It can be called with either the number of parallel requests first, or the RequestResolver first, followed by the number of parallel requests.

LANGUAGE: typescript
CODE:
declare const batchN: { (n: number): <A, R>(self: RequestResolver<A, R>) => RequestResolver<A, R>; <A, R>(self: RequestResolver<A, R>, n: number): RequestResolver<A, R>; }

----------------------------------------

TITLE: TypeScript Signature of fromIterableWith Function
DESCRIPTION: Provides the TypeScript signature for the fromIterableWith function. It shows two overloads: one that takes the projection function first and returns a function that takes an iterable, and another that takes both the iterable and projection function as arguments.

LANGUAGE: typescript
CODE:
declare const fromIterableWith: { <A, K extends string | symbol, B>(f: (a: A) => readonly [K, B]): (self: Iterable<A>) => Record<ReadonlyRecord.NonLiteralKey<K>, B>; <A, K extends string | symbol, B>(self: Iterable<A>, f: (a: A) => readonly [K, B]): Record<ReadonlyRecord.NonLiteralKey<K>, B>; }

----------------------------------------

TITLE: TypeScript Signature for encloseSep Function
DESCRIPTION: This code snippet shows the TypeScript signature for the `encloseSep` function. It demonstrates the function's overloaded nature, allowing for flexible usage with different parameter orders.

LANGUAGE: typescript
CODE:
declare const encloseSep: { <A, B, C>(left: Doc<A>, right: Doc<B>, sep: Doc<C>): <D>(docs: Iterable<Doc<D>>) => Doc<A | B | C | D>; <A, B, C, D>(docs: Iterable<Doc<D>>, left: Doc<A>, right: Doc<B>, sep: Doc<C>): Doc<A | B | C | D>; }

----------------------------------------

TITLE: repeatN Function Signature in TypeScript
DESCRIPTION: This code block shows the TypeScript signature for the repeatN function. It defines two overloads: one that takes the number of repetitions first, and another that takes the effect first.

LANGUAGE: typescript
CODE:
declare const repeatN: { (n: number): <A, E, R>(self: Effect<A, E, R>) => Effect<A, E, R>; <A, E, R>(self: Effect<A, E, R>, n: number): Effect<A, E, R>; }

----------------------------------------

TITLE: Implementing Conditional Stream Folding in TypeScript with Effect-TS
DESCRIPTION: Function signature for runFoldWhile that reduces stream elements to a value of type S, stopping when a condition is not met. Takes an initial state, continuation predicate, and fold function as parameters. Returns an Effect containing the final accumulated value.

LANGUAGE: typescript
CODE:
declare const runFoldWhile: { <S, A>(s: S, cont: Predicate<S>, f: (s: S, a: A) => S): <E, R>(self: Stream<A, E, R>) => Effect.Effect<S, E, R>; <A, E, R, S>(self: Stream<A, E, R>, s: S, cont: Predicate<S>, f: (s: S, a: A) => S): Effect.Effect<S, E, R>; }

----------------------------------------

TITLE: Implementing forEach Sink in TypeScript Effect Library
DESCRIPTION: Defines a sink that processes each input element using a provided effect-producing function. The sink executes the given effectful function for every element it receives, producing no output value but potentially causing side effects.

LANGUAGE: typescript
CODE:
declare const forEach: <In, X, E, R>(f: (input: In) => Effect.Effect<X, E, R>) => Sink<void, In, never, E, R>

----------------------------------------

TITLE: Defining Flat ConfigProvider Interface in TypeScript
DESCRIPTION: Defines the Flat interface for simplified config providers. It includes methods for loading configuration values and enumerating child keys. The interface is designed to work with flat key/value properties and provides special support for implementing such providers.

LANGUAGE: typescript
CODE:
export interface Flat {
    readonly [FlatConfigProviderTypeId]: FlatConfigProviderTypeId
    readonly patch: PathPatch.PathPatch
    load<A>(
      path: ReadonlyArray<string>,
      config: Config.Config.Primitive<A>,
      split?: boolean
    ): Effect.Effect<Array<A>, ConfigError.ConfigError>
    enumerateChildren(
      path: ReadonlyArray<string>
    ): Effect.Effect<HashSet.HashSet<string>, ConfigError.ConfigError>
  }

----------------------------------------

TITLE: Declaring asVoid Function for Micro Effect in TypeScript
DESCRIPTION: Defines the asVoid function that replaces the success value of a Micro effect with void. It takes a Micro effect as input and returns a new Micro effect with void as the success type.

LANGUAGE: typescript
CODE:
declare const asVoid: <A, E, R>(self: Micro<A, E, R>) => Micro<void, E, R>

----------------------------------------

TITLE: Creating Integer Arguments in Effect CLI TypeScript
DESCRIPTION: Defines a function 'integer' that creates an integer argument for command-line interfaces. It accepts an optional configuration object and returns an Args<number> type. The default argument name is 'integer' if not specified.

LANGUAGE: typescript
CODE:
declare const integer: (config?: Args.BaseArgsConfig) => Args<number>

----------------------------------------

TITLE: Using BigInt SemigroupSum for Addition
DESCRIPTION: Shows how to use the SemigroupSum to combine BigInt values using addition. The semigroup implementation provides a combine operation that adds two BigInt values together.

LANGUAGE: typescript
CODE:
import { SemigroupSum } from "@effect/typeclass/data/BigInt"

console.log(SemigroupSum.combine(2n, 3n))
// 5n

LANGUAGE: typescript
CODE:
declare const SemigroupSum: semigroup.Semigroup<bigint>

----------------------------------------

TITLE: Type Signature for withCurrentZoneLocal
DESCRIPTION: Type declaration for the withCurrentZoneLocal function, showing it takes an Effect and returns a new Effect with CurrentTimeZone requirement satisfied.

LANGUAGE: typescript
CODE:
declare const withCurrentZoneLocal: <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, Exclude<R, CurrentTimeZone>>

----------------------------------------

TITLE: Extracting Tail Elements from NonEmptyReadonlyArray in TypeScript
DESCRIPTION: The tailNonEmpty function returns all elements except the first one from a NonEmptyReadonlyArray. It takes a non-empty readonly array as input and returns a new array containing all elements after the first element.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const result = Array.tailNonEmpty([1, 2, 3, 4])
console.log(result) // [2, 3, 4]

LANGUAGE: typescript
CODE:
declare const tailNonEmpty: <A>(self: NonEmptyReadonlyArray<A>) => Array<A>

----------------------------------------

TITLE: Implementing Unsafe Tail Operation for Lists in TypeScript
DESCRIPTION: The unsafeTail function unsafely returns the tail of a given List. It's part of the List module in the Effect package. This operation is considered unsafe as it doesn't handle empty lists.

LANGUAGE: typescript
CODE:
declare const unsafeTail: <A>(self: List<A>) => List<A>

----------------------------------------

TITLE: Prepending Arrays using Array.prependAll in TypeScript
DESCRIPTION: Demonstrates how to use the Array.prependAll function to prepend one array to another. The function takes two arrays (or iterables) and returns a new array with the elements of the second array prepended to the first.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const result = Array.prependAll([2, 3], [0, 1])
console.log(result) // [0, 1, 2, 3]

----------------------------------------

TITLE: Using Doc.hsep to Concatenate Documents Horizontally in TypeScript
DESCRIPTION: This example demonstrates how to use the Doc.hsep function to concatenate words horizontally with spaces. It also shows that hsep does not introduce line breaks automatically, even when the page width is narrow.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"

const doc: Doc.Doc<never> = Doc.hsep(Doc.words("lorem ipsum dolor sit amet"))

assert.strictEqual(
  Doc.render(doc, {
    style: "pretty",
    options: { lineWidth: 80 }
  }),
  "lorem ipsum dolor sit amet"
)

// The `hsep` combinator will not introduce line breaks on its own, even when
// the page is too narrow
assert.strictEqual(
  Doc.render(doc, {
    style: "pretty",
    options: { lineWidth: 5 }
  }),
  "lorem ipsum dolor sit amet"
)

----------------------------------------

TITLE: Creating Intervals from List - TypeScript Effect Package
DESCRIPTION: Function signature for creating a new Intervals instance from a List of Interval objects. Takes a Chunk of Interval objects as input and returns an Intervals type.

LANGUAGE: typescript
CODE:
declare const make: (intervals: Check.Chunk<Interval.Interval>) => Intervals

----------------------------------------

TITLE: Accessing Sink Context in TypeScript
DESCRIPTION: The context function allows access to the whole context of a sink. It returns a Sink that provides the entire Context<R> as its output.

LANGUAGE: typescript
CODE:
declare const context: <R>() => Sink<Context.Context<R>, unknown, never, never, R>

----------------------------------------

TITLE: Either.getRight Function Signature in TypeScript
DESCRIPTION: This code snippet shows the TypeScript signature of the Either.getRight function. It takes an Either<R, L> as input and returns an Option<R>.

LANGUAGE: typescript
CODE:
declare const getRight: <R, L>(self: Either<R, L>) => Option<R>

----------------------------------------

TITLE: Executing Micro Effect and Returning Promise with MicroExit in TypeScript
DESCRIPTION: The runPromiseExit function executes a Micro effect and returns a Promise that resolves with the MicroExit of the computation. It takes a Micro effect and optional options including an AbortSignal and a MicroScheduler.

LANGUAGE: typescript
CODE:
declare const runPromiseExit: <A, E>(effect: Micro<A, E>, options?: { readonly signal?: AbortSignal | undefined; readonly scheduler?: MicroScheduler | undefined; } | undefined) => Promise<MicroExit<A, E>>

----------------------------------------

TITLE: Generating Equivalence Relation for Redacted Values in TypeScript
DESCRIPTION: This snippet demonstrates how to use the Redacted.getEquivalence function to compare Redacted instances without exposing their contents. It creates an equivalence relation based on string equality and applies it to Redacted API keys.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Redacted, Equivalence } from "effect"

const API_KEY1 = Redacted.make("1234567890")
const API_KEY2 = Redacted.make("1-34567890")
const API_KEY3 = Redacted.make("1234567890")

const equivalence = Redacted.getEquivalence(Equivalence.string)

assert.equal(equivalence(API_KEY1, API_KEY2), false)
assert.equal(equivalence(API_KEY1, API_KEY3), true)

----------------------------------------

TITLE: Implementing Default imap for Covariant TypeClass
DESCRIPTION: Provides a default implementation of the imap function for the Covariant typeclass. Takes a map function for type F and returns an implementation of the Invariant's imap method. The function handles type parameters R, O, E, A, and B in the context of Effect's type system.

LANGUAGE: typescript
CODE:
declare const imap: <F extends TypeLambda>(map: <R, O, E, A, B>(self: Kind<F, R, O, E, A>, f: (a: A) => B) => Kind<F, R, O, E, B>) => Invariant<F>["imap"]

----------------------------------------

TITLE: Defining Channel.pipeTo Type Signature in TypeScript
DESCRIPTION: Defines the type signature for the pipeTo function that allows piping the output of one channel into another channel. The function is overloaded to support both curried and uncurried forms, handling generic type parameters for input/output elements, errors, and done values.

LANGUAGE: typescript
CODE:
declare const pipeTo: { 
  <OutElem2, OutElem, OutErr2, OutErr, OutDone2, OutDone, Env2>
  (that: Channel<OutElem2, OutElem, OutErr2, OutErr, OutDone2, OutDone, Env2>): 
    <InElem, InErr, InDone, Env>
    (self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => 
      Channel<OutElem2, InElem, OutErr2, InErr, OutDone2, InDone, Env2 | Env>; 
  
  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, OutElem2, OutErr2, OutDone2, Env2>
  (self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, 
   that: Channel<OutElem2, OutElem, OutErr2, OutErr, OutDone2, OutDone, Env2>): 
     Channel<OutElem2, InElem, OutErr2, InErr, OutDone2, InDone, Env | Env2>; 
}

----------------------------------------

TITLE: Checking for ConfigError Type in TypeScript
DESCRIPTION: Defines a type guard function 'isConfigError' that determines if a given value is an instance of ConfigError. This function is useful for runtime type checking and ensuring type safety when working with configuration errors.

LANGUAGE: typescript
CODE:
declare const isConfigError: (u: unknown) => u is ConfigError

----------------------------------------

TITLE: Defining Micro.failCause Function in TypeScript
DESCRIPTION: This code snippet defines the signature of the Micro.failCause function. It takes a MicroCause<E> as input and returns a Micro<never, E> effect that fails with the specified cause.

LANGUAGE: typescript
CODE:
declare const failCause: <E>(cause: MicroCause<E>) => Micro<never, E>

----------------------------------------

TITLE: Declaring DateTimeUtc Schema Class in TypeScript
DESCRIPTION: Defines a schema class that handles conversion of strings to DateTime.Utc instances using DateTime.unsafeMake constructor. This is part of the Effect library's Schema module for type-safe data handling.

LANGUAGE: typescript
CODE:
declare class DateTimeUtc

----------------------------------------

TITLE: Implementing Stream Tracing with withSpan in TypeScript
DESCRIPTION: Defines a withSpan function that wraps a stream with a new tracing span. The function provides two overloads: one that takes the span name and options first, and another that takes the stream as the first parameter. Both versions return a new stream with updated tracing context.

LANGUAGE: typescript
CODE:
declare const withSpan: { 
  (name: string, options?: Tracer.SpanOptions | undefined): <A, E, R>(self: Stream<A, E, R>) => Stream<A, E, Exclude<R, Tracer.ParentSpan>>; 
  <A, E, R>(self: Stream<A, E, R>, name: string, options?: Tracer.SpanOptions | undefined): Stream<A, E, Exclude<R, Tracer.ParentSpan>>; 
}

----------------------------------------

TITLE: TypeScript Function Signature for lessThan in BigDecimal Module
DESCRIPTION: This code snippet shows the TypeScript function signature for the lessThan function in the BigDecimal module. It supports both curried and uncurried calling styles, taking BigDecimal arguments and returning a boolean.

LANGUAGE: typescript
CODE:
declare const lessThan: { (that: BigDecimal): (self: BigDecimal) => boolean; (self: BigDecimal, that: BigDecimal): boolean; }

----------------------------------------

TITLE: Defining Cartesian Product Function for Iterables in TypeScript
DESCRIPTION: This code snippet defines the cartesian function, which takes two Iterables and returns a new Iterable containing pairs of elements from both input Iterables. It supports both curried and non-curried invocations.

LANGUAGE: typescript
CODE:
declare const cartesian: { <B>(that: Iterable<B>): <A>(self: Iterable<A>) => Iterable<[A, B]>; <A, B>(self: Iterable<A>, that: Iterable<B>): Iterable<[A, B]>; }

----------------------------------------

TITLE: Declaring Shuffle Function in TRandom Module (TypeScript)
DESCRIPTION: Defines the shuffle function that takes an iterable of elements and returns an STM (Software Transactional Memory) effect that produces a shuffled array. The function uses a pseudo-random number generator to randomize the order of elements.

LANGUAGE: typescript
CODE:
declare const shuffle: <A>(elements: Iterable<A>) => STM.STM<Array<A>, never, TRandom>

----------------------------------------

TITLE: Transforming Literal Values with Schema.transformLiterals in TypeScript
DESCRIPTION: Demonstrates how to create a Schema that maps between numeric and string literal values. The example shows mapping numbers to animal names using Effect's Schema module.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import * as S from "effect/Schema"

const Animal = S.transformLiterals(
  [0, "cat"],
  [1, "dog"],
  [2, "cow"]
)

assert.deepStrictEqual(S.decodeSync(Animal)(1), "dog")

LANGUAGE: typescript
CODE:
declare const transformLiterals: { <const A extends AST.Members<readonly [from: AST.LiteralValue, to: AST.LiteralValue]>>(...pairs: A): Union<{ -readonly [I in keyof A]: transformLiteral<A[I][1], A[I][0]>; }>; <Encoded extends AST.LiteralValue, Type extends AST.LiteralValue>(pairs: [Encoded, Type]): transformLiteral<Type, Encoded>; <const A extends ReadonlyArray<readonly [from: AST.LiteralValue, to: AST.LiteralValue]>>(...pairs: A): Schema<A[number][1], A[number][0]>; }

----------------------------------------

TITLE: Capturing Metrics with unsafeSnapshot in Effect TypeScript
DESCRIPTION: Function signature for unsafely capturing a snapshot of all metrics recorded by the application. Returns an array of untyped MetricPair values.

LANGUAGE: typescript
CODE:
declare const unsafeSnapshot: (_: void) => ReadonlyArray<MetricPair.MetricPair.Untyped>

----------------------------------------

TITLE: Setting Fiber in FiberHandle - TypeScript
DESCRIPTION: Function signature for setting a fiber in a FiberHandle with options for conditional setting and interruption propagation. The fiber will be automatically removed upon completion. Supports both curried and direct invocation patterns.

LANGUAGE: typescript
CODE:
declare const set: { 
  <A, E, XE extends E, XA extends A>(
    fiber: Fiber.RuntimeFiber<XA, XE>, 
    options?: { 
      readonly onlyIfMissing?: boolean; 
      readonly propagateInterruption?: boolean | undefined; 
    }
  ): (self: FiberHandle<A, E>) => Effect.Effect<void>; 
  
  <A, E, XE extends E, XA extends A>(
    self: FiberHandle<A, E>, 
    fiber: Fiber.RuntimeFiber<XA, XE>, 
    options?: { 
      readonly onlyIfMissing?: boolean; 
      readonly propagateInterruption?: boolean | undefined; 
    }
  ): Effect.Effect<void>; 
}

----------------------------------------

TITLE: Accessing Sink Context with Effect in TypeScript
DESCRIPTION: Function that provides access to the sink's context within an effect. Takes a function that receives a Context and returns an Effect, producing a Sink that combines the input context requirements with the effect requirements.

LANGUAGE: typescript
CODE:
declare const contextWithEffect: <R0, A, E, R>(f: (context: Context.Context<R0>) => Effect.Effect<A, E, R>) => Sink<A, unknown, never, E, R0 | R>

----------------------------------------

TITLE: Defining Cause.Cause.Variance Interface in TypeScript
DESCRIPTION: Defines an internal interface that manages covariant type variance for the Cause type using a readonly type parameter E. This interface is crucial for maintaining proper type relationships in the Effect type system.

LANGUAGE: typescript
CODE:
export interface Variance<out E> {
    readonly [CauseTypeId]: {
      readonly _E: Covariant<E>
    }
  }

----------------------------------------

TITLE: Logger.make Function Signature in TypeScript
DESCRIPTION: Provides the TypeScript signature for the Logger.make function. It shows that the function takes a callback with Logger.Options<Message> and returns a Logger<Message, Output>.

LANGUAGE: typescript
CODE:
declare const make: <Message, Output>(log: (options: Logger.Options<Message>) => Output) => Logger<Message, Output>

----------------------------------------

TITLE: Implementing a Sink to Take N Values in TypeScript
DESCRIPTION: Defines a 'take' function that creates a Sink which collects a specified number of values. It takes a number parameter and returns a Sink that processes chunks of input, collecting the first 'n' values.

LANGUAGE: typescript
CODE:
declare const take: <In>(n: number) => Sink<Chunk.Chunk<In>, In, In>

----------------------------------------

TITLE: Type Checking TEnqueue Operation in TypeScript
DESCRIPTION: Type guard function that determines if a given value is a TEnqueue operation. Takes an unknown value and returns a type predicate indicating whether the value is a TEnqueue instance.

LANGUAGE: typescript
CODE:
declare const isTEnqueue: (u: unknown) => u is TEnqueue<unknown>

----------------------------------------

TITLE: Implementing MicroFiber Fork Operation in TypeScript
DESCRIPTION: Implementation signature for the forkIn function that runs a Micro effect in a new MicroFiber. The function accepts a MicroScope parameter and returns a new Micro effect that produces a MicroFiber which can be awaited, joined, or aborted. The fiber's lifetime is managed by the provided scope.

LANGUAGE: typescript
CODE:
declare const forkIn: { 
  (scope: MicroScope): <A, E, R>(self: Micro<A, E, R>) => Micro<MicroFiber<A, E>, never, R>; 
  <A, E, R>(self: Micro<A, E, R>, scope: MicroScope): Micro<MicroFiber<A, E>, never, R>; 
}

----------------------------------------

TITLE: TypeScript Type Definition for isHttpMethod Function
DESCRIPTION: Provides the type signature for the isHttpMethod function. It takes an unknown input and returns a type predicate indicating whether the input is of type HttpMethod.

LANGUAGE: typescript
CODE:
declare const isHttpMethod: (u: unknown) => u is HttpMethod

----------------------------------------

TITLE: Creating After Interval in TypeScript
DESCRIPTION: Function signature for creating an Interval that includes all time equal to and after a specified start time in milliseconds. The function takes a start time in milliseconds and returns an Interval object.

LANGUAGE: typescript
CODE:
declare const after: (startMilliseconds: number) => Interval

----------------------------------------

TITLE: Implementing SemigroupMultiply for BigInt in TypeScript
DESCRIPTION: Defines a Semigroup instance for BigInt under multiplication. This allows BigInt values to be combined using the semigroup's combine operation, which in this case is multiplication.

LANGUAGE: typescript
CODE:
declare const SemigroupMultiply: semigroup.Semigroup<bigint>

----------------------------------------

TITLE: Declaring unsafeHead Function in TypeScript for Iterable Module
DESCRIPTION: This code snippet defines the unsafeHead function, which retrieves the first element of an Iterable. It takes an Iterable of type A as input and returns an element of type A. The function is marked as unsafe, indicating it may throw an error if the Iterable is empty.

LANGUAGE: typescript
CODE:
declare const unsafeHead: <A>(self: Iterable<A>) => A

----------------------------------------

TITLE: Defining onInterrupt Handler in TypeScript
DESCRIPTION: Type declaration for the onInterrupt handler that takes a finalizer effect and returns a new Micro effect. The handler can be used in two ways: either by passing the finalizer first and then the effect, or by passing both the effect and finalizer together.

LANGUAGE: typescript
CODE:
declare const onInterrupt: {
  <XE, XR>(finalizer: Micro<void, XE, XR>): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E | XE, R | XR>;
  <A, E, R, XE, XR>(self: Micro<A, E, R>, finalizer: Micro<void, XE, XR>): Micro<A, E | XE, R | XR>;
}

----------------------------------------

TITLE: Implementing Chunk Difference Operation in TypeScript
DESCRIPTION: Defines a function that computes the difference between two Chunks. The function preserves the order and references of values from the first Chunk while excluding values present in the second Chunk. Available in two forms: curried and uncurried versions.

LANGUAGE: typescript
CODE:
declare const difference: { <A>(that: Chunk<A>): (self: Chunk<A>) => Chunk<A>; <A>(self: Chunk<A>, that: Chunk<A>): Chunk<A>; }

----------------------------------------

TITLE: Implementing dropWhile Function in TypeScript for Sink Module
DESCRIPTION: The dropWhile function is used to drop incoming elements from a Sink as long as a given predicate is satisfied. It takes a predicate function as an argument and returns a Sink that filters elements based on this predicate.

LANGUAGE: typescript
CODE:
declare const dropWhile: <In>(predicate: Predicate<In>) => Sink<unknown, In, In>

----------------------------------------

TITLE: Using isError Type Guard in TypeScript
DESCRIPTION: Demonstrates how to use the isError predicate function to check if a value is an Error instance. The function accepts any unknown input and returns a type predicate indicating if the value is an Error.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { isError } from "effect/Predicate"

assert.deepStrictEqual(isError(new Error()), true)

assert.deepStrictEqual(isError(null), false)
assert.deepStrictEqual(isError({}), false)

LANGUAGE: typescript
CODE:
declare const isError: (input: unknown) => input is Error

----------------------------------------

TITLE: Accessing MicroScope in TypeScript using Effect Package
DESCRIPTION: Defines a constant 'scope' that allows access to the current MicroScope. It uses the Micro type with MicroScope as both the input and output type, and never as the error type.

LANGUAGE: typescript
CODE:
declare const scope: Micro<MicroScope, never, MicroScope>

----------------------------------------

TITLE: Checking Fail Type in Cause Module (TypeScript)
DESCRIPTION: The isFailType function checks if a given Cause is of the Fail type. It takes a Cause<E> as input and returns a boolean indicating whether it's a Fail<E>. This function is useful for type narrowing in conditional statements.

LANGUAGE: TypeScript
CODE:
declare const isFailType: <E>(self: Cause<E>) => self is Fail<E>

----------------------------------------

TITLE: Calculating Size of Cause Objects in TypeScript
DESCRIPTION: A function that calculates the total number of Cause nodes in a semiring structure. It takes a Cause object as input and returns a number representing the count of individual error elements recorded.

LANGUAGE: typescript
CODE:
declare const size: <E>(self: Cause<E>) => number

----------------------------------------

TITLE: Implementing Runtime Promise Handler in Effect TypeScript
DESCRIPTION: Function signature for capturing a Runtime to fork Effects and manage fibers. Returns a run function that produces Promises resolving when fibers complete. Takes a FiberHandle and optional runtime options including propagation control.

LANGUAGE: typescript
CODE:
declare const runtimePromise: <A, E>(self: FiberHandle<A, E>) => <R = never>() => Effect.Effect<(<XE extends E, XA extends A>(effect: Effect.Effect<XA, XE, R>, options?: (Runtime.RunForkOptions & { readonly propagateInterruption?: boolean | undefined; }) | undefined) => Promise<XA>), never, R>

----------------------------------------

TITLE: TypeScript Signature for isContext Function
DESCRIPTION: Provides the TypeScript type signature for the isContext function. It takes an unknown input and returns a boolean indicating whether the input is a Context<never>.

LANGUAGE: typescript
CODE:
declare const isContext: (input: unknown) => input is Context<never>

----------------------------------------

TITLE: Defining TimeoutException Class in TypeScript
DESCRIPTION: Declares a class named TimeoutException that represents a checked exception thrown when a timeout occurs. This class is part of the Micro module in the effect package.

LANGUAGE: typescript
CODE:
declare class TimeoutException

----------------------------------------

TITLE: Implementing Ternary imap Composition for Invariant Typeclasses in TypeScript
DESCRIPTION: The imapComposition function returns a default ternary imap composition for two Invariant instances. It takes two Invariant instances F and G, and returns a function that can map between nested kinds of F and G.

LANGUAGE: TypeScript
CODE:
declare const imapComposition: <F extends TypeLambda, G extends TypeLambda>(F: Invariant<F>, G: Invariant<G>) => <FR, FO, FE, GR, GO, GE, A, B>(self: Kind<F, FR, FO, FE, Kind<G, GR, GO, GE, A>>, to: (a: A) => B, from: (b: B) => A) => Kind<F, FR, FO, FE, Kind<G, GR, GO, GE, B>>

----------------------------------------

TITLE: Initializing Non-Empty Chunks with makeBy Function in TypeScript
DESCRIPTION: Function signature for creating a non-empty chunk where each element is initialized using a provided function f that takes an index parameter. The function supports both curried and non-curried calling styles. The resulting chunk length is normalized to be at least 1.

LANGUAGE: typescript
CODE:
declare const makeBy: { <A>(f: (i: number) => A): (n: number) => NonEmptyChunk<A>; <A>(n: number, f: (i: number) => A): NonEmptyChunk<A>; }

----------------------------------------

TITLE: Prepending Elements to Chunks in TypeScript with Effect Library
DESCRIPTION: The prepend function adds an element to the front of a Chunk, creating a new NonEmptyChunk. It can be used in two ways: by providing the element first and then the Chunk, or by providing the Chunk first and then the element.

LANGUAGE: typescript
CODE:
declare const prepend: { <B>(elem: B): <A>(self: Chunk<A>) => NonEmptyChunk<B | A>; <A, B>(self: Chunk<A>, elem: B): NonEmptyChunk<A | B>; }

----------------------------------------

TITLE: Removing Multiple Entries from HashMap in TypeScript
DESCRIPTION: Function signature for removeMany operation that removes multiple entries from a HashMap based on an iterable of keys. Supports both curried and non-curried versions for flexible usage patterns.

LANGUAGE: typescript
CODE:
declare const removeMany: { <K>(keys: Iterable<K>): <V>(self: HashMap<K, V>) => HashMap<K, V>; <K, V>(self: HashMap<K, V>, keys: Iterable<K>): HashMap<K, V>; }

----------------------------------------

TITLE: Declaring Never-Resolving Micro Type in TypeScript
DESCRIPTION: TypeScript type declaration for a Micro that never succeeds or fails. It uses setInterval internally to prevent the JavaScript runtime from exiting.

LANGUAGE: typescript
CODE:
declare const never: Micro<never, never, never>

----------------------------------------

TITLE: Defining transformLiteral Function Signature in Effect Schema
DESCRIPTION: This code snippet shows the TypeScript signature for the transformLiteral function. It takes two parameters of types 'Encoded' and 'Type', both extending AST.LiteralValue, and returns a transformed literal schema.

LANGUAGE: typescript
CODE:
declare const transformLiteral: <Encoded extends AST.LiteralValue, Type extends AST.LiteralValue>(from: Encoded, to: Type) => transformLiteral<Type, Encoded>

----------------------------------------

TITLE: Declaring Doc.lbrace Constant in TypeScript
DESCRIPTION: Declares a constant named 'lbrace' of type Doc<never> representing a document containing a single '{' character. This constant is part of the Doc module in the @effect/printer package.

LANGUAGE: typescript
CODE:
declare const lbrace: Doc<never>

----------------------------------------

TITLE: Implementing MutableList.shift in TypeScript
DESCRIPTION: TypeScript type declaration for the shift operation that removes and returns the first element from a MutableList. The operation returns undefined if the list is empty.

LANGUAGE: typescript
CODE:
declare const shift: <A>(self: MutableList<A>) => A | undefined

----------------------------------------

TITLE: Checking for RuntimeException in TypeScript
DESCRIPTION: This function determines if an unknown value is a RuntimeException. It takes an unknown input and returns a boolean indicating whether the input is a RuntimeException. The function uses a type predicate to narrow the type of the input if it returns true.

LANGUAGE: typescript
CODE:
declare const isRuntimeException: (u: unknown) => u is RuntimeException

----------------------------------------

TITLE: Initializing Do Notation Block in Effect Micro Module
DESCRIPTION: Defines the type signature for the Do function that initiates a do notation block. The function returns a Micro type with empty object parameters, never type for error and output.

LANGUAGE: typescript
CODE:
declare const Do: Micro<{}, never, never>

----------------------------------------

TITLE: Defining setHost Function for URL Host Modification in TypeScript
DESCRIPTION: This code snippet defines the setHost function, which updates the host (domain and port) of a URL. It provides two function signatures: one that takes a host string and returns a function to update a URL, and another that directly takes a URL and a host string to update.

LANGUAGE: typescript
CODE:
declare const setHost: { (host: string): (url: URL) => URL; (url: URL, host: string): URL; }

----------------------------------------

TITLE: Defining collectAllToSetN Sink Function in TypeScript
DESCRIPTION: This function creates a sink that collects the first n distinct inputs into a HashSet. It takes a number parameter n and returns a Sink that operates on HashSet<In> and inputs/outputs of type In.

LANGUAGE: typescript
CODE:
declare const collectAllToSetN: <In>(n: number) => Sink<HashSet.HashSet<In>, In, In>

----------------------------------------

TITLE: Implementing Default Map Function for Bicovariant in TypeScript
DESCRIPTION: Defines a map function that returns a default implementation for bicovariant type classes. It takes a Bicovariant<F> as an argument and returns a Covariant<F>["map"] function.

LANGUAGE: typescript
CODE:
declare const map: <F extends TypeLambda>(F: Bicovariant<F>) => Covariant<F>["map"]

----------------------------------------

TITLE: Using isEmptyReadonlyRecord Function in TypeScript
DESCRIPTION: Demonstrates how to use the isEmptyReadonlyRecord function to determine if a record is empty. The function returns true for an empty object and false for a non-empty object.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { isEmptyReadonlyRecord } from "effect/Record"

assert.deepStrictEqual(isEmptyReadonlyRecord({}), true);
assert.deepStrictEqual(isEmptyReadonlyRecord({ a: 3 }), false);

----------------------------------------

TITLE: Defining Shallow Interface for Document Optimization in TypeScript
DESCRIPTION: Defines a TypeScript interface named Shallow that represents a shallow optimization mode for document fusion. The interface contains a readonly tag property to identify the optimization type.

LANGUAGE: typescript
CODE:
export interface Shallow {
  readonly _tag: "Shallow"
}

----------------------------------------

TITLE: Implementing isTextStream Function in TypeScript for DocStream Module
DESCRIPTION: This function checks if a given DocStream is of type TextStream. It takes a DocStream<A> as input and returns a boolean indicating whether it is a TextStream<A>. This is useful for type narrowing and conditional logic based on stream types.

LANGUAGE: typescript
CODE:
declare const isTextStream: <A>(self: DocStream<A>) => self is TextStream<A>

----------------------------------------

TITLE: Checking for InvalidData ConfigError in TypeScript
DESCRIPTION: The isInvalidData function is a type guard that determines if a given ConfigError is specifically an InvalidData error. It returns true if the error is of type InvalidData, and false otherwise. This function is useful for narrowing down the type of configuration errors in TypeScript.

LANGUAGE: typescript
CODE:
declare const isInvalidData: (self: ConfigError) => self is InvalidData

----------------------------------------

TITLE: TypeScript Signature for decrement Function in effect/Number
DESCRIPTION: Provides the TypeScript type signature for the decrement function. It takes a number as input and returns a number.

LANGUAGE: typescript
CODE:
declare const decrement: (n: number) => number

----------------------------------------

TITLE: Defining Text Document Function in TypeScript for @effect/printer
DESCRIPTION: This code snippet defines the 'text' function in the Doc module. It creates a document containing a string of text, with specific invariants regarding text length and content. The function takes a string parameter and returns a Doc type with a 'never' generic.

LANGUAGE: typescript
CODE:
declare const text: (text: string) => Doc<never>

----------------------------------------

TITLE: Declaring PubSub Capacity Function in TypeScript
DESCRIPTION: Defines a function that returns the capacity of a PubSub queue. It takes a PubSub instance as a parameter and returns a number representing the queue's capacity.

LANGUAGE: typescript
CODE:
declare const capacity: <A>(self: PubSub<A>) => number

----------------------------------------

TITLE: Taking Values from Priority Queue in TypeScript
DESCRIPTION: Function that takes a value from a TPriorityQueue, implementing a retry mechanism until a value becomes available in the queue. Returns an STM transaction that resolves to the retrieved value.

LANGUAGE: typescript
CODE:
declare const take: <A>(self: TPriorityQueue<A>) => STM.STM<A>

----------------------------------------

TITLE: Defining Never-Completing Fiber in TypeScript
DESCRIPTION: Defines a constant representing a fiber that never completes - it neither succeeds nor fails. This is useful for representing perpetual computations or as a placeholder for infinite processes.

LANGUAGE: typescript
CODE:
declare const never: Fiber<never, never>

----------------------------------------

TITLE: Brand.all Type Signature Definition
DESCRIPTION: Type signature for the Brand.all method showing its generic constraints and return type. The method combines multiple brand constructors into a single constructor that validates all brand requirements.

LANGUAGE: typescript
CODE:
declare const all: <Brands extends readonly [Brand.Constructor<any>, ...Array<Brand.Constructor<any>>]>(...brands: Brand.EnsureCommonBase<Brands>) => Brand.Constructor<Types.UnionToIntersection<{ [B in keyof Brands]: Brand.FromConstructor<Brands[B]>; }[number]> extends infer X extends Brand<any> ? X : Brand<any>>

----------------------------------------

TITLE: TypeScript Signature for Logger.minimumLogLevel Function
DESCRIPTION: This snippet shows the TypeScript signature for the Logger.minimumLogLevel function. It takes a LogLevel as an argument and returns a Layer that never produces an error.

LANGUAGE: typescript
CODE:
declare const minimumLogLevel: (level: LogLevel.LogLevel) => Layer.Layer<never>

----------------------------------------

TITLE: Type Checking ConfigError And Type in TypeScript
DESCRIPTION: A type predicate function that determines if a given ConfigError instance is specifically of the And type. This is used for type narrowing in TypeScript.

LANGUAGE: typescript
CODE:
declare const isAnd: (self: ConfigError) => self is And

----------------------------------------

TITLE: Creating Interrupt Cause in TypeScript
DESCRIPTION: This function creates an Interrupt cause from a FiberId. It is used to represent a fiber that has been interrupted, storing the identifier of the interrupted fiber for precise tracking of concurrent cancellations.

LANGUAGE: typescript
CODE:
declare const interrupt: (fiberId: FiberId.FiberId) => Cause<never>

----------------------------------------

TITLE: Implementing MutableList Pop Operation in TypeScript
DESCRIPTION: Type declaration for the pop operation that removes and returns the last element from a MutableList. The operation returns undefined if the list is empty.

LANGUAGE: typescript
CODE:
declare const pop: <A>(self: MutableList<A>) => A | undefined

----------------------------------------

TITLE: Using Schema.pickLiteral in TypeScript
DESCRIPTION: Demonstrates how to use Schema.pickLiteral to create a new Schema that only includes specific literal values from an existing schema. It shows the creation of a schema, decoding valid values, and handling invalid values.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Either, Schema } from "effect"

const schema = Schema.Literal("a", "b", "c").pipe(Schema.pickLiteral("a", "b"))

assert.deepStrictEqual(Schema.decodeSync(schema)("a"), "a")
assert.deepStrictEqual(Schema.decodeSync(schema)("b"), "b")
assert.strictEqual(Either.isLeft(Schema.decodeUnknownEither(schema)("c")), true)

----------------------------------------

TITLE: Defining andThen Function in TypeScript
DESCRIPTION: Declares the andThen function, which is a flexible version of flatMap that combines map and flatMap into a single API. It allows direct passing of a Micro effect to be executed after the current effect.

LANGUAGE: typescript
CODE:
declare const andThen: { <A, X>(f: (a: A) => X): <E, R>(self: Micro<A, E, R>) => [X] extends [Micro<infer A1, infer E1, infer R1>] ? Micro<A1, E | E1, R | R1> : Micro<X, E, R>; <X>(f: NotFunction<X>): <A, E, R>(self: Micro<A, E, R>) => [X] extends [Micro<infer A1, infer E1, infer R1>] ? Micro<A1, E | E1, R | R1> : Micro<X, E, R>; <A, E, R, X>(self: Micro<A, E, R>, f: (a: A) => X): [X] extends [Micro<infer A1, infer E1, infer R1>] ? Micro<A1, E | E1, R | R1> : Micro<X, E, R>; <A, E, R, X>(self: Micro<A, E, R>, f: NotFunction<X>): [X] extends [Micro<infer A1, infer E1, infer R1>] ? Micro<A1, E | E1, R | R1> : Micro<X, E, R>; }

----------------------------------------

TITLE: Declaring 'absurd' Function in TypeScript
DESCRIPTION: The 'absurd' function is a utility for handling cases where a value of type 'never' is encountered, indicating an impossible scenario. It takes a parameter of type 'never' and returns a value of any type A, signifying that this function should never actually be called in well-typed code.

LANGUAGE: typescript
CODE:
declare const absurd: <A>(_: never) => A

----------------------------------------

TITLE: Config.unwrap Type Signature in TypeScript
DESCRIPTION: The type signature for the unwrap function, showing it accepts a wrapped configuration of type A and returns a Config of type A.

LANGUAGE: typescript
CODE:
declare const unwrap: <A>(wrapped: Config.Wrap<A>) => Config<A>

----------------------------------------

TITLE: Extracting Recoverable Errors from Cause in TypeScript
DESCRIPTION: The 'failures' function extracts all recoverable errors of type E from a Cause object. It returns a Chunk of errors, which is a list of all Fail values found in the cause. This is useful for collecting known failures for logging or combined error handling.

LANGUAGE: typescript
CODE:
declare const failures: <E>(self: Cause<E>) => Chunk.Chunk<E>

----------------------------------------

TITLE: Inserting Multiple Entries in Effect Trie (TypeScript)
DESCRIPTION: Demonstrates how to insert multiple entries into a Trie data structure using the insertMany function. It compares the result with individual insertions to show equivalence.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Trie, Equal } from "effect"

const trie = Trie.empty<number>().pipe(
  Trie.insert("shells", 0),
  Trie.insert("sells", 1),
  Trie.insert("she", 2)
)

const trieInsert = Trie.empty<number>().pipe(
  Trie.insert("shells", 0),
  Trie.insertMany(
    [["sells", 1], ["she", 2]]
  )
)

assert.equal(
  Equal.equals(trie, trieInsert),
  true
)

----------------------------------------

TITLE: Defining runInShell Function for Command Execution in TypeScript
DESCRIPTION: This code snippet defines the runInShell function, which allows specifying whether a Command should be run inside a shell. It can be used in two ways: either by passing the shell parameter first and then the Command, or by passing the Command first and then the shell parameter.

LANGUAGE: typescript
CODE:
declare const runInShell: { (shell: string | boolean): (self: Command) => Command; (self: Command, shell: string | boolean): Command; }

----------------------------------------

TITLE: Implementing Line Type Check in TypeScript Effect Printer
DESCRIPTION: A type predicate function that determines whether a given Doc instance is specifically of the Line variant. Returns a boolean indicating if the provided Doc is a Line type, using TypeScript type narrowing.

LANGUAGE: typescript
CODE:
declare const isLine: <A>(self: Doc<A>) => self is Line<A>

----------------------------------------

TITLE: Defining Micro.when Function Signature in TypeScript
DESCRIPTION: Declares the signature of the 'when' function in the Micro module. This function allows conditional execution of a Micro effect based on a boolean condition or another Micro effect that resolves to a boolean.

LANGUAGE: typescript
CODE:
declare const when: { <E2 = never, R2 = never>(condition: LazyArg<boolean> | Micro<boolean, E2, R2>): <A, E, R>(self: Micro<A, E, R>) => Micro<Option.Option<A>, E | E2, R | R2>; <A, E, R, E2 = never, R2 = never>(self: Micro<A, E, R>, condition: LazyArg<boolean> | Micro<boolean, E2, R2>): Micro<Option.Option<A>, E | E2, R | R2>; }

----------------------------------------

TITLE: Getting End Time from ScheduleIntervals in TypeScript
DESCRIPTION: A function that takes a ScheduleIntervals object and returns the numeric end time of the latest interval. Used for schedule interval management in the Effect-TS library.

LANGUAGE: typescript
CODE:
declare const end: (self: Intervals) => number

----------------------------------------

TITLE: Checking for MissingData in ConfigError - TypeScript
DESCRIPTION: The isMissingData function is a type guard that checks if a given ConfigError is specifically a MissingData error. It returns true if the error is MissingData, false otherwise. This function is useful for narrowing down error types in configuration handling.

LANGUAGE: typescript
CODE:
declare const isMissingData: (self: ConfigError) => self is MissingData

----------------------------------------

TITLE: TypeScript Function Signature for Record.size
DESCRIPTION: This code block shows the TypeScript function signature for the 'size' function in the Record module. It defines a generic function that takes a readonly record with string keys and returns a number representing the size of the record.

LANGUAGE: typescript
CODE:
declare const size: <K extends string, A>(self: ReadonlyRecord<K, A>) => number

----------------------------------------

TITLE: Defining Minimum Function for Ordered Values in TypeScript
DESCRIPTION: Declares a 'min' function that takes an Order<A> and returns a function to compare two values of type A. If the values are equal, the first argument is chosen as the minimum.

LANGUAGE: typescript
CODE:
declare const min: <A>(O: Order<A>) => { (that: A): (self: A) => A; (self: A, that: A): A; }

----------------------------------------

TITLE: Using Array.intersperse in TypeScript
DESCRIPTION: Demonstrates how to use Array.intersperse to insert a value between elements of an array. The function takes an array and a middle value, placing the middle value between each original array element.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const result = Array.intersperse([1, 2, 3], 0)
console.log(result) // [1, 0, 2, 0, 3]

LANGUAGE: typescript
CODE:
declare const intersperse: { <B>(middle: B): <S extends Iterable<any>>(self: S) => ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>; <A, B>(self: NonEmptyReadonlyArray<A>, middle: B): NonEmptyArray<A | B>; <A, B>(self: Iterable<A>, middle: B): Array<A | B>; }

----------------------------------------

TITLE: Creating Before Interval in TypeScript
DESCRIPTION: Function that constructs an Interval including all time up to and including a specified end time in milliseconds. Returns an Interval object representing this time range.

LANGUAGE: typescript
CODE:
declare const before: (endMilliseconds: number) => Interval

----------------------------------------

TITLE: Executing Commands with Effect Platform
DESCRIPTION: Function signature for starting command execution. Returns an Effect that resolves to either a CommandExecutor or Scope, with potential PlatformError errors. The function takes a Command parameter and manages process execution.

LANGUAGE: typescript
CODE:
declare const start: (command: Command) => Effect<Process, PlatformError, CommandExecutor | Scope>

----------------------------------------

TITLE: Converting DocStream to DocTree using treeForm Function in TypeScript
DESCRIPTION: Function signature for treeForm that transforms a DocStream<A> into a DocTree<A>. This is a core utility function in the @effect/printer package for document tree manipulation.

LANGUAGE: typescript
CODE:
declare const treeForm: <A>(stream: DocStream.DocStream<A>) => DocTree<A>

----------------------------------------

TITLE: Accessing STM Transaction Environment in TypeScript
DESCRIPTION: Defines a function that provides access to the transaction environment context. It takes a function parameter that receives the environment context and returns a value, wrapped in an STM transaction.

LANGUAGE: typescript
CODE:
declare const contextWith: <R0, R>(f: (environment: Context.Context<R0>) => R) => STM<R, never, R0>

----------------------------------------

TITLE: Checking ChildExecutorDecision Type in TypeScript
DESCRIPTION: The isContinue function is a type guard that checks if a ChildExecutorDecision is of type Continue. It returns true if the decision is Continue, false otherwise. This function is useful for conditional logic based on the type of ChildExecutorDecision.

LANGUAGE: typescript
CODE:
declare const isContinue: (self: ChildExecutorDecision) => self is Continue

----------------------------------------

TITLE: TypeScript Function Signature for takeRight
DESCRIPTION: Type declaration for the takeRight function showing its dual interface - it can be called with parameters in either order (curried or direct form).

LANGUAGE: typescript
CODE:
declare const takeRight: { (n: number): (self: string) => string; (self: string, n: number): string; }

----------------------------------------

TITLE: Checking Non-Empty Chunks in TypeScript
DESCRIPTION: The isNonEmpty function determines if a given chunk is not empty. It takes a Chunk<A> as input and returns a boolean indicating whether the chunk is a NonEmptyChunk<A>. This function is useful for type narrowing and ensuring that a chunk contains elements before performing operations on it.

LANGUAGE: typescript
CODE:
declare const isNonEmpty: <A>(self: Chunk<A>) => self is NonEmptyChunk<A>

----------------------------------------

TITLE: Modifying Array Elements with Option Return in TypeScript
DESCRIPTION: The Array.modifyOption function applies a transformation to an element at a specified index in an array. It returns Some with the modified array if successful, or None if the index is out of bounds. This function is useful for safe array modifications.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const input = [1, 2, 3, 4]
const result = Array.modifyOption(input, 2, (n) => n * 2)
console.log(result) // Option.some([1, 2, 6, 4])

const outOfBoundsResult = Array.modifyOption(input, 5, (n) => n * 2)
console.log(outOfBoundsResult) // Option.none()

LANGUAGE: typescript
CODE:
declare const modifyOption: { <A, B, S extends Iterable<A> = Iterable<A>>(i: number, f: (a: ReadonlyArray.Infer<S>) => B): (self: S) => Option.Option<ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>>; <A, B, S extends Iterable<A> = Iterable<A>>(self: S, i: number, f: (a: ReadonlyArray.Infer<S>) => B): Option.Option<ReadonlyArray.With<S, ReadonlyArray.Infer<S> | B>>; }

----------------------------------------

TITLE: Implementing FiberRef Localization in RequestResolver
DESCRIPTION: Function that creates a new data source with a localized FiberRef value. It supports both curried and uncurried versions, allowing for flexible usage patterns when working with request resolvers and fiber references.

LANGUAGE: typescript
CODE:
declare const locally: { 
  <A>(self: FiberRef<A>, value: A): <R, B extends Request.Request<any, any>>(use: RequestResolver<B, R>) => RequestResolver<B, R>; 
  <R, B extends Request.Request<any, any>, A>(use: RequestResolver<B, R>, self: FiberRef<A>, value: A): RequestResolver<B, R>; 
}

----------------------------------------

TITLE: Defining Empty Interface in TypeScript
DESCRIPTION: TypeScript interface definition for Empty cause type that represents a lack of errors. It extends Cause.Variance, Equal.Equal, Pipeable, and Inspectable interfaces and includes a readonly _tag property set to "Empty".

LANGUAGE: typescript
CODE:
export interface Empty extends Cause.Variance<never>, Equal.Equal, Pipeable, Inspectable {
  readonly _tag: "Empty"
}

----------------------------------------

TITLE: Implementing Predicate Sink in TypeScript
DESCRIPTION: Defines a type signature for creating a sink that evaluates whether all elements satisfy a given predicate. The sink takes input elements of type In and returns a boolean result.

LANGUAGE: typescript
CODE:
declare const every: <In>(predicate: Predicate<In>) => Sink<boolean, In, In>

----------------------------------------

TITLE: Defining ScopedRef Interface in TypeScript
DESCRIPTION: Defines the core interface for ScopedRef which extends Effect.Effect. It maintains a synchronized reference to a tuple containing a closeable scope and a value. The interface includes type variance handling and unification symbols for type system operations.

LANGUAGE: typescript
CODE:
export interface ScopedRef<in out A> extends Effect.Effect<A>, ScopedRef.Variance<A>, Pipeable {
  /** @internal */
  readonly ref: Synchronized.SynchronizedRef<readonly [Scope.Scope.Closeable, A]>

  readonly [Unify.typeSymbol]?: unknown
  readonly [Unify.unifySymbol]?: ScopedRefUnify<this>
  readonly [Unify.ignoreSymbol]?: ScopedRefUnifyIgnore
}

----------------------------------------

TITLE: Constructing a Dying Layer in TypeScript using effect's Layer Module
DESCRIPTION: The dieSync function creates a layer that immediately fails with a specified defect. It takes a lazy argument that evaluates to the defect and returns a Layer of unknown type.

LANGUAGE: typescript
CODE:
declare const dieSync: (evaluate: LazyArg<unknown>) => Layer<unknown>

----------------------------------------

TITLE: Either.getLeft Function Signature in TypeScript
DESCRIPTION: This code snippet shows the TypeScript function signature for the Either.getLeft function. It takes an Either<R, L> as input and returns an Option<L>.

LANGUAGE: typescript
CODE:
declare const getLeft: <R, L>(self: Either<R, L>) => Option<L>

----------------------------------------

TITLE: Implementing Fallback Configuration Loading in TypeScript
DESCRIPTION: Defines a function that creates a new config provider with fallback capability. If the primary provider fails to load configuration, it falls back to an alternate provider specified as an argument.

LANGUAGE: typescript
CODE:
declare const orElse: { (that: LazyArg<ConfigProvider>): (self: ConfigProvider) => ConfigProvider; (self: ConfigProvider, that: LazyArg<ConfigProvider>): ConfigProvider; }

----------------------------------------

TITLE: Implementing Stream Repetition with Schedule in TypeScript
DESCRIPTION: Function signature for repeatWith that takes a stream, schedule, and transformation functions for both stream elements and schedule outputs. It repeats the stream execution based on the schedule and combines both types of outputs using provided mapping functions.

LANGUAGE: typescript
CODE:
declare const repeatWith: {
  <B, R2, A, C>(
    schedule: Schedule.Schedule<B, unknown, R2>,
    options: {
      readonly onElement: (a: A) => C;
      readonly onSchedule: (b: B) => C;
    }
  ): <E, R>(self: Stream<A, E, R>) => Stream<C, E, R2 | R>;
  <A, E, R, B, R2, C>(
    self: Stream<A, E, R>,
    schedule: Schedule.Schedule<B, unknown, R2>,
    options: {
      readonly onElement: (a: A) => C;
      readonly onSchedule: (b: B) => C;
    }
  ): Stream<C, E, R | R2>;
}

----------------------------------------

TITLE: Defining WellKnownSystem Type in TypeScript
DESCRIPTION: TypeScript type definition that enumerates standardized identifiers for well-known AI systems and platforms. This type is used for the gen_ai.system attribute in telemetry data. Values include major AI providers like OpenAI, Anthropic, Google's Gemini, and various cloud platforms.

LANGUAGE: typescript
CODE:
type WellKnownSystem = | "anthropic"
    | "aws.bedrock"
    | "az.ai.inference"
    | "az.ai.openai"
    | "cohere"
    | "deepseek"
    | "gemini"
    | "groq"
    | "ibm.watsonx.ai"
    | "mistral_ai"
    | "openai"
    | "perplexity"
    | "vertex_ai"
    | "xai"

----------------------------------------

TITLE: Checking UpstreamPullRequest Type in TypeScript
DESCRIPTION: The isPulled function determines if a given UpstreamPullRequest is of type Pulled. It takes an UpstreamPullRequest<A> as input and returns a boolean indicating whether it's a Pulled<A>. This function is useful for type narrowing in conditional logic.

LANGUAGE: typescript
CODE:
declare const isPulled: <A>(self: UpstreamPullRequest<A>) => self is Pulled<A>

----------------------------------------

TITLE: Function Signature for BigDecimal Subtraction in TypeScript
DESCRIPTION: Provides the TypeScript function signature for the subtract operation in the BigDecimal module. It shows two overloads: one for curried usage and another for direct two-argument usage.

LANGUAGE: typescript
CODE:
declare const subtract: { (that: BigDecimal): (self: BigDecimal) => BigDecimal; (self: BigDecimal, that: BigDecimal): BigDecimal; }

----------------------------------------

TITLE: Defining zip Function for Combining Micro Effects in TypeScript
DESCRIPTION: The zip function combines two Micro effects into a single effect that produces a tuple of their results. It can be called with optional concurrent execution settings.

LANGUAGE: typescript
CODE:
declare const zip: { <A2, E2, R2>(that: Micro<A2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; } | undefined): <A, E, R>(self: Micro<A, E, R>) => Micro<[A, A2], E2 | E, R2 | R>; <A, E, R, A2, E2, R2>(self: Micro<A, E, R>, that: Micro<A2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; }): Micro<[A, A2], E | E2, R | R2>; }

----------------------------------------

TITLE: Transforming Config Paths in Effect ConfigProvider
DESCRIPTION: Function that creates a new config provider with transformed path configuration names. It accepts a transformation function and either a config provider instance or returns a function expecting a config provider. Used to adapt configuration property names between different naming conventions.

LANGUAGE: typescript
CODE:
declare const mapInputPath: { 
  (f: (path: string) => string): (self: ConfigProvider) => ConfigProvider; 
  (self: ConfigProvider, f: (path: string) => string): ConfigProvider; 
}

----------------------------------------

TITLE: Declaring size function for Iterable in TypeScript
DESCRIPTION: This code snippet declares the size function, which takes an Iterable<A> as input and returns the number of elements in it. The function is part of the Iterable module in the effect package.

LANGUAGE: typescript
CODE:
declare const size: <A>(self: Iterable<A>) => number

----------------------------------------

TITLE: Defining ParseResult.Transformation Error Class in TypeScript
DESCRIPTION: Class definition for handling transformation errors during parsing. Contains fields for the abstract syntax tree (AST), actual value encountered, error kind (Encoded/Transformation/Type), and the specific parse issue that occurred.

LANGUAGE: typescript
CODE:
declare class Transformation { constructor(
    readonly ast: AST.Transformation,
    readonly actual: unknown,
    readonly kind: "Encoded" | "Transformation" | "Type",
    readonly issue: ParseIssue
  ) }

----------------------------------------

TITLE: TypeScript Type Signature for Record.set Function
DESCRIPTION: Provides the TypeScript type signature for the Record.set function. It shows the function's polymorphic nature, allowing for different key types and value types, and its ability to be used in both curried and uncurried forms.

LANGUAGE: typescript
CODE:
declare const set: { <K extends string | symbol, K1 extends K | ((string | symbol) & {}), B>(key: K1, value: B): <A>(self: ReadonlyRecord<K, A>) => Record<K | K1, A | B>; <K extends string | symbol, A, K1 extends K | ((string | symbol) & {}), B>(self: ReadonlyRecord<K, A>, key: K1, value: B): Record<K | K1, A | B>; }

----------------------------------------

TITLE: Function Signature for Url.fromString in TypeScript
DESCRIPTION: Provides the TypeScript function signature for Url.fromString, showing its parameters and return type. It takes a URL string and an optional base, returning an Either type containing either a URL object or an IllegalArgumentException.

LANGUAGE: typescript
CODE:
declare const fromString: (url: string, base?: string | URL | undefined) => Either.Either<URL, Cause.IllegalArgumentException>

----------------------------------------

TITLE: Creating Top-Level HttpApi Layer in TypeScript
DESCRIPTION: The 'api' function is used to create a top-level HttpApi layer. It takes an HttpApi object as input and returns a Layer that can be used in an Effect application.

LANGUAGE: typescript
CODE:
declare const api: <Id extends string, Groups extends HttpApiGroup.HttpApiGroup.Any, E, R>(api: HttpApi.HttpApi<Id, Groups, E, R>) => Layer.Layer<HttpApi.Api, never, HttpApiGroup.HttpApiGroup.ToService<Id, Groups> | R | HttpApiGroup.HttpApiGroup.ErrorContext<Groups>>

----------------------------------------

TITLE: Defining Micro.sandbox Type Signature in TypeScript
DESCRIPTION: Type signature for the sandbox function that takes a Micro effect and returns a new Micro effect with errors wrapped in MicroCause. This allows for more detailed error handling by preserving the full error context.

LANGUAGE: typescript
CODE:
declare const sandbox: <A, E, R>(self: Micro<A, E, R>) => Micro<A, MicroCause<E>, R>

----------------------------------------

TITLE: Defining Flattened Interface in TypeScript
DESCRIPTION: Defines a generic interface Flattened<A> that represents a FlattenResult where the type parameter A is expected to be flatter than the input. The interface extends Flatten.Variance<A> and includes a discriminator _tag and a value property of type A.

LANGUAGE: typescript
CODE:
export interface Flattened<A> extends Flatten.Variance<A> {
  readonly _tag: "Flattened"
  readonly value: A
}

----------------------------------------

TITLE: Defining STM.map Function in TypeScript
DESCRIPTION: Defines the `map` function for the STM module, which maps the value produced by the effect. It provides two overloads: one for curried usage and another for direct application.

LANGUAGE: typescript
CODE:
declare const map: { <A, B>(f: (a: A) => B): <E, R>(self: STM<A, E, R>) => STM<B, E, R>; <A, E, R, B>(self: STM<A, E, R>, f: (a: A) => B): STM<B, E, R>; }

----------------------------------------

TITLE: Defining mapRequestInput Function in TypeScript for HttpClient Module
DESCRIPTION: This code snippet defines the mapRequestInput function, which allows for the transformation of HttpClientRequest objects before they are sent. It can be used in two ways: as a higher-order function or as a method on an HttpClient instance.

LANGUAGE: typescript
CODE:
declare const mapRequestInput: {
  (f: (a: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest): <E, R>(self: HttpClient.With<E, R>) => HttpClient.With<E, R>;
  <E, R>(self: HttpClient.With<E, R>, f: (a: ClientRequest.HttpClientRequest) => ClientRequest.HttpClientRequest): HttpClient.With<E, R>;
}

----------------------------------------

TITLE: Defining Micro.forever Function in TypeScript
DESCRIPTION: This code snippet defines the signature of the Micro.forever function. It takes a Micro effect as input and returns a new Micro effect that repeats the input effect indefinitely until it fails.

LANGUAGE: typescript
CODE:
declare const forever: <A, E, R>(self: Micro<A, E, R>) => Micro<never, E, R>

----------------------------------------

TITLE: Creating Semaphore Unsafely in TypeScript
DESCRIPTION: The unsafeMakeSemaphore function creates a new Semaphore with a specified number of permits. This function is marked as unsafe, indicating potential risks in its usage. It takes a number of permits as input and returns a Semaphore object.

LANGUAGE: typescript
CODE:
declare const unsafeMakeSemaphore: (permits: number) => Semaphore

----------------------------------------

TITLE: Defining AllAttributes Type for GenAI Telemetry in TypeScript
DESCRIPTION: This code snippet defines the AllAttributes type, which is a combination of various attribute types used for GenAI telemetry. It includes BaseAttributes, OperationAttributes, TokenAttributes, UsageAttributes, RequestAttributes, and ResponseAttributes.

LANGUAGE: typescript
CODE:
type AllAttributes = & BaseAttributes
    & OperationAttributes
    & TokenAttributes
    & UsageAttributes
    & RequestAttributes
    & ResponseAttributes

----------------------------------------

TITLE: Declaring AnsiDoc eraseLine Function - TypeScript
DESCRIPTION: TypeScript declaration for the eraseLine constant that clears the current line in the terminal without changing cursor position. This is part of the AnsiDoc module in @effect/printer-ansi package.

LANGUAGE: typescript
CODE:
declare const eraseLine: AnsiDoc

----------------------------------------

TITLE: Implementing Micro.ensuring in TypeScript
DESCRIPTION: Defines a function that ensures a finalizer effect runs after a Micro effect, regardless of the effect's outcome. The function supports both curried and uncurried variants for flexibility in usage.

LANGUAGE: typescript
CODE:
declare const ensuring: {
  <XE, XR>(finalizer: Micro<void, XE, XR>): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E | XE, R | XR>;
  <A, E, R, XE, XR>(self: Micro<A, E, R>, finalizer: Micro<void, XE, XR>): Micro<A, E | XE, R | XR>;
}

----------------------------------------

TITLE: Type Guard Function for Nesting Doc Type in TypeScript
DESCRIPTION: A type guard function that determines whether a given Doc<A> instance is specifically a Nesting<A> type. Returns true if the document is a Nesting instance, false otherwise.

LANGUAGE: typescript
CODE:
declare const isNesting: <A>(self: Doc<A>) => self is Nesting<A>

----------------------------------------

TITLE: Declaring Uint8ArrayFromHex Schema Type in TypeScript
DESCRIPTION: Type declaration for a Schema that converts hex-encoded strings to Uint8Array. The schema handles the transformation from string input to Uint8Array output with no error type specified.

LANGUAGE: typescript
CODE:
declare const Uint8ArrayFromHex: Schema<Uint8Array<ArrayBufferLike>, string, never>

----------------------------------------

TITLE: Implementing Unbounded Layout Algorithm in TypeScript
DESCRIPTION: Defines the unbounded layout algorithm function that processes a Doc<A> input and produces a DocStream<A> output. This algorithm formats documents without any page width constraints.

LANGUAGE: typescript
CODE:
declare const unbounded: <A>(self: Doc<A>) => DocStream<A>

----------------------------------------

TITLE: Implementing MicroSchedule Union Operation in TypeScript
DESCRIPTION: Defines a function that combines two MicroSchedule instances by taking the minimum duration between recurrences when either schedule wants to recur. The function supports both curried and uncurried calling styles.

LANGUAGE: typescript
CODE:
declare const scheduleUnion: { 
  (that: MicroSchedule): (self: MicroSchedule) => MicroSchedule; 
  (self: MicroSchedule, that: MicroSchedule): MicroSchedule; 
}

----------------------------------------

TITLE: Defining KeyedPool.invalidate Function Signature in TypeScript
DESCRIPTION: TypeScript type declaration for the invalidate function in KeyedPool module. The function supports both curried and uncurried calling styles for invalidating items in a keyed pool, returning an Effect that completes with void.

LANGUAGE: typescript
CODE:
declare const invalidate: { <A>(item: A): <K, E>(self: KeyedPool<K, A, E>) => Effect.Effect<void>; <K, A, E>(self: KeyedPool<K, A, E>, item: A): Effect.Effect<void>; }

----------------------------------------

TITLE: Declaring findAll Function for RedBlackTree in TypeScript
DESCRIPTION: Defines the findAll function for the RedBlackTree data structure. It allows finding all values associated with a specified key in the tree. The function is overloaded to accept either the key first or the tree first, providing flexibility in usage.

LANGUAGE: typescript
CODE:
declare const findAll: { <K>(key: K): <V>(self: RedBlackTree<K, V>) => Chunk<V>; <K, V>(self: RedBlackTree<K, V>, key: K): Chunk<V>; }

----------------------------------------

TITLE: Using vsep Combinator in TypeScript with @effect/printer
DESCRIPTION: Demonstrates how to use the vsep combinator to concatenate documents vertically, and shows the difference between unaligned and aligned output. It also illustrates how grouping affects the separator used.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import * as String from "effect/String"

const unaligned = Doc.hsep([
  Doc.text("prefix"),
  Doc.vsep(Doc.words("text to lay out"))
])

assert.strictEqual(
  Doc.render(unaligned, { style: "pretty" }),
  String.stripMargin(
    `|prefix text
     |to
     |lay
     |out`
  )
)

// The `align` function can be used to align the documents under their first
// element
const aligned = Doc.hsep([
  Doc.text("prefix"),
  Doc.align(Doc.vsep(Doc.words("text to lay out")))
])

assert.strictEqual(
  Doc.render(aligned, { style: "pretty" }),
  String.stripMargin(
    `|prefix text
     |       to
     |       lay
     |       out`
  )
)

----------------------------------------

TITLE: Creating Asynchronous Micro Effects in TypeScript
DESCRIPTION: Defines a function for creating asynchronous Micro effects that can include cleanup logic and abort signal handling. The function takes a register callback that receives a resume function and an AbortSignal, and can optionally return a cleanup effect.

LANGUAGE: typescript
CODE:
declare const async: <A, E = never, R = never>(register: (resume: (effect: Micro<A, E, R>) => void, signal: AbortSignal) => void | Micro<void, never, R>) => Micro<A, E, R>

----------------------------------------

TITLE: Implementing RedBlackTree Node Traversal with Maximum Key Limit
DESCRIPTION: Function signature for traversing a Red-Black Tree, visiting each node with a key less than the specified maximum value. Supports both curried and non-curried function calls, operating on nodes containing key-value pairs.

LANGUAGE: typescript
CODE:
declare const forEachLessThan: { <K, V>(max: K, f: (key: K, value: V) => void): (self: RedBlackTree<K, V>) => void; <K, V>(self: RedBlackTree<K, V>, max: K, f: (key: K, value: V) => void): void; }

----------------------------------------

TITLE: Converting Key-Value Pairs to Record using fromEntries in TypeScript
DESCRIPTION: Demonstrates how to use the fromEntries function to build a record from an iterable of key-value pairs. The function handles potential key conflicts by using the last occurrence of each key-value pair.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { fromEntries } from "effect/Record"

const input: Array<[string, number]> = [["a", 1], ["b", 2]]

assert.deepStrictEqual(fromEntries(input), { a: 1, b: 2 })

LANGUAGE: typescript
CODE:
declare const fromEntries: <Entry extends readonly [string | symbol, any]>(entries: Iterable<Entry>) => Record<ReadonlyRecord.NonLiteralKey<Entry[0]>, Entry[1]>

----------------------------------------

TITLE: Demonstrating Doc.seps Usage in TypeScript
DESCRIPTION: Example showing how Doc.seps formats text with automatic line breaks based on page width. The combinator attempts to lay out documents with spaces, falling back to newlines if width constraints are exceeded.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"
import * as String from "effect/String"

const doc: Doc.Doc<never> = Doc.hsep([
  Doc.text("prefix"),
  Doc.seps(Doc.words("text to lay out"))
])

assert.strictEqual(
  Doc.render(doc, { style: "pretty" }),
  "prefix text to lay out"
)

// If the page width is too narrow, documents are separated by newlines
assert.strictEqual(
  Doc.render(doc, {
    style: "pretty",
    options: { lineWidth: 20 }
  }),
  String.stripMargin(
    `|prefix text
     |to
     |lay
     |out`
  )
)

----------------------------------------

TITLE: Defining MicroSchedule Type in TypeScript
DESCRIPTION: Defines the MicroSchedule type as a function that takes the current attempt number and elapsed time, returning an Option of a number representing the delay for the next attempt. If None is returned, the repetition stops.

LANGUAGE: typescript
CODE:
type MicroSchedule = (attempt: number, elapsed: number) => Option.Option<number>

----------------------------------------

TITLE: Mutating DateTime Objects in Effect TypeScript
DESCRIPTION: A function that modifies a DateTime by applying a mutation function to a cloned Date instance. It handles timezone preservation by applying the timezone before mutation and converting back afterward. The function supports both curried and uncurried calling styles.

LANGUAGE: typescript
CODE:
declare const mutate: { 
  (f: (date: Date) => void): <A extends DateTime>(self: A) => A; 
  <A extends DateTime>(self: A, f: (date: Date) => void): A; 
}

----------------------------------------

TITLE: Creating NonEmptyArray with makeBy Function in TypeScript
DESCRIPTION: The makeBy function creates a NonEmptyArray of a specified length, with each element initialized using a provided function. It normalizes the length to an integer >= 1 and applies the function to each index.

LANGUAGE: typescript
CODE:
import { makeBy } from "effect/Array"

const result = makeBy(5, n => n * 2)
console.log(result) // [0, 2, 4, 6, 8]

LANGUAGE: typescript
CODE:
declare const makeBy: { <A>(f: (i: number) => A): (n: number) => NonEmptyArray<A>; <A>(n: number, f: (i: number) => A): NonEmptyArray<A>; }

----------------------------------------

TITLE: Defining RefinementError Interface in TypeScript
DESCRIPTION: Interface definition for RefinementError that captures validation failures in branded types. Contains meta information and an error message to describe the refinement failure.

LANGUAGE: typescript
CODE:
export interface RefinementError {
    readonly meta: unknown
    readonly message: string
  }

----------------------------------------

TITLE: Declaring Doc.group function in TypeScript
DESCRIPTION: This code snippet declares the 'group' function in the Doc module. It takes a Doc<A> as input and returns a Doc<A>. The function attempts to lay out a document on a single line by removing contained line breaks, adapting to available space.

LANGUAGE: typescript
CODE:
declare const group: <A>(self: Doc<A>) => Doc<A>

----------------------------------------

TITLE: Stream.bindTo Type Signature
DESCRIPTION: Type declaration for the bindTo function showing its polymorphic nature and type constraints. It defines how the function can bind stream values to named properties in an object type.

LANGUAGE: typescript
CODE:
declare const bindTo: { <N extends string>(name: N): <A, E, R>(self: Stream<A, E, R>) => Stream<{ [K in N]: A; }, E, R>; <A, E, R, N extends string>(self: Stream<A, E, R>, name: N): Stream<{ [K in N]: A; }, E, R>; }

----------------------------------------

TITLE: Defining STM.mapError Function in TypeScript
DESCRIPTION: Declares the mapError function for STM (Software Transactional Memory) operations. It allows mapping from one error type to another in STM computations. The function can be used in two ways: by providing just the mapping function, or by providing both the STM computation and the mapping function.

LANGUAGE: typescript
CODE:
declare const mapError: { <E, E2>(f: (error: E) => E2): <A, R>(self: STM<A, E, R>) => STM<A, E2, R>; <A, E, R, E2>(self: STM<A, E, R>, f: (error: E) => E2): STM<A, E2, R>; }

----------------------------------------

TITLE: Extracting Left Values from Record of Either Types in TypeScript
DESCRIPTION: The getLefts function takes a record with Either values and returns a new record containing only the Left values, preserving the original keys. It's useful for filtering out and collecting error cases in a structured way.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Record, Either } from "effect"

assert.deepStrictEqual(
  Record.getLefts({ a: Either.right(1), b: Either.left("err"), c: Either.right(2) }),
  { b: "err" }
)

LANGUAGE: typescript
CODE:
declare const getLefts: <K extends string, R, L>(self: ReadonlyRecord<K, Either<R, L>>) => Record<ReadonlyRecord.NonLiteralKey<K>, L>

----------------------------------------

TITLE: Defining Doc.Char Interface in TypeScript for @effect/printer
DESCRIPTION: This code snippet defines the Doc.Char interface, which represents a document containing a single character. It extends Doc.Variance<A> and includes properties for the tag and the character. The interface has an invariant that it cannot contain the newline character.

LANGUAGE: typescript
CODE:
export interface Char<A> extends Doc.Variance<A> {
  readonly _tag: "Char"
  readonly char: string
}

----------------------------------------

TITLE: Declaring upTo Function for Limiting Schedule Duration in TypeScript
DESCRIPTION: Defines the upTo function that modifies an existing schedule to stop execution after a specified duration. It takes a duration as input and returns a new schedule that limits execution to that fixed duration.

LANGUAGE: typescript
CODE:
declare const upTo: { (duration: Duration.DurationInput): <Out, In, R>(self: Schedule<Out, In, R>) => Schedule<Out, In, R>; <Out, In, R>(self: Schedule<Out, In, R>, duration: Duration.DurationInput): Schedule<Out, In, R>; }

----------------------------------------

TITLE: Merging Cookies Objects in TypeScript
DESCRIPTION: The merge function combines two Cookies objects, removing duplicates from the first. It has two overloads: one taking a single 'that' parameter and returning a function, and another taking both 'self' and 'that' parameters directly.

LANGUAGE: typescript
CODE:
declare const merge: { (that: Cookies): (self: Cookies) => Cookies; (self: Cookies, that: Cookies): Cookies; }

----------------------------------------

TITLE: Using HashSet.toggle in TypeScript with Effect Package
DESCRIPTION: Demonstrates various ways to use the HashSet.toggle function, including data-last (pipeable) API, piped with the pipe function, and data-first API. The toggle function adds a value if it's not present in the HashSet, or removes it if it is present.

LANGUAGE: typescript
CODE:
// Syntax
import { HashSet, pipe } from "effect"

// with `data-last`, a.k.a. `pipeable` API
pipe(HashSet.make(0, 1, 2), HashSet.toggle(0))

// or piped with the pipe function
HashSet.make(0, 1, 2).pipe(HashSet.toggle(0))

// or with `data-first` API
HashSet.toggle(HashSet.make(0, 1, 2), 0)

----------------------------------------

TITLE: Checking DocStream Type in TypeScript
DESCRIPTION: A type guard function that checks whether an unknown value is an instance of DocStream. Returns a boolean indicating if the input value is a DocStream instance. This function provides type narrowing functionality in TypeScript.

LANGUAGE: typescript
CODE:
declare const isDocStream: (u: unknown) => u is DocStream<unknown>

----------------------------------------

TITLE: Storing New Bindings in TMap using TypeScript
DESCRIPTION: The set function allows storing new key-value bindings into a transactional map (TMap). It can be used in two ways: either by passing the TMap as the first argument, or as a curried function where the TMap is the last argument.

LANGUAGE: typescript
CODE:
declare const set: { <K, V>(key: K, value: V): (self: TMap<K, V>) => STM.STM<void>; <K, V>(self: TMap<K, V>, key: K, value: V): STM.STM<void>; }

----------------------------------------

TITLE: Implementing Array Predicate Check with STM in TypeScript
DESCRIPTION: Defines a function that determines if a transactional array contains any elements satisfying a given predicate. The function operates within STM transactions and returns a boolean result.

LANGUAGE: typescript
CODE:
declare const some: { 
  <A>(predicate: Predicate<A>): (self: TArray<A>) => STM.STM<boolean>; 
  <A>(self: TArray<A>, predicate: Predicate<A>): STM.STM<boolean>; 
}

----------------------------------------

TITLE: Mapping Layer Error Channel in TypeScript
DESCRIPTION: The mapError function returns a new Layer with its error channel transformed using a provided function. It can be used in two ways: either by passing the function first and then the Layer, or by passing the Layer first and then the function.

LANGUAGE: typescript
CODE:
declare const mapError: { <E, E2>(f: (error: E) => E2): <A, R>(self: Layer<A, E, R>) => Layer<A, E2, R>; <A, E, R, E2>(self: Layer<A, E, R>, f: (error: E) => E2): Layer<A, E2, R>; }

----------------------------------------

TITLE: Defining LineStream Interface in TypeScript
DESCRIPTION: Defines the LineStream interface that extends DocStream.Variance<A>. It represents a document containing a single line with an indentation level for subsequent lines. Contains properties for type tag, indentation level, and document stream.

LANGUAGE: typescript
CODE:
export interface LineStream<A> extends DocStream.Variance<A> {
  readonly _tag: "LineStream"
  readonly indentation: number
  readonly stream: DocStream<A>
}

----------------------------------------

TITLE: Implementing Timeout with Fallback for Effects in TypeScript
DESCRIPTION: The timeoutOrElse function returns an effect that will timeout the original effect and execute a fallback if the timeout elapses before the effect produces a value. It safely interrupts the running effect if the timeout occurs.

LANGUAGE: typescript
CODE:
declare const timeoutOrElse: {
  <A2, E2, R2>(options: {
    readonly duration: number;
    readonly onTimeout: LazyArg<Micro<A2, E2, R2>>;
  }): <A, E, R>(self: Micro<A, E, R>) => Micro<A | A2, E | E2, R | R2>;
  <A, E, R, A2, E2, R2>(self: Micro<A, E, R>, options: {
    readonly duration: number;
    readonly onTimeout: LazyArg<Micro<A2, E2, R2>>;
  }): Micro<A | A2, E | E2, R | R2>;
}

----------------------------------------

TITLE: Defining flatMap Function for Iterables in TypeScript
DESCRIPTION: Declares the flatMap function that applies a mapping function to each element of an Iterable and concatenates the results. It supports both curried and uncurried forms, allowing flexible usage.

LANGUAGE: typescript
CODE:
declare const flatMap: { <A, B>(f: (a: NoInfer<A>, i: number) => Iterable<B>): (self: Iterable<A>) => Iterable<B>; <A, B>(self: Iterable<A>, f: (a: NoInfer<A>, i: number) => Iterable<B>): Iterable<B>; }

----------------------------------------

TITLE: Launching Effect-TS Layer Type Definition
DESCRIPTION: Type definition for the launch function that builds and maintains a layer until interrupted. Used for long-running applications like HTTP servers that need to maintain a persistent layer.

LANGUAGE: typescript
CODE:
declare const launch: <RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Effect.Effect<never, E, RIn>

----------------------------------------

TITLE: Launching Effect-TS Layer Type Definition
DESCRIPTION: Type definition for the launch function that builds and maintains a layer until interrupted. Used for long-running applications like HTTP servers that need to maintain a persistent layer.

LANGUAGE: typescript
CODE:
declare const launch: <RIn, E, ROut>(self: Layer<ROut, E, RIn>) => Effect.Effect<never, E, RIn>

----------------------------------------

TITLE: Executing Effects with Runtime.runFork in TypeScript
DESCRIPTION: Defines the runFork function signature that executes effects using either a provided Scheduler or the global Scheduler. The function returns a RuntimeFiber that represents the forked computation.

LANGUAGE: typescript
CODE:
declare const runFork: { <R>(runtime: Runtime<R>): <A, E>(effect: Effect.Effect<A, E, R>, options?: RunForkOptions | undefined) => Fiber.RuntimeFiber<A, E>; <R, A, E>(runtime: Runtime<R>, effect: Effect.Effect<A, E, R>, options?: RunForkOptions | undefined): Fiber.RuntimeFiber<A, E>; }

----------------------------------------

TITLE: Function Signature for Stream.groupedWithin in TypeScript
DESCRIPTION: This code snippet shows the TypeScript function signature for the Stream.groupedWithin function. It describes the function's parameters and return type, indicating its usage for grouping stream elements.

LANGUAGE: typescript
CODE:
declare const groupedWithin: { (chunkSize: number, duration: Duration.DurationInput): <A, E, R>(self: Stream<A, E, R>) => Stream<Chunk.Chunk<A>, E, R>; <A, E, R>(self: Stream<A, E, R>, chunkSize: number, duration: Duration.DurationInput): Stream<Chunk.Chunk<A>, E, R>; }

----------------------------------------

TITLE: Implementing Channel.mapInput Function in TypeScript
DESCRIPTION: Defines a function that creates a new channel by transforming the input channel's done value using a provided mapping function. The function supports both curried and uncurried calling styles.

LANGUAGE: typescript
CODE:
declare const mapInput: {
  <InDone0, InDone>(f: (a: InDone0) => InDone): <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>
    (self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) =>
    Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone0, Env>;
  <OutElem, InElem, OutErr, InErr, OutDone, InDone, Env, InDone0>
    (self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>,
     f: (a: InDone0) => InDone): Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone0, Env>;
}

----------------------------------------

TITLE: Implementing Error Handler for Micro Effects in TypeScript
DESCRIPTION: Defines a type signature for the onError function that handles failures in Micro effects. The function takes a finalizer effect that processes the MicroCause of the failed effect and returns a new Micro effect combining the original functionality with error handling.

LANGUAGE: typescript
CODE:
declare const onError: { <A, E, XE, XR>(f: (cause: MicroCause<NoInfer<E>>) => Micro<void, XE, XR>): <R>(self: Micro<A, E, R>) => Micro<A, E | XE, R | XR>; <A, E, R, XE, XR>(self: Micro<A, E, R>, f: (cause: MicroCause<NoInfer<E>>) => Micro<void, XE, XR>): Micro<A, E | XE, R | XR>; }

----------------------------------------

TITLE: Implementing Error Tracking Aspect in Effect-TS
DESCRIPTION: Defines a function that creates an aspect for tracking errors in effects. It takes a metric and a transformation function to process error values before updating the metric. The function is overloaded to support both fluent and pipeline styles of usage.

LANGUAGE: typescript
CODE:
declare const trackErrorWith: {
  <Type, In, Out, In2>(metric: Metric<Type, In, Out>, f: (error: In2) => In): <A, E extends In2, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>;
  <A, E extends In2, R, Type, In, Out, In2>(self: Effect.Effect<A, E, R>, metric: Metric<Type, In, Out>, f: (error: In2) => In): Effect.Effect<A, E, R>;
}

----------------------------------------

TITLE: Function Signature for zipWithPreviousAndNext in TypeScript
DESCRIPTION: Provides the TypeScript signature for the zipWithPreviousAndNext function. It takes a Stream of type A and returns a Stream of tuples containing Option<A> for the previous and next elements, and A for the current element.

LANGUAGE: typescript
CODE:
declare const zipWithPreviousAndNext: <A, E, R>(self: Stream<A, E, R>) => Stream<[Option.Option<A>, A, Option.Option<A>], E, R>

----------------------------------------

TITLE: Types.Equals Implementation in TypeScript
DESCRIPTION: Type-level implementation of the Equals utility that compares two types X and Y using conditional type inference patterns to determine structural equality.

LANGUAGE: typescript
CODE:
type Equals<X, Y> = (<T>() => T extends X ? 1 : 2) extends <
  T
>() => T extends Y ? 1 : 2 ? true
  : false

----------------------------------------

TITLE: Context Merging Function TypeScript Definition
DESCRIPTION: TypeScript type definition for the provideContext function that merges a given Context with the current context. The function supports both curried and uncurried forms for flexible usage patterns.

LANGUAGE: typescript
CODE:
declare const provideContext: { <XR>(context: Context.Context<XR>): <A, E, R>(self: Micro<A, E, R>) => Micro<A, E, Exclude<R, XR>>; <A, E, R, XR>(self: Micro<A, E, R>, context: Context.Context<XR>): Micro<A, E, Exclude<R, XR>>; }

----------------------------------------

TITLE: Implementing STM.every Function in TypeScript
DESCRIPTION: Defines the 'every' function that determines whether all elements of an Iterable<A> satisfy an effectual predicate. It supports both curried and non-curried versions of the function.

LANGUAGE: typescript
CODE:
declare const every: { <A, R, E>(predicate: (a: NoInfer<A>) => STM<boolean, E, R>): (iterable: Iterable<A>) => STM<boolean, E, R>; <A, R, E>(iterable: Iterable<A>, predicate: (a: A) => STM<boolean, E, R>): STM<boolean, E, R>; }

----------------------------------------

TITLE: Signature of Iterable.range Function in TypeScript
DESCRIPTION: Provides the TypeScript type signature for the range function. It takes a start number and an optional end number, returning an Iterable of numbers.

LANGUAGE: typescript
CODE:
declare const range: (start: number, end?: number) => Iterable<number>

----------------------------------------

TITLE: Defining Config Interface in TypeScript
DESCRIPTION: Defines a generic Config interface that extends both Config.Variance and Effect.Effect types. It handles configuration data with built-in error handling through ConfigError.

LANGUAGE: typescript
CODE:
export interface Config<out A> extends Config.Variance<A>, Effect.Effect<A, ConfigError.ConfigError> {}

----------------------------------------

TITLE: Creating Constant Delay MicroSchedule in TypeScript
DESCRIPTION: Function signature for creating a MicroSchedule that generates a constant delay specified in milliseconds. The scheduleSpaced function takes a number parameter representing milliseconds and returns a MicroSchedule instance.

LANGUAGE: typescript
CODE:
declare const scheduleSpaced: (millis: number) => MicroSchedule

----------------------------------------

TITLE: Implementing dropUntil Sink Function in TypeScript
DESCRIPTION: Function signature for creating a sink that drops incoming elements until a given predicate returns true. Takes a predicate function as input and returns a Sink that processes elements of type In.

LANGUAGE: typescript
CODE:
declare const dropUntil: <In>(predicate: Predicate<In>) => Sink<unknown, In, In>

----------------------------------------

TITLE: Function Signature for Stream.acquireRelease in TypeScript
DESCRIPTION: Provides the TypeScript function signature for the Stream.acquireRelease method. It takes an acquire effect and a release function, returning a stream of the acquired resource.

LANGUAGE: typescript
CODE:
declare const acquireRelease: <A, E, R, R2, X>(acquire: Effect.Effect<A, E, R>, release: (resource: A, exit: Exit.Exit<unknown, unknown>) => Effect.Effect<X, never, R2>) => Stream<A, E, R | R2>

----------------------------------------

TITLE: Using Doc.list to Create Formatted Lists in TypeScript
DESCRIPTION: This example demonstrates how to use the Doc.list function from @effect/printer to create a formatted list of numbers. It shows how to handle different lengths of numbers and render the result.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import * as Doc from "@effect/printer/Doc"

const doc = Doc.list(
  ["1", "20", "300", "4000"].map(
    (n) => (n.length === 1 ? Doc.char(n) : Doc.text(n))
  )
)

assert.strictEqual(
  Doc.render(doc, { style: "pretty" }),
  "[1, 20, 300, 4000]"
)

----------------------------------------

TITLE: Creating Stream from AsyncIterable in TypeScript using Effect Library
DESCRIPTION: Demonstrates how to create a stream from an AsyncIterable using the Stream.fromAsyncIterable function. It includes error handling and shows how to run and collect the stream's output.

LANGUAGE: typescript
CODE:
import { Effect, Stream } from "effect"

const myAsyncIterable = async function*() {
  yield 1
  yield 2
}

const stream = Stream.fromAsyncIterable(
  myAsyncIterable(),
  (e) => new Error(String(e)) // Error Handling
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
// { _id: 'Chunk', values: [ 1, 2 ] }

----------------------------------------

TITLE: Implementing dropWhileEffect in Effect Sink Module
DESCRIPTION: Defines a function that creates a Sink which drops incoming elements as long as the provided effectful predicate returns true. The predicate function takes an input value and returns an Effect that resolves to a boolean.

LANGUAGE: typescript
CODE:
declare const dropWhileEffect: <In, E, R>(predicate: (input: In) => Effect.Effect<boolean, E, R>) => Sink<unknown, In, In, E, R>

----------------------------------------

TITLE: Declaring greaterThan Function for RedBlackTree in TypeScript
DESCRIPTION: Defines the greaterThan function for RedBlackTree, which returns an iterator to traverse entries with keys greater than a specified key. It supports both curried and non-curried function calls.

LANGUAGE: typescript
CODE:
declare const greaterThan: { <K>(key: K): <V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>; <K, V>(self: RedBlackTree<K, V>, key: K): Iterable<[K, V]>; }

----------------------------------------

TITLE: Creating Order Instance for Option Values in TypeScript
DESCRIPTION: The getOrder function creates an Order instance for comparing Option values. It uses a provided Order for the inner type. None is considered less than any Some value, and Some values are compared using the provided Order instance.

LANGUAGE: typescript
CODE:
import { Number, Option } from "effect"

const order = Option.getOrder(Number.Order)

console.log(order(Option.none(), Option.none()))
// Output: 0

console.log(order(Option.none(), Option.some(1)))
// Output: -1

console.log(order(Option.some(1), Option.none()))
// Output: 1

console.log(order(Option.some(1), Option.some(2)))
// Output: -1

console.log(order(Option.some(1), Option.some(1)))
// Output: 0

LANGUAGE: typescript
CODE:
declare const getOrder: <A>(O: Order<A>) => Order<Option<A>>

----------------------------------------

TITLE: Composing Schedules in TypeScript with Effect-TS
DESCRIPTION: Defines a compose function that chains two schedules together, where the output of the first schedule becomes the input of the second schedule. The function takes two schedules and returns a new composite schedule that combines their behaviors while selecting the shorter delay between them.

LANGUAGE: typescript
CODE:
declare const compose: { <Out2, Out, R2>(that: Schedule<Out2, Out, R2>): <In, R>(self: Schedule<Out, In, R>) => Schedule<Out2, In, R2 | R>; <Out, In, R, Out2, R2>(self: Schedule<Out, In, R>, that: Schedule<Out2, Out, R2>): Schedule<Out2, In, R | R2>; }

----------------------------------------

TITLE: Declaring leftover Sink Function in TypeScript
DESCRIPTION: Defines the leftover function that creates a sink which doesn't consume input but provides a given chunk as leftovers. It takes a Chunk<L> as input and returns a Sink that outputs void, can handle any input, and has leftovers of type L.

LANGUAGE: typescript
CODE:
declare const leftover: <L>(chunk: Chunk.Chunk<L>) => Sink<void, unknown, L>

----------------------------------------

TITLE: Defining WellKnownServiceTier Type in TypeScript
DESCRIPTION: Defines a union type for well-known service tier values used in OpenAI telemetry attributes. The type specifies 'auto' and 'default' as the allowed values for the gen_ai.openai.request.service_tier attribute.

LANGUAGE: typescript
CODE:
type WellKnownServiceTier = "auto" | "default"

----------------------------------------

TITLE: Partitioning Chunk Elements with partitionMap in TypeScript
DESCRIPTION: The partitionMap function divides the elements of a chunk into two separate chunks using a provided function. It takes a function that returns an Either type and applies it to each element of the chunk, creating two new chunks based on the Left and Right results.

LANGUAGE: typescript
CODE:
declare const partitionMap: { <A, B, C>(f: (a: A) => Either<C, B>): (self: Chunk<A>) => [left: Chunk<B>, right: Chunk<C>]; <A, B, C>(self: Chunk<A>, f: (a: A) => Either<C, B>): [left: Chunk<B>, right: Chunk<C>]; }

----------------------------------------

TITLE: Implementing Schedule.eitherWith Function in TypeScript
DESCRIPTION: Defines the eitherWith function signature that combines two schedules using a provided intervals combining function. The function is overloaded to support both curried and direct invocation patterns.

LANGUAGE: typescript
CODE:
declare const eitherWith: { 
  <Out2, In2, R2>(
    that: Schedule<Out2, In2, R2>, 
    f: (x: Intervals.Intervals, y: Intervals.Intervals) => Intervals.Intervals
  ): <Out, In, R>(
    self: Schedule<Out, In, R>
  ) => Schedule<[Out, Out2], In & In2, R2 | R>; 
  
  <Out, In, R, Out2, In2, R2>(
    self: Schedule<Out, In, R>, 
    that: Schedule<Out2, In2, R2>, 
    f: (x: Intervals.Intervals, y: Intervals.Intervals) => Intervals.Intervals
  ): Schedule<[Out, Out2], In & In2, R | R2>; 
}

----------------------------------------

TITLE: Implementing Sink.zipLeft in TypeScript
DESCRIPTION: Function signature for zipLeft operation that combines two sinks and keeps only the result from the first sink. Supports optional concurrent execution through options parameter. Takes two sinks as input and returns a new combined sink that preserves type information.

LANGUAGE: typescript
CODE:
declare const zipLeft: { <A2, In, In2 extends In, L2, E2, R2>(that: Sink<A2, In2, L2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; } | undefined): <A, L, E, R>(self: Sink<A, In, L, E, R>) => Sink<A, In & In2, L2 | L, E2 | E, R2 | R>; <A, In, L, E, R, A2, In2 extends In, L2, E2, R2>(self: Sink<A, In, L, E, R>, that: Sink<A2, In2, L2, E2, R2>, options?: { readonly concurrent?: boolean | undefined; } | undefined): Sink<A, In & In2, L | L2, E | E2, R | R2>; }

----------------------------------------

TITLE: Array Operations with Pipe
DESCRIPTION: Example showing how to use pipe with array operations as an alternative to method chaining

LANGUAGE: typescript
CODE:
import { pipe, Array } from "effect"

pipe(as, Array.map(f), Array.filter(g))

----------------------------------------

TITLE: Declaring asVoid Function for Option Transformation in TypeScript
DESCRIPTION: Defines the asVoid function that replaces the value inside a Some with void, leaving None unchanged. It's useful when the presence of a value matters more than its content.

LANGUAGE: typescript
CODE:
declare const asVoid: <_>(self: Option<_>) => Option<void>

----------------------------------------

TITLE: Implementing Schedule.zipLeft Function in TypeScript
DESCRIPTION: Defines a function that combines two schedules by intersecting their behavior while only keeping the output from the left schedule. The function is overloaded to support both curried and uncurried forms.

LANGUAGE: typescript
CODE:
declare const zipLeft: {
  <Out2, In2, R2>(that: Schedule<Out2, In2, R2>): <Out, In, R>
    (self: Schedule<Out, In, R>) => Schedule<Out, In & In2, R2 | R>;
  <Out, In, R, Out2, In2, R2>
    (self: Schedule<Out, In, R>, that: Schedule<Out2, In2, R2>): Schedule<Out, In & In2, R | R2>;
}

----------------------------------------

TITLE: Converting Channel to Sink in TypeScript
DESCRIPTION: The toSink function converts a Channel to a Sink. It takes a Channel with specific generic types and returns a Sink with corresponding types. This function is available since version 2.0.0 of the package.

LANGUAGE: typescript
CODE:
declare const toSink: <OutElem, InElem, OutErr, InErr, OutDone, Env>(self: Channel<Chunk.Chunk<OutElem>, Chunk.Chunk<InElem>, OutErr, InErr, OutDone, unknown, Env>) => Sink.Sink<OutDone, InElem, OutElem, OutErr, Env>

----------------------------------------

TITLE: Configuring CORS Middleware in TypeScript using Effect Platform
DESCRIPTION: A middleware layer function that configures CORS (Cross-Origin Resource Sharing) settings for HTTP APIs. It accepts optional configuration for allowed origins, methods, headers, exposed headers, max age, and credentials settings.

LANGUAGE: typescript
CODE:
declare const middlewareCors: (options?: { readonly allowedOrigins?: ReadonlyArray<string> | undefined; readonly allowedMethods?: ReadonlyArray<string> | undefined; readonly allowedHeaders?: ReadonlyArray<string> | undefined; readonly exposedHeaders?: ReadonlyArray<string> | undefined; readonly maxAge?: number | undefined; readonly credentials?: boolean | undefined; } | undefined) => Layer.Layer<never>

----------------------------------------

TITLE: Implementing trackAll Function for Metric Updates in TypeScript
DESCRIPTION: The trackAll function returns an aspect that updates a metric with a specified constant value every time it's applied to an effect, regardless of success or failure. It supports both curried and non-curried invocations.

LANGUAGE: typescript
CODE:
declare const trackAll: { <In>(input: In): <Type, Out>(self: Metric<Type, In, Out>) => <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; <Type, In, Out>(self: Metric<Type, In, Out>, input: In): <A, E, R>(effect: Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>; }

----------------------------------------

TITLE: Defining ShardManagerClient Class in TypeScript
DESCRIPTION: Declares the ShardManagerClient class, which represents a client for communicating with the ShardManager. This class is part of the @effect/cluster package and is used in clustered environments for shard management.

LANGUAGE: typescript
CODE:
declare class ShardManagerClient

----------------------------------------

TITLE: Implementing Single Delay Schedule in TypeScript
DESCRIPTION: Defines a function that creates a schedule executing once after a specified duration. The schedule does not repeat after its single execution. The function takes a DurationInput parameter and returns a Schedule of Duration type.

LANGUAGE: typescript
CODE:
declare const fromDelay: (delay: Duration.DurationInput) => Schedule<Duration.Duration>

----------------------------------------

TITLE: Checking Layer Type in TypeScript
DESCRIPTION: The isLayer function is a type guard that checks if a given value is a Layer. It returns true if the value is a Layer, and false otherwise. This function is useful for type-checking and ensuring type safety when working with Layer objects.

LANGUAGE: typescript
CODE:
declare const isLayer: (u: unknown) => u is Layer<unknown, unknown, unknown>

----------------------------------------

TITLE: Retrieving Values from TMap with Fallback in TypeScript
DESCRIPTION: The getOrElse function retrieves a value associated with a given key from a TMap, or returns a default value if the key isn't present. It can be used in two ways: as a curried function or with all parameters at once.

LANGUAGE: typescript
CODE:
declare const getOrElse: { <K, V>(key: K, fallback: LazyArg<V>): (self: TMap<K, V>) => STM.STM<V>; <K, V>(self: TMap<K, V>, key: K, fallback: LazyArg<V>): STM.STM<V>; }

----------------------------------------

TITLE: Defining ShardManager.Rpcs Class in TypeScript
DESCRIPTION: Declares the ShardManager.Rpcs class, which represents the messaging protocol for the ShardManager. This class is part of the @effect/cluster package and is defined in the ShardManager module.

LANGUAGE: typescript
CODE:
declare class Rpcs

----------------------------------------

TITLE: Declaring filterOrDie Function Signature in TypeScript
DESCRIPTION: Type declaration for the filterOrDie function that filters an Effect value using a predicate or refinement, dying with a custom defect if the filter fails. The function supports both curried and uncurried forms, working with predicates and refinements.

LANGUAGE: typescript
CODE:
declare const filterOrDie: {
  <A, B extends A>(refinement: Refinement<NoInfer<A>, B>, orDieWith: (a: NoInfer<A>) => unknown): <E, R>(self: Effect<A, E, R>) => Effect<B, E, R>;
  <A>(predicate: Predicate<NoInfer<A>>, orDieWith: (a: NoInfer<A>) => unknown): <E, R>(self: Effect<A, E, R>) => Effect<A, E, R>;
  <A, E, R, B extends A>(self: Effect<A, E, R>, refinement: Refinement<A, B>, orDieWith: (a: A) => unknown): Effect<B, E, R>;
  <A, E, R>(self: Effect<A, E, R>, predicate: Predicate<A>, orDieWith: (a: A) => unknown): Effect<A, E, R>;
}

----------------------------------------

TITLE: Combining Parallel Causes in TypeScript
DESCRIPTION: The 'parallel' function merges two Cause instances that occurred simultaneously, retaining both errors for richer error reporting and debugging. It takes two Cause instances as input and returns a combined Cause instance.

LANGUAGE: typescript
CODE:
declare const parallel: <E, E2>(left: Cause<E>, right: Cause<E2>) => Cause<E | E2>

----------------------------------------

TITLE: Constructing HttpApp from HttpApi in TypeScript
DESCRIPTION: Function signature for creating an HttpApp from an HttpApi instance. Returns an Effect that produces an HttpApp.Default with HttpRouter default services.

LANGUAGE: typescript
CODE:
declare const httpApp: Effect.Effect<HttpApp.Default<never, HttpRouter.HttpRouter.DefaultServices>, never, HttpApi.Api | Router | Middleware>

----------------------------------------

TITLE: Retrieving Annotations with TestServices.get in TypeScript
DESCRIPTION: The 'get' function accesses an Annotations instance in the context and retrieves the annotation of the specified type, or its default value if none exists. It takes a TestAnnotation key as a parameter and returns an Effect containing the annotation value.

LANGUAGE: typescript
CODE:
declare const get: <A>(key: TestAnnotation.TestAnnotation<A>) => Effect.Effect<A>

----------------------------------------

TITLE: Effect.logTrace Type Signature
DESCRIPTION: TypeScript type signature for the logTrace function, showing it accepts any number of messages as arguments and returns an Effect with void return type and no requirements or errors.

LANGUAGE: typescript
CODE:
declare const logTrace: (...message: ReadonlyArray<any>) => Effect<void, never, never>

----------------------------------------

TITLE: Defining replicateSTMDiscard Function in TypeScript
DESCRIPTION: Declares the replicateSTMDiscard function which takes a number and an STM transaction, performing the transaction the specified number of times and discarding the results. It has two overloads to support different parameter orders.

LANGUAGE: typescript
CODE:
declare const replicateSTMDiscard: { (n: number): <A, E, R>(self: STM<A, E, R>) => STM<void, E, R>; <A, E, R>(self: STM<A, E, R>, n: number): STM<void, E, R>; }

----------------------------------------

TITLE: Implementing Default 'of' Composition in TypeScript
DESCRIPTION: The ofComposition function returns a default 'of' composition for two types F and G that implement the Of typeclass. It takes Of instances for F and G as parameters and returns a function that lifts a value of type A into the composed structure F[G[A]].

LANGUAGE: typescript
CODE:
declare const ofComposition: <F extends TypeLambda, G extends TypeLambda>(F: Of<F>, G: Of<G>) => <A>(a: A) => Kind<F, unknown, never, never, Kind<G, unknown, never, never, A>>

----------------------------------------

TITLE: Defining provideWithLive Function in TypeScript for Effect Package
DESCRIPTION: Declares the provideWithLive function, which takes a transformation function and an Effect, running the transformation with live services while keeping the main workflow on test services. It has two overloads to support different calling patterns.

LANGUAGE: TypeScript
CODE:
declare const provideWithLive: (<A, E, R, A2, E2, R2>(f: (effect: Effect.Effect<A, E, R>) => Effect.Effect<A2, E2, R2>) => (self: Effect.Effect<A, E, R>) => Effect.Effect<A2, E | E2, R | R2>) & (<A, E, R, A2, E2, R2>(self: Effect.Effect<A, E, R>, f: (effect: Effect.Effect<A, E, R>) => Effect.Effect<A2, E2, R2>) => Effect.Effect<A2, E | E2, R | R2>)

----------------------------------------

TITLE: Effect.firstSuccessOf Type Definition in TypeScript
DESCRIPTION: Type signature for the firstSuccessOf function showing its generic type constraints and return type. The function accepts an iterable of effects and returns a new effect that succeeds with the first successful result.

LANGUAGE: typescript
CODE:
declare const firstSuccessOf: <Eff extends Effect<any, any, any>>(effects: Iterable<Eff>) => Effect<Effect.Success<Eff>, Effect.Error<Eff>, Effect.Context<Eff>>

----------------------------------------

TITLE: Defining OpenApi.Transform Class in TypeScript
DESCRIPTION: Declares the Transform class within the OpenApi module. This class is used to transform generated OpenAPI specifications. It is part of the @effect/platform package.

LANGUAGE: typescript
CODE:
declare class Transform

----------------------------------------

TITLE: Defining scopedContext Function in Layer Module (TypeScript)
DESCRIPTION: Declares the scopedContext function which constructs a layer from a specified scoped effect. The effect must return one or more services. It takes an Effect as input and returns a Layer, excluding the Scope from the environment type.

LANGUAGE: typescript
CODE:
declare const scopedContext: <A, E, R>(effect: Effect.Effect<Context.Context<A>, E, R>) => Layer<A, E, Exclude<R, Scope.Scope>>

----------------------------------------

TITLE: Creating Timer Metric with Boundaries in TypeScript
DESCRIPTION: Function signature for creating a timer metric that tracks durations in milliseconds using histogram boundaries. The timer automatically includes a time unit tag and allows for custom boundaries and optional description.

LANGUAGE: typescript
CODE:
declare const timerWithBoundaries: (name: string, boundaries: ReadonlyArray<number>, description?: string) => Metric<MetricKeyType.MetricKeyType.Histogram, Duration.Duration, MetricState.MetricState.Histogram>

----------------------------------------

TITLE: Implementing Reverse Iterator for RedBlackTree in TypeScript
DESCRIPTION: Defines a function that returns an iterator to traverse RedBlackTree entries in reverse order, starting from entries with keys greater than or equal to a specified key. The function supports both curried and uncurried calling styles.

LANGUAGE: typescript
CODE:
declare const greaterThanEqualReversed: { 
  <K>(key: K): <V>(self: RedBlackTree<K, V>) => Iterable<[K, V]>; 
  <K, V>(self: RedBlackTree<K, V>, key: K): Iterable<[K, V]>; 
}

----------------------------------------

TITLE: Declaring 'as' Function in STM Module of Effect Package
DESCRIPTION: Declares the 'as' function which maps the success value of an STM effect to a specified constant value. It has two overloads: one for curried usage and another for direct application.

LANGUAGE: typescript
CODE:
declare const as: { <A2>(value: A2): <A, E, R>(self: STM<A, E, R>) => STM<A2, E, R>; <A, E, R, A2>(self: STM<A, E, R>, value: A2): STM<A2, E, R>; }

----------------------------------------

TITLE: Implementing Sink Finalizer in TypeScript using Effect-TS
DESCRIPTION: Defines a function that attaches a finalizer to a sink. The finalizer executes when the sink begins execution, regardless of completion status. The function is overloaded to support both curried and non-curried parameter passing.

LANGUAGE: typescript
CODE:
declare const ensuringWith: {
  <A, E, X, R2>(finalizer: (exit: Exit.Exit<A, E>) => Effect.Effect<X, never, R2>):
    <In, L, R>(self: Sink<A, In, L, E, R>) => Sink<A, In, L, E, R2 | R>;
  <A, In, L, E, R, X, R2>(self: Sink<A, In, L, E, R>,
    finalizer: (exit: Exit.Exit<A, E>) => Effect.Effect<X, never, R2>):
    Sink<A, In, L, E, R | R2>;
}

----------------------------------------

TITLE: Type Signature of Schema.StringFromUriComponent in TypeScript
DESCRIPTION: This code snippet shows the type signature of the StringFromUriComponent schema. It is defined as a transformOrFail type that works with string schemas and never produces an error.

LANGUAGE: typescript
CODE:
declare const StringFromUriComponent: transformOrFail<SchemaClass<string, string, never>, typeof String$, never>

----------------------------------------

TITLE: Releasing Read Lock in TReentrantLock - TypeScript
DESCRIPTION: Function signature for releasing a read lock held by the current fiber in a TReentrantLock implementation. Returns an STM operation that resolves to the number of remaining read locks held by the fiber.

LANGUAGE: typescript
CODE:
declare const releaseRead: (self: TReentrantLock) => STM.STM<number>

----------------------------------------

TITLE: Implementing Doc.parenthesized Type Definition in TypeScript
DESCRIPTION: Type signature for the parenthesized function that takes a Doc<A> and returns a new Doc<A> with parentheses around it. The function is generic over type parameter A.

LANGUAGE: typescript
CODE:
declare const parenthesized: <A>(self: Doc<A>) => Doc<A>

----------------------------------------

TITLE: TypeScript Function Signature for isPositive
DESCRIPTION: Defines the TypeScript function signature for the isPositive function in the BigDecimal module. It takes a BigDecimal as input and returns a boolean indicating whether the value is positive.

LANGUAGE: typescript
CODE:
declare const isPositive: (n: BigDecimal) => boolean

----------------------------------------

TITLE: Using Schema.pluck for Field Extraction in TypeScript
DESCRIPTION: Demonstrates how to use Schema.pluck to extract and transform a single field from a structured schema. The example shows extracting a 'column1' field from a table structure and converting string values to numbers.

LANGUAGE: typescript
CODE:
import * as Schema from "effect/Schema"

// ---------------------------------------------
// use case: pull out a single field from a
// struct through a transformation
// ---------------------------------------------

const mytable = Schema.Struct({
  column1: Schema.NumberFromString,
  column2: Schema.Number
})

// const pullOutColumn: S.Schema<number, {
//     readonly column1: string;
// }, never>
const pullOutColumn = mytable.pipe(Schema.pluck("column1"))

console.log(Schema.decodeUnknownEither(Schema.Array(pullOutColumn))([{ column1: "1", column2: 100 }, { column1: "2", column2: 300 }]))
// Output: { _id: 'Either', _tag: 'Right', right: [ 1, 2 ] }

----------------------------------------

TITLE: Zipping MetricPolling Types in TypeScript
DESCRIPTION: Function signature for zipping two MetricPolling instances together. The zip operation combines two polling metrics into a single metric that produces paired results. The resulting metric has combined type parameters for input and output types, and unions of resource and error types.

LANGUAGE: typescript
CODE:
declare const zip: { <Type2, In2, R2, E2, Out2>(that: MetricPolling<Type2, In2, R2, E2, Out2>): <Type, In, R, E, Out>(self: MetricPolling<Type, In, R, E, Out>) => MetricPolling<readonly [Type, Type2], readonly [In, In2], R2 | R, E2 | E, [Out, Out2]>; <Type, In, R, E, Out, Type2, In2, R2, E2, Out2>(self: MetricPolling<Type, In, R, E, Out>, that: MetricPolling<Type2, In2, R2, E2, Out2>): MetricPolling<readonly [Type, Type2], readonly [In, In2], R | R2, E | E2, [Out, Out2]>; }

----------------------------------------

TITLE: Implementing findLastSTM Function in TypeScript for TArray
DESCRIPTION: Function signature for finding the last element in a transactional array that matches a given predicate. The function operates within the STM (Software Transactional Memory) context and returns an Option type containing the found element.

LANGUAGE: typescript
CODE:
declare const findLastSTM: {
  <A, R, E>(predicate: (value: A) => STM.STM<boolean, E, R>): (self: TArray<A>) => STM.STM<Option.Option<A>, E, R>;
  <A, R, E>(self: TArray<A>, predicate: (value: A) => STM.STM<boolean, E, R>): STM.STM<Option.Option<A>, E, R>;
}

----------------------------------------

TITLE: Implementing filterMapWhile Array Operation in TypeScript
DESCRIPTION: Example demonstrating how to use filterMapWhile to transform numbers into their squares until encountering an odd number. The function processes elements until the first None result is encountered, combining filtering and mapping in a single pass.

LANGUAGE: typescript
CODE:
import { Array, Option } from "effect"

const toSquareTillOdd = (x: number) => x % 2 === 0 ? Option.some(x * x) : Option.none()

const result = Array.filterMapWhile([2, 4, 5], toSquareTillOdd)
console.log(result) // [4, 16]

LANGUAGE: typescript
CODE:
declare const filterMapWhile: { <A, B>(f: (a: A, i: number) => Option.Option<B>): (self: Iterable<A>) => Array<B>; <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option.Option<B>): Array<B>; }

----------------------------------------

TITLE: Defining Uncapitalize Schema Class in TypeScript
DESCRIPTION: This code snippet defines the Uncapitalize class, which is a schema for converting strings to uncapitalized format. It is part of the Schema module in the Effect package.

LANGUAGE: typescript
CODE:
declare class Uncapitalize

----------------------------------------

TITLE: Implementing Iterable Chunking in TypeScript
DESCRIPTION: Function signature for chunksOf operation that splits an Iterable into fixed-length pieces. Takes a number n as chunk size and returns an Iterable of Arrays. Supports both curried and uncurried function calls.

LANGUAGE: typescript
CODE:
declare const chunksOf: { (n: number): <A>(self: Iterable<A>) => Iterable<Array<A>>; <A>(self: Iterable<A>, n: number): Iterable<Array<A>>; }

----------------------------------------

TITLE: Creating File-Based Logger with PlatformLogger.toFile in TypeScript
DESCRIPTION: Demonstrates how to create a file-based logger using PlatformLogger.toFile. It shows the setup process, including importing necessary modules, creating the logger, and running a sample logging operation.

LANGUAGE: typescript
CODE:
import { PlatformLogger } from "@effect/platform"
import { NodeFileSystem, NodeRuntime } from "@effect/platform-node"
import { Effect, Layer, Logger } from "effect"

const fileLogger = Logger.logfmtLogger.pipe(
  PlatformLogger.toFile("/tmp/log.txt")
)
const LoggerLive = Logger.replaceScoped(Logger.defaultLogger, fileLogger).pipe(
  Layer.provide(NodeFileSystem.layer)
)

Effect.log("a").pipe(
  Effect.zipRight(Effect.log("b")),
  Effect.zipRight(Effect.log("c")),
  Effect.provide(LoggerLive),
  NodeRuntime.runMain
)

----------------------------------------

TITLE: Declaring UnknownExceptionTypeId Symbol in TypeScript
DESCRIPTION: Declares a unique symbol UnknownExceptionTypeId used to identify the UnknownException type. This symbol is typically used for generic or unexpected errors that don't fit other specific exception categories.

LANGUAGE: typescript
CODE:
declare const UnknownExceptionTypeId: unique symbol

----------------------------------------

TITLE: Implementing No-op Runner Health Layer in TypeScript
DESCRIPTION: Defines a Layer that always considers a Runner healthy, primarily used for testing scenarios. The layer has no requirements (never) and produces no errors (never).

LANGUAGE: typescript
CODE:
declare const layerNoop: Layer.Layer<RunnerHealth, never, never>

----------------------------------------

TITLE: Defining findLast Function for Iterables in TypeScript
DESCRIPTION: Declares the findLast function with multiple overloads to find the last element in an iterable that satisfies a predicate. It supports different input types including predicates, refinements, and functions returning Options.

LANGUAGE: typescript
CODE:
declare const findLast: { <A, B>(f: (a: NoInfer<A>, i: number) => Option<B>): (self: Iterable<A>) => Option<B>; <A, B extends A>(refinement: (a: NoInfer<A>, i: number) => a is B): (self: Iterable<A>) => Option<B>; <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Option<A>; <A, B>(self: Iterable<A>, f: (a: A, i: number) => Option<B>): Option<B>; <A, B extends A>(self: Iterable<A>, refinement: (a: A, i: number) => a is B): Option<B>; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Option<A>; }

----------------------------------------

TITLE: Declaring CauseTypeId Symbol in TypeScript
DESCRIPTION: Declares a unique symbol CauseTypeId used to identify instances of the Cause data type. This symbol can be used for advanced operations like refining types or building internal utilities to check if an unknown value is a Cause.

LANGUAGE: typescript
CODE:
declare const CauseTypeId: unique symbol

----------------------------------------

TITLE: Implementing Channel Sequential Composition in TypeScript
DESCRIPTION: Defines a function for sequential composition of channels where the resulting channel terminates with the terminal value of the second channel. Supports both curried and uncurried versions with optional concurrent execution.

LANGUAGE: typescript
CODE:
declare const zipRight: { <Env1, InErr1, InElem1, InDone1, OutErr1, OutElem1, OutDone1>(that: Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>, options?: { readonly concurrent?: boolean | undefined; }): <Env, InErr, InElem, InDone, OutErr, OutElem, OutDone>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>) => Channel<OutElem1 | OutElem, InElem & InElem1, OutErr1 | OutErr, InErr & InErr1, OutDone1, InDone & InDone1, Env1 | Env>; <Env, InErr, InElem, InDone, OutErr, OutElem, OutDone, Env1, InErr1, InElem1, InDone1, OutErr1, OutElem1, OutDone1>(self: Channel<OutElem, InElem, OutErr, InErr, OutDone, InDone, Env>, that: Channel<OutElem1, InElem1, OutErr1, InErr1, OutDone1, InDone1, Env1>, options?: { readonly concurrent?: boolean | undefined; }): Channel<OutElem | OutElem1, InElem & InElem1, OutErr | OutErr1, InErr & InErr1, OutDone1, InDone & InDone1, Env | Env1>; }

----------------------------------------

TITLE: Declaring takeFirst Function in TypeScript for TSet Module
DESCRIPTION: Defines the takeFirst function, which takes the first matching value from a TSet or retries until one is found. It accepts a predicate function and returns an STM (Software Transactional Memory) operation.

LANGUAGE: typescript
CODE:
declare const takeFirst: { <A, B>(pf: (a: A) => Option.Option<B>): (self: TSet<A>) => STM.STM<B>; <A, B>(self: TSet<A>, pf: (a: A) => Option.Option<B>): STM.STM<B>; }

----------------------------------------

TITLE: Using getLefts with Effect Iterable
DESCRIPTION: Demonstrates how to use getLefts to extract Left values from an Iterable of Either types. The example shows filtering an array containing both Right and Left values to get only the Left values.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Iterable, Either } from "effect"

assert.deepStrictEqual(
  Array.from(Iterable.getLefts([Either.right(1), Either.left("err"), Either.right(2)])),
  ["err"]
)

----------------------------------------

TITLE: Type Checking for Cause Objects in TypeScript
DESCRIPTION: The isCause function is a type guard that checks if a given value is of type Cause<unknown>. It takes an unknown input and returns a boolean indicating whether the input is a Cause object.

LANGUAGE: typescript
CODE:
declare const isCause: (u: unknown) => u is Cause<unknown>

----------------------------------------

TITLE: Defining Router Class for HTTP API in TypeScript
DESCRIPTION: This code snippet defines the Router class used for attaching API endpoints. It is part of the HttpApiBuilder module in the @effect/platform package.

LANGUAGE: typescript
CODE:
declare class Router

----------------------------------------

TITLE: Implementing Queue Shutdown Detection in TypeScript using Effect
DESCRIPTION: Defines an STM transaction that waits for a queue to be shutdown. The function works with both TDequeue and TEnqueue types and returns a void STM transaction that completes when shutdown occurs.

LANGUAGE: typescript
CODE:
declare const awaitShutdown: <A>(self: TDequeue<A> | TEnqueue<A>) => STM.STM<void>

----------------------------------------

TITLE: Finding Last Index in Array using Effect Library
DESCRIPTION: Demonstrates how to use Array.findLastIndex to find the last index where a predicate condition is true. Returns an Option type containing the index if found.

LANGUAGE: typescript
CODE:
import { Array } from "effect"

const result = Array.findLastIndex([1, 3, 8, 9], x => x < 5)
console.log(result) // Option.some(1)

LANGUAGE: typescript
CODE:
declare const findLastIndex: { <A>(predicate: (a: NoInfer<A>, i: number) => boolean): (self: Iterable<A>) => Option.Option<number>; <A>(self: Iterable<A>, predicate: (a: A, i: number) => boolean): Option.Option<number>; }

----------------------------------------

TITLE: Implementing Strict Less Than Comparison in TypeScript using Effect's Order Module
DESCRIPTION: This function creates a comparator to test if one value is strictly less than another. It takes an Order<A> as input and returns a function that can be used for comparison. The function can be called with two arguments or partially applied.

LANGUAGE: typescript
CODE:
declare const lessThan: <A>(O: Order<A>) => { (that: A): (self: A) => boolean; (self: A, that: A): boolean; }

----------------------------------------

TITLE: Defining Chunk.union Function in TypeScript
DESCRIPTION: Defines the union function for the Chunk module. This function creates a Chunk of unique values, in order, from all given Chunks. It supports both curried and non-curried invocations.

LANGUAGE: typescript
CODE:
declare const union: { <A>(that: Chunk<A>): <B>(self: Chunk<B>) => Chunk<A | B>; <A, B>(self: Chunk<A>, that: Chunk<B>): Chunk<A | B>; }

----------------------------------------

TITLE: Implementing Atomic Transactions with TMap.forEach in TypeScript
DESCRIPTION: Function signature for forEach that iterates over TMap key-value pairs and executes transactional effects atomically. Takes a function parameter that processes each key-value pair and returns an STM transaction.

LANGUAGE: typescript
CODE:
declare const forEach: {
  <K, V, X, E, R>(f: (key: K, value: V) => STM.STM<X, E, R>): (self: TMap<K, V>) => STM.STM<void, E, R>;
  <K, V, X, E, R>(self: TMap<K, V>, f: (key: K, value: V) => STM.STM<X, E, R>): STM.STM<void, E, R>;
}

----------------------------------------

TITLE: Using Array.getSomes with Option Values in TypeScript
DESCRIPTION: Demonstrates how to use Array.getSomes to extract valid Some values from an array of Options, filtering out None values. The function processes an Iterable of Option types and returns an array containing only the unwrapped Some values.

LANGUAGE: typescript
CODE:
import { Array, Option } from "effect"

const result = Array.getSomes([Option.some(1), Option.none(), Option.some(2)])
console.log(result) // [1, 2]

LANGUAGE: typescript
CODE:
declare const getSomes: <T extends Iterable<Option.Option<X>>, X = any>(self: T) => Array<Option.Option.Value<ReadonlyArray.Infer<T>>>

----------------------------------------

TITLE: Checking Empty RuntimeFlagsPatch in TypeScript
DESCRIPTION: A function that determines if a RuntimeFlagsPatch instance contains no modifications. Takes a RuntimeFlagsPatch parameter and returns a boolean indicating if the patch is empty.

LANGUAGE: typescript
CODE:
declare const isEmpty: (patch: RuntimeFlagsPatch) => boolean

----------------------------------------

TITLE: Configuring LogLevel Constructor in TypeScript
DESCRIPTION: Creates a configuration for LogLevel values in Effect-TS. The function optionally accepts a name parameter and returns a Config instance that manages LogLevel values. This is part of the Effect-TS configuration system introduced in version 2.0.0.

LANGUAGE: typescript
CODE:
declare const logLevel: (name?: string) => Config<LogLevel.LogLevel>

----------------------------------------

TITLE: Creating TMap Instance with Initial Values in TypeScript
DESCRIPTION: Function signature for creating a new TMap instance initialized with key-value pairs. Returns an STM transaction that produces a TMap<K, V> when executed. The function accepts variable number of tuple entries containing keys and values.

LANGUAGE: typescript
CODE:
declare const make: <K, V>(...entries: Array<readonly [K, V]>) => STM.STM<TMap<K, V>>

----------------------------------------

TITLE: Splitting NonEmptyChunk Implementation in TypeScript
DESCRIPTION: Function declaration for splitting a NonEmptyChunk into two segments. Takes a number parameter n (>= 1) and returns a tuple containing the first n elements as a NonEmptyChunk and the remaining elements as a Chunk. Supports both curried and non-curried function calls.

LANGUAGE: typescript
CODE:
declare const splitNonEmptyAt: { 
  (n: number): <A>(self: NonEmptyChunk<A>) => [beforeIndex: NonEmptyChunk<A>, fromIndex: Chunk<A>]; 
  <A>(self: NonEmptyChunk<A>, n: number): [beforeIndex: NonEmptyChunk<A>, fromIndex: Chunk<A>]; 
}

----------------------------------------

TITLE: Implementing cursorTo Function for ANSI Cursor Positioning in TypeScript
DESCRIPTION: Defines the cursorTo function that moves the cursor to a specified row and column. It takes 0-based coordinates and adjusts them to 1-based values for ANSI Control Sequence compatibility.

LANGUAGE: typescript
CODE:
declare const cursorTo: (column: number, row?: number) => AnsiDoc

----------------------------------------

TITLE: Executing Effects with FiberHandle.run in TypeScript
DESCRIPTION: The 'run' function executes an Effect and adds the forked fiber to the FiberHandle. It supports optional parameters for execution control and interruption propagation. The function returns a new Effect that yields a RuntimeFiber.

LANGUAGE: typescript
CODE:
declare const run: { <A, E>(self: FiberHandle<A, E>, options?: { readonly onlyIfMissing?: boolean; readonly propagateInterruption?: boolean | undefined; }): <R, XE extends E, XA extends A>(effect: Effect.Effect<XA, XE, R>) => Effect.Effect<Fiber.RuntimeFiber<XA, XE>, never, R>; <A, E, R, XE extends E, XA extends A>(self: FiberHandle<A, E>, effect: Effect.Effect<XA, XE, R>, options?: { readonly onlyIfMissing?: boolean; readonly propagateInterruption?: boolean | undefined; }): Effect.Effect<Fiber.RuntimeFiber<XA, XE>, never, R>; }

----------------------------------------

TITLE: Creating Failing Micro Effect in TypeScript
DESCRIPTION: Function signature for creating a Micro effect that fails with a given error. The error type is tracked at the type level resulting in a Fail variant of MicroCause.

LANGUAGE: typescript
CODE:
declare const fail: <E>(error: E) => Micro<never, E>

----------------------------------------

TITLE: Defining Chunk.tail Function in TypeScript
DESCRIPTION: Declares the tail function that returns every element after the first in a Chunk. It takes a Chunk<A> as input and returns an Option<Chunk<A>>.

LANGUAGE: typescript
CODE:
declare const tail: <A>(self: Chunk<A>) => Option<Chunk<A>>

----------------------------------------

TITLE: Defining Effect.logError Function Signature in TypeScript
DESCRIPTION: TypeScript type declaration for the logError function that accepts variable number of messages and returns an Effect. The function takes any number of arguments as a readonly array and returns an Effect with void result type and never for both error and dependencies.

LANGUAGE: typescript
CODE:
declare const logError: (...message: ReadonlyArray<any>) => Effect<void, never, never>

----------------------------------------

TITLE: Constructing HashMap Config in TypeScript
DESCRIPTION: The hashMap function constructs a config for a sequence of values. It takes a Config<A> and an optional name parameter, returning a Config for a HashMap of string keys and values of type A.

LANGUAGE: typescript
CODE:
declare const hashMap: <A>(config: Config<A>, name?: string) => Config<HashMap.HashMap<string, A>>

----------------------------------------

TITLE: Implementing zipWith Function for Chunks in TypeScript
DESCRIPTION: Defines the zipWith function which combines two chunks pointwise using a specified combiner function. It can be used in two ways: as a higher-order function or with direct application to two chunks.

LANGUAGE: typescript
CODE:
declare const zipWith: { <A, B, C>(that: Chunk<B>, f: (a: A, b: B) => C): (self: Chunk<A>) => Chunk<C>; <A, B, C>(self: Chunk<A>, that: Chunk<B>, f: (a: A, b: B) => C): Chunk<C>; }

----------------------------------------

TITLE: Unzipping Paired Chunks in TypeScript
DESCRIPTION: Function that takes a Chunk containing pairs of values and splits it into two separate Chunks. The first Chunk contains all the first elements of the pairs, and the second Chunk contains all the second elements. This operation is the reverse of the zip function.

LANGUAGE: typescript
CODE:
declare const unzip: <A, B>(self: Chunk<readonly [A, B]>) => [Chunk<A>, Chunk<B>]

----------------------------------------

TITLE: Defining MetricLabel Interface in TypeScript
DESCRIPTION: Defines the MetricLabel interface that extends Equal and Pipeable interfaces. It represents a key-value pair used for analyzing metrics with additional granularity, such as tracking service response times for different clients.

LANGUAGE: typescript
CODE:
export interface MetricLabel extends Equal.Equal, Pipeable {
  readonly [MetricLabelTypeId]: MetricLabelTypeId
  readonly key: string
  readonly value: string
}

----------------------------------------

TITLE: Modifying URL Query Parameters with @effect/platform in TypeScript
DESCRIPTION: This snippet demonstrates how to use the Url.modifyUrlParams function to read, modify, and update query parameters of a URL. It creates a new URL object with the modified parameters, ensuring immutability.

LANGUAGE: typescript
CODE:
import { Url, UrlParams } from "@effect/platform"

const myUrl = new URL("https://example.com?foo=bar")

const changedUrl = Url.modifyUrlParams(myUrl, UrlParams.append("key", "value"))

console.log(changedUrl.toString())
// Output: https://example.com/?foo=bar&key=value

----------------------------------------

TITLE: Extracting URL Parameters with Schema Validation in TypeScript
DESCRIPTION: Demonstrates how to use UrlParams.schemaStruct to extract and validate URL parameters according to a defined schema structure. The example shows parsing of array and primitive values with type conversion.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Effect, Schema } from "effect"
import { UrlParams } from "@effect/platform"

Effect.gen(function* () {
  const urlParams = UrlParams.fromInput({ "a": [10, "string"], "b": false })
  const result = yield* UrlParams.schemaStruct(Schema.Struct({
    a: Schema.Tuple(Schema.NumberFromString, Schema.String),
    b: Schema.BooleanFromString
  }))(urlParams)

  assert.deepStrictEqual(result, {
    a: [10, "string"],
    b: false
  })
})

LANGUAGE: typescript
CODE:
declare const schemaStruct: <A, I extends Record<string, string | ReadonlyArray<string> | undefined>, R>(schema: Schema.Schema<A, I, R>, options?: ParseOptions | undefined) => (self: UrlParams) => Effect.Effect<A, ParseResult.ParseError, R>

----------------------------------------

TITLE: Using Chunk.prependAll in TypeScript
DESCRIPTION: Demonstrates how to prepend elements from one chunk to another using the prependAll function. The example shows combining string and number elements into a single array.

LANGUAGE: typescript
CODE:
import { Chunk } from "effect"

const result = Chunk.make(1, 2).pipe(Chunk.prependAll(Chunk.make("a", "b")), Chunk.toArray)

console.log(result)
// [ "a", "b", 1, 2 ]

LANGUAGE: typescript
CODE:
declare const prependAll: { <S extends Chunk<any>, T extends Chunk<any>>(that: T): (self: S) => Chunk.OrNonEmpty<S, T, Chunk.Infer<S> | Chunk.Infer<T>>; <A, B>(self: Chunk<A>, that: NonEmptyChunk<B>): NonEmptyChunk<A | B>; <A, B>(self: NonEmptyChunk<A>, that: Chunk<B>): NonEmptyChunk<A | B>; <A, B>(self: Chunk<A>, that: Chunk<B>): Chunk<A | B>; }

----------------------------------------

TITLE: Defining Cause.Die Interface in TypeScript
DESCRIPTION: TypeScript interface definition for Cause.Die, which represents an unexpected defect. The interface extends Cause.Variance, Equal.Equal, Pipeable, and Inspectable, containing a _tag property identifying it as 'Die' and a defect property of unknown type.

LANGUAGE: typescript
CODE:
export interface Die extends Cause.Variance<never>, Equal.Equal, Pipeable, Inspectable {
  readonly _tag: "Die"
  readonly defect: unknown
}

----------------------------------------

TITLE: Flattening Nested Options in TypeScript
DESCRIPTION: A utility function that flattens a nested Option<Option<A>> structure into a single Option<A>. When the outer Option is Some, it returns the inner Option; when the outer Option is None, it returns None. This simplifies handling of nested optional values in functional programming.

LANGUAGE: typescript
CODE:
declare const flatten: <A>(self: Option<Option<A>>) => Option<A>

----------------------------------------

TITLE: Checking Trie Emptiness in TypeScript
DESCRIPTION: Demonstrates how to use the Trie.isEmpty function to check if a Trie contains any entries. It shows creating an empty Trie, inserting an element, and checking the emptiness of both.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Trie } from "effect"

const trie = Trie.empty<number>()
const trie1 = trie.pipe(Trie.insert("ma", 0))

assert.equal(Trie.isEmpty(trie), true)
assert.equal(Trie.isEmpty(trie1), false)

----------------------------------------

TITLE: Implementing Duration Clamping in TypeScript with Effect-TS Schema
DESCRIPTION: Function that creates a transformation to clamp a Duration value between specified minimum and maximum bounds. Takes minimum and maximum duration inputs as parameters and returns a transform function that can be applied to Schema types containing Duration values.

LANGUAGE: typescript
CODE:
declare const clampDuration: (minimum: duration_.DurationInput, maximum: duration_.DurationInput) => <S extends Schema.Any, A extends duration_.Duration>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => transform<S, filter<SchemaClass<A>>>

----------------------------------------

TITLE: Stream.partitionEither Function Signature in TypeScript
DESCRIPTION: This code snippet shows the TypeScript signature of the Stream.partitionEither function. It details the function's parameters and return types, including generic type parameters for various elements and effects.

LANGUAGE: typescript
CODE:
declare const partitionEither: { <A, A3, A2, E2, R2>(predicate: (a: NoInfer<A>) => Effect.Effect<Either.Either<A3, A2>, E2, R2>, options?: { readonly bufferSize?: number | undefined; } | undefined): <E, R>(self: Stream<A, E, R>) => Effect.Effect<[left: Stream<A2, E2 | E, never>, right: Stream<A3, E2 | E, never>], E2 | E, Scope.Scope | R2 | R>; <A, E, R, A3, A2, E2, R2>(self: Stream<A, E, R>, predicate: (a: A) => Effect.Effect<Either.Either<A3, A2>, E2, R2>, options?: { readonly bufferSize?: number | undefined; } | undefined): Effect.Effect<[left: Stream<A2, E | E2, never>, right: Stream<A3, E | E2, never>], E | E2, Scope.Scope | R | R2>; }

----------------------------------------

TITLE: Defining bindEffect Function for Stream in TypeScript
DESCRIPTION: Declares the bindEffect function, which binds an effectful value in a do scope. It supports two overloads with different parameter structures and return types, allowing for concurrent and buffered operations on streams.

LANGUAGE: typescript
CODE:
declare const bindEffect: { <N extends string, A, B, E2, R2>(tag: Exclude<N, keyof A>, f: (_: NoInfer<A>) => Effect.Effect<B, E2, R2>, options?: { readonly concurrency?: number | "unbounded" | undefined; readonly bufferSize?: number | undefined; }): <E, R>(self: Stream<A, E, R>) => Stream<{ [K in keyof A | N]: K extends keyof A ? A[K] : B; }, E | E2, R | R2>; <A, E, R, N extends string, B, E2, R2>(self: Stream<A, E, R>, tag: Exclude<N, keyof A>, f: (_: NoInfer<A>) => Effect.Effect<B, E2, R2>, options?: { readonly concurrency?: number | "unbounded" | undefined; readonly unordered?: boolean | undefined; }): Stream<{ [K in keyof A | N]: K extends keyof A ? A[K] : B; }, E | E2, R | R2>; }

----------------------------------------

TITLE: Adding File Tree ConfigProvider in TypeScript using @effect/platform
DESCRIPTION: The layerFileTreeAdd function adds a file tree ConfigProvider to the environment as a fallback. It optionally accepts an options object with a rootDirectory property. The function returns a Layer that requires Path.Path or FileSystem.FileSystem.

LANGUAGE: typescript
CODE:
declare const layerFileTreeAdd: (options?: { readonly rootDirectory?: string; }) => Layer.Layer<never, never, Path.Path | FileSystem.FileSystem>

----------------------------------------

TITLE: Implementing Conditional Exit Handlers in TypeScript Effect Micro Module
DESCRIPTION: Defines the onExitIf function signature that executes a finalizer effect when a Micro effect completes and matches specified conditions. The function supports both refinement and predicate-based matching of exit states.

LANGUAGE: typescript
CODE:
declare const onExitIf: { 
  <A, E, XE, XR, B extends MicroExit<A, E>>(
    refinement: Refinement<MicroExit<A, E>, B>, 
    f: (exit: B) => Micro<void, XE, XR>
  ): <R>(self: Micro<A, E, R>) => Micro<A, E | XE, R | XR>; 
  <A, E, XE, XR>(
    predicate: Predicate<MicroExit<NoInfer<A>, NoInfer<E>>>, 
    f: (exit: MicroExit<NoInfer<A>, NoInfer<E>>) => Micro<void, XE, XR>
  ): <R>(self: Micro<A, E, R>) => Micro<A, E | XE, R | XR>; 
  <A, E, R, XE, XR, B extends MicroExit<A, E>>(
    self: Micro<A, E, R>, 
    refinement: Refinement<MicroExit<A, E>, B>, 
    f: (exit: B) => Micro<void, XE, XR>
  ): Micro<A, E | XE, R | XR>; 
  <A, E, R, XE, XR>(
    self: Micro<A, E, R>, 
    predicate: Predicate<MicroExit<NoInfer<A>, NoInfer<E>>>, 
    f: (exit: MicroExit<NoInfer<A>, NoInfer<E>>) => Micro<void, XE, XR>
  ): Micro<A, E | XE, R | XR>; 
}

----------------------------------------

TITLE: Mutating URL Properties Using Effect Platform
DESCRIPTION: Demonstrates how to safely clone and modify a URL object using the Url.mutate function. The function accepts an original URL and a callback function that can perform multiple modifications on the cloned URL instance.

LANGUAGE: typescript
CODE:
import { Url } from "@effect/platform"

const myUrl = new URL("https://example.com")

const mutatedUrl = Url.mutate(myUrl, (url) => {
  url.username = "user"
  url.password = "pass"
})

console.log("Mutated:", mutatedUrl.toString())
// Output: Mutated: https://user:pass@example.com/

LANGUAGE: typescript
CODE:
declare const mutate: { (f: (url: URL) => void): (self: URL) => URL; (self: URL, f: (url: URL) => void): URL; }

----------------------------------------

TITLE: Implementing STM Error Refinement in TypeScript
DESCRIPTION: Function signature for refineOrDie that takes a partial function to filter errors. It transforms an STM transaction by keeping some error types (E2) while terminating the fiber for others. The function supports both curried and uncurried calling styles.

LANGUAGE: typescript
CODE:
declare const refineOrDie: { <E, E2>(pf: (error: E) => Option.Option<E2>): <A, R>(self: STM<A, E, R>) => STM<A, E2, R>; <A, E, R, E2>(self: STM<A, E, R>, pf: (error: E) => Option.Option<E2>): STM<A, E2, R>; }

----------------------------------------

TITLE: Defining Parallel Execution Strategy in TypeScript
DESCRIPTION: Defines the parallelN function that creates an ExecutionStrategy for parallel execution of effects with a specified concurrency limit. It takes a number parameter to set the maximum number of concurrent fibers.

LANGUAGE: typescript
CODE:
declare const parallelN: (parallelism: number) => ExecutionStrategy

----------------------------------------

TITLE: Implementing Fiber Interruption with FiberId in TypeScript
DESCRIPTION: Function signature for interrupting a fiber as if it was interrupted from a specified fiber. The function takes a FiberId and returns an Effect that completes when the target fiber exits. Supports both curried and uncurried calling styles.

LANGUAGE: typescript
CODE:
declare const interruptAsFork: { 
  (fiberId: FiberId.FiberId): <A, E>(self: Fiber<A, E>) => Effect.Effect<void>; 
  <A, E>(self: Fiber<A, E>, fiberId: FiberId.FiberId): Effect.Effect<void>; 
}

----------------------------------------

TITLE: Partitioning HashSet with Refinement in TypeScript
DESCRIPTION: Shows how to partition a HashSet containing mixed types (strings and numbers) using a refinement predicate that filters for string values. Demonstrates the same three API styles as the previous example.

LANGUAGE: typescript
CODE:
import { HashSet, pipe, Predicate } from "effect"

const stringRefinement: Predicate.Refinement<string | number, string> = (
  value
) => typeof value === "string"

// with `data-last`, a.k.a. `pipeable` API
pipe(
  HashSet.make(1, "unos", 2, "two", 3, "trois", 4, "vier"),
  HashSet.partition(stringRefinement)
)

// or with the pipe method
HashSet.make(1, "unos", 2, "two", 3, "trois", 4, "vier").pipe(
  HashSet.partition(stringRefinement)
)

// or with `data-first` API
HashSet.partition(
  HashSet.make(1, "unos", 2, "two", 3, "trois", 4, "vier"),
  stringRefinement
)

----------------------------------------

TITLE: Retrieving TestConfig Service in Effect TypeScript
DESCRIPTION: A function that retrieves the TestConfig service and executes a provided workflow. It takes a function parameter that accepts a TestConfig object and returns an Effect instance.

LANGUAGE: typescript
CODE:
declare const testConfigWith: <A, E, R>(f: (config: TestConfig.TestConfig) => Effect.Effect<A, E, R>) => Effect.Effect<A, E, R>

----------------------------------------

TITLE: Defining Float Argument Type in TypeScript
DESCRIPTION: Function signature for creating a floating point number argument in the Effect CLI library. Takes an optional configuration object and returns an Args instance typed as number.

LANGUAGE: typescript
CODE:
declare const float: (config?: Args.BaseArgsConfig) => Args<number>

----------------------------------------

TITLE: Updating Context in Effect Micro Module - TypeScript
DESCRIPTION: Definition of updateContext function that allows modification of Context within Micro operations. The function takes a mapping function to transform the context from one type to another and can be used in both curried and uncurried forms.

LANGUAGE: typescript
CODE:
declare const updateContext: { <R2, R>(f: (context: Context.Context<R2>) => Context.Context<NoInfer<R>>): <A, E>(self: Micro<A, E, R>) => Micro<A, E, R2>; <A, E, R, R2>(self: Micro<A, E, R>, f: (context: Context.Context<R2>) => Context.Context<NoInfer<R>>): Micro<A, E, R2>; }

----------------------------------------

TITLE: Using Record.getRights in TypeScript with Effect Library
DESCRIPTION: Demonstrates how to use the Record.getRights function to extract Right values from a record containing Either values. The function preserves the original keys and returns a new record with only the Right values.

LANGUAGE: typescript
CODE:
import * as assert from "node:assert"
import { Record, Either } from "effect"

assert.deepStrictEqual(
  Record.getRights({ a: Either.right(1), b: Either.left("err"), c: Either.right(2) }),
  { a: 1, c: 2 }
)

----------------------------------------

TITLE: Implementing isDone Function in Take Module (TypeScript)
DESCRIPTION: Defines the isDone function that checks if a Take<A, E> is done (Take.end). It takes a Take<A, E> as input and returns a boolean.

LANGUAGE: typescript
CODE:
declare const isDone: <A, E>(self: Take<A, E>) => boolean

----------------------------------------

TITLE: Defining Micro.onExit Handler in TypeScript
DESCRIPTION: TypeScript type declaration for the onExit handler that executes a finalizer effect when a Micro effect completes. The handler takes a function that processes the MicroExit result and returns a new Micro effect.

LANGUAGE: typescript
CODE:
declare const onExit: { <A, E, XE, XR>(f: (exit: MicroExit<A, E>) => Micro<void, XE, XR>): <R>(self: Micro<A, E, R>) => Micro<A, E | XE, R | XR>; <A, E, R, XE, XR>(self: Micro<A, E, R>, f: (exit: MicroExit<A, E>) => Micro<void, XE, XR>): Micro<A, E | XE, R | XR>; }

----------------------------------------

TITLE: Stream.filter Function Signature in TypeScript
DESCRIPTION: Provides the TypeScript signature for the Stream.filter function. It shows multiple overloads for different use cases, including refinement and predicate-based filtering.

LANGUAGE: typescript
CODE:
declare const filter: { <A, B extends A>(refinement: Refinement<NoInfer<A>, B>): <E, R>(self: Stream<A, E, R>) => Stream<B, E, R>; <A, B extends A>(predicate: Predicate<B>): <E, R>(self: Stream<A, E, R>) => Stream<A, E, R>; <A, E, R, B extends A>(self: Stream<A, E, R>, refinement: Refinement<A, B>): Stream<B, E, R>; <A, E, R>(self: Stream<A, E, R>, predicate: Predicate<A>): Stream<A, E, R>; }

----------------------------------------

TITLE: Trie Keys Function Type Signature
DESCRIPTION: Type declaration for the keys function that returns an IterableIterator of strings representing all keys in the Trie in alphabetical order.

LANGUAGE: typescript
CODE:
declare const keys: <V>(self: Trie<V>) => IterableIterator<string>

----------------------------------------

TITLE: Creating Histogram Metric Key in Effect TypeScript
DESCRIPTION: Function signature for creating a histogram metric key with specified name, boundaries, and optional description. Returns a MetricKey.Histogram type that can be used for metric tracking.

LANGUAGE: typescript
CODE:
declare const histogram: (name: string, boundaries: MetricBoundaries.MetricBoundaries, description?: string) => MetricKey.Histogram

----------------------------------------

TITLE: Transforming Metric Output State in TypeScript
DESCRIPTION: The 'map' function creates a new metric by transforming the output state type of an existing metric using a provided function. It supports both curried and uncurried calling styles.

LANGUAGE: typescript
CODE:
declare const map: { <Out, Out2>(f: (out: Out) => Out2): <Type, In>(self: Metric<Type, In, Out>) => Metric<Type, In, Out2>; <Type, In, Out, Out2>(self: Metric<Type, In, Out>, f: (out: Out) => Out2): Metric<Type, In, Out2>; }

----------------------------------------

TITLE: Defining capitalized function for string validation in TypeScript
DESCRIPTION: Declares a function named 'capitalized' that verifies if a string is capitalized. It takes optional annotations and returns a filter function for schema validation.

LANGUAGE: typescript
CODE:
declare const capitalized: <S extends Schema.Any>(annotations?: Annotations.Filter<Schema.Type<S>>) => <A extends string>(self: S & Schema<A, Schema.Encoded<S>, Schema.Context<S>>) => filter<S>

----------------------------------------

TITLE: Declaring RuntimeMetrics Flag in Effect's RuntimeFlags Module (TypeScript)
DESCRIPTION: This code snippet declares the RuntimeMetrics constant as a RuntimeFlag type. The RuntimeMetrics flag determines whether the Effect runtime system will collect metrics about its execution. Using this flag has a minor performance impact but provides valuable operational insights that can be exported to monitoring tools like Prometheus.

LANGUAGE: typescript
CODE:
declare const RuntimeMetrics: RuntimeFlag

----------------------------------------

TITLE: Declaring OpSupervision Runtime Flag in TypeScript
DESCRIPTION: Declaration of the OpSupervision constant as a RuntimeFlag type. This flag enables supervision of all operations in the Effect runtime system, which is necessary for profiling but impacts performance negatively.

LANGUAGE: typescript
CODE:
declare const OpSupervision: RuntimeFlag

----------------------------------------

TITLE: Declaring Effect.scoped Function in TypeScript
DESCRIPTION: TypeScript declaration for the Effect.scoped function. It takes an effect as input and returns a new effect with automatic resource management, excluding the Scope from the environment type.

LANGUAGE: typescript
CODE:
declare const scoped: <A, E, R>(effect: Effect<A, E, R>) => Effect<A, E, Exclude<R, Scope.Scope>>

----------------------------------------

TITLE: Converting Values to Singleton Arrays using Invariant Typeclass
DESCRIPTION: A function that takes an Invariant typeclass instance and converts a value of type A into a singleton array [A] while preserving the effect context. The function operates within the effect system's type hierarchy using Kind and TypeLambda.

LANGUAGE: typescript
CODE:
declare const tupled: <F extends TypeLambda>(F: Invariant<F>) => <R, O, E, A>(self: Kind<F, R, O, E, A>) => Kind<F, R, O, E, [A]>