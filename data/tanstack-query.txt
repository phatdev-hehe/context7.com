TITLE: Implementing Basic CRUD Operations with TanStack Query in React
DESCRIPTION: Demonstrates setting up a basic todo list application using TanStack Query's core features. Shows how to initialize QueryClient, make queries using useQuery, handle mutations with useMutation, and invalidate queries for data refetching. The example includes proper provider setup and component structure.

LANGUAGE: tsx
CODE:
import {
  useQuery,
  useMutation,
  useQueryClient,
  QueryClient,
  QueryClientProvider,
} from '@tanstack/react-query'
import { getTodos, postTodo } from '../my-api'

// Create a client
const queryClient = new QueryClient()

function App() {
  return (
    // Provide the client to your App
    <QueryClientProvider client={queryClient}>
      <Todos />
    </QueryClientProvider>
  )
}

function Todos() {
  // Access the client
  const queryClient = useQueryClient()

  // Queries
  const query = useQuery({ queryKey: ['todos'], queryFn: getTodos })

  // Mutations
  const mutation = useMutation({
    mutationFn: postTodo,
    onSuccess: () => {
      // Invalidate and refetch
      queryClient.invalidateQueries({ queryKey: ['todos'] })
    },
  })

  return (
    <div>
      <ul>{query.data?.map((todo) => <li key={todo.id}>{todo.title}</li>)}</ul>

      <button
        onClick={() => {
          mutation.mutate({
            id: Date.now(),
            title: 'Do Laundry',
          })
        }}
      >
        Add Todo
      </button>
    </div>
  )
}

render(<App />, document.getElementById('root'))

----------------------------------------

TITLE: Initializing QueryClient in TanStack Query
DESCRIPTION: Creates a new QueryClient instance with custom default options for queries. This example sets the staleTime to Infinity for all queries.

LANGUAGE: tsx
CODE:
import { QueryClient } from '@tanstack/react-query'

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      staleTime: Infinity,
    },
  },
})

await queryClient.prefetchQuery({ queryKey: ['posts'], queryFn: fetchPosts })

----------------------------------------

TITLE: Initializing Basic Query in React Query
DESCRIPTION: Demonstrates the basic setup of a query using the useQuery hook. Shows how to define a query with a unique key and query function.

LANGUAGE: tsx
CODE:
import { useQuery } from '@tanstack/react-query'

function App() {
  const info = useQuery({ queryKey: ['todos'], queryFn: fetchTodoList })
}

----------------------------------------

TITLE: Implementing Todo List with Query States
DESCRIPTION: Complete example showing how to handle different query states (loading, error, success) and render appropriate UI components based on the query status.

LANGUAGE: tsx
CODE:
function Todos() {
  const { isPending, isError, data, error } = useQuery({
    queryKey: ['todos'],
    queryFn: fetchTodoList,
  })

  if (isPending) {
    return <span>Loading...</span>
  }

  if (isError) {
    return <span>Error: {error.message}</span>
  }

  // We can assume by this point that `isSuccess === true`
  return (
    <ul>
      {data.map((todo) => (
        <li key={todo.id}>{todo.title}</li>
      ))}
    </ul>
  )
}

----------------------------------------

TITLE: Implementing Infinite Query with useInfiniteQuery in TanStack Query (TSX)
DESCRIPTION: This snippet demonstrates how to use the useInfiniteQuery hook to implement infinite scrolling or pagination. It includes options for fetching next and previous pages, checking if more pages are available, and handling loading states.

LANGUAGE: tsx
CODE:
const {
  fetchNextPage,
  fetchPreviousPage,
  hasNextPage,
  hasPreviousPage,
  isFetchingNextPage,
  isFetchingPreviousPage,
  promise,
  ...result
} = useInfiniteQuery({
  queryKey,
  queryFn: ({ pageParam }) => fetchPage(pageParam),
  initialPageParam: 1,
  ...options,
  getNextPageParam: (lastPage, allPages, lastPageParam, allPageParams) =>
    lastPage.nextCursor,
  getPreviousPageParam: (firstPage, allPages, firstPageParam, allPageParams) =>
    firstPage.prevCursor,
})

----------------------------------------

TITLE: Initializing Mutation for Optimistic UI Updates in React Query
DESCRIPTION: This snippet demonstrates how to set up a mutation in React Query for optimistic UI updates. It includes the mutation function and an onSettled callback to invalidate the query cache after completion.

LANGUAGE: tsx
CODE:
const addTodoMutation = useMutation({
  mutationFn: (newTodo: string) => axios.post('/api/data', { text: newTodo }),
  // make sure to _return_ the Promise from the query invalidation
  // so that the mutation stays in `pending` state until the refetch is finished
  onSettled: async () => {
    return await queryClient.invalidateQueries({ queryKey: ['todos'] })
  },
})

const { isPending, submittedAt, variables, mutate, isError } = addTodoMutation

----------------------------------------

TITLE: Defining Query Functions in TanStack Query
DESCRIPTION: This snippet demonstrates various ways to define query functions in TanStack Query. It shows how to use simple functions, arrow functions, and async functions as query functions.

LANGUAGE: tsx
CODE:
useQuery({ queryKey: ['todos'], queryFn: fetchAllTodos })
useQuery({ queryKey: ['todos', todoId], queryFn: () => fetchTodoById(todoId) })
useQuery({
  queryKey: ['todos', todoId],
  queryFn: async () => {
    const data = await fetchTodoById(todoId)
    return data
  },
})
useQuery({
  queryKey: ['todos', todoId],
  queryFn: ({ queryKey }) => fetchTodoById(queryKey[1]),
})

----------------------------------------

TITLE: Implementing TodosComponent with TanStack Query in Angular
DESCRIPTION: This comprehensive example demonstrates a TodosComponent using TanStack Query for data fetching and mutation. It includes a query for fetching todos, a mutation for adding a new todo, and a service for handling HTTP requests.

LANGUAGE: angular-ts
CODE:
import { Component, Injectable, inject } from '@angular/core'
import { HttpClient } from '@angular/common/http'
import { lastValueFrom } from 'rxjs'

import {
  injectMutation,
  injectQuery,
  QueryClient
} from '@tanstack/angular-query-experimental'

@Component({
  standalone: true,
  template: `
    <div>
      <button (click)="onAddTodo()">Add Todo</button>

      <ul>
        @for (todo of query.data(); track todo.title) {
          <li>{{ todo.title }}</li>
        }
      </ul>
    </div>
  `,
})
export class TodosComponent {
  todoService = inject(TodoService)
  queryClient = inject(QueryClient)

  query = injectQuery(() => ({
    queryKey: ['todos'],
    queryFn: () => this.todoService.getTodos(),
  }))

  mutation = injectMutation(() => ({
    mutationFn: (todo: Todo) => this.todoService.addTodo(todo),
    onSuccess: () => {
      this.queryClient.invalidateQueries({ queryKey: ['todos'] })
    },
  }))

  onAddTodo() {
    this.mutation.mutate({
      id: Date.now().toString(),
      title: 'Do Laundry',
    })
  }
}

@Injectable({ providedIn: 'root' })
export class TodoService {
  private http = inject(HttpClient)

  getTodos(): Promise<Todo[]> {
    return lastValueFrom(
      this.http.get<Todo[]>('https://jsonplaceholder.typicode.com/todos'),
    )
  }

  addTodo(todo: Todo): Promise<Todo> {
    return lastValueFrom(
      this.http.post<Todo>('https://jsonplaceholder.typicode.com/todos', todo),
    )
  }
}

interface Todo {
  id: string
  title: string
}

----------------------------------------

TITLE: Fetching GitHub Repository Data with React Query
DESCRIPTION: This example demonstrates how to use React Query to fetch and display data from the GitHub API. It shows the basic setup of QueryClientProvider and the use of the useQuery hook to manage the asynchronous data fetching process.

LANGUAGE: tsx
CODE:
import {
  QueryClient,
  QueryClientProvider,
  useQuery,
} from '@tanstack/react-query'

const queryClient = new QueryClient()

export default function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <Example />
    </QueryClientProvider>
  )
}

function Example() {
  const { isPending, error, data } = useQuery({
    queryKey: ['repoData'],
    queryFn: () =>
      fetch('https://api.github.com/repos/TanStack/query').then((res) =>
        res.json(),
      ),
  })

  if (isPending) return 'Loading...'

  if (error) return 'An error has occurred: ' + error.message

  return (
    <div>
      <h1>{data.name}</h1>
      <p>{data.description}</p>
      <strong>üëÄ {data.subscribers_count}</strong>{' '}
      <strong>‚ú® {data.stargazers_count}</strong>{' '}
      <strong>üç¥ {data.forks_count}</strong>
    </div>
  )
}

----------------------------------------

TITLE: Accessing Query Function Variables in TanStack Query
DESCRIPTION: This snippet shows how to access query key variables in the query function, demonstrating the extraction of query functions when needed.

LANGUAGE: tsx
CODE:
function Todos({ status, page }) {
  const result = useQuery({
    queryKey: ['todos', { status, page }],
    queryFn: fetchTodoList,
  })
}

// Access the key, status and page variables in your query function!
function fetchTodoList({ queryKey }) {
  const [_key, { status, page }] = queryKey
  return new Promise()
}

----------------------------------------

TITLE: Optimistic Update for Single Item in React Query
DESCRIPTION: This snippet shows how to implement an optimistic update for a single todo item. It demonstrates cancelling queries, snapshotting previous data, updating the cache, and handling errors with rollback functionality.

LANGUAGE: tsx
CODE:
useMutation({
  mutationFn: updateTodo,
  // When mutate is called:
  onMutate: async (newTodo) => {
    // Cancel any outgoing refetches
    // (so they don't overwrite our optimistic update)
    await queryClient.cancelQueries({ queryKey: ['todos', newTodo.id] })

    // Snapshot the previous value
    const previousTodo = queryClient.getQueryData(['todos', newTodo.id])

    // Optimistically update to the new value
    queryClient.setQueryData(['todos', newTodo.id], newTodo)

    // Return a context with the previous and new todo
    return { previousTodo, newTodo }
  },
  // If the mutation fails, use the context we returned above
  onError: (err, newTodo, context) => {
    queryClient.setQueryData(
      ['todos', context.newTodo.id],
      context.previousTodo,
    )
  },
  // Always refetch after error or success:
  onSettled: (newTodo) => {
    queryClient.invalidateQueries({ queryKey: ['todos', newTodo.id] })
  },
})

----------------------------------------

TITLE: Using useMutation Hook in React with TanStack Query
DESCRIPTION: Demonstrates how to use the useMutation hook to add a new todo item. The example shows different mutation states and how to trigger the mutation.

LANGUAGE: tsx
CODE:
function App() {
  const mutation = useMutation({
    mutationFn: (newTodo) => {
      return axios.post('/todos', newTodo)
    },
  })

  return (
    <div>
      {mutation.isPending ? (
        'Adding todo...'
      ) : (
        <>
          {mutation.isError ? (
            <div>An error occurred: {mutation.error.message}</div>
          ) : null}

          {mutation.isSuccess ? <div>Todo added!</div> : null}

          <button
            onClick={() => {
              mutation.mutate({ id: new Date(), title: 'Do Laundry' })
            }}
          >
            Create Todo
          </button>
        </>
      )}
    </div>
  )
}

----------------------------------------

TITLE: Configuring Query Options with TanStack Query in TypeScript
DESCRIPTION: Shows how to create and use the queryOptions helper to define reusable query configurations. The example demonstrates setting up query keys, query functions, and stale time, along with various usage patterns including useQuery, useSuspenseQuery, and queryClient methods.

LANGUAGE: typescript
CODE:
import { queryOptions } from '@tanstack/react-query'

function groupOptions(id: number) {
  return queryOptions({
    queryKey: ['groups', id],
    queryFn: () => fetchGroups(id),
    staleTime: 5 * 1000,
  })
}

// usage:

useQuery(groupOptions(1))
useSuspenseQuery(groupOptions(5))
useQueries({
  queries: [groupOptions(1), groupOptions(2)],
})
queryClient.prefetchQuery(groupOptions(23))
queryClient.setQueryData(groupOptions(42).queryKey, newGroups)

----------------------------------------

TITLE: Using Fetch API with TanStack Query
DESCRIPTION: This snippet demonstrates how to use the fetch API with TanStack Query, including manual error throwing for unsuccessful HTTP calls.

LANGUAGE: tsx
CODE:
useQuery({
  queryKey: ['todos', todoId],
  queryFn: async () => {
    const response = await fetch('/todos/' + todoId)
    if (!response.ok) {
      throw new Error('Network response was not ok')
    }
    return response.json()
  },
})

----------------------------------------

TITLE: Type-Safe GraphQL Query Implementation with TanStack Query
DESCRIPTION: Demonstrates how to implement a type-safe GraphQL query using TanStack Query with graphql-request and GraphQL Code Generator. The example shows querying a Star Wars API with full TypeScript type checking for both the query and its variables.

LANGUAGE: tsx
CODE:
import request from 'graphql-request'
import { useQuery } from '@tanstack/react-query'

import { graphql } from './gql/gql'

const allFilmsWithVariablesQueryDocument = graphql(/* GraphQL */ `
  query allFilmsWithVariablesQuery($first: Int!) {
    allFilms(first: $first) {
      edges {
        node {
          id
          title
        }
      }
    }
  }
`)

function App() {
  // `data` is fully typed!
  const { data } = useQuery({
    queryKey: ['films'],
    queryFn: async () =>
      request(
        'https://swapi-graphql.netlify.app/.netlify/functions/index',
        allFilmsWithVariablesQueryDocument,
        // variables are type-checked too!
        { first: 10 },
      ),
  })
  // ...
}

----------------------------------------

TITLE: Implementing Optimistic Updates with Cache Manipulation in React Query
DESCRIPTION: This snippet demonstrates how to implement optimistic updates by directly manipulating the query cache. It includes handlers for mutation lifecycle events to update the cache, handle errors, and perform rollbacks if necessary.

LANGUAGE: tsx
CODE:
const queryClient = useQueryClient()

useMutation({
  mutationFn: updateTodo,
  // When mutate is called:
  onMutate: async (newTodo) => {
    // Cancel any outgoing refetches
    // (so they don't overwrite our optimistic update)
    await queryClient.cancelQueries({ queryKey: ['todos'] })

    // Snapshot the previous value
    const previousTodos = queryClient.getQueryData(['todos'])

    // Optimistically update to the new value
    queryClient.setQueryData(['todos'], (old) => [...old, newTodo])

    // Return a context object with the snapshotted value
    return { previousTodos }
  },
  // If the mutation fails,
  // use the context returned from onMutate to roll back
  onError: (err, newTodo, context) => {
    queryClient.setQueryData(['todos'], context.previousTodos)
  },
  // Always refetch after error or success:
  onSettled: () => {
    queryClient.invalidateQueries({ queryKey: ['todos'] })
  },
})

----------------------------------------

TITLE: Implementing Paginated Data Fetching with TanStack Query in Vue
DESCRIPTION: A complete Vue component implementation showing paginated data fetching using TanStack Query. Features include pagination controls, loading states, error handling, and placeholder data support using keepPreviousData. The component fetches posts from JSONPlaceholder API with a limit of 10 items per page.

LANGUAGE: vue
CODE:
<script setup lang="ts">
import { ref, Ref } from 'vue'
import { useQuery, keepPreviousData } from '@tanstack/vue-query'

const fetcher = (page: Ref<number>) =>
  fetch(
    `https://jsonplaceholder.typicode.com/posts?_page=${page.value}&_limit=10`,
  ).then((response) => response.json())

const page = ref(1)
const { isPending, isError, data, error, isFetching, isPlaceholderData } =
  useQuery({
    queryKey: ['projects', page],
    queryFn: () => fetcher(page),
    placeholderData: keepPreviousData,
  })
const prevPage = () => {
  page.value = Math.max(page.value - 1, 1)
}
const nextPage = () => {
  if (!isPlaceholderData.value) {
    page.value = page.value + 1
  }
}
</script>

<template>
  <h1>Posts</h1>
  <p>Current Page: {{ page }} | Previous data: {{ isPlaceholderData }}</p>
  <button @click="prevPage">Prev Page</button>
  <button @click="nextPage">Next Page</button>
  <div v-if="isPending">Loading...</div>
  <div v-else-if="isError">An error has occurred: {{ error }}</div>
  <div v-else-if="data">
    <ul>
      <li v-for="item in data" :key="item.id">
        {{ item.title }}
      </li>
    </ul>
  </div>
</template>

----------------------------------------

TITLE: TanStack Query Default Timeout Configuration
DESCRIPTION: Default garbage collection timeout setting for inactive queries. Queries are removed from cache after 5 minutes of inactivity.

LANGUAGE: javascript
CODE:
1000 * 60 * 5

----------------------------------------

TITLE: Advanced Query Invalidation with Predicates in TanStack Query (TSX)
DESCRIPTION: Demonstrates the use of a predicate function with invalidateQueries for highly specific query invalidation. This allows for complex logic to determine which queries should be invalidated based on their keys and other properties.

LANGUAGE: tsx
CODE:
queryClient.invalidateQueries({
  predicate: (query) =>
    query.queryKey[0] === 'todos' && query.queryKey[1]?.version >= 10,
})

// The query below will be invalidated
const todoListQuery = useQuery({
  queryKey: ['todos', { version: 20 }],
  queryFn: fetchTodoList,
})

// The query below will be invalidated
const todoListQuery = useQuery({
  queryKey: ['todos', { version: 10 }],
  queryFn: fetchTodoList,
})

// However, the following query below will NOT be invalidated
const todoListQuery = useQuery({
  queryKey: ['todos', { version: 5 }],
  queryFn: fetchTodoList,
})

----------------------------------------

TITLE: Implementing Array Keys with Variables in TanStack Query (TSX)
DESCRIPTION: Shows how to use array keys with variables for hierarchical resources or queries with additional parameters. These keys can include IDs, indices, or objects with options.

LANGUAGE: tsx
CODE:
// An individual todo
useQuery({ queryKey: ['todo', 5], ... })

// An individual todo in a "preview" format
useQuery({ queryKey: ['todo', 5, { preview: true }], ...})

// A list of todos that are "done"
useQuery({ queryKey: ['todos', { type: 'done' }], ... })

----------------------------------------

TITLE: Mutation Side Effects in TanStack Query
DESCRIPTION: Shows how to use side effect callbacks (onMutate, onError, onSuccess, onSettled) with useMutation for handling different stages of the mutation lifecycle.

LANGUAGE: tsx
CODE:
useMutation({
  mutationFn: addTodo,
  onMutate: (variables) => {
    // A mutation is about to happen!

    // Optionally return a context containing data to use when for example rolling back
    return { id: 1 }
  },
  onError: (error, variables, context) => {
    // An error happened!
    console.log(`rolling back optimistic update with id ${context.id}`)
  },
  onSuccess: (data, variables, context) => {
    // Boom baby!
  },
  onSettled: (data, error, variables, context) => {
    // Error or success... doesn't matter!
  },
})

----------------------------------------

TITLE: Configuring Angular Query Service with HTTP Integration
DESCRIPTION: Demonstrates setting up a query service in Angular using TanStack Query with HTTP client integration. Shows how to define query options, make HTTP requests, and use the query client for prefetching and data manipulation.

LANGUAGE: typescript
CODE:
import { queryOptions } from '@tanstack/angular-query-experimental'

@Injectable({
  providedIn: 'root',
})
export class QueriesService {
  private http = inject(HttpClient)

  post(postId: number) {
    return queryOptions({
      queryKey: ['post', postId],
      queryFn: () => {
        return lastValueFrom(
          this.http.get<Post>(
            `https://jsonplaceholder.typicode.com/posts/${postId}`,
          ),
        )
      },
    })
  }
}

// usage:

postId = input.required({
  transform: numberAttribute,
})
queries = inject(QueriesService)

postQuery = injectQuery(() => this.queries.post(this.postId()))

queryClient.prefetchQuery(this.queries.post(23))
queryClient.setQueryData(this.queries.post(42).queryKey, newPost)

----------------------------------------

TITLE: Fetching Multiple Queries with useQueries in TanStack Query (TSX)
DESCRIPTION: Demonstrates how to use the useQueries hook to fetch multiple posts based on an array of IDs. The hook accepts an options object with a queries array, where each query specifies its key, fetch function, and stale time.

LANGUAGE: tsx
CODE:
const ids = [1, 2, 3]
const results = useQueries({
  queries: ids.map((id) => ({
    queryKey: ['post', id],
    queryFn: () => fetchPost(id),
    staleTime: Infinity,
  })),
})

----------------------------------------

TITLE: Query Invalidation After Mutation Success
DESCRIPTION: Demonstrates how to invalidate multiple query keys after a successful mutation using queryClient.invalidateQueries(). This example shows invalidation of both 'todos' and 'reminders' queries after adding a new todo item.

LANGUAGE: tsx
CODE:
import { useMutation, useQueryClient } from '@tanstack/react-query'

const queryClient = useQueryClient()

// When this mutation succeeds, invalidate any queries with the `todos` or `reminders` query key
const mutation = useMutation({
  mutationFn: addTodo,
  onSuccess: () => {
    queryClient.invalidateQueries({ queryKey: ['todos'] })
    queryClient.invalidateQueries({ queryKey: ['reminders'] })
  },
})

----------------------------------------

TITLE: Initializing useQuery Hook in React with TypeScript
DESCRIPTION: This snippet demonstrates how to use the useQuery hook from tanstack-query. It shows the full range of options and return values available when initializing a query.

LANGUAGE: tsx
CODE:
const {
  data,
  dataUpdatedAt,
  error,
  errorUpdatedAt,
  failureCount,
  failureReason,
  fetchStatus,
  isError,
  isFetched,
  isFetchedAfterMount,
  isFetching,
  isInitialLoading,
  isLoading,
  isLoadingError,
  isPaused,
  isPending,
  isPlaceholderData,
  isRefetchError,
  isRefetching,
  isStale,
  isSuccess,
  promise,
  refetch,
  status,
} = useQuery(
  {
    queryKey,
    queryFn,
    gcTime,
    enabled,
    networkMode,
    initialData,
    initialDataUpdatedAt,
    meta,
    notifyOnChangeProps,
    placeholderData,
    queryKeyHashFn,
    refetchInterval,
    refetchIntervalInBackground,
    refetchOnMount,
    refetchOnReconnect,
    refetchOnWindowFocus,
    retry,
    retryOnMount,
    retryDelay,
    select,
    staleTime,
    structuralSharing,
    subscribed,
    throwOnError,
  },
  queryClient,
)

----------------------------------------

TITLE: Using useQuery Hook for Fetching Todos in TanStack Query
DESCRIPTION: This snippet demonstrates the usage of the useQuery hook to fetch todos. It shows how the query key ['todos'] is used to manage the cache and trigger fetching. The example is used throughout the document to explain various caching scenarios.

LANGUAGE: javascript
CODE:
useQuery({ queryKey: ['todos'], queryFn: fetchTodos })

----------------------------------------

TITLE: Angular Component with Query and Conditional Rendering
DESCRIPTION: Illustrates a complete Angular component that injects a query and uses conditional rendering to display loading, error, and success states.

LANGUAGE: angular-ts
CODE:
@Component({
  selector: 'todos',
  standalone: true,
  template: `
    @if (todos.isPending()) {
      <span>Loading...</span>
    } @else if (todos.isError()) {
      <span>Error: {{ todos.error()?.message }}</span>
    } @else {
      <!-- We can assume by this point that status === 'success' -->
      @for (todo of todos.data(); track todo.id) {
        <li>{{ todo.title }}</li>
      } @empty {
        <li>No todos found</li>
      }
    }
  `,
})
export class PostsComponent {
  todos = injectQuery(() => ({
    queryKey: ['todos'],
    queryFn: fetchTodoList,
  }))
}

----------------------------------------

TITLE: Prefetching Infinite Query Data in TanStack Query
DESCRIPTION: Shows how to prefetch infinite query data using prefetchInfiniteQuery. This example prefetches project data with pagination support, specifying the number of pages to prefetch.

LANGUAGE: tsx
CODE:
const prefetchProjects = async () => {
  // The results of this query will be cached like a normal query
  await queryClient.prefetchInfiniteQuery({
    queryKey: ['projects'],
    queryFn: fetchProjects,
    initialPageParam: 0,
    getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
    pages: 3, // prefetch the first 3 pages
  })
}

----------------------------------------

TITLE: Conditional Prefetching in TanStack Query
DESCRIPTION: Demonstrates conditional prefetching based on the result of another query. This example prefetches graph data for specific feed items within the query function of the main feed query.

LANGUAGE: tsx
CODE:
function Feed() {
  const queryClient = useQueryClient()
  const { data, isPending } = useQuery({
    queryKey: ['feed'],
    queryFn: async (...args) => {
      const feed = await getFeed(...args)

      for (const feedItem of feed) {
        if (feedItem.type === 'GRAPH') {
          queryClient.prefetchQuery({
            queryKey: ['graph', feedItem.id],
            queryFn: getGraphDataById,
          })
        }
      }

      return feed
    }
  })

  ...
}

----------------------------------------

TITLE: Using useMutation Hook in TanStack Query - TypeScript/React
DESCRIPTION: Demonstrates the usage of useMutation hook with its complete configuration options and return values. The hook allows performing asynchronous mutations with support for optimistic updates, retry logic, and various lifecycle callbacks.

LANGUAGE: tsx
CODE:
const {
  data,
  error,
  isError,
  isIdle,
  isPending,
  isPaused,
  isSuccess,
  failureCount,
  failureReason,
  mutate,
  mutateAsync,
  reset,
  status,
  submittedAt,
  variables,
} = useMutation(
  {
    mutationFn,
    gcTime,
    meta,
    mutationKey,
    networkMode,
    onError,
    onMutate,
    onSettled,
    onSuccess,
    retry,
    retryDelay,
    scope,
    throwOnError,
  },
  queryClient,
)

mutate(variables, {
  onError,
  onSettled,
  onSuccess,
})

----------------------------------------

TITLE: Basic Parallel Queries in Vue with TanStack Query
DESCRIPTION: Demonstrates how to execute multiple queries in parallel using Vue's script setup syntax. Shows three independent queries that will fetch users, teams, and projects data simultaneously.

LANGUAGE: vue
CODE:
<script setup lang="ts">
// The following queries will execute in parallel
const usersQuery = useQuery({ queryKey: ['users'], queryFn: fetchUsers })
const teamsQuery = useQuery({ queryKey: ['teams'], queryFn: fetchTeams })
const projectsQuery = useQuery({
  queryKey: ['projects'],
  queryFn: fetchProjects,
})
</script>

----------------------------------------

TITLE: Invalidating Queries with QueryClient in TanStack Query (TSX)
DESCRIPTION: Demonstrates how to invalidate all queries or queries with specific keys using the QueryClient's invalidateQueries method. This is useful when you know a query's data is out of date due to user actions.

LANGUAGE: tsx
CODE:
// Invalidate every query in the cache
queryClient.invalidateQueries()
// Invalidate every query with a key that starts with `todos`
queryClient.invalidateQueries({ queryKey: ['todos'] })

----------------------------------------

TITLE: Implementing Default Query Function in TanStack Query with TypeScript
DESCRIPTION: This snippet demonstrates how to define a default query function, configure it with QueryClient, and use it in Angular components. It uses axios for HTTP requests and assumes a RESTful API structure.

LANGUAGE: typescript
CODE:
// Define a default query function that will receive the query key
const defaultQueryFn: QueryFunction = async ({ queryKey }) => {
  const { data } = await axios.get(
    `https://jsonplaceholder.typicode.com${queryKey[0]}`,
  )
  return data
}

// provide the default query function to your app with defaultOptions
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      queryFn: defaultQueryFn,
    },
  },
})

bootstrapApplication(MyAppComponent, {
  providers: [provideTanStackQuery(queryClient)],
})

export class PostsComponent {
  // All you have to do now is pass a key!
  postsQuery = injectQuery<Array<Post>>(() => ({
    queryKey: ['/posts'],
  }))
  // ...
}

export class PostComponent {
  // You can even leave out the queryFn and just go straight into options
  postQuery = injectQuery<Post>(() => ({
    enabled: this.postIdSignal() > 0,
    queryKey: [`/posts/${this.postIdSignal()}`],
  }))
  // ...
}

----------------------------------------

TITLE: Enabling Suspense Mode for Queries in TanStack Query
DESCRIPTION: Demonstrates how to use the useSuspenseQuery hook to enable suspense mode for a query. This approach guarantees that data is defined, as errors and loading states are handled by Suspense and Error Boundaries.

LANGUAGE: tsx
CODE:
import { useSuspenseQuery } from '@tanstack/react-query'

const { data } = useSuspenseQuery({ queryKey, queryFn })

----------------------------------------

TITLE: Using useSuspenseQuery in React with TanStack Query
DESCRIPTION: Demonstrates how to use the useSuspenseQuery hook in a React component. This hook is similar to useQuery but is designed to work with React Suspense, guaranteeing that data is defined and simplifying the status handling.

LANGUAGE: tsx
CODE:
const result = useSuspenseQuery(options)

----------------------------------------

TITLE: Exact Query Invalidation in TanStack Query (TSX)
DESCRIPTION: Shows how to use the 'exact' option with invalidateQueries to only invalidate queries that exactly match the provided key, without affecting queries with additional subkeys or variables.

LANGUAGE: tsx
CODE:
queryClient.invalidateQueries({
  queryKey: ['todos'],
  exact: true,
})

// The query below will be invalidated
const todoListQuery = useQuery({
  queryKey: ['todos'],
  queryFn: fetchTodoList,
})

// However, the following query below will NOT be invalidated
const todoListQuery = useQuery({
  queryKey: ['todos', { type: 'done' }],
  queryFn: fetchTodoList,
})

----------------------------------------

TITLE: Exact Query Invalidation in TanStack Query (TSX)
DESCRIPTION: Shows how to use the 'exact' option with invalidateQueries to only invalidate queries that exactly match the provided key, without affecting queries with additional subkeys or variables.

LANGUAGE: tsx
CODE:
queryClient.invalidateQueries({
  queryKey: ['todos'],
  exact: true,
})

// The query below will be invalidated
const todoListQuery = useQuery({
  queryKey: ['todos'],
  queryFn: fetchTodoList,
})

// However, the following query below will NOT be invalidated
const todoListQuery = useQuery({
  queryKey: ['todos', { type: 'done' }],
  queryFn: fetchTodoList,
})

----------------------------------------

TITLE: Implementing Dependent Queries with useQuery in React
DESCRIPTION: This snippet demonstrates how to create a dependent query using the useQuery hook from TanStack Query. It first fetches user data, then uses the user's ID to fetch their projects only when the user data is available.

LANGUAGE: tsx
CODE:
// Get the user
const { data: user } = useQuery({
  queryKey: ['user', email],
  queryFn: getUserByEmail,
})

const userId = user?.id

// Then get the user's projects
const {
  status,
  fetchStatus,
  data: projects,
} = useQuery({
  queryKey: ['projects', userId],
  queryFn: getProjectsByUser,
  // The query will not execute until the userId exists
  enabled: !!userId,
})

----------------------------------------

TITLE: Implementing Infinite Query with Load More Functionality
DESCRIPTION: Complete example of implementing infinite queries with a load more button using useInfiniteQuery hook.

LANGUAGE: tsx
CODE:
import { useInfiniteQuery } from '@tanstack/react-query'

function Projects() {
  const fetchProjects = async ({ pageParam }) => {
    const res = await fetch('/api/projects?cursor=' + pageParam)
    return res.json()
  }

  const {
    data,
    error,
    fetchNextPage,
    hasNextPage,
    isFetching,
    isFetchingNextPage,
    status,
  } = useInfiniteQuery({
    queryKey: ['projects'],
    queryFn: fetchProjects,
    initialPageParam: 0,
    getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
  })

  return status === 'pending' ? (
    <p>Loading...</p>
  ) : status === 'error' ? (
    <p>Error: {error.message}</p>
  ) : (
    <>
      {data.pages.map((group, i) => (
        <React.Fragment key={i}>
          {group.data.map((project) => (
            <p key={project.id}>{project.name}</p>
          ))}
        </React.Fragment>
      ))}
      <div>
        <button
          onClick={() => fetchNextPage()}
          disabled={!hasNextPage || isFetchingNextPage}
        >
          {isFetchingNextPage
            ? 'Loading more...'
            : hasNextPage
              ? 'Load More'
              : 'Nothing more to load'}
        </button>
      </div>
      <div>{isFetching && !isFetchingNextPage ? 'Fetching...' : null}</div>
    </>
  )
}

----------------------------------------

TITLE: Query Matching with invalidateQueries in TanStack Query (TSX)
DESCRIPTION: Shows how to use query key prefixes to invalidate multiple related queries. This example invalidates all queries that start with 'todos' in their query key, affecting multiple useQuery hooks.

LANGUAGE: tsx
CODE:
import { useQuery, useQueryClient } from '@tanstack/react-query'

// Get QueryClient from the context
const queryClient = useQueryClient()

queryClient.invalidateQueries({ queryKey: ['todos'] })

// Both queries below will be invalidated
const todoListQuery = useQuery({
  queryKey: ['todos'],
  queryFn: fetchTodoList,
})
const todoListQuery = useQuery({
  queryKey: ['todos', { page: 1 }],
  queryFn: fetchTodoList,
})

----------------------------------------

TITLE: Using Simple Query Keys in TanStack Query (TSX)
DESCRIPTION: Demonstrates the usage of simple query keys for generic list resources and non-hierarchical data in TanStack Query. These keys are arrays with constant values.

LANGUAGE: tsx
CODE:
// A list of todos
useQuery({ queryKey: ['todos'], ... })

// Something else, whatever!
useQuery({ queryKey: ['something', 'special'], ... })

----------------------------------------

TITLE: Implementing Basic Query Functions with TanStack Query in TypeScript
DESCRIPTION: This snippet shows different ways to define query functions using the injectQuery composable. It demonstrates using simple functions, async functions, and accessing query key parameters.

LANGUAGE: typescript
CODE:
injectQuery(() => ({ queryKey: ['todos'], queryFn: fetchAllTodos }))
injectQuery(() => ({ queryKey: ['todos', todoId], queryFn: () => fetchTodoById(todoId) })
injectQuery(() => ({
  queryKey: ['todos', todoId],
  queryFn: async () => {
    const data = await fetchTodoById(todoId)
    return data
  },
}))
injectQuery(() => ({
  queryKey: ['todos', todoId],
  queryFn: ({ queryKey }) => fetchTodoById(queryKey[1]),
}))

----------------------------------------

TITLE: Using mutateAsync for Promise-based Mutations in TanStack Query
DESCRIPTION: Demonstrates how to use mutateAsync to get a promise from a mutation, which can be useful for composing side effects or handling errors.

LANGUAGE: tsx
CODE:
const mutation = useMutation({ mutationFn: addTodo })

try {
  const todo = await mutation.mutateAsync(todo)
  console.log(todo)
} catch (error) {
  console.error(error)
} finally {
  console.log('done')
}

----------------------------------------

TITLE: Overriding Query Options with Select Function in TypeScript
DESCRIPTION: Demonstrates how to override query options at the component level using the select function for data transformation. The example shows how type inference is maintained when using select to transform the query result.

LANGUAGE: typescript
CODE:
const query = useQuery({
  ...groupOptions(1),
  select: (data) => data.groupName,
})

----------------------------------------

TITLE: Basic API Response Pattern for Infinite Queries
DESCRIPTION: Example of API response structure for paginated data using cursor-based pagination.

LANGUAGE: tsx
CODE:
fetch('/api/projects?cursor=0')
// { data: [...], nextCursor: 3}
fetch('/api/projects?cursor=3')
// { data: [...], nextCursor: 6}
fetch('/api/projects?cursor=6')
// { data: [...], nextCursor: 9}
fetch('/api/projects?cursor=9')
// { data: [...] }

----------------------------------------

TITLE: Creating a Reusable Mutation Hook in TanStack Query
DESCRIPTION: This example shows how to create a custom hook for a reusable mutation. The hook encapsulates the mutation logic and updates the query data on successful mutation, using the variables passed to the mutate function.

LANGUAGE: tsx
CODE:
const useMutateTodo = () => {
  const queryClient = useQueryClient()

  return useMutation({
    mutationFn: editTodo,
    // Notice the second argument is the variables object that the `mutate` function receives
    onSuccess: (data, variables) => {
      queryClient.setQueryData(['todo', { id: variables.id }], data)
    },
  })
}

----------------------------------------

TITLE: Executing Manual Parallel Queries with TanStack Query in React
DESCRIPTION: This snippet demonstrates how to execute multiple queries in parallel using TanStack Query's useQuery hook. It shows three queries being executed simultaneously for users, teams, and projects.

LANGUAGE: tsx
CODE:
function App () {
  // The following queries will execute in parallel
  const usersQuery = useQuery({ queryKey: ['users'], queryFn: fetchUsers })
  const teamsQuery = useQuery({ queryKey: ['teams'], queryFn: fetchTeams })
  const projectsQuery = useQuery({ queryKey: ['projects'], queryFn: fetchProjects })
  ...
}

----------------------------------------

TITLE: Vue Query with Loading and Error States
DESCRIPTION: Comprehensive Vue component example showing how to handle loading, error, and success states using destructured query properties. Demonstrates conditional rendering based on query state.

LANGUAGE: vue
CODE:
<script setup>
import { useQuery } from '@tanstack/vue-query'

const { isPending, isError, data, error } = useQuery({
  queryKey: ['todos'],
  queryFn: fetchTodoList,
})
</script>

<template>
  <span v-if="isPending">Loading...</span>
  <span v-else-if="isError">Error: {{ error.message }}</span>
  <!-- We can assume by this point that `isSuccess === true` -->
  <ul v-else-if="data">
    <li v-for="todo in data" :key="todo.id">{{ todo.title }}</li>
  </ul>
</template>

----------------------------------------

TITLE: Rendering Optimistic UI Updates in React Query
DESCRIPTION: This snippet shows how to render optimistic updates in the UI using the mutation's isPending and variables states. It displays a temporary item with reduced opacity while the mutation is in progress.

LANGUAGE: tsx
CODE:
<ul>
  {todoQuery.items.map((todo) => (
    <li key={todo.id}>{todo.text}</li>
  ))}
  {isPending && <li style={{ opacity: 0.5 }}>{variables}</li>}
</ul>

----------------------------------------

TITLE: Implementing Dynamic Parallel Queries with useQueries in TanStack Query
DESCRIPTION: This example shows how to use the useQueries hook from TanStack Query to dynamically execute multiple queries in parallel. It maps over an array of users to create query objects for each user, which are then executed simultaneously.

LANGUAGE: tsx
CODE:
function App({ users }) {
  const userQueries = useQueries({
    queries: users.map((user) => {
      return {
        queryKey: ['user', user.id],
        queryFn: () => fetchUserById(user.id),
      }
    }),
  })
}

----------------------------------------

TITLE: Integrating Angular HttpClient with TanStack Query
DESCRIPTION: Demonstrates how to use Angular's HttpClient within a TanStack Query queryFn. It shows the conversion of an HttpClient observable to a promise using rxjs's lastValueFrom function.

LANGUAGE: typescript
CODE:
@Component({
  // ...
})
class ExampleComponent {
  private readonly http = inject(HttpClient)

  readonly query = injectQuery(() => ({
    queryKey: ['repoData'],
    queryFn: () =>
      lastValueFrom(
        this.http.get('https://api.github.com/repos/tanstack/query'),
      ),
  }))
}

----------------------------------------

TITLE: Implementing Query Cancellation with Fetch in TanStack Query (TSX)
DESCRIPTION: This snippet demonstrates how to use the AbortSignal with fetch in a TanStack Query queryFn. It shows how to pass the signal to one or multiple fetch calls within the same query function.

LANGUAGE: tsx
CODE:
const query = useQuery({
  queryKey: ['todos'],
  queryFn: async ({ signal }) => {
    const todosResponse = await fetch('/todos', {
      // Pass the signal to one fetch
      signal,
    })
    const todos = await todosResponse.json()

    const todoDetails = todos.map(async ({ details }) => {
      const response = await fetch(details, {
        // Or pass it to several
        signal,
      })
      return response.json()
    })

    return Promise.all(todoDetails)
  },
})

----------------------------------------

TITLE: Using onSettled for Error Handling in React Query Mutations
DESCRIPTION: This snippet demonstrates using the onSettled function in place of separate onError and onSuccess handlers for mutations in React Query. It allows for unified error and success handling.

LANGUAGE: tsx
CODE:
useMutation({
  mutationFn: updateTodo,
  // ...
  onSettled: (newTodo, error, variables, context) => {
    if (error) {
      // do something
    }
  },
})

----------------------------------------

TITLE: Defining CreateQueryOptions Interface in TypeScript
DESCRIPTION: Defines the CreateQueryOptions interface with four type parameters. It extends OmitKeyof<CreateBaseQueryOptions>, omitting the 'suspense' property. The interface is used for creating query options in tanstack-query.

LANGUAGE: TypeScript
CODE:
# Interface: CreateQueryOptions<TQueryFnData, TError, TData, TQueryKey>

## Extends

- `OmitKeyof`<[`CreateBaseQueryOptions`](createbasequeryoptions.md)<`TQueryFnData`, `TError`, `TData`, `TQueryFnData`, `TQueryKey`>, `"suspense"`>

## Type Parameters

‚Ä¢ **TQueryFnData** = `unknown`

‚Ä¢ **TError** = `DefaultError`

‚Ä¢ **TData** = `TQueryFnData`

‚Ä¢ **TQueryKey** _extends_ `QueryKey` = `QueryKey`

----------------------------------------

TITLE: Implementing Error Reset Boundary with React Query
DESCRIPTION: Demonstrates how to use the useQueryErrorResetBoundary hook in combination with react-error-boundary to handle and reset query errors. The hook provides a reset function that can be used to clear query errors either within the closest QueryErrorResetBoundary or globally if no boundary is defined.

LANGUAGE: tsx
CODE:
import { useQueryErrorResetBoundary } from '@tanstack/react-query'
import { ErrorBoundary } from 'react-error-boundary'

const App = () => {
  const { reset } = useQueryErrorResetBoundary()
  return (
    <ErrorBoundary
      onReset={reset}
      fallbackRender={({ resetErrorBoundary }) => (
        <div>
          There was an error!
          <Button onClick={() => resetErrorBoundary()}>Try again</Button>
        </div>
      )}
    >
      <Page />
    </ErrorBoundary>
  )
}

----------------------------------------

TITLE: Configuring Global Retry Delay for TanStack Query
DESCRIPTION: Shows how to configure global retry delay settings using QueryClient. Implements an exponential backoff strategy with a maximum delay of 30 seconds.

LANGUAGE: tsx
CODE:
// Configure for all queries
import {
  QueryCache,
  QueryClient,
  QueryClientProvider,
} from '@tanstack/react-query'

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
    },
  },
})

function App() {
  return <QueryClientProvider client={queryClient}>...</QueryClientProvider>
}

----------------------------------------

TITLE: Implementing Infinite Queries with TanStack Query in Vue.js
DESCRIPTION: A complete Vue.js component that implements infinite scrolling using TanStack Query's useInfiniteQuery hook. The component fetches paginated project data, handles loading and error states, and provides a load more button for fetching additional pages. It demonstrates proper usage of query parameters, cursor-based pagination, and UI state management.

LANGUAGE: vue
CODE:
<script setup>
import { useInfiniteQuery } from '@tanstack/vue-query'

const fetchProjects = async ({ pageParam = 0 }) => {
  const res = await fetch('/api/projects?cursor=' + pageParam)
  return res.json()
}

const {
  data,
  error,
  fetchNextPage,
  hasNextPage,
  isFetching,
  isFetchingNextPage,
  isPending,
  isError,
} = useInfiniteQuery({
  queryKey: ['projects'],
  queryFn: fetchProjects,
  getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
})
</script>

<template>
  <span v-if="isPending">Loading...</span>
  <span v-else-if="isError">Error: {{ error.message }}</span>
  <div v-else-if="data">
    <span v-if="isFetching && !isFetchingNextPage">Fetching...</span>
    <ul v-for="(group, index) in data.pages" :key="index">
      <li v-for="project in group.projects" :key="project.id">
        {{ project.name }}
      </li>
    </ul>
    <button
      @click="() => fetchNextPage()"
      :disabled="!hasNextPage || isFetchingNextPage"
    >
      <span v-if="isFetchingNextPage">Loading more...</span>
      <span v-else-if="hasNextPage">Load More</span>
      <span v-else>Nothing more to load</span>
    </button>
  </div>
</template>

----------------------------------------

TITLE: Implementing Vue Query Plugin for Nuxt 3
DESCRIPTION: Sets up Vue Query with Nuxt 3 including hydration/dehydration logic. Creates a QueryClient with custom configuration and handles server/client state management.

LANGUAGE: typescript
CODE:
import type { DehydratedState, VueQueryPluginOptions } from '@tanstack/vue-query'
import { VueQueryPlugin, QueryClient, hydrate, dehydrate } from '@tanstack/vue-query'
import { defineNuxtPlugin, useState } from '#imports'

export default defineNuxtPlugin((nuxt) => {
  const vueQueryState = useState<DehydratedState | null>('vue-query')

  const queryClient = new QueryClient({
    defaultOptions: { queries: { staleTime: 5000 } },
  })
  const options: VueQueryPluginOptions = { queryClient }

  nuxt.vueApp.use(VueQueryPlugin, options)

  if (import.meta.server) {
    nuxt.hooks.hook('app:rendered', () => {
      vueQueryState.value = dehydrate(queryClient)
    })
  }

  if (import.meta.client) {
    hydrate(queryClient, vueQueryState.value)
  }
})

----------------------------------------

TITLE: Implementing Dynamic Parallel Queries with useQueries in React
DESCRIPTION: This snippet shows how to use useQueries for dynamic parallel queries that depend on a previous query. It first fetches user IDs, then uses those IDs to fetch messages for each user in parallel.

LANGUAGE: tsx
CODE:
// Get the users ids
const { data: userIds } = useQuery({
  queryKey: ['users'],
  queryFn: getUsersData,
  select: (users) => users.map((user) => user.id),
})

// Then get the users messages
const usersMessages = useQueries({
  queries: userIds
    ? userIds.map((id) => {
        return {
          queryKey: ['messages', id],
          queryFn: () => getMessagesByUsers(id),
        }
      })
    : [], // if users is undefined, an empty array will be returned
})

----------------------------------------

TITLE: Type Inference with Data Transformation
DESCRIPTION: Shows how TypeScript handles type inference when using the select option to transform query results.

LANGUAGE: tsx
CODE:
const { data } = useQuery({
  //      ^? const data: string | undefined
  queryKey: ['test'],
  queryFn: () => Promise.resolve(5),
  select: (data) => data.toString(),
})

----------------------------------------

TITLE: Implementing Basic GitHub Repository Data Fetching with TanStack Query in Angular
DESCRIPTION: Demonstrates a simple Angular component using TanStack Query to fetch and display GitHub repository statistics. Shows basic query implementation with error handling, loading states, and data display using Angular's template syntax.

LANGUAGE: typescript
CODE:
import { ChangeDetectionStrategy, Component, inject } from '@angular/core'
import { HttpClient } from '@angular/common/http'
import { CommonModule } from '@angular/common'
import { injectQuery } from '@tanstack/angular-query-experimental'
import { lastValueFrom } from 'rxjs'

@Component({
  changeDetection: ChangeDetectionStrategy.OnPush,
  selector: 'simple-example',
  standalone: true,
  template: `
    @if (query.isPending()) {
      Loading...
    }
    @if (query.error()) {
      An error has occurred: {{ query.error().message }}
    }
    @if (query.data(); as data) {
      <h1>{{ data.name }}</h1>
      <p>{{ data.description }}</p>
      <strong>üëÄ {{ data.subscribers_count }}</strong>
      <strong>‚ú® {{ data.stargazers_count }}</strong>
      <strong>üç¥ {{ data.forks_count }}</strong>
    }
  `
})
export class SimpleExampleComponent {
  http = inject(HttpClient)

  query = injectQuery(() => ({
    queryKey: ['repoData'],
    queryFn: () =>
      lastValueFrom(
        this.http.get<Response>('https://api.github.com/repos/tanstack/query'),
      ),
  }))
}

interface Response {
  name: string
  description: string
  subscribers_count: number
  stargazers_count: number
  forks_count: number
}

----------------------------------------

TITLE: Installing TanStack Query Persist Client Core Package
DESCRIPTION: Various package manager commands to install the @tanstack/query-persist-client-core package.

LANGUAGE: bash
CODE:
npm install @tanstack/query-persist-client-core

LANGUAGE: bash
CODE:
pnpm add @tanstack/query-persist-client-core

LANGUAGE: bash
CODE:
yarn add @tanstack/query-persist-client-core

LANGUAGE: bash
CODE:
bun add @tanstack/query-persist-client-core

----------------------------------------

TITLE: Invalidating Queries with QueryClient in TanStack Query
DESCRIPTION: Demonstrates how to use the invalidateQueries method to invalidate and refetch queries based on query keys or other properties. It includes options for controlling refetch behavior.

LANGUAGE: tsx
CODE:
await queryClient.invalidateQueries(
  {
    queryKey: ['posts'],
    exact,
    refetchType: 'active',
  },
  { throwOnError, cancelRefetch },
)

----------------------------------------

TITLE: Creating a Todo Mutation in Angular Component
DESCRIPTION: Demonstrates how to use injectMutation to create a todo item in an Angular component. It shows handling of different mutation states and triggering the mutation on button click.

LANGUAGE: angular-ts
CODE:
@Component({
  template: `
    <div>
      @if (mutation.isPending()) {
        <span>Adding todo...</span>
      } @else if (mutation.isError()) {
        <div>An error occurred: {{ mutation.error()?.message }}</div>
      } @else if (mutation.isSuccess()) {
        <div>Todo added!</div>
      }
      <button (click)="mutation.mutate(1)">Create Todo</button>
    </div>
  `,
})
export class TodosComponent {
  todoService = inject(TodoService)
  mutation = injectMutation(() => ({
    mutationFn: (todoId: number) =>
      lastValueFrom(this.todoService.create(todoId)),
  }))
}

----------------------------------------

TITLE: Implementing Query Cancellation with XMLHttpRequest in TanStack Query (TSX)
DESCRIPTION: This example demonstrates how to use the AbortSignal with XMLHttpRequest in a TanStack Query queryFn. It sets up event listeners for load and abort, and manually aborts the request when the signal is aborted.

LANGUAGE: tsx
CODE:
const query = useQuery({
  queryKey: ['todos'],
  queryFn: ({ signal }) => {
    return new Promise((resolve, reject) => {
      var oReq = new XMLHttpRequest()
      oReq.addEventListener('load', () => {
        resolve(JSON.parse(oReq.responseText))
      })
      signal?.addEventListener('abort', () => {
        oReq.abort()
        reject()
      })
      oReq.open('GET', '/todos')
      oReq.send()
    })
  },
})

----------------------------------------

TITLE: Configuring QueryClient for Server-Side Rendering in TanStack Query
DESCRIPTION: Demonstrates how to set up a QueryClient for server-side rendering with NextJS, including setting default stale time and creating separate clients for server and browser environments.

LANGUAGE: tsx
CODE:
// app/providers.tsx
'use client'

import {
  isServer,
  QueryClient,
  QueryClientProvider,
} from '@tanstack/react-query'
import * as React from 'react'
import { ReactQueryStreamedHydration } from '@tanstack/react-query-next-experimental'

function makeQueryClient() {
  return new QueryClient({
    defaultOptions: {
      queries: {
        // With SSR, we usually want to set some default staleTime
        // above 0 to avoid refetching immediately on the client
        staleTime: 60 * 1000,
      },
    },
  })
}

let browserQueryClient: QueryClient | undefined = undefined

function getQueryClient() {
  if (isServer) {
    // Server: always make a new query client
    return makeQueryClient()
  } else {
    // Browser: make a new query client if we don't already have one
    // This is very important, so we don't re-make a new client if React
    // suspends during the initial render. This may not be needed if we
    // have a suspense boundary BELOW the creation of the query client
    if (!browserQueryClient) browserQueryClient = makeQueryClient()
    return browserQueryClient
  }
}

export function Providers(props: { children: React.ReactNode }) {
  // NOTE: Avoid useState when initializing the query client if you don't
  //       have a suspense boundary between this and the code that may
  //       suspend because React will throw away the client on the initial
  //       render if it suspends and there is no boundary
  const queryClient = getQueryClient()

  return (
    <QueryClientProvider client={queryClient}>
      <ReactQueryStreamedHydration>
        {props.children}
      </ReactQueryStreamedHydration>
    </QueryClientProvider>
  )
}

----------------------------------------

TITLE: Connecting QueryClient to React App using QueryClientProvider
DESCRIPTION: This snippet demonstrates how to use the QueryClientProvider component to provide a QueryClient instance to a React application. It shows the import statements, creation of a QueryClient instance, and wrapping the App component with QueryClientProvider.

LANGUAGE: tsx
CODE:
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'

const queryClient = new QueryClient()

function App() {
  return <QueryClientProvider client={queryClient}>...</QueryClientProvider>
}

----------------------------------------

TITLE: Implementing Query Cancellation with Axios v0.22.0+ in TanStack Query (TSX)
DESCRIPTION: This example shows how to use the AbortSignal with Axios version 0.22.0 or higher in a TanStack Query queryFn. It demonstrates passing the signal directly to the Axios get method.

LANGUAGE: tsx
CODE:
import axios from 'axios'

const query = useQuery({
  queryKey: ['todos'],
  queryFn: ({ signal }) =>
    axios.get('/todos', {
      // Pass the signal to `axios`
      signal,
    }),
})

----------------------------------------

TITLE: Vue Query Plugin Setup for Nuxt 2
DESCRIPTION: Configures Vue Query plugin for Nuxt 2 with client/server state management and hydration support.

LANGUAGE: javascript
CODE:
import Vue from 'vue'
import { VueQueryPlugin, QueryClient, hydrate } from '@tanstack/vue-query'

export default (context) => {
  const queryClient = new QueryClient({
    defaultOptions: { queries: { staleTime: 5000 } },
  })

  if (process.server) {
    context.ssrContext.VueQuery = queryClient
  }

  if (process.client) {
    Vue.use(VueQueryPlugin, { queryClient })

    if (context.nuxtState && context.nuxtState.vueQueryState) {
      hydrate(queryClient, context.nuxtState.vueQueryState)
    }
  }
}

----------------------------------------

TITLE: Passing Parameters to Query Functions in TanStack Query with TypeScript
DESCRIPTION: This snippet demonstrates how to pass parameters to a query function using the queryKey. It shows how to define a query with multiple parameters and access them within the query function.

LANGUAGE: typescript
CODE:
result = injectQuery(() => ({
  queryKey: ['todos', { status: status(), page: page() }],
  queryFn: fetchTodoList,
}))

// Access the key, status and page variables in your query function!
function fetchTodoList({ queryKey }) {
  const [_key, { status, page }] = queryKey
  return new Promise()
}

----------------------------------------

TITLE: Advanced Pagination Component in Angular with TanStack Query
DESCRIPTION: Implements a full pagination component using TanStack Query in Angular. It includes handling of loading states, error states, and pagination controls. The component also demonstrates prefetching of the next page and use of placeholder data for smooth transitions.

LANGUAGE: angular-ts
CODE:
@Component({
  selector: 'pagination-example',
  template: `
    <div>
      <p>
        In this example, each page of data remains visible as the next page is
        fetched. The buttons and capability to proceed to the next page are also
        suppressed until the next page cursor is known. Each page is cached as a
        normal query too, so when going to previous pages, you'll see them
        instantaneously while they are also re-fetched invisibly in the
        background.
      </p>
      @if (query.status() === 'pending') {
        <div>Loading...</div>
      } @else if (query.status() === 'error') {
        <div>Error: {{ query.error().message }}</div>
      } @else {
        <!-- 'data' will either resolve to the latest page's data -->
        <!-- or if fetching a new page, the last successful page's data -->
        <div>
          @for (project of query.data().projects; track project.id) {
            <p>{{ project.name }}</p>
          }
        </div>
      }

      <div>Current Page: {{ page() + 1 }}</div>
      <button (click)="previousPage()" [disabled]="page() === 0">
        Previous Page
      </button>
      <button
        (click)="nextPage()"
        [disabled]="query.isPlaceholderData() || !query.data()?.hasMore"
      >
        Next Page
      </button>
      <!-- Since the last page's data potentially sticks around between page requests, -->
      <!-- we can use 'isFetching' to show a background loading -->
      <!-- indicator since our status === 'pending' state won't be triggered -->
      @if (query.isFetching()) {
        <span> Loading...</span>
      }
    </div>
  `,
})
export class PaginationExampleComponent {
  page = signal(0)
  queryClient = inject(QueryClient)

  query = injectQuery(() => ({
    queryKey: ['projects', this.page()],
    queryFn: () => lastValueFrom(fetchProjects(this.page())),
    placeholderData: keepPreviousData,
    staleTime: 5000,
  }))

  constructor() {
    effect(() => {
      // Prefetch the next page!
      if (!this.query.isPlaceholderData() && this.query.data()?.hasMore) {
        this.#queryClient.prefetchQuery({
          queryKey: ['projects', this.page() + 1],
          queryFn: () => lastValueFrom(fetchProjects(this.page() + 1)),
        })
      }
    })
  }

  previousPage() {
    this.page.update((old) => Math.max(old - 1, 0))
  }

  nextPage() {
    this.page.update((old) => (this.query.data()?.hasMore ? old + 1 : old))
  }
}

----------------------------------------

TITLE: Implementing Individual Query Loading States with TanStack Query in TSX
DESCRIPTION: Demonstrates how to use the isFetching boolean flag alongside status checks to display loading states for individual queries. The component shows different UI states based on the query status and background fetching state.

LANGUAGE: tsx
CODE:
function Todos() {
  const {
    status,
    data: todos,
    error,
    isFetching,
  } = useQuery({
    queryKey: ['todos'],
    queryFn: fetchTodos,
  })

  return status === 'pending' ? (
    <span>Loading...</span>
  ) : status === 'error' ? (
    <span>Error: {error.message}</span>
  ) : (
    <>
      {isFetching ? <div>Refreshing...</div> : null}

      <div>
        {todos.map((todo) => (
          <Todo todo={todo} />
        ))}
      </div>
    </>
  )
}

----------------------------------------

TITLE: Testing Infinite Query Implementation
DESCRIPTION: Complete test implementation for infinite query functionality including next page fetching.

LANGUAGE: tsx
CODE:
const { result, waitFor } = renderHook(() => useInfiniteQueryCustomHook(), {
  wrapper,
})

await waitFor(() => result.current.isSuccess)

expect(result.current.data.pages).toStrictEqual(generateMockedResponse(1))

result.current.fetchNextPage()

await waitFor(() =>
  expect(result.current.data.pages).toStrictEqual([
    ...generateMockedResponse(1),
    ...generateMockedResponse(2),
  ]),
)

expectation.done()

----------------------------------------

TITLE: Advanced Paginated Query with Placeholder Data
DESCRIPTION: Complete implementation of paginated queries using keepPreviousData for smooth transitions between pages. This approach maintains previous data while loading new pages and includes UI elements for navigation and loading states.

LANGUAGE: tsx
CODE:
import { keepPreviousData, useQuery } from '@tanstack/react-query'
import React from 'react'

function Todos() {
  const [page, setPage] = React.useState(0)

  const fetchProjects = (page = 0) =>
    fetch('/api/projects?page=' + page).then((res) => res.json())

  const { isPending, isError, error, data, isFetching, isPlaceholderData } =
    useQuery({
      queryKey: ['projects', page],
      queryFn: () => fetchProjects(page),
      placeholderData: keepPreviousData,
    })

  return (
    <div>
      {isPending ? (
        <div>Loading...</div>
      ) : isError ? (
        <div>Error: {error.message}</div>
      ) : (
        <div>
          {data.projects.map((project) => (
            <p key={project.id}>{project.name}</p>
          ))}
        </div>
      )}
      <span>Current Page: {page + 1}</span>
      <button
        onClick={() => setPage((old) => Math.max(old - 1, 0))}
        disabled={page === 0}
      >
        Previous Page
      </button>
      <button
        onClick={() => {
          if (!isPlaceholderData && data.hasMore) {
            setPage((old) => old + 1)
          }
        }}
        disabled={isPlaceholderData || !data?.hasMore}
      >
        Next Page
      </button>
      {isFetching ? <span> Loading...</span> : null}
    </div>
  )

----------------------------------------

TITLE: Installing TanStack Angular Query with Yarn
DESCRIPTION: Command to install the experimental version of TanStack Angular Query using Yarn package manager. Requires Angular v16 or higher.

LANGUAGE: bash
CODE:
yarn add @tanstack/angular-query-experimental

----------------------------------------

TITLE: Query Status Transitions in TanStack Query
DESCRIPTION: This snippet shows the different status states a dependent query goes through in TanStack Query. It illustrates the initial state, the fetching state when enabled, and the success state.

LANGUAGE: tsx
CODE:
status: 'pending'
isPending: true
fetchStatus: 'idle'

LANGUAGE: tsx
CODE:
status: 'pending'
isPending: true
fetchStatus: 'fetching'

LANGUAGE: tsx
CODE:
status: 'success'
isPending: false
fetchStatus: 'idle'

----------------------------------------

TITLE: Implementing Default Query Function in TanStack Query with Vue
DESCRIPTION: This snippet shows how to define a default query function using axios for HTTP requests, configure it with Vue Query plugin options, and use it in a query. The default function automatically handles requests to a specific API endpoint based on the provided query key.

LANGUAGE: tsx
CODE:
// Define a default query function that will receive the query key
const defaultQueryFn = async ({ queryKey }) => {
  const { data } = await axios.get(
    `https://jsonplaceholder.typicode.com${queryKey[0]}`,
  )
  return data
}

// provide the default query function to your app with defaultOptions
const vueQueryPluginOptions: VueQueryPluginOptions = {
  queryClientConfig: {
    defaultOptions: { queries: { queryFn: defaultQueryFn } },
  },
}
app.use(VueQueryPlugin, vueQueryPluginOptions)

// All you have to do now is pass a key!
const { status, data, error, isFetching } = useQuery({
  queryKey: [`/posts/${postId}`],
})

----------------------------------------

TITLE: Implementing Static Parallel Queries in Angular
DESCRIPTION: Demonstrates how to execute multiple independent queries simultaneously using injectQuery. Each query is defined with a unique queryKey and corresponding queryFn for fetching different data types.

LANGUAGE: typescript
CODE:
export class AppComponent {
  // The following queries will execute in parallel
  usersQuery = injectQuery(() => ({ queryKey: ['users'], queryFn: fetchUsers }))
  teamsQuery = injectQuery(() => ({ queryKey: ['teams'], queryFn: fetchTeams }))
  projectsQuery = injectQuery(() => ({
    queryKey: ['projects'],
    queryFn: fetchProjects,
  }))
}

----------------------------------------

TITLE: Simplified Query Injection in Angular
DESCRIPTION: Shows a more concise way to inject a query for fetching todos in an Angular component.

LANGUAGE: typescript
CODE:
result = injectQuery(() => ({ queryKey: ['todos'], queryFn: fetchTodoList }))

----------------------------------------

TITLE: Implementing Floating Mode Devtools
DESCRIPTION: Setup code for floating mode devtools that creates a toggleable panel fixed to the corner of the screen. The state is preserved in localStorage.

LANGUAGE: tsx
CODE:
import { ReactQueryDevtools } from '@tanstack/react-query-devtools'

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      {/* The rest of your application */}
      <ReactQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
  )
}

----------------------------------------

TITLE: Dehydrating Query Client in TanStack Query (TypeScript)
DESCRIPTION: The dehydrate function creates a frozen representation of a query cache. It's useful for server-side rendering or persisting queries. By default, it only includes successful queries.

LANGUAGE: tsx
CODE:
import { dehydrate } from '@tanstack/react-query'

const dehydratedState = dehydrate(queryClient, {
  shouldDehydrateQuery,
  shouldDehydrateMutation,
})

----------------------------------------

TITLE: Dynamic Parallel Queries with injectQueries
DESCRIPTION: Shows how to use injectQueries to dynamically create and execute multiple queries based on a signal array. Each query is generated for individual user data fetching based on user IDs.

LANGUAGE: typescript
CODE:
export class AppComponent {
  users = signal<Array<User>>([])

  // Please note injectQueries is under development and this code does not work yet
  userQueries = injectQueries(() => ({
    queries: users().map((user) => {
      return {
        queryKey: ['user', user.id],
        queryFn: () => fetchUserById(user.id),
      }
    }),
  }))
}

----------------------------------------

TITLE: Resetting Mutation State in React with TanStack Query
DESCRIPTION: Demonstrates how to reset the error or data state of a mutation using the reset function provided by useMutation.

LANGUAGE: tsx
CODE:
const CreateTodo = () => {
  const [title, setTitle] = useState('')
  const mutation = useMutation({ mutationFn: createTodo })

  const onCreateTodo = (e) => {
    e.preventDefault()
    mutation.mutate({ title })
  }

  return (
    <form onSubmit={onCreateTodo}>
      {mutation.error && (
        <h5 onClick={() => mutation.reset()}>{mutation.error}</h5>
      )}
      <input
        type="text"
        value={title}
        onChange={(e) => setTitle(e.target.value)}
      />
      <br />
      <button type="submit">Create Todo</button>
    </form>
  )
}

----------------------------------------

TITLE: Using useMutationState for Optimistic Updates in React Query
DESCRIPTION: This snippet shows how to use the useMutationState hook to access mutation state across components. It demonstrates setting up a mutation with a mutationKey and accessing its variables in a different component.

LANGUAGE: tsx
CODE:
// somewhere in your app
const { mutate } = useMutation({
  mutationFn: (newTodo: string) => axios.post('/api/data', { text: newTodo }),
  onSettled: () => queryClient.invalidateQueries({ queryKey: ['todos'] }),
  mutationKey: ['addTodo'],
})

// access variables somewhere else
const variables = useMutationState<string>({
  filters: { mutationKey: ['addTodo'], status: 'pending' },
  select: (mutation) => mutation.state.variables,
})

----------------------------------------

TITLE: Resetting Mutation State in React with TanStack Query
DESCRIPTION: Demonstrates how to reset the error or data state of a mutation using the reset function provided by useMutation.

LANGUAGE: tsx
CODE:
const CreateTodo = () => {
  const [title, setTitle] = useState('')
  const mutation = useMutation({ mutationFn: createTodo })

  const onCreateTodo = (e) => {
    e.preventDefault()
    mutation.mutate({ title })
  }

  return (
    <form onSubmit={onCreateTodo}>
      {mutation.error && (
        <h5 onClick={() => mutation.reset()}>{mutation.error}</h5>
      )}
      <input
        type="text"
        value={title}
        onChange={(e) => setTitle(e.target.value)}
      />
      <br />
      <button type="submit">Create Todo</button>
    </form>
  )
}

----------------------------------------

TITLE: Persister API Type Definition
DESCRIPTION: TypeScript interface definitions for the StoragePersisterOptions and AsyncStorage interfaces.

LANGUAGE: tsx
CODE:
export interface StoragePersisterOptions {
  storage: AsyncStorage | Storage | undefined | null
  serialize?: (persistedQuery: PersistedQuery) => string
  deserialize?: (cachedString: string) => PersistedQuery
  buster?: string
  maxAge?: number
  prefix?: string
  filters?: QueryFilters
}

interface AsyncStorage {
  getItem: (key: string) => Promise<string | undefined | null>
  setItem: (key: string, value: string) => Promise<unknown>
  removeItem: (key: string) => Promise<void>
}

----------------------------------------

TITLE: Memoizing Select Function with useCallback in React Query
DESCRIPTION: Shows how to optimize the select function in a React Query hook by wrapping it with useCallback. This prevents unnecessary re-renders by maintaining a stable function reference.

LANGUAGE: javascript
CODE:
export const useTodoCount = () => {
  return useTodos(useCallback((data) => data.length, []))
}

----------------------------------------

TITLE: Enabling Traditional Vue Devtools Integration
DESCRIPTION: Configuration code to enable Vue Query integration with official Vue devtools. This enables custom inspector and timeline events in the Vue devtools.

LANGUAGE: typescript
CODE:
app.use(VueQueryPlugin, {
  enableDevtoolsV6Plugin: true,
})

----------------------------------------

TITLE: Setting Maximum Pages in TanStack Query Infinite Query
DESCRIPTION: This snippet demonstrates how to set a maximum number of pages for an infinite query using TanStack Query. It also includes configuration for initial page parameter and pagination functions.

LANGUAGE: ts
CODE:
injectInfiniteQuery(() => ({
  queryKey: ['projects'],
  queryFn: fetchProjects,
  initialPageParam: 0,
  getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
  getPreviousPageParam: (firstPage, pages) => firstPage.prevCursor,
  maxPages: 3,
}))

----------------------------------------

TITLE: Query Result Assignment in React Query
DESCRIPTION: Shows how to store the query result in a variable for accessing various query states and data.

LANGUAGE: tsx
CODE:
const result = useQuery({ queryKey: ['todos'], queryFn: fetchTodoList })

----------------------------------------

TITLE: Documentation Mapping Configuration for useInfiniteQuery
DESCRIPTION: YAML frontmatter configuration that specifies documentation mapping parameters for converting React Query's useInfiniteQuery documentation to Vue Query equivalent.

LANGUAGE: yaml
CODE:
---
id: useInfiniteQuery
title: useInfiniteQuery
ref: docs/framework/react/reference/useInfiniteQuery.md
replace: { '@tanstack/react-query': '@tanstack/vue-query' }
---

----------------------------------------

TITLE: Prefetching Infinite Queries with TanStack Query in TypeScript
DESCRIPTION: Shows how to prefetch an infinite query using the prefetchInfiniteQuery method. This example demonstrates prefetching multiple pages of data, using the pages option and getNextPageParam function.

LANGUAGE: tsx
CODE:
const prefetchProjects = async () => {
  // The results of this query will be cached like a normal query
  await queryClient.prefetchInfiniteQuery({
    queryKey: ['projects'],
    queryFn: fetchProjects,
    initialPageParam: 0,
    getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
    pages: 3, // prefetch the first 3 pages
  })
}

----------------------------------------

TITLE: Vite SSR Integration with Vue Query
DESCRIPTION: Demonstrates how to integrate Vue Query with Vite SSR, including state serialization and hydration.

LANGUAGE: javascript
CODE:
import App from './App.vue'
import viteSSR from 'vite-ssr/vue'
import { QueryClient, VueQueryPlugin, hydrate, dehydrate } from '@tanstack/vue-query'

export default viteSSR(App, { routes: [] }, ({ app, initialState }) => {
  const queryClient = new QueryClient()

  if (import.meta.env.SSR) {
    initialState.vueQueryState = { toJSON: () => dehydrate(queryClient) }
  } else {
    hydrate(queryClient, initialState.vueQueryState)
  }

  app.use(VueQueryPlugin, { queryClient })
})

----------------------------------------

TITLE: Using Query Filters in TanStack Query
DESCRIPTION: Examples of using QueryFilters for canceling, removing, and refetching queries with different filter conditions. Shows how to filter queries based on query keys and types.

LANGUAGE: tsx
CODE:
// Cancel all queries
await queryClient.cancelQueries()

// Remove all inactive queries that begin with `posts` in the key
queryClient.removeQueries({ queryKey: ['posts'], type: 'inactive' })

// Refetch all active queries
await queryClient.refetchQueries({ type: 'active' })

// Refetch all active queries that begin with `posts` in the key
await queryClient.refetchQueries({ queryKey: ['posts'], type: 'active' })

----------------------------------------

TITLE: Basic Todo Mutation Setup
DESCRIPTION: Basic mutation setup for adding todos with query invalidation on settlement.

LANGUAGE: typescript
CODE:
addTodo = injectMutation(() => ({
  mutationFn: (newTodo: string) => axios.post('/api/data', { text: newTodo }),
  // make sure to _return_ the Promise from the query invalidation
  // so that the mutation stays in `pending` state until the refetch is finished
  onSettled: async () => {
    return await queryClient.invalidateQueries({ queryKey: ['todos'] })
  },
}))

----------------------------------------

TITLE: Basic createQuery Implementation with TypeScript
DESCRIPTION: Shows the complete signature of createQuery with all possible return values and configuration options. Demonstrates the full type interface for query configuration.

LANGUAGE: tsx
CODE:
const {
  data,
  dataUpdatedAt,
  error,
  errorUpdatedAt,
  failureCount,
  failureReason,
  fetchStatus,
  isError,
  isFetched,
  isFetchedAfterMount,
  isFetching,
  isInitialLoading,
  isLoading,
  isLoadingError,
  isPaused,
  isPending,
  isPlaceholderData,
  isRefetchError,
  isRefetching,
  isStale,
  isSuccess,
  refetch,
  status,
} = createQuery(
  () => ({
    queryKey,
    queryFn,
    enabled,
    select,
    placeholderData,
    deferStream,
    reconcile,
    gcTime,
    networkMode,
    initialData,
    initialDataUpdatedAt,
    meta,
    queryKeyHashFn,
    refetchInterval,
    refetchIntervalInBackground,
    refetchOnMount,
    refetchOnReconnect,
    refetchOnWindowFocus,
    retry,
    retryOnMount,
    retryDelay,
    staleTime,
    throwOnError,
  }),
  () => queryClient,
)

----------------------------------------

TITLE: Error Type Handling in Vue Query with TypeScript
DESCRIPTION: Shows how to handle and narrow the type of the 'error' object returned by Vue Query. The error is initially of type 'unknown' and can be narrowed to 'Error' using an instanceof check.

LANGUAGE: tsx
CODE:
const { error } = useQuery({ queryKey: ['groups'], queryFn: fetchGroups })
//      ^? const error: Ref<unknown>

if (error.value instanceof Error) {
  error.value
  //     ^? const error: Error
}

----------------------------------------

TITLE: Implementing QueryErrorResetBoundary with Error Boundary in React
DESCRIPTION: Demonstrates how to wrap components with QueryErrorResetBoundary and ErrorBoundary to handle query errors and provide retry functionality. The component provides a reset function that can be used with ErrorBoundary to clear query errors and retry failed queries.

LANGUAGE: tsx
CODE:
import { QueryErrorResetBoundary } from '@tanstack/react-query'
import { ErrorBoundary } from 'react-error-boundary'

const App = () => (
  <QueryErrorResetBoundary>
    {({ reset }) => (
      <ErrorBoundary
        onReset={reset}
        fallbackRender={({ resetErrorBoundary }) => (
          <div>
            There was an error!
            <Button onClick={() => resetErrorBoundary()}>Try again</Button>
          </div>
        )}
      >
        <Page />
      </ErrorBoundary>
    )}
  </QueryErrorResetBoundary>
)

----------------------------------------

TITLE: Implementing SSR with Remix
DESCRIPTION: Shows how to implement server-side rendering with React Query in a Remix application, including loader function and hydration setup.

LANGUAGE: tsx
CODE:
import { json } from '@remix-run/node'
import {
  dehydrate,
  HydrationBoundary,
  QueryClient,
  useQuery,
} from '@tanstack/react-query'

export async function loader() {
  const queryClient = new QueryClient()

  await queryClient.prefetchQuery({
    queryKey: ['posts'],
    queryFn: getPosts,
  })

  return json({ dehydratedState: dehydrate(queryClient) })
}

function Posts() {
  const { data } = useQuery({ queryKey: ['posts'], queryFn: getPosts })
  const { data: commentsData } = useQuery({
    queryKey: ['posts-comments'],
    queryFn: getComments,
  })

  // ...
}

export default function PostsRoute() {
  const { dehydratedState } = useLoaderData<typeof loader>()
  return (
    <HydrationBoundary state={dehydratedState}>
      <Posts />
    </HydrationBoundary>
  )
}

----------------------------------------

TITLE: Combining Query Results with useQueries in TanStack Query (TSX)
DESCRIPTION: Shows how to use the combine option in useQueries to aggregate data from multiple query results. The combine function maps the data from each result and checks if any query is pending, returning a single object with combined data and pending status.

LANGUAGE: tsx
CODE:
const ids = [1, 2, 3]
const combinedQueries = useQueries({
  queries: ids.map((id) => ({
    queryKey: ['post', id],
    queryFn: () => fetchPost(id),
  })),
  combine: (results) => {
    return {
      data: results.map((result) => result.data),
      pending: results.some((result) => result.isPending),
    }
  },
})

----------------------------------------

TITLE: Implementing Query Cancellation with TanStack Query in TypeScript
DESCRIPTION: Example showing how to implement query cancellation using both automatic signal handling in the queryFn and manual cancellation via queryClient. The query function accepts an AbortSignal parameter which is automatically passed by TanStack Query, while the cancelQueries method allows explicit cancellation of pending queries.

LANGUAGE: typescript
CODE:
const query = useQuery({
  queryKey: ['todos'],
  queryFn: async ({ signal }) => {
    const resp = await fetch('/todos', { signal })
    return resp.json()
  },
})

const queryClient = useQueryClient()

function onButtonClick() {
  queryClient.cancelQueries({ queryKey: ['todos'] })
}

----------------------------------------

TITLE: Implementing Infinite Query Component in Angular with TanStack Query
DESCRIPTION: This snippet shows how to set up an infinite query in an Angular component using TanStack Query. It includes query configuration, pagination logic, and computed properties for UI state.

LANGUAGE: angular-ts
CODE:
import { Component, computed, inject } from '@angular/core'
import { injectInfiniteQuery } from '@tanstack/angular-query-experimental'
import { lastValueFrom } from 'rxjs'
import { ProjectsService } from './projects-service'

@Component({
  selector: 'example',
  templateUrl: './example.component.html',
})
export class Example {
  projectsService = inject(ProjectsService)

  query = injectInfiniteQuery(() => ({
    queryKey: ['projects'],
    queryFn: async ({ pageParam }) => {
      return lastValueFrom(this.projectsService.getProjects(pageParam))
    },
    initialPageParam: 0,
    getPreviousPageParam: (firstPage) => firstPage.previousId ?? undefined,
    getNextPageParam: (lastPage) => lastPage.nextId ?? undefined,
    maxPages: 3,
  }))

  nextButtonDisabled = computed(
    () => !this.#hasNextPage() || this.#isFetchingNextPage(),
  )
  nextButtonText = computed(() =>
    this.#isFetchingNextPage()
      ? 'Loading more...'
      : this.#hasNextPage()
        ? 'Load newer'
        : 'Nothing more to load',
  )

  #hasNextPage = this.query.hasNextPage
  #isFetchingNextPage = this.query.isFetchingNextPage
}

----------------------------------------

TITLE: Installing Vue Query via NPM
DESCRIPTION: Command to install Vue Query using NPM package manager.

LANGUAGE: bash
CODE:
npm i @tanstack/vue-query

----------------------------------------

TITLE: Using React.use() with TanStack Query (Experimental)
DESCRIPTION: Demonstrates how to use React.use() with TanStack Query's useQuery hook for a more declarative approach to handling asynchronous data fetching in React components.

LANGUAGE: tsx
CODE:
import React from 'react'
import { useQuery } from '@tanstack/react-query'
import { fetchTodos, type Todo } from './api'

function TodoList({ query }: { query: UseQueryResult<Todo[]> }) {
  const data = React.use(query.promise)

  return (
    <ul>
      {data.map((todo) => (
        <li key={todo.id}>{todo.title}</li>
      ))}
    </ul>
  )
}

export function App() {
  const query = useQuery({ queryKey: ['todos'], queryFn: fetchTodos })

  return (
    <>
      <h1>Todos</h1>
      <React.Suspense fallback={<div>Loading...</div>}>
        <TodoList query={query} />
      </React.Suspense>
    </>
  )
}

----------------------------------------

TITLE: Implementing Global Background Fetching Indicator in Vue with TanStack Query
DESCRIPTION: This snippet shows how to use the useIsFetching hook from TanStack Query to create a global background fetching indicator. It displays a message when any query in the application is fetching data in the background.

LANGUAGE: vue
CODE:
<script setup>
import { useIsFetching } from '@tanstack/vue-query'

const isFetching = useIsFetching()
</script>

<template>
  <div v-if="isFetching">Queries are fetching in the background...</div>
</template>

----------------------------------------

TITLE: Defining Query Keys for Todo Fetching in TanStack Query (JavaScript)
DESCRIPTION: This snippet demonstrates how to create a custom hook that uses TanStack Query to fetch a todo item by its ID. It shows the proper structure of query keys and how they are used in conjunction with the useQuery hook.

LANGUAGE: javascript
CODE:
function useTodos(todoId) {
  const queryKey = ['todos', todoId]
  return useQuery({
    queryKey,
    queryFn: () => fetchTodoById(todoId.value),
  })
}

----------------------------------------

TITLE: Implementing SSR with Next.js Pages Router
DESCRIPTION: Demonstrates full server-side rendering implementation with React Query in Next.js, including prefetching data and hydrating the client state.

LANGUAGE: tsx
CODE:
import {
  dehydrate,
  HydrationBoundary,
  QueryClient,
  useQuery,
} from '@tanstack/react-query'

export async function getStaticProps() {
  const queryClient = new QueryClient()

  await queryClient.prefetchQuery({
    queryKey: ['posts'],
    queryFn: getPosts,
  })

  return {
    props: {
      dehydratedState: dehydrate(queryClient),
    },
  }
}

function Posts() {
  const { data } = useQuery({ queryKey: ['posts'], queryFn: getPosts })
  const { data: commentsData } = useQuery({
    queryKey: ['posts-comments'],
    queryFn: getComments,
  })

  // ...
}

export default function PostsRoute({ dehydratedState }) {
  return (
    <HydrationBoundary state={dehydratedState}>
      <Posts />
    </HydrationBoundary>
  )
}

----------------------------------------

TITLE: Creating Global Background Fetching Indicator with TanStack Query in TSX
DESCRIPTION: Shows how to implement a global loading indicator using the useIsFetching hook to display when any queries are fetching data in the background.

LANGUAGE: tsx
CODE:
import { useIsFetching } from '@tanstack/react-query'

function GlobalLoadingIndicator() {
  const isFetching = useIsFetching()

  return isFetching ? (
    <div>Queries are fetching in the background...</div>
  ) : null
}

----------------------------------------

TITLE: Advanced Mutation Configuration with Optimistic Updates
DESCRIPTION: Provides a comprehensive example of setting up mutations with optimistic updates, including cancelling queries, handling success and error cases, and integrating with query client methods.

LANGUAGE: ts
CODE:
const queryClient = new QueryClient()

// Define the "addTodo" mutation
queryClient.setMutationDefaults(['addTodo'], {
  mutationFn: addTodo,
  onMutate: async (variables) => {
    // Cancel current queries for the todos list
    await queryClient.cancelQueries({ queryKey: ['todos'] })

    // Create optimistic todo
    const optimisticTodo = { id: uuid(), title: variables.title }

    // Add optimistic todo to todos list
    queryClient.setQueryData(['todos'], (old) => [...old, optimisticTodo])

    // Return context with the optimistic todo
    return { optimisticTodo }
  },
  onSuccess: (result, variables, context) => {
    // Replace optimistic todo in the todos list with the result
    queryClient.setQueryData(['todos'], (old) =>
      old.map((todo) =>
        todo.id === context.optimisticTodo.id ? result : todo,
      ),
    )
  },
  onError: (error, variables, context) => {
    // Remove optimistic todo from the todos list
    queryClient.setQueryData(['todos'], (old) =>
      old.filter((todo) => todo.id !== context.optimisticTodo.id),
    )
  },
  retry: 3,
})

class someComponent {
  // Start mutation in some component:
  mutation = injectMutation(() => ({ mutationKey: ['addTodo'] }))

  someMethod() {
    mutation.mutate({ title: 'title' })
  }
}

// If the mutation has been paused because the device is for example offline,
// Then the paused mutation can be dehydrated when the application quits:
const state = dehydrate(queryClient)

// The mutation can then be hydrated again when the application is started:
hydrate(queryClient, state)

// Resume the paused mutations:
queryClient.resumePausedMutations()

----------------------------------------

TITLE: Streaming with React Query and Server Components
DESCRIPTION: Shows how to implement streaming SSR with React Query by configuring query client to handle pending queries and stream data to the client.

LANGUAGE: tsx
CODE:
import { QueryClient, defaultShouldDehydrateQuery } from '@tanstack/react-query'

function makeQueryClient() {
  return new QueryClient({
    defaultOptions: {
      queries: {
        staleTime: 60 * 1000,
      },
      dehydrate: {
        shouldDehydrateQuery: (query) =>
          defaultShouldDehydrateQuery(query) ||
          query.state.status === 'pending',
        shouldRedactErrors: (error) => false
      },
    },
  })
}

----------------------------------------

TITLE: Configuring Basic Query Retries in TanStack Query
DESCRIPTION: Demonstrates how to configure retry attempts for a specific query using useQuery hook. This example shows setting a fixed number of retry attempts (10) for a failed query.

LANGUAGE: tsx
CODE:
import { useQuery } from '@tanstack/react-query'

// Make a specific query retry a certain number of times
const result = useQuery({
  queryKey: ['todos', 1],
  queryFn: fetchTodoListPage,
  retry: 10, // Will retry failed requests 10 times before displaying an error
})

----------------------------------------

TITLE: Disabling Queries on Out-of-Focus Screens in React Native with TanStack Query
DESCRIPTION: This example demonstrates how to disable queries for out-of-focus screens in React Native using TanStack Query. It uses the useIsFocused hook from React Navigation and the subscribed prop of useQuery to control query subscription based on screen focus.

LANGUAGE: tsx
CODE:
import React from 'react'
import { useIsFocused } from '@react-navigation/native'
import { useQuery } from '@tanstack/react-query'
import { Text } from 'react-native'

function MyComponent() {
  const isFocused = useIsFocused()

  const { dataUpdatedAt } = useQuery({
    queryKey: ['key'],
    queryFn: () => fetch(...),
    subscribed: isFocused,
  })

  return <Text>DataUpdatedAt: {dataUpdatedAt}</Text>
}

----------------------------------------

TITLE: Handling Multiple Mutations in TanStack Query
DESCRIPTION: Illustrates how to handle multiple mutations, showing that global callbacks are called for each mutation while local callbacks are only called for the last mutation in a series.

LANGUAGE: ts
CODE:
export class Example {
  mutation = injectMutation(() => ({
    mutationFn: addTodo,
    onSuccess: (data, variables, context) => {
      // Will be called 3 times
    },
  }))

  doMutations() {
    ;['Todo 1', 'Todo 2', 'Todo 3'].forEach((todo) => {
      this.mutation.mutate(todo, {
        onSuccess: (data, variables, context) => {
          // Will execute only once, for the last mutation (Todo 3),
          // regardless which mutation resolves first
        },
      })
    })
  }
}

----------------------------------------

TITLE: Initializing QueriesObserver in TanStack Query
DESCRIPTION: Demonstrates how to create a QueriesObserver instance to monitor multiple queries and subscribe to their results. The observer accepts a queryClient and an array of query configurations, supporting the same options as useQueries hook.

LANGUAGE: tsx
CODE:
const observer = new QueriesObserver(queryClient, [
  { queryKey: ['post', 1], queryFn: fetchPost },
  { queryKey: ['post', 2], queryFn: fetchPost },
])

const unsubscribe = observer.subscribe((result) => {
  console.log(result)
  unsubscribe()
})

----------------------------------------

TITLE: Including Variables in Query Keys for TanStack Query (TSX)
DESCRIPTION: Demonstrates the importance of including variables that the query function depends on in the query key. This ensures proper caching and automatic refetching when variables change.

LANGUAGE: tsx
CODE:
function Todos({ todoId }) {
  const result = useQuery({
    queryKey: ['todos', todoId],
    queryFn: () => fetchTodoById(todoId),
  })
}

----------------------------------------

TITLE: Setting Global Retry Delay Configuration in Vue Query Plugin
DESCRIPTION: Demonstrates how to configure global retry delay behavior through Vue Query plugin options. Implements an exponential backoff strategy for retry delays, with a maximum delay cap of 30 seconds.

LANGUAGE: ts
CODE:
import { VueQueryPlugin } from '@tanstack/vue-query'

const vueQueryPluginOptions = {
  queryClientConfig: {
    defaultOptions: {
      queries: {
        retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
      },
    },
  },
}
app.use(VueQueryPlugin, vueQueryPluginOptions)

----------------------------------------

TITLE: Implementing Dependent Queries with injectQuery in TanStack Query for Angular
DESCRIPTION: This snippet demonstrates how to create dependent queries using injectQuery in TanStack Query for Angular. It first fetches a user by email, then uses the user's ID to fetch their projects. The second query is enabled only when the user ID is available.

LANGUAGE: typescript
CODE:
// Get the user
userQuery = injectQuery(() => ({
  queryKey: ['user', email],
  queryFn: getUserByEmail,
}))

// Then get the user's projects
projectsQuery = injectQuery(() => ({
  queryKey: ['projects', this.userQuery.data()?.id],
  queryFn: getProjectsByUser,
  // The query will not execute until the user id exists
  enabled: !!this.userQuery.data()?.id,
}))

----------------------------------------

TITLE: Custom IndexedDB Persister Implementation
DESCRIPTION: Example implementation of a custom persister using IndexedDB for improved storage capabilities.

LANGUAGE: tsx
CODE:
import { get, set, del } from 'idb-keyval'
import {
  PersistedClient,
  Persister,
} from '@tanstack/react-query-persist-client'

/**
 * Creates an Indexed DB persister
 * @see https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API
 */
export function createIDBPersister(idbValidKey: IDBValidKey = 'reactQuery') {
  return {
    persistClient: async (client: PersistedClient) => {
      await set(idbValidKey, client)
    },
    restoreClient: async () => {
      return await get<PersistedClient>(idbValidKey)
    },
    removeClient: async () => {
      await del(idbValidKey)
    },
  } satisfies Persister
}

----------------------------------------

TITLE: Implementing Query Cancellation with HttpClient in Angular
DESCRIPTION: This snippet demonstrates how to use TanStack Query's cancellation feature with Angular's HttpClient. It uses the injectQuery function to create a query that fetches a post, utilizing RxJS operators to handle the AbortSignal.

LANGUAGE: typescript
CODE:
import { HttpClient } from '@angular/common/http'
import { injectQuery } from '@tanstack/angular-query-experimental'

postQuery = injectQuery(() => ({
  enabled: this.postId() > 0,
  queryKey: ['post', this.postId()],
  queryFn: async (context): Promise<Post> => {
    const abort$ = fromEvent(context.signal, 'abort')
    return lastValueFrom(this.getPost$(this.postId()).pipe(takeUntil(abort$)))
  },
}))

----------------------------------------

TITLE: Updating getQueryData and getQueryState Methods in TypeScript/JavaScript
DESCRIPTION: Changes to getQueryData and getQueryState methods to accept only queryKey as an argument.

LANGUAGE: tsx
CODE:
;-queryClient.getQueryData(queryKey, filters) + // [!code --]
  queryClient.getQueryData(queryKey) // [!code ++]

LANGUAGE: tsx
CODE:
;-queryClient.getQueryState(queryKey, filters) + // [!code --]
  queryClient.getQueryState(queryKey) // [!code ++]

----------------------------------------

TITLE: Configuring Global Window Focus Refetching in TanStack Query
DESCRIPTION: Demonstrates how to disable window focus refetching globally by configuring the QueryClient default options. This affects all queries in the application unless overridden.

LANGUAGE: tsx
CODE:
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      refetchOnWindowFocus: false, // default: true
    },
  },
})

function App() {
  return <QueryClientProvider client={queryClient}>...</QueryClientProvider>
}

----------------------------------------

TITLE: Implementing Dependent Queries in React Query
DESCRIPTION: Example showing how dependent queries can create request waterfalls when one query depends on the result of another. Demonstrates using enabled option to control query execution.

LANGUAGE: tsx
CODE:
const { data: user } = useQuery({
  queryKey: ['user', email],
  queryFn: getUserByEmail,
})

const userId = user?.id

const {
  status,
  fetchStatus,
  data: projects,
} = useQuery({
  queryKey: ['projects', userId],
  queryFn: getProjectsByUser,
  enabled: !!userId,
})

----------------------------------------

TITLE: Managing React Native App Focus State
DESCRIPTION: Shows how to handle focus state in React Native applications using the AppState module and focusManager.

LANGUAGE: tsx
CODE:
import { AppState } from 'react-native'
import { focusManager } from '@tanstack/react-query'

function onAppStateChange(status: AppStateStatus) {
  if (Platform.OS !== 'web') {
    focusManager.setFocused(status === 'active')
  }
}

useEffect(() => {
  const subscription = AppState.addEventListener('change', onAppStateChange)

  return () => subscription.remove()
}, [])

----------------------------------------

TITLE: React Query Client Persistence Setup
DESCRIPTION: Example showing how to set up query client persistence in a React application using PersistQueryClientProvider.

LANGUAGE: tsx
CODE:
import { PersistQueryClientProvider } from '@tanstack/react-query-persist-client'
import { createSyncStoragePersister } from '@tanstack/query-sync-storage-persister'

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      gcTime: 1000 * 60 * 60 * 24, // 24 hours
    },
  },
})

const persister = createSyncStoragePersister({
  storage: window.localStorage,
})

ReactDOM.createRoot(rootElement).render(
  <PersistQueryClientProvider
    client={queryClient}
    persistOptions={{ persister }}
  >
    <App />
  </PersistQueryClientProvider>,
)

----------------------------------------

TITLE: Configuring Stale Time with Initial Data in TanStack Query (TypeScript)
DESCRIPTION: Demonstrates how to set a stale time for a query with initial data, delaying refetching until after the specified time has passed and an interaction event occurs.

LANGUAGE: typescript
CODE:
// Show initialTodos immediately, but won't refetch until
// another interaction event is encountered after 1000 ms
result = injectQuery(() => ({
  queryKey: ['todos'],
  queryFn: () => fetch('/todos'),
  initialData: initialTodos,
  staleTime: 1000,
}))

----------------------------------------

TITLE: Prefetching Query Data in TanStack Query
DESCRIPTION: Demonstrates how to use prefetchQuery to cache query results ahead of time. This function prefetches todos data using a specified query key and function.

LANGUAGE: tsx
CODE:
const prefetchTodos = async () => {
  // The results of this query will be cached like a normal query
  await queryClient.prefetchQuery({
    queryKey: ['todos'],
    queryFn: fetchTodos,
  })
}

----------------------------------------

TITLE: API Definition for broadcastQueryClient Options in TanStack Query
DESCRIPTION: This code defines the interface for the options object passed to the broadcastQueryClient function. It specifies the required queryClient instance, an optional broadcastChannel name, and additional options for the BroadcastChannel API.

LANGUAGE: tsx
CODE:
interface BroadcastQueryClientOptions {
  /** The QueryClient to sync */
  queryClient: QueryClient
  /** This is the unique channel name that will be used
   * to communicate between tabs and windows */
  broadcastChannel?: string
  /** Options for the BroadcastChannel API */
  options?: BroadcastChannelOptions
}

----------------------------------------

TITLE: Installing Vue Query via Yarn
DESCRIPTION: Command to install Vue Query using Yarn package manager.

LANGUAGE: bash
CODE:
yarn add @tanstack/vue-query

----------------------------------------

TITLE: Setting Up QueryClient for Prefetching in SvelteKit Layout
DESCRIPTION: Configures a QueryClient in a SvelteKit layout load function for prefetching queries. This setup allows for server-side data fetching and passing to the client.

LANGUAGE: typescript
CODE:
import { browser } from '$app/environment'
import { QueryClient } from '@tanstack/svelte-query'

export async function load() {
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: {
        enabled: browser,
      },
    },
  })

  return { queryClient }
}

----------------------------------------

TITLE: Query Disabling with skipToken
DESCRIPTION: Demonstrates using skipToken to conditionally disable queries. This approach uses the skipToken utility instead of the enabled option to control query execution.

LANGUAGE: angular-ts
CODE:
import { skipToken, injectQuery } from '@tanstack/query-angular'

@Component({
  selector: 'todos',
  template: `
    <div>
      // üöÄ applying the filter will enable and execute the query
      <filters-form onApply="filter.set" />
      <todos-table data="query.data()" />
    </div>
  `,
})
export class TodosComponent {
  filter = signal('')

  todosQuery = injectQuery(() => ({
    queryKey: ['todos', this.filter()],
    queryFn: this.filter() ? () => fetchTodos(this.filter()) : skipToken,
  }))
}

----------------------------------------

TITLE: Todo List Implementation Using Status Enum
DESCRIPTION: Alternative implementation using the status enum instead of boolean flags to handle query states and render appropriate UI components.

LANGUAGE: tsx
CODE:
function Todos() {
  const { status, data, error } = useQuery({
    queryKey: ['todos'],
    queryFn: fetchTodoList,
  })

  if (status === 'pending') {
    return <span>Loading...</span>
  }

  if (status === 'error') {
    return <span>Error: {error.message}</span>
  }

  // also status === 'success', but "else" logic works, too
  return (
    <ul>
      {data.map((todo) => (
        <li key={todo.id}>{todo.title}</li>
      ))}
    </ul>
  )
}

----------------------------------------

TITLE: Implementing Manual Query Cancellation in TanStack Query (TSX)
DESCRIPTION: This snippet demonstrates how to manually cancel a query using TanStack Query. It shows how to use the queryClient.cancelQueries method to cancel a specific query by its queryKey.

LANGUAGE: tsx
CODE:
const query = useQuery({
  queryKey: ['todos'],
  queryFn: async ({ signal }) => {
    const resp = await fetch('/todos', { signal })
    return resp.json()
  },
})

const queryClient = useQueryClient()

return (
  <button
    onClick={(e) => {
      e.preventDefault()
      queryClient.cancelQueries({ queryKey: ['todos'] })
    }}
  >
    Cancel
  </button>
)

----------------------------------------

TITLE: Basic Initial Data Query Configuration in TSX
DESCRIPTION: Demonstrates the basic usage of initialData option in useQuery hook to prepopulate query cache with initial data.

LANGUAGE: tsx
CODE:
const result = useQuery({
  queryKey: ['todos'],
  queryFn: () => fetch('/todos'),
  initialData: initialTodos,
})

----------------------------------------

TITLE: Structured Query Keys with Parameters
DESCRIPTION: Shows how to create query keys with specific identifiers and optional parameters. Demonstrates different variations for todo items including preview modes and filtered lists.

LANGUAGE: typescript
CODE:
// An individual todo
injectQuery(() => ({queryKey: ['todo', 5], ...}))

// An individual todo in a "preview" format
injectQuery(() => ({queryKey: ['todo', 5, {preview: true}], ...}))

// A list of todos that are "done"
injectQuery(() => ({queryKey: ['todos', {type: 'done'}], ...}))

----------------------------------------

TITLE: Object-Based Query Keys with Multiple Parameters
DESCRIPTION: Illustrates how to structure query keys using objects with multiple parameters. Shows equivalent ways of organizing parameters while maintaining consistency.

LANGUAGE: typescript
CODE:
injectQuery(() => ({ queryKey: ['todos', { status, page }], ... }))
injectQuery(() => ({ queryKey: ['todos', { page, status }], ...}))
injectQuery(() => ({ queryKey: ['todos', { page, status, other: undefined }], ... }))

----------------------------------------

TITLE: Optimizing Multiple Suspense Queries in React Query
DESCRIPTION: Shows how to optimize multiple suspense queries by using useSuspenseQueries hook instead of multiple individual useSuspenseQuery calls to avoid serial execution.

LANGUAGE: tsx
CODE:
const [usersQuery, teamsQuery, projectsQuery] = useSuspenseQueries({
  queries: [
    { queryKey: ['users'], queryFn: fetchUsers },
    { queryKey: ['teams'], queryFn: fetchTeams },
    { queryKey: ['projects'], queryFn: fetchProjects },
  ],
})

----------------------------------------

TITLE: Mutation Callback Execution Order in TanStack Query
DESCRIPTION: Demonstrates the execution order of mutation callbacks, including both global callbacks defined in the mutation configuration and local callbacks provided when calling mutate.

LANGUAGE: ts
CODE:
mutation = injectMutation(() => ({
  mutationFn: addTodo,
  onSuccess: (data, variables, context) => {
    // I will fire first
  },
  onError: (error, variables, context) => {
    // I will fire first
  },
  onSettled: (data, error, variables, context) => {
    // I will fire first
  },
}))

mutation.mutate(todo, {
  onSuccess: (data, variables, context) => {
    // I will fire second!
  },
  onError: (error, variables, context) => {
    // I will fire second!
  },
  onSettled: (data, error, variables, context) => {
    // I will fire second!
  },
})

----------------------------------------

TITLE: Implementing Query Cancellation with Axios <v0.22.0 in TanStack Query (TSX)
DESCRIPTION: This snippet illustrates how to implement query cancellation with Axios versions lower than 0.22.0 in TanStack Query. It uses a CancelToken source and listens for the abort event on the signal.

LANGUAGE: tsx
CODE:
import axios from 'axios'

const query = useQuery({
  queryKey: ['todos'],
  queryFn: ({ signal }) => {
    // Create a new CancelToken source for this request
    const CancelToken = axios.CancelToken
    const source = CancelToken.source()

    const promise = axios.get('/todos', {
      // Pass the source token to your request
      cancelToken: source.token,
    })

    // Cancel the request if TanStack Query signals to abort
    signal?.addEventListener('abort', () => {
      source.cancel('Query was cancelled by TanStack Query')
    })

    return promise
  },
})

----------------------------------------

TITLE: Configuring React Query Provider with Server Components
DESCRIPTION: Sets up the initial React Query configuration with QueryClientProvider for Server Components, handling both server and browser environments.

LANGUAGE: tsx
CODE:
'use client'

import {
  isServer,
  QueryClient,
  QueryClientProvider,
} from '@tanstack/react-query'

function makeQueryClient() {
  return new QueryClient({
    defaultOptions: {
      queries: {
        staleTime: 60 * 1000,
      },
    },
  })
}

let browserQueryClient: QueryClient | undefined = undefined

function getQueryClient() {
  if (isServer) {
    return makeQueryClient()
  } else {
    if (!browserQueryClient) browserQueryClient = makeQueryClient()
    return browserQueryClient
  }
}

export default function Providers({ children }: { children: React.ReactNode }) {
  const queryClient = getQueryClient()

  return (
    <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
  )
}

----------------------------------------

TITLE: Cursor-free Infinite Query Implementation
DESCRIPTION: Implementation of infinite queries for APIs that don't return cursors, using page numbers instead.

LANGUAGE: tsx
CODE:
return useInfiniteQuery({
  queryKey: ['projects'],
  queryFn: fetchProjects,
  initialPageParam: 0,
  getNextPageParam: (lastPage, allPages, lastPageParam) => {
    if (lastPage.length === 0) {
      return undefined
    }
    return lastPageParam + 1
  },
  getPreviousPageParam: (firstPage, allPages, firstPageParam) => {
    if (firstPageParam <= 1) {
      return undefined
    }
    return firstPageParam - 1
  },
})

----------------------------------------

TITLE: Implementing Custom Window Focus Event Handler
DESCRIPTION: Example of implementing a custom window focus event handler using focusManager.setEventListener. This code shows the default implementation that listens to visibilitychange events.

LANGUAGE: tsx
CODE:
focusManager.setEventListener((handleFocus) => {
  // Listen to visibilitychange
  if (typeof window !== 'undefined' && window.addEventListener) {
    const visibilitychangeHandler = () => {
      handleFocus(document.visibilityState === 'visible')
    }
    window.addEventListener('visibilitychange', visibilitychangeHandler, false)
    return () => {
      // Be sure to unsubscribe if a new handler is set
      window.removeEventListener('visibilitychange', visibilitychangeHandler)
    }
  }
})

----------------------------------------

TITLE: Installing TanStack Solid Query via PNPM
DESCRIPTION: Command to install TanStack Solid Query using PNPM package manager.

LANGUAGE: bash
CODE:
pnpm add @tanstack/solid-query

----------------------------------------

TITLE: Prefetching in Event Handlers with TanStack Query
DESCRIPTION: Demonstrates prefetching data on user interaction events like mouse enter or focus. This example uses queryClient.prefetchQuery to start prefetching details data when the user interacts with a button.

LANGUAGE: tsx
CODE:
function ShowDetailsButton() {
  const queryClient = useQueryClient()

  const prefetch = () => {
    queryClient.prefetchQuery({
      queryKey: ['details'],
      queryFn: getDetailsData,
      // Prefetch only fires when data is older than the staleTime,
      // so in a case like this you definitely want to set one
      staleTime: 60000,
    })
  }

  return (
    <button onMouseEnter={prefetch} onFocus={prefetch} onClick={...}>
      Show Details
    </button>
  )
}

----------------------------------------

TITLE: Nested Component Query Pattern in React Query
DESCRIPTION: Demonstrates a nested component waterfall pattern where parent and child components both contain queries, potentially creating performance bottlenecks.

LANGUAGE: tsx
CODE:
function Article({ id }) {
  const { data: articleData, isPending } = useQuery({
    queryKey: ['article', id],
    queryFn: getArticleById,
  })

  if (isPending) {
    return 'Loading article...'
  }

  return (
    <>
      <ArticleHeader articleData={articleData} />
      <ArticleBody articleData={articleData} />
      <Comments id={id} />
    </>
  )
}

function Comments({ id }) {
  const { data, isPending } = useQuery({
    queryKey: ['article-comments', id],
    queryFn: getArticleCommentsById,
  })

  ...
}

----------------------------------------

TITLE: Accessing Latest Mutation Data by mutationKey in React Query
DESCRIPTION: This snippet illustrates how to access the most recent mutation data using useMutationState. It explains that each mutate call adds a new entry to the mutation cache, and shows how to retrieve the latest data by selecting the last item in the returned array.

LANGUAGE: tsx
CODE:
import { useMutation, useMutationState } from '@tanstack/react-query'

const mutationKey = ['posts']

// Some mutation that we want to get the state for
const mutation = useMutation({
  mutationKey,
  mutationFn: (newPost) => {
    return axios.post('/posts', newPost)
  },
})

const data = useMutationState({
  // this mutation key needs to match the mutation key of the given mutation (see above)
  filters: { mutationKey },
  select: (mutation) => mutation.state.data,
})

// Latest mutation data
const latest = data[data.length - 1]

----------------------------------------

TITLE: Testing React Query Hook (React 18)
DESCRIPTION: Modified version of the hook test for React 18 using @testing-library/react.

LANGUAGE: tsx
CODE:
import { renderHook, waitFor } from "@testing-library/react";

...

const { result } = renderHook(() => useCustomHook(), { wrapper });

await waitFor(() => expect(result.current.isSuccess).toBe(true));

----------------------------------------

TITLE: Reactive Getter Query Implementation
DESCRIPTION: Final implementation supporting refs, plain values, and reactive getters using MaybeRefOrGetter type.

LANGUAGE: typescript
CODE:
export function useUserProjects(userId: MaybeRefOrGetter<string>) {
  return useQuery(
    queryKey: ['userProjects', userId],
    queryFn: () => api.fetchUserProjects(toValue(userId)),
    enabled: () => userId.value === activeUserId.value,
  );
}

----------------------------------------

TITLE: Type Inference with Custom Query Function in Vue Query
DESCRIPTION: Illustrates type inference when using a custom query function that returns a Promise of a specific type (Group[]). The inferred type for 'data' reflects the return type of the query function.

LANGUAGE: tsx
CODE:
const fetchGroups = (): Promise<Group[]> =>
  axios.get('/groups').then((response) => response.data)

const { data } = useQuery({ queryKey: ['groups'], queryFn: fetchGroups })
//      ^? const data: Ref<Group[]> | Ref<undefined>

----------------------------------------

TITLE: Implementing Custom Pagination Logic in TanStack Query
DESCRIPTION: This example shows how to implement custom pagination logic for both next and previous pages in an infinite query using TanStack Query. It includes checks for the first and last pages.

LANGUAGE: ts
CODE:
injectInfiniteQuery(() => ({
  queryKey: ['projects'],
  queryFn: fetchProjects,
  initialPageParam: 0,
  getNextPageParam: (lastPage, allPages, lastPageParam) => {
    if (lastPage.length === 0) {
      return undefined
    }
    return lastPageParam + 1
  },
  getPreviousPageParam: (firstPage, allPages, firstPageParam) => {
    if (firstPageParam <= 1) {
      return undefined
    }
    return firstPageParam - 1
  },
}))

----------------------------------------

TITLE: Installing React Query Devtools Package
DESCRIPTION: Various package manager commands to install the React Query Devtools package as a development dependency.

LANGUAGE: bash
CODE:
npm i @tanstack/react-query-devtools

LANGUAGE: bash
CODE:
pnpm add @tanstack/react-query-devtools

LANGUAGE: bash
CODE:
yarn add @tanstack/react-query-devtools

LANGUAGE: bash
CODE:
bun add @tanstack/react-query-devtools

----------------------------------------

TITLE: Fetching Data with Error Handling in TanStack Query using TypeScript
DESCRIPTION: This example shows how to fetch data from an API endpoint within a query function, including error handling for network responses.

LANGUAGE: typescript
CODE:
todos = injectQuery(() => ({
  queryKey: ['todos', todoId()],
  queryFn: async () => {
    const response = await fetch('/todos/' + todoId)
    if (!response.ok) {
      throw new Error('Network response was not ok')
    }
    return response.json()
  },
}))

----------------------------------------

TITLE: Configuring Vue Query Plugin with QueryClientConfig in TypeScript
DESCRIPTION: This snippet shows how to configure the VueQueryPlugin using a QueryClientConfig object. It sets default options for queries, such as staleTime.

LANGUAGE: tsx
CODE:
const vueQueryPluginOptions: VueQueryPluginOptions = {
  queryClientConfig: {
    defaultOptions: { queries: { staleTime: 3600 } },
  },
}
app.use(VueQueryPlugin, vueQueryPluginOptions)

----------------------------------------

TITLE: Configuring QueryClient with No Retries
DESCRIPTION: Configuration to disable retry behavior in React Query tests to prevent timeouts.

LANGUAGE: tsx
CODE:
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      // ‚úÖ turns retries off
      retry: false,
    },
  },
})
const wrapper = ({ children }) => (
  <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
)

----------------------------------------

TITLE: Implementing Custom Serialization for Sync Storage Persister
DESCRIPTION: Example of using custom serialization and deserialization functions with the sync storage persister to compress data using lz-string library.

LANGUAGE: tsx
CODE:
import { QueryClient } from '@tanstack/react-query'
import { persistQueryClient } from '@tanstack/react-query-persist-client'
import { createSyncStoragePersister } from '@tanstack/query-sync-storage-persister'

import { compress, decompress } from 'lz-string'

const queryClient = new QueryClient({
  defaultOptions: { queries: { staleTime: Infinity } },
})

persistQueryClient({
  queryClient: queryClient,
  persister: createSyncStoragePersister({
    storage: window.localStorage,
    serialize: (data) => compress(JSON.stringify(data)),
    deserialize: (data) => JSON.parse(decompress(data)),
  }),
  maxAge: Infinity,
})

----------------------------------------

TITLE: Using Prefetched Query Data in Svelte Component
DESCRIPTION: Shows how to use prefetched query data in a Svelte component. The createQuery function uses the same queryKey and queryFn as the prefetchQuery call, allowing it to access the cached data.

LANGUAGE: svelte
CODE:
<script lang="ts">
  import { createQuery } from '@tanstack/svelte-query'

  // This data is cached by prefetchQuery in +page.ts so no fetch actually happens here
  const query = createQuery({
    queryKey: ['posts'],
    queryFn: async () => (await fetch('/api/posts')).json(),
  })
</script>

----------------------------------------

TITLE: Query Configuration with initialDataUpdatedAt in TSX
DESCRIPTION: Shows how to use initialDataUpdatedAt to specify when the initial data was last updated.

LANGUAGE: tsx
CODE:
const result = useQuery({
  queryKey: ['todos'],
  queryFn: () => fetch('/todos'),
  initialData: initialTodos,
  staleTime: 60 * 1000, // 1 minute
  initialDataUpdatedAt: initialTodosUpdatedTimestamp, // eg. 1608412420052
})

----------------------------------------

TITLE: Implementing Infinite Scroll with TanStack Query in Angular
DESCRIPTION: This snippet shows how to implement infinite scroll functionality using TanStack Query in an Angular component. It uses an event from a child component to trigger fetching the next page.

LANGUAGE: angular-ts
CODE:
@Component({
  template: ` <list-component (endReached)="fetchNextPage()" /> `,
})
export class Example {
  query = injectInfiniteQuery(() => ({
    queryKey: ['projects'],
    queryFn: async ({ pageParam }) => {
      return lastValueFrom(this.projectsService.getProjects(pageParam))
    },
  }))

  fetchNextPage() {
    // Do nothing if already fetching
    if (this.query.isFetching()) return
    this.query.fetchNextPage()
  }
}

----------------------------------------

TITLE: Updating QueryClient Method Signatures in TypeScript/JavaScript
DESCRIPTION: Changes to function signatures for various QueryClient methods, including isFetching, ensureQueryData, getQueriesData, and others. All now use a single object parameter.

LANGUAGE: tsx
CODE:
;-queryClient.isFetching(key, filters) + // [!code --]
  queryClient.isFetching({ queryKey, ...filters }) - // [!code ++]
  queryClient.ensureQueryData(key, filters) + // [!code --]
  queryClient.ensureQueryData({ queryKey, ...filters }) - // [!code ++]
  queryClient.getQueriesData(key, filters) + // [!code --]
  queryClient.getQueriesData({ queryKey, ...filters }) - // [!code ++]
  queryClient.setQueriesData(key, updater, filters, options) + // [!code --]
  queryClient.setQueriesData({ queryKey, ...filters }, updater, options) - // [!code ++]
  queryClient.removeQueries(key, filters) + // [!code --]
  queryClient.removeQueries({ queryKey, ...filters }) - // [!code ++]
  queryClient.resetQueries(key, filters, options) + // [!code --]
  queryClient.resetQueries({ queryKey, ...filters }, options) - // [!code ++]
  queryClient.cancelQueries(key, filters, options) + // [!code --]
  queryClient.cancelQueries({ queryKey, ...filters }, options) - // [!code ++]
  queryClient.invalidateQueries(key, filters, options) + // [!code --]
  queryClient.invalidateQueries({ queryKey, ...filters }, options) - // [!code ++]
  queryClient.refetchQueries(key, filters, options) + // [!code --]
  queryClient.refetchQueries({ queryKey, ...filters }, options) - // [!code ++]
  queryClient.fetchQuery(key, fn, options) + // [!code --]
  queryClient.fetchQuery({ queryKey, queryFn, ...options }) - // [!code ++]
  queryClient.prefetchQuery(key, fn, options) + // [!code --]
  queryClient.prefetchQuery({ queryKey, queryFn, ...options }) - // [!code ++]
  queryClient.fetchInfiniteQuery(key, fn, options) + // [!code --]
  queryClient.fetchInfiniteQuery({ queryKey, queryFn, ...options }) - // [!code ++]
  queryClient.prefetchInfiniteQuery(key, fn, options) + // [!code --]
  queryClient.prefetchInfiniteQuery({ queryKey, queryFn, ...options }) // [!code ++]

----------------------------------------

TITLE: Configuring QueryClient with experimental_createPersister
DESCRIPTION: Example of creating a QueryClient with default options using experimental_createPersister. It sets up persistence with localStorage and configures garbage collection time and maximum age for persisted data.

LANGUAGE: tsx
CODE:
import { QueryClient } from '@tanstack/vue-query'
import { experimental_createPersister } from '@tanstack/query-persist-client-core'

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      gcTime: 1000 * 30, // 30 seconds
      persister: experimental_createPersister({
        storage: localStorage,
        maxAge: 1000 * 60 * 60 * 12, // 12 hours
      }),
    },
  },
})

----------------------------------------

TITLE: Immediate Refetching with Initial Data in TanStack Query (TypeScript)
DESCRIPTION: Shows how to set initial data for a query while also triggering an immediate refetch when the component or service is initialized.

LANGUAGE: typescript
CODE:
// Will show initialTodos immediately, but also immediately refetch todos
// when an instance of the component or service is created
result = injectQuery(() => ({
  queryKey: ['todos'],
  queryFn: () => fetch('/todos'),
  initialData: initialTodos,
}))

----------------------------------------

TITLE: Implementing Lazy Queries in TanStack Query (TSX)
DESCRIPTION: This snippet shows how to create a lazy query that only executes when a filter is applied. The query is enabled conditionally based on the presence of a filter value.

LANGUAGE: tsx
CODE:
function Todos() {
  const [filter, setFilter] = React.useState('')

  const { data } = useQuery({
    queryKey: ['todos', filter],
    queryFn: () => fetchTodos(filter),
    // ‚¨áÔ∏è disabled as long as the filter is empty
    enabled: !!filter,
  })

  return (
    <div>
      // üöÄ applying the filter will enable and execute the query
      <FiltersForm onApply={setFilter} />
      {data && <TodosTable data={data} />}
    </div>
  )
}

----------------------------------------

TITLE: Defining CreateBaseQueryResult Type Alias in TypeScript
DESCRIPTION: This code defines a complex type alias named CreateBaseQueryResult with three generic parameters. It combines BaseQueryNarrowing and MapToSignals types, using OmitKeyof to exclude certain properties.

LANGUAGE: typescript
CODE:
type CreateBaseQueryResult<TData, TError, TState>: BaseQueryNarrowing<TData, TError> & MapToSignals<OmitKeyof<TState, keyof BaseQueryNarrowing, "safely">>;

----------------------------------------

TITLE: Renaming cacheTime to gcTime in TypeScript/JavaScript
DESCRIPTION: The cacheTime option has been renamed to gcTime to better reflect its purpose of garbage collection time.

LANGUAGE: tsx
CODE:
const MINUTE = 1000 * 60;

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
-      cacheTime: 10 * MINUTE, // [!code --]
+      gcTime: 10 * MINUTE, // [!code ++]
    },
  },
})

----------------------------------------

TITLE: Angular Component with Query Status Switch
DESCRIPTION: Demonstrates an alternative approach to handling query states in an Angular component using a switch statement on the query status.

LANGUAGE: angular-ts
CODE:
@Component({
  selector: 'todos',
  standalone: true,
  template: `
    @switch (todos.status()) {
      @case ('pending') {
        <span>Loading...</span>
      }
      @case ('error') {
        <span>Error: {{ todos.error()?.message }}</span>
      }
      <!-- also status === 'success', but "else" logic works, too -->
      @default {
        <ul>
          @for (todo of todos.data(); track todo.id) {
            <li>{{ todo.title }}</li>
          } @empty {
            <li>No todos found</li>
          }
        </ul>
      }
    }
  `,
})
class TodosComponent {}

----------------------------------------

TITLE: Creating a Custom Hook for Refreshing Queries on Screen Focus in React Native
DESCRIPTION: This code defines a custom hook useRefreshOnFocus that refreshes a query when a React Native screen comes back into focus. It uses the useFocusEffect hook from React Navigation and skips the initial focus to avoid unnecessary refetches.

LANGUAGE: tsx
CODE:
import React from 'react'
import { useFocusEffect } from '@react-navigation/native'

export function useRefreshOnFocus<T>(refetch: () => Promise<T>) {
  const firstTimeRef = React.useRef(true)

  useFocusEffect(
    React.useCallback(() => {
      if (firstTimeRef.current) {
        firstTimeRef.current = false
        return
      }

      refetch()
    }, [refetch]),
  )
}

----------------------------------------

TITLE: Initial Data from Cache in TSX
DESCRIPTION: Shows how to provide initial data from cached results of another query.

LANGUAGE: tsx
CODE:
const result = useQuery({
  queryKey: ['todo', todoId],
  queryFn: () => fetch('/todos'),
  initialData: () => {
    return queryClient.getQueryData(['todos'])?.find((d) => d.id === todoId)
  },
})

----------------------------------------

TITLE: Using createSyncStoragePersister with TanStack Query
DESCRIPTION: Example of how to create and use a sync storage persister with TanStack Query. It demonstrates setting up a QueryClient and persisting it using localStorage.

LANGUAGE: tsx
CODE:
import { persistQueryClient } from '@tanstack/react-query-persist-client'
import { createSyncStoragePersister } from '@tanstack/query-sync-storage-persister'

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      gcTime: 1000 * 60 * 60 * 24, // 24 hours
    },
  },
})

const localStoragePersister = createSyncStoragePersister({
  storage: window.localStorage,
})
// const sessionStoragePersister = createSyncStoragePersister({ storage: window.sessionStorage })

persistQueryClient({
  queryClient,
  persister: localStoragePersister,
})

----------------------------------------

TITLE: Vue Query with Status-Based State Management
DESCRIPTION: Alternative implementation using the status property for state management. Shows how to handle different query states using explicit status checks rather than boolean flags.

LANGUAGE: vue
CODE:
<script setup>
import { useQuery } from '@tanstack/vue-query'

const { status, data, error } = useQuery({
  queryKey: ['todos'],
  queryFn: fetchTodoList,
})
</script>

<template>
  <span v-if="status === 'pending'">Loading...</span>
  <span v-else-if="status === 'error'">Error: {{ error.message }}</span>
  <!-- also status === 'success', but "else" logic works, too -->
  <ul v-else-if="data">
    <li v-for="todo in data" :key="todo.id">{{ todo.title }}</li>
  </ul>
</template>

----------------------------------------

TITLE: Updating Infinite Query Usage in TypeScript/JavaScript
DESCRIPTION: Changes to infinite query usage, including the addition of initialPageParam and removal of manual mode.

LANGUAGE: tsx
CODE:
useInfiniteQuery({
   queryKey,
-  queryFn: ({ pageParam = 0 }) => fetchSomething(pageParam), // [!code --]
+  queryFn: ({ pageParam }) => fetchSomething(pageParam), // [!code ++]
+  initialPageParam: 0, // [!code ++]
   getNextPageParam: (lastPage) => lastPage.next,
})

----------------------------------------

TITLE: Defining QueriesOptions Type Alias in TypeScript for tanstack-query
DESCRIPTION: This snippet defines a complex type alias QueriesOptions that uses conditional types and recursive type definitions to handle query options. It's designed to work with different depths of nested options and various types of query observers.

LANGUAGE: typescript
CODE:
type QueriesOptions<T, TResult, TDepth>: TDepth["length"] extends MAXIMUM_DEPTH ? QueryObserverOptionsForCreateQueries[] : T extends [] ? [] : T extends [infer Head] ? [...TResult, GetOptions<Head>] : T extends [infer Head, ...(infer Tail)] ? QueriesOptions<[...Tail], [...TResult, GetOptions<Head>], [...TDepth, 1]> : ReadonlyArray<unknown> extends T ? T : T extends QueryObserverOptionsForCreateQueries<infer TQueryFnData, infer TError, infer TData, infer TQueryKey>[] ? QueryObserverOptionsForCreateQueries<TQueryFnData, TError, TData, TQueryKey>[] : QueryObserverOptionsForCreateQueries[];

----------------------------------------

TITLE: Type Narrowing with Status Checks
DESCRIPTION: Shows how to use TypeScript's discriminated union types with React Query's status flags for type narrowing.

LANGUAGE: tsx
CODE:
const { data, isSuccess } = useQuery({
  queryKey: ['test'],
  queryFn: () => Promise.resolve(5),
})

if (isSuccess) {
  data
  //  ^? const data: number
}

----------------------------------------

TITLE: Subscribing to MutationCache Events
DESCRIPTION: Shows how to subscribe to mutation cache events using a callback function. The subscription provides updates about mutation state changes, additions, and removals.

LANGUAGE: tsx
CODE:
const callback = (event) => {
  console.log(event.type, event.mutation)
}

const unsubscribe = mutationCache.subscribe(callback)

----------------------------------------

TITLE: Initial Data Function Implementation in TSX
DESCRIPTION: Demonstrates using a function for initialData to optimize performance for expensive data access operations.

LANGUAGE: tsx
CODE:
const result = useQuery({
  queryKey: ['todos'],
  queryFn: () => fetch('/todos'),
  initialData: () => getExpensiveTodos(),
})

----------------------------------------

TITLE: Installing React Query via NPM
DESCRIPTION: Commands for installing React Query using different package managers including npm, pnpm, yarn, and bun.

LANGUAGE: bash
CODE:
npm i @tanstack/react-query

LANGUAGE: bash
CODE:
pnpm add @tanstack/react-query

LANGUAGE: bash
CODE:
yarn add @tanstack/react-query

LANGUAGE: bash
CODE:
bun add @tanstack/react-query

----------------------------------------

TITLE: Implementing Query Cancellation with Fetch API in TypeScript
DESCRIPTION: This example shows how to use TanStack Query's cancellation feature with the Fetch API. It demonstrates passing the AbortSignal to multiple fetch calls within a single query function, allowing for cancellation of all related requests.

LANGUAGE: typescript
CODE:
query = injectQuery(() => ({
  queryKey: ['todos'],
  queryFn: async ({ signal }) => {
    const todosResponse = await fetch('/todos', {
      // Pass the signal to one fetch
      signal,
    })
    const todos = await todosResponse.json()

    const todoDetails = todos.map(async ({ details }) => {
      const response = await fetch(details, {
        // Or pass it to several
        signal,
      })
      return response.json()
    })

    return Promise.all(todoDetails)
  },
}))

----------------------------------------

TITLE: Reactive Query Usage Example
DESCRIPTION: Example showing how the non-reactive implementation fails to update when the userId changes.

LANGUAGE: typescript
CODE:
// Reactive user ID ref.
const userId = ref('1')
// Fetches the user 1's projects.
const { data: projects } = useUserProjects(userId.value)

const onChangeUser = (newUserId: string) => {
  // Edits the userId, but the query will not re-fetch.
  userId.value = newUserId
}

----------------------------------------

TITLE: Updating Query Function Signatures in TypeScript/JavaScript
DESCRIPTION: Changes to function signatures for useQuery, useInfiniteQuery, useMutation, and other query methods. All now use a single object parameter instead of multiple arguments.

LANGUAGE: tsx
CODE:
;-useQuery(key, fn, options) + // [!code --]
  useQuery({ queryKey, queryFn, ...options }) - // [!code ++]
  useInfiniteQuery(key, fn, options) + // [!code --]
  useInfiniteQuery({ queryKey, queryFn, ...options }) - // [!code ++]
  useMutation(fn, options) + // [!code --]
  useMutation({ mutationFn, ...options }) - // [!code ++]
  useIsFetching(key, filters) + // [!code --]
  useIsFetching({ queryKey, ...filters }) - // [!code ++]
  useIsMutating(key, filters) + // [!code --]
  useIsMutating({ mutationKey, ...filters }) // [!code ++]

----------------------------------------

TITLE: Setting Up QueryClientProvider
DESCRIPTION: Wraps application with QueryClientProvider to provide query client context.

LANGUAGE: tsx
CODE:
import { QueryClient, QueryClientProvider } from 'react-query'

const queryClient = new QueryClient()

function App() {
  return <QueryClientProvider client={queryClient}>...</QueryClientProvider>
}

----------------------------------------

TITLE: Default Persister Options
DESCRIPTION: Default configuration options for the experimental_createPersister utility.

LANGUAGE: tsx
CODE:
{
  prefix = 'tanstack-query',
  maxAge = 1000 * 60 * 60 * 24,
  serialize = JSON.stringify,
  deserialize = JSON.parse,
}

----------------------------------------

TITLE: Subscribing to QueryCache Events in TanStack Query
DESCRIPTION: Demonstrates how to subscribe to query cache events and handle updates, with an unsubscribe function for cleanup.

LANGUAGE: tsx
CODE:
const callback = (event) => {
  console.log(event.type, event.query)
}

const unsubscribe = queryCache.subscribe(callback)

----------------------------------------

TITLE: Manual Query Priming in TanStack Query
DESCRIPTION: Shows how to manually prime a query's cache with synchronously available data. This example uses the setQueryData method to directly add or update a query's cached result.

LANGUAGE: tsx
CODE:
queryClient.setQueryData(['todos'], todos)

----------------------------------------

TITLE: Using Infinite Queries in React Query v3
DESCRIPTION: Demonstrates implementation of bi-directional infinite queries with pagination support.

LANGUAGE: tsx
CODE:
const {
  data,
  fetchNextPage,
  fetchPreviousPage,
  hasNextPage,
  hasPreviousPage,
  isFetchingNextPage,
  isFetchingPreviousPage,
} = useInfiniteQuery(
  'projects',
  ({ pageParam = 0 }) => fetchProjects(pageParam),
  {
    getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
    getPreviousPageParam: (firstPage, pages) => firstPage.prevCursor,
  }
)

----------------------------------------

TITLE: Accessing QueryClient with useQueryClient Hook in React
DESCRIPTION: Demonstrates how to use the useQueryClient hook to access the current QueryClient instance. The hook optionally accepts a custom QueryClient parameter, otherwise it uses the nearest QueryClient from React context.

LANGUAGE: tsx
CODE:
import { useQueryClient } from '@tanstack/react-query'

const queryClient = useQueryClient(queryClient?: QueryClient)

----------------------------------------

TITLE: Basic Query Injection in Angular Service/Component
DESCRIPTION: Demonstrates basic usage of injectQuery to fetch repository data from GitHub API. Shows how to create a simple query with a static queryKey and HTTP request.

LANGUAGE: typescript
CODE:
class ServiceOrComponent {
  query = injectQuery(() => ({
    queryKey: ['repoData'],
    queryFn: () =>
      this.#http.get<Response>('https://api.github.com/repos/tanstack/query'),
  }))
}

----------------------------------------

TITLE: Basic Type Inference in Solid Query TypeScript
DESCRIPTION: Demonstrates how Solid Query automatically infers types from the queryFn return value. The query's data property is correctly typed as number | undefined.

LANGUAGE: tsx
CODE:
import { createQuery } from '@tanstack/solid-query'

const query = createQuery(() => ({
  queryKey: ['number'],
  queryFn: () => Promise.resolve(5),
}))

query.data
//    ^? (property) data: number | undefined

----------------------------------------

TITLE: Running TypeScript Codemod
DESCRIPTION: Command to run the codemod for .ts/.tsx files to update imports

LANGUAGE: bash
CODE:
npx jscodeshift ./path/to/src/ \
  --extensions=ts,tsx \
  --parser=tsx \
  --transform=./node_modules/@tanstack/react-query/codemods/v4/replace-import-specifier.js

----------------------------------------

TITLE: Injecting Mutation Count Signal in Angular Query
DESCRIPTION: Function that injects a signal tracking the number of currently fetching mutations. Takes optional mutation filters and an Angular injector as parameters. Returns a signal containing the count of active mutations. Useful for implementing application-wide loading indicators.

LANGUAGE: typescript
CODE:
function injectIsMutating(filters?, injector?): Signal<number>

----------------------------------------

TITLE: Implementing Vue Query Devtools Component
DESCRIPTION: Example of implementing the VueQueryDevtools component in a Vue 3 application. The component should be placed as high as possible in the component tree for optimal functionality.

LANGUAGE: vue
CODE:
<script setup>
import { VueQueryDevtools } from '@tanstack/vue-query-devtools'
</script>

<template>
  <h1>The app!</h1>
  <VueQueryDevtools />
</template>

----------------------------------------

TITLE: Initializing and Caching Query in TanStack Query (JavaScript)
DESCRIPTION: This snippet demonstrates how to initialize a query using injectQuery, fetch data, and cache it. It shows the lifecycle of query instances, including cache hits, background refetching, and garbage collection.

LANGUAGE: javascript
CODE:
injectQuery(() => ({ queryKey: ['todos'], queryFn: fetchTodos }))

----------------------------------------

TITLE: Configuring Online Status Management in React Native with TanStack Query
DESCRIPTION: This snippet demonstrates how to set up online status management for TanStack Query in a React Native app using the @react-native-community/netinfo package. It configures the onlineManager to update the online status based on network connectivity changes.

LANGUAGE: tsx
CODE:
import NetInfo from '@react-native-community/netinfo'
import { onlineManager } from '@tanstack/react-query'

onlineManager.setEventListener((setOnline) => {
  return NetInfo.addEventListener((state) => {
    setOnline(!!state.isConnected)
  })
})

----------------------------------------

TITLE: Configuring Global Retry Options for TanStack Query in Angular
DESCRIPTION: This example demonstrates how to set up global retry options for all queries using QueryClient. It configures an exponential backoff strategy for retry delays, capped at 30 seconds.

LANGUAGE: typescript
CODE:
import {
  QueryCache,
  QueryClient,
  QueryClientProvider,
} from '@tanstack/angular-query-experimental'

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      retryDelay: (attemptIndex) => Math.min(1000 * 2 ** attemptIndex, 30000),
    },
  },
})

bootstrapApplication(AppComponent, {
  providers: [provideTanStackQuery(queryClient)],
})

----------------------------------------

TITLE: Mutation State Management
DESCRIPTION: Setup for managing mutation state with mutation keys and accessing variables across components.

LANGUAGE: typescript
CODE:
// somewhere in your app
addTodo = injectMutation(() => ({
  mutationFn: (newTodo: string) => axios.post('/api/data', { text: newTodo }),
  onSettled: () => queryClient.invalidateQueries({ queryKey: ['todos'] }),
  mutationKey: ['addTodo'],
}))

// access variables somewhere else

mutationState = injectMutationState<string>(() => ({
  filters: { mutationKey: ['addTodo'], status: 'pending' },
  select: (mutation) => mutation.state.variables,
}))

----------------------------------------

TITLE: Type Narrowing with Success Flag in Vue Query
DESCRIPTION: Demonstrates type narrowing using the 'isSuccess' flag from Vue Query. When 'isSuccess' is true, the 'data' type is narrowed to the resolved value type (number in this case).

LANGUAGE: tsx
CODE:
const { data, isSuccess } = reactive(
  useQuery({
    queryKey: ['test'],
    queryFn: () => Promise.resolve(5),
  }),
)

if (isSuccess) {
  data
  // ^? const data: number
}

----------------------------------------

TITLE: Importing React Query via CDN
DESCRIPTION: HTML script tag for importing React Query and its dependencies via ESM-compatible CDN (ESM.sh) for use without a module bundler.

LANGUAGE: html
CODE:
<script type="module">
  import React from 'https://esm.sh/react@18.2.0'
  import ReactDOM from 'https://esm.sh/react-dom@18.2.0'
  import { QueryClient } from 'https://esm.sh/@tanstack/react-query'
</script>

----------------------------------------

TITLE: Implementing Defined Infinite Query in Angular with TanStack Query
DESCRIPTION: Function signature for injecting an infinite query that guarantees defined return data. Used when the query will always return valid data and not undefined.

LANGUAGE: typescript
CODE:
function injectInfiniteQuery<
  TQueryFnData,
  TError,
  TData,
  TQueryKey,
  TPageParam,
>(optionsFn, injector?): DefinedCreateInfiniteQueryResult<TData, TError>

----------------------------------------

TITLE: Installing Vue Query via PNPM
DESCRIPTION: Command to install Vue Query using PNPM package manager.

LANGUAGE: bash
CODE:
pnpm add @tanstack/vue-query

----------------------------------------

TITLE: Using Query Cache for Placeholder Data in TanStack Query (Angular/TypeScript)
DESCRIPTION: This snippet demonstrates how to use the query cache to provide placeholder data in an Angular component using TanStack Query. It retrieves a preview version of a blog post from a previous query to use as placeholder data.

LANGUAGE: typescript
CODE:
export class BlogPostComponent {
  // Until Angular supports signal-based inputs, we have to set a signal
  @Input({ required: true, alias: 'postId' })
  set _postId(value: number) {
    this.postId.set(value)
  }
  postId = signal(0)
  queryClient = inject(QueryClient)

  result = injectQuery(() => ({
    queryKey: ['blogPost', this.postId()],
    queryFn: () => fetch(`/blogPosts/${this.postId()}`),
    placeholderData: () => {
      // Use the smaller/preview version of the blogPost from the 'blogPosts'
      // query as the placeholder data for this blogPost query
      return queryClient
        .getQueryData(['blogPosts'])
        ?.find((d) => d.id === this.postId())
    },
  }))
}

----------------------------------------

TITLE: Initializing Vue Query Plugin
DESCRIPTION: Code snippet showing how to initialize Vue Query by using the VueQueryPlugin in a Vue application.

LANGUAGE: tsx
CODE:
import { VueQueryPlugin } from '@tanstack/vue-query'

app.use(VueQueryPlugin)

----------------------------------------

TITLE: Setting Initial Data and Update Time from Another Query in TanStack Query (TypeScript)
DESCRIPTION: Demonstrates how to set both initial data and its update time for a single todo query by deriving them from an existing todos query.

LANGUAGE: typescript
CODE:
result = injectQuery(() => ({
  queryKey: ['todos', this.todoId()],
  queryFn: () => fetch(`/todos/${this.todoId()}`),
  initialData: () =>
    queryClient.getQueryData(['todos'])?.find((d) => d.id === this.todoId()),
  initialDataUpdatedAt: () =>
    queryClient.getQueryState(['todos'])?.dataUpdatedAt,
}))

----------------------------------------

TITLE: Setting Initial Query Data in TanStack Query (TypeScript)
DESCRIPTION: Demonstrates how to set initial data for a query using the injectQuery function. The query fetches todos and uses initialTodos as the initial data.

LANGUAGE: typescript
CODE:
result = injectQuery(() => ({
  queryKey: ['todos'],
  queryFn: () => fetch('/todos'),
  initialData: initialTodos,
}))

----------------------------------------

TITLE: Internal Handling of Custom QueryClient Key in TypeScript
DESCRIPTION: This example shows how Vue Query internally handles the custom QueryClient key by combining it with the default key. This is handled automatically and users don't need to worry about it.

LANGUAGE: tsx
CODE:
const vueQueryPluginOptions: VueQueryPluginOptions = {
  queryClientKey: 'Foo',
}
app.use(VueQueryPlugin, vueQueryPluginOptions) // -> VUE_QUERY_CLIENT:Foo

----------------------------------------

TITLE: Manually Setting Online State - TSX
DESCRIPTION: Examples of manually setting the online/offline state using the OnlineManager's setOnline method.

LANGUAGE: tsx
CODE:
import { onlineManager } from '@tanstack/react-query'

// Set to online
onlineManager.setOnline(true)

// Set to offline
onlineManager.setOnline(false)

----------------------------------------

TITLE: Using Vue Query with Script Setup Syntax
DESCRIPTION: Example of using Vue Query's useQuery hook within a Vue component using <script setup> syntax. This demonstrates how to fetch data and access query states.

LANGUAGE: vue
CODE:
<script setup>
import { useQuery } from '@tanstack/vue-query'

const { isPending, isFetching, isError, data, error } = useQuery({
  queryKey: ['todos'],
  queryFn: getTodos,
})
</script>

<template>...</template>

----------------------------------------

TITLE: Testing React Query Hook (React 17)
DESCRIPTION: Example of testing a custom React Query hook using @testing-library/react-hooks in React 17.

LANGUAGE: tsx
CODE:
const queryClient = new QueryClient()
const wrapper = ({ children }) => (
  <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
)

const { result, waitFor } = renderHook(() => useCustomHook(), { wrapper })

await waitFor(() => result.current.isSuccess)

expect(result.current.data).toEqual('Hello')

----------------------------------------

TITLE: Checking Current Focus State in TanStack Query
DESCRIPTION: Demonstrates how to check the current focus state using the isFocused method.

LANGUAGE: tsx
CODE:
const isFocused = focusManager.isFocused()

----------------------------------------

TITLE: Basic Todo Mutation Implementation in Vue
DESCRIPTION: Demonstrates basic mutation usage with TanStack Query in Vue, including loading, error, and success states for a todo creation operation. Uses the useMutation hook to handle POST requests with axios.

LANGUAGE: vue
CODE:
<script setup>
import { useMutation } from '@tanstack/vue-query'

const { isPending, isError, error, isSuccess, mutate } = useMutation({
  mutationFn: (newTodo) => axios.post('/todos', newTodo),
})

function addTodo() {
  mutate({ id: new Date(), title: 'Do Laundry' })
}
</script>

<template>
  <span v-if="isPending">Adding todo...</span>
  <span v-else-if="isError">An error occurred: {{ error.message }}</span>
  <span v-else-if="isSuccess">Todo added!</span>
  <button @click="addTodo">Create Todo</button>
</template>

----------------------------------------

TITLE: Configuring QueryClient with Extended GC Time
DESCRIPTION: Example of configuring a QueryClient instance with extended garbage collection time to work properly with persistence.

LANGUAGE: tsx
CODE:
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      gcTime: 1000 * 60 * 60 * 24, // 24 hours
    },
  },
})

----------------------------------------

TITLE: Installing TanStack Angular Query with NPM
DESCRIPTION: Command to install the experimental version of TanStack Angular Query using NPM package manager. Requires Angular v16 or higher.

LANGUAGE: bash
CODE:
npm i @tanstack/angular-query-experimental

----------------------------------------

TITLE: Handling Errors in Query Functions with TanStack Query in TypeScript
DESCRIPTION: This snippet demonstrates error handling within a query function. It shows how to throw errors directly or return rejected promises for different error scenarios.

LANGUAGE: typescript
CODE:
todos = injectQuery(() => ({
  queryKey: ['todos', todoId()],
  queryFn: async () => {
    if (somethingGoesWrong) {
      throw new Error('Oh no!')
    }
    if (somethingElseGoesWrong) {
      return Promise.reject(new Error('Oh no!'))
    }

    return data
  },
}))

----------------------------------------

TITLE: Non-Reactive Query Implementation in Svelte
DESCRIPTION: Example showing a non-reactive implementation of TanStack Query in Svelte where the refetchInterval option doesn't update reactively with input changes.

LANGUAGE: svelte
CODE:
<script lang="ts">
  import { createQuery } from '@tanstack/svelte-query'

  const endpoint = 'http://localhost:5173/api/data'

  let intervalMs = 1000

  const query = createQuery({
    queryKey: ['refetch'],
    queryFn: async () => await fetch(endpoint).then((r) => r.json()),
    refetchInterval: intervalMs,
  })
</script>

<input type="number" bind:value={intervalMs} />

----------------------------------------

TITLE: Using useIsFetching Hook in React Query
DESCRIPTION: Demonstrates how to use the useIsFetching hook to track the number of active query fetches. The hook can be used both for all queries and for filtered queries using a specific queryKey prefix. Returns a number indicating how many queries are currently fetching.

LANGUAGE: tsx
CODE:
import { useIsFetching } from '@tanstack/react-query'
// How many queries are fetching?
const isFetching = useIsFetching()
// How many queries matching the posts prefix are fetching?
const isFetchingPosts = useIsFetching({ queryKey: ['posts'] })

----------------------------------------

TITLE: Defining queryOptions Function with Defined Initial Data in TypeScript
DESCRIPTION: This function overload takes options with defined initial data and returns an object that includes DefinedInitialDataOptions and additional properties. It uses generic types for query function data, error, data, and query key.

LANGUAGE: typescript
CODE:
function queryOptions<TQueryFnData, TError, TData, TQueryKey>(
  options,
): DefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey> & object

----------------------------------------

TITLE: Mutation Error Handling with Reset in Vue
DESCRIPTION: Shows how to implement error handling and reset functionality in Vue mutations using TanStack Query. Includes error display and a reset button to clear error state.

LANGUAGE: vue
CODE:
<script>
import { useMutation } from '@tanstack/vue-query'

const { error, mutate, reset } = useMutation({
  mutationFn: (newTodo) => axios.post('/todos', newTodo),
})

function addTodo() {
  mutate({ id: new Date(), title: 'Do Laundry' })
}
</script>

<template>
  <span v-else-if="error">
    <span>An error occurred: {{ error.message }}</span>
    <button @click="reset">Reset error</button>
  </span>
  <button @click="addTodo">Create Todo</button>
</template>

----------------------------------------

TITLE: Defining InjectMutationStateOptions Interface in TypeScript
DESCRIPTION: Interface definition for mutation state injection options containing an optional injector property. Located in the inject-mutation-state.ts file at line 43.

LANGUAGE: typescript
CODE:
optional injector: Injector;

----------------------------------------

TITLE: Using useQueryClient Hook in a React Component
DESCRIPTION: This example demonstrates how to use the useQueryClient hook within a React component. It retrieves the QueryClient instance, which can be used to interact with the query cache.

LANGUAGE: javascript
CODE:
function MyComponent() {
  const queryClient = useQueryClient()

  // Use queryClient here...
}

----------------------------------------

TITLE: Importing and Using broadcastQueryClient in TanStack Query
DESCRIPTION: This snippet demonstrates how to import the broadcastQueryClient function from the experimental package and use it with a QueryClient instance. It shows the basic setup for broadcasting the query client state across browser tabs.

LANGUAGE: tsx
CODE:
import { broadcastQueryClient } from '@tanstack/query-broadcast-client-experimental'

const queryClient = new QueryClient()

broadcastQueryClient({
  queryClient,
  broadcastChannel: 'my-app',
})

----------------------------------------

TITLE: Typing Query Options in Solid Query
DESCRIPTION: Demonstrates how to use the queryOptions helper to maintain type inference when extracting query options into a separate function. This approach allows for sharing options between createQuery and prefetchQuery while preserving type safety.

LANGUAGE: ts
CODE:
import { queryOptions } from '@tanstack/solid-query'

function groupOptions() {
  return queryOptions({
    queryKey: ['groups'],
    queryFn: fetchGroups,
    staleTime: 5 * 1000,
  })
}

createQuery(groupOptions)
queryClient.prefetchQuery(groupOptions())

const data = queryClient.getQueryData(groupOptions().queryKey)
//    ^? const data: Group[] | undefined

----------------------------------------

TITLE: Defining QueriesResults Type Alias in TypeScript
DESCRIPTION: This type alias recursively maps query options to their results. It handles various cases including empty arrays, single-element arrays, and arrays with multiple elements. The type uses conditional types and recursive type definitions to achieve its functionality.

LANGUAGE: typescript
CODE:
type QueriesResults<T, TResults, TDepth>: TDepth["length"] extends MAXIMUM_DEPTH ? QueryObserverResult[] : T extends [] ? [] : T extends [infer Head] ? [...TResults, GetCreateQueryResult<Head>] : T extends [infer Head, ...(infer Tails)] ? QueriesResults<[...Tails], [...TResults, GetCreateQueryResult<Head>], [...TDepth, 1]> : T extends QueryObserverOptionsForCreateQueries<infer TQueryFnData, infer TError, infer TData, any>[] ? QueryObserverResult<unknown extends TData ? TQueryFnData : TData, unknown extends TError ? DefaultError : TError>[] : QueryObserverResult[];

----------------------------------------

TITLE: Implementing On-Demand TanStack Query Devtools Loading in Angular
DESCRIPTION: This snippet demonstrates how to implement on-demand loading of TanStack Query devtools in Angular, even in production mode, using a keyboard shortcut and RxJS observables.

LANGUAGE: typescript
CODE:
@Injectable({ providedIn: 'root' })
class DevtoolsOptionsManager {
  loadDevtools = toSignal(
    fromEvent<KeyboardEvent>(document, 'keydown').pipe(
      map(
        (event): boolean =>
          event.metaKey && event.ctrlKey && event.shiftKey && event.key === 'D',
      ),
      scan((acc, curr) => acc || curr, false),
    ),
    {
      initialValue: false,
    },
  )
}

export const appConfig: ApplicationConfig = {
  providers: [
    provideHttpClient(),
    provideTanStackQuery(
      new QueryClient(),
      withDevtools(() => ({
        initialIsOpen: true,
        loadDevtools: inject(DevtoolsOptionsManager).loadDevtools(),
      })),
    ),
  ],
}

----------------------------------------

TITLE: Defining CreateBaseMutationResult Type Alias in TypeScript
DESCRIPTION: Declares a type alias that extends MutationObserverResult with additional properties. It includes a mutateAsync function of type CreateMutateAsyncFunction.

LANGUAGE: typescript
CODE:
type CreateBaseMutationResult<TData, TError, TVariables, TContext>: Override<MutationObserverResult<TData, TError, TVariables, TContext>, object> & object;

LANGUAGE: typescript
CODE:
mutateAsync: CreateMutateAsyncFunction<TData, TError, TVariables, TContext>

----------------------------------------

TITLE: Defining CreateMutateFunction Type Alias in TypeScript
DESCRIPTION: Defines the CreateMutateFunction type alias with generic type parameters for data, error, variables, and context. It represents a function that takes arguments of the MutateFunction type and returns void.

LANGUAGE: typescript
CODE:
type CreateMutateFunction<TData, TError, TVariables, TContext>: (...args) => void;

----------------------------------------

TITLE: Importing TanStack Query Devtools
DESCRIPTION: Import statement for the SvelteQueryDevtools component from the installed package.

LANGUAGE: typescript
CODE:
import { SvelteQueryDevtools } from '@tanstack/svelte-query-devtools'

----------------------------------------

TITLE: Enabling TanStack Query Devtools in Angular
DESCRIPTION: This snippet demonstrates how to enable the TanStack Query devtools in an Angular application by adding withDevtools to the provideTanStackQuery configuration.

LANGUAGE: typescript
CODE:
import {
  QueryClient,
  provideTanStackQuery,
  withDevtools,
} from '@tanstack/angular-query-experimental'

export const appConfig: ApplicationConfig = {
  providers: [provideTanStackQuery(new QueryClient(), withDevtools())],
}

----------------------------------------

TITLE: Configuring Vue Query Plugin with Custom QueryClient in TypeScript
DESCRIPTION: This example demonstrates how to create a custom QueryClient instance and use it to configure the VueQueryPlugin.

LANGUAGE: tsx
CODE:
const myClient = new QueryClient(queryClientConfig)
const vueQueryPluginOptions: VueQueryPluginOptions = {
  queryClient: myClient,
}
app.use(VueQueryPlugin, vueQueryPluginOptions)

----------------------------------------

TITLE: Implementing Solid Query Devtools in Floating Mode
DESCRIPTION: Example of implementing Solid Query devtools in floating mode within a Solid app. This setup mounts the devtools as a fixed, floating element with a toggle for showing/hiding.

LANGUAGE: tsx
CODE:
import { SolidQueryDevtools } from '@tanstack/solid-query-devtools'

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      {/* The rest of your application */}
      <SolidQueryDevtools initialIsOpen={false} />
    </QueryClientProvider>
  )
}

----------------------------------------

TITLE: Using Custom Client Key in useQuery Hook in JavaScript
DESCRIPTION: This snippet demonstrates how to use the custom client key when making a query with the useQuery hook. The queryClientKey option must be provided alongside other query options.

LANGUAGE: js
CODE:
useQuery({
  queryKey: ['query1'],
  queryFn: fetcher,
  queryClientKey: 'foo',
})

----------------------------------------

TITLE: Using createQuery in Svelte Component
DESCRIPTION: Demonstrates how to use the createQuery function from @tanstack/svelte-query in a Svelte component. It sets up a query for fetching todos and renders the results based on the query state.

LANGUAGE: svelte
CODE:
<script lang="ts">
  import { createQuery } from '@tanstack/svelte-query'

  const query = createQuery({
    queryKey: ['todos'],
    queryFn: () => fetchTodos(),
  })
</script>

<div>
  {#if $query.isLoading}
    <p>Loading...</p>
  {:else if $query.isError}
    <p>Error: {$query.error.message}</p>
  {:else if $query.isSuccess}
    {#each $query.data as todo}
      <p>{todo.title}</p>
    {/each}
  {/if}
</div>

----------------------------------------

TITLE: Fetching Data with SolidJS createResource
DESCRIPTION: This snippet demonstrates how to fetch data from an API using SolidJS's createResource primitive. It includes error handling with ErrorBoundary and loading states with Suspense.

LANGUAGE: tsx
CODE:
import { createResource, ErrorBoundary, Suspense } from 'solid-js'
import { render } from 'solid-js/web'

function App() {
  const [repository] = createResource(async () => {
    const result = await fetch('https://api.github.com/repos/TanStack/query')
    if (!result.ok) throw new Error('Failed to fetch data')
    return result.json()
  })

  return (
    <div>
      <div>Static Content</div>
      {/* An error while fetching will be caught by the ErrorBoundary */}
      <ErrorBoundary fallback={<div>Something went wrong!</div>}>
        {/* Suspense will trigger a loading state while the data is being fetched */}
        <Suspense fallback={<div>Loading...</div>}>
          <div>{repository()?.updated_at}</div>
        </Suspense>
      </ErrorBoundary>
    </div>
  )
}

const root = document.getElementById('root')

render(() => <App />, root!)

----------------------------------------

TITLE: Implementing Floating Mode Devtools
DESCRIPTION: Example of implementing the SvelteQueryDevtools component in floating mode within a Svelte application. Should be placed as high as possible in the component tree.

LANGUAGE: typescript
CODE:
<script>
  import { QueryClientProvider } from '@tanstack/svelte-query'
  import { SvelteQueryDevtools } from '@tanstack/svelte-query-devtools'
</script>

<QueryClientProvider client={queryClient}>
  {/* The rest of your application */}
  <SvelteQueryDevtools />
</QueryClientProvider>

----------------------------------------

TITLE: Declaring injectQueries Function Signature in TypeScript
DESCRIPTION: Function signature for injectQueries that takes generic type parameters T and TCombinedResult. The function accepts named parameters and an optional injector, returning a Signal of TCombinedResult type.

LANGUAGE: typescript
CODE:
function injectQueries<T, TCombinedResult>(
  __namedParameters,
  injector?,
): Signal<TCombinedResult>

----------------------------------------

TITLE: Suspense Integration Example
DESCRIPTION: Demonstrates how to use createQuery with SolidJS Suspense and ErrorBoundary components for handling loading and error states.

LANGUAGE: tsx
CODE:
import { createQuery } from '@tanstack/solid-query'

function App() {
  const todos = createQuery(() => ({
    queryKey: 'todos',
    queryFn: async () => {
      const response = await fetch('/api/todos')
      if (!response.ok) {
        throw new Error('Failed to fetch todos')
      }
      return response.json()
    },
    throwOnError: true,
  }))

  return (
    <ErrorBoundary fallback={<div>Error: {todos.error.message}</div>}>
      <Suspense fallback={<div>Loading...</div>}>
        <div>
          <div>Todos:</div>
          <ul>
            <For each={todos.data}>{(todo) => <li>{todo.title}</li>}</For>
          </ul>
        </div>
      </Suspense>
    </ErrorBoundary>
  )
}

----------------------------------------

TITLE: Initializing QueryClientProvider in Svelte
DESCRIPTION: Sets up the QueryClientProvider near the root of a Svelte project. It creates a new QueryClient instance and wraps the Example component with the provider.

LANGUAGE: svelte
CODE:
<script lang="ts">
  import { QueryClient, QueryClientProvider } from '@tanstack/svelte-query'
  import Example from './lib/Example.svelte'

  const queryClient = new QueryClient()
</script>

<QueryClientProvider client={queryClient}>
  <Example />
</QueryClientProvider>

----------------------------------------

TITLE: Installing @tanstack/svelte-query with Yarn
DESCRIPTION: Command to install TanStack Query for Svelte using Yarn package manager.

LANGUAGE: bash
CODE:
yarn add @tanstack/svelte-query

----------------------------------------

TITLE: Using skipToken to Conditionally Disable Queries in Vue
DESCRIPTION: This snippet showcases the use of skipToken to conditionally disable a query. The query function is set to skipToken when the filter is empty, effectively disabling the query execution.

LANGUAGE: vue
CODE:
<script setup>
import { useQuery, skipToken } from '@tanstack/vue-query'

const filter = ref('')
const queryFn = computed(() =>
  !!filter.value ? () => fetchTodos(filter) : skipToken,
)
const { data } = useQuery({
  queryKey: ['todos', filter],
  // ‚¨áÔ∏è disabled as long as the filter is undefined or empty
  queryFn: queryFn,
})
</script>

<template>
  <span v-if="data">Filter was set and data is here!</span>
</template>

----------------------------------------

TITLE: Importing Solid Query Devtools in TSX
DESCRIPTION: Import statement for the Solid Query devtools in a TypeScript React component.

LANGUAGE: tsx
CODE:
import { SolidQueryDevtools } from '@tanstack/solid-query-devtools'

----------------------------------------

TITLE: Deriving Initial Data from Another Query in TanStack Query (TypeScript)
DESCRIPTION: Shows how to derive initial data for a single todo query from an existing todos query, reducing unnecessary data fetching.

LANGUAGE: typescript
CODE:
result = injectQuery(() => ({
  queryKey: ['todo', this.todoId()],
  queryFn: () => fetch('/todos'),
  initialData: () => {
    // Use a todo from the 'todos' query as the initial data for this todo query
    return this.queryClient
      .getQueryData(['todos'])
      ?.find((d) => d.id === this.todoId())
  },
}))

----------------------------------------

TITLE: Using usePrefetchQuery Hook in React with TypeScript
DESCRIPTION: Demonstrates the basic usage of the usePrefetchQuery hook. This hook is used to prefetch queries during render, before a suspense boundary that wraps a component using useSuspenseQuery.

LANGUAGE: tsx
CODE:
usePrefetchQuery(options)

----------------------------------------

TITLE: Providing QueryClient in SvelteKit Layout
DESCRIPTION: Sets up the QueryClientProvider in a SvelteKit layout file, using the QueryClient instance created in the layout load function.

LANGUAGE: svelte
CODE:
<script lang="ts">
  import { QueryClientProvider } from '@tanstack/svelte-query'
  import type { LayoutData } from './$types'

  export let data: LayoutData
</script>

<QueryClientProvider client={data.queryClient}>
  <slot />
</QueryClientProvider>

----------------------------------------

TITLE: Using useSuspenseInfiniteQuery Hook in React with TypeScript
DESCRIPTION: Demonstrates the basic usage of useSuspenseInfiniteQuery hook. This hook is a Suspense-enabled version of useInfiniteQuery that guarantees defined data and success status. It excludes suspense, throwOnError, enabled, and placeholderData options from the standard useInfiniteQuery hook.

LANGUAGE: tsx
CODE:
const result = useSuspenseInfiniteQuery(options)

----------------------------------------

TITLE: Implementing Basic Vue Query Operations in Vue.js
DESCRIPTION: Shows how to set up basic querying and mutation operations using Vue Query. Demonstrates fetching todos, handling loading/error states, and implementing a mutation to add new todos. Uses the Composition API with <script setup> syntax.

LANGUAGE: vue
CODE:
<script setup>
import { useQueryClient, useQuery, useMutation } from '@tanstack/vue-query'

// Access QueryClient instance
const queryClient = useQueryClient()

// Query
const { isPending, isError, data, error } = useQuery({
  queryKey: ['todos'],
  queryFn: getTodos,
})

// Mutation
const mutation = useMutation({
  mutationFn: postTodo,
  onSuccess: () => {
    // Invalidate and refetch
    queryClient.invalidateQueries({ queryKey: ['todos'] })
  },
})

function onButtonClick() {
  mutation.mutate({
    id: Date.now(),
    title: 'Do Laundry',
  })
}
</script>

<template>
  <span v-if="isPending">Loading...</span>
  <span v-else-if="isError">Error: {{ error.message }}</span>
  <!-- We can assume by this point that `isSuccess === true` -->
  <ul v-else>
    <li v-for="todo in data" :key="todo.id">{{ todo.title }}</li>
  </ul>
  <button @click="onButtonClick">Add Todo</button>
</template>

----------------------------------------

TITLE: Customizing Scheduler with notifyManager.setScheduler in TypeScript
DESCRIPTION: setScheduler configures a custom callback that schedules when the next batch runs. Examples include using queueMicrotask, requestAnimationFrame, or a custom setTimeout.

LANGUAGE: typescript
CODE:
import { notifyManager } from '@tanstack/react-query'

// Schedule batches in the next microtask
notifyManager.setScheduler(queueMicrotask)

// Schedule batches before the next frame is rendered
notifyManager.setScheduler(requestAnimationFrame)

// Schedule batches some time in the future
notifyManager.setScheduler((cb) => setTimeout(cb, 10))

----------------------------------------

TITLE: Conditional Query Execution Based on Computed Property in Vue
DESCRIPTION: This example demonstrates how to conditionally enable a query based on a computed property. The query is disabled when the filter is empty and enabled when it has a value.

LANGUAGE: vue
CODE:
<script setup>
import { useQuery } from '@tanstack/vue-query'

const filter = ref('')
const isEnabled = computed(() => !!filter.value)
const { data } = useQuery({
  queryKey: ['todos', filter],
  queryFn: () => fetchTodos(filter),
  // ‚¨áÔ∏è disabled as long as the filter is empty
  enabled: isEnabled,
})
</script>

<template>
  <span v-if="data">Filter was set and data is here!</span>
</template>

----------------------------------------

TITLE: Installing Solid Query Devtools via yarn
DESCRIPTION: Command to install the Solid Query devtools package using yarn.

LANGUAGE: bash
CODE:
yarn add @tanstack/solid-query-devtools

----------------------------------------

TITLE: Replacing keepPreviousData with placeholderData in TypeScript/JavaScript
DESCRIPTION: The keepPreviousData option has been removed in favor of using placeholderData with an identity function.

LANGUAGE: tsx
CODE:
import {
   useQuery,
+  keepPreviousData // [!code ++]
} from "@tanstack/react-query";

const {
   data,
-  isPreviousData, // [!code --]
+  isPlaceholderData, // [!code ++]
} = useQuery({
  queryKey,
  queryFn,
- keepPreviousData: true, // [!code --]
+ placeholderData: keepPreviousData // [!code ++]
});

----------------------------------------

TITLE: Invalidating Queries after Mutation in Vue with TanStack Query
DESCRIPTION: This snippet demonstrates how to use the useMutation hook from TanStack Query to invalidate specific queries after a successful mutation. It imports necessary functions, sets up a query client, and defines a mutation that invalidates 'todos' and 'reminders' queries upon success.

LANGUAGE: tsx
CODE:
import { useMutation, useQueryClient } from '@tanstack/vue-query'

const queryClient = useQueryClient()

// When this mutation succeeds, invalidate any queries with the `todos` or `reminders` query key
const mutation = useMutation({
  mutationFn: addTodo,
  onSuccess: () => {
    queryClient.invalidateQueries({ queryKey: ['todos'] })
    queryClient.invalidateQueries({ queryKey: ['reminders'] })
  },
})

----------------------------------------

TITLE: Implementing Basic Vue Query Operations in Vue.js
DESCRIPTION: Shows how to set up basic querying and mutation operations using Vue Query. Demonstrates fetching todos, handling loading/error states, and implementing a mutation to add new todos. Uses the Composition API with <script setup> syntax.

LANGUAGE: vue
CODE:
<script setup>
import { useQueryClient, useQuery, useMutation } from '@tanstack/vue-query'

// Access QueryClient instance
const queryClient = useQueryClient()

// Query
const { isPending, isError, data, error } = useQuery({
  queryKey: ['todos'],
  queryFn: getTodos,
})

// Mutation
const mutation = useMutation({
  mutationFn: postTodo,
  onSuccess: () => {
    // Invalidate and refetch
    queryClient.invalidateQueries({ queryKey: ['todos'] })
  },
})

function onButtonClick() {
  mutation.mutate({
    id: Date.now(),
    title: 'Do Laundry',
  })
}
</script>

<template>
  <span v-if="isPending">Loading...</span>
  <span v-else-if="isError">Error: {{ error.message }}</span>
  <!-- We can assume by this point that `isSuccess === true` -->
  <ul v-else>
    <li v-for="todo in data" :key="todo.id">{{ todo.title }}</li>
  </ul>
  <button @click="onButtonClick">Add Todo</button>
</template>

----------------------------------------

TITLE: Installing TanStack Solid Query via NPM
DESCRIPTION: Command to install TanStack Solid Query using NPM package manager.

LANGUAGE: bash
CODE:
npm i @tanstack/solid-query

----------------------------------------

TITLE: Dynamic Query Keys with Signals
DESCRIPTION: Shows how to implement dynamic query keys using signals. Demonstrates conditional querying based on signal values and passing signal values to query functions.

LANGUAGE: typescript
CODE:
todoId = signal(-1)

injectQuery(() => ({
  enabled: todoId() > 0,
  queryKey: ['todos', todoId()],
  queryFn: () => fetchTodoById(todoId()),
}))

----------------------------------------

TITLE: Installing Solid Query Devtools via bun
DESCRIPTION: Command to install the Solid Query devtools package using bun.

LANGUAGE: bash
CODE:
bun add @tanstack/solid-query-devtools

----------------------------------------

TITLE: Initializing QueryObserver in TanStack Query with TypeScript
DESCRIPTION: Demonstrates how to create a QueryObserver instance and subscribe to query results. The observer accepts a queryClient and options object with queryKey, and returns an unsubscribe function to clean up the subscription.

LANGUAGE: tsx
CODE:
const observer = new QueryObserver(queryClient, { queryKey: ['posts'] })

const unsubscribe = observer.subscribe((result) => {
  console.log(result)
  unsubscribe()
})

----------------------------------------

TITLE: Basic Type Inference in Angular Query Component
DESCRIPTION: Demonstrates basic type inference for query data in an Angular component using injectQuery. The query function returns a number which is correctly inferred in the template.

LANGUAGE: angular-ts
CODE:
@Component({
  // ...
  template: `@let data = query.data();`,
  //               ^? data: number | undefined
})
class MyComponent {
  query = injectQuery(() => ({
    queryKey: ['test'],
    queryFn: () => Promise.resolve(5),
  }))
}

----------------------------------------

TITLE: Disabling Query Execution with Enabled Option in Vue
DESCRIPTION: This snippet shows how to disable a query by default using the 'enabled' option set to false. It provides a button to manually trigger the query using the refetch function.

LANGUAGE: vue
CODE:
<script setup>
import { useQuery } from '@tanstack/vue-query'

const { isLoading, isError, data, error, refetch, isFetching } = useQuery({
  queryKey: ['todos'],
  queryFn: fetchTodoList,
  enabled: false,
})
</script>

<template>
  <button @click="refetch">Fetch Todos</button>
  <span v-if="isIdle">Not ready...</span>
  <span v-else-if="isError">Error: {{ error.message }}</span>
  <div v-else-if="data">
    <span v-if="isFetching">Fetching...</span>
    <ul>
      <li v-for="todo in data" :key="todo.id">{{ todo.title }}</li>
    </ul>
  </div>
</template>

----------------------------------------

TITLE: Installing Solid Query Devtools via npm
DESCRIPTION: Command to install the Solid Query devtools package using npm.

LANGUAGE: bash
CODE:
npm i @tanstack/solid-query-devtools

----------------------------------------

TITLE: Implementing Query Cancellation with Axios in React
DESCRIPTION: This snippet demonstrates how to use TanStack Query's cancellation feature with Axios in a React context. It shows how to pass the AbortSignal to an Axios GET request, enabling automatic cancellation when the query becomes inactive or out-of-date.

LANGUAGE: tsx
CODE:
import axios from 'axios'

const query = injectQuery(() => ({
  queryKey: ['todos'],
  queryFn: ({ signal }) =>
    axios.get('/todos', {
      // Pass the signal to `axios`
      signal,
    }),
}))

----------------------------------------

TITLE: Using Mutation Filters in TanStack Query
DESCRIPTION: Examples of using MutationFilters to check mutation status and filter mutations based on mutation keys and predicate functions.

LANGUAGE: tsx
CODE:
// Get the number of all fetching mutations
await queryClient.isMutating()

// Filter mutations by mutationKey
await queryClient.isMutating({ mutationKey: ['post'] })

// Filter mutations using a predicate function
await queryClient.isMutating({
  predicate: (mutation) => mutation.state.variables?.id === 1,
})

----------------------------------------

TITLE: Fetching Data with Solid Query
DESCRIPTION: This snippet showcases how to use Solid Query to fetch data from an API. It demonstrates the use of createQuery, QueryClient, and QueryClientProvider, along with error handling and loading states.

LANGUAGE: tsx
CODE:
import { ErrorBoundary, Suspense } from 'solid-js'
import {
  createQuery,
  QueryClient,
  QueryClientProvider,
} from '@tanstack/solid-query'

function App() {
  const repositoryQuery = createQuery(() => ({
    queryKey: ['TanStack Query'],
    queryFn: async () => {
      const result = await fetch('https://api.github.com/repos/TanStack/query')
      if (!result.ok) throw new Error('Failed to fetch data')
      return result.json()
    },
    staleTime: 1000 * 60 * 5, // 5 minutes
    throwOnError: true, // Throw an error if the query fails
  }))

  return (
    <div>
      <div>Static Content</div>
      {/* An error while fetching will be caught by the ErrorBoundary */}
      <ErrorBoundary fallback={<div>Something went wrong!</div>}>
        {/* Suspense will trigger a loading state while the data is being fetched */}
        <Suspense fallback={<div>Loading...</div>}>
          {/* 
            The `data` property on a query is a SolidJS resource  
            so it will work with Suspense and transitions out of the box! 
          */}
          <div>{repositoryQuery.data?.updated_at}</div>
        </Suspense>
      </ErrorBoundary>
    </div>
  )
}

const root = document.getElementById('root')
const client = new QueryClient()

render(
  () => (
    <QueryClientProvider client={client}>
      <App />
    </QueryClientProvider>
  ),
  root!,
)

----------------------------------------

TITLE: Initializing QueryClient in Next.js App Component
DESCRIPTION: Sets up the QueryClient provider in a Next.js _app.tsx file, ensuring each request has its own cache instance to prevent data leaks between users.

LANGUAGE: tsx
CODE:
// _app.tsx
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'

export default function MyApp({ Component, pageProps }) {
  const [queryClient] = React.useState(
    () =>
      new QueryClient({
        defaultOptions: {
          queries: {
            staleTime: 60 * 1000,
          },
        },
      }),
  )

  return (
    <QueryClientProvider client={queryClient}>
      <Component {...pageProps} />
    </QueryClientProvider>
  )
}

----------------------------------------

TITLE: Correct QueryClient Usage in Async Server Component
DESCRIPTION: Shows the valid use case of creating a new QueryClient instance within an async server component, where the function is only called once.

LANGUAGE: tsx
CODE:
async function App() {
  const queryClient = new QueryClient()
  await queryClient.prefetchQuery(options)
}

----------------------------------------

TITLE: Registering Global Error Type in Solid Query
DESCRIPTION: Shows how to register a global error type for all queries using module augmentation. This approach ensures consistent error typing across the application without specifying generics on each query.

LANGUAGE: tsx
CODE:
import '@tanstack/solid-query'

declare module '@tanstack/solid-query' {
  interface Register {
    defaultError: AxiosError
  }
}

const query = createQuery(() => ({
  queryKey: ['groups'],
  queryFn: fetchGroups,
}))

query.error
//    ^? (property) error: AxiosError | null

----------------------------------------

TITLE: Basic Query Disabling in Angular Component
DESCRIPTION: Demonstrates basic query disabling using the enabled: false option in injectQuery. Includes error handling and loading states in the template with structural directives.

LANGUAGE: angular-ts
CODE:
@Component({
  selector: 'todos',
  template: `<div>
    <button (click)="query.refetch()">Fetch Todos</button>

    @if (query.data()) {
      <ul>
        @for (todo of query.data(); track todo.id) {
          <li>{{ todo.title }}</li>
        }
      </ul>
    } @else {
      @if (query.isError()) {
        <span>Error: {{ query.error().message }}</span>
      } @else if (query.isLoading()) {
        <span>Loading...</span>
      } @else if (!query.isLoading() && !query.isError()) {
        <span>Not ready ...</span>
      }
    }

    <div>{{ query.isLoading() ? 'Fetching...' : '' }}</div>
  </div>`,
})
export class TodosComponent {
  query = injectQuery(() => ({
    queryKey: ['todos'],
    queryFn: fetchTodoList,
    enabled: false,
  }))
}

----------------------------------------

TITLE: Installing @tanstack/svelte-query with PNPM
DESCRIPTION: Command to install TanStack Query for Svelte using PNPM package manager.

LANGUAGE: bash
CODE:
pnpm add @tanstack/svelte-query

----------------------------------------

TITLE: Implementing Manual Query Cancellation in Angular
DESCRIPTION: This example illustrates how to manually cancel a query in an Angular component using TanStack Query. It defines a button that, when clicked, triggers the cancellation of a specific query using the QueryClient's cancelQueries method.

LANGUAGE: angular-ts
CODE:
@Component({
  standalone: true,
  template: `<button (click)="onCancel()">Cancel</button>`,
})
export class TodosComponent {
  query = injectQuery(() => ({
    queryKey: ['todos'],
    queryFn: async ({ signal }) => {
      const resp = await fetch('/todos', { signal })
      return resp.json()
    },
  }))

  queryClient = inject(QueryClient)

  onCancel() {
    this.queryClient.cancelQueries(['todos'])
  }
}

----------------------------------------

TITLE: Implementing a Suspendable Component with Vue Query
DESCRIPTION: This snippet shows how to create a suspendable component using Vue Query's useQuery hook and the suspense function. It fetches todo data asynchronously.

LANGUAGE: vue
CODE:
<script>
import { defineComponent } from 'vue'
import { useQuery } from '@tanstack/vue-query'

const todoFetcher = async () =>
  await fetch('https://jsonplaceholder.cypress.io/todos').then((response) =>
    response.json(),
  )
export default defineComponent({
  name: 'SuspendableComponent',
  async setup() {
    const { data, suspense } = useQuery(['todos'], todoFetcher)
    await suspense()

    return { data }
  },
})
</script>

----------------------------------------

TITLE: Demonstrating Query Key Hashing in TanStack Query (TSX)
DESCRIPTION: Illustrates how query keys are hashed deterministically in TanStack Query. The order of keys in objects doesn't affect equality, but array item order does matter.

LANGUAGE: tsx
CODE:
useQuery({ queryKey: ['todos', { status, page }], ... })
useQuery({ queryKey: ['todos', { page, status }], ...})
useQuery({ queryKey: ['todos', { page, status, other: undefined }], ... })

LANGUAGE: tsx
CODE:
useQuery({ queryKey: ['todos', status, page], ... })
useQuery({ queryKey: ['todos', page, status], ...})
useQuery({ queryKey: ['todos', undefined, page, status], ...})

----------------------------------------

TITLE: Basic Paginated Query Setup in TypeScript
DESCRIPTION: Demonstrates a simple paginated query setup using TanStack Query's injectQuery function. It fetches projects based on the current page.

LANGUAGE: typescript
CODE:
const result = injectQuery(() => ({
  queryKey: ['projects', page()],
  queryFn: fetchProjects,
}))

----------------------------------------

TITLE: Using Signals with TanStack Query in SolidJS
DESCRIPTION: This example demonstrates how to use SolidJS signals with TanStack Query. It shows that signals and store values can be passed directly to function arguments, and Solid Query will update the query store automatically when signal values change.

LANGUAGE: tsx
CODE:
import {
  QueryClient,
  QueryClientProvider,
  createQuery,
} from '@tanstack/solid-query'
import { createSignal, For } from 'solid-js'

const queryClient = new QueryClient()

function Example() {
  const [enabled, setEnabled] = createSignal(false)
  const [todo, setTodo] = createSignal(0)

  const todosQuery = createQuery(() => ({
    queryKey: ['todos'],
    queryFn: fetchTodos,
    enabled: enabled(),
  }))

  const todoDetailsQuery = createQuery(() => ({
    queryKey: ['todo', todo()],
    queryFn: fetchTodo,
    enabled: todo() > 0,
  }))

  return (
    <div>
      <Switch>
        <Match when={todosQuery.isPending}>
          <p>Loading...</p>
        </Match>
        <Match when={todosQuery.isError}>
          <p>Error: {todosQuery.error.message}</p>
        </Match>
        <Match when={todosQuery.isSuccess}>
          <For each={todosQuery.data}>
            {(todo) => (
              <button onClick={() => setTodo(todo.id)}>{todo.title}</button>
            )}
          </For>
        </Match>
      </Switch>
      <button onClick={() => setEnabled(!enabled())}>Toggle enabled</button>
    </div>
  )
}

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <Example />
    </QueryClientProvider>
  )
}

----------------------------------------

TITLE: Maintaining Immutability when Updating Cache in TanStack Query
DESCRIPTION: This snippet illustrates the importance of immutability when updating the query cache using setQueryData. It shows an incorrect mutable approach and the correct immutable way to update data, which helps prevent subtle bugs.

LANGUAGE: tsx
CODE:
queryClient.setQueryData(['posts', { id }], (oldData) => {
  if (oldData) {
    // ‚ùå do not try this
    oldData.title = 'my new post title'
  }
  return oldData
})

queryClient.setQueryData(
  ['posts', { id }],
  // ‚úÖ this is the way
  (oldData) =>
    oldData
      ? {
          ...oldData,
          title: 'my new post title',
        }
      : oldData,
)

----------------------------------------

TITLE: Example Data Fetching Hook
DESCRIPTION: Implementation of a custom hook that fetches data from an API endpoint.

LANGUAGE: tsx
CODE:
function useFetchData() {
  return useQuery({
    queryKey: ['fetchData'],
    queryFn: () => request('/api/data'),
  })
}

----------------------------------------

TITLE: Basic Query Composable Implementation (Non-Reactive)
DESCRIPTION: Initial implementation of a query composable that doesn't properly handle reactivity because it extracts the ref value directly.

LANGUAGE: typescript
CODE:
export function useUserProjects(userId: string) {
  return useQuery(
    queryKey: ['userProjects', userId],
    queryFn: () => api.fetchUserProjects(userId),
  );
}

----------------------------------------

TITLE: Installing TanStack Solid Query via Yarn
DESCRIPTION: Command to install TanStack Solid Query using Yarn package manager.

LANGUAGE: bash
CODE:
yarn add @tanstack/solid-query

----------------------------------------

TITLE: Global State After TanStack Query
DESCRIPTION: Example showing reduced global state structure after moving server state management to TanStack Query, leaving only client-specific state.

LANGUAGE: tsx
CODE:
const globalState = {
  themeMode,
  sidebarStatus,
}

----------------------------------------

TITLE: injectQuery Function Type Definition
DESCRIPTION: Type definition for the injectQuery function showing its generic parameters and return type. Includes options for query function data, error handling, and key management.

LANGUAGE: typescript
CODE:
function injectQuery<TQueryFnData, TError, TData, TQueryKey>(
  optionsFn,
  injector?,
): DefinedCreateQueryResult<TData, TError>

----------------------------------------

TITLE: Defining isSuccess Method in BaseQueryNarrowing Interface
DESCRIPTION: This method checks if the query result is in a success state. It takes 'this' as a parameter and returns a boolean indicating if the result is of success type.

LANGUAGE: typescript
CODE:
isSuccess: (this) => this is CreateBaseQueryResult<TData, TError, QueryObserverSuccessResult<TData, TError>>;

----------------------------------------

TITLE: Setting Initial Data Update Time in TanStack Query (TypeScript)
DESCRIPTION: Shows how to set both initial data and its update timestamp for a query, allowing fine-grained control over when the data becomes stale and needs refetching.

LANGUAGE: typescript
CODE:
// Show initialTodos immediately, but won't refetch until
// another interaction event is encountered after 1000 ms
result = injectQuery(() => ({
  queryKey: ['todos'],
  queryFn: () => fetch('/todos'),
  initialData: initialTodos,
  staleTime: 60 * 1000, // 1 minute
  // This could be 10 seconds ago or 10 minutes ago
  initialDataUpdatedAt: initialTodosUpdatedTimestamp, // eg. 1608412420052
}))

----------------------------------------

TITLE: Setting Initial Data Update Time in TanStack Query (TypeScript)
DESCRIPTION: Shows how to set both initial data and its update timestamp for a query, allowing fine-grained control over when the data becomes stale and needs refetching.

LANGUAGE: typescript
CODE:
// Show initialTodos immediately, but won't refetch until
// another interaction event is encountered after 1000 ms
result = injectQuery(() => ({
  queryKey: ['todos'],
  queryFn: () => fetch('/todos'),
  initialData: initialTodos,
  staleTime: 60 * 1000, // 1 minute
  // This could be 10 seconds ago or 10 minutes ago
  initialDataUpdatedAt: initialTodosUpdatedTimestamp, // eg. 1608412420052
}))

----------------------------------------

TITLE: QueryClient Injection Usage Example
DESCRIPTION: Example showing how to use the injectQueryClient function to obtain a QueryClient instance in an Angular component or service.

LANGUAGE: typescript
CODE:
const queryClient = injectQueryClient()

----------------------------------------

TITLE: Initializing InfiniteQueryObserver in TanStack Query (TSX)
DESCRIPTION: Demonstrates how to create and use an InfiniteQueryObserver instance for handling paginated data queries. The observer allows subscription to query results and includes configuration for both forward and backward pagination through getNextPageParam and getPreviousPageParam functions.

LANGUAGE: tsx
CODE:
const observer = new InfiniteQueryObserver(queryClient, {
  queryKey: ['posts'],
  queryFn: fetchPosts,
  getNextPageParam: (lastPage, allPages) => lastPage.nextCursor,
  getPreviousPageParam: (firstPage, allPages) => firstPage.prevCursor,
})

const unsubscribe = observer.subscribe((result) => {
  console.log(result)
  unsubscribe()
})

----------------------------------------

TITLE: Reactive Query Implementation Using Svelte Stores
DESCRIPTION: Improved implementation using Svelte stores to create truly reactive query options. Uses derived store to update refetchInterval dynamically when the input value changes.

LANGUAGE: svelte
CODE:
<script lang="ts">
  import { derived, writable } from 'svelte/store'
  import { createQuery } from '@tanstack/svelte-query'

  const endpoint = 'http://localhost:5173/api/data'

  const intervalMs = writable(1000)

  const query = createQuery(
    derived(intervalMs, ($intervalMs) => ({
      queryKey: ['refetch'],
      queryFn: async () => await fetch(endpoint).then((r) => r.json()),
      refetchInterval: $intervalMs,
    })),
  )
</script>

<input type="number" bind:value={$intervalMs} />

----------------------------------------

TITLE: Installing TanStack Solid Query via Bun
DESCRIPTION: Command to install TanStack Solid Query using Bun package manager.

LANGUAGE: bash
CODE:
bun add @tanstack/solid-query

----------------------------------------

TITLE: Configuring Vue Query Plugin with Custom Client and Key in TypeScript
DESCRIPTION: This example combines setting both a custom QueryClient instance and a custom context key when configuring the VueQueryPlugin.

LANGUAGE: tsx
CODE:
const myClient = new QueryClient(queryClientConfig)
const vueQueryPluginOptions: VueQueryPluginOptions = {
  queryClient: myClient,
  queryClientKey: 'Foo',
}
app.use(VueQueryPlugin, vueQueryPluginOptions)

----------------------------------------

TITLE: Initializing TanStack Query in Standalone Angular
DESCRIPTION: Configuration code for initializing TanStack Query in a standalone Angular application using provideTanStackQuery.

LANGUAGE: typescript
CODE:
import { provideTanStackQuery } from '@tanstack/angular-query-experimental'
import { QueryClient } from '@tanstack/angular-query-experimental'

bootstrapApplication(AppComponent, {
  providers: [provideTanStackQuery(new QueryClient())],
})

----------------------------------------

TITLE: Array-Based Query Keys with Multiple Parameters
DESCRIPTION: Demonstrates array-based query key patterns with multiple parameters. Shows how to handle undefined values and parameter ordering in array-based keys.

LANGUAGE: typescript
CODE:
injectQuery(() => ({ queryKey: ['todos', status, page], ... }))
injectQuery(() => ({ queryKey: ['todos', page, status], ...}))
injectQuery(() => ({ queryKey: ['todos', undefined, page, status], ...}))

----------------------------------------

TITLE: Setting Custom Notify Function with notifyManager.setNotifyFunction in TypeScript
DESCRIPTION: setNotifyFunction overrides the notify function. This can be used to wrap notifications with React.act while running tests.

LANGUAGE: typescript
CODE:
import { notifyManager } from '@tanstack/react-query'
import { act } from 'react-dom/test-utils'

notifyManager.setNotifyFunction(act)

----------------------------------------

TITLE: Defining CreateInfiniteQueryResult Type Alias in TypeScript
DESCRIPTION: Defines the CreateInfiniteQueryResult type alias as a Readable of InfiniteQueryObserverResult. It takes two type parameters: TData (defaulting to unknown) and TError (defaulting to DefaultError).

LANGUAGE: typescript
CODE:
type CreateInfiniteQueryResult<TData, TError>: Readable<InfiniteQueryObserverResult<TData, TError>>;

----------------------------------------

TITLE: Basic Query Options Usage Example
DESCRIPTION: Demonstrates basic usage of queryOptions function with a simple query that returns a number.

LANGUAGE: typescript
CODE:
const { queryKey } = queryOptions({
  queryKey: ['key'],
  queryFn: () => Promise.resolve(5),
  //  ^?  Promise<number>
})

const queryClient = new QueryClient()
const data = queryClient.getQueryData(queryKey)
//    ^?  number | undefined

----------------------------------------

TITLE: Setting QueryClient Context in Svelte with TypeScript
DESCRIPTION: A function that takes a QueryClient instance and sets it in Svelte's context system. This enables child components to access the QueryClient through Svelte's context API. The function accepts a QueryClient parameter and returns void.

LANGUAGE: typescript
CODE:
function setQueryClientContext(client): void

----------------------------------------

TITLE: Retrieving All Mutations from Cache
DESCRIPTION: Demonstrates using the getAll method to retrieve all mutations stored in the cache. Returns an array of Mutation instances.

LANGUAGE: tsx
CODE:
const mutations = mutationCache.getAll()

----------------------------------------

TITLE: Accessing Query Properties in SolidJS Reactive Context
DESCRIPTION: This snippet illustrates how to properly access query properties in a SolidJS reactive context. It shows that destructuring is not supported outside the reactive context, and demonstrates the correct way to use query properties in JSX.

LANGUAGE: tsx
CODE:
import {
  QueryClient,
  QueryClientProvider,
  createQuery,
} from '@tanstack/solid-query'
import { Match, Switch } from 'solid-js'

const queryClient = new QueryClient()

export default function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <Example />
    </QueryClientProvider>
  )
}

function Example() {
  const query = createQuery(() => ({
    queryKey: ['repoData'],
    queryFn: () =>
      fetch('https://api.github.com/repos/tannerlinsley/react-query').then(
        (res) => res.json(),
      ),
  }))

  return (
    <Switch>
      <Match when={query.isPending}>Loading...</Match>
      <Match when={query.isError}>Error: {query.error.message}</Match>
      <Match when={query.isSuccess}>
        <div>
          <h1>{query.data.name}</h1>
          <p>{query.data.description}</p>
          <strong>üëÄ {query.data.subscribers_count}</strong>{' '}
          <strong>‚ú® {query.data.stargazers_count}</strong>{' '}
          <strong>üç¥ {query.data.forks_count}</strong>
        </div>
      </Match>
    </Switch>
  )
}

----------------------------------------

TITLE: Creating New Svelte Project
DESCRIPTION: Commands for initializing a new Svelte project either in the current directory or in a specified folder using create-svelte.

LANGUAGE: bash
CODE:
# create a new project in the current directory
npm create svelte@latest

# create a new project in my-app
npm create svelte@latest my-app

----------------------------------------

TITLE: Using Memoized Function for Placeholder Data in TanStack Query (TypeScript)
DESCRIPTION: This example shows how to use a memoized function for placeholder data in TanStack Query. It uses the previous data and query to determine the placeholder data for a todo item query.

LANGUAGE: typescript
CODE:
class TodosComponent {
  result = injectQuery(() => ({
    queryKey: ['todos', id()],
    queryFn: () => fetch(`/todos/${id}`),
    placeholderData: (previousData, previousQuery) => previousData,
  }))
}

----------------------------------------

TITLE: Installing Vue Query with Package Managers
DESCRIPTION: Commands for installing Vue Query using npm, pnpm, yarn, or bun package managers. These commands add the @tanstack/vue-query package to your project dependencies.

LANGUAGE: bash
CODE:
$ npm i @tanstack/vue-query

LANGUAGE: bash
CODE:
$ pnpm add @tanstack/vue-query

LANGUAGE: bash
CODE:
$ yarn add @tanstack/vue-query

LANGUAGE: bash
CODE:
$ bun add @tanstack/vue-query

----------------------------------------

TITLE: Subscribing to Online State Changes - TSX
DESCRIPTION: Shows how to subscribe to online state changes in the OnlineManager, returning an unsubscribe function for cleanup.

LANGUAGE: tsx
CODE:
import { onlineManager } from '@tanstack/react-query'

const unsubscribe = onlineManager.subscribe((isOnline) => {
  console.log('isOnline', isOnline)
})

----------------------------------------

TITLE: Running TanStack Query Angular Example
DESCRIPTION: Commands for starting the example application using different package managers. This will launch the Angular application with TanStack Query integration.

LANGUAGE: markdown
CODE:
- `npm run start` or `yarn start` or `pnpm start` or `bun start`

----------------------------------------

TITLE: Disabling Queries with enabled Option in TanStack Query (TSX)
DESCRIPTION: This example demonstrates how to disable a query using the 'enabled' option set to false. It shows how to manually trigger the query using the 'refetch' function and handle different query states.

LANGUAGE: tsx
CODE:
function Todos() {
  const { isLoading, isError, data, error, refetch, isFetching } = useQuery({
    queryKey: ['todos'],
    queryFn: fetchTodoList,
    enabled: false,
  })

  return (
    <div>
      <button onClick={() => refetch()}>Fetch Todos</button>

      {data ? (
        <>
          <ul>
            {data.map((todo) => (
              <li key={todo.id}>{todo.title}</li>
            ))}
          </ul>
        </>
      ) : isError ? (
        <span>Error: {error.message}</span>
      ) : isLoading ? (
        <span>Loading...</span>
      ) : (
        <span>Not ready ...</span>
      )}

      <div>{isFetching ? 'Fetching...' : null}</div>
    </div>
  )
}

----------------------------------------

TITLE: Configuring QueryClient with Persister
DESCRIPTION: Example of creating a QueryClient with experimental_createPersister configuration using AsyncStorage for React Native.

LANGUAGE: tsx
CODE:
import AsyncStorage from '@react-native-async-storage/async-storage'
import { QueryClient } from '@tanstack/react-query'
import { experimental_createPersister } from '@tanstack/query-persist-client-core'

const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      gcTime: 1000 * 30, // 30 seconds
      persister: experimental_createPersister({
        storage: AsyncStorage,
        maxAge: 1000 * 60 * 60 * 12, // 12 hours
      }),
    },
  },
})

----------------------------------------

TITLE: Starting Svelte Development Server
DESCRIPTION: Commands for starting the development server, with options to automatically open in a browser tab. Requires dependencies to be installed first via package manager.

LANGUAGE: bash
CODE:
npm run dev

# or start the server and open the app in a new browser tab
npm run dev -- --open

----------------------------------------

TITLE: Setting Window Focus Refetching for Individual Queries
DESCRIPTION: Demonstrates how to disable window focus refetching for a specific query using the injectQuery hook. This configuration applies only to the individual query instance.

LANGUAGE: typescript
CODE:
injectQuery(() => ({
  queryKey: ['todos'],
  queryFn: fetchTodos,
  refetchOnWindowFocus: false,
}))

----------------------------------------

TITLE: Creating New Svelte Project with create-svelte
DESCRIPTION: Commands to create a new Svelte project either in the current directory or in a specified directory using create-svelte.

LANGUAGE: bash
CODE:
# create a new project in the current directory
npm create svelte@latest

# create a new project in my-app
npm create svelte@latest my-app

----------------------------------------

TITLE: Mutation Options Type Configuration
DESCRIPTION: Shows how to use mutationOptions helper to type-safe mutation configurations with proper inference of success callback parameter types.

LANGUAGE: typescript
CODE:
export class QueriesService {
  private http = inject(HttpClient)

  updatePost(id: number) {
    return mutationOptions({
      mutationFn: (post: Post) => Promise.resolve(post),
      mutationKey: ['updatePost', id],
      onSuccess: (newPost) => {
        //           ^? newPost: Post
        this.queryClient.setQueryData(['posts', id], newPost)
      },
    })
  }
}

----------------------------------------

TITLE: Checking Current Online State - TSX
DESCRIPTION: Shows how to retrieve the current online state using the OnlineManager's isOnline method.

LANGUAGE: tsx
CODE:
const isOnline = onlineManager.isOnline()

----------------------------------------

TITLE: Defining TypeScript Types for Svelte Components
DESCRIPTION: Example of creating TypeScript type definitions for a Svelte component in an index.d.ts file. This allows IDEs to provide intellisense for the component.

LANGUAGE: typescript
CODE:
import { SvelteComponent } from 'svelte'
export class MyComponent extends SvelteComponent<{ foo: string }> {}

----------------------------------------

TITLE: Correct Usage of TanStack Query Hook Dependencies in React
DESCRIPTION: Example demonstrating the proper way to use TanStack Query hook return values in dependency arrays by destructuring specific methods needed, ensuring referential stability.

LANGUAGE: tsx
CODE:
/* eslint "@tanstack/query/no-unstable-deps": "warn" */
import { useCallback } from 'React'
import { useMutation } from '@tanstack/react-query'

function Component() {
  const { mutate } = useMutation({ mutationFn: (value: string) => value })
  const callback = useCallback(() => {
    mutate('hello')
  }, [mutate])
  return null
}

----------------------------------------

TITLE: Creating New SolidStart Project
DESCRIPTION: Commands for initializing a new SolidStart project either in the current directory or in a specified folder using the Solid CLI.

LANGUAGE: bash
CODE:
# create a new project in the current directory
npm init solid@latest

# create a new project in my-app
npm init solid@latest my-app

----------------------------------------

TITLE: Prefetching Data in SvelteKit Load Function
DESCRIPTION: Demonstrates how to prefetch data in a SvelteKit load function. This data can be passed to the createQuery function's initialData option for immediate availability on the client.

LANGUAGE: typescript
CODE:
export async function load() {
  const posts = await getPosts()
  return { posts }
}

----------------------------------------

TITLE: Correct QueryClient Instantiation Outside Component
DESCRIPTION: Demonstrates creating a QueryClient instance outside the component scope, ensuring a single instance is shared across the application.

LANGUAGE: tsx
CODE:
const queryClient = new QueryClient()
function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <Home />
    </QueryClientProvider>
  )
}

----------------------------------------

TITLE: Installing and Running TanStack Query Star Wars Example
DESCRIPTION: Command line instructions for setting up and running the Star Wars example project. Requires Node.js and npm to be installed.

LANGUAGE: bash
CODE:
npm install
npm run dev

----------------------------------------

TITLE: Configuring Retry Attempts for Individual Queries in Angular with TanStack Query
DESCRIPTION: This snippet shows how to set a specific number of retry attempts for an individual query using the injectQuery function. It configures a query to retry 10 times before displaying an error.

LANGUAGE: typescript
CODE:
import { injectQuery } from '@tanstack/angular-query-experimental'

// Make a specific query retry a certain number of times
const result = injectQuery(() => ({
  queryKey: ['todos', 1],
  queryFn: fetchTodoListPage,
  retry: 10, // Will retry failed requests 10 times before displaying an error
}))

----------------------------------------

TITLE: Building Svelte Project for Production
DESCRIPTION: Command to create a production-ready build of the Svelte application, which can be previewed using the preview command.

LANGUAGE: bash
CODE:
npm run build

----------------------------------------

TITLE: Custom Configuration of TanStack Query ESLint Plugin with Flat Config
DESCRIPTION: JavaScript code to manually configure specific rules for the ESLint plugin in a flat config file (eslint.config.js).

LANGUAGE: javascript
CODE:
import pluginQuery from '@tanstack/eslint-plugin-query'

export default [
  {
    plugins: {
      '@tanstack/query': pluginQuery,
    },
    rules: {
      '@tanstack/query/exhaustive-deps': 'error',
    },
  },
  // Any other config...
]

----------------------------------------

TITLE: Installing Dependencies for TanStack Query Example (Shell)
DESCRIPTION: Command to install project dependencies using pnpm package manager.

LANGUAGE: shell
CODE:
pnpm install

----------------------------------------

TITLE: Using HydrationBoundary Component in TanStack Query (TypeScript/React)
DESCRIPTION: The HydrationBoundary component adds a previously dehydrated state into the queryClient. It's used in React applications to hydrate query data, typically after server-side rendering.

LANGUAGE: tsx
CODE:
import { HydrationBoundary } from '@tanstack/react-query'

function App() {
  return <HydrationBoundary state={dehydratedState}>...</HydrationBoundary>
}

----------------------------------------

TITLE: Configuring TanStack Query ESLint Plugin with Legacy Config
DESCRIPTION: JSON configuration to set up the ESLint plugin using the recommended configuration in a legacy .eslintrc file.

LANGUAGE: json
CODE:
{
  "extends": ["plugin:@tanstack/query/recommended"]
}

----------------------------------------

TITLE: Correct QueryClient Instantiation with useState
DESCRIPTION: Shows the recommended pattern of using useState to create a stable QueryClient instance that persists across renders.

LANGUAGE: tsx
CODE:
function App() {
  const [queryClient] = useState(() => new QueryClient())
  return (
    <QueryClientProvider client={queryClient}>
      <Home />
    </QueryClientProvider>
  )
}

----------------------------------------

TITLE: Installing and Running TanStack Query Example in Shell
DESCRIPTION: These commands install the necessary dependencies and start the TanStack Query example project. First, it installs all required packages using npm, then it runs the start script to launch the example.

LANGUAGE: shell
CODE:
npm install
npm run start

----------------------------------------

TITLE: Defining createInfiniteQuery Function in TypeScript
DESCRIPTION: This code snippet defines the createInfiniteQuery function with generic type parameters and its input parameters. It creates an infinite query with options and an optional queryClient, returning a CreateInfiniteQueryResult.

LANGUAGE: typescript
CODE:
function createInfiniteQuery<
  TQueryFnData,
  TError,
  TData,
  TQueryKey,
  TPageParam,
>(options, queryClient?): CreateInfiniteQueryResult<TData, TError>

----------------------------------------

TITLE: Installing Dependencies and Starting Development Server
DESCRIPTION: Commands for installing project dependencies using various package managers (npm, yarn, pnpm, bun) and starting the development server.

LANGUAGE: bash
CODE:
npm install
# or
yarn
# or
pnpm i
# or
bun i

LANGUAGE: bash
CODE:
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev

----------------------------------------

TITLE: Using skipToken for Typesafe Query Disabling in TanStack Query (TSX)
DESCRIPTION: This example illustrates the use of 'skipToken' to disable a query in a type-safe manner. The query is disabled when the filter is undefined or empty, providing better TypeScript integration.

LANGUAGE: tsx
CODE:
import { skipToken, useQuery } from '@tanstack/react-query'

function Todos() {
  const [filter, setFilter] = React.useState<string | undefined>()

  const { data } = useQuery({
    queryKey: ['todos', filter],
    // ‚¨áÔ∏è disabled as long as the filter is undefined or empty
    queryFn: filter ? () => fetchTodos(filter) : skipToken,
  })

  return (
    <div>
      // üöÄ applying the filter will enable and execute the query
      <FiltersForm onApply={setFilter} />
      {data && <TodosTable data={data} />}
    </div>
  )
}

----------------------------------------

TITLE: Installing Dependencies and Starting Development Server
DESCRIPTION: Commands for installing project dependencies using various package managers (npm, yarn, pnpm, bun) and starting the development server.

LANGUAGE: shell
CODE:
npm install
# or
yarn
# or
pnpm i
# or
bun i

LANGUAGE: shell
CODE:
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev

----------------------------------------

TITLE: Setting Up Local Documentation Preview for TanStack Query
DESCRIPTION: This snippet shows the process of cloning the necessary repositories and setting up the local environment to preview documentation changes for TanStack Query.

LANGUAGE: bash
CODE:
mkdir tanstack
cd tanstack
git clone git@github.com:TanStack/query.git
git clone git@github.com:TanStack/tanstack.com.git --depth=1 --single-branch --branch=main
cd tanstack.com
pnpm i
pnpm dev

----------------------------------------

TITLE: Installing Dependencies and Running TanStack Query Example
DESCRIPTION: These commands install the necessary dependencies and start the development server for the TanStack Query example project. The first command installs all required packages, while the second command runs the development server.

LANGUAGE: shell
CODE:
npm install
npm run dev

----------------------------------------

TITLE: Implementing provideAngularQuery in Standalone Angular Application
DESCRIPTION: Demonstrates how to use provideAngularQuery in a standalone Angular application. It imports necessary modules and bootstraps the application with the provided QueryClient.

LANGUAGE: typescript
CODE:
import {
  provideAngularQuery,
  QueryClient,
} from '@tanstack/angular-query-experimental'

bootstrapApplication(AppComponent, {
  providers: [provideAngularQuery(new QueryClient())],
})

----------------------------------------

TITLE: Creating Defined Query with Initial Data in TypeScript
DESCRIPTION: First overload of createQuery that handles defined initial data options. Takes generic type parameters for query function data, error type, transformed data, and query key. Returns a DefinedCreateQueryResult.

LANGUAGE: typescript
CODE:
function createQuery<TQueryFnData, TError, TData, TQueryKey>(
  options,
  queryClient?,
): DefinedCreateQueryResult<TData, TError>

----------------------------------------

TITLE: Installing and Running React Router Example with TanStack Query
DESCRIPTION: Commands to install dependencies and start the development server for a React Router example project using TanStack Query. Users need to run these commands in the project directory.

LANGUAGE: Markdown
CODE:
# React Router Example

To run this example:

- `npm install`
- `npm run dev`

----------------------------------------

TITLE: Global State Before TanStack Query
DESCRIPTION: Example showing typical global state structure including both server and client state before implementing TanStack Query.

LANGUAGE: tsx
CODE:
const globalState = {
  projects,
  teams,
  tasks,
  users,
  themeMode,
  sidebarStatus,
}

----------------------------------------

TITLE: Running TanStack Query Examples
DESCRIPTION: This snippet provides instructions for running examples in the TanStack Query project, including installing dependencies and running the development server.

LANGUAGE: bash
CODE:
pnpm install
pnpm run watch
pnpm run dev

----------------------------------------

TITLE: Installing Solid Query Devtools via pnpm
DESCRIPTION: Command to install the Solid Query devtools package using pnpm.

LANGUAGE: bash
CODE:
pnpm add @tanstack/solid-query-devtools

----------------------------------------

TITLE: Installing and Running TanStack Query Example
DESCRIPTION: Commands to install npm dependencies and start the development server for a TanStack Query example project. Requires Node.js and npm to be installed.

LANGUAGE: bash
CODE:
npm install
npm run dev

----------------------------------------

TITLE: Installing TanStack Query Angular Package
DESCRIPTION: Different package manager commands for installing the TanStack Query Angular experimental package.

LANGUAGE: bash
CODE:
$ npm i @tanstack/angular-query-experimental

LANGUAGE: bash
CODE:
$ pnpm add @tanstack/angular-query-experimental

LANGUAGE: bash
CODE:
$ yarn add @tanstack/angular-query-experimental

LANGUAGE: bash
CODE:
$ bun add @tanstack/angular-query-experimental

----------------------------------------

TITLE: Basic Query Key Patterns in TanStack Query
DESCRIPTION: Demonstrates basic query key patterns for simple queries using injectQuery. Shows how to structure query keys for both single-level and nested key structures.

LANGUAGE: typescript
CODE:
// A list of todos
injectQuery(() => ({ queryKey: ['todos'], ... }))

// Something else, whatever!
injectQuery(() => ({ queryKey: ['something', 'special'], ... }))

----------------------------------------

TITLE: Declaring createQueries Function Signature in TypeScript
DESCRIPTION: Type definition for the createQueries function that handles multiple parallel queries in Svelte. The function accepts query configurations and an optional QueryClient instance, returning a Readable store containing the combined query results.

LANGUAGE: typescript
CODE:
function createQueries<T, TCombinedResult>(
  __namedParameters,
  queryClient?,
): Readable<TCombinedResult>

----------------------------------------

TITLE: Installing Dependencies for TanStack Query Example
DESCRIPTION: Commands to install project dependencies using different package managers. This step is required before running the example.

LANGUAGE: shell
CODE:
npm install

LANGUAGE: shell
CODE:
yarn

LANGUAGE: shell
CODE:
pnpm i

LANGUAGE: shell
CODE:
bun i

----------------------------------------

TITLE: Using Static Placeholder Data in TanStack Query (TypeScript)
DESCRIPTION: This snippet demonstrates how to use static placeholder data in a TanStack Query. It sets up a query for fetching todos with a static placeholderData value.

LANGUAGE: typescript
CODE:
class TodosComponent {
  result = injectQuery(() => ({
    queryKey: ['todos'],
    queryFn: () => fetch('/todos'),
    placeholderData: placeholderTodos,
  }))
}

----------------------------------------

TITLE: Installing and Running TanStack Query Example
DESCRIPTION: Commands to install dependencies and start the development server for a TanStack Query example project

LANGUAGE: shell
CODE:
npm install
npm run dev

----------------------------------------

TITLE: Handling Error States in Optimistic UI Updates with React Query
DESCRIPTION: This snippet demonstrates how to handle error states in optimistic UI updates. It shows the errored item in red and provides a retry button using the mutation's mutate function.

LANGUAGE: tsx
CODE:
{
  isError && (
    <li style={{ color: 'red' }}>
      {variables}
      <button onClick={() => mutate(variables)}>Retry</button>
    </li>
  )
}

----------------------------------------

TITLE: Defining Query and Mutation Interfaces for Angular
DESCRIPTION: This snippet defines interfaces for base query and mutation operations in Angular using TanStack Query. It includes types for query options, results, and mutation options tailored for Angular's reactive programming model.

LANGUAGE: TypeScript
CODE:
export interface BaseMutationNarrowing<TData = unknown, TError = DefaultError, TVariables = unknown, TContext = unknown> {
    isError: SignalFunction<(this: CreateMutationResult<TData, TError, TVariables, TContext>) => this is CreateMutationResult<TData, TError, TVariables, TContext, CreateStatusBasedMutationResult<'error', TData, TError, TVariables, TContext>>>;
    isIdle: SignalFunction<(this: CreateMutationResult<TData, TError, TVariables, TContext>) => this is CreateMutationResult<TData, TError, TVariables, TContext, CreateStatusBasedMutationResult<'idle', TData, TError, TVariables, TContext>>>;
    isPending: SignalFunction<(this: CreateMutationResult<TData, TError, TVariables, TContext>) => this is CreateMutationResult<TData, TError, TVariables, TContext, CreateStatusBasedMutationResult<'pending', TData, TError, TVariables, TContext>>>;
    isSuccess: SignalFunction<(this: CreateMutationResult<TData, TError, TVariables, TContext>) => this is CreateMutationResult<TData, TError, TVariables, TContext, CreateStatusBasedMutationResult<'success', TData, TError, TVariables, TContext>>>;
}

export interface BaseQueryNarrowing<TData = unknown, TError = DefaultError> {
    isError: (this: CreateBaseQueryResult<TData, TError>) => this is CreateBaseQueryResult<TData, TError, CreateStatusBasedQueryResult<'error', TData, TError>>;
    isPending: (this: CreateBaseQueryResult<TData, TError>) => this is CreateBaseQueryResult<TData, TError, CreateStatusBasedQueryResult<'pending', TData, TError>>;
    isSuccess: (this: CreateBaseQueryResult<TData, TError>) => this is CreateBaseQueryResult<TData, TError, CreateStatusBasedQueryResult<'success', TData, TError>>;
}

export type CreateBaseMutationResult<TData = unknown, TError = DefaultError, TVariables = unknown, TContext = unknown> = Override<MutationObserverResult<TData, TError, TVariables, TContext>, {
    mutate: CreateMutateFunction<TData, TError, TVariables, TContext>;
}> & {
    mutateAsync: CreateMutateAsyncFunction<TData, TError, TVariables, TContext>;
};

export interface CreateBaseQueryOptions<TQueryFnData = unknown, TError = DefaultError, TData = TQueryFnData, TQueryData = TQueryFnData, TQueryKey extends QueryKey = QueryKey> extends QueryObserverOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey> {
}

----------------------------------------

TITLE: Running Development Server for TanStack Query Dependent Queries Example
DESCRIPTION: Commands for starting the development server using either npm or yarn. This allows you to run and interact with the dependent queries example.

LANGUAGE: Shell
CODE:
npm run dev

LANGUAGE: Shell
CODE:
yarn dev

----------------------------------------

TITLE: Running Angular E2E Tests
DESCRIPTION: Command to run end-to-end tests using the configured testing platform

LANGUAGE: bash
CODE:
ng e2e

----------------------------------------

TITLE: Initializing TanStack Query in NgModule-based Angular
DESCRIPTION: Configuration code for initializing TanStack Query in a traditional NgModule-based Angular application.

LANGUAGE: typescript
CODE:
import { provideHttpClient } from '@angular/common/http'
import {
  provideTanStackQuery,
  QueryClient,
} from '@tanstack/angular-query-experimental'

@NgModule({
  declarations: [AppComponent],
  imports: [BrowserModule],
  providers: [provideTanStackQuery(new QueryClient())],
  bootstrap: [AppComponent],
})

----------------------------------------

TITLE: Installing Dependencies and Running TanStack Query Example
DESCRIPTION: These commands install the necessary dependencies and start the development server for the TanStack Query example project. Run these commands in the project directory to set up and run the example.

LANGUAGE: shell
CODE:
npm install
npm run dev

----------------------------------------

TITLE: TypeScript Function Definition - useHydrate
DESCRIPTION: Type declaration for the useHydrate function that accepts optional state, options, and queryClient parameters. The function is used for hydrating query client state and returns void. Located in the svelte-query package.

LANGUAGE: typescript
CODE:
function useHydrate(state?, options?, queryClient?): void

----------------------------------------

TITLE: Installing Dependencies for Nuxt 3 Project
DESCRIPTION: Command to install all required project dependencies using Yarn package manager.

LANGUAGE: bash
CODE:
yarn install

----------------------------------------

TITLE: Bi-directional Infinite Query Configuration
DESCRIPTION: Configuration for implementing bi-directional infinite queries with previous and next page parameters.

LANGUAGE: tsx
CODE:
useInfiniteQuery({
  queryKey: ['projects'],
  queryFn: fetchProjects,
  initialPageParam: 0,
  getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
  getPreviousPageParam: (firstPage, pages) => firstPage.prevCursor,
})

----------------------------------------

TITLE: Installing and Running TanStack Query Example - Shell Commands
DESCRIPTION: Two shell commands to set up and run a TanStack Query example project. First installs the required dependencies using npm install, then starts the application using npm run start.

LANGUAGE: shell
CODE:
npm install
npm run start

----------------------------------------

TITLE: Installing Dependencies and Running TanStack Query Example
DESCRIPTION: These commands install the necessary dependencies and start the development server for the TanStack Query example project. First, 'npm install' fetches and installs all required packages. Then, 'npm run dev' launches the development server, likely using a bundler like Vite or Webpack.

LANGUAGE: shell
CODE:
npm install
npm run dev

----------------------------------------

TITLE: Installing ESLint Plugin Query
DESCRIPTION: Commands for installing the recommended ESLint Plugin Query to catch bugs and inconsistencies while coding with React Query.

LANGUAGE: bash
CODE:
npm i -D @tanstack/eslint-plugin-query

LANGUAGE: bash
CODE:
pnpm add -D @tanstack/eslint-plugin-query

LANGUAGE: bash
CODE:
yarn add -D @tanstack/eslint-plugin-query

LANGUAGE: bash
CODE:
bun add -D @tanstack/eslint-plugin-query

----------------------------------------

TITLE: Rendering Infinite Query Results in Angular Template
DESCRIPTION: This Angular template demonstrates how to render the results of an infinite query, including handling loading and error states, and implementing a 'Load More' button.

LANGUAGE: angular-html
CODE:
<div>
  @if (query.isPending()) {
  <p>Loading...</p>
  } @else if (query.isError()) {
  <span>Error: {{ query?.error().message }}</span>
  } @else { @for (page of query?.data().pages; track $index) { @for (project of
  page.data; track project.id) {
  <p>{{ project.name }} {{ project.id }}</p>
  } }
  <div>
    <button (click)="query.fetchNextPage()" [disabled]="nextButtonDisabled()">
      {{ nextButtonText() }}
    </button>
  </div>
  }
</div>

----------------------------------------

TITLE: Defining useIsRestoring Function in TypeScript
DESCRIPTION: Function declaration for useIsRestoring that returns a Svelte Readable store containing a boolean value. This function is used to track the restoration state in TanStack Query's Svelte integration.

LANGUAGE: typescript
CODE:
function useIsRestoring(): Readable<boolean>

----------------------------------------

TITLE: Running TanStack Query Example in Development Mode
DESCRIPTION: Commands for starting the development server using either npm or yarn package managers.

LANGUAGE: markdown
CODE:
- `npm run dev` or `yarn dev`

----------------------------------------

TITLE: Configuring TanStack Query Devtools Loading in Angular
DESCRIPTION: These snippets show different ways to configure when the TanStack Query devtools are loaded in an Angular application, including automatic, always-on, and disabled modes.

LANGUAGE: typescript
CODE:
provideTanStackQuery(new QueryClient(), withDevtools())

// which is equivalent to
provideTanStackQuery(
  new QueryClient(),
  withDevtools(() => ({ loadDevtools: 'auto' })),
)

LANGUAGE: typescript
CODE:
provideTanStackQuery(
  new QueryClient(),
  withDevtools(() => ({ loadDevtools: true })),
)

LANGUAGE: typescript
CODE:
provideTanStackQuery(
  new QueryClient(),
  withDevtools(() => ({ loadDevtools: false })),
)

----------------------------------------

TITLE: Function-based Placeholder Data in TanStack Query
DESCRIPTION: Illustrates using a function for placeholder data that can access previous query data, useful for maintaining data visibility during query transitions.

LANGUAGE: tsx
CODE:
const result = useQuery({
  queryKey: ['todos', id],
  queryFn: () => fetch(`/todos/${id}`),
  placeholderData: (previousData, previousQuery) => previousData,
})

----------------------------------------

TITLE: Installing Dependencies and Running TanStack Query Example
DESCRIPTION: These commands install the necessary dependencies and start the development server for the TanStack Query example project. First, it installs all required packages, then it runs the development server.

LANGUAGE: shell
CODE:
npm install
npm run dev

----------------------------------------

TITLE: Installing and Running TanStack Query Example
DESCRIPTION: Commands for setting up and running the TanStack Query example with Next.js. Includes package installation and development server startup.

LANGUAGE: bash
CODE:
npm install
npm run dev

----------------------------------------

TITLE: Using Prefetched Data in Svelte Query Component
DESCRIPTION: Shows how to use prefetched data from a SvelteKit load function in a Svelte Query component. The data is passed to the createQuery function's initialData option.

LANGUAGE: svelte
CODE:
<script>
  import { createQuery } from '@tanstack/svelte-query'
  import type { PageData } from './$types'

  export let data: PageData

  const query = createQuery({
    queryKey: ['posts'],
    queryFn: getPosts,
    initialData: data.posts,
  })
</script>

----------------------------------------

TITLE: Retrieving QueryClient from Svelte Context in TypeScript
DESCRIPTION: This function retrieves a QueryClient instance from Svelte's context. It doesn't take any parameters and returns a QueryClient object. The function is defined in the svelte-query package of the TanStack Query library.

LANGUAGE: TypeScript
CODE:
function getQueryClientContext(): QueryClient

----------------------------------------

TITLE: Installing and Running TanStack Query Angular Example
DESCRIPTION: Commands for installing dependencies and starting the example application using various package managers (npm, yarn, pnpm, or bun).

LANGUAGE: shell
CODE:
npm install
npm run start

LANGUAGE: shell
CODE:
yarn
yarn start

LANGUAGE: shell
CODE:
pnpm i
pnpm start

LANGUAGE: shell
CODE:
bun i
bun start

----------------------------------------

TITLE: Using a Function for Initial Data in TanStack Query (TypeScript)
DESCRIPTION: Demonstrates how to use a function to provide initial data for a query, useful when the initial data is expensive to compute.

LANGUAGE: typescript
CODE:
result = injectQuery(() => ({
  queryKey: ['todos'],
  queryFn: () => fetch('/todos'),
  initialData: () => getExpensiveTodos(),
}))

----------------------------------------

TITLE: Installing Dependencies for TanStack Query Example
DESCRIPTION: Commands for installing project dependencies using either npm or yarn package managers.

LANGUAGE: markdown
CODE:
- `npm install` or `yarn`

----------------------------------------

TITLE: Todo Creation Form with Mutation in Angular
DESCRIPTION: Illustrates integrating a mutation with a reactive form in Angular. It includes form validation, error handling, and triggering the mutation on form submission.

LANGUAGE: angular-ts
CODE:
@Component({
  standalone: true,
  selector: 'todo-item',
  imports: [ReactiveFormsModule],
  template: `
    <form [formGroup]="todoForm" (ngSubmit)="onCreateTodo()">
      @if (mutation.error()) {
        <h5 (click)="mutation.reset()">{{ mutation.error() }}</h5>
      }
      <input type="text" formControlName="title" />
      <br />
      <button type="submit">Create Todo</button>
    </form>
  `,
})
export class TodosComponent {
  mutation = injectMutation(() => ({
    mutationFn: createTodo,
  }))

  fb = inject(NonNullableFormBuilder)

  todoForm = this.fb.group({
    title: this.fb.control('', {
      validators: [Validators.required],
    }),
  })

  title = toSignal(this.todoForm.controls.title.valueChanges, {
    initialValue: '',
  })

  onCreateTodo = () => {
    this.mutation.mutate(this.title())
  }
}

----------------------------------------

TITLE: Running TanStack Query Example in Development Mode
DESCRIPTION: Commands to start the development server for the TanStack Query example using different package managers. This will run the example application.

LANGUAGE: shell
CODE:
npm run dev

LANGUAGE: shell
CODE:
yarn dev

LANGUAGE: shell
CODE:
pnpm dev

LANGUAGE: shell
CODE:
bun dev

----------------------------------------

TITLE: Implementing provideAngularQuery in NgModule-based Angular Application
DESCRIPTION: Shows how to use provideAngularQuery in an NgModule-based Angular application. It sets up the necessary imports and providers within the NgModule decorator.

LANGUAGE: typescript
CODE:
import {
  provideAngularQuery,
  QueryClient,
} from '@tanstack/angular-query-experimental'

@NgModule({
  declarations: [AppComponent],
  imports: [BrowserModule],
  providers: [provideAngularQuery(new QueryClient())],
  bootstrap: [AppComponent],
})
export class AppModule {}

----------------------------------------

TITLE: Starting TanStack Query Angular Example
DESCRIPTION: Commands for starting the development server using various package managers including npm, yarn, pnpm, and bun.

LANGUAGE: shell
CODE:
npm run start
# or
yarn start
# or
pnpm start
# or
bun start

----------------------------------------

TITLE: Manually Setting Focus State in TanStack Query
DESCRIPTION: Examples of manually controlling the focus state using setFocused method. Shows how to set focused, unfocused states and reset to default focus check.

LANGUAGE: tsx
CODE:
import { focusManager } from '@tanstack/react-query'

// Set focused
focusManager.setFocused(true)

// Set unfocused
focusManager.setFocused(false)

// Fallback to the default focus check
focusManager.setFocused(undefined)

----------------------------------------

TITLE: Retrieving Data for Specific Mutations by mutationKey in React Query
DESCRIPTION: This example shows how to use useMutationState to get data for specific mutations identified by their mutationKey. It demonstrates defining a mutation with useMutation and then accessing its state data using useMutationState.

LANGUAGE: tsx
CODE:
import { useMutation, useMutationState } from '@tanstack/react-query'

const mutationKey = ['posts']

// Some mutation that we want to get the state for
const mutation = useMutation({
  mutationKey,
  mutationFn: (newPost) => {
    return axios.post('/posts', newPost)
  },
})

const data = useMutationState({
  // this mutation key needs to match the mutation key of the given mutation (see above)
  filters: { mutationKey },
  select: (mutation) => mutation.state.data,
})

----------------------------------------

TITLE: Creating New Svelte Project with NPM
DESCRIPTION: Commands to create a new Svelte project either in the current directory or in a specified directory using create-svelte.

LANGUAGE: bash
CODE:
# create a new project in the current directory
npm create svelte@latest

# create a new project in my-app
npm create svelte@latest my-app

----------------------------------------

TITLE: Using Suspense with TanStack Query in SolidJS
DESCRIPTION: This example shows how to use Suspense with TanStack Query in SolidJS. It demonstrates that Suspense works out of the box for queries when data is accessed inside a Suspense boundary.

LANGUAGE: tsx
CODE:
import { For, Suspense } from 'solid-js'

function Example() {
  const query = createQuery(() => ({
    queryKey: ['todos'],
    queryFn: fetchTodos,
  }))
  return (
    <div>
      {/* ‚úÖ Will trigger loading fallback, data accessed in a suspense boundary. */}
      <Suspense fallback={'Loading...'}>
        <For each={query.data}>{(todo) => <div>{todo.title}</div>}</For>
      </Suspense>
      {/* ‚ùå Will not trigger loading fallback, data not accessed in a suspense boundary. */}
      <For each={query.data}>{(todo) => <div>{todo.title}</div>}</For>
    </div>
  )
}

----------------------------------------

TITLE: Configuring Infinite Query Options with Undefined Initial Data in TypeScript
DESCRIPTION: Function implementation for configuring infinite query options where initial data is undefined. It provides type-safe query configuration with generic type parameters for query data, error handling, query key, and pagination.

LANGUAGE: typescript
CODE:
function infiniteQueryOptions<
  TQueryFnData,
  TError,
  TData,
  TQueryKey,
  TPageParam,
>(
  options,
): UndefinedInitialDataInfiniteOptions<
  TQueryFnData,
  TError,
  TData,
  TQueryKey,
  TPageParam
> &
  object

----------------------------------------

TITLE: Prefetching Query Data in SvelteKit Page Load Function
DESCRIPTION: Demonstrates how to prefetch query data in a SvelteKit page load function using the queryClient.prefetchQuery method. This ensures data is available in the cache before rendering.

LANGUAGE: typescript
CODE:
export async function load({ parent, fetch }) {
  const { queryClient } = await parent()

  // You need to use the SvelteKit fetch function here
  await queryClient.prefetchQuery({
    queryKey: ['posts'],
    queryFn: async () => (await fetch('/api/posts')).json(),
  })
}

----------------------------------------

TITLE: Reversed Order Infinite Query
DESCRIPTION: Example of reversing the order of pages in an infinite query using the select option.

LANGUAGE: tsx
CODE:
useInfiniteQuery({
  queryKey: ['projects'],
  queryFn: fetchProjects,
  select: (data) => ({
    pages: [...data.pages].reverse(),
    pageParams: [...data.pageParams].reverse(),
  }),
})

----------------------------------------

TITLE: Creating External Store in Svelte TypeScript
DESCRIPTION: Demonstrates how to create a simple external store using Svelte's writable store for state management that persists during Hot Module Replacement (HMR). This approach helps retain component state that would otherwise be lost during development hot-reloading.

LANGUAGE: typescript
CODE:
// store.ts
// An extremely simple external store
import { writable } from 'svelte/store'
export default writable(0)

----------------------------------------

TITLE: Starting Next.js Development Server
DESCRIPTION: Commands to start the Next.js development server using different package managers (npm, yarn, or pnpm). The server will run on localhost:3000 by default.

LANGUAGE: bash
CODE:
npm run dev
# or
yarn dev
# or
pnpm dev

----------------------------------------

TITLE: Configuring Query Options in tanstack-query (TSX)
DESCRIPTION: The queryOptions function is used to set up query parameters. It accepts a queryKey and additional options that are compatible with useQuery. Some options may not affect certain functions like queryClient.prefetchQuery, but they are still type-safe.

LANGUAGE: tsx
CODE:
queryOptions({
  queryKey,
  ...options,
})

----------------------------------------

TITLE: Initializing MutationCache in TanStack Query
DESCRIPTION: Creates a new MutationCache instance with error and success callback handlers. The cache serves as storage for mutations and provides global event handling capabilities.

LANGUAGE: tsx
CODE:
import { MutationCache } from '@tanstack/react-query'

const mutationCache = new MutationCache({
  onError: (error) => {
    console.log(error)
  },
  onSuccess: (data) => {
    console.log(data)
  },
})

----------------------------------------

TITLE: Defining DefinedCreateBaseQueryResult Type Alias in TypeScript
DESCRIPTION: Defines a type alias for DefinedCreateBaseQueryResult that takes two generic type parameters TData and TError. It represents a Readable store of DefinedQueryObserverResult.

LANGUAGE: typescript
CODE:
type DefinedCreateBaseQueryResult<TData, TError>: Readable<DefinedQueryObserverResult<TData, TError>>;

----------------------------------------

TITLE: Query Configuration with Custom staleTime in TSX
DESCRIPTION: Demonstrates setting custom staleTime with initialData to control data freshness duration.

LANGUAGE: tsx
CODE:
const result = useQuery({
  queryKey: ['todos'],
  queryFn: () => fetch('/todos'),
  initialData: initialTodos,
  staleTime: 1000,
})

----------------------------------------

TITLE: Setting Custom Context Key for Vue Query Plugin in TypeScript
DESCRIPTION: This snippet shows how to set a custom context key for the QueryClient when configuring the VueQueryPlugin. This can help avoid name clashing between multiple apps.

LANGUAGE: tsx
CODE:
const vueQueryPluginOptions: VueQueryPluginOptions = {
  queryClientKey: 'Foo',
}
app.use(VueQueryPlugin, vueQueryPluginOptions)

----------------------------------------

TITLE: Default Options for broadcastQueryClient in TanStack Query
DESCRIPTION: This snippet shows the default options for the broadcastQueryClient function. It specifies the default broadcastChannel name as 'tanstack-query' if not provided by the user.

LANGUAGE: tsx
CODE:
{
  broadcastChannel = 'tanstack-query',
}

----------------------------------------

TITLE: Using QueryCache.findAll Method in TanStack Query
DESCRIPTION: Shows how to use findAll to retrieve multiple query instances that match a partial query key pattern.

LANGUAGE: tsx
CODE:
const queries = queryCache.findAll(queryKey)

----------------------------------------

TITLE: Defining useIsFetching Function in TypeScript
DESCRIPTION: This snippet defines the useIsFetching function, which takes optional filters and queryClient parameters. It returns a Readable<number>. The function is likely used to track the number of ongoing fetch operations in a query context.

LANGUAGE: TypeScript
CODE:
function useIsFetching(filters?, queryClient?): Readable<number>

----------------------------------------

TITLE: Defining DefinedInitialDataOptions Type Alias in TypeScript
DESCRIPTION: This code snippet defines the DefinedInitialDataOptions type alias, which extends CreateQueryOptions and includes an initialData property. It uses generic types for query function data, error, data, and query key.

LANGUAGE: typescript
CODE:
type DefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>: CreateQueryOptions<TQueryFnData, TError, TData, TQueryKey> & object;

----------------------------------------

TITLE: Initializing Vue Query with VueQueryPlugin
DESCRIPTION: This snippet demonstrates how to initialize Vue Query by using the VueQueryPlugin. It imports necessary dependencies, creates a Vue app instance, and applies the VueQueryPlugin before mounting the app.

LANGUAGE: tsx
CODE:
import { createApp } from 'vue'
import { VueQueryPlugin } from '@tanstack/vue-query'

import App from './App.vue'

createApp(App).use(VueQueryPlugin).mount('#app')

----------------------------------------

TITLE: Batching Updates with notifyManager.batch in TypeScript
DESCRIPTION: The batch method is used to batch all updates scheduled inside the passed callback. It's primarily used internally to optimize queryClient updating.

LANGUAGE: typescript
CODE:
function batch<T>(callback: () => T): T

----------------------------------------

TITLE: Defining queryOptions Function with Undefined Initial Data in TypeScript
DESCRIPTION: This function overload takes options with undefined initial data and returns an object that includes UndefinedInitialDataOptions and additional properties. It uses the same generic types as the previous overload.

LANGUAGE: typescript
CODE:
function queryOptions<TQueryFnData, TError, TData, TQueryKey>(
  options,
): UndefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey> & object

----------------------------------------

TITLE: Defining infiniteQueryOptions Function in TypeScript
DESCRIPTION: Generic function that creates infinite query options for TanStack Query. Takes type parameters for query function data, error handling, data structure, query key, and page parameters. Returns CreateInfiniteQueryOptions configured with the specified types.

LANGUAGE: typescript
CODE:
function infiniteQueryOptions<
  TQueryFnData,
  TError,
  TData,
  TQueryKey,
  TPageParam,
>(
  options,
): CreateInfiniteQueryOptions<
  TQueryFnData,
  TError,
  TData,
  TQueryFnData,
  TQueryKey,
  TPageParam
>

----------------------------------------

TITLE: Defining CreateBaseQueryResult Type Alias in TypeScript
DESCRIPTION: Defines the CreateBaseQueryResult type alias as a Readable store containing a QueryObserverResult. It has two generic type parameters: TData (defaulting to unknown) and TError (defaulting to DefaultError).

LANGUAGE: TypeScript
CODE:
type CreateBaseQueryResult<TData, TError>: Readable<QueryObserverResult<TData, TError>>;

----------------------------------------

TITLE: Setting Custom Event Listener in OnlineManager - TSX
DESCRIPTION: Demonstrates how to set a custom event listener using NetInfo for React Native applications to monitor network connectivity state changes.

LANGUAGE: tsx
CODE:
import NetInfo from '@react-native-community/netinfo'
import { onlineManager } from '@tanstack/react-query'

onlineManager.setEventListener((setOnline) => {
  return NetInfo.addEventListener((state) => {
    setOnline(!!state.isConnected)
  })
})

----------------------------------------

TITLE: Configuring Batch Notify Function with notifyManager.setBatchNotifyFunction in TypeScript
DESCRIPTION: setBatchNotifyFunction sets the function to use for batched updates. This example shows how to set the batch function in solid-query.

LANGUAGE: typescript
CODE:
import { notifyManager } from '@tanstack/query-core'
import { batch } from 'solid-js'

notifyManager.setBatchNotifyFunction(batch)

----------------------------------------

TITLE: Type Narrowing in Solid Query TypeScript
DESCRIPTION: Demonstrates how to use type narrowing with Solid Query's discriminated union type. Checking the success status makes the data property definitely defined as number.

LANGUAGE: tsx
CODE:
const query = createQuery(() => ({
  queryKey: ['number'],
  queryFn: () => Promise.resolve(5),
}))

if (query.isSuccess) {
  const data = query.data
  //     ^? const data: number
}

----------------------------------------

TITLE: Configuring Retry Strategy for Sync Storage Persister
DESCRIPTION: Example of configuring a retry strategy for the sync storage persister using the removeOldestQuery function to handle persistence failures.

LANGUAGE: tsx
CODE:
const localStoragePersister = createSyncStoragePersister({
  storage: window.localStorage,
  retry: removeOldestQuery,
})

----------------------------------------

TITLE: Creating Batched Calls with notifyManager.batchCalls in TypeScript
DESCRIPTION: batchCalls is a higher-order function that takes a callback and wraps it. All calls to the wrapped function schedule the callback to be run on the next batch.

LANGUAGE: typescript
CODE:
type BatchCallsCallback<T extends Array<unknown>> = (...args: T) => void

function batchCalls<T extends Array<unknown>>(
  callback: BatchCallsCallback<T>,
): BatchCallsCallback<T>

----------------------------------------

TITLE: Type Inference with Data Transformation in Solid Query
DESCRIPTION: Shows how Solid Query infers the correct type when using a select function to transform the query result. The data property is typed as string | undefined after transformation.

LANGUAGE: tsx
CODE:
import { createQuery } from '@tanstack/solid-query'

const query = createQuery(() => ({
  queryKey: ['test'],
  queryFn: () => Promise.resolve(5),
  select: (data) => data.toString(),
}))

query.data
//    ^? (property) data: string | undefined

----------------------------------------

TITLE: Defining CreateMutateFunction Type Alias in TypeScript
DESCRIPTION: This code snippet defines a type alias for CreateMutateFunction, which is a function that takes variable arguments and returns void. It includes generic type parameters for data, error, variables, and context.

LANGUAGE: typescript
CODE:
type CreateMutateFunction<TData, TError, TVariables, TContext>: (...args) => void;

----------------------------------------

TITLE: Handling Form Submission with useMutation in React
DESCRIPTION: Shows how to properly handle form submissions with useMutation in React, addressing the issue of event pooling in React 16 and earlier.

LANGUAGE: tsx
CODE:
// This will work
const CreateTodo = () => {
  const mutation = useMutation({
    mutationFn: (formData) => {
      return fetch('/api', formData)
    },
  })
  const onSubmit = (event) => {
    event.preventDefault()
    mutation.mutate(new FormData(event.target))
  }

  return <form onSubmit={onSubmit}>...</form>
}

----------------------------------------

TITLE: Default Options for Async Storage Persister
DESCRIPTION: Default configuration options for the createAsyncStoragePersister function including key, throttle time, and serialization methods.

LANGUAGE: tsx
CODE:
{
  key = `REACT_QUERY_OFFLINE_CACHE`,
  throttleTime = 1000,
  serialize = JSON.stringify,
  deserialize = JSON.parse,
}

----------------------------------------

TITLE: Incorrect Usage of TanStack Query Hook Dependencies in React
DESCRIPTION: Example showing incorrect usage where the complete mutation object is placed in a useCallback dependency array, which can cause unnecessary re-renders due to referential instability.

LANGUAGE: tsx
CODE:
/* eslint "@tanstack/query/no-unstable-deps": "warn" */
import { useCallback } from 'React'
import { useMutation } from '@tanstack/react-query'

function Component() {
  const mutation = useMutation({ mutationFn: (value: string) => value })
  const callback = useCallback(() => {
    mutation.mutate('hello')
  }, [mutation])
  return null
}

----------------------------------------

TITLE: Reactive Query Options Example
DESCRIPTION: Shows how to use reactive options with createQuery, where query parameters depend on reactive signals.

LANGUAGE: tsx
CODE:
import { createQuery } from '@tanstack/solid-query'

function App() {
  const [filter, setFilter] = createSignal('all')

  const todos = createQuery(() => ({
    queryKey: ['todos', filter()],
    queryFn: async () => {
      const response = await fetch(`/api/todos?filter=${filter()}`)
      if (!response.ok) {
        throw new Error('Failed to fetch todos')
      }
      return response.json()
    },
  }))

  return (
    <div>
      <div>
        <button onClick={() => setFilter('all')}>All</button>
        <button onClick={() => setFilter('active')}>Active</button>
        <button onClick={() => setFilter('completed')}>Completed</button>
      </div>
      <Show when={todos.isError}>
        <div>Error: {todos.error.message}</div>
      </Show>
      <Show when={todos.isLoading}>
        <div>Loading...</div>
      </Show>
      <Show when={todos.isSuccess}>
        <div>
          <div>Todos:</div>
          <ul>
            <For each={todos.data}>{(todo) => <li>{todo.title}</li>}</For>
          </ul>
        </div>
      </Show>
    </div>
  )
}

----------------------------------------

TITLE: Hydrating Query Client in TanStack Query (TypeScript)
DESCRIPTION: The hydrate function adds a previously dehydrated state into a query cache. It's used to restore a frozen query state, typically on the client-side after server-side rendering.

LANGUAGE: tsx
CODE:
import { hydrate } from '@tanstack/react-query'

hydrate(queryClient, dehydratedState, options)

----------------------------------------

TITLE: Installing TanStack Query Async Storage Dependencies
DESCRIPTION: Installation commands for the async storage persister and react query persist client packages using different package managers.

LANGUAGE: bash
CODE:
npm install @tanstack/query-async-storage-persister @tanstack/react-query-persist-client

LANGUAGE: bash
CODE:
pnpm add @tanstack/query-async-storage-persister @tanstack/react-query-persist-client

LANGUAGE: bash
CODE:
yarn add @tanstack/query-async-storage-persister @tanstack/react-query-persist-client

LANGUAGE: bash
CODE:
bun add @tanstack/query-async-storage-persister @tanstack/react-query-persist-client

----------------------------------------

TITLE: Incorrect Usage of Object Rest Destructuring in TanStack Query (TSX)
DESCRIPTION: This snippet demonstrates incorrect usage of object rest destructuring on query results, which can cause unnecessary re-renders by subscribing to all fields of the query result.

LANGUAGE: tsx
CODE:
const useTodos = () => {
  const { data: todos, ...rest } = useQuery({
    queryKey: ['todos'],
    queryFn: () => api.getTodos(),
  })
  return { todos, ...rest }
}

----------------------------------------

TITLE: Safe List End Reached Handler
DESCRIPTION: Example of safely handling infinite loading in a list component.

LANGUAGE: jsx
CODE:
<List onEndReached={() => !isFetchingNextPage && fetchNextPage()} />

----------------------------------------

TITLE: Defining createMutation Function in TypeScript
DESCRIPTION: This code snippet defines the createMutation function with generic type parameters. It takes options and an optional queryClient as parameters, and returns a CreateMutationResult.

LANGUAGE: typescript
CODE:
function createMutation<TData, TError, TVariables, TContext>(
  options,
  queryClient?,
): CreateMutationResult<TData, TError, TVariables, TContext>

----------------------------------------

TITLE: Specifying Type Parameters for CreateBaseQueryOptions in TypeScript
DESCRIPTION: Defines the generic type parameters for the CreateBaseQueryOptions interface, including default types and constraints.

LANGUAGE: TypeScript
CODE:
‚Ä¢ **TQueryFnData** = `unknown`

‚Ä¢ **TError** = `DefaultError`

‚Ä¢ **TData** = `TQueryFnData`

‚Ä¢ **TQueryData** = `TQueryFnData`

‚Ä¢ **TQueryKey** _extends_ `QueryKey` = `QueryKey`

----------------------------------------

TITLE: Accessing Variables of Running Mutations with useMutationState in React Query
DESCRIPTION: This snippet demonstrates how to use the useMutationState hook to retrieve variables of all pending mutations. It uses a filter to select only pending mutations and a selector to extract the variables from each mutation state.

LANGUAGE: tsx
CODE:
import { useMutationState } from '@tanstack/react-query'

const variables = useMutationState({
  filters: { status: 'pending' },
  select: (mutation) => mutation.state.variables,
})

----------------------------------------

TITLE: Correct Property Order for Infinite Query in TanStack Query (TSX)
DESCRIPTION: This example shows the correct property order for useInfiniteQuery, with queryFn placed before getPreviousPageParam and getNextPageParam. This order ensures proper type inference.

LANGUAGE: tsx
CODE:
/* eslint "@tanstack/query/infinite-query-property-order": "warn" */
import { useInfiniteQuery } from '@tanstack/react-query'

const query = useInfiniteQuery({
  queryKey: ['projects'],
  queryFn: async ({ pageParam }) => {
    const response = await fetch(`/api/projects?cursor=${pageParam}`)
    return await response.json()
  },
  initialPageParam: 0,
  getPreviousPageParam: (firstPage) => firstPage.previousId ?? undefined,
  getNextPageParam: (lastPage) => lastPage.nextId ?? undefined,
  maxPages: 3,
})

----------------------------------------

TITLE: Declaring provideQueryClient Function in TypeScript
DESCRIPTION: Function declaration for provideQueryClient that accepts either a QueryClient instance or factory function and returns a Provider. Used to configure TanStack Query client instances for specific parts of an Angular application.

LANGUAGE: typescript
CODE:
function provideQueryClient(value): Provider

----------------------------------------

TITLE: Incorrect Query Key Dependencies in TanStack Query
DESCRIPTION: Examples demonstrating incorrect implementation where the query key doesn't include all variables used in the queryFn. This can lead to caching issues and missed refetches when dependencies change.

LANGUAGE: tsx
CODE:
useQuery({
  queryKey: ['todo'],
  queryFn: () => api.getTodo(todoId),
})

const todoQueries = {
  detail: (id) => ({ queryKey: ['todo'], queryFn: () => api.getTodo(id) }),
}

----------------------------------------

TITLE: Defining QueriesResults Generic Type Alias in TypeScript
DESCRIPTION: A recursive type alias that transforms query parameter arrays into their corresponding result types. It includes depth checking to prevent infinite recursion and handles single elements, empty arrays, and arrays with multiple elements. The type supports custom error and data types through generics.

LANGUAGE: typescript
CODE:
type QueriesResults<T, TResult, TDepth>: TDepth["length"] extends MAXIMUM_DEPTH ? QueryObserverResult[] : T extends [] ? [] : T extends [infer Head] ? [...TResult, GetResults<Head>] : T extends [infer Head, ...(infer Tail)] ? QueriesResults<[...Tail], [...TResult, GetResults<Head>], [...TDepth, 1]> : T extends QueryObserverOptionsForCreateQueries<infer TQueryFnData, infer TError, infer TData, any>[] ? QueryObserverResult<unknown extends TData ? TQueryFnData : TData, unknown extends TError ? DefaultError : TError>[] : QueryObserverResult[];

----------------------------------------

TITLE: Custom Configuration of TanStack Query ESLint Plugin with Legacy Config
DESCRIPTION: JSON configuration to manually set up specific rules for the ESLint plugin in a legacy .eslintrc file.

LANGUAGE: json
CODE:
{
  "plugins": ["@tanstack/query"],
  "rules": {
    "@tanstack/query/exhaustive-deps": "error"
  }
}

----------------------------------------

TITLE: Nullable QueryClient Injection
DESCRIPTION: Injects a QueryClient instance that may return null. Takes InjectOptions as parameter and returns either a QueryClient instance or null.

LANGUAGE: typescript
CODE:
function injectQueryClient(injectOptions): null | QueryClient

----------------------------------------

TITLE: Cache Initial Data with Updated Timestamp in TSX
DESCRIPTION: Demonstrates using cached data with dataUpdatedAt timestamp for proper refetch timing.

LANGUAGE: tsx
CODE:
const result = useQuery({
  queryKey: ['todos', todoId],
  queryFn: () => fetch(`/todos/${todoId}`),
  initialData: () =>
    queryClient.getQueryData(['todos'])?.find((d) => d.id === todoId),
  initialDataUpdatedAt: () =>
    queryClient.getQueryState(['todos'])?.dataUpdatedAt,
})

----------------------------------------

TITLE: Incorrect Property Order for Infinite Query in TanStack Query (TSX)
DESCRIPTION: This example demonstrates incorrect property order for useInfiniteQuery, where getNextPageParam is placed before queryFn. This order can lead to type inference issues.

LANGUAGE: tsx
CODE:
/* eslint "@tanstack/query/infinite-query-property-order": "warn" */
import { useInfiniteQuery } from '@tanstack/react-query'

const query = useInfiniteQuery({
  queryKey: ['projects'],
  getNextPageParam: (lastPage) => lastPage.nextId ?? undefined,
  queryFn: async ({ pageParam }) => {
    const response = await fetch(`/api/projects?cursor=${pageParam}`)
    return await response.json()
  },
  initialPageParam: 0,
  getPreviousPageParam: (firstPage) => firstPage.previousId ?? undefined,
  maxPages: 3,
})

----------------------------------------

TITLE: Defining UndefinedInitialDataOptions Type in TypeScript
DESCRIPTION: A TypeScript type alias that extends CreateQueryOptions to specify query options where initialData must be undefined. Includes generic type parameters for query function data, error handling, transformed data, and query keys.

LANGUAGE: typescript
CODE:
type UndefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>: CreateQueryOptions<TQueryFnData, TError, TData, TQueryKey> & object;

----------------------------------------

TITLE: Installing TanStack Query ESLint Plugin
DESCRIPTION: Commands to install the ESLint plugin for TanStack Query using different package managers.

LANGUAGE: bash
CODE:
npm i -D @tanstack/eslint-plugin-query

LANGUAGE: bash
CODE:
pnpm add -D @tanstack/eslint-plugin-query

LANGUAGE: bash
CODE:
yarn add -D @tanstack/eslint-plugin-query

LANGUAGE: bash
CODE:
bun add -D @tanstack/eslint-plugin-query

----------------------------------------

TITLE: QueryClient Injection with Options
DESCRIPTION: Injects a QueryClient instance with inject options. Returns a QueryClient instance and accepts InjectOptions parameter for configuration.

LANGUAGE: typescript
CODE:
function injectQueryClient(injectOptions): QueryClient

----------------------------------------

TITLE: Defining CreateBaseMutationResult Type Alias in TypeScript
DESCRIPTION: Defines the CreateBaseMutationResult type alias with generic parameters TData, TError, TVariables, and TContext. It extends MutationObserverResult and includes an additional object type.

LANGUAGE: TypeScript
CODE:
type CreateBaseMutationResult<TData, TError, TVariables, TContext>: Override<MutationObserverResult<TData, TError, TVariables, TContext>, object> & object;

----------------------------------------

TITLE: Defining StoreOrVal Type Alias in TypeScript for TanStack Query Svelte
DESCRIPTION: This code snippet defines a type alias called StoreOrVal that can be either of type T or a Svelte Readable store of type T. It's used in the TanStack Query library to allow flexibility in handling both direct values and reactive stores.

LANGUAGE: TypeScript
CODE:
type StoreOrVal<T>: T | Readable<T>;

----------------------------------------

TITLE: Defining CreateInfiniteQueryOptions Interface in TypeScript
DESCRIPTION: Interface declaration for infinite query options with six generic type parameters. The interface extends OmitKeyof of InfiniteQueryObserverOptions while excluding the 'suspense' property. Includes type parameters for query function data, error handling, data transformation, query key, and pagination.

LANGUAGE: typescript
CODE:
interface CreateInfiniteQueryOptions<
  TQueryFnData = unknown,
  TError = DefaultError,
  TData = TQueryFnData,
  TQueryData = TQueryFnData,
  TQueryKey extends QueryKey = QueryKey,
  TPageParam = unknown
> extends OmitKeyof<
  InfiniteQueryObserverOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey, TPageParam>,
  "suspense"
>

----------------------------------------

TITLE: Transformable TanStack Query Hook Usage
DESCRIPTION: Example of a query hook usage that can be transformed by the code mod, where the first argument is an object expression containing queryKey, queryFn and other options.

LANGUAGE: typescript
CODE:
const { data } = useQuery({
  queryKey: ['posts'],
  queryFn: queryFn,
  keepPreviousData: true,
})

----------------------------------------

TITLE: Defining CreateMutationOptions Interface in TypeScript for TanStack Query
DESCRIPTION: This snippet defines the CreateMutationOptions interface, which extends OmitKeyof<MutationObserverOptions> with four type parameters: TData, TError, TVariables, and TContext. It specifies default types for these parameters and omits the '_defaulted' key from MutationObserverOptions.

LANGUAGE: TypeScript
CODE:
interface CreateMutationOptions<TData = unknown, TError = DefaultError, TVariables = void, TContext = unknown> extends OmitKeyof<MutationObserverOptions<TData, TError, TVariables, TContext>, "_defaulted">

----------------------------------------

TITLE: Defining DefinedCreateInfiniteQueryResult Type Alias in TypeScript
DESCRIPTION: This type alias maps a TDefinedInfiniteQueryObserver to signals using MapToSignals. It has three generic type parameters: TData (defaulting to unknown), TError (defaulting to DefaultError), and TDefinedInfiniteQueryObserver (defaulting to DefinedInfiniteQueryObserverResult<TData, TError>).

LANGUAGE: typescript
CODE:
type DefinedCreateInfiniteQueryResult<TData, TError, TDefinedInfiniteQueryObserver>: MapToSignals<TDefinedInfiniteQueryObserver>;

----------------------------------------

TITLE: Defining DefinedCreateQueryResult Type in TypeScript
DESCRIPTION: Defines a type alias that extends DefinedCreateBaseQueryResult with generic parameters TData and TError. TData defaults to unknown and TError defaults to DefaultError. Used for createQuery operations with initialData.

LANGUAGE: typescript
CODE:
type DefinedCreateQueryResult<TData, TError>: DefinedCreateBaseQueryResult<TData, TError>;

----------------------------------------

TITLE: Defining isPending Method in BaseQueryNarrowing Interface
DESCRIPTION: This method checks if the query result is in a pending state. It takes 'this' as a parameter and returns a boolean indicating if the result is of pending type.

LANGUAGE: typescript
CODE:
isPending: (this) => this is CreateBaseQueryResult<TData, TError, CreateStatusBasedQueryResult<"pending", TData, TError>>;

----------------------------------------

TITLE: Defining CreateInfiniteQueryResult Type Alias in TypeScript
DESCRIPTION: This code snippet defines a type alias called CreateInfiniteQueryResult that takes two generic type parameters, TData and TError. It maps signals to an InfiniteQueryObserverResult using the MapToSignals utility type.

LANGUAGE: typescript
CODE:
type CreateInfiniteQueryResult<TData, TError>: MapToSignals<InfiniteQueryObserverResult<TData, TError>>;

----------------------------------------

TITLE: Defining NonUndefinedGuard Type Alias in TypeScript
DESCRIPTION: This code snippet defines a type alias NonUndefinedGuard that takes a type parameter T. It uses a conditional type to return never if T extends undefined, otherwise it returns T. This effectively excludes undefined from the given type.

LANGUAGE: typescript
CODE:
type NonUndefinedGuard<T>: T extends undefined ? never : T;

----------------------------------------

TITLE: Defining CreateMutateAsyncFunction Type Alias in TypeScript
DESCRIPTION: This code snippet defines a type alias named CreateMutateAsyncFunction with four generic type parameters. It is equivalent to the MutateFunction type with the same type parameters.

LANGUAGE: typescript
CODE:
type CreateMutateAsyncFunction<TData, TError, TVariables, TContext>: MutateFunction<TData, TError, TVariables, TContext>;

----------------------------------------

TITLE: Initializing provideAngularQuery Function in TypeScript
DESCRIPTION: Defines the provideAngularQuery function that takes a QueryClient and returns EnvironmentProviders. This function is crucial for setting up TanStack Query in Angular applications.

LANGUAGE: typescript
CODE:
function provideAngularQuery(queryClient): EnvironmentProviders

----------------------------------------

TITLE: Basic Query Injection in Angular Component
DESCRIPTION: Demonstrates how to inject a basic query into an Angular component using injectQuery. The query fetches a list of todos.

LANGUAGE: typescript
CODE:
import { injectQuery } from '@tanstack/angular-query-experimental'

export class TodosComponent {
  info = injectQuery(() => ({ queryKey: ['todos'], queryFn: fetchTodoList }))
}

----------------------------------------

TITLE: Defining DefinedInitialDataOptions Type in TypeScript
DESCRIPTION: Defines a type alias that extends CreateQueryOptions with additional object properties, using generic type parameters for query function data, error handling, data transformation, and query key types.

LANGUAGE: typescript
CODE:
type DefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>: CreateQueryOptions<TQueryFnData, TError, TData, TQueryKey> & object;

----------------------------------------

TITLE: Defining isError Method in BaseQueryNarrowing Interface
DESCRIPTION: This method checks if the query result is in an error state. It takes 'this' as a parameter and returns a boolean indicating if the result is of error type.

LANGUAGE: typescript
CODE:
isError: (this) => this is CreateBaseQueryResult<TData, TError, CreateStatusBasedQueryResult<"error", TData, TError>>;

----------------------------------------

TITLE: Defining CreateQueryResult Type Alias in TypeScript
DESCRIPTION: Defines the CreateQueryResult type alias that extends CreateBaseQueryResult with generic parameters TData and TError. TData defaults to unknown, and TError defaults to DefaultError.

LANGUAGE: typescript
CODE:
type CreateQueryResult<TData, TError>: CreateBaseQueryResult<TData, TError>;

----------------------------------------

TITLE: Basic QueryClient Injection in TypeScript
DESCRIPTION: Injects a QueryClient instance without any options. Returns a QueryClient instance that can be used for query operations.

LANGUAGE: typescript
CODE:
function injectQueryClient(): QueryClient

----------------------------------------

TITLE: Defining CreateMutationResult Type Alias in TypeScript
DESCRIPTION: This code snippet defines the CreateMutationResult type alias. It is a Readable store containing a CreateBaseMutationResult with generic types for data, error, variables, and context. This type is used to represent the result of creating a mutation in the tanstack-query library.

LANGUAGE: typescript
CODE:
type CreateMutationResult<TData, TError, TVariables, TContext>: Readable<CreateBaseMutationResult<TData, TError, TVariables, TContext>>;

----------------------------------------

TITLE: Defining initialData Property Type in TypeScript
DESCRIPTION: Specifies the type definition for the initialData property, which can be either a non-undefined value or a function returning a non-undefined value of TQueryFnData type.

LANGUAGE: typescript
CODE:
initialData: NonUndefinedGuard<TQueryFnData> | () => NonUndefinedGuard<TQueryFnData>;

----------------------------------------

TITLE: Defining CreateMutationResult Type Alias in TypeScript
DESCRIPTION: Defines a complex type alias for CreateMutationResult that combines BaseMutationNarrowing with MapToSignals. It uses multiple generic type parameters for data, error, variables, context, and state.

LANGUAGE: typescript
CODE:
type CreateMutationResult<TData, TError, TVariables, TContext, TState>: BaseMutationNarrowing<TData, TError, TVariables, TContext> & MapToSignals<OmitKeyof<TState, keyof BaseMutationNarrowing, "safely">>;

----------------------------------------

TITLE: Defining injectIsFetching Function in TypeScript
DESCRIPTION: This function injects a signal that tracks the number of queries that the application is loading or fetching in the background. It can be used for app-wide loading indicators. The function takes optional filters and an Angular injector as parameters, and returns a signal with the number of loading or fetching queries.

LANGUAGE: TypeScript
CODE:
function injectIsFetching(filters?, injector?): Signal<number>

----------------------------------------

TITLE: Defining CreateQueryOptions Type Alias in TypeScript
DESCRIPTION: Defines the CreateQueryOptions type alias with generic type parameters. It extends CreateBaseQueryOptions with the same type parameters, representing options for creating a query.

LANGUAGE: typescript
CODE:
type CreateQueryOptions<TQueryFnData, TError, TData, TQueryKey>: CreateBaseQueryOptions<TQueryFnData, TError, TData, TQueryFnData, TQueryKey>;

----------------------------------------

TITLE: Providing TanStack Query Client in NgModule-based Angular App
DESCRIPTION: This code snippet shows how to provide the TanStack Query client in an NgModule-based Angular application. It imports necessary modules and uses the provideTanStackQuery function in the providers array.

LANGUAGE: typescript
CODE:
import { provideHttpClient } from '@angular/common/http'
import {
  provideTanStackQuery,
  QueryClient,
} from '@tanstack/angular-query-experimental'

@NgModule({
  declarations: [AppComponent],
  imports: [BrowserModule],
  providers: [provideTanStackQuery(new QueryClient())],
  bootstrap: [AppComponent],
})
export class AppModule {}

----------------------------------------

TITLE: Defining Mutation Options with TypeScript in TanStack Query
DESCRIPTION: This snippet demonstrates how to use the 'mutationOptions' helper to define mutation options for updating a post. It shows type inference for the onSuccess callback and includes setting query data after a successful mutation.

LANGUAGE: typescript
CODE:
export class QueriesService {
  private http = inject(HttpClient)

  updatePost(id: number) {
    return mutationOptions({
      mutationFn: (post: Post) => Promise.resolve(post),
      mutationKey: ['updatePost', id],
      onSuccess: (newPost) => {
        //           ^? newPost: Post
        this.queryClient.setQueryData(['posts', id], newPost)
      },
    })
  }
}

----------------------------------------

TITLE: HydrationBoundary Class Constructor
DESCRIPTION: Constructor definition for the HydrationBoundary class. It takes ComponentConstructorOptions as a parameter and returns an instance of HydrationBoundary.

LANGUAGE: typescript
CODE:
new HydrationBoundary<Props, Events, Slots>(options): HydrationBoundary<Props, Events, Slots>

----------------------------------------

TITLE: Implementing Generic Infinite Query in Angular with TanStack Query
DESCRIPTION: Function signature for injecting an infinite query with flexible type parameters. Provides the most generic implementation supporting various data types and query configurations.

LANGUAGE: typescript
CODE:
function injectInfiniteQuery<
  TQueryFnData,
  TError,
  TData,
  TQueryKey,
  TPageParam,
>(optionsFn, injector?): CreateInfiniteQueryResult<TData, TError>

----------------------------------------

TITLE: Conditional Query Enabling with Signal
DESCRIPTION: Shows how to conditionally enable a query based on a signal value. The query only executes when the filter signal has a value.

LANGUAGE: angular-ts
CODE:
@Component({
  selector: 'todos',
  template: `
    <div>
      // üöÄ applying the filter will enable and execute the query
      <filters-form onApply="filter.set" />
      <todos-table data="query.data()" />
    </div>
  `,
})
export class TodosComponent {
  filter = signal('')

  todosQuery = injectQuery(() => ({
    queryKey: ['todos', this.filter()],
    queryFn: () => fetchTodos(this.filter()),
    enabled: !!this.filter(),
  }))
}

----------------------------------------

TITLE: Reversing Infinite Query Data in TanStack Query
DESCRIPTION: This example shows how to reverse the order of pages and page parameters in an infinite query result using the select option in TanStack Query.

LANGUAGE: ts
CODE:
query = injectInfiniteQuery(() => ({
  queryKey: ['projects'],
  queryFn: fetchProjects,
  select: (data) => ({
    pages: [...data.pages].reverse(),
    pageParams: [...data.pageParams].reverse(),
  }),
}))

----------------------------------------

TITLE: Using Typed Svelte Components in TypeScript
DESCRIPTION: Example of using a typed Svelte component in a Svelte file with TypeScript. This demonstrates how to import and use the component with proper type checking.

LANGUAGE: svelte
CODE:
<script lang="ts">
  import { MyComponent } from 'component-library'
</script>

<MyComponent foo={'bar'} />

----------------------------------------

TITLE: Configuring Mutation Callbacks in TanStack Query
DESCRIPTION: Shows how to set up various callbacks for a mutation, including onMutate, onError, onSuccess, and onSettled. These callbacks allow for handling different stages of the mutation lifecycle.

LANGUAGE: ts
CODE:
mutation = injectMutation(() => ({
  mutationFn: addTodo,
  onMutate: (variables) => {
    // A mutation is about to happen!

    // Optionally return a context containing data to use when for example rolling back
    return { id: 1 }
  },
  onError: (error, variables, context) => {
    // An error happened!
    console.log(`rolling back optimistic update with id ${context.id}`)
  },
  onSuccess: (data, variables, context) => {
    // Boom baby!
  },
  onSettled: (data, error, variables, context) => {
    // Error or success... doesn't matter!
  },
}))

----------------------------------------

TITLE: injectQueries Development Status for Angular Query
DESCRIPTION: This snippet indicates that the injectQueries function is currently under development for Angular Query and is not yet available for use.

LANGUAGE: typescript
CODE:
// injectQueries is under development for Angular Query

----------------------------------------

TITLE: Clearing QueryCache in TanStack Query
DESCRIPTION: Shows how to clear the entire query cache using the clear method.

LANGUAGE: tsx
CODE:
queryCache.clear()

----------------------------------------

TITLE: Specific Variable Query Invalidation
DESCRIPTION: Shows how to invalidate queries with specific variables by providing a more detailed query key. Demonstrates that only queries matching the exact key structure will be invalidated.

LANGUAGE: typescript
CODE:
queryClient.invalidateQueries({
  queryKey: ['todos', { type: 'done' }],
})

// The query below will be invalidated
todoListQuery = injectQuery(() => ({
  queryKey: ['todos', { type: 'done' }],
  queryFn: fetchTodoList,
}))

// However, the following query below will NOT be invalidated
todoListQuery = injectQuery(() => ({
  queryKey: ['todos'],
  queryFn: fetchTodoList,
}))

----------------------------------------

TITLE: Reactive Query Injection with Signal Dependencies
DESCRIPTION: Shows how to create a reactive query that depends on a signal value. The query automatically updates when the filter signal changes and includes conditional enabling based on the filter value.

LANGUAGE: typescript
CODE:
class ServiceOrComponent {
  filter = signal('')

  todosQuery = injectQuery(() => ({
    queryKey: ['todos', this.filter()],
    queryFn: () => fetchTodos(this.filter()),
    // Signals can be combined with expressions
    enabled: !!this.filter(),
  }))
}

----------------------------------------

TITLE: Optimistic Update Implementation
DESCRIPTION: Complete implementation of optimistic updates with rollback functionality and error handling.

LANGUAGE: typescript
CODE:
queryClient = inject(QueryClient)

updateTodo = injectMutation(() => ({
  mutationFn: updateTodo,
  // When mutate is called:
  onMutate: async (newTodo) => {
    // Cancel any outgoing refetches
    // (so they don't overwrite our optimistic update)
    await this.queryClient.cancelQueries({ queryKey: ['todos'] })

    // Snapshot the previous value
    const previousTodos = client.getQueryData(['todos'])

    // Optimistically update to the new value
    this.queryClient.setQueryData(['todos'], (old) => [...old, newTodo])

    // Return a context object with the snapshotted value
    return { previousTodos }
  },
  // If the mutation fails,
  // use the context returned from onMutate to roll back
  onError: (err, newTodo, context) => {
    client.setQueryData(['todos'], context.previousTodos)
  },
  // Always refetch after error or success:
  onSettled: () => {
    this.queryClient.invalidateQueries({ queryKey: ['todos'] })
  },
}))

----------------------------------------

TITLE: Specific Variable Query Invalidation
DESCRIPTION: Shows how to invalidate queries with specific variables by providing a more detailed query key. Demonstrates that only queries matching the exact key structure will be invalidated.

LANGUAGE: typescript
CODE:
queryClient.invalidateQueries({
  queryKey: ['todos', { type: 'done' }],
})

// The query below will be invalidated
todoListQuery = injectQuery(() => ({
  queryKey: ['todos', { type: 'done' }],
  queryFn: fetchTodoList,
}))

// However, the following query below will NOT be invalidated
todoListQuery = injectQuery(() => ({
  queryKey: ['todos'],
  queryFn: fetchTodoList,
}))

----------------------------------------

TITLE: Declaring select Function in MutationStateOptions
DESCRIPTION: Declares an optional select function within the MutationStateOptions type alias. This function takes a mutation parameter of type Mutation<unknown, DefaultError, unknown, unknown> and returns TResult.

LANGUAGE: typescript
CODE:
optional select: (mutation) => TResult;

----------------------------------------

TITLE: Incorrect QueryClient Instantiation in React Component
DESCRIPTION: Demonstrates an incorrect pattern where QueryClient is instantiated on every render, which should be avoided for performance and stability reasons.

LANGUAGE: tsx
CODE:
function App() {
  const queryClient = new QueryClient()
  return (
    <QueryClientProvider client={queryClient}>
      <Home />
    </QueryClientProvider>
  )
}

----------------------------------------

TITLE: Error Handling in Todo Component
DESCRIPTION: Angular component template showing error state handling with retry functionality.

LANGUAGE: angular-ts
CODE:
@Component({
  template: `
    @if (addTodo.isError()) {
      <li style="color: red">
        {{ addTodo.variables() }}
        <button (click)="addTodo.mutate(addTodo.variables())">Retry</button>
      </li>
    }
  `,
})
class TodosComponent {}

----------------------------------------

TITLE: Importing and Defining Types for TanStack Query in Angular
DESCRIPTION: This snippet shows the import statements and type definitions for various TanStack Query components and utilities adapted for Angular. It includes types for query options, results, mutation options, and core TanStack Query concepts.

LANGUAGE: TypeScript
CODE:
import type { DataTag } from '@tanstack/query-core';
import type { DefaultError } from '@tanstack/query-core';
import type { DefinedInfiniteQueryObserverResult } from '@tanstack/query-core';
import type { DefinedQueryObserverResult } from '@tanstack/query-core';
import type { DevtoolsButtonPosition } from '@tanstack/query-devtools';
import type { DevtoolsErrorType } from '@tanstack/query-devtools';
import type { DevtoolsPosition } from '@tanstack/query-devtools';
import type { EnvironmentProviders } from '@angular/core';
import type { InfiniteData } from '@tanstack/query-core';
import type { InfiniteQueryObserverOptions } from '@tanstack/query-core';
import type { InfiniteQueryObserverResult } from '@tanstack/query-core';
import type { InitialDataFunction } from '@tanstack/query-core';
import { InjectionToken } from '@angular/core';
import { InjectOptions } from '@angular/core';
import { Injector } from '@angular/core';
import type { MutateFunction } from '@tanstack/query-core';
import type { Mutation } from '@tanstack/query-core';
import type { MutationFilters } from '@tanstack/query-core';
import type { MutationObserverOptions } from '@tanstack/query-core';
import type { MutationObserverResult } from '@tanstack/query-core';
import type { MutationState } from '@tanstack/query-core';
import type { OmitKeyof } from '@tanstack/query-core';
import type { Override } from '@tanstack/query-core';
import { Provider } from '@angular/core';
import type { QueriesPlaceholderDataFunction } from '@tanstack/query-core';
import type { QueryClient } from '@tanstack/query-core';
import type { QueryFilters } from '@tanstack/query-core';
import type { QueryFunction } from '@tanstack/query-core';
import type { QueryKey } from '@tanstack/query-core';
import type { QueryObserverOptions } from '@tanstack/query-core';
import type { QueryObserverResult } from '@tanstack/query-core';
import type { Signal } from '@angular/core';
import type { ThrowOnError } from '@tanstack/query-core';

----------------------------------------

TITLE: MaybeRef Query Implementation
DESCRIPTION: Enhanced implementation that accepts both plain values and refs using MaybeRef type.

LANGUAGE: typescript
CODE:
export function useUserProjects(userId: MaybeRef<string>) {
  return useQuery(
    queryKey: ['userProjects', userId],
    queryFn: () => api.fetchUserProjects(toValue(userId)),
  );
}

----------------------------------------

TITLE: Installing Vue Query via Bun
DESCRIPTION: Command to install Vue Query using Bun package manager.

LANGUAGE: bash
CODE:
bun add @tanstack/vue-query

----------------------------------------

TITLE: Implementing Embedded Mode Devtools
DESCRIPTION: Implementation of embedded mode devtools that renders as a fixed element within the application layout with custom toggle control.

LANGUAGE: tsx
CODE:
import { ReactQueryDevtoolsPanel } from '@tanstack/react-query-devtools'

function App() {
  const [isOpen, setIsOpen] = React.useState(false)

  return (
    <QueryClientProvider client={queryClient}>
      {/* The rest of your application */}
      <button
        onClick={() => setIsOpen(!isOpen)}
      >{`${isOpen ? 'Close' : 'Open'} the devtools panel`}</button>
      {isOpen && <ReactQueryDevtoolsPanel onClose={() => setIsOpen(false)} />}
    </QueryClientProvider>
  )
}

----------------------------------------

TITLE: Setting Fixed Retry Delay for Individual Queries in Angular with TanStack Query
DESCRIPTION: This snippet illustrates how to override the retry delay for an individual query, setting it to a fixed value of 1000ms regardless of the number of retries. This approach is not recommended for production use.

LANGUAGE: typescript
CODE:
const result = injectQuery(() => ({
  queryKey: ['todos'],
  queryFn: fetchTodoList,
  retryDelay: 1000, // Will always wait 1000ms to retry, regardless of how many retries
}))

----------------------------------------

TITLE: Defining CreateInfiniteQueryOptions Type Alias in TypeScript
DESCRIPTION: Type alias that extends InfiniteQueryObserverOptions with generic parameters for query function data, error handling, transformed data, query data, query key, and page parameters. Used for configuring infinite queries in TanStack Query.

LANGUAGE: typescript
CODE:
type CreateInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey, TPageParam>: InfiniteQueryObserverOptions<TQueryFnData, TError, TData, TQueryData, TQueryKey, TPageParam>;

----------------------------------------

TITLE: Installing and Running TanStack Query Example
DESCRIPTION: Commands to install project dependencies and start the development server. First installs required packages via npm, then starts the development server.

LANGUAGE: bash
CODE:
npm install

LANGUAGE: bash
CODE:
npm run dev

----------------------------------------

TITLE: Configuring Global Window Focus Refetching in TanStack Query
DESCRIPTION: Sets up global configuration for TanStack Query with disabled window focus refetching. This is done by configuring a QueryClient instance with defaultOptions in the application configuration.

LANGUAGE: typescript
CODE:
export const appConfig: ApplicationConfig = {
  providers: [
    provideTanStackQuery(
      new QueryClient({
        defaultOptions: {
          queries: {
            refetchOnWindowFocus: false, // default: true
          },
        },
      }),
    ),
  ],
}

----------------------------------------

TITLE: Declaring mutateAsync Function in CreateBaseMutationResult
DESCRIPTION: Declares the mutateAsync function within the CreateBaseMutationResult type alias. It uses the CreateMutateAsyncFunction type with the same generic parameters as the parent type.

LANGUAGE: TypeScript
CODE:
mutateAsync: CreateMutateAsyncFunction<TData, TError, TVariables, TContext>

----------------------------------------

TITLE: Importing useQueryClient from React Query
DESCRIPTION: This snippet shows how to import the useQueryClient hook from the @tanstack/react-query package. It's the first step in using the QueryClient in a React component.

LANGUAGE: javascript
CODE:
import { useQueryClient } from '@tanstack/react-query'

----------------------------------------

TITLE: Defining BaseMutationNarrowing Interface in TypeScript
DESCRIPTION: This code snippet defines the BaseMutationNarrowing interface with type parameters and properties for type narrowing in mutation results. It includes methods to check if the mutation is in an error, idle, pending, or success state.

LANGUAGE: typescript
CODE:
interface BaseMutationNarrowing<TData = unknown, TError = DefaultError, TVariables = unknown, TContext = unknown> {
  isError: (this: CreateMutationResult<TData, TError, TVariables, TContext, CreateStatusBasedMutationResult<"error" | "success" | "pending" | "idle", TData, TError, TVariables, TContext>>) => this is CreateMutationResult<TData, TError, TVariables, TContext, Override<MutationObserverErrorResult<TData, TError, TVariables, TContext>, Object> & Object>;
  isIdle: (this: CreateMutationResult<TData, TError, TVariables, TContext, CreateStatusBasedMutationResult<"error" | "success" | "pending" | "idle", TData, TError, TVariables, TContext>>) => this is CreateMutationResult<TData, TError, TVariables, TContext, Override<MutationObserverIdleResult<TData, TError, TVariables, TContext>, Object> & Object>;
  isPending: (this: CreateMutationResult<TData, TError, TVariables, TContext, CreateStatusBasedMutationResult<"error" | "success" | "pending" | "idle", TData, TError, TVariables, TContext>>) => this is CreateMutationResult<TData, TError, TVariables, TContext, Override<MutationObserverLoadingResult<TData, TError, TVariables, TContext>, Object> & Object>;
  isSuccess: (this: CreateMutationResult<TData, TError, TVariables, TContext, CreateStatusBasedMutationResult<"error" | "success" | "pending" | "idle", TData, TError, TVariables, TContext>>) => this is CreateMutationResult<TData, TError, TVariables, TContext, Override<MutationObserverSuccessResult<TData, TError, TVariables, TContext>, Object> & Object>;
}

----------------------------------------

TITLE: Installing and Running TanStack Query Angular Example
DESCRIPTION: Command line instructions for installing dependencies and starting the application using various package managers including npm, yarn, pnpm, and bun.

LANGUAGE: shell
CODE:
npm install
# or
yarn
# or
pnpm i
# or
bun i

LANGUAGE: shell
CODE:
npm run start
# or
yarn start
# or
pnpm start
# or
bun start

----------------------------------------

TITLE: Configuring Per-Query Window Focus Refetching
DESCRIPTION: Shows how to disable window focus refetching for a specific query using the refetchOnWindowFocus option in useQuery hook.

LANGUAGE: tsx
CODE:
useQuery({
  queryKey: ['todos'],
  queryFn: fetchTodos,
  refetchOnWindowFocus: false,
})

----------------------------------------

TITLE: Creating Query with Undefined Initial Data in TypeScript
DESCRIPTION: Second overload of createQuery that handles undefined initial data options. Takes the same generic type parameters as the first overload but returns a standard CreateQueryResult.

LANGUAGE: typescript
CODE:
function createQuery<TQueryFnData, TError, TData, TQueryKey>(
  options,
  queryClient?,
): CreateQueryResult<TData, TError>

----------------------------------------

TITLE: Setting Custom Event Listener in TanStack Query FocusManager
DESCRIPTION: Demonstrates how to set a custom event listener for focus management using the setEventListener method. The example shows setting up a visibilitychange event listener with proper cleanup.

LANGUAGE: tsx
CODE:
import { focusManager } from '@tanstack/react-query'

focusManager.setEventListener((handleFocus) => {
  // Listen to visibilitychange
  if (typeof window !== 'undefined' && window.addEventListener) {
    window.addEventListener('visibilitychange', handleFocus, false)
  }

  return () => {
    // Be sure to unsubscribe if a new handler is set
    window.removeEventListener('visibilitychange', handleFocus)
  }
})

----------------------------------------

TITLE: Installing and Starting TanStack Query Angular Project
DESCRIPTION: Command line instructions for installing dependencies and starting the development server using various package managers including npm, yarn, pnpm, and bun.

LANGUAGE: bash
CODE:
npm install
npm run start

LANGUAGE: bash
CODE:
yarn
yarn start

LANGUAGE: bash
CODE:
pnpm i
pnpm start

LANGUAGE: bash
CODE:
bun i
bun start

----------------------------------------

TITLE: Configuring Production Devtools with Lazy Loading
DESCRIPTION: Advanced setup for including devtools in production builds using lazy loading to minimize bundle size impact.

LANGUAGE: tsx
CODE:
import * as React from 'react'
import { QueryClient, QueryClientProvider } from '@tanstack/react-query'
import { ReactQueryDevtools } from '@tanstack/react-query-devtools'
import { Example } from './Example'

const queryClient = new QueryClient()

const ReactQueryDevtoolsProduction = React.lazy(() =>
  import('@tanstack/react-query-devtools/build/modern/production.js').then(
    (d) => ({
      default: d.ReactQueryDevtools,
    }),
  ),
)

function App() {
  const [showDevtools, setShowDevtools] = React.useState(false)

  React.useEffect(() => {
    // @ts-expect-error
    window.toggleDevtools = () => setShowDevtools((old) => !old)
  }, [])

  return (
    <QueryClientProvider client={queryClient}>
      <Example />
      <ReactQueryDevtools initialIsOpen />
      {showDevtools && (
        <React.Suspense fallback={null}>
          <ReactQueryDevtoolsProduction />
        </React.Suspense>
      )}
    </QueryClientProvider>
  )
}

----------------------------------------

TITLE: Defining DefinedInitialDataInfiniteOptions Type Alias in TypeScript
DESCRIPTION: Defines a type alias that extends CreateInfiniteQueryOptions for infinite queries with defined initial data. The type is generic, accepting parameters for query function data, error type, data type, query key, and page parameter.

LANGUAGE: typescript
CODE:
type DefinedInitialDataInfiniteOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam>: CreateInfiniteQueryOptions<TQueryFnData, TError, TData, TQueryFnData, TQueryKey, TPageParam> & object;

----------------------------------------

TITLE: Type Inference with Data Selection
DESCRIPTION: Shows type inference when using a select function to transform the query result from number to string.

LANGUAGE: angular-ts
CODE:
@Component({
  // ...
  template: `@let data = query.data();`,
  //               ^? data: string | undefined
})
class MyComponent {
  query = injectQuery(() => ({
    queryKey: ['test'],
    queryFn: () => Promise.resolve(5),
    select: (data) => data.toString(),
  }))
}

----------------------------------------

TITLE: Installing TanStack Angular Query with Bun
DESCRIPTION: Command to install the experimental version of TanStack Angular Query using Bun package manager. Requires Angular v16 or higher.

LANGUAGE: bash
CODE:
bun add @tanstack/angular-query-experimental

----------------------------------------

TITLE: Installing and Running TanStack Query Example
DESCRIPTION: Commands for installing dependencies and starting the development server for a TanStack Query example project.

LANGUAGE: shell
CODE:
npm install
npm run dev

----------------------------------------

TITLE: Error Type Narrowing with Axios in Solid Query
DESCRIPTION: Demonstrates how to narrow the error type to a specific error class (AxiosError) using type guards. This approach maintains type inference while allowing for more specific error handling.

LANGUAGE: tsx
CODE:
import axios from 'axios'

const query = createQuery(() => ({
  queryKey: ['groups'],
  queryFn: fetchGroups,
}))

query.error
//    ^? (property) error: Error | null

if (axios.isAxiosError(query.error)) {
  query.error
  //    ^? (property) error: AxiosError
}

----------------------------------------

TITLE: Optional InitialData Property Declaration
DESCRIPTION: Declares an optional initialData property that must be undefined when specified. This ensures the initialData cannot have any other value.

LANGUAGE: typescript
CODE:
optional initialData: undefined;

----------------------------------------

TITLE: Exact Query Key Invalidation
DESCRIPTION: Demonstrates using the exact:true option to invalidate only queries that exactly match the provided query key, without affecting queries that have additional parameters.

LANGUAGE: typescript
CODE:
queryClient.invalidateQueries({
  queryKey: ['todos'],
  exact: true,
})

// The query below will be invalidated
todoListQuery = injectQuery(() => ({
  queryKey: ['todos'],
  queryFn: fetchTodoList,
}))

// However, the following query below will NOT be invalidated
const todoListQuery = injectQuery(() => ({
  queryKey: ['todos', { type: 'done' }],
  queryFn: fetchTodoList,
}))

----------------------------------------

TITLE: Installing and Running TanStack Query Example - NPM Commands
DESCRIPTION: Commands to install project dependencies and start the development server. First installs required packages using npm install, then starts the development server using npm run dev.

LANGUAGE: bash
CODE:
npm install

LANGUAGE: bash
CODE:
npm run dev

----------------------------------------

TITLE: Custom Error Typing in Solid Query
DESCRIPTION: Shows how to specify a custom error type for a query. The error property is typed as string | null instead of the default Error | null.

LANGUAGE: tsx
CODE:
const query = createQuery<Group[], string>(() => ({
  queryKey: ['groups'],
  queryFn: fetchGroups,
}))

query.error
//    ^? (property) error: string | null

----------------------------------------

TITLE: Declaring initialData Property in TypeScript
DESCRIPTION: This code snippet declares the initialData property within the DefinedInitialDataOptions type. It can be either a non-undefined value of TQueryFnData or a function returning such a value.

LANGUAGE: typescript
CODE:
initialData: NonUndefinedGuard<TQueryFnData> | () => NonUndefinedGuard<TQueryFnData>;

----------------------------------------

TITLE: Installing TanStack Query Devtools Package
DESCRIPTION: Different package manager commands to install the @tanstack/svelte-query-devtools package.

LANGUAGE: bash
CODE:
npm i @tanstack/svelte-query-devtools

LANGUAGE: bash
CODE:
pnpm add @tanstack/svelte-query-devtools

LANGUAGE: bash
CODE:
yarn add @tanstack/svelte-query-devtools

LANGUAGE: bash
CODE:
bun add @tanstack/svelte-query-devtools

----------------------------------------

TITLE: Query Configuration with Default staleTime in TSX
DESCRIPTION: Shows how query behaves with default staleTime (0) and initialData, causing immediate refetch on mount.

LANGUAGE: tsx
CODE:
const result = useQuery({
  queryKey: ['todos'],
  queryFn: () => fetch('/todos'),
  initialData: initialTodos,
})

----------------------------------------

TITLE: Installing Dependencies and Running TanStack Query Example
DESCRIPTION: These commands install the necessary dependencies and start the TanStack Query example project. First, 'npm install' fetches and installs all required packages. Then, 'npm run start' launches the example application.

LANGUAGE: shell
CODE:
npm install
npm run start

----------------------------------------

TITLE: Basic Type Inference in React Query
DESCRIPTION: Demonstrates basic type inference for query results where TypeScript automatically infers the data type from the queryFn return value.

LANGUAGE: tsx
CODE:
const { data } = useQuery({
  //    ^? const data: number | undefined
  queryKey: ['test'],
  queryFn: () => Promise.resolve(5),
})

----------------------------------------

TITLE: Building Svelte Project for Production
DESCRIPTION: Command to create a production build of the Svelte application.

LANGUAGE: bash
CODE:
npm run build

----------------------------------------

TITLE: Creating Custom Hook with Select Option in React Query
DESCRIPTION: Demonstrates how to create a custom hook using React Query's useQuery with a select option for data transformation. The example shows a useTodos hook that fetches todos and a useTodoCount hook that selects only the length of the todos array.

LANGUAGE: javascript
CODE:
export const useTodos = (select) => {
  return useQuery({
    queryKey: ['todos'],
    queryFn: fetchTodos,
    select,
  })
}

export const useTodoCount = () => {
  return useTodos((data) => data.length)
}

----------------------------------------

TITLE: Installing and Running TanStack Query Example with NPM
DESCRIPTION: Commands to install dependencies and start the development server for a TanStack Query example project. Uses npm for package management.

LANGUAGE: shell
CODE:
npm install
npm run dev

----------------------------------------

TITLE: Correct Query Key Dependencies in TanStack Query
DESCRIPTION: Examples showing proper implementation where all variables used in queryFn are included in the query key array. This ensures proper caching and automatic refetching when dependencies change.

LANGUAGE: tsx
CODE:
useQuery({
  queryKey: ['todo', todoId],
  queryFn: () => api.getTodo(todoId),
})

const todoQueries = {
  detail: (id) => ({ queryKey: ['todo', id], queryFn: () => api.getTodo(id) }),
}

----------------------------------------

TITLE: Type Inference for Basic Query in Vue Query with TypeScript
DESCRIPTION: Demonstrates basic type inference for a simple query using Vue Query. The inferred type for 'data' is a Ref<number> | Ref<undefined>, reflecting the resolved Promise value.

LANGUAGE: tsx
CODE:
const { data } = useQuery({
  //    ^? const data: Ref<number> | Ref<undefined>
  queryKey: ['test'],
  queryFn: () => Promise.resolve(5),
})

----------------------------------------

TITLE: Manual Focus State Management
DESCRIPTION: Demonstrates how to manually control the focus state using focusManager.setFocused method.

LANGUAGE: tsx
CODE:
import { focusManager } from '@tanstack/react-query'

// Override the default focus state
focusManager.setFocused(true)

// Fallback to the default focus check
focusManager.setFocused(undefined)

----------------------------------------

TITLE: Updating React Query Provider in TypeScript/JavaScript
DESCRIPTION: Changes to the QueryClientProvider, including removal of contextSharing prop and updates to hydration API.

LANGUAGE: tsx
CODE:
- import { Hydrate } from '@tanstack/react-query' // [!code --]
+ import { HydrationBoundary } from '@tanstack/react-query' // [!code ++]


- <Hydrate state={dehydratedState}> // [!code --]
+ <HydrationBoundary state={dehydratedState}> // [!code ++]
  <App />
- </Hydrate> // [!code --]
+ </HydrationBoundary> // [!code ++]

----------------------------------------

TITLE: Installing Dependencies for Tanstack-Query Example
DESCRIPTION: Command to install the necessary dependencies for the Tanstack-Query example project.

LANGUAGE: shell
CODE:
npm install

----------------------------------------

TITLE: Configuring TanStack Query ESLint Plugin with Flat Config
DESCRIPTION: JavaScript code to set up the ESLint plugin using the recommended configuration in a flat config file (eslint.config.js).

LANGUAGE: javascript
CODE:
import pluginQuery from '@tanstack/eslint-plugin-query'

export default [
  ...pluginQuery.configs['flat/recommended'],
  // Any other config...
]

----------------------------------------

TITLE: Global Error Type Registration
DESCRIPTION: Demonstrates how to register a global error type for React Query using TypeScript module augmentation.

LANGUAGE: tsx
CODE:
import '@tanstack/react-query'

declare module '@tanstack/react-query' {
  interface Register {
    defaultError: AxiosError
  }
}

const { error } = useQuery({ queryKey: ['groups'], queryFn: fetchGroups })
//      ^? const error: AxiosError | null

----------------------------------------

TITLE: Todo List Component with Pending State
DESCRIPTION: Angular component template showing todos list with optimistic pending state rendering.

LANGUAGE: angular-ts
CODE:
@Component({
  template: `
    @for (todo of todos.data(); track todo.id) {
      <li>{{ todo.title }}</li>
    }
    @if (addTodo.isPending()) {
      <li style="opacity: 0.5">{{ addTodo.variables() }}</li>
    }
  `,
})
class TodosComponent {}

----------------------------------------

TITLE: Creating a Svelte Project with npm
DESCRIPTION: Commands to create a new Svelte project using npm. It demonstrates how to create a project in the current directory or in a new directory.

LANGUAGE: bash
CODE:
# create a new project in the current directory
npm create svelte@latest

# create a new project in my-app
npm create svelte@latest my-app

----------------------------------------

TITLE: Providing TanStack Query Client in Angular Standalone App
DESCRIPTION: This snippet demonstrates how to provide the TanStack Query client to a standalone Angular application. It uses the provideTanStackQuery function and creates a new QueryClient instance.

LANGUAGE: typescript
CODE:
import { provideHttpClient } from '@angular/common/http'
import {
  provideTanStackQuery,
  QueryClient,
} from '@tanstack/angular-query-experimental'

bootstrapApplication(AppComponent, {
  providers: [provideHttpClient(), provideTanStackQuery(new QueryClient())],
})

----------------------------------------

TITLE: Mock Response Generator for Pagination
DESCRIPTION: Helper function to generate mock responses for paginated data testing.

LANGUAGE: tsx
CODE:
function generateMockedResponse(page) {
  return {
    page: page,
    items: [...]
  }
}

----------------------------------------

TITLE: Setting Static Placeholder Data in TanStack Query
DESCRIPTION: This snippet shows how to set static placeholder data for a query using the placeholderData option. It uses a predefined placeholderTodos variable to provide initial data while the query is loading.

LANGUAGE: tsx
CODE:
const result = useQuery({
  queryKey: ['todos'],
  queryFn: () => fetch('/todos'),
  placeholderData: placeholderTodos,
})

----------------------------------------

TITLE: Updating Query Defaults in TypeScript/JavaScript
DESCRIPTION: Changes to how query defaults are set and merged, requiring updates to the order of setQueryDefaults calls.

LANGUAGE: ts
CODE:
+ queryClient.setQueryDefaults(['todo'], {   // [!code ++]
+   retry: false,  // [!code ++]
+   staleTime: 60_000,  // [!code ++]
+ })  // [!code ++]
queryClient.setQueryDefaults(['todo', 'detail'], {
+   retry: true,  // [!code --]
  retryDelay: 1_000,
  staleTime: 10_000,
})
- queryClient.setQueryDefaults(['todo'], { // [!code --]
-   retry: false, // [!code --]
-   staleTime: 60_000, // [!code --]
- }) // [!code --]

----------------------------------------

TITLE: Creating Astro Project with Minimal Template
DESCRIPTION: This command creates a new Astro project using the minimal template. It utilizes npm to run the Astro creation script with the specified template option.

LANGUAGE: sh
CODE:
npm create astro@latest -- --template minimal

----------------------------------------

TITLE: Testing Network Calls with Nock
DESCRIPTION: Example of testing API calls using Nock to mock network requests.

LANGUAGE: tsx
CODE:
const queryClient = new QueryClient()
const wrapper = ({ children }) => (
  <QueryClientProvider client={queryClient}>{children}</QueryClientProvider>
)

const expectation = nock('http://example.com').get('/api/data').reply(200, {
  answer: 42,
})

const { result, waitFor } = renderHook(() => useFetchData(), { wrapper })

await waitFor(() => {
  return result.current.isSuccess
})

expect(result.current.data).toEqual({ answer: 42 })

----------------------------------------

TITLE: Testing Infinite Query with Nock
DESCRIPTION: Configuration for mocking paginated API responses using Nock.

LANGUAGE: tsx
CODE:
const expectation = nock('http://example.com')
  .persist()
  .query(true)
  .get('/api/data')
  .reply(200, (uri) => {
    const url = new URL(`http://example.com${uri}`)
    const { page } = Object.fromEntries(url.searchParams)
    return generateMockedResponse(page)
  })

----------------------------------------

TITLE: Installing Dependencies for TanStack Query Angular Pagination Example
DESCRIPTION: Commands to install project dependencies using different package managers. This step is required before running the example.

LANGUAGE: Shell
CODE:
npm install

LANGUAGE: Shell
CODE:
yarn

LANGUAGE: Shell
CODE:
pnpm i

LANGUAGE: Shell
CODE:
bun i

----------------------------------------

TITLE: Configuring QueryClient for SvelteKit SSR
DESCRIPTION: Sets up a QueryClient with queries disabled on the server using SvelteKit's browser module. This configuration ensures queries only run in the browser environment.

LANGUAGE: svelte
CODE:
<script lang="ts">
  import { browser } from '$app/environment'
  import { QueryClient, QueryClientProvider } from '@tanstack/svelte-query'

  const queryClient = new QueryClient({
    defaultOptions: {
      queries: {
        enabled: browser,
      },
    },
  })
</script>

<QueryClientProvider client={queryClient}>
  <slot />
</QueryClientProvider>

----------------------------------------

TITLE: Server Prefetching Component Setup for Nuxt 3
DESCRIPTION: Example component setup showing how to prefetch queries on the server using onServerPrefetch and suspense.

LANGUAGE: typescript
CODE:
export default defineComponent({
  setup() {
    const { data, suspense } = useQuery({
      queryKey: ['test'],
      queryFn: fetcher,
    })

    onServerPrefetch(async () => {
      await suspense()
    })

    return { data }
  },
})

----------------------------------------

TITLE: Basic Custom Query Hook Implementation
DESCRIPTION: Simple example of a custom React Query hook that returns a static value.

LANGUAGE: tsx
CODE:
export function useCustomHook() {
  return useQuery({ queryKey: ['customHook'], queryFn: () => 'Hello' })
}

----------------------------------------

TITLE: Defining useQueryClient Function in TypeScript
DESCRIPTION: This snippet defines the useQueryClient function, which takes an optional QueryClient parameter and returns a QueryClient. It's used to access or create a QueryClient instance in Svelte applications using tanstack-query.

LANGUAGE: typescript
CODE:
function useQueryClient(queryClient?): QueryClient

----------------------------------------

TITLE: Displaying Astro Project Structure
DESCRIPTION: This snippet shows the folder structure of an Astro minimal project. It includes the public directory for static assets, src/pages for Astro pages, and the package.json file.

LANGUAGE: text
CODE:
/
‚îú‚îÄ‚îÄ public/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îî‚îÄ‚îÄ pages/
‚îÇ       ‚îî‚îÄ‚îÄ index.astro
‚îî‚îÄ‚îÄ package.json

----------------------------------------

TITLE: Defining Query and Mutation Functions for Angular
DESCRIPTION: This snippet defines functions for creating and injecting queries and mutations in Angular using TanStack Query. It includes functions for infinite queries, mutations, and query state management.

LANGUAGE: TypeScript
CODE:
export function infiniteQueryOptions<TQueryFnData, TError = DefaultError, TData = InfiniteData<TQueryFnData>, TQueryKey extends QueryKey = QueryKey, TPageParam = unknown>(options: DefinedInitialDataInfiniteOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam>): DefinedInitialDataInfiniteOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam> & {
    queryKey: DataTag<TQueryKey, InfiniteData<TQueryFnData>>;
};

export function injectInfiniteQuery<TQueryFnData, TError = DefaultError, TData = InfiniteData<TQueryFnData>, TQueryKey extends QueryKey = QueryKey, TPageParam = unknown>(optionsFn: (client: QueryClient) => DefinedInitialDataInfiniteOptions<TQueryFnData, TError, TData, TQueryKey, TPageParam>, injector?: Injector): DefinedCreateInfiniteQueryResult<TData, TError>;

export function injectMutation<TData = unknown, TError = DefaultError, TVariables = void, TContext = unknown>(optionsFn: (client: QueryClient) => CreateMutationOptions<TData, TError, TVariables, TContext>, injector?: Injector): CreateMutationResult<TData, TError, TVariables, TContext>;

export function injectQuery<TQueryFnData = unknown, TError = DefaultError, TData = TQueryFnData, TQueryKey extends QueryKey = QueryKey>(optionsFn: (client: QueryClient) => DefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey>, injector?: Injector): DefinedCreateQueryResult<TData, TError>;

----------------------------------------

TITLE: Installing @tanstack/query-persist-client-core package
DESCRIPTION: Commands for installing the @tanstack/query-persist-client-core package using various package managers.

LANGUAGE: bash
CODE:
npm install @tanstack/query-persist-client-core

LANGUAGE: bash
CODE:
pnpm add @tanstack/query-persist-client-core

LANGUAGE: bash
CODE:
yarn add @tanstack/query-persist-client-core

LANGUAGE: bash
CODE:
bun add @tanstack/query-persist-client-core

----------------------------------------

TITLE: Installing Testing Dependencies
DESCRIPTION: Commands for installing React Hooks Testing Library and its peer dependencies for testing React Query hooks.

LANGUAGE: sh
CODE:
npm install @testing-library/react-hooks react-test-renderer --save-dev

----------------------------------------

TITLE: Starting Next.js Development Server
DESCRIPTION: Commands to start the Next.js development server using different package managers (npm, yarn, or pnpm). The server will run on localhost:3000 with hot-reload enabled.

LANGUAGE: bash
CODE:
npm run dev
# or
yarn dev
# or
pnpm dev

----------------------------------------

TITLE: Installing TanStack Angular Query with PNPM
DESCRIPTION: Command to install the experimental version of TanStack Angular Query using PNPM package manager. Requires Angular v16 or higher.

LANGUAGE: bash
CODE:
pnpm add @tanstack/angular-query-experimental

----------------------------------------

TITLE: Configuring Window Focus Refetching in Vue Query
DESCRIPTION: This snippet demonstrates how to configure the Vue Query plugin to disable automatic refetching of queries when the window regains focus. It sets the 'refetchOnWindowFocus' option to false in the default query options.

LANGUAGE: javascript
CODE:
const vueQueryPluginOptions: VueQueryPluginOptions = {
  queryClientConfig: {
    defaultOptions: {
      queries: {
        refetchOnWindowFocus: false,
      },
    },
  },
}
app.use(VueQueryPlugin, vueQueryPluginOptions)

----------------------------------------

TITLE: Starting Nuxt 3 Development Server
DESCRIPTION: Command to start the development server which runs on http://localhost:3000 for local development and testing.

LANGUAGE: bash
CODE:
yarn dev

----------------------------------------

TITLE: Using QueryCache.find Method in TanStack Query
DESCRIPTION: Demonstrates using the find method to retrieve an existing query instance from the cache by its query key.

LANGUAGE: tsx
CODE:
const query = queryCache.find(queryKey)

----------------------------------------

TITLE: Starting Svelte Development Server
DESCRIPTION: Commands to start the development server, with options to automatically open in a browser tab.

LANGUAGE: bash
CODE:
npm run dev

# or start the server and open the app in a new browser tab
npm run dev -- --open

----------------------------------------

TITLE: Implementing TanStack Solid Query via CDN
DESCRIPTION: HTML script tag implementation for loading TanStack Solid Query directly from ESM.sh CDN. Suitable for projects not using a module bundler.

LANGUAGE: html
CODE:
<script type="module">
  import { QueryClient } from 'https://esm.sh/@tanstack/solid-query'
</script>

----------------------------------------

TITLE: Invalidating Specific Queries with Variables in TanStack Query (TSX)
DESCRIPTION: Demonstrates how to invalidate queries with specific variables by passing a more detailed query key to the invalidateQueries method. This allows for more targeted invalidation of queries.

LANGUAGE: tsx
CODE:
queryClient.invalidateQueries({
  queryKey: ['todos', { type: 'done' }],
})

// The query below will be invalidated
const todoListQuery = useQuery({
  queryKey: ['todos', { type: 'done' }],
  queryFn: fetchTodoList,
})

// However, the following query below will NOT be invalidated
const todoListQuery = useQuery({
  queryKey: ['todos'],
  queryFn: fetchTodoList,
})

----------------------------------------

TITLE: Installing and Running TanStack Query Basic Example
DESCRIPTION: Commands for installing project dependencies using npm, yarn, or pnpm package managers and starting the development server.

LANGUAGE: bash
CODE:
npm install
npm run dev

LANGUAGE: bash
CODE:
yarn
yarn dev

LANGUAGE: bash
CODE:
pnpm i
pnpm dev

----------------------------------------

TITLE: Starting TanStack Query Angular Devtools Example
DESCRIPTION: This snippet demonstrates the command to start the TanStack Query Angular devtools panel example project using various package managers, including npm, yarn, pnpm, and bun.

LANGUAGE: markdown
CODE:
- `npm run start` or `yarn start` or `pnpm start` or `bun start`

----------------------------------------

TITLE: Generating Angular Components and Features
DESCRIPTION: Angular CLI commands for generating various application elements including components, directives, pipes, services, and other structures

LANGUAGE: bash
CODE:
ng generate component component-name

----------------------------------------

TITLE: Resetting Error Boundaries with QueryErrorResetBoundary in TanStack Query
DESCRIPTION: Demonstrates how to use the QueryErrorResetBoundary component to reset query errors within its boundaries. This is useful for both suspense and throwOnError queries.

LANGUAGE: tsx
CODE:
import { QueryErrorResetBoundary } from '@tanstack/react-query'
import { ErrorBoundary } from 'react-error-boundary'

const App = () => (
  <QueryErrorResetBoundary>
    {({ reset }) => (
      <ErrorBoundary
        onReset={reset}
        fallbackRender={({ resetErrorBoundary }) => (
          <div>
            There was an error!
            <Button onClick={() => resetErrorBoundary()}>Try again</Button>
          </div>
        )}
      >
        <Page />
      </ErrorBoundary>
    )}
  </QueryErrorResetBoundary>
)

----------------------------------------

TITLE: Creating New Svelte Project
DESCRIPTION: Commands for initializing a new Svelte project either in the current directory or in a specified folder using create-svelte CLI tool.

LANGUAGE: bash
CODE:
# create a new project in the current directory
npm create svelte@latest

# create a new project in my-app
npm create svelte@latest my-app

----------------------------------------

TITLE: Basic Paginated Query Implementation in TanStack Query
DESCRIPTION: Simple example showing how to implement basic pagination by including page information in the query key. This demonstrates the basic structure but may result in UI jumping between loading states.

LANGUAGE: tsx
CODE:
const result = useQuery({
  queryKey: ['projects', page],
  queryFn: fetchProjects,
})

----------------------------------------

TITLE: Building Svelte Production App
DESCRIPTION: Command for creating a production build of the Svelte application.

LANGUAGE: bash
CODE:
npm run build

----------------------------------------

TITLE: Building and Running TanStack Query Development Server
DESCRIPTION: This snippet demonstrates how to build all packages and run the development server for TanStack Query.

LANGUAGE: bash
CODE:
pnpm build:all

pnpm run watch

----------------------------------------

TITLE: Implementing Refetch on App Focus in React Native with TanStack Query
DESCRIPTION: This snippet shows how to implement refetching queries when the app comes back into focus in React Native. It uses the AppState module to detect when the app becomes active and updates the focus state in TanStack Query's focusManager.

LANGUAGE: tsx
CODE:
import { useEffect } from 'react'
import { AppState, Platform } from 'react-native'
import type { AppStateStatus } from 'react-native'
import { focusManager } from '@tanstack/react-query'

function onAppStateChange(status: AppStateStatus) {
  if (Platform.OS !== 'web') {
    focusManager.setFocused(status === 'active')
  }
}

useEffect(() => {
  const subscription = AppState.addEventListener('change', onAppStateChange)

  return () => subscription.remove()
}, [])

----------------------------------------

TITLE: Installing and Starting TanStack Query Expo Example
DESCRIPTION: Commands for installing required dependencies and starting the Expo application. Requires global installation of Expo CLI followed by package installation and project startup.

LANGUAGE: bash
CODE:
npm install --global expo-cli

LANGUAGE: bash
CODE:
pnpm install

LANGUAGE: bash
CODE:
pnpm start

----------------------------------------

TITLE: Starting SolidStart Development Server
DESCRIPTION: Commands for starting the development server, with options to automatically open the application in a new browser tab.

LANGUAGE: bash
CODE:
npm run dev

# or start the server and open the app in a new browser tab
npm run dev -- --open

----------------------------------------

TITLE: Installing and Running TanStack Query Angular Example
DESCRIPTION: Commands for installing dependencies and starting the example application using npm, yarn, pnpm, or bun package managers.

LANGUAGE: bash
CODE:
npm install
npm run start

# or

yarn
yarn start

# or

pnpm i
pnpm start

# or

bun i
bun start

----------------------------------------

TITLE: Configuring QueryClient Default Options
DESCRIPTION: Sets default configuration options for queries and mutations using the QueryClient constructor.

LANGUAGE: tsx
CODE:
const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      // query options
    },
    mutations: {
      // mutation options
    },
  },
})

----------------------------------------

TITLE: Installing and Running TanStack Query Example
DESCRIPTION: Basic npm commands to install dependencies and start the development server for a TanStack Query example project.

LANGUAGE: shell
CODE:
npm install
npm run dev

----------------------------------------

TITLE: Component-based Prefetching in TanStack Query
DESCRIPTION: Illustrates how to prefetch data within a component's lifecycle. This example shows an Article component that prefetches comments data alongside the article data to improve performance.

LANGUAGE: tsx
CODE:
function Article({ id }) {
  const { data: articleData, isPending } = useQuery({
    queryKey: ['article', id],
    queryFn: getArticleById,
  })

  // Prefetch
  useQuery({
    queryKey: ['article-comments', id],
    queryFn: getArticleCommentsById,
    // Optional optimization to avoid rerenders when this query changes:
    notifyOnChangeProps: [],
  })

  if (isPending) {
    return 'Loading article...'
  }

  return (
    <>
      <ArticleHeader articleData={articleData} />
      <ArticleBody articleData={articleData} />
      <Comments id={id} />
    </>
  )
}

function Comments({ id }) {
  const { data, isPending } = useQuery({
    queryKey: ['article-comments', id],
    queryFn: getArticleCommentsById,
  })

  ...
}

----------------------------------------

TITLE: Building Nuxt 3 for Production
DESCRIPTION: Command to create a production build of the Nuxt 3 application, optimizing and bundling all assets for deployment.

LANGUAGE: bash
CODE:
yarn build

----------------------------------------

TITLE: Installing and Running TanStack Query Angular Example
DESCRIPTION: Commands for installing dependencies and starting the example application using various package managers including npm, yarn, pnpm, and bun.

LANGUAGE: shell
CODE:
npm install
npm run start

# or

yarn
yarn start

# or

pnpm i
pnpm start

# or

bun i
bun start

----------------------------------------

TITLE: TanStack Query Retry Configuration
DESCRIPTION: Default retry configuration showing the number of retry attempts (3) before displaying an error. Uses exponential backoff for retry delays.

LANGUAGE: javascript
CODE:
retry: 3

----------------------------------------

TITLE: Installing and Running TanStack Query Example
DESCRIPTION: Basic npm commands to install dependencies and start the development server for a TanStack Query example project.

LANGUAGE: bash
CODE:
npm install
npm run dev

----------------------------------------

TITLE: Starting Svelte Development Server
DESCRIPTION: Commands to start the development server for a Svelte project, with an option to automatically open in a browser tab.

LANGUAGE: bash
CODE:
npm run dev

# or start the server and open the app in a new browser tab
npm run dev -- --open

----------------------------------------

TITLE: Installing Dependencies for TanStack Query Angular Example
DESCRIPTION: Commands for installing project dependencies using various package managers. This step is necessary before running the example.

LANGUAGE: markdown
CODE:
- `npm install` or `yarn` or `pnpm i` or `bun i`

----------------------------------------

TITLE: Conditional Initial Data from Cache in TSX
DESCRIPTION: Shows how to conditionally use cached data based on its freshness using queryClient.getQueryState.

LANGUAGE: tsx
CODE:
const result = useQuery({
  queryKey: ['todo', todoId],
  queryFn: () => fetch(`/todos/${todoId}`),
  initialData: () => {
    const state = queryClient.getQueryState(['todos'])
    if (state && Date.now() - state.dataUpdatedAt <= 10 * 1000) {
      return state.data.find((d) => d.id === todoId)
    }
  },
})

----------------------------------------

TITLE: Installing and Running TanStack Query Angular Example
DESCRIPTION: Commands for installing dependencies and starting the example project using different package managers including npm, yarn, pnpm, and bun.

LANGUAGE: bash
CODE:
npm install
# or
yarn
# or
pnpm i
# or
bun i

npm run start
# or
yarn start
# or
pnpm start
# or
bun start

----------------------------------------

TITLE: Initializing and Using TanStack Query with SolidJS
DESCRIPTION: This snippet demonstrates how to set up and use TanStack Query in a SolidJS application. It shows the creation of a QueryClient, wrapping the app with QueryClientProvider, and using createQuery to fetch and display data.

LANGUAGE: tsx
CODE:
import {
  QueryClient,
  QueryClientProvider,
  createQuery,
} from '@tanstack/solid-query'
import { Switch, Match, For } from 'solid-js'

const queryClient = new QueryClient()

function Example() {
  const query = createQuery(() => ({
    queryKey: ['todos'],
    queryFn: fetchTodos,
  }))

  return (
    <div>
      <Switch>
        <Match when={query.isPending}>
          <p>Loading...</p>
        </Match>
        <Match when={query.isError}>
          <p>Error: {query.error.message}</p>
        </Match>
        <Match when={query.isSuccess}>
          <For each={query.data}>{(todo) => <p>{todo.title}</p>}</For>
        </Match>
      </Switch>
    </div>
  )
}

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <Example />
    </QueryClientProvider>
  )
}

----------------------------------------

TITLE: Building Svelte Project for Production
DESCRIPTION: Command to create a production version of the Svelte app. It also mentions how to preview the production build.

LANGUAGE: bash
CODE:
npm run build

----------------------------------------

TITLE: Installing and Running TanStack Query Example
DESCRIPTION: Shell commands for setting up and running a TanStack Query example project in development mode. Requires Node.js and npm to be installed.

LANGUAGE: shell
CODE:
npm install
npm run dev

----------------------------------------

TITLE: Initializing QueryCache with Event Handlers in TanStack Query
DESCRIPTION: Creates a new QueryCache instance with error, success, and settled event handlers. Shows basic configuration and accessing cached queries.

LANGUAGE: tsx
CODE:
import { QueryCache } from '@tanstack/react-query'

const queryCache = new QueryCache({
  onError: (error) => {
    console.log(error)
  },
  onSuccess: (data) => {
    console.log(data)
  },
  onSettled: (data, error) => {
    console.log(data, error)
  },
})

const query = queryCache.find(['posts'])

----------------------------------------

TITLE: Installing Dependencies for TanStack Query Angular Example
DESCRIPTION: Commands for installing project dependencies using various package managers including npm, yarn, pnpm, and bun.

LANGUAGE: shell
CODE:
npm install
# or
yarn
# or
pnpm i
# or
bun i

----------------------------------------

TITLE: Starting TanStack Query Angular Pagination Example
DESCRIPTION: Commands to start the Angular application using different package managers. This will run the pagination example.

LANGUAGE: Shell
CODE:
npm run start

LANGUAGE: Shell
CODE:
yarn start

LANGUAGE: Shell
CODE:
pnpm start

LANGUAGE: Shell
CODE:
bun start

----------------------------------------

TITLE: Installing and Running TanStack Query Example
DESCRIPTION: Commands to install project dependencies and start the development server. Requires npm to be installed on the system.

LANGUAGE: bash
CODE:
npm install
npm run dev

----------------------------------------

TITLE: Fetching Query Data with QueryClient in TanStack Query
DESCRIPTION: Demonstrates how to use the fetchQuery method to asynchronously fetch and cache query data. It includes error handling and an example of setting a custom staleTime.

LANGUAGE: tsx
CODE:
try {
  const data = await queryClient.fetchQuery({ queryKey, queryFn })
} catch (error) {
  console.log(error)
}

try {
  const data = await queryClient.fetchQuery({
    queryKey,
    queryFn,
    staleTime: 10000,
  })
} catch (error) {
  console.log(error)
}

----------------------------------------

TITLE: Running Next.js Development Server
DESCRIPTION: Commands to start the Next.js development server using npm, yarn, or pnpm. This allows developers to run the project locally for development and testing.

LANGUAGE: bash
CODE:
npm run dev
# or
yarn dev
# or
pnpm dev

----------------------------------------

TITLE: Configuring Pagination Parameters in TanStack Query
DESCRIPTION: This snippet demonstrates how to configure next and previous page parameters for an infinite query using TanStack Query. It uses cursor-based pagination.

LANGUAGE: ts
CODE:
query = injectInfiniteQuery(() => ({
  queryKey: ['projects'],
  queryFn: fetchProjects,
  getNextPageParam: (lastPage, pages) => lastPage.nextCursor,
  getPreviousPageParam: (firstPage, pages) => firstPage.prevCursor,
}))

----------------------------------------

TITLE: Running Tanstack-Query Example in Development Mode
DESCRIPTION: Command to start the Tanstack-Query example project in development mode.

LANGUAGE: shell
CODE:
npm run dev

----------------------------------------

TITLE: Installing and Running TanStack Query Example
DESCRIPTION: Commands for installing dependencies and starting the development server for a TanStack Query example project

LANGUAGE: bash
CODE:
npm install
npm run dev

----------------------------------------

TITLE: Using Vue Query with Reactive Variables
DESCRIPTION: This snippet demonstrates how to use Vue Query with reactive variables. It shows how to pass dynamic options to the useQuery hook, including a reactive query key and enabled flag.

LANGUAGE: tsx
CODE:
const id = ref(1)
const enabled = ref(false)

const query = useQuery({
  queryKey: ['todos', id],
  queryFn: () => getTodos(id),
  enabled,
})

----------------------------------------

TITLE: Running Angular Unit Tests
DESCRIPTION: Command to execute unit tests using the Karma test runner

LANGUAGE: bash
CODE:
ng test

----------------------------------------

TITLE: Accessing Angular CLI Help
DESCRIPTION: Command to display Angular CLI help information and documentation

LANGUAGE: bash
CODE:
ng help

----------------------------------------

TITLE: Installing and Running TanStack Query Example
DESCRIPTION: Commands to install dependencies and start the development server for a TanStack Query example project. Uses npm for package management.

LANGUAGE: shell
CODE:
npm install

LANGUAGE: shell
CODE:
npm run dev

----------------------------------------

TITLE: Query Options Function Definition with Undefined Initial Data
DESCRIPTION: Function signature for queryOptions when used with undefined initial data. Includes generic type parameters for query function data, error type, result data type, and query key.

LANGUAGE: typescript
CODE:
function queryOptions<TQueryFnData, TError, TData, TQueryKey>(
  options,
): UndefinedInitialDataOptions<TQueryFnData, TError, TData, TQueryKey> & object

----------------------------------------

TITLE: Building Angular Application
DESCRIPTION: Command to create a production build of the Angular application, outputting to the dist directory

LANGUAGE: bash
CODE:
ng build

----------------------------------------

TITLE: Subscribing to Focus State Changes in TanStack Query
DESCRIPTION: Shows how to subscribe to focus state changes using the subscribe method. Returns an unsubscribe function for cleanup.

LANGUAGE: tsx
CODE:
import { focusManager } from '@tanstack/react-query'

const unsubscribe = focusManager.subscribe((isVisible) => {
  console.log('isVisible', isVisible)
})

----------------------------------------

TITLE: Installing Dependencies for TanStack Query Dependent Queries Example
DESCRIPTION: Commands for installing project dependencies using either npm or yarn package managers. This step is necessary before running the example.

LANGUAGE: Shell
CODE:
npm install

LANGUAGE: Shell
CODE:
yarn

----------------------------------------

TITLE: Type Inference with Custom Fetch Function in Solid Query
DESCRIPTION: Illustrates how to use a custom fetch function with a well-defined return type to ensure proper type inference. The query's data property is correctly typed as Group[] | undefined.

LANGUAGE: tsx
CODE:
const fetchGroups = (): Promise<Group[]> =>
  axios.get('/groups').then((response) => response.data)

const query = createQuery(() => ({
  queryKey: ['groups'],
  queryFn: fetchGroups,
}))

query.data
//    ^? (property) data: Group[] | undefined

----------------------------------------

TITLE: Starting Angular Development Server
DESCRIPTION: Command to start the local development server that serves the Angular application on port 4200 with hot reload capability

LANGUAGE: bash
CODE:
ng serve

----------------------------------------

TITLE: Starting Svelte Development Server
DESCRIPTION: Commands for starting the development server, with an option to automatically open the app in a new browser tab.

LANGUAGE: bash
CODE:
npm run dev

# or start the server and open the app in a new browser tab
npm run dev -- --open

----------------------------------------

TITLE: Installing @tanstack/svelte-query with Bun
DESCRIPTION: Command to install TanStack Query for Svelte using Bun package manager.

LANGUAGE: bash
CODE:
bun add @tanstack/svelte-query

----------------------------------------

TITLE: Clearing the MutationCache
DESCRIPTION: Demonstrates how to clear all mutations from the cache using the clear method. This removes all stored mutations and resets the cache state.

LANGUAGE: tsx
CODE:
mutationCache.clear()

----------------------------------------

TITLE: Starting Svelte Development Server
DESCRIPTION: Commands to start a development server for a Svelte project. It includes options to run the server and optionally open the app in a new browser tab.

LANGUAGE: bash
CODE:
npm run dev

# or start the server and open the app in a new browser tab
npm run dev -- --open

----------------------------------------

TITLE: Generating Dynamic Placeholder Data from Query Cache in TanStack Query
DESCRIPTION: This example demonstrates how to dynamically generate placeholder data using a function. It retrieves a smaller version of a blog post from an existing query cache to use as placeholder data for a more detailed blog post query.

LANGUAGE: tsx
CODE:
const result = useQuery({
  queryKey: ['blogPost', blogPostId],
  queryFn: () => fetch(`/blogPosts/${blogPostId}`),
  placeholderData: () => {
    // Use the smaller/preview version of the blogPost from the 'blogPosts'
    // query as the placeholder data for this blogPost query
    return queryClient
      .getQueryData(['blogPosts'])
      ?.find((d) => d.id === blogPostId)
  },
})

----------------------------------------

TITLE: Installing @tanstack/svelte-query with NPM
DESCRIPTION: Command to install TanStack Query for Svelte using NPM package manager.

LANGUAGE: bash
CODE:
npm i @tanstack/svelte-query

----------------------------------------

TITLE: Building Svelte Project for Production
DESCRIPTION: Command to create a production build of the Svelte application.

LANGUAGE: bash
CODE:
npm run build

----------------------------------------

TITLE: Cache-based Placeholder Data in TanStack Query
DESCRIPTION: Shows how to use cached data from one query as placeholder data for another query, specifically demonstrating blog post preview data usage.

LANGUAGE: tsx
CODE:
function Todo({ blogPostId }) {
  const queryClient = useQueryClient()
  const result = useQuery({
    queryKey: ['blogPost', blogPostId],
    queryFn: () => fetch(`/blogPosts/${blogPostId}`),
    placeholderData: () => {
      // Use the smaller/preview version of the blogPost from the 'blogPosts'
      // query as the placeholder data for this blogPost query
      return queryClient
        .getQueryData(['blogPosts'])
        ?.find((d) => d.id === blogPostId)
    },
  })
}

----------------------------------------

TITLE: Installing TanStack Query v4 Dependencies
DESCRIPTION: Commands to uninstall react-query and install the new @tanstack/react-query packages

LANGUAGE: bash
CODE:
npm uninstall react-query
npm install @tanstack/react-query
npm install @tanstack/react-query-devtools

----------------------------------------

TITLE: Scheduling Callbacks with notifyManager.schedule in TypeScript
DESCRIPTION: schedule schedules a function to be run on the next batch. By default, the batch is run with a setTimeout, but this can be configured.

LANGUAGE: typescript
CODE:
function schedule(callback: () => void): void

----------------------------------------

TITLE: Non-transformable TanStack Query Hook Usage
DESCRIPTION: Example of a query hook usage that cannot be transformed by the code mod because the first argument is an identifier (variable) rather than an object expression.

LANGUAGE: typescript
CODE:
const hookArgument = {
  queryKey: ['posts'],
  queryFn: queryFn,
  keepPreviousData: true,
}
const { data } = useQuery(hookArgument)

----------------------------------------

TITLE: Installing Dependencies for TanStack Query Development
DESCRIPTION: This snippet shows how to install the project dependencies using pnpm. It also includes commands for enabling corepack and preparing pnpm, as well as using the correct node version with nvm.

LANGUAGE: bash
CODE:
pnpm install

corepack enable && corepack prepare

nvm use

----------------------------------------

TITLE: Configuring Mutation Scopes in TanStack Query
DESCRIPTION: Shows how to use mutation scopes to control the execution order of multiple mutations with the same scope ID.

LANGUAGE: tsx
CODE:
const mutation = useMutation({
  mutationFn: addTodo,
  scope: {
    id: 'todo',
  },
})

----------------------------------------

TITLE: Basic Placeholder Data Implementation in TanStack Query
DESCRIPTION: Demonstrates the basic usage of placeholder data with useQuery hook. The query starts in success state with placeholder data while actual data is fetched in background.

LANGUAGE: tsx
CODE:
function Todos() {
  const result = useQuery({
    queryKey: ['todos'],
    queryFn: () => fetch('/todos'),
    placeholderData: placeholderTodos,
  })
}

----------------------------------------

TITLE: Configuring Mutation Retry in TanStack Query
DESCRIPTION: Shows how to configure the retry option for mutations to automatically retry failed mutations.

LANGUAGE: tsx
CODE:
const mutation = useMutation({
  mutationFn: addTodo,
  retry: 3,
})

----------------------------------------

TITLE: Defining useMutationState Function in TypeScript
DESCRIPTION: This function signature defines useMutationState, which takes optional MutationStateOptions and QueryClient parameters, and returns a Readable of an array of TResult. It's used to manage mutation state in Svelte applications using tanstack-query.

LANGUAGE: typescript
CODE:
function useMutationState<TResult>(options, queryClient?): Readable<TResult[]>

----------------------------------------

TITLE: Persisting and Resuming Mutations in TanStack Query
DESCRIPTION: Demonstrates how to persist mutations to storage and resume them later, including handling optimistic updates and error cases.

LANGUAGE: tsx
CODE:
const queryClient = new QueryClient()

// Define the "addTodo" mutation
queryClient.setMutationDefaults(['addTodo'], {
  mutationFn: addTodo,
  onMutate: async (variables) => {
    // Cancel current queries for the todos list
    await queryClient.cancelQueries({ queryKey: ['todos'] })

    // Create optimistic todo
    const optimisticTodo = { id: uuid(), title: variables.title }

    // Add optimistic todo to todos list
    queryClient.setQueryData(['todos'], (old) => [...old, optimisticTodo])

    // Return context with the optimistic todo
    return { optimisticTodo }
  },
  onSuccess: (result, variables, context) => {
    // Replace optimistic todo in the todos list with the result
    queryClient.setQueryData(['todos'], (old) =>
      old.map((todo) =>
        todo.id === context.optimisticTodo.id ? result : todo,
      ),
    )
  },
  onError: (error, variables, context) => {
    // Remove optimistic todo from the todos list
    queryClient.setQueryData(['todos'], (old) =>
      old.filter((todo) => todo.id !== context.optimisticTodo.id),
    )
  },
  retry: 3,
})

// Start mutation in some component:
const mutation = useMutation({ mutationKey: ['addTodo'] })
mutation.mutate({ title: 'title' })

// If the mutation has been paused because the device is for example offline,
// Then the paused mutation can be dehydrated when the application quits:
const state = dehydrate(queryClient)

// The mutation can then be hydrated again when the application is started:
hydrate(queryClient, state)

// Resume the paused mutations:
queryClient.resumePausedMutations()

----------------------------------------

TITLE: Initializing QueryClient in React Query v3
DESCRIPTION: Creates a new QueryClient instance which manages query caching and configuration.

LANGUAGE: tsx
CODE:
import { QueryClient } from 'react-query'

const queryClient = new QueryClient()

----------------------------------------

TITLE: Running JavaScript Codemod
DESCRIPTION: Command to run the codemod for .js/.jsx files to update imports

LANGUAGE: bash
CODE:
npx jscodeshift ./path/to/src/ \
  --extensions=js,jsx \
  --transform=./node_modules/@tanstack/react-query/codemods/v4/replace-import-specifier.js

----------------------------------------

TITLE: Embedding YouTube Video with React iframe
DESCRIPTION: React JSX code for embedding YouTube videos with responsive width and standard video permissions. Each iframe includes configuration for video playback features and responsive styling.

LANGUAGE: jsx
CODE:
<iframe
  width="280"
  height="400"
  title="React Query: It's Time to Break up with your Global State! ‚Äì Tanner Linsley"
  src="https://www.youtube.com/embed/seU46c6Jz7E"
  frameborder="0"
  allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture"
  allowfullscreen
  style={{
    width: '100%',
  }}
></iframe>

----------------------------------------

TITLE: Declaring filters Property in MutationStateOptions
DESCRIPTION: Declares an optional filters property of type MutationFilters within the MutationStateOptions type alias.

LANGUAGE: typescript
CODE:
optional filters: MutationFilters;